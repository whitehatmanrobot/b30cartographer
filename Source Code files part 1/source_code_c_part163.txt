  When you want to change font name,
    if include japanese string in select string
    then don't change only japanese string
    but change alpha string
*/

extern CHAR szAppName[];
extern struct SEL   selCur;
extern struct CHP   vchpFetch;
extern int          vcchFetch;
extern int          vccpFetch;
extern  CHAR        *vpchFetch;
extern typeCP       vcpFetch;
BOOL	FontChangeDBCS = FALSE; //01/21/93

static BOOL NEAR PASCAL KanjiCheckAddSprm(hwnd, alphaftc, fSetUndo)
HWND hwnd;
int  alphaftc;                    //Not KANJI_CHARSET
int  fSetUndo;
{
    typeCP CpLimNoSpaces(typeCP, typeCP);
    static BOOL NEAR KanjiCheckSelect();
    static BOOL NEAR PASCAL GetSelCur(typeCP *, typeCP *, typeCP);

    CHAR    rgb[2];
    struct  SEL selSave;
    typeCP  cpLim, cpFirst, dcp, cpSt, cpEnd;

    if (selCur.cpFirst == selCur.cpLim)
        return(FALSE);

    /* include japanese string ? */
    if( KanjiCheckSelect() ) {   // Yes
        char szMsg[cchMaxSz];
        PchFillPchId( szMsg, IDPMTNotKanjiFont, sizeof(szMsg) );
        MessageBox(hwnd, (LPSTR)szMsg, (LPSTR)szAppName,
                            MB_OK | MB_ICONEXCLAMATION);
    }
    else
        return(FALSE);

    selSave = selCur;

    cpLim = CpLimNoSpaces(selCur.cpFirst, selCur.cpLim);

    cpFirst = selCur.cpFirst;

    dcp = cpLim - cpFirst;

    if (fSetUndo) {
        SetUndo(uacReplNS, docCur, cpFirst, dcp, docNil, cpNil, dcp, 0);
        fSetUndo = FALSE;
    }

    cpEnd = cpFirst;

	FontChangeDBCS = TRUE;	//01/21/93

    while(TRUE) {
        cpSt = cpEnd;
        if( FALSE == GetSelCur(&cpSt, &cpEnd, cpLim))
            break;
        rgb[0] = sprmCFtc;
        rgb[1] = alphaftc;

        selCur.cpFirst = cpSt;
        selCur.cpLim = cpEnd;

        AddOneSprm(rgb, fSetUndo);

		if (ferror) //01/21/93
			break;
    }

	FontChangeDBCS = FALSE;	//01/21/93

	if(ferror) {            //01/21/93
	    vfSeeSel = TRUE;
		selCur.cpFirst = selCur.cpLim = cpSt;
	} else {
	    selCur = selSave;
	}

    return(TRUE);
}

static BOOL NEAR PASCAL GetSelCur(cpSt,cpEnd,cpLim)
typeCP  *cpSt, *cpEnd, cpLim;
{
    static BOOL NEAR PASCAL GetSelCurStart(typeCP *, typeCP);
    static void NEAR PASCAL GetSelCurEnd(typeCP *,typeCP *, typeCP);

    if(FALSE == GetSelCurStart(cpSt,cpLim))
        return(FALSE);

    GetSelCurEnd(cpSt,cpEnd,cpLim);

    return(TRUE);
}

static BOOL NEAR PASCAL GetSelCurStart(cpSt,cpLim)
typeCP *cpSt, cpLim;
{
    int cch;
    CHAR *cp;
    CHAR ch;
	BOOL DBCSbundan = FALSE; // 02/12/93 bug fix

    if(*cpSt == cpLim)
        return(FALSE);

    FetchCp(docCur, *cpSt, 0, fcmChars);

    while(TRUE) {
        for(cch = 0,cp = vpchFetch; cch < vccpFetch; cch++,cp++) {

            if((vcpFetch + (typeCP)cch) >= cpLim)
                return(FALSE);

            ch = *cp;

            if( FKana(ch))
                 ;
            else if( IsDBCSLeadByte(ch) ) {
                cp++; cch++;
				if(cch >= vccpFetch) {  // 02/12/93 bug fix
					DBCSbundan = TRUE;
					break;
				}
            } else if (isprint(ch)) {
                *cpSt = vcpFetch + (typeCP)cch;
                return(TRUE);
            }
        }

        if((vcpFetch + (typeCP)cch) >= cpLim)
            return(FALSE);

		if(DBCSbundan) {	// 02/12/93 bug fix
		    FetchCp(docCur, vcpFetch + (typeCP)(cch+1), 0, fcmChars);
			DBCSbundan = FALSE;
		} else
    	    FetchCp(docNil, cpNil, 0, fcmChars);
    }
}

static void NEAR PASCAL GetSelCurEnd(cpSt,cpEnd,cpLim)
typeCP *cpSt, *cpEnd, cpLim;
{
    int cch;
    CHAR *cp;
    CHAR ch;

    FetchCp(docCur, *cpSt, 0, fcmChars);

    while(TRUE) {
        for(cch = 0,cp = vpchFetch; cch < vccpFetch; cch++,cp++) {

            if((vcpFetch + (typeCP)cch) >= cpLim) {
                *cpEnd = cpLim;
                return;
            }

            ch = *cp;
            if( FKana(ch) || IsDBCSLeadByte(ch) ) {
                *cpEnd = vcpFetch + (typeCP)cch;
                return;
            }
        }

        if((vcpFetch + (typeCP)cch) >= cpLim) {
            *cpEnd = cpLim;
            return;
        }

        FetchCp(docNil, cpNil, 0, fcmChars);
    }
}

static BOOL NEAR KanjiCheckSelect()
{
    typeCP  CpLimNoSpaces(typeCP, typeCP);
    typeCP  cpLim;
    CHAR    *cp;
    CHAR    ch;
    int     cch;

    cpLim = CpLimNoSpaces(selCur.cpFirst, selCur.cpLim);
//    FetchCp(docCur, selCur.cpFirst, 0, fcmChars);
    FetchCp(docCur, selCur.cpFirst, 0,fcmBoth + fcmParseCaps);

    while(TRUE) {
        if(NATIVE_CHARSET == GetCharSetFromChp(&vchpFetch)) {
            for(cch = 0,cp = vpchFetch; cch < vccpFetch; cch++,cp++) {

                if((vcpFetch + (typeCP)cch) >= cpLim)
                    return(FALSE);

                ch = *cp;
                if( FKana(ch) || IsDBCSLeadByte(ch) ) {
                    return(TRUE);
                }
            }
        }

        if((vcpFetch + (typeCP)vccpFetch) >= cpLim)
            return(FALSE);

        FetchCp(docNil, cpNil, 0, fcmBoth + fcmParseCaps);
    }

}

int FAR PASCAL GetKanjiStringLen(cch, cchF, cp)
int     cch, cchF;
CHAR    *cp;
{
    int cblen = 0;

    for (; cch+cblen < cchF; cp++ ){
        if( FKana(*cp) )
            cblen++;
        else if( IsDBCSLeadByte(*cp) ) {
            cblen += 2;
            cp++;
        } else
            break;
    }
    return(cblen);
}

int FAR PASCAL GetAlphaStringLen(cch, cchF, cp)
int     cch, cchF;
CHAR    *cp;
{
    int cblen = 0;

    for (; cch+cblen < cchF; cp++ ) {
        if( FKana(*cp) || IsDBCSLeadByte(*cp))
            break;
        else
            cblen++;
    }
    return(cblen);
}
// 02/15/93 add T-HIROYN 2 function
int FAR PASCAL GetFtcFromPchp(pchp)
struct CHP *pchp;
{
	int ftc;
	ftc = pchp->ftc + (pchp->ftcXtra << 6);
	return ftc;
}

int FAR PASCAL SetFtcToPchp(pchp, ftc)
struct CHP *pchp;
int	ftc;
{
	pchp->ftc = ftc & 0x003f;
	pchp->ftcXtra = (ftc & 0x00c0) >> 6;
}


// added  02 Jun. 1992  by Hiraisi
/*
 *  This function deletes facename(s) with @-prefix
 * from FONT combobox(cmb1) of the CHOOSEFONT dialog.
*/
BOOL FAR PASCAL _export DeleteFacename( hDlg, uMsg, wParam, lParam )
HWND hDlg;
UINT uMsg;
WPARAM wParam;
LPARAM lParam;
{
    char str[50], sel[50];
    int ix;
    int cnt;

    if( uMsg != WM_INITDIALOG )
        return FALSE;

    cnt = (int)SendDlgItemMessage( hDlg, cmb1, CB_GETCOUNT, 0, 0L );
    ix = (int)SendDlgItemMessage( hDlg, cmb1, CB_GETCURSEL, 0, 0L );
    SendDlgItemMessage( hDlg, cmb1, CB_GETLBTEXT, ix, (DWORD)sel );
    for( ix = 0 ; ix < cnt ; ){
        SendDlgItemMessage( hDlg, cmb1, CB_GETLBTEXT, ix, (DWORD)str );
        if( str[0] == '@' )
            cnt = (int)SendDlgItemMessage( hDlg,cmb1,CB_DELETESTRING,ix,NULL );
        else
            ix++;
    }
    ix = (int)SendDlgItemMessage( hDlg, cmb1, CB_FINDSTRING, -1, (DWORD)sel );
    SendDlgItemMessage( hDlg, cmb1, CB_SETCURSEL, ix, 0L );

    return  TRUE;
}
#elif defined(KOREA)     // jinwoo : 10/14/92
// added  02 Jun. 1992  by Hiraisi
/*
 *  This function deletes facename(s) with @-prefix
 * from FONT combobox(cmb1) of the CHOOSEFONT dialog.
*/
BOOL FAR PASCAL _export DeleteFacename( hDlg, uMsg, wParam, lParam )
HWND hDlg;
UINT uMsg;
WPARAM wParam;
LPARAM lParam;
{
    char str[50], sel[50];
    int ix;
    int cnt;

    if( uMsg != WM_INITDIALOG )
        return FALSE;

    cnt = (int)SendDlgItemMessage( hDlg, cmb1, CB_GETCOUNT, 0, 0L );
    ix = (int)SendDlgItemMessage( hDlg, cmb1, CB_GETCURSEL, 0, 0L );
    SendDlgItemMessage( hDlg, cmb1, CB_GETLBTEXT, ix, (DWORD)sel );
    for( ix = 0 ; ix < cnt ; ){
        SendDlgItemMessage( hDlg, cmb1, CB_GETLBTEXT, ix, (DWORD)str );
        if( str[0] == '@' )
            cnt = (int)SendDlgItemMessage( hDlg,cmb1,CB_DELETESTRING,ix,NULL );
        else
            ix++;
    }
    ix = (int)SendDlgItemMessage( hDlg, cmb1, CB_FINDSTRING, -1, (DWORD)sel );
    SendDlgItemMessage( hDlg, cmb1, CB_SETCURSEL, ix, 0L );

    return  TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\fontutil.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* FontUtil.c -- font table management routines */

#define NOVIRTUALKEYCODES
#define NOCTLMGR
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "debug.h"
#include "wwdefs.h"
#include "dispdefs.h"
#include "editdefs.h"
#include "str.h"
#include "prmdefs.h"
#include "printdef.h"
#include "fontdefs.h"

extern struct DOD       (**hpdocdod)[];


struct FFNTB **HffntbAlloc()
/* returns empty ffntb */
{
struct FFNTB **hffntb;
int cwAlc;

cwAlc = CwFromCch(sizeof(struct FFNTB) - cffnMin * sizeof(struct FFN **));
if (!FNoHeap(hffntb = (struct FFNTB **)HAllocate(cwAlc)))
        {
        (*hffntb)->iffnMac = 0;
        (*hffntb)->fFontMenuValid = FALSE;
        }
return(hffntb);
}



FtcAddDocFfn(doc, pffn)
/* adds the described ffn to the ffntb for this doc - returns ftcNil if the
   allocation failed */

int doc;
struct FFN *pffn;
{
struct FFNTB **hffntb;

hffntb = HffntbGet(doc);
if (hffntb == 0)
        {
        hffntb = HffntbAlloc();
        if (FNoHeap(hffntb))
                return(ftcNil);
        (**hpdocdod)[doc].hffntb = hffntb;
        }

return(FtcAddFfn(hffntb, pffn));
}



int FtcAddFfn(hffntb, pffn)
/* adds the described ffn to hffntb.  returns ftcNil if it fails */
struct FFNTB **hffntb;
struct FFN *pffn;

{
unsigned cb;
int cwAlloc, iffnMac, ftc;
FFID ffid;
struct FFN **hffn;

(*hffntb)->fFontMenuValid = FALSE;  /* so fonts on char dropdown get updated */
ftc = ftcNil;
ffid = pffn->ffid;

cb = CchSz( pffn->szFfn );
if (cb > LF_FACESIZE)
    {
    Assert( FALSE );    /* If we get here, the doc's font tables are prob. bad */
    cb = LF_FACESIZE;
    }
Assert( cb > 0 );

cwAlloc = CwFromCch( CbFfn( cb ) );
if (!FNoHeap(hffn = (struct FFN **)HAllocate(cwAlloc)))
        {
        blt(pffn, *hffn, cwAlloc);
        (*hffn)->szFfn[ cb - 1 ] = '\0';   /* In case of font name too big */

        iffnMac = (*hffntb)->iffnMac + 1;
        cwAlloc = CwFromCch(sizeof(struct FFNTB) +
                        (iffnMac - cffnMin) * sizeof(struct FFN **));
        if (FChngSizeH(hffntb, cwAlloc, FALSE))
                {
                ftc = iffnMac - 1; /* ?! pault */
                (*hffntb)->mpftchffn[ftc] = hffn;
                (*hffntb)->iffnMac = iffnMac;
                }
        else
                {
                FreeH(hffn);
                }
        }

return(ftc);
}



FEnsurePffn(hffntb, pffn)
/* return TRUE if we were able to add the described font to the table - this
   routine is just a convenience, the other pieces aren't that complex to
   call. */

struct FFNTB **hffntb;
struct FFN *pffn;
{
if (FtcScanFfn(hffntb, pffn) != ftcNil ||
    FtcAddFfn(hffntb, pffn) != ftcNil)
        return(TRUE);
return(FALSE);
}



FtcScanDocFfn(doc, pffn)
/* looks for described font in docs ffntb - returns ftcNil if not found */

int doc;
struct FFN *pffn;
{
int ftc;
struct FFNTB **hffntb;

ftc = ftcNil;
hffntb = HffntbGet(doc);
if (hffntb != 0)
        ftc = FtcScanFfn(hffntb, pffn);

return(ftc);
}



FtcScanFfn(hffntb, pffn)
struct FFNTB **hffntb;
struct FFN *pffn;

{
int iffn, iffnMac;
struct FFN ***mpftchffn;

mpftchffn = (*hffntb)->mpftchffn;
iffnMac = (*hffntb)->iffnMac;
for (iffn = 0; iffn < iffnMac; iffn++)
        {
        if (WCompSz(pffn->szFfn, (*mpftchffn[iffn])->szFfn) == 0)
                {
                /* found it */
                if (pffn->ffid != FF_DONTCARE)
                {
                    /* maybe we discovered a family for this font? */
                    (*mpftchffn[iffn])->ffid = pffn->ffid;
                    (*mpftchffn[iffn])->chs  = pffn->chs;
                }
                return(iffn);
                }
        }
return(ftcNil);
}



FtcChkDocFfn(doc, pffn)
/* Adds described font to doc's ffntb if it's not already there - ftcNil is
   returned if it wasn't there and couldn't be added */

int doc;
struct FFN *pffn;
{
int ftc;

ftc = FtcScanDocFfn(doc, pffn);
if (ftc == ftcNil)
        ftc = FtcAddDocFfn(doc, pffn);

return(ftc);
}



FreeFfntb(hffntb)
struct FFNTB **hffntb;
{
int iffn, iffnMac;

if ((hffntb == 0) || FNoHeap(hffntb))
        /* nothing to do */
        return;

iffnMac = (*hffntb)->iffnMac;
for (iffn = 0; iffn < iffnMac; iffn++)
        FreeH((*hffntb)->mpftchffn[iffn]);
FreeH(hffntb);
}



SmashDocFce(doc)
/* the font table for this doc has scrambled, so we need to disassociate
   the corresponding cache entries from the doc */
int doc;

    {
    extern int vifceMac;
    extern union FCID vfcidScreen;
    extern union FCID vfcidPrint;
    extern struct FCE rgfce[ifceMax];
    int ifce;

    for (ifce = 0; ifce < vifceMac; ifce++)
        if (rgfce[ifce].fcidRequest.strFcid.doc == doc)
            rgfce[ifce].fcidRequest.strFcid.ftc = ftcNil;
    vfcidScreen.strFcid.ftc = ftcNil;
    vfcidPrint.strFcid.ftc = ftcNil;
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\format2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* format2.c -- MW formatting routines */
/* Less used subroutines */


#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOMENUS
#define NOKEYSTATE
#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "editdefs.h"
#include "cmddefs.h"
#include "fmtdefs.h"
#include "propdefs.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "ffdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "printdef.h"
#include "str.h"
#include "wwdefs.h"

extern struct FLI	vfli;
extern struct SEP	vsepAbs;
extern typeCP		vcpFirstSectCache;
extern typeCP		vcpFetch;
extern int		vcchFetch;
extern CHAR		*vpchFetch;
extern int		vpgn;
extern CHAR		stBuf[];
extern struct DOD	(**hpdocdod)[];
extern struct WWD	rgwwd[];
extern typeCP		cpMinDocument;


int CchExpPgn(pch, pgn, nfc, flm, cchMax)
CHAR *pch;
unsigned pgn, cchMax;
int nfc, flm;
{

#ifdef CASHMERE
static CHAR rgchUCRoman[] = "IVIIIXLXXXCDCCCMMM???";
static CHAR rgchLCRoman[] = "iviiixlxxxcdcccmmm???";
#define cchRgchDigit 5
#endif /* CASMERE */

if (flm & flmPrinting)
	{

#ifdef CASHMERE
	switch (nfc)
		{
		int cch, ich, chLetter;
	case nfcArabic:
		if (cchMax < cchMaxNum)
			return 0;
		return ncvtu(pgn, &pch);
	case nfcUCRoman:
		return CchStuffRoman(&pch, pgn, rgchUCRoman, cchMax);
	case nfcLCRoman:
		return CchStuffRoman(&pch, pgn, rgchLCRoman, cchMax);
	case nfcUCLetter:
	case nfcLCLetter:
		if ((cch = (pgn - 1) / 26 + 1) > cchMax)
			return 0;
		chLetter = (pgn - 1) % 26 + (nfc == nfcUCLetter ? 'A' : 'a');
		for (ich = 0; ich < cch; ich++)
			pch[ich] = chLetter;
		return cch;
		}
#else /* not CASHMERE */
	if (cchMax < cchMaxNum)
		return 0;
	return ncvtu(pgn, &pch);
	}
#endif /* not CASHMERE */

else
	{
	int cch;
	cch = CchChStuff(&pch, chLParen, cchMax);
	cch += CchStuffIdstr(&pch, IDSTRChPage, cchMax - cch);
	cch += CchChStuff(&pch, chRParen, cchMax - cch);
	return cch;
	}
}


/* C C H  S T U F F  I D S T R */
int CchStuffIdstr(ppch, idstr, cchMax)
CHAR **ppch;
IDSTR idstr;
int cchMax;
{
	int cch;
	CHAR st[cchMaxExpand]; /* note: we assume no individual idstr
				will have a length > cchMaxExpand */

	FillStId(st, idstr, sizeof(st));
	cch = max(0, min(cchMax, st[0]));
	bltbyte(&st[1], *ppch, cch);
	(*ppch) += cch;
	return cch;
}

/* C C H  C H  S T U F F */
int CchChStuff(ppch, ch, cchMax)
CHAR **ppch;
CHAR ch;
int cchMax;
{
	if(cchMax > 0)
		{
		**ppch = ch;
		(*ppch)++;
		return 1;
		}
	else
		return 0;
}


#ifdef CASHMERE
int CchStuffRoman(ppch, u, rgch, cchMax)
CHAR **ppch, *rgch;
unsigned u, cchMax;
    {
    static CHAR mpdgcch[10] =
	    { 0, 1, 2, 3, 2, 1, 2, 3, 4, 2 };
    static CHAR mpdgich[10] =
	    { 0, 0, 2, 2, 0, 1, 1, 1, 1, 4 };
    int cch, cchDone;

    cchDone = 0;
    if (u >= 10)
	    {
	    cchDone = CchStuffRoman(ppch, u / 10, rgch + cchRgchDigit, cchMax);
	    cchMax -= cchDone;
	    u %= 10;
	    }

    cch = mpdgcch[u];
    if (cch > cchMax || cch == 0)
	    return cchDone;
    bltbyte(&rgch[mpdgich[u]], *ppch, cch);
    *ppch += cch;
    return cch + cchDone;
    }
#endif /* CASHMERE */


int FFormatSpecials(pifi, flm, nfc)
struct IFI *pifi;
int flm;
int nfc;
{ /* A run of special characters was encountered; format it */
/* Return true unless wordwrap required */
int cch;
int cchPr;
int ich;
int dxp;
int dxpPr;
int sch;
CHAR *pchPr;

while (pifi->ichFetch < vcchFetch && pifi->xpPr <= pifi->xpPrRight)
	{

#ifdef CASHMERE
	switch (sch = vpchFetch[pifi->ichFetch++])
		{
	case schPage:
		cch = CchExpPgn(&vfli.rgch[pifi->ich], vpgn, nfc, flm,
		  ichMaxLine - pifi->ich);
		break;

	case schFootnote:
		cch = CchExpFtn(&vfli.rgch[pifi->ich], vcpFetch +
		  pifi->ichFetch - 1, flm, ichMaxLine - pifi->ich);
		break;

	default:
		cch = CchExpUnknown(&vfli.rgch[pifi->ich], flm, ichMaxLine -
		  pifi->ich);
		break;
		}
#else /* not CASHMERE */
	pchPr = &vfli.rgch[pifi->ich];
	if ((sch = vpchFetch[pifi->ichFetch]) == schPage &&
	  (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter || ((flm &
	  flmPrinting) && vcpFetch + (typeCP)pifi->ichFetch < cpMinDocument)))
	    {
	    cch = CchExpPgn(pchPr, vpgn, nfc, flm, ichMaxLine - pifi->ich);
	    if (flm & flmPrinting)
		{
		cchPr = cch;
		}
	    else
		{
		/* Assume that vsepAbs has been set up by FormatLine(). */
		cchPr = CchExpPgn(pchPr = &stBuf[0], vsepAbs.pgnStart == pgnNil
		  ? 1 : vsepAbs.pgnStart, nfc, flmPrinting, ichMaxLine -
		  pifi->ich);
		}
	    }
	else
	    {
	    cch = cchPr = CchExpUnknown(pchPr, flm, ichMaxLine - pifi->ich);
	    }
	pifi->ichFetch++;
#endif /* not CASHMERE */

	dxpPr = 0;
	for (ich = 0; ich < cchPr; ++ich, ++pchPr)
	    {
	    dxpPr += DxpFromCh(*pchPr, true);
	    }
	pifi->xpPr += dxpPr;
	if (flm & flmPrinting)
	    {
	    dxp = dxpPr;
	    }
	else
	    {
	    dxp = 0;
	    for (ich = pifi->ich; ich < pifi->ich + cch; ++ich)
		{
		dxp += DxpFromCh(vfli.rgch[ich], false);
		}
	    }
	vfli.rgch[pifi->ich] = sch;
	pifi->xp += (vfli.rgdxp[pifi->ich++] = dxp);

	if (pifi->xpPr > pifi->xpPrRight)
	    {
	    return (vcpFetch == vfli.cpMin);
	    }
	}

pifi->fPrevSpace = false;
return true;
}


int CchExpUnknown(pch, flm, cchMax)
CHAR *pch;
int flm, cchMax;
{
int cch;

#ifdef CASHMERE
cch = CchChStuff(&pch, chLParen, cchMax);
cch += CchChStuff(&pch, chQMark, cchMax - cch);
cch += CchChStuff(&pch, chRParen, cchMax - cch);
#else /* not CASHMERE */
cch = CchChStuff(&pch, chStar, cchMax);
#endif /* not CASHMERE */

return cch;
}


#ifdef CASHMERE
int CchExpFtn(pch, cp, flm, cchMax)
CHAR *pch;
typeCP cp;
int flm, cchMax;
{
int doc = vfli.doc;
if (cchMax < cchMaxNum)
	return 0;
if (cp >= CpMacText(doc))
	cp = CpRefFromFtn(doc, cp);
CacheSect(doc, cp);
return ncvtu(IfndFromCp(doc, cp) - IfndFromCp(doc, vcpFirstSectCache) + 1,
    &pch);
}
#endif /* CASHMERE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\heapdata.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#ifdef OURHEAP
/*
	heapData.h - include file for the share data of the heap modules.
*/

extern HH      *phhMac;      
extern int     *pHeapFirst;  
extern FGR     *rgfgr;      
extern FGR     *pfgrMac;    
extern FGR     *pfgrFree; 
extern HH      *phhFree; 
extern int     *pmemMax;
#ifdef DEBUG
extern int fStoreCheck, fNoShake;
#endif
		/* CONSTANTS */
#define bhh             (-1)        /* finds hunk given hh  */
#define cfgrBlock	10
#define ifgrInit        60          /* defines the initial number of finger
				       pointers. */
#define cwHunkMin       cwof(HH)    /* minimum number of words in a hunk */
				    /* including the header (1 word) */
#define cwReqMin	(cwHunkMin - 1) /* how small a request can be */

extern int     cwHeapMac;   
extern unsigned cbTot, cbTotQuotient, cwHeapFree;
#endif /* OURHEAP */
extern int     *memory; 


#define cwSaveAlloc     (128)   /* A buffer (vhrgbSave) of this size is */
				/* allocated off of */
				/* the heap in init.  It is freed during */
				/* the save operation so we have enough */
				/* heap space to complete the save */
				/* operation.  After the save is complete, */
				/* we try to reclaim this space so the next */
				/* save operation will have a fighting */
				/* chance to complete. */
#define cwHeapMinPerWindow  50  /* We expand the vhrgbSave buffer by this */
				/* amount every time we open a new window. */
				/* The theory is that for every additional */
				/* window, we can conceivable require an */
				/* additional save operation which may eat */
				/* up space.  A save operation may require */
				/* space for an fcb and new run table. */
				/* On the other hand, the save operation */
				/* reduces the size of the piece table and*/
				/* thus frees some space.  Whether this will*/
				/* free enough space for the save operation */
				/* is impossible to tell at the time we */
				/* open the window.*/


#define cwHeapSpaceMin  (60)    /* once heap space is below this amount,
				   the main loop will disable all menu
				   commands except save, saveas, and quit. */


#define ibpMaxSmall (30)  /* pages in rgbp if we were in a tight memory environment */
#define ibpMaxBig   (60)  /* pages in rgbp if we were in a bigger memory environment */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\form1.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*--- Module not really used, just the idea behind FORMAT.ASM ---*/


#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOCLIPBOARD
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#include <windows.h>
/* #include "wwsmall.h" */

#include "mw.h"
#include "cmddefs.h"
#include "fmtdefs.h"
#include "propdefs.h"
#include "ch.h"
#include "docdefs.h"
#include "ffdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "dispdefs.h"
#include "scrndefs.h"
#include "macro.h"
#include "debug.h"
#include "fontdefs.h"
#include "str.h"
#include "wwdefs.h"
#ifdef DBCS
#include "dbcs.h"
#endif

#ifdef DFLI
#define Dfli(x) x  /* Enable debug-format-line info */
#else
#define Dfli(x)
#endif

#ifdef CASHMERE
#define                 cchSmcapMax     16
#endif /* CASHMERE */

static int              ichpFormat;

#ifdef CASHMERE
static CHAR             mptlcch[] = " .-_";
#endif /* CASHMERE */

extern int              docHelp;
extern struct FLI       vfli;
extern struct CHP       (**vhgchpFormat)[];
extern int              ichpMacFormat;
extern struct CHP       vchpAbs;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern struct SEP       vsepPage;
extern struct CHP       vchpNormal;
extern struct DOD       (**hpdocdod)[];
extern typeCP           vcpLimSectCache;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern typeCP           vcpFetch;
extern int              vichFetch;
extern int              vccpFetch;
extern CHAR             *vpchFetch;
extern int              vcchFetch;
extern int              vftc;
extern int              ypSubSuper;
extern int              ypSubSuperPr;
extern HDC              vhMDC;
extern HDC              vhDCPrinter;
extern int              dxpLogInch;
extern int              dypLogInch;
extern int              dxaPrPage;
extern int              dyaPrPage;
extern int              dxpPrPage;
extern int              dypPrPage;
extern int              dypMax;
extern struct FMI       vfmiScreen, vfmiPrint;
extern int              vfOutOfMemory;
extern CHAR             vchDecimal;  /* "decimal point" character */
extern int              vzaTabDflt;  /* width of default tab */
#ifdef CASHMERE
extern int              vfVisiMode;
#endif /* CASHMERE */


/* F O R M A T  L I N E */
FormatLine(doc, cp, ichCp, cpMac, flm)
int doc;
typeCP cp;
int ichCp;
typeCP cpMac;
int flm;
    {
    /* Fills up vfli with a line of text */

    int near Justify(struct IFI *, unsigned, int);
    int near FGrowFormatHeap(void);
    int near FFirstIch(int);

    struct IFI ifi;
    struct TBD *ptbd;
    struct CHP chpLocal;
    int xpTab;

#ifdef CASHMERE
    int dypBefore;
#endif /* CASHMERE */

    int dypAscent;
    int dypDescent;
    int dypAscentMac;
    int dypDescentMac;
    unsigned xaLeft;
    unsigned xaRight;
    struct PAP *ppap;
    struct SEP *psep;
    int fFlmPrinting = flm & flmPrinting;
    int dxaFormat;
    int dyaFormat;
    int dxpFormat;
    int dypFormat;
    int ypSubSuperFormat;
    int fTruncated = false;     /* if the run was truncated */
    int ichpNRH;



#ifdef CASHMERE
    struct FNTB **hfntb;
    int fVisiMode;
#endif /* CASHMERE */

    /* Check for fli current */
    if (vfli.doc == doc && vfli.cpMin == cp && vfli.ichCpMin == ichCp &&
      vfli.flm == flm)
        {
        /* Just did this one */
        return;
        }

    Scribble(5, 'F');
    bltc(&vfli, 0, cwFLIBase);
    /* This means:
        vfli.fSplat = false;
        vfli.dcpDepend = 0;
        vfli.ichCpMac = 0;
        vfli.dypLine = 0;
        vfli.dypAfter = 0;
        vfli.dypFont = 0;
        vfli.dypBase = 0;
    */

    /* vfSplatNext = FALSE; No longer used. */

    /* Rest of format loads up cache with current data */
    vfli.doc = doc;
    vfli.cpMin = cp;
    vfli.ichCpMin = ichCp;
    vfli.flm = flm;

    if (cp > cpMac)
        {
        /* Space after the endmark.  Reset the cache because the footnotes come
        at the same cp in the footnote window */
        vfli.doc = docNil;
        vfli.cpMac = cp;
        vfli.rgdxp[0] = 0;

        /* Line after end mark is taller than screen */

#ifdef CASHMERE
        vfli.dypBase = vfli.dypFont = vfli.dypAfter = ((vfli.dypLine = dypMax)
          >> 1);
#else /* not CASHMERE */
        vfli.dypBase = vfli.dypFont = ((vfli.dypLine = dypMax) >> 1);
#endif /* not CASHMERE */

        Scribble(5, ' ');
        return;
        }

    /* Initialize run tables */
    ichpFormat = 0;

    /* Cache section and paragraph properties */

#ifdef CASHMERE
    hfntb = (**hpdocdod)[doc].hfntb;
    if (hfntb == 0 || cp < (**hfntb).rgfnd[0].cpFtn)
        {
        /* Normal text */
        CacheSect(doc, cp);
        }
    else
        {
        /* Footnote section properties come from the section of the footnote
        reference. */
        CacheSect(doc, CpRefFromFtn(doc, cp));
        }
#else /* not CASHMERE */
    CacheSect(doc, cp);
#endif /* not CASHMERE */

    psep = &vsepAbs;

    CachePara(doc, cp);
    ppap = &vpapAbs;

    /* Now we have:
        ppap    paragraph properties
        psep    division properties
    */

    if (ppap->fGraphics)
        {
        /* Format a picture paragraph in a special way (see picture.c) */
        FormatGraphics(doc, cp, ichCp, cpMac, flm);
        Scribble(5, ' ');
        return;
        }

    /* Assure we have a good memory DC for font stuff */
    ValidateMemoryDC();
    if (vhMDC == NULL || vhDCPrinter == NULL)
        {
        Scribble(5, ' ');
        return;
        }

#ifdef CASHMERE
    /* When printing, don't show visible characters */
    fVisiMode = vfVisiMode && !fFlmPrinting;
#endif /* CASHMERE */

    bltc(&ifi, 0, cwIFI);
    /* This means:
        ifi.ich = 0;
        ifi.ichPrev = 0;
        ifi.ichFetch = 0;
        ifi.cchSpace = 0;
        ifi.ichLeft = 0;
    */

    ifi.jc = jcTabLeft;
    ifi.fPrevSpace = true;

    /* Set up some variables that have different value depending on whether we
    are printing or not. */
    if (fFlmPrinting)
        {
        dxaFormat = dxaPrPage;
        dyaFormat = dyaPrPage;
        dxpFormat = dxpPrPage;
        dypFormat = dypPrPage;
        ypSubSuperFormat = ypSubSuperPr;
        }
    else
        {
        dxaFormat = dyaFormat = czaInch;
        dxpFormat = dxpLogInch;
        dypFormat = dypLogInch;
        ypSubSuperFormat = ypSubSuper;
        }

    /* Calculate line height and width measures.  Compute
        xaLeft          left indent 0 means at left margin
        xaRight         width of column measured from left margin (not from left
                        indent).
    */
    xaLeft = ppap->dxaLeft;

    /* If this is the first line of a paragraph, adjust xaLeft for the first
    line indent.  (Also, set dypBefore, since its handy.) */
    if (cp == vcpFirstParaCache)
        {
        xaLeft += ppap->dxaLeft1;

#ifdef CASHMERE
        dypBefore = MultDiv(ppap->dyaBefore, dypLogInch, czaInch);
#endif /* CASHMERE */

        }

#ifdef CASHMERE
    else
        {
        dypBefore = 0;
        }
#endif /* CASHMERE */

    /* Now, set xaRight (width measured in twips). */

#ifdef CASHMERE
    xaRight = (ppap->rhc ? vsepPage.xaMac - vsepPage.dxaGutter :
      psep->dxaText) - ppap->dxaRight;
#else /* not CASHMERE */
    xaRight = psep->dxaText - ppap->dxaRight;
#endif /* not CASHMERE */


    /* Do necessary checks on xaLeft and xaRight */
    if (xaRight > xaRightMax)
        {
        xaRight = xaRightMax;
        }
    if (xaLeft > xaRightMax)
        {
        xaLeft = xaRightMax;
        }
    if (xaLeft < 0)
        {
        xaLeft = 0;
        }
    if (xaRight < xaLeft)
        {
        xaRight = xaLeft + 1;
        }

    vfli.xpLeft = ifi.xp = ifi.xpLeft = MultDiv(xaLeft, dxpFormat, dxaFormat);
    vfli.xpMarg = ifi.xpRight = MultDiv(xaRight, dxpFormat, dxaFormat);
    ifi.xpPr = MultDiv(xaLeft, dxpPrPage, dxaPrPage);
    ifi.xpPrRight = MultDiv(xaRight, dxpPrPage, dxaPrPage);

    /* Get a pointer to the tab-stop table. */
    ptbd = ppap->rgtbd;

    /* Turn off justification. */
    SetTextJustification(fFlmPrinting ? vhDCPrinter : vhMDC, 0, 0);

    /* Initialize the line height information. */
    dypAscentMac = dypDescentMac = 0;

    /* To tell if there were any tabs */
    ifi.ichLeft = -1;

    /* Get the first run, and away we go... */
    FetchCp(doc, cp, ichCp, fcmBoth + fcmParseCaps);
    goto FirstCps;

    for ( ; ; )
        {
        int iichNew;
        int xpPrev;
        int dxp;
        int dxpPr;

        /* The number of characters to process (usually vcchFetch) */
        int cch;

        /* The number of characters in current run already used */
        int cchUsed;

        /* A pointer to the current list of characters (usually vpchFetch) */
        CHAR *pch;

#ifdef CASHMERE
        CHAR rgchSmcap[cchSmcapMax];
#endif /* CASHMERE */

        if (ifi.ichFetch == cch)
            {
            /* End of a run */
            int dich;
            BOOL fSizeChanged;

            if (ifi.ich >= ichMaxLine)
            /* End of run because of line length limit has been reached. */
                {
                goto DoBreak;
                }

            if (fTruncated)
                {
                cchUsed += cch;
                pch = vpchFetch + cchUsed;
                cch = vcchFetch - cchUsed;
                fTruncated = false;
                goto OldRun;    /* use the rest of the old run  */
                }

NullRun:
            FetchCp(docNil, cpNil, 0, fcmBoth + fcmParseCaps);
FirstCps:

            cchUsed = 0;

            /* Continue fetching runs until a run is found with a nonzero
            length. */
            if ((cch = vcchFetch) == 0)
                {
                goto NullRun;
                }

            pch = vpchFetch;
            if (vcpFetch >= cpMac || (!fFlmPrinting && *pch == chSect))
                {
#ifdef SYSENDMARK
                /* Force end mark and section mark to be in standard system
                font. */
                blt(&vchpNormal, &vchpAbs, cwCHP);
                vchpAbs.ftc = ftcSystem;
                vchpAbs.ftcXtra = 0;
                vchpAbs.hps = hpsDefault;
#else
#ifdef REVIEW
                /* The following comment is absolutely misleading!  Ftc==0
                   doesn't give you a system font.  It gives you the first
                   entry in the font table. */
#endif /* REVIEW */
                /* Force end mark and section mark to be in standard system
                font. */
                blt(&vchpNormal, &vchpAbs, cwCHP);
                vchpAbs.ftc = 0;
                vchpAbs.ftcXtra = 0;
                vchpAbs.hps = hpsDefault;
#endif /* if-else-def KANJI */
                }

#ifdef CASHMERE
            /* Adjust the size of the font for "small capitals". */
            if (vchpAbs.csm == csmSmallCaps)
                {
                vchpAbs.hps = HpsAlter(vchpAbs.hps, -1);
                }
#endif /* CASHMERE */

            /* Now we have:
                ichpFormat     index into gchp table
                vcpFetch        first cp of current run
                vfli.cpMin      first cp of line
                ifi.ich         ???
            */

           /* since LoadFont could change vchpAbs, and we don't want
              that to happen, we copy vchpAbs into vchpLocal and use
              vchpLocal in place of vchpAbs hereafter. Note that vchpAbs
              is intentionally used above for handling the endmark. */

                blt(&vchpAbs, &chpLocal, cwCHP);


            if (fFlmPrinting)
                {
                LoadFont(doc, &chpLocal, mdFontPrint);
                dypAscent = vfmiPrint.dypAscent + vfmiPrint.dypLeading;
                dypDescent = vfmiPrint.dypDescent;
                }
            else
                {
                LoadFont(doc, &chpLocal, mdFontJam);
                dypAscent = vfmiScreen.dypAscent + vfmiScreen.dypLeading;
                dypDescent = vfmiScreen.dypDescent;
                }

#ifdef ENABLE   /* BRYANL 8/27/87: New philosophy for handling
                   font selection failures is: font selection
                   ALWAYS succeeds. This prevents FormatLine
                   returns that do not advance. */
            /* Bail out if there is a memory failure. */
            if (vfOutOfMemory)
                {
                goto DoBreak;
                }
#endif  /* ENABLE */

            /* Floating line size algorithm */
            if (chpLocal.hpsPos != 0)
                {
                /* Modify font for subscript/superscript */
                if (chpLocal.hpsPos < hpsNegMin)
                    {
                    dypAscent += ypSubSuperFormat;
                    }
                else
                    {
                    dypDescent += ypSubSuperFormat;
                    }
                }

            /* Update the maximum ascent and descent of the line. */
            fSizeChanged = FALSE;
            if (dypDescentMac < dypDescent)
                {
                dypDescentMac = dypDescent;
                fSizeChanged = TRUE;
                }
            if (dypAscentMac < dypAscent)
                {
                dypAscentMac = dypAscent;
                fSizeChanged = TRUE;
                }


            if (fSizeChanged)
                {

#ifdef AUTO_SPACING
                /* This is the original Mac Word code that assumed line spacing
                of 0 in a PAP meant auto line spacing.  PC Word defaults to 1
                line invalidating this assumption. */
                if (ppap->dyaLine == 0)
                    {

#ifdef CASHMERE
                    ifi.dypLineSize = dypDescentMac + dypAscentMac + dypBefore;
#else /* not CASHMERE */
                    ifi.dypLineSize = dypDescentMac + dypAscentMac;
#endif /* not CASHMERE */

                    }
                else
                    {

#ifdef CASHMERE
                    ifi.dypLineSize = imax(MultDiv(ppap->dyaLine, dypFormat,
                      dyaFormat) + dypBefore, dypBefore + 1);
#else /* not CASHMERE */
                    ifi.dypLineSize = imax(MultDiv(ppap->dyaLine, dypFormat,
                      dyaFormat), 1);
#endif /* not CASHMERE */

                    }
#else /* not AUTO_SPACING */
                /* This code forces auto line spacing except in the case where
                the user specifies a line spacing greater than the auto line
                spacing. */
                    {
#ifdef CASHMERE
                    register int dypAuto = dypDescentMac + dypAscentMac +
                      dypBefore;
#else /* not CASHMERE */
                    register int dypAuto = dypDescentMac + dypAscentMac;
#endif /* not CASHMERE */

                    if (ppap->dyaLine > czaLine)
                        {

#ifdef CASHMERE
                        register int dypUser = imax(MultDiv(ppap->dyaLine,
                          dypFormat, dyaFormat) + dypBefore, dypBefore + 1);
#else /* not CASHMERE */
                        register int dypUser = imax(MultDiv(ppap->dyaLine,
                          dypFormat, dyaFormat), 1);
#endif /* not CASHMERE */

                        ifi.dypLineSize = max(dypAuto, dypUser);
                        }
                    else
                        {
                        ifi.dypLineSize = dypAuto;
                        }
                    }
#endif /* not AUTO_SPACING */

                }

OldRun:
            /* Calculate length of the run but no greater than 256 */
            iichNew = (int)(vcpFetch - vfli.cpMin);
            if (iichNew >= ichMaxLine)
                {
                iichNew = ichMaxLine - 1;
                }
            dich = iichNew - ifi.ich;

            /* Ensure that all tab and non-required hyphen characters start at
            beginning of run */
            if (ichpFormat <= 0  || dich > 0 || CchDiffer(&chpLocal,
              &(**vhgchpFormat)[ichpFormat - 1], cchCHPUsed) != 0 || *pch ==
              chTab || *pch == chNRHFile)
                {
#ifdef DFLI
                if (*pch == chNRHFile)
                    CommSz("CHNRHFILE at beginning of run");
#endif                
                if (ichpFormat != ichpMacFormat || FGrowFormatHeap())
                    {
                    register struct CHP *pchp = &(**vhgchpFormat)[ichpFormat -
                      1];

                    if (ichpFormat > 0)
                        {
                        pchp->cchRun = ifi.ich - ifi.ichPrev;
                        pchp->ichRun = ifi.ichPrev;
                        }
                    blt(&chpLocal, ++pchp, cwCHP);

#ifdef ENABLE   /* font codes */
                    pchp->ftc = vftc;
                    pchp->ftcXtra = (vftc & 0x01c0) >> 6;
                    pchp->hps = vhps;
#endif /* ENABLE */

                    pchp->cchRun = ichMaxLine;
                    if (dich <= 0)
                        {
                        pchp->ichRun = ifi.ich;
                        }
                    else
                        {
                        /* Q&D insert */
                        bltc(&vfli.rgdxp[ifi.ich], 0, dich);
                        bltbc(&vfli.rgch[ifi.ich], 0, dich);
                        pchp->ichRun = ifi.ich = iichNew;
                        }
                    ifi.ichPrev = ifi.ich;
                    ichpFormat++;
                    }
                }

            if (vcpFetch >= cpMac)
                {
                /* End of doc reached */
                if (!ifi.fPrevSpace || vcpFetch == cp)
                    {
                    vfli.ichReal = ifi.ich;
                    vfli.xpReal = ifi.xpReal = ifi.xp;
                    }
                if (!fFlmPrinting && (doc != docHelp))
                    {
                    vfli.rgch[ifi.ich] = chEMark;
                    vfli.xpReal += (vfli.rgdxp[ifi.ich++] = DxpFromCh(chEMark,
                      false));
                    }
                vfli.dypLine = ifi.dypLineSize;
                vfli.dypBase = dypDescentMac;
                vfli.dypFont = dypAscentMac + dypDescentMac;
                vfli.ichMac = vfli.ichReal = ifi.ich;
                vfli.cpMac = cpMac + 1;
                goto JustEol;   /* dcpDepend == 0 */
                }

            /* Here we have ifi.ich, cch */
            if (ifi.ich + cch > ichMaxLine)
            /* If this run would put the line over 255, truncate it and set a
            flag. */
                  {
                  cch = ichMaxLine - ifi.ich;
                  fTruncated = true;
                  }

            ifi.ichFetch = 0;

#ifdef CASHMERE
            if (chpLocal.csm != csmNormal)
                {
                int ich;
                CHAR *pchT = &rgchSmcap[0];

                /* We can handle only a run of cchSmcapMax small capital
                characters.  If the run is larger then truncate. */
                if (cch > cchSmcapMax)
                    {
                    cch = cchSmcapMax;
                    fTruncated = true;
                    }

                /* Raise the case of the characters. */
                for (ich = 0 ; ich < cch ; ich++)
                    {
                    *pchT++ = ChUpper(*pch++);
                    }
                pch = &rgchSmcap[0];
                }
#endif /* CASHMERE */

            /* Do "special" characters here */
            if (chpLocal.fSpecial)
                {
                if (!FFormatSpecials(&ifi, flm, vsepAbs.nfcPgn))
                    {
                    if (ifi.chBreak == 0)   /* No breaks in this line */
                        {
                        goto Unbroken;
                        }
                    else
                        {
                        vfli.dcpDepend = vcpFetch + ifi.ichFetch - vfli.cpMac;
                        goto JustBreak;
                        }
                    }
                }

            continue;
            }

        /* End of new run treatment.  We are back in the "for every character"
        section. */
            {
            register int ch = pch[ifi.ichFetch++];

NormChar:

            if (ch == chSpace)
                {
                /* Speed kludge for spaces */
                ifi.xp += (vfli.rgdxp[ifi.ich] = dxp =
                    fFlmPrinting ? vfmiPrint.dxpSpace : vfmiScreen.dxpSpace);
                ifi.xpPr += (dxpPr = vfmiPrint.dxpSpace);
                vfli.rgch[ifi.ich++] = chSpace;
#ifdef DFLI                
                {
                char rgch[100];
                
                wsprintf(rgch,"  chSpace     , xp==%d/%d, xpPr==%d/%d", 
                    ifi.xp, ifi.xpRight, ifi.xpPr, ifi.xpPrRight);
                CommSz(rgch);
                }
#endif
                goto BreakOppr;
                }

            /* If the printer width is not in the printer width table, then get
            it. */
            if (ch < chFmiMin || ch >= chFmiMax || (dxpPr =
              vfmiPrint.mpchdxp[ch]) == dxpNil)
                {
                dxpPr = DxpFromCh(ch, TRUE);
                }

            if (fFlmPrinting)
                {
                /* If we are printing, then there is no need to bother with the
                screen width. */
                dxp = dxpPr;
                }
            else if (ch < chFmiMin || ch >= chFmiMax ||
                (dxp = vfmiScreen.mpchdxp[ch]) == dxpNil)
                    dxp = DxpFromCh(ch, FALSE);

#ifdef DBCS
            if (IsDBCSLeadByte(ch))
                {
                ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
                ifi.xpPr += dxpPr;
                vfli.rgch[ifi.ich++] = ch;
                ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
                ifi.xpPr += dxpPr;
                vfli.rgch[ifi.ich++] = pch[ifi.ichFetch++];
                }
            else
                {
                ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
                ifi.xpPr += dxpPr;
                vfli.rgch[ifi.ich++] = ch;
                }
#else
            ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
            ifi.xpPr += dxpPr;
            vfli.rgch[ifi.ich++] = ch;
#endif

             /* special case "normal characters" above hyphen */

            if (ch > chHyphen)
                goto DefaultCh;

            switch (ch)
                {

#ifdef CRLF
                case chReturn:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;
                    continue;
#endif /* CRLF */

                case chNRHFile:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;

                    ichpNRH = ichpFormat - 1;
#ifdef DFLI
                    {
                    char rgch[100];
                    
                    wsprintf(rgch,"  OptHyph: width==%d, xpPr==%d/%d\n\r", 
                        DxpFromCh(chHyphen,true), ifi.xpPr,ifi.xpPrRight);
                    CommSz(rgch);
                    }
#endif
                    if (ifi.xpPr + DxpFromCh(chHyphen, true) > ifi.xpPrRight)
                        {
                        /* Won't fit, force a break */
                        goto DoBreak;
                        }

#ifdef CASHMERE
                    else if (fVisiMode)
                        {
                        /* Treat just like a normal hyphen */
                        ch = chHyphen;
                        goto NormChar;
                        }
#endif /* CASHMERE */

                    xpPrev = ifi.xp;
                    vfli.rgch[ifi.ich] = chTab;
                    goto Tab0;

                case chSect:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;

                    vfli.dypFont = vfli.dypLine = (dypAscentMac + (vfli.dypBase
                      = dypDescentMac));
                    vfli.cpMac = vcpFetch + ifi.ichFetch;
                    if (FFirstIch(ifi.ich))
                        {
                        /* Beginning of line; return a splat */
                        vfli.fSplat = true;

                        if (!fFlmPrinting)
                            {

#ifdef CASHMERE
                            int chT = vfli.cpMac == vcpLimSectCache ?
                              chSectSplat : chSplat;
#else /* not CASHMERE */
                            int chT = chSplat;
#endif /* not CASHMERE */

                            int dxpCh = DxpFromCh(chT, false);

                            /* Set the width of the splat to be about 8.5" */
                            int cch = min((dxpLogInch * 17 / 2) / dxpCh,
                              ichMaxLine - 32);

                            bltbc(&vfli.rgch[ifi.ich], chT, cch);
                            bltc(&vfli.rgdxp[ifi.ich], dxpCh, cch);
                            vfli.ichMac = cch + ifi.ich;
                            vfli.xpReal = LOWORD(GetTextExtent(vhMDC,
                              (LPSTR)vfli.rgch, cch));
                            vfli.xpLeft = 0;
                            }
                        else
                            {
                            vfli.ichMac = 0;
                            }
                        goto EndFormat;
                        }

                    /* The section character is in the middle of a line, the
                    line will terminate in front of the character. */
                    /* vfSplatNext = TRUE; No longer used*/
                    vfli.cpMac += cchUsed - 1;
                    vfli.dcpDepend = 1;
                    if (!ifi.fPrevSpace)
                        {
                        ifi.cBreak = ifi.cchSpace;
                        vfli.ichReal = ifi.ich;
                        vfli.xpReal = ifi.xpReal = ifi.xp;
                        }
                    vfli.ichMac = ifi.ich;
                    vfli.dypLine = ifi.dypLineSize;
                    goto JustBreak;

                case chTab:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;

                    if (ifi.xpPr < ifi.xpPrRight)
                        {
                        register struct CHP *pchp;
                        unsigned xaPr;
                        unsigned xaTab;

                        if (!ifi.fPrevSpace)
                            {
                            /* Remember number of spaces to left and number of
                            real chars in line for justification */
                            ifi.cBreak = ifi.cchSpace;
                            vfli.ichReal = ifi.ich;
                            ifi.xpReal =  ifi.xp;
                            }

                        if (ifi.jc != jcTabLeft)
                            {
                            Justify(&ifi, xpTab, flm);
                            }
                        xpPrev = ifi.xp;

                        /* Now get info about this tab */
                        xaPr = MultDiv(ifi.xpPr, dxaPrPage, dxpPrPage);
                        while ((xaTab = ptbd->dxa) != 0)
                            {
                            if (xaTab > xaRight)
                                {
                                /* Don't let tabs extend past right margin. */
                                xaTab = xaRight;
                                }

                            if (xaTab >= xaPr)
                                {
                                /* Use tab stop information */

#ifdef CASHMERE
                                ifi.tlc = ptbd->tlc;
#endif /* CASHMERE */

                                ifi.jc = jcTabMin + (ptbd++)->jc;

#ifdef ENABLE /* we do the mapping in HgtbdCreate */
                                if (ifi.jc != jcTabDecimal)
                                    {
                                    ifi.jc = jcTabLeft;
                                    }
#endif
                                goto TabFound;
                                }
                            ptbd++;
                            }

                        /* Out of set tabs; go to next nth column */
                        xaTab = (xaPr / (vzaTabDflt) + 1) * (vzaTabDflt);

#ifdef CASHMERE
                        ifi.tlc = tlcWhite;
#endif /* CASHMERE */

                        ifi.jc = jcTabLeft;

TabFound:
                        xpTab = imax(MultDiv(xaTab, dxpFormat, dxaFormat),
                          ifi.xp);

                        /* Do left-justified tabs immediately */
                        if (ifi.jc == jcTabLeft)
                            {
                            ifi.xp = xpTab;
                            ifi.xpPr = MultDiv(xaTab, dxpPrPage, dxaPrPage);
                            }
                        ifi.xpLeft = ifi.xp;
                        ifi.ichLeft = ifi.ich;
                        ifi.cchSpace = 0;
                        ifi.chBreak = 0;
Tab0:
                        ifi.fPrevSpace = false;
                        vfli.ichMac = ifi.ich;
                        vfli.xpReal = ifi.xp;
                        vfli.dypLine = ifi.dypLineSize;
                        vfli.dypBase = dypDescentMac;
                        vfli.dypFont = dypAscentMac + dypDescentMac;

                        if (ifi.ichFetch != 1 && (ichpFormat != ichpMacFormat
                          || FGrowFormatHeap()))
                            {
                            /* Probably in real trouble if FGrowFormatHeap fails
                            at this point */
                            pchp = &(**vhgchpFormat)[ichpFormat - 1];
                            if (ichpFormat > 0)
                                {
                                /* Finish off previous run */
                                pchp->ichRun = ifi.ichPrev;
                                pchp->cchRun = ifi.ich - ifi.ichPrev;
                                }

                            blt(&chpLocal, ++pchp, cwCHP);
                            ichpFormat++;
                            }
                        else
                            {
                            pchp = &(**vhgchpFormat)[ichpFormat - 1];
                            }
                        pchp->ichRun = ifi.ich;
                        pchp->cchRun = ichMaxLine;

#ifdef CASHMERE
                        pchp->chLeader = mptlcch[ifi.tlc];
#endif /* CASHMERE */

                        vfli.rgdxp[ifi.ichPrev = ifi.ich++] = ifi.xp - xpPrev;

                        if (ch != chTab)
                            {
                            /* This character is a non-required hyphen. */
                            Dfli(CommSz("ch is really OptHyph "));
                            goto BreakOppr;
                            }

                        continue;
                        }
                    else
                        {
                        ch = chNBSFile;
                        goto NormChar;
                        }

                case chHyphen:
                    if (ifi.xpPr > ifi.xpPrRight)
                        {
                        goto DoBreak;
                        }

BreakOppr:
                Dfli(CommSz(" BKOPPR\n\r"));
                /*    this case never used in switch - always goto here */
                /* case chSpace:  */
                    if (ifi.ich >= ichMaxLine)
                        {
                        Dfli(CommSzNum("  Unbroken, ich>ichMaxLine\n\r"));
                        goto Unbroken;
                        }

                case chEol:
                case chNewLine:
                    ifi.chBreak = ch;
                    vfli.cpMac = vcpFetch + cchUsed + ifi.ichFetch;
                    vfli.xpReal = ifi.xp;
                    vfli.ichMac = ifi.ich;
                    vfli.dypLine = ifi.dypLineSize;
                    vfli.dypFont = dypAscentMac + (vfli.dypBase =
                      dypDescentMac);
                    Dfli(CommSzNumNum("    vfli.xpReal, ichMac ",vfli.xpReal,vfli.ichMac));


                    if (ch == chHyphen || ch == chNRHFile)
                        {
                        Dfli(CommSz("    chHyph/OptHyph catch \n\r"));
                        ifi.cBreak = ifi.cchSpace;
                        vfli.ichReal = ifi.ich;
                        vfli.xpReal = ifi.xpReal = ifi.xp;
                        }
                    else
                        {
                        if (!ifi.fPrevSpace)
                            {
                            Dfli(CommSz("!fPrevSpace \n\r"));
                            ifi.cBreak = ifi.cchSpace;
                            vfli.ichReal = ifi.ich - 1;
                            ifi.xpReal = (vfli.xpReal = ifi.xp) - dxp;
                            }
                        if (ch == chEol || ch == chNewLine)
                            {

#ifdef CASHMERE
                            if (hfntb != 0 && vfli.cpMac ==
                              (**hfntb).rgfnd[0].cpFtn)
                                {
                                /* End of footnote */
                                if (!fFlmPrinting)
                                    {
                                    vfli.rgch[ifi.ich - 1] = chEMark;
                                    vfli.xpReal += (vfli.rgdxp[ifi.ich - 1] =
                                      DxpFromCh(chEMark, false)) - dxp;
                                    vfli.ichReal++;     /* show this guy */
                                    }
                                }
                            else
#endif /* CASHMERE */
                                {

#ifdef CASHMERE
                                int chT = fVisiMode ? ChVisible(ch) : chSpace;
#else /* not CASHMERE */
                                int chT = chSpace;
#endif /* not CASHMERE */

                                int dxpNew = DxpFromCh(chT, fFlmPrinting);

                                vfli.rgch[ifi.ich - 1] = chT;
                                vfli.rgdxp[ifi.ich - 1] = dxpNew;

                                vfli.xpReal += (vfli.rgdxp[ifi.ich - 1] =
                                    dxpNew) - dxp;


                                if (!ifi.fPrevSpace)
                                    {
                                    vfli.xpReal += dxpNew - dxp;
#ifdef CASHMERE
                                    vfli.ichReal =
                                         fVisiMode ? ifi.ich : ifi.ich - 1;
#else /* not CASHMERE */
                                    vfli.ichReal = ifi.ich - 1;
#endif /* not CASHMERE */
                                    }
                                }


                            if (ch == chEol)
                                {
JustEol:
                                if (fFlmPrinting)
                                    {
                                    vfli.ichMac = vfli.ichReal;
                                    }
                                if (ifi.jc != jcTabLeft)
                                    {
                                    /* Handle last tab's text */
                                    Justify(&ifi, xpTab, flm);
                                    }
                                else if ((ifi.jc = ppap->jc) != jcBoth &&
                                  ifi.jc != jcLeft)
                                    {
                                    /* Do line justification */
                                    Justify(&ifi, ifi.xpRight, flm);
                                    }
                                vfli.xpRight = ifi.xpRight;
                                goto EndFormat;
                                }
                            else
                                {
                                /* Handle a line break */
                                goto JustBreak;
                                }
                            }
                        ++ifi.cchSpace;
                        ifi.fPrevSpace = true;
                        }
                    break;

DefaultCh:

                default:

#ifdef DFLI                    
                    {
                    char rgch[100];
                    wsprintf(rgch,"  DefaultCh: %c, xp==%d/%d, xpPr==%d/%d\n\r", 
                        ch, ifi.xp, ifi.xpRight, ifi.xpPr, ifi.xpPrRight);
                    CommSz(rgch);
                    }
#endif /* ifdef DFLI */
                    
                    if (ifi.xpPr > ifi.xpPrRight)
DoBreak:
                        {
                        Dfli(CommSz("    BREAK!\n\r"));
                        if (ifi.chBreak == 0)
Unbroken:
                            {
                            /* Admit first character to the line, even if margin
                            is crossed.  First character at ifi.ich - 1 may be
                            preceded by 0 width characters. */
#ifdef DBCS
                            if (IsDBCSLeadByte(ch))
                                {
                                if (FFirstIch(ifi.ich-2) && ifi.ich<ichMaxLine)
                                    goto PChar;
                                vfli.cpMac = vcpFetch+cchUsed+ifi.ichFetch-2;
                                vfli.ichReal = vfli.ichMac = ifi.ich - 2;
                                vfli.dypLine = ifi.dypLineSize;
                                vfli.dypFont = dypAscentMac + (vfli.dypBase =
                                  dypDescentMac);
                                vfli.dcpDepend = 1;
                                vfli.xpReal = ifi.xpReal = ifi.xp - (dxp * 2);
                                }
                            else
                                {
                                if (FFirstIch(ifi.ich-1) && ifi.ich<ichMaxLine)
                                    goto PChar;
                                vfli.cpMac = vcpFetch+cchUsed+ifi.ichFetch-1;
                                vfli.ichReal = vfli.ichMac = ifi.ich - 1;
                                vfli.dypLine = ifi.dypLineSize;
                                vfli.dypFont = dypAscentMac + (vfli.dypBase =
                                  dypDescentMac);
                                vfli.dcpDepend = 1;
                                vfli.xpReal = ifi.xpReal = ifi.xp - dxp;
                                }
#else
                            if (FFirstIch(ifi.ich - 1) && ifi.ich < ichMaxLine)
                                {
                                goto PChar;
                                }
                            vfli.cpMac = vcpFetch + cchUsed + ifi.ichFetch - 1;
                            vfli.ichReal = vfli.ichMac = ifi.ich - 1;
                            vfli.dypLine = ifi.dypLineSize;
                            vfli.dypFont = dypAscentMac + (vfli.dypBase =
                              dypDescentMac);
                            vfli.dcpDepend = 1;
                            vfli.xpReal = ifi.xpReal = ifi.xp - dxp;
#endif
                            goto DoJustify;
                            }

                        vfli.dcpDepend = vcpFetch + ifi.ichFetch - vfli.cpMac;
JustBreak:
                        if (ifi.chBreak == chNRHFile)
                            {
                            /* Append a non-required hyphen to the end of the
                            line. (Replace zero length tab previously
                            inserted)  */

                            Dfli(CommSz("    Breaking line at OptHyphen\n\r"));
                            ifi.xpReal += (vfli.rgdxp[vfli.ichReal - 1] =
                              DxpFromCh(chHyphen, fFlmPrinting));
                            vfli.xpRight = vfli.xpReal = ifi.xpReal;
                            vfli.rgch[vfli.ichReal - 1] = chHyphen;
                            vfli.ichMac = vfli.ichReal;
                            if (ichpNRH < ichpFormat - 1)
                                {
                                register struct CHP *pchp =
                                  &(**vhgchpFormat)[ichpNRH];

                                pchp->cchRun++;
                                if (pchp->ichRun >= vfli.ichMac)
                                    {
                                    pchp->ichRun = vfli.ichMac - 1;
                                    }
                                }
                            }

                        if (fFlmPrinting)
                            {
                            vfli.ichMac = vfli.ichReal;
                            }
                        if (ifi.jc != jcTabLeft)
                            {
                            Justify(&ifi, xpTab, flm);
                            }
                        else
                            {
DoJustify:
                            if ((ifi.jc = ppap->jc) != jcLeft)
                                {
                                Dfli(CommSzNum("    DoJustify: xpRight ",ifi.xpRight));
                                Justify(&ifi, ifi.xpRight, flm);
                                }
                            }
                        vfli.xpRight = ifi.xpRight;
EndFormat:
                        vfli.ichLastTab = ifi.ichLeft;

#ifdef CASHMERE
                        if (vfli.cpMac == vcpLimParaCache)
                            {
                            vfli.dypAfter = vpapAbs.dyaAfter / DyaPerPixFormat;
                            vfli.dypLine += vfli.dypAfter;
                            vfli.dypBase += vfli.dypAfter;
                            }
#endif /* CASHMERE */

                        Scribble(5, ' ');
                        return;
                        }
                    else
                        {
PChar:
                        /* A printing character */
                        ifi.fPrevSpace = false;
                        }
                    break;

                }       /* Switch */
            }
        }       /* for ( ; ; ) */

    Scribble(5, ' ');
    }


/* J U S T I F Y */
near Justify(pifi, xpTab, flm)
struct IFI *pifi;
unsigned xpTab;
int flm;
    {
    int dxp;
    int ichT;
    int xpLeft;


    xpLeft = pifi->xpLeft;
    switch (pifi->jc)
        {
        CHAR *pch;
        unsigned *pdxp;

#ifdef CASHMERE
        case jcTabLeft:
        case jcLeft:
            return;

        case jcTabRight:
            dxp = xpTab - pifi->xpReal;
            break;

        case jcTabCenter:
            dxp = (xpTab - xpLeft) - ((pifi->xpReal - xpLeft + 1) >> 1);
            break;
#endif /* CASHMERE */

        case jcTabDecimal:
            dxp = xpTab - xpLeft;
            for (ichT = pifi->ichLeft + 1; ichT < vfli.ichReal &&
              vfli.rgch[ichT] != vchDecimal; ichT++)
                {
                dxp -= vfli.rgdxp[ichT];
                }
            break;

        case jcCenter:
            if ((dxp = xpTab - pifi->xpReal) <= 0)
                {
                return;
                }
            dxp = dxp >> 1;
            break;

        case jcRight:
            dxp = xpTab - pifi->xpReal;
            break;

        case jcBoth:
            if (pifi->cBreak == 0)
                {
                /* Ragged edge forced */
                return;
                }

            if ((dxp = xpTab - pifi->xpReal) <= 0)
                {
                /* There is nothing to do. */
                return;
                }

            pifi->xp += dxp;
            vfli.xpReal += dxp;
            vfli.dxpExtra = dxp / pifi->cBreak;

            /* Rounding becomes a non-existant issue due to brilliant
            re-thinking.
                "What a piece of work is man
                How noble in reason
                In form and movement,
                how abject and admirable..."

                        Bill "Shake" Spear [describing Sand Word] */
                {
                register CHAR *pch = &vfli.rgch[vfli.ichReal];
                register int *pdxp = &vfli.rgdxp[vfli.ichReal];
                int dxpT = dxp;
                int cBreak = pifi->cBreak;
                int cxpQuotient = (dxpT / cBreak) + 1;
                int cWideSpaces = dxpT % cBreak;

                vfli.fAdjSpace = fTrue;

                for ( ; ; )
                    {
                    /* Widen blanks */
                    --pch;
                    --pdxp;
                    if (*pch == chSpace)
                        {
                        if (cWideSpaces-- == 0)
                            {
                            int *pdxpT = pdxp + 1;

                            while (*pdxpT == 0)
                                {
                                pdxpT++;
                                }
                            vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                            cxpQuotient--;
                            }
                        *pdxp += cxpQuotient;
                        if ((dxpT -= cxpQuotient) <= 0)
                            {
                            if (pifi->cBreak > 1)
                                {
                                int *pdxpT = pdxp + 1;

                                while (*pdxpT == 0)
                                    {
                                    pdxpT++;
                                    }
                                vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                                }
                            return;
                            }
                        pifi->cBreak--;
                        }
                    }
                }
        }       /* Switch */

    if (dxp <= 0)
        {
        /* Nothing to do */
        return;
        }

    pifi->xp += dxp;

    if (flm & flmPrinting)
        {
        pifi->xpPr += dxp;
        }
    else
        {
        /* This statememt might introduce rounding errors in pifi->xpPr, but
        with luck, they will be small. */
        pifi->xpPr += MultDiv(MultDiv(dxp, czaInch, dxpLogInch), dxpPrPage,
          dxaPrPage);
        }

    if (pifi->ichLeft < 0)
        {
        /* Normal justification */
        vfli.xpLeft += dxp;
        }
    else
        {
        /* Tab justification */
        vfli.rgdxp[pifi->ichLeft] += dxp;
        }
    vfli.xpReal += dxp;
    }


/* F  G R O W  F O R M A T  H E A P */
int near FGrowFormatHeap()
    {
    /* Grow vhgchpFormat by 20% */
    int cchpIncr = ichpMacFormat / 5 + 1;

#ifdef WINHEAP
    if (!LocalReAlloc((HANDLE)vhgchpFormat, (ichpMacFormat + cchpIncr) * cchCHP,
      NONZEROLHND))
#else /* not WINHEAP */
    if (!FChngSizeH(vhgchpFormat, (ichpMacFormat + cchpIncr) * cwCHP, false))
#endif /* not WINHEAP */

        {
        /* Sorry, charlie */
        return false;
        }
    ichpMacFormat += cchpIncr;
    return true;
    }


/* #define DBEMG */
/* D X P  F R O M  C H */
#ifdef DBCS
/* DxpFromCh() assumes that ch passed is the first byte of a DBCS character
   if it is a part of such character. */
#endif
int DxpFromCh(ch, fPrinter)
int ch;
int fPrinter;
    {
    int               *pdxp; // changed to int (7.23.91) v-dougk
    int               dxpDummy; // changed to int (7.23.91) v-dougk

    extern int        dxpLogCh;
    extern struct FCE *vpfceScreen;

    /* If the width is not in the width table, then get it. */
    if (ch < chFmiMin)
        {
        switch (ch)
            {
        case chTab:
        case chEol:
        case chReturn:
        case chSect:
        case chNewLine:
        case chNRHFile:
            /* the width for these characters aren't really important */
	    pdxp = (CHAR *)(fPrinter ? &vfmiPrint.dxpSpace : &vfmiScreen.dxpSpace);
            break;
        default:
            pdxp = &dxpDummy;
            *pdxp = dxpNil;
            break;
            }
        }
    else if (ch >= chFmiMax)
        {
        /* outside the range we hold in our table - kludge it */
        pdxp = &dxpDummy;
        *pdxp = dxpNil;
        }
    else
        {
        /* inside our table */
        pdxp = (fPrinter ? vfmiPrint.mpchdxp : vfmiScreen.mpchdxp) + ch;
        }

#ifdef DBCS
    if (*pdxp == dxpNil && IsDBCSLeadByte(ch) )
        {
        int dxp;
#else
    if (*pdxp == dxpNil)
        {
        int dxp;
#endif

#ifdef DBCS
        struct FMI *pfmi;
        int        rgchT[cchDBCS]; // changed to int (7.23.91) v-dougk
        int        dxpT;
        int        dxpDBCS;

        pfmi = fPrinter ? (&vfmiPrint) : (&vfmiScreen);
        Assert(pfmi->bDummy == dxpNil);
        if (pfmi->dxpDBCS == dxpNil)
            {
            /* Get the width from GDI. */
            rgchT[0] = rgchT[1] = ch;
            dxpDBCS = (fPrinter ?
                            LOWORD(GetTextExtent(vhDCPrinter,
                                                 (LPSTR) rgchT, cchDBCS)) :
                            LOWORD(GetTextExtent(vhMDC,
                                                 (LPSTR) rgchT, cchDBCS)));
            /* Store in fmi, if it fits. */
            if (0 <= dxpDBCS && dxpDBCS < dxpNil)
                pfmi->dxpDBCS = (BYTE) dxpDBCS;
            return (dxpDBCS - pfmi->dxpOverhang);
            }
        else
            return (pfmi->dxpDBCS - pfmi->dxpOverhang);
        }
    else {
        int dxp;
#endif /* DBCS */
        /* get width from GDI */
        dxp = fPrinter ? LOWORD(GetTextExtent(vhDCPrinter, (LPSTR)&ch, 1)) -
          vfmiPrint.dxpOverhang : LOWORD(GetTextExtent(vhMDC, (LPSTR)&ch, 1)) -
          vfmiScreen.dxpOverhang;
#ifdef DBEMG
            CommSzNum("Get this.... ", dxp);
#endif
        //(7.24.91) v-dougk if (dxp >= 0 && dxp < dxpNil)
            {
            /* only store dxp's that fit in a byte */
            *pdxp = dxp;
            }

#ifdef DBEMG
        {
        char szT[10];
        CommSzSz("fPrinter:  ", (fPrinter ? "Printer" : "Screen"));
        if (ch == 0x0D) {
            szT[0] = 'C'; szT[1] = 'R'; szT[2] = '\0';
            }
        else if (ch == 0x0A) {
            szT[0] = 'L'; szT[1] = 'F'; szT[2] = '\0';
            }
        else if (32 <= ch && ch <= 126) {
            szT[0] = ch; szT[1] ='\0';
            }
        else if (FKanji1(ch)) {
            szT[0] = 'K'; szT[1] = 'A'; szT[2] = 'N'; szT[3] = 'J';
            szT[4] = 'I'; szT[5] = '\0';
            }
        else {
            szT[0] = szT[1] = szT[2] = '-'; szT[3] = '\0';
            }
        CommSzSz("Character: ", szT);
        CommSzNum("Dxp:      ", (int) dxp);
        CommSzNum("OverHang: ", (int) (fPrinter ? vfmiPrint.dxpOverhang : vfmiScreen.dxpOverhang));
        }
#endif
        return(dxp);
        }

#ifdef DBEMG
    {
    char szT[10];
    CommSzSz("fPrinter:  ", (fPrinter ? "Printer" : "Screen"));
    if (ch == 0x0D) {
        szT[0] = 'C'; szT[1] = 'R'; szT[2] = '\0';
        }
    else if (ch == 0x0A) {
        szT[0] = 'L'; szT[1] = 'F'; szT[2] = '\0';
        }
    else if (32 <= ch && ch <= 126) {
        szT[0] = ch; szT[1] ='\0';
        }
    else if (FKanji1(ch)) {
        szT[0] = 'K'; szT[1] = 'A'; szT[2] = 'N'; szT[3] = 'J';
        szT[4] = 'I'; szT[5] = '\0';
        }
    else {
        szT[0] = szT[1] = szT[2] = '-'; szT[3] = '\0';
        }
    CommSzSz("Character: ", szT);
    CommSzNum("Dxp:       ", (int) *pdxp);
    CommSzNum("OverHang:  ", (int) (fPrinter ? vfmiPrint.dxpOverhang : vfmiScreen.dxpOverhang));
    }
#endif
    return(*pdxp);
    }


/* F  F I R S T  I C H */
int near FFirstIch(ich)
int ich;
    {
    /* Returns true iff ich is 0 or preceded only by 0 width characters */
    register int ichT;
    register int *pdxp = &vfli.rgdxp[0];

    for (ichT = 0; ichT < ich; ichT++)
        {
        if (*pdxp++)
            {
            return false;
            }
        }
    return true;
    }


ValidateMemoryDC()
    {
    /* Attempt to assure that vhMDC and vhDCPrinter are valid.  If we have not
    already run out of memory, then vhDCPrinter is guaranteed, but vhMDC may
    fail due to out of memory -- it is the callers responsibility to check for
    vhMDC == NULL. */

    extern int vfOutOfMemory;
    extern HDC vhMDC;
    extern BOOL vfMonochrome;
    extern long rgbText;
    extern struct WWD *pwwdCur;

    /* If we are out of memory, then we shouldn't try to gobble it up by getting
    DC's. */
    if (!vfOutOfMemory)
        {
        if (vhMDC == NULL)
            {
            /* Create a memory DC compatible with the screen if necessary. */
            vhMDC = CreateCompatibleDC(pwwdCur->hDC);

            /* Callers are responsible for checking for vhMDC == NULL case */
            if (vhMDC != NULL)
                {
                /* Put the memory DC in transparent mode. */
                SetBkMode(vhMDC, TRANSPARENT);

                /* If the display is a monochrome device, then set the text
                color for the memory DC.  Monochrome bitmaps will not be
                converted to the foreground and background colors in this case,
                we must do the conversion. */
                if (vfMonochrome = (GetDeviceCaps(pwwdCur->hDC, NUMCOLORS) ==
                  2))
                    {
                    SetTextColor(vhMDC, rgbText);
                    }
                }
            }

        /* If the printer DC is NULL then we need to reestablish it. */
        if (vhDCPrinter == NULL)
            {
            GetPrinterDC(FALSE);
            /* GetPrinterDC has already called SetMapperFlags() on vhDCPrinter. */
            }
        }
    }




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\globdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* ****************************************************************************
**
**      COPYRIGHT (C) 1985 MICROSOFT
**
** ****************************************************************************
*
*  Module: globdefs.h - text for static arrays and other uses. Change this
*                      module when internationalizing.
*
*  Functions included: none
*
**
** REVISIONS
**
** Date         Who Rel Ver     Remarks
** 10/20/89     fgd             Win 3.0. Some defines have been moved to write.rc
** 07/08/86     yy              addition of reverse string for unit parsing.
** 11/20/85     bz              initial version
**
** ***************************************************************************/

/* NOTE NOTE NOTE
Win 3.0.  In order to easy the localization of Write, some string defines
have been removed from here and placed into write.rc
*/

#define utDefault utCm  /* used to set utCur - may be utInch or utCm */
#define vzaTabDfltDef (czaInch / 2) /* width of default tab in twips */
                                   /* note that czaCm is also available */



#define szExtWordDocDef  ".DOC"
#define szExtWordBakDef  ".BAK"
#define szExtDrvDef  ".drv"
#define szExtGlsDef  ".GLS"


#ifdef KINTL
#define szExtDocDef  ".WRI"    /* this and next extension should be the same */
#define szExtSearchDef  "\\*.WRI"    /* store default search spec */
#define szExtBackupDef  ".BKP"
#else
#define szExtDocDef  ".DOC"   /* This and next extension should be the same */
#define szExtSearchDef "\\*.DOC"  /* Store default search spec. */
#define szExtBackupDef ".BAK"
#endif /* if-else-def INTL */


#define szWriteProductDef  "MSWrite"   /* WIN.INI: our app entry */
#define szFontEntryDef  "Fontx"        /* WIN.INI: our font list */
#define szSepNameDef  " - "  /* Separates AppName from file name in header */

#ifdef STYLES
#define szSshtEmpty "NORMAL.STY"
#endif /* STYLES */


/* Strings for parsing the user profile. */
#define szWindowsDef  "windows"
#define szDeviceDef  "Device"
#define szDevicesDef  "devices"
#define szBackupDef  "Backup"

#if defined(JAPAN) || defined(KOREA) //Win3.1J
#define szWordWrapDef  "WordWrap"
#endif

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
#define szImeHiddenDef "IMEHidden"
#endif

  /* used to get decimal point character from user profile */
#define szIntlDef "intl"
#define szsDecimalDef "sDecimal"
#define szsDecimalDefaultDef "."
#define sziCountryDef "iCountry"
                  /* see msdos manual for meaning of codes */

/* Strings for our window classes (MUST BE < 39 CHARS) */

#define szParentClassDef  "MSWRITE_MENU"
#define szDocClassDef  "MSWRITE_DOC"
#define szRulerClassDef  "MSWRITE_RULER"
#define szPageInfoClassDef  "MSWRITE_PAGEINFO"

#ifdef ONLINEHELP
#define szHelpDocClassDef  "MSWRITE_HELPDOC"
#endif

  /* used in fileutil.c  - name of temp file */
#ifdef INTL
#define szMWTempDef "~WRI0000.TMP"
#else
#define szMWTempDef "~DOC0000.TMP"
#endif

  /* used in fontenum.c  */
#define szSystemDef "System"

#ifdef  DBCS_VERT       /* was in JAPAN, changed it to DBCS */
// Vertical orientation systemfont facename [yutakan:08/09/91]
#define szAtSystemDef "@System"
#endif

  /* used in initwin.c  */

#define szMw_acctbDef "mw_acctb"
#define szNullPortDef "NullPort"
#define szMwloresDef "mwlores"
#define szMwhiresDef "mwhires"
#define szMw_iconDef "mw_icon"
#define szMw_menuDef "mw_menu"
#define szScrollBarDef "ScrollBar"

  /* used in pictdrag.c  */
#define szPmsCurDef "pmscur"


  /* used in screen.c  - available font family names */
#define szModernDef "Modern"
#define szRomanDef "Roman"
#define szSwissDef "Swiss"
#define szScriptDef "Script"
#define szDecorativeDef "Decorative"

  /* used in util2.c  abbreviations for units */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\format.asm ===
;* ****************************************************************************
;*
;*      COPYRIGHT (C) 1985-1992 MICROSOFT
;*
;* ****************************************************************************
;
        TITLE    Format.asm line formatting routines for windows Write
;  Module: format.asm
;     contains native code versions of FormatLine, Justify, FGrowFormatHeap,
;         FFirstIch, DxpFromCh, and ValidateMemoryDC
;
;*
;* REVISION HISTORY
;*
;* Date         Who Rel Ver     Remarks
;* 5/23/85      bz              initial translation from c
;* 6/21/85      bl              Set ?WIN == 0 for windows header
;* 7/09/85      pnt             Call WinFailure() if vhMDC == NULL
;* 7/16/85      pnt             Truncate tabs at right margin
;* 7/21/85      pnt             Treat running heads like normal paragraphs
;* 7/30/85      bl              Fixed bug in FFirstIch -- change scasb to scasw
;* 8/05/85      pnt             Added ValidateMemoryDC()
;* 8/05/85      pnt             DxpFromCh returns dxpSpace if ch < space
;* 8/07/85      pnt             cchCHPUsed changed from 9 to 7
;* 8/09/85      pnt             Ensure there tabs don't back up on the screen
;* 8/14/85      pnt             Map center and right tabs to left tabs
;* 8/27/85	pnt		Single spacing changed to font leading only
;* 8/29/85	pnt		Lines with no breaks can be right, center flush
;* 10/01/85	pnt		Forced section mark to be in stardard font
;* 10/07/85	pnt		DxpFromCh returns dxpSpace iff width unimportant
;* 10/10/85	pnt		Validity of vfli cache depends on flm
;* 10/10/85	pnt		fPrevSpace not set for null runs
;* 10/30/89 pault   set code to use SYSENDMARK code in FORM1.C
;* (7.23.91)    v-dougk         changed dxp char arrays to int arrays
SYSENDMARK EQU 1
;*
;* ************************************************************************* */

;* ************************************************************************* */
;          Naming conventions used here
;
;       rxx_name   register variable - reg is xx. This may be a temporary naming
;                       of a register (e.g. rax_ichT)
;       c_name     defined constant in c program (e.g. c_false)
;
;* ************************************************************************* */
        subttl Conditional variables and cmacros
        page

; *************** Conditional variables *************************
; ***** These variables should be defined using the -D command line
; ***** option in masm. They are only checked for being defined, not
; ***** for a particular value
;
; DEBUG   define with   -DDEBUG ; ** controls ASSERT code **
; SCRIBBLE  define with -DSCRIBBLE ; ** controls SCRIBBLE code **
; CASHMERE ; ** code taken out for Write, to be used for Cashmere **
;
; ***************  End conditional variables *************************

        memM =   1     ; medium model for cmacros
        ?WIN    = 1    ; windows header used here
        .xlist
        include cmacros.inc
        page
        .list
        ;.sall
        createSeg FORM1_TEXT,FORM1_TEXT,BYTE,PUBLIC,CODE

        ASSUME  CS: FORM1_TEXT, DS: DGROUP, SS: DGROUP, ES: DGROUP

        subttl Public definitions
        page
;
;   Public definitions for this module
;
PUBLIC  DxpFromCh
PUBLIC  FormatLine
PUBLIC  Justify
PUBLIC  FGrowFormatHeap
PUBLIC  FFirstIch
PUBLIC  ValidateMemoryDC

;
;   External procedures referenced from this module
;

EXTRN   IMAX:FAR
EXTRN   CCHDIFFER:FAR
EXTRN   CACHESECT:FAR
EXTRN   FCHNGSIZEH:FAR
EXTRN   CACHEPARA:FAR
EXTRN   FORMATGRAPHICS:FAR
EXTRN   FFORMATSPECIALS:FAR
EXTRN   MULTDIV:FAR
EXTRN   FETCHCP:FAR
EXTRN   SETTEXTJUSTIFICATION:FAR
EXTRN   GETTEXTEXTENT:FAR
EXTRN   LOADFONT:FAR
EXTRN   WINFAILURE:FAR
EXTRN   GETDEVICECAPS:FAR
EXTRN   SETBKMODE:FAR
EXTRN   SETTEXTCOLOR:FAR
EXTRN   CREATECOMPATIBLEDC:FAR
EXTRN	GETPRINTERDC:FAR

        ; **** Debugging code **********
IFDEF DEBUG
IFDEF SCRIBBLE
EXTRN   FNSCRIBBLE:FAR
ENDIF
ENDIF


        subttl External definitions
        page
;
;   External definitions referenced from this module
;
        sBegin DATA

EXTRN   PLOCALHEAP:WORD
;EXTRN   DOCHELP:WORD
EXTRN   VFLI:BYTE
EXTRN   VHGCHPFORMAT:WORD
EXTRN   ICHPMACFORMAT:WORD
EXTRN   VCHPABS:BYTE
EXTRN   VPAPABS:BYTE
EXTRN   VSEPABS:BYTE
EXTRN   VSEPPAGE:BYTE
EXTRN   VCHPNORMAL:BYTE
EXTRN   VCPFIRSTPARACACHE:DWORD
EXTRN   VCPFETCH:DWORD
EXTRN   YPSUBSUPER:WORD
EXTRN   VPCHFETCH:WORD
EXTRN   VCCHFETCH:WORD
EXTRN   YPSUBSUPERPR:WORD
EXTRN   VHMDC:WORD
EXTRN   VHDCPRINTER:WORD
EXTRN   DXPLOGINCH:WORD
EXTRN   DYPLOGINCH:WORD
EXTRN   DXAPRPAGE:WORD
EXTRN   DYAPRPAGE:WORD
EXTRN   DXPPRPAGE:WORD
EXTRN   DYPPRPAGE:WORD
EXTRN   DYPMAX:WORD
EXTRN   VFMISCREEN:BYTE
EXTRN   VFMIPRINT:BYTE
EXTRN   VFOUTOFMEMORY:WORD
EXTRN   VFMONOCHROME:WORD
EXTRN   RGBTEXT:DWORD
EXTRN   PWWDCUR:WORD
EXTRN   VCHDECIMAL:BYTE
EXTRN   VZATABDFLT:BYTE
        sEnd DATA

        ;sBegin BSS
        sBegin DATA
$S784_ichpFormat        DB 02H DUP (?)
        EVEN
        sEnd DAT
        ;sEnd BSS

        subttl Macros
        page
; ********************************************************************
; macros done here for speed, rather than doing far procedure call

;-----------------------------------------------------------------------------
; bltc (pTo, wFill, cw) - fills cw words of memory starting at pTo with wFill.
;-----------------------------------------------------------------------------
;  macro bltc destroys ax,es,cx

bltc    MACRO pTo,wFill,cw
        push    di
        mov     ax,ds               ; we are filling in the data segment
        mov     es,ax
        mov     di,pTo              ; get the destination, constant, and count
        mov     ax,wFill
        mov     cx,cw
        cld                         ; the operation is forward
        rep     stosw               ; fill memory
        pop     di
        ENDM

;-----------------------------------------------------------------------------
; bltbc (pTo, bFill, cb) - fills cb bytes of memory starting at pTo with
; bFill.
;-----------------------------------------------------------------------------

;  macro bltbc destroys ax,es,cx

bltbc   MACRO pTo,bFill,cb
        push    di
        mov     ax,ds               ; we are filling in the data segment
        mov     es,ax
        mov     di,pTo              ; get the destination, constant, and count
        mov     al,bFill
        mov     cx,cb
        cld                         ; the operation is forward
        rep     stosb               ; fill memory
        pop     di
        ENDM

;------------------------------------------------------------------------------
; blt (pFrom, pTo, cw) - a block transfer of wFills from pFrom to pTo;
; The size of the block is cw wFills.  This blt() handles the case of
; overlapping source and destination.  blt() returns a pointer to the
; end of the destination buffer (pTo + cw).  NOTE - use this blt() to
; to transfer within the current DS only--use the bltx for FAR blts.
;-----------------------------------------------------------------------------

;  macro blt destroys ax,bx,cx,es

blt     MACRO pFrom,pTo,cw
        local   blt1
        push    si
        push    di
        mov     si,pFrom            ; get pointers and length of blt
        mov     di,pTo
        mov     cx,cw
        mov     ax,ds               ; set up segment registers
        mov     es,ax
        mov     ax,di               ; calculate return value
        mov     bx,cx
        shl     bx,1
        add     ax,bx
        cmp     si,di               ; reverse direction of the blt if
        jae     blt1                ;  necessary

        dec     bx
        dec     bx
        add     si,bx
        add     di,bx
        std
blt1:
        rep     movsw
        cld
        pop     di
        pop     si
        ENDM


        subttl C structures Used in this module
        page
;
;       *** The following structure definitions were used when this module
;       *** was being developed:
;
;struct IFI
        ;{
        ;int             xp;
        ;int             xpLeft;
        ;int             xpRight;
        ;int             xpReal;
        ;int            xpPr;
        ;int            xpPrRight;
        ;int             ich;
        ;int             ichLeft;
        ;int             ichPrev;
        ;int             ichFetch;
        ;int             dypLineSize;
        ;int             cchSpace;
        ;int             cBreak;
        ;int             chBreak;
        ;int             jc;

;#ifdef CASHMERE
        ;int             tlc;
;#endif /* CASHMERE */

        ;int             fPrevSpace;
        ;};
; ***************************************************************************
; ***** Equates for IFI structure ifi offsets ****************

        IFI_STRUC       STRUC
        xp              DW      ?
        xpLeft_Ifi      DW      ?
        xpRight_Ifi     DW      ?
        xpReal_Ifi      DW      ?
        xpPr            DW      ?
        xpPrRight       DW      ?
        ich_Ifi         DW      ?
        ichLeft         DW      ?
        ichPrev         DW      ?
        ichFetch        DW      ?
        dypLineSize     DW      ?
        cchSpace        DW      ?
        cBreak_Ifi      DW      ?
        chBreak         DW      ?
        _jc             DW      ? ; (2.27.91) D. Kent
        fPrevSpace      DW      ?
        IFI_STRUC       ENDS

        oIfi_xp         EQU 0
        oIfi_xpLeft     EQU 2
        oIfi_xpRight    EQU 4
        oIfi_xpReal     EQU 6
        oIfi_xpPr       EQU 8
        oIfi_xpPrRight  EQU 10
        oIfi_ich        EQU 12
        oIfi_ichLeft    EQU 14
        oIfi_ichPrev    EQU 16
        oIfi_ichFetch   EQU 18
        oIfi_dypLineSize        EQU 20
        oIfi_cchSpace   EQU 22
        oIfi_cBreak     EQU 24
        oIfi_chBreak    EQU 26
        oIfi_jc         EQU 28
        oIfi_fPrevSpace EQU 30

        page
; ***************************************************************************

;/* Formatted line structure.
;Reorganized KJS, CS Sept 3 */
;/* booleans in bytes to simplify machine code */
;struct FLI
        ;{
        ;typeCP          cpMin;
        ;int             ichCpMin;
        ;typeCP          cpMac;
        ;int             ichCpMac;
        ;int             ichMac;
        ;int             dcpDepend;
        ;unsigned        fSplat : 8;
;/* First character in region where spaces have additional pixel */
        ;unsigned        ichFirstWide : 8;
;/* ichMac, with trailing blanks excluded */
        ;int             ichReal;
        ;int             doc;

        ;int             xpLeft;
        ;int             xpRight;
;/* xpRight, with trailing blanks excluded */
        ;int             xpReal;
;/* the right margin where insert will have to break the line */
        ;int             xpMarg;
;
        ;unsigned        fGraphics : 8;
        ;unsigned        fAdjSpace : 8;  /* Whether you adjust the spaces */

        ;unsigned        dxpExtra;
;/* the interesting positions in order from top to bottom are:
        ;top:                  yp+dypLine
        ;top of ascenders:     yp+dypAfter+dypFont
        ;base line:            yp+dypBase
        ;bottom of descenders: yp+dypAfter
        ;bottom of line:       yp
;distances between the points can be determined by algebraic subtraction.
;e.g. space before = yp+dypLine - (yp+dypAfter+dypFont)
;*/
        ;int             dypLine;
        ;int             dypAfter;
        ;int             dypFont;
        ;int             dypBase;

        ;int            ichLastTab;
        ;int             rgdxp[ichMaxLine];
        ;CHAR            rgch[ichMaxLine];
        ;};
; ***************************************************************************
ichMaxLine EQU  255
dxpNil     EQU  0FFFFH

        FLI STRUC
        cpMin_OFF       DW      ?
        cpMin_SEG       DW      ?
        ichCpMin        DW      ?
        cpMac_OFF       DW      ?
        cpMac_SEG       DW      ?
        ichCpMac        DW      ?
        ichMac          DW      ?
        dcpDepend       DW      ?
        fSplat          DB      ?
        ichFirstWide    DB      ?
        ichReal         DW      ?
        doc_Fli         DW      ?
        xpLeft_Fli      DW      ?
        xpRight         DW      ?
        xpReal_Fli      DW      ?
        xpMarg          DW      ?
        fGraphics_Fli   DB      ?
        fAdjSpace       DB      ?
        dxpExtra        DW      ?
        dypLine         DW      ?
        dypAfter        DW      ?
        dypFont         DW      ?
        dypBase         DW      ?
        fSplatNext      DW      ?
        ichLastTab      DW      ?
	flm_Fli		DW	?
        rgdxp           DW ichMaxLine DUP (?)
        rgch            DB ichMaxLine DUP (?)
        FLI     ENDS

        page

; **************************************************************************
;struct TBD      /* Tab Descriptor */
        ;{
        ;unsigned        dxa;        /* distance from left margin of tab stop */
        ;unsigned char   jc : 3;     /* justification code */
        ;unsigned char   tlc : 3;    /* leader dot code */
        ;unsigned char   opcode : 2; /* operation code for Format Tabs */
        ;CHAR            chAlign;    /* ASCII code of char to align on
                                       ;if jcTab=3, or 0 to align on '.' */
        ;};
; ***************************************************************************
; ***** Equates for TBD structure offsets ****************
        TBD     STRUC
        dxa     DW      ?
        jc_Tbd  DB      ?  ; 3 bits
        chAlign DB      ?  ;char
        TBD     ENDS

            ;/* bit field equates in TBD structure */
        tlc     EQU jc_Tbd  ; 3 bits
        opcode  EQU jc_Tbd  ; 2 bits

        page
; **************************************************************************
;struct PAP      /* Paragraph properties */
        ;{
        ;unsigned        fStyled : 1;                            /* BYTE 0 */
        ;unsigned        stc : 7;
        ;unsigned        jc : 2;                                 /* BYTE 1 */
        ;unsigned        fKeep : 1;
        ;unsigned        fKeepFollow : 1;
        ;unsigned        : 4;
        ;unsigned        stcNormChp : 7;                         /* BYTE 2 */
        ;unsigned        : 9;                                    /* BYTE 3 */
        ;unsigned        dxaRight;                               /* BYTE 4-5 */
        ;unsigned        dxaLeft;                                /* BYTE 6-7 */
        ;unsigned        dxaLeft1;                               /* BYTE 8-9 */
        ;unsigned        dyaLine;                                /* 10-11 */
        ;unsigned        dyaBefore;                              /* 12-13 */
        ;unsigned        dyaAfter;                               /* 14-15 */
        ;unsigned        rhc : 4;        /* Running hd code */
        ;unsigned        fGraphics : 1; /* Graphics bit */
        ;unsigned        wUnused1 : 11;
        ;int             wUnused2;
        ;int             wUnused3;
        ;struct TBD      rgtbd[itbdMaxWord];
        ;};

; ***************************************************************************
; ***** Equates for PAP structure offsets ****************

        PAP     STRUC
        fStyled         DB      ?       ;1 bit         /* BYTE 0 */
        jc_Pap          DB      ?       ;2 bits        /* BYTE 1 */
        rmChp           DB      ?       ;7 bits          /* BYTE 2 */
        unused9         DB      ?       ;9 bits          /* BYTE 3 */
        dxaRight        DW      ?       ;/* BYTE 4-5 */
        dxaLeft         DW      ?       ;/* BYTE 6-7 */
        dxaLeft1        DW      ?       ;/* BYTE 8-9 */
        dyaLine         DW      ?       ;/* 10-11 */
        dyaBefore       DW      ?       ;/* 12-13 */
        dyaAfter        DW      ?       ;/* 14-15 */
                                        ;/* BYTE 16-17 */
        rhc             DW      ?       ;4 bits        /* Running hd code */
        wUnused2        DW      ?       ;/* BYTE 18-19 */
        wUnused3        DW      ?       ;/* BYTE 20-21 */
        rgtbd           DW      ?       ;/* BYTE 23-23 */
        PAP     ENDS
            ;/* bit field equates in PAP structure */
        stc_Pap     EQU fStyled         ;7 bits
        fKeep       EQU jc_Pap          ;1 bit
        fKeepFollow EQU jc_Pap          ;1 bit
        unused4     EQU jc_Pap          ;4 bits
        fGraphics_Pap   EQU rhc         ;1 bits /* Graphics bit */
        wUnused1    EQU rhc             ;11 bits
        page

; **************************************************************************
;struct SEP
;       { /* Section properties */
;       unsigned        fStyled : 1;                            /* BYTE 0 */
;       unsigned        stc : 7;
;       unsigned        bkc : 3;        /* Break code */        /* BYTE 1 */
;       unsigned        nfcPgn : 3;     /* Pgn format code */
;       unsigned        :2;
;       unsigned        yaMac;          /* Page height */       /* BYTE 2-3 */
;       unsigned        xaMac;          /* Page width */        /* BYTE 4-5 */
;       unsigned        pgnStart;       /* Starting pgn */      /* BYTE 6-7 */
;       unsigned        yaTop;          /* Start of text */     /* BYTE 8-9 */
;       unsigned        dyaText;        /* Height of text */    /* 10-11 */
;       unsigned        xaLeft;         /* Left text margin */  /* 12-13 */
;       unsigned        dxaText;        /* Width of text */     /* 14-15 */
;       unsigned        rhc : 4;        /* *** RESERVED *** */  /* 16 */
;                                       /* (Must be same as PAP) */
;       unsigned        : 2;
;       unsigned        fAutoPgn : 1;   /* Print pgns without hdr */
;       unsigned        fEndFtns : 1;   /* Footnotes at end of doc */
;       unsigned        cColumns : 8;   /* # of columns */      /* BYTE 17 */
;       unsigned        yaRH1;          /* Pos of top hdr */    /* 18-19 */
;       unsigned        yaRH2;          /* Pos of bottom hdr */ /* 20-21 */
;       unsigned        dxaColumns;     /* Intercolumn gap */   /* 22-23 */
;       unsigned        dxaGutter;      /* Gutter width */      /* 24-25 */
;       unsigned        yaPgn;          /* Y pos of page nos */ /* 26-27 */
;       unsigned        xaPgn;          /* X pos of page nos */ /* 28-29 */
;       CHAR            rgbJunk[cchPAP - 30]; /* Pad to cchPAP */
;       };

; ***************************************************************************
; ***** Equates for SEP structure offsets ****************
        SEP     STRUC
        fStyled_Sep     DB      ?       ;1 bit          /* BYTE 0 */
        bkc             DB      ?       ;3 bits /* BYTE 1 */
        yaMac           DW      ?       ; /* Page height */ /* BYTE 2-3 */
        xaMac           DW      ?       ;/* Page width */  /* BYTE 4-5 */
        pgnStart        DW      ?       ; /* Starting pgn */      /* BYTE 6-7 */
        yaTop           DW      ?       ; /* Start of text */     /* BYTE 8-9 */
        dyaText         DW      ?       ; /* Height of text */    /* 10-11 */
        xaLeft_Sep      DW      ?       ; /* Left text margin */  /* 12-13 */
        dxaText         DW      ?       ; /* Width of text */     /* 14-15 */
        rhc_Sep         DB      ?       ;4 bits   /* 16 */
        ;                                       /* (Must be same as PAP) */
        cColumns        DB      ?       ; /* # of columns */      /* BYTE 17 */
        yaRH1           DW      ?       ; /* Pos of top hdr */    /* 18-19 */
        yaRH2           DW      ?       ; /* Pos of bottom hdr */ /* 20-21 */
        dxaColumns      DW      ?       ;/* Intercolumn gap */   /* 22-23 */
        dxaGutter       DW      ?       ; /* Gutter width */      /* 24-25 */
        yaPgn           DW      ?       ; /* Y pos of page nos */ /* 26-27 */
        xaPgn           DW      ?       ; /* X pos of page nos */ /* 28-29 */
        rgbJunk         DW      ?       ; /* Pad to cchPAP */
        SEP     ENDS

            ;/* bit field equates in SEP structure */

        stc_Sep EQU fStyled_Sep     ;7 bits
        nfcPgn EQU bkc  ; 3 bits     /* Pgn format code */
        junk1_Sep  EQU bkc  ; 2 bits
        junk2_Sep  EQU rhc_Sep  ;2 bits
        fAutoPgn EQU rhc_Sep    ;1 bit   /* Print pgns without hdr */
        fEndFtns EQU rhc_Sep    ;1 bit   /* Footnotes at end of doc */


        page

; **************************************************************************
;typedef struct FMI     /* font metric information */
        ;{
        ;int *mpchdxp;         /* pointer to width table */
                                ;/* NOTE - we actually point chDxpMin entries
                                          ;before the start of the table, so
                                          ;that the valid range begins at the
                                          ;start of the actual table */
        ;int dxpSpace;          /* width of a space */
        ;int dxpOverhang;       /* overhang for italic/bold chars */
        ;int dypAscent;         /* ascent */
        ;int dypDescent;                /* descent */
        ;int dypBaseline;       /* difference from top of cell to baseline */
        ;int dypLeading;        /* accent space plus recommended leading */
        ;};

; ***************************************************************************
; ***** Equates for FMI  structure offsets ****************
        FMI     STRUC
        mpchdxp         DW      ?
        dxpSpace        DW      ?
        dxpOverhang     DW      ?
        dypAscent_Fmi   DW      ?
        dypDescent_Fmi  DW      ?
        dypBaseline     DW      ?
        dypLeading      DW      ?
        FMI     ENDS
        page

; **************************************************************************
;struct CHP      /* Character properties */
        ;{
        ;unsigned       fStyled : 1;                            /* BYTE 0 */
        ;unsigned       stc : 7;        /* style */
        ;unsigned       fBold : 1;                              /* BYTE 1 */
        ;unsigned       fItalic : 1;
        ;unsigned       ftc : 6;        /* Font code */
        ;unsigned       hps : 8;        /* Size in half pts */  /* BYTE 2 */
        ;unsigned       fUline : 1;                             /* BYTE 3 */
        ;unsigned       fStrike : 1;
        ;unsigned       fDline: 1;
        ;unsigned       fOverset : 1;
        ;unsigned       csm : 2;        /* Case modifier */
        ;unsigned       fSpecial : 1;
        ;unsigned       : 1;
        ;unsigned       ftcXtra : 3;                            /* BYTE 4 */
        ;unsigned       fOutline : 1;
        ;unsigned       fShadow : 1;
        ;unsigned       : 3;
        ;unsigned       hpsPos : 8;                             /* BYTE 5 */
        ;unsigned       fFixedPitch : 8;        /* used internally only */
        ;unsigned       chLeader : 8;
        ;unsigned       ichRun : 8;
        ;unsigned       cchRun : 8;
        ;};

; ***************************************************************************
; ***** Equates for CHP structure offsets ****************
        CHP     STRUC
        fStyled_Chp     DB      ?       ;1 bit   /* BYTE 0 */
        fBold           DB      ?       ;1 bit   /* BYTE 1 */
        hps             DB      ?       ;8 bits  /* BYTE 2 */
        fUline          DB      ?       ;1 bit   /* BYTE 3 */
        ftcXtra         DB      ?       ;3 bits  /* BYTE 4 */
        hpsPos          DB      ?       ;8 bits  /* BYTE 5 */
        fFixedPitch     DB      ?       ;8 bits  /* BYTE 6 */
        chLeader        DB      ?       ;8 bits  /* BYTE 7 */
        ichRun          DB      ?       ;8 bits  /* BYTE 8 */
        cchRun          DB      ?       ;8 bits  /* BYTE 9 */
        CHP     ENDS

            ;/* bit field equates in CHP structure */
        stc_Chp         EQU fStyled_Chp ;7 bits        /* style */
        fItalic         EQU fBold       ;1 bit
        ftc             EQU fBold       ;6 bits
        fStrike         EQU fUline      ;1 bit
        fDline          EQU fUline      ;1 bit
        fOverset        EQU fUline      ;1 bit
        csm             EQU fUline      ;2 bits        /* Case modifier */
        fSpecial        EQU fUline      ;1 bit
        chp_unused1     EQU fUline      ;1 bit
        fOutline        EQU ftcXtra     ;1 bit
        fShadow         EQU ftcXtra     ;1 bit
        chp_unused2     EQU ftcXtra     ;3 bits

; **************************************************************************
        subttl  Bit masks
        page

        mask_0001       EQU 1
        mask_0010       EQU 2
        mask_0011       EQU 3
        mask_0100       EQU 4
        mask_0101       EQU 5
        mask_0110       EQU 6
        mask_0111       EQU 7
        mask_1000       EQU 8
        mask_1001       EQU 9
        mask_1010       EQU 10
        mask_1011       EQU 11
        mask_1100       EQU 12
        mask_1101       EQU 13
        mask_1110       EQU 14
        mask_1111       EQU 15
        mask_0001_0000  EQU 16
        mask_1111_1111  EQU 65535
        mask_0100_0000  EQU 64

        subttl Defined C Constants

        c_True          EQU     1
        c_False         EQU     0
        c_hpsDefault    EQU     20
        c_cwFLIBase     EQU     22
        c_cwIFI         EQU     16
        c_cwCHP         EQU     5
        c_docNil        EQU     -1
        c_cpNil         EQU     -1
        c_czaInch       EQU     1440
	c_czaLine	EQU	240
        c_xaRightMax    EQU     31680
        c_hpsNegMin     EQU     128
                ;/* Justification codes: must agree with menu.mod */
        c_jcLeft        EQU     0
        c_jcCenter      EQU     1
        c_jcRight       EQU     2
        c_jcBoth        EQU     3

        c_jcTabMin      EQU     4
        c_jcTabLeft     EQU     4
        c_jcTabCenter   EQU     5
        c_jcTabRight    EQU     6
        c_jcTabDecimal  EQU     7

                ;/* Tab leader codes: must agree with menu.mod */
        c_tlcWhite      EQU     0
        c_tlcDot        EQU     1
        c_tlcHyphen     EQU     2
        c_tlcUline      EQU     3

        c_chEmark       EQU     164

        c_chNil         EQU     -1
        c_chDelPrev     EQU     8
        c_chTab         EQU     9
        c_chEol         EQU     10
        c_chNewLine     EQU     11
        c_chSect        EQU     12
        c_chReturn      EQU     13
        c_chNRHFile     EQU     31
        c_chSpace       EQU     32
        c_chSplat       EQU     46
        c_chHyphen      EQU     45


        subttl FormatLine()
        page
; **************************************************************************
        sBegin FORM1_TEXT
;***
;
; FormatLine(doc, cp, ichCp, cpMac, flm)
;   int doc;
;   typeCP cp;
;   int ichCp;
;   typeCP cpMac;
;   int flm;
;
;  This procedure fills up vfli with a line of text. It is very large
;   and called often - each time a character is typed, at least.
;
;***
        cProc FormatLine,<PUBLIC,FAR>,<di,si>
                parmW   doc
                parmD   cp
                parmW   ichCp
                parmD   cpMac
                parmW   flm
; Line 79

                localW  dyaFormat
                localW  fFlmPrinting
                localDP psep
                localW  xaRight
                localW  dypAscentMac
                localW  ichpNRH
                localW  ypSubSuperFormat
                localW  dxpFormat
                localW  dypFormat
                localDP ppap
                localW  dypAscent

                localV  ifi,%(size IFI_STRUC)

                localW  xpTab
                localW  fTruncated
                localW  xaLeft
                localW  dypDescentMac
                localDP ptbd
                localW  dypDescent
                localW  dxaFormat
                localW  dxp
                localW  cch
                localDP pch
                localW  xpPrev
                localW  iichNew
                localW  dxpPr
                localW  cchUsed
                localW  dich
                localW  fSizeChanged
                localW  chT
                localW  cch2
                localW  dxpCh
                localW  xaTab
                localW  xaPr
                localW  chT2
                localW  dxpNew

                localV  chpLocal,%(size CHP)

        cBegin FormatLine

; Line 107
        mov     ax,flm
        and     ax,1
        mov     fFlmPrinting,ax
; Line 113
        mov     fTruncated,0

    ;** Check for fli current */
; Line 122
        mov     ax,WORD PTR VFLI.doc_Fli
        cmp     doc,ax
        jne     $I845
        mov     ax,WORD PTR VFLI.cpMin_OFF
        mov     dx,WORD PTR VFLI.cpMin_SEG
        cmp     SEG_cp,dx
        jne     $I845
        cmp     OFF_cp,ax
        jne     $I845
        mov     ax,WORD PTR VFLI.ichCpMin
        cmp     ichCp,ax
        jne     $I845
	mov	ax,WORD PTR VFLI.flm_Fli
	cmp	flm,ax
	jne	$I845

        ;* Just did this one */

        jmp     $RetFormat    ; *** return ****
; Line 125
$I845:
IFDEF DEBUG
IFDEF SCRIBBLE
        mov     ax,5
        push    ax
        mov     ax,70
        push    ax
        call    FAR PTR FNSCRIBBLE
ENDIF
ENDIF
; Line 129
    ;*
    ;* This means:
    ;*  vfli.fSplat = false;
    ;*  vfli.dcpDepend = 0;
    ;*  vfli.ichCpMac = 0;
    ;*  vfli.dypLine = 0;
    ;*  vfli.dypAfter = 0;
    ;*  vfli.dypFont = 0;
    ;*  vfli.dypBase = 0;
    ;*
    ;                         *** macro bltc destroys ax,es,cx
        bltc    <OFFSET VFLI>,0,c_cwFLIBase
        mov     WORD PTR VFLI.fSplatNext, 0
; Line 141
     ;* Rest of FormatLine loads up cache with current data *****

        mov     ax,doc
        mov     WORD PTR VFLI.doc_Fli,ax
	mov	ax,flm
	mov	WORD PTR VFLI.flm_Fli,ax
; Line 142
; *********** Register variables ********************
        rax_OFF_cp      EQU     ax
        rdx_SEG_cp      EQU     dx
; ****************************************************
        mov     rax_OFF_cp,OFF_cp
        mov     rdx_SEG_cp,SEG_cp
        mov     WORD PTR VFLI.cpMin_OFF,rax_OFF_cp
        mov     WORD PTR VFLI.cpMin_SEG,rdx_SEG_cp
; Line 143
        mov     cx,ichCp
        mov     WORD PTR VFLI.ichCpMin,cx
; Line 145
               ; *** if (cp > cpMac)
        cmp     rdx_SEG_cp,SEG_cpMac
        jl      $initRunTbl
        jg      $spAftEnd
        cmp     rax_OFF_cp,OFF_cpMac
        jbe     $initRunTbl
$spAftEnd:
        ;/* Space after the endmark. Reset the cache because the footnotes come
        ;at the same cp in the footnote window */
; Line 149
        mov     WORD PTR VFLI.doc_Fli,c_docNil
; Line 150
        mov     WORD PTR VFLI.cpMac_OFF,rax_OFF_cp
        mov     WORD PTR VFLI.cpMac_SEG,rdx_SEG_cp
; Line 151
        mov     WORD PTR VFLI.rgdxp,0
; Line 159
        ;  /* Line after end mark is taller than screen */
        mov     ax,DYPMAX
        mov     WORD PTR VFLI.dypLine,ax
        sar     ax,1
        mov     WORD PTR VFLI.dypFont,ax
        mov     WORD PTR VFLI.dypBase,ax
        jmp     $ScribRet       ; Scribble and return
;
; *************** EXIT POINT **********************************************
;


$initRunTbl:
                ;/* Initialize run tables */
        mov     WORD PTR $S784_ichpFormat,0
; Line 185
                ;/* Cache section and paragraph properties */
        push    doc
        push    SEG_cp
        push    OFF_cp
        call    FAR PTR CACHESECT
; Line 188
        mov     psep,OFFSET VSEPABS
; Line 190
        push    doc
        push    SEG_cp
        push    OFF_cp
        call    FAR PTR CACHEPARA
; Line 191
        mov     ppap,OFFSET VPAPABS

                ;/* Now we have:
                        ;ppap    paragraph properties
                        ;psep    division properties
                ;*/

; Line 198
                ; *** if (ppap->fGraphics)
        mov     bx,ppap
        test    WORD PTR [bx].fGraphics_Pap,mask_0001_0000
        je      $I851
; Line 201
                ;*** Format a picture paragraph in a special way (see picture.c)
        push    doc
        push    SEG_cp
        push    OFF_cp
        push    ichCp
        push    SEG_cpMac
        push    OFF_cpMac
        push    flm
        call    FAR PTR FORMATGRAPHICS
        jmp     $ScribRet       ; Scribble and return
;
; *************** EXIT POINT **********************************************
;
$I851:
                ; *** /* Assure we have a good memory DC for font stuff */
        call    FAR PTR VALIDATEMEMORYDC
        cmp     VHMDC,0
        je      $L20000
        cmp     VHDCPRINTER,0
        jne     $L20001
$L20000:
        call    FAR PTR WINFAILURE
        jmp     $ScribRet       ; Scribble and return
;
; *************** EXIT POINT **********************************************
;
$L20001:

; Line 216
        ; *** bltc(&ifi, 0, cwIFI);
        ; ***/* This means:
                ; ***ifi.ich = 0;
                ; ***ifi.ichPrev = 0;
                ; ***ifi.ichFetch = 0;
                ; ***ifi.cchSpace = 0;
                ; ***ifi.ichLeft = 0;
        ; ****/

    ;                         *** macro bltc destroys ax,es,cx
        lea     dx,ifi
        bltc    dx,0,c_cwIFI
; Line 225
        mov     ifi._jc,c_jcTabLeft
; Line 226
        mov     ifi.fPrevSpace,c_True
; Line 230
        ; *** /* Set up some variables that have different value depending on
        ; *** whether we are printing or not */

        ; ***   if (fFlmPrinting)

        cmp     fFlmPrinting,0
        je      $NoPrint
; Line 232
        mov     ax,DXAPRPAGE
        mov     dxaFormat,ax
; Line 233
        mov     ax,DYAPRPAGE
        mov     dyaFormat,ax
; Line 234
        mov     ax,DXPPRPAGE
        mov     dxpFormat,ax
; Line 235
        mov     ax,DYPPRPAGE
        mov     dypFormat,ax
; Line 236
        mov     ax,YPSUBSUPERPR
        jmp     SHORT $CalcHgt

$NoPrint:
; Line 240
        mov     ax,c_czaInch
        mov     dyaFormat,ax
        mov     dxaFormat,ax
; Line 241
        mov     ax,DXPLOGINCH
        mov     dxpFormat,ax
; Line 242
        mov     ax,DYPLOGINCH
        mov     dypFormat,ax
; Line 243
        mov     ax,YPSUBSUPER

$CalcHgt:
        mov     ypSubSuperFormat,ax

        ; *** /* Calculate line height and width measures.  Compute
                ; *** xaLeft    left indent 0 means at left margin
                ; *** xaRight   width of column measured from left
                ; ***           margin (not from left indent).
        ; *** */
        ; *** xaLeft = ppap->dxaLeft;

; Line 251
; *********** Register variables ********************
        rbx_ppap EQU    bx
; ****************************************************
        mov     rbx_ppap,ppap
        mov     ax,[rbx_ppap].dxaLeft
        mov     xaLeft,ax
; Line 255

        ; *** /* If this is the first line of a paragraph,
        ; ***      adjust xaLeft for the first
        ; *** line indent.  (Also, set dypBefore, since its handy.) */
        ; *** if (cp == vcpFirstParaCache)

        mov     ax,WORD PTR VCPFIRSTPARACACHE
        mov     dx,WORD PTR VCPFIRSTPARACACHE+2
        cmp     SEG_cp,dx
        jne     $setMargins
        cmp     OFF_cp,ax
        jne     $setMargins
; Line 257
        mov     ax,[rbx_ppap].dxaLeft1
        add     xaLeft,ax
; Line 273
$setMargins:
; Line 274
        ; *** /* Now, set xaRight (width measured in twips). */

IFDEF CASHMERE
        test    WORD PTR [rbx_ppap].rhc,15
        je      $L20005
        mov     ax,WORD PTR VSEPPAGE.xaMac
        sub     ax,WORD PTR VSEPPAGE.dxaGutter
        jmp     SHORT $L20006
$L20005:
ENDIF

        mov     si,psep
        mov     ax,[si].dxaText
$L20006:
        sub     ax,[rbx_ppap].dxaRight
        mov     xaRight,ax
; Line 277
        ; *** /* Do necessary checks on xaLeft and xaRight */

; *********** Register variables ********************
        rcx_xaRightMax EQU      cx
; ****************************************************
        mov     rcx_xaRightMax,c_xaRightMax
        cmp     ax,rcx_xaRightMax
        jbe     $I859
; Line 279
        mov     xaRight,rcx_xaRightMax
; Line 281
$I859:
; *********** Register variables ********************
        rax_xaLeft EQU  ax
; ****************************************************
        mov     rax_xaLeft,xaLeft
        cmp     rax_xaLeft,rcx_xaRightMax
        jbe     $I861
; Line 283
        mov     xaLeft,rcx_xaRightMax
; Line 285
$I861:
        cmp     rax_xaLeft,0
        jge     $I863
; Line 287
        xor     rax_xaLeft,rax_xaLeft
        mov     xaLeft,rax_xaLeft
; Line 289
$I863:
        cmp     xaRight,rax_xaLeft
        jae     $I865
; Line 291
        inc     rax_xaLeft
        mov     xaRight,rax_xaLeft
; Line 294
$I865:
        push    xaLeft
        push    dxpFormat
        push    dxaFormat
        call    FAR PTR MULTDIV
        mov     ifi.xpLeft_Ifi,ax
        mov     ifi.xp,ax
        mov     WORD PTR VFLI.xpLeft_Fli,ax
; Line 295
        push    xaLeft
        push    DXPPRPAGE
        push    DXAPRPAGE
        call    FAR PTR MULTDIV
        mov     ifi.xpPr,ax
; Line 296
        push    xaRight
        push    dxpFormat
        push    dxaFormat
        call    FAR PTR MULTDIV
        mov     ifi.xpRight_Ifi,ax
        mov     WORD PTR VFLI.xpMarg,ax
; Line 297
        push    xaRight
        push    DXPPRPAGE
        push    DXAPRPAGE
        call    FAR PTR MULTDIV
        mov     ifi.xpPrRight,ax
; Line 300
        ; *** /* Get a pointer to the tab-stop table. */
        mov     ax,ppap
        add     ax,rgtbd
        mov     ptbd,ax
; Line 303
        ; *** /* Turn off justification. */
        cmp     fFlmPrinting,0
        je      $L20007
        mov     ax,VHDCPRINTER
        jmp     SHORT $L20008
$L20007:
        mov     ax,VHMDC
$L20008:
        push    ax
        xor     ax,ax
        push    ax
        push    ax
        call    FAR PTR SETTEXTJUSTIFICATION
; Line 306
        ; *** /* Initialize the line height information. */
        xor     ax,ax
        mov     dypDescentMac,ax
        mov     dypAscentMac,ax
; Line 309
        ; ***   /* To tell if there were any tabs */
        mov     ifi.ichLeft,65535
; Line 312
        ; *** /* Get the first run, and away we go... */
        push    doc
        push    SEG_cp
        push    OFF_cp
        push    ichCp
        jmp     SHORT $L20037

$NullRun:
; Line 357
        mov     ax,c_cpNil
        push    ax
        push    ax   ; high word of cpNil
        push    ax
        xor     ax,ax
        push    ax
$L20037:
        mov     ax,11
        push    ax
        call    FAR PTR FETCHCP
$FirstCps:
; Line 360
        mov     cchUsed,0
; Line 364
        ; *** /* Continue fetching runs until a run is found with a nonzero
        ; ***    length */
        mov     ax,VCCHFETCH
        mov     cch,ax
        or      ax,ax
        je      $NullRun
        mov     ax,VPCHFETCH
        mov     pch,ax
; Line 371
        mov     ax,WORD PTR VCPFETCH
        mov     dx,WORD PTR VCPFETCH+2
        cmp     SEG_cpMac,dx
        jg      $I886
        jl      $L20009
        cmp     OFF_cpMac,ax
        jbe     $L20009
	cmp	fFlmPrinting,0
	jne	$I886
	mov	bx,pch
	cmp	BYTE PTR [bx],c_chSect
	jne	$I886
$L20009:
; Line 374
        ; *** /* Force end mark to be in standard system font */
;                   *** macro blt destroys ax,bx,cx,es
        blt     <OFFSET VCHPNORMAL>,<OFFSET VCHPABS>,c_cwCHP
; Line 375
IFDEF SYSENDMARK
                ; *** vchpAbs.ftc = ftcSystem;
        mov     BYTE PTR VCHPABS.ftc,248       ; 0x3e << 2 == 0xF8 == 248
ELSE
                ; *** vchpAbs.ftc = 0;
        and     BYTE PTR VCHPABS.ftc,3
ENDIF
; Line 376
                ; *** vchpAbs.ftcXtra = 0;
        and     BYTE PTR VCHPABS.ftcXtra,248

                ; *** vchpAbs.hps = hpsDefault;
        mov     BYTE PTR VCHPABS.hps,c_hpsDefault
; Line 394
$I886:
              ; *** not from original c code: copy VCHPABS into chpLocal
              ; *** and use chpLocal hereafter ***********
;                   *** macro blt destroys ax,bx,cx,es
        lea     dx,chpLocal
        blt     <OFFSET VCHPABS>,dx,c_cwCHP
; Line 375
                ; *** vchpAbs.ftc = 0;
        cmp     fFlmPrinting,0
        je      $I888
; Line 396
        push    doc
        lea     ax,chpLocal
        push    ax
        mov     ax,3
        push    ax
        call    FAR PTR LOADFONT
; Line 397
        mov     ax,WORD PTR VFMIPRINT.dypAscent_Fmi
        add     ax,WORD PTR VFMIPRINT.dypLeading
        mov     dypAscent,ax
; Line 398
        mov     ax,WORD PTR VFMIPRINT.dypDescent_Fmi
        jmp     SHORT $L20038
$I888:
; Line 402
        push    doc
        lea     ax,chpLocal
        push    ax
        mov     ax,2
        push    ax
        call    FAR PTR LOADFONT
; Line 403
        mov     ax,WORD PTR VFMISCREEN.dypAscent_Fmi
        add     ax,WORD PTR VFMISCREEN.dypLeading
        mov     dypAscent,ax
; Line 404
        mov     ax,WORD PTR VFMISCREEN.dypDescent_Fmi
$L20038:
        mov     dypDescent,ax

ifdef ENABLE    /* BRYANL 8/27/27; see comment in C source */
        ; *** /* Bail out if there is a memory failure. */
        cmp     VFOUTOFMEMORY,0
        je      $I889
        jmp     $DoBreak
$I889:
endif   ; ENABLE 

; Line 408
        ; lines 408-417 removed
; Line 418
        ; ***   /* Floating line size algorithm */
        ; ***      if (chpLocal.hpsPos != 0)

        test    BYTE PTR chpLocal.hpsPos,-1
        je      $I895
; Line 421
                   ; *** /* Modify font for subscript/superscript */
        ; ***      if (chpLocal.hpsPos < hpsNegMin)

        mov     al,BYTE PTR chpLocal.hpsPos
        cmp     al,c_hpsNegMin
        jae     $I894
; Line 423
        mov     ax,ypSubSuperFormat
        add     dypAscent,ax
; Line 425
        jmp     SHORT $I895
$I894:
; Line 427
        mov     ax,ypSubSuperFormat
        add     dypDescent,ax
; Line 428
$I895:
                ; *** /* Update the maximum ascent and descent of the line. */
; Line 432
        mov     fSizeChanged,0
; Line 433
        mov     ax,dypDescent
        cmp     dypDescentMac,ax
        jge     $I896
; Line 435
        mov     dypDescentMac,ax
; Line 436
        mov     fSizeChanged,1
; Line 438
$I896:
        mov     ax,dypAscent
        cmp     dypAscentMac,ax
        jge     $I897
; Line 440
        mov     dypAscentMac,ax
; Line 441
        mov     fSizeChanged,1
; Line 444
;       dypUser EQU bp-88
;       dypAuto EQU bp-90
; *********** Register variables ********************
        rsi_dypAuto EQU si
        rdi_dypUser EQU di
; ****************************************************
$I897:
        cmp     fSizeChanged,0
        je      $OldRun
; Line 485
        mov     rsi_dypAuto,dypDescentMac
        add     rsi_dypAuto,dypAscentMac
; Line 487
        mov     bx,ppap
        mov	ax,WORD PTR [bx].dyaLine
	cmp	ax,c_czaLine
	jle	$I898
	push	ax
        push    dypFormat
        push    dyaFormat
        call    FAR PTR MULTDIV
        push    ax
        mov     ax,1
        push    ax
        call    FAR PTR IMAX
        mov     rdi_dypUser,ax
; Line 490
        cmp     rsi_dypAuto,rdi_dypUser
        jle     $L20011
$I898:
        mov     ifi.dypLineSize,rsi_dypAuto
        jmp     SHORT $L20012
$L20011:
        mov     ifi.dypLineSize,rdi_dypUser
$L20012:
; Line 496
$OldRun:
; Line 498
            ; *** /* Calculate length of the run but no greater than 256 */
        mov     ax,WORD PTR VCPFETCH
        sub     ax,WORD PTR VFLI
; Line 499
        cmp     ax,255
        jl      $I902
; Line 501
        mov     ax,254
; Line 503
$I902:
        mov     iichNew,ax
        sub     ax,ifi.ich_Ifi
        mov     dich,ax
; Line 509
                ; *** /* Ensure that all tab and non-required
                ; ***        hyphen characters start at
                ; *** beginning of run */
        cmp     WORD PTR $S784_ichpFormat,0
        jle     $L20013
        or      ax,ax
        jg      $L20013
        lea     ax,chpLocal
        push    ax
        mov     ax,10
        imul    WORD PTR $S784_ichpFormat
        mov     bx,VHGCHPFORMAT
        add     ax,[bx]
        sub     ax,10
        push    ax
        mov     ax,7
        push    ax
        call    FAR PTR CCHDIFFER
        or      ax,ax
        jne     $L20013
        mov     bx,pch
        cmp     BYTE PTR [bx],9
        je      $L20013
        cmp     BYTE PTR [bx],31
        je      $+5
        jmp     $I905
;       pchp EQU bp-92
;       register si=pchp
$L20013:
; Line 511
        mov     ax,ICHPMACFORMAT
        cmp     WORD PTR $S784_ichpFormat,ax
        jne     $L20014
        call    FGrowFormatHeap
        or      ax,ax
        jne     $+5
        jmp     $I905
$L20014:
; Line 514
; *********** Register variables ********************
        rsi_pchp EQU    si
; ****************************************************
        mov     ax,10
        imul    WORD PTR $S784_ichpFormat
        mov     rsi_pchp,ax
        sub     rsi_pchp,10
        mov     bx,VHGCHPFORMAT
        add     rsi_pchp,[bx]    ; si = pch
; Line 516
        cmp     WORD PTR $S784_ichpFormat,0
        jle     $I907
; Line 518
        mov     ax,ifi.ich_Ifi
        sub     ax,ifi.ichPrev
        mov     BYTE PTR [rsi_pchp].cchRun,al
; Line 519
        mov     al,BYTE PTR (ifi.ichPrev)
        mov     BYTE PTR [rsi_pchp].ichRun,al
; Line 521
$I907:
        add     rsi_pchp,10
;                   *** macro blt destroys ax,bx,cx,es
        mov     dx,rsi_pchp
        lea     ax,chpLocal  ; ax not destroyed in blt until after value used
        blt     ax,dx,c_cwCHP

; Line 529
        or      BYTE PTR [rsi_pchp].cchRun,255
; Line 530
        cmp     dich,0
        jg      $I908
; Line 532
        mov     al,BYTE PTR (ifi.ich_Ifi)
        jmp     SHORT $L20048
$I908:
; Line 537
                ; *** bltc (&vfli.rgdxp[ifi.ich],0,dich)

        mov     dx,ifi.ich_Ifi
        shl     dx,1
        add     dx,OFFSET VFLI.rgdxp
    ;                         *** macro bltc destroys ax,es,cx
        bltc    dx,0,dich
; Line 538
                ; *** bltbc (&vfli.rgch[ifi.ich],0,dich)
        mov     dx,ifi.ich_Ifi
        add     dx,OFFSET VFLI.rgch
                ;***  macro bltbc destroys ax,es,cx
        bltbc   dx,0,dich

; Line 539
        mov     ax,iichNew
        mov     ifi.ich_Ifi,ax
$L20048:
        mov     BYTE PTR [rsi_pchp].ichRun,al
; Line 541
        mov     ax,ifi.ich_Ifi
        mov     ifi.ichPrev,ax
; Line 542
        inc     WORD PTR $S784_ichpFormat
; Line 544
$I905:
; Line 546
        mov     ax,WORD PTR VCPFETCH
        mov     dx,WORD PTR VCPFETCH+2
        cmp     SEG_cpMac,dx
        jle     $+5
        jmp     $I911
        jl      $L20016
        cmp     OFF_cpMac,ax
        jbe     $+5
        jmp     $I911
$L20016:
; Line 549
        cmp     ifi.fPrevSpace,0
        je      $L20015
                        ; *** note ax:dx still holds vcpFetch
        cmp     SEG_cp,dx
        jne     $I912
        cmp     OFF_cp,ax
        jne     $I912
$L20015:
; Line 551
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichReal,ax
; Line 552
        mov     ax,ifi.xp
        mov     ifi.xpReal_Ifi,ax
        mov     WORD PTR VFLI.xpReal_Fli,ax
; Line 554
$I912:
        cmp     fFlmPrinting,0
        jne     $I913
        ;mov     ax,DOCHELP
        ;cmp     doc,ax
        ;je      $I913
; Line 556
        mov     bx,ifi.ich_Ifi
        mov     BYTE PTR VFLI.rgch[bx],c_chEmark
; Line 558
        mov     ax,c_chEmark
        push    ax
        xor     ax,ax
        push    ax
        call    FAR PTR DxpFromCh
        mov     bx,ifi.ich_Ifi
        inc     ifi.ich_Ifi
        shl     bx,1
        mov     WORD PTR VFLI.rgdxp[bx],ax
        add     WORD PTR VFLI.xpReal_Fli,ax
; Line 560
$I913:
        mov     ax,ifi.dypLineSize
        mov     WORD PTR VFLI.dypLine,ax
; Line 561
        mov     ax,dypDescentMac
        mov     WORD PTR VFLI.dypBase,ax
; Line 562
        mov     ax,dypAscentMac
        add     ax,dypDescentMac
        mov     WORD PTR VFLI.dypFont,ax
; Line 563
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichReal,ax
        mov     WORD PTR VFLI.ichMac,ax
; Line 564
        mov     ax,OFF_cpMac
        mov     dx,SEG_cpMac
        add     ax,1
        adc     dx,0
        mov     WORD PTR VFLI.cpMac_OFF,ax
        mov     WORD PTR VFLI.cpMac_SEG,dx
; Line 565
        jmp     $JustEol
$I911:
        mov     ax,ifi.ich_Ifi
        add     ax,cch
        cmp     ax,255
        jle     $I916
; Line 573
        mov     ax,255
        sub     ax,ifi.ich_Ifi
        mov     cch,ax
; Line 574
        mov     fTruncated,1
; Line 577
$I916:
        mov     ifi.ichFetch,0
; Line 603
                ; *** if (chpLocal.fSpecial)
        test    BYTE PTR chpLocal.fSpecial,mask_0100_0000
        jne     $+5
        jmp     $GetCh
; Line 605
        lea     ax,ifi
        push    ax
        push    flm
        mov     ax,WORD PTR VSEPABS
        mov     cl,11
        shr     ax,cl
        and     ax,7
        push    ax
        call    FAR PTR FFORMATSPECIALS
        or      ax,ax
        je      $+5
        jmp     $GetCh
; Line 607
        cmp     ifi.chBreak,0
        jne     $+5
        jmp     $Unbroken
$I986:
        mov     ax,ifi.ichFetch
        sub     ax,WORD PTR VFLI.cpMac_OFF
        add     ax,WORD PTR VCPFETCH
        mov     WORD PTR VFLI.dcpDepend,ax
; Line 1026
$JustBreak:
; Line 1027
        cmp     WORD PTR ifi.chBreak,31
        je      $+5
        jmp     $I992
; Line 1032
        mov     ax,45
        push    ax
        push    fFlmPrinting
        call    FAR PTR DxpFromCh  ; *** ax will have width of hyphen

                 ; **** up to line 1036 rearranged bz
        mov     bx,WORD PTR VFLI.ichReal
; Line 1035
        mov     WORD PTR VFLI.ichMac,bx  ; ** ichMac = ichReal

        dec     bx    ; ichReal - 1
        mov     BYTE PTR VFLI.rgch[bx],45 ; ** rgch[ichReal-1] = "-

        shl     bx,1
        mov     WORD PTR VFLI.rgdxp[bx],ax
        add     ifi.xpReal_Ifi,ax
; Line 1033
        mov     ax,ifi.xpReal_Ifi
        mov     WORD PTR VFLI.xpReal_Fli,ax
        mov     WORD PTR VFLI.xpRight,ax


; Line 1036
        mov     ax,WORD PTR $S784_ichpFormat
        dec     ax
        cmp     ichpNRH,ax
        jge     $I992
;       pchp EQU bp-112
; *********** Register variables ********************
        rdi_pchp EQU    di
; ****************************************************
;       register di=pchp
;       =-114
;       =-116
; Line 1039
                ; ** register struct CHP *pchp=&(**vhgchpFormat)[ichpNRH]
        mov     ax,10
        imul    ichpNRH
        mov     rdi_pchp,ax
        mov     bx,VHGCHPFORMAT
        add     rdi_pchp,[bx]
; Line 1041
                ; ** pchp->cchRun++;
        inc     BYTE PTR [rdi_pchp].cchRun
; Line 1042
                ; ** if (pchp->ichRun >= vfli.ichMac)
        mov     dx,WORD PTR VFLI.ichMac
        cmp     BYTE PTR [rdi_pchp].ichRun,dl
        jb      $I992
; Line 1044
                ; ** pchp->ichRun = vfli.ichMac - 1;
        dec     dx
        mov     BYTE PTR [rdi_pchp].ichRun,dl
; Line 1046
$I992:
; Line 1049
        cmp     fFlmPrinting,0
        je      $I993
; Line 1051
        mov     ax,WORD PTR VFLI.ichReal
        mov     WORD PTR VFLI.ichMac,ax
; Line 1057
$I993:
        cmp     ifi._jc,c_jcTabLeft
        jne     $+5
        jmp     $I994
; Line 1061
$L20051:
        lea     ax,ifi
        push    ax
        push    xpTab
        jmp     $L20046
;       ch=-94
; *********** Register variables ********************
        rsi_ch EQU      si
; ****************************************************
;       register si=ch
$I877:
; Line 625
        mov     bx,ifi.ichFetch
        inc     ifi.ichFetch
        mov     di,pch
        mov     al,[bx][di]
        sub     ah,ah
        mov     rsi_ch,ax
; Line 627
$NormChar:
; Line 628
        cmp     rsi_ch,c_chSpace
        jne     $NotSpace
; Line 632
        cmp     fFlmPrinting,0
        je      $L20017
        mov     ax,WORD PTR VFMIPRINT+2
        jmp     SHORT $L20018
$L20017:
        mov     ax,WORD PTR VFMISCREEN+2
$L20018:
        mov     dxp,ax
        mov     bx,ifi.ich_Ifi
        shl     bx,1
        mov     WORD PTR VFLI.rgdxp[bx],ax
        add     ifi.xp,ax
; Line 633
        mov     ax,WORD PTR VFMIPRINT+2
        mov     dxpPr,ax
        add     ifi.xpPr,ax
; Line 634
        mov     bx,ifi.ich_Ifi
        inc     ifi.ich_Ifi
        mov     BYTE PTR VFLI.rgch[bx],c_chSpace

; Line 635
        jmp     $BreakOppr

$NotSpace:
; Line 641
        cmp     rsi_ch,c_chSpace
        jl      $L20019
        cmp     rsi_ch,128
        jge     $L20019
        mov     bx,WORD PTR VFMIPRINT
        shl     rsi_ch,1
        mov     ax,WORD PTR [bx][rsi_ch]
        shr     rsi_ch,1
        mov     dxpPr,ax
        cmp     ax,dxpNil
        jne     $I928
$L20019:
; Line 643
        push    rsi_ch
        mov     ax,1
        push    ax
        call    FAR PTR DxpFromCh
        mov     dxpPr,ax
; Line 646
$I928:
        cmp     fFlmPrinting,0
        je      $I929
; Line 650
        mov     ax,dxpPr
        jmp     SHORT $L20045
$I929:
; Line 653
        cmp     rsi_ch,c_chSpace
        jl      $L20020
        cmp     rsi_ch,128
        jge     $L20020
        mov     bx,WORD PTR VFMISCREEN
        shl     rsi_ch,1
        mov     ax,WORD PTR [bx][rsi_ch]
        shr     rsi_ch,1
        mov     dxp,ax
        cmp     ax,dxpNil
        jne     $I931
$L20020:
; Line 654
        push    rsi_ch
        xor     ax,ax
        push    ax
        call    FAR PTR DxpFromCh
$L20045:
        mov     dxp,ax
; Line 656
$I931:
        mov     bx,ifi.ich_Ifi
        shl     bx,1
                ; *** here ax = dxp from above
        mov     WORD PTR VFLI.rgdxp[bx],ax
        add     ifi.xp,ax
; Line 657
        mov     ax,dxpPr
        add     ifi.xpPr,ax
; Line 658
        mov     bx,ifi.ich_Ifi
        inc     ifi.ich_Ifi
        mov     ax,rsi_ch
        mov     BYTE PTR VFLI.rgch[bx],al
; Line 662
        cmp     rsi_ch,45
        jle     $SwitchCh
; Line 1001
$DefaultCh:
; Line 1002
        mov     ax,ifi.xpPrRight
        cmp     ifi.xpPr,ax
        jle     $PChar
; Line 1003
$DoBreak:
; Line 1005
        cmp     ifi.chBreak,0
        je      $+5
        jmp     $I986
; Line 1006
$Unbroken:
; Line 1011
        mov     ax,ifi.ich_Ifi
        dec     ax
        push    ax
        call    FFirstIch
        or      ax,ax
        jne     $+5
        jmp     $I987
        cmp     ifi.ich_Ifi,255
        jl      $+5
        jmp     $I987
; Line 1013
$PChar:
; Line 1087
        mov     ifi.fPrevSpace,0
; Line 1089
        jmp     SHORT $GetCh

                ; ***** end for default case **************
$SwitchCh:
        mov     ax,rsi_ch
        cmp     ax,c_chSect
        jne     $+5
        jmp     $SC942
        jle     $+5
        jmp     $L20028
        cmp     ax,c_chTab
        jne     $+5
        jmp     $SC951
        cmp     ax,c_chEol
        jl      $DefaultCh
        cmp     ax,c_chNewLine
        jg      $+5
        jmp     $SC971
        jmp     SHORT $DefaultCh
$SC938:
; Line 671
        dec     ifi.ich_Ifi
; Line 672
        mov     ax,dxp
        sub     ifi.xp,ax
; Line 673
        mov     ax,dxpPr
        sub     ifi.xpPr,ax

        page
; Line 674
$GetCh:         ; ****** START of main FOR loop ********************
; Line 335
        mov     ax,cch
        cmp     ifi.ichFetch,ax
        je      $+5
        jmp     $I877
; Line 341
        cmp     ifi.ich_Ifi,255
        jge     $DoBreak
; Line 344
        cmp     fTruncated,0
        jne     $+5
        jmp     $NullRun
; Line 349
        add     cchUsed,ax
; Line 350
        mov     ax,cchUsed
        add     ax,VPCHFETCH
        mov     pch,ax
; Line 351
        mov     ax,VCCHFETCH
        sub     ax,cchUsed
        mov     cch,ax
; Line 352
        mov     fTruncated,0
; Line 353
        jmp     $OldRun
$SC939:
; Line 679
        dec     ifi.ich_Ifi
; Line 680
        mov     ax,dxp
        sub     ifi.xp,ax
; Line 681
        mov     ax,dxpPr
        sub     ifi.xpPr,ax
; Line 683
        mov     ax,WORD PTR $S784_ichpFormat
        dec     ax
        mov     ichpNRH,ax
; Line 684
        mov     ax,c_chHyphen
        push    ax
        mov     ax,1
        push    ax
        call    FAR PTR DxpFromCh
        add     ax,ifi.xpPr
        cmp     ax,ifi.xpPrRight
        jle     $+5
        jmp     $DoBreak
; Line 687
        mov     ax,ifi.xp
        mov     xpPrev,ax
; Line 700
        mov     bx,ifi.ich_Ifi
        mov     BYTE PTR VFLI.rgch[bx],c_chTab
; Line 701
        jmp     $Tab0
$SC942:
; Line 705
        dec     ifi.ich_Ifi
; Line 706
        mov     ax,dxp
        sub     ifi.xp,ax
; Line 707
        mov     ax,dxpPr
        sub     ifi.xpPr,ax
; Line 710
        mov     ax,dypDescentMac
        mov     WORD PTR VFLI.dypBase,ax
        add     ax,dypAscentMac
        mov     WORD PTR VFLI.dypLine,ax
        mov     WORD PTR VFLI.dypFont,ax
; Line 711
        mov     ax,ifi.ichFetch
        cwd
        add     ax,WORD PTR VCPFETCH
        adc     dx,WORD PTR VCPFETCH+2
        mov     WORD PTR VFLI.cpMac_OFF,ax
        mov     WORD PTR VFLI.cpMac_SEG,dx
; Line 712
        push    ifi.ich_Ifi
        call    FFirstIch
        or      ax,ax
        jne     $+5
        jmp     $I943
; Line 715
        mov     ax,WORD PTR VFLI.fSplat
        mov     al,1
        mov     WORD PTR VFLI.fSplat,ax
; Line 716
        cmp     fFlmPrinting,0
        je      $+5
        jmp     $I944
        ;chT EQU bp-96
        ;cch EQU bp-98
        ;dxpCh EQU bp-100
; Line 723
        mov     chT,c_chSplat
; Line 726
        push    chT
        xor     ax,ax
        push    ax
        call    FAR PTR DxpFromCh
        mov     dxpCh,ax
; Line 730
        mov     ax,17
        imul    DXPLOGINCH
        cwd
        sub     ax,dx
        sar     ax,1
        cwd
        mov     cx,dxpCh
        idiv    cx
        cmp     ax,223
        jge     $L20021
        jmp     SHORT $L20022
$L20021:
        mov     ax,223
$L20022:
        mov     cch2,ax
; Line 732
               ; ***             bltbc(&vfli.rgch[ifi.ich], chT, cch);
        mov     dx,ifi.ich_Ifi
        add     dx,OFFSET VFLI.rgch
                 ;***  macro bltbc destroys ax,es,cx
        bltbc   dx,<BYTE PTR (chT)>,cch2
; Line 733
               ; ***             bltc(&vfli.rgdxp[ifi.ich], dxpCh, cch);
        mov     dx,ifi.ich_Ifi
        shl     dx,1
        add     dx,OFFSET VFLI.rgdxp
    ;                         *** macro bltc destroys ax,es,cx
        bltc    dx,dxpCH,cch2
; Line 734
        mov     ax,ifi.ich_Ifi
        add     ax,cch2
        mov     WORD PTR VFLI.ichMac,ax
; Line 736
        push    VHMDC
        mov     ax,OFFSET VFLI.rgch
        push    ds
        push    ax
        push    cch2
        call    FAR PTR GETTEXTEXTENT
        mov     WORD PTR VFLI.xpReal_Fli,ax
; Line 737
        mov     WORD PTR VFLI.xpLeft_Fli,0
; Line 739
        jmp     $EndFormat
$I944:
; Line 741
        mov     WORD PTR VFLI.ichMac,0
; Line 743
        jmp     $EndFormat
$I943:
        mov     WORD PTR VFLI.fSplatNext, 1

        mov     ax,cchUsed
        dec     ax
        cwd
        add     WORD PTR VFLI.cpMac_OFF,ax
        adc     WORD PTR VFLI.cpMac_SEG,dx
; Line 749
        mov     WORD PTR VFLI.dcpDepend,1
; Line 750
        cmp     ifi.fPrevSpace,0
        jne     $I950
; Line 752
        mov     ax,ifi.cchSpace
        mov     ifi.cBreak_Ifi,ax
; Line 753
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichReal,ax
; Line 754
        mov     ax,ifi.xp
        mov     ifi.xpReal_Ifi,ax
        mov     WORD PTR VFLI.xpReal_Fli,ax
; Line 756
$I950:
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichMac,ax
; Line 757
        mov     ax,ifi.dypLineSize
        mov     WORD PTR VFLI.dypLine,ax
; Line 758
        jmp     $JustBreak
$SC951:
; Line 762
        dec     ifi.ich_Ifi
; Line 763
        mov     ax,dxp
        sub     ifi.xp,ax
; Line 764
        mov     ax,dxpPr
        sub     ifi.xpPr,ax
        ;xaTab EQU bp-102
        ;xaPr EQU bp-104
;       pchp EQU bp-106
;       register di=pchp
; Line 766
        mov     ax,ifi.xpPrRight
        cmp     ifi.xpPr,ax
        jl      $+5
        jmp     $I952
; Line 772
        cmp     ifi.fPrevSpace,0
        jne     $I956
; Line 776
        mov     ax,ifi.cchSpace
        mov     ifi.cBreak_Ifi,ax
; Line 777
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichReal,ax
; Line 778
        mov     ax,ifi.xp
        mov     ifi.xpReal_Ifi,ax
; Line 781
$I956:
        cmp     ifi._jc,c_jcTabLeft
        je      $I957
; Line 783
        lea     ax,ifi
        push    ax
        push    xpTab
        push    flm
        call    Justify
; Line 785
$I957:
        mov     ax,ifi.xp
        mov     xpPrev,ax
; Line 788
        push    ifi.xpPr
        push    DXAPRPAGE
        push    DXPPRPAGE
        call    FAR PTR MULTDIV
        mov     xaPr,ax
; Line 789
        jmp     SHORT $L20041
$WC958:
        mov     ax,xaRight
        cmp     xaTab,ax
        jb      $I959
        mov     xaTab,ax
$I959:
; Line 791
        mov     ax,xaPr
        cmp     xaTab,ax
        jb      $I960
; Line 799
        add     ptbd,4
        mov     al, [bx].jc_Tbd
        sub     ah,ah
        and     ax,7
        add     ax,c_jcTabMin
;#ifdef ENABLE /* we do the mapping in HgtbdCreate */
;        cmp    ax,c_jcTabDecimal
;        je     $I1958
;        mov    ax,c_jcTabLeft
;#endif
$I1958:
        mov     ifi._jc,ax
; Line 800
        jmp     SHORT $TabFound
$I960:
        add     ptbd,4
; Line 803
$L20041:
        mov     bx,ptbd
        mov     ax,[bx]
        mov     xaTab,ax
        or      ax,ax
        jne     $WC958
; Line 806
        mov     ax,xaPr
        sub     dx,dx
        mov     cx,WORD PTR VZATABDFLT
        div     cx
        mul     cx
        add     ax,cx
        mov     xaTab,ax
; Line 812
        mov     ifi._jc,c_jcTabLeft
; Line 814
$TabFound:
; Line 815
        push    xaTab
        push    dxpFormat
        push    dxaFormat
        call    FAR PTR MULTDIV
        cmp     ifi.xp,ax
        jle     $I1961
        mov     ax,ifi.xp
$I1961:
        mov     xpTab,ax
; Line 822
        cmp     ifi._jc,c_jcTabLeft
        jne     $I962
; Line 825
        mov     ifi.xp,ax
; Line 826
        push    xaTab
        push    DXPPRPAGE
        push    DXAPRPAGE
        call    FAR PTR MULTDIV
        mov     ifi.xpPr,ax
; Line 828
$I962:
        mov     ax,ifi.xp
        mov     ifi.xpLeft_Ifi,ax
; Line 829
        mov     ax,ifi.ich_Ifi
        mov     ifi.ichLeft,ax
; Line 830
        mov     ifi.cchSpace,0
; Line 831
        mov     ifi.chBreak,0
; Line 832
$Tab0:
; Line 833
        mov     ifi.fPrevSpace,0
; Line 834
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichMac,ax
; Line 835
        mov     ax,ifi.xp
        mov     WORD PTR VFLI.xpReal_Fli,ax
; Line 836
        mov     ax,ifi.dypLineSize
        mov     WORD PTR VFLI.dypLine,ax
; Line 837
        mov     ax,dypDescentMac
        mov     WORD PTR VFLI.dypBase,ax
; Line 838
        mov     ax,dypAscentMac
        add     ax,dypDescentMac
        mov     WORD PTR VFLI.dypFont,ax
; Line 841
        cmp     ifi.ichFetch,1
        je      $I963
        mov     ax,ICHPMACFORMAT
        cmp     WORD PTR $S784_ichpFormat,ax
        jne     $L20023
        call    FGrowFormatHeap
        or      ax,ax
        je      $I963
$L20023:
; Line 845
; *********** Register variables ********************
;       rdi_pchp EQU    di
; ****************************************************
;       register di=pchp
        mov     ax,10
        imul    WORD PTR $S784_ichpFormat
        mov     rdi_pchp,ax
        sub     rdi_pchp,10
        mov     bx,VHGCHPFORMAT
        add     rdi_pchp,[bx]
; Line 846
        cmp     WORD PTR $S784_ichpFormat,0
        jle     $I964
; Line 849
        mov     al,BYTE PTR (ifi.ichPrev)
        mov     BYTE PTR [rdi_pchp].ichRun,al
; Line 850
        mov     ax,ifi.ich_Ifi
        sub     ax,ifi.ichPrev
        mov     BYTE PTR [rdi_pchp].cchRun,al
; Line 853
$I964:
        add     rdi_pchp,10     ; ** ++pchp
        lea     ax,chpLocal  ; ax not destroyed in blt until after value used
                   ;*** macro blt destroys ax,bx,cx,es
        blt     ax,rdi_pchp,c_cwCHP

; Line 854
        inc     WORD PTR $S784_ichpFormat
; Line 856
        jmp     SHORT $I965
$I963:
; Line 858
        mov     ax,10
        imul    WORD PTR $S784_ichpFormat
        mov     rdi_pchp,ax
        sub     rdi_pchp,10
        mov     bx,VHGCHPFORMAT
        add     rdi_pchp,[bx]
; Line 859
$I965:
; Line 860
        mov     al,BYTE PTR (ifi.ich_Ifi)
        mov     BYTE PTR [rdi_pchp].ichRun,al
; Line 861
        or      BYTE PTR [rdi_pchp].cchRun,255

; Line 867
        mov     bx,ifi.ich_Ifi
        inc     ifi.ich_Ifi
        mov     ifi.ichPrev,bx
        shl     bx,1
        mov     ax,ifi.xp
        sub     ax,xpPrev
        mov     WORD PTR VFLI.rgdxp[bx],ax
; Line 869
        cmp     rsi_ch,c_chTab
        jne     $BreakOppr
        jmp     $GetCh
$I952:
; Line 878
        mov     rsi_ch,160
; Line 879
        jmp     $NormChar
$SC968:
; Line 883
        mov     ax,ifi.xpPrRight
        cmp     ifi.xpPr,ax
        jle     $+5
        jmp     $DoBreak
; Line 885
$BreakOppr:
; Line 891
        cmp     ifi.ich_Ifi,255
        jl      $+5
        jmp     $Unbroken
; Line 893
$SC971:
; Line 898
        mov     ifi.chBreak,rsi_ch
; Line 899
        mov     ax,ifi.ichFetch
        add     ax,cchUsed
        cwd
        add     ax,WORD PTR VCPFETCH
        adc     dx,WORD PTR VCPFETCH+2
        mov     WORD PTR VFLI.cpMac_OFF,ax
        mov     WORD PTR VFLI.cpMac_SEG,dx
; Line 900
        mov     ax,ifi.xp
        mov     WORD PTR VFLI.xpReal_Fli,ax
; Line 901
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichMac,ax
; Line 902
        mov     ax,ifi.dypLineSize
        mov     WORD PTR VFLI.dypLine,ax
; Line 904
        mov     ax,dypDescentMac
        mov     WORD PTR VFLI.dypBase,ax
        add     ax,dypAscentMac
        mov     WORD PTR VFLI.dypFont,ax
; Line 906
        cmp     rsi_ch,45
        je      $L20024
        cmp     rsi_ch,31
        jne     $I972
$L20024:
; Line 908
        mov     ax,ifi.cchSpace
        mov     ifi.cBreak_Ifi,ax
; Line 909
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichReal,ax
; Line 910
        mov     ax,ifi.xp
        mov     ifi.xpReal_Ifi,ax
        mov     WORD PTR VFLI.xpReal_Fli,ax
; Line 912
        jmp     $GetCh
$I972:
; Line 914
        cmp     ifi.fPrevSpace,0
        jne     $I974
; Line 916
        mov     ax,ifi.cchSpace
        mov     ifi.cBreak_Ifi,ax
; Line 917
        mov     ax,ifi.ich_Ifi
        dec     ax
        mov     WORD PTR VFLI.ichReal,ax
; Line 918
        mov     ax,ifi.xp
        mov     WORD PTR VFLI.xpReal_Fli,ax
        sub     ax,dxp
        mov     ifi.xpReal_Ifi,ax
; Line 920
        ;chT EQU bp-108
        ;dxpNew EQU bp-110
$I974:
        cmp     rsi_ch,10
        je      $L20025
        cmp     rsi_ch,11
        jne     $I975
$L20025:
; Line 943
        mov     chT2,c_chSpace
; Line 946
        push    chT2
        push    fFlmPrinting
        call    FAR PTR DxpFromCh
                ; *** ax will contain dxpNew at this point ****
; Line 948
        mov     bx,ifi.ich_Ifi
        mov     dl,BYTE PTR (chT2)
        mov     BYTE PTR VFLI.rgch[bx-1],dl
; Line 950
        shl     bx,1
                ;** difference was -1 in c - shifted to get -2
        mov     WORD PTR VFLI.rgdxp[bx-2],ax   ; ax has dxpNew

        cmp     ifi.fPrevSpace,0   ; only reset vfli.xp/ich real if not prev sp
        jne     $TestEol

        sub     ax,dxp
        add     WORD PTR VFLI.xpReal_Fli,ax
; Line 956
        mov     ax,ifi.ich_Ifi
        dec     ax
        mov     WORD PTR VFLI.ichReal,ax
; Line 961
$TestEol:
        cmp     rsi_ch,10
        je      $+5
        jmp     $JustBreak
; Line 963
$JustEol:
; Line 964
        cmp     fFlmPrinting,0
        je      $I979
; Line 966
        mov     ax,WORD PTR VFLI.ichReal
        mov     WORD PTR VFLI.ichMac,ax
; Line 972
$I979:
        cmp     ifi._jc,c_jcTabLeft
        je      $+5
        jmp     $L20051
; Line 980
        mov     bx,ppap
        mov     al,BYTE PTR [bx].jc_Pap
        and     ax,3        ; pick up low 2 bits in ax
        mov     ifi._jc,ax
        cmp     ax,3
        je      $I996
        jmp     SHORT $L20050
$I975:
        inc     ifi.cchSpace
; Line 995
        mov     ifi.fPrevSpace,1
; Line 1093
        jmp     $GetCh
$I987:
        mov     ax,ifi.ichFetch
        add     ax,cchUsed
        cwd
        add     ax,WORD PTR VCPFETCH
        adc     dx,WORD PTR VCPFETCH+2
        sub     ax,1
        sbb     dx,0
        mov     WORD PTR VFLI.cpMac_OFF,ax
        mov     WORD PTR VFLI.cpMac_SEG,dx
; Line 1016
        mov     ax,ifi.ich_Ifi
        dec     ax
        mov     WORD PTR VFLI.ichMac,ax
        mov     WORD PTR VFLI.ichReal,ax
; Line 1017
        mov     ax,ifi.dypLineSize
        mov     WORD PTR VFLI.dypLine,ax
; Line 1019
        mov     ax,dypDescentMac
        mov     WORD PTR VFLI.dypBase,ax
        add     ax,dypAscentMac
        mov     WORD PTR VFLI.dypFont,ax
; Line 1020
        mov     WORD PTR VFLI.dcpDepend,1
; Line 1021
        mov     ax,ifi.xp
        sub     ax,dxp
	mov	ifi.xpReal_Ifi,ax
        mov     WORD PTR VFLI.xpReal_Fli,ax
$I994:
        mov     bx,ppap
        mov     al,BYTE PTR [bx].jc_Pap
        and     ax,3
        mov     ifi._jc,ax
$L20050:
        or      ax,ax
        je      $I996
; Line 1065
        lea     ax,ifi
        push    ax
        push    ifi.xpRight_Ifi
$L20046:
        push    flm
        call    Justify
; Line 1067
$I996:
        mov     ax,ifi.xpRight_Ifi
$L20043:
        mov     WORD PTR VFLI.xpRight,ax
; Line 1068
$EndFormat:
; Line 1069
        mov     ax,ifi.ichLeft
        mov     WORD PTR VFLI.ichLastTab,ax
        jmp     SHORT $ScribRet ; Scribble and return
$L20028:
        cmp     ax,13
        jne     $+5
        jmp     $SC938
        cmp     ax,31
        jne     $+5
        jmp     $SC939
        cmp     ax,45
        jne     $+5
        jmp     $SC968
        jmp     $DefaultCh
$ScribRet:
IFDEF DEBUG
IFDEF SCRIBBLE
        mov     ax,5
        push    ax
        mov     ax,c_chSpace
        push    ax
        call    FAR PTR FNSCRIBBLE
ENDIF
ENDIF
; Line 1096
$RetFormat:
        cEnd FormatLine

        subttl Justify()
        page
; ***
;  Function Justify
;
;  near Justify(pifi, xpTab, flm)
;  struct IFI *pifi;
;  unsigned xpTab;
;  int flm;
;
; ***

; Line 1101
        cProc Justify,<PUBLIC,NEAR>,<di,si>
                parmDP  pifi
                parmW   xpTab
                parmW   flm

                LocalW  cWideSpaces
                LocalW  cxpQuotient
; *********** Register variables ********************
        rbx_pifi        EQU     bx
        rdx_dxp         EQU     dx
; ****************************************************
        cBegin Justify
; Line 1109
        mov     rbx_pifi,pifi
; Line 1110
        mov     ax,[rbx_pifi]._jc
        cmp     ax,c_jcBoth
        je      $JcBothCase
        cmp     ax,c_jcCenter
        je      $JcCenterCase
        cmp     ax,c_jcRight
        je      $JcRightCase
        cmp     ax,c_jcTabDecimal
        jne     $JustCaseBrk
; Line 1130
JcTabDecCase:
; *********** Register variables ********************
        rsi_ichT        EQU     si
; ****************************************************
        mov     rdx_dxp,xpTab
        sub     rdx_dxp,[rbx_pifi].xpLeft_Ifi
; Line 1132
        mov     rsi_ichT,[rbx_pifi].ichLeft
        inc     rsi_ichT
$TabDecFor:
        cmp     rsi_ichT,WORD PTR VFLI.ichReal
        jge     $JustCaseBrk
	mov     al,VCHDECIMAL
        cmp     BYTE PTR VFLI.rgch[rsi_ichT],al
        je      $JustCaseBrk
; Line 1134
        shl     rsi_ichT,1
        sub     rdx_dxp,WORD PTR VFLI.rgdxp[rsi_ichT]
        shr     rsi_ichT,1
; Line 1135
        inc     rsi_ichT
        jmp     SHORT $TabDecFor

$JcCenterCase:
; Line 1139
        mov     rdx_dxp,xpTab
        sub     rdx_dxp,[rbx_pifi].xpReal_Ifi
        or      rdx_dxp,rdx_dxp
        jg      $+5
        jmp     $JustifyRet
                ; **** EXIT POINT *****************************
; Line 1141
        sar     rdx_dxp,1
; Line 1144

$JustCaseBrk:
; Line 1212
        cmp     rdx_dxp,0
        jle     $+5
        jmp     $JustCleanup
; Line 1215
        jmp     $JustifyRet
                ; **** EXIT POINT *****************************

$JcRightCase:
; Line 1147
        mov     rdx_dxp,xpTab
        sub     rdx_dxp,[rbx_pifi].xpReal_Ifi
; Line 1148
        jmp     SHORT $JustCaseBrk

$JcBothCase:
; *********** Register variables ********************
        rdi_pch         EQU     di
        rsi_pdxp        EQU     si
; ***************************************************
                ; **** NOTE: the only way out of this section of code
                ; **** is through a RETURN of function Justify
; Line 1151
        cmp     WORD PTR [rbx_pifi].cBreak_Ifi,0
        jne     $+5
        jmp     $JustifyRet
                ; **** EXIT POINT *****************************
; Line 1154
        mov     rdx_dxp,xpTab
        sub     rdx_dxp,[rbx_pifi].xpReal_Ifi
        or      rdx_dxp,rdx_dxp
        jg      $+5
        jmp     $JustifyRet
                ; **** EXIT POINT *****************************
; Line 1160
        add     [rbx_pifi].xp,rdx_dxp
; Line 1164
        add     WORD PTR VFLI.xpReal_Fli,rdx_dxp
; Line 1165
; Line 1176
                ; register CHAR *pch = &vfli.rgch[vfli.ichReal]
                ; register int *pdxp = &vfli.rgdxp[vfli.ichReal]

        mov     rdi_pch,WORD PTR VFLI.ichReal
        mov     rsi_pdxp,rdi_pch

        add     rdi_pch,OFFSET VFLI.rgch

        shl     rsi_pdxp,1
        add     rsi_pdxp,OFFSET VFLI.rgdxp

   ; ************ dx /(dxp) will be wiped out and restored here !!!!!!!!!!!!!!!
        push    dx              ; save for use as dxpT

        mov     ax,dx          ; ** set up division
        cwd
        mov     cx,[rbx_pifi].cBreak_Ifi
        idiv    cx
        mov     WORD PTR VFLI.dxpExtra,ax
                ; ** at this point:
                ; **  ax = quotient, dx = remainder, cx = cbreak
        inc     ax

; *********** Register variables ********************
        rdx_dxpT        EQU     dx
; ***************************************************

        mov     cxpQuotient,ax
        mov     cWideSpaces,dx

        pop     dx              ; restore for use as dxpT

; Line 1183
        mov     BYTE PTR VFLI.fAdjSpace,c_True
; Line 1185
        ; ***** NOTE: the only way out of this loop is via a RETURN out of
        ; *****       function Justify
        ; * the immediately following loop accomplishes about the same thing as
; ** Loop:
        ;   dec rdi_pch
        ;   sub rsi_pdxp,2
        ;   cmp BYTE PTR [rdi_pch],c_chSpace
        ;   jne Loop
        ; * it should be faster for strings of > 2 characters.

        dec     rdi_pch  ; since predecrement to start pch correctly
        mov     ax,ds
        mov     es,ax   ; set up for string instruction
        std             ; use reverse direction for decrementing di
$JstForLoop:
        mov     cx,-1   ; counter set up 1 below (trick)
        mov     al,c_chSpace    ; comparison value
        repnz   scasb           ; dec di while not = space
        inc     cx              ; restore from original -1
        shl     cx,1            ; si is a word ptr  - double offset
        add     rsi_pdxp,cx
                                ; at this point, pch points 1 below
                                ; the character containing the space,
                                ; pdxp points to the entry for the space char
; Line 1192
        mov     ax,cWideSpaces
        dec     cWideSpaces
        or      ax,ax
        jne     $I1032
; Line 1194
        dec     cxpQuotient
; Line 1195
	push	rsi_pdxp	; find first nonzero ich after pch
	cld
$FindIch1:
	inc	rsi_pdxp
	inc	rsi_pdxp
	cmp	WORD PTR [rsi_pdxp],0
	je	$FindIch1
        mov     ax,rsi_pdxp
        sub     ax,OFFSET VFLI + rgdxp
	shr	ax,1
	std
	pop	rsi_pdxp

        mov     BYTE PTR VFLI.ichFirstWide,al

; Line 1197
$I1032:
        mov     ax,cxpQuotient
        add     [rsi_pdxp],ax
; Line 1198
        sub     rdx_dxpT,ax
        cmp     rdx_dxpT,0
        jg      $I1033
; Line 1200
        cmp     WORD PTR [rbx_pifi].cBreak_Ifi,1
        jle     $JustifyRet
                ; **** EXIT POINT *****************************
; Line 1202
	push	rsi_pdxp	; find first nonzero ich after pch
	cld
$FindIch2:
	inc	rsi_pdxp
	inc	rsi_pdxp
	cmp	WORD PTR [rsi_pdxp],0
	je	$FindIch2
        mov     ax,rsi_pdxp
        sub     ax,OFFSET VFLI + rgdxp
	shr	ax,1
	pop	rsi_pdxp

        mov     BYTE PTR VFLI.ichFirstWide,al
; Line 1204
        jmp     SHORT $JustifyRet
                ; **** EXIT POINT *****************************
$I1033:
        dec     WORD PTR [rbx_pifi].cBreak_Ifi
; Line 1208
        jmp     SHORT $JstForLoop  ; *** end of for loop **********


; *********** Register variables ********************
        rbx_pifi        EQU     bx
        rdx_dxp         EQU     dx
; ****************************************************

$JustCleanup:
        add     [rbx_pifi],rdx_dxp
        mov     ax,rdx_dxp
; Line 1220
        test    flm,1   ;* if (flm & flmPrinting)
        jne     $L20052
; Line 1228
        push    rdx_dxp     ; save - wiped out by multiply

        push    rdx_dxp
        mov     ax,c_czaInch
        push    ax
        push    DXPLOGINCH
        call    FAR PTR MULTDIV
        push    ax
        push    DXPPRPAGE
        push    DXAPRPAGE
        call    FAR PTR MULTDIV

        mov     rbx_pifi,pifi   ; restore in case multdiv wipes out bx
        pop     rdx_dxp     ; restore - wiped out by multdiv
$L20052:
        add     [rbx_pifi].xpPr,ax
; Line 1231
        cmp     WORD PTR [rbx_pifi].ichLeft,0
        jge     $I1038
; Line 1234
        add     WORD PTR VFLI.xpLeft_Fli,rdx_dxp
; Line 1236
        jmp     SHORT $I1039
$I1038:
; Line 1239
        mov     bx,[rbx_pifi].ichLeft ; *** here, bx is no longer pifi ****
        shl     bx,1
        add     WORD PTR VFLI.rgdxp[bx],rdx_dxp
; Line 1240
$I1039:
; Line 1241
        add     WORD PTR VFLI.xpReal_Fli,rdx_dxp
; Line 1242
$JustifyRet:
        cld     ; reset to be nice to later routines
        cEnd Justify


; Line 1247
        subttl FGrowFormatHeap()
        page

; ***
;  Function FGrowFormatHeap
;
;  int near FGrowFormatHeap()
;      /* Grow vhgchpFormat by 20% */
;
; ***

        cProc FGrowFormatHeap,<PUBLIC,NEAR>
        cBegin FGrowFormatHeap

; *********** Register variables ********************
        rsi_cchpIncr    EQU     si
; ****************************************************

; Line 1249
        mov     ax,ICHPMACFORMAT
        cwd
        mov     cx,5
        idiv    cx
        inc     ax
        mov     rsi_cchpIncr,ax
; Line 1255
        push    VHGCHPFORMAT
        add     ax,ICHPMACFORMAT
        imul    cx
        push    ax
        xor     ax,ax
        push    ax
        call    FAR PTR FCHNGSIZEH
        or      ax,ax
        jne     $I1043
; Line 1260
        xor     ax,ax
        jmp     SHORT $EX1040
$I1043:
        add     ICHPMACFORMAT,rsi_cchpIncr
; Line 1263
        mov     ax,1
$EX1040:
        cEnd    FGrowFormatHeap


; Line 1269
        subttl DxpFromCh()
        page

; ***
;  Function DxpFromCh
;
;  int DxpFromCh(ch, fPrinter)
;  int ch;
;  int fPrinter;
;
; ***


        cProc DxpFromCh,<PUBLIC,FAR>
                parmW   chIn
                parmW   fPrinter

                LocalW  dxpDummy
                LocalW  dxp
        cBegin DxpFromCh

; *********** Register variables ********************
        rbx_pdxp        EQU     bx
; ****************************************************

; Line 1276
        cmp     chIn,c_chSpace
        jg      $L20029
	cmp	chIn,c_chNRHFile
	jge	$L20026
	cmp	chIn,c_chTab
	jl	$L2029A
	cmp	chIn,c_chReturn
	jg	$L2029A
$L20026:
        cmp     fPrinter,0
        je      $L20027
        mov     rbx_pdxp,OFFSET VFMIPRINT+2
        jmp     SHORT $I1050
$L20027:
        mov     rbx_pdxp,OFFSET VFMISCREEN+2
        jmp     SHORT $I1050
$L20029:
        cmp     chIn,256    ; prev 128 (chFmiMax)  ..pault 
                            ; We now make sure the whole character set width 
                            ; table is queried initially via GetCharWidth()
        jl      $I1049
; Line 1279
$L2029A:
        lea     rbx_pdxp,dxpDummy
; Line 1280
        mov     WORD PTR [rbx_pdxp],dxpNil
; Line 1282
        jmp     SHORT $I1050
$I1049:
; Line 1285
        cmp     fPrinter,0
        je      $L20030
        mov     rbx_pdxp,WORD PTR VFMIPRINT
        jmp     SHORT $L20031
$L20030:
        mov     rbx_pdxp,WORD PTR VFMISCREEN
$L20031:
        mov     ax,chIn
        shl     ax,1
        add     rbx_pdxp,ax
; Line 1286
$I1050:
; Line 1288
        cmp     WORD PTR [rbx_pdxp],dxpNil
        jne     $I1051
; Line 1295
        push    bx              ; save pdxp

        cmp     fPrinter,0
        je      $L20032
        push    VHDCPRINTER
        lea     ax,chIn
        push    ss
        push    ax
        mov     ax,1
        push    ax
        call    FAR PTR GETTEXTEXTENT
        sub     ax,WORD PTR VFMIPRINT+4
        jmp     SHORT $L20033
$L20032:
        push    VHMDC
        lea     ax,chIn
        push    ss
        push    ax
        mov     ax,1
        push    ax
        call    FAR PTR GETTEXTEXTENT
        sub     ax,WORD PTR VFMISCREEN+4
$L20033:
        pop     bx              ; restore pdxp
; Line 1297
        ;or      ax,ax   ; ax == dxp
        ;jl      $I1053
        ;cmp     ax,dxpNil
        ;jge     $I1053
; Line 1300
        mov     [rbx_pdxp],ax
; Line 1303
$I1053:
        jmp     SHORT $DxpRet
$I1051:
        mov     ax,WORD PTR [rbx_pdxp]
$DxpRet:
        cEnd    DxpFromCh

        subttl FFirstIch()
        page
; Line 1312

; ***
;  Function FFirstIch
;
;  int near FFirstIch(ich)
;  int ich;
;    {
;      /* Returns true iff ich is 0 or preceded only by 0 width characters */
;
;   REGISTER USAGE ******************************
;      uses and restores: di
;      uses and destroys: ax, cx, es
;      ax = temp, return
;      cx = ich
;      di = pdxp
;
;  Note: this implements, in a different manner, the c code:
;
;     for (ichT = 0; ichT < ich; ichT++)
;        {
;          if (*pdxp++)
;             return false
;         }
;    return true;
; ***

        cProc FFirstIch,<PUBLIC,NEAR>,<di>
                parmW   ich

        cBegin FFirstIch

; *********** Register variables ********************
        rdi_pdxp        EQU     di
        rcx_ich EQU     cx
; ****************************************************
; Line 1316
        mov     ax,ds   ; set es=ds for string ops
        mov     es,ax

        mov     rdi_pdxp,OFFSET VFLI.rgdxp
        mov     rcx_ich,ich     ; loop count in cx
        cld

        xor     ax,ax         ; this does 3 things:
                                ;  - sets up the compare value for scasb
                                ;  - sets a 0 (false) default return value
                                ;  - sets the zero flag on. This will allow
                                ; a zero value of ich to correctly return
                                ; true. This instruction MUST immediately
                                ; precede the repz scasw instruction.
        repz    scasw           ; test *pdxp = 0
        jnz     $FFRet          ; non zero char found - return false
        inc     ax              ; return TRUE if all 0 or ich = 0
$FFRet:
        cEnd    FFirstIch


        subttl ValidateMemoryDC()
        page

;       ValidateMemoryDC()

        cProc ValidateMemoryDC,<PUBLIC,FAR>
        cBegin ValidateMemoryDC

; /* Attempt to assure that vhMDC and vhDCPrinter are valid.  If we have not
; already run out of memory, then vhDCPrinter is guaranteed, but vhMDC may
; fail due to out of memory -- it is the callers responsibility to check for
; vhMDC == NULL. */

; /* If we are out of memory, then we shouldn't try to gobble it up by getting
; DC's. */
        cmp     VFOUTOFMEMORY,0
        jne     $I862
        cmp     VHMDC,0
        jne     $I858
        mov     bx,PWWDCUR
        push    WORD PTR [bx+50]
        call    FAR PTR CREATECOMPATIBLEDC
        mov     VHMDC,ax
; /* Callers are responsible for checking for vhMDC == NULL case */
        or      ax,ax
        je      $I858
; /* Put the memory DC in transparent mode. */
        push    ax
        mov     ax,1
        push    ax
        call    FAR PTR SETBKMODE
; /* If the display is a monochrome device, then set the text color for the
; memory DC.  Monochrome bitmaps will not be converted to the foreground and
; background colors in this case, we must do the conversion. */
        mov     bx,PWWDCUR
        push    WORD PTR [bx+50]
        mov     ax,24
        push    ax
        call    FAR PTR GETDEVICECAPS
        cmp     ax,2
        jne     $I854
        mov     ax,1
        jmp     SHORT $I856
$I854:
        xor     ax,ax
$I856:
        mov     VFMONOCHROME,ax
        or      ax,ax
        je      $I858
        push    VHMDC
        push    WORD PTR RGBTEXT+2
        push    WORD PTR RGBTEXT
        call    FAR PTR SETTEXTCOLOR
$I858:
; /* If the printer DC is NULL then we need to restablish it. */
	cmp	VHDCPRINTER,0
	jne	$I862
	xor	ax,ax
	push	ax
	call	FAR PTR GETPRINTERDC
$I862:
        cEnd ValidateMemoryDC

        sEnd FORM1_TEXT
END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\heapdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*
	heapDefs.h - include file for the storage allocator.

*/

#if 0
	Storage allocation
    NULL
      |
      |    pHeapFirst
      |    ________________
      |    |_____cw________| hh
      |    |     block     | *Fgr <----------------------\
      |    |       of      |                             |
      |    |     words     |                             |
      |    |_______________|                             |
 phhFree---->______cw______| hh                          |
      |--|------phhNext____|                             |
	 | |____phhPrev--------------|                   |
	 | |               |         |                   |
	 | |               |         |                   |
	 | |               |         |                   |
	 | |    block      |         |                   |
	 | |      of       |         |                   |
	 | |    words      |         |                   |
	 | |_______________|         |                   |
	 | |_____cw________|         |                   |
	 | |     .         | *Fgr<---|-------------------|-\
	 | |---------------|         |                   | |
	 | |_____cw________|<--------/                   | |
	 |-----phhNext_____|                             | |
	   |   phhPrev---------|                         | |
	   |               |   |                         | |
	   |               |  NULL                       | |
	   |_______________|                             | |
	   |___shake_word__| (if needed) <-----phhMac    | |
  rgfgr--->|_____________--|-----------------------------/ |
 pfgrFree->|___________----|--\                            |
	   |_____________--|--|----------------------------/
	/--|--_____________|<-/
	\->|_____________--|-->NULL



 rgfgr can be indexed as an array with ifgrMac elements.
 The finger table slots are each one word in size.
 Putting the finger table at the high end of memory relies on the coding of
    of the CompactHeap routine; it moves the allocated blocks to low memory.
 The free list is threaded with addresses, NOT indexes.
 cw for a hunk includes size of header
 cw for a free hunk is negative the size of the hunk
 pfgr user's pointer to finger
 fgr pointer to hunk of whatever
 phh pointer to hunk header
 phhPrevs move toward the bottom of the free list
 phhNexts move toward the top
 phhFree should always have a phhNext of NULL (i.e. the list is just double,
    not circular).
				_________________
				|______cw_______|
     pph  -----> ph ----------->|      .        |
     (FGR *)    (FGR)           |      .        |
				|      .        |
				|_______________|


				_________________
		      phh ----->|______cw_______|
				|___phhNext_____|
				|___phhPrev_____|
				|      .        |
				|      .        |
				|      .        |
				|_______________|

#endif

typedef int *FGR;       /* definitions for finger-related stuff. */
typedef int **PFGR;

/* storage allocator related stuff */
struct _HH
	{
	int             cw;
	struct  _HH     *phhNext;
	struct  _HH     *phhPrev;
	};
typedef struct _HH HH;


#ifdef OURHEAP
		/* MACROS */
#define CwOfPfgr(pFgr)       (*(*(pFgr) + bhh))
#define CwOfPhh(phh)         ((phh)->cw)
#ifdef DEBUG
#define fPointsFgrTbl(pfgr)  (((FGR *)(pfgr) >= rgfgr) && ((FGR *)(pfgr) < pfgrMac))
#endif

FGR  	*PfgrAllocate();
FGR	*PfgrCopy();
extern ENV envMem;
#define cwof(i)         ((sizeof(i)+sizeof(int)-1)/sizeof(int))

#endif /* OURHEAP */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\heapinit.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCTLMGR
#define NOCLIPBOARD
#define NOMSG
#define NOGDI
#define NOMB
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOBRUSH
#define NOFONT
#define NOWNDCLASS
#include <windows.h>
#include "mw.h"

#ifdef OURHEAP
/*
        heapInit.c - one routine to calculate the proper information for
            heap management.
*/

#include "code.h"
#include "heapDefs.h"
#include "heapData.h"
#include "str.h"
#ifdef ENABLE
#include "memDefs.h"
#endif

/* heap specific data */
HH      *phhMac;      /* May change if grow heap */
int     cwHeapMac;    /*  "    "     "  "     "     "      "      "   */
int     *pHeapFirst;  /* change if the finger table rgfgr expands */
FGR     *rgfgr;       /* Declared as a pointer, but also used as an array. */
FGR     *pfgrMac;      /* Initially equal to &rgfgr[ifgrInit]; */
FGR     *pfgrFree;     /* Singly linked with a trailing NULL pointer. */
HH      *phhFree;     /* May be NULL along the way. */
ENV     envMem;
int     fMemFailed;
int     cwInitStorage;




FExpandFgrTbl()

/* Will expand the finger table.  This routines depends upon the fact
that the CompactHeap routine moves the allocated blocks to the
low end of memory.  The new space from the finger table comes from
the tail end of the (only) free block left after a compaction.
The finger is expanded by at most 'cfgrNewMax' and at least 1.
If there is no room to expand the finger table, then nothing is
changed.  To expand the table, several pointers and integers are
decreamented to reflect the reallocation of the storage.  Then
we recalculate the memory totals so the user
will have an acurate display of the percent free and total bytes
available.  The new fingers are linked so that the finger at the
low end of the table is at the end of the list.
(To expand the finger table there must be no fingers available.)
*/

{
FGR *pfgr;
int cfgrNew = cfgrBlock;
register HH *phhNew;

#ifdef DEBUG
    if (pfgrFree != NULL)
        panicH(34);
#endif

    if (!FCwInMem(cfgrNew + cwReqMin + 1))
        {
        /* couldn't get a block's worth - could we get one? */
        cfgrNew = 1;
        if (!FCwInMem(cfgrNew))
            /* no way to help this guy */
            return(FALSE);
        }
            
    phhNew = (HH *)pHeapFirst;
    if (phhNew->cw > 0 || !FHhFound(phhNew, cfgrNew))
        {
        /* we tried but failed to find an adequate free
           block at start of heap */
        CompactHeap();
        MoveFreeBlock(pHeapFirst);
        }

    if (!FPhhDoAssign(phhNew, cfgrNew))
        return(FALSE);

/* we have a block which is FIRST in the heap - let's steal it */
    cfgrNew = phhNew->cw; /* in case it was more than we
                             asked for */
    pHeapFirst = pHeapFirst + cfgrNew;
    pfgrMac += cfgrNew;
    cwHeapMac -= cfgrNew;

/* do some initialization if pfgrFree is not NULL and you
want the new fingers at the very end of the free finger list */
    for (pfgr = pfgrMac - cfgrNew; pfgr < pfgrMac; pfgr++)
        {
        *pfgr = (FGR)pfgrFree;
        pfgrFree = pfgr;
        }

/*  do we need this anymore? (cwInitStorage = cwHeapMac - cwHeapFree)
        cbTot = (cwHeapMac - cwInitStorage) * sizeof(int);
        cbTotQuotient = (cbTot>>1)/100;
*/
        return(TRUE);

} /* End of FExpandFgrTbl () */



CompactHeap()
        /* moves all allocated hunks  */
        /* toward beginning of pHeapFirst. Free hunks   */
        {
        HH      *phh, *phhSrc, *phhDest;   /* are combined into one hunk */
        FGR     *pfgr;
        int     cwActual;

#ifdef DEBUG
        StoreCheck();
#endif

        /* set up for compaction by placing cw of hunk in rgfgr and an
           index into rgfgr in the hunk                            */
        for (pfgr = rgfgr; pfgr < pfgrMac; pfgr++)
                {
                if (FPointsHeap(*pfgr))
                        /* if rgfgr[ifgr] points to heap... */
                        {
                        phh = (HH *)(*pfgr + bhh);
                                /* find header */
                        *pfgr = (FGR)phh->cw;
                        /* coerce so it fits, force the shift */
                        phh->cw = (int)(((unsigned)pfgr - (unsigned)rgfgr)/2);
                        }
                }
                /* now we have cw in rgfgr and ifgr in phh */
        phhSrc = (HH *) pHeapFirst;
        phhDest = phhSrc;
        while (phhSrc < phhMac)
                {
                if (phhSrc->cw < 0)
                        /* free hunk, don't recopy */
                        phhSrc = (HH *)((int *) phhSrc - phhSrc->cw);
                 else
                        {
                        pfgr = &rgfgr[phhSrc->cw];
                                /* find h */
                        cwActual = phhSrc->cw = (int) *pfgr;
                                /* restore cw */
                        *pfgr = ((FGR) phhDest - bhh);
                                /* update ha */
                        blt((int *)phhSrc, (int *)phhDest, (unsigned)cwActual);
                                /* unless ptrs are = */
                        phhDest = (HH *) ((int *) phhDest + cwActual);
                        phhSrc = (HH *) ((int *) phhSrc + cwActual);
                        }
                }

#ifdef DEBUG
        if ((int *)phhDest + cwHeapFree - cwHunkMin >= (int *)phhMac)
                panicH(35);
#endif
        phhFree = phhDest;
        phhFree->cw = -cwHeapFree;
        phhFree->phhNext = phhFree->phhPrev = phhFree;
#ifdef DEBUG
        StoreCheck();
#endif
        }

#endif /* NOT WINHEAP */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\heapmain.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCTLMGR
#define NOCLIPBOARD
#define NOMSG
#define NOGDI
#define NOMB
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOBRUSH
#define NOFONT
#define NOWNDCLASS
#include <windows.h>

#include "mw.h"
/*
    HeapManage.c - several routines to manage the heap, including changing
            the finger table, compacting the heap in general, and checking the
            heap for consistency.
            It also contains the routines which were once in heapNew.
*/
#include "code.h"
#include "heapDefs.h"
#include "heapData.h"
#define NOSTRUNDO
#define NOSTRMERGE
#include "str.h"
#include "macro.h"
#define NOUAC
#include "cmddefs.h"
#include "filedefs.h"
#include "docdefs.h"


extern CHAR       (*rgbp)[cbSector];
extern CHAR       *rgibpHash;
extern struct BPS *mpibpbps;
extern int        ibpMax;
extern int        iibpHashMax;
extern int        cwInitStorage;
extern typeTS     tsMruBps;


FTryGrow(unsigned);


PFGR  HAllocate(cwRequest)
unsigned cwRequest;
{
unsigned cb = cwRequest * sizeof(int);
HANDLE hTemp;

    Assert(*(pLocalHeap+1) == 0);

    if (cwRequest >= 0x8000)
        {
#ifdef DEBUG
        Assert(0);
        ErrorWithMsg(IDPMTRottenFile, " heapMan#1");
#else
        Error(IDPMTRottenFile);
#endif
        return((PFGR)hOverflow);
        }

    hTemp = LocalAlloc(LHND, cb);
    if (hTemp != NULL)
        return((PFGR)hTemp);
    else if (FTryGrow(cb))
        {
        return((PFGR)LocalAlloc(LHND, cb));
        }
    else
        {
#ifdef DEBUG
        ErrorWithMsg(IDPMTNoMemory, " heapMan#1");
#else
        Error(IDPMTNoMemory);
#endif
        return((PFGR)hOverflow);
        }
}

FChngSizeH(pfgrChng, cwRequest, fShrink)
PFGR pfgrChng;
int  cwRequest, fShrink;
{
unsigned cb = cwRequest * sizeof(int);
#ifdef DEBUG
PFGR pfgrNew;
#endif

    Assert(*(pLocalHeap+1) == 0);   /* Check for frozen heap */
    Assert(cwRequest >= 0);

    if ((
#ifdef DEBUG
    pfgrNew =
#endif
    (PFGR)LocalReAlloc( (HANDLE)pfgrChng, cb, LHND)) != NULL)
        {
        Assert( pfgrNew == pfgrChng );  /* Windows guarantees this for
                                           movable objects */
        return( TRUE );
        }
    else if (FTryGrow(cb))
        {
#ifdef DEBUG
        pfgrNew = 
#endif
        (PFGR)LocalReAlloc( (HANDLE)pfgrChng, cb, LHND);
        Assert( pfgrNew != (PFGR)NULL );
        Assert( pfgrNew == pfgrChng );
        return( TRUE );
        }
    else
        {
#ifdef DEBUG
        ErrorWithMsg( IDPMTNoMemory, " heapMan#2" );
#else
        Error( IDPMTNoMemory );
#endif
        return( FALSE );
        }
}



CHAR (**HszCreate(sz))[]
CHAR sz[];
{ /* Creates a heap block containing sz */
CHAR (**hsz)[];
int cch = CchSz(sz);
hsz = (CHAR (**)[]) HAllocate(CwFromCch(cch));
if (FNoHeap(hsz))
        return (CHAR (**)[])hOverflow;
bltbyte(sz, **hsz, cch);
return hsz;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\heaprare.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCTLMGR
#define NOCLIPBOARD
#define NOMSG
#define NOGDI
#define NOMB
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOBRUSH
#define NOFONT
#define NOWNDCLASS
#include <windows.h>

#include "mw.h"
/*
    HeapManage.c - several routines to manage the heap, including changing
            the finger table, compacting the heap in general, and checking the
            heap for consistency.
            It also contains the routines which were once in heapNew.
*/
#include "code.h"
#include "heapDefs.h"
#include "heapData.h"
#define NOSTRUNDO
#define NOSTRMERGE
#include "str.h"
#include "macro.h"
#define NOUAC
#include "cmddefs.h"
#include "filedefs.h"
#include "docdefs.h"

#ifdef DEBUG
int cPageMinReq = 15;
#else
#define cPageMinReq       (15)
#endif


/* the following statics are used when growing both heap and rgbp etc. */
static int cwRealRequest; /* heap is grow in blocks, this is the actual request */
static int cPageIncr;     /* count of page buffers to increase */
static int cwRgbpIncr;    /* cw in rgbp to be increment */
static int cwHashIncr;    /* cw in rgibpHash to be increment */
static int cwBPSIncr;     /* cw in mpibpbps to be increment */
static int cwHeapIncr;    /* cw in heap increment */


extern CHAR       (*rgbp)[cbSector];
extern CHAR       *rgibpHash;
extern struct BPS *mpibpbps;
extern int        ibpMax;
extern int        iibpHashMax;
extern int        cwInitStorage;
extern typeTS     tsMruBps;

NEAR FGiveupFreeBps(unsigned, int *);
NEAR FThrowPages(int);
NEAR GivePages(int);
NEAR CompressRgbp();

FTryGrow(cb)
unsigned cb;
{
int cPage;

#define cPageRemain (int)(ibpMax - cPage)

    if (FGiveupFreeBps(cb, &cPage) &&
        (cPageRemain >= cPageMinReq))
        {
        /* we have enough free pages to give */
        GivePages(cPage);
        }
    else if ((cPageRemain >= cPageMinReq) && FThrowPages(cPage))
        {
        GivePages(cPage);
        }
    else
        {
        return(FALSE);
        }

    return(TRUE);
}


NEAR FGiveupFreeBps(cb, pCPage)
unsigned cb;
int *pCPage;
{
/* Return true if we can simply give up certain free pages from rgbp to
   the heap.  Return false if all free pages from rgbp still cannot satisfy
   the request
   In any case, pCPage contains the count of pages required */

register struct BPS *pbps;
register int cPage = 0;
int ibp;

#define cbTotalFreed ((cPage*cbSector)+(2*cPage*sizeof(CHAR))+(cPage*sizeof(struct BPS)))

    for (ibp = 0, pbps = &mpibpbps[0]; ibp < ibpMax; ibp++, pbps++)
        {
        if (pbps->fn == fnNil)
            cPage++;
        }

    if (cb > cbTotalFreed )
        {
        /* free pages are not enough, find out exactly how many
        pages do we need */
        cPage++;
        while (cb > cbTotalFreed)
            cPage++;
        *pCPage = cPage;
        return(FALSE);
        }

/* there are enough free pages to give, find out exactly how many */
    while (cb <= cbTotalFreed)
        cPage--;
    cPage++;
    *pCPage = cPage;
    return(TRUE);
} /* end of FGiveupFreeBps */


NEAR FThrowPages(cPage)
int cPage;
{
int i;
register struct BPS *pbps;

    Assert(cPage > 0);

    for (i = 0; i < cPage; i++)
        {
        pbps = &mpibpbps[IbpLru(0)];
        if (pbps->fn != fnNil)
            {
            if (pbps->fDirty && !FFlushFn(pbps->fn))
                return(FALSE);

            /* delete references to old bps in hash table */
            FreeBufferPage(pbps->fn, pbps->pn);
            }
        pbps->ts = ++tsMruBps; /* so that it would not be picked up again as the LRUsed */
        }
    return(TRUE);
} /* end of FThrowPages */


NEAR GivePages(cPage)
int cPage;
{
register struct BPS *pbpsCur = &mpibpbps[0];
struct BPS *pbpsUsable = pbpsCur;
int ibp;
unsigned cbBps;
unsigned cbRgbp;
unsigned cbTotalNew;

    for (ibp = 0; ibp < ibpMax; pbpsCur++, ibp++)
        {
/* compressed so that non empty bps are at the low end,
store ibp in ibpHashNext field (this is important for
CompressRgbp relies on that), since ibpHashNext is invalid
after the compress anyway */
        if (pbpsCur->fn != fnNil)
            {
            if (pbpsCur != pbpsUsable)
                {
                bltbyte((CHAR *)pbpsCur, (CHAR *)pbpsUsable,
                        sizeof(struct BPS));
                /* reinitialized */
                SetBytes((CHAR*)pbpsCur, 0, sizeof(struct BPS));
                         pbpsCur->fn = fnNil;
                         pbpsCur->ibpHashNext = ibpNil;
                }
            pbpsUsable->ibpHashNext = ibp;
            pbpsUsable++;
            }
        } /* end of for */

    /* compressed rgbp, result -- all used pages at the low end */
    CompressRgbp();

    /* decrease the size of the hash table */
    ibpMax -= cPage;
    iibpHashMax = ibpMax * 2 + 1;
    cbRgbp = ibpMax * cbSector;

    rgibpHash = (CHAR *)((unsigned)rgbp + cbRgbp);
    /* contents of rgibpHash should be all ibpNil, that is
    taken care in RehashRgibpHash */

    cbBps = (ibpMax * sizeof(struct BPS) + 1) & ~1;
    bltbyte((CHAR *)mpibpbps, (CHAR *)(mpibpbps = (struct BPS *)
            (((unsigned)rgibpHash + iibpHashMax + 1) & ~1)), cbBps);

    RehashRgibpHash();

    cbTotalNew = cbRgbp + cbBps + ((iibpHashMax + 1) & ~1);

    LocalReAlloc((HANDLE)rgbp, cbTotalNew, LPTR);

    Assert(rgbp != NULL);

} /* end of GivePages */


NEAR CompressRgbp()
{
/* compressed so that all non empty pages are moved towards the low end of
   rgbp */

register struct BPS *pbps = &mpibpbps[0];
struct BPS *pbpsLim = &mpibpbps[ibpMax];
int ibp;

    for (ibp = 0; pbps < pbpsLim; ibp++, pbps++)
        {
        if (pbps->fn == fnNil)
            continue;
        if (pbps->ibpHashNext != ibp)
            {
        /* find out the location of pages (stored in ibpHashNext field) */
            bltbyte((CHAR *)rgbp[pbps->ibpHashNext], (CHAR *)rgbp[ibp], cbSector);
            }
        pbps->ibpHashNext = ibpNil;
        }
} /* end of CompressRgbp */


#ifdef DEBUG
cPageUnused()
{
int ibp;
struct BPS *pbps;
int cPage = 0;

    for (ibp = 0, pbps = &mpibpbps[0]; ibp < ibpMax; ibp++, pbps++)
        {
        if (pbps->fn == fnNil)
            cPage++;
        }
    return(cPage);
}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\initwin.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/



#define NOVIRTUALKEYCODES
#define NOKEYSTATE
#define NOCREATESTRUCT
#define NOICON
//#define NOATOM
//#define NOMEMMGR
#define NOPEN
#define NOREGION
#define NODRAWTEXT
#define NOMB
#define NOWINOFFSETS
#define NOOPENFILE
#define NOMETAFILE
#define NOWH
//#define NOCLIPBOARD
#define NOSYSCOMMANDS
#define NOWINMESSAGES
#define NOSOUND
#define NOCOMM
#include <windows.h>

#include "mw.h"


#define NOUAC
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "menudefs.h"
#include "str.h"
#include "fontdefs.h"
#include "printdef.h"
#if defined(OLE)
#include "obj.h"
#endif
#include <commdlg.h>

#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif

    /* static string arrays found in mglobals.c */
extern CHAR         szMw_acctb[];
extern CHAR         szNullPort[];
extern CHAR         szNone[15];
extern CHAR         szMwlores[];
extern CHAR         szMwhires[];
extern CHAR         szMw_icon[];
extern CHAR         szMw_menu[];
extern CHAR         szScrollBar[];
extern CHAR         szIntl[];
extern CHAR         szsDecimal[];
extern CHAR         szsDecimalDefault[];

#ifdef INTL /* International version */
extern CHAR         sziCountry[];
extern CHAR         sziCountryDefault[5];
#endif  /* International version */

extern CHAR         vchDecimal;  /* decimal point character */
extern int          viDigits;    /* digits after decimal point */
extern BOOL         vbLZero;     /* leading zero before decimal */

extern struct WWD   rgwwd[];
extern CHAR         stBuf[256];
extern int vifceMac;
extern union FCID vfcidScreen;
extern union FCID vfcidPrint;
extern struct FCE rgfce[ifceMax];
extern struct FCE *vpfceMru;
extern HCURSOR  vhcHourGlass;

#ifdef PENWIN   // for PenWindows (5/21/91) patlam
#include <penwin.h>

extern HCURSOR  vhcPen;

extern int (FAR PASCAL *lpfnProcessWriting)(HWND, LPRC);
extern VOID (FAR PASCAL *lpfnPostVirtualKeyEvent)(WORD, BOOL);
extern VOID (FAR PASCAL *lpfnTPtoDP)(LPPOINT, int);
extern BOOL (FAR PASCAL *lpfnCorrectWriting)(HWND, LPSTR, int, LPRC, DWORD, DWORD);
extern BOOL (FAR PASCAL *lpfnSymbolToCharacter)(LPSYV, int, LPSTR, LPINT);
#endif

extern WORD fPrintOnly;
extern HCURSOR  vhcIBeam;
extern HCURSOR  vhcArrow;
extern HCURSOR  vhcBarCur;
extern HANDLE   hMmwModInstance;
extern HWND     hParentWw;
extern HWND     vhWndSizeBox;
extern HWND     vhWndPageInfo;
extern HWND     vhWnd;
extern HMENU    vhMenu;
extern HANDLE   vhAccel;
extern long     rgbBkgrnd;
extern long     rgbText;
extern HBRUSH   hbrBkgrnd;
extern HDC      vhMDC;
extern int      vfInitializing;
extern int      vfMouseExist;
extern int      ferror;
extern CHAR     szWindows[];
extern CHAR     szNul[];
extern CHAR     szWriteProduct[];
extern CHAR     szBackup[];
extern int      vfBackupSave;

#if defined(JAPAN) || defined(KOREA)  //Win3.1J
extern CHAR     szWordWrap[];
extern int      vfWordWrap; /*t-Yoshio WordWrap flag*/
#endif
//IME3.1J

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
extern CHAR     szImeHidden[];
extern int      vfImeHidden; /*T-HIROYN ImeHidden Mode flag*/
#endif

#ifdef JAPAN    //01/21/93
extern HANDLE   hszNoMemorySel;
#endif
extern HANDLE   hszNoMemory;
extern HANDLE   hszDirtyDoc;
extern HANDLE   hszCantPrint;
extern HANDLE   hszPRFAIL;
extern HANDLE   hszCantRunM;
extern HANDLE   hszCantRunF;
extern HANDLE   hszWinFailure;
extern HDC      vhDCPrinter;

int vkMinus;

extern int utCur;

    /* Regrettably, we are not permitted to signal in WM_CREATE message
       handlers that we have failed -- instead, we resort to
       ugly global communication via this variable */
#ifdef WIN30
    /* Note that we now CAN return a -1L from MmwCreate and cause the
       CreateWindow to fail, but changing this now wouldn't accomplish us
       very much (besides saving a bunch of checks of a global) ..pault */
#endif
STATIC int fMessageInzFailed = FALSE;

STATIC BOOL NEAR FRegisterWnd( HANDLE );
#ifdef INEFFLOCKDOWN
STATIC int NEAR FInitFarprocs( HANDLE );
#endif
STATIC HANDLE NEAR HszCreateIdpmt( int );

BOOL InitIntlStrings( HANDLE );


#define cchCmdLineMax   64      /* Longest command line accepted */



/*               FInitWinInfo                           */
/* Main MS-WINDOWS initialization entry point for write */
/* Actions:
        Loads all mouse cursors & sets global handles to cursors (vhc's)
        Loads the menu key accelerator table vhAccel
        Registers all of WRITE's myriad window classes
        Sets up global hMmwModInstance, our instance handle
        Puts "DOC = WRITE.EXE ^.DOC" into WIN.INI if not already there
        Generates thunks for all exported procedures
        Creates a parent window for this instance (the menu window, NOT
          the document window)
        Sets the right colors for the window
*/
/* Returns FALSE if the initailization failed, TRUE if it succeeded */

int FInitWinInfo( hInstance, hPrevInstance, lpszCmdLine, cmdShow  )
HANDLE hInstance, hPrevInstance;
LPSTR  lpszCmdLine;
int    cmdShow;
{
 extern VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL);
 extern CHAR szParentClass[];
 extern int vfDiskError, vfDiskFull, vfSysFull;
 extern PRINTDLG PD;

 CHAR rgchCmdLine[ cchCmdLineMax ];
 CHAR bufT[3];  /* to hold decimal point string */
 CHAR *pch = bufT;
 BOOL fRetVal;

#if defined(OLE)
    /*
        The only place I'm worrying about this is when we open a file which
        contains objects.  Probably thats not enough, but its something.
        Alas for users of real mode.
    */
    fOleEnabled = GetWinFlags() & WF_PMODE; /* Are we in real mode today? */
#endif

    /* Save the command line in a DS variable so we can pass a NEAR pointer */
    bltszx( lpszCmdLine, (LPSTR)rgchCmdLine );

    /* First thing, put up the hourglass cursor. */
    if ((vhcHourGlass = LoadCursor( NULL, IDC_WAIT )) == NULL)
        {
        /* We don't even have enough memory to tell the user we don't have
        enough memory. */
        return (FALSE);
        }

    vfMouseExist = GetSystemMetrics(SM_MOUSEPRESENT);

    /* Next, save the out of memory messages. */
    hMmwModInstance = hInstance;
    if ((hszCantRunM = HszCreateIdpmt( IDPMTCantRunM )) == NULL ||
      (hszCantRunF = HszCreateIdpmt( IDPMTCantRunF )) == NULL ||
      (hszWinFailure = HszCreateIdpmt( IDPMTWinFailure )) == NULL ||
#ifdef JAPAN	//01/21/93
      (hszNoMemorySel = HszCreateIdpmt( IDPMTNoMemorySel )) == NULL ||
#endif
      (hszNoMemory = HszCreateIdpmt( IDPMTNoMemory )) == NULL ||
      (hszDirtyDoc  = HszCreateIdpmt( IDPMTDirtyDoc )) == NULL ||
      (hszCantPrint = HszCreateIdpmt( IDPMTCantPrint )) == NULL ||
      (hszPRFAIL = HszCreateIdpmt( IDPMTPRFAIL )) == NULL)
        {
        goto InzFailed;
        }

#if defined(INTL) && defined(WIN30)
/*  Initializaton of multi/intl strings.  This is done before anything
    else because many are defaults used for GetProfileString, etc. */

    if (!FInitIntlStrings(hInstance))
        goto InzFailed;
#endif

    /* Set up the standard cursors. */
    if ( ((vhcIBeam = LoadCursor( NULL, IDC_IBEAM )) == NULL) ||
         ((vhcArrow = LoadCursor( NULL, IDC_ARROW )) == NULL))
        goto InzFailed;

#ifdef PENWIN   // for PenWindows (5/21/91) patlam
    vhcPen =vhcIBeam;
#endif


    /* Set up the menu accelerator key table. */
    if ((vhAccel = LoadAccelerators( hMmwModInstance, (LPSTR)szMw_acctb )) ==
      NULL)
        goto InzFailed;

    /* Get whether to make backups during save from the user profile. */
    vfBackupSave = GetProfileInt((LPSTR)szWriteProduct, (LPSTR)szBackup, 0) == 0
      ? FALSE : TRUE;

    /* Get the name of the null port from the user profile. */

    GetProfileString((LPSTR)szWindows, (LPSTR)szNullPort, (LPSTR)szNone,
      (LPSTR)szNul, cchMaxIDSTR);

#ifdef INTL /* International version */
    /* Get the country code. If US or UK, set utCur to be inches, else set
       to cm */
    {
#if 0
      /* codes from MSDOS country codes */
#define USA (1)
#define UK (44)

    int iCountry;

    GetProfileString((LPSTR)szIntl, (LPSTR)sziCountry, (LPSTR)sziCountryDefault,
      (LPSTR)bufT, 4);
    iCountry = WFromSzNumber (&pch);
    if ((iCountry ==  USA) || (iCountry == UK))
        utCur = utInch;
#else
    if (GetProfileInt((LPSTR)szIntl, (LPSTR)"iMeasure", 1) == 1)
        utCur = utInch;
    else
        utCur = utCm;
#endif
    }

#endif  /* International version */

    /* Get the decimal point character from the user profile. */
    GetProfileString((LPSTR)szIntl, (LPSTR)szsDecimal, (LPSTR)szsDecimalDefault,
      (LPSTR)bufT, 2);
    vchDecimal = *bufT;

    viDigits = GetProfileInt((LPSTR)szIntl, (LPSTR)"iDigits", 2);
    vbLZero  = GetProfileInt((LPSTR)szIntl, (LPSTR)"iLZero", 0);

    MergeInit();   /* get message merge characters from resource file */
#if defined(JAPAN) || defined(KOREA)    /*t-Yoshio*/
/*
 *  Get WordWrap switch
 *      case 1 WordWrap ON(default)
 *      case 0 WordWrap OFF
 */
    vfWordWrap = GetProfileInt((LPSTR)szWriteProduct, (LPSTR)szWordWrap, 1);
#endif

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IR_UNDETERMINE
/*
 *  Get ImeHidden switch
 *      case 1 Ime Conversion Window MCW_HIDDEN SET
 *      case 0 Ime Conversion Window MCW_WINDOW SET (default)
 */

    if (3 == (vfImeHidden = 
                GetProfileInt((LPSTR)szWriteProduct, (LPSTR)szImeHidden, 3))) {
// insert machine power get routine someday
        vfImeHidden = 0;
    }

    GetImeHiddenTextColors();

#endif

#ifdef FONT_KLUDGE
    AddFontResource( (LPSTR)"helv.fon" );
#endif /* FONT_KLUDGE */

    if (!hPrevInstance)
        {
        /* First time loaded; register the Write Windows. */
        if (!FRegisterWnd( hMmwModInstance ))
            {
            return ( FALSE );
            }

        /* Get the Memo specific cursor. */
        if ((vhcBarCur = LoadCursor( hMmwModInstance,
                          (GetSystemMetrics( SM_CXICON ) < 32) ||
                          (GetSystemMetrics( SM_CYICON ) < 32) ?
                              (LPSTR) szMwlores : (LPSTR) szMwhires )) == NULL)
            goto InzFailed;
        }
    else /* not first time loaded; get data from previous instance */
        {
        if (!GetInstanceData( hPrevInstance,
                              (PSTR)&vhcBarCur, sizeof( vhcBarCur ) ))
            goto InzFailed;
        }

#ifdef INEFFLOCKDOWN
    /* Now initialize the pointers to far procedures (thunks). */
    if (!FInitFarprocs( hMmwModInstance ))
        goto InzFailed;
#endif

    /* Create our parent (tiled) window */
    /* CreateWindow call generates a call to MmwCreate via message */
    {
        int cxFrame  = GetSystemMetrics( SM_CXFRAME );
        int cxBorder = GetSystemMetrics( SM_CXBORDER );
        int cyBorder = GetSystemMetrics( SM_CYBORDER );
        int x = ((cxFrame + 7) & 0xfff8) - cxFrame;

    if (  CreateWindow(
                      (LPSTR)szParentClass,
                      (LPSTR)rgchCmdLine, /* don't pass lpszCmdLine; it will change! ..pault 2/22/90 */
                      WS_TILEDWINDOW,
#ifdef WIN30
/* This makes for nicer cascading of Write.exe invocations ..pault */
                      CW_USEDEFAULT,     /* x */
                      CW_USEDEFAULT,            /* y */
                      CW_USEDEFAULT,            /* dx */
                      CW_USEDEFAULT,            /* dy */
#else
                      x,                        /* x */
                      x * cyBorder / cxBorder,  /* y */
                      CW_USEDEFAULT,            /* dx */
                      NULL,                     /* dy */
#endif
                      (HWND)NULL,               /* no parent */
                      (HMENU)NULL,              /* use class menu */
                      (HANDLE)hInstance,        /* handle to window instance */
                      (LPSTR)NULL               /* no params to pass on */
                      ) == NULL)
            /* Could not create window */
        goto InzFailed;
    }
    if (fMessageInzFailed)
            /* The create itself did not fail, but something in MmwCreate did
               and it signals us via this global */
        goto InzFailed;

    Assert( hParentWw != NULL );    /* MmwCreate should have assured this */

#if WINVER >= 0x300
    vkMinus = VkKeyScan('-');
#endif

    /* Record the window foreground and background colors. */

#ifdef DEBUG
    {
    int f =
#endif

    FSetWindowColors();

#ifdef DEBUG
    Assert (f);
    }
#endif

    /* Select the background brush into the parent window. */

    SelectObject( GetDC( hParentWw ), hbrBkgrnd );

    /* Commdlg stuff (3.7.91) D. Kent */
    if (InitCommDlg(0))
        goto InzFailed;

#ifdef PENWIN
    if (lpfnRegisterPenApp = GetProcAddress(GetSystemMetrics(SM_PENWINDOWS),
                                            "RegisterPenApp"))
    {
        (*lpfnRegisterPenApp)((WORD)1, fTrue); // be Pen-Enhanced
    }

    {
    // This assumes no edit controls created in FInitWinInfo
    HANDLE hLib;

    if (lpfnProcessWriting = GetProcAddress(hLib = GetSystemMetrics(SM_PENWINDOWS),
        "ProcessWriting"))
         {
         lpfnPostVirtualKeyEvent = GetProcAddress(hLib, "PostVirtualKeyEvent");
         lpfnTPtoDP = GetProcAddress(hLib, "TPtoDP");
         lpfnCorrectWriting = GetProcAddress(hLib, "CorrectWriting");
         lpfnSymbolToCharacter = GetProcAddress(hLib, "SymbolToCharacter");

        if ((vhcPen = LoadCursor( NULL, IDC_PEN   )) == NULL)
            goto InzFailed;
         }
    }

#endif

    /* init fields of the PRINTDLG structure (not used yet) */
    PD.lStructSize    = sizeof(PRINTDLG);
    PD.hwndOwner      = hParentWw;
    // PD.hDevMode  is already initialized
    PD.hDevNames      = NULL;
    PD.hDC            = NULL;
    PD.Flags          = PD_ALLPAGES; /* disable "pages" and "Selection" radiobuttons */
    PD.nFromPage      = 1;
    PD.nToPage        = 1;
    PD.nMinPage       = pgnMin; /* constant 1 */
    PD.nMaxPage       = pgnMax; /* largest integer */
    PD.nCopies        = 1;

    /* initialize OLE stuff (1-23-91 dougk) */
    if (!ObjInit(hInstance))
    goto InzFailed;

    /* Parse command line; load document & create an "mdoc" child window */

    if (!FInitArgs(rgchCmdLine) || fMessageInzFailed)
            /* Serious error -- bail out */
        goto InzFailed;

    /* Create a memory DC for the child window, to test that it works */

    ValidateMemoryDC();
    if (vhMDC == NULL)
        goto InzFailed;

    /* Make parent window visible after the child gets created; the order is
    important and that the parent window is created without the visible bit on,
    so that no size message is sent before child gets created */

    //if (!fPrintOnly)
        ShowWindow(hParentWw, cmdShow);

    Diag(CommSz("---------------------------------------------------------------------------\n\r"));
    vfInitializing = FALSE;
    fRetVal = TRUE;

FreeMsgs:
    if (hszCantRunM != NULL)
        GlobalFree( hszCantRunM );
    if (hszCantRunF != NULL)
        GlobalFree( hszCantRunF );
    return fRetVal;

InzFailed:
    FreeMemoryDC( TRUE );
    if (vhDCPrinter != NULL)
        DeleteDC( vhDCPrinter);

    if (hszWinFailure != NULL)
        GlobalFree( hszWinFailure );
#ifdef JAPAN 	//01/21/93
    if (hszNoMemorySel != NULL)
        GlobalFree( hszNoMemorySel );
#endif
    if (hszNoMemory != NULL)
        GlobalFree( hszNoMemory );
    if (hszDirtyDoc != NULL)
        GlobalFree( hszDirtyDoc );
    if (hszCantPrint != NULL)
        GlobalFree( hszCantPrint );
    if (hszPRFAIL != NULL)
        GlobalFree( hszPRFAIL );

    ferror = vfInitializing = FALSE; /* So the error report is not suppressed */
    if (vfDiskFull || vfSysFull || vfDiskError)
        Error(IDPMTCantRunF);
    else
        Error(IDPMTCantRunM);

    fRetVal = FALSE;
    goto FreeMsgs;
}




STATIC BOOL NEAR FRegisterWnd(hInstance)
HANDLE hInstance;
    {
    /* This routine registers all of the window classes.  TRUE is returned if
    all of the windows classes were successfully registered; FALSE otherwise. */

    extern CHAR szParentClass[];
    extern CHAR szDocClass[];
    extern CHAR szRulerClass[];
    extern CHAR szPageInfoClass[];
#ifdef ONLINEHELP
    extern CHAR szHelpDocClass[];
#endif

    extern long FAR PASCAL MmwWndProc(HWND, unsigned, WORD, LONG);
    extern long FAR PASCAL MdocWndProc(HWND, unsigned, WORD, LONG);
    extern long FAR PASCAL RulerWndProc(HWND, unsigned, WORD, LONG);
    extern long FAR PASCAL PageInfoWndProc(HWND, unsigned, WORD, LONG);

#ifdef ONLINEHELP
    extern long FAR PASCAL HelpDocWndProc(HWND, unsigned, WORD, LONG);
#endif /* ONLINEHELP */

    WNDCLASS Class;

    /* Register our Window Proc */
    bltbc( (PCH)&Class, 0, sizeof( WNDCLASS ) );
    Class.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNCLIENT;
    Class.lpfnWndProc = MmwWndProc;
    Class.hInstance = hInstance;
    Class.hCursor = vhcArrow;
    Class.hIcon = LoadIcon( hInstance, (LPSTR)szMw_icon );
    Class.lpszMenuName = (LPSTR)szMw_menu;
    Class.lpszClassName = (LPSTR)szParentClass;
    Class.hbrBackground = COLOR_WINDOW+1;

    /* register the parent menu class with WINDOWS */
    if (!RegisterClass( (LPWNDCLASS)&Class ) )
        return FALSE;   /* Initialization failed */

    /* register memo document child window class */
    bltbc( (PCH)&Class, 0, sizeof( WNDCLASS ) );
    Class.style = CS_OWNDC | CS_DBLCLKS;
    Class.lpfnWndProc = MdocWndProc;
    Class.hInstance = hInstance;
    Class.lpszClassName = (LPSTR)szDocClass;
    if (!RegisterClass( (LPWNDCLASS)&Class ) )
        return FALSE;   /* Initialization failed */

    /* register ruler child window class */
    bltbc( (PCH)&Class, 0, sizeof( WNDCLASS ) );
    Class.style = CS_OWNDC | CS_DBLCLKS;
    Class.lpfnWndProc = RulerWndProc;
    Class.hInstance = hInstance;
    Class.hCursor = vhcArrow;
    Class.lpszClassName = (LPSTR)szRulerClass;
    if (!RegisterClass( (LPWNDCLASS)&Class ) )
        return FALSE;   /* Initialization failed */

#ifdef ONLINEHELP
    /* register Help document child window class */
    bltbc( (PCH)&Class, 0, sizeof( WNDCLASS ) );
    Class.style = CS_OWNDC;
    Class.lpfnWndProc = HelpDocWndProc;
    Class.hInstance = hInstance;
    Class.lpszClassName = (LPSTR)szHelpDocClass;
    if (!RegisterClass( (LPWNDCLASS)&Class ) )
        return FALSE;   /* Initialization failed */
#endif /* ONLINE HELP */

    /* register page info child window class */
    bltbc( (PCH)&Class, 0, sizeof( WNDCLASS ) );
    Class.style = CS_OWNDC;
    Class.lpfnWndProc = PageInfoWndProc;
    Class.hInstance = hInstance;
    Class.hCursor = vhcArrow;
    Class.lpszClassName = (LPSTR)szPageInfoClass;
    if (!RegisterClass( (LPWNDCLASS)&Class ) )
        return FALSE;   /* Initialization failed */

    return TRUE;
    }


#ifdef INEFFLOCKDOWN
/* I've removed this for Windows 3.0 because (unless reasons come up
   proving otherwise) it is inefficient for a Win program to lock-down
   so many procedures like this for the entire time the app is running.
   Originally thought to lock down the entire procedure; now understood only
   to lock down the thunk.  The principle still applies..pault 10/26/89 */

STATIC int NEAR FInitFarprocs( hInstance )
HANDLE  hInstance;
    {
    /* This routine initializes all of the far pointer to procedures. */

    extern FARPROC lpDialogOpen;
    extern FARPROC lpDialogSaveAs;
    extern FARPROC lpDialogConfirm;
    extern FARPROC lpDialogPrinterSetup;
    extern FARPROC lpDialogPrint;
    extern FARPROC lpDialogRepaginate;
    extern FARPROC lpDialogSetPage;
    extern FARPROC lpDialogPageMark;
    extern FARPROC lpDialogCancelPrint;
    extern FARPROC lpDialogHelp;
#ifdef ONLINEHELP
    extern FARPROC lpDialogHelpInner;
#endif /* ONLINEHELP */
    extern FARPROC lpDialogGoTo;
    extern FARPROC lpDialogFind;
    extern FARPROC lpDialogChange;
    extern FARPROC lpDialogCharFormats;
    extern FARPROC lpDialogParaFormats;
    extern FARPROC lpDialogRunningHead;
    extern FARPROC lpDialogTabs;
    extern FARPROC lpDialogDivision;
    extern FARPROC lpDialogBadMargins;
    extern FARPROC lpFontFaceEnum;
    extern FARPROC lpFPrContinue;

#ifdef INTL /* International version */
    extern FARPROC lpDialogWordCvt;
    extern BOOL far PASCAL DialogWordCvt(HWND, unsigned, WORD, LONG);
#endif  /* International version */

    extern BOOL far PASCAL DialogOpen(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogSaveAs(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogPrinterSetup(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogPrint(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogCancelPrint(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogRepaginate(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogSetPage(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogPageMark(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogHelp(HWND, unsigned, WORD, LONG);
#ifdef ONLINEHELP
    extern BOOL far PASCAL DialogHelpInner(HWND, unsigned, WORD, LONG);
#endif /* ONLINEHELP */
    extern BOOL far PASCAL DialogGoTo(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogFind(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogChange(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogCharFormats(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogParaFormats(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogRunningHead(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogTabs(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogDivision(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogConfirm(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogBadMargins(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL FontFaceEnum(LPLOGFONT, LPTEXTMETRIC, int, long);
    extern BOOL far PASCAL FPrContinue(HDC, int);

    if (
     ((lpDialogPrinterSetup = MakeProcInstance(DialogPrinterSetup, hInstance))
                                            == NULL) ||
     ((lpDialogPrint = MakeProcInstance(DialogPrint, hInstance)) == NULL) ||
     ((lpDialogSetPage = MakeProcInstance(DialogSetPage, hInstance)) == NULL)||
     ((lpDialogRepaginate = MakeProcInstance(DialogRepaginate, hInstance))
                                            == NULL) ||
     ((lpDialogPageMark = MakeProcInstance(DialogPageMark, hInstance))
                                            == NULL) ||
     ((lpDialogCancelPrint = MakeProcInstance(DialogCancelPrint, hInstance))
                                            == NULL) ||
     ((lpDialogHelp = MakeProcInstance(DialogHelp, hInstance)) == NULL) ||
#ifdef ONLINEHELP
     ((lpDialogHelpInner = MakeProcInstance(DialogHelpInner, hInstance))
                                            == NULL) ||
#endif /* ONLINEHELP */
     ((lpDialogGoTo = MakeProcInstance(DialogGoTo, hInstance)) == NULL) ||
     ((lpDialogFind = MakeProcInstance(DialogFind, hInstance)) == NULL) ||
     ((lpDialogChange = MakeProcInstance(DialogChange, hInstance)) == NULL) ||
     ((lpDialogCharFormats = MakeProcInstance(DialogCharFormats, hInstance))
                                            == NULL) ||
     ((lpDialogParaFormats = MakeProcInstance(DialogParaFormats, hInstance))
                                            == NULL) ||
     ((lpDialogRunningHead = MakeProcInstance(DialogRunningHead, hInstance))
                                            == NULL) ||
     ((lpDialogTabs = MakeProcInstance(DialogTabs, hInstance)) == NULL) ||
     ((lpDialogDivision = MakeProcInstance(DialogDivision, hInstance))
                                            == NULL) ||
     ((lpDialogConfirm = MakeProcInstance(DialogConfirm, hInstance)) == NULL)||
     ((lpDialogBadMargins = MakeProcInstance(DialogBadMargins, hInstance))
                                            == NULL) ||
     ((lpFontFaceEnum = MakeProcInstance(FontFaceEnum, hInstance)) == NULL) ||
     ((lpFPrContinue = MakeProcInstance(FPrContinue, hInstance)) == NULL)

#ifdef INTL /* International version */
     || ((lpDialogWordCvt = MakeProcInstance(DialogWordCvt, hInstance)) == NULL)
#endif  /* International version */
    )
        return FALSE;
    return TRUE;
    }
#endif /* ifdef-INEFFLOCKDOWN */


void MmwCreate(hWnd, lParam)
HWND  hWnd;
LONG  lParam;
{
    extern CHAR szPageInfoClass[];
    HANDLE hSysMenu;
    HDC hDC;
    HBRUSH hbr;

    Assert( hMmwModInstance != NULL );  /* Should have set up instance handle */

    hParentWw = hWnd;
    if ((vhMenu = GetMenu(hWnd)) == NULL)
        goto Error;

    /* set up font cache */
    /* RgfceInit() placed in line for speed */
    {
    int ifce;
    struct FCE *pfce;

    for (ifce = 0; ifce < vifceMac; ifce++)
        {
        pfce = &rgfce[ifce];
        pfce->pfceNext = &rgfce[(ifce + 1) % vifceMac];
        pfce->pfcePrev = &rgfce[(ifce + vifceMac - 1) % vifceMac];
        pfce->fmi.mpchdxp = pfce->rgdxp - chFmiMin;
        pfce->fcidRequest.lFcid = fcidNil;
        }

    Assert(sizeof(rgfce[0].fcidRequest.lFcid)
           == sizeof(rgfce[0].fcidRequest.strFcid));
    vpfceMru = &rgfce[0];
    vfcidScreen.lFcid = vfcidPrint.lFcid = fcidNil;
    }

/* set up page buffer, internal data structures, heap etc. */
    if (!FInitMemory())
        goto Error;

    /* Create the horizontal scroll bar.  The size is initialized to zero
    because it will be reset later. */

    if ((wwdCurrentDoc.hHScrBar = CreateWindow((LPSTR)szScrollBar, (LPSTR)NULL,
      WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | SBS_HORZ, 0, 0, 0, 0, hWnd,
      NULL, hMmwModInstance, (LPSTR)NULL)) == NULL)
        {
        goto Error;
        }
    wwdCurrentDoc.sbHbar = SB_CTL;

    /* Create the vertical scroll bar.  The size is initialized to zero
    because again it will be reset later. */

    if ((wwdCurrentDoc.hVScrBar = CreateWindow((LPSTR)szScrollBar, (LPSTR)NULL,
      WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | SBS_VERT, 0, 0, 0, 0, hWnd,
      NULL, hMmwModInstance, (LPSTR)NULL)) == NULL)
        {
        goto Error;
        }
    wwdCurrentDoc.sbVbar = SB_CTL;

#ifndef NOMORESIZEBOX
    /* Create the size box.  The size is initialized to zero because again it
    will be reset later. */
    if ((vhWndSizeBox = CreateWindow((LPSTR)szScrollBar, (LPSTR)NULL,
      WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | SBS_SIZEBOX,
      CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, hWnd, NULL,
      hMmwModInstance, (LPSTR)NULL)) == NULL)
        {
        goto Error;
        }
#endif

    /* Create the page info window.  Again, we'll worry about the sizing later.
    */
    if ((vhWndPageInfo = CreateWindow((LPSTR)szPageInfoClass, (LPSTR)NULL,
         WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE, 0, 0, 0, 0, hWnd, NULL,
         hMmwModInstance, (LPSTR)NULL)) == NULL)
        {
        goto Error;
        }

    /* Initialize the page info window. */
    if ((hDC = GetDC(vhWndPageInfo)) == NULL || (hbr =
      CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME))) == NULL)
        {
        goto Error;
        }
      if (SelectObject(hDC, hbr) == NULL)
        {
        DeleteObject(hbr);
        goto Error;
        }
    SetBkMode(hDC, TRANSPARENT);
#ifdef WIN30
    /* If the user has their colors set with a TextCaption color of
       black then this becomes hard to read!  We just hardcode this
       to be white since the background defaults to being black */
    SetTextColor(hDC, (DWORD) -1);
#else
    SetTextColor(hDC, GetSysColor(COLOR_CAPTIONTEXT));
#endif

    /* Get the height and width of the scroll bars. */
    dypScrlBar = GetSystemMetrics(SM_CYHSCROLL);
    dxpScrlBar = GetSystemMetrics(SM_CXVSCROLL);

    /* Set the ranges of the horizontal and vertical scroll bars. */
    SetScrollRange(wwdCurrentDoc.hHScrBar, SB_CTL, 0, xpRightLim, TRUE);
    SetScrollRange(wwdCurrentDoc.hVScrBar, SB_CTL, 0, drMax - 1, TRUE);

    return;
Error:
    fMessageInzFailed = TRUE;
}




void MdocCreate(hWnd, lParam)
register HWND  hWnd;
LONG  lParam;
{
    vhWnd = wwdCurrentDoc.wwptr = hWnd;
    wwdCurrentDoc.hDC = GetDC( hWnd );
    if ( wwdCurrentDoc.hDC == NULL )
        {
        fMessageInzFailed = TRUE;
        return;
        }

    /* Set the DC to transparent mode. */
    SetBkMode( wwdCurrentDoc.hDC, TRANSPARENT );

    /* Set the background and foreground colors. */
    SetBkColor( wwdCurrentDoc.hDC, rgbBkgrnd );
    SetTextColor( wwdCurrentDoc.hDC, rgbText );

    /* Set the background brush. */
    SelectObject( wwdCurrentDoc.hDC, hbrBkgrnd );

}


STATIC HANDLE NEAR HszCreateIdpmt(idpmt)
int idpmt;
{
    /* Create a heap string and fill it with a string from the resource file. */
    char szTmp[cchMaxSz];

    return (LoadString(hMmwModInstance, idpmt, (LPSTR)szTmp, sizeof(szTmp)) == 0 ? NULL :
      HszGlobalCreate(szTmp));
}


#if defined(INTL) && defined(WIN30)
/* Routine to load some strings from write.rc.  These strings
   used to be placed in globdefs.h.    fernandd  10/20/89     */

BOOL FInitIntlStrings(hInstance)
HANDLE hInstance;
    {
    extern  CHAR    szMode[30];
    extern  CHAR    szWriteDocPrompt[25];
    extern  CHAR    szScratchFilePrompt[25];
    extern  CHAR    szSaveFilePrompt[25];
#if defined(KOREA)  // jinwoo : 10/16/92
    extern  CHAR    szAppName[13];
#else
    extern  CHAR    szAppName[10];
#endif
    extern  CHAR    szUntitled[20];
    extern  CHAR    sziCountryDefault[5];
    extern  CHAR    szWRITEText[30];
    extern  CHAR    szFree[15];
    extern  CHAR    szNone[15];
    extern  CHAR    szHeader[15];
    extern  CHAR    szFooter[15];
    extern  CHAR    szLoadFile[25];
    extern  CHAR    szCvtLoadFile[45];
    extern  CHAR    szAltBS[15];
    extern  CHAR    *mputsz[];

#ifdef JAPAN /*t-Yoshio T-HIROYN Win3.1 */
    extern  CHAR    Zenstr1[256];
    extern  CHAR    Zenstr2[256];
// default Font Face Name . We use this FInitFontEnum()
    extern  CHAR    szDefFFN0[10];
    extern  CHAR    szDefFFN1[10];

    LoadString(hInstance, IDSTRZen1,(LPSTR)Zenstr1,sizeof(Zenstr1));
    LoadString(hInstance, IDSTRZen2,(LPSTR)Zenstr2,sizeof(Zenstr2));
    LoadString(hInstance, IDSdefaultFFN0, (LPSTR)szDefFFN0,sizeof(szDefFFN0));
    LoadString(hInstance, IDSdefaultFFN1, (LPSTR)szDefFFN1,sizeof(szDefFFN1));
#elif defined(KOREA)
    extern  CHAR    Zenstr1[256];
    LoadString(hInstance, IDSTRZen1,(LPSTR)Zenstr1,sizeof(Zenstr1));
#endif

    if (LoadString(hInstance, IDSTRModeDef,              (LPSTR)szMode,              sizeof(szMode)) &&
        LoadString(hInstance, IDSTRWriteDocPromptDef,    (LPSTR)szWriteDocPrompt,    sizeof(szWriteDocPrompt)) &&
        LoadString(hInstance, IDSTRScratchFilePromptDef, (LPSTR)szScratchFilePrompt, sizeof(szScratchFilePrompt)) &&
        LoadString(hInstance, IDSTRSaveFilePromptDef,    (LPSTR)szSaveFilePrompt,    sizeof(szSaveFilePrompt)) &&
        LoadString(hInstance, IDSTRAppNameDef,           (LPSTR)szAppName,           sizeof(szAppName)) &&
        LoadString(hInstance, IDSTRUntitledDef,          (LPSTR)szUntitled,          sizeof(szUntitled)) &&
        LoadString(hInstance, IDSTRiCountryDefaultDef,   (LPSTR)sziCountryDefault,    sizeof(sziCountryDefault)) &&
        LoadString(hInstance, IDSTRWRITETextDef,         (LPSTR)szWRITEText,         sizeof(szWRITEText)) &&
        LoadString(hInstance, IDSTRFreeDef,              (LPSTR)szFree,              sizeof(szFree)) &&
        LoadString(hInstance, IDSTRNoneDef,              (LPSTR)szNone,              sizeof(szNone)) &&
        LoadString(hInstance, IDSTRHeaderDef,            (LPSTR)szHeader,            sizeof(szHeader)))
            {
            if (LoadString(hInstance, IDSTRFooterDef,            (LPSTR)szFooter,            sizeof(szFooter)) &&
                LoadString(hInstance, IDSTRLoadFileDef,          (LPSTR)szLoadFile,          sizeof(szLoadFile)) &&
                LoadString(hInstance, IDSTRCvtLoadFileDef,       (LPSTR)szCvtLoadFile,       sizeof(szCvtLoadFile)) &&
                LoadString(hInstance, IDSTRAltBSDef,             (LPSTR)szAltBS,             sizeof(szAltBS)) &&
                LoadString(hInstance, IDSTRInchDef,           (LPSTR)mputsz[0], 6) &&
                LoadString(hInstance, IDSTRCmDef,             (LPSTR)mputsz[1], 6) &&
                LoadString(hInstance, IDSTRP10Def,            (LPSTR)mputsz[2], 6) &&
                LoadString(hInstance, IDSTRP12Def,            (LPSTR)mputsz[3], 6) &&
                LoadString(hInstance, IDSTRPointDef,          (LPSTR)mputsz[4], 6) &&
                LoadString(hInstance, IDSTRLineDef,           (LPSTR)mputsz[5], 6))
                return(fTrue);
            }
    /* else */
    return(fFalse);
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\insert.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* insert.c -- MW insertion routines */
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOHDC
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
//#define NOATOM
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "docdefs.h"
#include "editdefs.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#define NOSTRERRORS
#include "str.h"
#include "propdefs.h"
#include "fmtdefs.h"
#include "fkpdefs.h"
#include "ch.h"
#include "winddefs.h"
#include "fontdefs.h"
#include "debug.h"
#if defined(OLE)
#include "obj.h"
#endif
#ifdef DBCS
#include "dbcs.h"
#endif

#ifdef JAPAN //T-HIROYN Win3.1
#include "kanji.h"
int    changeKanjiftc = FALSE;
int    newKanjiftc = ftcNil;
#endif

/* E X T E R N A L S */

extern HWND vhWnd;  /* WINDOWS: Handle of the current document display window*/
extern MSG  vmsgLast;   /* WINDOWS: last message gotten */
extern HWND hParentWw;  /* WINDOWS: Handle for parent (MENU) window */

extern int vfSysFull;
extern int vfOutOfMemory;
extern int vxpIns;
extern int vdlIns;
extern struct PAP vpapAbs;
extern struct UAB vuab;
extern struct CHP vchpNormal;
extern int vfSeeSel;
extern int vfInsLast;
extern struct FCB (**hpfnfcb)[];
extern typeCP vcpLimParaCache;
extern typeCP vcpFirstParaCache;
extern typeCP CpMax();
extern typeCP CpMin();
extern CHAR rgchInsert[cchInsBlock]; /* Temporary insert buffer */
extern typeCP cpInsert; /* Beginning cp of insert block */
extern int ichInsert; /* Number of chars used in rgchInsert */
extern struct CHP vchpInsert;
extern int vfSelHidden;
extern struct FKPD vfkpdParaIns;
extern struct FKPD vfkpdCharIns;
extern struct PAP vpapPrevIns;
extern typeFC fcMacPapIns;
extern typeFC fcMacChpIns;
extern struct CHP vchpSel;
extern struct FLI vfli;
extern struct PAP *vppapNormal;
extern typeCP cpMinCur;
extern typeCP cpMacCur;
extern struct SEL selCur;
extern int docCur;
extern struct WWD rgwwd[];
extern struct DOD (**hpdocdod)[];
extern int wwCur;
extern struct CHP vchpFetch;
extern struct SEP vsepAbs;
extern int vfCommandKey;
extern int vfShiftKey;
extern int vfOptionKey;
extern int vfInsEnd;
extern typeCP cpWall;
extern int vfDidSearch;
extern int vdocParaCache;
extern typeCP vcpFetch;
extern int vccpFetch;
extern CHAR *vpchFetch;
extern struct CHP vchpFetch;
extern int ferror;
extern BOOL vfInvalid;
extern int docUndo;
extern struct EDL *vpedlAdjustCp;
extern int wwMac;
extern int vfFocus;
extern int vkMinus;

#ifdef CASHMERE
extern int vfVisiMode;      /* Whether "show fmt marks" mode is on */
extern int vwwCursLine;     /* Window containing cursor */
#endif

extern int vfLastCursor;    /* Whether up/down arrow xp goal position is valid */


/* state of the cursor line */
extern int vxpCursLine;
extern int vypCursLine;
extern int vdypCursLine;
extern int vfInsertOn;

/* G L O B A L S */
/* The following used to be defined here */

extern int vcchBlted;         /* # chars blted to screen, before line update */
extern int vidxpInsertCache;  /* current index of insertion into char width cache */
extern int vdlIns;
extern int vxpIns;
extern int vfTextBltValid;
extern int vfSuperIns;
extern int vdypLineSize;
extern int vdypCursLineIns;
extern int vdypBase;
extern int vypBaseIns;
extern int vxpMacIns;
extern int vdypAfter;
extern struct FMI vfmiScreen;

#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif

/* Used in this module only */

typeCP cpStart;    /* Start cp of the replacement operation that an Insert is */
typeCP cpLimInserted;  /* Last cp inserted */
typeCP cpLimDeleted;   /* Last cp deleted */

/* Enumerated type telling what to update  */
/* Ordering is such that larger numbers mean that there is more to update */

#define mdInsUpdNothing     0
#define mdInsUpdNextChar    1
#define mdInsUpdOneLine     2
#define mdInsUpdLines       3
#define mdInsUpdWhole       4

void NEAR FormatInsLine();
void NEAR DelChars( typeCP, int );
void NEAR EndInsert();
int  NEAR XpValidateInsertCache( int * );
int NEAR FBeginInsert();

#ifdef DBCS
CHAR near GetDBCSsecond();
BOOL      FOptAdmitCh(CHAR, CHAR);
int NEAR MdInsUpdInsertW( WORD, WORD, RECT *);
#else
int NEAR MdInsUpdInsertCh( CHAR, CHAR, RECT *);
#endif /* ifdef DBCS */

#ifdef  KOREA
int     IsInterim = 0;
int     WasInterim = 0;
BOOL    fInterim = FALSE; // MSCH bklee 12/22/94
#endif


#ifdef DEBUG
int vTune = 0;
#endif




/*      AlphaMode -- Handler for insertion, backspace, and forward delete

     Alpha mode works by inserting a block of cchInsBlock cp's at the
insertion point. The inserted piece has fn == fnInsert, cpMin == 0.
We AdjustCp for this block as though it contained cchInsBlock cp's,
even though it is initially "empty".

    When a character is typed, it is inserted at rgchInsert[ ichInsert++ ].
When rgchInsert is full, it is written to the scratch file, and
Replace'd with a new insertion block.

    AlphaMode exits when it encounters a key or event that it cannot handle
(e.g. cursor keys, mouse hits). It then cleans up, writing the insertion
block to the scratch file, and returns

    "Fast Insert" is achieved by writing characters directly to the screen
and scrolling the rest of the line out of the way.  The line is not updated
until it is necessary (or until we fall through the delay in KcInputNextKey).

    During "Fast Insert" (or fast backspace or fast delete), it is important
that ValidateTextBlt will usually NOT be called unless the line containing
the insertion point has been made valid. Otherwise, ValidateTextBlt will
fail to find a valid vdlIns, and call CpBeginLine, which forces an
update of the entire screen.
*/

#ifdef KOREA                   /* global to MdUpIns 90.12.28 */
int     dxpCh;
#endif


/* A L P H A  M O D E */
AlphaMode( kc )
int kc;         /* Keyboard Character */
{
 int rgdxp[ ichMaxLine ];
 int chShow, dlT, fGraphics;
 int mdInsUpd;
 int fDocDirty = (**hpdocdod) [docCur].fDirty;
 register struct EDL *pedl;
 int xpInsLineMac;

 int fGotKey = fFalse;
 int kcNext;
 int fScrollPending = fFalse;
 int dxpPending;
 int fDelPending = fFalse;
 typeCP cpPending;
 int cchPending;
 int mdInsUpdPending = mdInsUpdNothing;

#ifdef DBCS
 BOOL   fResetMdInsUpd = TRUE; /* To avoid the blinking cursor at beg. doc or eod. */
 CHAR   chDBCS2 = '\0'; /* Used to hold the second byte of a DBCS character */
#endif /* DBCS */

#ifdef JAPAN //T-HIROYN Win3.1
RetryAlpha:
    if(changeKanjiftc) {
        changeKanjiftc = FALSE;
        ApplyCLooks(&vchpSel, sprmCFtc, newKanjiftc);
    }
    changeKanjiftc = FALSE;
#endif

#ifdef DBCS                         /* was in JAPAN */
    if( kc == 0x000d )
          kc = 0x000a;
#endif

 if (!FWriteOk( fwcReplace ))
    {   /* Not OK to write on docCur (read-only OR out of memory) */
    _beep();
    return;
    }

/* Shut down the caret blink timer -- we don't want its messages or its cost */

#ifndef DBCS                    /* was in JAPAN */
 KillTimer( vhWnd, tidCaret );
#endif

#ifdef OLDBACKSPACE
/* Backspace in Win 3.0 has been changed to function
   identically like the Delete key ..pault 6/20/89 */

/* Handle BACKSPACE when there's a selection. DELETE with selection has already
   been filtered out by KcAlphaKeyMessage */
if (kc == kcDelPrev)
        /* Make a selection at selection-start preparatory to deleting previous
           char, which is accomplished in the loop. */
        Select( selCur.cpFirst, selCur.cpFirst );
#endif

    /* Set up initial limits for UNDO */
 cpStart = selCur.cpFirst;          /* Starting cp for insertion */
 cpLimDeleted = selCur.cpLim;       /* Last cp Deleted */

/* Delete the selection, and make an insert point selection in its stead */
/* Insert point selection inherits the properties of the deleted text */
 if (selCur.cpFirst < selCur.cpLim)
    {
    struct CHP chp;
    typeCP cpT;

    fDocDirty = TRUE;
    cpT = selCur.cpFirst;
    /* Get properties of the deleted text */
    FetchCp(docCur, cpT, 0, fcmProps);
    blt( &vchpFetch, &chp, cwCHP );
    if (fnClearEdit(OBJ_INSERTING))
        goto Abort;
    UpdateWw( wwCur, FALSE );
    if (ferror)
        goto Abort;
    Select(cpT, cpT);
    blt( &chp, &vchpSel, cwCHP );
    }
 else
    {    /* Current selection is 0 chars wide, no need to delete */
         /* Set up UNDO */
    noUndo:
    NoUndo();   /* Don't combine adjacent operations or
                   vuab.cp = cp in DelChars will be wrong */
    SetUndo( uacDelNS, docCur, cpStart, cp0, docNil, cpNil, cp0, 0);
    }

 fGraphics = FBeginInsert();

 Scribble( 7, (vfSuperIns ? 'S' : 'I') );

 vfSelHidden = false;
 vfTextBltValid = FALSE;

 if (ferror)
        /* Ran out of memory trying to insert */
    goto Abort;

 if (fGraphics)
    {
    selCur.cpFirst = selCur.cpLim = cpInsert + cchInsBlock;
/* this is to display the paragraph that has been automatically inserted
by edit in FBeginInsert */
    UpdateWw(wwCur, fFalse);
    if (kc == kcReturn)
        kc = kcNil;
    }

 for ( ; ; (fGotKey ? (fGotKey = fFalse, kc = kcNext) : (kc = KcInputNextKey())) )
    {           /* Loop til we get a command key we can't handle */
                /* KcInputNextKey will return kcNil if a nonkey */
                /* event occurs */
    RECT rc;
#ifndef  KOREA               /* has been defined globally */
    int dxpCh;
#endif

    typeCP cpFirstEdit=cpInsert + ichInsert;

    chShow = kc;
    mdInsUpd = mdInsUpdNothing;

        /* Force exit from loop if out of heap or disk space */
    if (vfSysFull || vfOutOfMemory)
        kc = kcNil;

#ifdef DBCS
    if (kc != kcDelPrev && kc != kcDelNext) {
        fResetMdInsUpd = TRUE;
        }
#endif /* DBCS */

    if (!vfTextBltValid)
        ValidateTextBlt();
    Assert( vdlIns >= 0 );
    pedl = &(**wwdCurrentDoc.hdndl) [vdlIns];
    FreezeHp();

    SetRect( (LPRECT)&rc, vxpIns+1, pedl->yp - pedl->dyp,
             wwdCurrentDoc.xpMac,
             min(pedl->yp, wwdCurrentDoc.ypMac));

    vfli.doc = docNil;

/* this is a speeder-upper of the switch below */
    if (kc <= 0)
        switch (kc)
            {
/*********************************************************************
 ********** START OF BACKSPACE/FORWARD DELETE CODE *******************
 *********************************************************************/
            CHAR chDelete;      /* Variables for Backspace/Delete */
            typeCP cpDelete;
            int cchDelete;
            int idxpDelete;
            int fCatchUp;
#ifdef DBCS
            typeCP cpT;

            case kcDelNext: /* Delete following character */
                cpT = selCur.cpFirst;
                if (fDelPending) {
                    cpT += cchPending;
                    }
                if (cpT >= cpMacCur) {
                    _beep();
                    MeltHp();
                    if (fResetMdInsUpd) {
                        mdInsUpd = mdInsUpdOneLine;
                        fResetMdInsUpd = FALSE;
                        }
                    goto DoReplace; /* Clean up pending replace ops */
                    }

                cpDelete  = CpFirstSty(cpT, styChar);
                cchDelete = CpLimSty(cpDelete, styChar) - cpDelete;
                goto DeleteChars;

            case kcDelPrev: /* Delete previous char */
                /* To reflect the state of cpPending and cchPending so that  */
                /* CpFirstSty( , styChar) is called with a proper cp.        */
                cpT = cpFirstEdit - 1;
                if (fDelPending) {
                    cpT -= cchPending;
                    }
                if (cpT < cpMinCur) {
                    _beep();
                    MeltHp();
                    if (fResetMdInsUpd) {
                        mdInsUpd = mdInsUpdOneLine;
                        fResetMdInsUpd = FALSE;
                        }
                    goto DoReplace;
                    }

                cpDelete = CpFirstSty(cpT, styChar);
                cchDelete = CpLimSty(cpDelete, styChar) - cpDelete;

#if defined(NEED_FOR_NT351_TAIWAN)  //Removed by bklee //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/24/93
    if ( cchDelete > 1 && (cpDelete + cchDelete + cchInsBlock) > cpMacCur )
        cchDelete = 1;
#endif  TAIWAN

#else
            case kcDelNext: /* Delete following character */
                cpDelete = selCur.cpFirst;
                if (fDelPending)
                    cpDelete += cchPending;

                if (cpDelete >= cpMacCur)
                    {
                    _beep();
                    MeltHp();
                    goto DoReplace;     /* Clean up pending replace ops */
                    }
                FetchCp( docCur, cpDelete, 0, fcmChars );
                chDelete = *vpchFetch;
                cchDelete = 1;
#ifdef CRLF
                if ((chDelete == chReturn) && (*(vpchFetch+1) == chEol) )
                    {
                    cchDelete++;
                    chDelete = chEol;
                    }
#endif
                goto DeleteChars;

            case kcDelPrev: /* Delete previous char */
                    /* Decide what char, cp we're deleting */
                cpDelete = cpFirstEdit - 1;
                if (fDelPending)
                    cpDelete -= cchPending;

                if (cpDelete < cpMinCur)
                    {
                    _beep();
                    MeltHp();
                    goto DoReplace;     /* Clean up pending replace ops */
                    }
                FetchCp( docCur, cpDelete, 0, fcmChars );
                chDelete = *vpchFetch;
                cchDelete = 1;
#ifdef CRLF
                if ( (chDelete == chEol) && (cpDelete > cpMinCur) )
                    {
                    FetchCp( docCur, cpDelete - 1, 0, fcmChars );
                    if (*vpchFetch == chReturn)
                        {
                        cchDelete++;
                        cpDelete--;
                        }
                    }
#endif
#endif /* DBCS */

DeleteChars:
#ifdef DBCS
                /* They expect chDelete as well as cpDelete and cchDelete */
                FetchCp(docCur, cpDelete, 0, fcmChars);
                chDelete = *vpchFetch;
#endif

                /* Here we have cpDelete, cchDelete */
                /* Also cchPending and cpPending if fDelPending is TRUE */
                /* Also dxpPending if fScrollPending is TRUE */

                if ( CachePara( docCur, cpDelete ), vpapAbs.fGraphics)
                    {   /* Trying to del over picture, illegal case */
                    _beep();
                    MeltHp();
                    goto DoReplace;     /* Clean up pending replace ops */
                    }

                /* Insert properties are now the properties of the
                   deleted char(s) */

                FetchCp( docCur, cpDelete, 0, fcmProps );
                vchpFetch.fSpecial = FALSE;
                NewChpIns( &vchpFetch );

                /* Pending replace operation <-- union of any pending
                             replace operations with the current one */

                if (fDelPending)
                    {
                    if (cpPending >= cchDelete)
                        {
                        cchPending += cchDelete;
                        if (kc == kcDelPrev)
                            cpPending -= cchDelete;
                        }
                    else
                        Assert( FALSE );
                    }
                else
                    {
                    cpPending = cpDelete;
                    cchPending = cchDelete;
                    fDelPending = TRUE;
                    }

                /* Determine whether the screen update for the current
                   deletion can be accomplished by scrolling.
                   We can scroll if:
                      (1) we are still on the line vdlIns,
                      (2) we are not deleting eol or chsect,
                      (3) our width cache is good OR vdlIns is valid, so we can
                          validate the cache w/o redisplaying the line
                */

                mdInsUpd = mdInsUpdOneLine;
                if ((idxpDelete = (int) (cpDelete - pedl->cpMin)) < 0)
                    {
                    mdInsUpd = mdInsUpdLines;
                    }
                else if ((chDelete != chEol) && (chDelete != chSect) &&
                         (vidxpInsertCache != -1 || pedl->fValid) &&
                         (mdInsUpdPending < mdInsUpdOneLine))
                    {   /* OK to scroll -- do all pending scrolls */
                    int fDlAtEndMark;
                    int fCatchUp;

                    MeltHp();
                            /* Re-entrant heap movement */
                    fCatchUp = FImportantMsgPresent();

                     if (vidxpInsertCache == -1)
                        {   /* Width cache is invalid, update it */
                        xpInsLineMac = XpValidateInsertCache( rgdxp ); /* HM */
                        }

                    pedl = &(**wwdCurrentDoc.hdndl) [vdlIns];
                    FreezeHp();

                    /* Obtain display width of character to delete */

                    if ((vcchBlted > 0) && (kc == kcDelPrev))
                        {   /* Deleted char was blted in superins mode
                               onto a line that has not been updated */
                        vcchBlted--;
                        /* Because chDelete is always 1 byte quantity
                           by itself or the 1st byte of the DBCS character
                           it is OK. */
                        dxpCh = DxpFromCh( chDelete, FALSE );
                        }
                    else
                        {
                        int idxpT = idxpDelete + cchDelete;

#ifdef DBCS
                        /* For the following segment of code to work,
                           an element in rgdxp corresponding to the second
                           byte of a DBCS character must contain 0. */
                        int *pdxpT;
                        int cchT;

                        for (dxpCh = 0, pdxpT = &rgdxp[idxpDelete], cchT = 0;
                             cchT < cchDelete;
                             dxpCh += *pdxpT++, cchT++);
#else
                        dxpCh = rgdxp[ idxpDelete ];
#endif

                        /* Adjust the character width cache to eliminate
                           width entries for deleted chars */

                        if ((vidxpInsertCache >= 0) &&
                            (idxpDelete >= 0) &&
                            (idxpT <= pedl->dcpMac) )
                            {
                            blt( &rgdxp[ idxpT ], &rgdxp[ idxpDelete ],
                                                  ichMaxLine - idxpT );

                            if (vidxpInsertCache > idxpDelete)
                                /* Deleted behind insert point, adjust index */
                                vidxpInsertCache -= cchDelete;
                            }
                        else
                            vidxpInsertCache = -1;
                        }

                    /* pending scroll op <-- current scroll op merged
                                            with pending scroll op */
                    if (fScrollPending)
                        {
                        dxpPending += dxpCh;
                        }
                    else
                        {
                        dxpPending = dxpCh;
                        fScrollPending = fTrue;
                        }

                    /* See if we should postpone the scroll */

                    if (fCatchUp)
                        {
                        MeltHp();
                        Assert( !fGotKey );
                        fGotKey = TRUE;
                        if ((kcNext = KcInputNextKey()) == kc)
                            {   /* Next key is same as this key, process NOW */
                            continue;
                            }
                        FreezeHp();
                        }

                    /* Perform all pending scrolls */

                    fScrollPending = fFalse;
                    if (dxpPending > 0)
                        {
                        ClearInsertLine();
                        if (kc == kcDelPrev)
                            {   /* Backspace */
                            vxpCursLine = (vxpIns -= dxpPending);
                            rc.left -= dxpPending;
                            }
                        ScrollCurWw( &rc, -dxpPending, 0 );
                        DrawInsertLine();
                        xpInsLineMac -= dxpPending;
                        }

                    /* See if we can get away without updating the screen
                       (and without invalidating the insert cache) */

#define cchGetMore         4
#define dxpGetMore         ((unsigned)dxpCh << 3)

                    /* Check for running out of chars ahead of the cursor */

                    fDlAtEndMark = (pedl->cpMin + pedl->dcpMac >= cpMacCur);

                    if ( (kc != kcDelNext && fDlAtEndMark) ||
                         ((idxpDelete + cchGetMore < pedl->dcpMac) &&
                          ( (int) (xpInsLineMac - vxpIns) > dxpGetMore) ))
                        {
                        mdInsUpd = mdInsUpdNothing;
                        }

                    /* Special check to avoid two end marks: see if the
                       dl after the ins line is dirty and beyond the
                       doc's end */

                    if (fDlAtEndMark &&
                        (vdlIns < wwdCurrentDoc.dlMac - 1) &&
                        !(pedl+1)->fValid)
                        {
                        mdInsUpd = mdInsUpdLines;
                        }
                    }   /* End of "if OK to scroll" */

                /* See if we should postpone the replace */

                MeltHp();
                    /* Re-entrant Heap Movement */
                if (FImportantMsgPresent() && !fGotKey)
                    {
                    fGotKey = TRUE;
                    if ((kcNext = KcInputNextKey()) == kc)
                        {   /* Next key is same as this key, process NOW */
                        if (mdInsUpd > mdInsUpdPending)
                            {
                                /* Mark screen update as pending */
                            mdInsUpdPending = mdInsUpd;
                            vidxpInsertCache = -1;
                            }
                        continue;
                        }
                    }

                /* Handle actual replacement of chars */

DoReplace:      if (fDelPending)
                    {
                    DelChars( cpPending, cchPending );  /* HM */
                    fDelPending = fFalse;
                    }

                /* Set up screen update based on present & pending needs */

                if (mdInsUpdPending > mdInsUpd)
                    mdInsUpd = mdInsUpdPending;

                if (mdInsUpd >= mdInsUpdOneLine)
                        /* If we're updating at least a line, assume we're
                           handling all necessary pending screen update */
                    mdInsUpdPending = mdInsUpdNothing;

                    /* Adjust vdlIns's dcpMac. vdlIns is invalid anyway,
                       and this allows us to catch the case
                       in which we run out of visible characters to scroll
                       in the forward delete case. See update test after
                       the scroll above */
                (**wwdCurrentDoc.hdndl) [vdlIns].dcpMac -= cchPending;

                /* this is here to compensate for RemoveDelFtnText */

                selCur.cpFirst = selCur.cpLim = cpInsert + (typeCP)cchInsBlock;
                cpFirstEdit = cpPending;

                goto LInvalIns;    /* Skip ahead to update the screen */
/*********************************************************************
 ************ END OF BACKSPACE/FORWARD DELETE CODE *******************
 *********************************************************************/

            case kcReturn:          /* Substitute EOL for return key */
                                    /* Also add a return if CRLF is on */
                MeltHp();
#ifdef CRLF
#ifdef DBCS
                MdInsUpdInsertW( MAKEWORD(0, chReturn),
                                 MAKEWORD(0, chReturn), &rc );
#else
                MdInsUpdInsertCh( chReturn, chReturn, &rc );
#endif /* DBCS */
#endif
                FreezeHp();
                kc = chEol;
                break;
#ifdef CASHMERE   /* These key codes are omitted from MEMO */
            case kcNonReqHyphen:    /* Substitute for non-required hyphen */
                kc = chNRHFile;
                chShow = chHyphen;
                break;
            case kcNonBrkSpace:     /* Substitute for non-breaking space */
                kc = chNBSFile;
                chShow = chSpace;
                break;
            case kcNLEnter:         /* Substitute for non-para return */
                kc = chNewLine;
                break;
#endif
#ifdef PRINTMERGE
            case kcLFld:        /* Substitite for Left PRINT MERGE bracket */
                chShow = kc = chLFldFile;
                break;
            case kcRFld:        /* Substitute for Right PRINT MERGE bracket */
                chShow = kc = chRFldFile;
                break;
#endif
            case kcPageBreak:
                kc = chSect;        /* Page break (no section) */
                if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
                    {   /* Page breaks prohibited in header/footer */
BadKey:             _beep();
                    MeltHp();
                    continue;
                    }
                break;
            case kcTab:             /* Tab */
                kc = chTab;
                break;
            default:
#if WINVER >= 0x300
                if (kc == kcNonReqHyphen)    /* Substitute for non-required hyphen */
                    {
                    /* no longer a const so can't be directly in switch */
                    kc = chNRHFile;
                    chShow = chHyphen;
                    break;
                    }
#endif
                            /* AlphaMode Exit point: Found key or event
                               that we don't know how to handle */
                MeltHp();
                goto EndAlphaMode;
                }       /* end of if kc < 0 switch (kc) */
    MeltHp();

#ifdef DBCS
    if (IsDBCSLeadByte(kc)) {
        /* We are dealing with the first byte of the DBCS character. */
        /* In case of DBCS letter, wInsert is equal to wShow. */
#ifdef JAPAN //T-HIROYN Win3.1
        if( ftcNil != (newKanjiftc = GetKanjiFtc(&vchpInsert)) ) {   //(menu.c)
            changeKanjiftc = TRUE;
            goto EndAlphaMode;
        }
#endif
        if ((chDBCS2 = GetDBCSsecond()) != '\0') {
            mdInsUpd = MdInsUpdInsertW( MAKEWORD(kc, chDBCS2),
                                        MAKEWORD(kc, chDBCS2), &rc );
        }
    } else {
#ifdef JAPAN //T-HIROYN Win3.1
        if (FKana(kc)) {
            if( ftcNil != (newKanjiftc = GetKanjiFtc(&vchpInsert)) ) {
                changeKanjiftc = TRUE;
                goto EndAlphaMode;
            }
        }
#endif
        mdInsUpd = MdInsUpdInsertW( MAKEWORD(0, kc), MAKEWORD(0, chShow), &rc);
    }
#else
/* Insert character kc into the document. Show character chShow (which is
equal to kc except for cases such as non-breaking space, etc. */
    mdInsUpd = MdInsUpdInsertCh( kc, chShow, &rc );
#endif /* DBCS */

/* common for insert and backspace: invalidate line and previous line if
dependency warrants it */
/* have vdlIns from ValidateTextBlt */
LInvalIns:
    pedl = &(**wwdCurrentDoc.hdndl) [vdlIns];
    pedl->fValid = fFalse;
    wwdCurrentDoc.fDirty = fTrue;

    Assert( vdlIns >= 0 );
    if ((dlT = vdlIns) == 0)
        {   /* Editing in first line of window */
        if ( wwdCurrentDoc.fCpBad ||
             (wwdCurrentDoc.cpFirst + wwdCurrentDoc.dcpDepend > cpFirstEdit) )
            {   /* Edit affects ww's first cp; recompute it */
            CtrBackDypCtr( 0, 0 );
            (**wwdCurrentDoc.hdndl) [vdlIns].cpMin = CpMax( wwdCurrentDoc.cpMin,
                                                      wwdCurrentDoc.cpFirst );
            mdInsUpd = mdInsUpdLines;
            }
        }
    else
        {   /* If the edit affects the line prior to vdlIns, invalidate it */
        --pedl;
#ifdef DBCS
        if (!IsDBCSLeadByte(kc)) {
            chDBCS2 = kc;
            kc = '\0';
            }
#endif /* DBCS */
        if ((pedl->cpMin + pedl->dcpMac + pedl->dcpDepend > cpFirstEdit))
            {
                pedl->fValid = fFalse;
                dlT--;
            }
#ifdef  DBCS    /* was in JAPAN; KenjiK '90-11-03 */
                // deal with the character beyond end of the line.
        else
#ifdef  KOREA  /* protect from displaying picture abnormally */
            if(((pedl+1)->cpMin == cpFirstEdit && FOptAdmitCh(kc, chDBCS2))
                && !pedl->fGraphics)
#else
            if ((pedl+1)->cpMin == cpFirstEdit && FOptAdmitCh(kc, chDBCS2))
#endif
            {
                /* We do exactly the same as above, except setting
                   mdInsUpd, because the one returned by MdInsUpdInsertW()
                   does not reflect this condition. */
                pedl->fValid = fFalse;
                dlT--;
                mdInsUpd = mdInsUpdOneLine;
            }
#endif
        else
            pedl++;
        }
#ifdef ENABLE   /* We now support end-of-line cursor while inserting because of
                   typing before splats */
    if (vfInsEnd)
        {   /* forget about special end-of-line cursor */
        vfInsEnd = fFalse;
        ClearInsertLine();
        }
#endif

#ifdef  KOREA   /* 90.12.28 sangl */
{
BOOL    UpNext=FALSE;
screenup:
#endif

    switch (mdInsUpd) {

        default:
        case mdInsUpdNothing:
        case mdInsUpdNextChar:
            break;
        case mdInsUpdLines:
        case mdInsUpdOneLine:
            ClearInsertLine();
            if ( FUpdateOneDl( dlT ) )
                {   /* Next line affected */
                struct EDL *pedl;

                if ( (mdInsUpd == mdInsUpdLines) ||
                        /* Re-entrant heap movement */
                     !FImportantMsgPresent() ||
                     (pedl = &(**wwdCurrentDoc.hdndl) [dlT],
                       (selCur.cpFirst >= pedl->cpMin + pedl->dcpMac)))
                    {
                    FUpdateOneDl( dlT + 1 );
                    }
                }
#ifdef  KOREA   /* 90.12.28 sangl */
            else if (UpNext && ((dlT+1) < wwdCurrentDoc.dlMac))
                        FUpdateOneDl(dlT + 1);
#endif
            ToggleSel(selCur.cpFirst, selCur.cpLim, fTrue);
            break;

        case mdInsUpdWhole:
            ClearInsertLine();
            UpdateWw(wwCur, fFalse);
            ToggleSel(selCur.cpFirst, selCur.cpLim, fTrue);
            break;
            }   /* end switch (mdInsUpd) */
#ifdef  KOREA   /* 90.12.28 sangl */
    if (IsInterim) {
        if (mdInsUpd>=mdInsUpdOneLine) {
                ClearInsertLine();
                vxpCursLine -= dxpCh;
                DrawInsertLine();
        }

//      while ( ((kc=KcInputNextHan()) < 0xA1) || (kc>0xFE) );
        while ( (((kc=KcInputNextHan()) < 0x81) || (kc>0xFE)) && (kc != VK_MENU));  // MSCH bklee 12/22/94

        if(kc == VK_MENU) { // MSCH bklee 12/22/94
           fInterim = IsInterim = 0;
           ichInsert -= 2;
           goto nextstep;
        }

        chDBCS2 = GetDBCSsecond();
        mdInsUpd = MdInsUpdInsertW(MAKEWORD(kc, chDBCS2),
                                        MAKEWORD(kc, chDBCS2), &rc);
        if (vfSuperIns)
                goto LInvalIns; /* This is for large size, when 1st interim
                                   becomes final (ex, consonants) */
        else {
                UpNext = TRUE;  /* For italic, try to FUpdateOneDl for
                                   current line */
                goto screenup;  /* 90.12.28 sangl */
        }
    }                           /* ex: all consonants */
}               /* For screenup: 90.12.28 sangl */

nextstep : // MSCH bklee 12/22/94

/*        if(IsInterim && kc == VK_MENU) { // MSCH bklee 12/22/94
           ClearInsertLine();
           UpdateWw(wwCur, fFalse);
           goto EndAlphaMode;
        } */

        if (WasInterim)
          { MSG msg;
            int wp;

            if (PeekMessage ((LPMSG)&msg, vhWnd, WM_KEYDOWN, WM_KEYUP, PM_NOYIELD | PM_NOREMOVE) )
                        { if( msg.message==WM_KEYDOWN &&
                                ( (wp=msg.wParam)==VK_LEFT || wp==VK_UP || wp==VK_RIGHT ||
                                        wp==VK_DOWN || wp==VK_DELETE) )
                                        goto EndAlphaMode;
                        }
                WasInterim = 0;
            }
#endif  /* KOREA */
    } /* end for */

EndAlphaMode:
 Scribble( 7, 'N' );
 EndInsert();       /* Clean Up Insertion Block */
#ifdef CASHMERE
 UpdateOtherWws(fFalse);
#endif

 if (cpLimInserted != cpStart)
    {   /* We inserted some characters */
    SetUndo( uacInsert, docCur, cpStart,
                             cpLimInserted - cpStart, docNil, cpNil, cp0, 0 );
    SetUndoMenuStr(IDSTRUndoTyping);
    }
 else if (cpLimDeleted == cpStart)
        /* This AlphaMode invocation had no net effect */
    {
Abort:
    NoUndo();
    if (!fDocDirty)
            /* The doc was clean when we started, & we didn't change it, so
               it's still clean */
        (**hpdocdod) [docCur].fDirty = FALSE;
    }

 vfLastCursor = fFalse; /* Tells MoveUpDown to recalc its xp seek position */
 if (vfFocus)
    {
    /* Restore the caret blink timer */
    SetTimer( vhWnd, tidCaret, GetCaretBlinkTime(), (FARPROC)NULL );
    }
 else
    {
    ClearInsertLine();
    }

 /* Backspaces/deletes may have changed vchpSel -- update it */

 blt( &vchpInsert, &vchpSel, cwCHP );

#ifdef  KOREA
 if (WasInterim)
    { MoveLeftRight(kcLeft);
      WasInterim = 0;
      vfSeeSel = TRUE;
    }
 else
      vfSeeSel = TRUE; /* Tell Idle() to scroll the selection into view */
#else
 vfSeeSel = TRUE;   /* Tell Idle() to scroll the selection into view */
#endif

#ifdef JAPAN //T-HIROYN Win3.1
 if(changeKanjiftc) {
    goto RetryAlpha;
 }
#endif
}



/* F  B E G I N  I N S E R T */
/* Prepare for start of insertion */
/* returns true iff inserting in front of a pic */
int NEAR FBeginInsert()
{
        int fGraphics;
        typeCP cp = selCur.cpFirst;
        typeCP cpFirstPara;
        cpInsert = cp;

/* We expect the caller to have deleted the selection already */
        Assert (selCur.cpLim == selCur.cpFirst);

/* Use super-fast text insertion unless we are inserting italics */
        CachePara(docCur, cp);
        cpFirstPara = vcpFirstParaCache;
        fGraphics = vpapAbs.fGraphics;
        vfSuperIns = !vchpSel.fItalic;
        vchpSel.fSpecial = fFalse;

        NewChpIns(&vchpSel);

        ichInsert = 0;  /* Must Set this BEFORE calling Replace */

/* Insert the speeder-upper QD insert block. Note: we invalidate since there
will be a character inserted anyway, plus to make sure that the line
length gets updated ("Invalidate" refers to the choice of Replace() over
the Repl1/AdjustCp/!vfInvalid mechanism used in EndInsert, in which the
insert dl is not made invalid).  It would be possible to optimize
by NOT invalidating here (thus being able to blt the first char typed),
but one would have to account for the case in which the cpMin of the
insert dl is changed by AdjustCp, or FUpdateOneDl will get messed up.
Currently this case is covered by an implicit UpdateWw, which occurs
in AlphaMode->ValidateTextBlt->CpBeginLine because we have invalidated vdlIns. */

        Replace(docCur, cpInsert, cp0, fnInsert, fc0, (typeFC) cchInsBlock);
        cpLimInserted = cpInsert + cchInsBlock;

        vidxpInsertCache = -1;  /* Char width cache for insert line is initially empty */

            /* Blank the mouse cursor so it doesn't make the display look ugly
               or slow us down trying to keep it up to date */
        SetCursor( (HANDLE) NULL );
        return fGraphics;
}




/* E N D  I N S E R T */
void NEAR EndInsert()
{ /* Clean up from quick insert mode */
        int dcp = cchInsBlock - ichInsert;
        typeFC fc;

#ifdef CASHMERE
        UpdateOtherWws(fTrue);
#endif

        fc = FcWScratch(rgchInsert, ichInsert);
#if WINVER >= 0x300
        if (!vfSysFull)
            /* The "tape dispenser bug replication method" has shown that
               holding down a key for 64k presses will cause FcWScratch()
               to run out of scratch-file space and fail.  If we go ahead
               with the Replacement we'll corrupt the piece table, so we
               delicately avoid that problem  3/14/90..pault */
#endif
            {
            Repl1(docCur, cpInsert, (typeCP) cchInsBlock, fnScratch, fc, (typeFC) ichInsert);
            cpLimInserted -= (cchInsBlock - ichInsert);
/* adjust separately, since first ichInsert characters have not changed at all */
            vfInvalid = fFalse;
            vpedlAdjustCp = (struct EDL *)0;
            AdjustCp(docCur, cpInsert + ichInsert, (typeCP) dcp, (typeFC) 0);
/* if the line is not made invalid, the length of the line
must be maintained.
*/
            if (vpedlAdjustCp)
                vpedlAdjustCp->dcpMac -= dcp;
            }

        vfInvalid = fTrue;

        cpWall = selCur.cpLim;
        vfDidSearch = fFalse;

        if (!vfInsertOn)
            DrawInsertLine();
}





/* N E W  C H P  I N S */
NewChpIns(pchp)
struct CHP *pchp;
{ /* Make forthcoming inserted characters have the look in pchp */

 if (CchDiffer(&vchpInsert, pchp, cchCHP) != 0)
    { /* Add the run for the previous insertion; our looks differ. */
    typeFC fcMac = (**hpfnfcb)[fnScratch].fcMac;

    if (fcMac != fcMacChpIns)
        {
        AddRunScratch(&vfkpdCharIns, &vchpInsert, &vchpNormal, cchCHP, fcMac);
        fcMacChpIns = fcMac;
        }
    blt(pchp, &vchpInsert, cwCHP);
    }
}



#ifdef DBCS
int NEAR MdInsUpdInsertW(wInsert, wShow, prcScroll)
    WORD    wInsert;    /* Char or 2 char's to insert into document */
    WORD    wShow;      /* Char or 2 char's to be shown on screen (SuperIns mode only) */
    RECT    *prcScroll; /* Rect to scroll for SuperIns */
#else
int NEAR MdInsUpdInsertCh( chInsert, chShow, prcScroll )
CHAR chInsert;     /* Char to insert into document */
CHAR chShow;       /* Char to show on screen (SuperIns mode only) */
RECT *prcScroll;   /* Rect to scroll for SuperIns */
#endif /* DBCS */
{       /* Insert character ch into the document. Show char chShow. */
        /* Flush the insert buffer to the scratch file if it fills up */
        /* Return:  mdInsUpdWhole     - Must do an UpdateWw
                    mdInsUpdNextChar  - Update not mandatory, char waiting
                    mdInsUpdLines     - Must update vdlIns and maybe following
                    mdInsUpdNothing   - No update needed & no char waiting
                    mdInsUpdOneLine   - Update vdlIns; only update following
                                        if there's no char waiting
         */
extern int vfInsFontTooTall;
void NEAR FlushInsert();
int mdInsUpd;

#ifndef KOREA                           /* has been defined globally */
int dxpCh;
#endif

int dl;

#ifdef DBCS
CHAR chInsert;
CHAR chShow;
BOOL fDBCSChar;
int  ichInsertSave;
int  dcchBlted;
#endif /* DBCS */

#ifdef  KOREA
        if (IsInterim)
                ichInsert -= 2;
#endif

#ifdef DIAG
{
char rgch[200];
wsprintf(rgch, "MdInsUpdInsertCh: ichInsert %d cpInsert %lu\n\r ",ichInsert, cpInsert);
CommSz(rgch);
}
#endif

 Assert(ichInsert <= cchInsBlock);
 if (ichInsert >= cchInsBlock)  /* Should never be >, but... */
    FlushInsert();

#ifdef DBCS
 ichInsertSave = ichInsert;
 if (HIBYTE(wInsert) != '\0') {
    fDBCSChar = TRUE;

#ifdef  KOREA   /* 90.12.28 sangl */
//  if (LOBYTE(HIWORD(vmsgLast.lParam)) == 0xF0)
    if (fInterim || LOBYTE(HIWORD(vmsgLast.lParam)) == 0xF0) // MSCH bklee 12/22/94
      {
        if (IsInterim == 0) dxpCh = DxpFromCh( wInsert, FALSE );  // fix bug #5382
        IsInterim ++;
      }
    else
     {
       WasInterim = IsInterim;
       IsInterim = 0;
     }
#endif

    if (ichInsert + 1 >= cchInsBlock) { /* Not enough room in the insertion block */
        FlushInsert();
#ifdef  KOREA
        ichInsertSave = ichInsert;       /* After flush, need to init ichInsertSave */
#endif
        }
    rgchInsert[ichInsert++] = chInsert = HIBYTE(wInsert);
    chShow = HIBYTE(wShow);
    }
 else {
    fDBCSChar = FALSE;
    chInsert = LOBYTE(wInsert);
    chShow = LOBYTE(wShow);
    }
 rgchInsert [ ichInsert++ ] = LOBYTE(wInsert);
#else
 rgchInsert [ ichInsert++ ] = chInsert;
#endif /* DBCS */

 /* NOTE: we only affect the para cache if the char inserted is Eol/chSect.
    We explicitly invalidate in this case below; otherwise, no invalidation
    is necessary */

 /* The following test works because chEol and chSect is not in
    the DBCS range. */

 if ( (chInsert == chEol) || (chInsert == chSect) )
    {          /* Add a paragraph run to the scratch file */
    struct PAP papT;

        /* Must invalidate the caches */
    vdocParaCache = vfli.doc = docNil;

#ifdef DBCS
    Assert(!fDBCSChar); /* Of course, you can't be too careful */
#endif /* DBCS */
        /* Get props for new para mark */
        /* NOTE: Under the new world, CachePara does not expect to ever */
        /* see an Eol in the insertion piece */
    ichInsert--;
    CachePara( docCur, cpInsert + cchInsBlock );
    papT = vpapAbs;
    ichInsert++;

#ifdef DEBUG
    if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
        {
        Assert( papT.rhc != 0 );
        }
#endif

        /* Write insert buf out to the scratch file */
    EndInsert();

        /* Add run for new para properties to the scratch file */
    AddRunScratch( &vfkpdParaIns,
                   &papT,
                   vppapNormal,
                   ((CchDiffer( &papT, &vpapPrevIns, cchPAP ) == 0) &&
                    (vfkpdParaIns.brun != 0)) ? -cchPAP : cchPAP,
                   fcMacPapIns = (**hpfnfcb)[fnScratch].fcMac );
    blt( &papT, &vpapPrevIns, cwPAP );

        /* Add a new insertion piece to the doc and we're ready to go again */
    InvalidateCaches( docCur );

    FBeginInsert();
    mdInsUpd = mdInsUpdWhole;   /* Must update the whole screen */
    }
 else if ( vfSuperIns && (chInsert != chNewLine) && (chInsert != chTab) &&
           (chInsert != chNRHFile ) && (chInsert != chReturn) &&
           !vfInsFontTooTall )
    {  /* We can do a superfast insert of this char */
    ClearInsertLine();

#ifdef DBCS
    /* Because chShow contains the first byte of a DBCS character,
       even when it is a DBCS character, the following call
       to DxpFromCh() is OK. */

#ifdef  KOREA
    if (fDBCSChar)
        dxpCh = DxpFromCh(wShow, FALSE);
    else
        dxpCh = DxpFromCh(chShow, FALSE);
#else
    dxpCh = DxpFromCh( chShow, FALSE );
#endif

    if( dxpCh > 0 ){
// Maybe it's no need so marked off, by chienho
#if defined(TAIWAN) || defined(KOREA) || defined(PRC)
//      dxpCh *= IsDBCSLeadByte(chShow) ? 2 : 1;
#else
        dxpCh *= IsDBCSLeadByte(chShow) ? 2 : 1;
#endif
        ScrollCurWw( prcScroll, dxpCh, 0 );
    }

    TextOut( wwdCurrentDoc.hDC,
             vxpIns + 1,
             vypBaseIns - vfmiScreen.dypBaseline,
             (LPSTR) &rgchInsert[ichInsertSave],
             dcchBlted = fDBCSChar ? 2 : 1 );
#ifdef  KOREA       /* 90.12.28  sangl */
    if ( IsInterim )
    {   unsigned kc;
    int dxpdiff;
    SetBkMode( wwdCurrentDoc.hDC, 2);   /* Set to OPAQUR mode */
    do { DrawInsertLine();
 //        while ( ((kc=KcInputNextHan()) < 0xA1) || (kc>0xFE) );
         while ( (((kc=KcInputNextHan()) < 0x81) || (kc>0xFE)) && (kc != VK_MENU));  // MSCH bklee 12/22/94
         if(kc == VK_MENU) return mdInsUpdLines;
         rgchInsert[ichInsertSave] = kc;
         rgchInsert[ichInsertSave+1] = GetDBCSsecond();
         ClearInsertLine();
         wShow = (kc<<8) + rgchInsert[ichInsertSave+1];
         prcScroll->left += dxpCh;      /* New left start of rect */
         dxpdiff = -dxpCh;      /* Save last dxpCh to go back */
         dxpCh = DxpFromCh(wShow, FALSE);  /* Get dxpCh of curr interim */
         dxpdiff += dxpCh;
         if (dxpdiff < 0)
                prcScroll->left += dxpdiff;
         ScrollCurWw(prcScroll, dxpdiff, 0);
         TextOut( wwdCurrentDoc.hDC,
                  vxpIns + 1,
                  vypBaseIns - vfmiScreen.dypBaseline,
                  (LPSTR)&rgchInsert[ichInsertSave], 2);
//      } while (LOBYTE(HIWORD(vmsgLast.lParam))==0xF0); /* End of If Hangeul */
        } while (fInterim || LOBYTE(HIWORD(vmsgLast.lParam))==0xF0); // MSCH bklee 12/22/94
        WasInterim = 1;
        IsInterim = 0;
        SetBkMode(wwdCurrentDoc.hDC, 1); /* Reset to TRANS mode */
      }
#endif      /* KOREA */

    vcchBlted += dcchBlted;
#else
    /* Because chShow contains the first byte of a DBCS character,
       even when it is a DBCS character, the following call
       to DxpFromCh() is OK. */

    if ((dxpCh = DxpFromCh( chShow, FALSE )) > 0)
        ScrollCurWw( prcScroll, dxpCh, 0 );

    TextOut( wwdCurrentDoc.hDC,
             vxpIns + 1,
             vypBaseIns - vfmiScreen.dypBaseline,
             (LPSTR) &chShow,
             1 );
    vcchBlted++;
#endif /* DBCS */

    vxpCursLine = (vxpIns += dxpCh);
    DrawInsertLine();

    /* Decide whether we have affected the next dl with this insertion */

    if ( vxpIns >= vxpMacIns )
        mdInsUpd = mdInsUpdLines;
    else if (!FImportantMsgPresent())
        {   /* No chars waiting; check for optional line update (word wrap) */
        if ((dl = vdlIns) < wwdCurrentDoc.dlMac - 1)
            {
            vfli.doc = docNil;

            FormatInsLine(); /* Update vfli for vdlIns */

            mdInsUpd = (vfli.cpMac != (**wwdCurrentDoc.hdndl) [dl + 1].cpMin) ?
              (FImportantMsgPresent() ? mdInsUpdNextChar : mdInsUpdOneLine) :
              mdInsUpdNothing;
            }
        }
    else
            /* Don't update; pay attention to the next character */
        mdInsUpd = mdInsUpdNextChar;
    }
 else if (vfSuperIns)
    {   /* In SuperInsMode but have a char we can't handle in SuperIns mode */
    mdInsUpd = (vfInsFontTooTall) ? mdInsUpdWhole : mdInsUpdLines;
    }
 else
    {   /* Non-superfast insertion; update line if we have to */
    vfli.doc = docNil;
    FormatInsLine(); /* Update vfli for vdlIns */

    /* Do the update only if:  (1) the selection is no longer on
       the current line OR  (2) No char is waiting */
#ifdef KOREA
    mdInsUpd = mdInsUpdLines;
#else
    mdInsUpd = ( (selCur.cpFirst < vfli.cpMin) ||
                 (selCur.cpFirst >= vfli.cpMac) ||
                 !FImportantMsgPresent() )  ? mdInsUpdLines : mdInsUpdNextChar;
#endif
    }

 Scribble( 10, mdInsUpd + '0' );
 return mdInsUpd;
}




void NEAR FlushInsert()
{       /* Flush the insert buffer to the scratch file. Insert a piece (ahead of
           the QD insertion piece) that points to the characters flushed to the
           scratch file.  Adjust CP's for the addition of the new scratch file
           piece. */

#ifdef DBCS
 /* The DBCS version of FlushInsert() is almost identical to the regular
    version, except it allows to insert an insertion block with one byte
    less than full.  This allows us to assume that the piece boundary aligns
    with the DBCS boundary. */
 typeFC fc = FcWScratch( rgchInsert, ichInsert );
 int    dcpDel;

#if WINVER >= 0x300
 if (!vfSysFull)
            /* The "tape dispenser bug replication method" has shown that
               holding down a key for 64k presses will cause FcWScratch()
               to run out of scratch-file space and fail.  If we go ahead
               with the Replacement we'll corrupt the piece table, so we
               delicately avoid that problem  3/14/90..pault */
#endif
  {
  Assert( cchInsBlock - ichInsert <= 1);
  Repl1( docCur, cpInsert, (typeCP) 0, fnScratch, fc, (typeFC) ichInsert );

  cpLimInserted += ichInsert;

  vfInvalid = fFalse;
  vpedlAdjustCp = (struct EDL *) 0;
  AdjustCp( docCur, cpInsert += ichInsert, (typeCP) (dcpDel = cchInsBlock - ichInsert),
            (typeCP) cchInsBlock );
  if (vpedlAdjustCp)
      vpedlAdjustCp->dcpMac += (cchInsBlock - dcpDel);
  }
#else
 typeFC fc = FcWScratch( rgchInsert, cchInsBlock );

#if WINVER >= 0x300
 if (!vfSysFull)
            /* The "tape dispenser bug replication method" has shown that
               holding down a key for 64k presses will cause FcWScratch()
               to run out of scratch-file space and fail.  If we go ahead
               with the Replacement we'll corrupt the piece table, so we
               delicately avoid that problem  3/14/90..pault */
#endif
  {
  Assert( ichInsert == cchInsBlock );
  Repl1( docCur, cpInsert, (typeCP) 0, fnScratch, fc, (typeFC) cchInsBlock );

  cpLimInserted += cchInsBlock;

  vfInvalid = fFalse;
  vpedlAdjustCp = (struct EDL *) 0;
  AdjustCp( docCur, cpInsert += cchInsBlock, (typeCP) 0, (typeFC) cchInsBlock );
  if (vpedlAdjustCp)
      vpedlAdjustCp->dcpMac += cchInsBlock;
  }
#endif /* DBCS */

 vfInvalid = fTrue;
 ichInsert = 0;
}




int NEAR XpValidateInsertCache( rgdxp )
int *rgdxp;
{    /* Validate the contents of the insert width cache, consisting of:
            (parm) rgdxp: table of widths of chars on the current insert
                          line (vdlIns) as last DisplayFli'd
            (global) vidxpInsertCache: -1 if invalid, index of current
                                       insert point otherwise
            (return value) xpMac: Mac pixel used on the insert line
    */
 int xpMac;

 Assert( vidxpInsertCache == -1 );

 vfli.doc = docNil;  /* Force FormatLine to act */

    /* Assert that FormatLine results will match screen contents */
 Assert( (**wwdCurrentDoc.hdndl)[vdlIns].fValid );

 /* Build vfli from insert line, extract cache info */

 FormatInsLine();
 blt( vfli.rgdxp, rgdxp, ichMaxLine );
 xpMac = umin( vfli.xpRight + xpSelBar, wwdCurrentDoc.xpMac );
 Assert( vcchBlted == 0);
 vidxpInsertCache = (int) (cpInsert + ichInsert - vfli.cpMin);

 Assert( vidxpInsertCache >= 0 && vidxpInsertCache < vfli.cpMac - vfli.cpMin);
 return xpMac;
}



void NEAR DelChars( cp, cch )
typeCP cp;
int    cch;
{   /* Delete cch characters at cp in docCur.

       We expect the request to be as results from repeated backspaces
       or forward deletes (not both); that is, the whole range extends
       backwards from (cpInsert + ichInsert) (non-inclusive) or forward from
       (cpInsert + cchInsBlock) (inclusive).

       We do not mark the vfli cache invalid, for speed.
       The Fast insert stuff will mark it invalid when it needs to.
     */

 int cchNotInQD;
 typeCP cpUndoAdd;
 int cchNewDel=0;

 Assert( (cp == cpInsert + cchInsBlock) ||      /* Fwd Deletes */
         (cp + cch == cpInsert + ichInsert));    /* Backsp */

 cchNotInQD = cch - ichInsert;
 if (cp + cchNotInQD == cpInsert)
    {   /* BACKSPACE */

    if (cchNotInQD <= 0)
        {   /* All deleted chars were in the QD buffer */
        ichInsert -= cch;

        /* Do not mark the para cache invalid -- we have not affected
           the para cache world, since there are never chSect/chEol in
           the QD buffer, and we have not adjusted cp's */
        return;
        }
    else
        {   /* Backspacing before the QD buffer */
        ichInsert = 0;

        if (cpStart > cp)
            {
            cpUndoAdd = cp0;
            cchNewDel = cpStart - cp;

            vuab.cp = cpStart = cp;

            /* cpStart has moved, and the count of cp's inserted has not
               changed -- we must adjust cpLimInserted */

            cpLimInserted -= cchNewDel;
            }

        cpInsert -= cchNotInQD;
        }
    }   /* End of if backspacing */
 else
    {   /* FORWARD DELETE */
    typeCP dcpFrontier = (cp + cch - cpLimInserted);

    if (dcpFrontier > 0)
        {
        cpUndoAdd = CpMacText( docUndo );
        cchNewDel = (int) dcpFrontier;
        cpLimDeleted += dcpFrontier;
        }
    cchNotInQD = cch;
    }

 /* Now we have: cchNewDel - chars deleted beyond previous limits
                             (cpStart to cpLimDeleted)
                 cpUndoAdd - where to add deleted chars to Undo doc
                             (only set if cchNewDel > 0)
                 cchNotInQD - chars deleted outside QD buffer */

 if (cchNotInQD > cchNewDel)
        /* Deleting chars previously inserted during this AlphaMode session */
    cpLimInserted -= (cchNotInQD - cchNewDel);

    /* Add the newly deleted stuff to the UNDO document.
       We find the { fn, fc } of the deleted char(s)
       so we can take advantage of Replace's optimizations
       wrt combining adjacent pieces (if the deletion is all one piece).
    */
 if (cchNewDel > 0)
    {
    struct PCTB **hpctb=(**hpdocdod)[ docCur ].hpctb;
    int ipcd=IpcdFromCp( *hpctb, cp );
    struct PCD *ppcd=&(*hpctb)->rgpcd [ipcd];
    int fn=ppcd->fn;
    typeFC fc=ppcd->fc;

    Assert( ppcd->fn != fnNil && (ppcd+1)->cpMin >= cp );

    if (bPRMNIL(ppcd->prm) && (cchNewDel <= (ppcd+1)->cpMin - cp))
        {   /* Deletion is all within one piece */
        Replace( docUndo, cpUndoAdd, cp0, fn, fc + (cp - ppcd->cpMin),
                 (typeFC) cchNewDel );
        }
    else
        {
        ReplaceCps( docUndo, cpUndoAdd, cp0, docCur, cp,
                    (typeCP) cchNewDel );
        }

    switch ( vuab.uac ) {
        default:
            Assert( FALSE );
            break;
        case uacDelNS:
            vuab.dcp += cchNewDel;
            break;
        case uacReplNS:
            vuab.dcp2 += cchNewDel;
            break;
        }
    }

 /* Remove deleted chars from the doc */
 Replace( docCur, cp, (typeCP) cchNotInQD, fnNil, fc0, fc0 );
}




FUpdateOneDl( dl )
int dl;
{   /* Update the display line dl.  Mark dl+1 as invalid if, in the process
       formatting dl, we discover that there is not a clean cp or
       yp transition between the two lines (i.e. the ending yp or cp of dl
       do not match the starting ones of dl+1).
       Return TRUE iff we marked dl+1 invalid; FALSE otherwise
       Starting cp & yp of dl+1 are adjusted as necessary */

 register struct EDL *pedl=&(**(wwdCurrentDoc.hdndl))[dl];
 int fUpdate=fFalse;
 RECT rc;

 vfli.doc = docNil;
 FormatLine(docCur, pedl->cpMin, 0, wwdCurrentDoc.cpMac, flmSandMode);

 pedl = &(**wwdCurrentDoc.hdndl) [dl + 1];

/* next line is invalid if it exists (<dlMac) and
        not following in cp space or not following in yp space
*/

 if ( (dl + 1 < wwdCurrentDoc.dlMac) &&
      (!pedl->fValid || (pedl->cpMin != vfli.cpMac) ||
                        (pedl->yp - pedl->dyp != (pedl-1)->yp)))
    {
    pedl->fValid = fFalse;
    pedl->cpMin = vfli.cpMac;
    pedl->yp = (pedl-1)->yp + pedl->dyp;
    fUpdate = fTrue;
    }
 else
    {
/* state is clean. Do not clear window dirty because more than one line may
have been made invalid earlier */
        /* Tell Windows we made this region valid */

#if WINVER >= 0x300
 /* Only actually USE pedl if it's be valid!  ..pault 2/21/90 */
    if (dl + 1 < wwdCurrentDoc.dlMac)
#endif
      {
      SetRect( (LPRECT) &rc, 0, wwdCurrentDoc.xpMac,
                              pedl->yp - pedl->dyp, pedl->yp );
      ValidateRect( wwdCurrentDoc.wwptr, (LPRECT) &rc );
      }

    (--pedl)->fValid = fTrue;
    }
 DisplayFli(wwCur, dl, fFalse);
 return fUpdate;
}



void NEAR FormatInsLine()
{   /* Format line containing insertion point, using vdlIns as a basis
       Assume vdlIns's cpMin has not changed */

 FormatLine( docCur, (**wwdCurrentDoc.hdndl) [vdlIns].cpMin, 0,
             wwdCurrentDoc.cpMac, flmSandMode );

     /* Compensate for LoadFont calls in FormatLine so we don't have to set
        vfTextBltValid to FALSE */
 LoadFont( docCur, &vchpInsert, mdFontChk );
}


#ifdef DBCS
/* Get the second byte of a DBCS character using a busy loop. */
CHAR near GetDBCSsecond()
{
    int        kc;
    CHAR       chDBCS2;
    BOOL       fGotKey;

    extern MSG vmsgLast;

    fGotKey = FALSE;
    do {
        if ( FImportantMsgPresent() ) {
            fGotKey = TRUE;
            if ((kc=KcAlphaKeyMessage( &vmsgLast )) != kcNil) {
                chDBCS2 = kc;
                if (vmsgLast.message == WM_KEYDOWN) {
                    switch (kc) {
                        default:
                            GetMessage( (LPMSG) &vmsgLast, NULL, 0, 0 );
                            break;
                        case kcAlphaVirtual:
                            /* This means we can't anticipate the key's meaning
                               before translation */
                            chDBCS2 = '\0';
                            if (!FNonAlphaKeyMessage(&vmsgLast, FALSE)) {
                                GetMessage( (LPMSG)&vmsgLast, NULL, 0, 0 );
                                TranslateMessage( &vmsgLast );
                                }
                            break;
                        }
                    }
                else {
                    if (kc < 0) {
                        chDBCS2 = '\0';
                        }
                    GetMessage( (LPMSG) &vmsgLast, NULL, 0, 0 );
                    }
                }
            else {
                chDBCS2 = '\0';
                }
            }
    } while (!fGotKey);

    /* As long as we go through the DBCS conversion window, this
       should not happen. */
    Assert(chDBCS2 != '\0');
    return chDBCS2;
}
#endif /* DBCS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\help.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* help.c -- MEMO Help handler */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOSYSMETRICS
#define NOMENUS
#define NOCOMM
#define NOSOUND
#define NOMINMAX
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "stdlib.h"
#include "docdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "dispdefs.h"
#include "fmtdefs.h"
#include "bitmaps.h"

#define NOIDISAVEPRINT
#define NOIDIFORMATS
#include "dlgdefs.h"
#include "wwdefs.h"
#define NOKCCODES
#include "ch.h"
#define NOSTRMERGE
#define NOSTRUNDO
#include "str.h"

extern HWND vhWndMsgBoxParent;
extern struct WWD rgwwd[];
extern struct DOD (**hpdocdod)[];
extern int vcchFetch;
extern int vccpFetch;
extern CHAR *vpchFetch;
extern typeCP vcpLimParaCache;
extern int vfCursorVisible;
extern HCURSOR vhcArrow;
extern struct FLI vfli;

int docHelp=docNil; /* this can be taken out if no online help */

#ifndef ONLINEHELP
#if 0
BOOL far PASCAL DialogHelp( hDlg, code, wParam, lParam )
HWND hDlg;
unsigned code;
WORD wParam;
LONG lParam;
{
    switch(code)
        {
        case WM_INITDIALOG:
            EnableOtherModeless(FALSE);
            return(TRUE);

#if WINVER >= 0x300
        case WM_PAINT:
            if (vfli.rgdxp[1] == 0xFFFD)
                FnSpecial(hDlg);
            break;
#endif
    
        case WM_COMMAND:
            if ((wParam == idiOk) || (wParam == idiCancel))
                {
                OurEndDialog(hDlg, TRUE);
#if WINVER >= 0x300            
                if (vfli.rgdxp[1] == 0xFFFD)
                    vfli.rgdxp[1] = NULL;
#endif
                return(TRUE);
                }
            break;
    
        case WM_ACTIVATE:
            if (wParam)
                vhWndMsgBoxParent = hDlg;
            if (vfCursorVisible)
                ShowCursor(wParam);
            break;
    
        case WM_SETVISIBLE:
            if (wParam)
                EndLongOp(vhcArrow);
        }
    return(FALSE);
}

FnSpecial(hDlg)
{
#define randTo(x) (rand() / (32767/x))

    HDC hDC = NULL;
    HDC hMDC = NULL;
    HFONT hFont, hFontPrev;
    int c, cmode;
    int x, y, x2, y2, s;
    HPEN hPen, hPenPrev;
    PAINTSTRUCT ps;
    RECT rc;
    BITMAPINFO DIBInfo;

    srand((int) GetMessageTime());
    cmode = randTo(3);
    GetClientRect(hDlg, &rc);
    if ((hDC = BeginPaint(hDlg, &ps)) == NULL)
        goto LDone;
    if ((hMDC = CreateCompatibleDC(hDC)) == NULL)
        goto LDone;
    
    for (c = 1; c < 100; c++)
        {
        int r, g, b, x, y;
        x = randTo(rc.right)+50;
        y = randTo(rc.bottom)+50;
        switch(cmode)
            {
            case 0:
                r = randTo(255);
                g = randTo(100)+100;
                b = 0;
                break;
            case 1:
                g = randTo(255);
                b = randTo(100)+100;
                r = 0;
                break;
            default:
                b = randTo(255);
                r = randTo(100)+100;
                g = 0;
                break;
            }

        s = 3 + 4*randTo(10);
        if ((hPen = CreatePen(PS_SOLID, s, RGB(r,g,b))) == NULL)
            hPen = GetStockObject(BLACK_PEN);
        hPenPrev = SelectObject(hDC, hPen);
        Ellipse(hDC, x-50, y-50, x-50+s, y-50+s);
        SelectObject(hDC, hPenPrev);
        DeleteObject(hPen);
        }
    SetTextColor(hDC, RGB(255,255,255));
    switch (cmode)
        {
        case 0:
            SetBkColor(hDC, RGB(255,0,0));
            break;
        case 1:
            SetBkColor(hDC, RGB(0,255,0));
            break;
        default:
            SetBkColor(hDC, RGB(0,0,255));
            break;
        }
    hFont = GetStockObject(ANSI_VAR_FONT);
    hFontPrev = SelectObject(hDC, hFont);
    if (vfli.rgch[2] == 0x30)
        for (c = vfli.rgch[1]-1; c >= 0; c--)
            vfli.rgch[c+2] -= 0x10;
    TextOut(hDC, 6, rc.bottom-15, &vfli.rgch[2], vfli.rgch[1]);
    SelectObject(hDC, hFontPrev);

    DeleteDC(hMDC);
LDone:            
    EndPaint(hDlg, &ps);
}
#endif

#else /* ONLINE HELP */

#define cchMaxTopicName 80

#ifndef DEBUG
#define STATIC static
#else
#define STATIC
#endif

STATIC int fnHelpFile;
STATIC int iTopicChoice=-1;
STATIC int cTopic;
STATIC struct PGTB **hpgtbHelp=0;
STATIC HWND hwndHelpDoc;


NEAR CleanUpHelpPopUp( void );
NEAR CloseHelpDoc( void );
NEAR FOpenHelpDoc( void );
NEAR MoveHelpCtl( HWND, int, int, int, int, int );

fnHelp()
{
extern HANDLE hMmwModInstance;
extern HWND hParentWw;
extern FARPROC lpDialogHelp;
extern FARPROC lpDialogHelpInner;
int idi;

Assert( hpgtbHelp == 0 );

/* Loop until the user exits the "Help on this topic/Return to Topics" loop */

ClearInsertLine();  /* Because we use MdocSize, which sets vfInsertOn */

if (!FOpenHelpDoc())
    {
    CloseHelpDoc();
    Error( IDPMTNoHelpFile );
    return;
    }
while (TRUE)
    {

    idi = DialogBox( hMmwModInstance, MAKEINTRESOURCE(dlgHelp), hParentWw,
                     lpDialogHelp );
    if (idi == -1)
        {
        Error(IDPMTNoMemory);
        return;
        }

    if ((idi == idiOk) && (iTopicChoice >= 0))
        {   /* Help file was read OK & user chose a topic */
        Assert( hpgtbHelp != 0);
        if ( iTopicChoice + 1 < (**hpgtbHelp).cpgd )
            {
            idi = DialogBox( hMmwModInstance, MAKEINTRESOURCE(dlgHelpInner),
                             hParentWw, lpDialogHelpInner );
            if (idi == -1)
                {
                Error(IDPMTNoMemory);
                break;
                }
            if ( idi != idiHelpTopics )
                break;

            }
            /* Not Enough Topics supplied in the help file */
        else
            {
            Error( IDPMTNoHelpFile );
            CloseHelpDoc();
            break;
            }
        }
    else
        break;
    }
iTopicChoice = -1;
DrawInsertLine();
CloseHelpDoc();
}




FInzHelpPopUp( hDlg )
HWND hDlg;
{   /* Build the Help popup Window */
extern CHAR szHelpDocClass[];
extern HANDLE hMmwModInstance;
extern int dxpScrlBar;

typedef struct {  int yp, dyp;  }  VD;       /* Vertical Dimension */
typedef struct {  int xp, dxp;  }  HD;       /* Horizontal Dimension */

 HD hdUsable;
 HD hdPopUp;
 VD vdPopUp, vdTopic, vdHelpDoc, vdButton;

 HDC hdcPopUp=NULL;

#define RectToHdVd( rc, hd, vd )    (hd.dxp=(rc.right - (hd.xp=rc.left)), \
                                     vd.dyp=(rc.bottom - (vd.yp=rc.top)))
 RECT rcPopUp;
 RECT rcHelpDoc;
 extern int dypMax;     /* Screen Size */
 int dxpMax=GetDeviceCaps( wwdCurrentDoc.hDC, HORZRES );
 TEXTMETRIC tm;
 unsigned dypChar;
 unsigned xpButton;
 unsigned dxpButton;
 register struct WWD *pwwdHelp;

#define cButton 4       /* # of buttons across the bottom of the Dialog */
 int rgidiButton[ cButton ];
 int iidiButton;

 rgidiButton [0] = idiHelpTopics;
 rgidiButton [1] = idiHelpNext;
 rgidiButton [2] = idiHelpPrev;
 rgidiButton [3] = idiCancel;

#define dxpMargin   (dxpMax/100)
#define dypMargin   (dypMax/100)

 Assert( docHelp != docNil );

    /* Make a wwd entry for the Help document & initialize it */
 if ((wwHelp=WwAlloc( (HWND)NULL, docHelp )) == wwNil)
    goto ErrRet;
 pwwdHelp = &rgwwd[ wwHelp ];

 SetHelpTopic( hDlg, iTopicChoice );

    /* Dialog box is centered and
       2/3 of the size of the screen, plus the scroll bar width
       This sizing method permits us to guarantee that the help document
       display area width is at least some fixed percentage of the width
       of the screen (currently 64.66 %) */
 hdPopUp.dxp = ((dxpMax * 2) / 3) + dxpScrlBar;
 hdPopUp.xp = (dxpMax - hdPopUp.dxp) / 2;
 vdPopUp.dyp = dypMax - ((vdPopUp.yp = dypMax / 6) * 2);
 MoveWindow( hDlg, hdPopUp.xp, vdPopUp.yp, hdPopUp.dxp, vdPopUp.dyp, TRUE );

    /* Get Standard text height so we know how much space to allow
       for Topic Name */
 if ( ((hdcPopUp=GetDC( hDlg ))==NULL) ||
      (SelectObject( hdcPopUp, GetStockObject( ANSI_FIXED_FONT ) )==0))
    goto ErrRet;
 GetTextMetrics( hdcPopUp, (LPTEXTMETRIC)&tm );
 ReleaseDC( hDlg, hdcPopUp );
 hdcPopUp = NULL;
 dypChar = tm.tmHeight + tm.tmExternalLeading;

     /* Obtain heights of button area, help doc display, and Topic Area by
        splitting up Dialog Box client rect */
 GetClientRect( hDlg, &rcPopUp );
 RectToHdVd( rcPopUp, hdPopUp, vdPopUp );
 vdButton.dyp = vdPopUp.dyp / 7;
 vdButton.yp = vdPopUp.yp + vdPopUp.dyp - vdButton.dyp;
 vdTopic.yp = vdPopUp.yp + dypMargin;
 vdTopic.dyp = dypMargin + dypChar;
 vdHelpDoc.yp = vdTopic.yp + vdTopic.dyp;
 vdHelpDoc.dyp = vdButton.yp - vdHelpDoc.yp;
 Assert( vdHelpDoc.dyp > dypChar + 2 );

    /* Obtain usable horiz area within dialog box */
 hdUsable.xp  = hdPopUp.xp + dxpMargin;
 hdUsable.dxp = hdPopUp.dxp - (2 * dxpMargin);

     /* Create the Help Doc Window */
 if ((hwndHelpDoc =
        CreateWindow( (LPSTR)szHelpDocClass, (LPSTR) "",
                      WS_CHILD | WS_BORDER,
                      hdUsable.xp, vdHelpDoc.yp,
                      hdUsable.dxp - dxpScrlBar, vdHelpDoc.dyp,
                      hDlg,                     /* PARENT */
                      NULL,                     /* Help Document Window ID */
                      hMmwModInstance,
                      (LONG) 0)) == NULL)
        /* Error Creating Help Document Window */
    goto ErrRet;
 pwwdHelp->wwptr = pwwdHelp->hHScrBar = hwndHelpDoc;

    /* OK to GetDc and hang onto it since Help doc window class has ownDC */
 if ((pwwdHelp->hDC = GetDC( hwndHelpDoc ))==NULL)
    goto ErrRet;

    /* Set up scroll bar control window */
 SetScrollRange( pwwdHelp->hVScrBar = GetDlgItem( hDlg, idiHelpScroll ),
                 pwwdHelp->sbVbar = SB_CTL,
                 0, drMax-1, FALSE );
 SetScrollPos( pwwdHelp->hVScrBar, SB_CTL, 0, FALSE );
 MoveHelpCtl( hDlg, idiHelpScroll,
                      hdUsable.xp + hdUsable.dxp - dxpScrlBar, vdHelpDoc.yp,
                      dxpScrlBar, vdHelpDoc.dyp );

    /* Move Button windows into place */
 xpButton = hdUsable.xp;
 dxpButton = (hdUsable.dxp - (dxpMargin*(cButton-1))) / cButton;
 vdButton.yp += dypMargin;
 vdButton.dyp -= (2 * dypMargin);
 for ( iidiButton = 0; iidiButton < cButton; iidiButton++ )
    {
    MoveHelpCtl( hDlg, rgidiButton[ iidiButton ],
                       xpButton, vdButton.yp, dxpButton, vdButton.dyp );
    xpButton += dxpButton + dxpMargin;
    }

    /* Move static text window into place */
 MoveHelpCtl( hDlg, idiHelpName, hdUsable.xp, vdTopic.yp,
                                 hdUsable.dxp, vdTopic.dyp );

    /* The "real, final" size of the help doc window goes in rgwwd */
 GetClientRect( hwndHelpDoc, (LPRECT) &rcHelpDoc );
 pwwdHelp->xpMin = rcHelpDoc.left;
 pwwdHelp->ypMin = rcHelpDoc.top;
 pwwdHelp->xpMac = rcHelpDoc.right;
 pwwdHelp->ypMac = rcHelpDoc.bottom;

    /* Finally, we display the whole dialog box */
 ShowWindow( hDlg, SHOW_OPENWINDOW );
 ShowWindow( hwndHelpDoc, SHOW_OPENWINDOW );
 return TRUE;

ErrRet:
    if (hdcPopUp != NULL)
        ReleaseDC( hDlg, hdcPopUp );
    CleanUpHelpPopUp();
    CloseHelpDoc();

    return FALSE;
}




NEAR MoveHelpCtl( hDlg, id, left, top, right, bottom )
HWND hDlg;
int id;
int left, top, right, bottom;
{
 MoveWindow( (HWND) GetDlgItem( hDlg, id ), left, top, right, bottom, TRUE );
}




SetHelpTopic( hDlg, iTopic )
HWND hDlg;
int iTopic;
{   /* Inz wwHelp entry in rgwwd for pending display of topic iTopic,
       which means "printed page" iTopic, the way we handle help files.
       We map iTopic==0 to "printed page 2", iTopic 1 to 3, etc.
       This skips the first printed page, which is the list of topics.
       Set the topic name of iTopic as the text for the idiHelpName
       static text control in the hDlg dialog box */

 extern typeCP cpMinCur, cpMacCur;
 extern struct SEL selCur;
 extern int wwCur;

 int ipgd = iTopic + 1;
 register struct WWD *pwwd=&rgwwd[ wwHelp ];
 typeCP cpFirstTopic = (**hpgtbHelp).rgpgd [ ipgd ].cpMin;
 typeCP cpLimTopic = (ipgd == (**hpgtbHelp).cpgd - 1) ?
                                      CpMacText( docHelp ) :
                                      (**hpgtbHelp).rgpgd [ ipgd + 1 ].cpMin;
 typeCP cp;
 int iTopicT;
 typeCP cpLimParaCache;
 RECT rc;

 Assert( wwHelp != wwNil && docHelp != docNil );

 cpLimTopic--;      /* Ignore end-of-page char at the end of each page */

 if (ipgd >= (**hpgtbHelp).cpgd)
    {
    Assert( FALSE );

    pwwd->cpMin = pwwd->cpMac = cp0;
    }
 else
    {
    pwwd->cpMin = cpFirstTopic;
    pwwd->cpMac = cpLimTopic;
    }
 pwwd->cpFirst = pwwd->cpMin;
    /* So no selection shows */
 pwwd->sel.cpFirst = pwwd->sel.cpLim = cpLimTopic + 1;

 if (wwCur == wwHelp)
    {
    cpMinCur = pwwd->cpMin;
    cpMacCur = pwwd->cpMac;
    selCur = pwwd->sel;
    }

 TrashCache();
 TrashWw( wwHelp );
 GetClientRect( pwwd->wwptr, (LPRECT) &rc );
 InvalidateRect( pwwd->wwptr, (LPRECT) &rc, TRUE );

 /* Set Help Topic name into dialog box */

 for ( iTopicT = 0, cp = (**hpgtbHelp).rgpgd [0].cpMin;
       cp < (**hpgtbHelp).rgpgd [1].cpMin;
       cp = cpLimParaCache, iTopicT++ )
        {
        int cch;
        int cchTopicMac;
        CHAR rgchTopic[ cchMaxTopicName ];

        CachePara( docHelp, cp );
        cpLimParaCache = vcpLimParaCache;

        if (iTopicT == iTopic)
            {   /* Found the topic we want */
            cchTopicMac = imin( (int)(vcpLimParaCache - cp) - ccpEol,
                                cchMaxTopicName );

            /* Build up a topic name string */

            cch = 0;
            while (cch < cchTopicMac)
                {
                int cchT;

                FetchCp( docHelp, cp, 0, fcmChars );
                cp += vccpFetch;
                cchT = imin( vcchFetch, cchTopicMac - cch );
                Assert( cchT > 0);
                bltbyte( vpchFetch, rgchTopic + cch, cchT );
                cch += cchT;
                }
            if ((cch == 0) || rgchTopic [0] == chSect)
                    /* End of Topics */
                break;

            rgchTopic[ cch ] = '\0';

            SetDlgItemText( hDlg, idiHelpName, (LPSTR) rgchTopic );
            return;
            }   /* end if */
        }   /* end for */
    /* Not enough topic names */
 Assert( FALSE );
}




NEAR CleanUpHelpPopUp()
{
extern int wwCur;

 if (wwCur != wwDocument)
    NewCurWw( wwDocument, TRUE );

 if (wwHelp != wwNil)
     FreeWw( wwHelp );
 }




NEAR CloseHelpDoc()
{
 if (docHelp != docNil)
    KillDoc( docHelp );

 if (hpgtbHelp != 0)
    {
    FreeH( hpgtbHelp );
    hpgtbHelp = 0;
    }

 if (fnHelpFile != fnNil)
    FreeFn( fnHelpFile );
 docHelp = docNil;
 fnHelpFile = fnNil;
}


NEAR FOpenHelpDoc()
{
 CHAR szHelpFile[ cchMaxFile ];
 CHAR (**hszHelpFile)[];

  /* This call to fnOpenSz is the one time that we don't normalize
    a filename before calling FnOpenSz.  The reason for this is
    that OpenFile (called in RfnAccess) will only search the path
    if the filename passed to it has no path.  We also get a side
    benefit: if the sneaky user has WRITE.HLP open as a document,
    it will get a different fn from FnOpenSz because the strings
    will not match. */

return ( PchFillPchId( szHelpFile, IDSTRHELPF ) &&
      ((fnHelpFile=FnOpenSz( szHelpFile, dtyHlp, TRUE ))!=fnNil) &&
      !FNoHeap(hszHelpFile=HszCreate( szHelpFile )) &&
      ((docHelp=DocCreate( fnHelpFile, hszHelpFile, dtyHlp )) != docNil) &&
      (**hpdocdod)[ docHelp ].fFormatted);
}

/* Window Proc for Help document child window */

long FAR PASCAL HelpDocWndProc( hwnd, message, wParam, lParam )
HWND hwnd;
unsigned message;
WORD wParam;
LONG lParam;
{
extern struct WWD *pwwdCur;
extern int wwCur;

    PAINTSTRUCT ps;

    switch (message)
        {
        case WM_SIZE:
            /* Window's size is changing.  lParam contains the width
            ** and height, in the low and high words, respectively.
            ** wParam contains SIZENORMAL for "normal" size changes,
            ** SIZEICONIC when the window is being made iconic, and
            ** SIZEFULLSCREEN when the window is being made full screen. */
            Assert( wParam == SIZENORMAL || wParam == SIZEFULLSCREEN );
            if (lParam)
                {   /* Not a NULL size request */
                rgwwd[ wwHelp ].xpMac = LOWORD( lParam );
                rgwwd[ wwHelp ].ypMac = HIWORD( lParam );
                }
            break;

        case WM_PAINT:
            /* Time for the window to draw itself. */
            {
            RECT rcSave;

                /* To allow UpdateWw to refresh ALL parts of the screen it */
                /* deems necessary, not just what Windows is telling us to */
                /* paint, we invoke it AFTER the call to EndPaint so that */
                /* the Vis region is not restricted.  The only reason we call */
                /* BeginPaint/EndPaint is to get the repaint rectangle */
            BeginPaint(hwnd, (LPPAINTSTRUCT)&ps);
            bltbyte( &ps.rcPaint, &rcSave, sizeof( RECT ) );
            EndPaint(hwnd, (LPPAINTSTRUCT)&ps);
            NewCurWw( wwHelp, TRUE );
            InvalBand( pwwdCur, rcSave.top, rcSave.bottom );
            UpdateWw( wwCur, FALSE );
            NewCurWw( wwDocument, TRUE );
            break;
            }

        default:

            /* Everything else comes here.  This call MUST exist
            ** in your window proc.  */

            return(DefWindowProc(hwnd, message, wParam, lParam));
            break;
    }

    /* A window proc should always return something */
    return(0L);
}


/* Dialog Box function for Inner Help box (shows the topic text) */

BOOL far PASCAL DialogHelpInner( hDlg, code, wParam, lParam )
HWND hDlg;
unsigned code;
WORD wParam;
LONG lParam;
{
extern int wwCur;

    switch (code)
        {
        case WM_VSCROLL:    /* Scroll in help document */
            NewCurWw( wwHelp, TRUE );
            MmwVertScroll( hwndHelpDoc, wParam, (int) lParam );
            UpdateWw( wwCur, FALSE );
            NewCurWw( wwDocument, TRUE );
            break;

        case WM_CLOSE:
            goto Cancel;
        case WM_INITDIALOG:
            if (!FInzHelpPopUp( hDlg ))
                {
                goto Cancel;
                }
            EnableOtherModeless(FALSE);
            break;

        case WM_COMMAND:
            switch (wParam)
                {
                default:
                    break;
                case idiHelpNext:
                    if (++iTopicChoice >= cTopic)
                        {
                        iTopicChoice--;
                        beep();
                        }
                    else
                        SetHelpTopic( hDlg, iTopicChoice );

                    break;
                case idiHelpPrev:
                    if (iTopicChoice == 0)
                        beep();
                    else
                        SetHelpTopic( hDlg, --iTopicChoice );
                    break;

                case idiOk:
                    wParam = idiHelpTopics;
                case idiHelpTopics:
                    CleanUpHelpPopUp();
                    goto Endit;

                case idiCancel:
Cancel:
                    CleanUpHelpPopUp();
                    CloseHelpDoc();
Endit:
                    EndDialog(hDlg, wParam);
                    EnableOtherModeless(TRUE);
                    break;
                }
            break;

        default:
            return(FALSE);
            }
    return(TRUE);
    }




BOOL far PASCAL DialogHelp( hDlg, code, wParam, lParam )
HWND hDlg;
unsigned code;
WORD wParam;
LONG lParam;
{
 HWND hwndListBox;

    switch (code)
        {
        case WM_INITDIALOG:
            if (!FSetHelpList( hwndListBox=GetDlgItem( hDlg, idiHelp ) ))
                {
                Error( IDPMTNoHelpFile );
                CloseHelpDoc();
                goto EndIt;
                }

                /* Come up with the first string in the list box selected */
            SendMessage( hwndListBox, LB_SETCURSEL, (WORD) 0, (LONG) 0);

            {   /* Compute % of free memory, set that into dialog box */
            extern cwHeapFree, cbTotQuotient, cbTot;
            extern int vfOutOfMemory;
            int pctHeapFree=0;
            CHAR rgchPct[ 4 ];
            int cchPct;
            CHAR *pchT=&rgchPct[ 0 ];

            if (!vfOutOfMemory)
                {
                pctHeapFree = cwHeapFree / cbTotQuotient;
                if (pctHeapFree > 99)
                    pctHeapFree = (cwHeapFree*sizeof(int) == cbTot) ? 100 : 99;
                }
            cchPct = ncvtu( pctHeapFree, &pchT );
            Assert( cchPct < 4);
            rgchPct[ cchPct ] = '\0';
            SetDlgItemText( hDlg, idiMemFree, (LPSTR) rgchPct );
            }

            EnableOtherModeless(FALSE);
            break;

        case WM_COMMAND:
            switch (wParam)
                {
            case idiHelp:
                /* This is received as part of the LBS_NOTIFY style */
                /* whenever the user mouses up over a string */
                /* LOWORD( lParam ) is the window handle of the list box */
                /* HIWORD( lParam ) is 1 for single click, 2 for doubleclick */

                switch( HIWORD( lParam ) ) {
                    default:
                        break;
                    case 1: /* SINGLE CLICK */
                        EnableWindow( GetDlgItem( hDlg, idiOk ),
                                      SendMessage( (HWND)GetDlgItem( hDlg,
                                                                     idiHelp ),
                                                    LB_GETCURSEL,
                                                    0,
                                                    (LONG) 0 ) >= 0 );
                        break;
                    case 2: /* DOUBLE CLICK */
                        wParam = idiOk;
                        goto Okay;
                    }
                break;

            case idiOk:
Okay:
                iTopicChoice = SendMessage( (HWND)GetDlgItem( hDlg, idiHelp ),
                                            LB_GETCURSEL, 0, (LONG) 0 );
                goto EndIt;

            case idiCancel:
                    /* Cancelled, get rid of Help Document info */
                CloseHelpDoc();
EndIt:
                EndDialog(hDlg, wParam);
                EnableOtherModeless(TRUE);
                break;
                }
            break;

        default:
            return(FALSE);
            }
    return(TRUE);
    } /* end of DialogHelp */



FSetHelpList( hWndListBox )
HWND hWndListBox;
{   /* Open the MEMO Help File as a MEMO Document.  Set docHelp, fnHelpFile.
       Read the strings for the list box as the contents of the first
       "printed" page (i.e. use the page table) and send them to the
       list box with the passed window handle */

 CHAR szTopicBuf[ cchMaxTopicName ];
 typeCP cp;
 typeCP cpLimParaCache;
 int cch;
 struct PGTB **hpgtbT;

 Assert( docHelp != docNil );

 cTopic = 0;

 if ((hpgtbT=(**hpdocdod)[ docHelp ].hpgtb) != 0)
    {
    hpgtbHelp = hpgtbT;
    (**hpdocdod)[ docHelp ].hpgtb = 0;
    }

 Assert( (hpgtbHelp != 0) && ((**hpgtbHelp).cpgd > 1) );

 /* List of topics starts on the first page, 1 para per topic */
 /* For each topic (paragraph), build a string and send it to the list box */

 for ( cp = (**hpgtbHelp).rgpgd [0].cpMin;
       cp < (**hpgtbHelp).rgpgd [1].cpMin;
       cp = cpLimParaCache )
    {
    int cchTopicMac;

    CachePara( docHelp, cp );
    cpLimParaCache = vcpLimParaCache;

    cchTopicMac = imin( (int)(vcpLimParaCache - cp) - ccpEol,
                        cchMaxTopicName );

        /* Build up a topic name string */
    cch = 0;
    while (cch < cchTopicMac)
        {
        int cchT;

        FetchCp( docHelp, cp, 0, fcmChars );
        cp += vccpFetch;
        cchT = imin( vcchFetch, cchTopicMac - cch );
        Assert( cchT > 0);
        bltbyte( vpchFetch, szTopicBuf + cch, cchT );
        cch += cchT;
        }
    if ((cch == 0) || szTopicBuf [0] == chSect)
            /* End of Topics */
        break;

    szTopicBuf[ cch ] = '\0';
    SendMessage( hWndListBox, LB_INSERTSTRING, -1, (LONG)(LPSTR)szTopicBuf);
    cTopic++;
    }   /* end for */

 return (cTopic > 0);
}
#endif /* ONLINEHELP */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\insert2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* insert2.c - MW insertion routines */

#define NOGDICAPMASKS
#define NOCLIPBOARD
#define NOCTLMGR
#define NOWINSTYLES

#ifndef KOREA
#define NOSYSMETRICS
#endif

#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOATOM
#define NOBRUSH
#define NOCREATESTRUCT
#define NOFONT
#define NOCLIPBOARD
#define NODRAWTEXT
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOMB
#define NOOPENFILE
#define NOSOUND
#define NOCOMM
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "propdefs.h"
#include "dispdefs.h"
#include "fmtdefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#define NOKCCODES
#include "ch.h"
#include "winddefs.h"
#include "fontdefs.h"
#include "debug.h"

#ifdef DEBUG
extern int          vTune;
#endif

#ifdef  KOREA       /* Use in KcInputNext..., 90.12.27 sangl */
extern int      IsInterim;
#endif

extern int          vdlIns;
extern int          vxpIns;
extern int          vfTextBltValid;
extern int          vdypCursLineIns;
extern struct FLI   vfli;
extern struct SEL   selCur;
extern int          vdypBase;
extern int          vypBaseIns;
extern int          vxpMacIns;
extern int          vdypAfter;
extern typeCP       cpInsert; /* Beginning cp of insert block */
extern int          ichInsert; /* Number of chars used in rgchInsert */
extern typeCP       cpMinCur;
extern typeCP       cpMacCur;
extern int          docCur;
extern struct CHP   vchpInsert;
extern struct WWD   rgwwd[];
extern struct WWD   *pwwdCur;
extern int          wwCur;
extern int          wwMac;
extern int          vfSeeSel;
extern int          vfFocus;
#ifdef DBCS
extern int      donteat;    /* see disp.c */
#endif


unsigned WHsecGetTime()
{       /* Get the time (in hundredths of seconds) into a normalized word */
        /* Ignore current hour, just minutes/seconds/hundredths */
 struct TIM tim;

 OsTime( &tim );
 return ( (unsigned)tim.minutes * 6000 +
          (unsigned)tim.sec * 100 +
          (unsigned)tim.hsec );
}




/* V A L I D A T E  T E X T  B L T */
ValidateTextBlt()
{   /* Validate info sufficient for TextOut and ScrollCurWw calls in Insert */
    /* In particular: vdlIns, vxpIns, vdypBase, vdypFont */

 int NEAR FCpInsertInDl( typeCP, struct EDL * );
 extern int vfInsFontTooTall;
 extern struct FMI vfmiScreen;
 extern int             ferror;
 extern int vfInsEnd;

 int dypFontAscent;
 int dypFontDescent;
 register struct EDL *pedl;
 int yp;
 typeCP cpBegin;

 /* Routine assumes ww == wwDocument */

 Assert( pwwdCur == &wwdCurrentDoc );

 {       /* Look for a valid dl containing selCur.cpFirst */
         /* We should usually be able to find one */
 int dlGuess = vdlIns;
 struct EDL *dndl=&(**wwdCurrentDoc.hdndl)[0];

 if ( (dlGuess < wwdCurrentDoc.dlMac) &&
      FCpInsertInDl( selCur.cpFirst, pedl = &dndl[ dlGuess ] ))
    {   /* vdlIns is already correct */
    cpBegin = pedl->cpMin;
    }
 else
    {   /* Search for valid dl containing insertion point */
        /* Use linear search, all dl's may not be valid */
    int dl;

    for ( pedl = dndl, dl = 0; dl < wwdCurrentDoc.dlMac; dl++, pedl++ )
        {
        if ( FCpInsertInDl( selCur.cpFirst, pedl ) )
            {   /* Found it */
            vdlIns = dl;
            cpBegin = pedl->cpMin;
            break;
            }
        }
    if (dl >= wwdCurrentDoc.dlMac)
        {   /* No valid dl contains the cp -- must update whole screen */
        cpBegin = CpBeginLine( &vdlIns, selCur.cpFirst );
        }
    }
 }

 /* Special case for splat: locate insert point at end of previous line */

 pedl = &(**wwdCurrentDoc.hdndl) [vdlIns];
 if (pedl->fSplat && (vdlIns > 0) && selCur.cpFirst == pedl->cpMin)
    {   /* Splat on current line */
        /* Check for pedl->cpMin above is necessary for the special case */
        /* in which the QD buffer is at the beginning of the splat line */
    pedl--;
    if (pedl->fValid && !pedl->fSplat)
        {   /* Locate cursor at end of previous line */
        vdlIns--;
        cpBegin = pedl->cpMin;

        ClearInsertLine();
        selCur.fEndOfLine = TRUE;
        vfInsEnd = TRUE;
        ToggleSel( selCur.cpFirst, selCur.cpLim, TRUE );
        }
    else
        {
        pedl++;
        goto CheckEnd;
        }
    }
 else
    {   /* Eliminate end of line cursor if not before a splat */
CheckEnd:
    if (selCur.fEndOfLine)
        {
        ClearInsertLine();
        selCur.fEndOfLine = FALSE;
        vfInsEnd = FALSE;
        ToggleSel( selCur.cpFirst, selCur.cpLim, TRUE );
        }
    }

 /* Assure we obtained a good vdlIns */

 Assert( vdlIns < wwdCurrentDoc.dlMac );
 Assert( ((selCur.cpFirst >= pedl->cpMin) &&
         (selCur.cpFirst <= pedl->cpMin + pedl->dcpMac)));

 FormatLine(docCur, cpBegin, 0, cpMacCur, flmSandMode);
 vxpIns = DxpDiff(0, (int) (selCur.cpFirst - cpBegin), &vxpIns) + vfli.xpLeft +
                    xpSelBar - wwdCurrentDoc.xpMin;
 vdypBase = vfli.dypBase;
 vdypAfter = vfli.dypAfter;
 vdypCursLineIns = min(vfli.dypFont, vfli.dypLine - vdypAfter);

 vxpMacIns = vfli.xpMarg;

 LoadFont(docCur, &vchpInsert, mdFontChk);
 ferror = FALSE; // running out of memory here is OK.  Must clear this
                 // or important calls will needlessly fail.
                 // (8.6.91) D. Kent

#ifdef	KOREA	// jinwoo: 92, 9, 28
/* For y position of display, 920604 KDLEE */
#ifdef	NODESC
	{ extern HDC	vhMDC;
	  TEXTMETRIC	tm;

	  GetTextMetrics (vhMDC, (LPTEXTMETRIC)&tm);
	  if (tm.tmCharSet==HANGEUL_CHARSET)
		vypBaseIns = (**wwdCurrentDoc.hdndl) [vdlIns].yp;
	  else
		vypBaseIns = (**wwdCurrentDoc.hdndl) [vdlIns].yp - vdypBase;
	}
#else  /* NODESC */
 vypBaseIns = (**wwdCurrentDoc.hdndl) [vdlIns].yp - vdypBase;
#endif /* NODESC */
#else   /* KOREA */

 vypBaseIns = (**wwdCurrentDoc.hdndl) [vdlIns].yp - vdypBase;
#endif // KOREA:  jinwoo: 92, 9, 28

 dypFontAscent = vfmiScreen.dypAscent + vfmiScreen.dypLeading;
 dypFontDescent = vfmiScreen.dypDescent;

 if (vchpInsert.hpsPos)
    {
    if (vchpInsert.hpsPos < hpsNegMin)
        {
        vypBaseIns -= ypSubSuper;   /* Superscript */
        dypFontAscent += ypSubSuper;
        }
    else
        {
        vypBaseIns += ypSubSuper;   /* Subscript */
        dypFontDescent += ypSubSuper;
        }
    }

 /* Set if current font is too tall to display on insert line */
 vfInsFontTooTall = (imax( dypFontAscent, vfli.dypLine - vfli.dypBase ) +
                     imax( dypFontDescent, vfli.dypBase )) > vfli.dypLine;

 vfTextBltValid = true;
}



int NEAR FCpInsertInDl( cp, pedl  )
typeCP cp;
register struct EDL *pedl;
{   /* Return TRUE if insert point cp is in dl & dl is valid, FALSE otherwise */

if ( (pedl->fValid) && (cp >= pedl->cpMin) )
    {   /* dl is valid & cp is at or below starting cp of dl */
    if ( (cp < pedl->cpMin + pedl->dcpMac) ||
         ((cp == cpMacCur) && (cp == pedl->cpMin + pedl->dcpMac)) )
        {   /* cp is on line dl */
        if (pedl->yp <= wwdCurrentDoc.ypMac)
            {   /* dl is complete, i.e. not cut off at bottom of window */
            return TRUE;
            }
        }
    }
return FALSE;
}




#ifdef FOOTNOTES
/* F  E D I T  F T N */
int FEditFtn(cpFirst, cpLim)
typeCP cpFirst, cpLim;
{ /* Return true if edit includes an end of footnote mark */
        struct FNTB **hfntb;
        typeCP cp;

        if ((hfntb = HfntbGet(docCur)) == 0 ||
                cpLim < (cp = (*hfntb)->rgfnd[0].cpFtn))
                return false;

        if (cpFirst < cp ||
                CpRefFromFtn(docCur, cpFirst) != CpRefFromFtn(docCur, cpLim))
                {
                Error(IDPMTFtnLoad);
                return fTrue;
                }
        return fFalse;
}
#endif  /* FOOTNOTES */




/* U P D A T E  O T H E R  W W S */
#ifdef CASHMERE
UpdateOtherWws(fInval)
BOOL fInval;
{
        int ww = 0;
        struct WWD *pwwd = rgwwd;
        {{
        while (ww < wwMac)
                {
                if (ww != wwCur && (pwwd++)->doc == docCur)
                        {{
                        typeCP cpI = cpInsert + ichInsert;
                        typeCP cpH = CpMax(cpI, cpInsLastInval);
                        typeCP cpL = CpMin(cpInsLastInval, cpI);
                        typeCP dcp;
                        if ((dcp = cpH - cpL) != cp0 || fInval)
                                AdjustCp(docCur, cpL, dcp, dcp);
                        cpInsLastInval = cpI;
                        return;
                        }}
                ww++;
                }
        }}
}
#endif  /* CASHMERE */




/* K C I N P U T N E X T K E Y */
KcInputNextKey()
{               /* Get next available key/event from Windows */
                /* Returns key code or kcNil if a non-key event */
                /* Updates the screen if there is time before events arrive */
extern HWND vhWnd;  /* WINDOWS: Handle of the current document display window*/
extern MSG  vmsgLast;   /* WINDOWS: last message gotten */
extern int  vfInsLast;
extern int vfCommandKey;
extern int vfShiftKey;
extern int vfAwfulNoise;

 int i;
 int kc;

 for ( ;; )
    {
    if ( FImportantMsgPresent() )
        goto GotMessage;

/* No events waiting -- if none show up for a while, update the screen */

#ifdef CASHMERE
    UpdateOtherWws( FALSE );
#endif

    {       /* Dawdle for a time, looking for keys, before updating the screen */
    unsigned WHsecGetTime();
    unsigned wHsec;

    wHsec = WHsecGetTime();
    do
        {
        if ( FImportantMsgPresent() )
            goto GotMessage;

        }    while ( WHsecGetTime() - wHsec < dwHsecKeyDawdle );
    }

#ifdef DEBUG
    if (vTune)
        continue;  /* Bag background update while debugging to see how we fare */
#endif

    Scribble( 8, 'U' );
    ClearInsertLine();
    UpdateWw(wwCur, fTrue);
    ToggleSel(selCur.cpFirst, selCur.cpLim, fTrue);
    Scribble( 8, ' ' );

    if ( FImportantMsgPresent() )
       goto GotMessage;

    vfAwfulNoise = FALSE;
    PutCpInWwHz( selCur.cpFirst );

    EndLongOp( NULL );

    if ( FImportantMsgPresent() )
        goto GotMessage;

    if ( !vfTextBltValid )
        ValidateTextBlt();

    /* Nothing has happened for a while, let's blink the cursor */

    {
    unsigned WHsecGetTime();
    unsigned wHsecBlink = GetCaretBlinkTime() / 10;
    unsigned wHsecLastBlink=WHsecGetTime() + wHsecBlink/2;

    for ( ;; )
        {
        unsigned wHsecT;

        if ( FImportantMsgPresent() )
            goto GotMessage;

        /* Another app may have stolen the focus away from us while we called
        PeekMessage(), in which case we should end Alpha mode. */
        if (!vfFocus)
            return kcNil;

        UpdateDisplay( TRUE );
        if ( (wHsecT = WHsecGetTime()) - wHsecLastBlink >= wHsecBlink )
            {
            DrawInsertLine();
            wHsecLastBlink = wHsecT;
            }
        }
    }

    continue;

GotMessage:
#ifdef DBCS

#ifdef  KOREA   /* Need to GetMessage for F-Key during Interim,90.12.27 sangl */
    if ( ((kc=KcAlphaKeyMessage( &vmsgLast )) != kcNil) || IsInterim)
#else
    if ((kc=KcAlphaKeyMessage( &vmsgLast )) != kcNil)
#endif
        {
        if (vmsgLast.wParam == VK_EXECUTE)
            return( kcNil );
        if (vmsgLast.message == WM_KEYDOWN)
            {
            switch (kc) {
            default:
                break;
            case kcAlphaVirtual:
                    /* This means we can't anticipate the key's meaning
                       before translation */
#ifdef  KOREA   /* Need GetMesssage for direc keys, etc during interim 90.12.26 sangl */
                if ( FNonAlphaKeyMessage( &vmsgLast, FALSE ) && !IsInterim)
#else
                if ( FNonAlphaKeyMessage( &vmsgLast, FALSE ) )
#endif
                        /* This is a non-alpha key message */
                    return kcNil;
        if ( !donteat ) {
                    GetMessage( (LPMSG)&vmsgLast, NULL, 0, 0 );
#ifdef DBCS
                    // kksuzuka #9193 NECAI95
                    // got message is WM_KEYDOWN by PeekMessage( )
                    // but got message is WM_IME_STARTCOMPOSITION by GetMessage()
                    // We need DispatchMessage( WM_IME_STARTCOMPOSITION ) 
                    if ( vmsgLast.message == 0x10d ) // WM_IME_STARTCOMPOSITION
                         DispatchMessage( (LPMSG)&vmsgLast );
#endif
            }
        else {
            /* not eat message because FimportantMsgPresent has
            ** eaten KEY_DOWN message
            */
            donteat = FALSE;
            }
        /*
        ** When KKAPP window open, this message is offten wrong.
        ** we must check it is really WM_KEYDOWN
        */
#ifdef  KOREA   /* for level 3, 90.12.26 sangl */
        if ((vmsgLast.message == WM_CHAR) || (vmsgLast.message == WM_INTERIM)) {
#else
        if ( vmsgLast.message == WM_CHAR ) {
#endif
            return vmsgLast.wParam;
            }
        if ( vmsgLast.message != WM_KEYDOWN ) {
            return kcNil;
            }
                TranslateMessage( &vmsgLast );
                continue;
            } /* switch kc */
            } /* if keydown */
    if ( !donteat ) {
            GetMessage( (LPMSG) &vmsgLast, NULL, 0, 0 );
#ifdef  KOREA       /* for level 3, 91.1.21 by Sangl */
        if ( (vmsgLast.message==WM_CHAR)||(vmsgLast.message==WM_INTERIM) ) {
#else
        if ( vmsgLast.message == WM_CHAR ) {
#endif
        return vmsgLast.wParam;
            }
        } /* dont eat */
    else {
        donteat = FALSE;
        }
        } /* if kc != kcNil */
#else
    if ((kc=KcAlphaKeyMessage( &vmsgLast )) != kcNil)
        {
        if (vmsgLast.message == WM_KEYDOWN)
            {
            switch (kc) {
            default:
                break;
            case kcAlphaVirtual:
                    /* This means we can't anticipate the key's meaning
                       before translation */
                if ( FNonAlphaKeyMessage( &vmsgLast, FALSE ) )
                        /* This is a non-alpha key message */
                    return kcNil;

                GetMessage( (LPMSG)&vmsgLast, NULL, 0, 0 );
                TranslateMessage( &vmsgLast );
                continue;
            }
            }
        GetMessage( (LPMSG) &vmsgLast, NULL, 0, 0 );
        }
#endif
    return kc;
    }   /* End of for ( ;; ) loop to process messages */
}

#ifdef  KOREA       /* 90.12.29 sangl */
KcInputNextHan()
{       /* Get next available key/event from Windows */
        /* Returns key code or kcNil if a non-key event */
        /* Updates the screen if there is time before events arrive */
extern HWND vhWnd;  /* WINDOWS: Handle of the current document display window*/
extern MSG  vmsgLast;   /* WINDOWS: last message gotten */
extern int  vfInsLast;
extern int vfCommandKey;
extern int vfShiftKey;
extern int vfAwfulNoise;

 int i;
 int kc;
 int tmp;

tmp = vfInsLast;
tmp = vfCommandKey;
tmp = vfShiftKey;
tmp = vfAwfulNoise;
tmp = vmsgLast.message;
tmp = vmsgLast.wParam;

 for ( ;; )
    {
    if ( FImportantMsgPresent() )
    goto GotMessage;

/* No events waiting -- if none show up for a while, update the screen */

    {       /* Dawdle for a time, looking for keys, before updating the screen */
    unsigned WHsecGetTime();
    unsigned wHsec;

    wHsec = WHsecGetTime();
    do
    {
    if ( FImportantMsgPresent() )
        goto GotMessage;

    }    while ( WHsecGetTime() - wHsec < dwHsecKeyDawdle );
    }

#ifdef DEBUG
    if (vTune)
    continue;  /* Bag background update while debugging to see how we fare */
#endif

    if ( FImportantMsgPresent() )
       goto GotMessage;

/*  vfAwfulNoise = FALSE;
    PutCpInWwHz( selCur.cpFirst );

    EndLongOp( NULL );*/

    if ( FImportantMsgPresent() )
    goto GotMessage;


    /* Nothing has happened for a while, let's blink the cursor */

    {
    unsigned WHsecGetTime();
    unsigned wHsecBlink = GetCaretBlinkTime() / 10;
    unsigned wHsecLastBlink=WHsecGetTime() + wHsecBlink/2;
    KillTimer( vhWnd, tidCaret );
    for ( ;; )
    {
    unsigned wHsecT;

        if ( FImportantMsgPresent() ) {
        SetTimer( vhWnd, tidCaret, GetCaretBlinkTime(), (FARPROC)NULL );
        goto GotMessage;
        }

    /* Another app may have stolen the focus away from us while we called
    PeekMessage(), in which case we should end Alpha mode. */
        if (!vfFocus) {
        SetTimer( vhWnd, tidCaret, GetCaretBlinkTime(), (FARPROC)NULL );
        return kcNil;
        }

    if ( (wHsecT = WHsecGetTime()) - wHsecLastBlink >= wHsecBlink )
        {
        DrawInsertLine();
        wHsecLastBlink = wHsecT;
        }
    }
    }

    continue;

GotMessage:
    {  // MSCH bklee 12/22/94
       #define VK_PROCESSKEY 0xE5 // New finalize message. bklee.
       #include "ime.h"
       MSG msg;
       extern  BOOL fInterim;

       if (fInterim) {
           if (PeekMessage ((LPMSG)&msg, vhWnd, WM_KEYDOWN, WM_SYSKEYUP, PM_NOYIELD | PM_NOREMOVE )) {
               if ( msg.wParam == VK_MENU || msg.wParam == VK_PROCESSKEY )
                    return VK_MENU;
               else if( msg.wParam == VK_LEFT || msg.wParam == VK_RIGHT ) {
                    HANDLE  hIme;
                    LPIMESTRUCT lpIme;
                    DWORD dwConversionMode;

                    hIme = GlobalAlloc (GMEM_MOVEABLE|GMEM_DDESHARE,(LONG)sizeof(IMESTRUCT));
                    if (hIme && (lpIme = (LPIMESTRUCT)GlobalLock(hIme))) {
                       lpIme->fnc = IME_GETCONVERSIONMODE;
                       GlobalUnlock(hIme);

                       dwConversionMode = SendIMEMessage (GetFocus(), MAKELONG(hIme,0));
                       GlobalFree(hIme);
                    }
                    if (dwConversionMode & IME_MODE_HANJACONVERT) // Hanja conversion mode
                        return VK_MENU;
               }
           }
       }
    }

    if( vmsgLast.wParam == VK_EXECUTE )
        vmsgLast.wParam = VK_RETURN;

/* To GetMessage for Func/Ctrl/direc keys, 90.4.4, Sang-Weon */
    if ( ((kc=KcAlphaKeyMessage(&vmsgLast))!=kcNil) || IsInterim )
    {
if( vmsgLast.wParam == VK_EXECUTE )
    return kcNil;

    if (vmsgLast.message == WM_KEYDOWN)
        {
        switch (kc) {
        default:
        break;
        case kcAlphaVirtual:
            /* This means we can't anticipate the key's meaning
               before translation */
        if ( FNonAlphaKeyMessage(&vmsgLast, FALSE) && !IsInterim )
            /* This is a non-alpha key message */
            return kcNil;
        if ( !donteat ) {
            GetMessage( (LPMSG)&vmsgLast, NULL, 0, 0 );
            }
        else {
            /* not eat message because FimportantMsgPresent has
            ** eaten KEY_DOWN message
            */
            donteat = FALSE;
            }
        /*
        ** When KKAPP window open, this message is offten wrong.
        ** we must check it is really WM_KEYDOWN
        */
        if ( (vmsgLast.message==WM_CHAR)||(vmsgLast.message==WM_INTERIM) ) {
            return vmsgLast.wParam;
            }
        if ( vmsgLast.message != WM_KEYDOWN ) {
            return kcNil;
            }
        TranslateMessage( &vmsgLast );
        continue;
        } /* switch kc */
        } /* if keydown */
    if ( !donteat ) {
        GetMessage( (LPMSG) &vmsgLast, NULL, 0, 0 );
        if ( (vmsgLast.message==WM_CHAR)||(vmsgLast.message==WM_INTERIM) ) {
        return vmsgLast.wParam;
        }
        } /* dont eat */
    else {
        donteat = FALSE;
        }
    } /* if kc != kcNil */
    return kc;
    }   /* End of for ( ;; ) loop to process messages */
}
#endif  /* ifdef KOREA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\initmmw.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* initialization codes for internal memory, page buffers, etc. */
#define NOKEYSTATE
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOSYSMETRICS
#define NOSYSCOMMANDS
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOSHOWWINDOW
//#define NOATOM
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSHOWWINDOW
#define NOBITMAP
#define NOSOUND
#define NOCOMM
#define NOOPENFILE
#define NORESOURCE
#define NOMETAFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOWH
#define NOWINOFFSETS
/* need gdi, hdc, memmgr */
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "editdefs.h"
#include "propdefs.h"
#include "fmtdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "stcdefs.h"
#ifdef CASHMERE
#include "txb.h"
#endif /* CASHMERE */
#include "fontdefs.h"
#include "code.h"
#include "heapdefs.h"
#include "heapdata.h"
#include "str.h"
#include "ch.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif

/* E X T E R N A L S */
extern int              ypMaxWwInit;
extern int              dypWwInit;
extern int              *memory;
extern int              *pmemMax;
extern CHAR             *pmemStart;
extern unsigned         vcbMemTotal;
extern HWND             hParentWw;
extern HDC              vhDCPrinter;
extern int              rfnMac;
extern CHAR             (*rgbp)[cbSector];
extern int              fnMac;
extern typeTS           tsMruRfn;
extern struct ERFN      dnrfn[];
extern CHAR             *rgibpHash;
extern struct BPS       *mpibpbps;
extern typeTS           tsMruBps;
extern struct CHP       vchpNormal;
extern struct PAP       *vppapNormal;
extern struct SEP       vsepNormal;
extern struct CHP       (**vhgchpFormat)[];
extern int              ichpMacFormat;
extern struct CHP       vchpInsert;
extern struct CHP       vchpSel;
extern struct FCB       (**hpfnfcb)[];
extern struct FKPD      vfkpdCharIns;
extern struct FKPD      vfkpdParaIns;
extern struct PAP       vpapPrevIns;
extern struct FLI       vfli;
extern int              docMac;
extern struct DOD       (**hpdocdod)[];
extern int              docScrap;
extern int              docUndo;
#ifdef CASHMERE /* No docBuffer in WRITE */
extern int              docBuffer;
#endif
extern int              docCur;
extern CHAR             (**hszSearch)[];
extern CHAR             (**hszReplace)[];
extern CHAR             (**hszFlatSearch)[];
extern CHAR             stBuf[];
extern int              vrefSystem;
extern CHAR             (**vhrgbSave)[];
extern int              vdxaPaper;
extern int              vdyaPaper;
extern struct SEL       selCur;
extern BOOL             vfPrinterValid;
extern int              dxaPrPage;
extern int              dyaPrPage;
extern int              dxpPrPage;
extern int              dypPrPage;
extern int              dxaPrOffset;
extern int              dyaPrOffset;
extern HCURSOR          vhcArrow;
#ifdef UNUSED
extern int  vfCanPrint;
#endif

//Win3.1J
#if defined(JAPAN) & defined(DBCS_IME) /* Doc for Insert IR_STRING from IME */
extern int     docIRString;
#endif

/* G L O B A L S -- used only in here */
int                     rgwPapNormal[cwPAPBase + cwTBD] = {0};


#ifdef STATICPAGES
#ifdef MACHA
#define                 ibpMaxStatic  79
#define                 iibpHashMaxStatic  163
#else /* not MACHA */
#define                 ibpMaxStatic  7
#define                 iibpHashMaxStatic  17
#endif /* MACHA */
CHAR                    rgbpStatic[ibpMaxStatic][cbSector];
#endif /* STATICPAGES */

extern typePN PnAlloc();

STATIC int NEAR FInitDocs( void );
STATIC int NEAR FInitProps( void );
STATIC int NEAR FInitFiles( void );
WORD wWinVer,fPrintOnly=FALSE;

int FInitMemory()
{
extern HANDLE vhReservedSpace;
int i;

#ifdef UNUSED
/* Initially assume that it is not possible to print  */
/* Formerly InitPrint was called here    */
        vfCanPrint =  false;
#endif

    /** This is a glitch so that the fixed array for storing relocation
        information will be created immediately */
    wWinVer = (WORD)(GetVersion() & 0x0000FFFFL);
    if (((wWinVer & 0xFF) >= 3) && ((wWinVer & 0xFF00) >= 0x0A00))
    /* Windows Version >= 3.10 */
    {
        FARPROC LHandleDelta = GetProcAddress(GetModuleHandle((LPSTR)"KERNEL"),(LPSTR)0x136L);
        i = LHandleDelta(0);
        LHandleDelta(i*5); /* make a big finger table */
        vhReservedSpace = LocalAlloc(LHND, cbReserve);
        LocalFree(vhReservedSpace);
        LHandleDelta(i); /* resume to a smaller finger table if needed more */
    }
    else
    /* Windows Version < 3.10 */
    {
        /**
            This is heaping kludge upon kludge in the effort to be backwards
            compatible with past kludges.  This is the old macro which with
            Win31 has become a function call. (3.11.91) D. Kent
        **/
#define LocalHandleDelta(d) ((d) ? (*(pLocalHeap+9) = (d)) : *(pLocalHeap+9))
        i = LocalHandleDelta(0);
        LocalHandleDelta(i*5); /* make a big finger table */
        vhReservedSpace = LocalAlloc(LHND, cbReserve);
        LocalFree(vhReservedSpace);
        LocalHandleDelta(i); /* resume to a smaller finger table if needed more */
    }

#ifdef OURHEAP
/* reserve 1K for windows's memory manager for creating dialog boxes */
        vhReservedSpace = LocalAlloc(LPTR, cbReserve);

        CreateHeapI(); /* create heap first */
        if (!FCreateRgbp())  /* rgbp are expandable */
            return FALSE;

/* now free the reserved space after our memory is set up. */
/* hopefully we will get all the fixed objects created by
   dialog manager be placed above our memory chunk, so we can still
   expand our heap while a dialog box is up. */
        LocalFree(vhReservedSpace);
#else
        if (!FCreateRgbp())
            return FALSE;
        vhReservedSpace = LocalAlloc(LHND, cbReserve); /* this is to make
        discardable when we are out of memory and try to bring up the
        save dialog box */
#endif

        if (vhReservedSpace == NULL)
            return FALSE;

/* formerly CreateHpfnfcb */
        hpfnfcb = (struct FCB (**)[])HAllocate(cwFCB * fnMax);
        if (FNoHeap(hpfnfcb))
            return FALSE;
        fnMac = fnMax;
        for (i = 0; i < fnMac; i++)
            (**hpfnfcb)[i].rfn = rfnFree;
/* end of CreateHpfnfcb */

        if (!FSetScreenConstants())
            return FALSE;

        if ( !FInitDocs() ||
#ifdef CASHMERE     /* No glossary in MEMO */
             !FInitBufs() ||
#endif  /* CASHMERE */
             !FInitProps() ||
             !FInitFiles() )
            return FALSE;

/* allocate emergency space for save operations */
        if (FNoHeap(vhrgbSave = (CHAR (**)[])HAllocate(cwSaveAlloc)))
            return FALSE;

        return TRUE;
}
/* end of  F I n i t M e m o r y  */




int FInitArgs(sz)
CHAR *sz;
{   /*  Set extern int docCur to be a new doc, containing
        the file (if any) specified on the command line (sz).

        Initialize a wwd (window descriptor) structure for the document
        and set an appropriate title into the title bar.

        Set selCur to be an insertion point before the first char of the doc,
        and set vchpSel to be the char properties of the insertion point.

        Return TRUE if all is well, FALSE if something went wrong.
        A return of FALSE means that initialization should not continue.
        */

        extern typeCP cpMinDocument;
        extern struct WWD rgwwd[];
        extern int vfDiskError;
        extern int vfSysFull;
        extern int ferror;
        extern BOOL vfWarnMargins;

        int fn, doc;
        RECT rcCont;
        CHAR szT [ cchMaxFile ];
        register CHAR *pch;
                CHAR ch;
        int fEmptyLine = TRUE;
        CHAR (**hsz) [];
        int iT, cbsz;

#ifdef INTL /* International version */
        int fWordDoc = FALSE;
#endif  /* International version */

        /* Decide whether we have anything but white space on the command line */

        for ( pch = sz; (ch = *pch) != '\0'; pch++ )
            if ((ch != ' ') && (ch != '\011'))
                {
                fEmptyLine = FALSE;
                break;
                }

        if (fEmptyLine)
                /* No filename; start with (Untitled) */
            goto Untitled;

        cbsz = CchSz (sz ) - 1;
           /* remove trailing spaces from sz */
        for ( pch = sz + cbsz - 1; pch >= sz; pch-- )
            if (*pch != ' ')
                break;
            else
                {
                *pch = '\0';  /* replace with null */
                cbsz--;
                }

        /* check for /p option (6.26.91) v-dougk */
        if ((sz[0] == '/') && (sz[1] == 'p'))
        {
            sz += 2;
            cbsz -= 2;
            fPrintOnly = TRUE;
            for (; *sz; sz++, cbsz-- ) // get to filename
                if ((*sz != ' ') && (*sz != '\011'))
                    break;

            if (!*sz) /* No filename, abort */
                return FALSE;
        }

        /* convert to OEM */
        AnsiToOem(sz, sz);

        if (!FValidFile( sz, cbsz, &iT ) ||
             !FNormSzFile( szT, sz, dtyNormal ))
            {   /* Bad filename -- it could not be normalized */
            extern int vfInitializing;
            char szMsg[cchMaxSz];
            char *pch;
            extern HWND vhWndMsgBoxParent;
            extern HANDLE hParentWw;

            vfInitializing = FALSE; /* Do not suppress reporting this err */
            MergeStrings (IDPMTBadFileName, sz, szMsg);
            /* if we're being called from a message box, then use it
               as the parent window, otherwise use main write window */
            IdPromptBoxSz(vhWndMsgBoxParent ? vhWndMsgBoxParent : hParentWw,
                          szMsg, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
            ferror = TRUE; /* need to flag */
            vfInitializing = TRUE;
            goto Untitled;
            }

        if ((fn = FnOpenSz( szT, dtyNormal,
               index( szT, '/' ) == NULL &&
               index( szT,':') == NULL && index( szT, '\\') == NULL )) != fnNil)
                /* Opened file OK -- prefetch file contents into rgbp */
        {

#ifdef INTL /* Kanji / International version */
              /* **************************************
              * added check for international version to
                 do Word format conversion. If Word format,
                 bring up another dialog box.
              * ************************************** */

                  /* TestWordCvt return values:

                    -1 means dialog box failed (error already sent)
                       or cancel without conversion.
                    FALSE means not a word document.
                    TRUE means convert this word document.
                        vfBackupSave is changed to reflect whether
                        save is done with backup.
                      */

#ifdef KKBUGFIX     //  added by Hiraisi (BUG#2816 WIN31) in Japan
            if ((fWordDoc = TestWordCvt (fn, (HWND)NULL)) == -1  ||
                 fWordDoc == -2)
#else
            if ((fWordDoc = TestWordCvt (fn, (HWND)NULL)) == -1)
#endif
                goto Untitled;
                /* if fWordDoc is true, will convert later */
#endif  /* International version */


            StartLongOp();
            ReadFilePages( fn );
            EndLongOp(vhcArrow);
        }
        else /* Could not open file  */
        {
            if (fPrintOnly)
                return FALSE;
            else
            {   /* use (Untitled) */
Untitled:
            fn = fnNil;
            sz [0] = '\0';
            szT [0] = '\0';
            }
        }

        if (vfDiskError || vfSysFull)
                /* Serious disk error OR disk holding scratch file is full --
                   bail out */
            return FALSE;

        if (fn != fnNil)
            {   /* Opened file OK -- must account for the case when OpenFile
                   returned a filename that differed from the one given it */

            bltsz( &(**(**hpfnfcb) [fn].hszFile) [0], szT );
            }

        if (FNoHeap(hsz=HszCreate( (PCH) szT )) ||
            (doc=DocCreate( fn, hsz, dtyNormal )) == docNil)
            {   /* Could not create a doc */
            return FALSE;
            }
        if (WwNew(doc, dypWwInit, ypMaxWwInit) == wwNil)
            return FALSE;
        NewCurWw(0, true);
        if (fn != fnNil)
            {
            vfWarnMargins = TRUE;
            SetPageSize();
            vfWarnMargins = FALSE;
            }
        wwdCurrentDoc.cpFirst = selCur.cpLim = selCur.cpFirst = cpMinDocument;
        selCur.fForward = true;
        GetInsPtProps(selCur.cpFirst);

#ifdef OURHEAP
        {
        extern int cwInitStorage;
/* save this amount of heap as "100% free" */
/* formerly CalcTot(true) */
        cwInitStorage = cwHeapMac - cwHeapFree;
        cbTot = (cwHeapMac - cwInitStorage) * sizeof(int);
        cbTotQuotient = (cbTot>>1)/100;
        }
#endif

#ifdef STYLES
/* Set up scrap document to have a valid style sheet on start up. */
        (**hpdocdod)[docScrap].docSsht = (**hpdocdod)[docCur].docSsht;
#endif  /* STYLES */

#ifdef INTL /* International version */
     /* if a word document to be converted, save
        it doing conversion. */

                if (fWordDoc == TRUE)
                        {
                          /* save file in write format. */
                        ConvertFromWord();
                        }
#endif  /* International version */

        SetTitle(szT);

#if defined(OLE)
        ObjOpenedDoc(doc);
#endif
        return TRUE;
}
/* end of  F I n i t A r g s  */




#ifdef OURHEAP
CreateHeapI()
{
FGR *pfgr, *pfgrLim;
#ifdef WINBUG
unsigned cb = (unsigned)GlobalCompact((DWORD)0);
#endif

    ibpMax = ibpMaxSmall;
    if (cb > 0x4fff /* about 20K */)
        {
        HANDLE hTemp;
        /* we can start with a bigger page buffer */
        vcbMemTotal = (unsigned)LocalCompact((WORD)0);
        pmemStart = (CHAR *)LocalAlloc(LPTR, vcbMemTotal);
        /* get all we have and force a reallocation */
        hTemp = LocalReAlloc((HANDLE)pmemStart, 0x4fff, LPTR);
        if (hTemp != NULL)
            {
            LocalFree(hTemp);
            ibpMax = ibpMaxBig;
            }
        else
            {
            /* somehow we failed and went back to the small system */
            LocalFree((HANDLE)pmemStart);
            }
        }

    vcbMemTotal = (unsigned)LocalCompact((WORD)0);

/* memory always bumped to point to the next available slot
   for allocation */
/* take all the space as one chunk and do our own memory management */
    pmemStart = (CHAR *)LocalAlloc(LPTR, vcbMemTotal);
    memory = (int *)pmemStart;
    vcbMemTotal = (unsigned)LocalSize((HANDLE)pmemStart); /* in case
                  we got more than we asked */
    pmemMax = (int *)((CHAR *)memory + vcbMemTotal);

/* take half of heap space for page buffers
    ibpMax = (vcbMemTotal>>1)/cbSector;*/
    iibpHashMax = ibpMax * 2 + 1;

/* Set finger table to low end of heap */
    rgfgr = (PFGR)memory;
    memory += ifgrInit;
    memory = (int *)(((unsigned) memory + 1) & ~1); /* word boundary */

/* Here is our heap */
    pHeapFirst = (int *)memory;

    cwHeapMac = /* cwtotal */
                (((unsigned)pmemMax - (unsigned)pHeapFirst +
                sizeof(int) - 1) / sizeof(int)) -
                /* cw in rgibpHash */
                ((iibpHashMax * sizeof(CHAR) +
                sizeof(int) - 1) / sizeof(int)) -
                /* cw in mpibpbps  */
                ((ibpMax * sizeof(struct BPS) +
                sizeof(int) - 1) / sizeof(int)) -
                /* cw in rgbp */
                ((ibpMax * cbSector * sizeof(CHAR) +
                sizeof(int) - 1) / sizeof(int));

    memory += cwHeapMac;

#ifdef DEBUG
    cwHeapMac -= 16; /* Need spare words for shaking */
                     /* This space is above the finger table */
#endif
    cwHeapFree = cwHeapMac;
    phhMac = (HH *)(pHeapFirst + cwHeapMac);
/* if DEBUG, then phhMac will point at the shake word;
   otherwise it will point to 1 cell after the heap */

    phhFree = (HH *) pHeapFirst;
    phhFree->cw = -cwHeapMac; /* whobj.heap is free */
    phhFree->phhNext = phhFree;
    phhFree->phhPrev = phhFree;

    pfgrMac = &rgfgr[ifgrInit];
    pfgrLim = pfgrMac - 1;

/* thread the free fingers */
    for (pfgr = rgfgr; pfgr < pfgrLim; pfgr++)
        *pfgr = (FGR)(pfgr + 1);
    *pfgrLim = NULL;              /* last free finger */
    pfgrFree = rgfgr;
}
/* end of  C r e a t e H e a p I  */
#endif /* OURHEAP */



STATIC int NEAR FInitDocs()
{ /* Initialize hpdocdod */
        struct DOD *pdod, *pdodLim;
        hpdocdod = (struct DOD (**)[])HAllocate(cwDOD * (docMac = cdocInit));
        if (FNoHeap(hpdocdod))
            return FALSE;

    pdod = &(**hpdocdod)[0];
        pdodLim = pdod + cdocInit;
        while (pdod < pdodLim)
            pdod++->hpctb = 0;  /* Mark all doc entries as free */
        docScrap = DocCreate(fnNil, HszCreate((PCH)""), dtyBuffer);   /* HM */

//Win3.1J
#if defined(JAPAN) & defined(DBCS_IME) /* Doc for Insert IR_STRING from IME */
        docIRString = DocCreate(fnNil, HszCreate((PCH)""), dtyBuffer); /* HM */
#endif

        docUndo = DocCreate(fnNil, HszCreate((PCH)""), dtyBuffer);    /* HM */
#ifdef CASHMERE
        docBuffer = DocCreate(fnNil, HszCreate((PCH)""), dtyBuffer);    /* HM */
#endif

        docCur = docNil;
        NoUndo();
        hszSearch = HszCreate((PCH)""); /* No initial search string */
        hszReplace = HszCreate((PCH)""); /* No initial replace string */
        hszFlatSearch = HszCreate((PCH)""); /* No initial flattenned search string */
        if (docScrap == docNil || docUndo == docNil ||
#if defined(JAPAN) & defined(DBCS_IME) /* Doc for Insert IR_STRING from IME */
        docIRString == docNil ||
#endif
#ifdef CASHMERE
            docBuffer == docNil ||
#endif
            FNoHeap(hszFlatSearch))
                return FALSE;
        return TRUE;
}
/* end of  F I n i t D o c s  */




#ifdef CASHMERE     /* No glossary in MEMO */
FInitBufs()
{
/* Initializes structures and data used in named buffer management.
Allocates space for hgtxb, initializes itxbMac */

        struct TXB *ptxb;
        extern struct TXB (**hgtxb)[];
        extern short itxbMac;

        if (FNoHeap(hszGlosFile = HszCreate((PCH)"")))
            return FALSE;
        if (FNoHeap(hgtxb = (struct TXB (**)[])HAllocate(cwTxb)))
            return FALSE;
        ptxb = &(**hgtxb)[0];
        ptxb->hszName = hszNil;
        itxbMac = 0;
        return TRUE;
}
/* end of  F I n i t B u f s  */
#endif  /* CASHMERE */



STATIC int NEAR FInitProps()
{ /* Initialize your basic properties */

#ifndef FIXED_PAGE
        unsigned dxaRightMin;
        unsigned dyaBottomMin;
#endif /* not FIXED_PAGE */

        vchpNormal.hps = hpsNormal;     /* NOTE - this is the size we use for
                                           incremental encoding, the "default"
                                           size may differ */
        vchpNormal.ftc = 0; /* will be whatever the standard modern font is */
        vchpNormal.ftcXtra = 0;

        vchpNormal.fStyled = true;
        /* vchpNormal.stc = stcNormal; */

        vppapNormal = (struct PAP *)rgwPapNormal;

        /* vppapNormal->fStyled = false; */
        /* vppapNormal->stc = 0; */
        vppapNormal->stcNormChp = stcParaMin;
        /* vppapNormal->dxaRight = 0; */
        /* vppapNormal->dxaLeft = 0; */
        /* vppapNormal->dxaLeft1 = 0; */
        /* vppapNormal->jc = jcLeft; */
        /* vppapNormal->dyaBefore = 0; */
        /* vppapNormal->dtaAfter = 0; */

        vppapNormal->fStyled = true;
        vppapNormal->stc = stcParaMin;
        vppapNormal->dyaLine = czaLine;

        Assert(cwPAP == cwSEP);

        /* vsepNormal.fStyled = false; */
        /* vsepNormal.stc = 0; */
        vsepNormal.bkc = bkcPage;
        /* vsepNormal.nfcPgn = nfcArabic; */

#ifdef FIXED_PAGE
        /* The "normal" page size is fixed at 8-1/2 by 11 inches. */
        vsepNormal.xaMac = cxaInch * 8 + cxaInch / 2;
        vsepNormal.xaLeft = cxaInch * 1 + cxaInch / 4;
        vsepNormal.dxaText = cxaInch * 6;
        vsepNormal.yaMac = cyaInch * 11;
        vsepNormal.yaTop = cyaInch * 1;
        vsepNormal.dyaText = cyaInch * 9;
        vsepNormal.yaRH1 = cyaInch * 3 / 4;
        vsepNormal.yaRH2 = cyaInch * 10 + cyaInch / 4;
#else /* not FIXED_PAGE */
        /* The page size is determined by inquiring it from the printer.  Then,
        other measurements can be derived from it. */
        Assert(vhDCPrinter);
        if (vfPrinterValid && vhDCPrinter != NULL)
            {
            POINT pt;

            /* Get the page size of the printer. */
            if (Escape(vhDCPrinter, GETPHYSPAGESIZE, 0, (LPSTR)NULL,
              (LPSTR)&pt))
                {
                vsepNormal.xaMac = MultDiv(pt.x, dxaPrPage, dxpPrPage);
                vsepNormal.yaMac = MultDiv(pt.y, dyaPrPage, dypPrPage);
                }
            else
                {
                /* The printer won't tell us it page size; we'll have to settle
                for the printable area. */
                vsepNormal.xaMac = ZaFromMm(GetDeviceCaps(vhDCPrinter,
                  HORZSIZE));
                vsepNormal.yaMac = ZaFromMm(GetDeviceCaps(vhDCPrinter,
                  VERTSIZE));
                }

            /* The page size cannot be smaller than the printable area. */
            if (vsepNormal.xaMac < dxaPrPage)
                {
                vsepNormal.xaMac = dxaPrPage;
                }
            if (vsepNormal.yaMac < dyaPrPage)
                {
                vsepNormal.yaMac = dyaPrPage;
                }

            /* Determine the offset of the printable area on the page. */
            if (Escape(vhDCPrinter, GETPRINTINGOFFSET, 0, (LPSTR)NULL,
              (LPSTR)&pt))
                {
                dxaPrOffset = MultDiv(pt.x, dxaPrPage, dxpPrPage);
                dyaPrOffset = MultDiv(pt.y, dyaPrPage, dypPrPage);
                }
            else
                {
                /* The printer won't tell us what the offset is; assume the
                printable area is centered on the page. */
                dxaPrOffset = (vsepNormal.xaMac - dxaPrPage) >> 1;
                dyaPrOffset = (vsepNormal.yaMac - dyaPrPage) >> 1;
                }

            /* Determine the minimum margins. */
            dxaRightMin = imax(0, vsepNormal.xaMac - dxaPrOffset - dxaPrPage);
            dyaBottomMin = imax(0, vsepNormal.yaMac - dyaPrOffset - dyaPrPage);
            }
        else
            {
            /* We have no printer; so, the page is 8-1/2" by 11" for now. */
            vsepNormal.xaMac = 8 * czaInch + czaInch / 2;
            vsepNormal.yaMac = 11 * czaInch;

            /* Assume the entire page can be printed. */
            dxaPrOffset = dyaPrOffset = dxaRightMin = dyaBottomMin = 0;
            }

        /* Ensure that the "normal" margins are larger than the minimum. */
        vsepNormal.xaLeft = umax(cxaInch * 1 + cxaInch / 4, dxaPrOffset);
        vsepNormal.dxaText = vsepNormal.xaMac - vsepNormal.xaLeft - umax(cxaInch
          * 1 + cxaInch / 4, dxaRightMin);
        vsepNormal.yaTop = umax(cyaInch * 1, dyaPrOffset);
        vsepNormal.dyaText = vsepNormal.yaMac - vsepNormal.yaTop - umax(cyaInch
          * 1, dyaBottomMin);

        /* Position the running-heads and the page numbers. */
        vsepNormal.yaRH1 = umax(cyaInch * 3 / 4, dyaPrOffset);
        vsepNormal.yaRH2 = vsepNormal.yaMac - umax(cyaInch * 3 / 4,
          dyaBottomMin);
        vsepNormal.xaPgn = vsepNormal.xaMac - umax(cxaInch * 1 + cxaInch / 4,
          dxaRightMin);
        vsepNormal.yaPgn = umax(cyaInch * 3 / 4, dyaPrOffset);
#endif /* not FIXED_PAGE */

        vsepNormal.pgnStart = pgnNil;
        /* vsepNormal.fAutoPgn = false; */
        /* vsepNormal.fEndFtns = false; */
        vsepNormal.cColumns = 1;
        vsepNormal.dxaColumns = cxaInch / 2;
        /* vsepNormal.dxaGutter = 0; */

        vdxaPaper = vsepNormal.xaMac;
        vdyaPaper = vsepNormal.yaMac;

        vfli.doc = docNil;      /* Invalidate vfli */
        ichpMacFormat = ichpMacInitFormat;
        vhgchpFormat = (struct CHP (**)[])HAllocate(ichpMacInitFormat * cwCHP);
        if (FNoHeap(vhgchpFormat))
            {
            return FALSE;
            }
        return TRUE;
}
/* end of  F I n i t P r o p s  */





STATIC int NEAR FInitFiles()
{
        extern WORD vwDosVersion;

        int fn;
        int cchT;
        struct FKP *pfkp;
        struct FCB *pfcb;
        int osfnExtra;
        CHAR sz [cchMaxFile];

        rfnMac = rfnMacEdit;

        /* Set DOS version we're running under */

        vwDosVersion = WDosVersion();

        InitBps();

#ifdef CKSM
#ifdef DEBUG
        {
        extern int ibpMax, ibpCksmMax;
        extern unsigned (**hpibpcksm) [];

        hpibpcksm = (unsigned (**) [])HAllocate( ibpMax );
        if (FNoHeap( hpibpcksm ))
            return FALSE;
        ibpCksmMax = ibpMax;
        }
#endif
#endif

            /* sz <-- name of new, unique file which will be fnScratch */
        sz[ 0 ] = '\0';     /* Create it in the root on a temp drive */
        if ((fn=FnCreateSz( sz, cpNil, dtyNetwork )) == fnNil )
                /* Couldn't create scratch file: fail */
            return FALSE;

        Assert(fn == fnScratch); /* fnScratch hardwired to 0 for efficiency */
        FreezeHp();
        pfcb = &(**hpfnfcb)[fnScratch];
        pfcb->fFormatted = true; /* Sort of a formatted file */
        pfcb->fDelete = true; /* Kill this file when we quit */
        MeltHp();
        vfkpdParaIns.brun = vfkpdCharIns.brun = 0;
        vfkpdParaIns.bchFprop = vfkpdCharIns.bchFprop = cbFkp;
        vfkpdParaIns.pn = PnAlloc(fnScratch);
        ((struct FKP *) PchGetPn(fnScratch, vfkpdParaIns.pn, &cchT, true))->fcFirst =
            fc0;
        vfkpdCharIns.pn = PnAlloc(fnScratch);
        ((struct FKP *) PchGetPn(fnScratch, vfkpdCharIns.pn, &cchT, true))->fcFirst =
            fc0;

        /* The following can really be allocated 0 words, but why push our luck? */
        vfkpdParaIns.hgbte = (struct BTE (**)[]) HAllocate(cwBTE);
        vfkpdCharIns.hgbte = (struct BTE (**)[]) HAllocate(cwBTE);
        vfkpdParaIns.ibteMac = vfkpdCharIns.ibteMac = 0;
        if (FNoHeap(vfkpdParaIns.hgbte) || FNoHeap(vfkpdCharIns.hgbte))
                return FALSE;

        blt(&vchpNormal, &vchpInsert, cwCHP);
        blt(&vchpNormal, &vchpSel, cwCHP);
        blt(vppapNormal, &vpapPrevIns, cwPAPBase + cwTBD);
        return TRUE;
}
/* end of   F I n i t F i l e s  */




InitBps()
{
/* called from initfiles to set up the tables */
        int ibp, iibp;
        int rfn;
        int fn;

/* In order impliment a LRU page swap strategy, a time stamp(TS) scheme is */
/* used. Associated with each buffer slot is a time stamp.  The least */
/* recently used slot is found by locating the slot with the smallest time */
/* stamp. Every time a new page is brought into the buffer, it TS is set  */
/* equal to the value of a incrimented global TS counter (tsMru...). */
/* Initially, the time stamps are set so that they increase as we move */
/* toward the end of the table.  Thus, even though the entire buffer pool */
/* is initially empty, slots at the beginning of the table will be */
/* allocated first.  */

        {
        register struct ERFN *perfn = &dnrfn [0];

        for (rfn = 0; rfn < rfnMac; rfn++, perfn++)
                {
                perfn->fn = fnNil;
                perfn->ts = rfn;
                }
        tsMruRfn = rfnMac /* + ? */;
        }

        for (iibp = 0; iibp < iibpHashMax; iibp++)
                rgibpHash[iibp] = ibpNil;
        {
        register struct BPS *pbps=&mpibpbps [0];

        for (ibp = 0; ibp < ibpMax; ++ibp, pbps++)
                {
                pbps->fn = fnNil;
                pbps->fDirty = false;
                pbps->ts = ibp;
                pbps->ibpHashNext = ibpNil;
                }
        tsMruBps = ibpMax + cbpMustKeep;
        }
        /* In IbpEnsureValid (file.c) we may not want to use the least */
        /* recently used slot for certain reasons.  But, we do want to */
        /* be assured that we do not clobber the 'cbpMustKeep' most */
        /* recently used slots.  Our check consists of making sure */
        /* (tsMruBps - ts_in_question) < cbpMustKeep.  By the above */
        /* statement, we are assured that non of the empty slots satisfy */
        /* this condition. */

        /* Allocate initial checksum array */



}
/* end of  I n i t B p s  */



#ifdef OURHEAP
FCreateRgbp()
{
    rgbp = (CHAR (*)[cbSector])memory;
    memory = (int *)((unsigned)memory + (unsigned)(ibpMax)
             * cbSector);
    memory = (int *)(((unsigned) memory + 1) & ~1); /* word boundary */
    rgibpHash = (CHAR *)memory;
    memory = (int *)((unsigned)memory +
             (unsigned)(iibpHashMax * sizeof(CHAR)));
    memory = (int *)(((unsigned) memory + 1) & ~1); /* word boundary */
    mpibpbps = (struct BPS *)memory;
    memory = (int *)((unsigned)memory +
             (unsigned)(ibpMax * sizeof(struct BPS)));
    memory = (int *)(((unsigned) memory + 1) & ~1);
    return (memory <= pmemMax);
}
/* end of  F C r e a t e R g b p  */
#else /* use windows' memory manager */
FCreateRgbp()
{
extern int vfLargeSys;

long lcbFree;
unsigned cb;

    ibpMax = ibpMaxSmall;
    lcbFree = GlobalCompact((DWORD)0);
    if (lcbFree > 0x00030D40 /* 200K */)
        {
        /* we can start with a bigger page buffer */
        ibpMax = ibpMaxBig;
        vfLargeSys = TRUE;
        }

    iibpHashMax = ibpMax * 2 + 1;

    cb = ((ibpMax * cbSector * sizeof(CHAR) + 1) & ~1) /* rgbp */
         + ((iibpHashMax * sizeof(CHAR) + 1) & ~1) /* rgibpHash */
         + ((ibpMax * sizeof(struct BPS) + 1) & ~1); /* mpibpbps */

    memory = (int *)LocalAlloc(LPTR, cb);

    if (memory == NULL)
        {
        ibpMax = ibpMaxSmall;
        iibpHashMax = ibpMax * 2 + 1;
        cb = ((ibpMax * cbSector * sizeof(CHAR) + 1) & ~1) /* rgbp */
             + ((iibpHashMax * sizeof(CHAR) + 1) & ~1) /* rgibpHash */
             + ((ibpMax * sizeof(struct BPS) + 1) & ~1); /* mpibpbps */
        memory = (int *)LocalAlloc(LPTR, cb);
        }

    if (memory == NULL)
        return FALSE;

    rgbp = (CHAR (*)[cbSector])memory;
    memory = (int *)((unsigned)memory + (unsigned)(ibpMax)
             * cbSector);
    memory = (int *)(((unsigned) memory + 1) & ~1); /* word boundary */
    rgibpHash = (CHAR *)memory;
    memory = (int *)((unsigned)memory +
             (unsigned)(iibpHashMax * sizeof(CHAR)));
    memory = (int *)(((unsigned) memory + 1) & ~1); /* word boundary */
    mpibpbps = (struct BPS *)memory;

/*
    memory = (int *)((unsigned)memory +
             (unsigned)(ibpMax * sizeof(struct BPS)));
    memory = (int *)(((unsigned) memory + 1) & ~1);*/

    return TRUE;
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\insertco.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOWINSTYLES
#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOSYSMETRICS
#define NOMENUS
#define NOGDI
#define NOKEYSTATE
#define NOHDC
#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "prmdefs.h"
#include "propdefs.h"
#include "filedefs.h"
#include "stcdefs.h"
#include "fkpdefs.h"
#include "editdefs.h"
#include "wwdefs.h"
#include "dispdefs.h"

/* E X T E R N A L S */
extern struct WWD rgwwd[];
extern int docCur;
extern struct CHP vchpFetch;
extern struct CHP vchpInsert;
extern struct CHP vchpSel;
extern struct CHP vchpNormal;
extern struct FKPD     vfkpdParaIns;
extern typeFC fcMacPapIns;
extern struct PAP *vppapNormal;
extern struct PAP vpapPrevIns;
extern struct FCB (**hpfnfcb)[];
extern struct BPS      *mpibpbps;
extern CHAR           (*rgbp)[cbSector];

extern typePN PnAlloc();


InsertRgch(doc, cp, rgch, cch, pchp, ppap)
int doc, cch;
typeCP cp;
CHAR rgch[];
struct CHP *pchp;
struct PAP *ppap;
{ /* Insert cch characters from rgch into doc before cp */
        typeFC fc;
        struct CHP chp;

        /* First finish off the previous CHAR run if necessary */
        if (pchp == 0)
                { /* Make looks be those of PREVIOUS character */
                CachePara(doc,cp);
                FetchCp(doc, CpMax(cp0, cp - 1), 0, fcmProps);
                blt(&vchpFetch, &chp, cwCHP);
                chp.fSpecial = false;
                pchp = &chp;
                }
        NewChpIns(pchp);

        /* Now write the characters to the scratch file */
        fc = FcWScratch(rgch, cch);

        /* Now insert a paragraph run if we inserted an EOL */
        if (ppap != 0)
                { /* Inserting EOL--must be last character of rgch */
                AddRunScratch(&vfkpdParaIns, ppap, vppapNormal,
                        FParaEq(ppap, &vpapPrevIns) &&
                        vfkpdParaIns.brun != 0 ? -cchPAP : cchPAP,
                        fcMacPapIns = (**hpfnfcb)[fnScratch].fcMac);
                blt(ppap, &vpapPrevIns, cwPAP);
                }

        /* Finally, insert the piece into the document */
        Replace(doc, cp, cp0, fnScratch, fc, (typeFC) cch);
}





InsertEolInsert(doc,cp)
int doc;
typeCP cp;
{
struct PAP papT;
struct CHP chpT;
CHAR rgch[2];

/* (MEMO) Here's the problem: When we insert or paste into a running head or
   foot, we expect all paras to have a non-0 rhc. This gets called from
   Replace to put in an Eol when we are inserting or pasting in front of
   a picture. It needs, therefore, to have running head properties when
   appropriate.  In a future world, cpMinDocument, cpMinHeader, cpMacHeader,
   cpMinFooter, and cpMacFooter will be document attributes instead of
   globals, and will be duly adjusted by AdjustCp. Then, we can trash the
   somewhat kludgy check for doc==docCur and editing header/footer,
   and instead check for cp within header/footer bounds for doc. */

papT = *vppapNormal;
if (doc==docCur)
    if (wwdCurrentDoc.fEditHeader)
        papT.rhc = RHC_fOdd + RHC_fEven;
    else if (wwdCurrentDoc.fEditFooter)
        papT.rhc = RHC_fBottom + RHC_fOdd + RHC_fEven;

#ifdef CRLF
        rgch[0] = chReturn;
        rgch[1] = chEol;
        chpT = vchpSel;
        chpT.fSpecial = fFalse;
        InsertRgch(doc, cp, rgch, 2, &chpT, &papT);
#else
        rgch[0] = chEol;
        chpT = vchpSel;
        chpT.fSpecial = fFalse;
        InsertRgch(doc, cp, rgch, 1, &chpT, &papT);
#endif
}





InsertEolPap(doc, cp, ppap)
int doc;
typeCP cp;
struct PAP      *ppap;
{
extern struct CHP vchpAbs;
struct CHP chpT;
#ifdef CRLF
CHAR rgch [2];
#else
CHAR rgch [1];
#endif

    /* We must get props here instead of using vchpNormal because of the
       "10-point kludge".  We don't want to change the default font
       just because we have to insert a new pap */

FetchCp( doc, cp, 0, fcmProps );
chpT = vchpAbs;
chpT.fSpecial = fFalse;

#ifdef CRLF
rgch [0] = chReturn;
rgch [1] = chEol;
InsertRgch(doc, cp, rgch, 2, &chpT, ppap);
#else
InsertRgch(doc, cp, rgch, 1, &chpT, ppap);
#endif
}




AddRunScratch(pfkpd, pchProp, pchStd, cchProp, fcLim)
struct FKPD *pfkpd;
CHAR *pchProp, *pchStd;
int cchProp;
typeFC fcLim;
{ /* Add a CHAR or para run to the scratch file FKP (see FAddRun) */
struct FKP *pfkp;
CHAR *pchFprop;
struct RUN *prun;
int ibp;

pfkp = (struct FKP *) rgbp[ibp = IbpEnsureValid(fnScratch, pfkpd->pn)];
pchFprop = &pfkp->rgb[pfkpd->bchFprop];
prun = (struct RUN *) &pfkp->rgb[pfkpd->brun];


while (!FAddRun(fnScratch, pfkp, &pchFprop, &prun, pchProp, pchStd, cchProp,
    fcLim))
        { /* Go to a new page; didn't fit. */
        int ibte = pfkpd->ibteMac;
        struct BTE (**hgbte)[] = pfkpd->hgbte;

        /* Create new entry in bin table for filled page */
        if (!FChngSizeH(hgbte, ((pfkpd->ibteMac = ibte + 1) * sizeof (struct BTE)) / sizeof (int),
            false))
                return;
        (**hgbte)[ibte].fcLim = (prun - 1)->fcLim;
        (**hgbte)[ibte].pn = pfkpd->pn;

        /* Allocate new page */
        pfkpd->pn = PnAlloc(fnScratch);
        pfkpd->brun = 0;
        pfkpd->bchFprop = cbFkp;

        if (cchProp < 0) /* New page, so force output of fprop */
                cchProp = -cchProp;

        /* Reset pointers and fill in fcFirst */
        pfkp = (struct FKP *) rgbp[ibp = IbpEnsureValid(fnScratch, pfkpd->pn)];
        pfkp->fcFirst = (prun - 1)->fcLim;
        pchFprop = &pfkp->rgb[pfkpd->bchFprop];
        prun = (struct RUN *) &pfkp->rgb[pfkpd->brun];
        }

mpibpbps[ibp].fDirty = true;
pfkpd->brun = (CHAR *) prun - &pfkp->rgb[0];
pfkpd->bchFprop = pchFprop - &pfkp->rgb[0];
}




int FAddRun(fn, pfkp, ppchFprop, pprun, pchProp, pchStd, cchProp, fcLim)
int fn, cchProp;
struct FKP *pfkp;
CHAR **ppchFprop, *pchProp, *pchStd;
struct RUN **pprun;
typeFC  fcLim;
{ /* Add a run and FCHP/FPAP to the current FKP. */
        /* Make a new page if it won't fit. */
        /* If cchProp < 0, don't make new fprop if page not full */
int cch;

/* If there's not even enough room for a run, force new fprop */
if (cchProp < 0 && (CHAR *) (*pprun + 1) > *ppchFprop)
        cchProp = -cchProp;

if (cchProp > 0)
        { /* Make a new fprop */
        /* Compute length of FPAP/FCHP */
        if (cchProp == cchPAP)
                {
/* compute difference from vppapNormal */
                if (((struct PAP *)pchProp)->rgtbd[0].dxa != 0)
                        {
                        int itbd;
/* find end of tab table */
                        for (itbd = 1; itbd < itbdMax; itbd++)
                                if (((struct PAP *)pchProp)->rgtbd[itbd].dxa == 0)
                                        {
                                        cch = cwPAPBase * cchINT + (itbd + 1) * cchTBD;
                                        goto HaveCch;
                                        }
                        }
                cchProp = cwPAPBase * cchINT;
                }
        cch = CchDiffer(pchProp, pchStd, cchProp);
HaveCch:
        if (cch > 0)
                ++cch;

        /* Determine whether info will fit on this page */
        if ((CHAR *) (*pprun + 1) > *ppchFprop - cch)
                { /* Go to new page; this one is full */
                if (fn == fnScratch)
                        return false; /* Let AddRunScratch handle this */
                WriteRgch(fn, pfkp, cbSector);
                pfkp->fcFirst = (*pprun - 1)->fcLim;
                *ppchFprop = &pfkp->rgb[cbFkp];
                *pprun = (struct RUN *) pfkp->rgb;
                }

        /* If new FPAP is needed, make it */
        if (cch > 0)
                {
                (*pprun)->b = (*ppchFprop -= cch) - pfkp->rgb;
                **ppchFprop = --cch;
                bltbyte(pchProp, *ppchFprop + 1, cch);
                }
        else /* Use standard props */
                (*pprun)->b = bNil;
        }
else  /* Point to previous fprop */
        (*pprun)->b = (*pprun - 1)->b;

    /* Replaced old sequence (see below) */
(*pprun)->fcLim = fcLim;
pfkp->crun = ++(*pprun) - (struct RUN *) pfkp->rgb;

/*      Used to be like this, but CMERGE -Oa (assume no aliasing)
        option made it not work -- "*pprun" is an alias for the
        postincremented value of *pprun */
/*(*pprun)++->fcLim = fcLim;
pfkp->crun = *pprun - (struct RUN *) pfkp->rgb; */

return true;
}


/* F  P A R A  E Q */
/* compares two PAP structures. Problem: tab tables are not fixed length
but are terminated by 0 dxa. */
FParaEq(ppap1, ppap2)
struct PAP *ppap1, *ppap2;
        {
        struct TBD *ptbd1 = ppap1->rgtbd, *ptbd2 = ppap2->rgtbd;
        while (ptbd1->dxa == ptbd2->dxa)
                {
                if (ptbd1->dxa == 0)
                        return CchDiffer(ppap1, ppap2, cchPAP) == 0;
                if (*(long *)ptbd1 != *(long *)ptbd2) break;
                ptbd1++; ptbd2++;
                }
        return fFalse;
        }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\kanji.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* kanji.h ----- kanji primitives forward declaration. */

#ifdef DBCS

/***** common definition for Korea, Japan and Taiwan PRC *****/

/* CHLS (c of half line spacing) used to indicate the default
   line spacing.  Used in createww.c and initmmw.c */
#define chlsSingle      2
#define chlsOneHalf     3
#define chlsDouble      4

#define chlsDefault     chlsOneHalf


/* HDC             KanjiGetDC(HWND);        */
/* void FAR PASCAL SetMapperFlags(HDC, long);   */
/* And the kludge value to be used. */
#define NEC_HACK      ((long) 0x04)


/* struct DNUT is used to map a unit annotation to ut. */
struct DNUT {
    char    *szUnit;
    int     ut;
    };

#ifdef CASHMERE
#define IDNUTMAX  19
#else
#define IDNUTMAX  15
#endif /* CASHMERE */


/* Function type declarations. */
int      HpsFromDya(unsigned);
unsigned DyaFromHps(int);

BOOL     FPasteTooLarge(unsigned long);

/* For copy command, we now use the "COPY" key. */
#ifndef NONECKEYBOARD
#define VK_COPY     0x2C
#else
#ifndef NOVIRTUALKEYCODES
#define VK_COPY     VK_F2
#endif /* not NOVIRTUALKEYCODES */
#endif /* if-else-def NONECKEYBOARD */

#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif /* DEBUG */

/* Kanji flag ---- used in CpFirstSty() */
#define fkNonKanji ((CHAR) 0)
#define fkKanji1   ((CHAR) 1)
#define fkKanji2   ((CHAR) 2)

#define cchKanji   2

#define MAKEWORD(_bHi, _bLo) ((((WORD) _bHi) << 8) | ((WORD) _bLo))

#define dxp0       0

/******* KOREA specific definitons *******/

#ifdef  KOREA
/* Used in GetKanjiMeasurement */
#define bKanji1Min   0xA1
/* First byte of a kanji space. */
#define bKanjiSpace1 0xA1
/* Second byte of a kanji space. */
#define bKanjiSpace2 0xA1
/* 1 byte kanji period. */
#define bKanjiKuten 0xA1

#define FKanji1(_ch) (((int) (_ch))>=0x0081 && ((int) (_ch))<=0x00FE)
#define FKanji2(_ch) (((int) (_ch))>=0x0041 && ((int) (_ch))<=0x00FE)
#define FKana(_ch)      (FALSE)
/* Excludes any kana punctuations. */
#define FKanaText(_ch)  ((0xB0 <= ((int) (_ch)) && ((int) (_ch)) <= 0xC8) \
                          || (0xCA <= ((int) (_ch)) && ((int) (_ch)) <= 0xFD))
#define FKanaPunct(_ch) (0xA1 <= ((int) (_ch)) && ((int) (_ch)) <= 0xA2)

#define FKanjiSpace(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                 ((int) (_ch2)) == 0x00A1)
#define FKanjiQMark(_ch1, _ch2) (((int) (_ch1)) == 0x00A3 && \
                                 ((int) (_ch2)) == 0x00AF)
#define FKanjiPeriod(_ch1, _ch2) (((int) (_ch1)) == 0x00A3 && \
                                  ((int) (_ch2)) == 0x00AE)
#define FKanjiBang(_ch1, _ch2)   (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x00A1)
#define FKanjiKuten(_ch1, _ch2)  (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x00A3)


/* Since the higher half of 1-byte character codes are used for
   kanas and the first byte of a kanji character, we will use
   kanji characters for our markers. */
#define chEMark     ((CHAR) 0xA4)
#define chStatPage  ((CHAR) 0xBB)
#if 0
#define chMark1     ((CHAR) 0xA1)
#define chEMark     ((CHAR) 0xDF)
#define chStatPage  ((CHAR) 0xB7)
#define chStatRH    ((CHAR) 0xB5)
#endif

#ifdef  CODE_TABLE
/* The following tables defines those characters which can be display
   beyond the right margin.
   Refer to FAdmitCh2 function in d_FORM1.c */

#define MPDCHRGCHIDX_MAC    2
static CHAR mpdchrgchIdx[2] = {0xA1, 0xA3};
static int  mpdchichMax[2] = {13, 12};

static CHAR mpdchrgch[2][13] = {
          /* A1 */ {0xA1, 0xAF, 0xB1, 0xB3, 0xB5, 0xB7, 0xB9, 0xBB, 0xBD, 0xC6, 0xC7, 0xC8, 0xC9},
          /* A3 */ {0xA1, 0xA2, 0xA5, 0xA7, 0xA9, 0xAC, 0xAE, 0xBA, 0xBB, 0xBF, 0xDD, 0xFD}
                               };

/* The followin tables specify characters which can exist beyond the
   right margin provided there is a kanji character on its left side
   Refer to FOptAdmitCh2 in d_FORM1.c on how to use them */

#define OPTADMIT2IDX_MAC    1
static  CHAR OptAdmit2Idx[1] = {0xA3};
static  int OptAdmit2ichMax[1] = {6};
static  CHAR mpdchrgchOptAdmit2[1][6] = {
                {0xA1, 0xAC, 0xAE, 0xBA, 0xBB, 0xBF}
                                        };
#endif      /* CODE_TABLE */

#endif      /* Korea */

/******* JAPAN specific definitons *******/

#ifdef  JAPAN
/* Used in GetKanjiMeasurement */
#define bKanji1Min   0x81
/* First byte of a kanji space. */
#define bKanjiSpace1 0x81
/* Second byte of a kanji space. */
#define bKanjiSpace2 0x40
/* 1 byte kanji period. */
#define bKanjiKuten 0xA1

#define FKanji1(_ch) ((((int) (_ch))>=0x0081 && ((int) (_ch))<=0x009f)  \
                   || (((int) (_ch))>=0x00e0 && ((int) (_ch))<=0x00fc))
//T-HIROYN Win3.1
#define FKanji2(_ch) ((((int) (_ch))>=0x0040 && ((int) (_ch))<=0x007e)  \
                   || (((int) (_ch))>=0x0080 && ((int) (_ch))<=0x00fc))

#define FKana(_ch)      (0xA0 <= ((int) (_ch)) && ((int) (_ch)) <= 0xdf)
/* Excludes any kana punctuations. */
#define FKanaText(_ch)  (0xA6 <= ((int) (_ch)) && ((int) (_ch)) <= 0xDD)
#define FKanaPunct(_ch) ((0xA0 <= ((int) (_ch)) && ((int) (_ch)) <= 0xA5) || \
                         (0xDE <= ((int) (_ch)) && ((int) (_ch)) <= 0xDF))

#define FKanjiSpace(_ch1, _ch2) (((int) (_ch1)) == 0x0081 && \
                                 ((int) (_ch2)) == 0x0040)
#define FKanjiQMark(_ch1, _ch2) (((int) (_ch1)) == 0x0081 && \
                                 ((int) (_ch2)) == 0x0048)
#define FKanjiPeriod(_ch1, _ch2) (((int) (_ch1)) == 0x0081 && \
                                  ((int) (_ch2)) == 0x0044)
#define FKanjiBang(_ch1, _ch2)   (((int) (_ch1)) == 0x0081 && \
                                  ((int) (_ch2)) == 0x0049)
#define FKanjiKuten(_ch1, _ch2)  (((int) (_ch1)) == 0x0081 && \
                                  ((int) (_ch2)) == 0x0042)

/* Write 3.1j endmark and pagemark is 1-byte charcter
 *                              t-Yoshio May 26,92
 */
//Win3.1 New Code
#define chEMark     ((CHAR) 0xA4)
#define chStatPage  ((CHAR) 0xBB)
/* Since the higher half of 1-byte character codes are used for
   kanas and the first byte of a kanji character, we will use
   kanji characters for our markers. */
//Win3.0
#if 0
#define chMark1     ((CHAR) 0x81)
#define chEMark     ((CHAR) 0x9F)
#define chStatPage  ((CHAR) 0x74)
#define chStatRH    ((CHAR) 0x72)
#endif

#ifdef  CODE_TABLE
/* The following tables defines those characters which can be display
   beyond the right margin.
   Refer to FAdmitCh2 function in d_FORM1.c */

#define MPDCHRGCHIDX_MAC    4
static CHAR mpdchrgchIdx[4] = {0x81, 0x82, 0x83, 0x85};
static int  mpdchichMax[4] = {24, 9, 12, 20};

static CHAR mpdchrgch[4][24] = {
             /* 0x81 */ {0x40, 0x41, 0x42, 0x45, 0x4A, 0x4B, 0x5B, 0x5C,
                         0x5D, 0x63, 0x64, 0x66, 0x68, 0x6A, 0x6C, 0x6E,
                         0x70, 0x72, 0x74, 0x76, 0x78, 0x7A, 0x8C, 0x8D},
             /* 0x82 */ {0x9F, 0xA1, 0xA3, 0xA5, 0xA7, 0xC1, 0xE1, 0xE3,
                         0xE5},
             /* 0x83 */ {0x40, 0x42, 0x44, 0x46, 0x48, 0x62, 0x83, 0x85,
                         0x87, 0x8E, 0x95, 0x96},
             /* 0x85 */ {0x41, 0x46, 0x48, 0x7C, 0x9D, 0x9F, 0xA1, 0xA2,
                         0xA3, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB,
                         0xAC, 0xAD, 0xDC, 0xDD}
                               };
/* The followin tables specify characters which can exist beyond the
   right margin provided there is a kanji character on its left side
   Refer to FOptAdmitCh2 in d_FORM1.c on how to use them */

#define OPTADMIT2IDX_MAC    2
static  CHAR OptAdmit2Idx[2] = {0x81, 0x85};
static  int OptAdmit2ichMax[2] = {6,6};
static  CHAR mpdchrgchOptAdmit2[2][6] = {
                        {0x43, 0x44, 0x46, 0x47, 0x48, 0x49},
                        {0x40, 0x49, 0x4A, 0x4B, 0x4D, 0x5E}
                                        };
#endif      /* CODE_TABLE */

#endif      /* Japan */

/******* PRC specific definitons *******/


#ifdef  PRC
/* Used in GetKanjiMeasurement */
#define bKanji1Min   0x81
/* First byte of a kanji space. */
#define bKanjiSpace1 0xA1
/* Second byte of a kanji space. */
#define bKanjiSpace2 0xA1
/* 1 byte kanji period. */
#define bKanjiKuten 0x7F

#define FKanji1(_ch) (((int) (_ch))>=0x0081 && ((int) (_ch))<=0x00FE)
/* Excludes any kana punctuations. */
#define FKanaText(_ch)  ((0x81 <= ((int) (_ch)) && ((int) (_ch)) <= 0xA0) ||  \
	                     (0xAA <= ((int) (_ch)) && ((int) (_ch)) <= 0xFE))

#define FKanaPunct(_ch) (0xA1 <= ((int) (_ch)) && ((int) (_ch)) <= 0xA9)

#define FKanjiSpace(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                 ((int) (_ch2)) == 0x00A1)
#define FKanjiQMark(_ch1, _ch2) (((int) (_ch1)) == 0x00A3 && \
                                 ((int) (_ch2)) == 0x00BF)
#define FKanjiPeriod(_ch1, _ch2) (((int) (_ch1)) == 0x00A3 && \
                                  ((int) (_ch2)) == 0x00AE)
#define FKanjiBang(_ch1, _ch2)   (((int) (_ch1)) == 0x00A3 && \
                                  ((int) (_ch2)) == 0x00A1)
#define FKanjiKuten(_ch1, _ch2)  (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x00A2)


/* Since the higher half of 1-byte character codes are used for
   kanas and the first byte of a kanji character, we will use
   kanji characters for our markers. */
#define chMark1     ((CHAR) 0xA1)
#define chEMark     ((CHAR) 0xF4)
#define chStatPage  ((CHAR) 0x6E)
#define chStatRH    ((CHAR) 0x72)

#ifdef  CODE_TABLE
/* The following tables defines those characters which can be display
   beyond the right margin.
   Refer to FAdmitCh2 function in d_FORM1.c */

#define MPDCHRGCHIDX_MAC    2
static CHAR mpdchrgchIdx[2] = {0xA1, 0xA3};
static int  mpdchichMax[2]  = {11,13};

static CHAR mpdchrgch[2][13] = {
	            /* 0xA1 */     {0xA2, 0xA3, 0xAF, 0xB1, 0xB3, 0xB5, 0xB7, 
                                0xB9, 0xBB, 0xBD, 0xBF},
	            /* 0xA3 */     {0xA1, 0xA2, 0xA7, 0xA9, 0xAC, 0xAE, 0xBA, 
                                0xBB, 0xBF, 0xDD, 0xE0, 0xFC, 0xFD},
						       };
/* The followin tables specify characters which can exist beyond the
   right margin provided there is a kanji character on its left side
   Refer to FOptAdmitCh2 in d_FORM1.c on how to use them */

#define OPTADMIT2IDX_MAC    2
static  CHAR OptAdmit2Idx[2] = {0xA1, 0xA3};
static  int OptAdmit2ichMax[2] = {1,5};
static  CHAR mpdchrgchOptAdmit2[2][5] = {
	                   /* 0xA1 */         { 0xA3 },
	                   /* 0xA3 */         { 0xA1, 0xAE, 0xBA, 0xBB, 0xBF }
	                                    };
#endif      /* CODE_TABLE */

#else  

/******* TAIWAN specific definitons *******/

#ifdef  TAIWAN
/* Used in GetKanjiMeasurement */
#define bKanji1Min   0xA1
/* First byte of a kanji space. */
#define bKanjiSpace1 0xA1
/* Second byte of a kanji space. */
#define bKanjiSpace2 0x40
/* 1 byte kanji period. */
#define bKanjiKuten 0x7F

#define FKanji1(_ch) (((int) (_ch))>=0x0081 && ((int) (_ch))<=0x00FE)
/* Excludes any kana punctuations. */
#define FKanaText(_ch)  (0xA4 <= ((int) (_ch)) && ((int) (_ch)) <= 0xFE)
#define FKanaPunct(_ch) (0xA1 <= ((int) (_ch)) && ((int) (_ch)) <= 0xA3)

#define FKanjiSpace(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                 ((int) (_ch2)) == 0x0040)
#define FKanjiQMark(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                 ((int) (_ch2)) == 0x0048)
#define FKanjiPeriod(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x0044)
#define FKanjiBang(_ch1, _ch2)   (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x0049)
#define FKanjiKuten(_ch1, _ch2)  (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x0042)


/* Since the higher half of 1-byte character codes are used for
   kanas and the first byte of a kanji character, we will use
   kanji characters for our markers. */
#define chMark1     ((CHAR) 0xA1)
#define chEMark     ((CHAR) 0xBB)
#define chStatPage  ((CHAR) 0x6E)
#define chStatRH    ((CHAR) 0x72)

#ifdef  CODE_TABLE
/* The following tables defines those characters which can be display
   beyond the right margin.
   Refer to FAdmitCh2 function in d_FORM1.c */

#define MPDCHRGCHIDX_MAC    1
static CHAR mpdchrgchIdx[1] = {0xA1};
static int  mpdchichMax[1] = {24};

static CHAR mpdchrgch[1][24] = {
                        {0x41, 0x42, 0x43, 0x44, 0x46, 0x47, 0x48, 0x49,
                         0x4A, 0x4D, 0x4E, 0x51, 0x52, 0x53, 0x54, 0x62,
                         0x66, 0x6A, 0x77, 0x7B, 0x7E, 0xA2, 0xA4, 0xA8}
                               };

/* The followin tables specify characters which can exist beyond the
   right margin provided there is a kanji character on its left side
   Refer to FOptAdmitCh2 in d_FORM1.c on how to use them */

#define OPTADMIT2IDX_MAC    1
static  CHAR OptAdmit2Idx[1] = {0xA1};
static  int OptAdmit2ichMax[1] = {6};
static  CHAR mpdchrgchOptAdmit2[1][6] = {
                        0x43, 0x44, 0x46, 0x47, 0x48, 0x49,
                                        };
#endif      /* CODE_TABLE */

#endif      /* Taiwan */

#endif  /* PRC */

#ifdef USA
#define chMark1     ((CHAR) 0x81)
#define chStatPage      (CHAR)'\273'
#define chStatRH        '>'
#define chEMark         (CHAR)'\244'


/* Used in GetKanjiMeasurement */
#define bKanji1Min   0xA1
/* First byte of a kanji space. */
#define bKanjiSpace1 0xA1
/* Second byte of a kanji space. */
#define bKanjiSpace2 0xA1
/* 1 byte kanji period. */
#define bKanjiKuten 0xA1

#define FKanji1(_ch) (((int) (_ch))>=0x00A1 && ((int) (_ch))<=0x00FE)
/* Excludes any kana punctuations. */
#define FKanaText(_ch)  (0xA4 <= ((int) (_ch)) && ((int) (_ch)) <= 0xFE)
#define FKanaPunct(_ch) (0xA1 <= ((int) (_ch)) && ((int) (_ch)) <= 0xA3)

#define FKanjiSpace(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                 ((int) (_ch2)) == 0x0040)
#define FKanjiQMark(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                 ((int) (_ch2)) == 0x0048)
#define FKanjiPeriod(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x0044)
#define FKanjiBang(_ch1, _ch2)   (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x0049)
#define FKanjiKuten(_ch1, _ch2)  (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x0042)

#ifdef  CODE_TABLE
/* The following tables defines those characters which can be display
   beyond the right margin.
   Refer to FAdmitCh2 function in d_FORM1.c */

#define MPDCHRGCHIDX_MAC    0
static CHAR mpdchrgchIdx[1] = {0};
static int  mpdchichMax[1] = {0};

static CHAR mpdchrgch[1][1] = {0};

/* The followin tables specify characters which can exist beyond the
   right margin provided there is a kanji character on its left side
   Refer to FOptAdmitCh2 in d_FORM1.c on how to use them */

#define OPTADMIT2IDX_MAC    0
static  CHAR OptAdmit2Idx[1] = {0};
static  int OptAdmit2ichMax[1] = {0};
static  CHAR mpdchrgchOptAdmit2[1][1] = {0};
#endif      /* CODE_TABLE */

#endif

#endif      /* Kanji */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\jumppage.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOSCROLL
#define NOMB
#include <windows.h>

#include "mw.h"
#include "dlgdefs.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "str.h"
#include "propdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "docdefs.h"


extern int    rgval[];
extern struct WWD *pwwdCur;
extern struct DOD (**hpdocdod)[];
extern int        docCur;     /* Document in current ww */
extern struct SEL selCur;      /* Current selection (i.e., sel in current ww */
extern struct SEP vsepNormal;
extern HWND       vhWndMsgBoxParent;
extern int        vfCursorVisible;
extern HCURSOR    vhcArrow;



BOOL far PASCAL DialogGoTo( hDlg, message, wParam, lParam )
HWND    hDlg;            /* Handle to the dialog box */
unsigned message;
WORD wParam;
LONG lParam;
{
    /* This routine handles input to the Go To dialog box. */
    /*RECT rc;*/
    struct SEP **hsep = (**hpdocdod)[docCur].hsep;
    struct SEP *psep;
    CHAR szT[cchMaxNum];
    CHAR *pch = &szT[0];
    extern ferror;

    switch (message)
    {
    case WM_INITDIALOG:
        EnableOtherModeless(false);
        /* Get a pointer to the section properties. */
        psep = (hsep == NULL) ? &vsepNormal : *hsep;

        /* Initialize the starting page number. */
        if (psep->pgnStart != pgnNil)
            {
            szT[ncvtu(psep->pgnStart, &pch)] = '\0';
            SetDlgItemText(hDlg, idiGtoPage, (LPSTR)szT);
            SelectIdiText(hDlg, idiGtoPage);
            }
        else
            {
            SetDlgItemText(hDlg, idiGtoPage, (LPSTR)"1");
            SelectIdiText(hDlg, idiGtoPage);
            }
        break;

    case WM_SETVISIBLE:
        if (wParam)
            EndLongOp(vhcArrow);
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            vhWndMsgBoxParent = hDlg;
        if (vfCursorVisible)
            ShowCursor(wParam);
        return(FALSE); /* so that we leave the activate message to
        the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
        switch (wParam)
        {
        case idiOk:
            if (!WPwFromItW3Id(&rgval[0], hDlg, idiGtoPage, pgnMin, pgnMax, wNormal, IDPMTNPI))
                {
                ferror = FALSE; /* reset error condition, so as to report any 
                                   further error */
                break;
                }
            OurEndDialog(hDlg, TRUE);   /* So we take down the dialog box and
                                           only screen update ONCE ..pault */
            CmdJumpPage();
            if (pwwdCur->fRuler)
                UpdateRuler();
            break;
        
        case idiCancel:
CancelDlg:
            OurEndDialog(hDlg, TRUE);
            break;
        default:
            return(FALSE);
        }
        break;

    case WM_CLOSE:
        goto CancelDlg;

    default:
        return(FALSE);
    }
    return(TRUE);
}
/* end of DialogGoTo */


/* C M D  J U M P  P A G E */
CmdJumpPage()
    { /* JUMP PAGE:
	0    page number
       */

    extern typeCP cpMinCur;

    int ipgd;
    int cpgd;
    register struct PGD *ppgd;
    struct PGTB **hpgtb = (**hpdocdod)[docCur].hpgtb;
    BOOL fWrap = FALSE;
    typeCP cpTarget;


    ClearInsertLine();

    if (hpgtb == NULL)
	{
	goto SelFirstPage;
	}

    cpgd = (**hpgtb).cpgd;

TryAgain:
    for (ipgd = 0, ppgd = &(**hpgtb).rgpgd[0]; ipgd < cpgd; ipgd++, ppgd++)
	{
	if (ppgd->pgn == rgval[0] && (fWrap || ipgd + 1 == cpgd ||
	  (ppgd + 1)->cpMin > selCur.cpFirst))
	    {
	    cpTarget = ppgd->cpMin;
	    goto ShowPage;
	    }
	}
    if (!fWrap)
	{
	fWrap = TRUE;
	goto TryAgain;
	}

    /* If rgval[0] > last page number jump to last page */
    if ((ppgd = &(**hpgtb).rgpgd[cpgd - 1])->pgn < rgval[0])
	{
	cpTarget = ppgd->cpMin;
	}
    else if (rgval[0] == 1)
	{

SelFirstPage:
	cpTarget = cpMinCur;
	}
    else
	{
	Error(IDPMTNoPage);
	return;
	}

ShowPage:
    /* Position first char of page on the first dl */
    DirtyCache(pwwdCur->cpFirst = cpTarget);
    pwwdCur->ichCpFirst = 0;
    CtrBackDypCtr(0, 0);

    /* In this case, CpFirstSty() will update the screen. */
    cpTarget = CpFirstSty(cpTarget, styLine);
    Select(cpTarget, cpTarget);
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\lib.asm ===
TITLE   lib - various C library routines

; Windows Write, Copyright 1985-1992 Microsoft Corporation
;=============================================================================
;   This file contains various C library functions (and a few other
;   functions) with the PL/M calling conventions.  These routines
;   may some day make their way into a real library of some kind, but
;   until then, you'll just have to link this file in with the rest
;   of your code.
;=============================================================================

?PLM = 1
?WIN = 1

;*** See note about cmacros2.inc in DOSLIB.ASM
include cmacros3.inc

;
;createSeg _MMP2, code, byte, public, CODE
;

sBegin  CODE
;    assumes CS,_MMP2
        assumes CS,CODE

;------------------------------------------------------------------------------
; bltbyte (pbFrom, pbTo, cb) - a block transfer of bytes from pbFrom to
; pbTo.  The size of the block is cb bytes.  This bltbyte() handles the
; case of overlapping source and destination.  bltbyte() returns a pointer
; to the end of the destination buffer (pbTo + cb).  NOTE - use this
; bltbyte to transfer within the current DS only--use the bltbx for
; FAR blts.
;-----------------------------------------------------------------------------

cProc bltbyte, <FAR, PUBLIC>, <SI, DI>
parmDP  <pbFrom, pbTo>
parmW   <cb>
cBegin bltbyte
    mov     si,pbFrom           ; get pointers and length of blt
    mov     di,pbTo
    mov     cx,cb
    mov     ax,di               ; calculate return value
    add     ax,cx
    push    ds                  ; set up segment registers
    pop     es
    cmp     si,di               ; reverse direction of the blt if
    jae     bltb1               ;  necessary
    add     si,cx
    add     di,cx
    dec     si
    dec     di
    std
bltb1:
    rep     movsb
    cld
cEnd bltbyte

;-----------------------------------------------------------------------------
; bltbx (qbFrom, qbTo, cb) - same as bltbyte above except everything is
; handled as FAR pointers.
;-----------------------------------------------------------------------------

cProc bltbx, <FAR, PUBLIC>, <SI, DI, DS>
parmD <qbFrom, qbTo>
parmW <cb>
cBegin bltbx
    les     di,qbTo
    lds     si,qbFrom
    mov     cx,cb
    mov     ax,di
    add     ax,cx
    cmp     si,di
    jae     bltbx1
    add     si,cx
    add     di,cx
    dec     si
    dec     di
    std
bltbx1:
    rep     movsb
    cld
    mov     dx,es
cEnd bltbx


;------------------------------------------------------------------------------
; blt (pFrom, pTo, cw) - a block transfer of wFills from pFrom to pTo;
; The size of the block is cw wFills.  This blt() handles the case of
; overlapping source and destination.  blt() returns a pointer to the
; end of the destination buffer (pTo + cw).  NOTE - use this blt() to
; to transfer within the current DS only--use the bltx for FAR blts.
;-----------------------------------------------------------------------------

cProc blt, <FAR, PUBLIC>, <SI, DI>
parmDP  <pFrom, pTo>
parmW   <cw>
cBegin blt
    mov     si,pFrom            ; get pointers and length of blt
    mov     di,pTo
    mov     cx,cw
    mov     ax,di               ; calculate return value
    mov     bx,cx
    shl     bx,1
    add     ax,bx
    push    ds                  ; set up segment registers
    pop     es
    cmp     si,di               ; reverse direction of the blt if
    jae     blt1                ;  necessary
    dec     bx
    dec     bx
    add     si,bx
    add     di,bx
    std
blt1:
    rep     movsw
    cld
cEnd blt

;-----------------------------------------------------------------------------
; bltx (qFrom, qTo, cw) - same as blt() above except everything is
; handled as FAR pointers.
;-----------------------------------------------------------------------------

cProc bltx, <FAR, PUBLIC>, <si, di, ds>
parmD <qFrom, qTo>
parmW <cw>
cBegin bltx
    les     di,qTo
    lds     si,qFrom
    mov     cx,cw
    mov     ax,di
    mov     bx,cx
    shl     bx,1
    add     ax,bx
    cmp     si,di
    jae     bltx1
    dec     bx
    dec     bx
    add     si,bx
    add     di,bx
    std
bltx1:
    rep     movsw
    cld
    mov     dx,es
cEnd bltx

;-----------------------------------------------------------------------------
; bltc (pTo, wFill, cw) - fills cw words of memory starting at pTo with wFill.
;-----------------------------------------------------------------------------

cProc bltc, <FAR, PUBLIC>, <DI>
parmDP  <pTo>
parmW   <wFill, cw>
cBegin bltc
    mov     ax,ds               ; we are filling in the data segment
    mov     es,ax
    mov     di,pTo              ; get the destination, constant, and count
    mov     ax,wFill
    mov     cx,cw
    cld                         ; the operation is forward
    rep     stosw               ; fill memory
cEnd bltc

;-----------------------------------------------------------------------------
; bltcx (qTo, wFill, cw) - fills cw words of memory starting at FAR location
; qTo with wFill.
;-----------------------------------------------------------------------------

cProc bltcx, <FAR, PUBLIC>, <DI>
parmD   <qTo>
parmW   <wFill, cw>
cBegin bltcx
    les     di,qTo              ; get the destination, constant, and count
    mov     ax,wFill
    mov     cx,cw
    cld                         ; the operation is forward
    rep     stosw               ; fill memory
cEnd bltcx

;-----------------------------------------------------------------------------
; bltbc (pTo, bFill, cb) - fills cb bytes of memory starting at pTo with
; bFill.
;-----------------------------------------------------------------------------

cProc bltbc, <FAR, PUBLIC>, <DI>
parmDP  <pTo>
parmB   <bFill>
parmW   <cb>
cBegin bltbc
    mov     ax,ds               ; we are filling in the data segment
    mov     es,ax
    mov     di,pTo              ; get the destination, constant, and count
    mov     al,bFill
    mov     cx,cb
    cld                         ; the operation is forward
    rep     stosb               ; fill memory
cEnd bltbc

;-----------------------------------------------------------------------------
; bltbcx (qTo, bFill, cb) - fills cb bytes of memory starting at FAR location
; qTo with bFill.
;-----------------------------------------------------------------------------

cProc bltbcx, <FAR, PUBLIC>, <DI>
parmD   <qTo>
parmB   <bFill>
parmW   <cb>
cBegin bltbcx
    les     di,qTo              ; get the destination, constant, and count
    mov     al,bFill
    mov     cx,cb
    cld                         ; the operation is forward
    rep     stosb               ; fill memory
cEnd bltbcx



;-----------------------------------------------------------------------------
; MultDiv(w, Numer, Denom) returns (w * Numer) / Denom rounded to the nearest
; integer.  A check is made so that division by zero is not attempted.
;-----------------------------------------------------------------------------

cProc MultDiv, <FAR, PUBLIC>
parmW  <w, Numer, Denom>
cBegin MultDiv
    mov     bx,Denom    ; get the demoninator
    mov     cx,bx       ; cx holds the final sign
    or      bx,bx       ; ensure the denominator is positive
    jns     md1
    neg     bx
md1:
    mov     ax,w        ; get the word we are multiplying
    xor     cx,ax       ; make cx reflect any sign change
    or      ax,ax       ; ensure this word is positive
    jns     md2
    neg     ax
md2:
    mov     dx,Numer    ; get the numerator
    xor     cx,dx       ; make cx reflect any sign change
    or      dx,dx       ; ensure the numerator is positive
    jns     md3
    neg     dx
md3:
    mul     dx          ; multiply
    mov     cl,bl       ; get half of the demoninator to adjust for rounding
    sar     bx,1
    add     ax,bx       ; adjust for possible rounding error
    adc     dx,0        ; this is really a long addition
    sal     bx,1        ; restore the demoninator
    or      bl,cl
    cmp     dx,bx       ; check for overflow
    jae     md5
    div     bx          ; divide
    or      ax,ax       ; if sign is set, then overflow occured
    js      md5
    or      cx,cx       ; put the sign on the result
    jns     md4
    neg     ax
md4:

cEnd MultDiv

md5:
    mov     ax,7FFFh    ; return the largest integer
    or      cx,cx       ; with the correct sign
    jns     md4
    neg     ax
    jmp     md4

;-----------------------------------------------------------------------------
; FSzSame (szOne, szTwo) - Compare strings, return 1=Same, 0=different
;   Both strings in DS
;-----------------------------------------------------------------------------

cProc FSzSame, <FAR, PUBLIC>, <SI>
parmDP  <szOne>
parmDP  <szTwo>
cBegin FszSame

    mov     bx,szOne
    mov     si,szTwo

fszloop:
    mov     al,[bx]
    cmp     al,[si]
    jnz     notequal    ; found inequality - return FALSE
    inc     bx
    inc     si
    test    al,al
    jnz     fszloop     ; didn't reach a zero-terminator compare next char

    mov     ax,1
    jmp     fszend
notequal:
    xor     ax,ax
fszend:

cEnd FszSame


;-----------------------------------------------------------------------------
; CchDiffer (rgch1,rgch2,cch) - compare 2 strings, returning cch of
;                               shortest prefix leaving a common remainder
;    implementation of the following C code
;    note rather odd return values: 0 if =, # of unmatched chars +1 otherwise.
;    note comparison is from end of string
;** int CchDiffer(rgch1, rgch2, cch)
;** register CHAR *rgch1, *rgch2;
;** int cch;
;** {{ /* Return cch of shortest prefix leaving a common remainder */
;** int ich;

;** for (ich = cch - 1; ich >= 0; ich--)
        ;** if (rgch1[ich] != rgch2[ich])
                ;** break;
;** return ich + 1;
;** }}
;-----------------------------------------------------------------------------

        cProc CchDiffer, <FAR, PUBLIC>, <SI,DI>
        parmDP  <rgch1>
        parmDP  <rgch2>
        parmW   <cch>
        cBegin CchDiffer
        mov     ax,ds   ; set es=ds for string ops
        mov     es,ax

        mov     si,rgch1
        mov     di,rgch2
        mov     cx,cch     ; loop count in cx
        mov     ax,cx      ; compare from end of string down
        dec     ax
        add     si,ax
        add     di,ax
        std
        repz    cmpsb           ; compare strings
        jz      DiffRet         ; return 0 if strings =
        inc     cx              ; else increment return value
DiffRet:
        mov     ax,cx       ; return # of unmatched chars
        cld                     ; restore to be nice
        cEnd CchDiffer


ifdef DEBUG

;-----------------------------------------------------------------------------
; toggleProf () - toggles winprof (windows profiler) profiling on or off.
;     this calls to hard coded locations that both symdeb and winprof know
;     about - see Lyle Kline for an actual explanation.
;-----------------------------------------------------------------------------

cProc toggleProf, <FAR, PUBLIC>
cBegin toggleProf

    ; ** the following strings are stored by the profiler starting at
    ; ** 100h of the loaded segment. This routine checks that the 1st
    ; ** 3 letters of each string are in the proper location to determine
    ; ** whether the profiler is already loaded.

; **** segname  db      "SEGDEBUG",0
; ****          db      "PROFILER",0

        push    es
        push    di
        push    si
        xor     ax,ax
        mov     es,ax
        mov     ax,es:[14]              ;Get segment down there.
        mov     es,ax
        mov     di,0100h                ;See if Profiler in memory.

        cmp     Byte Ptr es:[di],'S'
        jnz     $0001

        cmp     Byte Ptr es:[di+1],'E'
        jnz     $0001

        cmp     Byte Ptr es:[di+2],'G'
        jnz     $0001

        cmp     Byte Ptr es:[di+9],'P'
        jnz     $0001

        cmp     Byte Ptr es:[di+10],'R'
        jnz     $0001

        mov     ax,30    ;Type of call.
        push    ax

        mov     di,00FCh
        call    Dword Ptr es:[di]       ; call to profiler toggle routine.
        add     sp,2                    ; winprof uses normal c conventions

$0001:
        pop     si
        pop     di
        pop     es

cEnd toggleProf

endif

;-----------------------------------------------------------------------------
; void OsTime( pTime )
;
;   pTime is a pointer to a structure of the form:
;       struct {
;               char min;       Minutes (0-59)
;               char hour;      Hours (0-23)
;               char hsec;      Hundredths of seconds (0-99)
;               char sec;       Seconds (0-59)
;
;   Get current time into structure
;   DOS-specific
;-----------------------------------------------------------------------------

cProc OsTime, <FAR, PUBLIC>
parmDP  <pTime>
cBegin OsTime

    mov     ah,2ch
    int     21h

    mov     bx,pTime
    mov     WORD PTR [bx], cx
    mov     WORD PTR [bx+2], dx

cEnd OsTime


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Added by PaulT 3/23/89, borrowed from PC Word 5:
;
;	IchIndexLp(lpsz, ch)
;		char far *lpsz;
;		int ch;
;	Searches for ch in lpsz and returns the index (-1 if not found)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cProc	IchIndexLp,<FAR, PUBLIC>
	parmD	lpsz
	parmB	chT
cBegin
	mov	dx, di			; Save di
	les	di, lpsz
	mov	ah, chT
	xor	al,al
	mov	bx, di			; Save initial pointer
					; **** Can't access parms anymore

	mov	cx,-1
	repnz	scasb			; Must have '\0'
	or	ax, ax
	jz	LDoneILI
	mov	al, ah			; al = chT
	not	cx
	dec	cx
	mov	di, bx
	repnz	scasb
	jz	LDoneILI
	mov	di, bx
LDoneILI:
	mov	ax, di
	sub	ax, bx
	dec	ax			; ax = return value
	mov	di, dx			; Restore di
cEnd IchIndexLp


sEnd    CODE

        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\macro.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains some useful macros. */

#define FillBuf(pb, cb, ch)     bltbc((pb), (CHAR)(ch), cb)

#define FSzSame(sz1, sz2)       (WCompSz(sz1, sz2) == 0)

#define SetWords(pw, w, cw)     bltc((CHAR *)(pw), (unsigned)(w), cw)

#define SetBytes(pb, b, cb)     bltbc((CHAR *)(pb), (CHAR)(b), cb)

#define NMultDiv(w1, w2, w3)    MultDiv(w1, w2, w3)

/* Theses macros are used by Windows Word to facilitate the conversion form
Mac Word. */

#define SetSpaceExtra(dxp)      SetTextJustification(vhMDC, dxp, 1)

#define TextWidth(rgch, w, cch) LOWORD(GetTextExtent(vhMDC, (LPSTR)rgch, cch))


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\looks.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the definitions of the various codes returned from the
"looks" expert keys in Windows Word. */

#define fLooks		0x4000

#define fCharLooks	0x0100
#define fParaLooks	0x0200
#define fSectLooks	0x0400
#define fUserDefined	0x0800

#define ilkNil		0x4fff

/* Character looks */
#define ilkStd		0x4100
#define ilkBold		0x4101
#define ilkItalic	0x4102
#define ilkUline	0x4103
#define ilkSuper	0x4104
#define ilkSub		0x4105
#define ilkSmCaps	0x4106
#define ilkHpsSmall	0x4107
#define ilkHpsBig	0x4108
#define ilkFont		0x4109

/* Paragraph looks */
#define ilkGeneral	0x4200
#define ilkLeft		0x4201
#define ilkRight	0x4202
#define ilkCenter	0x4203
#define ilkJust		0x4204
#define ilkOpen		0x4205
#define ilkIndent	0x4206
#define ilkNest		0x4207
#define ilkUnnest	0x4208
#define ilkHang		0x4209

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\machdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define MACHA
       /* definition of macha moved here by bz instead of on command
          like to compiler to allow other command line args */

/* cbSector -- Number of bytes in sector */
/* p2bSector -- Power of two of bytes in sector (iff cbSector==2^n) */
/* cbPad -- Difference between real sector size and our sector size. (Used
            only if the real sector size is odd) */
/* cbWorkspace -- Number of bytes needed by interpreter for file overhead */


#ifdef SAND
#define cbSector        128
#define p2bSector       7
#define cbPad           0
#define cbWorkspace     0
#define rfnMax          5
#define pnMaxScratch    (1 << (16 - p2bSector))

#else

#ifdef MACHA            /* IBM PC, PC-XT, OR PC-AT */
#define cbSector        128
#define p2bSector       7
#define cbPad           0
#define cbWorkspace     1

#define rfnMacEdit      9        /* # of rfn's to use during editing */
#define rfnMacSave      10       /* # of rfn's to use during saving */
#define rfnMax          10       /* Allocated # of rfn slots */

#define pnMaxScratch    (1 << (16 - p2bSector))


/* -------------------------------------------------------------------- */
/* Added conditional compilation for long filename support under OS/2   */
/* t-carlh - August, 1990                                               */
/* -------------------------------------------------------------------- */
#ifdef OS2
#define cchMaxLeaf      260     /* Largest filename (w/ ext, w/o drv,path) */
#define cchMaxFile      260     /* Largest filename (w/ ext, drv, path) */
#else   /* OS2 */
#define cchMaxLeaf      13      /* Largest filename (w/ ext, w/o drv,path) */
#define cchMaxFile      128     /* Largest filename (w/ ext, drv, path) */
#endif  /* OS2 */

#endif

#ifdef MACHB
#define cbSector        252
#define cbPad           1
#define cbWorkspace     (64+253)
#endif

#ifdef MACHC
#define cbSector        512
#define p2bSector       9
#define cbPad           0
#define cbWorkspace     20
#endif

#ifdef MACHD
#define cbSector        256
#define p2bSector       8
#define cbPad           0
#define cbWorkspace     (31+256)
#endif

#ifdef MACHE
#define cbSector        512
#define p2bSector       9
#define cbPad           0
#define cbWorkspace     0
#define rfnMax          2
#endif

#ifdef MACHF
#define cbSector        512
#define p2bSector       9
#define cbPad           0
#define cbWorkspace     38
#endif
#endif /* SAND */


#define EOF     (-1)

#ifdef SAND
#define mdRandom        0
#define mdRanRO         0100000 /* Read only random file */
#define mdBinary        1
#define mdBinRO         0100001 /* Read only binary save file */
#define mdText          2
#define mdTxtRO         0100002 /* Read only text file */
#define mdPrint         3
#endif

#ifdef MACHA
#define mdRandom        0x0002
#define mdBinary        mdRandom
#define mdText          mdRandom
#define mdRanRO         0x0000
#define mdBinRO         mdRanRO
#define mdTxtRO         mdRanRO

#define mdExtMax        5       /* # chars in an extension, including the . */

#endif

extern int ibpMax;
extern int iibpHashMax;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\loadfont.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* loadfont.c - MW font support code */

#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOSYSMETRICS
#define NOMENUS
#define NOWINSTYLES
#define NOCTLMGR
#define NOCLIPBOARD
#include <windows.h>

#include "mw.h"
#include "propdefs.h"
#include "macro.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "fontdefs.h"
#include "docdefs.h"

#ifdef  DBCS
#include "dbcs.h"
#include "kanji.h"
#endif

extern HDC vhMDC;
extern HDC vhDCPrinter;
extern struct CHP vchpNormal;
extern int vifceMac;
extern union FCID vfcidScreen;
extern union FCID vfcidPrint;
extern struct FCE rgfce[ifceMax];
extern struct FCE *vpfceMru;
extern struct FCE *vpfceScreen;
extern struct FCE *vpfcePrint;
extern struct FMI vfmiScreen;
extern struct FMI vfmiPrint;
#ifdef SYSENDMARK
extern struct FMI vfmiSysScreen;
#endif /* KANJI */


extern int dxpLogInch;
extern int dypLogInch;
extern int dxaPrPage;
extern int dyaPrPage;
extern int dxpPrPage;
extern int dypPrPage;
extern int ypSubSuperPr;
extern BOOL vfPrinterValid;


#ifdef DEBUG
BOOL NEAR DogoneTrashTest(HDC hdc, struct FCE *pfce, BOOL fPrint);
#endif

NEAR LoadFcid(union FCID *, struct CHP *);
void NEAR SelectWriteFont(int, HFONT *);
struct FCE * (PfceFcidScan(union FCID *));
struct FCE * (PfceLruGet(void));
#ifdef SMFONT
void NEAR FillWidthTable(HDC, int [], TEXTMETRIC *);
#endif /* SMFONT */

#ifdef JAPAN                  //  added  11 Jun. 1992  by Hiraisi
void fnCheckWriting( LPLOGFONT );
#endif

LoadFont( doc, pchp, mdFont )
/* loads the font specified in pchp for this doc.  mdFont tells us how the
   font will be used (printer, screen, screen modulo printer,... */

int doc;
register struct CHP *pchp;
int mdFont;

    {
    register int wFcid;
    struct CHP *pchpT;
    union FCID fcid;

    Assert(doc != docNil);

    pchpT = pchp;
    if (pchp == NULL)
        pchp = &vchpNormal;

    fcid.strFcid.hps = pchp->hps;
    fcid.strFcid.ftc = pchp->ftc;
    fcid.strFcid.doc = doc;
#ifdef ENABLE
    wFcid = pchp->psWidth;
    wFcid |= bitPrintFcid;
    if (pchp->fItalic)
        wFcid |= bitItalicFcid;
    if (pchp->fBold)
        wFcid |= bitBoldFcid;
    if (pchp->fUline)
        wFcid |= bitUlineFcid;
    if (pchp->fFixedPitch)
        wFcid |= bitFixedPitchFcid;
    fcid.strFcid.wFcid = wFcid;
#else
    /* Super-nitpick-optimization (but worth it because LoadFont can take
       10% of display refresh time): bits being cleared is more
       common than set, and a "jump not taken" plus an "or di, xxxx" is 8
       cycles, vs the above "jump taken" which is 16 */

    wFcid = pchp->psWidth + bitPrintFcid + bitItalicFcid + bitBoldFcid +
      bitUlineFcid + bitFixedPitchFcid;
    if (!pchp->fItalic)
        wFcid &= ~bitItalicFcid;
    if (!pchp->fBold)
        wFcid &= ~bitBoldFcid;
    if (!pchp->fUline)
        wFcid &= ~bitUlineFcid;
    if (!pchp->fFixedPitch)
        wFcid &= ~bitFixedPitchFcid;
    fcid.strFcid.wFcid = wFcid;
#endif

    switch (mdFont)
        {
        /* fall throughs are intentional! */

        default:
            break;

        case mdFontChk:         /* sets font as constrained by printer avail */
        case mdFontPrint:       /* like mdFontScreen, but for the printer */
            /* don't want to jam the chp props back */
            pchpT = NULL;

        case mdFontJam:         /* like mdFontChk, but jams props into chp */

            /* get printer font loaded */
            LoadFcid(&fcid, pchpT);

            if (mdFont == mdFontPrint)
                /* don't need screen font */
                return;

        case mdFontScreen:      /* sets font for random screen chars */
            /* get screen font loaded */
            fcid.strFcid.wFcid &= ~bitPrintFcid;
            LoadFcid(&fcid, (struct CHP *)NULL);
        }
    }


NEAR LoadFcid(pfcid, pchp)
/* loads described font and associates it with the appropriate dc's */

union FCID *pfcid;
struct CHP *pchp;
    {
    register struct FCE *pfce;
    int fPrint;
    int fTouchAndGo;
    int fGetMetrics;
    int fNewFont;
    struct FFN **hffnSave;
    LOGFONT lf;

#ifdef SYSENDMARK
    fPrint = pfcid->strFcid.wFcid & bitPrintFcid;

    /* Since this ftc came from CHP, we have lost the first 2 bits. */
    if (pfcid->strFcid.ftc == (bitFtcChp & ftcSystem)) {
        /* If vpfceScreen == NULL already, the standard system font
           has already been selected. So, save some time here.      */
        if (vpfceScreen != NULL) {
            /* Gives you the standard system font for the screen.   */
            ResetFont(FALSE);
            }
        bltbyte(&vfmiSysScreen, &vfmiScreen, sizeof(struct FMI));
#if defined(KANJI) && defined(DFONT)
        /* CommSz("System Font!\r\n"); */
        KTS();
#endif
        return;
        }
    else if (fPrint)
#else
    if ((fPrint = pfcid->strFcid.wFcid & bitPrintFcid))
#endif /* if-else-def KANJI */
        {
        if (pfcid->lFcid == vfcidPrint.lFcid)
            {
            pfce = vpfcePrint;
            fTouchAndGo = TRUE;
            goto EstablishFont;
            }
        }
    else
        {
        if (pfcid->lFcid == vfcidScreen.lFcid)
            {
            pfce = vpfceScreen;
            fTouchAndGo = TRUE;
            goto EstablishFont;
            }
        }

    /* failed at the "trivial" comparisons - look through list */
    fTouchAndGo = FALSE;
    pfce = vpfceMru;
    do
        {
        if (pfce->fcidRequest.lFcid == pfcid->lFcid)
            {
            /* found a match */
            fGetMetrics = FALSE;
            goto EstablishFont;
            }
        pfce = pfce->pfceNext;
        }
    while (pfce != vpfceMru);

    /* failed at the "easy" search - look for name text & property match */
    fGetMetrics = TRUE;
    if (fNewFont = (pfce = PfceFcidScan(pfcid)) == NULL)
        {
        /* this font isn't in our list - we have to create it */
        int wFcid = pfcid->strFcid.wFcid;
        int dyaHeight;
        int cwAlloc;
        int ich;
        struct FFN **hffnT;
        struct FFN **MpFcidHffn();

        pfce = PfceLruGet();    /* disposes of a font to make room */

        bltbc(&lf, 0, sizeof(LOGFONT));
        dyaHeight = pfcid->strFcid.hps * (czaPoint / 2);
        if (fPrint)
            {
            lf.lfHeight = -MultDiv(dyaHeight, dypPrPage, dyaPrPage);
            }
        else
            {
            /* In the Z version we have tried the idea of using a
               positive value for selection based on cell height
               rather than character height because of weirdness
               with the Courier screen font -- but it seemed to
               mess too many things up (like make all other fonts
               a bit too small and it didn't always make Courier
               work right).  I believe Win Word *is* using this
               trick but only when selecting Courier fonts.  It
               seems to me like there has got to be a different
               cause of this anamoly.  ..pault 9/22/89 */

            lf.lfHeight = -MultDiv(dyaHeight, dypLogInch, czaInch);
            if (wFcid & grpbitPsWidthFcid)
                {
// Sync Win3.0 //T-HIROYN
#ifdef JAPAN
#ifdef KKBUGFIX     //  added by Hiraisi (BUG#1980)
                lf.lfWidth = 0;
#else
                lf.lfWidth = MultDiv((wFcid & grpbitPsWidthFcid) * czaPoint,
                dxpLogInch, czaInch);
#endif
#else
                //lf.lfWidth = MultDiv((wFcid & grpbitPsWidthFcid) * czaPoint,
                  //dxpLogInch, czaInch);
                lf.lfWidth = 0;
#endif
                }
            }

        if (wFcid & bitItalicFcid)
            {
            lf.lfItalic = 1;
            }
        if (wFcid & bitUlineFcid)
            {
            lf.lfUnderline = 1;
            }
        lf.lfWeight = wFcid & bitBoldFcid ? FW_BOLD : FW_NORMAL;

        hffnSave = MpFcidHffn(pfcid);

#ifdef  JAPAN
//   When we need system font, we want rather variable pitch than fixed,
//  since fixed pitch system font is probably same as terminal font.
//   So we specify VARIABLE_PITCH especialy for system font.

{
    extern  char    szSystem[];
    extern  char    szAtSystem[];

        if( WCompSz(szSystem,(*hffnSave)->szFfn) == 0
        ||  WCompSz(szAtSystem,(*hffnSave)->szFfn) == 0  )// Add '@'systemfont
            lf.lfPitchAndFamily = (*hffnSave)->ffid | VARIABLE_PITCH ;
        else
            lf.lfPitchAndFamily
            = ((*hffnSave)->ffid) | ((wFcid & bitPrintFcid) ?
                DEFAULT_PITCH : ((wFcid & bitFixedPitchFcid) ? FIXED_PITCH :
                VARIABLE_PITCH));
}
#else
        lf.lfPitchAndFamily = ((*hffnSave)->ffid) | ((wFcid & bitPrintFcid) ?
          DEFAULT_PITCH : ((wFcid & bitFixedPitchFcid) ? FIXED_PITCH :
          VARIABLE_PITCH));
#endif

#if defined(NEWFONTENUM) && !defined(KANJI)
        lf.lfCharSet = (*hffnSave)->chs; /* pass the character set that
                                            enumfonts told us this fontname
                                            was associated with ..pault */
#else
/*T-HIROYN from 3.0 loadfont.c*/
#if defined(NEWFONTENUM) && defined(JAPAN)
        lf.lfCharSet = (*hffnSave)->chs; /* pass the character set that
                                            enumfonts told us this fontname
                                            was associated with ..pault */
#endif  /* NEWFONTENUM and JAPAN */

#endif

        ich = 0;
        if ((*hffnSave)->szFfn[0] == chGhost)
            {
            ich++;
            }
        bltszLimit(&(*hffnSave)->szFfn[ich], lf.lfFaceName, LF_FACESIZE);

#ifdef  KOREA
    if ( (*hffnSave)->szFfn[ich] > 0xA0 ||
         ( (*hffnSave)->szFfn[ich]=='@' && (*hffnSave)->szFfn[ich+1] > 0xA0 ) ||
         ( WCompSz(lf.lfFaceName,"terminal")==0 ) ||
         ( WCompSz(lf.lfFaceName,"@terminal")==0 ) ||
         ( WCompSz(lf.lfFaceName,"system")==0 ) ||
         ( WCompSz(lf.lfFaceName,"@system")==0 ) )

        lf.lfCharSet = HANGEUL_CHARSET;
#endif

#if defined(DFONT) || defined (PRDRVTEST)
        {
        char rgch[100];
        wsprintf(rgch, "Creating %s font: %s,\t\th %d, w %d, charset %d\n\r",
                 (LPSTR)(fPrint ? "prt" : "scr"), (LPSTR)lf.lfFaceName,
                 lf.lfHeight, lf.lfWidth, (int)(lf.lfCharSet));
        CommSz(rgch);

        CommSzNum("     Requested weight: ", lf.lfWeight);
        CommSzNum("     Requested italics: ", lf.lfItalic);
        CommSzNum("     Requested underline: ", lf.lfUnderline);
        CommSzNum("     Requested family: ", lf.lfPitchAndFamily >> 4);
        CommSzNum("     Requested pitch: ", lf.lfPitchAndFamily & 3);
        }
#endif /* DFONT */

#ifdef JAPAN                  //  added  11 Jun. 1992  by Hiraisi
{
    extern BOOL fPrinting;    //  Specifies printing doc.
                              //  PrintDoc function had set this flag.
    extern BOOL fWriting;     //  Specifies printing direction.
                              //  TRUE vertically  or  FALSE horizontally.
                              //  This flag had been set in the PRINT DIALOG.

        if( fPrinting && fWriting )
            fnCheckWriting( (LPLOGFONT)&lf );
}
#endif

        if ((pfce->hfont = CreateFontIndirect((LPLOGFONT)&lf)) == NULL)
            {
            pfce->hfont = GetStockObject( fPrint && vfPrinterValid ?
                                DEVICE_DEFAULT_FONT : SYSTEM_FONT );
            Assert( pfce->hfont );
            /* if the above fails, I don't know what we can do */

            WinFailure();     /* report the failure so we give the user notice
                               for weird behavior to follow */
            }

#ifdef DFONT
        CommSzNum("Font handle: ", pfce->hfont);
#endif /* DFONT */

        pfce->fcidRequest = *pfcid;
        cwAlloc = CwFromCch(CbFfn(CchSz((*hffnSave)->szFfn)));
        if (FNoHeap(hffnT = (struct FFN **)HAllocate(cwAlloc)))
            {
            FreePfce(pfce);
            return;
            }
        else
            {
            blt((*hffnSave), (*hffnT), cwAlloc);
            }
        pfce->hffn = hffnT;
        }

EstablishFont:
    if ((pfce != vpfceMru) && (pfce != vpfceMru->pfceNext))
        {
        /* make this the mru font cache entry */
        /* Only do it if pfce is not already one of the first 2 mru fonts */
        /* since we generally ask for the things in groups of 2 */

        /* pull it out of its current place */
        pfce->pfceNext->pfcePrev = pfce->pfcePrev;
        pfce->pfcePrev->pfceNext = pfce->pfceNext;

        /* insert it at mru position */
        pfce->pfceNext = vpfceMru;
        pfce->pfcePrev = vpfceMru->pfcePrev;
        pfce->pfceNext->pfcePrev = pfce;
        pfce->pfcePrev->pfceNext = pfce;
        vpfceMru = pfce;

#ifndef JAPAN  // added by Hiraisi(BUG#4645/WIN31)
#ifndef DISCARDABLE_FONTS
        /* KLUDGE ALERT: To accomodate Windows inability to make synthesized
        fonts discardable, we will now throw out the third font in the LRU chain
        if it is taller than 16 points.  (Ain't this a doozey...) */
            {
            register struct FCE *pfceThird = vpfceMru->pfceNext->pfceNext;

            if (pfceThird->fcidRequest.lFcid != fcidNil &&
#ifdef OLD
              pfceThird->fcidActual.strFcid.hps > 32)
#else
              pfceThird->fcidActual.strFcid.hps > 48)
#endif /* if-else-def OLD */
                {
                /* Free this particular font. */
                FreePfce(pfceThird);
                }
            }
#endif /* not DISCARDABLE_FONTS */
#endif // not JAPAN

        }

    if (!fTouchAndGo)
        {
        /* we have this font in our cache, but we need to select it */
        SelectWriteFont(fPrint, &pfce->hfont);

        /**
            I wish I knew why this is needed, but I don't want to spend
            more time on it.  For some reason the font width table
            (pfce->rgdxp) is getting either trashed or is simply
            incorrect when first obtained.  I suspect it is a GDI bug
            because it only happens the first time you use certain fonts
            (at least in Write) during a given session of Windows.
            The DogoneTrashTest detects the problem and fixes it.
            It is slow though, unfortunately.
            (7.25.91) v-dougk.
        **/

#ifdef DEBUG
        if (!fGetMetrics)
            DogoneTrashTest(fPrint ? vhDCPrinter : vhMDC, pfce, fPrint);
#endif

        if (fGetMetrics)
            {
            register union FCID *pfcidT = &pfce->fcidActual;
            HDC hDCMetrics = fPrint ? vhDCPrinter : vhMDC;
            TEXTMETRIC tm;

            Assert(hDCMetrics);
            if (hDCMetrics == NULL)
                return;

            GetTextMetrics(hDCMetrics, (LPTEXTMETRIC)&tm);
            if (fNewFont)
                {
                /* We need all of the metrics for this guy. */
                CHAR szFace[LF_FACESIZE];
                int wFcid;
                int dypHeight;
                int dxpch;

#if defined(DFONT) || defined(PRDRVTEST)
                {
                char rgch[100];
                GetTextFace(hDCMetrics, LF_FACESIZE, (LPSTR)szFace);
                wsprintf(rgch, "     Actual fname: %s,\t\th %d, w %d, charset %d\n\r",
                         (LPSTR)szFace, tm.tmHeight-tm.tmInternalLeading,
                         tm.tmAveCharWidth, (int)(tm.tmCharSet));
                CommSz(rgch);
                }
                CommSzNum("     Actual width: ", tm.tmAveCharWidth);
                CommSzNum("     Actual leading: ", tm.tmInternalLeading +
                  tm.tmExternalLeading);
                CommSzNum("     Actual weight: ", tm.tmWeight);
                CommSzNum("     Actual italics: ", tm.tmItalic);
                CommSzNum("     Actual underline: ", tm.tmUnderlined);
                CommSzNum("     Actual font family: ", tm.tmPitchAndFamily >>
                  4);
                CommSzNum("     Actual pitch: ", tm.tmPitchAndFamily & 1);
#endif /* DFONT */

                SetTextJustification(hDCMetrics, 0, 0);
                pfce->fmi.dxpOverhang = tm.tmOverhang;
#if defined(KOREA)
                if ((tm.tmPitchAndFamily & 1) == 0)
                     pfce->fmi.dxpSpace = tm.tmAveCharWidth;
                else
#endif
                pfce->fmi.dxpSpace = LOWORD(GetTextExtent(hDCMetrics,
                  (LPSTR)" ", 1)) - tm.tmOverhang;
#ifdef PRDRVTEST
                {
                /* Just so no printers or printer driver manufacturers
                   get funky on us!  ..pault */
                int dxpSpace = pfce->fmi.dxpSpace + tm.tmOverhang;

                CommSzNum("    GetTextExtent(space) ", LOWORD(GetTextExtent(hDCMetrics, (LPSTR)" ", 1)));
                if (dxpSpace < 1 || dxpSpace > tm.tmMaxCharWidth+tm.tmOverhang)
                    {
                    pfce->fmi.dxpSpace = tm.tmAveCharWidth;
                    CommSzNum("    ...resetting to ",pfce->fmi.dxpSpace);
                    }
                }
#endif
                pfce->fmi.dypAscent = tm.tmAscent;
                pfce->fmi.dypDescent = tm.tmDescent;
                pfce->fmi.dypBaseline = tm.tmAscent;
                pfce->fmi.dypLeading = tm.tmExternalLeading;
#ifdef DBCS
                pfce->fmi.dypIntLeading = tm.tmInternalLeading;
//#ifdef  KOREA
//        if (tm.tmPitchAndFamily & 1) /* Is variable pitch ? */
//                        pfce->fmi.dxpDBCS = dxpNil;
//        else
//#endif
                {
#if defined(TAIWAN) || defined(KOREA) || defined(PRC) //fix Italic display error, for Bug# 3362, MSTC - pisuih, 3/4/93
                CHAR    rgchT[cchDBCS << 1];
                int     dxpOverhang;
#else
                CHAR rgchT[cchDBCS];
#endif //TAIWAN
                int  dxpDBCS;

                rgchT[0] = rgchT[1] = bKanji1Min;

                dxpDBCS = LOWORD(GetTextExtent(hDCMetrics,
                                                (LPSTR) rgchT, cchDBCS));

#if defined(TAIWAN) || defined(KOREA) || defined(PRC) //fix Italic display error, for Bug# 3362, MSTC - pisuih, 3/4/93
                rgchT[2] = rgchT[3] = bKanji1Min;
                dxpOverhang = (dxpDBCS << 1) - LOWORD( GetTextExtent(
                  hDCMetrics, (LPSTR) rgchT, cchDBCS << 1 ));

               //for compatible with SBCS's overhang
               dxpDBCS += (pfce->fmi.dxpOverhang - dxpOverhang);
#endif //TAIWAN

                pfce->fmi.dxpDBCS =
#if defined(JAPAN) || defined(KOREA) || defined(PRC)       //Win3.1 BYTE-->WORD
                pfce->fmi.dxpDBCS =
                    (WORD) ((0 <= dxpDBCS && dxpDBCS < dxpNil) ? dxpDBCS : dxpNil);
#elif TAIWAN        //Win3.1 BYTE-->WORD
                pfce->fmi.dxpDBCS =
                    (WORD) ((0 <= dxpDBCS && dxpDBCS < dxpNil) ? dxpDBCS : dxpNil);
#else
                pfce->fmi.dxpDBCS =
                    (BYTE) ((0 <= dxpDBCS && dxpDBCS < dxpNil) ? dxpDBCS : dxpNil);
#endif
                }
#endif

#ifdef SMFONT
                FillWidthTable(hDCMetrics, pfce->rgdxp, &tm);
#ifdef DEBUG
                if (DogoneTrashTest(hDCMetrics, pfce, fPrint))
                    OutputDebugString("That was an immediate check\n\r");
#endif

#else /* not SMFONT */
                /* Fill the width table.  If this is a fixed font and the width
                fits in a byte, then go ahead and fill the width table with the
                width; otherwise, put dxpNil in the table. */
                dxpch = (tm.tmPitchAndFamily & 1 || tm.tmAveCharWidth >= dxpNil)
                  ? dxpNil : tm.tmAveCharWidth;
                bltc(pfce->rgdxp, dxpch, chFmiMax - chFmiMin);
#endif /* SMFONT */

                if ((*hffnSave)->ffid == FF_DONTCARE && (tm.tmPitchAndFamily &
                  grpbitFamily) != FF_DONTCARE)
                    {
                    /* Hey! maybe we've discovered a family for this orphan
                    font? */
                    GetTextFace(hDCMetrics, LF_FACESIZE, (LPSTR)szFace);
                    if (WCompSz((*hffnSave)->szFfn, szFace) == 0)
                        {
                        /* name matches - jam family in */
                        (*hffnSave)->ffid = tm.tmPitchAndFamily & grpbitFamily;
                        }
                    }

                /* jam back the properties we found */
                dypHeight = tm.tmHeight - tm.tmInternalLeading;
                if (fPrint)
                    {
                    /* Save the height of this font. */
                    pfcidT->strFcid.hps = umin((MultDiv(dypHeight, dyaPrPage,
                      dypPrPage) + (czaPoint / 4)) / (czaPoint / 2), 0xff);

#ifdef APLLW
                    /* Save the width of this font if it is a fixed pitch
                       device font. */
                    wFcid = ((tm.tmPitchAndFamily & 0x09) == 0x08) ?
#else
                    /* Save the width of this font if it is a device font. */
#ifdef  KOREA   /* give width info for all (like excel) to select DuBae shape */
            wFcid = (1==1) ?
#else
                    wFcid = (tm.tmPitchAndFamily & 0x08) ?
#endif

#endif /* if-else-def APLLW */
                      umin((MultDiv(tm.tmAveCharWidth, dxaPrPage, dxpPrPage) +
                      (czaPoint / 2)) / czaPoint, psWidthMax) : 0;
                    wFcid |= bitPrintFcid;
                    }
                else
                    {
                    pfcidT->strFcid.hps = umin((MultDiv(dypHeight, czaInch,
                      dypLogInch) + (czaPoint / 4)) / (czaPoint / 2), 0xff);
                    wFcid = 0;
                    }

                if (tm.tmWeight > (FW_NORMAL + FW_BOLD) / 2)
                    {
                    wFcid |= bitBoldFcid;
                    }

                if (tm.tmItalic)
                    {
                    wFcid |= bitItalicFcid;
                    }

                if (tm.tmUnderlined)
                    {
                    wFcid |= bitUlineFcid;
                    }

                if ((tm.tmPitchAndFamily & bitPitch) == 0)
                    {
                    wFcid |= bitFixedPitchFcid;
                    }

                pfcidT->strFcid.wFcid = wFcid;
                }

            /* Set the document and the font code. */
            pfcidT->strFcid.doc = pfce->fcidRequest.strFcid.doc;
            if (fPrint)
                {
                CHAR rgb[ibFfnMax];
                struct FFN *pffn = (struct FFN *)&rgb[0];

                /* Get the font code for this font. */
                GetTextFace(vhDCPrinter, LF_FACESIZE, (LPSTR)pffn->szFfn);
                if (WCompSz(pffn->szFfn, (*pfce->hffn)->szFfn) == 0)
                    {
                    /* The face name is the same as what we requested; so, the
                    font code should be the same. */
                    pfcidT->strFcid.ftc = pfce->fcidRequest.strFcid.ftc;
                    }
                else
                    {
                    /* Well, we've got to go hunting for the font code. */
                    int ftc;

                    pffn->ffid = tm.tmPitchAndFamily & grpbitFamily;
#ifdef NEWFONTENUM
                    pffn->chs = tm.tmCharSet;
#endif
                    ftc = FtcScanDocFfn(pfcidT->strFcid.doc, pffn);
                    if (ftc == ftcNil)
                        {
                        /* Make the first character of the face name a sentinal
                        to mark that this font was not requested by the user. */
                        bltszLimit(pffn->szFfn, &pffn->szFfn[1], LF_FACESIZE);
                        pffn->szFfn[0] = chGhost;
                        ftc = FtcChkDocFfn(pfcidT->strFcid.doc, pffn);
                        }
                    pfcidT->strFcid.ftc = ftc;
                    }
                }
            else
                {
                pfcidT->strFcid.ftc = pfce->fcidRequest.strFcid.ftc;
                }
            }

        if (fPrint)
            {
            vpfcePrint = pfce;
            vfcidPrint = pfce->fcidRequest;
            bltbyte(&pfce->fmi, &vfmiPrint, sizeof(struct FMI));
            }
        else
            {
            vpfceScreen = pfce;
            vfcidScreen = pfce->fcidRequest;
            bltbyte(&pfce->fmi, &vfmiScreen, sizeof(struct FMI));
            }
        }

    if (pfce->fcidRequest.lFcid != pfce->fcidActual.lFcid)
        {
        /* all's not as we asked for - feed properties back to caller */
        pfcid->lFcid = pfce->fcidActual.lFcid;
        if (pchp != NULL)
            { /* JamChpFcid(pchp, pfcid) bring in line for speed */
            register struct CHP *pchpT = pchp;
            int wFcid = pfcid->strFcid.wFcid;

            pchpT->ftc = pfcid->strFcid.ftc;
            pchpT->hps = pfcid->strFcid.hps;
            pchpT->psWidth = wFcid & grpbitPsWidthFcid;

            pchpT->fBold = pchpT->fItalic = pchpT->fUline = pchpT->fFixedPitch =
              FALSE;

            if (wFcid & bitBoldFcid)
                {
                pchpT->fBold = TRUE;
                }
            if (wFcid & bitItalicFcid)
                {
                pchpT->fItalic = TRUE;
                }
            if (wFcid & bitUlineFcid)
                {
                pchpT->fUline = TRUE;
                }
            if (wFcid & bitFixedPitchFcid)
                {
                pchpT->fFixedPitch = TRUE;
                }
            }
        }
    }


void NEAR SelectWriteFont(fPrint, phfont)
int fPrint;
HFONT *phfont;
    {
    extern HWND hParentWw;
    extern int wwMac;
    extern struct WWD rgwwd[];

    if (fPrint)
        {

#ifdef DFONT
        CommSzNum("Selecting printer font: ", *phfont);
#endif /* DFONT */

        /* The printer DC should be valid. */
        if (vhDCPrinter == NULL)
            {
/* This case can occur from ResetFont when closing */
            return;
            }
        else
            {
            /* Establish the font with the printer DC. */
            if (SelectObject(vhDCPrinter, *phfont) == NULL)
                {
                if (SelectObject(vhDCPrinter, GetStockObject(vfPrinterValid ?
                        DEVICE_DEFAULT_FONT : SYSTEM_FONT)) == NULL)
                    {
                    if (vfPrinterValid)
                        {
                        /* This is a real printer DC; delete it. */
                        DeleteDC(vhDCPrinter);
                        }
                    else
                        {
                        /* This is really the screen DC; it must be released. */
                        ReleaseDC(hParentWw, vhDCPrinter);
                        }
                    vhDCPrinter = NULL;
                    }
                WinFailure();
                if (vhDCPrinter == NULL)
                    {
                    GetPrinterDC(FALSE);
                    }
                return;
                }
            }
        }
    else
        {
        /* Establish it with screen and memory DC's. */
        register int ww;
        register struct WWD *pwwd;

#ifdef DFONT
        CommSzNum("Selecting screen font: ", *phfont);
#endif /* DFONT */

        /* The current memory DC had best be active. */
        if (vhMDC == NULL)
            {
/* this case occurs from ResetFont when Write is closed */
            return;
            }
        else
            {
            /* Select the font into the memory DC. */
            if (SelectObject(vhMDC, *phfont) == NULL)
                {

                Assert(*phfont != GetStockObject(SYSTEM_FONT));
                *phfont = GetStockObject(SYSTEM_FONT);
                Assert( *phfont );
#ifdef DEBUG
                Assert( SelectObject( vhMDC, *phfont ) );
#else /* not DEBUG */
                SelectObject(vhMDC, *phfont );
#endif /* not DEBUG */

                WinFailure();
                }
            }

        /* Select the font into all of the window DC's. */
        for (ww = 0, pwwd = &rgwwd[0]; ww < wwMac; ww++, pwwd++)
            {
            if (pwwd->hDC != NULL)
                {
                if (SelectObject(pwwd->hDC, *phfont) == NULL)
                    {
                    HFONT hSysFont = GetStockObject(SYSTEM_FONT);
                    int wwT;
                    struct WWD *pwwdT;

#ifdef DEBUG
                    Assert(*phfont != hSysFont);
                    Assert(SelectObject(vhMDC, hSysFont) != NULL);
#else /* not DEBUG */
                    SelectObject(vhMDC, hSysFont);
#endif /* not DEBUG */
                    *phfont = hSysFont;

                    for (wwT = 0, pwwdT = &rgwwd[0]; wwT <= ww; wwT++, pwwdT++)
                        {
                        if (pwwdT->hDC != NULL)
                            {

#ifdef DEBUG
                            Assert(SelectObject(pwwdT->hDC, hSysFont) != NULL);
#else /* not DEBUG */
                            SelectObject(pwwdT->hDC, hSysFont);
#endif /* not DEBUG */

                            }
                        }

                    WinFailure();
                    }
                }
            }
        }
    }


ResetFont(fPrint)
BOOL fPrint;
    {
    /* This routine sets to NULL the currently selected printer or screen font,
    depending on the value of fPrint. */

    extern HFONT vhfSystem;
    HFONT hfont;

#ifdef DFONT
    CommSzSz("Resetting the ", (fPrint ? "printer font." : "screen font."));
#endif /* DEBUG */

#ifdef JAPAN   /* T-YOSHIO win 3.1 */
    hfont = GetStockObject(fPrint && vfPrinterValid ?
                                         DEVICE_DEFAULT_FONT : ANSI_VAR_FONT);
#else
    hfont = GetStockObject(fPrint && vfPrinterValid ?
                                         DEVICE_DEFAULT_FONT : SYSTEM_FONT);
#endif

    SelectWriteFont( fPrint, &hfont );
    if (fPrint)
        {
        vpfcePrint = NULL;
        vfcidPrint.lFcid = fcidNil;
        }
    else
        {
        vpfceScreen = NULL;
        vfcidScreen.lFcid = fcidNil;
        }
    }




BOOL OurGetCharWidth(hdc, chFirst, chLast, lpw)
HDC hdc;
CHAR chFirst, chLast;
LPINT lpw;
    {
    int i;
    BYTE b;

    for (i = chFirst; i <= chLast; i++)
        {
/*T-HIROYN  from 3.0 loadfont.c */
#ifdef  DBCS    /* KenjiK '90-11-26 */
    if(IsDBCSLeadByte(i))
       {
        *(lpw++) = dxpNil;
       }
    else
       {
            b = i;
            *(lpw++) = LOWORD(GetTextExtent(hdc, (LPSTR)&b, 1));
       }
        }
#else
        b = i;
        *(lpw++) = LOWORD(GetTextExtent(hdc, (LPSTR)&b, 1));
        }
#endif


    return(fTrue);
    }

#ifdef SMFONT
/* Note: we put widths in here that represent true char widths,
   not considering bold/italics Overhang.  This is because of the
   following formula for string widths:

   strwidth = overhang +
              summation [ (gettextextent_or_getcharwidth - overhang) ]

   ..pault 9/22/89 */

void NEAR FillWidthTable(hdc, rgdxp, ptm)
HDC hdc;
int rgdxp[];
TEXTMETRIC *ptm;
    {
    int rgWidth[chFmiMax - chFmiMin];
    if ((ptm->tmPitchAndFamily & 1) == 0)
        {
#ifdef PRDRVTEST
        CommSzNum("  * Fixed pitch font! tmAveCharWidth==",ptm->tmMaxCharWidth);
#endif
#if defined(DBCS) && !defined(KOREA)                /* was in JAPAN */
        bltc(rgdxp, (WORD)dxpNil, chFmiMax - chFmiMin);
#else
        bltc(rgdxp, (WORD)ptm->tmAveCharWidth, chFmiMax - chFmiMin);
#endif
        }

    /* Attempt to get the width table from the DC. */
    else
    {
        int *pdxpMax = &rgdxp[chFmiMax - chFmiMin];
        register int *pWidth;
        register int *pdxp;
        int dxpOverhang = ptm->tmOverhang;

#ifdef  DBCS    /* was in JAPAN; KenjiK '90-11-26 */
//92.10.26 T-HIROYN
//Win3.1J    if(OurGetCharWidth(hdc, chFmiMin, chFmiMax - 1, (LPINT)rgWidth))
        if( (GetDeviceCaps(hdc, DRIVERVERSION) > 0x300) ?
             GetCharWidth(hdc, chFmiMin, chFmiMax - 1, (LPINT)rgWidth) :
             OurGetCharWidth(hdc, chFmiMin, chFmiMax - 1, (LPINT)rgWidth) )
#else
        if (GetCharWidth(hdc, chFmiMin, chFmiMax - 1, (LPINT)rgWidth))
#endif

        {
#if defined(JAPAN) || defined(KOREA)        //  added by Hiraisi (BUG#2690)
            int ch = chFmiMin;
#endif

#ifdef PRDRVTEST
            CommSz("  * GetCharWidth() supported\n\r");
#endif

            /* Remove the overhang factor from individual char widths
            (see formula for widths of character strings above) */
            for (pWidth = &rgWidth[0], pdxp = &rgdxp[0];
                    pdxp != pdxpMax; pWidth++, pdxp++)
                {
#ifdef  DBCS        /* was in JAPAN */
#if defined(JAPAN) || defined(KOREA)        //  added by Hiraisi (BUG#2690)
                if(!IsDBCSLeadByte(ch++))
                {
#endif
                   if(*pWidth == dxpNil)
/*T-HIROYN            *pdxp = (CHAR)dxpNil;*/
                      *pdxp = dxpNil;
                   else
                      *pdxp = (*pWidth - dxpOverhang);
#if defined(JAPAN) || defined(KOREA)        //  added by Hiraisi (BUG#2690)
                }
                else
                   *pdxp = dxpNil;
#endif
#else
                *pdxp = (*pWidth - dxpOverhang);
#endif
                }
        }
        else
        {
            /* There is no easy way, put dxpNil in the table.  It looks like each
            char has a bogus width but FormatLine will make individual calls to
            GetTextExtent() and replace the dxpNil on an as-needed basis ..pault */

#ifdef PRDRVTEST
            CommSz("  * GetCharWidth() not supported!\n\r");
#endif
            bltc(rgdxp, (WORD)dxpNil, chFmiMax - chFmiMin);
        }
    }

#ifdef PRDRVTEST
/* Take a quick look through to see if this printer is returning any
   char widths that seem odd -- report those!  This should
   end my searching for WRITE problems which are really caused by bad
   printer-driver return values! */
    {
    BOOL fReported = fFalse;
    int rgch[cchMaxSz];
    int i,w;
    BYTE b;
    for (i = chFmiMin; i < chFmiMax; i++)
        {
        b = i;
        w = LOWORD(GetTextExtent(hdc, (LPSTR)&b, 1));
        if (w < 1)
            {
            wsprintf(rgch,"    GetTextExtent(ascii %d) return value %d is invalid\n\r",b,(int)w);
            CommSz(rgch);
            if (!fReported)
                {
                CommSz("");
                fReported = fTrue;
                }
            }
        else if (w > (ptm->tmMaxCharWidth + ptm->tmOverhang))
            {
            wsprintf(rgch,"    GetTextExtent(ascii %d) return value %d exceeds tmMaxCharWidth %d\n\r",
                    b,(int)w,(int)(ptm->tmMaxCharWidth + ptm->tmOverhang));
            CommSz(rgch);
            if (!fReported)
                {
                CommSz("");
                fReported = fTrue;
                }
            }
        else if ((rgdxp[i] != dxpNil) && (rgdxp[i] > (ptm->tmMaxCharWidth + ptm->tmOverhang)))
            {
            wsprintf(rgch,"    GetCharWidth(ascii %d) return value %d questionable, exceeds tmMaxCW %d\n\r",
                    b, (int)(rgdxp[i]), (int)(ptm->tmMaxCharWidth + ptm->tmOverhang));
            CommSz(rgch);
            if (!fReported)
                {
                CommSz("");
                fReported = fTrue;
                }
            }
        }
    }
#endif /* PRDRVTEST */

    }
#endif /* SMFONT */

#ifdef DEBUG
BOOL NEAR DogoneTrashTest(HDC hdc, struct FCE *pfce, BOOL fPrint)
{
#if 1
    int i,width;
    int *pdxpMax = pfce->rgdxp + chFmiMax - chFmiMin;
    int dxpOverhang = pfce->fmi.dxpOverhang;
    register int *rgdxp;
    int rgdxpNew[chFmiMax - chFmiMin];
    register int *dxpNew;

    return 0;
    for (i=chFmiMin,
         rgdxp = pfce->rgdxp;
         i < chFmiMax; rgdxp++, ++i)
    {
        width = LOWORD(GetTextExtent(hdc,&i,1));
        if (*rgdxp != (width - dxpOverhang))
        {
#ifdef DEBUG
            {
            char msg[120];
            wsprintf(msg,"widths have changed!  Getting new width. (%s)\n\r",
                (LPSTR)(fPrint ? "PrinterDc" : "ScreenDC"));
            OutputDebugString(msg);
            }
#endif
            GetCharWidth(hdc, chFmiMin, chFmiMax - 1, (LPINT)rgdxpNew);
            for (dxpNew = rgdxpNew,
                    rgdxp = pfce->rgdxp;
                    rgdxp != pdxpMax; dxpNew++, rgdxp++)
                    *rgdxp = (*dxpNew - dxpOverhang);
            return TRUE;
        }
    }
#else
    int rgdxpNew[chFmiMax - chFmiMin];
    int *pdxpMax = pfce->rgdxp + chFmiMax - chFmiMin;
    int dxpOverhang = pfce->fmi.dxpOverhang;
    register int *dxpNew;
    register int *rgdxp;
    if (GetCharWidth(hdc, chFmiMin, chFmiMax - 1, (LPINT)rgdxpNew))
    {
        /* Remove the overhang factor from individual char widths
        (see formula for widths of character strings above) */
        for (dxpNew = rgdxpNew,
             rgdxp = pfce->rgdxp;
             rgdxp != pdxpMax; dxpNew++, rgdxp++)
        {
            if (*rgdxp != (*dxpNew - dxpOverhang))
            {
#ifdef DEBUG
                {
                char msg[120];
                wsprintf(msg,"widths have changed!  Getting new width. (%s)\n\r",
                    (LPSTR)(fPrint ? "PrinterDc" : "ScreenDC"));
                OutputDebugString(msg);
                }
#endif
                for (dxpNew = rgdxpNew,
                     rgdxp = pfce->rgdxp;
                     rgdxp != pdxpMax; dxpNew++, rgdxp++)
                        *rgdxp = (*dxpNew - dxpOverhang);
                return TRUE;
            }
        }
    }
#endif
return FALSE;
}
#endif

#ifdef JAPAN                  //  added  11 Jun. 1992  by Hiraisi

int FAR PASCAL _export fnFontHook( lf, tm, nType, lpData )
LPLOGFONT lf;
LPTEXTMETRIC tm;
short nType;
LPSTR lpData;
{
    if( lf->lfFaceName[0] == '@' &&
        lf->lfEscapement == 0 ){        /* @facename is found */
        return( FALSE );
    }

    return( TRUE );
}

void fnCheckWriting( LPLOGFONT lf )
{
    extern HANDLE hMmwModInstance;
    FARPROC lpfnFontHook;
    char cFaceName[LF_FACESIZE+1] = "@";

    lstrcat( (LPSTR)cFaceName, lf->lfFaceName );
    lpfnFontHook = MakeProcInstance(fnFontHook, hMmwModInstance);
    if( !EnumFonts( vhDCPrinter, cFaceName, lpfnFontHook, NULL ) )
        lstrcpy( (LPSTR)lf->lfFaceName, (LPSTR)cFaceName );
    FreeProcInstance( lpfnFontHook );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\loadfnt2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* loadfnt2.c - MW font support code */

#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOSYSMETRICS
#define NOMENUS
#define NOWINSTYLES
#define NOCTLMGR
#define NOCLIPBOARD
#include <windows.h>

#include "mw.h"
#include "macro.h"
#define NOUAC
#include "cmddefs.h"
#include "fontdefs.h"
#include "docdefs.h"


extern int vifceMac;
extern union FCID vfcidScreen;
extern union FCID vfcidPrint;
extern struct FCE rgfce[ifceMax];
extern struct FCE *vpfceMru;
extern struct FCE *vpfceScreen;
extern struct FCE *vpfcePrint;
extern struct DOD (**hpdocdod)[];


struct FCE * (PfceLruGet(void));
struct FCE * (PfceFcidScan(union FCID *));


struct FCE * (PfceLruGet())
/* tosses out the LRU cache entry's information */

    {
    struct FCE *pfce;

    pfce = vpfceMru->pfcePrev;
    FreePfce(pfce);
    return(pfce);
    }


FreePfce(pfce)
/* frees the font objects for this cache entry */
struct FCE *pfce;

    {
    int ifce;
    HFONT hfont;

    if (pfce->fcidRequest.lFcid != fcidNil)
	{
	hfont = pfce->hfont;

	/* see if we're about to toss the screen or printer's current font */
	if (pfce == vpfceScreen)
	    {
	    ResetFont(FALSE);
	    }
	else if (pfce == vpfcePrint)
	    {
	    ResetFont(TRUE);
	    }

#ifdef DFONT
	CommSzNum("Deleting font: ", hfont);
#endif /* DFONT */

	if (hfont != NULL)
	    {
            DeleteObject(hfont);
	    pfce->hfont = NULL;
	    }

	if (pfce->hffn != 0)
	    {
	    FreeH(pfce->hffn);
	    }

	pfce->fcidRequest.lFcid = fcidNil;
	}
    }


FreeFonts(fScreen, fPrinter)
/* frees up the font objects for the screen, and the printer */

int fScreen, fPrinter;
    {
    int ifce, bit;

    for (ifce = 0; ifce < vifceMac; ifce++)
	{
	bit = (rgfce[ifce].fcidRequest.strFcid.wFcid & bitPrintFcid) != 0;
	if (bit && fPrinter || !bit && fScreen)
	    FreePfce(&rgfce[ifce]);
	}
    }


struct FCE * (PfceFcidScan(pfcid))
union FCID *pfcid;

/* look for this font the "hard way" in the LRU list */
    {
    struct FFN **hffn, **hffnT;
    register struct FCE *pfce;
    struct FFN **MpFcidHffn();

    hffn = MpFcidHffn(pfcid);
    pfce = vpfceMru;
    do
	{
	hffnT = pfce->hffn;
	if (hffnT != NULL)
	    if (WCompSz((*hffn)->szFfn, (*hffnT)->szFfn) == 0 &&
	      pfcid->strFcid.hps == pfce->fcidRequest.strFcid.hps &&
	      pfcid->strFcid.wFcid == pfce->fcidRequest.strFcid.wFcid)
		{
		pfce->fcidRequest.strFcid.doc = pfcid->strFcid.doc;
		pfce->fcidRequest.strFcid.ftc = pfcid->strFcid.ftc;
		return(pfce);
		}
	pfce = pfce->pfceNext;
	}
    while (pfce != vpfceMru);

    return(NULL);
    }



struct FFN **MpFcidHffn(pfcid)
/* makes sure we use a font code that exists in the table - this is insurance
   against out of memory problems */

union FCID *pfcid;
    {
    int ftc;
    struct FFNTB **hffntb;

    ftc = pfcid->strFcid.ftc;
    hffntb = HffntbGet(pfcid->strFcid.doc);
    if (ftc >= (*hffntb)->iffnMac)
	ftc = 0;

    return((*hffntb)->mpftchffn[ftc]);
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\mainloop.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* MainLoop.c -- WRITE's main message loop */

#define NOGDICAPMASKS
//#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOOPENFILE
#define NOPEN
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#define NOFONT
#define NOGDI
#define NOBRUSH
#define NOATOM
#define NOSCROLL
#define NOCOLOR
#include <windows.h>

#define NOUAC
#include "mw.h"
#include "cmddefs.h"
#include "ch.h"
#include "docdefs.h"
#include "fmtdefs.h"
#include "dispdefs.h"
#include "printdef.h"
#include "wwdefs.h"
#include "propdefs.h"
#include "filedefs.h"
#define NOSTRUNDO
#define NOSTRERRORS
#include "str.h"
#include "preload.h"


extern CHAR		(*rgbp)[cbSector];
extern CHAR		*rgibpHash;
extern struct BPS	*mpibpbps;
extern int		ibpMax;
extern int		iibpHashMax;
extern struct DOD	(**hpdocdod)[];
extern int		docCur;
extern int		visedCache;
extern typeCP		cpMinDocument;
extern struct WWD	rgwwd[];
extern int		wwCur;
extern struct FLI	vfli;
extern struct WWD	*pwwdCur;
extern int		docMode;
extern CHAR		stMode[];
extern int		isedMode;
extern int		vdocPageCache;
extern typeCP		vcpMinPageCache;
extern typeCP		vcpMacPageCache;
extern int		vipgd;
extern int		vfInsLast;
extern struct SEP	vsepAbs;
extern struct DOD	(**hpdocdod)[];
extern int		vfSelHidden;
extern struct SEL	selCur;
extern int		vfAwfulNoise;
extern HWND		vhWndPageInfo;
extern int		vfSeeSel;
extern int		vipgd;
extern int		vfInsEnd;   /* Is insert point at end-of-line? */
extern int		vfModeIsFootnote;   /*	true when szMode contains string "Footnote" */
/* used by ShowMode */
extern int		docMode;
static int		isedMode = iNil;
static int		ipgdMode = iNil;
extern CHAR		szMode[];
extern HCURSOR		vhcIBeam;
#ifdef DBCS
extern int		donteat;	/* disp.c : if TRUE vmsgLast has msg */
#endif
static int		vfSizeMode = false;
int vcCount = 1; /* count to be decremented until 0 before trying to grow rgbp */





NEAR FNeedToGrowRgbp(void);



MainLoop()
{
    extern int vfIconic;
    extern int vfDead;
    extern int vfDeactByOtherApp;
    extern MSG vmsgLast;
    extern int vfDiskFull;
    extern int ferror;
    extern HWND hParentWw;
    extern HANDLE   vhAccel; /* handle to accelerator table */
    extern HWND vhDlgFind, vhDlgRunningHead, vhDlgChange;

    while (TRUE)
	{
	if (!vfDeactByOtherApp && !vfIconic && !vfDead &&
	  !FImportantMsgPresent())
	    {	/* Neither an icon nor a dying ember -- perform background
		   tasks like screen update, showing selection, etc. */
	    Idle();
	    }

	/* We are done Idling or there's a message waiting for us */
#ifdef DBCS
	if ( donteat ) {
	    /* We have already get message */
	    donteat = FALSE;
	    }
	else {
	    if (!GetMessage( (LPMSG)&vmsgLast, NULL, 0, 0 ))
	        {
	        /* Terminating the app; return from WinMain */
LTerm:
	        break;
	        }
	}
#else
	if (!GetMessage( (LPMSG)&vmsgLast, NULL, 0, 0 ))
	    {
	    /* Terminating the app; return from WinMain */
LTerm:
	    break;
	    }
#endif

	/* Reset disk full error flag */
	vfDiskFull = false;
	ferror = false;

#if WINVER >= 0x300    
    if (hParentWw == NULL)
        /* Odd shut-down condition where we've hParentWw has been 
           invalidated without our genuine knowledge and thus RIP's */
        goto LTerm; 
#endif

	/* Handle modeless dialog box messages thru IsDialogMessage. */
	if (
         !(vhDlgFind        != NULL && IsDialogMessage(vhDlgFind,       &vmsgLast))
	  && !(vhDlgChange      != NULL && IsDialogMessage(vhDlgChange,     &vmsgLast)) 
      && !(vhDlgRunningHead != NULL && IsDialogMessage(vhDlgRunningHead,&vmsgLast)) 
      && !(TranslateAccelerator(hParentWw, vhAccel, &vmsgLast))
       )
	    {
	    int kc;

	    /* Even if we process the toggle key, still want to translate it */
	    if (FCheckToggleKeyMessage( &vmsgLast ))
		{
		goto Translate;
		}

	    if ( ((kc = KcAlphaKeyMessage( &vmsgLast )) != kcNil) &&
		 (kc != kcAlphaVirtual) )
		{
#ifdef CYCLESTOBURN
		PreloadCodeTsk( tskInsert );
#endif
		AlphaMode( kc );
		}
	    else if (!FNonAlphaKeyMessage( &vmsgLast, TRUE ))
		{
Translate:
		TranslateMessage( (LPMSG)&vmsgLast);
		DispatchMessage((LPMSG)&vmsgLast);
		}
	    }
	}   /* end while (TRUE) */
}


/* I D L E */
#ifdef DEBUG
int vfValidateCode;
#endif

Idle()
{     /* Idle routine -- do background processing things */
    extern int vfOutOfMemory;
    extern int ibpMaxFloat;
    extern int vfLargeSys;
    extern int vfDeactByOtherApp;
    typeCP cpEdge;
    int cdr;

#ifdef DEBUG
    extern int fIbpCheck;
    extern int fPctbCheck;
    int fIbpT=fIbpCheck;
    int fPctbT=fPctbCheck;

    fIbpT = fIbpCheck;
    fPctbT = fPctbCheck;
    fPctbCheck = fIbpCheck = TRUE;
    CheckIbp();
    CheckPctb();
    fIbpCheck = fIbpT;
    fPctbCheck = fPctbT;
#endif

    vfAwfulNoise = false; /* Re-enable beep */

    /* Here is where we attempt to recognize that we have
       regained memory and are no longer in an error state */
    if (vfOutOfMemory)
	{
	extern int vfMemMsgReported;

	if (FStillOutOfMemory())
	    {
	    return;
	    }
	else
	    {
	    /* Hooray! We recovered from out-of-memory */
	    vfOutOfMemory = vfMemMsgReported = FALSE;
	    }
	if (FImportantMsgPresent())
	    return;
	}

    /* Make sure we repaint what Windows considers to be invalid */
    UpdateInvalid();
    UpdateDisplay(true);
    if (wwdCurrentDoc.fDirty)
	    /* Update was interrupted */
	return;

    Assert( wwCur >= 0 );

    {
    extern int vfSeeEdgeSel;
    int dlMac = pwwdCur->dlMac;
    struct EDL *pedl = &(**(pwwdCur->hdndl))[dlMac - 1];

    cpEdge = CpEdge();

    if ( vfSeeSel &&
	    (vfSeeEdgeSel || (selCur.cpFirst == selCur.cpLim) ||
	    (selCur.cpLim <= pwwdCur->cpFirst) ||
	    (selCur.cpFirst >= pedl->cpMin + pedl->dcpMac)) )
	{
	extern int vfInsEnd;

	if (vfInsEnd)
		/* Adjust for insert point at end of line */
	    cpEdge--;
   cpEdge = max(0, cpEdge);    /* make sure cpEdge is at least 0 */

	if (selCur.cpFirst == selCur.cpLim)
	    ClearInsertLine();
	PutCpInWwHz(cpEdge);
	if (FImportantMsgPresent())
	    return;
	}
    vfSeeSel = vfInsLast = vfSeeEdgeSel = false;


#ifdef DEBUG
    if (vfValidateCode)
	ValidateCodeSegments(); /* Special kernel call to test checksums */
#endif

    if (vfSelHidden && !vfDeactByOtherApp)
	{ /* Turn on selection highlight */
	vfInsEnd = selCur.fEndOfLine;
	vfSelHidden = false;
	ToggleSel(selCur.cpFirst, selCur.cpLim, true);
	if (FImportantMsgPresent())
	    return;
	}

    if (!vfSizeMode)
	{
	CheckMode();
	if (FImportantMsgPresent())
	    return;
	}
    }

#define cbpIncr 5

    if (--vcCount == 0)
	{
#ifdef DEBUG
	dummy();    /* So Chi-Chuen can set a breakpoint here */
#endif
	UnlockData(0);
	if ( GlobalCompact((DWORD)0) >= (DWORD)LCBAVAIL )
	    {
	    vfLargeSys = TRUE;
	    ibpMaxFloat = 255; /* about 32K for rgbp */
	    }
	else
	    {
	    vfLargeSys = FALSE;
	    ibpMaxFloat = 75; /* about 10K for rgbp */
	    }
	LockData(0);
	/* after adjustment, ibpMaxFloat may be smaller than current ibpMax
	   but we will not grow rgbp anymore and rgbp will be reduced eventually
	   when we need more heap space */
	if ( ibpMax < ibpMaxFloat && FNeedToGrowRgbp() )
	    if (!FGrowRgbp(cbpIncr))
		FGrowRgbp(1);
	if (FImportantMsgPresent())
	    return;
	}

    CloseEveryRfn( FALSE ); /* Close files on removable media */

#ifdef CYCLESTOBURN
    if (vfLargeSys)
	{   /* Large system, preload code for as much as possible */
	int tsk;

	for ( tsk = tskMin; tsk < tskMax; tsk++ )
	    PreloadCodeTsk( tsk );
	}
    else
	    /* Small system, preload code for insert only */
	PreloadCodeTsk( tskInsert );
#endif

    EndLongOp(vhcIBeam);
}


#ifdef DEBUG
dummy()
{
}
#endif


UpdateInvalid()
{   /* Find out what Windows considers to be the invalid range of
       the current window.  Mark it invalid in WRITE's data structures &
       blank the area on the screen */

extern HWND hParentWw;
extern long ropErase;
extern int vfDead;

RECT rc;

if ( (pwwdCur->wwptr != NULL) &&
	/* Getting the update rect for the parent is essentially the same as
	   processing any WM_ERASEBKGND messages that might be out there for the
	   parent. */
     (GetUpdateRect( hParentWw, (LPRECT) &rc, TRUE ),
     GetUpdateRect( pwwdCur->wwptr, (LPRECT) &rc, TRUE )) &&
	/* Check for vfDead is so we don't repaint after we have
	   officially closed.  Check is AFTER GetUpdateRect call so
	   we DO clear the background and validate the border */
     !vfDead )
    {
    int ypTop = rc.top;

    if (ypTop < pwwdCur->ypMin)
        {   /* Repaint area includes stripe above ypMin -- validate it,
               since erasure is the only repaint necessary */
        ypTop = pwwdCur->ypMin; /* Only invalidate below ypMin */

        /* The above is NOT ensuring that the upper 4 pixel rows
           in the text window get cleared, so we use brute force ..pault */
        PatBlt(GetDC(pwwdCur->wwptr), 0, 0, pwwdCur->xpMac, pwwdCur->ypMin, 
               ropErase);
        }

    if (ypTop < rc.bottom)
	{
	InvalBand( pwwdCur, ypTop, rc.bottom );
	}

    /* Since we have found out the invalid rect, and marked it invalid
       in our structures, we don't want to hear about it again,
       so we tell windows that we have made everything valid */
    ValidateRect( pwwdCur->wwptr, (LPRECT) NULL );
    }
}



/* C H E C K  M O D E */
CheckMode()
{
    typeCP cp;
    int pgn;
    struct PGTB **hpgtb;
    CHAR st[30];
    CHAR *pch;

#ifdef BOGUS
    /* The mode is driven off of the first cp in the window. */
    cp = pwwdCur->cpFirst;
#else /* not BOGUS */
    /* The mode is driven off of the last cp of the first line in the window. */
	{
	register struct EDL *pedl = &(**pwwdCur->hdndl)[0];

	cp = CpMax(pedl->cpMin + pedl->dcpMac - 1, cp0);
	}
#endif /* not BOGUS */

#ifdef CASHMERE
    if (cp > CpMacText(docCur)) /* in footnote and running head */
	{
	SetModeToFootnote();
	return;
	}
#endif /* CASHMERE */

    CacheSect(docCur, cp);

    /* If the doc has changed since the last time we entered, or the current cp
    is not in the last page that was cached, then cache the current page. */
    if (!(vdocPageCache == docCur && cp >= vcpMinPageCache && cp <
      vcpMacPageCache))
	{
	CachePage(docCur, cp);
	}

    /* If the current doc, ised, and ipgd have not changed then the page number
    is the same, so return. */
    if (docMode == docCur && isedMode == visedCache && ipgdMode == vipgd)
	{
	return;
	}

    /* szMode is going to be set to "Page nnn" or "Pnnn Dnnn". */
    vfModeIsFootnote = false;

    /* Record the current doc, ised and ipgd. */
    docMode = docCur;
    isedMode = visedCache;
    ipgdMode = vipgd;

    /* Retrieve the current page number. */
    hpgtb = (**hpdocdod)[docMode].hpgtb;
    pgn = (vipgd == iNil) ? ((vsepAbs.pgnStart == pgnNil) ? 1 : vsepAbs.pgnStart)
			  : (**hpgtb).rgpgd[vipgd].pgn;

#ifdef CASHMERE
    /* If the document has multiple sections and we had to set szMode to "Pnnn
    Dnnn", then return. */
    if ((isedMode != iNil) && (FSetModeForSection(pgn)))
	{
	return;
	}
#endif /* CASHMERE */

    /* Place "Page nnn" in szMode and output to mode field of window. */
#if defined(KOREA)
    pch = &szMode[0];
    *pch++ = chSpace;
    ncvtu(pgn, &pch);
    *pch++ = chSpace;
    FillStId(st, IDSTRChPage, sizeof(st));
    bltbyte(&st[1], pch, st[0]+1);
    //*pch = '\0';
#else
    FillStId(st, IDSTRChPage, sizeof(st));
    st[1] = ChUpper(st[1]);
    bltbyte(&st[1], szMode, st[0]);
    pch = &szMode[st[0]];
    *pch++ = chSpace;
    ncvtu(pgn, &pch);
    *pch = '\0';
#endif
    DrawMode();
}  /* end CheckMode */


NEAR FNeedToGrowRgbp()
{ /* return true iif page buffers are all used up */
register struct BPS *pbps;
struct BPS *pbpsMax = &mpibpbps[ibpMax];
extern int ibpMaxFloat;

vcCount = 512;

if (ibpMax + 1 > ibpMaxFloat)
    return(FALSE); /* don't even try if adding one more page will exceed limit */

for (pbps = &mpibpbps[0]; pbps < pbpsMax; pbps++)
    {
    /* any unused page? */
    if (pbps->fn == fnNil)
	{
	return(FALSE);
	}
    }
return(TRUE);
}


CachePage(doc,cp)
int	doc;
typeCP	cp;
    {
    struct PGTB **hpgtb;
    int cpgd;
    typeCP cpMacPage;

    vdocPageCache = doc;
    hpgtb = (**hpdocdod)[doc].hpgtb;

    if (hpgtb == 0 || (**hpgtb).cpgd == 0)
	{
	vcpMinPageCache = cp0;
	vcpMacPageCache = cpMax;
	vipgd = -1;
	return;
	}

	/* Get index to beginning of NEXT page */
    cpgd = (**hpgtb).cpgd;
    vipgd = IcpSearch(cp+1, &((**hpgtb).rgpgd[0]), sizeof(struct PGD),
			    bcpPGD, cpgd);
    cpMacPage = (**hpgtb).rgpgd[vipgd].cpMin;
    if (cp >= cpMacPage)
	{ /* Last page */
	vcpMinPageCache = cpMacPage;
	vcpMacPageCache = (**hpdocdod)[doc].cpMac + 1;
	}
    else
	{
	vcpMinPageCache = (vipgd == 0) ? cpMinDocument : (**hpgtb).rgpgd[vipgd - 1].cpMin;
	vcpMacPageCache = cpMacPage;
	vipgd -= 1;  /* so that ShowMode can get correct pgn */
	}
    }



#ifdef CASHMERE
/* A D D  V I S I  S P A C E S */
AddVisiSpaces(ww, pedl, dypBaseline, dypFontSize)
int ww;
struct EDL *pedl;  /* Do no heap movement in this subroutine */
int dypBaseline, dypFontSize;
	{
	/* Put a centered dot in each space character, and show all tabs */
	int ich;
	struct WWD *pwwd = &rgwwd[ww];
	int xpPos = vfli.xpLeft + xpSelBar - pwwd->xpMin;
	int ypPos;
	WORDPTR bitsDest = pwwd->wwptr + (long)STRUCIDX(portBits);
	RECT rcDest;
	int xpRightReal = vfli.xpRight - pwwd->xpMin;
	extern BITPAT patVisiTab;
	BITMAP bmap;

	ypPos = pedl->yp - dypBaseline - dypFontSize / 4;
	rcDest.bottom = ypPos + 4;
	rcDest.top = rcDest.bottom - 8;

	SetRect(&bmap.bounds, 8, 0, 16, 8);
	bmap.rowBytes = 2;
	bmap.baseAddr = MPLP(&patVisiTab);

	PenSize(1, 1);
	PenMode(patXor);

	for (ich = 0; ich < vfli.ichMac; ++ich)
		{
		switch(vfli.rgch[ich])
			{
		case chSpace:
			MoveTo(xpPos + vfli.rgdxp[ich] / 2, ypPos);
			Line(0, 0);
			break;
		case chTab:
			rcDest.left = xpPos - 1;
			rcDest.right = rcDest.left + 8;
			CopyBits(MPLP(&bmap), bitsDest, &(bmap.bounds),
				&rcDest, srcXor, 0l);
			}
		xpPos += vfli.rgdxp[ich];
		}
	}
#endif /* CASHMERE */


#ifdef ENABLE
/* F  S E T  M O D E  F O R  S E C T I O N  */
FSetModeForSection(pgn)
int pgn;  /* pgn is the current page number */
	{
	struct	SETB *psetb;
	struct	SED  *psed;
	int cch, sectn;
	CHAR *pch;

#ifdef DEBUG
	Assert(HsetbGet(docMode) != 0);
#endif /* DEBUG*/

	psetb = *HsetbGet(docMode);
	psed  = psetb->rgsed;

	/* Decide if a mode string of the form "Pnnn Dnnn" needs to be */
	/* displayed. If no, just return. If yes, derive the section # */

	if(psed->cp == CpMacText(docMode))
		return(FALSE);
	else
		{
		if (psetb->csed <= 1)
		       return(FALSE);
		sectn = isedMode + 1;
		}

	/*  Place "Pnnn Dnnn"  in stMode and output to window */
	pch = &stMode[1];
	*pch++ = chPnMode;
	ncvtu(pgn,&pch);
	*pch++ = chSpace;
	*pch++ = chDivMode;
	ncvtu(sectn,&pch);
	stMode[0] = pch - stMode - 1;
	DrawMode();
	return(TRUE);
	}
#endif /* ENABLE */


#ifdef CASHMERE
Visify(pch, pcch)
CHAR *pch;
int  *pcch;
{ /* Transform chars to "Visible font" */
CHAR *pchT = pch;
int cch = *pcch;

while (cch--)
	{
	if ((*pchT = ChVisible(*pch++)) != 0)
		pchT++;
	else
		--(*pcch);
	}
}
#endif /* CASHMERE */



#ifdef CASHMERE
int ChVisible(ch)
int ch;
{ /* Return "visible font" for ch */
switch (ch)
	{
#ifdef CRLF
case chReturn:
	return 0;  /* chNil won't fit into a byte */
#endif
case chNRHFile: return chHyphen;
case chNewLine: return chVisNewLine;
case chEol: return chVisEol;
case chTab: return chVisTab;
case chSect: return chVisSect;
default:
	return ch;
	}
}
#endif /* CASHMERE */




#ifdef CYCLESTOBURN
void PreloadCodeTsk( tsk )
int tsk;
{
switch (tsk) {

    case tskInsert:
	LoadF( IbpMakeValid );		/* FILE.C */
	LoadF( MoveLeftRight ); 	/* CURSKEYS.C */
	LoadF( CtrBackDypCtr ); 	/* SCROLLVT.C */    /* Sometimes */
	LoadF( PutCpInWwHz );		/* SCROLLHZ.C */
	LoadF( ValidateTextBlt );	/* INSERT2.C  */
	LoadF( InsertEolInsert );	/* INSERTCO.C */
	LoadF( Replace );		/* EDIT.C     */
	LoadF( AlphaMode );		/* INSERT.C   */
	break;
    case tskFormat:
	LoadF( DoPrm ); 		    /* DOPRM.C */
	LoadF( AddSprmCps );		    /* ADDPRM.C */
	LoadF( SetUndo );		    /* EDIT.C */
	LoadF( FInitFontEnum ); 	    /* FONTS.C */
	LoadF( SetAppMenu );		    /* MENU.C */
	break;
    case tskScrap:
	LoadWindowsF( SetClipboardData );   /* USER!WINCLIP */
	LoadF( Replace );		    /* EDIT.C */
	LoadF( fnCutEdit );		    /* CLIPBORD.C */
	LoadF( SetAppMenu );		    /* MENU.C */
	break;
    }
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\mergedef.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#ifdef SAND
#define ihszMax			127     /* max fields */
#else /* not SAND */
#define ihszMax			255     /* max fields */
#endif /* not SAND */

#define cchMaxMName		128     /* max field name length */
#define levNil			(-1)
#define cIncludesMax		64     /* max number of nested include files */
#define typeNumMaxOver10	(214748364L)

typedef long typeNum;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\mglobals.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* WRITE Globals */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "dispdefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "fmtdefs.h"  /* formatdefs.h */
#include "propdefs.h"
#include "fkpdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "wwdefs.h"
#include "prmdefs.h"
#include "rulerdef.h"
#include "editdefs.h"
#define NOSTRERRORS
#include "str.h"
#include "fontdefs.h"
#include "globdefs.h"   /* text for static strings */

VAL rgval [ivalMax];            /* General purpose parm-passing array */
#ifdef ENABLE
VAL rgvalAgain[ivalMax];
#endif

CHAR         vchDecimal = '?';  /* "decimal point" character
                    real value set in initwin.c */

int      vzaTabDflt = vzaTabDfltDef; /* width of default tab in twips */

/* pen windows */
VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL) = NULL;

/* page buffers stuff */
CHAR        *rgibpHash;
int     iibpHashMax;
struct BPS  *mpibpbps;
int     ibpMax;
int     ibpMaxFloat = 128;
typeTS      tsMruBps;
CHAR        (*rgbp)[cbSector];
struct ERFN dnrfn[rfnMax];
int     rfnMac;
typeTS      tsMruRfn;
int     vfBuffersDirty = FALSE;

/* doc stuff */
struct DOD  (**hpdocdod)[];
int     docCur;         /* current doc */
int     docMac;
int     docScrap;
#ifdef CASHMERE     /* No docBuffer in WRITE */
int     docBuffer;
#endif
int     docUndo;

#if defined(JAPAN) & defined(DBCS_IME) /* Doc for Insert IR_STRING from IME [yutakan]*/
int     docIRString;
#endif

int     docRulerSprm;
int     docMode = docNil;   /* doc with "Page nnn" message */
int     vpgn;           /* current page number of document */
typeCP      cpMinCur;
typeCP      cpMacCur;

/* file stuff */
struct FCB  (**hpfnfcb)[];
int     fnMac;
int     ferror;
int     errIO;          /* i/o error code */
int     versFile = 0;
int     vrefFile = 0;
int     vrefSystem = 0;

#ifdef  DBCS_VERT
CHAR        szAtSystem [] = szAtSystemDef; // for vertical-sysfont
#endif

WORD        vwDosVersion; /* Current DOS version, maj in lo 8, minor in hi */
int     vfInitializing = TRUE;  /* TRUE during inz, FALSE thereafter */
int     vfDiskFull = FALSE; /* Disk full error, fn != fnScratch */
int     vfSysFull = FALSE;  /* Disk holding fnScratch is full */
int     vfDiskError = FALSE;    /* Serious Disk Error has occurred */
int     vfLargeSys = FALSE;
int     vfMemMsgReported = FALSE;
int     vfCloseFilesInDialog = FALSE;   /* Set inside OPEN, SAVE dialog */
int     vfSizeMode;
int     vfPictSel;
int     vfPMS = FALSE;      /* Currently doing picture move/size */
int     vfnWriting = fnNil; /* fn that gets written to disk */
int     vfnSaving = fnNil;  /* Like above, but longer lifetime */
int     vibpWriting;
CHAR        (**vhrgbSave)[];    /* emergency space for save events */
struct FPRM fprmCache;      /* scratch file property modifiers */

/* global boolean flags */
int  vfTextOnlySave = FALSE; /* reset by each new/open, use by save as */
int  vfBackupSave; /* use by save as box */

#if defined(JAPAN) || defined(KOREA)
int  vfWordWrap;   /*t-Yoshio WordWrap flag*/
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25
int  vfWordWrap= 1; // always set it on
#endif

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
int  vfImeHidden;   /*T-HIROYN ImeHidden Mode flag*/
#endif

int  vfOutOfMemory = FALSE;
int  vfOvertype = FALSE; /* still using this ? */
int  vfPrintMode = FALSE; /* TRUE if format to printer mode on screen */
int  vfDraftMode = FALSE; /* TRUE if the user choose the draft mode option */
int  vfRepageConfirm = FALSE; /* repaginate confirm page break option */
int  vfVisiMode = FALSE; /* TRUE if visible char mode on */
int  vfModeIsFootnote; /* TRUE when szMode contains string "Footnote" */
int  vfNoIdle = FALSE;
int  vfDeactByOtherApp = FALSE; /* TRUE if we are deactivated by another app */
int  vfDownClick = FALSE; /* TRUE when we received a down click in our window */
int  vfCursorVisible = FALSE; /* TRUE if want to show the cursor in a mouseless
                 system */
int  vfMouseExist = FALSE; /* TRUE if mouse hardware is installed */
int  vfInLongOperation = FALSE; /* TRUE if we are still in a long operation
                   so that the cursor should stay hourglass */
int  vfScrapIsPic = FALSE; /* Whether docScrap contains picture */
BOOL fDestroyOK;

int  fGrayChar; /* TRUE if selection consists of mixed char properties */
int  fGrayPara; /* TRUE if selection consists of mixed para properties */

int  vfPrPages = FALSE; /* TRUE if print page range */
int  vpgnBegin; /* starting page number to print */
int  vpgnEnd; /* ending page number to print */
int  vcCopies = 1;       /* nubmer of copies to print */
BOOL vfPrErr = FALSE;        /* TRUE iff a printing error occurred */
BOOL vfPrDefault = TRUE;     /* TRUE iff Write chose printer */
BOOL vfWarnMargins = FALSE;  /* TRUE if we should warn user about bad margins */

/* Show that Print, Help, and Glossary processing is uninitialized */
int  vfPrintIsInit = FALSE;
int  vfHelpIsInit = FALSE;
int  vfGlyIsInit = FALSE;

int  vfInsEnd = false;   /* Is insert point at end-of-line? */
int  vfInsertOn;
int  vfMakeInsEnd;
int  vfSelAtPara;
int  vfSeeSel = FALSE;
int  vfLastCursor;       /* TRUE iff the last selection was made
                       by an Up/Down cursor key */
int  vfGotoKeyMode = FALSE;  /* Apply GOTO meta mode to next cursor
                       key */
#ifdef SAND
int  vftcDaisyPS = -1;
int  vftcDaisyNoPS = -1;
int  vfDaisyWheel = FALSE;
int  vifntApplication;
int  vifntMac;
#endif /* SAND */

#ifdef UNUSED
int  vfCanPrint;
#endif

int  vchInch;
int  vfMouse;
typeCP      vcpSelect;

#ifdef DEBUG
int  fIbpCheck = TRUE;
int  fPctbCheck = TRUE;
#ifdef CKSM
unsigned (**hpibpcksm) [];   /* Checksums for buffer page contents */
unsigned ibpCksmMax;         /* Alloc limit for cksm array */
#endif
#endif /* DEBUG */

int  vWordFmtMode = FALSE; /* used during saves. If false, no conversion is
                  done. True is convert to Word format,CVTFROMWORD
                  is translate chars from Word character set at
                  save */

/* **************************************************************** */
/* strings, predefined file names - definitions stored in globdefs.h */
/*                                                                   */
/* NOTE NOTE NOTE   Win 3.0                                          */
/*                                                                   */
/* Some of these strings have now been moved from globdefs.h         */
/* to write.rc.  This was done to easy localization.                 */
/*                                                                   */
/* **************************************************************** */

CHAR        (**hszTemp)[];
CHAR        (**hszGlosFile)[];
CHAR        (**hszXfOptions)[];
CHAR            szMode[30];              /* buffer for "Page nnn" message */

CHAR        szEmpty[] = "";
CHAR        szExtDoc[] = szExtDocDef;
CHAR        szExtWordDoc[] = szExtWordDocDef;
CHAR        szExtGls[] = szExtGlsDef;
CHAR        szExtDrv[] = szExtDrvDef;
           /* for Intl added szExtWordDoc entry */
CHAR        *mpdtyszExt [] = { szExtDoc, szExtGls, szEmpty, szEmpty,
             szEmpty, szEmpty,
             szExtWordDoc };
CHAR        szExtBackup[] = szExtBackupDef;
CHAR        szExtWordBak[] = szExtWordBakDef;
               /* WIN.INI: our app entry */
CHAR        szWriteProduct[] = szWriteProductDef;
CHAR        szFontEntry[] = szFontEntryDef;    /* WIN.INI: our font list */
CHAR            szWriteDocPrompt[25];                     /* OpenFile prompts */
CHAR            szScratchFilePrompt[25];
CHAR            szSaveFilePrompt[25];
#if defined(KOREA)  // jinwoo : 10/16/92
CHAR            szAppName[13];               /* For message box headings */
#else
CHAR            szAppName[10];               /* For message box headings */
#endif
CHAR            szUntitled[20];                  /* Unnamed doc */
CHAR        szSepName[] = szSepNameDef;  /* separator between product
                        name and file name in header */

#ifdef STYLES
CHAR        szSshtEmpty[] = szSshtEmptyDef;
#endif /* STYLES */

/* Strings for parsing the user profile. */
CHAR        szWindows[] = szWindowsDef;
CHAR        szDevice[] = szDeviceDef;
CHAR        szDevices[] = szDevicesDef;
CHAR        szBackup[] = szBackupDef;

#if defined(JAPAN) || defined(KOREA) //Win3.1J
CHAR        szWordWrap[] = szWordWrapDef;
#endif

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
CHAR        szImeHidden[] = szImeHiddenDef;
#endif

/* Strings for our window classes (MUST BE < 39 CHARS) */

CHAR        szParentClass[] = szParentClassDef;
CHAR        szDocClass[] = szDocClassDef;
CHAR        szRulerClass[] = szRulerClassDef;
CHAR        szPageInfoClass[] = szPageInfoClassDef;
#ifdef ONLINEHELP
CHAR        szHelpDocClass[] = szHelpDocClassDef;
#endif

CHAR            szWRITEText[30];
CHAR            szFree[15];
CHAR        szMWTemp [] = szMWTempDef;
CHAR        szSystem [] = szSystemDef;

CHAR         szMw_acctb[] = szMw_acctbDef;
CHAR         szNullPort[] = szNullPortDef;
CHAR         szNone[15];
CHAR         szMwlores[] = szMwloresDef;
CHAR         szMwhires[] = szMwhiresDef;
CHAR         szMw_icon[] = szMw_iconDef;
CHAR         szMw_menu[] = szMw_menuDef;
CHAR         szScrollBar[] = szScrollBarDef;
CHAR         szAltBS[20];
CHAR         szPmsCur[] = szPmsCurDef;
CHAR         szHeader[15];
CHAR         szFooter[15];

CHAR     szModern[] = szModernDef;
CHAR     szRoman[] = szRomanDef;
CHAR     szSwiss[] = szSwissDef;
CHAR     szScript[] = szScriptDef;
CHAR     szDecorative[] = szDecorativeDef;

CHAR     szExtSearch[] = szExtSearchDef; /* store default search spec */
CHAR     szLoadFile[25];
CHAR     szCvtLoadFile[45];

CHAR     szIntl[] = szIntlDef;
CHAR     szsDecimal[] = szsDecimalDef;
CHAR     szsDecimalDefault[] = szsDecimalDefaultDef;
CHAR     sziCountry[] = sziCountryDef;
CHAR     sziCountryDefault[5];

/*  table of unit names from util2.c - Must agree with cmddefs.h */
CHAR    *mputsz[utMax] =
    {
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
    };


/* For convenience, we reserves Mac's st concept, the difference is that
cch stored in the first byte of the array includes the '\0' so that we
can use it as a sz by chopping the 1st byte */
CHAR        stBuf[256];

CHAR        szCaptionSave[cchMaxFile]; /* save the caption text */
/* insert stuff */
CHAR        rgchInsert[cchInsBlock]; /* temporary insert buffer */
typeCP      cpInsert;       /* beginning cp of insert block */
int     ichInsert;      /* number of chars used in rgchInsert */
typeFC      fcMacPapIns = fc0;
typeFC      fcMacChpIns = fc0;
struct FKPD vfkpdCharIns;
struct FKPD vfkpdParaIns;
int     vdlIns;         /* Display line for current insert */
int     vcchBlted=0;        /* # of chars blted onto vdlIns */
int     vidxpInsertCache=-1;    /* Current position in vfli.rgdxp
                       during fast insert */
int     vfInsFontTooTall;   /* Ins chr will be too tall for line */
struct EDL  *vpedlAdjustCp;
int     vfSuperIns;     /* whether in super-fast insert mode */
typeCP      cpInsLastInval;
int     vdypCursLineIns;
int     vdypBase;
int     vdypAfter;
int     vxpIns;
int     vxpMacIns;
int     vypBaseIns;
int     vfTextBltValid;
typeCP      cpWall = cp0;
int     vfInsLast;

/* Keyboard shift/lock flags */
int     vfShiftKey = FALSE; /* whether Shift is down */
int     vfCommandKey = FALSE;   /* whether Ctrl key is down */
int     vfOptionKey = FALSE;    /* whether Alt key is down */

/* cache stuff */
CHAR        *vpchFetch;
CHAR        (**hgchExpand)[];
int     vichFetch;
int     vdocFetch;
int     vccpFetch;
int     vcchFetch;
int     visedCache;
int     vdocExpFetch;
int     vdocParaCache = docNil;
int     vdocPageCache;
int     vdocSectCache;
typeCP      vcpFetch;
typeCP      vcpFirstParaCache;
typeCP      vcpLimParaCache;
typeCP      vcpMinPageCache;
typeCP      vcpMacPageCache;
typeCP      vcpLimSectCache;
typeCP      vcpFirstSectCache;

/* cache stuff for display purpose */
int     ctrCache = 0;
int     itrFirstCache = 0;
int     itrLimCache = itrMaxCache;
int     dcpCache = 0;
typeCP      cpCacheHint = cp0;

/* The picture bitmap cache */

int     vdocBitmapCache = docNil;
typeCP      vcpBitmapCache;
HBITMAP     vhbmBitmapCache = NULL;
BOOL        vfBMBitmapCache;

/* style property stuff */
int     ichpMacFormat;
struct CHP  vchpNormal;
struct CHP  vchpAbs;
struct CHP  vchpInsert;
struct CHP  vchpFetch;
struct CHP  vchpSel;        /* Holds the props when the selection is
                       an insert point */
struct CHP  *pchpDefault;
struct CHP  (**vhgchpFormat)[];
struct PAP  vpapPrevIns;
struct PAP  vpapAbs;
struct PAP  *vppapNormal;
struct SEP  vsepNormal;
struct SEP  vsepAbs;
struct SEP  vsepStd;
struct SEP  vsepPage;

#define ESPRM(cch, sgc, spr, fSame, fClobber) \
    (cch + (ESPRM_sgcMult * sgc) + (ESPRM_spr * spr) + \
      (ESPRM_fSame * fSame) + (ESPRM_fClobber * fClobber))

/* ESPRM fields are:
    cch     2 bits of length, 0 means determined by procedure
    sgc     2 bits of group: char, para, or running head
    spr     1 bit priority, fClobber sprms clobber sprms in same group with
          priority less than or equal
    fSame   means overrides previous instance of same sprm
    fClobber    see spr
*/

#define ESPRMChar   ESPRM(2,0,0,1,0)
#define ESPRMPara   ESPRM(2,1,1,1,0)
#define ESPRMParaLong   ESPRM(3,1,1,1,0)

/* This table corresponds to sprm's in prmdefs.h */
CHAR    dnsprm[sprmMax] = {
/*  0 */ 0,         /* */
     ESPRMParaLong,     /* PLMarg */
/*  2 */ ESPRMParaLong,     /* PRMarg */
     ESPRMParaLong,     /* PFIndent */
/*  4 */ ESPRMPara,     /* PJc */
     ESPRM(1,1,1,1,0),  /* Ruler */
/*  6 */ ESPRM(0,1,1,1,0),  /* Ruler1 */
     ESPRMPara,     /* PKeep */
/*  8 */ ESPRM(2,1,1,1,1),  /* PNormal (formerly Pstyle) */
     ESPRM(2,2,0,1,0),  /* PRhc running head code */
/* 10 */ ESPRM(0,1,0,1,1),  /* PSame, clobbers all tabs but related ones */
     ESPRMParaLong,     /* PDyaLine */
/* 12 */ ESPRMParaLong,     /* PDyaBefore */
     ESPRMParaLong,     /* PDyaAfter */
/* 14 */ ESPRM(1,1,1,0,0),  /* PNest */
     ESPRM(1,1,1,0,0),  /* PUnNest */
/* 16 */ ESPRM(1,1,1,0,0),  /* PHang - hanging indent */
     ESPRM(0,1,1,1,0),  /* PRgtbd */
/* 18 */ ESPRMPara,     /* PKeepFollow */
     ESPRM(1,1,0,1,1),  /* PCAll - NUSED */
/* 20 */ ESPRMChar,     /* CBold */
     ESPRMChar,     /* CItalic */
/* 22 */ ESPRMChar,     /* CUline */
     ESPRMChar,     /* CPos */
/* 24 */ ESPRMChar,     /* CFtc */
     ESPRMChar,     /* CHps */
/* 26 */ ESPRM(0,0,0,1,1),  /* CSame */
     ESPRMChar,     /* CChgFtc */
/* 28 */ ESPRMChar,     /* CChgHps */
     ESPRM(2,0,0,1,0),  /* CPlain */
/* 30 */ ESPRMChar,     /* CShadow */
     ESPRMChar,     /* COutline */
/* 32 */ ESPRMChar,     /* CCsm - case modification. */

    /* The following sprms are unused as of 10/10/84: */
     ESPRMChar,     /* CStrike */
/* 34 */ ESPRMChar,     /* DLine - ? */
     ESPRMChar,     /* CPitch - obs. */
/* 36 */ ESPRMPara,     /* COverset */
     ESPRM(2,0,0,1,1),  /* CStc Style */
    /* The preceding sprms are unused as of 10/10/84: */

/* 38 */ ESPRM(0,0,0,0,0),  /* CMapFtc */
     ESPRM(0,0,0,0,0),  /* COldFtc */
/* 40 */ ESPRM(0,1,1,1,0)   /* PRhcNorm -- cch is 4 */
};

/* ruler stuff */
int     mprmkdxa[rmkMARGMAX]; /* stores dxa of indents on ruler */
int     rgxaRulerSprm[3];

/* This is a global parameter to AdjustCp; if FALSE, no invalidation will
take place. */
BOOL        vfInvalid = TRUE; /* if FALSE, no invalidation will take place
                in AdjustCp */

int     viDigits = 2;
BOOL    vbLZero  = FALSE;
int     utCur = utDefault;  /* may be inch or cm depending on value
                       in globdefs.h */

short       itxbMac;
struct TXB  (**hgtxb)[];
struct UAB  vuab;

/* search stuff */
CHAR        (**hszFlatSearch)[];
#if defined(JAPAN) || defined(KOREA)
CHAR        (**hszDistFlatSearch)[];
#endif
CHAR        (**hszSearch)[];
CHAR        (**hszReplace)[];
CHAR        (**hszRealReplace)[]; /* used for building replacement text */
CHAR        (**hszCaseReplace)[]; /* used for building replacement text with
                appropriate capitalization. */
CHAR        *szSearch;
BOOL        fReplConfirm = TRUE;
BOOL        fSearchCase = FALSE;
#if defined(JAPAN) || defined(KOREA)
BOOL        fSearchDist = TRUE;
#endif
BOOL        fSearchWord = FALSE;
BOOL        fSpecialMatch;
BOOL        fMatchedWhite = FALSE;
BOOL        fParaReplace = FALSE;
/*BOOL      fSearchForward = TRUE;*/
typeCP      cpMatchLim;
int     vfDidSearch = FALSE;

/* Strings for printer selection */
CHAR        (**hszPrinter)[];   /* name of the current printer */
CHAR        (**hszPrDriver)[];  /* name of the current printer driver */
CHAR        (**hszPrPort)[];    /* name of the current printer port */
CHAR        szNul[cchMaxIDSTR]; /* name of the null device */
BOOL        vfPrinterValid = TRUE;  /* FALSE iff the above strings do not
                    describe the printer DC */

/* global dxa/dya stuff */
int     vdxaPaper;
int     vdyaPaper;
int     vdxaTextRuler; /* from section props used to calculate right margin */

int dxpLogInch;
int dypLogInch;
int dxpLogCm;
int dypLogCm;
int dxaPrPage;
int dyaPrPage;
int dxpPrPage;
int dypPrPage;
int ypSubSuperPr;

#ifdef KINTL
int dxaAdjustPerCm; /* The amount of kick-back to be added to xa per cm in
               XaQuantize() to offset a round-off error. */
#endif /* ifdef KINTL    */

/* actual position of the cursor line */
int vxpCursLine;
int vypCursLine;
int vdypCursLine;
int vfScrollInval; /* means scroll did not take and UpdateWw must be repeated */

/* selection stuff */
int     vfSelHidden = FALSE;
struct SEL  selCur;     /* current selection (i.e. sel in current ww) */

/* window stuff */
struct WWD  rgwwd[wwMax];
int     wwMac = 0;
int     wwCur = wwNil;
#ifdef ONLINEHELP
int     wwHelp=wwNil;       /* Help Window */
#endif
int     wwClipboard=wwNil;  /* Clipboard Display Window */
struct WWD  *pwwdCur = &rgwwd[0]; /* current window descriptor */
int     vipgd = -1; /* page number displayed in lower corner */
int     xpAlpha;
int     ypAlpha;
RECT        rectParent;
struct FLI  vfli =
    {
    cp0, 0, cp0, 0, 0, 0, FALSE, 0, 0, 0, 0, 0, 0, 0,
    FALSE, FALSE, 0, 0, 0, 0, 0, FALSE, 0, 0,
    /* rgdxp */
    0x0000, 0xFFFE, 0xffff, 0xffff, 0xe0ff, 0xff3f, 0x00ff, 0xff07,
    0x00fe, 0xff03, 0x00f8, 0xff00, 0x0ff0, 0x7f80, 0x3fe0, 0x3fe0,
    0x7fc0, 0x1ff0, 0xffc0, 0x1ff8, 0xff81, 0x0ffc, 0xff83, 0x0ffe,
    0xff87, 0x0fff, 0x8f07, 0x071f, 0x060f, 0x870f, 0x060f, 0x870f,
    0x8f0f, 0x871f, 0xff0f, 0x87ff, 0xff0f, 0x87ff, 0xff0f, 0x87ff,
    0x1f0f, 0x878f, 0x0f0f, 0x870f, 0x0007, 0x070f, 0x8087, 0x0f1f,
    0xe083, 0x0f7e, 0xff81, 0x0ffc, 0xffc0, 0x1ff8, 0x7fc0, 0x1ff0,
    0x1fe0, 0x3fc0, 0x00f0, 0x7f00, 0x00fc, 0xff01, 0x00fe, 0xff03,
    0xe0ff, 0xff3f, 0x8BEC, 0xFC46, 0xF8D1, 0x4689, 0x2BEA, 0x8BFF,
    0xEBF7, 0xFF55, 0x0A76, 0x468B, 0x2BEC, 0x50C6, 0x8B57, 0x085E,
    0x5FFF, 0xFF08, 0x0A76, 0x8B56, 0xEA46, 0xC703, 0x8B50, 0x085E,
    0x5FFF, 0xFF0C, 0x0A76, 0x468B, 0x03EC, 0x50C6, 0x8B57, 0x085E,
    0x5FFF, 0xFF08, 0x0A76, 0x468B, 0x2BFA, 0x50C6, 0x468B, 0x03EA,
    0x50C7, 0x5E8B, 0xFF08, 0x0C5F, 0x468B, 0xB1FA, 0xD306, 0x03F8,
    0x8BF0, 0xFC46, 0xF8D3, 0xF803, 0x7639, 0x7DEC, 0x5EA6, 0x835F,
    0x02ED, 0xE58B, 0x5D1F, 0xCA4D, 0x0008, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* rgch */
    0x11, 0x30, 0x5c, 0x71, 0x84, 0x75, 0x83, 0x84,
    0x30, 0x72, 0x89, 0x30, 0x60, 0x71, 0x85, 0x7c,
    0x64, 0x30, 0x7A, 0x7D, 0x77, 0x7C, 0x64, 0x60,
    0x33, 0x44, 0x61, 0x7A, 0x67, 0x76, 0x33, 0x7B,
    0x72, 0x60, 0x33, 0x71, 0x76, 0x76, 0x7D, 0x33,
    0x71, 0x61, 0x7C, 0x66, 0x74, 0x7B, 0x67, 0x33,
    0x67, 0x7C, 0x33, 0x6A, 0x7C, 0x66, 0x33, 0x71,
    0x6A, 0x33, 0x51, 0x7C, 0x71, 0x3F, 0x33, 0x51,
    0x7C, 0x71, 0x3F, 0x33, 0x51, 0x61, 0x6A, 0x72,
    0x7D, 0x3F, 0x33, 0x50, 0x7B, 0x7A, 0x3E, 0x50,
    0x7B, 0x66, 0x76, 0x7D, 0x3F, 0x33, 0x72, 0x7D,
    0x77, 0x33, 0x43, 0x72, 0x67, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

/* Screen dependent measurements */
int     DxaPerPix;  /* number of twips per xp */
int     DyaPerPix;  /* number of twips per yp */

int     xpInch;     /* number of xp's per inch */
int     xpMaxUser;
int     xpSelBar;   /* width of the selection bar in xp's */

int     dxpScrlBar; /* width of the scroll bar in xp's */
int     dypScrlBar; /* height of the scroll bar in xp's */
int     dxpInfoSize;    /* width of the page info area */

int     xpRightMax;
int     xpMinScroll;
int     xpRightLim;

int     ypMaxWwInit;
int     ypMaxAll;

int     dypMax;
int     dypAveInit;
int     dypWwInit;
int     dypBand;
int     dypRuler = 0;
int     dypSplitLine;
int     ypSubSuper; /* adjustment from base line for sub/super */

/* idstr stuff */
int     idstrCurrentUndo = IDSTRUndoBase;

/* the following two may eventually be deleted -- check usage in ruler.c */
int     vfTabsChanged = FALSE; /* TRUE if any tabs are changed from the ruler */
int     vfMargChanged = FALSE; /* TRUE if any indents are changed from the ruler */

#ifdef CASHMERE
struct TBD  rgtbdRulerSprm[itbdMax];
#endif /* CASHMERE */

#ifdef RULERALSO
BOOL        vfDisableMenus = FALSE;/* TRUE if top level menus (including
                      the system menu are to be disabled */
int     vfTempRuler; /* TRUE if ruler is created because of dialog box creation */
HWND        vhDlgTab = (HWND)NULL;
HWND        vhDlgIndent = (HWND)NULL;
struct TBD  rgtbdRuler[itbdMax];
#endif /* RULERALSO */

int     flashID = 0; /* timer ID for flashing before we put up a messagebox when we are not the active app */



/*-----------------------------------------------------*/
/* Merged MGLOBALS.C and MGLOBALS2.C  ..pault 10/26/89 */
/*-----------------------------------------------------*/


/* internal memory stuff */
int *memory; /* ptr to beginning of free space, get incremented after
                                allocating chunks from memory */
#ifdef OURHEAP
int *pmemMax;/* ptr to max of memory */
CHAR * pmemStart; /* point to start of memory after global data */
unsigned vcbMemTotal; /* total number of free memory bytes */
unsigned cbTotQuotient;/* for calculating % of free space */
unsigned cbTot; /* for calculating % of free space */
#endif
unsigned cwHeapFree; /* number of free heap space in words */

/* MS-WINDOWS related variables */

HWND            hParentWw = NULL;       /* handle to parent ww (created in
                                           interface module) */
HANDLE          hMmwModInstance = NULL; /* handle to memory module instance */
HANDLE          vhReservedSpace;         /* space reserved for control manger */
long            rgbBkgrnd = -1L;        /* rgb color of the background */
long            rgbText = -1L;          /* rgb color of the text */
HBRUSH          hbrBkgrnd = NULL;       /* handle to background brush */
long            ropErase = WHITENESS;   /* raster op to erase the screen */
BOOL            vfMonochrome = FALSE;   /* TRUE iff display is monochrome */

HMENU           vhMenu = NULL;          /* handle to top level menu */

CHAR            *vpDlgBuf;              /* pointer to buffer for dialog boxes */

#ifdef INEFFLOCKDOWN    /* SEE NOTE IN FINITFARPROCS() */
/* far pointers to dialog functions exported to WINDOWS */
FARPROC lpDialogOpen;
FARPROC lpDialogSaveAs;
FARPROC lpDialogPrinterSetup;
FARPROC lpDialogPrint;
FARPROC lpDialogCancelPrint;
FARPROC lpDialogRepaginate;
FARPROC lpDialogSetPage;
FARPROC lpDialogPageMark;
FARPROC lpDialogHelp;

#ifdef ONLINEHELP
FARPROC lpDialogHelpInner;
#endif /* ONLINEHELP */

FARPROC lpDialogGoTo;
FARPROC lpDialogFind;
FARPROC lpDialogChange;
FARPROC lpDialogCharFormats;
FARPROC lpDialogParaFormats;
FARPROC lpDialogRunningHead;
FARPROC lpDialogTabs;
FARPROC lpDialogDivision;
FARPROC lpDialogAlert;
FARPROC lpDialogConfirm;
FARPROC lpFontFaceEnum;
FARPROC lpFPrContinue;
FARPROC lpDialogWordCvt;
#endif /* ifdef INEFFLOCKDOWN */

/* Mouse status flags and cursors */
int             vfDoubleClick = FALSE;  /* whether click is double click */
HCURSOR         vhcHourGlass;           /* handle to hour glass cursor */
HCURSOR         vhcIBeam;               /* handle to i-beam cursor */
HCURSOR         vhcArrow;               /* handle to arrow cursor */
HCURSOR         vhcBarCur;              /* handle to back arrow cursor */

#ifdef PENWIN   // for PenWindows (5/21/91) patlam
#include <penwin.h>
HCURSOR         vhcPen;                 /* handle to pen cursor */
int (FAR PASCAL *lpfnProcessWriting)(HWND, LPRC) = NULL;
VOID (FAR PASCAL *lpfnPostVirtualKeyEvent)(WORD, BOOL) = NULL;
VOID    (FAR PASCAL *lpfnTPtoDP)(LPPOINT, int) = NULL;
BOOL    (FAR PASCAL *lpfnCorrectWriting)(HWND, LPSTR, int, LPRC, DWORD, DWORD) = NULL;
BOOL    (FAR PASCAL *lpfnSymbolToCharacter)(LPSYV, int, LPSTR, LPINT) = NULL;
#endif

/* MS-WINDOWS stuff */
HANDLE          vhSysMenu;
HDC             vhMDC = NULL;   /* memory DC compatible with the screen */
int             dxpbmMDC = 0;   /* width of the bitmap attatched to vhMDC */
int             dypbmMDC = 0;   /* height of the bitmap attatched to vhMDC */
HBITMAP         hbmNull;        /* handle to an empty bitmap */
HDC             vhDCPrinter = NULL; /* DC for the printer */
HWND            vhWnd;          /* handle to document window */
HANDLE          vhAccel;        /* handle to menu key accelerator table */

/* modeless dialog handles */
HWND            vhDlgRunningHead = (HWND)NULL;
HWND            vhDlgFind = (HWND)NULL;
                                /* handle to modeless Find dialog box */
HWND            vhDlgChange = (HWND)NULL;
                                /* handle to modeless Change dialog box */

HWND            vhWndRuler = (HWND)NULL;
HWND            vhWndCancelPrint = (HWND)NULL;
                                /* handle to modeless Cancel Print dialog box */
#ifndef NOMORESIZEBOX
HWND            vhWndSizeBox;   /* handle to the size box */
#endif
HWND            vhWndPageInfo;  /* handle to the page info window */
HWND            vhWndMsgBoxParent = (HWND)NULL; /* parent of the message box */

int             vfSkipNextBlink = FALSE;
                                /* skip next timed off-transition of caret */
int             vfFocus = FALSE; /* Whether we have the input focus */
int             vfOwnClipboard = FALSE;
                                /* Whether we are the owner of the clipboard */
MSG             vmsgLast;       /* last message received */

HFONT           vhfPageInfo = NULL; /* handle to the font for the page info */
int             ypszPageInfo;   /* y position in window to write page info */

/* font related variables */
int         vifceMac = ifceMax;
union FCID  vfcidScreen;
union FCID  vfcidPrint;
struct FCE  rgfce[ifceMax];
struct FCE  *vpfceMru;
struct FCE  *vpfceScreen;
struct FCE  *vpfcePrint;
struct FMI  vfmiScreen;
struct FMI  vfmiPrint;

#ifndef NEWFONTENUM
int aspectXFont;
int aspectYFont;
#endif


#ifdef SYSENDMARK
HFONT           vhfSystem = NULL; /* handle to the standard system font for
                                     chEMark. */
struct FMI      vfmiSysScreen;    /* to keep the metrics info for the system
                                     font.    */
int            vrgdxpSysScreen[chFmiMax - chFmiMin];
                                  /* Used by vfmiSysScreen. */
#endif /* KANJI */

#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
unsigned char Zenstr1[256];
unsigned char Zenstr2[256];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\menu.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* menu.c -- WRITE menu handling routines */
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCTLMGR
#define NOSYSMETRICS
#define NOICON
#define NOKEYSTATE
#define NORASTEROPS
#define NOSHOWWINDOW
//#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMETAFILE
#define NOSOUND
#define NOSCROLL
#define NOWH
#define NOOPENFILE
#define NOCOMM
#define NOMSG
#define NOREGION
#define NORECT

#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "filedefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "prmdefs.h"
#define NOKCCODES
#include "ch.h"
#include "editdefs.h"
#include "menudefs.h"
#include "str.h"
#include "fontdefs.h"
#include "dlgdefs.h"
#include "dispdefs.h"
#include <shellapi.h>
#if defined(OLE)
#include "obj.h"
#endif

#ifdef JAPAN //T-HIROYN Win3.1
#include "kanji.h"
#endif

extern int FAR PASCAL ShellAbout(HWND hWnd, LPSTR szApp, LPSTR szOtherStuff, HICON hIcon);

extern typeCP cpMinCur, cpMacCur;
extern struct WWD       rgwwd[];
extern CHAR             stBuf[];
extern int              docCur;
extern struct DOD       (**hpdocdod)[];
extern struct SEL       selCur;
extern int              vfOutOfMemory;
extern BOOL             vfWinFailure;
extern int              vfSysFull;
extern int              vfDiskError;
extern struct CHP       vchpAbs;
extern struct PAP       vpapAbs;
extern struct CHP       vchpFetch;
extern struct CHP       vchpSel;
extern int              vfSeeSel;
extern typeCP           vcpFetch;
extern int              vccpFetch;
extern typeCP           cpMacCur;
extern typeCP           vcpLimParaCache;
extern HMENU            vhMenu; /* global handle to the top level menu */
extern HANDLE           hParentWw;
extern HCURSOR          vhcHourGlass;
extern HANDLE           hMmwModInstance;
extern HANDLE           vhDlgFind;
extern HANDLE           vhDlgChange;
extern HANDLE           vhDlgChange;
extern CHAR             (**hszSearch)[];    /* Default search string */
#ifdef CASHMERE
extern int              vfVisiMode;
extern HWND             vhWndGlos;
extern HWND             vhWndScrap;
#endif /* CASHMERE */

#ifdef ONLINEHELP
extern fnHelp(void);
#endif /* ONLINEHELP */

/* These values are comprised of one bit for each menu item in the
   applicable menu (for example, there are bitcount(0xfff)==12 menu
   items under Character) ..pault */

static int rgmfAllItems[CMENUS] = {
    0x01ff,  /* FILE */
    0x003f,  /* EDIT */
    0x000f,  /* FIND */
#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
    0x03ff,  /* CHARACTER */
#else
    0x01ff,  /* CHARACTER */
#endif
    0x01ff,  /* PARA */
    0x001f,  /* DOCU */
    0x000f   /* HELP */
};


/* When we're editing a running header or footer, use this */
static int rgmfRunning[CMENUS] = {
    0x0020,        /* FILE -- enable printer-setup only */
    0x003F,        /* EDIT -- everything */
    0x0007,        /* FIND -- enable find/again and change */
#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
    0x03ff,        /* CHARACTER -- everything */
#else
    0x01FF,        /* CHARACTER -- everything */
#endif
    0x01FF,        /* PARAGRAPH -- everything */
    0x001F,        /* DOCUMENT -- everything */
    0x000f         /* HELP -- everything */
};


int viffnMenuMac;

NEAR PutSzUndoInMenu(void);
NEAR GetChpVals (struct CHP *, TSV *);
NEAR GetPapVals (struct PAP *, TSV *);
NEAR GetHffn (struct CHP *, TSV *);
NEAR SetChUndef(TSV *, struct CHP *, int *);
NEAR SetParaUndef(TSV *, struct PAP *, int *);
NEAR FNoSearchStr(HWND);



SetAppMenu(hMenu, index)
HMENU hMenu;   /* handle to popup menu */
int   index;   /* index to popup menu */
{
/* Mark greying and checks on menus as appropriate to current state. */
extern BOOL vfPrinterValid;
extern CHAR (**hszPrPort)[];
extern CHAR szNul[];
extern int vfPictSel;
extern int vfOwnClipboard;
extern int docScrap;
extern struct UAB vuab;
extern HWND vhWnd;
typeCP CpMacText();

register int rgmfT[CMENUS]; /* Our workspace for menu greying */
int imi;
int imiMin = 0;
int imiMax = 0;
int *pflags;
TSV rgtsv[itsvchMax];  /* gets attributes and gray flags from CHP, PAP */
unsigned wPrintBitPos = ~(0x0001 << (imiPrint - imiFileMin));


/* If we are out of memory or the disk is full, then... */
if (vfOutOfMemory || vfSysFull || vfDiskError || vfWinFailure)
    {
    bltc( rgmfT, 0, CMENUS );
#if WINVER >= 0x300
    /* Disable the print stuff, but leave New/Open/Save/SaveAs/Exit */
    rgmfT[FILE] = 0x008f;
#else
    /* Disable everything except Save & SaveAs */
    rgmfT[FILE] = 0x0018;
#endif
    }
else
    {
    /* Start with all items or subset if editing running head/foot */
    blt( (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter) ? rgmfRunning
      : rgmfAllItems, rgmfT, CMENUS );

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
        {
            extern int  vfImeHidden;   /*T-HIROYN ImeHidden Mode flag*/
    
            if(index == CHARACTER) {
                /* Version 3.1 or more ok */
                if(FALSE == GetIMEVersioOk(vhWnd)) {
                    rgmfT[CHARACTER] = 0x1ff;       //Set Ime mode memu gray
                    vfImeHidden = 0;
                }
                if(TRUE == GetIMEOpenMode(vhWnd))
                    rgmfT[CHARACTER] = 0x1ff;       //Set Ime mode memu gray
            }
        }
#endif
    }

pflags = &rgmfT[index];

switch (index)
    {
    case FILE:
        imiMin = imiFileMin;
        imiMax = imiFileMax;

        /* Disallow print, if the printer or the port is not valid. */
        if (!vfPrinterValid || hszPrPort == NULL ||
                WCompSz( *hszPrPort, szNul ) == 0)
            *pflags &= wPrintBitPos;
        break;

    case EDIT:
        imiMin = imiEditMin;
        imiMax = imiEditMax;
        /* Disallow cut, copy if the selection is empty */
        if (selCur.cpFirst == selCur.cpLim)
            {
            *pflags &= 0xfff9;
            }
        /* Move and Size picture are only allowed if a picture is selected */
        if (!vfPictSel)
            *pflags &= 0xFFCF;
        /* Disallow Paste if we can determine that the scrap is empty.
           Regrettably, we can be fooled into thinking it is not by
           another instance of MEMO that is the clipboard owner and has
           an empty scrap. */

        /* Disallow UNDO if appropriate; set UNDO string into menu */
        {
        if ((vuab.uac == uacNil) || vfOutOfMemory)
            {
            /* Gray out undo */
            *pflags &=  0xfffe;
            }
        PutSzUndoInMenu();
        }
        break;

    case FIND:
        imiMin = imiFindMin;
        imiMax = imiFindMax;
        if ((GetActiveWindow() == hParentWw && CchSz(**hszSearch) == 1) ||
            (!vhDlgFind && !vhDlgChange && (CchSz(**hszSearch) == 1)) ||
            (vhDlgFind && FNoSearchStr(vhDlgFind)) ||
            (vhDlgChange && FNoSearchStr(vhDlgChange)))
            *pflags &= 0xfffd; /* disable find again */

        if (CpMacText( docCur ) == cp0)
            *pflags &= 0xfff0; /* disable find, search, change, goto page */
        break;

    case CHARACTER:
        imiMin = imiCharMin;
        imiMax = imiCharMax;

        if (!(vfOutOfMemory || vfWinFailure))
        {
        int iffn, iffnCurFont, fSetFontList;
        struct FFN **hffn, *pffn;
        union FCID fcid;
        extern struct FFN **MpFcidHffn();

        /* GetRgtsvChpSel() fills up rgtsv */
        GetRgtsvChpSel(rgtsv);

        CheckMenuItem(hMenu, imiBold,
           (rgtsv[itsvBold].fGray == 0 && rgtsv[itsvBold].wTsv != 0) ?
             MF_CHECKED : MF_UNCHECKED);
        CheckMenuItem(hMenu, imiItalic,
           (rgtsv[itsvItalic].fGray == 0 && rgtsv[itsvItalic].wTsv != 0) ?
             MF_CHECKED : MF_UNCHECKED);
        CheckMenuItem(hMenu, imiUnderline,
           (rgtsv[itsvUline].fGray == 0 && rgtsv[itsvUline].wTsv != 0) ?
             MF_CHECKED : MF_UNCHECKED);

               /* note that the value stored in rgtsv[itsvPosition].wTsv
                  is really a signed integer, so we can just check for
                  0, > 0, and < 0 */

        CheckMenuItem(hMenu, imiSuper,
           (rgtsv[itsvPosition].fGray == 0
            && (int)(rgtsv[itsvPosition].wTsv) > 0) ?
             MF_CHECKED : MF_UNCHECKED);
        CheckMenuItem(hMenu, imiSub,
           (rgtsv[itsvPosition].fGray == 0
            && (int)(rgtsv[itsvPosition].wTsv) < 0) ?
             MF_CHECKED : MF_UNCHECKED);

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IME3.1J
{
        extern int  vfImeHidden;   /*T-HIROYN ImeHidden Mode flag*/
        CheckMenuItem(hMenu, imiImeHidden,
           vfImeHidden ? MF_CHECKED : MF_UNCHECKED);
}
#endif

#if 0
        /* SetFontMenuItems() pulled on line */
        {
        /* make sure that the right font names are on the character dropdown */

        /* These two lines avoid calculating bdodCur twice */
        unsigned int bdodCur = docCur * sizeof (struct DOD);
#define pdodCur  ( (struct DOD *) ( (CHAR *)(&(**hpdocdod) [0]) + bdodCur))

        fSetFontList = !(*(pdodCur->hffntb))->fFontMenuValid;
        if (fSetFontList)
            {
            /* need to get the current list */
            viffnMenuMac = 0;
            if (FInitFontEnum(docCur, 3, TRUE))
                {
                for (iffn = 0; iffn < 3; iffn++)
                    {
                    if (!FEnumFont((struct FFN *)rgffnFontMenu[iffn]))
                        break;
                    viffnMenuMac++;
                    }
                EndFontEnum();
                (*(pdodCur->hffntb))->fFontMenuValid = TRUE;
                }
            }

        /* make sure the current font is on the list - ok, so it's kind of
           a hack */
        mfFonts = 0xffff; /* template to mask "no font" entries */
        iffnCurFont = -1;
        hffn = (struct FFN **)rgtsv[itsvFfn].wTsv;
        for (iffn = 0; iffn < 3; iffn++)
            {
            if (iffn >= viffnMenuMac)
                mfFonts ^= (0x0040 << iffn); /* disable this entry */
            else if (iffnCurFont < 0 && !rgtsv[itsvFfn].fGray)
                {
                pffn = (struct FFN *)rgffnFontMenu[iffn];
                if (WCompSz((*hffn)->szFfn, pffn->szFfn) == 0)
                    iffnCurFont = iffn;
                }
            }

        if (!rgtsv[itsvFfn].fGray && iffnCurFont < 0)
            {
            /* no match for this font - ram it in */
            if (viffnMenuMac < 3)
                viffnMenuMac++;
            iffnCurFont = viffnMenuMac - 1;
            bltbyte(*hffn, rgffnFontMenu[iffnCurFont],
                    CbFfn(CchSz((*hffn)->szFfn)));

            mfFonts |= (0x0040 << iffnCurFont); /* enable this entry */

            /* invalidate cache since we're messing it up */
            (*pdodCur->hffntb)->fFontMenuValid = FALSE;
            fSetFontList = TRUE;
            }

        if (fSetFontList)
            /* font name cache has changed - update the menu dropdown */
            for (iffn = 0; iffn < 3; iffn++)
                {
                int imi;
#ifdef  KOREA
                int i;
                CHAR rgb[LF_FACESIZE + 8];
#else
                CHAR rgb[LF_FACESIZE + 4];
#endif

                if (iffn < viffnMenuMac)
                    {
#ifdef  KOREA   /* sangl 91.6.19 */
                    i = CchCopySz(((struct FFN *)rgffnFontMenu [iffn])->szFfn,
                               &rgb [0]);
                    rgb[i] = '(';
                    rgb[i+1] = '\036';
                    rgb[i+2] = '1' + iffn;
                    rgb[i+3] = '\037';
                    rgb[i+4] = '';
                    rgb[i+5] = '' + iffn;
                    rgb[i+6] = ')';
                    rgb[i+7] = '\0';
#else
                    rgb[0] = '&';
                    rgb[1] = '1' + iffn;
                    rgb[2] = '.';
                    rgb[3] = ' ';
                    CchCopySz(((struct FFN *)rgffnFontMenu [iffn])->szFfn,
                               &rgb [4]);
#endif
                    }
                else
                    {
                    /* empty font name -- don't display it */
                    rgb [0] = '\0';
                    }

                /* Set the menu */
                imi = imiFont1 + iffn;
                ChangeMenu( vhMenu, imi, (LPSTR)rgb, imi, MF_CHANGE );
                }
        }

        *pflags &= mfFonts;

        /* see which (if any) fonts apply */
        /* note that the value stored in rgtsv[itsvFfn].wTsv
           is the font name handle, rather than the ftc */
        for (iffn = 0; iffn < 3; iffn++)
            {
            CheckMenuItem(hMenu, imiFont1 + iffn,
                iffn == iffnCurFont ? MF_CHECKED : MF_UNCHECKED);
            }
#endif
        }
        break;

    case PARA:
        imiMin = imiParaMin;
        imiMax = imiParaMax;

        if (!(vfOutOfMemory || vfWinFailure))
        {
        int jc;

        /* GetRgtsvPapSel() fills up rgtsv  with paragraph properties */
        GetRgtsvPapSel(rgtsv);

           /* if gray, set jc to invalid value */
        jc = (rgtsv[itsvJust].fGray == 0) ? rgtsv[itsvJust].wTsv : jcNil;

        CheckMenuItem(hMenu, imiParaNormal, MF_UNCHECKED);
        CheckMenuItem(hMenu, imiLeft, jc == jcLeft ? MF_CHECKED : MF_UNCHECKED);
        CheckMenuItem(hMenu, imiCenter, jc == jcCenter ? MF_CHECKED :
          MF_UNCHECKED);
        CheckMenuItem(hMenu, imiRight, jc == jcRight ? MF_CHECKED :
          MF_UNCHECKED);
        CheckMenuItem(hMenu, imiJustified, jc == jcBoth ? MF_CHECKED :
          MF_UNCHECKED);


        CheckMenuItem(hMenu, imiSingleSpace,
         (rgtsv[itsvSpacing].fGray == 0
          && rgtsv[itsvSpacing].wTsv == czaLine) ?
             MF_CHECKED : MF_UNCHECKED);

        CheckMenuItem(hMenu, imiOneandhalfSpace,
         (rgtsv[itsvSpacing].fGray == 0
          && rgtsv[itsvSpacing].wTsv == (3 * czaLine / 2)) ?
             MF_CHECKED : MF_UNCHECKED);

        CheckMenuItem(hMenu, imiDoubleSpace,
         (rgtsv[itsvSpacing].fGray == 0
          && rgtsv[itsvSpacing].wTsv == (2 * czaLine)) ?
             MF_CHECKED : MF_UNCHECKED);
        }
        break;

    case DIV:
        imiMin = imiDocuMin;
        imiMax = imiDocuMax;

        if (wwdCurrentDoc.fEditHeader)
            *pflags &= ~2; /* disable footer */
        else if (wwdCurrentDoc.fEditFooter)
            *pflags &= ~1; /* disable header */
        break;

    default:
        break;
    } /* end of switch */

    { /* enable or gray menu items */
    register WORD wFlagMask = 1;

    for (imi = imiMin; imi < imiMax; imi++)
        {
        EnableMenuItem(hMenu, imi, (*pflags & wFlagMask ? MF_ENABLED :
          MF_GRAYED));
        wFlagMask <<= 1;
        }
    }

#if defined(OLE)
    if (index == EDIT)
        ObjUpdateMenu(hMenu);
#endif
}




NEAR PutSzUndoInMenu()
{
/* Put the proper string for the current undo into the EDIT menu.
idstrCurrentUndo gives the resource id for the current undo string.  An
idstrCurrentUndo value of -1 means use the last value loaded.
This routine caches Undo strings so resource loads are needed only
when the string changes. */

extern struct UAB vuab;
extern int idstrCurrentUndo;   /* Current UNDO's string ID */
extern CHAR szAltBS[];

#ifdef JAPAN //T-HIROYN Win3.1
static CHAR szUndo[ cchSzUndo + 5];
#else
static CHAR szUndo[ cchSzUndo ];
#endif
static int idstrUndoCache = -1;

if (vuab.uac == uacNil)
    {
    idstrCurrentUndo = IDSTRUndoBase;
    }

if (idstrCurrentUndo < 0)
    {
    /* This means we should use the last Undo string */
    Assert(idstrUndoCache > 0);

    idstrCurrentUndo = idstrUndoCache;
    }

if (idstrCurrentUndo != idstrUndoCache)
    {
    /* Cached string is no good, build another */

    CHAR *PchFillPchId();
    CHAR *pch = szUndo;
#if defined(KOREA)
    if (idstrCurrentUndo != IDSTRUndoBase)
        {
        /* need the tail part */
        pch = PchFillPchId(pch, idstrCurrentUndo, (int)sizeof(szUndo) );
        }
    pch += LoadString(hMmwModInstance, IDSTRUndoBase, (LPSTR)pch,
                  (int)(szUndo + sizeof(szUndo) - pch));
    CchCopySz((PCH)szAltBS, pch);
#else
    pch += LoadString(hMmwModInstance, IDSTRUndoBase, (LPSTR)szUndo,
                  cchSzUndo);
    if (idstrCurrentUndo != IDSTRUndoBase)
        {
        /* need the tail part */
        pch = PchFillPchId(pch, idstrCurrentUndo,
            (int)(szUndo + sizeof(szUndo) - pch));
        }
    CchCopySz((PCH)szAltBS, pch);
#endif

    /* Set the menu */
    ChangeMenu( vhMenu, imiUndo, (LPSTR)szUndo, imiUndo, MF_CHANGE );

    /* Set cache for next time */
    idstrUndoCache = idstrCurrentUndo;
    }
}


GetRgtsvChpSel (prgtsv)
TSV        *prgtsv;
{
/* Return properties for the character menu.  */

typeCP cpLim;
typeCP cpStartRun;
struct CHP chp;
int cchGray = 0;  /* number of undefined (grayed) character attributes */
int ccpFetch = 0;  /* number of calls made to FetchCp */
                  /* max number of calls to FetchCp */
#define ccpFetchMax 50

#ifndef SAND
if (selCur.cpLim > cpMacCur)
    {
    bltbc(prgtsv, 1, (cchTSV * itsvchMax));  /* turn all grays on */
    return;
    }
#endif /* NOT SAND */

bltbc(prgtsv, 0, (cchTSV * itsvchMax));  /* initializw rgtsv */
CachePara(docCur, selCur.cpFirst);
if (selCur.cpFirst == selCur.cpLim)
    {
    GetChpVals (&vchpSel,prgtsv);  /* load up chp values */
    GetHffn (&vchpSel,prgtsv);  /* load up handle for font name */
    }
else
    {
    typeCP CpLimNoSpaces(typeCP, typeCP);

    cpLim = CpLimNoSpaces(selCur.cpFirst, selCur.cpLim);
    FetchCp(docCur, selCur.cpFirst, 0, fcmProps);
    blt(&vchpFetch, &chp, cwCHP);  /* CHP for use in comparisons */
    GetChpVals (&vchpFetch,prgtsv);  /* load up chp values */

    while ((vcpFetch + vccpFetch) < cpLim && ++ccpFetch <= ccpFetchMax)
        {
        /* Indicate which attributes should be grayed */
        FetchCp(docNil, cpNil, 0, fcmProps);
        chp.fSpecial = vchpFetch.fSpecial;
        if (CchDiffer (&chp, &vchpFetch, cchCHP) != 0)
            {
            SetChUndef(prgtsv, &vchpFetch, &cchGray);
            if (cchGray == itsvchMax)  /* all gray - don't bother */
                break;
            }
        }
    if (ccpFetch > ccpFetchMax)
        {
        /* never finished - make everything gray */
        bltbc(prgtsv, 1, (cchTSV * itsvchMax));
        }
    else
        GetHffn (&chp,prgtsv);  /* load up handle for font name */
    }
}


GetRgtsvPapSel (prgtsv)
TSV        *prgtsv;
{
/* Return properties for the paragraph menu.  */

/* Using selCur, the current para props are left in vpapAbs and the paragraph
   attributes in rgtsv are set to gray if that attribute differs from that
   in the previous paragraph. Up to cparaMax paragraphs will be checked */


int cparaGray = 0;  /* number of undefined (grayed) paragraph attributes */
                  /* max number of calls to CachePara */
#define cparaMax 50

int cpara = 0;
struct PAP pap;

CachePara(docCur, selCur.cpFirst);

#ifdef ENABLE /* we will show defaults even if the cursor is next to endmark */
if (selCur.cpFirst == cpMacCur)
    {
    bltbc(prgtsv, 1, (cchTSV * itsvparaMax));  /* turn all grays on */
    return;
    }
#endif

bltbc(prgtsv, 0, (cchTSV * itsvparaMax));  /* initializw rgtsv */

blt(&vpapAbs, &pap, cwPAP);   /* save 1st paragraph for compares */
GetPapVals (&pap,prgtsv);  /* load rgtsv with pap values */

while (vcpLimParaCache < selCur.cpLim && ++cpara <= cparaMax)
    {
    /* If any props are different, set appropriate flags */
    CachePara(docCur, vcpLimParaCache);
    if (CchDiffer(&pap, &vpapAbs, (cwPAPBase * cchINT)) != 0)
           {
           SetParaUndef(prgtsv, &vpapAbs, &cparaGray);
           if (cparaGray == itsvparaMax)  /* all gray - don't bother */
              break;
           }
     }

if (cpara > cparaMax)
    /* never finished - make everything gray */
    bltbc(prgtsv, 1, (cchTSV * itsvparaMax));
}


NEAR GetChpVals (pchp,prgtsv)  /* load chp values into rgtsv */
register struct CHP        *pchp;
register TSV        *prgtsv;
{

  (prgtsv+itsvBold)->wTsv = pchp->fBold;
  (prgtsv+itsvItalic)->wTsv = pchp->fItalic;
  (prgtsv+itsvUline)->wTsv = pchp->fUline;

  (prgtsv+itsvFfn)->wTsv = pchp->ftc;
  (prgtsv+itsvSize)->wTsv = pchp->hps;

                  /*  sub/superscripts - note that value is stored
                      as a signed integer, so we can just check for
                      the value relative to 0 */

  (int)((prgtsv+itsvPosition)->wTsv) = (char)pchp->hpsPos;
}

NEAR GetPapVals (ppap,prgtsv)  /* load pap values into rgtsv */
register struct PAP        *ppap;
register TSV        *prgtsv;
{

  (prgtsv+itsvJust)->wTsv = ppap->jc;
  (prgtsv+itsvSpacing)->wTsv = ppap->dyaLine;
  (prgtsv+itsvLIndent)->wTsv = ppap->dxaLeft;
  (prgtsv+itsvFIndent)->wTsv = ppap->dxaLeft1;
  (prgtsv+itsvRIndent)->wTsv = ppap->dxaRight;

}

NEAR GetHffn (pchp,prgtsv)  /* load font name handle into rgtsv */
register struct CHP        *pchp;
register TSV        *prgtsv;
{
union FCID fcid;
extern struct FFN **MpFcidHffn();
         /* store handle for font name in font name entry */
  Assert(sizeof(struct FFN **) == sizeof(prgtsv->wTsv));

  fcid.strFcid.doc = docCur;
  fcid.strFcid.ftc = pchp->ftc + (pchp->ftcXtra << 6);
  (struct FFN **)((prgtsv+itsvFfn)->wTsv) = MpFcidHffn(&fcid);
}


NEAR SetChUndef(prgtsv, pchp, pcchGray)
register TSV        *prgtsv;
register struct CHP        *pchp;
int        *pcchGray;
{

        /* compare chp to values stored in rgtsv and set undefined
           flags for differing fields of interest.  */
                     /* BOLD */
        if ((prgtsv+itsvBold)->fGray == 0)
           if (pchp->fBold != (prgtsv+itsvBold)->wTsv)
              {
              (prgtsv+itsvBold)->fGray = 1;
              (*pcchGray)++;
              }
                     /* ITALIC */
        if ((prgtsv+itsvItalic)->fGray == 0)
           if (pchp->fItalic != (prgtsv+itsvItalic)->wTsv)
              {
              (prgtsv+itsvItalic)->fGray = 1;
              (*pcchGray)++;
              }
                     /* UNDERLINE */
        if ((prgtsv+itsvUline)->fGray == 0)
           if (pchp->fUline != (prgtsv+itsvUline)->wTsv)
              {
              (prgtsv+itsvUline)->fGray = 1;
              (*pcchGray)++;
              }
                     /* Position (SUBSCRIPT OR SUPERSCRIPT) */
                     /* if different: gray both sub and superscript.
                        The properties are really mutually exclusive,
                        even though they appear on the menu as separate
                        items. Also, for Write, off and gray are the
                        same, so if either is grayed, the other must be
                        either off or gray, so the appearance is the
                        same. */

        if ((prgtsv+itsvPosition)->fGray == 0)
           if (pchp->hpsPos != (prgtsv+itsvPosition)->wTsv)
              {
              (prgtsv+itsvPosition)->fGray = 1;
              (*pcchGray)++;
              }

                     /* FONT NAME */
        if ((prgtsv+itsvFfn)->fGray == 0)
           if (pchp->ftc != (prgtsv+itsvFfn)->wTsv)
              {
              (prgtsv+itsvFfn)->fGray = 1;
              (*pcchGray)++;
              }

                     /* FONT SIZE */
        if ((prgtsv+itsvSize)->fGray == 0)
           if (pchp->hps != (prgtsv+itsvSize)->wTsv)
              {
              (prgtsv+itsvSize)->fGray = 1;
              (*pcchGray)++;
              }

}

NEAR SetParaUndef(prgtsv, ppap, pcparaGray)
register TSV    *prgtsv;
register struct PAP    *ppap;
int    *pcparaGray;
{

    /* compare pap to values stored in rgtsv and set undefined
           flags for differing fields of interest.  */
                     /* JUSTIFICATION */
        if ((prgtsv+itsvJust)->fGray == 0)
           if (ppap->jc != (prgtsv+itsvJust)->wTsv)
              {
              (prgtsv+itsvJust)->fGray = 1;
              (*pcparaGray)++;
              }
                     /* LINE SPACING */
        if ((prgtsv+itsvSpacing)->fGray == 0)
           if (ppap->dyaLine != (prgtsv+itsvSpacing)->wTsv)
              {
              (prgtsv+itsvSpacing)->fGray = 1;
              (*pcparaGray)++;
              }
                     /* LEFT INDENT */
        if ((prgtsv+itsvLIndent)->fGray == 0)
           if (ppap->dxaLeft != (prgtsv+itsvLIndent)->wTsv)
              {
              (prgtsv+itsvLIndent)->fGray = 1;
              (*pcparaGray)++;
              }
                     /* FIRST LINE INDENT */
        if ((prgtsv+itsvFIndent)->fGray == 0)
           if (ppap->dxaLeft1 != (prgtsv+itsvFIndent)->wTsv)
              {
              (prgtsv+itsvFIndent)->fGray = 1;
              (*pcparaGray)++;
              }
                     /* RIGHT INDENT */
        if ((prgtsv+itsvRIndent)->fGray == 0)
           if (ppap->dxaRight != (prgtsv+itsvRIndent)->wTsv)
              {
              (prgtsv+itsvRIndent)->fGray = 1;
              (*pcparaGray)++;
              }

}



/* C P  L I M  N O  S P A C E S */
typeCP CpLimNoSpaces(cpFirst, cpLim)
typeCP cpFirst, cpLim;
{
/* Truncate trailing spaces unless only spaces are in sel. */

int cch;
typeCP cpLimOrig;
CHAR rgch[cchMaxSz];

cpLimOrig = cpLim;

FetchRgch(&cch, rgch, docCur, CpMax(cpFirst + cchMaxSz, cpLim) - cchMaxSz,
  cpLim, cchMaxSz);
while (cch-- > 0 && rgch[cch] == chSpace)
    {
    --cpLim;
    }
return cch < 0 ? cpLimOrig : cpLim;
} /* end of CpLimNoSpaces */




NEAR FNoSearchStr(hDlg)
HWND hDlg;
{
CHAR szBuf[255];
HWND hWndFrom = GetActiveWindow();

if (hDlg == hWndFrom || hDlg == (HANDLE)GetWindowWord(hWndFrom, GWW_HWNDPARENT))
    {
    if (GetDlgItemText(hDlg, idiFind, (LPSTR)szBuf, 255) == 0)
        return(TRUE);
    }
return(FALSE);
}




PhonyMenuAccelerator( menu, imi, lpfn )
int menu;
int imi;
FARPROC lpfn;
{
    HMENU hSubmenu = GetSubMenu(vhMenu,menu);

    SetAppMenu( hSubmenu , menu );

    if (FIsMenuItemEnabled( hSubmenu , imi ))
    {
        HiliteMenuItem( hParentWw, vhMenu, menu, MF_BYPOSITION | MF_HILITE );
        (*lpfn) ();
        HiliteMenuItem( hParentWw, vhMenu, menu, MF_BYPOSITION );
    }
}




FIsMenuItemEnabled (HMENU hMenu , int id )
{   /* Find out if a menu item in vhMenu is enabled. */
    return !(GetMenuState(hMenu, id, MF_BYCOMMAND ) & (MF_DISABLED|MF_GRAYED));
}


int FAR PASCAL NewFont(HWND hwnd);

void MmwCommand(hWnd, wParam, hWndCtl, codeCtl)
HWND hWnd;
WORD wParam;
HWND hWndCtl;
WORD codeCtl;
{
#ifdef INEFFLOCKDOWN
extern FARPROC lpDialogHelp;
extern FARPROC lpDialogGoTo;
extern FARPROC lpDialogCharFormats;
extern FARPROC lpDialogParaFormats;
extern FARPROC lpDialogTabs;
extern FARPROC lpDialogDivision;
extern FARPROC lpDialogPrinterSetup;
#else
extern BOOL far PASCAL DialogPrinterSetup(HWND, unsigned, WORD, LONG);
extern BOOL far PASCAL DialogHelp(HWND, unsigned, WORD, LONG);
extern BOOL far PASCAL DialogGoTo(HWND, unsigned, WORD, LONG);
extern BOOL far PASCAL DialogCharFormats(HWND, unsigned, WORD, LONG);
extern BOOL far PASCAL DialogParaFormats(HWND, unsigned, WORD, LONG);
extern BOOL far PASCAL DialogTabs(HWND, unsigned, WORD, LONG);
extern BOOL far PASCAL DialogDivision(HWND, unsigned, WORD, LONG);
#endif
extern int vfPictSel;
extern CHAR *vpDlgBuf;

int DialogOk = 0;
int fQuit = fFalse;

    if (wParam & fMenuItem)
        {
        switch (wParam & MENUMASK)
            {
        case FILEMENU:
            switch(wParam)
                {
            case imiNew:
                fnNewFile();
                break;
            case imiOpen:
                fnOpenFile((LPSTR)NULL);
                break;
            case imiSave:
#if defined(OLE)
                if (CloseUnfinishedObjects(TRUE) == FALSE)
                    return;
#endif
                fnSave();
                break;
            case imiSaveAs:
#if defined(OLE)
                if (CloseUnfinishedObjects(TRUE) == FALSE)
                    return;
#endif
                fnSaveAs();
                break;
            case imiPrint:
                fnPrPrinter();
                break;
            case imiPrintSetup:
                /* Bring up the Change Printer dialog box. */
                PrinterSetupDlg(FALSE);
                break;
            case imiRepaginate:
                fnRepaginate();
                break;
            case imiQuit:
                fnQuit(hWnd);
                fQuit = fTrue;
                break;
            default:
                break;
                }
            break;

        case EDITMENU:
            switch(wParam)
                {
            case imiUndo:
                CmdUndo();
                break;
            case imiCut:
                fnCutEdit();
                break;
            case imiCopy:
                fnCopyEdit();
                break;
            case imiPaste:
#if defined(OLE)
                vbObjLinkOnly = FALSE;
#endif
                fnPasteEdit();
                break;
#if defined(OLE)
            case imiPasteSpecial:
                vbObjLinkOnly = FALSE;
                fnObjPasteSpecial();
                break;
            case imiPasteLink:
                vbObjLinkOnly = TRUE;
                fnPasteEdit();
                break;
            case imiInsertNew:
                fnObjInsertNew();
            break;
#endif
            case imiMovePicture:
                fnMovePicture();
                break;
            case imiSizePicture:
                fnSizePicture();
                break;
#if defined(OLE)
            case imiProperties:
                fnObjProperties();
            break;
#endif
            default:
                break;
                }
            break;

#if defined(OLE)
        case VERBMENU:
            fnObjDoVerbs(wParam);
        break;
#endif

        case FINDMENU:
            if (wParam != imiGoTo && wParam != imiFindAgain)
                StartLongOp();
            switch(wParam)
                {
            case imiFind:
                fnFindText();
                break;
            case imiFindAgain:
                fnFindAgain();
                break;
            case imiChange:
                fnReplaceText();
                break;
            case imiGoTo:
                {
#ifndef INEFFLOCKDOWN
                FARPROC lpDialogGoTo = MakeProcInstance(DialogGoTo, hMmwModInstance);
                if (!lpDialogGoTo)
                    goto LNotEnufMem;
#endif
                DialogOk = OurDialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgGoTo),
                  hParentWw, lpDialogGoTo);
#ifndef INEFFLOCKDOWN
                FreeProcInstance(lpDialogGoTo);
#endif

/* the following block has been commentted out because
   the corresponding file(DISP.C) doesn't inlcude MmwCatSt
   routine anymore */

#if  0
            {
            extern void far MmwCatSt( HWND, BOOL );
                MmwCatSt(hParentWw, FALSE);
            }
#endif

                break;
                }
            default:
                break;
                }
            break;

        case CHARMENU:
            if (wParam != imiCharFormats)
                StartLongOp();
            {
            /* rgtsv gets attributes and gray flags from CHP */
            TSV rgtsv[itsvchMax];
            CHAR rgbDlgBuf[sizeof(BOOL)];
               void NEAR fnCharSelectFont(int);

            /* GetRgtsvChpSel() fills up rgtsv */
            GetRgtsvChpSel(rgtsv);
            switch(wParam)
                {
            case imiCharNormal:
                ApplyCLooks(0, sprmCPlain, 0);
                break;
            case imiBold:
                ApplyCLooks(0, sprmCBold, (rgtsv[itsvBold].fGray != 0) ? TRUE :
                  !rgtsv[itsvBold].wTsv);
                break;
            case imiItalic:
                ApplyCLooks(0, sprmCItalic, (rgtsv[itsvItalic].fGray != 0) ?
                  TRUE : !rgtsv[itsvItalic].wTsv);
                break;
            case imiUnderline:
                ApplyCLooks(0, sprmCUline, (rgtsv[itsvUline].fGray != 0) ? TRUE
                  : !rgtsv[itsvUline].wTsv);
                break;
            case imiSuper:
                /* Note that the value stored in rgtsv[itsvPosition].wTsv is
                really a signed integer, so we can just check for 0, > 0, and <
                0. */
                ApplyCLooks(0, sprmCPos, !(rgtsv[itsvPosition].fGray == 0 &&
                  (int)rgtsv[itsvPosition].wTsv > 0) ? ypSubSuper : 0);
                break;
            case imiSub:
                ApplyCLooks(0, sprmCPos, !(rgtsv[itsvPosition].fGray == 0 &&
                  (int)rgtsv[itsvPosition].wTsv < 0) ? -ypSubSuper : 0);
                break;
#if 0
            case imiFont1:
                fnCharSelectFont(0);
                break;
            case imiFont2:
                fnCharSelectFont(1);
                break;
            case imiFont3:
                fnCharSelectFont(2);
                break;
#endif
            case imiSmFont:
                if (CanChangeFont(-1))
                {
                    ApplyCLooks(0, sprmCChgHps, -1);
                    vfSeeSel = TRUE;
                }
                break;
            case imiLgFont:
                if (CanChangeFont(1))
                {
                    ApplyCLooks(0, sprmCChgHps, 1);
                    vfSeeSel = TRUE;
                }
                break;
            case imiCharFormats:
                {
#if 0

#ifndef INEFFLOCKDOWN
                FARPROC lpDialogCharFormats = MakeProcInstance(DialogCharFormats, hMmwModInstance);
                if (!lpDialogCharFormats)
                    goto LNotEnufMem;
#endif
                vpDlgBuf = &rgbDlgBuf[0];
                DialogOk = OurDialogBox(hMmwModInstance,
                                     MAKEINTRESOURCE(dlgCharFormats),
                                     hParentWw, lpDialogCharFormats);
#ifndef INEFFLOCKDOWN
                FreeProcInstance(lpDialogCharFormats);
#endif

#else
        DialogOk = NewFont(hParentWw);
#endif

break;
                }
#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IME3.1J
            case imiImeHidden:
                ChangeImeConversionMode();
                break;
#endif
            default:
                break;
                }

#if defined(JAPAN) & defined(DBCS_IME) //Win3.1J
            SetImeFont(vhWnd);
#endif
  
            break;
            }

        case PARAMENU:
            switch(wParam)
                {
            case imiParaNormal:
                ApplyLooksParaS(0, sprmPNormal, 0);
                if (vfPictSel)
                    {
                    CmdUnscalePic();
                    }
                break;
            case imiLeft:
                ApplyLooksParaS(0, sprmPJc, jcLeft);
                break;
            case imiCenter:
                ApplyLooksParaS(0, sprmPJc, jcCenter);
                break;
            case imiRight:
                ApplyLooksParaS(0, sprmPJc, jcRight);
                break;
            case imiJustified:
                ApplyLooksParaS(0, sprmPJc, jcBoth);
                break;
            case imiSingleSpace:
                ApplyLooksPara(0, sprmPDyaLine, czaLine);
                break;
            case imiOneandhalfSpace:
                ApplyLooksPara(0, sprmPDyaLine, czaLine * 3 / 2);
                break;
            case imiDoubleSpace:
                ApplyLooksPara(0, sprmPDyaLine, czaLine * 2);
                break;
            case imiParaFormats:
                {
#ifndef INEFFLOCKDOWN
                FARPROC lpDialogParaFormats = MakeProcInstance(DialogParaFormats, hMmwModInstance);
                if (!lpDialogParaFormats)
                    goto LNotEnufMem;
#endif
                DialogOk = OurDialogBox(hMmwModInstance,
                                     MAKEINTRESOURCE(dlgParaFormats),
                                     hParentWw, lpDialogParaFormats);
#ifndef INEFFLOCKDOWN
                FreeProcInstance(lpDialogParaFormats);
#endif
                break;
                }
            default:
                break;
                }
            break;

        case DOCUMENU:
            switch(wParam)
                {
            case imiFooter:
            case imiHeader:
                fnEditRunning(wParam);
                break;
            case imiShowRuler:
                fnShowRuler();
                break;
            case imiTabs:
                {
#ifndef INEFFLOCKDOWN
                FARPROC lpDialogTabs = MakeProcInstance(DialogTabs, hMmwModInstance);
                if (!lpDialogTabs)
                    goto LNotEnufMem;
#endif
                DialogOk = OurDialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgTabs),
                  hParentWw, lpDialogTabs);
#ifndef INEFFLOCKDOWN
                FreeProcInstance(lpDialogTabs);
#endif
                break;
                }
            case imiDivFormats:
                {
#ifndef INEFFLOCKDOWN
                FARPROC lpDialogDivision = MakeProcInstance(DialogDivision, hMmwModInstance);
                if (!lpDialogDivision)
                     goto LNotEnufMem;
#endif
                DialogOk = OurDialogBox(hMmwModInstance,
                                     MAKEINTRESOURCE(dlgDivision),
                  hParentWw, lpDialogDivision);
#ifndef INEFFLOCKDOWN
                FreeProcInstance(lpDialogDivision);
#endif
                break;
                }
            default:
                break;
                }
            break;

        case HELPMENU:
            {
            int wHelpCode;
            extern WORD wWinVer;
            CHAR sz[ cchMaxFile ];
LDefaultHelp:
            PchFillPchId( sz, IDSTRHELPF, sizeof(sz) );
            switch(wParam)
                {
                case imiIndex:
                    WinHelp(hParentWw, (LPSTR)sz, HELP_INDEX, NULL);
                    break;
                case imiHelpSearch:
                    WinHelp(hParentWw, (LPSTR)sz, HELP_PARTIALKEY, (DWORD)(LPSTR)"");
                    break;
                case imiUsingHelp:
                    WinHelp(hParentWw, (LPSTR)NULL, HELP_HELPONHELP, NULL);
                    break;
                default:
                case imiAbout:
                    if (((wWinVer & 0xFF) >= 3) && ((wWinVer & 0xFF00) >= 0x0A00))
                    {
                        extern CHAR         szMw_icon[];
                        extern  CHAR    szAppName[];
                        ShellAbout(hParentWw, szAppName, "",
                            LoadIcon( hMmwModInstance, (LPSTR)szMw_icon ));
                    }
                    break;
                }
            break;
            }

        default:
            if (wParam == imiHelp)
                {
#ifdef WIN30
                wParam = imiIndex;  /* For all Win3 applets, pressing F1
                                       should bring up the Help Index */
#endif
                goto LDefaultHelp;
                }
            }
        if (DialogOk == -1)
            {
LNotEnufMem:
#ifdef WIN30
            WinFailure();
#else
            Error(IDPMTNoMemory);
#endif
            }
        }

    if (!fQuit)
        UpdateInvalid();   /* To be sure we update the area behind dialogs */
}




#if 0
void NEAR fnCharSelectFont(iffn)
/* select the specified font from the three listed on char dropdown */

int iffn;
    {
    struct FFN *pffn;
    int ftc;

    extern CHAR rgffnFontMenu[3][ibFfnMax];
    extern int            docCur;

    pffn = (struct FFN *)rgffnFontMenu[iffn];

    ftc = FtcChkDocFfn(docCur, pffn);
    if (ftc != ftcNil)
        ApplyCLooks(0, sprmCFtc, ftc);
    vfSeeSel = TRUE;
    }
#endif

#ifdef JAPAN //Win3.1J
int KanjiFtc = ftcNil;

GetKanjiFtc(pchp)
struct CHP *pchp;
{
    int ftc;
    int CharSet;

    CharSet = GetCharSetFromChp(pchp);

    if (NATIVE_CHARSET == CharSet) {
		KanjiFtc = GetFtcFromPchp(pchp);
        return(ftcNil);
    } else {
        if(KanjiFtc == ftcNil)
            ftc = SearchKanjiFtc(docCur);    //Get set New szFfn chs
        else
            ftc = KanjiFtc;
        return(ftc);
    }
}

GetCharSetFromChp(pchp)
struct CHP *pchp;
{
    TSV rgtsv[itsvchMax];  /* gets attributes and gray flags from CHP, PAP */
    struct FFN **hffn;

    GetHffn (pchp,rgtsv);  /* load up handle for font name */
    hffn = (struct FFN **)rgtsv[itsvFfn].wTsv;
    return((*hffn)->chs);
}

extern CHAR saveKanjiDefFfn[ibFfnMax];

SearchKanjiFtc(doc)
/* looks for described font in docs ffntb - returns ftcNil if not found */
int doc;
{
    int ftc;
    int iffn, iffnMac;
    struct FFNTB **hffntb;
    struct FFN ***mpftchffn;
    struct FFN *pffn;

    ftc = ftcNil;
    hffntb = HffntbGet(doc);
    if (hffntb != 0) {
        mpftchffn = (*hffntb)->mpftchffn;
        iffnMac = (*hffntb)->iffnMac;
        for (iffn = 0; iffn < iffnMac; iffn++) {
            if ( (*mpftchffn[iffn])->chs == NATIVE_CHARSET &&
                 (*mpftchffn[iffn])->szFfn[0] != chGhost)
                return(iffn);
        }
    }

    pffn = (struct FFN *)saveKanjiDefFfn;

    ftc = FtcChkDocFfn(doc, pffn);

    if (ftc != ftcNil)
        return(ftc);

    return(ftcNil);
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\mdoc.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/


#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOOPENFILE
#define NORESOURCE
#include <windows.h>

#include "mw.h"
#include "winddefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "dispdefs.h"
#include "docdefs.h"
#include "debug.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef PENWIN
#define WM_PENWINFIRST 0x0380   // Remove when #define WIN31

#include <penwin.h>
int vcFakeMessage = 0;

extern HCURSOR         vhcPen;                 /* handle to pen cursor */
extern int (FAR PASCAL *lpfnProcessWriting)(HWND, LPRC);
extern VOID (FAR PASCAL *lpfnPostVirtualKeyEvent)(WORD, BOOL);
extern VOID (FAR PASCAL *lpfnTPtoDP)(LPPOINT, int);
extern BOOL (FAR PASCAL *lpfnCorrectWriting)(HWND, LPSTR, int, LPRC, DWORD, DWORD);
extern BOOL (FAR PASCAL *lpfnSymbolToCharacter)(LPSYV, int, LPSTR, LPINT);


VOID NEAR PASCAL PostCharacter(WORD wch);
VOID NEAR PASCAL SendVirtKeyShift(WORD wVk, BYTE bFlags);
VOID NEAR PASCAL SetSelection(HWND hWnd, LPPOINT lpPtFirst, LPPOINT lpPtLast, WORD wParam);
int NEAR PASCAL WGetClipboardText(HWND hwndOwner, LPSTR lpsz, int cbSzSize);
VOID NEAR PASCAL ClearAppQueue(VOID);

#define VKB_SHIFT 0x01
#define VKB_CTRL  0x02
#define VKB_ALT   0x04
#endif

extern HWND             vhWnd;
extern HCURSOR          vhcArrow;
extern HCURSOR          vhcIBeam;
extern HCURSOR          vhcBarCur;
extern struct WWD       rgwwd[];
extern struct WWD       *pwwdCur;
extern HANDLE           hMmwModInstance; /* handle to own module instance */
extern int              vfShiftKey;
extern int              vfCommandKey;
extern int              vfOptionKey;
extern int              vfDoubleClick;
extern struct SEL       selCur;
extern long             rgbBkgrnd;
extern long             rgbText;
extern HBRUSH           hbrBkgrnd;
extern long             ropErase;

int                     vfCancelPictMove = FALSE;
BOOL                    vfEraseWw = FALSE;

long FAR PASCAL MdocWndProc(HWND, unsigned, WORD, LONG);
void MdocCreate(HWND, LONG);
void MdocSize(HWND, int, int, WORD);
void MdocGetFocus(HWND, HWND);
void MdocLoseFocus(HWND, HWND);
void MdocMouse(HWND, unsigned, WORD, POINT);
void MdocTimer(HWND, WORD);

#if defined(JAPAN) & defined(DBCS_IME)
#include <ime.h>
extern  BOOL    bGetFocus;
extern  BOOL	bImeFontEx;
//  for Non_PeekMessage mode in 'FImportantMsgPresent()'. [yutakan]
BOOL    bImeCnvOpen = FALSE;
BOOL	bSendFont = FALSE;
BOOL    GetIMEOpen(HWND);
#endif

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IR_UNDETERMINE
extern typeCP selUncpFirst;
extern typeCP selUncpLim;
extern int    vfImeHidden;   /*ImeHidden Mode flag*/
#endif




#ifdef PENWIN
// Helper routines to get events into system.  Would be better (more efficient) if
// could just call routines to set selection, copy, etc,
// but this is the easiest way without touching any internals

// Minics penwin internal routine, exception messages are posted instead
// of sent since Write does a lot of peek ahead

VOID NEAR PASCAL SetSelection(HWND hWnd,
    LPPOINT lpPtFirst, LPPOINT lpPtLast, WORD wParam)
    {
    static LONG lFirst = 0L;

    if (lpPtFirst)
        {
        (*lpfnTPtoDP)(lpPtFirst, 1);
        ScreenToClient(hWnd, lpPtFirst);
        }
    if (lpPtLast != NULL)
        {
        (*lpfnTPtoDP)(lpPtLast, 1);
        ScreenToClient(hWnd, lpPtLast);
        }

    if (lpPtFirst)
        {
        lFirst = MAKELONG(lpPtFirst->x, lpPtFirst->y);
        PostMessage(hWnd, WM_LBUTTONDOWN, wParam, lFirst);
        if (lpPtLast)
            {
            LONG lLast = MAKELONG(lpPtLast->x, lpPtLast->y);

            PostMessage(hWnd, WM_MOUSEMOVE, wParam, lLast);
            vcFakeMessage++;
            PostMessage(hWnd, WM_LBUTTONUP, wParam, lLast);
            }
        else
            {
            PostMessage(hWnd, WM_LBUTTONUP, wParam, lFirst);
            vcFakeMessage++;
            }
        }
    else    // doubleclick
        {
        PostMessage(hWnd, WM_LBUTTONDBLCLK, wParam, lFirst);
        vcFakeMessage++;
        PostMessage(hWnd, WM_LBUTTONUP, wParam, lFirst);
        vcFakeMessage++;
        }
    }




/*
PURPOSE: Map a symbol value to a set of virtual keystrokes and then
    send the virtual keystrokes.
    TODO: Add real mapping of symbol values instead of assuming ANSI values
        Right now, this routine is worthless
RETURN:
GLOBALS:
CONDITIONS: Kanji is not handled now, but could be.
*/
VOID NEAR PASCAL PostCharacter(WORD wch)
    {
    int iVk = VkKeyScan(LOBYTE(wch));
    WORD wVk = (WORD)LOBYTE(iVk);
    char bFl = HIBYTE(iVk);

    if ((wVk != -1))
        SendVirtKeyShift(wVk, bFl);
    }


/*--------------------------------------------------------------------------
PURPOSE: Send an optionally shifted key sequence as system events
RETURN: nothing
GLOBALS:
CONDITIONS: see flags in mspen.h
*/
VOID NEAR PASCAL SendVirtKeyShift(WORD wVk, BYTE bFlags)
    {
    // send DOWN events:
    if (bFlags & VKB_SHIFT)
        (*lpfnPostVirtualKeyEvent)(VK_SHIFT, fFalse);
    if (bFlags & VKB_CTRL)
        (*lpfnPostVirtualKeyEvent)(VK_CONTROL, fFalse);
    if (bFlags & VKB_ALT)
        (*lpfnPostVirtualKeyEvent)(VK_MENU, fFalse);
    (*lpfnPostVirtualKeyEvent)(wVk, fFalse);

    // send UP events (in opposite order):
    (*lpfnPostVirtualKeyEvent)(wVk, fTrue);
    if (bFlags & VKB_ALT)
        (*lpfnPostVirtualKeyEvent)(VK_MENU, fTrue);
    if (bFlags & VKB_CTRL)
        (*lpfnPostVirtualKeyEvent)(VK_CONTROL, fTrue);
    if (bFlags & VKB_SHIFT)
        (*lpfnPostVirtualKeyEvent)(VK_SHIFT, fTrue);
    }


/* Fill buffer with contents of clipboard
*/
int NEAR PASCAL WGetClipboardText(HWND hwndOwner, LPSTR lpsz, int cbSzSize)
    {
    HANDLE hClip;
    int wLen = 0;

    OpenClipboard(hwndOwner);
    if (hClip = GetClipboardData(CF_TEXT))
        {
        LPSTR lpszClip = (LPSTR)GlobalLock(hClip);

        if (lpsz && cbSzSize > 0)
            {
            wLen = lstrlen(lpszClip);
            if (wLen > cbSzSize)
                lpszClip[cbSzSize-1] = 0;
            lstrcpy(lpsz, lpszClip);
            }
        GlobalUnlock(hClip);
        }
#ifdef KKBUGFIX
    else
        *lpsz = '\0';
#endif
    CloseClipboard();
    return wLen;
    }


/*--------------------------------------------------------------------------
PURPOSE: Dispatches any messages currently pending in our queue
RETURN: nothing
GLOBALS:
CONDITIONS:
*/
VOID NEAR PASCAL ClearAppQueue(VOID)
    {
    MSG msg;

    while (PeekMessage(&msg, (HWND)NULL, NULL, NULL, PM_REMOVE))
        {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
    }

#endif



static RECT rSaveInv;

long FAR PASCAL MdocWndProc(hWnd, message, wParam, lParam)
HWND      hWnd;
unsigned  message;
WORD      wParam;
LONG      lParam;
{
extern int vfCloseFilesInDialog;
extern BOOL fPrinting;
long lReturn=0L;
#ifdef PENWIN
static cCharSent;
#endif

/*  if IME Window mode is MCW_HIDDEN then IME don't send IR_OPENCONVERT.
    so I add this routine. */ 

#ifdef PENWIN
 if (message < WM_CUT || message == WM_RCRESULT)
#else
 if (message < WM_CUT )
#endif

    {
    switch (message)
        {
        default:
            goto DefaultProc;

        /* For each of following mouse window messages, wParam contains
        ** bits indicating whether or not various virtual keys are down,
        ** and lParam is a POINT containing the mouse coordinates.   The
        ** keydown bits of wParam are:  MK_LBUTTON (set if Left Button is
        ** down); MK_RBUTTON (set if Right Button is down); MK_SHIFT (set
        ** if Shift Key is down); MK_ALTERNATE (set if Alt Key is down);
        ** and MK_CONTROL (set if Control Key is down). */

        case WM_LBUTTONDBLCLK:
#ifdef PENWIN
        if (vcFakeMessage > 0)
            vcFakeMessage--;
        // fall through
#endif
        case WM_LBUTTONUP:
        case WM_MOUSEMOVE:
        case WM_LBUTTONDOWN:
            MdocMouse(hWnd, message, wParam, MAKEPOINT(lParam));
            break;



#ifdef PENWIN
        case WM_RCRESULT:
            {
            LPRCRESULT lpr = (LPRCRESULT)lParam;
            LPPOINT lpPntHot;
            LPPOINT lpPntHot2;

            if( (lpr->wResultsType&(RCRT_ALREADYPROCESSED|RCRT_NOSYMBOLMATCH))!=0 || lpr->lpsyv==NULL
                || lpr->cSyv == 0)
                return( FALSE );

            if (lpr->wResultsType&RCRT_GESTURE)
                {
                SYV syv = *(lpr->lpsyv);

                vcFakeMessage = 0;

                lpPntHot = lpr->syg.rgpntHotSpots;
                lpPntHot2 = lpr->syg.cHotSpot > 1 ? lpr->syg.rgpntHotSpots + 1: NULL;

                switch ( LOWORD(syv))
                    {
                case LOWORD( SYV_EXTENDSELECT ):
                    SetSelection(hWnd, lpPntHot, NULL, MK_SHIFT);   // extend sel
                    break;

                case LOWORD( SYV_CLEARWORD ):       // dbl click & drag
                    if (lpPntHot2)
                        {
                        SetSelection(hWnd, lpPntHot, NULL, 0);
                        SetSelection(hWnd, NULL, NULL, 0);  // dblclick selects word
                        }
                    SendVirtKeyShift(VK_DELETE, 0);
                    break;

                case LOWORD( SYV_COPY):
                case LOWORD( SYV_CLEAR ):
                case LOWORD( SYV_CUT ):
                    if ( selCur.cpFirst == selCur.cpLim && (lpr->wResultsType&RCRT_GESTURETRANSLATED)==0)
                        {
                        SetSelection(hWnd, lpPntHot, NULL, 0);
                        if (syv != SYV_CLEAR)
                            SetSelection(hWnd, NULL, NULL, 0);  // dblclick
                        }

                    switch ( LOWORD(syv))
                        {
                        case LOWORD( SYV_COPY):
                            SendVirtKeyShift(VK_INSERT, VKB_CTRL);
                            break;

                        case LOWORD( SYV_CLEAR ):
                            SendVirtKeyShift(VK_DELETE, 0);
                            break;

                        case LOWORD( SYV_CUT ):
                            SendVirtKeyShift(VK_DELETE, VKB_SHIFT);
                            break;
                        }

                    break;


                case LOWORD( SYV_PASTE ):
                    if ((lpr->wResultsType&RCRT_GESTURETRANSLATED)==0)
                        SetSelection(hWnd, lpPntHot, NULL, 0);
                    SendVirtKeyShift(VK_INSERT, VKB_SHIFT);
                    break;

                case LOWORD( SYV_UNDO):
                    SendVirtKeyShift(VK_BACK, VKB_ALT);
                    break;

                case LOWORD(SYV_BACKSPACE):
                case LOWORD(SYV_SPACE):
                case LOWORD(SYV_RETURN):
                case LOWORD(SYV_TAB):
                    SetSelection(hWnd, lpPntHot, NULL, 0);
                    PostCharacter(LOWORD(*(lpr->lpsyv))&0x00ff);
                    break;

#if defined(KKBUGFIX) && !defined(KOREA)
                case LOWORD( SYV_CORRECT ):
                case LOWORD( SYV_KKCONVERT ):
                    {
                    WORD wLen;
                    HANDLE hMem = NULL;
                    LPSTR lpstr;
                    LPSTR lpsz;
                    BOOL fDoubleClickSent = fFalse;
                    DWORD dwFlags = NULL;
                    DWORD dwReserved = NULL;
                    POINT pt;
                    extern int vxpCursLine;
                    extern int vypCursLine;
    #define cbCorrectMax 128

                    // Strategy: If no selection, send in a double click to
                    // select a word.  Then copy selection to clipboard
                    // read off of clipboard.  Call CorrectWriting, and
                    // but changed text in clipboard and then paste
                    // from clipboard.
                    if ( selCur.cpFirst == selCur.cpLim )
                        {
                        if (LOWORD(syv) == LOWORD(SYV_KKCONVERT))
                            {
                            SetSelection(hWnd, lpPntHot, lpPntHot2, 0);
                            }
                        else
                            {
                            // No selection so send double click
                            SetSelection(hWnd, lpPntHot, NULL, 0);  // set caret
                            SetSelection(hWnd, NULL, NULL, 0);  // dblclick
                            }
                        fDoubleClickSent = fTrue;
                        ClearAppQueue();
                        }

                    SendMessage(hWnd, WM_COPY, 0, 0L);

                    hMem = GlobalAlloc(GMEM_MOVEABLE, (DWORD)cbCorrectMax);
                    if (hMem == NULL || (lpsz = (LPSTR)GlobalLock(hMem)) == NULL)
                        return 1;   // Just bag out for now: should add error message
                    wLen = WGetClipboardText(hWnd, lpsz, cbCorrectMax);
                    if (LOWORD(syv) == LOWORD(SYV_KKCONVERT) && wLen == 0)
                        {
                        beep();
                        return 1;
                        }
                    if (IsClipboardFormatAvailable(CF_TEXT) || wLen == 0)
                        {
                        if (wLen < cbCorrectMax)
                            {
                            if (LOWORD(syv) == LOWORD(SYV_KKCONVERT))
                                {
                                dwFlags = CWR_KKCONVERT | CWR_SIMPLE;
                                pt.x = vxpCursLine;
                                pt.y = vypCursLine;
                                ClientToScreen(hWnd, &pt);
                                dwReserved = MAKELONG(pt.x, pt.y);
                                }
                            // Only bring up corrector if selection wasn't too big
                            if ((*lpfnCorrectWriting)(hWnd, lpsz, cbCorrectMax, NULL, dwFlags, dwReserved))
                                {
                                if (*lpsz==0)
                                    {
                                    // User deleted all text in correction
                                    SendVirtKeyShift(VK_DELETE, 0);
                                    }
                                else if (LOWORD(syv) == LOWORD(SYV_CORRECT))
                                    {
                                    GlobalUnlock(hMem);
                                    OpenClipboard(GetParent(hWnd)); // Use parent as
                                            // owner to circumvent write's short check
                                            // cuts if it is owner of clipboard
                                    EmptyClipboard();
                                    SetClipboardData(CF_TEXT, hMem);
                                    CloseClipboard();
                                    hMem = NULL;
                                    SendMessage(hWnd, WM_PASTE, 0, 0L);
                                    UpdateWindow(hWnd);
                                    }
                                }
                            else if (fDoubleClickSent)
                                {
                                // Need to clear bogus selection.  Just send in a tap.
                                SetSelection(hWnd, lpPntHot, NULL, 0);
                                }
                            }

                        }
                    if (hMem)   // may never have been alloc'd if user canceled
                        {
                        GlobalUnlock(hMem);
                        GlobalFree(hMem);
                        }
                    }
                    break;
#else		// KKBUGFIX
                case LOWORD( SYV_CORRECT ):
                    {
                    WORD wLen;
                    HANDLE hMem = NULL;
                    LPSTR lpstr;
                    LPSTR lpsz;
                    BOOL fDoubleClickSent = fFalse;
    #define cbCorrectMax 128

                    // Strategy: If no selection, send in a double click to
                    // select a word.  Then copy selection to clipboard
                    // read off of clipboard.  Call CorrectWriting, and
                    // but changed text in clipboard and then paste
                    // from clipboard.
                    if ( selCur.cpFirst == selCur.cpLim )
                        {
                        // No selection so send double click
                        SetSelection(hWnd, lpPntHot, NULL, 0);  // set caret
                        SetSelection(hWnd, NULL, NULL, 0);  // dblclick
                        fDoubleClickSent = fTrue;
                        ClearAppQueue();
                        }

                    SendMessage(hWnd, WM_COPY, 0, 0L);

                    if (IsClipboardFormatAvailable(CF_TEXT))
                        {
                        hMem = GlobalAlloc(GMEM_MOVEABLE, (DWORD)cbCorrectMax);
                        if (hMem == NULL || (lpsz = (LPSTR)GlobalLock(hMem)) == NULL)
                            return 1;   // Just bag out for now: should add error message
                        if (WGetClipboardText(hWnd, lpsz, cbCorrectMax) < cbCorrectMax)
                            {
                            // Only bring up corrector if selection wasn't too big
                            if ((*lpfnCorrectWriting)(hWnd, lpsz, cbCorrectMax, NULL, 0, 0))
                                {
                                if (*lpsz==0)
                                    {
                                    // User deleted all text in correction
                                    SendVirtKeyShift(VK_DELETE, 0);
                                    }
                                else
                                    {
                                    GlobalUnlock(hMem);
                                    OpenClipboard(GetParent(hWnd)); // Use parent as
                                            // owner to circumvent write's short check
                                            // cuts if it is owner of clipboard
                                    EmptyClipboard();
                                    SetClipboardData(CF_TEXT, hMem);
                                    CloseClipboard();
                                    hMem = NULL;
                                    SendMessage(hWnd, WM_PASTE, 0, 0L);
                                    UpdateWindow(hWnd);
                                    }
                                }
                            else if (fDoubleClickSent)
                                {
                                // Need to clear bogus selection.  Just send in a tap.
                                SetSelection(hWnd, lpPntHot, NULL, 0);
                                }


                            }

                        if (hMem)   // may never have been alloc'd if user canceled
                            {
                            GlobalUnlock(hMem);
                            GlobalFree(hMem);
                            }
                        }
                    }
                    break;
#endif		// KKBUGFIX


                default:
                    return( FALSE );
                    }
                }
            else // Not a gesture,see if normal characters
                {
#define cbTempBufferSize 128
                char rgch[cbTempBufferSize+2];
                int cb=0;
                int cbT;
                LPSTR lpstr = (LPSTR)lpr->lpsyv;
                typeCP  cp=cp0;
                LPSYV lpsyv;
                LPSYV lpsyvEnd;

                extern int              docScrap;
                extern int              vfScrapIsPic;
                extern struct PAP       *vppapNormal;
                extern struct CHP       vchpNormal;

                vfScrapIsPic = fFalse;
                ClobberDoc( docScrap, docNil, cp0, cp0 );

                // Replace CR with LF's  These are treated as EOLs
                // by CchReadLineExt.  Then, before inserting
                // buffer, change all LFs to CR LFs as write expects
                // Will work for Kanji

                for (lpsyv=lpr->lpsyv, lpsyvEnd=&lpr->lpsyv[lpr->cSyv+1];
                        lpsyv<lpsyvEnd; lpsyv++)
                    {
                    if (*lpsyv == SyvCharacterToSymbol(0xD))
                        {
                        *lpstr++ = 0xd;
                        *lpstr++ = 0xa;
                        cb+=2;
                        }
                    else
                        {
                        (*lpfnSymbolToCharacter)(lpsyv, 1, lpstr, &cbT);
                        lpstr += cbT;
                        cb += cbT;
                        }
                    }
                lpstr = (LPSTR)lpr->lpsyv;
                Assert(cb>0 && lpstr[cb-1] == 0);

                // This code is abstracted for FReadExtScrap where it copies
                // text from clipboard into the scrap document.  We do similar.
                // copy result into scrap and then insert scrap with
                // no formating.
                while (cb > 0)
                    {
                    struct PAP *ppap=NULL;
                    int fEol;
                    unsigned cch=min(cb, cbTempBufferSize);

                    if ((cch = CchReadLineExt((LPCH) lpstr, cch, rgch, &fEol))==0)
                            /* Reached terminator */
                        break;

                    if (fEol)
                        ppap = vppapNormal;

                    InsertRgch(docScrap, cp, rgch, cch, &vchpNormal, ppap);

                    cb -= cch;
                    cp += (typeCP) cch;
                    lpstr += cch;
                    }

                CmdInsScrap(fTrue);
                }
            }
        return TRUE;

#endif  // PENWIN

#if defined(OLE)
        case WM_DROPFILES:
            /* We got dropped on, so bring ourselves to the top */
            BringWindowToTop(hParentWw);
            ObjGetDrop(wParam,FALSE);
        break;
#endif

        case WM_TIMER:
            /* Timer message.  wParam contains the timer ID value */
#if defined(JAPAN) & defined(DBCS_IME) //01/19/93
			if(bSendFont == TRUE) {
                SetImeFont(hWnd);
				bSendFont = FALSE;
			}

			if(bImeCnvOpen == TRUE) {	//03/08/93 #4687 T-HIROYN
	            if(FALSE == GetIMEOpen(hWnd))
		            bImeCnvOpen = FALSE;
			}
#endif
            MdocTimer(hWnd, wParam);
            break;

        case WM_CREATE:
            /* Window's being created; lParam contains lpParam field
            ** passed to CreateWindow */
            SetRectEmpty(&rSaveInv);
            MdocCreate(hWnd, lParam);

#if defined(JAPAN) & defined(DBCS_IME) //IME3.1J
			bImeFontEx = FALSE;
#if defined(IME_HIDDEN)
            vfImeHidden = 0;
#endif
            if(TRUE == GetIMEVersioOk(hWnd)) {
			    //IME_SETCONVERSIONFONTEX use OK ?
				if(TRUE == GetIMESupportFontEx(hWnd))
					bImeFontEx = TRUE;
#if defined(IME_HIDDEN)
                vfImeHidden = 1;
#endif
			}
			SetFocus(hWnd); //03/29/93 after TestWordCnv (INITMMW.C)
							// WM_SETFOCUS dose not come.
#endif
            break;

        case WM_SIZE:
            /* Window's size is changing.  lParam contains the height
            ** and width, in the low and high words, respectively.
            ** wParam contains SIZENORMAL for "normal" size changes,
            ** SIZEICONIC when the window is being made iconic, and
            ** SIZEFULLSCREEN when the window is being made full screen. */
            MdocSize(hWnd, LOWORD(lParam), HIWORD(lParam), wParam);
            break;

        case WM_PAINT:
#if defined(OLE)
            if (nBlocking || fPrinting)
            // this'll reduce async problems
            {
                PAINTSTRUCT Paint;
                RECT rTmp=rSaveInv;

                BeginPaint(hWnd,&Paint);
                UnionRect(&rSaveInv,&rTmp,&Paint.rcPaint);
                EndPaint(hWnd,&Paint);
                break;
            }
#endif
            /* Time for the window to draw itself. */
            UpdateInvalid();
            UpdateDisplay( FALSE );

            break;

        case WM_SETFOCUS:
            /* The window is getting the focus.  wParam contains the window
            ** handle of the window that previously had the focus. */

#if defined(JAPAN) & defined(DBCS_IME)

//  If we're getting input focus, we have to get current status of IME convert
// window, and initialize 'bImeCnvOpen'.    [yutakan:07/15/91]
//
#if 1 //#3221 01/25/93
            if(TRUE == GetIMEOpen(hWnd)) {
				bImeCnvOpen = TRUE;
				if (TRUE == SendIMEVKFLUSHKey(hWnd))    //Win3.1J t-hiroyn
					bImeCnvOpen = FALSE;
			} else
	            bImeCnvOpen = FALSE;
#else
            /* If err return, supporse IME is not enalble.*/
            if(TRUE == GetIMEOpen(hWnd)) {
                bImeCnvOpen = TRUE;
            } else
                bImeCnvOpen = FALSE;
#endif
            bGetFocus = TRUE;

			//T-HIROYN add
			bImeFontEx = FALSE;
            if(TRUE == GetIMEVersioOk(hWnd)) {
			    //IME_SETCONVERSIONFONTEX use OK ?
				if(TRUE == GetIMESupportFontEx(hWnd))
					bImeFontEx = TRUE;
			}

#endif
            MdocGetFocus(hWnd, (HWND)wParam);
            break;

        case WM_KILLFOCUS:
            /* The window is losing the focus.  wParam contains the window
            ** handle of the window about to get the focus, or NULL. */

#if defined(JAPAN) & defined(DBCS_IME)

/*  If we're losing input focus, we have to clear OpenStatus of convertwindow,
**  'bImeCnvOpen'.                  [yutakan:07/15/91]
*/
            bImeCnvOpen = FALSE;
            bGetFocus = FALSE;

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IME3.1J IR_UNDETERMINE
            if(selUncpFirst < selUncpLim) {
                UndetermineToDetermine(hWnd);
            }
#endif
            SendIMEVKFLUSHKey(hWnd);    //Win3.1J t-hiroyn
#endif
            MdocLoseFocus(hWnd, (HWND)wParam);
            /* Since we might be moving/sizing a picture, set flag to
            ** cancel this. */
            vfCancelPictMove = TRUE;
            break;

#if defined(JAPAN) & defined(DBCS_IME) 

        case WM_IME_REPORT:

            /*   if IME convert window has been opened,
            **  we're getting into Non PeekMessage
            **  Mode at 'FImportantMsgPresent()'
            */

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IR_UNDETERMINE
            if(wParam == IR_UNDETERMINE) {
                LONG GetIRUndetermin(HWND, LPARAM);          //clipbrd2.c
                return(GetIRUndetermin(hWnd, lParam));
            }
#endif

			if(wParam == IR_IMESELECT) {
				bImeFontEx = FALSE;
    	        if(TRUE == GetIMEVersioOk(hWnd)) {
				    //IME_SETCONVERSIONFONTEX use OK ?
					if(TRUE == GetIMESupportFontEx(hWnd))
						bImeFontEx = TRUE;
				}
			}

            if (wParam == IR_STRING) {
#if 0   //t-hiroyn
            // Do nothing with IR_STRING // Yutakan
                break;
        /* put string from KKC to scrap */
//              PutImeString(hWnd, LOWORD(lParam));  // need more bug fix.
//              return 1L;
#endif
                LONG GetIRString(HWND, LPARAM);          //clipbrd2.c
                return(GetIRString(hWnd, lParam));
            }

//IR_STRINGEX New Win3.1J
            if(wParam == IR_STRINGEX) {
                LONG GetIRStringEx(HWND, LPARAM);          //clipbrd2.c
                return(GetIRStringEx(hWnd, lParam));
            }

            if(wParam == IR_OPENCONVERT || wParam == IR_CHANGECONVERT) {
                bImeCnvOpen = TRUE;
//IME3.1J
                if(wParam == IR_OPENCONVERT) {
                    SetImeFont(hWnd);
					bSendFont = TRUE;	//01/19/93
                }
            }

            if(wParam == IR_CLOSECONVERT) {
                bImeCnvOpen = FALSE;
            }

            if (wParam == IR_STRINGSTART) {
                HANDLE hMem;
                LPSTR lpText;

                if (hMem = GlobalAlloc(GMEM_MOVEABLE, 512L)) {
                    if (lpText = GlobalLock(hMem)) {
                        if (EatString(hWnd, (LPSTR)lpText, 512)) {
                            ForceImeBlock(hWnd, TRUE);  //T-HIROYN 3.1J
                            PutImeString( hWnd, hMem );
                            CmdInsIRString();           //T-HIROYN 3.1J
                            ForceImeBlock(hWnd, FALSE); //T-HIROYN 3.1J
                        }
                        GlobalUnlock(hMem);
                    }
                    GlobalFree(hMem);
                }
            }
            goto DefaultProc;
#endif
        }

    }
 else if (message < WM_USER)
    {   /* Clipboard messages */
    if (!FMdocClipboardMsg( message, wParam, lParam ))
        goto DefaultProc;
    }
 else
    {   /* Private WRITE messages */
    switch (message)
        {
        default:
            goto DefaultProc;

#if defined(OLE)
        case WM_WAITFORSERVER:
        {
            extern int vfDeactByOtherApp;
            if (!hwndWait && !vfDeactByOtherApp)
            {
                vbCancelOK = TRUE;
                ((LPOBJINFO)lParam)->fCanKillAsync =  wParam;
                ((LPOBJINFO)lParam)->fCompleteAsync = TRUE;
                DialogBoxParam(hMmwModInstance, (LPSTR)"DTWAIT", hParentWw, lpfnWaitForObject, ((LPOBJINFO)lParam)->lpobject);
            }
        }
        break;

        case WM_OBJUPDATE:
            ObjObjectHasChanged(wParam,(LPOLEOBJECT)lParam);
        break;

        case WM_OBJERROR:
            ObjReleaseError(wParam);
        break;

        case WM_OBJBADLINK:
            ObjHandleBadLink(wParam,(LPOLEOBJECT)lParam);
        break;

        case WM_OBJDELETE:
            ObjDeleteObject((LPOBJINFO)lParam,wParam);
        break;
#endif

        case wWndMsgDeleteFile:
            /* wParam is a global handle to the file to be deleted */
            /* Return code: TRUE - Ok to delete
                            FALSE - don't delete */
            lReturn = (LONG)FDeleteFileMessage( wParam );
            break;

        case wWndMsgRenameFile:
            /* wParam is a global handle to the file being renamed */
            /* LOWORD( lParam ) is a global handle to the new name */
            /* No return code */
            RenameFileMessage( wParam, LOWORD( lParam ) );
            break;
        }
    }

 goto Ret;

DefaultProc:    /* All messages not processed come here. */

    lReturn = DefWindowProc(hWnd, message, wParam, lParam);
Ret:
    if (vfCloseFilesInDialog)
        CloseEveryRfn( FALSE );

    return lReturn;
}




void MdocMouse(hWnd, message, wParam, pt)
HWND       hWnd;
unsigned   message;
WORD       wParam;
POINT      pt;
{
extern int vfFocus;
extern int vfDownClick;
extern int vfMouseExist;
extern HCURSOR vhcHourGlass;
extern int vfInLongOperation;

MSG msg;

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IR_UNDETERMINE
    if(message == WM_LBUTTONDOWN || message == WM_LBUTTONDBLCLK) {
        if(selUncpFirst < selUncpLim) {
            UndetermineToDetermine(hWnd);
        }
    }
#endif

    if (vfInLongOperation)
        {
        SetCursor(vhcHourGlass);
        return;
        }

    if (message == WM_MOUSEMOVE)
        {
        if (vfMouseExist)
            {
            HCURSOR hc;

            /* All we do on move moves is set the cursor. */

            if (pt.y < wwdCurrentDoc.ypMin)
                {
                hc = vhcArrow;
                }
            else
                {
#ifdef PENWIN
                hc = (pt.x > xpSelBar ) ? vhcPen  : vhcBarCur;

#else
                hc = (pt.x > xpSelBar) ? vhcIBeam : vhcBarCur;
#endif
                }
            SetCursor( hc );
            }
        return;
        }

    /* Save the state of the shift keys. */
    vfShiftKey = wParam & MK_SHIFT;
    vfCommandKey = wParam & MK_CONTROL;
    /* high bit returned from GetKeyState is 1 when the key is down, else
       it is up, the low bit is 1 if it is toggled */

    PeekMessage(&msg, (HWND)NULL, NULL, NULL, PM_NOREMOVE);

    vfOptionKey = GetKeyState(VK_MENU) < 0 ? true : false;
    vfDoubleClick = (message == WM_LBUTTONDBLCLK);

    if (message == WM_LBUTTONUP)
        {
        /* Windows demands this */
        if (vfDownClick && !vfFocus)
            {
            SetFocus( hWnd );
            vfDownClick = FALSE;
            }
        }
    else
        {
        extern int vfGotoKeyMode;

        vfGotoKeyMode = FALSE;
        /* WM_LBUTTONDOWN or WM_LBUTTONDBLCLK */
        vfDownClick = TRUE;

#ifdef PENWIN
#ifdef KKBUGFIX
        if( lpfnProcessWriting == NULL ||
            vfDoubleClick ||
            pt.x < xpSelBar )
            //Normal mouse processing
            DoContentHit(pt);
         else
            {
            if ((*lpfnProcessWriting)( hWnd, NULL ) < 0)
                //Normal mouse processing
                DoContentHit(pt);
            else
                // During recognition, caret blinking rate is destroyed
                SetTimer( hWnd, tidCaret, GetCaretBlinkTime(), (FARPROC)NULL );
            }
#else
        if( lpfnProcessWriting == NULL ||
            vfDoubleClick ||
            pt.x < xpSelBar ||
            (*lpfnProcessWriting)( hWnd, NULL ) < 0
            )
            //Normal mouse processing
            DoContentHit(pt);
#endif
#else
        DoContentHit(pt);
#endif
        }
#ifdef JAPAN
        if(bImeCnvOpen)
            SetImeFont(hWnd);
#endif
}



void MdocTimer(hWnd, id)
HWND hWnd;
WORD id;
{
extern int vfSkipNextBlink;
extern int vfInsertOn;
extern int vfFocus;

#if defined(OLE)
 ++nGarbageTime;
#endif

    /* A timer event has occurred with ID id.  Process it here. */
 Assert( id == tidCaret );  /* Caret blink is the only timer event we know */

 if ( ( vhWnd != hWnd ) ||   /* Document window is not current */
      ( !vfFocus ) ||        /* Don't have the focus */
      ( wwdCurrentDoc.fDirty) ) /* dl's are not up to date */
    return;

 if ( vfSkipNextBlink )
    {   /* We have been warned not to blank the cursor this time around */
    vfSkipNextBlink = FALSE;
    if ( vfInsertOn )
        return;
    }

#if defined(OLE)
 if (nGarbageTime > GARBAGETIME)
    ObjCollectGarbage();
#endif

 if ( selCur.cpFirst == selCur.cpLim )
    {
    /* We must use ToggleSel instead of DrawInsertLine because the */
    /* insert cp might not be on the screen & ToggleSel can */
    /* figure this out */

    extern int vypCursLine;
    extern int vdypCursLine;

    /* The following condition may not be true if we get a timer message
       after a size message but before a paint message; ypMac will
       have been adjusted but dlMac does not get adjusted to reflect
       the change until UpdateDisplay is called. We have violated the
       Windows dictate that ALL size-related calculations must occur
       in the Size proc and we must compensate here */

    if ( vypCursLine - vdypCursLine < wwdCurrentDoc.ypMac )
        {
        ToggleSel( selCur.cpFirst, selCur.cpFirst, !vfInsertOn );
        vfSkipNextBlink = FALSE;
        }
    }
}


void CatchupInvalid(HWND hWnd)
{
    if (!nBlocking && !IsRectEmpty(&rSaveInv))
    {
        InvalidateRect(hWnd,&rSaveInv,FALSE);
        SetRectEmpty(&rSaveInv);
    }
}

#if defined(JAPAN) & defined(DBCS_IME)

/*
**   We want to get 'IME ConvertWindow OpenStatus' but IME_GETOPEN
**  subfunction.
**  now does not support 'wCount' in IMESTRUCT (will support in future).
**   So this function will always return FALSE since wCount is always 0
**  as we set it before do SendIMEMessage(). [yutakan:07/16/91]
*/

BOOL    GetIMEOpen(HWND hwnd)
{
    LPIMESTRUCT lpmem;
    HANDLE      hIMEBlock;
    int         wRet;

    /* Get comunication area with IME */
    hIMEBlock=GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE | GMEM_LOWER,
            (DWORD)sizeof(IMESTRUCT));
    if(!hIMEBlock)  return FALSE;

    lpmem           = (LPIMESTRUCT)GlobalLock(hIMEBlock);
    lpmem->fnc      = IME_GETOPEN;
    lpmem->wCount   = 0;	//01/25/93

    GlobalUnlock(hIMEBlock);
    if(FALSE == (MySendIMEMessageEx(hwnd,MAKELONG(hIMEBlock,NULL)))){
        wRet = FALSE;   /* Error */
    }
    else
        wRet = TRUE;    /* Success */

	//01/25/93
    if (lpmem = (LPIMESTRUCT)GlobalLock(hIMEBlock)) {
        if(wRet == TRUE && lpmem->wCount == 0) 
            wRet = FALSE; //ok
        GlobalUnlock(hIMEBlock);
    }

    GlobalFree(hIMEBlock);
    return  wRet;
}

//T_HIROYN
//SendIMEMessageEx New3.1J
MySendIMEMessageEx(HWND hwnd, LPARAM lParam)
{
    return(SendIMEMessageEx(hwnd, lParam));
//    return(SendIMEMessage(hwnd, lParam));
}

BOOL    GetIMEVersioOk(HWND hwnd)
{
    LPIMESTRUCT lpmem;
    WORD        wVersion;
    int         wRet = FALSE;

    /* comunication area with IME */
    HANDLE hImeStruct;

    /* Get comunication area with IME */
    hImeStruct = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE,
				 (DWORD)sizeof(IMESTRUCT));
    if( !hImeStruct )
        return FALSE;

    if(lpmem = (LPIMESTRUCT)GlobalLock(hImeStruct)) {
        lpmem->fnc      = IME_GETIMECAPS;
        lpmem->wParam   = IME_GETVERSION;

        GlobalUnlock(hImeStruct);
        if(FALSE == (MySendIMEMessageEx(hwnd,MAKELONG(hImeStruct,NULL)))) {
            goto retVercheck;
        }
    }

    if(lpmem = (LPIMESTRUCT)GlobalLock(hImeStruct)) {
        lpmem->fnc      = IME_GETVERSION;

        GlobalUnlock(hImeStruct);
        wVersion = MySendIMEMessageEx(hwnd,MAKELONG(hImeStruct,NULL));

        if(wVersion >= 0x0a03) 
            wRet = TRUE;
        else
            wRet = FALSE;
    }

retVercheck:

    GlobalFree(hImeStruct);
    return  wRet;
}

BOOL    GetIMESupportFontEx(HWND hwnd)
{
    LPIMESTRUCT lpmem;
    int         wRet = FALSE;

    /* comunication area with IME */
    HANDLE hImeStruct;

    /* Get comunication area with IME */
    hImeStruct = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE,
				 (DWORD)sizeof(IMESTRUCT));
    if( !hImeStruct )
        return FALSE;

    if(lpmem = (LPIMESTRUCT)GlobalLock(hImeStruct)) {
        lpmem->fnc      = IME_GETIMECAPS;
       	lpmem->wParam   = IME_SETCONVERSIONFONTEX;

        GlobalUnlock(hImeStruct);
        if(TRUE == (MySendIMEMessageEx(hwnd,MAKELONG(hImeStruct,NULL)))) {
            wRet = TRUE;
        }
    }

    GlobalFree(hImeStruct);
    return  wRet;
}

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
BOOL    GetIMEOpenMode(HWND hwnd)
{
    LPIMESTRUCT lpmem;
    int  wRet = TRUE;

    /* comunication area with IME */
    extern HANDLE hImeMem;

    if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
        lpmem->fnc      = IME_GETOPEN;
        lpmem->wCount   = 0;

        GlobalUnlock(hImeMem);
        if(0 == (MySendIMEMessageEx(hwnd,MAKELONG(hImeMem,NULL))))
            wRet = FALSE;   /* close ok */
        else
            wRet = TRUE;    /* open ok ? */
    }

    if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
        if(wRet == TRUE && lpmem->wCount == 0) 
            wRet = FALSE; //ok
        GlobalUnlock(hImeMem);
    }
    return  wRet;
}

#endif //IME_HIDDEN

/* routine to retrieve WM_CHAR from the message queue associated with hwnd.
 * this is called by EatString.
 */
WORD NEAR PASCAL EatOneCharacter(hwnd)
register HWND hwnd;
{
    MSG msg;
    register int i = 10;

    while(!PeekMessage((LPMSG)&msg, hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) {
        if (--i == 0)
            return -1;
        Yield();
    }
    return msg.wParam & 0xFF;
}

/* This routine is called when the MSWRITE_DOC class receives WM_IME_REPORT
 * with IR_STRINGSTART message. The purpose of this function is to eat
 * all strings between IR_STRINGSTART and IR_STRINGEND.
 */
BOOL EatString(hwnd, lpSp, cchLen)
register HWND   hwnd;
LPSTR lpSp;
WORD cchLen;
{
    MSG msg;
    int i = 10;
    int w;

    *lpSp = '\0';
    if (cchLen < 4)
    return NULL;    // not enough
    cchLen -= 2;

    while(i--) {
        while(PeekMessage((LPMSG)&msg, hwnd, NULL, NULL, PM_REMOVE)) {
        i = 10;
        switch(msg.message) {
            case WM_CHAR:
            *lpSp++ = (BYTE)msg.wParam;
            cchLen--;
            if (IsDBCSLeadByte((BYTE)msg.wParam)) {
            if ((w = EatOneCharacter(hwnd)) == -1) {
                /* Bad DBCS sequence - abort */
                lpSp--;
                goto WillBeDone;
            }
            *lpSp++ = (BYTE)w;
            cchLen--;
            }
            if (cchLen <= 0)
            goto WillBeDone;   // buffer exhausted
            break;
            case WM_IME_REPORT:
            if (msg.wParam == IR_STRINGEND) {
            if (cchLen <= 0)
                goto WillBeDone; // no more room to stuff
            if ((w = EatOneCharacter(hwnd)) == -1)
                goto WillBeDone;
            *lpSp++ = (BYTE)w;
            if (IsDBCSLeadByte((BYTE)w)) {
                if ((w = EatOneCharacter(hwnd)) == -1) {
                    /* Bad DBCS sequence - abort */
                    lpSp--;
                    goto WillBeDone;
                }
                *lpSp++ = (BYTE)w;
            }
            goto WillBeDone;
            }
            /* Fall through */
            default:
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            break;
        }
        }
    }
    /* We don't get WM_IME_REPORT + IR_STRINGEND
     * But received string will be OK
     */

WillBeDone:

    *lpSp = '\0';
    return TRUE;
}

#endif      /* JAPAN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\menudefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*
This file contains the definitions of the numerical indexes to the menu
items (imi) used by Windows WRITE.
Each imi should be unique and be continuous within the same
menu. The middle 2 bytes of imi are masked against MENUMASK to
provide the submenu index.
IF any of the menu item order has changed, menu.c has
to be modified also -- rgmfAllItem, rgmfScrap, SetMenuFlags etc.
*/

/* number of pulldown submenus */
#define CMENUS 7

/* menu index */
#define FILE 0
#define EDIT 1
#define FIND 2
#define CHARACTER 3
#define PARA 4
#define DIV 5
#define HELP 6

#define MENUMASK           0x0ff0
#define FILEMENU           0x0000
#define EDITMENU           0x0010
#define FINDMENU           0x0020
#define CHARMENU           0x0040
#define PARAMENU           0x0080
#define DOCUMENU           0x0100
#define HELPMENU        0x0200
#define VERBMENU        0x0400

#define fMenuItem                       0x1000

#define imiNil                          0x1fff
#define imiHelp                         0xf2f0

/* Menu items */
/* #define imiAbout                     0x1000 */
#define imiNew                          0x1001
#define imiOpen                         0x1002
#define imiSave                         0x1003
#define imiSaveAs               0x1004
#define imiPrint                        0x1005
#define imiPrintSetup           0x1006
#define imiRepaginate           0x1007
#define imiQuit                         0x1008
#define imiFileMin                      (imiNew)
#define imiFileMax                      (imiQuit + 1)

#define imiUndo                         0x1010
#define imiCut                          0x1011
#define imiCopy                         0x1012
#define imiPaste                        0x1013
#define imiMovePicture                  0x1014
#define imiSizePicture                  0x1015
#if defined(OLE)
#if !defined(SMALL_OLE_UI)
#define imiPasteLink                    0x1016
#define imiProperties                   0x1017
#endif
#define imiInsertNew                    0x1018
#define imiPasteSpecial         0x1019
#endif
#define imiEditMin         (imiUndo)
/* note imiEditMax intentionally doesn't include OLE menu items. (1.25.91) D. Kent */
#define imiEditMax         (imiSizePicture + 1)

#if defined(OLE)
/* verbs */
#define imiVerb                 0x1400
#define imiVerbEdit             0x1401
#define imiVerbPlay             0x1402
#define imiVerbMax              0x14FF
#endif


#define imiFind                         0x1020
#define imiFindAgain       0x1021
#define imiChange                       0x1022
#define imiGoTo                          0x1023
#define imiFindMin         (imiFind)
#define imiFindMax         (imiGoTo + 1)

#if defined(OLE)
/* these aren't really menu items, but we'll associate them with
   WM_COMMAND messages like cardfile does. 01/24/91 -- dougk */
#define imiActivate     1030
#define imiUpdate       1031
#define imiFreeze       1032
#define imiClone        1033
#define imiCopyfromlink 1034
#endif

#define imiCharNormal      0x1040
#define imiBold                                 0x1041
#define imiItalic                       0x1042
#define imiUnderline                    0x1043
#define imiSuper                        0x1044
#define imiSub                          0x1045
#if 0
#define imiFont1           0x1046
#define imiFont2           0x1047
#define imiFont3           0x1048
#endif
#define imiSmFont          0x1046
#define imiLgFont          0x1047
#define imiCharFormats          0x1048

#if defined(JAPAN) & defined(IME_HIDDEN)  //IME3.1J
#define imiImeHidden       0x1049
#endif

#define imiCharMin         (imiCharNormal)

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
#define imiCharMax         (imiImeHidden + 1)
#else
#define imiCharMax         (imiCharFormats + 1)
#endif

/* special accelerator key
#define imiAccelBold       0x104c
#define imiAccelItalic     0x104d
#define imiAccelUnderline  0x104e*/

#define imiParaNormal                   0x1080
#define imiLeft                         0x1081
#define imiCenter                       0x1082
#define imiRight                        0x1083
#define imiJustified                    0x1084
#define imiSingleSpace                  0x1085
#define imiOneandhalfSpace              0x1086
#define imiDoubleSpace                  0x1087
#define imiParaFormats                  0x1088
#define imiParaMin                      (imiParaNormal)
#define imiParaMax                      (imiParaFormats + 1)

#define imiHeader                0x1100
#define imiFooter               0x1101
#define imiShowRuler                 0x1102
#define imiTabs                 0x1103
#define imiDivFormats           0x1104
#define imiDocuMin         (imiHeader)
#define imiDocuMax         (imiDivFormats + 1)

#define imiIndex                 0x1200
#define imiHelpSearch            0x1201
#define imiUsingHelp             0x1202
#define imiAbout                 0x1203
#define imiHelpMin               (imiIndex)
#define imiHelpMax               (imiAbout + 1)

#ifdef CASHMERE
#define imiFootnote
#define imiPreferences
#endif

#ifdef ENABLE /* CFILE, CEDIT ... */
/* number of items in each submenu */
#define CFILE  (imiFileMax - imiFileMin)
#define CEDIT  (imiEditMax - imiEditMin)
#define CFIND  (imiFindMax - imiFindMin)
#define CCHAR  (imiCharMax - imiCharMin)
#define CPARA  (imiParaMax - imiParaMin)
#define CDOCU  (imiDocuMax - imiDocuMin)
#define CHELP  (imiHelpMax - imiHelpMin)
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\mouse.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* The routines in this file roughly correspond to the routines in the original
Mac Word file, sand.c.  But since that name is confusing, and most of these
routine deal with the mouse, the name was changed to protect the innocent. */

#define NOGDICAPMASKS
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
//#define NOMETAFILE
#include <windows.h>
#include "mw.h"
#include "dispdefs.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "fmtdefs.h"
#include "propdefs.h"

#if defined(OLE)
#include "obj.h"
#include "winddefs.h"
#include "str.h"
#endif

/* cpNil is defined in docdefs.h, but to include the whole file will cause the
symbol table to overflow, so it is redefined here. */
#define cpNil           ((typeCP) -1)


extern struct WWD       rgwwd[];
extern struct WWD       *pwwdCur;
extern int              wwCur;
extern struct SEL       selCur;
extern int              docCur;
extern int              vfShiftKey;
extern int              vfOptionKey;
extern int              vfCommandKey;
extern int              vfDoubleClick;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern struct PAP       vpapAbs;
extern typeCP           cpWall;
extern int              vfDidSearch;
extern typeCP           vcpSelect;
extern int              vfSelAtPara;
extern int              vfPictSel;
extern long             tickOld;

#ifdef PENWIN
extern int		vcFakeMessage;
extern LONG FAR PASCAL GetMessageExtraInfo( void ); // Defined in Win 3.1
#endif

/* G L O B A L S */

int                     vfSelecting = false;
int                     vstyCur;
int                     vpsmCur;
int                     vfObjOpen=0,vfObjProps=0,vfObjSel=0;
int                     vfAwfulNoise = false;
struct SEL              selPend;

/* MB_STANDARD is the same as in diaalert.c */
#define MB_STANDARD (MB_OK | MB_SYSTEMMODAL | MB_ICONEXCLAMATION)

/* _ B E E P */
_beep()
    {
    /* Beeps once */
    if (!vfAwfulNoise)
        {
        beep();
        vfAwfulNoise = true;
        }
    }



beep()
    {
        MessageBeep(MB_STANDARD);
    }



/* D O  C O N T E N T  H I T */
DoContentHit(pt)
POINT pt;
    {

    /* This routine process everything from a mouse-down click to the
    corresponding mouse-up click. */

    int dlMouse;

    /* Ignore mouse hits in the page area & above the first line*/
    if ( (pt.y >= wwdCurrentDoc.ypMac) ||
         (pt.y < wwdCurrentDoc.ypMin) )
        return;

    /* Check for a special selection, i.e. move, copy or format text. */
    if (FSetPsm())
        {
        blt(&selCur, &selPend, cwSEL);
        vfDoubleClick = vfCommandKey = vfShiftKey = false;
        vstyCur = vpsmCur != psmLooks ? StyFromPt(pt) : styChar;
        }
    else
        {
        vstyCur = StyFromPt(pt);
        }

    dlMouse = DlFromYp(pt.y, pwwdCur);
    vcpSelect = cpNil;
    vfSelAtPara = false;

#ifdef ENABLE
    if (vfPictSel)
        {
        /* Check for a picture modification (moving, sizing). */
        if (FHitPictFrame(dlMouse, pt))
            {
            return;
            }

        /* Remove the picture frame */
        ToggleSel(selCur.cpFirst, selCur.cpLim, false);
        vfPictSel = false;
        ToggleSel(selCur.cpFirst, selCur.cpLim, true);
        }
#endif

    vfSelecting = true;
    SelectDlXp(dlMouse, pt.x, vstyCur, vfShiftKey);

    /* Now we sit in a loop processing all mouse events in all windows until a
    mouse-up click. */
    SetCapture(wwdCurrentDoc.wwptr);
    while( FStillDown( &pt ) )
        {
        /* If the mouse is above or below the window, then scroll the window and
        pretend the mouse is in the window. */
        if (pt.y > (int)wwdCurrentDoc.ypMac)
            {
            ScrollDownCtr( 1 );
            goto DoCont1;
            }
        else if (pt.y < (int)wwdCurrentDoc.ypMin)
            {
            ScrollUpCtr( 1 );
DoCont1:    UpdateWw(wwCur, false);
            }

        /* Get a valid dl and xp. */
        dlMouse = DlFromYp(pt.y, pwwdCur);
        if (pt.x < 0)
            pt.x = 0;
        else if (pt.x > wwdCurrentDoc.xpMac)
            pt.x = wwdCurrentDoc.xpMac;

        /* Update the selection. */
        if (vfOptionKey)
            {
            vcpSelect = cpNil;
            }
        SelectDlXp(dlMouse, pt.x, vstyCur, !vfOptionKey);
        }   /* End of for ( ; ; ) */

    /* Release all of the mouse events. */
    ReleaseCapture();

    /* Process Mouse Up */
    DoContentHitEnd( pt );
    SetFocus( wwdCurrentDoc.wwptr );

    /* If the selection is an insertion bar, start it flashing. */
    if (selCur.cpFirst == selCur.cpLim)
        {
        extern int vfSkipNextBlink;
        vfSkipNextBlink = true;
        }

#if defined(OLE)           
        if (ObjQueryCpIsObject(docCur,selCur.cpFirst) && (vfObjProps || vfObjOpen))
        /* doubleclick and maybe alt key */
        {
            /* set whether link or emb selected */
            ObjSetSelectionType(docCur,selCur.cpFirst,selCur.cpLim);
            if (vfObjProps)
            /* alt + double click */
            {
                switch(OBJ_SELECTIONTYPE)
                {
#if 0 // do nothing if embedded
                    case EMBEDDED:
                    {
                        struct PICINFOX  picInfo;
                        GetPicInfo(selCur.cpFirst,selCur.cpLim, docCur, &picInfo);
                        ObjEditObjectInDoc(&picInfo, docCur, vcpFirstParaCache);
                    }
                    break;
#endif

                    case LINK:
                        /* bring up properties dlg */
                        fnObjProperties();
                    break;
                }
                CachePara(docCur,selCur.cpFirst);
            }
            else if (vfObjOpen) // edit object
            /* double click */
            {
                if (OBJ_SELECTIONTYPE == STATIC)
                    Error(IDPMTStatic);
                else
                {
                    struct PICINFOX  picInfo;
                    GetPicInfo(selCur.cpFirst,selCur.cpLim, docCur, &picInfo);
                    ObjPlayObjectInDoc(&picInfo, docCur, vcpFirstParaCache);
                }
            }
        }
#endif

    }


/* D O  C O N T E N T  H I T  E N D */
DoContentHitEnd(pt)
POINT pt;
    {
    int dlMouse;
    int cch;

    dlMouse = DlFromYp(min(pt.y, wwdCurrentDoc.ypMac), pwwdCur);
    SelectDlXp(dlMouse, pt.x, vstyCur, vpsmCur == psmNil);

    switch (vpsmCur)
        {
        default:
        case psmNil:
            break;

        case psmLooks:
                LooksMouse();
            break;

        case psmCopy:
            #if defined(OLE)
            /* we'll disable CopyMouse if any objects are in dest */
            vfObjSel = ObjQueryCpIsObject(docCur,selCur.cpFirst);

            if (!vfObjSel)
                    // !!! disable because for objects this 
                    // interferes with Alt-DoubleClick (2.20.91) D. Kent
            #endif
                CopyMouse();
            break;

        case psmMove:
                MoveMouse();
            break;
        }

#ifdef ENABLE
    CachePara(docCur, selCur.cpFirst);

    if (vpapAbs.fGraphics && selCur.cpLim == vcpLimParaCache)
        {
        /* Selected a picture, do special selection stuff. */
        Assert(selCur.cpFirst == vcpFirstParaCache);

        /* Turn off the selection, indicate that it is a picture, then turn it
        back on. */
        ToggleSel(selCur.cpFirst, selCur.cpLim, false);
        vfPictSel = true;
        ToggleSel(selCur.cpFirst, selCur.cpLim, true);
        }
    else
        {
        vfPictSel = false;
        }
#endif

    vfDidSearch = false;
    cpWall = selCur.cpLim;
    vfSelecting = false;
    }


/* S T Y  F R O M  P T */
int StyFromPt(pt)
POINT pt;
    {
    /* Return the style code associated with the selection made at point pt. */
    if (pt.x > xpSelBar)
        {
        return vfCommandKey ? stySent : (vfDoubleClick ? styWord : styChar);
        }
    else
        {
        return vfCommandKey ? styDoc : (vfDoubleClick ? styPara : styLine);
        }
    }


/* F  S E T  P S M */
int FSetPsm()
    {
    /* Sets vpsmCur according to the states of the shift, commad, and option
    keys.  True is returned if vpsmCur is not nil; false otherwise. */

    vpsmCur = psmNil;

    if (vfOptionKey)
        {
        if (vfShiftKey && !vfCommandKey)
            {
            vpsmCur = psmMove;
            }
        else if (vfCommandKey && !vfShiftKey)
            {
            vpsmCur = psmLooks;
            }
        else if (!vfCommandKey && !vfShiftKey)
            {
                vfObjProps = vfDoubleClick;
                vfObjOpen = FALSE;
                vpsmCur = psmCopy;
            }
        }
        else 
        {
            vfObjOpen = vfDoubleClick;
            vfObjProps = FALSE;
        }
    return (vpsmCur != psmNil);
    }


/* D L  F R O M  Y P */
int DlFromYp(yp, pwwd)
int yp;
struct WWD *pwwd;
    {
    /* Return the dl that contains yp */
    int dlT;
    int ypSum;
    struct EDL *pedl;
    int dlMac;

    /* Clean up a dirty window. */
    if (pwwd->fDirty)
        {
        UpdateWw(pwwd - &rgwwd[0] /* = ww; grr.. */, false);
        }

    /* Loop throught the EDLs summing up the heights utill the sum is greater
    than yp. */
    ypSum = pwwd->ypMin;
    pedl = &(**(pwwd->hdndl))[0];
    dlMac = pwwd->dlMac;

    for (dlT = 0; dlT < dlMac; ++dlT, pedl++)
        {
        ypSum += pedl->dyp;
        if (ypSum > yp)
            {
            return dlT;
            }
        }

    return dlMac - 1;
    }


FStillDown( ppt )
POINT   *ppt;
{   /* This is roughly equivalent to a Mac routine that returns whether
       the mouse button is down.  We look for one mouse message from our
       window's queue, and return FALSE if it is a BUTTONUP.  We return the
       point at which the mouse event occurred through a pointer.  If no
       message occurred, we return TRUE and do not store into the pointer */
 MSG msg;

retry_peek:

 if ( PeekMessage( (LPMSG)&msg, (HWND)NULL, NULL, NULL, PM_REMOVE ) )
    {
    extern WORD wWinVer;
    switch (msg.message) {
        default:
            TranslateMessage( (LPMSG)&msg );
            DispatchMessage( (LPMSG)&msg );
            return TRUE;

        case WM_MOUSEMOVE:
        case WM_LBUTTONUP:
        case WM_LBUTTONDOWN:
#ifdef PENWIN
        if (((wWinVer & 0xFF) >= 3) && ((wWinVer & 0xFF00) >= 0x0A00))
        /* Windows Version >= 3.10 */
	        if( vcFakeMessage > 0 )
			    {
                static FARPROC MessageExtraInfo = NULL;

                if (MessageExtraInfo == NULL)
                    MessageExtraInfo = GetProcAddress(GetModuleHandle((LPSTR)"USER"),(LPSTR)288L);

			    if( MessageExtraInfo() != 0 )
				    goto retry_peek;
			    vcFakeMessage--;
			    }
#endif
            /* A Mouse Move, Mouse Down, or Mouse Up is waiting */
            ppt->x = MAKEPOINT(msg.lParam).x;
            ppt->y = MAKEPOINT(msg.lParam).y;

            return (msg.message != WM_LBUTTONUP);
        }
    }
 else
     return GetKeyState( VK_LBUTTON ) < 0;

 return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\mouse.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the mouse definitions used by Windows Word.  The verbosity
of this file is due to the fact that although the resource compiler will accept
include files, it will do no algerbraic simplification. */

#define cMouseButton	1

#define fMouseKey	0x2000

#define fUp		0
#define fDown		1
#define fCommand	2
#define fOption		4
#define fShift		8

#define imbMove		0x2000

#if cMouseButton > 0
    #define fMouseButton1	0x2100
    #define imb1Up		0x2100	/* fMouseButton1 | fUp */
    #define imb1Dn		0x2101	/* fMouseButton1 | fDown */
    #define imb1ComUp		0x2102	/* fMouseButton1 | fCommand | fUp */
    #define imb1ComDn		0x2103	/* fMouseButton1 | fCommand | fDown */
    #define imb1OptUp		0x2104	/* fMouseButton1 | fOption | fUp */
    #define imb1OptDn		0x2105	/* fMouseButton1 | fOption | fDown */
    #define imb1ShfUp		0x2108	/* fMouseButton1 | fShift | fUp */
    #define imb1ShfDn		0x2109	/* fMouseButton1 | fShift | fDown */
    #define imb1ComOptUp	0x2106	/* fMouseButton1 | fCommand | fOption |
					   fUp */
    #define imb1ComOptDn	0x2107	/* fMouseButton1 | fCommand | fOption |
					   fDown */
    #define imb1ComShfUp	0x210a	/* fMouseButton1 | fCommand | fShift |
					   fUp */
    #define imb1ComShfDn	0x210b	/* fMouseButton1 | fCommand | fShift |
					   fDown */
    #define imb1OptShfUp	0x210c	/* fMouseButton1 | fOption | fShift |
					   fUp */
    #define imb1OptShfDn	0x210d	/* fMouseButton1 | fOption | fShift |
					   fDown */
    #define imb1ComOptShfUp	0x210e	/* fMouseButton1 | fCommand | fOption |
					   fShift | fUp */
    #define imb1ComOptShfDn	0x210f	/* fMouseButton1 | fCommand | fOption |
					   fShift | fDown */
#endif /* cMouseButtonButton > 0 */

#if cMouseButton > 1
    #define fMouseButton2	0x2200
    #define imb2Up		0x2200	/* fMouseButton2 | fUp */
    #define imb2Dn		0x2201	/* fMouseButton2 | fDown */
    #define imb2ComUp		0x2202	/* fMouseButton2 | fCommand | fUp */
    #define imb2ComDn		0x2203	/* fMouseButton2 | fCommand | fDown */
    #define imb2OptUp		0x2204	/* fMouseButton2 | fOption | fUp */
    #define imb2OptDn		0x2205	/* fMouseButton2 | fOption | fDown */
    #define imb2ShfUp		0x2208	/* fMouseButton2 | fShift | fUp */
    #define imb2ShfDn		0x2209	/* fMouseButton2 | fShift | fDown */
    #define imb2ComOptUp	0x2206	/* fMouseButton2 | fCommand | fOption |
					   fUp */
    #define imb2ComOptDn	0x2207	/* fMouseButton2 | fCommand | fOption |
					   fDown */
    #define imb2ComShfUp	0x220a	/* fMouseButton2 | fCommand | fShift |
					   fUp */
    #define imb2ComShfDn	0x220b	/* fMouseButton2 | fCommand | fShift |
					   fDown */
    #define imb2OptShfUp	0x220c	/* fMouseButton2 | fOption | fShift |
					   fUp */
    #define imb2OptShfDn	0x220d	/* fMouseButton2 | fOption | fShift |
					   fDown */
    #define imb2ComOptShfUp	0x220e	/* fMouseButton2 | fCommand | fOption |
					   fShift | fUp */
    #define imb2ComOptShfDn	0x220f	/* fMouseButton2 | fCommand | fOption |
					   fShift | fDown */
#endif /* cMouseButton > 1 */

#if cMouseButton > 2
    #define fMouseButton3	0x2400
    #define imb3Up		0x2400	/* fMouseButton3 | fUp */
    #define imb3Dn		0x2401	/* fMouseButton3 | fDown */
    #define imb3ComUp		0x2402	/* fMouseButton3 | fCommand | fUp */
    #define imb3ComDn		0x2403	/* fMouseButton3 | fCommand | fDown */
    #define imb3OptUp		0x2404	/* fMouseButton3 | fOption | fUp */
    #define imb3OptDn		0x2405	/* fMouseButton3 | fOption | fDown */
    #define imb3ShfUp		0x2408	/* fMouseButton3 | fShift | fUp */
    #define imb3ShfDn		0x2409	/* fMouseButton3 | fShift | fDown */
    #define imb3ComOptUp	0x2406	/* fMouseButton3 | fCommand | fOption |
					   fUp */
    #define imb3ComOptDn	0x2407	/* fMouseButton3 | fCommand | fOption |
					   fDown */
    #define imb3ComShfUp	0x240a	/* fMouseButton3 | fCommand | fShift |
					   fUp */
    #define imb3ComShfDn	0x240b	/* fMouseButton3 | fCommand | fShift |
					   fDown */
    #define imb3OptShfUp	0x240c	/* fMouseButton3 | fOption | fShift |
					   fUp */
    #define imb3OptShfDn	0x240d	/* fMouseButton3 | fOption | fShift |
					   fDown */
    #define imb3ComOptShfUp	0x240e	/* fMouseButton3 | fCommand | fOption |
					   fShift | fUp */
    #define imb3ComOptShfDn	0x240f	/* fMouseButton3 | fCommand | fOption |
					   fShift | fDown */
#endif /* cMouseButton > 2 */

#if cMouseButton > 3
    #define fMouseButton4	0x2800
    #define imb4Up		0x2800	/* fMouseButton4 | fUp */
    #define imb4Dn		0x2801	/* fMouseButton4 | fDown */
    #define imb4ComUp		0x2802	/* fMouseButton4 | fCommand | fUp */
    #define imb4ComDn		0x2803	/* fMouseButton4 | fCommand | fDown */
    #define imb4OptUp		0x2804	/* fMouseButton4 | fOption | fUp */
    #define imb4OptDn		0x2805	/* fMouseButton4 | fOption | fDown */
    #define imb4ShfUp		0x2808	/* fMouseButton4 | fShift | fUp */
    #define imb4ShfDn		0x2809	/* fMouseButton4 | fShift | fDown */
    #define imb4ComOptUp	0x2806	/* fMouseButton4 | fCommand | fOption |
					   fUp */
    #define imb4ComOptDn	0x2807	/* fMouseButton4 | fCommand | fOption |
					   fDown */
    #define imb4ComShfUp	0x280a	/* fMouseButton4 | fCommand | fShift |
					   fUp */
    #define imb4ComShfDn	0x280b	/* fMouseButton4 | fCommand | fShift |
					   fDown */
    #define imb4OptShfUp	0x280c	/* fMouseButton4 | fOption | fShift |
					   fUp */
    #define imb4OptShfDn	0x280d	/* fMouseButton4 | fOption | fShift |
					   fDown */
    #define imb4ComOptShfUp	0x280e	/* fMouseButton4 | fCommand | fOption |
					   fShift | fUp */
    #define imb4ComOptShfDn	0x280f	/* fMouseButton4 | fCommand | fOption |
					   fShift | fDown */
#endif /* cMouseButton > 3 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\mmw.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

//#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOMM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOGDICAPMASKS
#define NOICON
#define NOKEYSTATE
#define NOMB
#define NOMEMMGR
//#define NOMENUS
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOPEN
#define NOREGION
//#define NOSHOWWINDOW
#define NOSOUND
#define NOSYSCOMMANDS
#define NOSYSMETRICS
#define NOVIRTUALKEYCODES
#define NOWH
#define NOWINOFFSETS
#define NOWINSTYLES
#define NOWNDCLASS
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#define NOSTRUNDO
#include "str.h"
#include "menudefs.h"
#include "prmdefs.h"
#include "propdefs.h"
#include "debug.h"
#include "fontdefs.h"
#include "preload.h"
#include "winddefs.h"
#define NOIDISAVEPRINT
#define NOIDIFORMATS
#include "dlgdefs.h"

#if defined(OLE)
#include "obj.h"
#endif

static void DrawResizeHole(HWND hWnd, HDC hDC);

extern HANDLE   hMmwModInstance;  /* handle to it's own module instance */
extern HWND     hParentWw;          /* handle to parent's window */
extern HWND     vhWndMsgBoxParent;
extern HCURSOR  vhcHourGlass;
extern HCURSOR  vhcIBeam;
extern HCURSOR  vhcArrow;
extern HMENU    vhMenu;
extern MSG      vmsgLast;
extern FARPROC  lpDialogHelp;

extern struct WWD   rgwwd[];
extern struct WWD   *pwwdCur;
extern int          wwCur;
extern int          vfInitializing;
extern int          vfInsertOn;
extern int          vfSeeSel;
extern int          vfSelHidden;
extern int          vfDeactByOtherApp;
extern int          vfDownClick;
extern int          vfCursorVisible;
extern int          vfMouseExist;
extern int          flashID;
extern int          ferror;
extern typeCP       cpMacCur;
extern struct SEL   selCur;
extern CHAR         stBuf[];
extern HBITMAP      hbmNull;
extern CHAR         szWindows[];
extern CHAR         szDevices[];
extern CHAR         szIntl[];
extern WORD fPrintOnly;

#ifdef RULERALSO
extern BOOL vfDisableMenus;
#endif /* RULERALSO */

#ifdef DEBUG
#define STATIC
#else /* not DEBUG */
#define STATIC  static
#endif /* not DEBUG */

CHAR **hszDevmodeChangeParam = NULL;
BOOL vfDevmodeChange = fFalse;
int wWininiChange = 0;

BOOL vfDead = FALSE;
BOOL vfIconic = FALSE;
/*int vcActiveCount = 0;  0 or 1 for active/deactive count */


void MmwCreate(HWND, LONG);
void NEAR MmwPaint(HWND);
void MmwSize(HWND, int, int, WORD);
void MmwCommand(HWND, WORD, HWND, WORD);
void MmwVertScroll(HWND, WORD, int);
void NEAR MmwHorzScroll(HWND, WORD, int);


int PASCAL WinMain( hInstance, hPrevInstance, lpszCmdLine, cmdShow )
HANDLE hInstance, hPrevInstance;
LPSTR  lpszCmdLine;
int    cmdShow;
{
    /* Set up all manner of windows-related data; create parent (menu)
       window and child (document) window */

    if (!FInitWinInfo( hInstance, hPrevInstance, lpszCmdLine, cmdShow ))
            /* Could not initialize; WRITE fails */
        {
        return FALSE;
        }

    if (fPrintOnly)
    {
        UpdateDisplay(FALSE);
        fnPrPrinter();
        FMmwClose( hParentWw );
        DeleteObject( hbmNull );
        _exit( vmsgLast.wParam );
    }
    else
        MainLoop();

    DeleteObject( hbmNull );
    _exit( vmsgLast.wParam );
}


long FAR PASCAL MmwWndProc(hWnd, message, wParam, lParam)
HWND      hWnd;
unsigned  message;
WORD      wParam;
LONG      lParam;
{
    extern int vfCloseFilesInDialog;
    extern long ropErase;
    extern int vfLargeSys;
    extern HDC vhDCPrinter;
    extern HWND vhWndCancelPrint;
    extern HWND vhWndPageInfo;
    extern HFONT vhfPageInfo;
    extern BOOL vfWinFailure;
    CHAR szT[cchMaxSz];
    long lReturn = 0L;

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IR_UNDETERMINE
extern HWND vhWnd;  /* WINDOWS: Handle of the current document display window*/
extern typeCP selUncpFirst;
extern typeCP selUncpLim;
    if(selUncpFirst < selUncpLim) {
        switch (message) {
            case WM_INITMENU:
            case WM_VSCROLL:
            case WM_HSCROLL:
                UndetermineToDetermine(vhWnd);
                break;
            case WM_SIZE:
                if(SIZEICONIC == wParam )
                    UndetermineToDetermine(vhWnd);
            default:
                break;  //Fall 
        }
    }
#endif

    switch (message)
        {
        case WM_MENUSELECT:
            SetShiftFlags();
        break;

        case WM_CREATE:
            /* Window's being created; lParam contains lpParam field
            ** passed to CreateWindow */
            MmwCreate(hWnd, lParam);
            break;

        case WM_PAINT:
            /* Time to repaint this window. */
            MmwPaint(hWnd);
            break;

#if defined(OLE)
        case WM_DROPFILES:
            /* We got dropped on, so bring ourselves to the top */
            BringWindowToTop(hWnd);
#ifdef DEBUG
            OutputDebugString("Dropping on main window\r\n");
#endif
            ObjGetDrop(wParam,TRUE);
        break;
#endif

        case WM_INITMENU:
            /* setup the pull down menu before being drawn */
            /* wParam is the top level menu handle */
            vhMenu = (HMENU)wParam;
            break;

        case WM_INITMENUPOPUP:
            /* setup the pull down menu before being drawn */
            /* wParam is the popup menu handle */
            /* LOWORD(lParam) = index of popup in main menu */
            /* HIWORD(lParam) = 1 if system menu, 0 if application main menu */
            EndLongOp(vhcArrow);
            if (HIWORD(lParam) == 0)
                { /* we care for the application main menu only */
#ifdef CYCLESTOBURN
                switch (LOWORD(lParam)) {
                    default:
                        break;
                    case EDIT:
                        PreloadCodeTsk( tskScrap );
                    case CHARACTER:
                        PreloadCodeTsk( tskFormat );
                        break;
                    }
#endif
                SetAppMenu((HMENU)wParam, LOWORD(lParam));
                }
                /* Turn on the cursor so we can see where it is */
            if (!vfInsertOn && selCur.cpFirst == selCur.cpLim)
                ToggleSel( selCur.cpFirst, selCur.cpFirst, TRUE );
            break;

        case WM_ACTIVATE:
            /* We are becoming the active window iff wParam is non-0 */
            /* HIWORD( lParam ) is true iff the window is iconic */
            if (wParam && !HIWORD(lParam)
#if 0
#if defined(OLE)
                 && !nBlocking
#endif
#endif
                && IsWindowEnabled(wwdCurrentDoc.wwptr))
                {
                SetFocus( wwdCurrentDoc.wwptr );
                vhWndMsgBoxParent = hParentWw;
                }
            if (wParam)
                {
                vfDeactByOtherApp = FALSE; /* this is to conquer a windows' bug */
                }

            /* did we receive a devmode/winini change that we should process now? */
            if (wWininiChange != 0)
                {
                Assert(wWininiChange > 0 && wWininiChange < wWininiChangeMax);
                PostMessage( hWnd, wWndMsgSysChange, WM_WININICHANGE, (LONG) wWininiChange );
                }

            if (vfDevmodeChange)
                {
                Assert(hszDevmodeChangeParam != NULL);
                PostMessage( hWnd, wWndMsgSysChange, WM_DEVMODECHANGE, (LONG) 0 );
                vfDevmodeChange = fFalse;
                }

            if (!vfInitializing && vfCursorVisible)
                ShowCursor(wParam);
            break;

        case WM_ACTIVATEAPP:
            /* We are activated or deactivated by another application */
            if (wParam == 0)    /* being deactivated */
                {
                vfDeactByOtherApp = TRUE;
                vfDownClick = FALSE;
                /* hide selection if needed */
                if (!vfSelHidden)
                    {
                    UpdateWindow(hParentWw);
                    ToggleSel(selCur.cpFirst, selCur.cpLim, FALSE);
                    vfSelHidden = TRUE;
                    }

                /* Deselect our fonts so that they can move if necessary. */
                ResetFont(FALSE);
                if (vhWndCancelPrint == NULL)
                    {
                    /* Reset the printer font iff we are not printing or
                    repaginating.  */
                    ResetFont(TRUE);
                    }
                if (!vfLargeSys && vhfPageInfo != NULL)
                    {
                    DeleteObject(SelectObject(GetDC(vhWndPageInfo),
                      GetStockObject(SYSTEM_FONT)));
                    vhfPageInfo = NULL;
                    }
                }
            else                /* being activated */
                {
                vfDeactByOtherApp = vfWinFailure = FALSE;

#ifndef WIN30
                /* We get into a recursive loop in the situation where we
                   have a bad/invalid/nonexistent printer driver because
                   GetPrinterDC() calls CreateIC() which will end up sending
                   another WM_ACTIVATEAPP!  I think the machinery in Write
                   work just fine with a null vhDCPrinter, and will retry
                   again when it needs to do so ..pault 9/28/89 */

                /* get a DC for the current printer if necessary */
                if (vhDCPrinter == NULL)
                    {
                    GetPrinterDC(FALSE);
                    }
#endif

                /* hilight selection if needed */
                if (vfSelHidden)
                    {
                    UpdateWindow(hParentWw);
                    /* Turn on selection highlight
                    vfInsEnd = selCur.fEndOfLine;*/
                    vfSelHidden = FALSE;
                    ToggleSel(selCur.cpFirst, selCur.cpLim, TRUE);
                    }
                }
            break;

        case WM_TIMER:
            /* the only timer event for the parent window is flashID */
            /* the blinking insertion point is for the doc window */
            if (vfDeactByOtherApp)
                {
                FlashWindow(hParentWw, TRUE);
                }
            else
                {
                KillTimer(hParentWw, flashID);
                flashID = 0;
                FlashWindow(hParentWw, FALSE);
                }
            break;

        case WM_CLOSE:
            /* The user has selected "Close" on the system menu */
            /* Failure to process this message means that DefWindowProc */
            /* Will send us a Destroy message */
            /* A return value of TRUE says "don't close" */
            /* Calling DestroyWindow means "Go ahead and close" */

            lReturn = (LONG) !FMmwClose( hWnd );
            break;

        case WM_QUERYENDSESSION:
            /* User has selected "End Session" from the MS-DOS window */
            /* Return TRUE if willing to quit, else return FALSE */
            lReturn = (LONG) FConfirmSave();
            break;

        case WM_ENDSESSION:
            /* if wParam is TRUE, Windows is shutting down and we should */
            /* delete temp files */
            /* if wParam is FALSE, then an "End session" has been aborted */
            if (wParam)
                {
                KillTempFiles( TRUE );
                }
            break;

        case WM_DESTROY:
            /* Window's being destroyed. */
            MmwDestroy();
            lReturn = (LONG) TRUE;
            break;

        case WM_SIZE:
            /* Window's size is changing.  lParam contains the height
            ** and width, in the low and high words, respectively.
            ** wParam contains SIZENORMAL for "normal" size changes,
            ** SIZEICONIC when the window is being made iconic, and
            ** SIZEFULLSCREEN when the window is being made full screen. */
            MmwSize(hWnd, MAKEPOINT(lParam).x, MAKEPOINT(lParam).y, wParam);
            //if (wParam == SIZEICONIC)
                lReturn = DefWindowProc(hWnd, message, wParam, lParam);
            break;

        case WM_COMMAND:
            /* A menu item has been selected, or a control is notifying
            ** its parent.  wParam is the menu item value (for menus),
            ** or control ID (for controls).  For controls, the low word
            ** of lParam has the window handle of the control, and the hi
            ** word has the notification code.  For menus, lParam contains
            ** 0L. */

#ifdef RULERALSO
            if (!vfDisableMenus)
#endif /* RULERALSO */

                {
                MmwCommand(hWnd, wParam, (HWND)LOWORD(lParam), HIWORD(lParam));
                }
            break;

        case WM_SYSCOMMAND:
            /* system command */

#ifdef RULERALSO
            if (!vfDisableMenus)
#endif /* RULERALSO */
                {
                lReturn = DefWindowProc(hWnd, message, wParam, lParam);
                }

            break;

        case WM_VSCROLL:
            /* Vertical scroll bar input.  wParam contains the
            ** scroll code.  For the thumb movement codes, the low
            ** word of lParam contain the new scroll position.
            ** Possible values for wParam are: SB_LINEUP, SB_LINEDOWN,
            ** SB_PAGEUP, SB_PAGEDOWN, SB_THUMBPOSITION, SB_THUMBTRACK */
            MmwVertScroll(hWnd, wParam, (int)lParam);
            break;

        case WM_HSCROLL:
            /* Horizontal scroll bar input.  Parameters same as for
            ** WM_HSCROLL.  UP and DOWN should be interpreted as LEFT
            ** and RIGHT, respectively. */
            MmwHorzScroll(hWnd, wParam, (int)lParam);
            break;

        case WM_WININICHANGE:
            /* We first save away the string passed in lParam,
               then return because WM_ACTIVATE will cause our
               wWndMsgSysChange message to get posted ..pault */

            if (lParam != NULL)
                {
                bltszx((LPSTR) lParam, (LPSTR) szT);

                /* Here we only care about [devices], [windows] or [intl] changes */

                if (WCompSz(szT, szWindows) == 0)
                    wWininiChange |= wWininiChangeToWindows;

#ifdef  DBCS        /* was in JAPAN */
           //  We have to respond WININICHANGE immediately to deal with
           // dispatch driver. For deleting printer DC, dispatch driver
           // must be available. If do not so, syserr box comes up from
           // GDI module.

                if (WCompSz(szT, szDevices) == 0) {
                    if( vhWndCancelPrint == NULL ) {
                        MmwWinSysChange(WM_WININICHANGE);
                        wWininiChange = 0; // reset
                    }
                    else
                        wWininiChange |= wWininiChangeToDevices;
                }
#else
                if (WCompSz(szT, szDevices) == 0)
                    wWininiChange |= wWininiChangeToDevices;
#endif

                if (WCompSz(szT, szIntl) == 0)
                    wWininiChange |= wWininiChangeToIntl;

                lReturn = TRUE;
                }
            break;
        case WM_DEVMODECHANGE:
            /* See WM_WININICHANGE above */

            if (lParam != NULL)
                {
                CHAR (**HszCreate())[];
                bltszx((LPSTR) lParam, (LPSTR) szT);

                /* was there another change before this? */
                if (hszDevmodeChangeParam != NULL)
                    FreeH(hszDevmodeChangeParam);
                hszDevmodeChangeParam = HszCreate(szT);
                vfDevmodeChange = fTrue;
                lReturn = TRUE;
                }
            break;

        case WM_SYSCOLORCHANGE:
        case WM_FONTCHANGE:
            /* Post this message to handle soon */
            PostMessage( hWnd, wWndMsgSysChange, message, (LONG) 0 );
            lReturn = TRUE;
            break;

        case wWndMsgSysChange:
            /* Handle postponed message from windows */

#ifdef DEBUG
            if (wWininiChange != 0)
                Assert(wWininiChange > 0 && wWininiChange < wWininiChangeMax);
#endif
                MmwWinSysChange( wParam );
                wWininiChange = 0; /* reset */
            lReturn = TRUE;
            break;

        default:
            /* Everything else comes here.  This call MUST exist
            ** in your window proc.  */
            lReturn = DefWindowProc(hWnd, message, wParam, lParam);
            break;
        }

 if (vfCloseFilesInDialog)
    CloseEveryRfn( FALSE );

 return lReturn;
}


void NEAR MmwPaint(hWnd)
HWND hWnd;
{
    /* This window is completely covered by it's children; so, there is
    no painting of this window to do. */

    extern HWND vhWndRuler;
    extern HWND vhWndSizeBox;
    extern HWND vhWndPageInfo;
    PAINTSTRUCT ps;
    HDC hDC;

    hDC = BeginPaint(hWnd, &ps); // this is causing nested BeginPaint calls,
    DrawResizeHole(hWnd,hDC);

    /* Paint the ruler if necessary. */
    if (vhWndRuler != NULL)
        {
        UpdateWindow(vhWndRuler);
        }

    /* Paint the scroll bar controls. */
    UpdateWindow(wwdCurrentDoc.hVScrBar);
    UpdateWindow(wwdCurrentDoc.hHScrBar);
    UpdateWindow(vhWndPageInfo);

    /* Paint the document window. */
    if (wwdCurrentDoc.wwptr != NULL)
        {
        UpdateWindow(wwdCurrentDoc.wwptr);
        }

    EndPaint(hWnd, &ps);
}


void MmwVertScroll(hWnd, code, posNew)
HWND hWnd;
WORD code;
int posNew;
{
extern int vfSeeSel;
extern int vfSeeEdgeSel;

    /* There's nothing to do if we are just tracking the thumb. */
    if (code == SB_THUMBTRACK)
        {
        return;
        }

    vfSeeSel = vfSeeEdgeSel = FALSE;    /* So Idle doesn't override the scroll */

    if (code == SB_THUMBPOSITION)
        {
        /* Position to posNew; we rely upon Idle() to redraw the screen. */
        if (posNew != pwwdCur->drElevator)
            {
            ClearInsertLine();
            DirtyCache(pwwdCur->cpFirst = (cpMacCur - pwwdCur->cpMin) * posNew
              / (drMax - 1) + pwwdCur->cpMin);
            pwwdCur->ichCpFirst = 0;
            pwwdCur->fCpBad = TRUE;
            TrashWw(wwCur);
            }
        }
    else
        {
        switch (code)
            {
            case SB_LINEUP:
                ScrollUpCtr( 1 );
                break;
            case SB_LINEDOWN:
                ScrollDownCtr( 1 );
                break;
            case SB_PAGEUP:
                ScrollUpDypWw();
                break;
            case SB_PAGEDOWN:
                ScrollDownCtr( 100 );   /* 100 > tr's in a page */
                break;
            }
        UpdateWw(wwDocument, fFalse);
        }
}


void near MmwHorzScroll(hWnd, code, posNew)
HWND hWnd;
WORD code;
int posNew;
{
extern int vfSeeSel;
extern int vfSeeEdgeSel;

    /* There's nothing to do if we are just tracking the thumb. */
    if (code == SB_THUMBTRACK)
        {
        return;
        }

    vfSeeSel = vfSeeEdgeSel = FALSE;    /* So Idle doesn't override the scroll */

    switch (code)
        {
        case SB_LINEUP:     /* line left */
            ScrollRight(xpMinScroll);
            break;
        case SB_LINEDOWN:   /* line right */
            ScrollLeft(xpMinScroll);
            break;
        case SB_PAGEUP:     /* page left */
            ScrollRight(wwdCurrentDoc.xpMac - xpSelBar);
            break;
        case SB_PAGEDOWN:   /* page right */
            ScrollLeft(wwdCurrentDoc.xpMac - xpSelBar);
            break;
        case SB_THUMBPOSITION:
            /* position to posNew */
            AdjWwHoriz(posNew - wwdCurrentDoc.xpMin);
            break;
        }
}

static void DrawResizeHole(HWND hWnd, HDC hDC)
/* There's now a hole in the bottom right corner where
    the size box used to be, so need to fill it in! */
{
    RECT rcSB,rcClient;
    HBRUSH hbr, hbrPrev;

    GetClientRect(hWnd,&rcClient);

    rcSB.left   = rcClient.right - dxpScrlBar;
    rcSB.right  = rcClient.right;
    rcSB.top    = rcClient.bottom - dypScrlBar;
    rcSB.bottom = rcClient.bottom;

    if ((hbr = CreateSolidBrush(GetSysColor(COLOR_SCROLLBAR))) == NULL)
        hbr = GetStockObject(GRAY_BRUSH);
    hbrPrev = SelectObject(hDC, hbr);
    FillRect(hDC, (LPRECT)&rcSB, hbr);

    SelectObject(hDC, hbrPrev);
    DeleteObject(hbr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\msseqds.asm ===
title   Special Export call locations for DS == SS conversion.

; Windows Write, Copyright 1985-1992 Microsoft Corporation

?DF  = 1                     ; Dont generate default segment definitions
?PLM = 1
        .XLIST
        include cmacros.inc
        .LIST

        subttl  Define Windows Groups
        page

MGROUP      group   HEADER,EXPORTS,IMPORTS,IMPORTEND,ENDHEADER
IGROUP      group   _TEXT,_INITTEXT,_ENDTEXT
DGROUP      group   _DATA,DATA,CDATA,CONST,_BSS,c_common,_INITDATA,_ENDDATA,STACK
HEADER      segment para 'MODULE'
HEADER      ENDS
EXPORTS     segment byte 'MODULE'
EXPORTS     ENDS
IMPORTS     segment byte public 'MODULE'
IMPORTS     ENDS
IMPORTEND   segment byte 'MODULE'
IMPORTEND   ENDS
ENDHEADER   segment para 'MODULE'
ENDHEADER   ENDS
_TEXT       segment byte public 'CODE'
_TEXT       ENDS
_INITTEXT   segment para public 'CODE'
_INITTEXT   ends
_ENDTEXT    segment para 'CODE'
_ENDTEXT    ends

_DATA       segment para public 'DATA'

STACKSIZE   =   2048

$$STACK     dw  STACKSIZE   dup (?)
$$STACKTOP  label   word
            dw  0

_DATA       ends

DATA        segment para public 'DATA'
DATA        ends
CDATA       segment word common 'DATA'      ; C globals end up here
CDATA       ends
CONST       segment word public 'CONST'
CONST       ends
_BSS        segment para public 'BSS'
_BSS        ends
c_common    segment para common 'BSS'       ; C globals end up here
c_common    ends
_INITDATA   segment para public 'BSS'
_INITDATA   ends
_ENDDATA    segment para 'BSS'
_ENDDATA    ends

STACK       segment para stack 'STACK'
            DB      0                       ; Force link to write entire DGROUP
STACK       ends

        subttl  ENTRYPOINT definition
        page

ENTRYPOINT  MACRO   name, cwArgs
        extrn   x&name:far
        public  name
name    proc    far
        mov     ax,ds               ; we have to include all this code
        nop                         ; or exe2mod chokes
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ds,ax

        mov     cx,cwArgs * 2
        mov     dx,offset igroup:x&name
        jmp     SetLocStack
name    endp

        ENDM

        subttl  external->local stack switcher
        page

_TEXT   segment byte public 'CODE'
        assume  cs:igroup, ds:dgroup, es:dgroup, ss:nothing

;
; SetLocStack
;
;       Purpose:        To switch to a seperate stack located in the
;                       Modules Data Segment.
;
;       Inputs:         AX = module's DS
;                       SS, SP, BP = caller's stack stuff
;                       DS = "true" entry point addr
;                       cx = no. of bytes of parameters on caller's stack
;
SetLocStack  proc    near
        mov     bx,ss                   ; get copy of current segment
        cmp     ax,bx                   ; see if we're already in local stack
        je      inlocal                 ; we are - fall into existing code

        mov     cs:SESPat,cx            ; save arg byte count for return

        mov     ss,ax
        mov     sp,offset dgroup:$$STACKTOP

        push    bx                      ; save old ss
        sub     bp,2                    ; point at the pushed ds
        push    bp                      ; and  old sp
        push    si                      ; save si

        jcxz    argdone

        mov     ds,bx
        lea     si,[bp + 8 - 2]         ; point past ds, bp, far addr to args
        add     si,cx                   ; point at top of args for backward move

        std
        shr     cx,1                    ; divide byte count by two
        jcxz    argdone
argloop:
        lodsw
        push    ax
        loop    argloop
        cld

argdone:
        push    cs
        mov     ax,offset igroup:SetExtStack  ; push setextstack return addr
        push    ax

        mov     ax,ss                   ; get new ds into ds and ax
        mov     ds,ax

        push    dx                      ; jump to true entry point via RET
        ret

inlocal:
        add     dx,10                   ; point past prolog code
        push    dx                      ; jump into middle of prolog code
        ret

SetLocStack     endp

SetExtStack     proc    near
        pop     si                      ; get back saved si
        pop     bp                      ; get old sp
        pop     bx                      ; and old ss

        mov     ss,bx
        mov     sp,bp                   ; now set them up

        pop     ds                      ; standard epilog stuff
        pop     bp
        dec     bp

        db      0cah                    ;RETF n instruction
SESPat  dw      0

SetExtStack     endp

        subttl  Entry point definitions
        page
;
; mp module entry points
;
ENTRYPOINT MMpNew,    3
ENTRYPOINT MMpLoad,   2
ENTRYPOINT MMpFree,   2
;
; routines called by interface module
;
ENTRYPOINT MRgchVal, 6
ENTRYPOINT Mdecode,  2
ENTRYPOINT MEnter,   1
ENTRYPOINT Fill,     1
ENTRYPOINT Clear,    0
ENTRYPOINT Format,   1
ENTRYPOINT MCellsContract, 0
ENTRYPOINT MInsertBents,   8
ENTRYPOINT MSheetCut, 0
ENTRYPOINT MSheetCopy, 0
ENTRYPOINT MSheetPaste, 1
ENTRYPOINT MExeCut, 0
ENTRYPOINT MExePaste, 0
ENTRYPOINT CheckRecalc, 0
ENTRYPOINT recalc, 1
ENTRYPOINT MLoadSheet, 2
ENTRYPOINT MSaveSheet, 3
ENTRYPOINT MSortDialog, 4


_TEXT   ENDS

        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\obj.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/
#ifndef OLEH
#define OLEH
#include <ole.h>

//#define SMALL_OLE_UI

/* 
 * Constant IDs used in the Object Properties... dialog
 */
#define IDD_WHAT	    0x0100
#define IDD_CLASSID     0x0101
#define IDD_AUTO        0x0102
#define IDD_MANUAL      0x0103
#define IDD_EDIT        imiActivate
#define IDD_FREEZE      imiFreeze
#define IDD_UPDATE      imiUpdate
#define	IDD_CHANGE	    0x106
#define	IDD_LINK	    0x107
#define	IDD_LINKDONE	0x108
#define	IDD_LISTBOX 	0x109
#define	IDD_EMBEDDED	0x110
#define IDD_PLAY        0x111
#define IDD_UNDO        0x112
#define IDD_REFRESH     0x113
#define IDD_UPDATEOTHER 0x114
#define IDD_WAIT	    0x115
#define IDD_MESSAGE     0x116
#define IDD_CLIPOWNER   0x117
#define IDD_ITEM        0x118
#define IDD_PASTE       0x119
#define IDD_PASTELINK   0x11a
#define IDD_SOURCE      0x11b
#define IDD_SWITCH      0x11c

typedef enum { NONE, STATIC, EMBEDDED, LINK } OBJECTTYPE;

#define UPDATE_INVALID() CatchupInvalid(hDOCWINDOW)

#define PROTOCOL 	((LPSTR)"StdFileEditing")
#define	SPROTOCOL	((LPSTR)"Static")
#if OBJ_EMPTY_OBJECT_FRAME
#define nOBJ_BLANKOBJECT_X 0x480
#define nOBJ_BLANKOBJECT_Y 0x480
#else
#define nOBJ_BLANKOBJECT_X 0x0
#define nOBJ_BLANKOBJECT_Y 0x0
#endif

#define wOleMagic 0137062 // for ole file headers (wMagic+1)
#define OBJ_PLAYEDIT ObjPlayEdit
#if !defined(SMALL_OLE_UI)
#define EDITMENUPOS 9
#else
#define EDITMENUPOS 7
#endif

/* number of timer ticks between garbage collection */
#define GARBAGETIME  200
extern int nGarbageTime;

/* properties list flags */
#define OUT     0
#define IN      1
#define DELETED 2

/* for ObjDeletionOK and fnClearEdit */
#define OBJ_DELETING 0
#define OBJ_INSERTING  1
#define OBJ_CUTTING  2

#define UNDO_EVERY_UPDATE 
#undef UPDATE_UNDO

typedef char szOBJNAME[9];

/* object information that needn't be stored in file.  This is also used as
   the OLECLIENT structure passed to the OLE object creation API's.  It is
   passed as an argument into the Callback proc. */
struct _OBJINFO
{
    LPOLECLIENTVTBL   lpvtbl;
    unsigned fTooBig        : 1; // see LoadObject
    unsigned fWasUpdated    : 1; // Links diaog crappola
    unsigned fPropList      : 2; // Links diaog crappola
    unsigned fDirty         : 1; // changed size or got updated
    unsigned fDontSaveData  : 1; // see ObjSaveObject
    unsigned fBadLink       : 1; // Links dialog
    unsigned fKillMe        : 1; // means return FALSE for QUERYRETRY
    unsigned fDeleteMe      : 1; // means this object is deleted on OLE_RELEASE
                                 //   (set if can't call OleDelete)
    unsigned fReleaseMe      : 1; // means this object is released on OLE_RELEASE
                                 //   (set if can't call OleDelete)
    unsigned fFreeMe        : 1; // free ObjInfo on OLE_RELEASE
    unsigned fReuseMe       : 1;
    unsigned fInDoc         : 1; // see CollectGarbage

    /* waiting for server dialog flags */
    unsigned fCancelAsync   : 1; // means cancel pending async if possible
    unsigned fCompleteAsync : 1; // means must complete pending async to allow cancel
    unsigned fCanKillAsync  : 1; // like CompleteAsync, indicates cancel is possible

    int    OlePlay;          
    LPOLEOBJECT lpobject;
    ATOM  aName;        // docname for links, server class for unfinished insertnew objects,
    ATOM  aObjName;     // unique object name

    struct _OBJINFO FAR *lpclone;      // clone used for link properties cancel
    typeCP cpWhere;     /* cp where picinfo is to be found (only used in ObjHasChanged! for NONE objects) */
    OLECLIPFORMAT objectType;   /* dup of what's in picInfo (so can get type
                                   for unfinished objects not yet stored in a picinfo)
                                 */

    unsigned fCantDisplay  : 1;
} ;
typedef struct _OBJINFO OBJINFO;
typedef OBJINFO FAR * LPOBJINFO ;
typedef LPOBJINFO FAR * LPLPOBJINFO;

/* the following return OBJINFO pointers */
#define lpOBJ_QUERY_UPDATE_UNDO(lpPicInfo)  (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->lpUndoUpdate)
#if defined(UNDO_EVERY_UPDATE)
#define lpOBJ_QUERY_UPDATE_UNDO2(lpPicInfo)  (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->lpUndoUpdate2)
#endif
#define lpOBJ_QUERY_CLONE(lpPicInfo)        (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->lpclone)
#define lpOBJ_QUERY_INFO(lpPicInfo)         (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo)

/* the following return stuff from lpPicInfo */
#define dwOBJ_QUERY_OBJECT_NUM(lpPicInfo)   (((lpOBJPICINFO)(lpPicInfo))->dwObjNum)
#define dwOBJ_QUERY_DATA_SIZE(lpPicInfo)    (((lpOBJPICINFO)(lpPicInfo))->dwDataSize)
#define bOBJ_QUERY_IS_OBJECT(lpPicInfo)     (((lpOBJPICINFO)(lpPicInfo))->mm == MM_OLE)

/* the following return stuff from lpPicInfo->lpObjInfo */
#define otOBJ_QUERY_TYPE(lpPicInfo)         (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->objectType)
#define docOBJ_QUERY_DOC(lpPicInfo)        (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->doc)
#define cpOBJ_QUERY_WHERE(lpPicInfo)        (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->cpWhere)
#define lpOBJ_QUERY_CLONE_OBJECT(lpPicInfo)        (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->lpclone->lpobject)
//#define uoiFLAGS(lpObjInfo) (*((unsigned FAR *)((LPSTR)lpObjInfo + sizeof(LPOLECLIENTVTBL))))
#define bOBJ_REUSE_ME(lpPicInfo)            (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fReuseMe)
#define fOBJ_INDOC(lpPicInfo)               (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fInDoc)
#define fOBJ_BADLINK(lpPicInfo)             (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fBadLink)
#define bOBJ_QUERY_DONT_SAVE_DATA(lpPicInfo) (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fDontSaveData)
#define bOBJ_QUERY_DATA_INVALID(lpPicInfo)  (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fDataInvalid)
#define bOBJ_QUERY_TOO_BIG(lpPicInfo)       (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fTooBig)
#define bOBJ_WAS_UPDATED(lpPicInfo)         (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fWasUpdated)
//#define aOBJ_QUERY_SERVER_CLASS(lpPicInfo)  (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->aName)
#define aOBJ_QUERY_DOCUMENT_LINK(lpPicInfo) (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->aName)
#define lpOBJ_QUERY_OBJECT(lpPicInfo)       (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->lpobject)
#define fOBJ_QUERY_DIRTY_OBJECT(lpPicInfo)  (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fDirty)
#define fOBJ_QUERY_IN_PROP_LIST(lpPicInfo)  (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fPropList)
#define fOBJ_QUERY_PLAY(lpPicInfo)          (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->OlePlay)
#define cfOBJ_QUERY_CLIPFORMAT(lpPicInfo)   ( \
    ((((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->objectType) == EMBEDDED) ? vcfNative : \
    ((((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->objectType) == LINK)     ? vcfLink : \
    ((((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->objectType) == STATIC)   ? vcfOwnerLink : NULL)



/* this coerces the PICINFO structure: */
typedef struct
{
    /* overlay METAFILEPICT structure: */
    int mm;                     // mfp.mm  (MM_OLE if an object)
    WORD xExt; // not used
    WORD yExt; // not used
    OLECLIPFORMAT objectType;   // mfp.hMF

    /* real PICINFO stuff we won't mess with: */
    int  dxaOffset;
    int  dxaSize;
    int  dyaSize;
    WORD cbOldSize; // not used

    /* overlay the BITMAP structure: */
    DWORD   dwDataSize;       // bmType,bmWidth, this supercedes cbSize
    WORD  bmHeight; // not used
    WORD  bmWidthBytes; // not used
    DWORD dwObjNum;           // bmPlanes,bmBitsPixel, 2 bytes of bmBits
    WORD  bmBits; // two bytes of it, not used
    /** 
        If you want to add more fields here, don't wipe out the cbHeader,
        mx and my fields because they are being used. 
     **/
    unsigned cbHeader;        
    LPOBJINFO lpObjInfo;      // cbSize
    unsigned mx, my;         
} OBJPICINFO, FAR *lpOBJPICINFO;

extern LPLPOBJINFO lplpObjInfo;
extern LHCLIENTDOC      lhClientDoc;
extern BOOL	            fOleEnabled;
extern LPOLESTREAM	    lpStream;
extern OLESTREAMVTBL	streamTbl;
extern OLECLIENTVTBL	clientTbl;
//extern LPOLECLIENT	    lpclient;
extern OBJECTTYPE       votObjSelType;

extern HWND		        hwndLinkWait;
extern FARPROC          lpfnLinkProps;
extern FARPROC          lpfnObjProps;
extern FARPROC          lpfnWaitForObject;
extern FARPROC          lpfnInvalidLink;
extern FARPROC          lpfnInsertNew;
extern FARPROC          lpfnPasteSpecial;
extern BOOL             vbObjLinkOnly;
extern BOOL             vObjPasteLinkSpecial;
extern WORD             cfObjPasteSpecial;
//extern int              vcEmbeds;
extern int		        cObjWait;	/* Count of "open" OLE transactions */
extern OLECLIPFORMAT	vcfNative;
extern OLECLIPFORMAT	vcfLink;
extern OLECLIPFORMAT	vcfOwnerLink;
extern ATOM             aNewName;
extern ATOM             aOldName;    
extern BOOL             bLinkProps;
extern int              vcObjects;  // count in doc. Note limit of 32K!!!
extern int              ObjPlayEdit;
extern int              nBlocking;
extern int              vcVerbs;
extern BOOL             vbCancelOK;
extern HWND		        hwndWait;

void CatchupInvalid(HWND hWnd);
extern int FAR PASCAL fnPasteSpecial(HWND hDlg, unsigned message, WORD wParam, LONG lParam);
extern int FAR PASCAL fnInsertNew(HWND hDlg, unsigned msg, WORD wParam, LONG lParam) ;
extern BOOL FAR PASCAL fnObjWait(HWND hDlg, unsigned msg, WORD wParam, LONG lParam);
extern   int far PASCAL fnProperties();
extern   int far PASCAL fnInvalidLink();
extern   void fnObjDoVerbs(WORD wVerb);
extern   void fnObjProperties(void);
extern   void fnObjInsertNew(void);
extern   BOOL fnObjFreeze(LPOLEOBJECT far *lplpObject, szOBJNAME szObjName);
extern   BOOL fnObjActivate(LPOLEOBJECT lpObject);
extern   BOOL fnObjUpdate(LPOBJINFO lpObjInfo);
extern   void fnObjPasteSpecial(void);
extern   ATOM MakeLinkAtom(LPOBJINFO lpObjInfo);


#ifdef DEBUG
extern void ObjPrintError(WORD stat,BOOL bRelease);
#endif

extern BOOL ObjUpdateFromPicInfo(OBJPICINFO *pPicInfo,szOBJNAME szObjName);
extern BOOL ObjUpdateFromObjInfo(OBJPICINFO *pPicInfo);
void FinishUp(void);
BOOL FinishAllAsyncs(BOOL bAllowCancel);
BOOL FAR ObjError(OLESTATUS olestat) ;
extern BOOL ObjDeletionOK(int nMode);
//extern BOOL ObjContainsUnfinished(int doc, typeCP cpFirst, typeCP cpLim);
extern BOOL ObjContainsOpenEmb(int doc, typeCP cpFirst, typeCP cpLim, BOOL bLookForUnfinished);
extern BOOL ObjSetTargetDeviceForObject(LPOBJINFO lpObjInfo);
extern void ObjSetTargetDevice(BOOL bSetObjects);
extern BOOL ObjSetClientInfo(LPOBJINFO lpObjInfoNew, LPOLEOBJECT lpobj);
extern  WORD  _cdecl  CheckPointer (LPSTR lp, WORD access);
extern LPOBJINFO ObjGetClientInfo(LPOLEOBJECT lpobj);
extern BOOL ObjIsValid(LPOLEOBJECT lpobj);
extern BOOL ObjFreeObjInfoWithObject(LPOLEOBJECT lpObject);
extern BOOL ObjAllocObjInfo(OBJPICINFO *,typeCP,OBJECTTYPE,BOOL,szOBJNAME);
extern BOOL ObjFreeObjInfo(OBJPICINFO *pPicInfo);
extern LONG FAR PASCAL BufReadStream(LPOLESTREAM lpStream, char huge *lpstr, DWORD cb) ;
extern LONG FAR PASCAL BufWriteStream(LPOLESTREAM lpStream, char huge *lpstr, DWORD cb) ;
extern BOOL ObjUpdatePicSize(OBJPICINFO *pPicInfo, typeCP cpParaStart);
extern BOOL ObjSetPicInfo(OBJPICINFO *pSrcPicInfo, int doc, typeCP cpParaStart);
extern void ObjCachePara(int doc, typeCP cp);
extern void ObjUpdateMenu(HMENU hMenu);
extern void ObjUpdateMenuVerbs( HMENU hMenu );
extern void ObjShutDown(void);
extern BOOL ObjInit(HANDLE hInstance);
extern BOOL ObjCreateObjectInClip(OBJPICINFO *pPicInfo);
extern BOOL ObjWriteToClip(OBJPICINFO FAR *lpPicInfo);
extern BOOL ObjDisplayObjectInDoc(OBJPICINFO FAR *lpPicInfo, int doc, typeCP cpParaStart, HDC hDC, LPRECT lpBounds);
extern BOOL ObjQueryObjectBounds(OBJPICINFO FAR *lpPicInfo, HDC hDC, 
                            int *pdxa, int *pdya);
extern ObjGetPicInfo(LPOLEOBJECT lpObject, int doc, OBJPICINFO *pPicInfo, typeCP *pcpParaStart);
extern BOOL ObjQueryNewLinkName(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern BOOL CloseUnfinishedObjects(BOOL bSaving);
extern BOOL ObjOpenedDoc(int doc);
extern BOOL ObjClosingDoc(int docOld,LPSTR szNewDocName);
extern BOOL ObjSavingDoc(BOOL bFormatted);
extern void ObjSavedDoc(void);
extern void ObjRenamedDoc(LPSTR szNewName);
extern void ObjRevertedDoc();
extern void ObjObjectHasChanged(int flags, LPOBJINFO lpObjInfo);
extern void ObjGetObjectName(LPOBJINFO lpObjInfo, szOBJNAME szObjName);
extern void ObjMakeObjectName(LPOBJINFO lpObjInfo, LPSTR lpstr);
extern void ObjHandleBadLink(OLE_RELEASE_METHOD rm, LPOLEOBJECT lpObject);
extern void ObjQueryInvRect(OBJPICINFO FAR *lpPicInfo, RECT *rc, typeCP cp);
extern void ObjReleaseError(OLE_RELEASE_METHOD rm);
extern char *ObjGetServerName(LPOLEOBJECT lpObject, char *szServerName);
extern void ObjGetDrop(HANDLE hDrop, BOOL bOpenFile);
extern LPOBJINFO GetObjInfo(LPOLEOBJECT lpObject);
extern BOOL ObjDeleteObjInfo(LPOBJINFO lpOInfo);

/* enumeration functions */
extern LPLPOBJINFO EnumObjInfos(LPLPOBJINFO lpObjInfoPrev);
extern ObjPicEnumInRange(OBJPICINFO *pPicInfo,int doc, typeCP cpFirst, typeCP cpLim, typeCP *cpCur);
typedef typeCP (FAR PASCAL *cpFARPROC)();
extern int ObjEnumInDoc(int doc, cpFARPROC lpFunc);
extern int ObjEnumInAllDocs(cpFARPROC lpFunc);
extern int ObjEnumInRange(int doc, typeCP cpStart, typeCP cpEnd, cpFARPROC lpFunc);
extern typeCP ObjSaveObjectToDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjReleaseObjectInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjLoadObjectInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjNullObjectInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjDeleteObjectInDoc (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjCloneObjectInDoc  (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjCheckObjectTypes  (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjChangeLinkInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjFreezeObjectInDoc (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjUpdateObjectInDoc (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjUpdateLinkInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjMakeUniqueInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjPlayObjectInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjEditObjectInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjSetNoUpdate       (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjToCloneInDoc      (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjFromCloneInDoc    (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjClearCloneInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjUseCloneInDoc     (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjBackupInDoc       (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjNewDocForObject   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjSetHostNameInDoc  (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjSetUpdateUndo     (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjClearUpdateUndo   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjCloseObjectInDoc(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart);

extern BOOL ObjCreateObjectInDoc (int doc,typeCP cpParaStart);
extern void ObjDoUpdateUndo(int doc,typeCP cpParaStart);
extern BOOL ObjSetData(OBJPICINFO far *lpPicInfo, OLECLIPFORMAT cf, HANDLE hData);
extern OLESTATUS ObjGetData(LPOBJINFO lpObjInfo, OLECLIPFORMAT cf, HANDLE far *lphData);
extern void UpdateOtherLinks(int doc);
extern void ChangeOtherLinks(int doc, BOOL bChange, BOOL bPrompt);
extern BOOL ObjSetUpdateOptions(OBJPICINFO *pPicInfo, WORD wParam, int doc, typeCP cpParaStart) ;
extern OLEOPT_UPDATE ObjGetUpdateOptions(OBJPICINFO far *lpPicInfo);
extern BOOL ObjWaitForObject(LPOBJINFO lpObjInfo,BOOL bCancelOK);
extern BOOL ObjObjectSync(LPOBJINFO lpObjInfo, OLESTATUS (FAR PASCAL *lpProc)(LPOLEOBJECT lpObject),BOOL bCancelOK);
extern int ObjSetSelectionType(int doc, typeCP cpFirst, typeCP cpLim);
extern BOOL ObjQueryCpIsObject(int doc,typeCP cpFirst);
extern FixInvalidLink(OBJPICINFO far *lpPicInfo,int doc, typeCP cpParaStart);
extern void OfnInit(HANDLE hInst);
extern ObjPushParms(int doc);
extern ObjPopParms(BOOL bCache);
void ObjWriteClearState(int doc);
extern void ObjInvalidateObj(LPOLEOBJECT lpObject);
extern void ObjInvalidatePict(OBJPICINFO *pPicInfo, typeCP cp);
extern BOOL ObjDeletePrompt(int doc,typeCP cpFirst,typeCP cpLim);
extern BOOL ObjSetHostName(LPOBJINFO lpOInfo, int doc);
extern void ObjTryToKill(OBJPICINFO *pPicInfo);
extern BOOL ObjCloneObjInfo(OBJPICINFO *pPicInfo, typeCP cpParaStart, szOBJNAME szObjName);
extern LPOBJINFO ObjGetObjInfo(szOBJNAME szObjName);
extern BOOL ObjCopyObjInfo(LPOBJINFO lpOldObjInfo, LPLPOBJINFO lplpNewObjInfo, szOBJNAME szObjName);
extern BOOL ObjDeleteObject(LPOBJINFO lpObjInfo,BOOL bDelete);
extern void ObjAdjustCps(int doc,typeCP cpLim, typeCP dcpAdj);
extern void ObjAdjustCpsForDeletion(int doc);
extern BOOL GimmeNewPicinfo(OBJPICINFO *pPicInfo, LPOBJINFO lpObjInfo);
extern BOOL ObjMakeObjectReady(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart);
extern BOOL ObjInitServerInfo(LPOBJINFO lpObjInfo);

#ifdef KOREA
extern CHAR     szAppName[13];
#else
extern CHAR     szAppName[10];
#endif

extern HWND     vhWndMsgBoxParent,hParentWw,vhWnd;
extern HANDLE   hMmwModInstance;
extern int              vdocParaCache;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern int              docCur;
extern struct SEL       selCur;
extern int  docMac;

#define	WM_UPDATELB	    (WM_USER+0x100)
#define	WM_UPDATEBN	    (WM_USER+0x101)
#define	WM_OBJUPDATE    (WM_USER+0x102)
#define	WM_OBJERROR     (WM_USER+0x103)
#define	WM_OBJBADLINK   (WM_USER+0x104)
#define	WM_DOLINKSCOMMAND (WM_USER+0x105)
#define WM_UPDATE_INVALID (WM_USER+0x106)
#define WM_OBJDELETE     (WM_USER+0x107)
#define WM_DIESCUMSUCKINGPIG     (WM_USER+0x108)
#define WM_RUTHRUYET        (WM_USER+0x109)
#define WM_UKANKANCEL       (WM_USER+0x10a)
#define WM_WAITFORSERVER    (WM_USER+0x10b)

#define szDOCCLASS "WINWRITE"
#define hINSTANCE  hMmwModInstance
#define hDOCWINDOW vhWnd
#define hMAINWINDOW hParentWw
#define hPARENTWINDOW  ((vhWndMsgBoxParent == NULL) ? \
                    hParentWw : vhWndMsgBoxParent)

#define OBJ_SELECTIONTYPE (votObjSelType)

typedef struct {
    WORD deviceNameOffset;
    WORD driverNameOffset;
    WORD portNameOffset;
    WORD extDevmodeOffset;
    WORD extDevmodeSize;
    WORD environmentOffset;
    WORD environmentSize;
} STDTARGETDEVICE;
typedef STDTARGETDEVICE FAR *LPSTDTARGETDEVICE;

#if 0
typedef struct _RAWOLEOBJECT {
    LPOLEOBJECTVTBL lpvtbl;
    char            objId[2];
    HOBJECT         hobj;
    LPOLECLIENT     lpclient;
    } RAWOBJECT;
typedef RAWOBJECT FAR *LPRAWOBJECT;
#endif

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\objmini.asm ===
;\
    ;   obj.asm
    ;
    ;   Copyright (C) 1992, MicroSoft Corporation
    ;
    ;   Contains pointer validation routine
    ;       
    ;   History:  sriniK   02/01/1991 original
    ;             (8.20.91) v-dougk made into far proc
   ;/               

.286p
.MODEL MEDIUM
.CODE

;**************************** _CheckPointer ****************************
;
;   WORD    _CheckPointer (lp, access)
;
;   Args:
;       lp          pointer to be verified
;       access      0 test the pointer for read access
;                   1 test the pointer for write access
;   returns: 
;       FALSE       invalid pointer
;       TRUE        valid pointer
;
;
;
        public  _CheckPointer

_CheckPointer   proc

            push    bp
            mov     bp, sp
            
            xor     ax, ax ; assume an error
            and     word ptr [bp+0AH], -1
            jnz     check_write_access

            verr    word ptr [bp+8]     ; check selector for read access
            jnz     error
            jmp short check_offset

check_write_access:
            verw    word ptr [bp+8]     ; check selector for write access
            jnz     error                                         
                                                                        
check_offset:
            lsl     bx, word ptr [bp+8] ; segment limit gets copied into BX
            jnz     error                                         
            cmp     [bp+6], bx          
            ja      error                                       
            or      ax, -1                                              
error:                  
            pop     bp
            ret

_CheckPointer   endp


            end


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\obj3.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/
#include "windows.h"
#include "mw.h"
#include "winddefs.h"
#include "obj.h"
#include "menudefs.h"
#include "cmddefs.h"
#include "str.h"
#include "objreg.h"
#include "docdefs.h"
#include "editdefs.h"
#include "propdefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#include "shellapi.h"
#include <commdlg.h>

extern BOOL ferror;
extern HCURSOR      vhcArrow;
extern  HCURSOR     vhcIBeam;
extern struct DOD (**hpdocdod)[];
extern struct PAP      vpapAbs;
extern struct UAB       vuab;
extern struct WWD       rgwwd[];
extern BOOL         bKillMe;
extern BOOL fPropsError;
extern int docScrap;
extern int          docUndo;
extern PRINTDLG PD;

static BOOL DoLinksCommand(WORD wParam, DWORD lParam, HWND hDlg, BOOL *bError);

/****************************************************************/
/*********************** OLE DISPLAY HANDLING *******************/
/****************************************************************/
BOOL ObjDisplayObjectInDoc(OBJPICINFO far *lpPicInfo,
                           int doc, typeCP cpParaStart,
                           HDC hDC, LPRECT lpBounds)
{
    BOOL bSuccess;


    if (lpOBJ_QUERY_INFO(lpPicInfo) == NULL)
        return(FALSE);

#ifndef JAPAN  // added by Hiraisi (BUG#2732/WIN31)
    // If we return here, we can never redraw the object again.
    if (lpOBJ_QUERY_INFO(lpPicInfo)->fCantDisplay)
        return(FALSE);
#endif  // not JAPAN

    if (otOBJ_QUERY_TYPE(lpPicInfo) == NONE)
    switch(otOBJ_QUERY_TYPE(lpPicInfo))
    {
        case NONE:
        {
#if OBJ_EMPTY_OBJECT_FRAME
            extern DrawBlank(HDC hDC, RECT FAR *rc);
            DrawBlank(hDC,lpBounds);
#else
#ifdef DEBUG
            OutputDebugString( (LPSTR) "Displaying empty object\n\r");
#endif
#endif
            return TRUE;
        }
    }

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Displaying object\n\r");
#endif

#ifdef JAPAN   // added by Hiraisi (BUG#2732/WIN31)
    if (lpOBJ_QUERY_INFO(lpPicInfo)->fCantDisplay)
       bSuccess = (OLE_OK == OleDraw(lpOBJ_QUERY_OBJECT(lpPicInfo),hDC,lpBounds,NULL,NULL));
    else
       bSuccess = !ObjError(OleDraw(lpOBJ_QUERY_OBJECT(lpPicInfo),hDC,lpBounds,NULL,NULL));
    if (!bSuccess)
        lpOBJ_QUERY_INFO(lpPicInfo)->fCantDisplay = TRUE;
    else
        lpOBJ_QUERY_INFO(lpPicInfo)->fCantDisplay = FALSE;
#else
    bSuccess = !ObjError(OleDraw(lpOBJ_QUERY_OBJECT(lpPicInfo),hDC,lpBounds,NULL,NULL));
    if (!bSuccess)
        lpOBJ_QUERY_INFO(lpPicInfo)->fCantDisplay = TRUE;
#endif    // JAPAN
    return bSuccess;
}

BOOL ObjQueryObjectBounds(OBJPICINFO far *lpPicInfo, HDC hDC,
                            int *pdxa, int *pdya)
/* return bounds in twips */
{
    RECT bounds;
    BOOL bRetval;
    OLESTATUS olestat;
    int mmOld;
    POINT pt;

    if (otOBJ_QUERY_TYPE(lpPicInfo) == NONE)
    {
        /* set to default */
        *pdxa = nOBJ_BLANKOBJECT_X;
        *pdya = nOBJ_BLANKOBJECT_Y;
        return TRUE;
    }

    if ((olestat = OleQueryBounds(lpOBJ_QUERY_OBJECT(lpPicInfo),&bounds))
                        == OLE_ERROR_BLANK)
    {
        Assert(0);
        if (ObjWaitForObject(lpOBJ_QUERY_INFO(lpPicInfo),TRUE))
            return FALSE;
        olestat = OleQueryBounds(lpOBJ_QUERY_OBJECT(lpPicInfo),&bounds);
    }

    if (ObjError(olestat))
        return FALSE;

    pt.x = bounds.right - bounds.left;
    pt.y = -(bounds.bottom - bounds.top);
#ifdef DEBUG
    {
        char szMsg[180];
        wsprintf(szMsg,"Object HIMETRIC width: %d height: %d\n\r",pt.x,-pt.y);
        OutputDebugString(szMsg);
    }
#endif
    mmOld = SetMapMode(hDC,MM_HIMETRIC);
    LPtoDP(hDC,&pt,1);

    SetMapMode(hDC,MM_TWIPS);
    DPtoLP(hDC,&pt,1);

    SetMapMode(hDC,mmOld);
    *pdxa = pt.x;
    *pdya = pt.y;

    return TRUE;
}

void ObjInvalidatePict(OBJPICINFO *pPicInfo, typeCP cp)
{
    struct EDL      *pedl;
    RECT rc;
    extern int              wwCur;

    ObjPushParms(docCur);

    ObjCachePara(docCur,cp);
    Select(vcpFirstParaCache,vcpLimParaCache);

    FreezeHp();
    if (FGetPictPedl(&pedl))  // find pedl at selCur.cpFirst;
    {
        ComputePictRect( &rc, pPicInfo, pedl, wwCur );
        InvalidateRect(hDOCWINDOW, &rc, FALSE);
    }
    MeltHp();

    ObjPopParms(TRUE);
    UPDATE_INVALID();
}

void ObjInvalidateObj(LPOLEOBJECT lpObject)
{
    typeCP cp;
    OBJPICINFO picInfo;

    ObjPushParms(docCur);
    if (ObjGetPicInfo(lpObject,docCur,&picInfo,&cp))
        ObjInvalidatePict(&picInfo,cp);
    ObjPopParms(TRUE);
}

/****************************************************************/
/*********************** OLE CLIPBOARD  *************************/
/****************************************************************/
BOOL ObjCreateObjectInClip(OBJPICINFO *pPicInfo)
{
    LONG        otobject;
    szOBJNAME szObjName;
    OLESTATUS olestat;
    BOOL bRetval = FALSE;

    Assert (lhClientDoc != NULL);

    if (ObjAllocObjInfo(pPicInfo,selCur.cpFirst,NONE,TRUE,szObjName))
        goto error;

    if (vbObjLinkOnly)
    {
        if (ObjError(OleCreateLinkFromClip(PROTOCOL, (LPOLECLIENT)lpOBJ_QUERY_INFO(pPicInfo),
                    lhClientDoc, szObjName,
                    &lpOBJ_QUERY_OBJECT(pPicInfo), olerender_draw, 0)))
        {
            lpOBJ_QUERY_OBJECT(pPicInfo) = NULL;
            goto error;
        }
    }
    else if (vObjPasteLinkSpecial)
    {
        if (ObjError(OleCreateLinkFromClip(PROTOCOL, (LPOLECLIENT)lpOBJ_QUERY_INFO(pPicInfo),
                    lhClientDoc, szObjName,
                    &lpOBJ_QUERY_OBJECT(pPicInfo), olerender_format, cfObjPasteSpecial)))
        {
            lpOBJ_QUERY_OBJECT(pPicInfo) = NULL;
            goto error;
        }
    }
    else
    {
        WORD cfClipFormat=0;
        OLEOPT_RENDER orRender = olerender_draw;

        if (cfObjPasteSpecial && (cfObjPasteSpecial != vcfOwnerLink))
        /* from PasteSpecial.  There's a format on clipboard that
           user wants to paste and its not the embedded object format.
           So we'll do it as a static object. */
        {
            cfClipFormat = cfObjPasteSpecial;
            orRender = olerender_format;
            olestat = OLE_ERROR_CLIPBOARD; // force get static object
        }
        else // try for embedded
            olestat = OleCreateFromClip(PROTOCOL, (LPOLECLIENT)lpOBJ_QUERY_INFO(pPicInfo),
                                    lhClientDoc, szObjName,
                                    &lpOBJ_QUERY_OBJECT(pPicInfo), orRender, cfClipFormat);

        switch(olestat)
        {
            case OLE_ERROR_CLIPBOARD:
                /* try static protocol */
                olestat = OleCreateFromClip(SPROTOCOL, (LPOLECLIENT)lpOBJ_QUERY_INFO(pPicInfo),
                                    lhClientDoc, szObjName,
                                    &lpOBJ_QUERY_OBJECT(pPicInfo), orRender, cfClipFormat);
                switch(olestat)
                {
                    case OLE_ERROR_CLIPBOARD:
                    goto error;

                    case OLE_WAIT_FOR_RELEASE:
                    case OLE_OK:
                    break;

                    default:
                        lpOBJ_QUERY_OBJECT(pPicInfo) = NULL;
                    goto error;
                }
            break;

            case OLE_WAIT_FOR_RELEASE:
            case OLE_OK:
            break;

            default:
                ObjError(olestat);
            goto error;
        }
    }

    /* Figure out what kind of object we have */
    if (ObjError(OleQueryType(lpOBJ_QUERY_OBJECT(pPicInfo),&otobject)))
        goto error;

    switch(otobject)
    {
        case OT_LINK:
            otOBJ_QUERY_TYPE(pPicInfo) = LINK;
        break;
        case OT_EMBEDDED:
            otOBJ_QUERY_TYPE(pPicInfo) = EMBEDDED;
        break;
        default:
            otOBJ_QUERY_TYPE(pPicInfo) = STATIC;
        break;
    }

    if (ObjInitServerInfo(lpOBJ_QUERY_INFO(pPicInfo)))
        goto error;

    if (!FComputePictSize(pPicInfo, &(pPicInfo->dxaSize),
                          &(pPicInfo->dyaSize) ))
        goto error;

    return TRUE;

    error:
    if (lpOBJ_QUERY_INFO(pPicInfo))
        ObjDeleteObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE);
    Error(IDPMTFailedToCreateObject);
    return FALSE;
}

BOOL ObjWriteToClip(OBJPICINFO FAR *lpPicInfo)
/* return TRUE if OK, FALSE if not */
{
#ifdef DEBUG
        OutputDebugString( (LPSTR) "Copying Object to Clipboard\n\r");
#endif

    if (otOBJ_QUERY_TYPE(lpPicInfo) == NONE)
        return FALSE;

    if (ObjWaitForObject(lpOBJ_QUERY_INFO(lpPicInfo),TRUE))
        return FALSE;
    return (!ObjError(OleCopyToClipboard(lpOBJ_QUERY_OBJECT(lpPicInfo))));
}

/****************************************************************/
/*********************** OLE MENU HANDLING **********************/
/****************************************************************/
void ObjUpdateMenu(HMENU hMenu)
/* this *MUST* be called *AFTER* paste menuitem has already been enabled
   according to presence of non-object contents of the clipboard!!! (1.25.91) D. Kent */
{
    int     mfPaste      = MF_GRAYED;
#if !defined(SMALL_OLE_UI)
    int     mfPasteLink  = MF_GRAYED;
    int     mfLinks = MF_GRAYED;
#endif
    int     mfPasteSpecial  = MF_GRAYED;
    int     mfInsertNew  = MF_GRAYED;
    WORD cfFormat = NULL;
    BOOL bIsEmbed=FALSE,bIsLink=FALSE;
    extern BOOL vfOutOfMemory;
    extern int vfOwnClipboard;

    if (!vfOutOfMemory)
    {
        if (vfOwnClipboard)
        {
            if (CpMacText( docScrap ) != cp0) // something in scrap
                mfPaste = MF_ENABLED;
        }
        else
        {
            if (OleQueryCreateFromClip(PROTOCOL, olerender_draw, 0) == OLE_OK)
                mfPaste = MF_ENABLED, bIsEmbed=TRUE;
            else if (OleQueryCreateFromClip(SPROTOCOL, olerender_draw, 0) == OLE_OK)
                mfPaste = MF_ENABLED;

            // Enable "Paste Link" if there is a link-able object in the clipboard
            if (OleQueryLinkFromClip(PROTOCOL, olerender_draw, 0) == OLE_OK)
            {
                bIsLink=TRUE;
#if !defined(SMALL_OLE_UI)
                mfPasteLink = MF_ENABLED;
#endif
            }
        }

        /* There's no point in putting up pastespecial if there are no
            alternate clip formats to choose from. */

#if defined(SMALL_OLE_UI)
        /* except to get paste link */
#endif

        if (OpenClipboard( hPARENTWINDOW ) )
        {
            int ncfCount=0;
            while (cfFormat = EnumClipboardFormats(cfFormat))
                switch (cfFormat)
                {
                    case CF_TEXT:
                        mfPaste = MF_ENABLED;
                    case CF_BITMAP:
                    case CF_METAFILEPICT:
                    case CF_DIB:
                        ++ncfCount;
                    break;
                }
            CloseClipboard();

            if (bIsLink || bIsEmbed)
            {
#if !defined(SMALL_OLE_UI)
                if (ncfCount >= 1)
#endif
                    mfPasteSpecial = MF_ENABLED;
            }
            else if (ncfCount > 1)
                mfPasteSpecial = MF_ENABLED;
        }

#if !defined(SMALL_OLE_UI)
        mfLinks = MF_ENABLED;
#endif

        // Insert_New is always enabled?
        mfInsertNew = MF_ENABLED;
    }

    ObjUpdateMenuVerbs( hMenu );
    EnableMenuItem(hMenu, imiPaste,  mfPaste);
#if !defined(SMALL_OLE_UI)
    EnableMenuItem(hMenu, imiPasteLink,  mfPasteLink);
    EnableMenuItem(hMenu, imiProperties, mfLinks);
#endif
    EnableMenuItem(hMenu, imiPasteSpecial, mfPasteSpecial);
    EnableMenuItem(hMenu, imiInsertNew,  mfInsertNew);
}


/****************************************************************/
/*********************** OLE DIALOG PROCS ***********************/
/****************************************************************/
#if !defined(SMALL_OLE_UI)
/* Properties... dialog */
BOOL FAR PASCAL fnProperties(HWND hDlg, unsigned msg, WORD wParam, LONG lParam)
{
    ATOM    aDocName    = 0;
    ATOM    aCurName    = 0;
    static int     idButton    = 0;
    OBJPICINFO picInfo;
    BOOL    bSelected;
    int     cSelected     = 0;
    int     iListItem     = 0;
    HWND    vhwndObjListBox      = GetDlgItem(hDlg, IDD_LISTBOX);
    extern HWND vhWndMsgBoxParent;
    static BOOL bDidSomething;

    switch (msg) {
        case WM_ACTIVATE:
            if (wParam)
                vhWndMsgBoxParent = hDlg;
        break;

        case WM_UPDATELB: /* Redrawing listbox contents */
            SendMessage(vhwndObjListBox, WM_SETREDRAW, 0, 0L);

        case WM_UPDATEBN: /* Updating Buttons only */
        case WM_INITDIALOG: {
            HANDLE  hData = NULL;
            LPSTR   lpstrData = NULL;
            LPSTR   lpstrTemp;
            char    szType[40];
            char    szFull[cchMaxSz];
            typeCP cpPicInfo;
            struct SEL selSave;
            OLESTATUS olestat;

            idButton    = 0;

            /* Reset the list box */
            if (msg == WM_INITDIALOG) // see fall through above
            {
                SendMessage(vhwndObjListBox, LB_RESETCONTENT, 0, 0L);
                EnableOtherModeless(FALSE);
                selSave=selCur;
                //ObjWriteFixup(docCur,TRUE,cp0);
                bLinkProps = TRUE;
                bDidSomething = FALSE;
                ObjSetSelectionType(docCur, selSave.cpFirst, selSave.cpLim);
            }

            /* Insert all the items in list box */
            cpPicInfo = cpNil;
            while (ObjPicEnumInRange(&picInfo,docCur,cp0,CpMacText(docCur),&cpPicInfo))
            {
                if (otOBJ_QUERY_TYPE(&picInfo) != LINK)
                {
                    if (msg == WM_UPDATEBN)
                        continue;  // object ain't in list box

                    if (msg == WM_INITDIALOG)
                        fOBJ_QUERY_IN_PROP_LIST(&picInfo) = OUT;
                    else if (fOBJ_QUERY_IN_PROP_LIST(&picInfo) == IN)
                    /** then this is an object which was in the list and
                        has been frozen */
                    {
                        fOBJ_QUERY_IN_PROP_LIST(&picInfo) = DELETED;
                        SendMessage(vhwndObjListBox, LB_DELETESTRING, iListItem, 0L);
                    }
                    else
                        continue; // object ain't in list box

                    continue;
                }
                else if (msg == WM_INITDIALOG)
                {
                    fOBJ_QUERY_IN_PROP_LIST(&picInfo) = IN;

                    /**
                        This flag causes object to be cloned if any changes
                        are made to it.  Clone will be used for cancel button.
                     **/

                    if (ObjLoadObjectInDoc(&picInfo,docCur,cpPicInfo) == cp0)
                        goto onOut;
                }


                if (msg == WM_INITDIALOG) // select in list if selected in doc
                {
                    if (OBJ_SELECTIONTYPE == LINK)
                        bSelected = (cpPicInfo >= selSave.cpFirst &&
                                        cpPicInfo < selSave.cpLim);
                    else // no selection, select first item
                        bSelected = iListItem == 0;

                    /* OR if its a bad link, take the liberty of selecting it */
                    if (fOBJ_BADLINK(&picInfo))
                        bSelected = TRUE;
                }
                else // select in list if already selected in list
                    bSelected = SendMessage(vhwndObjListBox, LB_GETSEL, iListItem, 0L);

                /* Get the update options */
                if (fOBJ_BADLINK(&picInfo))
                {
                    LoadString(hINSTANCE, IDSTRFrozen, szType, sizeof(szType));
                    if (bSelected)
                        idButton = -1;
                }
                else switch (ObjGetUpdateOptions(&picInfo))
                {
                    case oleupdate_always:
                        LoadString(hINSTANCE, IDSTRAuto, szType, sizeof(szType));
                        if (bSelected)
                            switch (idButton) {
                                case 0:          idButton = IDD_AUTO; break;
                                case IDD_MANUAL: idButton = -1;       break;
                                default:         break;
                            }
                        break;
                    case oleupdate_oncall:
                        LoadString(hINSTANCE, IDSTRManual, szType, sizeof(szType));
                        if (bSelected)
                            switch (idButton) {
                                case 0:         idButton = IDD_MANUAL; break;
                                case IDD_AUTO:  idButton = -1;         break;
                                default:        break;
                            }
                        break;

                    default:
                        LoadString(hINSTANCE, IDSTRFrozen, szType, sizeof(szType));
                        if (bSelected)
                            idButton = -1;

                        /* Disable the change link button, can't change frozen link */
                        aCurName = -1;
                }

                /* Retrieve the server name */
                olestat = ObjGetData(lpOBJ_QUERY_INFO(&picInfo), vcfLink, &hData);

                if ((olestat != OLE_WARN_DELETE_DATA) && (olestat !=  OLE_OK))
                    return TRUE;

                lpstrData = MAKELP(hData,0);

                /* The link format is:  "szClass0szDocument0szItem00" */

                /* Retrieve the server's class ID */
                RegGetClassId(szFull, lpstrData);
                lstrcat(szFull, "\t");

                /* Display the Document and Item names */
                while (*lpstrData++);

                /* Get this document name */
                aDocName = AddAtom(lpstrData);

                /* Make sure only one document selected for Change Link */
                if (bSelected)
                    switch (aCurName) {
                        case 0:
                            aCurName = aDocName;
                        break;
                        case -1:
                        break;
                        default:
                            if (aCurName != aDocName)
                                aCurName = -1;
                        break;
                    }

                DeleteAtom(aDocName);

                /* Strip off the path name and drive letter */
                lpstrTemp = lpstrData;
                while (*lpstrTemp)
                {
                    if (*lpstrTemp == '\\' || *lpstrTemp == ':')
                        lpstrData = lpstrTemp + 1;
#ifdef DBCS //T-HIROYN 1992.07.13
                    lpstrTemp = AnsiNext(lpstrTemp);
#else
                    lpstrTemp++;
#endif
                }

                /* Append the file name */
                lstrcat(szFull, lpstrData);
                lstrcat(szFull, "\t");

                /* Append the item name */
                while (*lpstrData++);
                lstrcat(szFull, lpstrData);
                lstrcat(szFull, "\t");

                if (olestat == OLE_WARN_DELETE_DATA)
                    GlobalFree(hData);

                /* Append the type of link */
                lstrcat(szFull, szType);

                switch (msg)
                {
                    case WM_UPDATELB:
                        SendMessage(vhwndObjListBox, LB_DELETESTRING, iListItem, 0L);
                        // fall through...

                    case WM_INITDIALOG:
                        SendMessage(vhwndObjListBox, LB_INSERTSTRING, iListItem, (DWORD)(LPSTR)szFull);
                        SendMessage(vhwndObjListBox, LB_SETSEL, bSelected, (DWORD)iListItem);
                    break;

                }

                if (bSelected)
                    cSelected++;

                iListItem++;
            }

            /* Uncheck those buttons that shouldn't be checked */
            CheckDlgButton(hDlg, IDD_AUTO,   idButton == IDD_AUTO);
            CheckDlgButton(hDlg, IDD_MANUAL, idButton == IDD_MANUAL);

            /* Gray the Change Link... button, as appropriate */
            EnableWindow(GetDlgItem(hDlg, IDD_CHANGE), (aCurName && aCurName != -1));
            EnableWindow(GetDlgItem(hDlg, IDD_EDIT), cSelected);
            EnableWindow(GetDlgItem(hDlg, IDD_PLAY), cSelected);
            EnableWindow(GetDlgItem(hDlg, IDD_UPDATE), cSelected);
            EnableWindow(GetDlgItem(hDlg, IDD_FREEZE), cSelected);
            EnableWindow(GetDlgItem(hDlg, IDD_AUTO), cSelected);
            EnableWindow(GetDlgItem(hDlg, IDD_MANUAL), cSelected);

            if (msg == WM_UPDATELB)
            {
                /* WM_UPDATELB case:  Redraw the list box */
                InvalidateRect(vhwndObjListBox, NULL, TRUE);
                SendMessage(vhwndObjListBox, WM_SETREDRAW, 1, 0L);
            }

            return TRUE;
        }

        case WM_SYSCOMMAND:
            switch(wParam & 0xFFF0)
            {
                case SC_CLOSE:
                    goto onOut;
                break;
            }
        break;

        case WM_DOLINKSCOMMAND:
        {
            BOOL bError;
            bDidSomething |= DoLinksCommand(wParam,lParam,hDlg,&bError);
            switch (wParam)
            {
                case IDD_PLAY:
                case IDD_EDIT:
                    InvalidateRect(hDOCWINDOW, NULL, TRUE);
                    if (!bError) // don't leave if there was an error 
                        goto onOut;
            }
        }
        break;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDCANCEL:
                    if (bDidSomething)
                    {
                        SendMessage(hDlg,WM_DOLINKSCOMMAND,IDD_UNDO,0L);
                        InvalidateRect(hDOCWINDOW, NULL, TRUE);
                        bDidSomething = FALSE;  // cause its undone now
                    }
                    // fall through...

                case IDOK:
                onOut:
                    if (bDidSomething)
                    {
                        ObjEnumInDoc(docCur,ObjClearCloneInDoc);
                    }
                    NoUndo();
                    bLinkProps = FALSE;
                    //ObjWriteFixup(docCur,FALSE,cp0);
                    OurEndDialog(hDlg, TRUE);
                    UpdateWindow(hDOCWINDOW); // cause we may have lost activation
                    return TRUE;

                default:
                    /** posting message avoids some weird asynchronicities when
                        waiting for objects before returning after pressing a
                        button **/
                    PostMessage(hDlg,WM_DOLINKSCOMMAND,wParam,lParam);
                break;
            }
        break;
    }
    return FALSE;
}

static BOOL DoLinksCommand(WORD wParam, DWORD lParam, HWND hDlg, BOOL *bError)
{
    int     cItems;
    int     i;
    HANDLE hSelected=NULL;
    int far *lpSelected;
    typeCP cpSuccess;
    typeCP cpPicInfo;
    BOOL bFirst=TRUE;
    OBJPICINFO picInfo;
    BOOL bDidSomething=FALSE;
    HWND    vhwndObjListBox      = GetDlgItem(hDlg, IDD_LISTBOX);

    StartLongOp();

    *bError = FALSE;

    switch (wParam)
    {
        case IDD_REFRESH:
        /** update a link if its been set to AUTOMATIC update */
        {
            OLEOPT_UPDATE UpdateOpt;
            if (!ObjError(OleGetLinkUpdateOptions(((LPOBJINFO)lParam)->lpobject,&UpdateOpt)))
                if (UpdateOpt == oleupdate_always)
                    fnObjUpdate((LPOBJINFO)lParam);
            goto SkipIt;
        }
        break;
        case IDD_LISTBOX:
            switch (HIWORD(lParam))
            {
                case LBN_SELCHANGE:
                    PostMessage(hDlg, WM_UPDATEBN, 0, 0L); // fall through
                default:
                    goto SkipIt;
            }
        break;

        case IDD_CHANGE:
            aNewName = aOldName = 0;
            // fall through...

        case IDD_UPDATE:
            ObjEnumInDoc(docCur,ObjSetNoUpdate);
        break;

        case IDD_AUTO:
        case IDD_MANUAL:
            if (IsDlgButtonChecked(hDlg,wParam))
                goto SkipIt;
            /* work around for bug #8280 */
            CheckDlgButton(hDlg,wParam,TRUE);
        break;
    }


    /**
        Everything after here is done for each item selected in
        links list box *
        **/

    /* If nothing is selected, quit! */
    if (wParam != IDD_UNDO)
    {
        if ((cItems = SendMessage(vhwndObjListBox, LB_GETSELCOUNT, 0, 0L)) <= 0)
            goto SkipIt;

        if ((hSelected = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,
                                cItems * sizeof(int))) == NULL)
        {
            Error(IDPMTNoMemory);
            goto SkipIt;
        }

        if ((lpSelected = (int far *)GlobalLock(hSelected)) == NULL)
        {
            Error(IDPMTNoMemory);
            goto SkipIt;
        }

        /* Retrieve the selected items (in sorted order) */
        SendMessage(vhwndObjListBox, LB_GETSELITEMS,
                            cItems, (DWORD)lpSelected);
    }


    for (i = 0, cpPicInfo = cpNil;
            ObjPicEnumInRange(&picInfo,docCur,cp0,CpMacText(docCur),&cpPicInfo);)
    {
        /**
            For IDD_UNDO we do all.  Dirty flag will filter in the ones
            we've operated on.  Assumes Saved before calling (see
            fnObjProperties())
            **/
        if (fOBJ_QUERY_IN_PROP_LIST(&picInfo)) // is or was in list
        {
            if (wParam == IDD_UNDO)
            {
                cpSuccess = ObjUseCloneInDoc(&picInfo,docCur,cpPicInfo);
                if ((cpSuccess == cp0) || ferror || fPropsError)
                    break; // there was an error
            }
            else if (fOBJ_QUERY_IN_PROP_LIST(&picInfo) == IN)
            {
                /** We're enumerating all objects, not just 
                    ones in list box **/
                if (*lpSelected == i)  // selected item
                {
                    ObjCachePara(docCur,cpPicInfo);
                    switch(wParam)
                    {
                        case IDD_AUTO:          /* Change the (link) update options */
                        case IDD_MANUAL:
                            if (!fOBJ_BADLINK(&picInfo))
                            {
                                cpSuccess = ObjBackupInDoc(&picInfo,docCur,cpPicInfo);
                                if (cpSuccess)
                                    cpSuccess = (typeCP)ObjSetUpdateOptions(&picInfo, wParam, docCur, cpPicInfo);

                            }
                        break;

                        case IDD_CHANGE:
                            if (bFirst)
                            {
                                if (!ObjQueryNewLinkName(&picInfo,docCur,cpPicInfo))
                                    // then didn't get new link name
                                    goto SkipIt;

                                bFirst=FALSE;
                            }

                            cpSuccess = ObjBackupInDoc(&picInfo,docCur,cpPicInfo);

                            if (cpSuccess)
                                cpSuccess = ObjChangeLinkInDoc(&picInfo,docCur,cpPicInfo);

                            /*  must do this because we don't want to put up
                                ChangeOtherLinks dialog until we know the first
                                change was a success */
                            if (cpSuccess)
                            {
                                lpOBJ_QUERY_INFO(&picInfo)->fCompleteAsync = TRUE;
                                if (ObjWaitForObject(lpOBJ_QUERY_INFO(&picInfo),TRUE))
                                    cpSuccess = cp0;
                                else if (ferror || fPropsError)
                                    cpSuccess = cp0;
                            }
                        break;

                        case IDD_PLAY:
                            cpSuccess = ObjPlayObjectInDoc(&picInfo,docCur,cpPicInfo);
                        break;

                        case IDD_EDIT:
                            cpSuccess = ObjEditObjectInDoc(&picInfo,docCur,cpPicInfo);
                        break;

                        case IDD_UPDATE:

                                cpSuccess = ObjBackupInDoc(&picInfo,docCur,cpPicInfo);

                                if (cpSuccess)
                                    cpSuccess = ObjUpdateObjectInDoc(&picInfo,docCur,cpPicInfo);

                                /*  must do this because we don't want to put up
                                    ChangeOtherLinks dialog until we know the first
                                    change was a success */
                                if (cpSuccess)
                                {
                                    lpOBJ_QUERY_INFO(&picInfo)->fCompleteAsync = TRUE;
                                    if (ObjWaitForObject(lpOBJ_QUERY_INFO(&picInfo),TRUE))
                                        cpSuccess = cp0;
                                    else if (ferror || fPropsError)
                                        cpSuccess = cp0;
                                }
                        break;
                        case IDD_UPDATEOTHER:
                            aOldName = aOBJ_QUERY_DOCUMENT_LINK(&picInfo);
                            if (cpSuccess)
                                ChangeOtherLinks(docCur,FALSE,TRUE);
                            aOldName=0;
                        break;
                        case IDD_FREEZE:
                            cpSuccess = ObjBackupInDoc(&picInfo,docCur,cpPicInfo);

                            if (cpSuccess)
                                cpSuccess = ObjFreezeObjectInDoc(&picInfo,docCur,cpPicInfo);
                        break;
                    }
                    if ((cpSuccess == cp0) || ferror || fPropsError)
                        break; // there was an error
                    lpSelected++;
                }
                i++;  // counting all objects in list box
            }  // end if IN
        }
    }

    /*** Handle error conditions ***/
    if ((cpSuccess == cp0) || ferror || fPropsError)
    {
        *bError = TRUE;
        if (!ferror) // issue error message
        {
            switch (wParam)
            {
                case IDD_UPDATE:
                case IDD_CHANGE:
                    Error(IDPMTLinkUnavailable);
                break;
                default:
                    Error(IDPMTOLEError);
                break;
            }
        }

        if (wParam != IDD_UNDO)
        {
            /** so we can continue calling Replace(), etc */
            ferror = FALSE;

            /* undo whatever we tried to do that failed */
            ObjCachePara(docCur,cpPicInfo); // for use clone
            ObjUseCloneInDoc(&picInfo,docCur,cpPicInfo);
            lpOBJ_QUERY_INFO(&picInfo)->fCompleteAsync = TRUE;
            ObjWaitForObject(lpOBJ_QUERY_INFO(&picInfo),TRUE);
            ObjInvalidatePict(&picInfo,cpPicInfo);
            PostMessage(hDlg,WM_UPDATELB,0,0L);

            ferror = FALSE; // again
        }

        fPropsError = FALSE;
    }

    switch (wParam)
    {
        /* Dismiss the dialog on Open */
        case IDD_UPDATEOTHER:
            UPDATE_INVALID();
        break;

        case IDD_PLAY:
        case IDD_EDIT:
        case IDD_UNDO:
        break;

        case IDD_UPDATE:
        if (cpSuccess)
            SendMessage(hDlg,WM_COMMAND,IDD_UPDATEOTHER,0L);
        bDidSomething = TRUE;
        break;

        case IDD_CHANGE:
            if (cpSuccess)
            {
                /** aOldName and aNewName are now set, change other links having
                    aOldName */
                /** if first change is bad, don't change others */
                ChangeOtherLinks(docCur,TRUE,TRUE);
                UPDATE_INVALID();
            }

            aOldName=0;
            aNewName=0;

            // fall through....

        case IDD_FREEZE:
        case IDD_AUTO:
        case IDD_MANUAL:
            PostMessage(hDlg,WM_UPDATELB,0,0L);
            bDidSomething = TRUE;
        break;
    }

    SkipIt:

    if (hSelected)
        GlobalFree(hSelected);

    EndLongOp(vhcArrow);

    return bDidSomething;
}
#else
// cause I don't wanna change def file yet...
BOOL FAR PASCAL fnProperties(HWND hDlg, unsigned msg, WORD wParam, LONG lParam)
{
    hDlg;
}
#endif

/* Invalid Link dialog */
int FAR PASCAL fnInvalidLink(HWND hDlg, unsigned msg, WORD wParam, LONG lParam)
{
    switch (msg) {
        case WM_INITDIALOG:
#if 0
        {
            char lpString[120];

            LoadString(hINSTANCE, (WORD)lParam, lpString, sizeof(lpString));
            SetDlgItemText(hDlg,IDD_MESSAGE,lpString);
        }
#endif
        break;

        case WM_SYSCOMMAND:
            switch(wParam & 0xFFF0)
            {
                case SC_CLOSE:
                    EndDialog(hDlg, IDOK);
                break;
            }
        break;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                case IDD_CHANGE:
                    EndDialog(hDlg, wParam);
            }
    }
    return FALSE;
}

/* Insert New... dialog */
int FAR PASCAL fnInsertNew(HWND hDlg, unsigned msg, WORD wParam, LONG lParam)
{
    HWND hwndList = GetDlgItem(hDlg, IDD_LISTBOX);

    switch (msg) {
        case WM_INITDIALOG:
            if (!RegGetClassNames(hwndList))
                OurEndDialog(hDlg, IDCANCEL);

            EnableOtherModeless(FALSE);
            SendMessage(hwndList, LB_SETCURSEL, 0, 0L);
            break;

        case WM_ACTIVATE:
            if (wParam)
                vhWndMsgBoxParent = hDlg;
        break;

        case WM_SYSCOMMAND:
            switch(wParam & 0xFFF0)
            {
                case SC_CLOSE:
                    OurEndDialog(hDlg, IDCANCEL);
                break;
            }
        break;

        case WM_COMMAND:
            switch (wParam) {

                case IDD_LISTBOX:
                    if (HIWORD(lParam) != LBN_DBLCLK)
                        break;

                case IDOK:
                    StartLongOp();
                    if (!RegCopyClassName(hwndList, (LPSTR)szClassName))
                        wParam = IDCANCEL;
                    // fall through ...

                case IDCANCEL:
                    OurEndDialog(hDlg, wParam);
                break;
            }
            break;
    }
    return FALSE;
}

BOOL vbCancelOK=FALSE;

/* Waiting for object dialog */
BOOL FAR PASCAL fnObjWait(HWND hDlg, unsigned msg, WORD wParam, LONG lParam)
{
    static LPOLEOBJECT lpObject;
    static LPOBJINFO lpOInfo;
    static BOOL bCanCancel;
    extern HWND             hwndWait;
    extern int vfDeactByOtherApp;
    extern int flashID;

    switch (msg) {
        case WM_INITDIALOG:
        {
            /**
                NOTE: the key idea in setting these options is that the cancel
                button must cancel what the user thinks is the current operation.

                vbCancelOK == TRUE,
                    cancel button may be enabled, depending on other flags
                    vbCancelOK is set in WMsgLoop.

                lpOInfo->fCancelAsync == TRUE,
                    Cancel is enabled if vbCancelOK
                    Cancel button cancels dialog without regard to pending async.
                    Pending async is killed quietly in CallBack if possible.
                    Generally use if the pending async is not part of the operation
                    being cancelled, and:
                        1)  You're about to make a very important call which justifies
                            silently killing any pending operation.
                    Note: this one is weird if you're trying to release or delete, because
                        the pending async could itself be a release or delete.

                lpOInfo->fCompleteAsync == TRUE,
                    Cancel is enabled only if pending async can be cancelled.
                    Cancel button cancels pending async.
                    Generally use if the pending async *is* part of the operation
                    being cancelled, and:
                        1)  You're in a sequence of async calls and cancelling
                            would require cancelling the previous async in the
                            sequence, or
                        2)  You have just made an async call which you want to make
                            synchronous but don't mind if the user cancels it.

                lpOInfo->fCanKillAsync == TRUE,
                    Use with lpOInfo->fCompleteAsync.
                    Indicates that we already know that the async can be cancelled,
                    so Cancel button can be enabled immediately.
            **/

            hwndWait = hDlg;
            lpObject = (LPOLEOBJECT)lParam;

            Assert (lpObject != NULL);

            lpOInfo = GetObjInfo(lpObject);

            Assert(lpOInfo != NULL);

            bCanCancel=FALSE;
            if (vbCancelOK && (!lpOInfo->fCompleteAsync || lpOInfo->fCanKillAsync))
                SendMessage(hDlg,WM_UKANKANCEL,0,0L);

            if (lpOInfo->fCancelAsync)
            /* we'll cancel async in CallBack if get a QUERY_RETRY */
                 lpOInfo->fKillMe = TRUE;

            SetTimer(hDlg, 1234, 250, (FARPROC)NULL);

            return TRUE;
        }
        break;


        case WM_ACTIVATE:
            if (wParam)
                vhWndMsgBoxParent = hDlg;
        break;

        case WM_RUTHRUYET:
        case WM_TIMER:
            /* this is a lot easier than making this modeless */
            /* we gotta check this because if server dies we don't get 
                an OLE_RELEASE (the 'normal way this dialog is knocked off),
                rather OleQueryReleaseStatus will return OLE_OK */
            if (OleQueryReleaseStatus(lpObject) != OLE_BUSY)
                PostMessage(hDlg,WM_DIESCUMSUCKINGPIG,0,0L);
        break;

        case WM_UKANKANCEL:
        /* we got a QUERY_RETRY or are initing */
        if (!bCanCancel && vbCancelOK)
        {
            char szMsg[20];

            LoadString(hINSTANCE, IDSTRCancel, szMsg, sizeof(szMsg));
            SetDlgItemText(hDlg,IDOK,szMsg);
            bCanCancel=TRUE;
        }
        break;

        case WM_DIESCUMSUCKINGPIG:
            hwndWait = NULL;

            KillTimer(hDlg, 1234);

            /* clear flags */
            if (CheckPointer(lpOInfo,1))
            {
                lpOInfo->fCompleteAsync =
                lpOInfo->fCancelAsync =
                lpOInfo->fCanKillAsync = FALSE;
            }

            /* wParam is TRUE if error */
            OurEndDialog(hDlg,wParam);
        break;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    if (bCanCancel) // pressed cancel button
                    {
                        if (lpOInfo->fCompleteAsync)
                            lpOInfo->fKillMe = TRUE; // cancel async asynchronously
                        else if (lpOInfo->fCancelAsync)
                            lpOInfo->fKillMe = FALSE; // had a chance to kill, user doesn't care anymore
                        PostMessage(hDlg,WM_DIESCUMSUCKINGPIG,1,0L);
                    }
                    else
                    {
                        /* retry */
                        if (OleQueryReleaseStatus(lpObject) != OLE_BUSY)
                            PostMessage(hDlg,WM_DIESCUMSUCKINGPIG,0,0L);
                    }
                    break;

                case IDD_SWITCH:
                    /* bring up task list */
                    DefWindowProc(hDlg,WM_SYSCOMMAND,SC_TASKLIST,0L);
                break;
            }
            break;

        default:
            break;
    }
    return FALSE;
}


/****************************************************************/
/*********************** VARIOUS OLE FUNCTIONS ******************/
/****************************************************************/
void fnObjInsertNew(void)
{
    OBJPICINFO picInfo;
    typeCP cpNext=selCur.cpFirst;

    if (!FWriteOk( fwcInsert ))
        return;

    /* this'll set global szClassName */
    if (OurDialogBox(hINSTANCE, "DTCREATE" ,hMAINWINDOW, lpfnInsertNew) == IDCANCEL)
        return;

    StartLongOp();

    ObjCachePara( docCur, cpNext);

    if (!ObjCreateObjectInDoc(docCur, cpNext))
    {
        ClearInsertLine();
        fnClearEdit(OBJ_INSERTING);
        NoUndo();
    }
    EndLongOp(vhcIBeam);
}


BOOL ObjCreateObjectInDoc(int doc,typeCP cpParaStart)
/* assumes szClassName is set to server class */
/* called only for InsertObject */
/* return whether error */
{
    szOBJNAME szObjName;
    LPOBJINFO lpObjInfo=NULL;

    if ((lpObjInfo = ObjGetObjInfo(szObjName)) == NULL)
        goto err;

    if (ObjError(OleCreate(PROTOCOL, (LPOLECLIENT)lpObjInfo,
                    (LPSTR)szClassName,
                    lhClientDoc, szObjName, &(lpObjInfo->lpobject), olerender_draw, 0)))
    {
        /* will free memory later */
        lpObjInfo->lpobject = NULL;
        goto err;
    }

    /* normally set in ObjAllocObjInfo, but for unfinished objects we need it now! */
    lpObjInfo->cpWhere = cpParaStart;

    lpObjInfo->objectType = NONE;

    //lpObjInfo->aName = AddAtom(szClassName);

    if (ObjInitServerInfo(lpObjInfo))
        goto err;

    return FALSE;

    err:
    if (lpObjInfo)
        ObjDeleteObject(lpObjInfo,TRUE);
    Error(IDPMTFailedToCreateObject);
    return TRUE;
}

#define DRAG_EMBED      0               /* nothing */
#define DRAG_LINK       6               /* Ctrl + Shift + Drag */
#define DRAG_MULTIPLE   4               /* Shift + Drag */

void ObjGetDrop(HANDLE hDrop, BOOL bOpenFile)
{
    int nNumFiles,count;
    char szFileName[cchMaxFile];
    extern struct CHP vchpSel;
    struct CHP chpT;
    BYTE    bKeyState = 0;
    typeCP cpFirst=selCur.cpFirst, dcp = 0;
    int cchAddedEol=0;
    typeCP cpNext=selCur.cpFirst,cpPrev=selCur.cpFirst,cpSel;
    OBJPICINFO picInfo;
    BOOL bError=FALSE;
    static char szPackage[] = "Package";
    MSG msg;

    if (!FWriteOk( fwcInsert ))
        return;

    /* get number of files dropped */
    nNumFiles = DragQueryFile(hDrop,0xFFFF,NULL,0);

    /* See what the user wants us to do */
    PeekMessage(&msg, (HWND)NULL, NULL, NULL, PM_NOREMOVE);
    bKeyState = ((((GetKeyState(VK_SHIFT) < 0) << 2)
                | ((GetKeyState(VK_CONTROL) < 0) << 1)));

    if ((nNumFiles == 0) ||
        ((bKeyState != DRAG_EMBED) && (bKeyState != DRAG_LINK) && (bKeyState != DRAG_MULTIPLE)) ||
         (bOpenFile && (bKeyState != DRAG_EMBED) && (bKeyState != DRAG_MULTIPLE)))
    {
        DragFinish(hDrop);
        return;
    }

    if (bOpenFile)
    {
        DragQueryFile(hDrop,0,szFileName,sizeof(szFileName));
        fnOpenFile((LPSTR)szFileName);
        DragFinish(hDrop);
        return;
    }

    ClearInsertLine();

    if (fnClearEdit(OBJ_INSERTING))
        return;

    StartLongOp();

    chpT = vchpSel;

    (**hpdocdod)[docCur].fFormatted = fTrue;

    if (cpFirst > cp0)
    {
        ObjCachePara(docCur, cpFirst - 1);
        if (vcpLimParaCache != cpFirst)
        {
            cchAddedEol = ccpEol;
            InsertEolPap(docCur, selCur.cpFirst, &vpapAbs);
            cpNext += (typeCP)ccpEol;
        }
    }

    ObjCachePara( docCur, cpNext );

    /* create object for each file dropped */
    for (count=0; count < nNumFiles; ++count)
    {
        szOBJNAME szObjName;
        typeCP cpTmp;

        /* get the filename */
        DragQueryFile(hDrop,count,szFileName,sizeof(szFileName));

        if (ObjAllocObjInfo(&picInfo,cpNext,EMBEDDED,TRUE,szObjName))
        {
            bError=TRUE;
            goto end;
        }

        if ((bKeyState == DRAG_LINK))
        {
            if (ObjError(OleCreateLinkFromFile(PROTOCOL, (LPOLECLIENT)lpOBJ_QUERY_INFO(&picInfo),
                        szPackage,
                        szFileName, NULL,
                        lhClientDoc, szObjName,
                        &lpOBJ_QUERY_OBJECT(&picInfo), olerender_draw, 0)))
            {
                bError=TRUE;
                lpOBJ_QUERY_OBJECT(&picInfo) = NULL;
                goto end;
            }
        }
        else // if ((bKeyState == DRAG_EMBED))
        {
            if (ObjError(OleCreateFromFile(PROTOCOL, (LPOLECLIENT)lpOBJ_QUERY_INFO(&picInfo),
                        szPackage,
                        szFileName,
                        lhClientDoc, szObjName,
                        &lpOBJ_QUERY_OBJECT(&picInfo), olerender_draw, 0)))
            {
                bError=TRUE;
                lpOBJ_QUERY_OBJECT(&picInfo) = NULL;
                goto end;
            }
        }

        if (ObjInitServerInfo(lpOBJ_QUERY_INFO(&picInfo)))
        {
            bError=TRUE;
            goto end;
        }

        if (!FComputePictSize(&picInfo, &(picInfo.dxaSize),
                              &(picInfo.dyaSize)))
        {
            bError=TRUE;
            goto end;
        }

        ObjCachePara(docCur,cpNext);
        if ((cpTmp = ObjSaveObjectToDoc(&picInfo,docCur,cpNext)) == cp0)
        {
            bError=TRUE;
            goto end;
        }

        cpNext = cpTmp;
    }

    end:

    dcp = cpNext-cpFirst;
    if (dcp)
    {
        cpSel=CpFirstSty(cpFirst + dcp, styChar );

        SetUndo( uacInsert, docCur, cpFirst, dcp, docNil, cpNil, cp0, 0 );
        SetUndoMenuStr(IDSTRUndoEdit);

        if (vuab.uac == uacReplNS)
            /* Special UNDO code for picture paste */
            vuab.uac = uacReplPic;

        Select(cpSel, cpSel);
        vchpSel = chpT; /* Preserve insert point props across this operation */
        if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
            {   /* If running head/foot, remove chSects & set para props */
            MakeRunningCps( docCur, cpFirst, dcp    );
            }
        if (ferror)
            NoUndo();
    }

    if (bError)
    {
        Error(IDPMTFailedToCreateObject);
        ObjDeleteObject(lpOBJ_QUERY_INFO(&picInfo),TRUE);
    }

    EndLongOp(vhcIBeam);
    DragFinish(hDrop);
}

int vcVerbs;
void fnObjDoVerbs(WORD wVerb)
{
    NoUndo();

    if ((wVerb == imiVerb) // more than one object selected
        || (vcVerbs == 1)) // one verb
        OBJ_PLAYEDIT = OLEVERB_PRIMARY;
    else
        OBJ_PLAYEDIT = (int)(wVerb - imiVerb - 1);
    ObjEnumInRange(docCur,selCur.cpFirst,selCur.cpLim,ObjPlayObjectInDoc);
    OBJ_PLAYEDIT = OLEVERB_PRIMARY;
}

void fnObjProperties(void)
{
    int nRetval;

    if (nRetval != -1)
        OurDialogBox(hINSTANCE, "DTPROP", hMAINWINDOW, lpfnLinkProps);
}

BOOL fnObjUpdate(LPOBJINFO lpObjInfo)
{
    BOOL bRetval;
#ifdef DEBUG
        OutputDebugString( (LPSTR) "Updating object\n\r");
#endif
    if (ObjWaitForObject(lpObjInfo,TRUE))
        return TRUE;

    StartLongOp();
    if ((bRetval = ObjError(OleUpdate(lpObjInfo->lpobject))))
            Error(IDPMTFailedToUpdate);
    EndLongOp(vhcArrow);
    return bRetval;
}


BOOL ObjDeleteObject(LPOBJINFO lpObjInfo, BOOL bDelete)
/** Delete object as well as objinfo.  Note this must be synchronous.
    Return whether an error.
**/
{
    LPOLEOBJECT lpObject;

    Assert(lpObjInfo != NULL);

    if (!CheckPointer((LPSTR)lpObjInfo,1))
        return FALSE; // already deleted

    lpObject = lpObjInfo->lpobject;

    if (lpObject == NULL)
    {
        ObjDeleteObjInfo(lpObjInfo);
        return FALSE;
    }

    /* make sure not already deleted */
    if (!ObjIsValid(lpObject))
    {
        ObjDeleteObjInfo(lpObjInfo);
        return FALSE;
    }

    /** asynchronous deletion **/
    if (OleQueryReleaseStatus(lpObject) != OLE_BUSY)
    {
        OLESTATUS olestat;

        if (bDelete)
            olestat = OleDelete(lpObject);
        else
            olestat = OleRelease(lpObject);

        switch (olestat)
        {
            case OLE_OK:
                ObjDeleteObjInfo(lpObjInfo);
            break;
            case OLE_WAIT_FOR_RELEASE:
                lpObjInfo->fFreeMe = TRUE;
            break;
        }
    }
    else if (bDelete)
        lpObjInfo->fDeleteMe = TRUE; // delete on OLE_RELEASE
    else
        lpObjInfo->fReleaseMe = TRUE; // release on OLE_RELEASE

    return FALSE;
}


#include <print.h>
HANDLE hStdTargetDevice=NULL;

void ObjSetTargetDevice(BOOL bSetObjects)
{
    extern PRINTDLG PD;  /* Common print dlg structure, initialized in the init code */
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];
    LPSTDTARGETDEVICE lpStdTargetDevice;
    WORD nCount;
    DEVMODE FAR *lpDevmodeData;
    char FAR *lpData;
    LPOLEOBJECT lpObject;
    STDTARGETDEVICE stdT;

    if (!PD.hDevMode)
    /* then get for default printer */
    {
        if (hszPrinter == NULL || hszPrDriver == NULL || hszPrPort == NULL)
            return;

        if (**hszPrinter == '\0' || **hszPrDriver == '\0' || **hszPrPort == '\0')
            return;

        if (fnPrGetDevmode())
            return;
    }

    lpDevmodeData = MAKELP(PD.hDevMode,0);

    /* get the offsets */
    stdT.deviceNameOffset = 0;
    nCount = CchSz(*hszPrinter);

    stdT.driverNameOffset = nCount;
    nCount += CchSz(*hszPrDriver);

    stdT.portNameOffset = nCount;
    nCount += CchSz(*hszPrPort);

    stdT.extDevmodeOffset = nCount;
    nCount += (stdT.extDevmodeSize = lpDevmodeData->dmSize);

    stdT.environmentOffset = nCount;
    nCount += (stdT.environmentSize = lpDevmodeData->dmSize);

    /* alloc the buffer */
    if (hStdTargetDevice == NULL)
    {
        if ((hStdTargetDevice = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,nCount+sizeof(STDTARGETDEVICE))) == NULL)
            return;
    }
    else
    {
        if ((hStdTargetDevice =
            GlobalReAlloc(hStdTargetDevice,
                            nCount+sizeof(STDTARGETDEVICE),GMEM_MOVEABLE|GMEM_ZEROINIT)) == NULL)
        {
            return;
        }
    }

    lpStdTargetDevice = (LPSTDTARGETDEVICE)GlobalLock(hStdTargetDevice);
    GlobalUnlock(hStdTargetDevice);

    /* copy stdT into lpStdTargetDevice */
    bltbx((LPSTR)&stdT, lpStdTargetDevice, sizeof(STDTARGETDEVICE));

    /* get temporary pointer to the end of StdTargetDevice (the data buffer) */
    lpData = ((LPSTR)lpStdTargetDevice) + sizeof(STDTARGETDEVICE);

    /* now fill the buffer */
    nCount = lpStdTargetDevice->driverNameOffset;
    bltbx((LPSTR)*hszPrinter, lpData, nCount);
    lpData += nCount;

    nCount = lpStdTargetDevice->portNameOffset -
                                lpStdTargetDevice->driverNameOffset;
    bltbx((LPSTR)*hszPrDriver, lpData, nCount);
    lpData += nCount;

    nCount = lpStdTargetDevice->extDevmodeOffset -
                                lpStdTargetDevice->portNameOffset;
    bltbx((LPSTR)*hszPrPort, lpData, nCount);
    lpData += nCount;

    nCount = lpStdTargetDevice->extDevmodeSize;
    bltbx(lpDevmodeData, (LPSTR)lpData, nCount);
    lpData += nCount;

    /* environment info is the same as the devmode info */
    bltbx(lpDevmodeData, (LPSTR)lpData, nCount);

    /* now set all the objects to this printer */
    if (bSetObjects)
    {
        lpObject=NULL;
        do
        {
            OleEnumObjects(lhClientDoc,&lpObject);
            if (lpObject)
            {
#ifdef DEBUG
                OutputDebugString("Setting Target Device\n\r");
#endif

                OleSetTargetDevice(lpObject,hStdTargetDevice);
            }
        }
        while (lpObject);
    }
}

BOOL ObjSetTargetDeviceForObject(LPOBJINFO lpObjInfo)
/* return whether error */
/* we assume object ain't busy!! */
{
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];

    if (lpObjInfo == NULL)
    {
        Assert(0);
        return TRUE;
    }
    if (lpObjInfo->lpobject == NULL)
    {
        Assert(0);
        return TRUE;
    }

    if (lpObjInfo->objectType == STATIC)
        return FALSE;

    if (hszPrinter == NULL || hszPrDriver == NULL || hszPrPort == NULL)
        return FALSE;

    if (**hszPrinter == '\0' || **hszPrDriver == '\0' || **hszPrPort == '\0')
        return FALSE;

    if (PD.hDevMode == NULL)
        ObjSetTargetDevice(FALSE);

    if (PD.hDevMode == NULL)
    {
        return FALSE;   // punt, couldn't get extdevmode structure.  
                        // device doesn't support it
    }

#ifdef DEBUG
    OutputDebugString("Setting Target Device\n\r");
#endif

    return (ObjError(OleSetTargetDevice(lpObjInfo->lpobject,hStdTargetDevice)));
}

#if 0
BOOL ObjContainsUnfinished(int doc, typeCP cpFirst, typeCP cpLim)
{
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    BOOL bRetval=FALSE;

    StartLongOp();

    for (cpPicInfo = cpNil;
        ObjPicEnumInRange(&picInfo,doc,cpFirst,cpLim,&cpPicInfo);
        )
        {
            if (lpOBJ_QUERY_INFO(&picInfo) == NULL)
                continue;

            if (otOBJ_QUERY_TYPE(&picInfo) == NONE)
            {
                bRetval = TRUE;
                break;
            }
        }

    EndLongOp(vhcArrow);
    return bRetval;
}
#endif

BOOL ObjContainsOpenEmb(int doc, typeCP cpFirst, typeCP cpLim, BOOL bLookForUnfinished)
{
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    BOOL bRetval=FALSE;
    LPLPOBJINFO lplpObjTmp;

    StartLongOp();

    for (cpPicInfo = cpNil;
        ObjPicEnumInRange(&picInfo,doc,cpFirst,cpLim,&cpPicInfo);
        )
        {
            if (lpOBJ_QUERY_INFO(&picInfo) == NULL)
                continue;

            if (lpOBJ_QUERY_OBJECT(&picInfo) == NULL)
                continue;

#if 0  // see new check below (NONEs are no longer saved to doc)
            if (otOBJ_QUERY_TYPE(&picInfo) == NONE)
            {
                bRetval = TRUE;
                break;
            }
#endif

            if ((otOBJ_QUERY_TYPE(&picInfo) == EMBEDDED) &&
                OleQueryOpen(lpOBJ_QUERY_OBJECT(&picInfo)) == OLE_OK)
            {
                bRetval = TRUE;
                break;
            }
        }

    if (bLookForUnfinished)
        for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
        {
            if (((*lplpObjTmp)->objectType == NONE) &&
                ((*lplpObjTmp)->cpWhere >= cpFirst) &&
                ((*lplpObjTmp)->cpWhere <= cpLim))
                {
                    bRetval = TRUE;
                    break;
                }
        }

    EndLongOp(vhcArrow);
    return bRetval;
}

BOOL ObjDeletionOK(int nMode)
/**
    Return whether OK to delete objects in current selection.
    We don't worry about unfinished objects because they are just floating around in space
    (ie, no picinfo has been yet saved to the doc),
    and we don't allow the user to delete them until they are finished or the
    document is abandonded.
  **/
{
    if (ObjContainsOpenEmb(docCur, selCur.cpFirst, selCur.cpLim,FALSE))
    {
        switch (nMode)
        {
            case OBJ_INSERTING:
                Error(IDPMTInsertOpenEmb);
                return FALSE;
            break;
            case OBJ_CUTTING:
            case OBJ_DELETING:
            {
                char szMsg[cchMaxSz];

                LoadString(hINSTANCE,
                    nMode == OBJ_DELETING ? IDPMTDeleteOpenEmb : IDPMTCutOpenEmb,
                    szMsg, sizeof(szMsg));

                if (MessageBox(hPARENTWINDOW, (LPSTR)szMsg, (LPSTR)szAppName, MB_OKCANCEL) == IDCANCEL)
                    return FALSE;

                if (ObjEnumInRange(docCur,selCur.cpFirst,selCur.cpLim,ObjCloseObjectInDoc) < 0)
                    return FALSE;

                /* handle any unfinished objects in selection region */
                ObjAdjustCpsForDeletion(docCur);

                return TRUE;
            }
            break;
        }
    }
    else
    {
        /* handle any unfinished objects in selection region */
        ObjAdjustCpsForDeletion(docCur);
        return TRUE;
    }
}

void ObjAdjustCps(int doc,typeCP cpLim, typeCP dcpAdj)
/* for every picinfo after cpLim, adjust the cp value in its objinfo */
{
    LPLPOBJINFO lplpObjTmp;
    typeCP cpMac = CpMacText(doc);

    if (dcpAdj == cp0)
        return;

    if (doc != docCur)
        return;

    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        if (((*lplpObjTmp)->objectType == NONE) &&
            ((*lplpObjTmp)->cpWhere >= cpLim))
            {
                typeCP cpNew = (*lplpObjTmp)->cpWhere + dcpAdj;
                if (cpNew > cpMac)
                    cpNew = cpMac;
                else if (cpNew < cp0)
                    cpNew = cp0;
                (*lplpObjTmp)->cpWhere = cpNew;
            }
    }
}

void ObjAdjustCpsForDeletion(int doc)
/* for every picinfo in selCur, set cpWhere to selCur.cpFirst (presumably
   selCur is about to be deleted) */
{
    LPLPOBJINFO lplpObjTmp;

    if (selCur.cpFirst == selCur.cpLim)
        return;

    if (doc != docCur)
        return;

    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        if (((*lplpObjTmp)->objectType == NONE) &&
            ((*lplpObjTmp)->cpWhere >= selCur.cpFirst) &&
            ((*lplpObjTmp)->cpWhere <= selCur.cpLim))
                (*lplpObjTmp)->cpWhere = selCur.cpFirst;
    }
}

#include <stdlib.h>

BOOL GimmeNewPicinfo(OBJPICINFO *pPicInfo, LPOBJINFO lpObjInfo)
/* assume lpObjInfo already is filled out */
/* return whether error */
{
    szOBJNAME szObjName;
    char *pdumb;

    if (lpObjInfo == NULL)
        return TRUE;

    bltbc( pPicInfo, 0, cchPICINFOX );

    /* objinfo */
    lpOBJ_QUERY_INFO(pPicInfo) = lpObjInfo;

    /* so Save'll save */
    fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) = TRUE;

    /* only save picinfo until File.Save */
    bOBJ_QUERY_DONT_SAVE_DATA(pPicInfo) = TRUE;

    ObjUpdateFromObjInfo(pPicInfo);

    /* data size */
    dwOBJ_QUERY_DATA_SIZE(pPicInfo) = 0xFFFFFFFF; // to indicate brand new object

    pPicInfo->mx = mxMultByOne;
    pPicInfo->my = myMultByOne;
    pPicInfo->cbHeader = cchPICINFOX;
    pPicInfo->dxaOffset = 0;
    pPicInfo->mm = MM_OLE;
    pPicInfo->dxaSize = nOBJ_BLANKOBJECT_X;
    pPicInfo->dyaSize = nOBJ_BLANKOBJECT_Y;
    return FALSE;
}

BOOL ObjInitServerInfo(LPOBJINFO lpObjInfo)
/* this is called right after creating an object */
/* return whether error */
{
    lpObjInfo->fCompleteAsync = TRUE; // kill prev async (OleCreate...)
    if (ObjWaitForObject(lpObjInfo,TRUE))
        return TRUE;

    /* make sure Create succeeded */
    if (lpObjInfo->fDeleteMe)
    /* this is how we know it failed asynchronously */
        return TRUE;

    if ((lpObjInfo->objectType == EMBEDDED) ||
        (lpObjInfo->objectType == NONE))
    {
        if (ObjSetHostName(lpObjInfo,docCur))
            return TRUE;

        lpObjInfo->fCompleteAsync = TRUE; // kill SetHostName if Cancel
        if (ObjWaitForObject(lpObjInfo,TRUE))
            return TRUE;
    }

    if (ObjSetTargetDeviceForObject(lpObjInfo))
        return TRUE;

    if (lpObjInfo->aName == NULL)
        if (lpObjInfo->objectType == LINK)
        {
            lpObjInfo->fCompleteAsync = TRUE; // kill SetTarget if Cancel
            if (ObjWaitForObject(lpObjInfo,TRUE))
                return TRUE;
            if ((lpObjInfo->aName = MakeLinkAtom(lpObjInfo)) == NULL)
                return TRUE;
        }

    /* note: Caller needs to handle getting the size of object. */

    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\obj2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#include "windows.h"
#include "mw.h"
#include "winddefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "cmddefs.h"
#include "obj.h"
#include "str.h"
#include "objreg.h"
#include <commdlg.h>
#include <stdlib.h>  // for strtoul()

extern struct CHP       vchpNormal;
extern struct DOD (**hpdocdod)[];
extern BOOL ferror;
extern struct PAP      vpapAbs;
extern struct PAP      vpapPrevIns;
extern struct PAP   *vppapNormal;
extern int     vdocParaCache;
extern struct UAB       vuab;
extern int vfOutOfMemory,vfSysFull;
extern int          docUndo;
extern struct FCB (**hpfnfcb)[];
extern HCURSOR		vhcArrow;

/* intercepted stream functions work with this buffer */
static typeCP cpObjectDataCurLoc=cp0, cpObjectDataBase=cp0;
static DWORD cObjectData=0L,dwDataMax;
static int docStream;
static struct CHP *pchpStream;
static struct PAP *ppapStream;

static OPENFILENAME    OFN;

static void GetChp(struct CHP       *pchp, typeCP cp, int doc);
static BOOL ObjParaDup(int doc, typeCP cpFirst, typeCP cpLim);
static BOOL bUniqueData(int doc, typeCP cpFirst, typeCP cpLim);
static ObjOpenStreamIO(typeCP cpParaStart, int doc, struct CHP *pchp, struct PAP *ppapGraph, DWORD dwObjectSize);
static void ObjCloseStreamIO(void);
static typeCP ObjWriteDataToDoc( LPOLEOBJECT lpObject);
static HANDLE OfnGetNewLinkName(HWND hwnd, HANDLE hData);
static void Normalize(LPSTR lpstrFile) ;
static HANDLE ObjMakeNewLinkName(HANDLE hData, ATOM atom) ;
static char            szCustFilterSpec[CBFILTERMAX];
static char            szFileName[CBPATHMAX];
//static char            szFilterSpec[CBFILTERMAX];
//static char            szLastDir[CBPATHMAX];
static char            szLinkCaption[cchMaxSz];
static char            szTemplateName[CBPATHMAX];
static BOOL             fUpdateAll = FALSE;
static BOOL             ObjStop=FALSE;
static BOOL             vbChangeOther;
BOOL                    bNoEol=FALSE;

#define ulmin(a,b)      ((DWORD)(a) < (DWORD)(b) ? \
                         (WORD)(a) : (WORD)(b))


/****************************************************************/
/**************** OLE ENUMERATION FUNCTIONS *********************/
/****************************************************************/

#if 0 // good, just not used
int
ObjEnumInAllDocs(cpFARPROC lpFunc)
{
    int doc,count=0;
    for (doc = 0; doc < docMac; doc++)
    {
        int nRetval;

        nRetval = ObjEnumInDoc(doc, lpFunc);

        if (nRetval < 0)
            return -1;
        else
            count += nRetval;
    }
    return count;
}
#endif

int
ObjEnumInDoc(int doc, cpFARPROC lpFunc)
{
    typeCP cpMac = (**hpdocdod) [doc].cpMac;

    return ObjEnumInRange(doc, cp0, cpMac, lpFunc);
}


int
ObjEnumInRange(int doc, typeCP cpStart, typeCP cpEnd, cpFARPROC lpFunc)
/*  Call lpFunc for each OLE object.  
    lpFunc takes the following args: 
        a far pointer to a PICINFOX struct (can be NULL).
        an int for the doc we're operating on.
        a typeCP that gives the cp position of the PICINFOX struct.
    lpFunc returns the cp of the paragraph following the PICINFO struct
        if OK, or cp0 if error.
    Enumeration quits if error returned from FARPROC.
    Return number of objects operated on, or -1 if error. 
*/
{
        typeCP cpNow, cpLimPara;
        int count;

        /* Loop on paras */

        for ( count = 0, cpNow = cpStart; cpNow < cpEnd; cpNow = cpLimPara )
        {

            Assert(cpEnd <= (**hpdocdod) [doc].cpMac);

            /* this shouldn't happen */
            if (cpEnd > (**hpdocdod) [doc].cpMac)
                goto done;

            ObjCachePara( doc, cpNow );

            if (vpapAbs.fGraphics)
            {
                /* get PICINFO struct and see if its an object */
                OBJPICINFO  picInfo;
                GetPicInfo(vcpFirstParaCache,vcpFirstParaCache + cchPICINFOX, doc, &picInfo);
                if (bOBJ_QUERY_IS_OBJECT(&picInfo))
                {
                    typeCP cpOldLimPara = vcpLimParaCache;

                    if (!lpFunc)
                        cpLimPara = vcpLimParaCache;
                    else
                        if ((cpLimPara = (*lpFunc)(&picInfo,doc,vcpFirstParaCache)) == 0)
                            goto error;

                    ++count;

                    /* amount para has grown ( < 0 if shrunk, 0 if none )*/
                    cpEnd += cpLimPara - cpOldLimPara;

                    continue;
                }
            }

            cpLimPara = vcpLimParaCache;
        }

        /* success */
        goto done;

        error:
        count = -1;

        done:

        return count;
}

ObjPicEnumInRange(OBJPICINFO *pPicInfo,int doc, typeCP cpFirst, typeCP cpLim, typeCP *cpCur) 
/*  
    Enumerate over PicInfos between cpFirst and cpLim in doc. If 
    cpCur == cpNil, then start at cpFirst, else start at *cpCur.  
    Return 0 if done, 1 otherwise.
    Calls ObjCachePara() at picInfo.
*/
{
    /* static typeCP cpCur;
       used to use static, but that prevented being able to recursively
       call this function, and its almost impossible to prevent with
       asynchronicity rampant.
    */

    typeCP cpMac = (**hpdocdod) [doc].cpMac;

    if (cpFirst >= cpMac)
        return 0;

    if (cpLim > cpMac)
        cpLim = cpMac;

    /* initialize cpCur */
    if (*cpCur == cpNil)
        /* then starting afresh */
        *cpCur = cpFirst;
    else
    {
        ObjCachePara(doc,*cpCur); // cache the previous para
        *cpCur = vcpLimParaCache;  // get next para
    }

    /* pull in next para */
    do
    {
        if (*cpCur >= cpLim)
        {
            /* all done */
            *cpCur = vcpFirstParaCache; // we want to point to last para hit
            return 0;
        }

        ObjCachePara(doc,*cpCur);

        if (vpapAbs.fGraphics)
        {
            GetPicInfo(*cpCur,*cpCur + cchPICINFOX, doc, pPicInfo);
            if (bOBJ_QUERY_IS_OBJECT(pPicInfo))
                return 1;
        }
        *cpCur = vcpLimParaCache;
    }
    while (1);
}

typeCP ObjSaveObjectToDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/* 
    Assumes para is cached.  
    In some cases we only write the picinfo.  In others we write the
    object data after the picinfo.  We assume that the latter case
    only occurs when the file is being saved.
*/
{
    typeCP cpRetval;  // cp of next byte in doc after what we just wrote
    static BOOL bMyRecurse=FALSE;
    DWORD dwObjectSize;
    OLESTATUS olestat;
    struct CHP chp;
    struct PAP          papGraph;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
        
    if (lpOBJ_QUERY_OBJECT(pPicInfo) == NULL)
        return(vcpLimParaCache);
        
    /* we don't save nothing if it ain't dirty and has data */
    if (!fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) &&
        dwOBJ_QUERY_DATA_SIZE(pPicInfo) != 0L)
        return(vcpLimParaCache);

    if (vfOutOfMemory || vfSysFull /*|| ObjStop*/)
        return cp0;

    olestat = OleQuerySize(lpOBJ_QUERY_OBJECT(pPicInfo),&dwObjectSize);

    if (olestat == OLE_ERROR_BLANK)
        dwObjectSize = 0L;
    else if (ObjError(olestat))
        return cp0;

    /** don't let this function recurse (in CallBack) **/
    if (bMyRecurse)
    {
        Assert(0); // this has never happened yet (8.21.91) v-dougk
        return cp0;
    }
    bMyRecurse = TRUE;

    fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) = FALSE;

    /** 
        If docUndo will want to undo some region that contains this
        object, and if saving the object changes the size of that
        region, then vuab will become obsolete.
    **/

    ObjWriteClearState(doc);

    GetChp(&chp, cpParaStart, doc);

    if (dwOBJ_QUERY_DATA_SIZE(pPicInfo) != 0xFFFFFFFF)
    /* then has been saved before */
    {
        /* zap the entire existing object */
        papGraph = vpapAbs;
        Replace(doc, cpParaStart, (vcpLimParaCache - vcpFirstParaCache), fnNil, fc0, fc0);
    }
    else // new object
    {
        ObjCachePara(doc,cpParaStart-1); // use previous PAP
        papGraph = vpapAbs;
        papGraph.fGraphics = TRUE;
        ObjCachePara(doc,cpParaStart);
    }

    if (otOBJ_QUERY_TYPE(pPicInfo) == NONE)
    {
        if (dwObjectSize)
        /* 
            Insert New has culminated in a new baby object!
        */
        {
            otOBJ_QUERY_TYPE(pPicInfo) = EMBEDDED; // do this first
            if (!FComputePictSize(pPicInfo, &(pPicInfo->dxaSize), &(pPicInfo->dyaSize)))
            {
                cpRetval = cp0;
                goto end;
            }
#if 0
	        DeleteAtom(aOBJ_QUERY_SERVER_CLASS(pPicInfo));
	        aOBJ_QUERY_SERVER_CLASS(pPicInfo) = NULL;
#endif
        }
        else // don't save empty object
        {
            Assert(0);
            goto end;
        }
    }

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Saving object\n\r");
#endif

    /* 
        Insert PICINFO struct.  There is a problem here which is a 
        bug in Write (CheckGraphic()).  EOL gets inserted when we are
        replacing an object which is immediately in front of
        another object.  Kludge is to set this flag to inhibit.
    */
    bNoEol = TRUE;

    if (bOBJ_QUERY_DONT_SAVE_DATA(pPicInfo))
    /* only save picinfo until user does File.Save */
    {
        ObjUpdateFromObjInfo(pPicInfo);

        bOBJ_QUERY_DONT_SAVE_DATA(pPicInfo) = FALSE;
        dwOBJ_QUERY_DATA_SIZE(pPicInfo) = 0L;

        pPicInfo->mm |= MM_EXTENDED;    /* Extended file format */
        InsertRgch( doc, cpParaStart, pPicInfo, sizeof(OBJPICINFO), &chp, &papGraph);
        pPicInfo->mm &= ~MM_EXTENDED;

        ObjCachePara(doc,cpParaStart);
        cpRetval = vcpLimParaCache;
    }
    else
    {
        dwOBJ_QUERY_DATA_SIZE(pPicInfo) = dwObjectSize;
        ObjUpdateFromObjInfo(pPicInfo);

        pPicInfo->mm |= MM_EXTENDED;    /* Extended file format */
        InsertRgch( doc, cpParaStart, pPicInfo, sizeof(OBJPICINFO), &chp, NULL );
        pPicInfo->mm &= ~MM_EXTENDED;

        /* insert object data into doc */
        ObjOpenStreamIO(cpParaStart + cchPICINFOX, doc, &chp, &papGraph, dwObjectSize);
        cpRetval = ObjWriteDataToDoc(lpOBJ_QUERY_OBJECT(pPicInfo));
        ObjCloseStreamIO();
    }

    bNoEol = FALSE;

    end:

    ObjCachePara(doc,cpParaStart);

    bMyRecurse = FALSE;
    return ((cpRetval == cp0) ? cp0 : vcpLimParaCache);
}

typeCP ObjLoadObjectInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/*  
    Do an OleLoad from object data in doc.  Set lpobject in PICINFO struct.
    Assumes para is cached.
    This is a *synchronous* function.
*/
{
    typeCP cpRetval = vcpLimParaCache;
    szOBJNAME szObjName;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
    {
        if (ObjAllocObjInfo(pPicInfo,cpParaStart,pPicInfo->objectType,FALSE,NULL))
            return(cp0);

        if (ObjSetPicInfo(pPicInfo, doc, cpParaStart))
            return(cp0);
    }

    else if (lpOBJ_QUERY_OBJECT(pPicInfo)) // already loaded
        return(vcpLimParaCache);

    if (otOBJ_QUERY_TYPE(pPicInfo) == NONE)
        return(vcpLimParaCache);

    if (bOBJ_QUERY_TOO_BIG(pPicInfo)) // ObjLoadObject previously failed
        return(cp0);

    if ((dwOBJ_QUERY_DATA_SIZE(pPicInfo) == 0L) ||
        (dwOBJ_QUERY_DATA_SIZE(pPicInfo) == 0xFFFFFFFFL))
        /* then has no data */
        return(cp0);

    if (vfOutOfMemory || vfSysFull /*|| ObjStop*/)
        return cp0;

    StartLongOp();

    ObjGetObjectName(lpOBJ_QUERY_INFO(pPicInfo),szObjName);

    Assert(szObjName[0]);

    ObjOpenStreamIO(cpParaStart + cchPICINFOX, doc, NULL, NULL, 0L);

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Loading object\n\r");
#endif

    if (ObjError(OleLoadFromStream(lpStream,
        otOBJ_QUERY_TYPE(pPicInfo) == STATIC ? SPROTOCOL : PROTOCOL,
        (LPOLECLIENT)lpOBJ_QUERY_INFO(pPicInfo),
        lhClientDoc,szObjName,&lpOBJ_QUERY_OBJECT(pPicInfo))))
    {
         /*  mark as unloadable to prevent infinite LoadObject loops */
         bOBJ_QUERY_TOO_BIG(pPicInfo) = TRUE;
         lpOBJ_QUERY_OBJECT(pPicInfo) = NULL; // just in case (OLE ain't good about this)
         ferror = FALSE; // be sure to issue this message
         Error(IDPMTFailedToLoadObject);
         cpRetval = cp0;
         goto end;
    }

    if (ObjInitServerInfo(lpOBJ_QUERY_INFO(pPicInfo)))
    {
        ferror = FALSE; // be sure to issue this message
        Error(IDPMTOLEError);
        goto end;
    }

    if (ObjUpdatePicSize(pPicInfo,cpParaStart))
        if (ObjSetPicInfo(pPicInfo, doc, cpParaStart))
            goto end;

    ObjCachePara(doc,cpParaStart); // just in case

    cpRetval = vcpLimParaCache;

    end:
    ObjCloseStreamIO();
	EndLongOp(vhcArrow);
    return cpRetval;
}

typeCP ObjEditObjectInDoc(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart)
{
    typeCP cpRetval;
    OBJ_PLAYEDIT = OLEVERB_PRIMARY+1;
    cpRetval = ObjPlayObjectInDoc(pPicInfo, doc, cpParaStart);
    OBJ_PLAYEDIT = OLEVERB_PRIMARY;  // the default
    return cpRetval;
}

typeCP ObjPlayObjectInDoc(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart)
{
    OLESTATUS olestat;
    LPOBJINFO lpOInfo=lpOBJ_QUERY_INFO(pPicInfo);

    if ((otOBJ_QUERY_TYPE(pPicInfo) == STATIC) ||
        (otOBJ_QUERY_TYPE(pPicInfo) == NONE))
        return(vcpLimParaCache);

    if (ObjMakeObjectReady(pPicInfo,doc,cpParaStart))
        goto err;

    fOBJ_QUERY_PLAY(pPicInfo) = OBJ_PLAYEDIT; 

    do
    {
#ifdef DEBUG
        OutputDebugString( "Opening Object\n\r");
#endif

        StartLongOp();
        olestat = OleActivate(lpOBJ_QUERY_OBJECT(pPicInfo), 
                            OBJ_PLAYEDIT,
                            TRUE, 
                            TRUE, 
                            hDOCWINDOW, 
                            NULL);
	    EndLongOp(vhcArrow);

        switch (olestat)
        {
            /* check for bad link */
            case OLE_ERROR_OPEN:
            case OLE_ERROR_ADVISE_NATIVE:
            case OLE_ERROR_ADVISE_PICT: 
            case OLE_ERROR_REQUEST_NATIVE:
            case OLE_ERROR_REQUEST_PICT:

            fOBJ_BADLINK(pPicInfo) = TRUE;
            if (bLinkProps)
            {
                Error(IDPMTLinkUnavailable);
                goto err;
            }
            else
            {
                ObjCachePara(doc,cpParaStart);
                if (!FixInvalidLink(pPicInfo,doc,cpParaStart))
                    goto err;
                olestat = OLE_OK;
                lpOInfo->fCompleteAsync = TRUE; // cancel OleSetData (FixInvalid) as well
                if (ObjWaitForObject(lpOInfo,TRUE))
                    goto err;
            }
            break;
        }

        if (ObjError(olestat))
            goto err;
        else
            break;
    }
    while (1);

    fOBJ_BADLINK(pPicInfo) = FALSE; // can't be bad if succeeded
    //(**hpdocdod) [doc].fDirty = TRUE; // assume dirty is opened.
    ObjCachePara(doc,cpParaStart); // just in case
    return(vcpLimParaCache);

    err:
    Error(IDPMTFailedToActivate);
    return cp0;
}

typeCP ObjUpdateObjectInDoc(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart)
{
    int xSize,ySize;
    BOOL  bUpdate = FALSE;
    OLESTATUS olestat;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
        
    if ((otOBJ_QUERY_TYPE(pPicInfo) == STATIC) ||
        (otOBJ_QUERY_TYPE(pPicInfo) == NONE))
        return(vcpLimParaCache);

    if (bLinkProps && bOBJ_WAS_UPDATED(pPicInfo))
        return(vcpLimParaCache);

    if (ObjMakeObjectReady(pPicInfo,doc,cpParaStart))
        goto err;

    do
    {
#ifdef DEBUG
        OutputDebugString( "Updating Object\n\r");
#endif

        StartLongOp();
        olestat = OleUpdate(lpOBJ_QUERY_OBJECT(pPicInfo));
	    EndLongOp(vhcArrow);

        switch (olestat)
        {
            /* check for bad link */
            case OLE_ERROR_OPEN:
            case OLE_ERROR_ADVISE_NATIVE:
            case OLE_ERROR_ADVISE_PICT: 
            case OLE_ERROR_REQUEST_NATIVE:
            case OLE_ERROR_REQUEST_PICT:

            fOBJ_BADLINK(pPicInfo) = TRUE;
            if (bLinkProps)
            {
                Error(IDPMTLinkUnavailable);
                goto err;
            }
            else
            {
                ObjCachePara(doc,cpParaStart);
                if (!FixInvalidLink(pPicInfo,doc,cpParaStart))
                    goto err;
                olestat = OLE_OK;
                lpOBJ_QUERY_INFO(pPicInfo)->fCompleteAsync = TRUE; // cancel OleSetData (FixInvalid) as well 
                if (ObjWaitForObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE))
                    goto err;
            }
            break;
        }

        if (ObjError(olestat))
            goto err;
        else
            break;
    }
    while (1);

    ObjCachePara(doc,cpParaStart); // just in case

    fOBJ_BADLINK(pPicInfo) = FALSE; // can't be bad if succeeded

    if (bLinkProps)
    {
        bOBJ_WAS_UPDATED(pPicInfo) = TRUE;
    }

    return(vcpLimParaCache);

    err:
    Error(IDPMTFailedToUpdate);
    return cp0;
}

typeCP ObjFreezeObjectInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
{
    szOBJNAME szObjName;
    OBJPICINFO NewPicInfo = *pPicInfo;

    if ((otOBJ_QUERY_TYPE(pPicInfo) == STATIC) || 
        (otOBJ_QUERY_TYPE(pPicInfo) == NONE))
        return(vcpLimParaCache);

    if (ObjMakeObjectReady(pPicInfo,doc,cpParaStart))
        goto err;

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Freezing object\n\r");
#endif

    if (ObjCloneObjInfo(&NewPicInfo, cpParaStart, szObjName))
        return cp0;

    /* Make the object static.  Note side effect of changing lpObject!! */
    if (ObjError(OleObjectConvert(lpOBJ_QUERY_OBJECT(pPicInfo), SPROTOCOL,
                (LPOLECLIENT)lpOBJ_QUERY_INFO(&NewPicInfo), 
                lhClientDoc, szObjName, 
                &lpOBJ_QUERY_OBJECT(&NewPicInfo))))
        goto err;

    /* now delete original */
    ObjDeleteObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE);

    *pPicInfo = NewPicInfo;
    fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) = TRUE;
    otOBJ_QUERY_TYPE(pPicInfo) = STATIC;

    /* we got a new name to save */
    if (ObjSetPicInfo(pPicInfo, doc, cpParaStart))
        goto err;

    return(vcpLimParaCache);

    err:
    ObjDeleteObjInfo(lpOBJ_QUERY_INFO(&NewPicInfo));
    Error(IDPMTFailedToFreeze);
    return cp0;
}

typeCP ObjCloneObjectInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/* note we are *not* deleting the cloned object!   Note side effect that
   *pPicInfo gets altered to new clone values. */
{
    BOOL fDirty;
    szOBJNAME szObjName;
    OBJPICINFO NewPicInfo = *pPicInfo;
    LPOLEOBJECT lpObject;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);

    if (bOBJ_REUSE_ME(pPicInfo))
    /* assume that the original picInfo will be deleted!!! */
    {

#ifdef DEBUG
        OutputDebugString( (LPSTR) "Reusing object\n\r");
#endif
        bOBJ_REUSE_ME(pPicInfo) = FALSE;
        return(vcpLimParaCache);
    }

    if (ObjMakeObjectReady(pPicInfo,doc,cpParaStart))
        goto err;

    lpObject = lpOBJ_QUERY_OBJECT(pPicInfo);

    /* clone it.  This assumes the one we're cloning from is still in use
       (shouldn't be deleted). */

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Cloning object\n\r");
#endif

    if (ObjCloneObjInfo(&NewPicInfo, cpParaStart, szObjName))
        return cp0;

    if (ObjError(OleClone(lpObject,
        (LPOLECLIENT)lpOBJ_QUERY_INFO(&NewPicInfo),
        lhClientDoc,szObjName,
        &lpOBJ_QUERY_OBJECT(&NewPicInfo))))
        goto err;


    lpOBJ_QUERY_INFO(&NewPicInfo)->fCompleteAsync = TRUE;
    if (ObjWaitForObject(lpOBJ_QUERY_INFO(&NewPicInfo),TRUE))
        goto err;

    if (lpOBJ_QUERY_INFO(&NewPicInfo)->fDeleteMe)
    /* this is how we know it failed asynchronously */
        goto err;

    /** 
        Save object name and objinfo that we just got.
    **/
    *pPicInfo = NewPicInfo;

    if (ObjSetPicInfo(pPicInfo, doc, cpParaStart))
        goto err;

    return(vcpLimParaCache);

    err:
    ObjDeleteObjInfo(lpOBJ_QUERY_INFO(&NewPicInfo));
    Error(IDPMTFailedToCreateObject);
    return cp0;
}

typeCP ObjToCloneInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
{
    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
        
#ifdef DEBUG
    OutputDebugString( (LPSTR) "Marking object reusable\n\r");
#endif

    bOBJ_REUSE_ME(pPicInfo) = TRUE;

    return(vcpLimParaCache);
}

typeCP ObjFromCloneInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
{
    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
        
#ifdef DEBUG
    OutputDebugString( (LPSTR) "Marking object not reusable\n\r");
#endif

    bOBJ_REUSE_ME(pPicInfo) = FALSE;

    return(vcpLimParaCache);
}

typeCP ObjBackupInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/* !!! used by link properties only !!!. Object guaranteed loaded */
{
    szOBJNAME szObjName;
    LPOBJINFO lpCloneInfo=NULL;

    if (lpOBJ_QUERY_CLONE(pPicInfo) == NULL) // then clone it
    {
#ifdef DEBUG
        OutputDebugString( (LPSTR) "Backing up object\n\r");
#endif

        if (ObjWaitForObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE))
            return cp0;

        if (ObjCopyObjInfo(lpOBJ_QUERY_INFO(pPicInfo),
                            &lpOBJ_QUERY_CLONE(pPicInfo),
                            szObjName))
            return(cp0);

        if (ObjError(OleClone(lpOBJ_QUERY_OBJECT(pPicInfo),
            (LPOLECLIENT)lpOBJ_QUERY_CLONE(pPicInfo),
            lhClientDoc,szObjName,&(lpOBJ_QUERY_CLONE(pPicInfo)->lpobject))))
                return cp0;
    }

    return(vcpLimParaCache);
}

typeCP ObjClearCloneInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/* !!! used by link properties only !!! Object guaranteed loaded */
/* delete clone, don't use it */
{
    if (lpOBJ_QUERY_CLONE(pPicInfo))
    {
#ifdef DEBUG
        OutputDebugString( (LPSTR) "Deleting clone\n\r");
#endif
        ObjDeleteObject(lpOBJ_QUERY_CLONE(pPicInfo),TRUE);
        lpOBJ_QUERY_CLONE(pPicInfo) = NULL;
    }

    return(vcpLimParaCache);
}

typeCP ObjUseCloneInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/* !!! used by link properties only !!! */
{
    szOBJNAME szObjName;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
        
    if (lpOBJ_QUERY_CLONE(pPicInfo))
    {
        extern int FAR _cdecl sscanf(const char FAR *, const char FAR *, ...);
        LPOBJINFO lpClone = lpOBJ_QUERY_CLONE(pPicInfo);

#ifdef DEBUG
        OutputDebugString( (LPSTR) "using clone\n\r");
#endif

        ObjDeleteObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE);

        lpOBJ_QUERY_INFO(pPicInfo) = lpClone;
        lpOBJ_QUERY_CLONE(pPicInfo) = NULL;
        fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) = TRUE;   // wanna save clone information
                                                    // just in case

        /* might've been frozen, used by LoadObject (this is what is unique
           in the context of link properties) */
        otOBJ_QUERY_TYPE(pPicInfo) = LINK;  

        if (ObjSetPicInfo(pPicInfo, doc, cpParaStart))
            return cp0;
    }

    return(vcpLimParaCache);
}


typeCP ObjSetNoUpdate(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
{
    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
        
#ifdef DEBUG
    OutputDebugString( (LPSTR) "Set no update for object\n\r");
#endif

    if (otOBJ_QUERY_TYPE(pPicInfo) == LINK)
    {
        bOBJ_WAS_UPDATED(pPicInfo) = FALSE;
    }

    return(vcpLimParaCache);
}


typeCP ObjCheckObjectTypes(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
{
#ifdef DEBUG
    //OutputDebugString( (LPSTR) "Checking Object Type\n\r");
#endif

    /*  Result returned in OBJ_SELECTIONTYPE is highest object type which 
        exists at cpParaStart relative to current value of OBJ_SELECTIONTYPE.
    */
    switch(otOBJ_QUERY_TYPE(pPicInfo))
    {
        case STATIC:
            if (OBJ_SELECTIONTYPE < STATIC)
                OBJ_SELECTIONTYPE = STATIC;
            //OBJ_CEMBEDS = 0;
            return(vcpLimParaCache);

        case LINK:
            OBJ_SELECTIONTYPE = LINK;
            //OBJ_CEMBEDS = 0;
            return(vcpLimParaCache);

        case NONE:
            if (OBJ_SELECTIONTYPE < NONE)
                OBJ_SELECTIONTYPE = NONE;
            //OBJ_CEMBEDS = 0;
            return(vcpLimParaCache);

        case EMBEDDED:
            if (OBJ_SELECTIONTYPE < EMBEDDED)
                OBJ_SELECTIONTYPE = EMBEDDED;
            //++OBJ_CEMBEDS;
            return(vcpLimParaCache);

        default:
            Assert(0);
            return cp0;
    }
}

typeCP ObjSetHostNameInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
{
    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);

    if (lpOBJ_QUERY_OBJECT(pPicInfo) == NULL)
        return(vcpLimParaCache); // dont care if not loaded

    if ((otOBJ_QUERY_TYPE(pPicInfo) != EMBEDDED) &&
        (otOBJ_QUERY_TYPE(pPicInfo) != NONE))
        return(vcpLimParaCache);

    //if (OleQueryOpen(lpOBJ_QUERY_OBJECT(pPicInfo)) != OLE_OK)
        //return(vcpLimParaCache);
        
    if (ObjWaitForObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE))
        return cp0;

    if (ObjSetHostName(lpOBJ_QUERY_INFO(pPicInfo),doc))
        return(cp0);

    return(vcpLimParaCache);
}

typeCP ObjChangeLinkInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/* assumes aNewName is set */
{
    HANDLE      hData,hNewData=NULL;
    typeCP cpRetval=cp0;
    OLESTATUS olestat=OLE_OK;

    if (otOBJ_QUERY_TYPE(pPicInfo) != LINK)
        return(vcpLimParaCache);

    if (ObjMakeObjectReady(pPicInfo,doc,cpParaStart))
        return cp0;

    /* Change the link information */
    /* if theres a newname, then use it.  Else get a new name from user */
    olestat = ObjGetData(lpOBJ_QUERY_INFO(pPicInfo), vcfLink, &hData); 

    if ((olestat == OLE_WARN_DELETE_DATA) || (olestat ==  OLE_OK))
    {
        if (!(hNewData = ObjMakeNewLinkName(hData, aNewName))
            || !ObjSetData(pPicInfo, vcfLink, hNewData))
            goto end;

        if (olestat == OLE_WARN_DELETE_DATA)
            GlobalFree(hData);

       /* this may not be necessary any more, check carefully. */
        if (ObjUpdateObjectInDoc(pPicInfo,doc,cpParaStart) == cp0)
            goto end;

        fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) = TRUE;
        fOBJ_BADLINK(pPicInfo) = FALSE;

        cpRetval = vcpLimParaCache;
    }

    end:
    if (hNewData)
        GlobalFree(hNewData);
    return cpRetval;
}

typeCP ObjUpdateLinkInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/** 
    Change or update link to aNewName if == aOldName.  Assumes vbChangeOther
    has been initialized.
**/
{
    HANDLE      hData;
    char        szRename[cchMaxSz];

    if (otOBJ_QUERY_TYPE(pPicInfo) != LINK)
        return(vcpLimParaCache);

    if (aOBJ_QUERY_DOCUMENT_LINK(pPicInfo) == aOldName) 
    /* Change the link information */
    {
        if (bLinkProps && bOBJ_WAS_UPDATED(pPicInfo))
            return(vcpLimParaCache);
            
        if (!fUpdateAll) 
        {
            char szTmp[sizeof(szRename) + 90];
            char szLink[30],szDocName[30];
            CHAR szDocPath[ cchMaxFile ]; 
            CHAR szFullPath[ cchMaxFile ]; 

            SplitSzFilename( (**((**hpdocdod)[doc].hszFile)), szDocPath, szDocName );

            GetAtomName(aOBJ_QUERY_DOCUMENT_LINK(pPicInfo),szFullPath,sizeof(szFullPath));
            SplitSzFilename( szFullPath, szDocPath, szLink );

            if (!szDocName[0])
                LoadString(hINSTANCE, IDSTRUntitledDef, szDocName, sizeof(szDocName));

            /* Ask the user if they want to update the links */
            if (vbChangeOther)
                LoadString(hINSTANCE, IDSTRRename, szRename, sizeof(szRename));
            else // update other
                LoadString(hINSTANCE, IDSTRUpdate, szRename, sizeof(szRename));

            /* cast cause compiler is screwing up */
            wsprintf((LPSTR)szTmp,(LPSTR)szRename,(LPSTR)szLink,(LPSTR)szDocName,(LPSTR)szLink);

            if (MessageBox(hPARENTWINDOW, szTmp, szAppName,
                            MB_YESNO|MB_ICONEXCLAMATION) == IDNO) 
                return cp0;

            ObjCachePara(doc,cpParaStart); // MessageBox screws things up
            fUpdateAll = TRUE;
        }

        if (vbChangeOther)
        {
            if (ObjBackupInDoc(pPicInfo,doc,cpParaStart))
                return ObjChangeLinkInDoc(pPicInfo,doc,cpParaStart);
        }
        else
        {
            if (ObjBackupInDoc(pPicInfo,doc,cpParaStart))
                return ObjUpdateObjectInDoc(pPicInfo,doc,cpParaStart);
        }
    }

    return(vcpLimParaCache);
}


typeCP ObjCloseObjectInDoc(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart)
{
    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
    
    if (lpOBJ_QUERY_OBJECT(pPicInfo) == NULL)
        return(vcpLimParaCache);

    if (otOBJ_QUERY_TYPE(pPicInfo) == STATIC) // nothing to close
        return(vcpLimParaCache);

    if (ObjWaitForObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE))
        return cp0;

    /* 
        Note that if this is an unfinished object, then the OLE_CLOSE 
        (whenever it happens to arrive) will cause the picinfo to be 
        deleted.
    */
    if (ObjError(OleClose(lpOBJ_QUERY_OBJECT(pPicInfo))))
        return(cp0);

    return(vcpLimParaCache);
}

/****************************************************************/
/****************** OLE OBJECT DATA I/O *************************/
/****************************************************************/
static typeCP ObjWriteDataToDoc(LPOLEOBJECT lpObject)
/* 
    Return cp after end of paragraph we've created or 0 if error.
    Assume ObjStream is initialized.
*/
{
    BOOL fSaveError = ferror;
    
    if (vfOutOfMemory || vfSysFull /*|| ObjStop*/)
        return cp0;

    Assert(!ferror);

    ferror = FALSE; /* so we can still call Replace().  */

    if (ObjError(OleSaveToStream(lpObject,lpStream)))
    {
        if (ferror)
        /* uh oh, hope we can clean up enough to look clean */
        {
            /* delete what we inserted if possible */
            ferror = FALSE;
            Replace(docStream, cpObjectDataBase  - cchPICINFOX,  cpObjectDataCurLoc - cpObjectDataBase + cchPICINFOX, fnNil, fc0, fc0);
            ferror = TRUE;
            return cp0;
        }
    }

    /* is this call necessary? Important to do if InsertRgch doesn't. */
    ObjCachePara(docStream,cpObjectDataBase - cchPICINFOX);

    ferror = fSaveError || ferror;

    return vcpLimParaCache; // cp after para we just inserted
}


/****************************************************************/
/******************** OLE STREAM I/O ****************************/
/****************************************************************/

static 
ObjOpenStreamIO(typeCP cpParaStart, int doc, struct CHP *pchp, struct PAP *ppapGraph, DWORD dwObjectSize)
{
    if (cpObjectDataCurLoc)
        ObjCloseStreamIO();

    cpObjectDataBase = cpObjectDataCurLoc = cpParaStart;
    cObjectData = 0L;
    dwDataMax = dwObjectSize;
    docStream = doc;
    pchpStream = pchp;
    ppapStream = ppapGraph;
}

static void
ObjCloseStreamIO(void)
{
    cpObjectDataBase = cpObjectDataCurLoc = cp0;
}

LONG FAR PASCAL BufReadStream(LPOLESTREAM lpStream, char huge *lpstr, DWORD cb) 
{
    DWORD dwRetval;
    typeCP cpMac = vcpLimParaCache;
    int cchRun;

    if ((cb + cpObjectDataCurLoc) > cpMac) // reading past end of para
    {
        Assert(0);
        return 0L;
    }

    for (   dwRetval = 0L;
            cb;
            cb -= cchRun, 
            cObjectData += cchRun,
            cpObjectDataCurLoc += (typeCP) cchRun,
            dwRetval += cchRun)
    {
        CHAR rgch[ 255 ];
        register char *chT;
        register unsigned cchT;
        unsigned cch = ulmin(cb, 255L);

        FetchRgch( &cchRun, rgch, docStream, cpObjectDataCurLoc, cpMac, cch);

        if (ferror)
            return -dwRetval;

        for(chT = rgch,cchT=cchRun; cchT--; )
            *lpstr++ = *chT++;
    }

    return dwRetval;
}


LONG FAR PASCAL BufWriteStream(LPOLESTREAM lpStream, char huge *lpstr, DWORD cb) 
{
    DWORD dwRetval;
    char *chT;
    unsigned cchT;
    CHAR                rgch[255];
    unsigned cch;
    struct PAP *ppap=NULL;
    
    for (   dwRetval = 0L;
            dwRetval < cb;
            cpObjectDataCurLoc += (typeCP) cch,
            cObjectData += cch,
            dwRetval += cch)
    {
        cch = ulmin(cb - dwRetval, 255L);

        for(chT = rgch,cchT=cch; cchT--;)
            *chT++ = *lpstr++;

        if ((cObjectData + cch) == dwDataMax)
            ppap = ppapStream;

        InsertRgch( docStream, cpObjectDataCurLoc, rgch, cch, pchpStream, ppap);

        if (ferror)
            return 0L;
    }

    return dwRetval;
}

ObjGetPicInfo(LPOLEOBJECT lpObject, int doc, OBJPICINFO *pPicInfo, typeCP *pcpParaStart)
/* get picInfo that has lpObject */
/* !!! since writing this it has occurred to me that a quicker way to do
   this would be to keep a list of pieces that point to objects.  Pieces
   never */
{
    OBJPICINFO picInfoT;
    typeCP cpStart,cpMac= CpMacText(doc);

    for (cpStart = cpNil; ObjPicEnumInRange(&picInfoT,doc,cp0,cpMac,&cpStart); ) 
    {
        if (lpOBJ_QUERY_INFO(&picInfoT) == NULL)
            continue;
        
        if (lpOBJ_QUERY_OBJECT(&picInfoT) == lpObject) // bingo
         {
            if (pPicInfo)
                *pPicInfo = picInfoT;
            if (pcpParaStart)
                *pcpParaStart = cpStart;
            return TRUE;
         }
    }

    return FALSE;
}

BOOL vfObjDisplaying=FALSE;
BOOL ObjSetPicInfo(OBJPICINFO *pSrcPicInfo, int doc, typeCP cpParaStart)
{
/* 
    NOTE that you only gotta call this when you change the OBJPICINFO fields:
        mm,
        objecttype,
        dwDataSize,
        dwObjNum, or
        lpObjInfo.
*/
    BOOL bError = FALSE;
    typeFC fcT;
    extern BOOL            vfInvalid;
    BOOL vfSaveInvalid = vfInvalid;
    BOOL docDirty = (**hpdocdod) [doc].fDirty;

    ObjPushParms(doc);

    ObjCachePara(doc,cpParaStart);

    if (vfObjDisplaying)  
        vfInvalid = FALSE; // this'll suppress things that mess up UpdateWw()
    bNoEol = TRUE;

    if (dwOBJ_QUERY_DATA_SIZE(pSrcPicInfo) == 0L)
    /* is this ever executed? */
    {
        struct CHP chp;

        /* problem is to retain graphics property of picinfo structure */
        GetChp(&chp, cpParaStart, doc); // calls CachePara
        NewChpIns(&chp);
        ObjUpdateFromObjInfo(pSrcPicInfo);
        pSrcPicInfo->mm |= MM_EXTENDED;
        InsertRgch( doc, cpParaStart + (typeCP)cchPICINFOX, pSrcPicInfo, 
                   (unsigned)cchPICINFOX, &chp, &vpapAbs );
        pSrcPicInfo->mm &= ~MM_EXTENDED;

        if (ferror)
            return TRUE;

        /* delete old pieces (in front) that pointed to duped data */
        Replace(doc, cpParaStart, (typeCP)cchPICINFOX, fnNil, fc0, fc0);
    }
    else
    {
        ObjUpdateFromObjInfo(pSrcPicInfo);
        pSrcPicInfo->mm |= MM_EXTENDED;
        fcT = FcWScratch( pSrcPicInfo, cchPICINFOX );
        pSrcPicInfo->mm &= ~MM_EXTENDED;

        if (ferror)
            return TRUE;
        Replace( doc, cpParaStart, (typeCP)cchPICINFOX,
            fnScratch, fcT, (typeFC)cchPICINFOX);
    }

    if (ferror)
        return TRUE;

    bNoEol = FALSE;
    if (vfObjDisplaying)
        vfInvalid = vfSaveInvalid;

    /* don't want this to affect docDirty flag */
    (**hpdocdod) [doc].fDirty = docDirty; 

    ObjPopParms(TRUE);

    return bError;
}


void ChangeOtherLinks(int doc, BOOL bChange, BOOL bPrompt)
/** For any items == aOldName, set to aNewName.  Query user if OK first. 
    Assumes aOldName and aNewName are set.  (See FixInvalidLink() and
    ObjChangeLinkInDoc()).
    bChange is TRUE if ChangeLink, FALSE if UpdateObject.
    bPrompt is TRUe if prompt user for change.
  **/
{
    fUpdateAll = !bPrompt;

    vbChangeOther = bChange; // TRUE to change links, FALSE to update links
    ObjEnumInDoc(doc,ObjUpdateLinkInDoc);

}

BOOL ObjQueryNewLinkName(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/** Return whether obtained new link name from user.  Set aOldName 
    and aNewName. **/
{
    HANDLE      hData,hNewData=NULL;
    LPSTR       lpdata=NULL;
    BOOL bRetval = FALSE;
    OLESTATUS olestat=OLE_OK;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(FALSE);

    if (otOBJ_QUERY_TYPE(pPicInfo) != LINK)
        return(FALSE);

    if (ObjMakeObjectReady(pPicInfo,doc,cpParaStart))
        return(FALSE);

    /* query user for new name */
    olestat = ObjGetData(lpOBJ_QUERY_INFO(pPicInfo), vcfLink, &hData); 
    if ((olestat == OLE_WARN_DELETE_DATA) || (olestat ==  OLE_OK))
        if (!(hNewData = OfnGetNewLinkName(hPARENTWINDOW, hData)))
            goto end;

    if (olestat == OLE_WARN_DELETE_DATA)
        GlobalFree(hData);

    aOldName = aOBJ_QUERY_DOCUMENT_LINK(pPicInfo);

    lpdata=MAKELP(hNewData,0);

    while (*lpdata++);

    aNewName = AddAtom(lpdata);

    bRetval = TRUE;

    end:
    if (olestat == OLE_WARN_DELETE_DATA)
        GlobalFree(hData);

    if (hNewData)
        GlobalFree(hNewData); 

    return bRetval;
}

FixInvalidLink(OBJPICINFO far *lpPicInfo, int doc, typeCP cpParaStart)
/* returns FALSE if couldn't or wouldn't do anything, RETRY if reset link */
{

    fOBJ_BADLINK(lpPicInfo) = TRUE;
    if (DialogBox(hINSTANCE, "DTINVALIDLINK",
                    hPARENTWINDOW, lpfnInvalidLink) == IDD_CHANGE) 
#if !defined(SMALL_OLE_UI)
        fnObjProperties();
#else
        ObjChangeLinkInDoc(lpPicInfo,doc,cpParaStart);
#endif
    return FALSE;
}

/* ObjMakeNewLinkName() - Constructs a new link name from an atom.
 */
static HANDLE ObjMakeNewLinkName(HANDLE hData, ATOM atom) 
{
    BOOL    fSuccess    = FALSE;
    HANDLE  hData2      = NULL;
    HANDLE  hData3      = NULL;
    LPSTR   lpstrData   = NULL;
    LPSTR   lpstrLink   = NULL;
    LPSTR   lpstrTemp;
    char    szFile[CBPATHMAX];

    if (!GetAtomName(atom, szFile, CBPATHMAX)
     || !(lpstrData = (LPSTR)GlobalLock(hData))
     || !(hData2 = GlobalAlloc(GMEM_DDESHARE | GMEM_ZEROINIT, CBPATHMAX * 2))
     || !(lpstrLink = lpstrTemp = (LPSTR)GlobalLock(hData2)))
        goto Error;

    /* ... copy the server name */
    while (*lpstrTemp++ = *lpstrData++);

    /* ... copy the document name */
    lstrcpy(lpstrTemp, szFile);
    lpstrTemp += lstrlen(lpstrTemp) + 1;
    lpstrData += lstrlen(lpstrData) + 1;

    /* ... copy the item name */
    while (*lpstrTemp++ = *lpstrData++);
    *lpstrTemp = 0;

    /* ... and compress the memory block to minimal size */
    GlobalUnlock(hData2);
    hData3 = GlobalReAlloc(hData2, (DWORD)(lpstrTemp - lpstrLink + 1), 0);

    if (!hData3)
        hData3 = hData2;

    fSuccess = TRUE;

Error:
    if (!fSuccess) {
        if (lpstrLink)
            GlobalUnlock(hData2);
        if (hData2)
            GlobalFree(hData2);
        hData3 = NULL;
    }

    if (lpstrData)
        GlobalUnlock(hData);

    return hData3;
}

char *ObjGetServerName(LPOLEOBJECT lpObject, char *szServerName)
{
    LPSTR   lpstrData;
    HANDLE  hData;
	LONG        otobject;
    OLESTATUS olestat;

    /**  NOTE: OleGetData can return OLE_BUSY.  Because of how 
        ObjGetServerName is used, we're not going to wait for the 
        object here, we'll just return if its busy **/

    if (OleQueryReleaseStatus(lpObject) == OLE_BUSY)
        return NULL;

    if (ObjError(OleQueryType(lpObject,&otobject)))
        return NULL;

    olestat = OleGetData(lpObject, 
                    otobject == OT_LINK ? vcfLink : vcfOwnerLink, 
                    &hData);

    if ((olestat != OLE_WARN_DELETE_DATA) && (olestat !=  OLE_OK))
    {
        ObjError(olestat);
        return NULL;
    }

    lpstrData = MAKELP(hData,0);
    RegGetClassId(szServerName, lpstrData);
    if (olestat == OLE_WARN_DELETE_DATA)
        GlobalFree(hData);

    return szServerName;
}

/* OfnInit() - Initializes the standard file dialog OFN structure.
 */
void OfnInit(HANDLE hInst) {
    LPSTR lpstr;

    OFN.lStructSize         = sizeof(OPENFILENAME);
    OFN.hInstance           = hInst;
    OFN.nMaxCustFilter      = CBFILTERMAX;
    OFN.nMaxFile            = CBPATHMAX;
    OFN.Flags               = OFN_HIDEREADONLY;
    OFN.lCustData           = NULL;
    OFN.lpfnHook            = NULL;
    OFN.lpTemplateName      = NULL;
    OFN.lpstrDefExt         = NULL;
    OFN.lpstrFileTitle      = NULL;

    LoadString(hInst, IDSTRChangelink, szLinkCaption, sizeof(szLinkCaption));
}

/* OfnGetNewLinkName() - Sets up the "Change Link..." dialog box
 */
static HANDLE OfnGetNewLinkName(HWND hwnd, HANDLE hData) 
{
    BOOL    fSuccess    = FALSE;
    HANDLE  hData2      = NULL;
    HANDLE  hData3      = NULL;
    LPSTR   lpData2     = NULL;
    LPSTR   lpstrData   = NULL;
    LPSTR   lpstrFile   = NULL;
    LPSTR   lpstrLink   = NULL;
    LPSTR   lpstrPath   = NULL;
    LPSTR   lpstrTemp   = NULL;
    char    szDocFile[CBPATHMAX];
    char    szDocPath[CBPATHMAX];
    HANDLE  hServerFilter=NULL;

    /* Get the link information */
    if (!(lpstrData = GlobalLock(hData)))
        goto Error;

    /* Figure out the link's path name and file name */
    lpstrTemp = lpstrData;
    while (*lpstrTemp++);
    lpstrPath = lpstrFile = lpstrTemp;
    while (*(lpstrTemp = AnsiNext(lpstrTemp)))
        if (*lpstrTemp == '\\')
            lpstrFile = lpstrTemp + 1;

    /* Copy the document name */
    lstrcpy(szDocFile, lpstrFile);
    *(lpstrFile - 1) = 0;

    /* Copy the path name */
    lstrcpy(szDocPath, ((lpstrPath != lpstrFile) ? lpstrPath : ""));
    if (lpstrPath != lpstrFile)                 /* Restore the backslash */
        *(lpstrFile - 1) = '\\';
    while (*lpstrFile != '.' && *lpstrFile)     /* Get the extension */
        lpstrFile++;

    /* Make a filter that respects the link's class name */
    OFN.hwndOwner           = hwnd;

    OFN.nFilterIndex        = RegMakeFilterSpec(lpstrData, lpstrFile, &hServerFilter);
    if (OFN.nFilterIndex == -1)
        goto Error;
    OFN.lpstrFilter         = (LPSTR)MAKELP(hServerFilter,0);

    Normalize(szDocFile);
    OFN.lpstrFile           = (LPSTR)szDocFile;
    OFN.lpstrInitialDir     = (LPSTR)szDocPath;
    OFN.lpstrTitle          = (LPSTR)szLinkCaption;
    OFN.lpstrCustomFilter   = (LPSTR)szCustFilterSpec;


    /* If we get a file... */
    if (GetOpenFileName((LPOPENFILENAME)&OFN)) 
    {
        if (!(hData2 = GlobalAlloc(GMEM_DDESHARE | GMEM_ZEROINIT, CBPATHMAX * 2))
         || !(lpstrLink = lpstrTemp = GlobalLock(hData2)))
            goto Error;

        /* ... copy the server name */
        while (*lpstrTemp++ = *lpstrData++);

        /* ... copy the document name */
        lstrcpy(lpstrTemp, szDocFile);
        lpstrTemp += lstrlen(lpstrTemp) + 1;
        lpstrData += lstrlen(lpstrData) + 1;

        /* ... copy the item name */
        while (*lpstrTemp++ = *lpstrData++);
        *lpstrTemp = 0;

        /* ... and compress the memory block to minimal size */
        GlobalUnlock(hData2);
        hData3 = GlobalReAlloc(hData2, (DWORD)(lpstrTemp - lpstrLink + 1), 0);

        if (!hData3)
            hData3 = hData2;

        fSuccess = TRUE;
    }

Error:
    if (!fSuccess) 
    {
        if (lpstrLink)
            GlobalUnlock(hData2);
        if (hData2)
            GlobalFree(hData2);
        hData3 = NULL;
    }

    if (lpstrData)
        GlobalUnlock(hData);

    if (hServerFilter)
        GlobalFree(hServerFilter);

    return hData3;
}

/* Normalize() - Removes the path specification from the file name.
 *
 * Note:  It isn't possible to get "<drive>:<filename>" as input because
 *        the path received will always be fully qualified.
 */
static void Normalize(LPSTR lpstrFile) 
{
    LPSTR   lpstrBackslash  = NULL;
    LPSTR   lpstrTemp       = lpstrFile;

    while (*lpstrTemp) {
        if (*lpstrTemp == '\\')
            lpstrBackslash = lpstrTemp;

        lpstrTemp = AnsiNext(lpstrTemp);
    }
    if (lpstrBackslash)
        lstrcpy(lpstrFile, lpstrBackslash + 1);
}

/* ObjSetUpdateOptions() - Sets the update options of the object.
 *
 * Returns:  TRUE iff the command completed successfully
 */
BOOL ObjSetUpdateOptions(OBJPICINFO *pPicInfo, WORD wParam, int doc, typeCP cpParaStart) 
/* !!! Used by Link Properties only!!!  Object guaranteed loaded */
{
    if (ObjWaitForObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE))
    {
        Error(IDPMTFailedToUpdateLink);
        return FALSE;
    }

    if (ObjError(OleSetLinkUpdateOptions(lpOBJ_QUERY_OBJECT(pPicInfo),
            (wParam == IDD_AUTO) ? oleupdate_always : oleupdate_oncall)))
    {
        Error(IDPMTFailedToUpdateLink);
        return FALSE;
    }

    fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) = TRUE;

    return TRUE;
}

/* ObjGetUpdateOptions() - Retrieves the update options of the object.
 */
OLEOPT_UPDATE ObjGetUpdateOptions(OBJPICINFO far *lpPicInfo) 
/* !!! Used by Link Properties only!!!  Object guaranteed loaded */
{
    BOOL        fSuccess = FALSE;
    OLEOPT_UPDATE fUpdate;

    if (otOBJ_QUERY_TYPE(lpPicInfo) == LINK)
    {
        if (ObjWaitForObject(lpOBJ_QUERY_INFO(lpPicInfo),TRUE))
            return FALSE;

        fSuccess = !ObjError(OleGetLinkUpdateOptions(lpOBJ_QUERY_OBJECT(lpPicInfo), &fUpdate));
    }
    return (fSuccess ? fUpdate : oleupdate_onsave);
}

OLESTATUS ObjGetData(LPOBJINFO lpObjInfo, OLECLIPFORMAT cf, HANDLE far *lphData)
/*  
    Return olestat.
    Put handle to data into lphData.
    Assumes object is loaded.
*/
{
    HANDLE      hData;
    OLESTATUS olestat;

    if (ObjWaitForObject(lpObjInfo,TRUE))
        return OLE_BUSY;

    olestat = OleGetData(lpObjInfo->lpobject, cf, lphData);
    if ((olestat != OLE_WARN_DELETE_DATA) && (olestat !=  OLE_OK))
        ObjError(olestat);
    return olestat;
}

/* ObjSetData() - Set the object's (link) information
   Sets DOCUMENT_LINK ATOM in pPicInfo
 */
BOOL ObjSetData(OBJPICINFO far *lpPicInfo, OLECLIPFORMAT cf, HANDLE hData) 
/* assumes object is loaded */
{
    HANDLE      hitem;
    LPSTR       lpdata;

    if (ObjWaitForObject(lpOBJ_QUERY_INFO(lpPicInfo),TRUE))
        return FALSE;

    if (ObjError(OleSetData(lpOBJ_QUERY_OBJECT(lpPicInfo), cf, hData)))
        return FALSE;

    /* If we have a link, update the document name */
    if (cf == vcfLink && (lpdata = GlobalLock(hData))) 
    {
        ATOM aSaveOld = aOBJ_QUERY_DOCUMENT_LINK(lpPicInfo);

        while (*lpdata++);

        aOBJ_QUERY_DOCUMENT_LINK(lpPicInfo) = AddAtom(lpdata);

        if (aSaveOld)
            DeleteAtom(aSaveOld);

        GlobalUnlock(hData);
    }
    else
        return FALSE;

    return TRUE;
}

int ObjSetSelectionType(int doc, typeCP cpFirst, typeCP cpLim)
{
    /* set whether link or emb selected */
    OBJ_SELECTIONTYPE = NONE;  // this'll be set by ObjCheckObjectTypes()
    //OBJ_CEMBEDS       = 0;     // this'll be set by ObjCheckObjectTypes()
    return ObjEnumInRange(doc,cpFirst,cpLim,ObjCheckObjectTypes);
}

BOOL ObjQueryCpIsObject(int doc,typeCP cpFirst)
{
    OBJPICINFO picInfo;

    /* assume its cached already! */
    //ObjCachePara(doc,cpFirst); /* NOTE side effect of caching */

    if (!vpapAbs.fGraphics)
        return FALSE;

    if (cpFirst >= CpMacText(doc))
        return FALSE;

    GetPicInfo(cpFirst,cpFirst + cchPICINFOX, doc, &picInfo);
    return bOBJ_QUERY_IS_OBJECT(&picInfo);
}


ATOM MakeLinkAtom(LPOBJINFO lpObjInfo)
{
    HANDLE      hData;
    LPSTR       lpdata;
    ATOM aRetval=NULL;
    OLESTATUS olestat=OLE_OK;

    olestat = ObjGetData(lpObjInfo, vcfLink, &hData);

    if ((olestat == OLE_WARN_DELETE_DATA) || (olestat ==  OLE_OK))
    {
        lpdata = MAKELP(hData,0);
        while (*lpdata++);
        aRetval =  AddAtom(lpdata);
    
        if (olestat == OLE_WARN_DELETE_DATA)
            GlobalFree(hData);
    }
    return aRetval;
}

#include <time.h>
void ObjGetObjectName(LPOBJINFO lpObjInfo, szOBJNAME szObjName)
/* put object name from ObjInfo into szObjName */
{
    if (szObjName && lpObjInfo)
        GetAtomName(lpObjInfo->aObjName,szObjName,sizeof(szObjName));
}

void ObjMakeObjectName(LPOBJINFO lpObjInfo, LPSTR lpstr)
{
    szOBJNAME szObjName;

    time_t lTime;
    time(&lTime);
    wsprintf(szObjName, "%lx", lTime);

    if (lpObjInfo)
        lpObjInfo->aObjName = AddAtom(szObjName);

    if (lpstr)
        lstrcpy(lpstr,szObjName);
}

static void GetChp(struct CHP *pchp, typeCP cp, int doc)
{
 /** 
    Return chp at cp in *pchp.
    Resets Cache to cp when done. 
    We assume that we're always inserting after an EOL or at beginning of
    document.
  **/

extern struct CHP       vchpAbs;

if (cp == cp0) // beginning of doc
{
    typeCP cpMac =  CpMacText(doc);
    if (cpMac == cp0) // empty doc
    {
	    /* force default character properties, font size to be 10 point */
	    *pchp = vchpNormal;
	    pchp->hps = hpsDefault;
        return;
    }
    else // get next char props
    {
        ObjCachePara(doc,cp+1); // to reset
        FetchCp( doc, cp+1, 0, fcmProps );
    }
}
else
{
    ObjCachePara(doc,cp-1); // to reset
    FetchCp( doc, cp-1, 0, fcmProps ); // previous paragraph's chp
}

*pchp = vchpAbs;

if (pchp->fSpecial && pchp->hpsPos != 0)
	{ /* if this char is a footnote or page marker, then ignore */
	pchp->hpsPos = 0;		  /* super/subscript stuff. */
	pchp->hps = HpsAlter(pchp->hps, 1);
	}

pchp->fSpecial = fFalse;

ObjCachePara(doc,cp); // to reset
}

BOOL ObjSetHostName(LPOBJINFO lpOInfo, int doc)
/* TRUE if error */
/* we assume object ain't busy!!! */
{
    extern  CHAR    szUntitled[20];
    CHAR *PchStartBaseNameSz(),*szTitle= **((**hpdocdod)[doc].hszFile);

    if (szTitle[0])
        szTitle = PchStartBaseNameSz(szTitle);
    else
        szTitle = szUntitled;

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Setting host name\n\r");
#endif

    /*  
        Note that OleSetHostNames can return OLE_BUSY!!!  So you
        better call ObjWaitForObject() first.
     */

    if (ObjError(OleSetHostNames(lpOInfo->lpobject,szAppName,szTitle))) 
        return TRUE;

    return FALSE;
}

BOOL ObjMakeObjectReady(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart)
/* Load object, complete async.  Return whether an error. */
{
    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return TRUE;

    if (lpOBJ_QUERY_OBJECT(pPicInfo) == NULL)
    {
        if (ObjLoadObjectInDoc(pPicInfo,doc,cpParaStart) == cp0)
            return TRUE;
    }
    else if (ObjWaitForObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE))
        return TRUE;

    ObjCachePara(doc, cpParaStart);

    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\mw.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* MW.H  --  Main header file for Windows Write */


/* some defines that used to be done in the makefile... 
   (started exceeding command line length!) */

#define OLE         /* Object Linking and Embedding 01/23/91 -- dougk 
		               Also defined in write.rc. */

#define PENWIN      /* pen windows: also defined in write.rc (6.21.91) v-dougk */

#define WIN30
/* #define WINVER 310 */  /* First convention was to use WIN30 defined above, 
                       but later switched to use of WINVER so it will be 
                       easier next time we change either the Windows or 
                       Write products  12/3/89..pault */

#define INTL        /* This MUST be turned on (even for the Z version now) */
#define CRLF        /* MS-DOS defines the carriage-return/line-feed sequence */

/* Major intermodule defines */

#define SMFONT          /* SmartFont? */
#define NOMORESIZEBOX   /* The CUA spec has changed for Win30 and
                           we no longer have a special size box in
                           the lower-right corner of the Write window */
#define NEWFONTENUM     /* So many problems have come up that I'm
                           revamping a large part of the font enumeration
                           code and it'll be marked by this.  Among others:
                           -- removed font filtering based on aspect ratio,
                           -- don't disallow fonts not in ANSI_CHARSET, etc.
                        ..pault */
#define SYSENDMARK      /* This enables code for putting the end mark
                           in the system font -- previously Kanji only */
#ifndef NEWFONTENUM
 #define INEFFLOCKDOWN
#endif

#undef  MSDOS
#undef  M_I86MM
#undef  M_I86

#ifndef SAND
#define REG1 register
#define REG2 register
#endif /* not SAND */

#define true	1
#define false	0
#define fTrue	true
#define fFalse	false

#ifdef SAND
/*  already defined in windows.h */
#define NULL	0
#endif /* SAND */

#define LNULL	0L

#define bNil	(-1)
#define iNil	(-1)
#define valNil	(-1)

#define cchINT	(sizeof (int))

#define BStructMember( s, field )  ((unsigned)&(((struct s *)(0))->field))


#define hOverflow	(-1)

#define ivalMax 	24
#define mrgNil		(-32766)

#define cchMaxSz	350
typedef long typeCP;
typedef long typeFC;
typedef unsigned typePN;
typedef unsigned typeTS;		/* TS = time stamp */

#ifdef CRLF
#define ccpEol	2
#else /* not CRLF */
#define ccpEol	1
#endif /* not CRLF */

#ifdef SAND
typedef char CHAR;
#else /* not SAND */
typedef unsigned char CHAR;
#endif /* not SAND */

typedef CHAR *PCH;
typedef CHAR far *LPCH;
#if WINVER >= 0x300
typedef CHAR huge *HPCH;    /* this is a far but C generates extra code
                               to make sure segment arithmetic is done
                               correctly, esp. important in protect mode.
                               added for handling >64k clipboard text.
                               apologies re apparently odd hungarian ..pault */
#endif

#ifdef SAND
/* ifdef out because typedef unsigned char BYTE in windows.h */
#define BYTE unsigned char
#endif /* SAND */

#define VAL	int
#define MD	int
#define BOOL	int
#define IDFLD	int
#define IDSTR	int
#define IDPMT	int
#define CC	int

#ifdef WIN30
/* DialogBox has been fixed so it automatically brings up the hourglass! */

#ifdef DBCS /* was in KKBUGFIX */
 // [yutakan:05/17/91] 'c' can be null at initialize.
#define OurDialogBox(a,b,c,d) DialogBox(a,b,((c==(HWND)NULL)?hParentWw:c),d)
#else
#define OurDialogBox(a,b,c,d) DialogBox(a,b,c,d)
#endif	/* DBCS */

#endif

/* bltsz: copy only up to terminator, inclusive
   4/20/89 NOTE: using CchCopySz kills previously returned value of a psz! */
#define bltsz(pFrom, pTo) CchCopySz((pFrom), (pTo))

/* bltszx: far version of above */
#define bltszx(lpFrom, lpTo) \
        bltbx((LPCH) (lpFrom), (LPCH) (lpTo), IchIndexLp((LPCH) (lpFrom), '\0')+1)

/* bltszLimit: added 4/20/89 to assure safe copying of strings which just 
   might not have fit the terminating zero within their buffer space ..pt */
#define bltszLimit(pFrom, pTo, cchMax) \
        bltbyte((pFrom), (pTo), min(cchMax, CchSz(pFrom)))

/* Extra-verbose diagnostic debugging output... */

#ifdef DIAG
#define Diag(s) s
#else
#define Diag(s)
#endif

#define cwVal	(1)

#define CwFromCch(cch)		(((cch) + sizeof (int) - 1) / sizeof (int))
#define FNoHeap(h)		((int)(h) == hOverflow)
#define iabs(w) 		((w) < 0 ? (-(w)) : (w))
#define low(ch) 		((ch) & 0377)
#define walign(pb)		{if ((unsigned)(pb) & 1) \
				  (*((unsigned *)&(pb)))++;}
#define FtcFromPchp(pchp)	(((pchp)->ftcXtra << 6) | (pchp)->ftc)
#define WFromCh(ch)		((ch) - '0')

#ifndef OURHEAP
#define FreezeHp()		LocalFreeze(0)
#define MeltHp()		LocalMelt(0)
#else
#ifdef DEBUG
#define FreezeHp()		{ extern int cHpFreeze; ++cHpFreeze; }
#define MeltHp()		{ extern int cHpFreeze; --cHpFreeze; }
#else /* not DEBUG */
#define FreezeHp()
#define MeltHp()
#endif /* not DEBUG */
#endif


#define HideSel()

typeCP CpMacText(), CpFirstFtn(), CpRefFromFtn(), CpFromDlTc(),
	CpBeginLine(), CpInsertFtn(), CpRSearchSz(),
	CpLimSty(), CpFirstSty(), CpGetCache(), CpHintCache(),
	CpEdge(), CpMax(), CpMin();

typeFC FcParaFirst(), FcParaLim(), FcWScratch(), FcNewSect();
typeFC (**HgfcCollect())[];
CHAR (**HszCreate())[];


#ifndef OURHEAP
#define FreeH(h)		((FNoHeap(h) || ((int)h == 0)) ? NULL : LocalFree((HANDLE)h))
#endif

#ifdef DEBUG
#define Assert(f)		_Assert(__FILE__, __LINE__, f)
#define panic() 		Assert(false)
extern _Assert(PCH pch, int line, BOOL f);
#else /* not DEBUG */
#define Assert(f)
#endif /* DEBUG */

#define cbReserve  (1024) /* reserved in our local heap */
			  /* for windows to create dialog boxes */

/* The flag KINTL is used to share some code between the international
   and the kanji Write. */

#ifdef INTL
#define KINTL
#endif

extern void Error(IDPMT idpmt);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\obj.c ===
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*
    Some comments on how the Obj subsystem for handling OLE objects
    is herein implemented.

        Written (2.14.92) by v-dougk (Doug Kent)

    Metafile and bitmaps have always been described in the Write
    file format (and in memory) by a PICINFOX structure.  For OLE
    objects the PICINFOX structure is replaced by the OBJPICINFO
    structure of the same size.

    OBJPICINFO has a field (lpObjInfo) which is a pointer to another
    structure (OBJINFO) which is globally allocated. This structure contains
    info about the object which doesn't need to be stored in the file 
    with the object data.

    The object data as obtained from OleSaveToStream() is stored in the
    Write file format immediately following the OBJPICINFO structure.
    Object data is not actually written to the file until the user
    does a File.Save.  For a newly-created object, the OBJPICINFO structure
    is the only data saved until that point.  If the object is an
    unfinished one from an Insert.Object operation, then not even the
    OBJPICINFO structure is saved.  In that case the object is solely
    represented by the OBJINFO structure until an OLE_CHANGED or OLE_SAVED
    is received. Then an OBJPICINFO structure is saved to the file.

    The OBJINFO structures are allocated for all objects when the file
    is opened.  This involves writing new OBJPICINFO data to the doc
    (with the new lpObjInfo values) on open.  This makes the doc dirty,
    but we reset the doc dirty flag to make it undirty.

    The lpObjInfo pointers are passed to the OLE create functions for the
    lpClient value.  This is a crucial aspect of the implementation as
    the CallBack function passes back this pointer, allowing us to identify
    the object, and query and set its state without having to access
    the file on disk.  As I was not aware of the importance (or existence)
    of this feature until late, it was patched in.  It is not perfectly
    implemented and could use some polishing.

    As much as I tried to seamlessly integrate objects into the existing
    Write architecture, there have been glitches:

    1)  Writing into the doc as the visible page is being drawn
        (See ObjLoadObjectInDoc() in DisplayGraphics() in picture.c)
        tends to mess things up.  The drawing code (namely
        UpdateWw(), expects certain state variables (like the
        pedls and the pwwds) to be constant during a single call
        to UpdateWw().  Writing into the doc alters those variables.
        Workaround uses vfInvalid in ObjSetPicInfo().
    2)  Write does not expect data to be entered other than in data
        currently being displayed on the screen, whereas we
        frequently operate on objects all over the doc (ObjEnumInDoc()).
        Workaround is to use ObjCachePara() instead of CachePara().
    3)  Asynchronicity wreaks havoc on Write.  Since every action
        in Write is affected by the current state, if an action
        occurs out of normal sequence, i.e., occurs in an improper
        state, then blamo big trouble.  When events happen
        recursively state variables cannot be restored without a
        state 'Pushing and Popping' mechanism.

        This is especially true for 'cp' variables.  cp's are pointers
        into the document and global cp state variables are ubiguitous.
        Global cp variables include the selection and undo variables
        mentioned above, plus many others.  See ObjPopParms() and
        ObjPushParms().

        While waiting for an object to release (see WMsgLoop()) we
        stub out WM_PAINT message responses using the nBlocking variable.
        Between document opening and closing we set the doc fDisplayable
        flag to FALSE.  NOTE: we ought to do something like this in
        IDPromptBoxSz() -- many of the asynchronicity problems occur
        when calling MessageBox() (which yields).

        Hopefully OLE 2.0 will implement an OleBlockClient() mechanism.


    Notes on Asynchronicity:  Ole calls that require communication with the
    server may be asynchronous.  The following rules apply:

    1)  Only one asynchronous call at a time may be made for a given object.
    2)  The OleCreate* calls must complete before some synchronous
        calls such as OleGetData().
    3)  All asynchronous activity must be complete before calling
        OleRevokeClientDoc.

    Asynchronous calls return OLE_WAIT_FOR_RELEASE.  You don't know
    that an asynchronous call has completed until the CallBack function
    receives an OLE_RELEASE message for that object. If you ignore this
    and issue an offending call for the object, the call will
    return OLE_BUSY.

    We deal with these rules by calling OleQueryReleaseStatus to
    determine whether an object is busy before making any Ole call
    (see ObjWaitForObject()). If the object is busy then we spin until the
    object is not busy.  After 6 seconds we put up a msg box which, depending
    on the flags we set, may allow the user to stop waiting and cancel the
    operation (see notes in fnObjWait()).

    Note that the OleCreate calls can fail in 3 different ways that aren't 
    documented (not at this point anyway).

    1)  The call returns error immediately.  In this case you mustn't depend
        on the returned lpObject to be NULL.  If it is not NULL, ignore
        it -- it needn't be deleted.

    2)  The call returns OLE_WAIT_FOR_RELEASE and eventually you get an
        OLE_RELEASE and OleQueryReleaseError() is != OLE_OK.  In
        this case you gotta delete the lpObject that was returned by
        the original call.

    3)  The call completes, but you receive OLE_CLOSED on the object
        without receiving OLE_CHANGED.  This indicates that for some
        reason the native data could not be obtained from the server.
        The object must be deleted in this case.  Write currently
        handles this properly for Insert.Object (OleCreate), but not
        for other cases (OleCreateFromFile,...).

    The Links dialog should be optimized so that it doesn't require that all 
    links be loaded at once.  The Printing process could use the same
    optimization.

    Cutting, copying and pasting works as follows.  Any object that exists
    in docScrap (where clipboard contents are stored) must be a unique
    object.  Thus when we copy we clone any objects in the selection.
    When we cut we needn't clone since the objects have been deleted
    from the document.  When we paste we clone.

    Deleted objects and cut objects that get purged from docScrap (and
    therefore become effectively deleted), are not actually deleted right
    away.  These objects get shovelled into docUndo for access by the
    Undo function.  Even when the objects get purged from docUndo
    (by another undoable operation), they are still not deleted.  These
    objects never finally get deleted until ObjCollectGarbage() is
    called.  This function is called on a timer about every 5 minutes.
    It enumerates all documents and deletes any objects not found.

    The reason for not deleting objects right away is that it would've
    hurt performance to check the contents of docUndo and docScrap
    every time they change.  It also would've been a nasty programming job
    since those change points are not localized physically or logically.
*/

#include "windows.h"
#include "mw.h"
#include "winddefs.h"
#include "obj.h"
#include "menudefs.h"
#include "cmddefs.h"
#include "str.h"
#include "objreg.h"
#include "docdefs.h"
#include "editdefs.h"
#include "propdefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#include <shellapi.h>
#include <stdlib.h>

extern struct FCB (**hpfnfcb)[];
HANDLE hlpObjInfo = NULL;       // array of allocated ObjInfos
LPLPOBJINFO lplpObjInfo = NULL; // array of allocated ObjInfos
static  BOOL        bSavedDoc=FALSE;
static  BOOL        bDontFix=FALSE;
int                 vcObjects=0;  // count in doc. Note limit of 32K!!!
BOOL                fOleEnabled=FALSE;
BOOL                bKillMe=FALSE;
OLECLIENTVTBL       clientTbl = {NULL};
OLESTREAMVTBL       streamTbl;
//LPOLECLIENT         lpclient = NULL;
LPOLESTREAM         lpStream = NULL;
OLECLIPFORMAT       vcfLink = 0;
OLECLIPFORMAT       vcfOwnerLink = 0;
OLECLIPFORMAT       vcfNative = 0;
int                 cOleWait = 0;
HWND                hwndWait=NULL;
BOOL                vbObjLinkOnly;
int           vObjVerb;
OBJECTTYPE          votObjSelType;
ATOM                aNewName=NULL;
ATOM                aOldName=NULL;
LHCLIENTDOC         lhClientDoc=NULL;
BOOL                bLinkProps=FALSE;
FARPROC             lpfnLinkProps=NULL;
FARPROC             lpfnInvalidLink=NULL;
FARPROC             lpfnInsertNew=NULL;
FARPROC             lpfnWaitForObject=NULL;
FARPROC             lpfnPasteSpecial=NULL;
static BOOL WMsgLoop ( BOOL fExitOnIdle, BOOL fIgnoreInput, BOOL bOK2Cancel, LPOLEOBJECT lpObject);
BOOL ObjFreeAllObjInfos();
static BOOL ObjUpdateAllOpenObjects(void);

int nBlocking=0; // block WM_PAINTS if > 0
static  int        nWaitingForObject=0; // in ObjWaitForObject()
int nGarbageTime=0;

extern struct UAB       vuab;
extern  HCURSOR     vhcIBeam;
extern  HCURSOR     vhcHourGlass;
extern int          docUndo;
extern struct PAP      vpapAbs;
extern struct DOD (**hpdocdod)[];
extern struct WWD       rgwwd[];
extern BOOL ferror;
extern int vfDeactByOtherApp;
extern HCURSOR      vhcArrow;
extern HANDLE hStdTargetDevice;
extern typeCP cpMinCur,cpMacCur;

BOOL fPropsError=FALSE;
static  HANDLE      hobjStream = NULL;
char        szOPropMenuStr[21];
char        szPPropMenuStr[21];
int   ObjPlayEdit=OLEVERB_PRIMARY;

int FAR PASCAL CallBack(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);

/****************************************************************/
/******************** STARTUP/SHUTDOWN **************************/
/****************************************************************/
BOOL ObjInit(HANDLE hInstance)
{
    int bRetval=TRUE;

    vcfLink      = RegisterClipboardFormat("ObjectLink");
    vcfNative    = RegisterClipboardFormat("Native");
    vcfOwnerLink = RegisterClipboardFormat("OwnerLink");

    if ((clientTbl.CallBack = MakeProcInstance(CallBack, hInstance)) == NULL)
        goto error;

    if ((hobjStream = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof(OLESTREAM))) == NULL)
        goto error;

    ObjSetTargetDevice(FALSE);

    if((lpStream = (LPOLESTREAM)(GlobalLock(hobjStream))) == NULL)
        goto error;
    else
    {
        lpStream->lpstbl = (LPOLESTREAMVTBL)&streamTbl;
        lpStream->lpstbl->Get       =  MakeProcInstance( (FARPROC)BufReadStream, hInstance );
        lpStream->lpstbl->Put       =  MakeProcInstance( (FARPROC)BufWriteStream, hInstance);
        //lpStream->lpstbl->Seek      =  MakeProcInstance( (FARPROC)BufPosStream, hInstance);
    }

    /* Initialize the registration database */
    RegInit(hINSTANCE);

    /* commdlg stuff */
    OfnInit(hInstance);

    /* dragdrop */
    DragAcceptFiles(hMAINWINDOW,TRUE);

    if ((hlpObjInfo = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, sizeof(LPOBJINFO))) == NULL)
        goto error;

    if ((lplpObjInfo = (LPLPOBJINFO)GlobalLock(hlpObjInfo)) == NULL)
        goto error;

    if (LoadString(hInstance, IDSTRMenuVerb, szOPropMenuStr, sizeof(szOPropMenuStr)) == NULL)
        goto error;

    if (LoadString(hInstance, IDSTRMenuVerbP, szPPropMenuStr, sizeof(szPPropMenuStr)) == NULL)
        goto error;

#if !defined(SMALL_OLE_UI)
    lpfnLinkProps   = MakeProcInstance(fnProperties, hInstance);
#endif
    lpfnInvalidLink = MakeProcInstance(fnInvalidLink, hInstance);
    lpfnInsertNew   = MakeProcInstance(fnInsertNew, hInstance);
    lpfnWaitForObject = MakeProcInstance(fnObjWait, hInstance);
    lpfnPasteSpecial = MakeProcInstance(fnPasteSpecial, hInstance);

    goto end;

    error:
    bRetval = FALSE;
    ObjShutDown();

    end:
    return bRetval;
}

void ObjShutDown(void)
{
    extern HANDLE vhMenu;

#ifdef KKBUGFIX
//if we close write.exe when write.exe is iconic. GetSubMenu() return NULL
    if (vhMenu) {
		HMENU	hsMenu;
        hsMenu = GetSubMenu(vhMenu,EDIT);
		if(hsMenu)
	        DeleteMenu(hsMenu, EDITMENUPOS, MF_BYPOSITION);
	}
#else
    if (vhMenu)
        DeleteMenu(GetSubMenu(vhMenu,EDIT), EDITMENUPOS, MF_BYPOSITION);
#endif

    if (hobjStream)
    {
        if (lpStream)
            if (lpStream->lpstbl)
            {
                if (lpStream->lpstbl->Get)
                    FreeProcInstance((FARPROC)(lpStream->lpstbl->Get));
                if (lpStream->lpstbl->Put)
                    FreeProcInstance((FARPROC)(lpStream->lpstbl->Put));
            }

        GlobalUnlock(hobjStream);
        if (lpStream)
            GlobalFree(hobjStream);
    }

    if (hStdTargetDevice)
        GlobalFree(hStdTargetDevice);

    if (clientTbl.CallBack)
        FreeProcInstance(clientTbl.CallBack);

    if (lpfnLinkProps)
        FreeProcInstance(lpfnLinkProps);
    if (lpfnInvalidLink)
        FreeProcInstance(lpfnInvalidLink);
    if (lpfnInsertNew)
        FreeProcInstance(lpfnInsertNew);
    if (lpfnWaitForObject)
        FreeProcInstance(lpfnWaitForObject);
    if (lpfnPasteSpecial)
        FreeProcInstance(lpfnPasteSpecial);

    RegTerm();

    /* dragdrop */
    DragAcceptFiles(hMAINWINDOW,FALSE);

    /* make sure all OInfo structures are freed */
    ObjFreeAllObjInfos();

    if (hlpObjInfo)
        GlobalFree(hlpObjInfo);
}

#if 0
BOOL ObjFreeObjInfo(OBJPICINFO *pPicInfo)
/* return whether an error */
{
    LPLPOBJINFO lplpObjTmp;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return FALSE;

    /* find slot in lplpObjInfo and NULL it out */
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
        if (*lplpObjTmp == lpOBJ_QUERY_INFO(pPicInfo))
        {
            lpOBJ_QUERY_INFO(pPicInfo) = NULL;

            return ObjDeleteObjInfo(*lplpObjTmp);
        }

    Assert(0); // make sure we found it
    return TRUE;
}
#endif

BOOL ObjUpdateFromObjInfo(OBJPICINFO *pPicInfo)
/* update picinfo from objinfo */
{
    char *pdumb;
    szOBJNAME szObjName;
    LPOBJINFO lpObjInfo = lpOBJ_QUERY_INFO(pPicInfo);

    if (lpObjInfo == NULL)
        return TRUE;

    /* we won't do data size, that'll get set in SaveObjectToDoc */

    /* object name */
    if (lpObjInfo->aObjName)
    {
        GetAtomName(lpObjInfo->aObjName,szObjName,sizeof(szObjName));
        pPicInfo->dwObjNum = strtoul(szObjName,&pdumb,16);
    }

    /* object type */
    pPicInfo->objectType = lpObjInfo->objectType;

    return FALSE;
}

BOOL ObjUpdateFromPicInfo(OBJPICINFO *pPicInfo,szOBJNAME szObjName)
/* update objinfo from picInfo, return szObjName */
{
    char *pdumb;
    LPOBJINFO lpObjInfo = lpOBJ_QUERY_INFO(pPicInfo);
    szOBJNAME szTmp;

    if (lpObjInfo == NULL)
        return TRUE;

    /* object name */
    wsprintf(szTmp, "%lx", dwOBJ_QUERY_OBJECT_NUM(pPicInfo));
    lpObjInfo->aObjName = AddAtom(szTmp);

    if (szObjName)
        lstrcpy(szObjName,szTmp);

    /* object type */
     lpObjInfo->objectType = pPicInfo->objectType;

    return FALSE;
}

BOOL ObjFreeObjInfoWithObject(LPOLEOBJECT lpObject)
/**
    Given lpObject, find lpObjInfo for that object and free the ObjInfo.
    Return whether an error.
    This deletes objects if not already deleted.
  **/
{
    LPLPOBJINFO lplpObjTmp;

    /* find slot in lplpObjInfo, free it and NULL it out */
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        if ((*lplpObjTmp)->lpobject == lpObject)
            return ObjDeleteObjInfo(*lplpObjTmp);
    }

#ifdef DEBUG
    OutputDebugString("No OInfo for object\n\r");
#endif
    return TRUE;
}

BOOL ObjDeleteObjInfo(LPOBJINFO lpOInfo)
{
    WORD wSegment;
    HANDLE hInfo;
    LPLPOBJINFO lplpObjTmp;

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Nulling objinfo slot.\n\r");
#endif

    /* find slot in lplpObjInfo, free it and NULL it out */
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        if (*lplpObjTmp == lpOInfo)
            break;
    }

    if (lplpObjTmp == NULL) // hmmm, shouldn't happen
    {
        Assert(0);
        return NULL;
    }

    if ((*lplpObjTmp)->aName)
        DeleteAtom((*lplpObjTmp)->aName);
    if ((*lplpObjTmp)->aObjName)
        DeleteAtom((*lplpObjTmp)->aObjName);
    wSegment = HIWORD(((DWORD)*lplpObjTmp));

    *lplpObjTmp = NULL;

    hInfo = GlobalHandle(wSegment) & 0xFFFFL;
    return (BOOL)GlobalFree(hInfo);
}

LPOBJINFO ObjGetObjInfo(szOBJNAME szObjName)
/* allocate objinfo, return szObjName if !NULL */
{
    HANDLE hObjInfo=NULL;
    DWORD dwCount,dwCountSave;
    LPLPOBJINFO lplpObjTmp;
    LPOBJINFO lpObjInfoNew=NULL;

    if (lplpObjInfo == NULL)
        return NULL;

    if ((hObjInfo = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, sizeof(OBJINFO))) == NULL)
    {
        /* gotta recover better here !!! (7.5.91) v-dougk */
        Error(IDPMTCantRunM);
        return NULL;
    }

    if ((lpObjInfoNew = (LPOBJINFO)GlobalLock(hObjInfo)) == NULL)
    {
        /* gotta recover better here !!! (7.5.91) v-dougk */
        Error(IDPMTCantRunM);
        GlobalFree(hObjInfo);
        return NULL;
    }

    /* now add to lplpObjInfo array */
    dwCount = dwCountSave = GlobalSize(hlpObjInfo) / sizeof(LPLPOBJINFO);

    /* find if any NULL slots */
    for (lplpObjTmp = lplpObjInfo; dwCount ; --dwCount, ++lplpObjTmp)
        if (*lplpObjTmp == NULL)
            break;

    if (dwCount) // then found a NULL slot
    {
#ifdef DEBUG
        OutputDebugString( (LPSTR) "Adding objinfo to empty slot.\n\r");
#endif
        *lplpObjTmp = lpObjInfoNew;
    }
    else // gotta reallocate
    {
        ++dwCountSave;
        if ((hlpObjInfo = GlobalRealloc(hlpObjInfo,dwCountSave * sizeof(LPLPOBJINFO),GMEM_MOVEABLE|GMEM_ZEROINIT)) == NULL)
        {
            /* gotta recover better here !!! (7.5.91) v-dougk */
            GlobalFree(hObjInfo);
            lplpObjInfo = NULL;
            Error(IDPMTCantRunM);
            return NULL;
        }
        if ((lplpObjInfo = (LPLPOBJINFO)GlobalLock(hlpObjInfo)) == NULL)
        {
            /* gotta recover better here !!! (7.5.91) v-dougk */
            GlobalFree(hObjInfo);
            Error(IDPMTCantRunM);
            return NULL;
        }

#ifdef DEBUG
        OutputDebugString( (LPSTR) "Adding objinfo to new slot.\n\r");
#endif
        /* put new gal in last slot */
        lplpObjInfo[dwCountSave-1] = lpObjInfoNew;
    }

    if (szObjName)
        /* make object's unique name */
        ObjMakeObjectName(lpObjInfoNew, szObjName);
    else
        lpObjInfoNew->aObjName = NULL;

    /* this is a requirement of the OLECLIENT structure */
    lpObjInfoNew->lpvtbl = (LPOLECLIENTVTBL)&clientTbl;

    return lpObjInfoNew;
}

BOOL ObjAllocObjInfo(OBJPICINFO *pPicInfo, typeCP cpParaStart, OBJECTTYPE ot, BOOL bInitPicinfo, szOBJNAME szObjName)
/* return whether an error */
{
    if (lpOBJ_QUERY_INFO(pPicInfo) = ObjGetObjInfo(NULL))
    {
        //cpOBJ_QUERY_WHERE(pPicInfo) = cpParaStart;

        if (bInitPicinfo)
        /* new object, make a new szObjName, use passed-in ot */
        {
            /* get new values and put into ObjInfo */
            if (szObjName)
                ObjMakeObjectName(lpOBJ_QUERY_INFO(pPicInfo), szObjName);

            lpOBJ_QUERY_INFO(pPicInfo)->objectType = ot;

            /* this'll take values from ObjInfo and put into PicInfo */
            return GimmeNewPicinfo(pPicInfo,lpOBJ_QUERY_INFO(pPicInfo));
        }
        else // picInfo already has values.  Put 'em into ObjInfo
        {
            ObjUpdateFromPicInfo(pPicInfo,szObjName);
            return FALSE;
        }
    }
    else
        return TRUE;

}


BOOL ObjCloneObjInfo(OBJPICINFO *pPicInfo, typeCP cpParaStart, szOBJNAME szObjName)
/* clone pPicInfo->lpObjInfo */
{
    if (ObjCopyObjInfo(lpOBJ_QUERY_INFO(pPicInfo),
                      &lpOBJ_QUERY_INFO(pPicInfo),
                      szObjName))
            return TRUE;

    return FALSE;
}

BOOL ObjCopyObjInfo(LPOBJINFO lpOldObjInfo,
                         LPLPOBJINFO lplpNewObjInfo,
                         szOBJNAME szObjName)
/* lpobject field is NULL'd!  Atoms are cloned, new unique object name */
{
    char szTmp[180];

    if (lplpObjInfo == NULL)
        return TRUE;

    if ((*lplpNewObjInfo = ObjGetObjInfo(NULL)) == NULL)
        return TRUE;

    /* copy old stuff over to new */
    /* note new will inherit old lpclone if there is one */
    **lplpNewObjInfo = *lpOldObjInfo;

    (*lplpNewObjInfo)->lpobject = NULL;

    /* clone the utility (class or whatever) name */
    if (lpOldObjInfo->aName)
    {
        GetAtomName(lpOldObjInfo->aName,szTmp,sizeof(szTmp));
        (*lplpNewObjInfo)->aName = AddAtom(szTmp);
    }

    /* make a new ObjName if requested */
    if (szObjName)
        /* make object's unique name */
        ObjMakeObjectName(*lplpNewObjInfo, szObjName);
    else
        (*lplpNewObjInfo)->aObjName = NULL;

    return FALSE;
}

BOOL ObjFreeAllObjInfos()
/**
    Return whether an error.
  **/
{
    WORD wSegment;
    HANDLE hInfo;
    DWORD dwCount;
    LPLPOBJINFO lplpObjTmp;

    if (lplpObjInfo == NULL)
        return FALSE;

    /* find slot in lplpObjInfo, free it and NULL it out */
    dwCount = GlobalSize(hlpObjInfo) / sizeof(LPLPOBJINFO);
    for (lplpObjTmp = lplpObjInfo; dwCount ; --dwCount, ++lplpObjTmp)
    {
        if (*lplpObjTmp)
        {
#ifdef DEBUG
            OutputDebugString( (LPSTR) "Nulling objinfo slot (from object).\n\r");
#endif
            /** Delete info about this object.  This assumes picinfo will not
                be reused unless via file.open. **/
            if ((*lplpObjTmp)->aName)
                DeleteAtom((*lplpObjTmp)->aName);
            if ((*lplpObjTmp)->aObjName)
                DeleteAtom((*lplpObjTmp)->aObjName);
            wSegment = HIWORD(((DWORD)*lplpObjTmp));
            *lplpObjTmp = NULL;
            hInfo = GlobalHandle(wSegment) & 0xFFFF;
            GlobalFree(hInfo);
        }
    }
    return FALSE;
}

LPLPOBJINFO EnumObjInfos(LPLPOBJINFO lplpObjInfoPrev)
{
    LPLPOBJINFO lplpOIMax;

    if (lplpObjInfo == NULL)
        return NULL;

    if (lplpObjInfoPrev == NULL) // starting out
        lplpObjInfoPrev = lplpObjInfo;
    else
        ++lplpObjInfoPrev;

    lplpOIMax = (LPLPOBJINFO)((LPSTR)lplpObjInfo + GlobalSize(hlpObjInfo));

    for ( ; lplpObjInfoPrev < lplpOIMax ; ++lplpObjInfoPrev)
    {
        if (*lplpObjInfoPrev == NULL)
            continue;
        else
            return lplpObjInfoPrev;
    }
    return NULL;
}


void ObjCollectGarbage()
{
    LPLPOBJINFO lplpObjTmp;
    int nObjCount=0,doc;

    if (nBlocking)
        return;

    StartLongOp();

#ifdef DEBUG
    OutputDebugString("Collecting Garbage...\n\r");
#endif

    ObjPushParms(docCur);

    /* mark all as not in doc */
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        ++nObjCount;
        (*lplpObjTmp)->fInDoc = FALSE;
    }

    if (nObjCount == 0)
        goto end;

    /* mark in doc if in */
    /* go through all the docs */
    for (doc = 0; doc < docMac; doc++)
    {
        OBJPICINFO picInfo;
        typeCP cpPicInfo;

        if ((doc != docNil) && (**hpdocdod)[doc].hpctb)
        for (cpPicInfo = cpNil;
            ObjPicEnumInRange(&picInfo,doc,cp0,CpMacText(doc),&cpPicInfo);
            )
            {
                if (lpOBJ_QUERY_INFO(&picInfo) == NULL)
                    continue;

                fOBJ_INDOC(&picInfo) = TRUE;
            }
    }


    /* if not in doc delete */
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        if (!(*lplpObjTmp)->fInDoc)
            ObjDeleteObject(*lplpObjTmp,TRUE);
    }

    end:

    /* 'til next time... */
    nGarbageTime=0;

    ObjPopParms(TRUE);

    EndLongOp(vhcArrow);
}

/****************************************************************/
/********************** OLE DOCUMENT FUNCTIONS ******************/
/****************************************************************/
BOOL ObjClosingDoc(int docOld,LPSTR szNewDocName)
/**
    Clone objects in docScrap from docOld into szNewDocName.
    Release all objects in docOld.
    Return whether an error occurred.  Error indicates to caller that
        a new document cannot be opened.  No error indicates to caller
        that a new document *must* be reopened via ObjOpenedDoc() (because
        all lpObjInfos have been deleted).
    If szNewDocName is NULL then don't make a new doc. 
    Important point to remember is that for objects whose data has never
        been saved, there is no recovery from release/delete in an error
        condition.  There is no state to which we can recover in an
        error condition.  This function should not be allowed to exit
        on the basis of a busy object.
 **/
{
    char szTitle[120];
    BOOL bRetval=FALSE;
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    extern int              vfScrapIsPic;
    extern int              docScrap;
    extern int              vfOwnClipboard;
    extern CHAR szUntitled[];
    LPOBJINFO lpObjInfo;
    LPOLEOBJECT lpObject;
    LHCLIENTDOC lhNewClientDoc=NULL;
    OLESTATUS olestat;
    LPLPOBJINFO lplpObjTmp;

    if (!lhClientDoc)
        return FALSE;

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Closing Doc\n\r");
#endif

    /* ensure all async ops are complete */
    if (FinishAllAsyncs(TRUE))
    {
        UPDATE_INVALID();
        return TRUE;
    }

    ++nBlocking; // inhibit repaints

    /* drag drop */
    DragAcceptFiles(hDOCWINDOW,FALSE);

    if (szNewDocName)
    /* then we'll be opening another doc soon, so plan ahead */
    {
        if (!szNewDocName[0])
            lstrcpy((LPSTR)szTitle,(LPSTR)szUntitled);
        else
            lstrcpy((LPSTR)szTitle,szNewDocName);

        if (ObjError(OleRegisterClientDoc(szDOCCLASS,szTitle,0L,&lhNewClientDoc)))
        {
            lhNewClientDoc = NULL; // just in case OLE flatlined
            goto error;
        }

        /**
            Clone any objects from docScrap into new doc.  Since this
            requires knowing the name of the new doc you
            would think it should go into ObjOpeningDoc, but it can't.
            You have to do it *before* releasing the objects below!
            (Because OleEnumObjects keys off of the lhClientDoc).
        **/
        ObjCloneScrapToNewDoc(lhNewClientDoc);

        /* ensure all async ops are complete */
        if (FinishAllAsyncs(FALSE))
            goto error;
    }


    /* release objects in docOld (assume not busy) */
    if ((**hpdocdod)[docOld].fFormatted)
    {
        /* objects are being released/deleted, don't allow display */
        (**hpdocdod)[docOld].fDisplayable = FALSE;

        for (cpPicInfo = cpNil;
            ObjPicEnumInRange(&picInfo,docOld,cp0,CpMacText(docOld),&cpPicInfo);
            )
        {
            lpObjInfo=lpOBJ_QUERY_INFO(&picInfo);

            if (lpObjInfo == NULL)
                continue;

            if (lpObjInfo->lpobject == NULL)
                continue;

    #ifdef DEBUG
            OutputDebugString( (LPSTR) "Releasing object\n\r");
    #endif

            switch (olestat = OleRelease(lpObjInfo->lpobject))
            {
                case OLE_OK:
                    lpObjInfo->lpobject = NULL;
                break;
                case OLE_WAIT_FOR_RELEASE:
                    lpObjInfo->fCompleteAsync = TRUE;
                    /* No cancel allowed! */
                    if (ObjWaitForObject(lpObjInfo,FALSE))
                        goto error;
                    else
                        lpObjInfo->lpobject = NULL;
                break;
            }
        }
    }

    if (FinishAllAsyncs(FALSE)) // necessary?
        goto error;

    /* delete remaining objects in lhClientDoc (assume not busy) */
    lpObject=NULL;
    do
    {
        lpObject=NULL;
        OleEnumObjects(lhClientDoc,&lpObject);
        if (lpObject)
        {
            lpObjInfo = GetObjInfo(lpObject);
            switch (olestat = OleDelete(lpObject))
            {
                case OLE_OK:
                    if (lpObjInfo)
                        lpObjInfo->lpobject = NULL;
                break;
                case OLE_WAIT_FOR_RELEASE:
                    if (lpObjInfo)
                    {
                        lpObjInfo->fCompleteAsync = TRUE;
                        /* no cancel allowed! */
                        if (ObjWaitForObject(lpObjInfo,FALSE))
                            goto error;
                        else
                            lpObjInfo->lpobject = NULL;
                    }
                    else
                        FinishUp();
                break;
                default:
                    ObjError(olestat);
                    goto error;
            }
        }
    }
    while (lpObject);

    /* say goodbye to old doc if there was one */
    if (!bSavedDoc)
    {
        ObjRevertedDoc();
        bSavedDoc=FALSE;
    }

#ifdef DEBUG
    OutputDebugString("Revoking doc\n\r");
#endif

    if (ObjError(OleRevokeClientDoc(lhClientDoc)))
        goto error;

    lhClientDoc = lhNewClientDoc;

    /**
        Delete all the lpObjInfos having NULL lpobjects (non-NULLs
        belong to docScrap).  Make sure that ObjOpenedDoc is
        called if this doc is reopened.  This is the point of no return.
     **/
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
        if ((*lplpObjTmp)->lpobject == NULL)
            ObjDeleteObjInfo(*lplpObjTmp);

    goto end;

    error:
    bRetval = TRUE;

    if (lhNewClientDoc)
    {
        OleRevokeClientDoc(lhNewClientDoc);
        /**
            If any objects are in the scrap, they must be made to belong to
            lhClientDoc, or be deleted.
        **/
        ObjCloneScrapToNewDoc(lhClientDoc);
    }

    end:

    --nBlocking; // reenable repaints
    UPDATE_INVALID();  // let WM_PAINTS get through now that we're no longer blocking

    return bRetval;
}

BOOL ObjOpenedDoc(int doc)
/*
    Return whether error that precludes continuing with opening this doc.
    If an error, then a new doc *must* be opened via ObjOpenedDoc().  We
        will clean this doc up to closed state if couldn't open it (ie,
        delete all objects and lpObjInfos).
*/
{
    BOOL bRetval=FALSE,bLinkError=FALSE;
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    BOOL bPrompted=FALSE;
    char szMsg[cchMaxSz];
    extern CHAR szUntitled[];

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Opened Doc\n\r");
#endif

    /* prevent display until done updating */
    ++nBlocking;

    StartLongOp();

    /* start collection timer all over */
    nGarbageTime=0;

    /* in case contains any picInfos left over from previous doc */
    ClobberDoc(docUndo,docNil,cp0,cp0);

    /* drag drop */
    DragAcceptFiles(hDOCWINDOW,TRUE);

    if (!lhClientDoc)
        if (ObjError(OleRegisterClientDoc(szDOCCLASS,szUntitled,0L,&lhClientDoc)))
            goto error;

    /* Do this first because much code assumes every picInfo has an
       lpObjInfo associated with it */
    if ((**hpdocdod)[doc].fFormatted)
    {
        for (cpPicInfo = cpNil;
            ObjPicEnumInRange(&picInfo,doc,cp0,CpMacText(doc),&cpPicInfo);
            )
        {
            if (ObjAllocObjInfo(&picInfo,cpPicInfo,picInfo.objectType,FALSE,NULL))
                goto error; // this is a real problem condition

            /* note this makes doc dirty right off the bat, but gotta do it because
               we gotta save ObjInfo handle in doc. (8.20.91) v-dougk */
            if (ObjSetPicInfo(&picInfo, doc, cpPicInfo))
                goto error;
        }

        /* OK to display.  Any error hereafter is not fatal. */
        (**hpdocdod)[doc].fDisplayable  = TRUE;

#if !defined(SMALL_OLE_UI)

    /**** Now see if links need updating ****/
    bDontFix=TRUE;  // don't bring up change links on release error

    if ((**hpdocdod)[doc].fFormatted)
    for (cpPicInfo = cpNil;
         ObjPicEnumInRange(&picInfo,doc,cp0,CpMacText(doc),&cpPicInfo);
         )
    {
        if (otOBJ_QUERY_TYPE(&picInfo) == LINK)
        if (ObjLoadObjectInDoc(&picInfo, doc, cpPicInfo) != cp0)
        {
            OLESTATUS olestat;

            if (!bPrompted)
            {
                LoadString(hINSTANCE, IDSTRUpdateObject, szMsg, sizeof(szMsg));
                if (MessageBox(hPARENTWINDOW, (LPSTR)szMsg, (LPSTR)szAppName, MB_YESNO|MB_ICONEXCLAMATION) == IDYES)
                    bPrompted = TRUE;
                else
                    break; // no updating requested
            }

#ifdef DEBUG
            OutputDebugString( (LPSTR) "Updating link\n\r");
#endif
            if (ObjError(OleUpdate(lpOBJ_QUERY_OBJECT(&picInfo))))
            {
                bLinkError = TRUE;
                fOBJ_BADLINK(&picInfo) = TRUE; // in case didn't get release, gotta set
                ferror = FALSE; // to reenable error messages
            }
        }
        else /* if load object failed, then give up */
        {
            bLinkError = FALSE; /*  Don't put up Links dialog */
            goto end;           /*  Not fatal, though they need to reopen doc
                                    after freeing memory */
        }
    }
    bDontFix=FALSE;
#endif
    }
    else /* OK to display. */
        (**hpdocdod)[doc].fDisplayable  = TRUE;

    goto end;

    error:
    bRetval = TRUE;

    end:

    if (bLinkError)
    /* fix 'em */
    {
        if (DialogBox(hINSTANCE, "DTINVALIDLINKS",
                    hPARENTWINDOW, lpfnInvalidLink) == IDD_CHANGE)
            fnObjProperties();
    }

    --nBlocking;
    EndLongOp(vhcArrow);

    UPDATE_INVALID();  // let WM_PAINTS get through now that we're no longer blocking

    return bRetval;
}


BOOL ObjSavingDoc(BOOL bFormatted)
/* return whether there was an error */
{
    /* drag drop */
    DragAcceptFiles(hDOCWINDOW,FALSE);

    /* update any other objects */

    vcObjects = 0;
    if (bFormatted)
        vcObjects = ObjEnumInDoc(docCur,ObjSaveObjectToDoc);

    return (vcObjects < 0); // return whether error
}

void ObjSavedDoc(void)
{
#ifdef DEBUG
    OutputDebugString( (LPSTR) "Saved Doc\n\r");
#endif

    if (lhClientDoc)
        ObjError(OleSavedClientDoc(lhClientDoc));
    bSavedDoc=TRUE;

    /* drag drop */
    DragAcceptFiles(hDOCWINDOW,TRUE);
}

static BOOL ObjUpdateAllOpenObjects(void)
/* Update all open embedded objects. Return whether successful.
   Called on file.close.  */
{
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    BOOL bRetval=TRUE;

    StartLongOp();
    for (cpPicInfo = cpNil;
        ObjPicEnumInRange(&picInfo,docCur,cp0,CpMacText(docCur),&cpPicInfo);
        )
    {
        if (((otOBJ_QUERY_TYPE(&picInfo) == NONE) ||
            (otOBJ_QUERY_TYPE(&picInfo) == EMBEDDED)) &&
                (OleQueryOpen(lpOBJ_QUERY_OBJECT(&picInfo)) == OLE_OK))
        {
            fnObjUpdate(lpOBJ_QUERY_INFO(&picInfo));
        }
    }

    end:

    /*  To make sure we've gotten all messages relevant to calling 
        ObjObjectHasChanged() and setting doc dirty. */
    if (FinishAllAsyncs(TRUE))
        bRetval = FALSE;

    EndLongOp(vhcArrow);
    UPDATE_INVALID();  // let WM_PAINTS get through now that we're no longer blocking
    return bRetval;
}


BOOL CloseUnfinishedObjects(BOOL bSaving)
/**
    Used with File.Save or File.Exit.
    Return TRUE whether should proceed with Save/Exit.
 **/
{
    char szMsg[cchMaxSz];

    if (ObjContainsOpenEmb(docCur, cp0, CpMacText(docCur),TRUE))
    {
        if (bSaving)
            LoadString(hINSTANCE, IDPMTSaveOpenEmb, szMsg, sizeof(szMsg));
        else
            LoadString(hINSTANCE, IDPMTExitOpenEmb, szMsg, sizeof(szMsg));

        switch (MessageBox(hPARENTWINDOW, (LPSTR)szMsg, (LPSTR)szAppName, MB_YESNOCANCEL))
        {
            case IDYES:
                return ObjUpdateAllOpenObjects();
            case IDNO:
            default:
                return TRUE;
            case IDCANCEL:
                return FALSE;
        }
    }
    return TRUE;
}

void ObjRenamedDoc(LPSTR szNewName)
{
    OBJPICINFO picInfo;
    typeCP cpPicInfo;

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Renamed Doc\n\r");
#endif
    if (lhClientDoc)
        ObjError(OleRenameClientDoc(lhClientDoc,szNewName));

    /* don't need to do all docs since objects can only be active in docCur */
    for (cpPicInfo = cpNil;
        ObjPicEnumInRange(&picInfo,docCur,cp0,CpMacText(docCur),&cpPicInfo);
        )
        /* ignore return value on purpose */
        ObjSetHostNameInDoc(&picInfo,docCur,cpPicInfo);
}

void ObjRevertedDoc()
{
#ifdef DEBUG
    OutputDebugString( (LPSTR) "Reverted Doc\n\r");
#endif
    if (lhClientDoc)
        ObjError(OleRevertClientDoc(lhClientDoc));
}

/****************************************************************/
/*********************** ERROR HANDLING *************************/
/****************************************************************/
BOOL FAR
ObjError(OLESTATUS olestat)
{
    register HWND hWndParent = hPARENTWINDOW;

    switch (olestat) {
        case OLE_WAIT_FOR_RELEASE:
        case OLE_OK:
            return FALSE;
    }

    ferror = FALSE; // to enable error message

    switch (olestat) {
    case OLE_ERROR_LAUNCH:
        Error(IDPMTFailedToLaunchServer);
    break;

    case OLE_ERROR_COMM:
        Error(IDPMTFailedToCommWithServer);
    break;

    case OLE_ERROR_MEMORY:
        Error(IDPMTWinFailure);
    break;

    case OLE_BUSY:
        Error(IDPMTServerBusy);
    break;

    case OLE_ERROR_FORMAT:
        Error(IDPMTFormat);
    break;

    case OLE_ERROR_DRAW:
        Error(IDPMTFailedToDraw);
    break;

    default:
#ifdef DEBUG
        ObjPrintError(olestat,FALSE);
#endif

        Error(IDPMTOLEError);
    break;
    }
    return TRUE;
}

void
ObjReleaseError(OLE_RELEASE_METHOD rm)
/*
    There's an async problem here, in that the posted message 
    that invokes this routine may be allowed through by Error() which
    isn't reentrant (or at least causes problems when called recursively).
*/
{
    register HWND hWndParent = hPARENTWINDOW;

    switch (rm) {

    case OLE_DELETE:
        Error(IDPMTFailedToDeleteObject);
    break;

    case OLE_LOADFROMSTREAM:
        Error(IDPMTFailedToReadObject);
    break;

    case OLE_LNKPASTE:
    case OLE_EMBPASTE:
        Error(IDPMTGetFromClipboardFailed);
    break;

    case OLE_ACTIVATE:
        Error(IDPMTFailedToLaunchServer);
    break;

    case OLE_UPDATE:
        Error(IDPMTFailedToUpdate);
    break;

    case OLE_CREATE:
    case OLE_CREATELINKFROMFILE:
    case OLE_CREATEFROMFILE:
        Error(IDPMTFailedToCreateObject);
    break;

    case OLE_SETUPDATEOPTIONS:
        Error(IDPMTImproperLinkOptionsError);
    break;

    default:
        Error(IDPMTOLEError);
    break;
    }
#ifdef DEBUG
        ObjPrintError(rm,TRUE);
#endif
}

#ifdef DEBUG
void ObjPrintError(WORD olestat, BOOL bRelease)
{
    #define szMsgMax       100
    char szError[szMsgMax];
    if (!bRelease)
        wsprintf(szError, "***Ole Error #%d\n\r",olestat);
    else
        wsprintf(szError, "***Ole Release Error on Method #%d\n\r",olestat);
    OutputDebugString(szError);
}
#endif

/****************************************************************/
/***************** ASYNCRONICITY HANDLING ***********************/
/****************************************************************/
int FAR PASCAL
CallBack(LPOLECLIENT lpclient,
         OLE_NOTIFICATION flags,
         LPOLEOBJECT lpObject)
{
    extern int     vdocParaCache;
    LPOBJINFO lpOInfo = (LPOBJINFO)lpclient;

    switch(flags)
    {
        case OLE_SAVED:
        case OLE_CLOSED:
        case OLE_CHANGED:
            /**
                Post a message instead of process here because we have to return from
                CallBack before making any other OLE calls.
              **/
#ifdef DEBUG
            OutputDebugString(flags == OLE_CHANGED ? "received OLE_CHANGED\n\r" :
                              flags == OLE_SAVED   ? "received OLE_SAVED\n\r"   :
                                                     "received OLE_CLOSED\n\r");
#endif
            PostMessage(hDOCWINDOW,WM_OBJUPDATE,flags,(DWORD)lpOInfo);
        break;

        case OLE_RELEASE:
        {
            OLE_RELEASE_METHOD ReleaseMethod = OleQueryReleaseMethod(lpObject);

            if (!CheckPointer((LPSTR)lpOInfo,1))
                return FALSE;

            lpOInfo->fKillMe = FALSE; // pending async is dead

            if (lpOInfo->fDeleteMe && (ReleaseMethod != OLE_DELETE))   // not dead enough
            {
                PostMessage(hDOCWINDOW,WM_OBJDELETE,1,(DWORD)lpOInfo);
                return FALSE; // error message will already have been given
            }

            if (lpOInfo->fReleaseMe && (ReleaseMethod != OLE_DELETE))  // not dead enough
            {
                PostMessage(hDOCWINDOW,WM_OBJDELETE,0,(DWORD)lpOInfo);
                return FALSE; // error message will already have been given
            }

            if (lpOInfo->fFreeMe && (ReleaseMethod == OLE_DELETE)) // on OLE_DELETE release
            {
                ObjDeleteObjInfo(lpOInfo);
                return FALSE;
            }

            if (OleQueryReleaseError(lpObject) == OLE_OK)
            {
                switch (ReleaseMethod)
                {
                    case OLE_SETUPDATEOPTIONS:
                    {
                        if (bLinkProps) // we're in Link Properties dialog
                        {
                            PostMessage(hPARENTWINDOW, WM_UPDATELB, 0, 0L);
                            PostMessage(hPARENTWINDOW, WM_COMMAND, IDD_REFRESH, (DWORD)lpOInfo);
                        }
                    }
                    break;

                    case OLE_UPDATE:
                        ObjInvalidateObj(lpObject);
                    break;

                    case OLE_DELETE: // get this for delete and release
                        lpOInfo->lpobject = NULL;
                    break;
                }
            }
            else // release error != OLE_OK
            {
#ifdef DEBUG
                PostMessage(hDOCWINDOW,WM_OBJERROR,ReleaseMethod,0L);
#endif

                switch(ReleaseMethod)
                {
                    case OLE_CREATE:
                    case OLE_CREATELINKFROMFILE:
                    case OLE_CREATEFROMFILE:
                        /*
                            OleQueryReleaseError won't help us after callback returns
                            so this is how we tell that the object wasn't created.
                        */
                        lpOInfo->fDeleteMe = TRUE;
                        // creator should ObjDeleteObject and issue error message
                    break;

                    default:
                        switch (OleQueryReleaseError(lpObject))
                        {
                            case OLE_ERROR_OPEN:
                            case OLE_ERROR_ADVISE_NATIVE:
                            case OLE_ERROR_ADVISE_PICT:
                            case OLE_ERROR_REQUEST_NATIVE:
                            case OLE_ERROR_REQUEST_PICT:
                                /**
                                    Post a message instead of process here because we have to return from
                                    CallBack before making any other OLE calls.
                                **/
                                if (lpOInfo->objectType == LINK)
                                    lpOInfo->fBadLink = TRUE;
                                if (bLinkProps)
                                    fPropsError = TRUE; // so linkprops knows there was a problem
                                else if (!bDontFix && (lpOInfo->objectType == LINK))
                                    PostMessage(hDOCWINDOW,WM_OBJBADLINK,OleQueryReleaseMethod(lpObject),(DWORD)lpObject);
                            break;
                        }
                    break;
                }
            }
        }
        break;

        case OLE_QUERY_RETRY:
        {
            Assert(CheckPointer((LPSTR)lpOInfo,1));

            if (lpOInfo->fKillMe)
            {
                lpOInfo->fKillMe = FALSE;
                return FALSE;
            }
            else if (hwndWait)
                PostMessage(hwndWait,WM_UKANKANCEL,0,0L);
            else if (nWaitingForObject == 0)
                PostMessage(hDOCWINDOW,WM_WAITFORSERVER,TRUE,(DWORD)lpOInfo);

            return TRUE;
        }
        break;

        case OLE_QUERY_PAINT:
            return TRUE;
        break;

        default:
        break;
    }
    return FALSE;
}

void ObjObjectHasChanged(int flags, LPOBJINFO lpObjInfo)
{
    typeCP cpParaStart,
           cpParaCache = vcpFirstParaCache;
    int docCache = vdocParaCache;
    OBJPICINFO picInfo;
    LPOLEOBJECT lpObject = lpObjInfo->lpobject;

    /**
    For Embeds (including InsertObject objects):
        OLE_SAVED   is sent with server File.Update
                    (set undo if not NONE)
        OLE_CHANGED is sent with server File.Save or File.Close (?)
                    with update (set undo if not NONE), or when OleSetData()
                    causes a change in the presentation of the object.
        OLE_CLOSED  is sent when doc closes in server (clear undo if set)
    For Links:
        OLE_SAVED   is sent with server File.Save (As?) if update_options
                    == update_on_save (that never happens)
        OLE_CHANGED is sent when something in the server doc changes
        OLE_CLOSED  is never sent
    **/

    Assert(lpObjInfo != NULL);

    if (lpObjInfo == NULL)
        return;

    if (lpObjInfo->objectType == NONE) // result of InsertObject
    {
        cpParaStart=lpObjInfo->cpWhere; // note only used here!

        if (flags == OLE_CLOSED) // delete object
        {
            if (lpObject) /* may already be released or deleted */
                ObjDeleteObject(lpObjInfo,TRUE);
            NoUndo();
            BringWindowToTop(hMAINWINDOW);
        }
        else
        {
            extern int              vfSeeSel;

            (**hpdocdod)[docCur].fFormatted = fTrue;

            /* insert EOL if needed */
            if (cpParaStart > cp0)
            {
                ObjCachePara(docCur, cpParaStart - 1);
                if (vcpLimParaCache != cpParaStart)
                {
                    InsertEolPap(docCur, cpParaStart, &vpapAbs);
                    cpParaStart += ccpEol;
                }
            }

            GimmeNewPicinfo(&picInfo, lpObjInfo);
            ObjCachePara(docCur,cpParaStart);
            /* this'll clear selection. */
            if (ObjSaveObjectToDoc(&picInfo,docCur,cpParaStart) == cp0)
                Error(IDPMTFailedToCreateObject);
            NoUndo();
            ObjInvalidatePict(&picInfo,cpParaStart);
            vfSeeSel = true; /* Tell    Idle() to scroll the selection into view */
            (**hpdocdod) [docCur].fDirty = TRUE;
        }
    }
    else if (ObjGetPicInfo(lpObject,docCur,&picInfo,&cpParaStart))
    {
        BOOL bSizeChanged;

        //GetPicInfo(cpParaStart,cpParaStart + cchPICINFOX, docCur, &picInfo);

        /* invalidate rect before updating size (cause invalidate
            needs to know old pic size) */
        ObjInvalidatePict(&picInfo,cpParaStart);

        bSizeChanged = ObjUpdatePicSize(&picInfo,cpParaStart);

        if ((flags == OLE_CHANGED) ||
            (flags == OLE_SAVED) && (otOBJ_QUERY_TYPE(&picInfo) == EMBEDDED))
        {
            NoUndo();
#ifdef DEBUG
            if (!fOBJ_QUERY_DIRTY_OBJECT(&picInfo))
                OutputDebugString( (LPSTR) "Marking object dirty\n\r");
#endif
            fOBJ_QUERY_DIRTY_OBJECT(&picInfo) = TRUE;
#ifdef DEBUG
            if (!(**hpdocdod) [docCur].fDirty)
                OutputDebugString( (LPSTR) "Marking doc dirty\n\r");
#endif
            (**hpdocdod) [docCur].fDirty = TRUE;
        }

        if (bSizeChanged)
            if (ObjSetPicInfo(&picInfo,docCur,cpParaStart))
                Error(IDPMTFailedToUpdate);

        if (otOBJ_QUERY_TYPE(&picInfo) == EMBEDDED)
        {
            if (flags == OLE_CLOSED)
            {
                //if (fOBJ_QUERY_DIRTY_OBJECT(&picInfo))
                    BringWindowToTop(hMAINWINDOW);
#ifdef UPDATE_UNDO
                ObjClearUpdateUndo(&picInfo,docCur,cpParaStart);
#endif
            }
#ifdef UPDATE_UNDO
            else if (flags == OLE_SAVED)
            {
                ObjSetUpdateUndo(&picInfo,docCur,cpParaStart);
                SetUndo(uacObjUpdate,docCur,cpParaStart,cp0,docNil,cp0,cp0,0);
            }
#endif
        }
    }

    ObjCachePara(docCache,cpParaCache); // reset state
}

BOOL ObjUpdatePicSize(OBJPICINFO *pPicInfo, typeCP cpParaStart)
/* returns whether size changed */
{
int xSize,ySize;
BOOL bUpdate = FALSE;

    /* object may have changed size */
    if (!FComputePictSize(pPicInfo, &xSize, &ySize ))
        Error(IDPMTFailedToUpdate);
    else
        bUpdate = (xSize != pPicInfo->dxaSize) ||
                  (ySize != pPicInfo->dyaSize);

    if (bUpdate)
    {
        int yOldSize = pPicInfo->dyaSize;

        pPicInfo->dxaSize = xSize;
        pPicInfo->dyaSize = ySize;

        if (yOldSize < pPicInfo->dyaSize)
        { /* If the picture height was increased, make sure proper EDLs are
                invalidated. */
            typeCP dcp = CpMacText(docCur) - cpParaStart + (typeCP) 1;
            ObjPushParms(docCur);
            AdjustCp(docCur, cpParaStart, dcp, dcp);  // major async problems here?
            ObjPopParms(TRUE);
        }
    }
    return bUpdate;
}

void ObjHandleBadLink(OLE_RELEASE_METHOD rm, LPOLEOBJECT lpObject)
{
    switch (rm)
    {
        case OLE_ACTIVATE:
        case OLE_UPDATE:
        {
            typeCP cpParaStart,cpParaCache = vcpFirstParaCache;
            int docCache = vdocParaCache;
            OBJPICINFO picInfo;

            /* don't need to do all docs since objects can only be active in docCur */
            if (!ObjGetPicInfo(lpObject,docCur,&picInfo,&cpParaStart))
            {
                /* maybe in scrap, just ignore */
                ObjCachePara(docCache,cpParaCache); // reset state
                return;
            }

            ObjCachePara(docCur,cpParaStart);
            if (FixInvalidLink(&picInfo,docCur,cpParaStart))
                switch (rm)
                {
                    case OLE_ACTIVATE:
                        StartLongOp();
                        ObjError(OleActivate(lpObject,
                            fOBJ_QUERY_PLAY(&picInfo),
                            TRUE,
                            TRUE,
                            hDOCWINDOW,
                            NULL));
                        EndLongOp(vhcArrow);
                    break;
                    case OLE_UPDATE:
                        StartLongOp();
                        ObjError(OleUpdate(lpObject));
                        EndLongOp(vhcArrow);
                    break;
                }
            ObjCachePara(docCache,cpParaCache); // reset state
        }
        break;
    }
}

BOOL ObjWaitForObject(LPOBJINFO lpObjInfo, BOOL bOK2Cancel)
{
    HCURSOR hCursor = NULL;
    BOOL bRetval;
    /**
        WMsgLoop allows WM_PAINT messages which wreak havoc.  Try to
        recover from the insult.
     **/
    typeCP cpParaCache = vcpFirstParaCache;
    int docCache = vdocParaCache;
    LPOLEOBJECT lpObject;

    if (lpObjInfo == NULL) // shouldn't happen
    {
        Assert(0);
        return FALSE;
    }

    /*  Since ObjPicEnumInRange returns unloaded picinfo's this is a 
        valid possibility, but we shouldn't be getting called!!! */
    Assert(lpObjInfo->lpobject != NULL);

    Assert (CheckPointer((LPSTR)lpObjInfo,1));

    lpObject = lpObjInfo->lpobject;

    if (!ObjIsValid(lpObject))
    {
        Assert (0);
        return FALSE;
    }

    hCursor = SetCursor(vhcHourGlass);
    StartLongOp();
    bRetval = WMsgLoop(TRUE,TRUE,bOK2Cancel,lpObject);
    if (hCursor)
        EndLongOp(hCursor);

    ObjCachePara(docCache,cpParaCache); // reset state

    /* problem here is that we may have been waiting for a release or delete */
    if (ObjIsValid(lpObject))
    {
        lpObjInfo->fCancelAsync = FALSE; // clear after use
        lpObjInfo->fCompleteAsync = FALSE; // clear after use
        lpObjInfo->fCanKillAsync = FALSE;
    }

    UPDATE_INVALID();  // let WM_PAINTS get through now that we're no longer blocking
    return bRetval;
}


#if 0
BOOL ObjObjectSync(LPOBJINFO lpObjInfo, OLESTATUS (FAR PASCAL *lpProc)(LPOLEOBJECT lpObject), BOOL bOK2Cancel)
/*
    This makes an asynchronous call synchronous.  lpProc must have only
    lpObject as argument.  This will block if operation cannot be completed
    or cancelled.
*/
{
    /* caller has set or not set CancelAsync flag for object */
    if (ObjWaitForObject(lpObjInfo,bOK2Cancel))
        return TRUE;

    switch((*lpProc)(lpObjInfo->lpobject))
    {
            case OLE_WAIT_FOR_RELEASE:
            {
                /* cancel button should only be enabled if this operation
                   can be cancelled. */
                lpObjInfo->fCancelAsync = FALSE;  // don't cancel automatically
                lpObjInfo->fCompleteAsync = TRUE; // this op must complete or be cancelled

                if (ObjWaitForObject(lpObjInfo,TRUE))
                    return TRUE;

                /*  the trouble with this is that lpObject may now be released
                    (and thus invalid):
                    return ObjError(OleQueryReleaseError(lpObjInfo->lpobject));
                */

                return FALSE;
            }
            case OLE_OK:
                return FALSE;
            default:
                return TRUE;
    }
}
#endif

#define WM_NCMOUSEFIRST 0x00A0
#define WM_NCMOUSELAST  0x00A9

static BOOL WMsgLoop
(
BOOL fExitOnIdle,       // if true, return as soon as no messages to process
                        // (not used, assumed FALSE).
BOOL fIgnoreInput,      // if true, ignore keyboard and mouse input
BOOL bOK2Cancel,
LPOLEOBJECT lpObject
)
    {
    MSG     msg;
    DWORD GetCurrentTime();
    DWORD cTime=GetCurrentTime();
    BOOL bRetval=FALSE,bBeeped=FALSE;
    int fParentEnable;
    extern int flashID;

#ifdef DEBUG
    if (OleQueryReleaseStatus(lpObject) == OLE_BUSY)
        OutputDebugString("waiting for object\n\r");
#endif

    ++nBlocking;

    ferror = FALSE;

    ++nWaitingForObject;

    StartLongOp();

    while (OleQueryReleaseStatus(lpObject) == OLE_BUSY)
    {
        /* put up wait dialog after 6 seconds */
        if ((GetCurrentTime() - cTime) > 6000L)
        {
            // bring up wait dialog.
            if (!hwndWait)
            {
                if (vfDeactByOtherApp)
                {
                    if (!bBeeped) // flash until we're activated
                    {
                        fParentEnable = IsWindowEnabled(hMAINWINDOW);
                        //MessageBeep(0);
                        bBeeped = TRUE;

                        if (!fParentEnable)
                            EnableWindow(hMAINWINDOW, TRUE); /* make sure parent window is enabled
                                                            to let the user click in it */
                        flashID = 1234; // arbitrary ID
                        SetTimer(hMAINWINDOW, flashID, 500, (FARPROC)NULL);
                        // this'll cause flashing, see mmw.c
                    }
                }
                else // Write is active app
                {
                    if (bBeeped)
                    /* then we've regained the activation */
                    {
                        if (!fParentEnable)
                            EnableWindow(hMAINWINDOW, FALSE); /* reset */
                        bBeeped = FALSE;
                        KillTimer(hMAINWINDOW, flashID);
                        flashID = 0;
                        FlashWindow(hMAINWINDOW, FALSE);
                    }

                    if (OleQueryReleaseStatus(lpObject) == OLE_BUSY)
                    {
                        /* this'll set hwndWait */
                        vbCancelOK = bOK2Cancel;
                        bRetval = DialogBoxParam(hINSTANCE, (LPSTR)"DTWAIT", hPARENTWINDOW, lpfnWaitForObject, (DWORD)lpObject);
                       break;
                    }
                }
            }
            else
            {
                bRetval = TRUE;
                break;
            }
        }

        if (!PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
            {
            /* No messages, do Idle processing */
            /* this is where we'd use ExitOnIdle */
            }
        else
        {
            /* The following code will put the app into a
            sleeping state if the fIgnoreInput flag is set
            to TRUE.  It will allow Quit, DDE, and any
            other non input messages to be passed along
            and dispatched but will prohibit the user from
            interacting with the app.  The user can
            Alt-(sh)Tab, Alt-(sh)Esc, and Ctrl-Esc away from the
            app as well as use any Windows hot keys to
            activate other apps */

            /* if we pass this test, then the message may be one we can ignore */
            if ((fIgnoreInput) &&
                (!(vfDeactByOtherApp &&
                  (msg.message == WM_NCLBUTTONDOWN))) &&
                ((msg.message >= WM_NCMOUSEFIRST &&
                 msg.message <= WM_NCMOUSELAST) ||
                (msg.message >= WM_KEYFIRST  &&
                 msg.message <= WM_KEYLAST) ||
                (msg.message >= WM_MOUSEFIRST &&
                 msg.message <= WM_MOUSELAST)))
                {
                static BOOL fAltCtl = FALSE;

                if (msg.message != WM_SYSKEYDOWN)
                    continue; // ignore

                if (msg.wParam == VK_MENU)
                    fAltCtl = TRUE;
                else if (fAltCtl && msg.wParam != VK_SHIFT)
                    {
                    fAltCtl = FALSE;
                    if (msg.wParam != VK_TAB && msg.wParam != VK_ESCAPE)
                        continue; // ignore
                    }
                }


            if ((vfDeactByOtherApp &&
                    (msg.message == WM_NCLBUTTONDOWN)))
                BringWindowToTop(hwndWait ? hwndWait : msg.hwnd);
            else
            {
                TranslateMessage ((LPMSG) &msg);
                DispatchMessage ((LPMSG) &msg);
            }
        }
    }

    Assert(hwndWait == NULL);

    if (bBeeped) // then beeped but done before received activation
    {
        if (!fParentEnable)
            EnableWindow(hMAINWINDOW, FALSE); /* reset */
        KillTimer(hMAINWINDOW, flashID);
        flashID = 0;
        FlashWindow(hMAINWINDOW, FALSE);
    }

    --nBlocking;
    --nWaitingForObject;

    EndLongOp(vhcArrow);

    Assert(nBlocking >= 0);
    return bRetval;
}

void FinishUp(void)
/* let all pending messages through and return */
/*
    !!! Note that we may accumulate WM_PAINTS.  Caller is responsible for
    calling UPDATE_INVALID() to catch up on them!!!
*/
{
    MSG     msg;

    /* now allow through all messages posted from callback */
    ++nBlocking; // block WM_PAINTS
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        TranslateMessage ((LPMSG) &msg);
        DispatchMessage ((LPMSG) &msg);
    }
    --nBlocking;

    return FALSE;
}

BOOL FinishAllAsyncs(BOOL bAllowCancel)
/*
    !!! Note that we may accumulate WM_PAINTS.  Caller is responsible for
    calling UPDATE_INVALID() to catch up on them!!!  (see FinishUp())
*/
{
    LPOLEOBJECT lpObject;
    LPOBJINFO lpObjInfo;

    /* first make sure all async ops are complete */
    lpObject=NULL;
    do
    {
        OleEnumObjects(lhClientDoc,&lpObject);
        if (lpObject)
        {
            lpObjInfo = GetObjInfo(lpObject);

            if (lpObjInfo)
            {
                /* cancel takes us outa here.  Pending asyncs will block us. */
                if (ObjWaitForObject(lpObjInfo,bAllowCancel))
                    return TRUE;
            }
            else // shouldn't happen, but don't assume for now
            {
                Assert(0);
                if (WMsgLoop(TRUE,TRUE,bAllowCancel,lpObject))
                    return TRUE;
            }

            if (!ObjIsValid(lpObject)) // then got deleted
                lpObject = NULL; // start over
        }
    }
    while (lpObject);

    /* let all messages posted from callback get through */
    FinishUp();

    return FALSE;
}

static typeCP       cpPPSave;
static int          docPPSave;
static struct SEL   selPPSave;
static int nPushed=FALSE;

ObjPushParms(int doc)
/*  Save selCur and Cache info to reset with Pop after writing to
    doc.  Assumes aren't changing size of doc.  
*/
{
    if (nPushed) // prevent recursion
    {
#ifdef DEBUG
        OutputDebugString("Unmatched ObjPushParms\n\r");
#endif
        return;
    }
    ++nPushed;

    cpPPSave = vcpFirstParaCache;
    docPPSave = vdocParaCache;

    selPPSave = selCur;
    Select(selCur.cpFirst,selCur.cpFirst); // this caches para
//T-HIROYN raid #3538
#ifdef KKBUGFIX
	if(docPPSave == docNil)
		docPPSave = vdocParaCache;
#endif
    CachePara(docPPSave,cpPPSave);
}

ObjPopParms(BOOL bCache)
{
    typeCP cpMac = (**hpdocdod) [docPPSave].cpMac;

    if (!nPushed) // unmatched push/pops
    {
#ifdef DEBUG
        OutputDebugString("Unmatched ObjPopParms\n\r");
#endif
        return;
    }
    --nPushed;

    if (docPPSave == docCur)
    {
        if (selPPSave.cpLim > cpMac)
            selPPSave.cpLim = cpMac;
        if (cpPPSave > cpMac)
            cpPPSave = cpMac;
    }

    Select(selPPSave.cpFirst,selPPSave.cpLim); // this caches para
    if (bCache)
        CachePara(docPPSave,cpPPSave);
    //(**hpdocdod) [docPPSave].fDirty = TRUE; /* why? */
}


void ObjCachePara(int doc, typeCP cp)
{
    typeCP cpMac = (**hpdocdod) [doc].cpMac;
    typeCP cpMacCurSave = cpMacCur,
           cpMinCurSave = cpMinCur;

    if (doc == docNil)
        return;

    /**
        cpMinCur and cpMacCur are the min and mac value for whatever is
        currently docCur.  Their values will be different for the header,
        footer and regular docs.  OBJ code doesn't distinguish.  Async
        operations can happen on any and all cps at once.  Gotta set so
        CachePara wil understand that.
    **/
    cpMinCur = cp0;
    cpMacCur = cpMac;

    if (cp >= cpMac)
        cp = cpMac;
    else if (cp < cp0)
        cp = cp0;

    CachePara(doc,cp);

    cpMinCur = cpMinCurSave;
    cpMacCur = cpMacCurSave;
}

#if 0
void ObjWriteFixup(int doc, BOOL bStart, typeCP cpStart)
/* note this must not be called recursively!!  It is for use where size of
   doc may change between bStart=TRUE and bStart=FALSE. */
{
    static typeCP dcp,cpLim;
    static struct SEL selSave;
    typeCP cpMac;

    /* reset selection accounting for change in size if any */
    if (bStart)
    {
        cpLim = CpMacText(doc);
        selSave=selCur;
        if ((selCur.cpFirst != selCur.cpLim) && (doc == docCur))
            Select(selCur.cpFirst,selCur.cpFirst);  /* Take down sel before we mess with cp's */
        /* select undoes cache */
        ObjCachePara(doc,cpStart);
    }
    else
    {
        cpMac =  CpMacText(doc);

        dcp = cpMac-cpLim; /* change in size of doc */

        if (doc == docCur)
        {
            if (selSave.cpFirst <= cpStart)
            {
                if ((selSave.cpLim) > cpStart)
                    selSave.cpLim += dcp;
            }
            else if (selSave.cpFirst > cpStart)
                /* selection proceeds object */
            {
                selSave.cpFirst += dcp;
                selSave.cpLim += dcp;
            }

            if (selSave.cpFirst > cpMac)
                selSave.cpFirst = selSave.cpLim = cpMac;
            else if (selSave.cpLim > cpMac)
                selSave.cpLim = cpMac;

            /* this'll cache first para in selection */
            if (selSave.cpFirst != selSave.cpLim)
                Select(selSave.cpFirst,selSave.cpLim);
        }

        ObjCachePara(doc,cpStart);

        /* Fixup Undo pointers */
        if (vuab.doc == docCur)
        {
            if (doc == docUndo) /* operating on docUndo, cpStart is irrelevant */
                vuab.dcp += dcp;
            else if (doc == docCur)
            {
                if (vuab.cp <= cpStart)
                {
                    /* undo encloses object */
                    if ((vuab.cp+vuab.dcp) > cpStart)
                        vuab.dcp += dcp;
                }
                else if (vuab.cp > cpStart)
                    /* undo proceeds object */
                    vuab.cp += dcp;
            }
        }

        if (vuab.doc2 == docCur)
        {
            if (doc == docUndo) /* operating on docUndo, cpStart is irrelevant */
                vuab.dcp += dcp;
            else if (doc == docCur)
            {
                if (vuab.cp2 <= cpStart)
                {
                    /* undo encloses object */
                    if ((vuab.cp2+vuab.dcp2) > cpStart)
                        vuab.dcp2 += dcp;
                }
                else if (vuab.cp2 > cpStart)
                    /* undo proceeds object */
                    vuab.cp2 += dcp;
            }
        }
    }
}
#endif

void ObjWriteClearState(int doc)
/** Call this before writing asynchronously to doc.  In practise, this is
    being called in synchronous times as well, so higher level code
    must take care of resetting selection and undo after writing to doc.
**/
{
    typeCP cpSave=vcpFirstParaCache;
    int docSave=vdocParaCache;

    if (doc == docCur)
    {
        Select(selCur.cpFirst,selCur.cpFirst);  /* Take down sel before we mess with cp's */
        /* select undoes cache */
        ObjCachePara(docSave,cpSave);
    }
    //NoUndo(); /** Higher level code must SetUndo *after* calling **/
}

LPOBJINFO GetObjInfo(LPOLEOBJECT lpObject)
{
    LPLPOBJINFO lplpObjTmp;

    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
        if ((*lplpObjTmp)->lpobject == lpObject)
            return *lplpObjTmp;

    Assert(0);
    return NULL;
}


BOOL ObjIsValid(LPOLEOBJECT lpobj)
{
    if (!CheckPointer((LPSTR)lpobj, 1))
        return FALSE;

    if (OleQueryReleaseStatus(lpobj) == OLE_ERROR_OBJECT)
        return FALSE;

#if 0 // can't depend on this in future version of OLE
    if (!(((LPRAWOBJECT)lpobj)->objId[0] == 'L' && ((LPRAWOBJECT)lpobj)->objId[1] == 'E'))
        return FALSE;
#endif

    return TRUE;
}

#if 0  // these should work, but not using them now
LPOBJINFO ObjGetClientInfo(LPOLEOBJECT lpobj)
{
    LPOBJINFO lpObjInfo;

    if (!CheckPointer((LPSTR)lpobj, 1))
    {
        Assert(0);
        return NULL;
    }

#if 0 // can't depend on this in future versions of OLE
    if (!CheckPointer((LPSTR)(((LPRAWOBJECT)lpobj)->lpclient), 1))
    {
        Assert(0);
        return NULL;
    }
    else
        return (LPOBJINFO)(((LPRAWOBJECT)lpobj)->lpclient);
#endif

    if (*(lpObject->lpvtbl->ObjectLong)(lpObject,OF_GET,(LPLONG)&lpObjInfo) == OLE_OK)
        return lpClient;
    else
        return NULL;
}

BOOL ObjSetClientInfo(LPOBJINFO lpObjInfoNew, LPOLEOBJECT lpobj)
/* return if error */
{
    if (!CheckPointer((LPSTR)lpobj, 0))
    {
        Assert(0);
        return TRUE;
    }

    if (*(lpObject->lpvtbl->ObjectLong)(lpObject,OF_SET,(LPLONG)&lpObjInfoNew) == OLE_OK)
        return FALSE;
    else
    {
        Assert(0);
        return TRUE;
    }
}
#endif

#if 0
int ObjMarkInDoc(int doc)
/* mark as 'InDoc' all objects located in docScrap, all others are marked
   as not 'InDoc'.  Return count of objects in doc. */
{
    LPLPOBJINFO lplpObjTmp;
    int nObjCount=0,doc;
    OBJPICINFO picInfo;
    typeCP cpPicInfo;

    /* mark all as not in doc */
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        ++nObjCount;
        (*lplpObjTmp)->fInDoc = FALSE;
    }

    if (nObjCount == 0)
        return 0;

    for (cpPicInfo = cpNil,nObjCount=0;
        ObjPicEnumInRange(&picInfo,doc,cp0,CpMacText(doc),&cpPicInfo);
        )
        {
            if (lpOBJ_QUERY_INFO(&picInfo))
            {
                fOBJ_INDOC(&picInfo) = TRUE;
                ++nObjCount;
            }
        }
    return nObjCount;
}

BOOL AllocObjInfos()
/* return whether error */
{
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    int doc;

    for (doc = 0; doc < docMac; doc++)
    {
        if ((doc != docNil) && (**hpdocdod)[doc].hpctb)
        {
            for (cpPicInfo = cpNil;
                ObjPicEnumInRange(&picInfo,doc,cp0,CpMacText(doc),&cpPicInfo);
                )
            {
                if (picInfo.lpObjInfo)
                    continue;

                if (ObjAllocObjInfo(&picInfo,cpPicInfo,picInfo.objectType,FALSE,NULL))
                    return TRUE;

                /* note this makes doc dirty right off the bat, but gotta do it because
                    we gotta save ObjInfo handle in doc. (8.20.91) v-dougk */
                ObjWriteFixup(doc,TRUE,cpPicInfo);
                if (ObjSetPicInfo(&picInfo, doc, cpPicInfo))
                    return TRUE;
                ObjWriteFixup(doc,FALSE,cpPicInfo);
            }
        }
    }
}
#endif

BOOL ObjCloneScrapToNewDoc(LHCLIENTDOC lhNewClientDoc)
/* return whether an error */
{
    szOBJNAME szObjName;
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    int nCount=0;
    extern int docScrap;



    for (cpPicInfo = cpNil;
        ObjPicEnumInRange(&picInfo,docScrap,cp0,CpMacText(docScrap),&cpPicInfo);
    )
    {
        szOBJNAME szObjName;
        LPOBJINFO   lpObjInfo = lpOBJ_QUERY_INFO(&picInfo);
        LPOLEOBJECT lpObject  = lpObjInfo->lpobject;
        OBJPICINFO NewPicInfo = picInfo;

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Cloning object in scrap\n\r");
#endif

        if (ObjCloneObjInfo(&NewPicInfo, cpPicInfo, szObjName))
            goto error;

        if (ObjError(OleClone(lpObject,
            (LPOLECLIENT)lpOBJ_QUERY_INFO(&NewPicInfo),
            lhNewClientDoc,szObjName,
            &lpOBJ_QUERY_OBJECT(&NewPicInfo))))
            goto error;

        if (ObjSetPicInfo(&NewPicInfo, docScrap, cpPicInfo))
            goto error;

        ObjDeleteObject(lpObjInfo,TRUE);

        ++nCount;
    }

    goto end;

    error:

    /* cleanup after failure by deleting docScrap objects */
    for (cpPicInfo = cpNil;
        ObjPicEnumInRange(&picInfo,docScrap,cp0,CpMacText(docScrap),&cpPicInfo);
    )
    {
        ObjDeleteObject(lpOBJ_QUERY_INFO(&picInfo),TRUE);
    }

    ClobberDoc(docScrap,docNil,cp0,cp0);

    nCount = -1;

    end:

    if (nCount) // docScrap has changed
        NoUndo();

    return nCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\objpsp.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#include "windows.h"
#include "mw.h"
#include "winddefs.h"
#include "obj.h"
#include "objreg.h"
#include "str.h"

static BOOL GetClipObjectInfo(LPSTR szClass, LPSTR szItem);
BOOL QueryPasteFromClip(OLEOPT_RENDER lpRender, OLECLIPFORMAT lpFormat);
BOOL QueryLinkFromClip(OLEOPT_RENDER lpRender, OLECLIPFORMAT lpFormat);
static int FillListFormat(HWND hwndList, BOOL bObjAvail);
static WORD GetFormatClip(int i);
static BOOL IsFormatAvailable(WORD cfFormat);

WORD cfObjPasteSpecial;
BOOL vObjPasteLinkSpecial;
WORD rgchFormats[5];
int  irgchFormats = 0;

void fnObjPasteSpecial(void)
{
    if (OurDialogBox(hINSTANCE, "PasteSpecial", hMAINWINDOW, lpfnPasteSpecial))
        fnPasteEdit();
    cfObjPasteSpecial = 0; // clear it for next time
    vbObjLinkOnly =  vObjPasteLinkSpecial = FALSE;
}

int FAR PASCAL fnPasteSpecial(HWND hDlg, unsigned message, WORD wParam, LONG lParam)
{
    extern HWND vhWndMsgBoxParent;
    static BOOL bLinkAvail,bObjAvail;
    extern BOOL ferror;

    switch (message)
        {
        case WM_INITDIALOG:
        {
            char szClassName[KEYNAMESIZE];
            char szItemName[CBPATHMAX];
            int nWhichToSelect;

            HWND hwndList = GetDlgItem(hDlg,IDD_LISTBOX);

            szClassName[0] = szItemName[0] = '\0';
            irgchFormats = 0; //always start with 0
            vObjPasteLinkSpecial = vbObjLinkOnly = FALSE;

            bObjAvail  = OleQueryCreateFromClip(PROTOCOL, olerender_draw, 0) == OLE_OK;
            bLinkAvail = OleQueryLinkFromClip(PROTOCOL, olerender_draw, 0) == OLE_OK;

            if (bObjAvail || bLinkAvail)
            {
                GetClipObjectInfo(szClassName, szItemName);
                SetWindowText(GetDlgItem(hDlg,IDD_CLIPOWNER), szClassName);
                SetWindowText(GetDlgItem(hDlg,IDD_ITEM), szItemName);
            }
            else
                ShowWindow(GetDlgItem(hDlg,IDD_SOURCE), SW_HIDE);

            if (bObjAvail || bLinkAvail)
            /* then there's an object on clipboard */
            {
                char szListItem[CBMESSAGEMAX]; // hope this is big enough!
                char szTmp[CBMESSAGEMAX];

                LoadString(hINSTANCE, IDSTRObject, szTmp, sizeof(szTmp));
                wsprintf(szListItem,"%s %s",(LPSTR)szClassName,(LPSTR)szTmp);
                SendMessage(hwndList, LB_INSERTSTRING, irgchFormats, (DWORD)(LPSTR)szListItem);
                if (bObjAvail)
                    rgchFormats[irgchFormats++] = vcfOwnerLink;
                else
                    rgchFormats[irgchFormats++] = vcfLink;
            }

            nWhichToSelect = FillListFormat(hwndList,bObjAvail || bLinkAvail);

            /* select what Write would normally take */
            SendMessage(hwndList, LB_SETCURSEL, nWhichToSelect, 0L);

            EnableWindow(GetDlgItem(hDlg, IDD_PASTELINK), bLinkAvail &&
                         rgchFormats[nWhichToSelect] != CF_TEXT);

            if (!bObjAvail && bLinkAvail)
            /* then we've got the object format in the list box, but don't want to
               enable paste if its selected */
                EnableWindow(GetDlgItem(hDlg, IDD_PASTE), nWhichToSelect != 0);

            return TRUE;
        }

        case WM_ACTIVATE:
            if (wParam)
                vhWndMsgBoxParent = hDlg;
        break;

        case WM_SYSCOMMAND:
            switch(wParam & 0xFFF0)
            {
                case SC_CLOSE:
                    OurEndDialog(hDlg, FALSE);
                break;
            }
        break;

        case WM_COMMAND:
            switch (wParam)
                {
                case IDD_LISTBOX:
                    switch (HIWORD(lParam))
                    {
                        case LBN_DBLCLK:
                            SendMessage(hDlg,WM_COMMAND,IDD_PASTE,0L);
                        return TRUE;
                        case LBN_SELCHANGE:
                            if (!bObjAvail && bLinkAvail)
                            /*  then we've got the object format in the list box, but don't want to
                                enable paste if its selected */
                                EnableWindow(GetDlgItem(hDlg, IDD_PASTE),
                                    SendMessage(LOWORD(lParam), LB_GETCURSEL, 0, 0L) != 0);

                            EnableWindow(GetDlgItem(hDlg, IDD_PASTELINK),
                                bLinkAvail &&
                                  (GetFormatClip(SendMessage(LOWORD(lParam), LB_GETCURSEL, 0, 0L)) != CF_TEXT));
                        return TRUE;
                    }
                 break;


                case IDD_PASTE:
                case IDD_PASTELINK:
                {
                    int i;

                    if (LB_ERR == (i = (WORD)SendMessage(GetDlgItem(hDlg, IDD_LISTBOX), LB_GETCURSEL, 0, 0L)))
                        break;

                    cfObjPasteSpecial = GetFormatClip(i);

                    if (!IsFormatAvailable(cfObjPasteSpecial))
                    /* somebody changed clip contents while in dialog */
                    {
                        Error(IDPMTFormat);
                        ferror=FALSE; // reenable error messages
                        SendMessage(GetDlgItem(hDlg,IDD_LISTBOX), LB_RESETCONTENT, 0, 0L);
                        SendMessage(hDlg, WM_INITDIALOG, 0, 0L);
                        break;
                    }


                    if (wParam == IDD_PASTELINK)
                        if (i > 0)
                            vObjPasteLinkSpecial = TRUE;
                        else
                            vbObjLinkOnly = TRUE;

                    OurEndDialog(hDlg, TRUE);
                }
                break;

                case IDCANCEL:
                    OurEndDialog(hDlg, FALSE);
                break;
            }
            break;

    }
    return FALSE;
}

static int FillListFormat(HWND hwndList, BOOL bObjAvail)
    /* fill hwndList with all the formats available on clipboard */
    /* return index of which format Write would normally take */
{
   WORD cfFormat = NULL;
   int nDefFormat= -1;
   char szFormat[cchMaxSz];
   BOOL bFoundDefault = FALSE;

   OpenClipboard(hDOCWINDOW);

   /** priority order:
        if (bObjAvail)
            If text comes before native, then text is default.
            else object is default
        else no object available
            if text is there it is the default,
            else default is first come first server of bitmap, metafile or DIB
    **/

   while (cfFormat = EnumClipboardFormats(cfFormat))
    switch(cfFormat)
    {
      case CF_BITMAP:
         LoadString(hINSTANCE, IDSTRBitmap, szFormat, sizeof(szFormat));
         SendMessage(hwndList, LB_INSERTSTRING, irgchFormats, (DWORD)(LPSTR)szFormat);

         if (!bObjAvail)
            if (!bFoundDefault)
            {
                nDefFormat = irgchFormats;
                bFoundDefault = TRUE;
            }

         rgchFormats[irgchFormats++] = cfFormat;
         break;

      case CF_METAFILEPICT:
         LoadString(hINSTANCE, IDSTRPicture, szFormat, sizeof(szFormat));
         SendMessage(hwndList, LB_INSERTSTRING, irgchFormats, (DWORD)(LPSTR)szFormat);

         if (!bObjAvail)
            if (!bFoundDefault)
            {
                nDefFormat = irgchFormats;
                bFoundDefault = TRUE;
            }

         rgchFormats[irgchFormats++] = cfFormat;
         break;

      case CF_DIB:
         LoadString(hINSTANCE, IDSTRDIB, szFormat, sizeof(szFormat));
         SendMessage(hwndList, LB_INSERTSTRING, irgchFormats, (DWORD)(LPSTR)szFormat);

         if (!bObjAvail)
            if (!bFoundDefault)
            {
                nDefFormat = irgchFormats;
                bFoundDefault = TRUE;
            }

         rgchFormats[irgchFormats++] = cfFormat;
         break;

      case CF_TEXT:
         LoadString(hINSTANCE, IDSTRText, szFormat, sizeof(szFormat));
         SendMessage(hwndList, LB_INSERTSTRING, irgchFormats, (DWORD)(LPSTR)szFormat);
         if (bObjAvail)
         {
            if (!bFoundDefault)
            /* then found text before native */
                nDefFormat = irgchFormats;
         }
         else
             nDefFormat = irgchFormats;

         rgchFormats[irgchFormats++] = cfFormat;
         bFoundDefault = TRUE;

         break;

      default:
            if (!bFoundDefault && (cfFormat == vcfNative))
            {
                bFoundDefault = TRUE;
                nDefFormat = 0;
            }
         break;
     } //end switch

   CloseClipboard();
   if (nDefFormat == -1)
        nDefFormat = 0;
   return nDefFormat;
}

static WORD GetFormatClip(int i)
{
   return rgchFormats[i];
}


static BOOL GetClipObjectInfo(LPSTR szClass, LPSTR szItem)
/* get the classname, item name for the owner of the clipboard */
/* return TRUE if error */
/* only gets ownerlink class, assumes its available */
{
    HANDLE hData=NULL;
    LPSTR lpData=NULL;
    BOOL bRetval = TRUE;
    char szFullItem[CBPATHMAX],*pch;

    OpenClipboard( hDOCWINDOW );

    if ((hData = GetClipboardData(vcfOwnerLink)) == NULL)
    if ((hData = GetClipboardData(vcfLink)) == NULL)
    {
        bRetval = TRUE;
        goto end;
    }

    if ((lpData = GlobalLock(hData)) == NULL)
        goto end;

    /**** get szClass ****/
    RegGetClassId(szClass,lpData);

    /**** get szName ****/
    while(*lpData++); // skip class key

    pch = szFullItem;

    /* first doc name */
    do
       *pch++ = *lpData;
    while(*lpData++);

    /* second item name (if there) */
    if (*lpData)
    {
        *(pch-1) = ' ';
        do
            *pch++ = *lpData;
        while(*lpData++);
    }

    /* get rid of path.  pch now points to \0 */
#ifdef DBCS //T-HIROYN 1992.07.13
    pch = AnsiPrev(szFullItem,pch);				//02/26/93 T-HIROYN
    while (pch != szFullItem) {
        if ((*(pch) == '\\') || (*(pch) == ':')) {
            pch++;
            break;
        }
        else
            pch = AnsiPrev(szFullItem,pch);
	}
    if ((*(pch) == '\\') || (*(pch) == ':'))	//02/26/93 T-HIROYN
		pch++;
#else
    --pch;
    while (pch != szFullItem)
        if ((*(pch-1) == '\\') || (*(pch-1) == ':'))
            break;
        else
            --pch;
#endif

    lstrcpy(szItem,(LPSTR)pch);

    bRetval = FALSE;

    end:
    if (lpData)
        GlobalUnlock(hData);

    CloseClipboard();

    return bRetval;
}

static BOOL IsFormatAvailable(WORD cfFormat)
{
    BOOL bRetval;

    OpenClipboard(hDOCWINDOW);

    bRetval = IsClipboardFormatAvailable(cfFormat);

    CloseClipboard();

    return bRetval;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\objreg.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/
/* olereg.h - Contains the header for registration database related calls.
 *
 * Created by Microsoft Corporation.
 */
/* Constants */
#define	CBPATHMAX	250
#define KEYNAMESIZE     300             /* Maximum registration key length */
#define	CLASSES	((LPSTR)".classes")	/* Classes root key */
#define	CFILTERMAX	20			/* Max # filters */
#define	CFILTERLEN	30			/* Max length of one filters */
#define	CBFILTERMAX	(CFILTERLEN * CFILTERMAX)	/* Max # chars/filter */
#define CBMESSAGEMAX 80

/* Function prototypes */
BOOL FAR RegCopyClassName(HWND hwndList, LPSTR lpstrClassName);
void FAR RegGetClassId(LPSTR lpstrName, LPSTR lpstrClass);
BOOL FAR RegGetClassNames(HWND hwndList);
void FAR RegInit(HANDLE hInst);
int  FAR RegMakeFilterSpec(LPSTR lpstrClass, LPSTR lpstrExt, HANDLE *hFilterSpec);
void FAR RegTerm(void);

extern char             szClassName[CBPATHMAX];


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\pictdrag.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* pictdrag.c -- Routines for Move Picture and Size Picture */

//#define NOGDICAPMASKS
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
//#define NOATOM
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOFONT
#define NOHDC
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "dispdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#include "editdefs.h"
#include "prmdefs.h"
#include "winddefs.h"
#if defined(OLE)
#include "obj.h"
#endif

extern struct DOD       (**hpdocdod)[];
extern typeCP           cpMacCur;
extern int              docCur;
extern int              wwCur;
extern struct SEL       selCur;
extern struct WWD       *pwwdCur;
extern struct WWD       rgwwd[];
extern typeCP           vcpFirstParaCache;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern struct SEP       vsepPage;
extern int              dxpLogInch;
extern int              dypLogInch;
extern int              vfPictSel;
extern int              vfPMS;
extern int              vfCancelPictMove;


#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif


STATIC NEAR ModifyPicInfoDxa( int, int, int, unsigned, unsigned, BOOL );
STATIC NEAR ModifyPicInfoDxp( int, int, int, unsigned, unsigned );
STATIC NEAR ShowPictMultipliers( void );


#define dxpPicSizeMin   dypPicSizeMin

/* Type for possible positions of the "size box" icon while
   moving/sizing a picture */
/* WARNING: fnSizePicture relies on mdIconCenterFloat == 0 */

#define mdIconCenterFloat   0       /* In Center of picture; icon may float */
#define mdIconLeft          1       /* On Left Border */
#define mdIconRight         2       /* On Right Border */
#define mdIconCenterFix     3       /* In center of picture; border moves w/icon */
#define mdIconXMask         3       /* Masks left/right */
#define mdIconBottom        4       /* On bottom border */
#define mdIconSetCursor     8       /* Force set of mouse cursor position */
#define mdIconLL            (mdIconLeft | mdIconBottom)
#define mdIconLR            (mdIconRight | mdIconBottom)


/* "PMS"  means "Picture Move or Size" */

HCURSOR vhcPMS=NULL;                /* Handle to "size box" cursor */
STATIC RECT rcPicture;              /* Rectangle containing picture */
STATIC RECT rcClip;                 /* Window clip box (may intersect above) */
STATIC int ilevelPMS;               /* Level for DC save */
STATIC RECT rcInverted;             /* Rectangle for last border drawn */
STATIC int fIsRcInverted=FALSE;     /* Whether border is on */
STATIC int dxpKeyMove=8;            /* # of pixels to move per arrow key (X) */
STATIC int dypKeyMove=4;            /* # of pixels to move per arrow key (Y) */

STATIC int dxpPicMac;               /* Rightmost edge (enforced for move only) */
STATIC int dypPicMac;               /* Max. picture bottom edge */
STATIC int fPictModified;           /* Set to TRUE if pic gets changed */

/* Special statics for resizing bitmaps with multipliers */

STATIC unsigned mxCurrent;          /* Current Multipliers while resizing */
STATIC unsigned myCurrent;
STATIC int fSizing;                 /* TRUE for sizing, FALSE for moving */
STATIC int dxpOrig;                 /* Object's original size in pixels */
STATIC int dypOrig;                 /* used as a basis for computing multipliers */

STATIC unsigned cxpPrinterPixel;         /* For scaling devices, expand the 64K */
STATIC unsigned cypPrinterPixel;         /* Limit */

int NEAR FStartPMS( int );
void NEAR EndPMS( void );
void NEAR DrawPMSFrameIcon( int, POINT );
void NEAR GetCursorClientPos( POINT * );
void NEAR SetCursorClientPos( POINT );
void NEAR InvertPMSFrame( void );
void NEAR SetupDCForPMS( void );




CmdUnscalePic()
{   /* Restore picture to the size that it originally was on import */
struct PICINFOX  picInfo;
int dxa, dya;

GetPicInfo(selCur.cpFirst, selCur.cpLim, docCur, &picInfo);
if (FComputePictSize( &picInfo.mfp, &dxa, &dya ))
    ModifyPicInfoDxa( 0, dxa, dya, mxMultByOne, myMultByOne, FALSE );
}



fnMovePicture()
{   /* Handle the "Move Picture" command in the EDIT dropdown. */
 MSG msg;
 int mdIcon=mdIconCenterFix;
 POINT pt;

 Assert( vfPictSel );

 vfCancelPictMove = FALSE;
 if (!FStartPMS(FALSE))
    return;

 GetCursorClientPos( &pt );

 while (TRUE)
 {
    /*    
        * If the main window proc was sent a kill focus message,
        * then we should cancel this move.
        */
    if (vfCancelPictMove)
        {
        fPictModified = FALSE;
        goto SkipChange;
        }

    /*
        * Otherwise, continue normal processing for a picture move.
        */

 if (!PeekMessage( (LPMSG) &msg, (HWND) NULL, 0, 0, PM_NOREMOVE ))
    {   /* No message waiting -- scroll if we're above or below window */
    mdIcon &= ~mdIconSetCursor;
    goto MoveFrame;
    }
 else
    {   /* Absorb all messages, only process: left & right arrows,
                   RETURN and ESC, mouse move & mouse down (left button) */

    GetMessage( (LPMSG) &msg, (HWND) NULL, 0, 0 );

    switch (msg.message) {
        default:
            break;
        case WM_KEYDOWN:
            mdIcon |= mdIconSetCursor;
            GetCursorClientPos( &pt );
            pt.y = rcInverted.top +
                        (unsigned)(rcInverted.bottom - rcInverted.top) / 2;
            switch (msg.wParam) {
                case VK_RETURN:
                    goto MakeChange;
                case VK_ESCAPE:
                    goto SkipChange;
                case VK_LEFT:
                    pt.x -= dxpKeyMove;
                    goto MoveFrame;
                case VK_RIGHT:
                    pt.x += dxpKeyMove;
                    goto MoveFrame;
            }
            break;
        case WM_MOUSEMOVE:
            mdIcon &= ~mdIconSetCursor;
            pt = MAKEPOINT( msg.lParam );
MoveFrame:
            DrawPMSFrameIcon( mdIcon, pt );
            break;
        case WM_LBUTTONDOWN:
            goto MakeChange;
            break;
        }
    }   /* end else */
 }  /* end while */

MakeChange:
 ModifyPicInfoDxp( rcInverted.left - xpSelBar + wwdCurrentDoc.xpMin, -1, -1,
                   -1, -1 );
SkipChange:
 EndPMS();
}




fnSizePicture()
{   /* Handle the "Size Picture" command in the EDIT dropdown. */
 MSG msg;
 int mdIcon=mdIconCenterFloat;
 POINT pt;
 int fFirstMouse=TRUE;      /* A workaround hack bug fix */


 vfCancelPictMove = FALSE;
 if (!FStartPMS(TRUE))
    return;
 ShowPictMultipliers();

 GetCursorClientPos( &pt );

 while (TRUE)
 {
 /*    
  * If the main window proc was sent a killfocus message,
  * then we should cancel this sizing.
  */
 if (vfCancelPictMove) 
    {
    fPictModified = FALSE;
    goto SkipChange;
    }

 /*
  * Otherwise, continue normal processing for a picture size.
  */
 if (!PeekMessage( (LPMSG) &msg, (HWND) NULL, 0, 0, PM_NOREMOVE ))
    {   /* No message waiting -- scroll if we're above or below window */
    mdIcon &= ~mdIconSetCursor;
    goto MoveFrame;
    }
 else
    {   /* Absorb all messages, only process: left & right arrows,
                   RETURN and ESC, mouse move & mouse down (left button) */

    GetMessage( (LPMSG) &msg, (HWND) NULL, 0, 0 );

    switch (msg.message) {
        default:
            break;
        case WM_KEYDOWN:
            GetCursorClientPos( &pt );
            mdIcon |= mdIconSetCursor;
            switch (msg.wParam) {
                case VK_RETURN:
                    goto MakeChange;
                case VK_ESCAPE:
                    goto SkipChange;
                case VK_RIGHT:
                    switch (mdIcon & mdIconXMask) {
                        default:
                            pt.x = rcInverted.right;
                            mdIcon |= mdIconRight;
                            break;
                        case mdIconRight:
                        case mdIconLeft:
                            pt.x += dxpKeyMove;
                            break;
                        }
                    goto MoveFrame;
                case VK_LEFT:
                    switch (mdIcon & mdIconXMask) {
                        default:
                            pt.x = rcInverted.left;
                            mdIcon |= mdIconRight;
                            break;
                        case mdIconRight:
                        case mdIconLeft:
                            pt.x -= dxpKeyMove;
                            break;
                        }
                    goto MoveFrame;
                case VK_UP:
                    if ( mdIcon & mdIconBottom )
                        pt.y -= dypKeyMove;
                    else
                        {
                        pt.y = rcInverted.bottom;
                        mdIcon |= mdIconBottom;
                        }
                    goto MoveFrame;
                case VK_DOWN:
                    if ( mdIcon & mdIconBottom )
                        pt.y += dypKeyMove;
                    else
                        {
                        pt.y = rcInverted.bottom;
                        mdIcon |= mdIconBottom;
                        }
                    goto MoveFrame;
            }
            break;
        case WM_MOUSEMOVE:
            mdIcon &= ~mdIconSetCursor;
            if (fFirstMouse)
                {   /* We sometimes get 1 bogus mouse message, so skip it */
                fFirstMouse = FALSE;
                break;
                }

            pt = MAKEPOINT( msg.lParam );

            /* Trap "breaking through" a border with a mouse */

            if ( !(mdIcon & mdIconXMask) )
                {   /* Haven't broken through left or right */
                if (pt.x >= rcInverted.right)
                    mdIcon |= mdIconRight;
                else if (pt.x <= rcInverted.left)
                    mdIcon |= mdIconLeft;
                }
            if ( !(mdIcon & mdIconBottom) )
                {   /* Haven't broken through bottom */
                if (pt.y >= rcInverted.bottom)
                    mdIcon |= mdIconBottom;
                }
MoveFrame:

            /* Trap border crossings */

            switch (mdIcon & mdIconXMask) {
                default:
                    break;
                case mdIconLeft:
                    if (pt.x >= rcInverted.right)
                        {   /* Moving left icon right, crossed right border */
                        mdIcon = (mdIcon & ~mdIconXMask) | mdIconRight;
                        goto WholePic;
                        }
                    break;
                case mdIconRight:
                    if (pt.x <= rcInverted.left)
                        {   /* Moving right icon left, crossed border */
                        mdIcon = (mdIcon & ~mdIconXMask) | mdIconLeft;
WholePic:
                        if (fIsRcInverted)
                            InvertPMSFrame();
                        rcInverted = rcPicture;
                        }
                    break;
                }

            DrawPMSFrameIcon( mdIcon, pt );
            break;
        case WM_LBUTTONDOWN:
            goto MakeChange;
            break;
        }
    }   /* end else */
 }   /* end while */

MakeChange:

 {
 unsigned NEAR MxRoundMx( unsigned );
    /* Round multipliers if near an even multiple */
 unsigned mx = MxRoundMx( mxCurrent );
 unsigned my = MxRoundMx( myCurrent );

    /* Assert must be true for above call to work for an my */
 Assert( mxMultByOne == myMultByOne );

 ModifyPicInfoDxp( rcInverted.left - xpSelBar + wwdCurrentDoc.xpMin,
                   rcInverted.right - rcInverted.left,
                   rcInverted.bottom - rcInverted.top,
                   mx, my );
 }

SkipChange:
 EndPMS();
}


unsigned NEAR MxRoundMx( mx )
unsigned mx;
{   /* If mx is near an "interesting" multiple, round it to be exactly that
       multiple.  Interesting multiples are:
                    1 (m=mxMultByOne), 2 (m=2 * mxMultByOne), 3 , ...
                    0.5 (m = .5 * mxMultByOne)
     This routine works for my, too, as long as mxMultByOne == myMultByOne */

    /* This means close enough to round (1 decimal place accuracy) */
#define dmxRound    (mxMultByOne / 20)

 unsigned mxRemainder;

 if (mx >= mxMultByOne - dmxRound)
    {   /* Multiplier > 1 -- look for rounding to integer multiple */
    if ((mxRemainder = mx % mxMultByOne) < dmxRound)
        mx -= mxRemainder;
    else if (mxRemainder >= mxMultByOne - dmxRound)
        mx += (mxMultByOne - mxRemainder);
    }
 else
    {   /* Multiplier < 1 -- look for multiplication by 1/2 */
    if ((mxRemainder = mx % (mxMultByOne >> 1)) < dmxRound)
        mx -= mxRemainder;
    else if (mxRemainder >= ((mxMultByOne >> 1) - dmxRound))
        mx += (mxMultByOne >> 1) - mxRemainder;
    }

 return mx;
}




int NEAR FStartPMS( fSize )
int fSize;
{               /* Initialization for Picture Move/Size */
extern HCURSOR vhcHourGlass;
extern HWND hParentWw;
extern struct SEP vsepAbs;
extern struct SEP vsepPage;
extern HDC vhDCPrinter;

 struct PICINFOX picInfo;
 struct EDL *pedl;
 RECT rc;
 HDC hdcT;
 POINT pt;

 Assert(vhDCPrinter);
 fSizing = fSize;

 UpdateWw( wwCur, FALSE );  /* Screen must be up-to-date */

    /* Set the rect that defines our display area */
 SetRect( (LPRECT) &rcClip, xpSelBar, wwdCurrentDoc.ypMin,
           wwdCurrentDoc.xpMac, wwdCurrentDoc.ypMac );

 GetPicInfo( selCur.cpFirst, selCur.cpLim, docCur, &picInfo );

 if (fSize)
    {
    if (BStructMember( PICINFOX, my ) >= picInfo.cbHeader )
        {   /* OLD file format (no multipliers), scaling not supported */
        return FALSE;
        }
    }

/* Set multiplier factor used by the printer (will be { 1, 1 } if
   the printer is not a scaling device; greater if it is.)
   This info is used for the 64K limit test of picture growth. */
     
    if (!(GetDeviceCaps( vhDCPrinter, RASTERCAPS ) & RC_BITMAP64))
    /* doesn't support > 64K bitmaps */
    {
        if (GetDeviceCaps( vhDCPrinter, RASTERCAPS ) & RC_SCALING)
        {
            POINT pt;

            pt.x = pt.y = 0;   /* Just in case */
            Escape( vhDCPrinter, GETSCALINGFACTOR, 0, (LPSTR) NULL,
                    (LPSTR) (LPPOINT) &pt );
            cxpPrinterPixel = 1 << pt.x;
            cypPrinterPixel = 1 << pt.y;
        }
        else
        {
            cxpPrinterPixel = cypPrinterPixel = 1;
        }
    }
    else
    {
        cxpPrinterPixel = cypPrinterPixel = 0xFFFF;
    }

 /* Compute picture's original (when pasted) size in
    screen pixels {dxpOrig, dypOrig}.
    These numbers are the bases for computing the multiplier. */

 switch(picInfo.mfp.mm)
 {
    case MM_BITMAP:
        GetBitmapSize( &dxpOrig, &dypOrig, &picInfo, FALSE );

        /* Compensate for effects of existing multipliers */

        dxpOrig = MultDiv( dxpOrig, mxMultByOne, picInfo.mx );
        dypOrig = MultDiv( dypOrig, myMultByOne, picInfo.my );
    break;

    default: // OLE and META
    {
    int dxa, dya;

    if (!FComputePictSize( &picInfo.mfp, &dxa, &dya ))
        return FALSE;

    dxpOrig = DxpFromDxa( dxa, FALSE );
    dypOrig = DypFromDya( dya, FALSE );
    }
    break;
 }

 if (!FGetPictPedl( &pedl ))
        /* Picture must be on the screen */
    return FALSE;
 ComputePictRect( &rcPicture, &picInfo, pedl, wwCur );
 rcInverted = rcPicture;    /* Initial grey box is the size of the picture */

 vfPMS = TRUE;      /* So ToggleSel knows not to invert the pict */
 fPictModified = FALSE;

    /* Amt to move for arrow keys is derived from size of fixed font */

 if ( ((hdcT=GetDC( hParentWw ))!=NULL) &&
      (SelectObject( hdcT, GetStockObject( ANSI_FIXED_FONT ) )!=0))
    {
    TEXTMETRIC tm;

    GetTextMetrics( hdcT, (LPTEXTMETRIC) &tm );
    ReleaseDC( hParentWw, hdcT );
    dxpKeyMove = tm.tmAveCharWidth;
    dypKeyMove = (tm.tmHeight + tm.tmExternalLeading) / 2;
    }

 SetupDCForPMS();   /* Save DC and select in a grey brush for border drawing */

    /* Assure that the "size box" mouse cursor is loaded */
 if (vhcPMS == NULL)
    {
    extern HANDLE hMmwModInstance;
    extern CHAR szPmsCur[];

    vhcPMS = LoadCursor( hMmwModInstance, (LPSTR) szPmsCur );
    }

    /* Compute maximum allowable area for picture to roam
       (relative to para left edge, picture top) */
 CacheSectPic( docCur, selCur.cpFirst );
 dxpPicMac = imax(
             DxpFromDxa( vsepAbs.dxaText, FALSE ),
             rcPicture.right - xpSelBar + wwdCurrentDoc.xpMin );
 dypPicMac = DypFromDya( vsepAbs.yaMac, FALSE );

    /* Since the picture is selected, need to un-invert it */
 InvertRect( wwdCurrentDoc.hDC, (LPRECT) &rcPicture );

 SetCapture( wwdCurrentDoc.wwptr );     /* Hog all mouse actions */

 /* Draw initial size box icon in the center of the picture */

 pt.x = rcInverted.left + (unsigned)(rcInverted.right - rcInverted.left)/2;
 pt.y = rcInverted.top + (unsigned)(rcInverted.bottom - rcInverted.top)/2;
 DrawPMSFrameIcon( mdIconCenterFix | mdIconSetCursor, pt );

 SetCursor( vhcPMS );        /* Make the mouse cursor a size box */
 ShowCursor( TRUE );        /* So cursor appears even on mouseless systems */

 return TRUE;
}




void NEAR SetupDCForPMS()
{   /* Save current document DC & set it up for picture move/sizing:
        - A gray background brush for drawing the border
        - A drawing area resricted to rcClip */

 ilevelPMS = SaveDC( wwdCurrentDoc.hDC );
 SelectObject( wwdCurrentDoc.hDC, GetStockObject( GRAY_BRUSH ) );
 IntersectClipRect( wwdCurrentDoc.hDC,
                    rcClip.left, rcClip.top, rcClip.right, rcClip.bottom );
}




void NEAR EndPMS()
{       /* Leaving Picture Move/Size */
extern int docMode;
struct PICINFOX picInfo;

 vfPMS = FALSE;
 ReleaseCapture();  /* Allow other windows to receive mouse events */
 SetCursor( NULL );

 docMode = docNil;
 CheckMode();       /* Compensate for multiplier display */

 if (fIsRcInverted)
    InvertPMSFrame();

 if (!fPictModified && !vfCancelPictMove)
    {   /* Picture did not change, restore inversion to show selection */
        /* Must do this BEFORE RestoreDC so excess above ypMin is clipped */
    InvertRect( wwdCurrentDoc.hDC, (LPRECT) &rcPicture );
    }

 RestoreDC( wwdCurrentDoc.hDC, ilevelPMS );

 ShowCursor( FALSE );   /* Decrement cursor ref cnt (blanks if no mouse) */

    /* Since we've been ignoring messages, make sure our key flags are OK */
 SetShiftFlags();
}



void NEAR DrawPMSFrameIcon( mdIcon, pt )
int mdIcon;
POINT pt;
{       /* Draw Picture Move/Size frame and icon, with the icon at position
           pt.  The icon type is given by mdIcon.

           Scrolls the correct part of the picture into view if necessary.

           Uses statics: rcPicture, rcClip, rcInverted, fIsRcInverted
        */
#define FEqualRect( r1, r2 )    ((r1.left==r2.left)&&(r1.right==r2.right)&&\
                                 (r1.top==r2.top)&&(r1.bottom==r2.bottom))

 extern int vfAwfulNoise;
 int xpCntr;
 int dxpCntr = ((unsigned)(rcInverted.right - rcInverted.left)) / 2;
 RECT rcT;

 rcT = rcInverted;

 /* Set pt.y so it does not exceed limits */

 if (mdIcon & mdIconBottom)
    {
    if (pt.y - rcInverted.top > dypPicMac)
        {
        pt.y = rcInverted.top + dypPicMac;  /* max y-size is 1 page */
        }
    else if (pt.y < rcInverted.top + 1)
        pt.y = rcInverted.top + 1;          /* min y-size is 1 pixel */

    /* Restrict pt.x as necessary to keep printer bitmap < 64K */

    if ((pt.y > rcInverted.bottom) && (cxpPrinterPixel < 0xFFFF) && (cypPrinterPixel < 0xFFFF))
        {   /* Really sizing in y */
        unsigned dxpScreen = imax (imax(pt.x,rcInverted.right)-rcInverted.left,
                                   dxpPicSizeMin);
        unsigned dxpPrinter = DxpFromDxa(DxaFromDxp( dxpScreen, FALSE ), TRUE);
        unsigned dypLast = 0xFFFF / (dxpPrinter / 8);
        unsigned dyp = DypFromDya( DyaFromDyp( pt.y - rcInverted.top , FALSE),
                                   TRUE );

        if (dyp / (cxpPrinterPixel * cypPrinterPixel) > dypLast )
            {   /* Bitmap would overflow 64K boundary */
            pt.y = rcInverted.top +
                  DypFromDya( DyaFromDyp( dypLast, TRUE ), FALSE );
            }
        }
    }
 else if (pt.y < rcInverted.top)
    pt.y = rcInverted.top;          /* Can't go above picture top */
 else if (pt.y > rcInverted.bottom)
    pt.y = rcInverted.bottom;       /* Necessary? */

 /* Set pt.x so it does not execeed limits */

 switch (mdIcon & mdIconXMask) {
    case mdIconCenterFloat:
    case mdIconRight:

        /* Restrict pt.x as necessary to keep printer bitmap < 64K */
         if ((cxpPrinterPixel < 0xFFFF) && (cypPrinterPixel < 0xFFFF))
         {
         unsigned dyp = DypFromDya( DyaFromDyp( imax( pt.y - rcInverted.top,
                                    dypPicSizeMin), FALSE ), TRUE );
         unsigned dxpLast = 0xFFFF / (dyp / 8);
         unsigned dxp = DxpFromDxa( DxaFromDxp( pt.x - rcInverted.left,
                                    FALSE ), TRUE );

         if (dxp / (cxpPrinterPixel * cypPrinterPixel) > dxpLast )
             {   /* Printer bitmap would overflow 64K boundary */
             pt.x = rcInverted.left +
                        DxpFromDxa( DxaFromDxp( dxpLast, TRUE ), FALSE );
             }
         }

    default:
        break;
    case mdIconLeft:
        if ((pt.x < rcClip.left) && (wwdCurrentDoc.xpMin == 0))
            pt.x = rcClip.left;     /* Reached left scroll limit */
        break;
    case mdIconCenterFix:
        if ( (pt.x - dxpCntr < rcClip.left) && (wwdCurrentDoc.xpMin == 0))
            pt.x = rcClip.left + dxpCntr;   /* Reached left scroll limit */
        else if (pt.x - xpSelBar + wwdCurrentDoc.xpMin + dxpCntr > dxpPicMac)
                /* Move Picture only: can't move past margins */
            pt.x = dxpPicMac + xpSelBar - wwdCurrentDoc.xpMin - dxpCntr;
        break;
    }

 /* Check for pt outside of clip rectangle; scroll/bail out as needed */

 if (!PtInRect( (LPRECT)&rcClip, pt ))
    {
    int dxpHalfWidth =  (unsigned)(rcClip.right - rcClip.left) / 2;
    int dypHalfHeight = (unsigned)(rcClip.bottom - rcClip.top) / 2;
    int dxpScroll=0;
    int dypScroll=0;

    if (pt.x < rcClip.left)
        {
        if (wwdCurrentDoc.xpMin == 0)
            {
            _beep();                /* Reached left-hand scroll limit */
            pt.x = rcClip.left;
            }
        else
            {   /* SCROLL LEFT */
            dxpScroll = imax( -wwdCurrentDoc.xpMin,
                               imin( -dxpHalfWidth, pt.x - rcClip.left ) );
            }
        }
    else if (pt.x > rcClip.right)
        {
        if (wwdCurrentDoc.xpMin + rcClip.right - rcClip.left >= xpRightLim )
            {
            _beep();
            pt.x = rcClip.right;    /* Reached right-hand scroll limit */
            }
        else
            {   /* SCROLL RIGHT */
            dxpScroll = imin( xpRightLim - wwdCurrentDoc.xpMin +
                              rcClip.right - rcClip.left,
                              imax( dxpHalfWidth, pt.x - rcClip.right ) );
            }
        }

    if (pt.y < rcClip.top)
        {
        struct EDL *pedl = &(**wwdCurrentDoc.hdndl)[wwdCurrentDoc.dlMac - 1];

        if ( (rcInverted.top >= rcClip.top) ||
                /* May not scroll all of the original picture off the screen */
             (wwdCurrentDoc.dlMac <= 1) ||
             ( (pedl->cpMin == selCur.cpFirst) &&
                 ( ((pedl-1)->cpMin != pedl->cpMin) || !(pedl-1)->fGraphics)))
            {
            _beep();
            pt.y = rcClip.top;
            }
        else
            {   /* SCROLL UP */
            dypScroll = rcInverted.top - rcClip.top;
            }
        }
    else if (pt.y > rcClip.bottom)
        {
        struct EDL *pedl=&(**wwdCurrentDoc.hdndl)[0];

                /* May not scroll all of the original picture off the screen */
        if ( (wwdCurrentDoc.dlMac <= 1) ||
             ( (pedl->cpMin == selCur.cpFirst) &&
               ( ((pedl+1)->ichCpMin == 0) || !(pedl+1)->fGraphics) ))
            {
            _beep();                /* Reached downward scroll limit */
            pt.y = rcClip.bottom;   /* Must have at least 1 picture dl visible */
            }
        else
            dypScroll = 1;      /* SCROLL DOWN */
        }

    if (dxpScroll || dypScroll)
        {                       /* SCROLL */
        struct EDL *pedl;
        struct PICINFOX picInfo;
        int xpMinT = wwdCurrentDoc.xpMin;
        int ypTopT = rcPicture.top;
        int dxpAdjust, dypAdjust;

        if (dxpScroll && dypScroll)
                /* Did not need to truncate coordinates; re-enable beep */
            vfAwfulNoise = FALSE;

        if (fIsRcInverted)
            InvertPMSFrame();

        /* Scroll by the appropriate amount:
                dxpScroll in x-direction; one line in y-direction */

        RestoreDC( wwdCurrentDoc.hDC, ilevelPMS );  /* Use orig DC props */
        if (dxpScroll)
            AdjWwHoriz( dxpScroll );
        if (dypScroll > 0)
            ScrollDownCtr( 1 );
        else if (dypScroll < 0)
            ScrollUpCtr( 1 );
        UpdateWw( wwCur, FALSE );
        SetupDCForPMS();                         /* Compensate for RestoreDC */

        /* Update rcPicture to reflect new scroll position */

        GetPicInfo( selCur.cpFirst, selCur.cpLim, docCur, &picInfo );
        if (!FGetPictPedl( &pedl ))
            {
            Assert (FALSE);     /* If we get here, we're in trouble */
            _beep();
            return;
            }
        ComputePictRect( &rcPicture, &picInfo, pedl, wwCur );

        /* Adjust rcT, pt relative to the amount we actually scrolled */

        dxpAdjust = xpMinT - wwdCurrentDoc.xpMin;
        dypAdjust = rcPicture.top - ypTopT;
        OffsetRect( (LPRECT) &rcT, dxpAdjust, dypAdjust );
        pt.x += dxpAdjust;
        pt.y += dypAdjust;

        goto Display;   /* Dont let rcInverted be edited until we have
                           scrolled the icon into view */
        }
    }

 /* Compute effect of new icon position and/or type on rcInverted */

 switch (mdIcon & mdIconXMask) {
    case mdIconCenterFix:
        if (!fSizing)
            {
            xpCntr = rcInverted.left + dxpCntr;
            OffsetRect( (LPRECT) &rcT, pt.x - xpCntr, 0 );
            }
        break;
    case mdIconLeft:
        rcT.left = pt.x;
        goto ComputeY;
    case mdIconRight:
        rcT.right = pt.x;
    default:
    case mdIconCenterFloat:
ComputeY:
        if (mdIcon & mdIconBottom)
            rcT.bottom = pt.y;
        break;
     }

Display:

 /* If redrawing the border is necessary, do it */

 if (!FEqualRect( rcT, rcInverted ) || (mdIcon & mdIconSetCursor))
    {
    if (fIsRcInverted)
        InvertPMSFrame();
    rcInverted = rcT;
    InvertPMSFrame();
    }
 if (mdIcon & mdIconSetCursor)
    {
    SetCursorClientPos( pt );
    SetCursor( vhcPMS );
    }

 /* If the multipliers have changed, redisplay them */

 if (fSizing)
     {
     unsigned mx, my;

     mx = MultDiv( rcInverted.right - rcInverted.left, mxMultByOne, dxpOrig );
     my = MultDiv( rcInverted.bottom - rcInverted.top, myMultByOne, dypOrig );

     if (mx != mxCurrent || my != myCurrent)
        {   /* Multipliers have changed */
        mxCurrent = mx;
        myCurrent = my;
        ShowPictMultipliers();
        }
     }
}




void NEAR InvertPMSFrame()
{   /* Draw a frame for rcInverted in XOR mode, update fIsRcInverted */
 int dxpSize=rcInverted.right - rcInverted.left - 1;
 int dypSize=rcInverted.bottom - rcInverted.top - 1;

 PatBlt( wwdCurrentDoc.hDC, rcInverted.left, rcInverted.top,
                            dxpSize, 1, PATINVERT );
 PatBlt( wwdCurrentDoc.hDC, rcInverted.right - 1, rcInverted.top,
                            1, dypSize, PATINVERT );
 PatBlt( wwdCurrentDoc.hDC, rcInverted.left + 1, rcInverted.bottom - 1,
                            dxpSize, 1, PATINVERT );
 PatBlt( wwdCurrentDoc.hDC, rcInverted.left, rcInverted.top + 1,
                            1, dypSize, PATINVERT );

 fIsRcInverted ^= -1;
}




void NEAR GetCursorClientPos( ppt )
POINT *ppt;
{       /* Get current mouse cursor coordinates (window-relative) */
GetCursorPos( (LPPOINT) ppt );
ScreenToClient( wwdCurrentDoc.wwptr, (LPPOINT) ppt );
}




void NEAR SetCursorClientPos( pt )
POINT pt;
{     /* Set current mouse cursor coordinates (window-relative) */
ClientToScreen( wwdCurrentDoc.wwptr, (LPPOINT) &pt );
SetCursorPos( pt.x, pt.y );
}



STATIC NEAR ModifyPicInfoDxp( xpOffset, xpSize, ypSize, mx, my )
int xpOffset, xpSize, ypSize;
unsigned mx, my;
{   /* Modify the currently selected picture by adjusting its offset and
       size to the pixel values specified. Negative values mean don't
       set that value.
       Added    9/23/85: mx and my parms give the multiplier, redundant
                         info used for scaling bitmaps. */

 int xaOffset, xaSize, yaSize;

 xaOffset = xaSize = yaSize = -1;

 if (xpSize >= 0)
    xaSize = DxaFromDxp( umax( xpSize, dxpPicSizeMin ), FALSE );
 if (ypSize >= 0)
    yaSize = DyaFromDyp( umax( ypSize, dypPicSizeMin ), FALSE );
 if (xpOffset >= 0)
    xaOffset = DxaFromDxp( xpOffset, FALSE );
 ModifyPicInfoDxa( xaOffset, xaSize, yaSize, mx, my, TRUE );
}




/* M O D I F Y  P I C  I N F O  D X A */
STATIC NEAR ModifyPicInfoDxa( xaOffset, xaSize, yaSize, mx, my, fSetUndo )
int xaOffset, xaSize, yaSize;
unsigned mx, my;
BOOL fSetUndo;
{   /* Modify the currently selected picture by adjusting its offset and
       size to the twip values specified. Negative values mean don't
       set that value.
       Added 9/23/85: mx, my are size "multipliers", used for
                      bitmaps only */

typeFC fcT;
struct PICINFOX  picInfo;
typeCP  cp = selCur.cpFirst;
int     dyaSizeOld;
int     fBitmap,fObj;

fPictModified = TRUE;
FreeBitmapCache();

GetPicInfo(cp, cpMacCur, docCur, &picInfo);
fBitmap = (picInfo.mfp.mm == MM_BITMAP);
fObj =    (picInfo.mfp.mm == MM_OLE);

dyaSizeOld = picInfo.dyaSize;

if (fBitmap || fObj)
    {
    if ((int)mx > 0 && (int)my > 0)
        {
        picInfo.mx = mx;
        picInfo.my = my;
        }
    }
else 
    {
    if (xaSize >= 0)
        picInfo.dxaSize = xaSize;

    if (yaSize >= 0)
        picInfo.dyaSize = yaSize;
    }

if (xaOffset >= 0)
    picInfo.dxaOffset = xaOffset;

if (picInfo.cbHeader > cchOldPICINFO)
        /* Extended picture format, set extended format bit */
    picInfo.mfp.mm |= MM_EXTENDED;

if (!fObj)
    fcT = FcWScratch( &picInfo, picInfo.cbHeader );

picInfo.mfp.mm &= ~MM_EXTENDED;

/* Right or center justify becomes invalid if the picture is moved
   without being sized */

CachePara(docCur, cp);
if ( (xaSize < 0 && yaSize < 0) &&
     (vpapAbs.jc == jcRight || vpapAbs.jc == jcCenter))
        {
        CHAR rgb[2];

	if (fSetUndo)
	    SetUndo(uacPictSel, docCur, cp, selCur.cpLim - selCur.cpFirst,
                                                docNil, cpNil, cpNil, 0);
        TrashCache();
        rgb[0] = sprmPJc;
        rgb[1] = jcLeft;
        AddSprm(&rgb[0]);
        }
else
	{
	if (fSetUndo)
	    SetUndo( uacPictSel, docCur, cp, (typeCP) picInfo.cbHeader,
                 docNil, cpNil, cpNil, 0);
	}

if (fObj)
    ObjSetPicInfo(&picInfo, docCur, cp);
else
    Replace( docCur, cp, (typeCP) picInfo.cbHeader,
            fnScratch, fcT, (typeFC) picInfo.cbHeader);

if ( ((fBitmap || fObj) && (my > myMultByOne)) ||
     (!fBitmap && (dyaSizeOld < picInfo.dyaSize)))
        { /* If the picture height was increased, make sure proper EDLs are
                        invalidated. */
        typeCP dcp = cpMacCur - cp + (typeCP) 1;
        AdjustCp(docCur, cp, dcp, dcp);
        }
}




STATIC NEAR ShowPictMultipliers( )
{   /* Display the current multipliers (mxCurrent, myCurrent) in the page info
       window in the form "n.nX/n.nY". */

CHAR *PchCvtMx( unsigned, CHAR * );
extern CHAR szMode[];

CHAR *pch = szMode;

pch = PchCvtMx( mxCurrent, pch );
*(pch++) = 'X';
*(pch++) = '/';
Assert( mxMultByOne == myMultByOne );   /* Necessary for below to work w/ my */
pch = PchCvtMx( myCurrent, pch );
*(pch++) = 'Y';
*pch = '\0';

DrawMode();
}


CHAR *PchCvtMx( mx, pch )
CHAR *pch;
unsigned mx;
{   /* Convert the passed multiplier word to a string representation.
       Number is based on a mxMultByOne === 1 scale
       (e.g. mx == .9 * mxMultByOne yields "0.9")
       String always has at least one digit before the decimal point,
       and exactly one after.
       Examples of return strings: "10.5", "0.0", "5.5" */

 int nTenths;
 int nWholes;
 int cch;
 extern CHAR vchDecimal;
 extern BOOL    vbLZero;
 extern int     viDigits;

 /* Round up to nearest single decimal place */

 if (mx % (mxMultByOne / 10) >= mxMultByOne / 20)
    mx += mxMultByOne / 20;

 /* Write digit(s) before decimal place */

 if (((nWholes = mx / mxMultByOne) == 0) && vbLZero)
    *(pch++) = '0';
 else
    ncvtu( nWholes, &pch );

 /* Write Decimal Point and following digit */

 *(pch++) = vchDecimal;

 if (viDigits > 0)
    *(pch++) = ((mx % mxMultByOne) / (mxMultByOne / 10)) + '0';

 *pch = '\0';

 return pch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\picture.c ===
/************************************************************/

/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* picture.c -- MW format and display routines for pictures */

//#define NOGDICAPMASKS
#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
//#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOFONT
#define NOMB
#define NOMENUS
#define NOOPENFILE
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "fmtdefs.h"
#include "dispdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "stcdefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#include "editdefs.h"
/* #include "str.h" */
#include "prmdefs.h"
/* #include "fkpdefs.h" */
/* #include "macro.h" */
#include "winddefs.h"
#if defined(OLE)
#include "obj.h"
#endif

extern typeCP           cpMacCur;
extern int              docCur;
extern int              vfSelHidden;
extern struct WWD       rgwwd[];
extern int              wwCur;
extern int              wwMac;
extern struct FLI       vfli;
extern struct SEL       selCur;
extern struct WWD       *pwwdCur;
extern struct PAP       vpapCache;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern int              vfPictSel;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern struct SEP       vsepPage;
extern struct DOD       (**hpdocdod)[];
extern unsigned         cwHeapFree;
extern int              vfInsertOn;
extern int              vfPMS;
extern int              dxpLogInch;
extern int              dypLogInch;
extern int              dxaPrPage;
extern int              dyaPrPage;
extern int              dxpPrPage;
extern int              dypPrPage;
extern HBRUSH           hbrBkgrnd;
extern long             ropErase;
extern int              vdocBitmapCache;
extern typeCP           vcpBitmapCache;
extern HBITMAP          vhbmBitmapCache;
extern BOOL             vfBMBitmapCache;
extern HCURSOR          vhcIBeam;
extern BOOL             vfMonochrome;


/* Used in this module only */
#ifdef DEBUG
#define STATIC static
#else
#define STATIC
#endif

STATIC RECT rcPictInvalid;  /* Rectangle (in window coords) that needs refresh */
int vfWholePictInvalid = TRUE;


FreeBitmapCache()
{
 vdocBitmapCache = docNil;
 if (vhbmBitmapCache != NULL)
    {
    DeleteObject( vhbmBitmapCache );
    vhbmBitmapCache = NULL;
    }
}




MarkInvalidDlPict( ww, dlPict )
int ww;
int dlPict;
{   /* Mark the passed dl (presumed to be part of a picture) as requiring
       eventual update, when DisplayGraphics is called */

 register struct WWD *pwwd = &rgwwd [ww];
 struct EDL (**hdndl)[] = pwwd->hdndl;
 struct EDL *pedl = &(**hdndl)[ dlPict ];
 RECT rcDl;

 SetRect( (LPRECT) &rcDl, 0, pedl->yp - pedl->dyp,
                          pwwd->xpMac, pedl->yp );

 if (vfWholePictInvalid)
    {
    CopyRect( (LPRECT) &rcPictInvalid, (LPRECT) &rcDl );
    vfWholePictInvalid = FALSE;
    }
 else
    {
    RECT rcT;

    rcT = rcPictInvalid;    /* Necessary?  i.e. can UnionRect handle
                                source == destination */
    UnionRect( (LPRECT) &rcPictInvalid, (LPRECT) &rcT, (LPRECT) &rcDl );
    }
}




DisplayGraphics( ww, dl, fDontDisplay )
int ww;
int dl;
int fDontDisplay;
{       /* Display a line of graphics info */
        struct WWD *pwwd = &rgwwd[ww];
        struct EDL *pedl;
        typeCP cpPictStart;
        typeCP cp;
        typeCP cpMac = (**hpdocdod)[vfli.doc].cpMac;
        struct PICINFOX  picInfo;
        RECT rcEnclose;
        RECT rcPict;
        HANDLE hBits=NULL;
        HDC hMDC=NULL;
        HDC hMDCCache=NULL;
        HANDLE hbm=NULL;
        HDC hDC=pwwd->hDC;
        int cchRun;
        unsigned long cbPict=0;
        int dxpOrig;        /* Size of picture in the original */
        int dypOrig;
        int dxpDisplay;     /* Size of picture as we want to show it */
        int dypDisplay;
        int fBitmap;
        int ilevel=0;
    
        /* THIS ROUTINE COULD USE SOME GDI-CALL ERROR CHECKING!  ..pault */

        int fDrew=false;

        /* In the case of monochrome devices, this raster op will map white in
        the bitmap to the background color and black to the foreground color. */
        #define ropMonoBm 0x00990066

        Assert( dl >= 0 && dl < pwwd->dlMax );

        MarkInvalidDlPict( ww, dl );

        if (fDontDisplay)
            {
            return;
            }

        Diag(CommSz("DisplayGraphics:       \n\r"));

        FreezeHp();
        pedl = &(**(pwwd->hdndl))[dl];
        cpPictStart=pedl->cpMin;

        GetPicInfo( cpPictStart, cpMac, vfli.doc, &picInfo );

        /* Compute desired display size of picture (in device pixels) */

        ComputePictRect( &rcPict, &picInfo, pedl, ww );
        dxpDisplay = rcPict.right - rcPict.left;
        dypDisplay = rcPict.bottom - rcPict.top;

        /* Compute original size of picture (in device pixels) */
        /* MM_ANISOTROPIC and MM_ISOTROPIC pictures have no original size */

        switch ( picInfo.mfp.mm ) {
            case MM_ISOTROPIC:
            case MM_ANISOTROPIC:
                break;
            case MM_BITMAP:
                dxpOrig = picInfo.bm.bmWidth;
                dypOrig = picInfo.bm.bmHeight;
                break;
#if defined(OLE)
            case MM_OLE:
            {
                extern BOOL vfObjDisplaying;

                if (lpOBJ_QUERY_INFO(&picInfo) == NULL)
                        goto DontDraw;

                /* just to be safe */
                if (!CheckPointer(lpOBJ_QUERY_INFO(&picInfo),1))
                    goto DontDraw;

                if (lpOBJ_QUERY_OBJECT(&picInfo) == NULL)
                {
                    typeCP cpRet;

                    /* this can require memory, so unlock heap */
                    MeltHp();
                    vfObjDisplaying = TRUE;

                    cpRet = ObjLoadObjectInDoc(&picInfo,vfli.doc,cpPictStart);

                    vfObjDisplaying = FALSE;
                    FreezeHp();
                    pedl = &(**(pwwd->hdndl))[dl];

                    if (cpRet == cp0)
                        goto DontDraw;
                }
            }
            break;
#endif
            default:
                dxpOrig = PxlConvert( picInfo.mfp.mm, picInfo.mfp.xExt,
                                      GetDeviceCaps( hDC, HORZRES ),
                                      GetDeviceCaps( hDC, HORZSIZE ) );
                dypOrig = PxlConvert( picInfo.mfp.mm, picInfo.mfp.yExt,
                                      GetDeviceCaps( hDC, VERTRES ),
                                      GetDeviceCaps( hDC, VERTSIZE ) );
                if (! (dxpOrig && dypOrig) )
                    {
                    goto DontDraw;
                    }
                break;
            }

        /* Save DC as a guard against DC attribute alteration by a metafile */
#ifdef WINDOWS_BUG_FIXED    /* Currently 0 is a valid level for Own DC's */
        if ((ilevel=SaveDC( hDC )) == 0)
            goto DontDraw;
#endif
        ilevel = SaveDC( hDC );
        SetStretchBltMode( hDC, BLACKONWHITE );

        /* Clip out top bar, selection bar */

        IntersectClipRect( hDC, ((wwCur == wwClipboard) ? 0 : xpSelBar),
                           pwwdCur->ypMin, pwwdCur->xpMac, pwwdCur->ypMac );

        if (!vfWholePictInvalid)
                /* Repainting less than the whole picture; clip out
                   what we're not drawing */
            IntersectClipRect( hDC, rcPictInvalid.left, rcPictInvalid.top,
                                    rcPictInvalid.right, rcPictInvalid.bottom );

        /* Build rcEnclose, a rect enclosing the picture that
           includes the "space before" and "space after" fields */

        rcEnclose.left = xpSelBar;
        if ((rcEnclose.top = rcPict.top -
                        DypFromDya( vpapAbs.dyaBefore, FALSE )) < pwwd->ypMin)
            rcEnclose.top = pwwd->ypMin;
        rcEnclose.right = pwwd->xpMac;
        if ((rcEnclose.bottom = rcPict.bottom +
                        DypFromDya( vpapAbs.dyaAfter, FALSE )) > pwwd->ypMac)
            rcEnclose.bottom = pwwd->ypMac;

        /* White out enclosing rect */

        PatBlt( hDC, rcEnclose.left, rcEnclose.top,
                     rcEnclose.right - rcEnclose.left,
                     rcEnclose.bottom - rcEnclose.top, ropErase );

        /* If we have it cached, do display the easy way */

        if (pwwd->doc == vdocBitmapCache &&  cpPictStart == vcpBitmapCache)
            {
            Assert( pwwd->doc != docNil && vhbmBitmapCache != NULL);

            if ( ((hMDC = CreateCompatibleDC( hDC )) != NULL) &&
                 SelectObject( hMDC, vhbmBitmapCache ))
                {
                Diag(CommSz("DisplayGraphics: BitBlt\n\r"));
                BitBlt( hDC, rcPict.left, rcPict.top, dxpDisplay, dypDisplay,
                             hMDC, 0, 0, vfMonochrome && vfBMBitmapCache ?
                             ropMonoBm : SRCCOPY );
                fDrew = TRUE;
                goto DontDraw;
                }
            else
                {   /* Using the cache failed -- empty it
                       (SelectObject will fail if bitmap was discarded) */
                FreeBitmapCache();
                }
            }

        StartLongOp();  /* Put up an hourglass */

        /* Build up all bytes associated with the picture (except the header)
           into the global Windows handle hBits */

        if ( picInfo.mfp.mm != MM_OLE)
        {
        if ((hBits=GlobalAlloc( GMEM_MOVEABLE, (long)picInfo.cbSize )) == NULL)
            {    /* Not enough global heap space to load bitmap/metafile */
            goto DontDraw;
            }

#ifdef DCLIP    
        {
        char rgch[200];
        wsprintf(rgch,"DisplayGraphics: picinfo.cbSize %lu \n\r", picInfo.cbSize);
        CommSz(rgch);
        }
#endif

        for ( cbPict = 0, cp = cpPictStart + picInfo.cbHeader;
              cbPict < picInfo.cbSize;
              cbPict += cchRun, cp += (typeCP) cchRun )
            {
            CHAR rgch[ 256 ];
#if WINVER >= 0x300            
            HPCH lpch;
#else            
            LPCH lpch;
#endif

#define ulmin(a,b)      ((unsigned long)(a) < (unsigned long)(b) ? \
                          (unsigned long)(a) : (unsigned long)(b))

            FetchRgch( &cchRun, rgch, vfli.doc, cp, cpMac,
                                 (int) ulmin( picInfo.cbSize - cbPict, 256 ) );
            if ((lpch=GlobalLock( hBits )) != NULL)
                {
#ifdef DCLIP    
            {
            char rgch[200];
            wsprintf(rgch," copying %d bytes from %lX to %lX \n\r",cchRun,(LPSTR)rgch,lpch+cbPict);
            CommSz(rgch);
            }

            {
            char rgchT[200];
            int i;
            for (i = 0; i< min(20,cchRun); i++,i++)
                {
                wsprintf(rgchT,"%X ",* (int *) &(rgch[i]));
                CommSz(rgchT);
                }
            CommSz("\n\r");
            }
#endif
#if WINVER >= 0x300                
                bltbh( (LPSTR)rgch, lpch+cbPict, cchRun );
#else
                bltbx( (LPSTR)rgch, lpch+cbPict, cchRun );
#endif
                GlobalUnlock( hBits );
                }
            else
                {
                goto DontDraw;
                }
            }
        }


        /* Display the picture */

        MeltHp();

#if defined(OLE)
        /* CASE 0: OLE */
        if (picInfo.mfp.mm == MM_OLE)
        {
            Diag(CommSz("Case 0:\n\r"));
            if (ObjDisplayObjectInDoc(&picInfo, vfli.doc, cpPictStart,
                            hDC, &rcPict) == FALSE)
                goto DontDraw;
            fDrew = true;
        }
        else
#endif
        /* CASE 1: Bitmap */
        if (fBitmap = (picInfo.mfp.mm == MM_BITMAP))
            {
            Diag(CommSz("Case 1: \n\r"));
            if ( ((hMDC = CreateCompatibleDC( hDC )) != NULL) &&
                 ((picInfo.bm.bmBits = GlobalLock( hBits )) != NULL) &&
                 ((hbm=CreateBitmapIndirect((LPBITMAP)&picInfo.bm))!=NULL))
                {
                picInfo.bm.bmBits = NULL;
                GlobalUnlock( hBits );
                GlobalFree( hBits ); /* Free handle to bits to allow max room */
                hBits = NULL;
                SelectObject( hMDC, hbm );

                goto CacheIt;
                }
            }

        /* Case 2: non-scalable metafile pictures which we are, for
           user interface consistency, scaling by force using StretchBlt */

        else if ( ((dxpDisplay != dxpOrig) || (dypDisplay != dypOrig)) &&
                  (picInfo.mfp.mm != MM_ISOTROPIC) &&
                  (picInfo.mfp.mm != MM_ANISOTROPIC) )
           {

            Diag(CommSz("Case 2: \n\r"));
           if (((hMDC=CreateCompatibleDC( hDC)) != NULL) &&
               ((hbm=CreateCompatibleBitmap( hDC, dxpOrig, dypOrig ))!=NULL) &&
               SelectObject( hMDC, hbm ) && SelectObject( hMDC, hbrBkgrnd ))
                {
                extern int vfOutOfMemory;

                PatBlt( hMDC, 0, 0, dxpOrig, dypOrig, ropErase );
                SetMapMode( hMDC, picInfo.mfp.mm );
                    /* To cover StretchBlt calls within the metafile */
                SetStretchBltMode( hMDC, BLACKONWHITE );
                PlayMetaFile( hMDC, hBits );
                    /* Because we pass pixels to StretchBlt */
                SetMapMode( hMDC, MM_TEXT );

CacheIt:        Assert( hbm != NULL && hMDC != NULL );

                if (vfOutOfMemory)
                    goto NoCache;
#ifndef NOCACHE
                FreeBitmapCache();
                /* Among other things, this code caches the current picture.
                Notice that there are two assumptions: (1) all bitmaps are
                monochrome, and (2) a newly created memory DC has a monochrome
                bitmap selected in. */
                if ( ((hMDCCache = CreateCompatibleDC( hDC )) != NULL) &&
                     ((vhbmBitmapCache = CreateDiscardableBitmap(
                       fBitmap ? hMDCCache : hDC, dxpDisplay, dypDisplay )) !=
                       NULL) &&
                     SelectObject( hMDCCache, vhbmBitmapCache ))
                        {
                        if (!StretchBlt( hMDCCache, 0, 0, dxpDisplay,
                          dypDisplay, hMDC, 0, 0, dxpOrig, dypOrig, SRCCOPY ))
                            {   /* may get here if memory is low */
                            DeleteDC( hMDCCache );
                            hMDCCache = NULL;
                            DeleteObject( vhbmBitmapCache );
                            vhbmBitmapCache = NULL;
                            goto NoCache;
                            }

#ifdef DCLIP            
            if (vfMonochrome && fBitmap)
                CommSzNum("BitBlt using ropMonoBm == ",ropMonoBm);
#endif

                        BitBlt( hDC, rcPict.left, rcPict.top, dxpDisplay,
                          dypDisplay, hMDCCache, 0, 0, vfMonochrome && fBitmap ?
                          ropMonoBm : SRCCOPY );

                            /* Cached bitmap OK, make cache valid */
                        vdocBitmapCache = pwwd->doc;
                        vcpBitmapCache = cpPictStart;
                        vfBMBitmapCache = fBitmap;
                        }
                else
#endif  /* ndef NOCACHE */
                    {
NoCache:
                    StretchBlt( hDC, rcPict.left, rcPict.top,
                                dxpDisplay, dypDisplay,
                                hMDC, 0, 0, dxpOrig, dypOrig, vfMonochrome &&
                                fBitmap ? ropMonoBm : SRCCOPY );
                    }
                fDrew = TRUE;
                }
            }

        /* Case 3: A metafile picture which can be directly scaled
           or does not need to be because its size has not changed */
        else
            {
            fDrew = true;
            Diag(CommSz("Case 3:\n\r"));
            SetMapMode( hDC, picInfo.mfp.mm );

            SetViewportOrg( hDC, rcPict.left, rcPict.top );
            switch( picInfo.mfp.mm ) {
                case MM_ISOTROPIC:
                    if (picInfo.mfp.xExt && picInfo.mfp.yExt)
                        /* So we get the correct shape rectangle when
                           SetViewportExt gets called */
                        SetWindowExt( hDC, picInfo.mfp.xExt, picInfo.mfp.yExt );
                    /* FALL THROUGH */
                case MM_ANISOTROPIC:
                    /** (9.17.91) v-dougk 
                        Set the window extent in case the metafile is bad 
                        and doesn't call it itself.  This will prevent
                        possible gpfaults in GDI
                     **/
                    SetWindowExt( hDC, dxpDisplay, dypDisplay );

                    SetViewportExt( hDC, dxpDisplay, dypDisplay );
                    break;
                }

            PlayMetaFile( hDC, hBits );
            }
DontDraw:

        /* Clean up */
        if ( *(pLocalHeap+1) )
            MeltHp();

        if (ilevel > 0)
            RestoreDC( hDC, ilevel );
        if (hMDCCache != NULL)
            DeleteDC( hMDCCache );
        if (hMDC != NULL)
            DeleteDC( hMDC );
        if (hbm != NULL)
            DeleteObject( hbm );
        if (hBits != NULL)
            {
            if (fBitmap && picInfo.bm.bmBits != NULL)
                GlobalUnlock( hBits );
            GlobalFree( hBits );
            }

        if (!fDrew)
        {
            void DrawBlank(HDC hDC, RECT FAR *rc);
            DrawBlank(hDC,&rcPict);
        }   

        /* Invert the selection */
        if (ww == wwDocument && !vfSelHidden && !vfPMS)
            {
            extern int vypCursLine;

            ilevel = SaveDC( hDC );  /* Because of clip calls below */

            if (!vfWholePictInvalid)
                    /* Repainting less than the whole picture; clip out
                       what we're not drawing */
                IntersectClipRect( hDC, rcPictInvalid.left, rcPictInvalid.top,
                                   rcPictInvalid.right, rcPictInvalid.bottom );

            /* Clip out top bar, selection bar */

            IntersectClipRect( hDC, xpSelBar,
                           pwwdCur->ypMin, pwwdCur->xpMac, pwwdCur->ypMac );

            if (selCur.cpLim > cpPictStart && selCur.cpFirst <= cpPictStart)
                { /* Take into account 'space before' field */
                rcEnclose.left = rcPict.left;
                rcEnclose.right = rcPict.right;
                InvertRect( hDC, (LPRECT) &rcEnclose );
                }
            else if ((selCur.cpLim == selCur.cpFirst) &&
                     (selCur.cpFirst == cpPictStart) &&
                     (vfWholePictInvalid || rcPictInvalid.top < vypCursLine))
                {   /* We erased the insert point */
                vfInsertOn = fFalse;
                }
            RestoreDC( hDC, ilevel );
            }

        vfWholePictInvalid = TRUE;   /* Next picture, start invalidation anew */
        {
        extern int vfPMS;
        extern HCURSOR vhcPMS;


        EndLongOp( vfPMS ? vhcPMS : vhcIBeam );
        }
}


#ifdef ENABLE   /* Don't use this anymore */
int
FPointInPict(pt)
POINT pt;
{       /* Return true if point is within the picture frame */
struct EDL      *pedl;
struct PICINFOX  picInfo;
RECT rcPict;

GetPicInfo(selCur.cpFirst, cpMacCur, docCur, &picInfo);

if (!FGetPictPedl(&pedl))
        return false;

ComputePictRect( &rcPict, &picInfo, pedl, wwCur );

return PtInRect( (LPRECT)&rcPict, pt );
}
#endif  /* ENABLE */


/* C O M P U T E  P I C T  R E C T */
ComputePictRect( prc, ppicInfo, pedl, ww )
RECT *prc;
register struct PICINFOX  *ppicInfo;
struct EDL      *pedl;
int     ww;
{       /* Compute rect containing picture indicated by passed ppicInfo,
           pedl, in the indicated ww. Return the computed rect through
           prc.  picInfo structure is not altered. */

        int dypTop, xaLeft;
        struct WWD *pwwd = &rgwwd[ww];
        int xaStart;
        int dxaText, dxa;
        int dxpSize, dypSize;
        int dxaSize, dyaSize;

        CacheSectPic(pwwd->doc, pedl->cpMin);

        if (ppicInfo->mfp.mm == MM_BITMAP && ((ppicInfo->dxaSize == 0) ||
                                              (ppicInfo->dyaSize == 0)))
            {
            GetBitmapSize( &dxpSize, &dypSize, ppicInfo, FALSE );
            dxaSize = DxaFromDxp( dxpSize, FALSE );
            dyaSize = DyaFromDyp( dypSize, FALSE );
            }
#if defined(OLE)
        else if (ppicInfo->mfp.mm == MM_OLE)
        {
            dxpSize = DxpFromDxa(ppicInfo->dxaSize, FALSE );
            dypSize = DypFromDya(ppicInfo->dyaSize, FALSE );
            dxpSize = MultDiv( dxpSize, ppicInfo->mx, mxMultByOne );
            dypSize = MultDiv( dypSize, ppicInfo->my, myMultByOne );
            dxaSize = DxaFromDxp( dxpSize, FALSE );
            dyaSize = DyaFromDyp( dypSize, FALSE );
        }
#endif
        else
            {

            dxpSize = DxpFromDxa( dxaSize = ppicInfo->dxaSize, FALSE );
            dypSize = DypFromDya( dyaSize = ppicInfo->dyaSize, FALSE );
            }

        dypTop = pedl->dcpMac != 0 ?
                /* Last line of picture */
            DypFromDya( dyaSize + vpapAbs.dyaAfter, FALSE ) :
            (pedl->ichCpMin + 1) * dypPicSizeMin;
        dypTop = pedl->yp - dypTop;

        xaStart = DxaFromDxp( xpSelBar - (int) pwwd->xpMin, FALSE );
        dxaText = vsepAbs.dxaText;
        switch (vpapAbs.jc)
                {
        case jcBoth:
        case jcLeft:
                dxa = ppicInfo->dxaOffset;
                break;
        case jcCenter:
                dxa = (dxaText - (int)vpapAbs.dxaRight + (int)vpapAbs.dxaLeft -
                        dxaSize) / 2;
                break;
        case jcRight:
                dxa = dxaText - (int)vpapAbs.dxaRight - dxaSize;
                break;
                }

        xaLeft = xaStart + max( (int)vpapAbs.dxaLeft, dxa );

        prc->right = (prc->left = DxpFromDxa( xaLeft, FALSE )) + dxpSize;
        prc->bottom = (prc->top = dypTop) + dypSize;
}

FGetPictPedl(ppedl)
struct EDL      **ppedl;
{
int dlLim = pwwdCur->dlMac;
int     dl;
typeCP  cpFirst = selCur.cpFirst;
struct EDL      *pedl;

//Assert(vfPictSel);

if (!vfPictSel)
    return FALSE;

pedl = &(**(pwwdCur->hdndl)[0]);

for (dl = 0; dl < dlLim; ++dl, ++pedl)
        {
        //if (!pedl->fValid)
                //return false;

        if (pedl->cpMin == cpFirst)
                break;
        }
if (dl >= dlLim)
        return false;   /* No part of picture is on screen */

*ppedl = pedl;
return true;
}




/* C P  W I N  G R A P H I C */
typeCP CpWinGraphic(pwwd)
struct WWD *pwwd;
        {
        int cdlPict, dl;
        struct EDL *dndl = &(**(pwwd->hdndl))[0];

        Assert( !pwwd->fDirty );    /* So we can rely on dl info */
        CachePara(pwwd->doc, dndl->cpMin);
        for (dl = 0; (dl < pwwd->dlMac - 1 && dndl[dl].fIchCpIncr); ++dl)
                ;
        Assert(dndl[dl].fGraphics);
        cdlPict = dndl[dl].ichCpMin + 1;
        return (dndl[0].cpMin +
                (vcpLimParaCache - vcpFirstParaCache) * dndl[0].ichCpMin / cdlPict);
        }




CacheSectPic(doc, cp)
int doc;
typeCP cp;
{ /* Cache section and para props, taking into account that footnotes take props
                                        from the reference point */
#ifdef FOOTNOTES
struct DOD *pdod = &(**hpdocdod)[doc];
struct FNTB (**hfntb) = pdod->hfntb;
#endif

CachePara(doc, cp);

#ifdef FOOTNOTES
if ( (hfntb != 0) && (cp >= (**hfntb).rgfnd[0].cpFtn) )
    CacheSect( doc, CpRefFromFtn( doc, cp ) )
else
#endif
    CacheSect(doc, cp); /* Normal text */
}


void DrawBlank(HDC hDC, RECT FAR *rc)
{   /* To tell us when the draw tried but failed */
    int xpMid=rc->left + (rc->right-rc->left)/2;
    int ypMid=rc->top + (rc->bottom - rc->top)/2;
    int dxpQ=(rc->right-rc->left)/4;
    int dypQ=(rc->bottom-rc->top)/4;
    HPEN hOldPen;
    HBRUSH hOldBrush;

    hOldPen = SelectObject( hDC, GetStockObject( BLACK_PEN ) );
    hOldBrush = SelectObject( hDC, GetStockObject( WHITE_BRUSH ) );
    Rectangle(hDC,rc->left,rc->top,rc->right,rc->bottom);
    MoveTo( hDC, rc->left, rc->top );
    LineTo( hDC, rc->right, rc->bottom );
    MoveTo( hDC, rc->left, rc->bottom );
    LineTo( hDC, rc->right, rc->top );
    MoveTo( hDC, xpMid, rc->top );
    LineTo( hDC, xpMid, rc->bottom );
    MoveTo( hDC, rc->left, ypMid );
    LineTo( hDC, rc->right, ypMid );
    Ellipse( hDC,
                xpMid-dxpQ, ypMid-dypQ,
                xpMid+dxpQ, ypMid+dypQ );
    SelectObject( hDC, hOldPen );
    SelectObject( hDC, hOldBrush );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\objreg.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/
/* register.c - Handles the Win 3.1 registration library.
 *
 * Created by Microsoft Corporation.
 */

#define LSTRING // for lstrcat etc
#include <windows.h>
#include <shellapi.h>
#include "objreg.h"
#include "mw.h"
#include "winddefs.h"
#include "obj.h"	 
#include "str.h"			/* Needed for string resource id */
#include "menudefs.h"
#include "cmddefs.h"

char szClassName[CBPATHMAX];

HKEY hkeyRoot = NULL;

void NEAR PASCAL MakeMenuString(char *szCtrl, char *szMenuStr, char *szVerb, char *szClass, char *szObject);

/* RegInit() - Prepare the registration database for calls.
 */
void FAR RegInit(HANDLE hInst) 
{
    /* this seems to speed up registration operations immensely, but serves
       no other purpose */
    //RegOpenKey(HKEY_CLASSES_ROOT,NULL,&hkeyRoot);
}

/* RegTerm() - Clean up and terminate the registration library.
 */
void FAR RegTerm(void) 
{
    if (hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
        hkeyRoot = NULL;
    }
}

/* RegGetClassId() - Retrieves the string name of a class.
 *
 * Note:  Classes are guaranteed to be in ASCII, but should
 *        not be used directly as a rule because they might
 *        be meaningless if running non-English Windows.
 */
void FAR RegGetClassId(LPSTR lpstrName, LPSTR lpstrClass) {
    DWORD dwSize = KEYNAMESIZE;

    if (RegQueryValue(HKEY_CLASSES_ROOT, lpstrClass, (LPSTR)lpstrName, &dwSize))
	    lstrcpy(lpstrName, lpstrClass);
}

/* RegMakeFilterSpec() - Retrieves class-associated default extensions.
 *
 * This function returns a filter spec, to be used in the "Change Link"
 * standard dialog box, which contains all the default extensions which
 * are associated with the given class name.  Again, the class names are
 * guaranteed to be in ASCII.
 *
 * Returns:  The index nFilterIndex stating which filter item matches the
 *           extension, or 0 if none is found or -1 if error.
 **          *hFilterSpec is allocated and must be freed by caller.
 */
int FAR RegMakeFilterSpec(LPSTR lpstrClass, LPSTR lpstrExt, HANDLE *hFilterSpec) 
{
    DWORD dwSize;
    LPSTR lpstrFilterSpec;
    char szClass[KEYNAMESIZE];
    char szName[KEYNAMESIZE];
    char szString[KEYNAMESIZE];
    unsigned int i;
    int  idWhich = 0;
    int  idFilterIndex = 0;

    if (*hFilterSpec == NULL)
    {
        if ((*hFilterSpec = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,KEYNAMESIZE+16)) == NULL)
            return -1;
        lpstrFilterSpec = MAKELP(*hFilterSpec,0);
    }

    RegOpenKey(HKEY_CLASSES_ROOT,NULL,&hkeyRoot);
	for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szName, KEYNAMESIZE); ) 
    {
        if (*szName == '.'              /* Default Extension... */

        /* ... so, get the class name */
            && (dwSize = KEYNAMESIZE)
            && !RegQueryValue(HKEY_CLASSES_ROOT, szName, szClass, &dwSize)

	    /* ... and if the class name matches (null class is wildcard) */
	     && (!lpstrClass || !lstrcmpi(lpstrClass, szClass))

        /* ... get the class name string */
            && (dwSize = KEYNAMESIZE)
            && !RegQueryValue(HKEY_CLASSES_ROOT, szClass, szString, &dwSize)) 
        {
            int offset;

		    idWhich++;

		    /* If the extension matches, save the filter index */
		    if (lpstrExt && !lstrcmpi(lpstrExt, szName))
		        idFilterIndex = idWhich;

            offset = lpstrFilterSpec - MAKELP(*hFilterSpec,0);

            if ((GlobalSize(*hFilterSpec) - offset) < 
                                        (lstrlen(szString) + 16))
            {
                if ((*hFilterSpec = GlobalReAlloc(*hFilterSpec,GlobalSize(*hFilterSpec)+KEYNAMESIZE+16,
                                    GMEM_MOVEABLE|GMEM_ZEROINIT)) == NULL)
                {
                    GlobalFree(*hFilterSpec);
                    *hFilterSpec = NULL;
                    idFilterIndex = -1;
                    break;
                }
                lpstrFilterSpec = (LPSTR)MAKELP(*hFilterSpec,0) + offset;
            }

            /* Copy over "<Class Name String> (*<Default Extension>)"
                * e.g. "Server Picture (*.PIC)"
                */
            lstrcpy(lpstrFilterSpec, szString);
            lstrcat(lpstrFilterSpec, " (*");
            lstrcat(lpstrFilterSpec, szName);
            lstrcat(lpstrFilterSpec, ")");
            lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;

            /* Copy over "*<Default Extension>" (e.g. "*.PIC") */
            lstrcpy(lpstrFilterSpec, "*");
            lstrcat(lpstrFilterSpec, szName);
            lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;
        }
    }

    /* Add another NULL at the end of the spec (+ 16 accounts for this) */
    if (idFilterIndex > -1)
        *lpstrFilterSpec = 0;

    if (hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
        hkeyRoot = NULL;
    }

    return idFilterIndex;
}

/* RegCopyClassName() - Returns the ASCII class id from the listbox.
 */
BOOL FAR RegCopyClassName(HWND hwndList, LPSTR lpstrClassName) {
    BOOL    fSuccess = FALSE;
    DWORD   dwSize = 0L;
    HKEY    hkeyTemp;
    char    szClass[KEYNAMESIZE];
    char    szExec[KEYNAMESIZE];
    char    szKey[KEYNAMESIZE];
    char    szName[KEYNAMESIZE];
    int     i;
    int     iWhich;

    iWhich = (int)SendMessage(hwndList, LB_GETCURSEL, 0, 0L);
    SendMessage(hwndList, LB_GETTEXT, iWhich, (DWORD)(LPSTR)szKey);

    RegOpenKey(HKEY_CLASSES_ROOT,NULL,&hkeyRoot);
    for (i = 0; !fSuccess && !RegEnumKey(HKEY_CLASSES_ROOT, i++, szClass, KEYNAMESIZE); )
        if (*szClass != '.') {          /* Not default extension... */

            /* See if this class really refers to a server */
            dwSize = 0;
            hkeyTemp = NULL;
            lstrcpy(szExec, szClass);
            lstrcat(szExec, "\\protocol\\StdFileEditing\\server");

            if (!RegOpenKey(HKEY_CLASSES_ROOT, szExec, &hkeyTemp)) {
                /* ... get the class name string */
                dwSize = KEYNAMESIZE;
                if (!RegQueryValue(HKEY_CLASSES_ROOT, szClass, szName, &dwSize)
                    && !lstrcmp(szName, szKey))
                    fSuccess = TRUE;

                RegCloseKey(hkeyTemp);
            }
        }

    if (fSuccess)
        lstrcpy(lpstrClassName, szClass);

    if (hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
        hkeyRoot = NULL;
    }

    return fSuccess;
}

/* RegGetClassNames() - Fills the list box with possible server names.
 */
BOOL FAR RegGetClassNames(HWND hwndList) {
    BOOL    fSuccess = FALSE;
    DWORD   dwSize = 0L;
    HKEY    hkeyTemp;
    char    szClass[KEYNAMESIZE];
    char    szExec[KEYNAMESIZE];
    char    szName[KEYNAMESIZE];
    int     i;

    SendMessage(hwndList, LB_RESETCONTENT, 0, 0L);

    RegOpenKey(HKEY_CLASSES_ROOT,NULL,&hkeyRoot);
    for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szClass, KEYNAMESIZE); )
        if (*szClass != '.') {          /* Not default extension... */

            /* See if this class really refers to a server */
            dwSize = 0;
            hkeyTemp = NULL;
            lstrcpy(szExec, szClass);
            lstrcat(szExec, "\\protocol\\StdFileEditing\\server");

            if (!RegOpenKey(HKEY_CLASSES_ROOT, szExec, &hkeyTemp)) {
                /* ... get the class name string */
                dwSize = KEYNAMESIZE;
                if (!RegQueryValue(HKEY_CLASSES_ROOT, szClass, szName, &dwSize)) {
                    SendMessage(hwndList, LB_ADDSTRING, 0, (DWORD)(LPSTR)szName);
                    fSuccess = TRUE;
                }
                RegCloseKey(hkeyTemp);
            }
        }

    if (hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
        hkeyRoot = NULL;
    }
    return fSuccess;
}


void ObjUpdateMenuVerbs( HMENU hMenu )
{
    int cObjects;
    extern struct SEL       selCur;
    extern char szOPropMenuStr[];
    extern char szPPropMenuStr[];
    extern BOOL vfOutOfMemory;
    char szBuffer[cchMaxSz];
    char szWordOrder2[10], szWordOrder3[10];

    if (vfOutOfMemory)
    {
        EnableMenuItem(hMenu, EDITMENUPOS, MF_GRAYED|MF_BYPOSITION);
        return;
    }

    LoadString(hINSTANCE, IDSTRPopupVerbs, szWordOrder2, sizeof(szWordOrder2));
    LoadString(hINSTANCE, IDSTRSingleVerb, szWordOrder3, sizeof(szWordOrder3));

    DeleteMenu(hMenu, EDITMENUPOS, MF_BYPOSITION);

/** Cases: 
    0)  0 objects selected
    1)  1 object  selected
        a) object supports 0 verbs          "Edit <Object Class> Object"
        b) object supports more than 1 verb "<Object Class> Object" => verbs
    2)  more than 1 object selected         "Objects"

    Use the VerbMenu strings to determine the order in which these words
    should appear in the menu string (for localization).
**/

    /* how many objects are selected? */
    cObjects = ObjSetSelectionType(docCur,selCur.cpFirst, selCur.cpLim);

    /* must be only an object, not text in selection */
    if (cObjects == 1)
    {
        ObjCachePara(docCur,selCur.cpFirst);
        if (!ObjQueryCpIsObject(docCur,selCur.cpFirst))
            cObjects = 0;
    }

    if ((cObjects == -1) // error
        || (cObjects == 0)
        || (cObjects > 1))
    {
        wsprintf(szBuffer, "%s", (LPSTR)((cObjects > 1) ? szPPropMenuStr : szOPropMenuStr));
        InsertMenu(hMenu, EDITMENUPOS, MF_BYPOSITION,imiVerb,szBuffer);

        /*  
            Spec says if > 1 then optionally should enable if all servers 
            are of the same class.  I'm opting not to implement. (9.27.91) v-dougk
        */
        EnableMenuItem(hMenu, EDITMENUPOS, MF_GRAYED | MF_BYPOSITION);

#if 0
        else // > 1
        {
            EnableMenuItem(hMenu, EDITMENUPOS, 
                (((OBJ_SELECTIONTYPE == EMBEDDED) || (OBJ_SELECTIONTYPE == LINK)) 
                    ? MF_ENABLED : MF_GRAYED) | MF_BYPOSITION);
        }
#endif
        return;
    }
    else // 1 object selected
    {
        OBJPICINFO picInfo;

        /** CASES:
            object supports 0 verbs          "Edit <Object Class> Object"
            object supports more than 1 verb "<Object Class> Object" => verbs
        **/

        RegOpenKey(HKEY_CLASSES_ROOT,NULL,&hkeyRoot);

        GetPicInfo(selCur.cpFirst,selCur.cpFirst + cchPICINFOX, docCur, &picInfo);

        if ((otOBJ_QUERY_TYPE(&picInfo) == EMBEDDED) ||
            (otOBJ_QUERY_TYPE(&picInfo) == LINK))
        {
            HANDLE hData=NULL;
            LPSTR lpstrData;
            OLESTATUS olestat;
  
            olestat = OleGetData(lpOBJ_QUERY_OBJECT(&picInfo), 
                        otOBJ_QUERY_TYPE(&picInfo) == LINK? vcfLink: vcfOwnerLink, 
                        &hData);

            if ((olestat == OLE_WARN_DELETE_DATA) || (olestat == OLE_OK))
            {
                HKEY hKeyVerb;
                DWORD dwSize = KEYNAMESIZE;
                char szClass[KEYNAMESIZE];
                char szVerb[KEYNAMESIZE];
                HANDLE hPopupNew=NULL;

                lpstrData = MAKELP(hData,0);

                /* Both link formats are:  "szClass0szDocument0szItem00" */

                /* get real language class of object in szClass for menu */              
                if (RegQueryValue(HKEY_CLASSES_ROOT, lpstrData, szClass, &dwSize))
                    lstrcpy(szClass, lpstrData);    /* if above call failed */

                if (olestat == OLE_WARN_DELETE_DATA)
                    GlobalFree(hData);

                /* append class key */
                for (vcVerbs=0; ;++vcVerbs)
                {
                    dwSize = KEYNAMESIZE;
                    wsprintf(szBuffer, "%s\\protocol\\StdFileEditing\\verb\\%d", (LPSTR)lpstrData,vcVerbs);
                    if (RegQueryValue(HKEY_CLASSES_ROOT, szBuffer, szVerb, &dwSize))
                        break;

                    if (hPopupNew == NULL)
                        hPopupNew = CreatePopupMenu();

                    InsertMenu(hPopupNew, -1, MF_BYPOSITION, imiVerb+vcVerbs+1, szVerb);
                }

                if (vcVerbs == 0)
                {
                    LoadString(hINSTANCE, IDSTREdit, szVerb, sizeof(szVerb));
                    MakeMenuString(szWordOrder3, szBuffer, szVerb, szClass, szOPropMenuStr);
                    InsertMenu(hMenu, EDITMENUPOS, MF_BYPOSITION, imiVerbPlay, szBuffer);
                }
                else if (vcVerbs == 1)
                {
                    MakeMenuString(szWordOrder3, szBuffer, szVerb, szClass, szOPropMenuStr);
                    InsertMenu(hMenu, EDITMENUPOS, MF_BYPOSITION, imiVerbPlay, szBuffer);
                    DestroyMenu(hPopupNew);
                }
                else // > 1 verbs
                {
                    MakeMenuString(szWordOrder2, szBuffer, NULL, szClass, szOPropMenuStr);
                    InsertMenu(hMenu, EDITMENUPOS, MF_BYPOSITION | MF_POPUP,
                        hPopupNew, szBuffer);
                }
                EnableMenuItem(hMenu, EDITMENUPOS, MF_ENABLED|MF_BYPOSITION);
                if (hkeyRoot)
                {
                    RegCloseKey(hkeyRoot);
                    hkeyRoot = NULL;
                }
                return;
            }
            else
                ObjError(olestat);
        }
    }

    /* error if got to here */
    wsprintf(szBuffer, "%s", (LPSTR)szOPropMenuStr);
    InsertMenu(hMenu, EDITMENUPOS, MF_BYPOSITION,NULL,szBuffer);
    EnableMenuItem(hMenu, EDITMENUPOS, MF_GRAYED|MF_BYPOSITION);
    if (hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
        hkeyRoot = NULL;
    }
}

void NEAR PASCAL MakeMenuString(char *szCtrl, char *szMenuStr, char *szVerb, char *szClass, char *szObject)
{
    char *pStr;
    register char c;

    while (c = *szCtrl++)
    {
        switch(c)
        {
            case 'c': // class
            case 'C': // class
                pStr = szClass;
            break;
            case 'v': // class
            case 'V': // class
                pStr = szVerb;
            break;
            case 'o': // object
            case 'O': // object
                pStr = szObject;
            break;
            default:
                *szMenuStr++ = c;
                *szMenuStr = '\0'; // just in case
            continue;
        }

        if (pStr) // should always be true
        {
            lstrcpy(szMenuStr,pStr);
            szMenuStr += lstrlen(pStr); // point to '\0'
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\pageinfo.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the window proc for the page info window. */

#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#include "fmtdefs.h"
#include "wwdefs.h"

#ifdef  DBCS
#include "kanji.h"
#endif

/* D R A W  M O D E */
DrawMode()
    {
    /* This routine forces the repainting of the page info window. */

    extern HWND vhWndPageInfo;

    InvalidateRect(vhWndPageInfo, (LPRECT)NULL, FALSE);
    UpdateWindow(vhWndPageInfo);
    }




long FAR PASCAL PageInfoWndProc(hWnd, message, wParam, lParam)
HWND      hWnd;
unsigned  message;
WORD      wParam;
LONG      lParam;
    {
    extern HFONT vhfPageInfo;
    extern int ypszPageInfo;
    extern CHAR szMode[];
    extern int dypScrlBar;
    extern struct FLI vfli;
    extern struct WWD rgwwd[];

    if (message == WM_PAINT)
        {
        PAINTSTRUCT ps;

        /* Initialize the DC. */
        BeginPaint(hWnd, (LPPAINTSTRUCT)&ps);

        if (vhfPageInfo == NULL)
            {
            extern char szSystem[];
            LOGFONT lf;
            TEXTMETRIC tm;

            /* Load a font that will fit in the info "window". */
            bltbc(&lf, 0, sizeof(LOGFONT));
#ifdef WIN30
            /* Don't default to ANY ol' typeface ..pault */
            bltsz(szSystem, lf.lfFaceName);
#ifdef  DBCS    /* was in JAPAN; KenjiK ' 90-10-25 */
        /* We use Double Byte Character string,so using font must be
          able to show them. */
	    lf.lfCharSet = NATIVE_CHARSET;
// What this is for ?  Teminal Font is not so good ! -- WJPARK
//            bltbyte ( "Terminal", lf.lfFaceName, LF_FACESIZE);

#endif  /* DBCS */

#endif
            lf.lfHeight = -(dypScrlBar - (GetSystemMetrics(SM_CYBORDER) << 1));
            if ((vhfPageInfo = CreateFontIndirect((LPLOGFONT)&lf)) == NULL)
                {
                goto BailOut;
                }
            if (SelectObject(ps.hdc, vhfPageInfo) == NULL)
                {
                DeleteObject(vhfPageInfo);
                vhfPageInfo = NULL;
                goto BailOut;
                }

            /* Figure out where to draw the string. */
            GetTextMetrics(ps.hdc, (LPTEXTMETRIC)&tm);
#ifdef KOREA	// jinwoo: 92, 9, 28
            // It looks better in Hangeul Windows -- WJPark
            ypszPageInfo = (dypScrlBar - (tm.tmHeight - tm.tmInternalLeading) +
              1) >> 1;
#else
            ypszPageInfo = ((dypScrlBar - (tm.tmHeight - tm.tmInternalLeading) +
              1) >> 1) - tm.tmInternalLeading;
#endif  // KOREA
            }

        /* Draw the "Page nnn" (no longer at the VERY left) */
        PatBlt(ps.hdc, ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right -
          ps.rcPaint.left, ps.rcPaint.bottom - ps.rcPaint.top, PATCOPY);
        TextOut(ps.hdc, GetSystemMetrics(SM_CXBORDER)+5, ypszPageInfo,
          (LPSTR)szMode, CchSz(szMode) - 1);

BailOut:
        EndPaint(hWnd, (LPPAINTSTRUCT)&ps);
        return(0L);
        }
    else if (message == WM_RBUTTONDOWN && vfli.rgdxp[1] == 0xFFFE &&
            wParam & MK_CONTROL )
        {
        (vfli.rgdxp[1])--;
        return(0L);
        }
    else
        {
        /* All we are interested in here are paint messages. */
        return(DefWindowProc(hWnd, message, wParam, lParam));
        }
    }


#ifdef SPECIAL
fnSpecial(hWnd, hDC, rgfp, sz)
HWND hWnd;
HDC hDC;
FARPROC rgfp[];
CHAR sz[];
    {
    RECT rc;
    RECT rcText;
    int dxpLine;
    int dypLine;

        {
        register CHAR *pch = &sz[0];

        while (*pch != '\0')
            {
            *pch = *pch ^ 0x13;
            pch++;
            }
        }
    (*rgfp[0])(hWnd, (LPRECT)&rc);
    rc.right &= 0xFF80;
    rc.bottom &= 0xFF80;
    rcText.right = rc.right - (rcText.left = (rc.right >> 2) + (rc.right >> 3));
    rcText.bottom = rc.bottom - (rcText.top = rc.bottom >> 2);
    (*rgfp[1])(hDC, (LPSTR)sz, -1, (LPRECT)&rcText, DT_CENTER | DT_WORDBREAK);
    dxpLine = rc.right >> 1;
    dypLine = rc.bottom >> 1;
        {
        register int dxp;
        register int dyp;

        for (dxp = dyp = 0; dxp <= dxpLine; dxp += rc.right >> 6, dyp +=
          rc.bottom
          >> 6)
            {
            (*rgfp[2])(hDC, dxpLine - dxp, dyp);
            (*rgfp[3])(hDC, dxp, dyp + dypLine);
            (*rgfp[2])(hDC, dxpLine + dxp, dyp);
            (*rgfp[3])(hDC, rc.right - dxp, dyp + dypLine);
            }
        }
    }
#endif /* SPECIAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\open.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Open.c -- WRITE document opening */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
//#define NOATOM
#define NOBITMAP
#define NOPEN
#define NODRAWTEXT
#define NOCOLOR
#define NOCREATESTRUCT
#define NOHDC
#define NOMETAFILE
#define NOMSG
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOWH
#define NOWINOFFSETS
#define NOSOUND
#define NOCOMM
#define NORESOURCE
#include <windows.h>
#include "mw.h"
#include "doslib.h"
#include "dispdefs.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "fontdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#define NOSTRUNDO
#define NOSTRMERGE
#include "str.h"
#include "code.h"
#include "prmdefs.h"
#include "obj.h"
#define PAGEONLY
#include "printdef.h"   /* printdefs.h */
/*
#include "dlgdefs.h"
*/

    /* These defines replace dlgdefs.h to combat compiler heap overflows */
#define idiYes               IDOK
#define idiNo                3
#define idiCancel            IDCANCEL

    /* These defines replace heapdefs.h and heapdata.h for the same
       irritating reason */
#define cwSaveAlloc         (128)
#define cwHeapMinPerWindow  (50)
#define cwHeapSpaceMin      (60)

/* E X T E R N A L S */

extern CHAR             (**vhrgbSave)[];
extern HANDLE           hParentWw;
extern HANDLE           hMmwModInstance;
extern struct WWD rgwwd[];
extern int wwMac;
extern struct FCB (**hpfnfcb)[];
extern struct DOD (**hpdocdod)[];
extern int docMac;
extern struct WWD *pwwdCur;
extern int fnMac;
extern CHAR stBuf[];
#if WINVER >= 0x300
extern BOOL fError;
#endif


short WCompSzC();
CHAR (**HszCreate())[];
struct FNTB **HfntbCreate();
#ifdef CASHMERE
struct SETB **HsetbCreate();
#else
struct SEP **HsepCreate();
#endif
struct PGTB **HpgtbCreate();


CHAR *PchFromFc( int, typeFC, int * );
CHAR *PchGetPn( int, typePN, int *, int );
typeFC FcMacFromUnformattedFn( int );
int CchReadAtPage( int, typePN, CHAR *, int, int );





struct TBD (**HgtbdCreate(fn))[]
int fn;
{   /* Create a MEMO tab table by reading the properties of the first
       para of the passed fn and returning a handle. The handle returned will
       be 0 if the tab table is not present or null */
struct TBD (**hgtbd)[] = 0;
struct PAP pap;

Assert( (fn != fnNil) && (**hpfnfcb)[fn].fFormatted );

bltc((int *)&pap, 0, cwPAP); /* else we will have garbage tabs */
FcParaLim( fn, (typeFC)cfcPage, (**hpfnfcb)[fn].fcMac, &pap );
if (pap.rgtbd[0].dxa && !FNoHeap( hgtbd = (struct TBD (**)[])HAllocate( cwTBD *
  itbdMax )))
    {
    register struct TBD *ptbd = &pap.rgtbd[0];
    pap.rgtbd[itbdMax - 1].dxa = 0; /* just in case a WORD document has more
                                       than 12 tabs */

/* overwrite tabs and leading tab char that WRITE does not support */
    for ( ; ptbd->dxa != 0; ptbd++)
        {
        ptbd->tlc = tlcWhite;
        ptbd->opcode = 0;
        ptbd->chAlign = 0;
        if (ptbd->jc == jcCenter)
            ptbd->jc = jcLeft;
        else if (ptbd->jc == jcRight)
            ptbd->jc = jcBoth;
        }
    blt( &pap.rgtbd[0], *hgtbd, cwTBD * itbdMax );
    }
return hgtbd;
}



struct SEP **HsepCreate(fn)
int fn;
{   /* Given an fn for a formatted file, return a handle to an SEP
       giving section properties for the file.  Returns NULL if
       standard properties should be used.  If the file has a section
       table, the properties from the first section in the table are used */
extern struct SEP vsepNormal;


struct SETB *psetbFile;
typePN pn;
struct SEP **hsep;
struct SED *psed;
CHAR *pchFprop;
int cch;

Assert(fn != fnNil && (**hpfnfcb)[fn].fFormatted);

if ((pn = (**hpfnfcb)[fn].pnSetb) == (**hpfnfcb)[fn].pnBftb)
        return (struct SEP **) 0;
psetbFile = (struct SETB *) PchGetPn(fn, pn, &cch, false);
if (psetbFile->csed == 0)
        return (struct SEP **)0;

    /* File has a section table; copy properties from first SEP */
hsep = (struct SEP **) HAllocate( cwSEP );
if (FNoHeap( hsep ))
    return (struct SEP **) hOverflow;
blt( &vsepNormal, *hsep, cwSEP );
psed = &psetbFile->rgsed [0];
if (psed->fc == fcNil)
    return (struct SEP **)0;
pchFprop = PchFromFc( fn, psed->fc, &cch );
if (*pchFprop != 0)
    {
    struct SEP *psep = *hsep;

    bltbyte( pchFprop+1, psep, *pchFprop );

#ifndef FIXED_PAGE
    /* Some of the section properties must be adjusted to the current page size
    (stored in vsepNormal). */
    if (psep->xaMac != vsepNormal.xaMac)
        {
        int dxa = vsepNormal.xaMac - psep->xaMac;

        psep->xaMac += dxa;
        psep->dxaText = max(psep->dxaText + dxa, dxaMinUseful);
        psep->xaPgn += dxa;
        }
    if (psep->yaMac != vsepNormal.yaMac)
        {
        int dya = vsepNormal.yaMac - psep->yaMac;

        psep->yaMac += dya;
        psep->dyaText = max(psep->dyaText + dya, dyaMinUseful);
        psep->yaRH2 += dya;
        }
#endif /* not FIXED_PAGE */

    }
return hsep;
} /* end of  H s e p C r e a t e  */




struct PGTB **HpgtbCreate(fn)
int fn;
{ /* Create a page table from a formatted file */
struct PGTB *ppgtbFile;
typePN pn;
int cchT;
int cpgd;
struct PGTB **hpgtb;
int *pwPgtb;
int cw;

Assert(fn != fnNil && (**hpfnfcb)[fn].fFormatted);

if ((pn = (**hpfnfcb)[fn].pnBftb) == (**hpfnfcb)[fn].pnFfntb)
        return (struct PGTB **)0;
ppgtbFile = (struct PGTB *) PchGetPn(fn, pn, &cchT, false);
if ((cpgd = ppgtbFile->cpgd) == 0)
        return (struct PGTB **)0;

hpgtb = (struct PGTB **) HAllocate(cw = cwPgtbBase + cpgd * cwPGD);
if (FNoHeap(hpgtb))
        return (struct PGTB **)hOverflow;

pwPgtb = (int *) *hpgtb;

blt(ppgtbFile, pwPgtb, min(cwSector, cw));

while ((cw -= cwSector) > 0)
        { /* Copy the pgd's to heap */
        blt(PchGetPn(fn, ++pn, &cchT, false), pwPgtb += cwSector,
            min(cwSector, cw));
        }

(*hpgtb)->cpgdMax = cpgd;
return hpgtb;
} /* end of  H p g t b C r e a t e  */




int FnFromSz( sz )  /* filename is expected as ANSI */
CHAR *sz;
{
int fn;
struct FCB *pfcb;

if (sz[0] == 0)
    return fnNil;

/* Mod for Sand: Only return fn if it is on the "current" volume (disk) */
for (fn = 0; fn < fnMac; fn++)
    if ((pfcb = &(**hpfnfcb)[fn])->rfn != rfnFree && (WCompSzC((PCH)sz, (PCH)**pfcb->hszFile) == 0)
#ifdef SAND
                && (pfcb->vref == vrefFile)
#endif /* SAND */
                                           )
        return fn;
return fnNil;
} /* end of  F n F r o m S z  */




int FnOpenSz( szT, dty, fSearchPath )   /* filename is expected as ANSI */
CHAR *szT;
int dty;
int fSearchPath;
{        /* Open an existing file.  Returns fnNil if not found */
int fn;
struct FIB fib;

struct FCB *pfcb;
CHAR (**hsz)[];

CHAR sz[cchMaxFile];

bltsz( szT, sz );
sz[cchMaxFile - 1] = 0;

#ifdef DFILE
CommSzSz("FnOpenSz: sz presumed ANSI = ",sz);
#endif

if (sz[0]=='\0')
    return fnNil;

if ((fn = FnFromSz(sz)) != fnNil)
    {   /* File is already open -- re-open it, in case it was changed by
           another app */
    FreeFn( fn );
    }

if ((fn = FnAlloc()) == fnNil)
    return fnNil;

if (FNoHeap((hsz = HszCreate((PCH)sz))))
    return fnNil;

pfcb = &(**hpfnfcb)[fn];
Assert( !pfcb->fSearchPath );
if (fSearchPath)
    pfcb->fSearchPath = TRUE;
pfcb->mdFile = mdBinary;  /* Try R/W first, will be smashed to RO if needed */
pfcb->dty = pfcb->mdExt = (dty == dtyNormNoExt) ? dtyNormal : dty;
pfcb->hszFile = hsz;

{
OFSTRUCT of;
SetErrorMode(1);
if (OpenFile(sz, (LPOFSTRUCT) &of, OF_EXIST) == -1)
/* this is much cleaner than FAccessFn() for check existance */
{
    char szMsg[cchMaxSz];
    extern int vfInitializing;
    int fT = vfInitializing;

    vfInitializing = FALSE;   /* Report this err, even during inz */
    MergeStrings ((of.nErrCode == dosxSharing) ? IDPMTCantShare:IDPMTCantOpen, sz, szMsg);
    IdPromptBoxSz(vhWndMsgBoxParent ? vhWndMsgBoxParent : hParentWw, szMsg, MB_OK|MB_ICONEXCLAMATION);
    vfInitializing = fT;
    FreeH( (**hpfnfcb) [fn].hszFile);
    return fnNil;
}
}

/* dtyNormNoExt is directed at this call */
if (!FAccessFn( fn, dty ))   /* HM if error */
    {
    FreeH( (**hpfnfcb) [fn].hszFile);
    return fnNil;
    }

/* kludge management (6.21.91) v-dougk */
dty = (dty == dtyNormNoExt) ? dtyNormal : dty;

Assert( (sizeof (struct FIB) == cfcPage) && (cfcPage == cbSector) );
Assert( pfcb == &(**hpfnfcb) [fn] );    /* No HM if FAccessFn succeeds */

if ( (CchReadAtPage( fn, (typePN) 0,
                     (CHAR *) &fib, cbSector, TRUE ) != cbSector) ||
                     (fib.wTool != wMagicTool) )
     
    {                   /* Not a formatted file */
    typeFC fcMac = fc0;
    int cfc;

    if (dty != dtyNormal)
    {
        char szMsg[cchMaxSz];
        PchFillPchId( szMsg, IDPMTBadFile, sizeof(szMsg) );
        if (MessageBox(hPARENTWINDOW, (LPSTR)szMsg,
                        (LPSTR)szAppName, MB_ICONEXCLAMATION|MB_YESNO|MB_DEFBUTTON2) == IDNO)
            goto ErrRet;
        }
    pfcb->fFormatted = false;

        /* Obtain file size by seeking to end-of-file */
    if ((pfcb->fcMac = fcMac = FcMacFromUnformattedFn( fn )) == (typeFC) -1)
            /* Serious error while seeking to file's end */
        goto ErrRet;
    pfcb->pnMac = (fcMac + cfcPage - 1) / cfcPage;
    }
else
    { /* File is formatted; use stored fcMac, create run table */

    if ((((fib.wIdent != wMagic) && (fib.wIdent != wOleMagic)) ||
        (fib.dty != dty)) ||
        // some bigwig media guy sent us a Write file whose fcMac was
        // trashed (all else was OK).  We gotta try to detect this obsure
        // potentiality.
        (fib.fcMac >= (typeFC)fib.pnPara*128 ) || 
        (fib.fcMac >  FcMacFromUnformattedFn( fn ))
        )
        { /* Wrong type of file or corrupted file */
            char szMsg[cchMaxSz];
            PchFillPchId( szMsg, IDPMTBadFile, sizeof(szMsg) );
            if (MessageBox(hPARENTWINDOW, (LPSTR)szMsg,
                        (LPSTR)szAppName, MB_ICONEXCLAMATION|MB_YESNO|MB_DEFBUTTON2) == IDNO)
                goto ErrRet;
        }

    if ((fib.wIdent == wOleMagic) && !fOleEnabled)
        Error(IDPMTFileContainsObjects);

    if (fib.pnMac == (typePN)0)
        /* KLUDGE to load word files, which don't have ffntb entries. */
        fib.pnMac = fib.pnFfntb;

    pfcb->fFormatted = true;
    pfcb->fcMac = fib.fcMac;
#ifdef p2bSector
    pfcb->pnChar = (fib.fcMac + cfcPage - 1) / cfcPage;
#else
    pfcb->pnChar = (fib.fcMac + cfcPage - 1) / cfcPage;
#endif
    pfcb->pnPara = fib.pnPara;
    pfcb->pnFntb = fib.pnFntb;
    pfcb->pnSep = fib.pnSep;

    pfcb->pnSetb = fib.pnSetb;
    pfcb->pnBftb = fib.pnBftb;
    pfcb->pnFfntb = fib.pnFfntb;
    pfcb->pnMac = fib.pnMac;
    if (dty != dtyPrd)
        {
        if (FNoHeap(hsz = HszCreate((PCH)fib.szSsht)))
            goto ErrRet;
        (**hpfnfcb)[fn].hszSsht = hsz;
        if (!FMakeRunTables(fn))
            goto ErrRet;
        }
    }

return fn;

ErrRet:
(pfcb = &(**hpfnfcb)[fn])->rfn = rfnFree;
FreeH(pfcb->hszFile);
return fnNil;
} /* end of  F n O p e n S z  */






/*---------------------------------------------------------------------------
-- Routine: WCompSzC(psz1,psz2)
-- Description and Usage:
    Alphabetically compares the two null-terminated strings psz1 and  psz2.
    Upper case alpha characters are mapped to lower case.
    Comparison of non-alpha characters is by ascii code.
    Returns 0 if they are equal, a negative number if psz1 precedes psz2, and
    a non-zero positive number if psz2 precedes psz1.
-- Arguments:
    psz1, psz2    - pointers to two null-terminated strings to compare
-- Returns:
    a short - 0 if strings are equal, negative number if psz1 precedes psz2,
    and non-zero positive number if psz2 precedes psz1.
-- Side-effects: none
-- Bugs:
-- History:
    3/14/83 - created (tsr)
----------------------------------------------------------------------------*/
short
WCompSzC(psz1,psz2)
PCH psz1;
PCH psz2;
{
    int ch1;
    int ch2;

    for(ch1=ChLowerC(*psz1++),ch2=ChLowerC(*psz2++);
      ch1==ch2;
    ch1=ChLowerC(*psz1++),ch2=ChLowerC(*psz2++))
    {
    if(ch1 == '\0')
        return(0);
    }
    return(ch1-ch2);
} /* end of  W C o m p S z C  */

/*---------------------------------------------------------------------------
-- Routine: ChLowerC(ch)
-- Description and Usage:
    Converts its argument to lower case iff its argument is upper case.
    Returns the de-capitalized character or the initial char if it wasn't caps.
-- Arguments:
    ch      - character to be de-capitalized
-- Returns:
    a character - initial character, de-capitalized if needed.
-- Side-effects:
-- Bugs:
-- History:
    3/14/83 - created (tsr)
----------------------------------------------------------------------------*/
int
ChLowerC(ch)
register CHAR    ch;
{
    if(isupper(ch))
        return(ch + ('a' - 'A')); /* foreign is taken care of */
    else
        return ch;
} /* end of  C h L o w e r C  */

#ifdef JAPAN
// Compare ch with halfsize-KANA code range, then return whether it is or not.
BOOL IsKanaInDBCS(int ch)
{
	ch &= 0x00ff;
	if(ch>=0xA1 && ch <= 0xDF)	return	TRUE;
	else						return	FALSE;
}
#endif





typeFC (**HgfcCollect(fn, pnFirst, pnLim))[]
typePN pnFirst, pnLim;
{    /* Create a table indexing fc's by fkp number */
    typeFC fcMac;
    typePN pn;
    int ifcMac, ifc;
    typeFC (**hgfc)[];

    struct FKP fkp;

    fcMac = (**hpfnfcb)[fn].fcMac;
    pn = pnFirst + 1;
    ifcMac = ifcMacInit; /* Length of table */
    hgfc = (typeFC (**)[])HAllocate((ifcMacInit * sizeof(typeFC)) / sizeof(int));
    if (FNoHeap(hgfc))
        return (typeFC (**)[])hOverflow;

    for (ifc = 0; ; ++ifc, ++pn)
        { /* Put first fcLim of each fkp in table */
        if (ifc >= ifcMac)
            { /* Must grow table */
            int cw = ((ifcMac += ifcMacInit) * sizeof (typeFC)) / sizeof(int);
            if (!FChngSizeH(hgfc, cw, false))
                {
LHFGCErrRet:
                FreeH(hgfc);
                return (typeFC (**)[])hOverflow;
                }
            }
        if (pn < pnLim)
            { /* Get fcLimFkb from fcFirst of next page */
            int cch;

            cch = CchReadAtPage( fn, pn, (CHAR *) &fkp, cbSector, TRUE );
            if (cch != cfcPage)
                goto LHFGCErrRet;
            (**hgfc)[ifc] = fkp.fcFirst;
            }
        else
            { /* fcLimFkb is fcMac + 1 */
            (**hgfc)[ifc] = fcMac + 1;
            if (!FChngSizeH(hgfc, ((ifc + 1) * sizeof(typeFC)) / sizeof(int), true))
                {
                /* Previously ignored bad return value here ..pault 11/3/89 */
                goto LHFGCErrRet;
                }
            return hgfc;
            }
        }
} /* end of  H g f c C o l l e c t  */




/* F  M A K E  R U N  T A B L E S */
int FMakeRunTables(fn)
{ /* Create two tables of fc-dpn pairs, one for chr's and one for par's */
    typeFC (**hgfc)[];

    if (FNoHeap(hgfc = HgfcCollect(fn, (**hpfnfcb)[fn].pnChar, (**hpfnfcb)[fn].pnPara)))
        return false;
    (**hpfnfcb)[fn].hgfcChp = hgfc;
    if (FNoHeap(hgfc = HgfcCollect(fn, (**hpfnfcb)[fn].pnPara, (**hpfnfcb)[fn].pnFntb)))
        {
        FreeH( (**hpfnfcb) [fn].hgfcChp );
        return false;
        }
    (**hpfnfcb)[fn].hgfcPap = hgfc;
    return true;
} /* end of  F M a k e R u n T a b l e  */



FApplyOldWordSprm(doc)
/* applies a sprm to this doc which causes all "old word" fonts to be remapped
   into new windows ones */
{
CHAR rgbSprm[7];
extern int vfSysFull;

/* set up the OldFtc sprm mapping */
rgbSprm[0] = sprmCOldFtc;
rgbSprm[1] = 5;

rgbSprm[2 + iftcModern] = FtcScanDocFfn(doc, PffnDefault(FF_MODERN));
rgbSprm[2 + iftcRoman] = FtcScanDocFfn(doc, PffnDefault(FF_ROMAN));
rgbSprm[2 + iftcScript] = FtcScanDocFfn(doc, PffnDefault(FF_SCRIPT));
rgbSprm[2 + iftcDecorative] = FtcScanDocFfn(doc, PffnDefault(FF_DECORATIVE));
rgbSprm[2 + iftcSwiss] = FtcScanDocFfn(doc, PffnDefault(FF_SWISS));

AddSprmCps(rgbSprm, doc, (typeCP)0, (**hpdocdod)[doc].cpMac);
return(vfSysFull == 0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\preload.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*----------------TASK ENUMERATED TYPE FOR CODE PRELOAD-----------------*/

#define tskMin      0
#define tskMax      3

#define tskInsert   0   /* Insert, backspace, cursoring */
#define tskFormat   1   /* Char dropdown, formatting, fonts */
#define tskScrap    2   /* Edit dropdown, cut/paste, clipboard */

/*----------------------------------------------------------------------*/

void PreloadCodeTsk( int );

/* Macros for function preloading */

#define LoadWindowsF(f)      GetCodeHandle( (FARPROC) f )
#define LoadF(f)             {  int f();  GetCodeHandle( (FARPROC) f );  }

#define LCBAVAIL             0x00030D40 /* 200K */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\picture2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* picture2.c -- MW format and display routines for pictures */

//#define NOGDICAPMASKS
#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
//#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOFONT
#define NOMB
#define NOMENUS
#define NOOPENFILE
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "fmtdefs.h"
#include "dispdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "stcdefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#include "editdefs.h"
/* #include "str.h" */
#include "prmdefs.h"
/* #include "fkpdefs.h" */
/* #include "macro.h" */
#include "winddefs.h"
#if defined(OLE)
#include "obj.h"
#endif

extern typeCP           cpMacCur;
extern int              docCur;
extern int              vfSelHidden;
extern struct WWD       rgwwd[];
extern int              wwCur;
extern int              wwMac;
extern struct FLI       vfli;
extern struct SEL       selCur;
extern struct WWD       *pwwdCur;
extern struct PAP       vpapCache;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern int              vfPictSel;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern struct SEP       vsepPage;
extern struct DOD       (**hpdocdod)[];
extern unsigned         cwHeapFree;
extern int              vfInsertOn;
extern int              vfPMS;
extern int              dxpLogInch;
extern int              dypLogInch;
extern int              dxaPrPage;
extern int              dyaPrPage;
extern int              dxpPrPage;
extern int              dypPrPage;
extern HBRUSH           hbrBkgrnd;
extern long             ropErase;
extern int              vdocBitmapCache;
extern typeCP           vcpBitmapCache;
extern HBITMAP          vhbmBitmapCache;
extern HCURSOR          vhcIBeam;


/* Used in this module only */
#ifdef DEBUG
#define STATIC static
#else
#define STATIC
#endif


/* (windows naming convention for func name, not Hung.) */

long GetBitmapMultipliers( hDC, dxpOrig, dypOrig, dxmmIdeal, dymmIdeal )
HDC hDC;
int dxpOrig, dypOrig;
int dxmmIdeal, dymmIdeal;
{   /* Return the "best" integer bit-multiples to use when displaying a bitmap
       of size { dxpOrig, dypOrig } (in pixels) on device DC hDC.
       The "ideal size" of the bitmap is { dxmmIdeal, dymmIdeal } (in 0.1mm units);
       this conveys the desired aspect ratio as well.
       Returns the y-multiplier in the hi word, the x-multiplier in the lo word.
       Default/error value returned is { 1, 1 }. */

 typedef unsigned long ul;

 long lT;
 int cx, cy;
 int cxBest, cyBest;
 int dcx=1, dcy=1;
 int dxpT, dypT;
 int dxmmOrig, dymmOrig;
 int dxmmDevice = GetDeviceCaps( hDC, HORZSIZE ) * 10;
 int dymmDevice = GetDeviceCaps( hDC, VERTSIZE ) * 10;
 int dxpDevice = GetDeviceCaps( hDC, HORZRES );
 int dypDevice = GetDeviceCaps( hDC, VERTRES );
 int cxMac, cyMac;
 int pctAspectBest, pctSizeBest;

 /* Compute scale factor (dcx, dcy, our minimum scale multiple) */

 if (GetDeviceCaps( hDC, RASTERCAPS ) & RC_SCALING)
    {
    POINT pt;

    pt.x = pt.y = 0;   /* Just in case */
    Escape( hDC, GETSCALINGFACTOR, 0, (LPSTR) NULL, (LPSTR) (LPPOINT) &pt );
    dcx = 1 << pt.x;
    dcy = 1 << pt.y;
    }

 /* Compute size of unscaled picture on hDC in 0.1 mm units */

 if (dxpDevice <= 0 || dypDevice <= 0)
    goto Error;

 dxmmOrig = MultDiv( dxpOrig, dxmmDevice, dxpDevice );
 dymmOrig = MultDiv( dypOrig, dymmDevice, dypDevice );

 /* Ideal size not supplied; return 1,1 (times device multipliers) */

 if (dxmmIdeal <= 0 || dymmIdeal <= 0)
    {
    goto Error;
    }

 /* Compute absolute maximums for cx, cy */
 /* 2nd term of min restricts search space by refusing to consider
    more tham one size above the ideal */

 if (dxmmOrig <= 0 || dymmOrig <= 0)
    goto Error;

 cxMac = min ( (dxmmDevice / dxmmOrig) + 1, (dxmmIdeal / dxmmOrig) + 2 );
 cyMac = min ( (dymmDevice / dymmOrig) + 1, (dymmIdeal / dymmOrig) + 2 );

 /* Search all possible multiplies to see what would be best */

 cxBest = dcx;
 cyBest = dcy;
 pctAspectBest = pctSizeBest = 32767;

 for ( cx = dcx ; cx < cxMac; cx += dcx )
    for ( cy = dcy ; cy < cyMac; cy += dcy )
        {
        int dxmm = dxmmOrig * cx;
        int dymm = dymmOrig * cy;
        int pctAspect = PctDiffUl( (ul) dxmmIdeal * (ul) dymm,
                                   (ul) dymmIdeal * (ul) dxmm );
        int pctSize = PctDiffUl( (ul) dxmmIdeal * (ul) dymmIdeal,
                                 (ul)dxmm * (ul)dymm );

        /* ??? Strategy for loss on one, gain on the other ??? */

        if (pctAspect <= pctAspectBest && pctSize <= pctSizeBest )
            {
            cxBest = cx;
            cyBest = cy;
            pctAspectBest = pctAspect;
            pctSizeBest = pctSize;
            }
        }

 Assert( cxBest > 0 && cyBest > 0 );

 return MAKELONG( cxBest, cyBest );

Error:
 return MAKELONG( dcx, dcy );
}



int PctDiffUl( ul1, ul2 )
unsigned long ul1, ul2;
{   /* Return a number that is proportional to the percentage
       of difference between the two numbers */
    /* Will not work for > 0x7fffffff */

#define dulMaxPrec  1000     /* # of "grains" of response possible */

unsigned long ulAvg = (ul1 >> 1) + (ul2 >> 1);
unsigned long ulDiff = (ul1 > ul2) ? ul1 - ul2 : ul2 - ul1;

if (ulAvg == 0)
    return (ul1 == ul2) ? 0 : dulMaxPrec;

if (ulDiff > 0xFFFFFFFF / dulMaxPrec)
    return dulMaxPrec;

return (int) ((ulDiff * dulMaxPrec) / ulAvg);
}


int PxlConvert( mm, val, pxlDeviceRes, milDeviceRes )
int mm;
int val;
int pxlDeviceRes;
int milDeviceRes;
{   /* Return the # of pixels spanned by val, a measurement in coordinates
       appropriate to mapping mode mm.  pxlDeviceRes gives the resolution
       of the device in pixels, along the axis of val. milDeviceRes gives
       the same resolution measurement, but in millimeters.
       returns 0 on error */
 typedef unsigned long ul;

 ul ulMaxInt = 32767L;   /* Should be a constant, but as of 7/12/85,
                           CMERGE generates incorrect code for the
                           ul division if we use a constant */
 ul ulPxl;
 ul ulDenom;
 unsigned wMult=1;
 unsigned wDiv=1;


    if (milDeviceRes == 0)
        {   /* to make sure we don't get divide-by-0 */
        return 0;
        }

    switch ( mm ) {
        case MM_LOMETRIC:
            wDiv = 10;
            break;
        case MM_HIMETRIC:
            wDiv = 100;
            break;
        case MM_TWIPS:
            wMult = 25;
            wDiv = 1440;
            break;
        case MM_LOENGLISH:
            wMult = 25;
            wDiv = 100;
            break;
        case MM_HIENGLISH:
            wMult = 25;
            wDiv = 1000;
            break;
        case MM_BITMAP:
        case MM_OLE:
        case MM_TEXT:
            return val;
        default:
            Assert( FALSE );        /* Bad mapping mode */
        case MM_ISOTROPIC:
        case MM_ANISOTROPIC:
                /* These picture types have no original size */
            return 0;
    }

/* Add Denominator - 1 to Numerator, to avoid rounding down */

 ulDenom = (ul) wDiv * (ul) milDeviceRes;
 ulPxl = ((ul) ((ul) wMult * (ul) val * (ul) pxlDeviceRes) + ulDenom - 1) /
         ulDenom;

 return (ulPxl > ulMaxInt) ? 0 : (int) ulPxl;
}




/* F O R M A T  G R A P H I C S */
FormatGraphics(doc, cp, ichCp, cpMac, flm)
int     doc;
typeCP  cp;
int     ichCp;
typeCP  cpMac;
int     flm;
{       /* Format a line of graphics  */
        CHAR rgch[10];
        int cch;
        int dypSize;
        int dxpSize;
        int dxaText;
        int dxa;
        struct PICINFOX  picInfo;
        int fPrinting = flm & flmPrinting;

        GetPicInfo(cp, cpMac, doc, &picInfo);

        /* Compute the size of the pict in device pixels */

        if (picInfo.mfp.mm == MM_BITMAP && ((picInfo.dxaSize == 0) ||
                                            (picInfo.dyaSize == 0)))
            {
            GetBitmapSize( &dxpSize, &dypSize, &picInfo, fPrinting);
            }
#if defined(OLE)
        else if (picInfo.mfp.mm == MM_OLE)
        {
            dxpSize = DxpFromDxa( picInfo.dxaSize, fPrinting );
            dypSize = DypFromDya( picInfo.dyaSize, fPrinting );
            dxpSize = MultDiv( dxpSize, picInfo.mx, mxMultByOne );
            dypSize = MultDiv( dypSize, picInfo.my, myMultByOne );
        }
#endif
        else
            {
            dxpSize = DxpFromDxa( picInfo.dxaSize, fPrinting );
            dypSize = DypFromDya( picInfo.dyaSize, fPrinting );
            }

        if (fPrinting)
                {
                /* If we are printing, then the picture consists of a single
                band. */
                vfli.cpMac = vcpLimParaCache;
                vfli.ichCpMac = 0;
                vfli.dypLine = dypSize;
                }
        else if ((ichCp + 2) * dypPicSizeMin > dypSize)
                {
                /* Last band of picture.  NOTE: last band is always WIDER than
                dypPicSizeMin */
                vfli.cpMac = vcpLimParaCache;
                vfli.ichCpMac = 0;

#ifdef CASHMERE
                vfli.dypLine = dypSize - max(0, dypSize / dypPicSizeMin - 1) *
                        dypPicSizeMin + DypFromDya( vpapAbs.dyaAfter, FALSE );
#else /* not CASHMERE */
                vfli.dypLine = dypSize - max(0, dypSize / dypPicSizeMin - 1) *
                        dypPicSizeMin;
#endif /* not CASHMERE */

                }
        else
                {
                vfli.ichCpMac = vfli.ichCpMin + 1;
                vfli.cpMac = vfli.cpMin;
                vfli.dypLine = dypPicSizeMin;
                }

#ifdef CASHMERE
        if (ichCp == 0) /* Add in the 'space before' field. */
                {
                vfli.dypLine += DypFromDya( vpapAbs.dyaBefore, fPrinting );
                }
#endif /* CASHMERE */

        vfli.dypFont = vfli.dypLine;

        dxaText = vsepAbs.dxaText;

        switch (vpapAbs.jc)
                {
        case jcLeft:
        case jcBoth:
                dxa = picInfo.dxaOffset;
                break;
        case jcCenter:
                dxa = (dxaText - (int)vpapAbs.dxaRight + (int)vpapAbs.dxaLeft -
                                DxaFromDxp( dxpSize, fPrinting )) >> 1;
                break;
        case jcRight:
                dxa = dxaText - (int)vpapAbs.dxaRight -
                                DxaFromDxp( dxpSize, fPrinting );
                break;
                }

        vfli.xpLeft = DxpFromDxa( max( (int)vpapAbs.dxaLeft, dxa ), fPrinting );
#ifdef BOGUSBL
        vfli.xpReal = imin( dxpSize + vfli.xpLeft,
                            DxpFromDxa( dxaText - vpapAbs.dxaRight, fPrinting );
#else   /* Don't crunch the picture to fit the margins */
        vfli.xpReal = dxpSize + vfli.xpLeft;
#endif
        vfli.fGraphics = true;
}

GetPicInfo(cp, cpMac, doc, ppicInfo)
typeCP  cp, cpMac;
int     doc;
struct PICINFOX  *ppicInfo;
{   /* Fetch the header structure for a picture at cp into *ppicInfo.
       Supports the OLD file format (which used cbOldSize); always returns
       the NEW PICINFO structure. */
int     cch;

FetchRgch(&cch, ppicInfo, doc, cp, cpMac, cchPICINFOX);

if (ppicInfo->mfp.mm & MM_EXTENDED)
    {
    ppicInfo->mfp.mm &= ~MM_EXTENDED;
    }
 else
    {   /* Old file format -- fill out extended fields */
    ppicInfo->cbSize = ppicInfo->cbOldSize;
    ppicInfo->cbHeader = cchOldPICINFO;
    }

 /* Fill in defaults for extended fields that are not present in the file */
 /* These are:  mx, my      Added 9/19/85 by bryanl */

 if (BStructMember( PICINFOX, my ) >= ppicInfo->cbHeader )
    {   /* Scaling multipliers not present */
    ppicInfo->mx = mxMultByOne;
    ppicInfo->my = myMultByOne;
    }

  if (ppicInfo->dyaSize < 0)
  /* 3.1 beta III bug, wrote negative height values */
{
    ppicInfo->dyaSize = -ppicInfo->dyaSize;
#ifdef DEBUG
    OutputDebugString("Negative object height found!\n\r");
#endif
}
}




GetBitmapSize( pdxp, pdyp, ppicInfo, fPrinting )
int *pdxp, *pdyp;
struct PICINFOX *ppicInfo;
int fPrinting;
{   /* Compute the appropriate display or printing (depending on fPrinting)
       size of the bitmap described by the passed PICINFOX structure.
       The interesting fields are:

       ppicInfo->bm.bmWidth, bmHeight   Bitmap size in pixels
       ppicInfo->mfp.xExt, yExt         Desired size in 0.1 mm
       Return the results through *pdxp, *pdyp. */

 long GetBitmapMultipliers();
 extern HDC vhDCPrinter;
 extern int dxaPrPage, dxpPrPage, dyaPrPage, dypPrPage;

 long lT;
 int cx, cy;
 int dxpT, dypT;
 int dxpOrig = ppicInfo->bm.bmWidth;
 int dypOrig = ppicInfo->bm.bmHeight;
 int dxmmIdeal = ppicInfo->mfp.xExt;
 int dymmIdeal = ppicInfo->mfp.yExt;
 Assert(vhDCPrinter);

 /* Scale for printer */

 lT = GetBitmapMultipliers( vhDCPrinter, dxpOrig, dypOrig, dxmmIdeal, dymmIdeal );
 cx = LOWORD( lT );
 cy = HIWORD( lT );
 dxpT = cx * dxpOrig;
 dypT = cy * dypOrig;

 if (!fPrinting)
    {   /* Re-scale for screen */
    dxpT = DxpFromDxa( DxaFromDxp( dxpT, TRUE ), FALSE );
    dypT = DypFromDya( DyaFromDyp( dypT, TRUE ), FALSE );
    }

 /* apply the user's "ideal multiple" of the computed size */

 dxpT = MultDiv( dxpT, ppicInfo->mx, mxMultByOne );
 dypT = MultDiv( dypT, ppicInfo->my, myMultByOne );

 *pdxp = dxpT;
 *pdyp = dypT;
 return;
}


int DxpFromDxa( dxa, fPrinter )
int dxa;
int fPrinter;
{       /* Given twips for an x-axis measurement, return printer
           or logical screen pixels */
 extern int dxpPrPage, dxaPrPage;
 extern int dxpLogInch;

 if (fPrinter)
    return MultDiv( dxa, dxpPrPage, dxaPrPage );
 else
    return MultDiv( dxa, dxpLogInch, czaInch );
}




int DxaFromDxp( dxp, fPrinter )
int dxp;
int fPrinter;
{       /* Given printer or logical screen pixels for an x-axis measurement,
           return twips */
 extern int dxpPrPage, dxaPrPage;
 extern int dxpLogInch;

 if (fPrinter)
    return MultDiv( dxp, dxaPrPage, dxpPrPage );
 else
    return MultDiv( dxp, czaInch, dxpLogInch );
}


int DypFromDya( dya, fPrinter )
int dya;
int fPrinter;
{   /* Given twips for a y-axis measurement, return printer or logical screen
       pixels */
 extern int dypPrPage, dyaPrPage;
 extern int dypLogInch;

 if (fPrinter)
    return MultDiv( dya, dypPrPage, dyaPrPage );
 else
    return MultDiv( dya, dypLogInch, czaInch );
}

int DyaFromDyp( dyp, fPrinter )
int dyp;
int fPrinter;
{   /* Given printer or logical screen pixels for a y-axis measurement,
       return twips */
 extern int dypPrPage, dyaPrPage;
 extern int dypLogInch;

 if (fPrinter)
    return MultDiv( dyp, dyaPrPage, dypPrPage );
 else
    return MultDiv( dyp, czaInch, dypLogInch );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\print.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the printing routines. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOFONT
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "str.h"
#include "printdef.h"
#include "fmtdefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "dlgdefs.h"
#include "debug.h"
#include "fontdefs.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef INEFFLOCKDOWN
    extern FARPROC lpDialogCancelPrint;
    extern FARPROC lpFPrContinue;
#else
    extern BOOL far PASCAL DialogCancelPrint(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL FPrContinue(HDC, int);
    FARPROC lpFPrContinue;
#endif

BOOL fPrinting;

PrintDoc(doc, fPrint)
int doc;
BOOL fPrint;
    {
    /* This routine formats the document, doc, for printing and prints it if
    fPrint is TRUE. */

    BOOL FInitHeaderFooter(BOOL, unsigned *, struct PLD (***)[], int *);
    BOOL FSetPage(void);
    BOOL FPromptPgMark(typeCP);
    BOOL FPrintBand(int, struct PLD (**)[], int, PRECT);

    extern BOOL vbCollate;
    extern HDC vhDCPrinter;
    extern HWND hParentWw;
    extern HANDLE hMmwModInstance;
    extern struct DOD (**hpdocdod)[];
    extern int vpgn;
    extern struct SEP vsepAbs;
    extern typeCP vcpFirstParaCache;
    extern typeCP vcpLimParaCache;
    extern typeCP cpMinCur;
    extern typeCP cpMinDocument;
    extern struct FLI vfli;
    extern int wwCur;
    extern int docMode;
    extern int vdocPageCache;
    extern int dxaPrPage;
    extern int dyaPrPage;
    extern int dxpPrPage;
    extern int dypPrPage;
    extern int dxaPrOffset;
    extern int dyaPrOffset;
    extern CHAR szMode[30];
    extern int vfRepageConfirm;
    extern int vfPrPages;           /* true if print page range */
    extern int vpgnBegin;           /* starting page number to print */
    extern int vpgnEnd;             /* ending page number to print */
    extern int vcCopies;            /* nubmer of copies to print */
    extern int vfOutOfMemory;
    extern BOOL vfPrinterValid;
    extern BOOL vfPrErr;
    extern BOOL vfDraftMode;
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];
    extern CHAR *vpDlgBuf;
    extern HWND vhWndCancelPrint;
    extern HCURSOR vhcArrow;
    extern HCURSOR vhcIBeam;

    LONG lHolder;
    int CopyIncr;   /* number of copies the printer can print at a time */
    typeCP cp;
    typeCP cpMin;
    typeCP cpMac;
    int ichCp;
    struct PGD *ppgd;
    struct PGTB **hpgtbOld;
    int cpld;
    unsigned pgnFirst;
    unsigned pgnFirstHeader;
    unsigned pgnFirstFooter;
    int ypTop;
    int ypBottom;
    int xpLeft;
    struct PLD (**hrgpldHeader)[];
    struct PLD (**hrgpldFooter)[];
    int cpldHeader;
    int cpldFooter;
    int cCopies,cCollateCopies;
    BOOL fConfirm = !fPrint && vfRepageConfirm;
    BOOL fSplat;
    CHAR stPage[cchMaxIDSTR];
    struct PDB pdb;
    int iEscape;
#ifndef INEFFLOCKDOWN
    FARPROC lpDialogCancelPrint = MakeProcInstance(DialogCancelPrint, hMmwModInstance);
    lpFPrContinue = MakeProcInstance(FPrContinue, hMmwModInstance);

    if (!lpDialogCancelPrint || !lpFPrContinue)
        goto MemoryAbort;
#endif

    Assert(vhDCPrinter != NULL);

    /* If we are out of memory, we better bail out now. */
    if (vfOutOfMemory || vhDCPrinter == NULL)
    {
    return;
    }

    /* Disable all other windows. */
    EnableWindow(hParentWw, FALSE);
    EnableOtherModeless(FALSE);

    fPrinting = fPrint;

    /* Set some flags associated with printing. */
    vfPrErr = pdb.fCancel = FALSE;

    /* Set up the print dialog buffer for the repagination or cancellation
    dialog boxes. */
    vpDlgBuf = (CHAR *)&pdb;

    if (fConfirm)
        {
    /* Reassure the user that we haven't crashed. */
    StartLongOp();
    }
    else
    {
        /* Bring up the dialog box telling the user how to cancel printing or
        repagination. */
        if ((vhWndCancelPrint = CreateDialog(hMmwModInstance, fPrint ?
          MAKEINTRESOURCE(dlgCancelPrint) : MAKEINTRESOURCE(dlgCancelRepage),
          hParentWw, lpDialogCancelPrint)) == NULL)
            {
MemoryAbort:
        /* Inform the user we cannot print because of a memory failure. */
        Error(IDPMTPRFAIL);
        vfPrErr = TRUE;
        goto Abort;
            }

    /* Immediately halt if the user requests. */
    if (!(*lpFPrContinue)(NULL, wNotSpooler))
        {
        goto Abort;
        }
    }

    if (fPrint)
    {
    /* Get the latest printer DC, in case it has changed. */
    FreePrinterDC();
    GetPrinterDC(TRUE);
    if (!vfPrinterValid)
        {
        goto MemoryAbort;
        }
    }

    /* If we are printing or repaginating without confirmation, then
    immediately halt if the user requests. */
    if (!fConfirm && !(*lpFPrContinue)(NULL, wNotSpooler))
    {
    goto Abort;
    }

#if defined(OLE)
    /*
        Load all OLE objects now because loading them
        can cause changes in doc layout.
    */
    {
        OBJPICINFO picInfo;
        typeCP cpStart=cpNil,cpMac= CpMacText(doc);
        struct SEL selSave = selCur;
        BOOL bAbort=FALSE,bSetMode=FALSE;

        while (ObjPicEnumInRange(&picInfo,doc,cpMinDocument, cpMac, &cpStart))
        {
            if (lpOBJ_QUERY_INFO(&picInfo) == NULL)
            {
                Error(IDPMTCantPrint);
                bAbort=TRUE;
                break;
            }

            if (lpOBJ_QUERY_OBJECT(&picInfo) == NULL)
            {
                /* put message in status window */
                if (!bSetMode)
                {
                    LoadString(hMmwModInstance, IDSTRLoading, szMode, sizeof(szMode));
                    DrawMode();
                    bSetMode=TRUE;
                }

                if (ObjLoadObjectInDoc(&picInfo,doc,cpStart) == cp0)
                {
                    bAbort=TRUE;
                    break;
                }
            }

            if (!(*lpFPrContinue)(NULL, wNotSpooler))
            {
                bAbort=TRUE;
                break;
            }
        }
        Select(selSave.cpFirst,selCur.cpLim); // reset
        if (bAbort)
        {
            /* Invalidate the mode so will redraw */
            docMode = docNil;
            goto Abort;
        }
    }
#endif
    /* Initialize the array of print line descriptors. */
    if (FNoHeap(pdb.hrgpld = (struct PLD (**)[])HAllocate((cpld = cpldInit) *
      cwPLD)))
        {
        goto MemoryAbort;
        }

    /* Get the document properties and set up some local variables. */
    CacheSect(doc, cpMin = cpMinDocument);
    cpMac = CpMacText(doc);
    ypTop = MultDiv(vsepAbs.yaTop - dyaPrOffset, dypPrPage, dyaPrPage);
    ypBottom = MultDiv(vsepAbs.yaTop + vsepAbs.dyaText - dyaPrOffset, dypPrPage,
      dyaPrPage);
    xpLeft = MultDiv(vsepAbs.xaLeft - dxaPrOffset, dxpPrPage, dxaPrPage);
    vdocPageCache = docNil;

    /* Initialize the page table. */
    if (FNoHeap(pdb.hpgtb = (struct PGTB **)HAllocate(cwPgtbBase + cpgdChunk *
      cwPGD)))
        {
        /* Not enough memory for page table; time to bail out. */
        FreeH(pdb.hpgtb);
        goto MemoryAbort;
        }
    (**pdb.hpgtb).cpgdMax = cpgdChunk;
    (**pdb.hpgtb).cpgd = 1;
    ppgd = &((**pdb.hpgtb).rgpgd[0]);
    ppgd->cpMin = cpMin;
    if ((pgnFirst = vsepAbs.pgnStart) == pgnNil)
        {
        pgnFirst = 1;
        }
    ppgd->pgn = pgnFirst;

    /* Ensure that szMode says "Page ". */
    FillStId(stPage, IDSTRChPage, sizeof(stPage));
#if !defined(KOREA)
    stPage[1] = ChUpper(stPage[1]);
    stPage[stPage[0] + 1] = ' ';
    bltbyte(&stPage[1], szMode, ++stPage[0]);
#endif

    /* Attatch the new page table to the document. */
        {
        register struct DOD *pdod = &(**hpdocdod)[doc];

        hpgtbOld = pdod->hpgtb;
        pdod->hpgtb = pdb.hpgtb;
        }

    /* Set cpMinCur to cp0 for the duration of the print. */
    Assert(cpMinCur == cpMinDocument);
    cpMinCur = cp0;

    /* If we are printing or repaginating without confirmation, then
    immediately halt if the user requests. */
    if (!fConfirm && !(*lpFPrContinue)(NULL, wNotSpooler))
    {
    goto ErrorNoAbort;
    }

    if (fPrint)
        {
        CHAR stTitle[cchMaxIDSTR];

        /* Set up the variables that describe the header. */
        if (!FInitHeaderFooter(TRUE, &pgnFirstHeader, &hrgpldHeader,
          &cpldHeader))
            {
        Error(IDPMTPRFAIL);
            goto ErrorNoAbort;
            }

        /* Set up the variables that describe the footer. */
        if (!FInitHeaderFooter(FALSE, &pgnFirstFooter, &hrgpldFooter,
          &cpldFooter))
            {
        Error(IDPMTPRFAIL);
            goto ErrorNoAbort;
            }

        /* Set the name of the function called to query whether the print should
    be aborted. */
        Escape(vhDCPrinter, SETABORTPROC, sizeof(FARPROC), (LPSTR)lpFPrContinue,
      (LPSTR)NULL);

        /* Set the printer into draft mode if necessary. */
        if (vfDraftMode)
            {
            Escape(vhDCPrinter, DRAFTMODE, sizeof(BOOL), (LPSTR)&vfDraftMode,
              (LPSTR)NULL);
            }

        /* Inform the spooler that we are about to print. */
        stTitle[0] = GetWindowText(hParentWw, (LPSTR)&stTitle[1],
          sizeof(stTitle) - 1) + 1;
        if ((iEscape = Escape(vhDCPrinter, STARTDOC, stTitle[0],
      (LPSTR)&stTitle[1], (LPSTR)NULL)) < 0)
        {
ErrorSwitch:
        switch (iEscape)
        {
        default:
        if ((iEscape & SP_NOTREPORTED) == 0)
            {
            break;
            }
        case SP_ERROR:
        Error(IDPMTCantPrint);
        break;

        case SP_APPABORT:
        case SP_USERABORT:
        break;

        case SP_OUTOFDISK:
        Error(IDPMTPrDiskErr);
        break;

        case SP_OUTOFMEMORY:
        Error(IDPMTPRFAIL);
        break;
        }
            goto ErrorNoAbort;
            }
        }
#ifdef DPRINT
CommSzSz("Start doc", "");
#endif

    /* If we are printing or repaginating without confirmation, then
    immediately halt if the user requests. */
    if (!fConfirm && !(*lpFPrContinue)(NULL, wNotSpooler))
    {
    goto Error;
    }

    // vcCopies is how many times to print each page
    // cCollateCopies is how many times to print the doc
    if (vbCollate && fPrint)
    {
        cCollateCopies = vcCopies;
        vcCopies = 1;
    }
    else
        cCollateCopies = 1;

    /* And away we go... */
    while (cCollateCopies--)
    {
    cCopies = 0;
    /*------------------------------------------------*/
    /* Tell the driver how many copies we want        */
    /*------------------------------------------------*/
    lHolder = SETCOPYCOUNT;
    /* Set number of copies the printer can print */
    CopyIncr = vcCopies;
    if (Escape(vhDCPrinter, QUERYESCSUPPORT, 2, (LPSTR) &lHolder, NULL))
        Escape(vhDCPrinter, SETCOPYCOUNT, 2, (LPSTR) &CopyIncr, (LPSTR) &CopyIncr);
    else
        CopyIncr = 1;

    do
        {
        /* Initalize the counters to the beginning of the document. */
        cp = cpMin;
        ichCp = 0;
        vpgn = pgnFirst;

        /* Step through the document, formatting a page and then printing a
        page. */
        while (cp < cpMac)
            {
            register struct PLD *ppld;
            CHAR *pch;
            int yp = ypTop;
            BOOL fPageAdj = FALSE;

            /* If only a range of pages are being printed, then stop when the
            last of the pages are printed. */
            if (fPrint && vfPrPages && vpgn > vpgnEnd)
                {
                goto DocFinished;
                }

            /* Show the page number we are formatting and printing. */
#if defined(KOREA)
            pch = &szMode[0];
            *pch++ = ' ';
            ncvtu(vpgn, &pch);
            *pch++ = ' ';
            bltbyte(&stPage[1], pch, stPage[0]+1);
#else
            pch = &szMode[stPage[0]];
            ncvtu(vpgn, &pch);
            *pch = '\0';
#endif
            DrawMode();

            /* Let's go through the document page by page. */
            pdb.ipld = 0;
            while (cp < cpMac)
                {
                /* If we are printing or repaginating without confirmation, then
                immediately halt if the user requests. */
                if (!fConfirm && !(*lpFPrContinue)(NULL, wNotSpooler))
                    {
                    goto Error;
                    }

                /* We have reached the end of the line descriptors; try to
                increase its size. */
                if (pdb.ipld >= cpld && !FChngSizeH(pdb.hrgpld, (cpld +=
                  cpldChunk) * cwPLD, FALSE))
                    {
                    goto Error;
                    }

PrintFormat:
                /* Format this line. */
                FormatLine(doc, cp, ichCp, cpMac, flmPrinting);

                /* Abort if a memory error has occurred. */
                if (vfOutOfMemory)
                    {
                    goto Error;
                    }

                /* If this line is a splat, we have to decide if we really want
                it or not. */
                if (fSplat = vfli.fSplat)
                    {
                    /* Next, we are going to format either the next line (cp and
                    ichCp) or this line after the page has been removed (cpT and
                    ichCpT). */
                    typeCP cpT = cp;
                    int ichCpT = ichCp;

                    cp = vfli.cpMac;
                    ichCp = vfli.ichCpMac;

                    if (fConfirm)
                        {
                        /* The user must be prompted if he wants to keep this
                        page break. */
                        if (FPromptPgMark(cpT))
                            {
                            if (pdb.fRemove)
                                {
                                /* The page mark was removed, set cp and ichCp
                                to point to the start of the next line. */
                                cp = cpT;
                                ichCp = ichCpT;
                                cpMac--;
                                goto PrintFormat;
                                }
                            }
                        else
                            {
                if (vfPrErr)
                {
                /* Something went wrong; punt. */
                goto Error;
                }
                else
                {
                /* Well, the user wishes to cancel repagination.
                */
                                goto CancelRepage;
                }
                            }
                        }

                    /* Set the print line descriptor for the line after a splat.
                    */
                    ppld = &(**pdb.hrgpld)[pdb.ipld];
                    ppld->cp = cp;
                    ppld->ichCp = ichCp;
                    ppld->rc.left = ppld->rc.top = ppld->rc.right =
                      ppld->rc.bottom = 0;

                    /* Force a page break here with no widow and orphan
                    control. */
                    goto BreakPage;
                    }

                /* Set the value for the current print line descriptor. */
                ppld = &(**pdb.hrgpld)[pdb.ipld];
                ppld->cp = cp;
                ppld->ichCp = ichCp;
                ppld->rc.left = xpLeft + vfli.xpLeft;
                ppld->rc.right = xpLeft + vfli.xpReal;
                ppld->rc.top = yp;
                ppld->rc.bottom = yp + vfli.dypLine;
                ppld->fParaFirst = (cp == vcpFirstParaCache && ichCp == 0 &&
                  vfli.cpMac != vcpLimParaCache);

                /* If this line is not the first line and it won't fit on the
                page, then force a page break, and prompt the user for input.
                NOTE: At least one line is printed on each page. */
                if (yp + vfli.dypLine > ypBottom && pdb.ipld > 0)
                    {
                    /* If the first line on the next page is the last line of a
                    paragraph, an orphan, then put the last line of this page on
                    the next page. */
                    if (vfli.cpMac == vcpLimParaCache && (cp !=
                      vcpFirstParaCache || ichCp != 0) && pdb.ipld > 1)
                        {
                        pdb.ipld--;
                        fPageAdj = TRUE;
                        }

                    /* If the last line on this page is the first line of a
                    paragraph, a widow, then put it on the next page. */
                    if (pdb.ipld > 1 && (**pdb.hrgpld)[pdb.ipld - 1].fParaFirst)
                        {
                        pdb.ipld--;
                        fPageAdj = TRUE;
                        }

BreakPage:
                    /* Add an entry into the page table (only during the first
                    copy of the document). */
                    if (cCopies == 0)
                        {
                        if ((pdb.ipgd = (**pdb.hpgtb).cpgd++) + 1 >=
                          (**pdb.hpgtb).cpgdMax)
                            {
                            if (!FChngSizeH(pdb.hpgtb, cwPgtbBase +
                              ((**pdb.hpgtb).cpgdMax += cpgdChunk) * cwPGD,
                              FALSE))
                                {
                                /* Not enough memory to expand the page table;
                                time to bail out.  */
                                goto ErrorMsg;
                                }
                            }
                        ppgd = &((**pdb.hpgtb).rgpgd[pdb.ipgd]);
                        ppgd->cpMin = (**pdb.hrgpld)[pdb.ipld].cp;
                        ppgd->pgn = vpgn + 1;
                        vdocPageCache = docNil;
                        }

                    /* Now go ask the user for his opinion. */
                    if (fConfirm)
                        {
                        if (!fSplat)
                            {
                            pdb.ipldCur = pdb.ipld;
                            if (FSetPage())
                                {
                                if (pdb.ipld != pdb.ipldCur)
                                    {
                                    /* The user has decided to move the page
                                    break. */
                                    pdb.ipld = pdb.ipldCur;
                                    cpMac++;
                                    fPageAdj = TRUE;
                                    }
                                }
                            else
                                {
                if (vfPrErr)
                    {
                    /* Something went wrong; punt. */
                    goto Error;
                    }
                else
                    {
                    /* Well, the user wishes to cancel
                    repagination.  */
                    goto CancelRepage;
                    }
                                }
                            }

                        /* After repaginating interactively, make certain the
                        screen reflects the current page break. */
                        UpdateWw(wwCur, FALSE);
                        }

                    /* This page has finished formatting, reset the cp and ichCp
                    pair to the top of the next page if necessary and get out of
                    this loop.  */
                    if (fPageAdj)
                        {
                        ppld = &(**pdb.hrgpld)[pdb.ipld];
                        cp = ppld->cp;
                        ichCp = ppld->ichCp;
                        }
                    break;
                    }

                /* Set the cp and ichCp to the start of the next line. */
                cp = vfli.cpMac;
                ichCp = vfli.ichCpMac;
                yp += vfli.dypLine;
                pdb.ipld++;
                }

            /* Now that we have figured out which lines fit on the page, its
            time to print them. */
            if (fPrint && (!vfPrPages || (vpgn >= vpgnBegin && vpgn <=
              vpgnEnd)))
                {
                BOOL fFirstBand = TRUE;

                /* This loop is executed for each band (once for non-banding
                devices). */
                for ( ; ; )
                    {
                    RECT rcBand;

                    /* Abort the print if the user so desires. */
                    if (!(*lpFPrContinue)(NULL, wNotSpooler))
                        {
                        goto Error;
                        }

                    /* Get the next band. */
                    if ((iEscape = Escape(vhDCPrinter, NEXTBAND, 0,
                      (LPSTR)NULL, (LPSTR)&rcBand)) < 0)
                        {
                        goto ErrorSwitch;
                        }
#ifdef DPRINT
CommSzSz("Next band", "");
#endif

                    /* If the band is empty then we are finished with this
                    page. */
                    if (rcBand.top >= rcBand.bottom || rcBand.left >=
                      rcBand.right)
                        {
                        /* Reset the currently selected font. */
                        ResetFont(TRUE);
                        break;
                        }

                    /* The printer DC gets wiped clean at the start of each
                    page.  It must be reinitialized. */
                    if (fFirstBand)
                        {
                        /* Set the printer into transparent mode. */
                        SetBkMode(vhDCPrinter, TRANSPARENT);

                        /* Reset the currently selected font. */
                        ResetFont(TRUE);

                        fFirstBand = FALSE;
                        }

                    /* First, print the header, if there is one. */
                    if (vpgn >= pgnFirstHeader && !FPrintBand(doc,
                      hrgpldHeader, cpldHeader, &rcBand))
                        {
                        goto Error;
                        }

                    /* Print that part of the document that lies in the
                    band. */
                    if (!FPrintBand(doc, pdb.hrgpld, pdb.ipld, &rcBand))
                        {
                        goto Error;
                        }

                    /* Lastly, print the footer, if it exists. */
                    if (vpgn >= pgnFirstFooter && !FPrintBand(doc,
                      hrgpldFooter, cpldFooter, &rcBand))
                        {
                        goto Error;
                        }
                    }
                }

            /* Finally, bump the page counter. */
            vpgn++;
            }
DocFinished:;
        }
    while (fPrint && (cCopies += CopyIncr) < vcCopies);
    }

    /* If a range of pages is being printed then we reattatch the old page table
    to the document. */
    if (fPrint && vfPrPages)
        {
        goto RestorePgtb;
        }

CancelRepage:
    /* If the page table has changed, then mark the document as dirty. */
    if (!(**hpdocdod)[doc].fDirty)
        {
        (**hpdocdod)[doc].fDirty = (hpgtbOld == NULL) || ((**pdb.hpgtb).cpgd !=
          (**hpgtbOld).cpgd) || !FRgchSame((**pdb.hpgtb).rgpgd,
          (**hpgtbOld).rgpgd, (**pdb.hpgtb).cpgd * cchPGD);
        }

    /* Delete the old page table. */
    if (hpgtbOld != NULL)
        {
        FreeH(hpgtbOld);
        }

    /* Printing and non-interactive repagination can't be undone. */
    if (!fConfirm)
        {
        NoUndo();
        }

ErrorLoop:
    /* Delete the array of line descriptors. */
    FreeH(pdb.hrgpld);

    if (fPrint)
        {
        BOOL fResetMode = FALSE;

        /* Delete the descriptors for the header and footer. */
        if (hrgpldHeader != NULL)
            {
            FreeH(hrgpldHeader);
            }
        if (hrgpldFooter != NULL)
            {
            FreeH(hrgpldFooter);
            }

        /* Tell the spooler that we are finished printing. */
        if (!vfPrErr)
            {
            Escape(vhDCPrinter, ENDDOC, 0, (LPSTR)NULL, (LPSTR)NULL);
#ifdef DPRINT
CommSzSz("End doc", "");
#endif
            }

        /* Reset the printer from draft mode if necessary. */
        if (vfDraftMode)
            {
            Escape(vhDCPrinter, DRAFTMODE, sizeof(BOOL), (LPSTR)&fResetMode,
              (LPSTR)NULL);
            }
        }

    /* Reset the value of cpMinCur. */
    cpMinCur = cpMin;

    /* Invalidate the mode and page caches. */
    docMode = vdocPageCache = docNil;

    /* Since this might have changed the page breaks, dirty the windows so that
    UpdateDisplay() will show them. */
    TrashAllWws();

Abort:
    if (fPrint)
    {
    /* Create a new IC for the printer. */
    ResetFont(TRUE);
    FreePrinterDC();
    GetPrinterDC(FALSE);
    }

    /* Enable all other windows. */
    EnableWindow(hParentWw, TRUE);
    EnableOtherModeless(TRUE);

    if (fConfirm)
        {
    /* Let the user know that we are finished repaginating. */
    EndLongOp(vhcIBeam);
    }
    else if (vhWndCancelPrint != NULL)
    {
    /* Get rid of the dialog box telling the user how to cancel printing or
    repagination. */
        DestroyWindow(vhWndCancelPrint);
        vhWndCancelPrint = NULL;
    DispatchPaintMsg();
        }

#ifndef INEFFLOCKDOWN
    if (lpDialogCancelPrint)
        FreeProcInstance(lpDialogCancelPrint);
    if (lpFPrContinue)
        FreeProcInstance(lpFPrContinue);
    lpDialogCancelPrint = lpFPrContinue = NULL;
#endif

    fPrinting = FALSE;

#if defined(OLE)
    UPDATE_INVALID(); /* WM_PAINTS blocked while printing, repaint when done */
#endif

    /* Here is the exit point for this routine. */
    return;

ErrorMsg:
    /* Give the user an error message before aborting the print/repagination. */
    Error(IDPMTPRFAIL);

Error:
    /* Abort the print job if necessary. */
    if (fPrint)
        {
        Escape(vhDCPrinter, ABORTDOC, 0, (LPSTR)NULL, (LPSTR)NULL);
#ifdef DPRINT
CommSzSz("Abort doc", "");
#endif
        }

ErrorNoAbort:
    /* Indicate that an error has occurred.  (Cancellation is an error.) */
    vfPrErr = TRUE;

RestorePgtb:
    /* Reconnect to old page table to the document, and then delete the new
    page table. */
    (**hpdocdod)[doc].hpgtb = hpgtbOld;
    FreeH(pdb.hpgtb);

    goto ErrorLoop;
    }


BOOL far PASCAL FPrContinue(hDC, iCode)
HDC hDC;
int iCode;
    {
    /* This routine returns TRUE if the user has not aborted the print; FALSE
    otherwise. */

    extern CHAR *vpDlgBuf;
    extern HWND vhWndCancelPrint;
    extern BOOL vfPrErr;
    extern int vfOutOfMemory;

    struct PDB *ppdb = (struct PDB *)vpDlgBuf;
    MSG msg;


#if 0
    /* If a printer error has occurred, that is the same as an abort. */
    if (vfPrErr || vfOutOfMemory || (iCode < 0 && iCode != SP_OUTOFDISK))
        {
        return (FALSE);
        }

    /* If we have been called by the spooler then just return TRUE.
       (Calling PeekMessage() at this point might be death.) */

    if (iCode != wNotSpooler)
        {
        Assert(iCode == 0 || iCode == SP_OUTOFDISK);
        if (iCode == 0)
            return (TRUE);
        /* else fall through to wait -- we're getting called by GDI while 
           the spooler frees up some temp files.  this is NOT a genuine
           error yet!  12/20/89 ..pault */
        }
#else
    if (vfPrErr || vfOutOfMemory)
        return FALSE;
#endif

    /* If there are any messages waiting the Cancel Print window, then send them
    to the window messages handling routine. */
    while (!ppdb->fCancel && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
        if (!IsDialogMessage(vhWndCancelPrint, &msg))
            {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            }
        }

    /* If one of the messages was a cancel print meassge, then the value of
    fCancel has been set. */
    return !(vfPrErr = ppdb->fCancel || vfOutOfMemory);
    }


BOOL far PASCAL DialogCancelPrint(hWnd, message, wParam, lParam)
HWND hWnd;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine is supposed to process messages to the Cancel Print dialog
    box, but, in reality, the sole responsiblity of this routine is to set the
    flag fCancel if the user wishes to cancel printing. */

    extern CHAR *vpDlgBuf;
    extern HWND vhWndMsgBoxParent;

    struct PDB *ppdb = (struct PDB *)vpDlgBuf;

    if ((message == WM_COMMAND && (wParam == idiCancel || wParam == idiOk)) ||
      (message == WM_CLOSE))
        {
        ppdb->fCancel = TRUE;
        return (TRUE);
        }
    if (message == WM_INITDIALOG)
        {
        extern int docCur;
        extern char szUntitled[];
        extern struct DOD (**hpdocdod)[];
        extern char * PchStartBaseNameSz();
        struct DOD *pdod = &(**hpdocdod)[docCur];
        CHAR *psz = &(**(pdod->hszFile))[0];

        SetDlgItemText(hWnd, idiPrCancelName,
                       (LPSTR)(*psz ? PchStartBaseNameSz(psz) : szUntitled));
        return(TRUE);
        }
    if (message == WM_ACTIVATE)
        {
        vhWndMsgBoxParent = wParam == 0 ? (HWND)NULL : hWnd;
        }
    return (FALSE);
    }


DispatchPaintMsg()
    {
    /* This routine looks for and dispatches any outstanding paint messages for
    Write (like after an EndDialog() call). */

    extern int vfOutOfMemory;

    MSG msg;

    while (!vfOutOfMemory && PeekMessage((LPMSG)&msg, NULL, WM_PAINT, WM_PAINT,
      PM_REMOVE))
        {
        DispatchMessage((LPMSG)&msg);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\print2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* These routines are the guts of the text print code. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOATOM
#define NOFONT
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOMB
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>
#include "mw.h"
#include "printdef.h"
#include "fmtdefs.h"
#include "propdefs.h"
#include "fontdefs.h"
#include "docdefs.h"
#define NOKCCODES
#include "ch.h"
#include "debug.h"
#include "str.h"

#if defined(JAPAN) || defined(KOREA)                  //  added  01 Jul. 1992  by Hiraisi
#include "kanji.h"
#endif

BOOL FPrintBand(doc, hrgpld, cpld, prcBand)
int doc;
struct PLD (**hrgpld)[];
int cpld;
PRECT prcBand;
    {
    /* This routine prints the lines in document doc that any part of which fall
    in the rectange *prcBand.  The first cpld print line descriptors in hrgpld
    describe the current page in the document that will be printed.  TRUE is
    returned if the band is printed, FALSE otherwise. */

    void PrintGraphics(int, int);
    void near PrintFli(int, int);

    extern struct DOD (**hpdocdod)[];
    extern struct FLI vfli;
    extern int vfOutOfMemory;
    extern FARPROC lpFPrContinue;

    int ipld;
    typeCP cpMac = (**hpdocdod)[doc].cpMac;

    for (ipld = 0; ipld < cpld; ipld++)
        {
        register struct PLD *ppld;

        /* Check for user cancellation. */
        if (!(*lpFPrContinue)(NULL, wNotSpooler))
            {
            return (FALSE);
            }

        /* Is this line within the band? */
        ppld = &(**hrgpld)[ipld];
        if (ppld->rc.top < prcBand->bottom && ppld->rc.bottom > prcBand->top &&
          ppld->rc.left < prcBand->right && ppld->rc.right > prcBand->left)
            {
            /* Format this line for the printer. */
            FormatLine(doc, ppld->cp, ppld->ichCp, cpMac, flmPrinting);

            /* If memory failure occurred, then punt. */
            if (vfOutOfMemory)
                {
                return (FALSE);
                }

            /* Reset the pointer to the print line descriptors (possible heap
            movement in FormatLine()). */
            ppld = &(**hrgpld)[ipld];

            /* Print this line. */
            if (vfli.fGraphics)
                {
                PrintGraphics(ppld->rc.left, ppld->rc.top);
                }
            else
                {
                PrintFli(ppld->rc.left, ppld->rc.top);
                }
            }
        }
    return (TRUE);
    }


void near PrintFli(xpPrint, ypPrint)
int xpPrint;
int ypPrint;
    {
    /* This routine prints the line of text stored in the vfli structure at
    position (xpPrint, ypPrint). */

#ifdef	KOREA  // jinwoo: 92, 9, 28
     /* process Subscript separatedly from descent 920605 KDLEE*/
    extern int isSubs;
#endif  /* KOREA */
    extern HDC vhDCPrinter;
    extern struct FLI vfli;
    extern struct DOD (**hpdocdod)[];
    extern struct CHP (**vhgchpFormat)[];
    extern int dxpPrPage;
    extern int dypPrPage;
    extern int ypSubSuperPr;
    extern CHAR stBuf[];
    extern struct FMI vfmiPrint;
    extern typeCP cpMinDocument;
    extern int vpgn;

    int dcp;
    int dxp;            /* Width of current run */
    int dxpExtra;       /* Width of pad for each space */
    int yp;             /* Y-coordinate to print at. */
    struct CHP *pchp;   /* CHP associated with the current run */
    BOOL fTabsKludge = (vfli.ichLastTab >= 0);
    int cBreakRun;              /* break characters in run (no relation to Dick or Jane) */

#if defined(JAPAN) || defined(KOREA)                  //  added  04 Jul. 1992  by Hiraisi
    extern struct PAP vpapAbs;
    extern int vfWordWrap;    /* WordWrap flag : TRUE=ON, FALSE=OFF */
    extern int iNonWideSpaces;
    int iRun;
#endif

    Scribble(5,'P');
    Assert(vhDCPrinter);

    pchp = &(**vhgchpFormat)[0];
    dxpExtra = fTabsKludge ? 0 : vfli.dxpExtra;

#if defined(JAPAN) || defined(KOREA)                  //  added  04 Jul. 1992  by Hiraisi
    iRun = 0;
#endif
    for (dcp = 0; dcp < vfli.ichReal; pchp++)
        {
        /* For all runs do: */
        int ichFirst;   /* First character in the current run */
        int cchRun;     /* Number of characters in the current run */

        dcp = ichFirst = pchp->ichRun;
        dcp += pchp->cchRun;
        if (dcp > vfli.ichReal)
            {
            dcp = vfli.ichReal;
            }
        cchRun = dcp - ichFirst;

        /* Compute dxp = sum of width of characters in current run (formerly
        DxpFromIcpDcp). */
            {
            register int *pdxp;
            register int cchT = cchRun;
            PCH pch = vfli.rgch + ichFirst;

            dxp = cBreakRun = 0;
            pdxp = &vfli.rgdxp[ichFirst];
            while (cchT-- > 0)
                {
                dxp += *pdxp++;
                if (*pch++ == chSpace)
                    ++cBreakRun;
                }
            }

        if (dxp > 0)
            {
            int cchDone;
            PCH pch = &vfli.rgch[ichFirst];
#if defined(JAPAN) || defined(KOREA)                  //  added  08 Jul. 1992  by Hiraisi
            int *pdxpT = &vfli.rgdxp[ichFirst];
#endif

            LoadFont(vfli.doc, pchp, mdFontPrint);
#ifdef	KOREA	/* 920605 KDLEE */  // jinwoo: 92, 9, 28
#ifdef	NODESC
		yp = ypPrint+vfli.dypLine - (vfli.dypBase + (pchp->hpsPos != 0 ? (pchp->hpsPos <
		     hpsNegMin ? ypSubSuperPr : -ypSubSuperPr) : 0)) -
		     vfmiPrint.dypBaseline - ( isSubs ? ypSubSuperPr : 0 );
#else	/* NODESC */
            yp = ypPrint + vfli.dypLine - vfli.dypBase - (pchp->hpsPos != 0 ?
              (pchp->hpsPos < hpsNegMin ? ypSubSuperPr : -ypSubSuperPr) : 0) -
	      vfmiPrint.dypBaseline;
#endif	/* NODESC */
#else   /* KOREA */
            yp = ypPrint + vfli.dypLine - vfli.dypBase - (pchp->hpsPos != 0 ?
              (pchp->hpsPos < hpsNegMin ? ypSubSuperPr : -ypSubSuperPr) : 0) -
              vfmiPrint.dypBaseline;
#endif  /* KOREA */

            /* Note: tabs and other special characters are guaranteed to come at
            the start of a run. */
#ifdef JAPAN                  //  added  01 Jul. 1992  by Hiraisi
            if( vpapAbs.jc != jcBoth || fTabsKludge )
              SetTextJustification(vhDCPrinter, dxpExtra*cBreakRun, cBreakRun);
#else
            SetTextJustification(vhDCPrinter, dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */
            cchDone = 0;
            while (cchDone < cchRun)
                {
                int cch;

                /* Does the wide-space zone begin in this run? */
                if (vfli.fAdjSpace && (vfli.ichFirstWide < ichFirst + cchRun) &&
                  (ichFirst + cchDone <= vfli.ichFirstWide))
                    {
                    int cchDoneT = cchDone;

                    /* Is this the beginning of the wide-space zone? */
                    if (ichFirst + cchDone == vfli.ichFirstWide)
                        {
                        /* Reset the width of the spaces. */
#ifdef JAPAN                  //  added  01 Jul. 1992  by Hiraisi
                        if( vpapAbs.jc != jcBoth || fTabsKludge )
                            SetTextJustification(vhDCPrinter, ++dxpExtra*cBreakRun, cBreakRun);
#else
                        SetTextJustification(vhDCPrinter, ++dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */
                        cch = cchRun - cchDone;
                        cchDone = cchRun;
                        }
                    else
                        {
                        cchDone = cch = vfli.ichFirstWide - ichFirst;
                        }

                    /* This run is cut short because of a wide space, so we need
                    to calculate a new width. */
                        {
                        register int *pdxp;
                        register int cchT = cch;
                        PCH pch = &vfli.rgch[ichFirst + cchDoneT];

                        dxp = 0;
                        pdxp = &vfli.rgdxp[ichFirst + cchDoneT];
                        while (cchT-- > 0)
                            {
                            dxp += *pdxp++;
                            if (*pch++ == chSpace)
                                ++cBreakRun;
                            }
                        }
                    }
                else
                    {
                    cchDone = cch = cchRun;
                    }

                while (cch > 0)
                    {
                    switch (*pch)
                        {
                        CHAR ch;
                        int dxpT;

                    case chTab:

#ifdef CASHMERE
                        /* chLeader contains tab leader character (see
                        FormatLine) */
                        if ((ch = pchp->chLeader) != chSpace)
                            {
                            int cxpTab;
                            CHAR rgch[32];
                            int dxpLeader = DxpFromCh(ch, TRUE);
                            int xp = xpPrint;
                            int iLevelT = SaveDC(vhDCPrinter);

                            SetBytes(&rgch[0], ch, 32);
                            dxpT = vfli.rgdxp[ichFirst];
                            cxpTab = ((dxpT + dxpLeader - 1) / dxpLeader + 31)
                              >> 5;
#ifdef CLIP
                            IntersectClipRect(vhDCPrinter, xpPrint, 0, xpPrint +
                              dxpT, vfli.dypLine);
#endif

                            while (cxpTab-- > 0)
                                {
                                TextOut(vhDCPrinter, xp, yp, (LPSTR)rgch,
                                  32);
                                xp += dxpLeader << 5;
                                }
                            RestoreDC(vhDCPrinter, iLevelT);
                            xpPrint += dxpT;
                            }
                        else
#endif /* CASHMERE */

                            {
                            xpPrint += vfli.rgdxp[ichFirst];
                            }

                        if (fTabsKludge && ichFirst >= vfli.ichLastTab)
                            {
#ifdef JAPAN                  //  added  01 Jul. 1992  by Hiraisi
                            if( vpapAbs.jc != jcBoth )
                                SetTextJustification(vhDCPrinter, (dxpExtra =
                                       vfli.dxpExtra) *cBreakRun, cBreakRun);
                            else
                                dxpExtra = vfli.dxpExtra;
#else
                            SetTextJustification(vhDCPrinter, (dxpExtra =
                              vfli.dxpExtra) * cBreakRun, cBreakRun);
#endif /* JAPAN */
                            fTabsKludge = FALSE;
                            }
                        dxp -= vfli.rgdxp[ichFirst];
                        pch++;
                        cch--;
#if defined(JAPAN) || defined(KOREA)                  //  added  04 Jul. 1992  by Hiraisi
                        iRun++;
                        pdxpT++;
#endif
                        goto EndLoop;

#ifdef CASHMERE
                    case schPage:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = CchExpPgn(&stBuf[1], vpgn, vsepAbs.nfcPgn,
                          flmPrinting, ichMaxLine);
                        goto DrawSpecial;

                    case schFootnote:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = CchExpFtn(&stBuf[1], cpMin + ichFirst,
                          flmPrinting, ichMaxLine);
DrawSpecial:
#else /* not CASHMERE */
                    case schPage:
                    case schFootnote:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = *pch == schPage && vfli.cpMin + ichFirst <
                          cpMinDocument ? CchExpPgn(&stBuf[1], vpgn, 0,
                          flmPrinting, ichMaxLine) : CchExpUnknown(&stBuf[1],
                          flmPrinting, ichMaxLine);
#endif /* not CASHMERE */

                        TextOut(vhDCPrinter, xpPrint, yp, (LPSTR)&stBuf[1],
                          stBuf[0]);
                        break;

                    default:
                        goto EndLoop;
                        }
                    dxp -= vfli.rgdxp[ichFirst];
                    xpPrint += vfli.rgdxp[ichFirst++];
                    pch++;
                    cch--;
#if defined(JAPAN) || defined(KOREA)                  //  added  09 Jul. 1992  by Hiraisi
                    pdxpT++;
#endif
                    }
EndLoop:

                /* Output cch characters starting at pch */
#if 0
            {
                char msg[180];
                wsprintf(msg,"putting out %d characters\n\r",cch);
                OutputDebugString(msg);
            }
#endif

#ifdef JAPAN                  //  added  01 Jul. 1992  by Hiraisi
                if( vpapAbs.jc == jcBoth && !fTabsKludge ){
                   CHAR *ptr1, *ptr2;
                   int len, cnt;
                   int iExtra, iSpace, iWid;
                   BOOL bFlag;
                   ptr2 = pch;
                   for( cnt=0 ; cnt<cch ; ){
                      ptr1 = ptr2;
                      iExtra = dxpExtra;
                      iWid = len = 0;
                      bFlag = TRUE;
                      if( IsDBCSLeadByte( *ptr2 ) ){
                         for( ; cnt<cch ; ){
                            iWid += *pdxpT;
                            pdxpT+=2;
                            cnt+=2;
                            len += 2;
                            iRun += 2;
                            ptr2 += 2;
                            if( --iNonWideSpaces == 0){
                               dxpExtra++;
                               break;
                            }
                            if( iRun == dcp-2 )
                               break;
                            if( iRun == dcp ){    /* last DBC (maybe) */
                               iExtra = 0;
                               break;
                            }
                            if( !IsDBCSLeadByte( *ptr2 ) )
                               break;
                         }
                      }
                      else{
                         if( FKana( (int)*ptr2 ) ){
                            for( ; cnt<cch ; ){
                               iWid += *pdxpT++;
                               cnt++;
                               len++;
                               iRun++;
                               ptr2++;
                               if( --iNonWideSpaces == 0){
                                  dxpExtra++;
                                  break;
                               }
                               if( iRun == dcp-1 )
                                  break;
                               if( iRun == dcp ){    /* last SBC (maybe) */
                                  iExtra = 0;
                                  break;
                               }
                               if( !FKana( (int)*ptr2 ) )
                                  break;
                            }
                         }
                         else{
                            for( bFlag=FALSE,iSpace = 0 ; cnt<cch ; ){
                               iWid += *pdxpT++;
                               cnt++;
                               len++;
                               iRun++;
                               if( *ptr2++ == chSpace || !vfWordWrap ){
                                   iSpace++;
                                   if( --iNonWideSpaces == 0){
                                       dxpExtra;
                                       break;
                                   }
                               }
                               if( iRun == dcp-1 )
                                  break;
                               if( iRun == dcp ){    /* last SBC (maybe) */
                                  iExtra = 0;
                                  break;
                               }
                               if( IsDBCSLeadByte( *ptr2 ) ||
                                  FKana( (int)*ptr2 ) )
                                  break;
                            }
                         }
                      }
                      if( vfWordWrap && !bFlag ){
                         SetTextCharacterExtra( vhDCPrinter, 0 );
                         SetTextJustification(vhDCPrinter, iExtra*iSpace,
                                              iSpace);
                      }
                      else{
                         SetTextJustification( vhDCPrinter, 0, 0 );
                         SetTextCharacterExtra( vhDCPrinter, iExtra );
                      }
                      TextOut(vhDCPrinter, xpPrint, yp, ptr1, len);
                      xpPrint += iWid;
                   }
                }
                else{
                    iRun += cch;
                    SetTextCharacterExtra( vhDCPrinter, 0 );
                    TextOut(vhDCPrinter, xpPrint, yp, pch, cch);
                    xpPrint += dxp;
                }
#else
                TextOut(vhDCPrinter, xpPrint, yp, (LPSTR)pch, cch);
                xpPrint += dxp;
#endif
                pch += cch;
                }
            }
        }

    Scribble(5,' ');
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\print3.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* These routines are the guts of the graphics print code. */

#define	NOGDICAPMASKS
#define	NOVIRTUALKEYCODES
#define	NOWINMESSAGES
#define	NOWINSTYLES
#define	NOSYSMETRICS
#define	NOICON
#define	NOKEYSTATE
#define	NOSYSCOMMANDS
#define	NOSHOWWINDOW
//#define	NOATOM
#define	NOFONT
#define	NOBRUSH
#define	NOCLIPBOARD
#define	NOCOLOR
#define	NOCREATESTRUCT
#define	NOCTLMGR
#define	NODRAWTEXT
#define	NOMB
#define	NOOPENFILE
#define	NOPEN
#define	NOREGION
#define	NOSCROLL
#define	NOSOUND
#define	NOWH
#define	NOWINOFFSETS
#define	NOWNDCLASS
#define	NOCOMM
#include <windows.h>
#include "mw.h"
#include "printdef.h"
#include "fmtdefs.h"
#include "docdefs.h"
#define	NOKCCODES
#include "winddefs.h"
#include "debug.h"
#include "str.h"
#if defined(OLE)
#include "obj.h"
#endif

PrintGraphics(xpPrint, ypPrint)
int	xpPrint;
int	ypPrint;
	{
	/* This	routine	prints the picture in the vfli structure at	position
	(xpPrint, ypPrint).	*/

	extern HDC vhDCPrinter;
	extern struct FLI vfli;
	extern struct DOD (**hpdocdod)[];
	extern int dxpPrPage;
	extern int dypPrPage;
	extern FARPROC lpFPrContinue;

	typeCP cp;
	typeCP cpMac = (**hpdocdod)[vfli.doc].cpMac;
	struct PICINFOX	picInfo;
	HANDLE hBits = NULL;
	HDC	hMDC = NULL;
	HBITMAP	hbm	= NULL;
	LPCH lpBits;
	int	cchRun;
	unsigned long cbPict = 0;
	int	dxpOrig;		/* Size	of picture in the original */
	int	dypOrig;
	int	dxpDisplay;		/* Size	of picture as we want to show it */
	int	dypDisplay;
	BOOL fRescale;
	BOOL fBitmap;
	BOOL fPrint	= FALSE;
	int	iLevel = 0;
    RECT bounds;

	Assert(vhDCPrinter);
    GetPicInfo(vfli.cpMin, cpMac, vfli.doc,	&picInfo);

	/* Compute desired display size	of picture (in device pixels) */
	dxpDisplay = vfli.xpReal - vfli.xpLeft;
	dypDisplay = vfli.dypLine;

	/* Compute original	size of	picture	(in	device pixels) */
	/* MM_ANISOTROPIC and MM_ISOTROPIC pictures	have no	original size */

	fRescale = FALSE;
	switch (picInfo.mfp.mm)
		{
	case MM_ISOTROPIC:
	case MM_ANISOTROPIC:
		break;

#if defined(OLE)
    case MM_OLE:
        if (lpOBJ_QUERY_INFO(&picInfo) == NULL)
                goto DontDraw;

        if (lpOBJ_QUERY_OBJECT(&picInfo) == NULL)
                goto DontDraw;
    break;
#endif

	case MM_BITMAP:
		dxpOrig	= picInfo.bm.bmWidth;
		dypOrig	= picInfo.bm.bmHeight;
		break;

	default:
		dxpOrig	= PxlConvert(picInfo.mfp.mm, picInfo.mfp.xExt, dxpPrPage,
		  GetDeviceCaps(vhDCPrinter, HORZSIZE));
		dypOrig	= PxlConvert(picInfo.mfp.mm, picInfo.mfp.yExt, dypPrPage,
		  GetDeviceCaps(vhDCPrinter, VERTSIZE));
		if (dxpOrig	== 0 ||	dypOrig	== 0)
			{
#ifdef DPRINT            
            CommSz("PrintGraphics: nodraw because dxpOrig==0 | dypOrig==0\r\n");
#endif
			goto DontDraw;
			}
		fRescale = (dxpOrig	!= dxpDisplay) || (dypOrig != dypDisplay);
		break;
		}

	/* Get a handle	to a global	object large enough	to hold	the	picture. */
    if (picInfo.mfp.mm != MM_OLE)
    {
	if ((hBits = GlobalAlloc(GMEM_MOVEABLE,	(long)picInfo.cbSize)) == NULL)
		{
		/* Not enough global heap space	to load	bitmap/metafile	*/
#ifdef DPRINT        
        CommSz("PrintGraphics: nodraw because not enough mem to alloc\r\n");
#endif
		goto DontDraw;
		}

	/* Build up	all	bytes associated with the picture (except the header) into
	the	global handle hBits	*/
	for	(cbPict	= 0, cp	= vfli.cpMin + picInfo.cbHeader; cbPict	<
	  picInfo.cbSize; cbPict +=	cchRun,	cp += cchRun)
		{
		CHAR rgch[256];
		LPCH lpch;

		#define	ulmin(a,b)	((a) < (b) ? (a) : (b))

		FetchRgch(&cchRun, rgch, vfli.doc, cp, cpMac, (int)ulmin(picInfo.cbSize
		  -	cbPict,	256));

		if ((lpch =	GlobalLock(hBits)) == NULL)
			{
#ifdef DPRINT            
            CommSz("PrintGraphics: nodraw because couldn't lock\r\n");
#endif
			goto DontDraw;
			}

		bltbx((LPSTR)rgch, lpch	+ cbPict, cchRun);
		GlobalUnlock(hBits);
		}
    }

	/* Save	the	printer	DC as a	guard against DC attribute alteration by a
	metafile */
	iLevel = SaveDC(vhDCPrinter);

	fBitmap	= picInfo.mfp.mm ==	MM_BITMAP;

#if defined(OLE)
        /* CASE 0: OLE */
        if (picInfo.mfp.mm == MM_OLE)
        {
            RECT rcPict;

            rcPict.left  = xpPrint;
            rcPict.top   = ypPrint;
            rcPict.right = rcPict.left + dxpDisplay;
            rcPict.bottom   = rcPict.top  + dypDisplay;
	        SetMapMode(vhDCPrinter, MM_TEXT);
            //SetViewportOrg( vhDCPrinter, xpPrint, ypPrint);
            fPrint = ObjDisplayObjectInDoc(&picInfo, vfli.doc, vfli.cpMin, vhDCPrinter, &rcPict);
        }
        else
#endif
	if (fBitmap)
		{
		if (((hMDC = CreateCompatibleDC(vhDCPrinter)) != NULL) &&
		  ((picInfo.bm.bmBits =	GlobalLock(hBits)) != NULL)	&& ((hbm =
		  CreateBitmapIndirect((LPBITMAP)&picInfo.bm)) != NULL))
			{
			picInfo.bm.bmBits =	NULL;
			GlobalUnlock(hBits);
			if (SelectObject(hMDC, hbm)	!= NULL)
				{
				fPrint = StretchBlt(vhDCPrinter, xpPrint, ypPrint, dxpDisplay,
				  dypDisplay, hMDC,	0, 0, dxpOrig, dypOrig,	SRCCOPY);
#ifdef DPRINT                
                CommSzNum("PrintGraphics: after StretchBlt1, fPrint==", fPrint);
#endif
				}
			}
		}

	/* Case	2: a non-scalable picture which	we are nevertheless	scaling	by force
	using StretchBlt */
	else if	(fRescale)
		{
		if (((hMDC = CreateCompatibleDC(vhDCPrinter)) != NULL) && ((hbm	=
		  CreateCompatibleBitmap(vhDCPrinter, dxpOrig, dypOrig)) !=	NULL))
			{
			if (SelectObject(hMDC, hbm)	&& PatBlt(hMDC,	0, 0, dxpOrig, dypOrig,
			  WHITENESS) &&	SetMapMode(hMDC, picInfo.mfp.mm) &&
			  PlayMetaFile(hMDC, hBits))
				{
				/* Successfully	played metafile	*/
				SetMapMode(hMDC, MM_TEXT);
				fPrint = StretchBlt(vhDCPrinter, xpPrint, ypPrint, dxpDisplay,
				  dypDisplay, hMDC,	0, 0, dxpOrig, dypOrig,	SRCCOPY);
#ifdef DPRINT                
                CommSzNum("PrintGraphics: after StretchBlt2, fPrint==", fPrint);
#endif
				}
			}
		}

	/* Case	3: A metafile picture which	can	be directly	scaled or does not
	need to	be because its size	has	not	changed	*/
	else
		{
		SetMapMode(vhDCPrinter,	picInfo.mfp.mm);

		SetViewportOrg(vhDCPrinter,	xpPrint, ypPrint);
		switch (picInfo.mfp.mm)
			{
		case MM_ISOTROPIC:
			if (picInfo.mfp.xExt &&	picInfo.mfp.yExt)
				{
				/* So we get the correct shape rectangle when SetViewportExt
				gets called	*/
				SetWindowExt(vhDCPrinter, picInfo.mfp.xExt,	picInfo.mfp.yExt);
				}

		/* FALL	THROUGH	*/
		case MM_ANISOTROPIC:
            /** (9.17.91) v-dougk 
                Set the window extent in case the metafile is bad 
                and doesn't call it itself.  This will prevent
                possible gpfaults in GDI
                **/
            SetWindowExt( vhDCPrinter,  dxpDisplay, dypDisplay );

			SetViewportExt(vhDCPrinter,	dxpDisplay,	dypDisplay);
			break;
			}

		fPrint = PlayMetaFile(vhDCPrinter, hBits);
#ifdef DPRINT        
        CommSzNum("PrintGraphics: after PlayMetaFile, fPrint==", fPrint);
#endif
		}

DontDraw:
	/* We've drawn all we are going	to draw; now its time to clean up. */
	if (iLevel > 0)
		{
		RestoreDC(vhDCPrinter, iLevel);
		}
	if (hMDC !=	NULL)
		{
		DeleteDC(hMDC);
		}
	if (hbm	!= NULL)
		{
		DeleteObject(hbm);
		}
	if (hBits != NULL)
		{
		if (fBitmap	&& picInfo.bm.bmBits !=	NULL)
			{
			GlobalUnlock(hBits);
			}
		GlobalFree(hBits);
		}

	/* If we couldn't print	the	picture, warn the user.	*/
	if (!fPrint)
		{
		Error(IDPMTPrPictErr);
		}
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\prmdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Single property modifiers */

/*      ***     MUST agree with dnsprm in mglobals.c       ***     */

#ifndef PRMDEFSH
#define PRMDEFSH

/* Paragraph */
#define sprmPLMarg      1       /* Left margin */
#define sprmPRMarg      2       /* Right margin */
#define sprmPFIndent    3       /* First line indent (from LM) */
#define sprmPJc         4       /* Justification code */
#define sprmPRuler      5       /* Ruler (formerly Clear tab) */
#define sprmPRuler1     6       /* Ruler1 (formerly Set tab) */
#define sprmPKeep       7       /* Keep */
#define sprmPNormal     8       /* Normal para (formerly Style, overrides all others) */
#define sprmPRhc        9       /* Running head code */
#define sprmPSame       10      /* Everything (overrides all others) */
#define sprmPDyaLine    11      /* Line height */
#define sprmPDyaBefore  12      /* Space before */
#define sprmPDyaAfter   13      /* Space after */
#define sprmPNest       14      /* Nest para */
#define sprmPUnNest     15      /* Un-nest para */
#define sprmPHang       16      /* Hanging indent */
#define sprmPRgtbd      17      /* add a range of tabs  */
#define sprmPKeepFollow 18      /* Keep follow */
/*#define sprmPCAll       19      /* Clear all tabs */

/* Character */
#define sprmCBold       20      /* Bold */
#define sprmCItalic     21      /* Italic */
#define sprmCUline      22      /* Underline */
#define sprmCPos        23      /* Super/subscript */
#define sprmCFtc        24      /* Font code */
#define sprmCHps        25      /* Half-point size */
#define sprmCSame       26      /* Whole CHP */
#define sprmCChgFtc     27      /* Alter Font code */
#define sprmCChgHps     28      /* Alter point size */
#define sprmCPlain      29      /* Change to plain text (preserve font) */
#define sprmCShadow     30      /* Shadow text attribute */
#define sprmCOutline    31      /* Outline text attribute */
#define sprmCCsm        32      /* case modification */

#define sprmCStrike     33      /* Strikeout */               /* unused */
#define sprmCDline      34      /* Double underline */        /* unused */
/*#define sprmCPitch    35      /* Pitch */
/*#define sprmCOverset  36      /* Margin overset */
/*#define sprmCStc      37      /* Style (overrides all others) */
#define sprmCMapFtc     38      /* Defines font code mapping */
#define sprmCOldFtc     39      /* Defines procedural font code mapping
                                   for old WORD files */

#define sprmPRhcNorm    40      /* Normalize rhc indent to be margin-relatve */
#define sprmMax         41      /* UPDATE WHEN ADDING SPRMS */

struct PRM
        { /* PropeRty Modifier -- 2 bytes only 
            (now 4 bytes so scratch file can be >64K (7.12.91) v-dougk) 
            Couldn't be 3 bytes because Heap mgmt in Write assumes
            word sizes of memory requests .  Don't know what would take 
            to change that. */
        unsigned char    fComplex        : 1; /* If fComplex == false . . . */
        unsigned char    sprm            : 7;
        CHAR     val;
        WORD dummy;
        };

struct PRMX
        { /* PropeRty Modifier, part 2 */
        unsigned     int fComplex        : 1; /* if fComplex == true */
        unsigned     int bfprm_hi        : 15;
        unsigned     int  bfprm_low          ;
        };

extern struct PRM PrmAppend(struct PRM prm, CHAR *psprm);
extern DoPrm(struct CHP *pchp, struct PAP *ppap, struct PRM prm);

#define fcSCRATCHPRM(prm) (((((typeFC)(((struct PRMX *)&(prm))->bfprm_hi )) << 16) + \
                             (((typeFC)(((struct PRMX *)&(prm))->bfprm_low))      )) << 1)
#define bPRMNIL(prm)      (!((prm).fComplex) && !((prm).sprm) && !((prm).val))
#define SETPRMNIL(prm)    ((prm).fComplex = (prm).sprm = (prm).val = (prm).dummy = 0)

/* Definitions for ESPRM */
#define ESPRM_cch       000003  /* Mask for cch of sprm */
#define ESPRM_sgcMult   000004  /* Sgc multiplier */
#define ESPRM_sgc       000014  /* Sprm Group Code mask */
#define ESPRM_spr       000040  /* Sprm priority mask */
#define ESPRM_fClobber  000100  /* Overrides sprms with same sgc and <= spr */
#define ESPRM_fSame     000200  /* Overrides another instance of same sprm */

#define sgcChar         (0 * ESPRM_sgcMult)
#define sgcPara         (1 * ESPRM_sgcMult)
#define sgcParaSpec     (2 * ESPRM_sgcMult)

#define hpsSuperSub     12

#define dxaTabDelta     50
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\printdef.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* printdefs.h */

#ifndef PAGEONLY        /* ifdef for page table declarations only */

#define wNotSpooler	12741	/* an infamous number */

#define cchMaxProfileSz	256
#define cchMaxIDSTR     30

struct PLD
        { /* print line descriptor */
        typeCP cp;
        int ichCp;
        RECT rc;
        BOOL fParaFirst;
        };

#define cwPLD           (sizeof(struct PLD) / sizeof(int))
#define cpldInit        25
#define cpldChunk       10
#define cpldRH          5

#endif  /* PAGEONLY */

#define ipgdMaxFile     2

struct PGD
        {
        int pgn;
        typeCP cpMin;
        };

#define bcpPGD          2
#define cchPGD          (sizeof(struct PGD))
#define cwPGD           (sizeof(struct PGD) / sizeof(int))
#define cpgdChunk       10
#define cwPgtbBase      2

struct PGTB
        { /* Page table */
        int             cpgd;   /* Number of entries (sorted ascending) */
        int             cpgdMax; /* Heap space allocated */
        struct PGD      rgpgd[ipgdMaxFile]; /* Size varies */
        };

struct PDB
        { /* Print dialog buffer */
        struct PLD      (**hrgpld)[];
        int             ipld;
        int             ipldCur;
        struct PGTB     **hpgtb;
        int             ipgd;
        BOOL            fCancel;
        BOOL            fRemove;
        };

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\quit.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Quit.c -- MW quit commands (non-resident) */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
//#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOFONT
#define NOHDC
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMINMAX
//#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "str.h"
#include "cmddefs.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "wwdefs.h"
#include "propdefs.h"
#include "dlgdefs.h"
#include "commdlg.h"
#if defined(OLE)
#include "obj.h"
#endif

#include "debug.h"

extern PRINTDLG PD;  /* Common print dlg structure, initialized in the init code */
extern struct FCB       (**hpfnfcb)[];
extern int      fnMac;
extern struct WWD rgwwd[];
extern int      wwMac;
extern struct DOD (**hpdocdod)[];
extern int             docCur;     /* Document in current ww */
extern int              vfExtScrap;
extern int              rgval[];
extern int              docMac;
extern int              vfBuffersDirty;
extern int              vdxaPaper;
extern int              vdyaPaper;
extern int              ferror;
extern int              docScrap;
extern struct PAP       vpapAbs;
extern int              vccpFetch;
extern CHAR             *vpchFetch;
extern int              vfScrapIsPic;
extern typeCP           vcpLimParaCache;


FMmwClose( hwnd )
HWND hwnd;
{   /* Handle WM_CLOSE message sent to parent window. Return FALSE if
       the CLOSE should be aborted, TRUE if it is OK to go ahead
       and CLOSE (DestroyWindow is called in this case). */

 extern int vfDead;
 extern VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL);
extern WORD fPrintOnly;

 if (fPrintOnly || FConfirmSave())
    {
    extern int vfOwnClipboard;

    FreeMemoryDC( FALSE );   /* To give FRenderAll max memory */

    /* Render Data BEFORE the world collapses around our ears */
    if (vfOwnClipboard)
        {   /* We are the clipboard owner -- render the clipboard contents in
               all datatypes that we know about */
        if (!FRenderAll())
                /* Render failed; abort close */
            return FALSE;
        }

#if defined(OLE)
    if (ObjClosingDoc(docCur,NULL)) // do this *after* call to RenderAll!
        return FALSE;
#endif

    /* pen windows */
    if (lpfnRegisterPenApp)   // global
        (*lpfnRegisterPenApp)((WORD)1, fFalse);   // deregister

    if (PD.hDevMode)
        {
        /* We'd opened a Win3 printer driver before, now discard */
        GlobalFree(PD.hDevMode);
        PD.hDevMode = NULL;
        }
    vfDead = TRUE;  /* So we don't repaint or idle anymore */

    DestroyWindow( hwnd );
    KillTempFiles( FALSE );
    return TRUE;        /* OK to close window */
    }

 return FALSE;  /* ABort the close */
}




MmwDestroy()
{   /* Parent window is being destroyed */
 extern HWND hParentWw;
 extern HWND vhWndPageInfo;
 extern HDC vhDCRuler;
 extern HBRUSH hbrBkgrnd;
 extern HFONT vhfPageInfo;
 extern HBITMAP hbmBtn;
 extern HBITMAP hbmMark;
#ifdef JAPAN 	//01/21/93
 extern HANDLE hszNoMemorySel;
#endif
 extern HANDLE hszNoMemory;
 extern HANDLE hszDirtyDoc;
 extern HANDLE hszCantPrint;
 extern HANDLE hszPRFAIL;

 HBRUSH hbr = GetStockObject( WHITE_BRUSH );
 HDC hDC = GetDC( vhWndPageInfo );

#ifdef WIN30
    {
    /* We use the help engine so advise it we're going far far away */

    CHAR sz[cchMaxFile];
    PchFillPchId(sz, IDSTRHELPF, sizeof(sz));
    WinHelp(hParentWw, (LPSTR)sz, HELP_QUIT, NULL);
    }
#endif

 FreeMemoryDC( TRUE );
 SelectObject( GetDC( hParentWw ), hbr );
 SelectObject( wwdCurrentDoc.hDC, hbr );
 if (vhDCRuler != NULL)
    {
    SelectObject( vhDCRuler, hbr );
    }
 DeleteObject( hbrBkgrnd );

 DeleteObject( SelectObject( hDC, hbr ) );
 if (vhfPageInfo != NULL)
     {
     DeleteObject( SelectObject( hDC, GetStockObject( SYSTEM_FONT ) ) );
     }

 if (hbmBtn != NULL)
     {
     DeleteObject( hbmBtn );
     }
 if (hbmMark != NULL)
     {
     DeleteObject( hbmMark );
     }

#ifdef JAPAN 	//01/21/93
 if (hszNoMemorySel != NULL)
     {
     GlobalFree( hszNoMemorySel );
     }
#endif
 if (hszNoMemory != NULL)
     {
     GlobalFree( hszNoMemory );
     }
 if (hszDirtyDoc != NULL)
     {
     GlobalFree( hszDirtyDoc );
     }
 if (hszCantPrint != NULL)
     {
     GlobalFree( hszCantPrint );
     }
 if (hszPRFAIL != NULL)
     {
     GlobalFree( hszPRFAIL );
     }

#if defined(JAPAN) & defined(DBCS_IME)
 /* Release Ime communication memory */
{
    extern HANDLE   hImeMem;
    extern HANDLE   hImeSetFont;

    if (hImeMem)
        GlobalFree(hImeMem);

    if(hImeSetFont != NULL) {
        HDC hdc;
        HANDLE oldhfont;

        hdc = GetDC(NULL);
        oldhfont = SelectObject(hdc,hImeSetFont);
        SelectObject(hdc,oldhfont);
        DeleteObject(hImeSetFont);
        ReleaseDC(NULL, hdc);
    }
}
#endif

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IR_UNDETERMINE
 /* Release Ime Undetermin string & attrib memory */
{
    extern HANDLE   hImeUnAttrib;
    extern HANDLE   hImeUnString;
    extern CHAR     szWriteProduct[];
    extern CHAR     szImeHidden[];
    extern int      vfImeHidden; /*T-HIROYN ImeHidden Mode flag*/

    if (hImeUnAttrib)
        GlobalFree(hImeUnAttrib);

    if (hImeUnString)
        GlobalFree(hImeUnString);

    WriteProfileString((LPSTR)szWriteProduct, (LPSTR)szImeHidden,
                vfImeHidden ? (LPSTR)"1" : (LPSTR)"0" );
}
#endif


#ifdef FONT_KLUDGE
 RemoveFontResource( (LPSTR)"helv.fon" );
#endif /* FONT_KLUDGE */

#if defined(OLE)
    ObjShutDown();
#endif

 PostQuitMessage( 0 );
}




KillTempFiles( fEndSession )
int fEndSession;
{   /* Kill off all of the temp files. MEMO cannot run after this is done */
int f;
int fn, fnT;

CloseEveryRfn( TRUE );

/* Delete all temp files */

/* loop thru the FCB table looking for files that should be deleted before
      we quit. */
for (fn = 0; fn < fnMac; fn++)
        {
        int fpe;
        struct FCB *pfcb = &(**hpfnfcb)[fn];
        if (pfcb->rfn != rfnFree && pfcb->fDelete)
                /* Having found a file that must be deleted, delete it */
                {
                /* This should be FDeleteFile all of the time, but we don't
                   want to add a window enumeration during End Session
                   at this very late stage of the project */

                if (fEndSession)
                    FpeDeleteSzFfname( **pfcb->hszFile );
                else
                    FDeleteFile( **pfcb->hszFile );
                (**hpfnfcb) [fn].rfn = rfnFree;
                }
        }
}






#ifdef ENABLE   /* Part of "Save All", not needed */
int CnfrmSz(sz)
CHAR    *sz;
{
extern   AlertBoxSz2();
int     cch;

cch = CchFillSzId(&stBuf[1], IDPMTSaveChanges);
stBuf[++cch] = chSpace;
cch += CchCopySz(sz, &stBuf[cch+1]);
stBuf[++cch] = chQMark;
stBuf[0] = cch;
return(AlertBoxSz2(stBuf));
}
#endif  /* ENABLE */



#ifdef ENABLE   /* Not needed, only 1 document in MEMO */
int
FAllDocsClean()
{
int     fAllClean = true;
int     dty;
int     doc;

if (vfBuffersDirty)
        return false;

for (doc = 0; doc < docMac; ++doc)
        {
        dty = (**hpdocdod)[doc].dty;
        if ((dty != dtyNormal && dty != dtySsht) ||
                (**hpdocdod)[doc].hpctb == 0  || !(**hpdocdod)[doc].fDirty)
                continue;
        fAllClean = false;
        }
return fAllClean;
}
#endif



#ifdef ENABLE    /* We don't support saving between-session state info */
WriteStateInfo()
{ /* Write out state information into Word resource file */
        struct STATEINFO stiTemp;
        HANDLE           hRes, hData;

        UseResFile(vresSystem);

        SetWords(&stiTemp,0,cwSTATEINFO);

        stiTemp.sf.fScrnDraftStor = vfScrnDraft;
        stiTemp.sf.fPrintModeStor = vfPrintMode;
        stiTemp.sf.fDriverDefaultOK = vfDriverDefaultOK;
        stiTemp.utCurStor = utCur;
        stiTemp.vcDaisyPitchStor = vcDaisyPitch;
        stiTemp.vBaudRateStor =vBaudRate;
        stiTemp.vPortNumStor = vPortNum;
        if (hszPrdFile != 0)
                {/* User has a Word printer driver selected currently */
                int cch = CchCopySz(**hszPrdFile,stiTemp.rgchPrd);
                stiTemp.vdxaPaperStor = vdxaPaper;
                stiTemp.vdyaPaperStor = vdyaPaper;
                stiTemp.sf.fPrintStateOK = true;
                }
        else
                stiTemp.sf.fPrintStateOK = false;
        hRes = GetResource(WINF, 1);
        if (hRes != 0L)
                RmveResource(hRes);
        hData = NewHandle(0);
        if (HandleAppendQ(hData,&stiTemp,sizeof(stiTemp)))
                AddResource(hData, WINF, 1, "");
        }
#endif  /* ENABLE */


fnQuit(hWnd)
/* user has selected Quit menu item... */
HWND hWnd;
{
    SendMessage(hWnd, WM_CLOSE, 0, 0L);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\printdlg.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1990 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOCLIPBOARD
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMETAFILE
#define NOWH
#define NOWNDCLASS
#define NOSOUND
#define NOCOLOR
#define NOSCROLL
#define NOCOMM

#include <windows.h>
#include "mw.h"
#include "dlgdefs.h"
#include "cmddefs.h"
#include "machdefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "printdef.h"
#include "str.h"
#include "fmtdefs.h"
#include <commdlg.h>
#include <cderr.h>
#include <print.h>
#include <stdlib.h>

extern CHAR (**hszPrinter)[];
extern CHAR (**hszPrDriver)[];
extern CHAR (**hszPrPort)[];
extern BOOL vfPrDefault;

#ifdef JAPAN                  //  added  08 Jun. 1992  by Hiraisi
BOOL FAR PASCAL _export fnPrintHook( HWND, UINT, WPARAM, LPARAM );
extern HANDLE   hMmwModInstance;
BOOL fWriting = FALSE;
BOOL bWriting = FALSE;
#endif    //JAPAN

BOOL vbCollate = TRUE;

static void GetPrNames(BOOL bPrDialog);
PRINTDLG PD = {0,0,0,0,0}; /* Common print dlg structure, initialized in the init code */

void PrinterSetupDlg(BOOL bGetDevmodeOnly /* not used */)
{
    extern HWND vhWnd;
    BOOL bDevMode = PD.hDevMode ? TRUE : FALSE;

    PD.Flags |= PD_PRINTSETUP;
    PD.Flags &= ~PD_RETURNDEFAULT;

    if (vfPrDefault && !PD.hDevNames)
        if (PD.hDevMode)
        {
            /*
                So dlg will show that default is selected.  Its a pity
                to do this because hDevMode is perfectly good.  Alternative
                is to build a DevNames structure which we could do, but
                that would just allocate a new devmode anyways.
             */
            GlobalFree(PD.hDevMode);
            PD.hDevMode = 0;
        }

#ifdef JAPAN                  //  added  08 Jun. 1992  by Hiraisi
    PD.hInstance = NULL;
    PD.lpPrintTemplateName = (LPCSTR)NULL;
    PD.Flags    &= ~PD_ENABLEPRINTTEMPLATE;
    PD.Flags    &= ~PD_ENABLEPRINTHOOK;
#endif    //JAPAN

TryPrnSetupAgain:
    if (!PrintDlg(&PD))
    {
        /* Bug #11531:  When PrintDlg returns 0, it could me we gave it garbage in
        * the DevNames or DevMode structures, perhaps due to the user making
        * changes through Control Panel that we don't monitor.  Clean out the
        * appropriate structure and try again.  Note that these errors can't be
        * returned to us again after cleaning out the structure.
        *   23 August 1991    Clark R. Cyr
        */
        switch (CommDlgExtendedError())
        {
            case PDERR_PRINTERNOTFOUND:
            case PDERR_DNDMMISMATCH:
                if (PD.hDevNames)
                {
                    GlobalFree(PD.hDevNames);
                    PD.hDevNames = 0;
                }

                if (PD.hDevMode)
                {
                    GlobalFree(PD.hDevMode);
                    PD.hDevMode = 0;
                }
            goto TryPrnSetupAgain;

            default:
            return;
        }
    }

    PD.Flags &= ~PD_PRINTSETUP;

    GetPrNames(FALSE); // this gets new PrinterDC

    ResetFontTables();

#if defined(OLE)
    ObjSetTargetDevice(TRUE);
#endif

    InvalidateRect(vhWnd, (LPRECT)NULL, fFalse);

    return;
}

void fnPrPrinter(
    void)
{
    /* This routine is the outside world's interface to the print code. */
    extern int docCur;
    extern int vfPrPages, vpgnBegin, vpgnEnd, vcCopies;
    extern WORD fPrintOnly;
    extern CHAR (**hszPrPort)[];
    HANDLE hPort=NULL;
    LPDEVNAMES lpDevNames;
    int Len3;
    char szPort[cchMaxFile];
    extern struct SEL       selCur;
    BOOL bDevMode = PD.hDevMode ? TRUE : FALSE;
#ifdef JAPAN                  //  added  08 Jun. 1992  by Hiraisi
    FARPROC lpfnPrintHook;
    BOOL bReturn;
#endif

    PD.Flags &= ~(PD_RETURNDEFAULT|PD_PRINTSETUP|PD_SELECTION); /*turn off PRINTSETUP flag */
    if (vbCollate)
        PD.Flags |= PD_COLLATE;
    else
        PD.Flags &= ~PD_COLLATE;

    if (selCur.cpFirst == selCur.cpLim) // no selection
        PD.Flags |= PD_NOSELECTION;
    else
        PD.Flags &= ~PD_NOSELECTION;

    if (vfPrDefault && !PD.hDevNames)
        if (PD.hDevMode)
        {
            /*
                So dlg will show that default is selected.  Its a pity
                to do this beause hDevMode is perfectly good.  Alternative
                is to build a DevNames structure.
             */
            GlobalFree(PD.hDevMode);
            PD.hDevMode = 0;
        }

#ifdef JAPAN                  //  added  08 Jun. 1992  by Hiraisi
    PD.hInstance = hMmwModInstance;
    PD.Flags    |= PD_ENABLEPRINTTEMPLATE;
    PD.lpPrintTemplateName = (LPCSTR)MAKEINTRESOURCE( dlgPrint );
    PD.Flags    |= PD_ENABLEPRINTHOOK;
    lpfnPrintHook = MakeProcInstance( fnPrintHook, hMmwModInstance );
    PD.lpfnPrintHook = (FARPROC)lpfnPrintHook;
TryPrintAgain:
    bReturn = PrintDlg(&PD);
    FreeProcInstance( lpfnPrintHook );
    if (!bReturn)
#else
TryPrintAgain:
    if (!PrintDlg(&PD))
#endif
    {
        switch (CommDlgExtendedError())
        {
            case PDERR_PRINTERNOTFOUND:
            case PDERR_DNDMMISMATCH:
                if (PD.hDevNames)
                {
                    GlobalFree(PD.hDevNames);
                    PD.hDevNames = 0;
                }

                if (PD.hDevMode)
                {
                    GlobalFree(PD.hDevMode);
                    PD.hDevMode = 0;
                }
            goto TryPrintAgain;

            default:
                if (!bDevMode && PD.hDevMode)
                {
                    GlobalFree(PD.hDevMode);
                    PD.hDevMode = 0;
                }
            return;
        }
    }

#ifdef JAPAN                  //  added  08 Jun. 1992  by Hiraisi
    fWriting = bWriting;
#endif

    if (PD.Flags & PD_PAGENUMS)     /* Page Range specified? */
    {
        vfPrPages = TRUE;
        if (PD.nFromPage)
            vpgnBegin = PD.nFromPage;
        if (PD.nToPage)
            vpgnEnd = PD.nToPage;
        if (vpgnEnd < vpgnBegin)
        {
            int temp = vpgnBegin;

            vpgnBegin = vpgnEnd;
            vpgnEnd = temp;
        }
    }
    else                            /* No, print all pages */
        vfPrPages = FALSE;

    vcCopies = PD.nCopies;
    vbCollate = PD.Flags & PD_COLLATE;

    GetPrNames(TRUE);

    /**  At this point, we have the following :

    vfPrPages = true if print page range else print all pages
    vpgnBegin = starting page number (if vfPrPages)
    vpgnEnd   = ending page number (if vfPrPages)
    vcCopies  = number of copies to print
    vbCollate = whuddya think?
    **/

#if defined(OLE)
    ObjSetTargetDevice(TRUE);
#endif

    if (PD.Flags & PD_SELECTION)
    {
        int docTmp;
        BOOL bIssueError;
        extern WORD ferror;
        extern typeCP cpMinCur, cpMacCur, cpMinDocument;
        extern struct DOD      (**hpdocdod)[];
        typeCP cpMinCurT = cpMinCur;
        typeCP cpMacCurT = cpMacCur;
        typeCP cpMinDocumentT = cpMinDocument;

        docTmp = DocCreate(fnNil, HszCreate(""), dtyNormal);
        if (docTmp != docNil)
        {
            ClobberDoc( docTmp, docCur, selCur.cpFirst, selCur.cpLim-selCur.cpFirst );

            if (!ferror)
            {
                cpMinCur = cp0;
                cpMacCur = (**hpdocdod) [docTmp].cpMac;
                PrintDoc(docTmp, TRUE);
                cpMinCur = cpMinCurT;
                cpMacCur = cpMacCurT;
            }

        }

        cpMinDocument = cpMinDocumentT;  /* destroyed possibly by DocCreate */

        bIssueError = ferror;

        if (ferror)
            ferror = FALSE; // to enable the following:

        if (docTmp != docNil)
            KillDoc (docTmp); // do this first to free memory to assist messagebox if necessary

        if (bIssueError)
            Error(IDPMTPRFAIL);
    }
    else
        PrintDoc(docCur, TRUE);
}

BOOL FInitHeaderFooter(fHeader, ppgn, phrgpld, pcpld)
BOOL fHeader;
unsigned *ppgn;
struct PLD (***phrgpld)[];
int *pcpld;
    {
    /* This routine initializes the array of print line descriptors used in
    positioning the header/footer on the printed page.  FALSE is returned if an
    error occurs; TRUE otherwise. */

    extern typeCP cpMinHeader;
    extern typeCP cpMacHeader;
    extern typeCP cpMinFooter;
    extern typeCP cpMacFooter;
    extern int docCur;
    extern struct PAP vpapAbs;
    extern struct SEP vsepAbs;
    extern int dxaPrOffset;
    extern int dyaPrOffset;
    extern int dxpPrPage;
    extern int dxaPrPage;
    extern int dypPrPage;
    extern int dyaPrPage;
    extern struct FLI vfli;
    extern int vfOutOfMemory;

    typeCP cpMin;
    typeCP cpMac;

    /* Get the cpMin and the cpMac for the header/footer. */
    if (fHeader)
        {
        cpMin = cpMinHeader;
        cpMac = cpMacHeader;
        }
    else
        {
        cpMin = cpMinFooter;
        cpMac = cpMacFooter;
        }

    /* Is there a header/footer. */
    if (cpMac - cpMin > ccpEol)
        {
        int cpld = 0;
        int cpldReal = 0;
        int cpldMax;
        int xp;
        int yp;
        int ichCp = 0;
        typeCP cpMacDoc = CpMacText(docCur);

        /* Compute the page number of the start of the headers/footers. */
        CacheSect(docCur, cpMin);
        if ((*ppgn = vsepAbs.pgnStart) == pgnNil)
            {
            *ppgn = 1;
            }

        /* Does the header/footer appear on the first page. */
        CachePara(docCur, cpMin);
        if (!(vpapAbs.rhc & RHC_fFirst))
            {
            (*ppgn)++;
            }

        /* Calculate the bounds of the header/footer in pixels. */
        xp = MultDiv(vsepAbs.xaLeft - dxaPrOffset, dxpPrPage, dxaPrPage);
        yp = fHeader ? MultDiv(vsepAbs.yaRH1 - dyaPrOffset, dypPrPage,
          dyaPrPage) : 0;

        /* Initialize the array of print line descriptors for the header/footer.
        */
        if (FNoHeap(*phrgpld = (struct PLD (**)[])HAllocate((cpldMax = cpldRH) *
          cwPLD)))
            {
            *phrgpld = NULL;
            return (FALSE);
            }

        /* We now have to calculate the array of print line descriptors for the
        header/footer. */
        cpMac -= ccpEol;
        while (cpMin < cpMac)
            {
            /* Format this line of the header/footer for the printer. */
            FormatLine(docCur, cpMin, ichCp, cpMacDoc, flmPrinting);

            /* Bail out if an error occurred. */
            if (vfOutOfMemory)
                {
                return (FALSE);
                }

            /* Is the array of print line descriptors big enough? */
            if (cpld >= cpldMax && !FChngSizeH(*phrgpld, (cpldMax += cpldRH) *
              cwPLD, FALSE))
                {
                return (FALSE);
                }

            /* Fill the print line descriptor for this line. */
                {
                register struct PLD *ppld = &(***phrgpld)[cpld++];

                ppld->cp = cpMin;
                ppld->ichCp = ichCp;
                ppld->rc.left = xp + vfli.xpLeft;
                ppld->rc.right = xp + vfli.xpReal;
                ppld->rc.top = yp;
                ppld->rc.bottom = yp + vfli.dypLine;
                }

            /* Keep track of the non-blank lines in the header/footer */
            if ((vfli.ichReal > 0) || vfli.fGraphics)
                {
                cpldReal = cpld;
                }

            /* Bump the counters. */
            cpMin = vfli.cpMac;
            ichCp = vfli.ichCpMac;
            yp += vfli.dypLine;
            }

        /* If this is a footer, then we have to move the positions of the lines
        around so that the footer ends where the user has requested. */
        if (!fHeader && cpldReal > 0)
            {
            register struct PLD *ppld = &(***phrgpld)[cpldReal - 1];
            int dyp = MultDiv(vsepAbs.yaRH2 - dyaPrOffset, dypPrPage, dyaPrPage)
              - ppld->rc.bottom;
            int ipld;

            for (ipld = cpldReal; ipld > 0; ipld--, ppld--)
                {
                ppld->rc.top += dyp;
                ppld->rc.bottom += dyp;
                }
            }

        /* Record the number of non-blank lines in the head/footer. */
        *pcpld = cpldReal;
        }
    else
        {
        /* Indicate there is no header/footer. */
        *ppgn = pgnNil;
        *phrgpld = NULL;
        *pcpld = 0;
        }
    return (TRUE);
    }



static void GetPrNames(BOOL bPrDialog)
{
    HANDLE hPrinter = NULL, hDriver = NULL, hPort = NULL;
    LPDEVNAMES lpDevNames;
    char szPrinter[cchMaxFile], szDriver[cchMaxFile], szPort[cchMaxFile];
    int Len1, Len2, Len3;            /* count of words in each string */

    hPrinter = NULL;
    hDriver = NULL;
    hPort = NULL;

    lpDevNames = MAKELP(PD.hDevNames,0);

    if (lpDevNames == NULL)
        /* we're in trouble */
        return;

    lstrcpy(szPrinter, (LPSTR)lpDevNames+lpDevNames->wDeviceOffset);
    lstrcpy(szDriver, (LPSTR)lpDevNames+lpDevNames->wDriverOffset);

    if (bPrDialog && (PD.Flags & PD_PRINTTOFILE))
        lstrcpy(szPort, (LPSTR)"FILE:");
    else
        lstrcpy(szPort, (LPSTR)lpDevNames+lpDevNames->wOutputOffset);

    vfPrDefault = lpDevNames->wDefault & DN_DEFAULTPRN;

    if (FNoHeap((hPrinter = (CHAR (**)[])HAllocate(Len1 =
        CwFromCch(CchSz(szPrinter))))))
        goto err;
    if (FNoHeap((hDriver = (CHAR (**)[])HAllocate(Len2 =
        CwFromCch(CchSz(szDriver))))))
        goto err;
    if (FNoHeap((hPort = (CHAR (**)[])HAllocate(Len3 =
        CwFromCch(CchSz(szPort))))))
        goto err;

    /* Free old printer, driver and port handles */
    if (hszPrinter)
        FreeH(hszPrinter);
    if (hszPrDriver)
        FreeH(hszPrDriver);
    if (hszPrPort)
        FreeH(hszPrPort);
    /* Set printer, driver and port handles */
    hszPrinter = hPrinter;
    hszPrDriver = hDriver;
    hszPrPort = hPort;

    /* copy strings into the memory corresponding to the new handles */
    blt(szPrinter, *hszPrinter, Len1);
    blt(szDriver, *hszPrDriver, Len2);
    blt(szPort, *hszPrPort, Len3);

    FreePrinterDC();
    GetPrinterDC(FALSE);
    return;

    err:
    if (FNoHeap(hPrinter))
        FreeH(hPrinter);
    if (FNoHeap(hDriver))
        FreeH(hDriver);
    if (FNoHeap(hPort))
        FreeH(hPort);
}

BOOL fnPrGetDevmode(void)
/*  Set the devmode structure for the currently-selected printer,
    Assumes all needed values are correctly initialized!
    Return whether an error. */
{
    int nCount;
    HANDLE hDevice=NULL;
    FARPROC lpfnDevMode;
    BOOL bRetval=FALSE;
    char  szDrvName[_MAX_PATH];

    if (PD.hDevMode) // then already set (why called?)
        return FALSE;
    else if (PD.hDevNames) // then device is not extended
        return TRUE;

    if (hszPrinter == NULL || hszPrDriver == NULL || hszPrPort == NULL)
        return TRUE;

    if (**hszPrinter == '\0' || **hszPrDriver == '\0' || **hszPrPort == '\0')
        return TRUE;

    /* is this necessary for GetModuleHandle?  For sure if calling LoadLibrary(). */
    wsprintf((LPSTR)szDrvName, (LPSTR)"%s%s", (LPSTR)*hszPrDriver, (LPSTR)".DRV");

#if 1
    SetErrorMode(1); /* No kernel error dialogs */
    if ((hDevice = LoadLibrary((LPSTR)szDrvName)) < 32)
    {
        bRetval = TRUE;
        goto end;
    }
#else
    hDevice = GetModuleHandle((LPSTR)szDrvName);
#endif


    if ((lpfnDevMode = GetProcAddress(hDevice, (LPSTR)"ExtDeviceMode")) == NULL)
    {
#ifdef DEBUG
        OutputDebugString("Unable to get extended device\n\r");
#endif

        bRetval = TRUE;
        goto end;
    }

    /* get sizeof devmode structure */
    nCount = (*lpfnDevMode)(NULL,
                            hDevice,
                            (LPSTR)NULL,
                            (LPSTR)(*hszPrinter),
                            (LPSTR)(*hszPrPort),
                            (LPSTR)NULL,
                            (LPSTR)NULL,
                            NULL);

    if ((PD.hDevMode =
        GlobalAlloc(GMEM_MOVEABLE,(DWORD)nCount)) == NULL)
    {
        bRetval = TRUE;
        goto end;
    }

    if ((*lpfnDevMode)( NULL,
                        hDevice,
                        MAKELP(PD.hDevMode,0),
                        (LPSTR)(*hszPrinter),
                        (LPSTR)(*hszPrPort),
                        (LPSTR)NULL,
                        (LPSTR)NULL,
                        DM_COPY) != IDOK)
    {
        GlobalFree(PD.hDevMode);
        PD.hDevMode = NULL;
        bRetval = TRUE;
        goto end;
    }

    end:

#if 1
    if (hDevice >= 32)
        FreeLibrary(hDevice);
#endif

    SetErrorMode(0); /* reset kernel error dialogs */

    /* can't allow hDevNames to be out of sync with hDevmode */
    if (PD.hDevNames)
    {
        GlobalFree(PD.hDevNames);
        PD.hDevNames = NULL;
    }

    return bRetval;
}


#ifdef JAPAN                  //  added  08 Jun. 1992  by Hiraisi

#include <dlgs.h>

BOOL FAR PASCAL _export fnPrintHook( hDlg, uMsg, wParam, lParam )
HWND hDlg;
UINT uMsg;
WPARAM wParam;
LPARAM lParam;
{
    switch( uMsg ){
    case  WM_INITDIALOG:
        CheckRadioButton(hDlg, rad4, rad5, fWriting ? rad5 : rad4 );
        return TRUE;
    case  WM_COMMAND:
        switch( wParam ){
        case  rad4:
        case  rad5:
            if( HIWORD(lParam) == BN_CLICKED ){
                CheckRadioButton(hDlg, rad4, rad5, wParam );
                bWriting = ( wParam == rad4 ? FALSE : TRUE );
                return TRUE;
            }
        default:
            break;
        }
    default:
        break;
    }
    return FALSE;
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\propdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* propdefs.h - MW defsfor char/para properties */

#define hpsNegMin       128
/* NOTE - "hpsNormal" is used for incremental encoding/decoding of chps in doc
   files, hpsDefault is the size the guy starts typing into a new doc with */
#define hpsNormal       24

#ifdef KOREA
#define hpsDefault      24
#else
#ifdef JAPAN
#define hpsDefault      24      //T-HIROYN Win3.1
#else
#define hpsDefault      20
#endif
#endif

struct TBD      /* Tab Descriptor */
        {
        unsigned        dxa;        /* distance from left margin of tab stop */
        unsigned char   jc : 3;     /* justification code */
        unsigned char   tlc : 3;    /* leader dot code */
        unsigned char   opcode : 2; /* operation code for Format Tabs */
        CHAR            chAlign;    /* ASCII code of char to align on
                                       if jcTab=3, or 0 to align on '.' */
        };

#define cchTBD          (sizeof (struct TBD))
#define cwTBD           (sizeof (struct TBD) / sizeof (int))
#define itbdMax         13
#define itbdMaxWord     20
#define cchMaxNum       10

struct CHP      /* Character properties */
        {
        unsigned       fStyled : 1;                            /* BYTE 0 */
        unsigned       stc : 7;        /* style */
        unsigned       fBold : 1;                              /* BYTE 1 */
        unsigned       fItalic : 1;
        unsigned       ftc : 6;        /* Font code */
        unsigned       hps : 8;        /* Size in half pts */  /* BYTE 2 */
        unsigned       fUline : 1;                             /* BYTE 3 */
        unsigned       fStrike : 1;
        unsigned       fDline: 1;
        unsigned       fOverset : 1;
        unsigned       csm : 2;        /* Case modifier */
        unsigned       fSpecial : 1;
        unsigned       : 1;
        unsigned       ftcXtra : 3;                            /* BYTE 4 */
        unsigned       fOutline : 1;
        unsigned       fShadow : 1;
        unsigned       : 3;
        unsigned       hpsPos : 8;                             /* BYTE 5 */
        unsigned       fFixedPitch : 1; /* used internally only */
        unsigned       psWidth : 7;
        unsigned       chLeader : 8;
        unsigned       ichRun : 8;
        unsigned       cchRun : 8;
        };

#define cchCHP          (sizeof (struct CHP))
#define cwCHP           (cchCHP / sizeof (int))
#define cchCHPUsed      (cchCHP - 3)


#define csmNormal       0
#define csmUpper        1
#define csmSmallCaps    3


/* Justification codes: must agree with menu.mod */
#define jcLeft          0
#define jcCenter        1
#define jcRight         2
#define jcBoth          3

#define jcTabMin        4
#define jcTabLeft       4
#define jcTabCenter     5
#define jcTabRight      6
#define jcTabDecimal    7
                          /* nice, safe invalid jc value */
#define jcNil           -1

/* Tab leader codes: must agree with menu.mod */
#define tlcWhite        0
#define tlcDot          1
#define tlcHyphen       2
#define tlcUline        3


struct PAP      /* Paragraph properties */
        {
        unsigned        fStyled : 1;                            /* BYTE 0 */
        unsigned        stc : 7;
        unsigned        jc : 2;                                 /* BYTE 1 */
        unsigned        fKeep : 1;
        unsigned        fKeepFollow : 1;
        unsigned        : 4;
        unsigned        stcNormChp : 7;                         /* BYTE 2 */
        unsigned        : 9;                                    /* BYTE 3 */
        unsigned        dxaRight;                               /* BYTE 4-5 */
        unsigned        dxaLeft;                                /* BYTE 6-7 */
        unsigned        dxaLeft1;                               /* BYTE 8-9 */
        unsigned        dyaLine;                                /* 10-11 */
        unsigned        dyaBefore;                              /* 12-13 */
        unsigned        dyaAfter;                               /* 14-15 */
        unsigned        rhc : 4;        /* Running hd code */
        unsigned        fGraphics : 1;  /* Graphics bit */
        unsigned        wUnused1 : 11;
        int             wUnused2;
        int             wUnused3;
        struct TBD      rgtbd[itbdMaxWord];
        };

#define cchPAP  (sizeof (struct PAP))
#define cwPAP   (cchPAP / sizeof (int))
#define cwPAPBase (cwPAP - cwTBD * itbdMaxWord)

struct SEP
        { /* Section properties */
        unsigned        fStyled : 1;                            /* BYTE 0 */
        unsigned        stc : 7;
        unsigned        bkc : 3;        /* Break code */        /* BYTE 1 */
        unsigned        nfcPgn : 3;     /* Pgn format code */
        unsigned        :2;
        unsigned        yaMac;          /* Page height */       /* BYTE 2-3 */
        unsigned        xaMac;          /* Page width */        /* BYTE 4-5 */
        unsigned        pgnStart;       /* Starting pgn */      /* BYTE 6-7 */
        unsigned        yaTop;          /* Start of text */     /* BYTE 8-9 */
        unsigned        dyaText;        /* Height of text */    /* 10-11 */
        unsigned        xaLeft;         /* Left text margin */  /* 12-13 */
        unsigned        dxaText;        /* Width of text */     /* 14-15 */
        unsigned        rhc : 4;        /* *** RESERVED *** */  /* 16 */
                                        /* (Must be same as PAP) */
        unsigned        : 2;
        unsigned        fAutoPgn : 1;   /* Print pgns without hdr */
        unsigned        fEndFtns : 1;   /* Footnotes at end of doc */
        unsigned        cColumns : 8;   /* # of columns */      /* BYTE 17 */
        unsigned        yaRH1;          /* Pos of top hdr */    /* 18-19 */
        unsigned        yaRH2;          /* Pos of bottom hdr */ /* 20-21 */
        unsigned        dxaColumns;     /* Intercolumn gap */   /* 22-23 */
        unsigned        dxaGutter;      /* Gutter width */      /* 24-25 */
        unsigned        yaPgn;          /* Y pos of page nos */ /* 26-27 */
        unsigned        xaPgn;          /* X pos of page nos */ /* 28-29 */
        CHAR            rgbJunk[cchPAP - 30]; /* Pad to cchPAP */
        };


#define cchSEP  (sizeof (struct SEP))
#define cwSEP   (cchSEP / sizeof (int))


struct PROP
        { /* A CHP, PAP, or SEP. */
        unsigned char   fStyled : 1;
        unsigned char   stc : 7;
        CHAR            rgb[cchPAP - 1]; /* Variable size */
        };


#define cchPROP (sizeof (struct PROP))

typedef struct
        {             /* tri-state value for character/paragraph properties */
        unsigned wTsv;  /* 16 bit value */
        unsigned char   fGray;
        }TSV;


#define cchTSV (sizeof (TSV))
#define itsvMax         6
#define itsvchMax       6
#define itsvparaMax     5

    /* character index values */
#define itsvBold        0
#define itsvItalic      1
#define itsvUline       2
#define itsvPosition    3     /* 0 = normal; >0 = superscript; <0 = subscript */
#define itsvFfn         4     /* font name and family */
#define itsvSize        5     /* font size */
    /* paragraph index values */
#define itsvJust        0       /* justification (left, center, right, both) */
#define itsvSpacing     1
#define itsvLIndent     2       /* left indent */
#define itsvFIndent     3       /* first line indent */
#define itsvRIndent     4       /* right indent */





#define cyaInch         czaInch
#define cxaInch         czaInch
#define cyaTl           czaLine
#define dxaNest         720

extern int              cxaTc;

#define yaNil           0xffff
#define xaNil           0xffff

#define ypNil           0xffff
#define xpNil           0xffff

#define dyaMinUseful    cyaInch
#define dxaMinUseful    (cxaInch / 2)
#define cColumnsMax     (10)

#define bkcLine         0
#define bkcColumn       1
#define bkcPage         2
#define bkcRecto        3
#define bkcVerso        4

#define nfcArabic       0
#define nfcUCRoman      1
#define nfcLCRoman      2
#define nfcUCLetter     3
#define nfcLCLetter     4

#define pgnNil          (-1)

struct PROP *PpropXlate();

/* Running head codes */
#define RHC_fBottom     1
#define RHC_fOdd        2
#define RHC_fEven       4
#define RHC_fFirst      8

#define rhcDefault      (RHC_fOdd + RHC_fEven)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\rare.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This routine sets up the screen position used by Word relative to the
current device. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOATOM
#define NODRAWTEXT
#define NOMSG
#define NOOPENFILE
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "scrndefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "printdef.h"
#include "str.h"
#include "docdefs.h"
#include "propdefs.h"
#include "machdefs.h"
#include "fontdefs.h"
#include "winddefs.h"
#include <commdlg.h>


MmwWinSysChange(wm)
int wm;
    {
    /* This routine processes the WM_SYSCOLORCHANGE, WM_WININICHANGE,
    WM_DEVMODECHANGE, and WM_FONTCHANGE  messages. */

    extern HDC vhDCRuler;
    extern HBRUSH hbrBkgrnd;
    extern long rgbBkgrnd;
    extern long rgbText;
    extern struct WWD rgwwd[];
    extern HDC vhMDC;
    extern BOOL vfMonochrome;
    extern HWND hParentWw;
    extern HWND vhWndPageInfo;
    extern HBITMAP vhbmBitmapCache;
    extern BOOL vfBMBitmapCache;
    extern int vfPrinterValid;
    extern CHAR szWindows[];
    extern CHAR szDevices[];
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];
    extern CHAR (**hszDevmodeChangeParam)[];
    extern CHAR (**hszWininiChangeParam)[];
    extern HFONT vhfPageInfo;
    extern int docMode;
    extern HWND vhWndCancelPrint;
    extern BOOL vfIconic;
    extern BOOL vfWarnMargins;
    extern int wWininiChange;

    BOOL FSetWindowColors(void);

    CHAR szPrinter[cchMaxProfileSz];
    CHAR (**hszPrinterSave)[];
    CHAR (**hszPrDriverSave)[];
    CHAR (**hszPrPortSave)[];
    BOOL fNotPrinting = (vhWndCancelPrint == NULL);
    RECT rc;

    switch (wm)
        {
    case WM_SYSCOLORCHANGE:
        /* Someone is changing the system colors. */
        if (FSetWindowColors())
            {
            /* Change the colors of the ruler. */
            if (vhDCRuler != NULL)
                {
                HPEN hpen;

                /* Set the background and foreground colors of the ruler. */
                SetBkColor(vhDCRuler, rgbBkgrnd);
                SetTextColor(vhDCRuler, rgbText);

                /* Set the pen for the ruler. */
                if ((hpen = CreatePen(0, 0, rgbText)) == NULL)
                    {
                    hpen = GetStockObject(BLACK_PEN);
                    }
                DeleteObject(SelectObject(vhDCRuler, hpen));

                /* Set the background brush for the ruler. */
                SelectObject(vhDCRuler, hbrBkgrnd);
                }

            if (wwdCurrentDoc.hDC != NULL)
                {
                /* Set the background and foreground colors. */
                SetBkColor(wwdCurrentDoc.hDC, rgbBkgrnd);
                SetTextColor(wwdCurrentDoc.hDC, rgbText);

                /* Set the background brush. */
                SelectObject(wwdCurrentDoc.hDC, hbrBkgrnd);

                if (vhMDC != NULL && vfMonochrome)
                    {
                    /* If the display is a monochrome device, then set the text
                    color for the memory DC.  Monochrome bitmaps will not be
                    converted to the foreground and background colors in this
                    case, we must do the conversion. */
                    SetTextColor(vhMDC, rgbText);
                    }
                }

            if (hParentWw != NULL)
                {
                /* Set the background brush for the parent window. */
                DeleteObject(SelectObject(GetDC(hParentWw), hbrBkgrnd));
                }
            }

        if (vhWndPageInfo != NULL)
            {
            HBRUSH hbr;
            HDC hDC = GetDC(vhWndPageInfo);

            /* Set the colors for the page info window. */
            if ((hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME))) ==
              NULL)
                {
                hbr = GetStockObject(BLACK_BRUSH);
                }
            DeleteObject(SelectObject(hDC, hbr));
#ifdef WIN30
            /* If the user has their colors set with a TextCaption color of
               black then this becomes hard to read!  We just hardcode this
               to be white since the background defaults to being black */
            SetTextColor(hDC, (DWORD) -1);
#else
            SetTextColor(hDC, GetSysColor(COLOR_CAPTIONTEXT));
#endif
            }

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
        GetImeHiddenTextColors();
#endif

        /* If the bitmap cache is holding a resized metafile, then free the
        cache because the bitmap might contain part of the background that might
        have changed. */
        if (vhbmBitmapCache != NULL && !vfBMBitmapCache)
            {
            FreeBitmapCache();
            }
        break;

    case WM_WININICHANGE:
        /* We only care if the "windows", "devices", or "intl" fields have
           changed -- this has been taken care of already, see mmw.c */

           if (wWininiChange & wWininiChangeToIntl)
           {
                extern HWND vhDlgRunning;
                extern int utCur;
                extern CHAR         vchDecimal;  /* decimal point character */
                CHAR bufT[3];  /* to hold decimal point string */
                extern CHAR         szsDecimal[];
                extern CHAR         szsDecimalDefault[];
                extern CHAR         szIntl[];
                extern HWND vhWndRuler;
                extern int     viDigits;
                extern BOOL    vbLZero;

                if (GetProfileInt((LPSTR)szIntl, (LPSTR)"iMeasure", 1) == 1)
                    utCur = utInch;
                else
                    utCur = utCm;

                viDigits = GetProfileInt((LPSTR)szIntl, (LPSTR)"iDigits", 2);
                vbLZero  = GetProfileInt((LPSTR)szIntl, (LPSTR)"iLZero", 0);

                /* Get the decimal point character from the user profile. */
                GetProfileString((LPSTR)szIntl, (LPSTR)szsDecimal, (LPSTR)szsDecimalDefault,
                    (LPSTR)bufT, 2);
                vchDecimal = *bufT;

                InvalidateRect(vhWndRuler, (LPRECT)NULL, FALSE);
                UpdateRuler();
           }

           if ((wWininiChange & wWininiChangeToDevices) ||
               (wWininiChange & wWininiChangeToWindows))
            {
            /* Reestablish the printer from the profile in case it was the
            printer that was changed. */
            hszPrinterSave = hszPrinter;
            hszPrDriverSave = hszPrDriver;
            hszPrPortSave = hszPrPort;

            if (FGetPrinterFromProfile())
                {
                BOOL fPrChange = FALSE;

                if (hszPrinterSave == NULL || hszPrDriverSave == NULL ||
                  hszPrPortSave == NULL || hszPrinter == NULL || hszPrDriver ==
                  NULL || hszPrPort == NULL || WCompSz(&(**hszPrinter)[0],
                  &(**hszPrinterSave)[0]) != 0 || WCompSz(&(**hszPrDriver)[0],
                  &(**hszPrDriverSave)[0]) != 0 || WCompSz(&(**hszPrPort)[0],
                  &(**hszPrPortSave)[0]) != 0)
                    {
                    /* If we are not printing, then we can reflect the change of
                    the printer on the screen. */
                    if (!(fPrChange = fNotPrinting))
                        {
                        /* We are printing while the printer has changed, set
                        the flags so that the next time we get a printer DC we
                        will assume that it is valid. */
                        Assert(vfPrinterValid);
                        vfWarnMargins = TRUE;
                        }
                    }

                /* Delete the saved copies of the printer strings. */
                if (hszPrinterSave != NULL)
                    {
                    FreeH(hszPrinterSave);
                    }
                if (hszPrDriverSave != NULL)
                    {
                    FreeH(hszPrDriverSave);
                    }
                if (hszPrPortSave != NULL)
                    {
                    FreeH(hszPrPortSave);
                    }

                if (fPrChange)
                    {
                    /* Get the new printer DC and update the world. */
                    goto GetNewPrinter;
                    }
                }
            else
                {
                Error(IDPMTNoMemory);
                hszPrinter = hszPrinterSave;
                hszPrDriver = hszPrDriverSave;
                hszPrPort = hszPrPortSave;
                }
            }
        break;

    case WM_DEVMODECHANGE:
        /* The device mode for some printer has changed; check to see if it was
        our printer. */
        if (fNotPrinting && hszPrinter != NULL &&
            (hszDevmodeChangeParam == NULL ||
                (bltszx(*hszDevmodeChangeParam, (LPSTR)szPrinter ),
                WCompSz(szPrinter, &(**hszPrinter)[0]) == 0)))
            {
            extern PRINTDLG PD;  /* Common print dlg structure, initialized in the init code */
GetNewPrinter:
            if (PD.hDevMode)
                GlobalFree(PD.hDevMode);
            if (PD.hDevNames)
                GlobalFree(PD.hDevNames);
            PD.hDevMode = PD.hDevNames = NULL;

            /* The printer has changed, so get rid of the old one. */
            FreePrinterDC();

            fnPrGetDevmode();

#if defined(OLE)
            ObjSetTargetDevice(TRUE);
#endif

            /* The printer description has changed; assume the new printer is
            valid. */
            vfPrinterValid = vfWarnMargins = TRUE;
            GetPrinterDC(FALSE);
            ResetFontTables();

RedrawWindow:
            /* Everything must be redisplayed because the world may have
            changed. */
            if (!vfIconic)
                {
                InvalidateRect(wwdCurrentDoc.wwptr, (LPRECT)NULL, FALSE);
                }
        }

        if (hszDevmodeChangeParam != NULL)
            FreeH(hszDevmodeChangeParam);
        hszDevmodeChangeParam = NULL;
        break;

    case WM_FONTCHANGE:
        /* The font used to display the page number may have changed. */
        if (vhfPageInfo != NULL)
            {
            DeleteObject(SelectObject(GetDC(vhWndPageInfo),
              GetStockObject(SYSTEM_FONT)));
            vhfPageInfo = NULL;
            }
        docMode = docNil;
        DrawMode();

        ResetFontTables();

        goto RedrawWindow;
        }   /* end switch */
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\ruler2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains routines that change dialog boxes or the menu for the
ruler. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#include <windows.h>
#include "mw.h"
#include "menudefs.h"
#include "str.h"


extern HMENU vhMenu;
extern CHAR stBuf[256];
extern int utCur;

SetRulerMenu(fShowRuler)
BOOL fShowRuler;
    {
    /* This routine puts "Ruler On" into the menu if fShowRuler is true; else,
    "Ruler Off" is put into the menu. */

    FillStId(stBuf, fShowRuler ? IDSTRShowRuler : IDSTRHideRuler, sizeof(stBuf));
    ChangeMenu(vhMenu, imiShowRuler, (LPSTR)&stBuf[1], imiShowRuler, MF_CHANGE);
    }


#ifdef RULERALSO
#include "cmddefs.h"
#include "propdefs.h"
#include "rulerdef.h"
#include "dlgdefs.h"

extern HWND vhDlgIndent;
extern int mprmkdxa[];
extern int vdxaTextRuler;

SetIndentText(rmk, dxa)
int rmk;	/* ruler mark */
unsigned dxa;
    {
    /* This routine reflects the changes made on the ruler in the Indentd dialog
    box. */

    unsigned dxaShow;
    int idi;
    CHAR sz[cchMaxNum];
    CHAR *pch = &sz[0];

    /* Get the dialog item number and the measurement. */
    switch (rmk)
	{
    case rmkLMARG:
	dxaShow = dxa;
	idi = idiParLfIndent;
	break;

    case rmkINDENT:
	dxaShow = dxa - mprmkdxa[rmkLMARG];
	idi = idiParFirst;
	break;

    case rmkRMARG:
	dxaShow = vdxaTextRuler - dxa;
	idi = idiParRtIndent;
	break;
	}
    CchExpZa(&pch, dxaShow, utCur, cchMaxNum);
    SetDlgItemText(vhDlgIndent, idi, (LPSTR)sz);

    if (rmk == rmkLMARG)
	{
	/* If the left indent changes, then we need to update the first line
	indent. */
	dxaShow = mprmkdxa[rmkINDENT] - dxaShow;
	pch = sz;
	CchExpZa(&pch, dxaShow, utCur, cchMaxNum);
	idi = idiParFirst;
	SetDlgItemText(vhDlgIndent, idi, (LPSTR)sz);
	}
    }
#endif /* RULERALSO */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\ruler.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the routines for creating, displaying, and manipulating
the ruler for Memo. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOATOM
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMSG
#define NOOPENFILE
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "rulerdef.h"
#include "propdefs.h"
#include "prmdefs.h"
#include "docdefs.h"
#include "bitmaps.h"

#define MERGEMARK 0x00990066

extern HWND hParentWw;
extern HANDLE hMmwModInstance;
extern HCURSOR vhcIBeam;
extern struct DOD (**hpdocdod)[];
extern struct WWD *pwwdCur;
extern struct PAP vpapAbs;
extern struct SEP vsepAbs;
extern struct SEL selCur;
extern typeCP cpMacCur;
extern int docCur;
extern int vdocParaCache;
extern int dypRuler;
extern int dxpLogInch;
extern int dypLogInch;
extern int dxpLogCm;
extern int dypLogCm;
extern int xpSelBar;
extern HWND vhWndRuler;
extern int vdxaTextRuler;
extern int mprmkdxa[rmkMARGMAX];
extern int vfTabsChanged;
extern int vfMargChanged;
extern struct WWD rgwwd[];
extern long rgbBkgrnd;
extern long rgbText;
extern HBRUSH hbrBkgrnd;
extern long ropErase;
extern BOOL vfMonochrome;
extern BOOL vfEraseWw;
extern int vfIconic;

#ifdef RULERALSO
extern HWND vhDlgIndent;
#endif /* RULERALSO */

HDC vhDCRuler = NULL;
HDC hMDCBitmap = NULL;
HDC hMDCScreen = NULL;
HBITMAP hbmBtn = NULL;
HBITMAP hbmMark = NULL;
HBITMAP hbmNullRuler = NULL;
int dxpRuler;

int viBmRuler = -1;  /* Index into [CGA/EGA/VGA/8514] bitmaps (see
                        WRITE.RC).  Set appropriately in FCreateRuler(). */

static RECT rgrcRulerBtn[btnMaxUsed];
static int mprlcbtnDown[rlcBTNMAX] = {btnNIL, btnNIL, btnNIL};
static struct TBD rgtbdRuler[itbdMax];
static int xpMinCur;
static int dxpMark;
static int dypMark;
static int btnTabSave = btnLTAB;


near UpdateRulerBtn(int, int);
BOOL near FCreateRuler(void);
int near DestroyRuler(void);
int near RulerStateFromPt(POINT, int *, int *);
int near MergeRulerMark(int, int, BOOL);
BOOL near FPointNear(unsigned, unsigned);
unsigned near XaQuantize(int);
int near DeleteRulerTab(struct TBD *);
int near InsertRulerTab(struct TBD *);
BOOL near FCloseXa(unsigned, unsigned);
#ifdef KINTL
unsigned near XaKickBackXa(unsigned);
near XpKickBackXp(int);
unsigned near XaQuantizeXa(unsigned);
#endif /* KINTL */

fnShowRuler()
    {
    /* This routine toggles the creation and the destruction of the ruler
    window. */

    StartLongOp();
    if (pwwdCur->fRuler)
        {
        /* Take down the existing ruler. */
        DestroyRuler();
        SetRulerMenu(TRUE);
        }
    else
        {
        /* There is no ruler, bring one up. */
        if (FCreateRuler())
            {
            SetRulerMenu(FALSE);
            }
        }
    EndLongOp(vhcIBeam);
    }


BOOL near FCreateRuler()
    {
    /* This routine creates the ruler child window and positions it on the
    screen. */

    extern CHAR szRulerClass[];
    int xpMac = pwwdCur->xpMac;
    int ypMac = pwwdCur->ypMac;
    LOGFONT lf;
    HFONT hf;
    int dyp;
    HPEN hpen;
    RECT rc;
    TEXTMETRIC tmSys;
    HDC hdcSys;


    /* Create the ruler window. */
    if ((vhWndRuler = CreateWindow((LPSTR)szRulerClass, (LPSTR)NULL,
      WS_CHILD | WS_CLIPSIBLINGS, 0, 0, 0, 0, hParentWw, NULL, hMmwModInstance,
      (LPSTR)NULL)) == NULL)
        {
        goto Error2;
        }

    /* Save the DC and the memory DC. */
    if ((vhDCRuler = GetDC(vhWndRuler)) == NULL || (hMDCBitmap =
      CreateCompatibleDC(vhDCRuler)) == NULL || (hMDCScreen =
      CreateCompatibleDC(vhDCRuler)) == NULL)
        {
        goto Error1;
        }

    /* Create a null bitmap for the ruler. */
    if ((hbmNullRuler = CreateBitmap(1, 1, 1, 1, (LPSTR)NULL)) == NULL)
        {
        goto Error1;
        }

    /* New for Write 3.0: we have a variety of bitmaps for the ruler buttons 
       and marks -- loaded depending on the resolution of the user's display.
       All we really want to do here is set viBmRuler, which indexes into the
       appropriate bitmaps (see bitmaps.h) ..pault 7/13/89 */

    if (viBmRuler < 0)
        {
        /* This idea of passing NULL to GetDC borrowed from WinWord ..pt */
        if ((hdcSys = GetDC(NULL)) == NULL) 
            goto Error1;
        else
            {
            int tmHeight;

            GetTextMetrics(hdcSys, (LPTEXTMETRIC) &tmSys);
            tmHeight = tmSys.tmHeight;
            ReleaseDC(NULL, hdcSys);
            
            viBmRuler = 0;
            if (tmHeight > 8)
                viBmRuler++;
            if (tmHeight > 12)
                viBmRuler++;
            if (tmHeight > 16)
                viBmRuler++;
            }
        
        Diag(CommSzNum("FCreateRuler: index into [CGA/EGA/VGA/8514] bitmaps==", viBmRuler));
        Assert(idBmBtns + viBmRuler < idBmBtnsMax);
        Assert(idBmMarks + viBmRuler < idBmMarksMax);
        }

    /* Get the bitmaps for the ruler buttons and the ruler marks. */
    if (hbmBtn == NULL || SelectObject(hMDCBitmap, hbmBtn) == NULL)
        {
        if (NULL == (hbmBtn = LoadBitmap(hMmwModInstance, 
                                         MAKEINTRESOURCE(idBmBtns+viBmRuler))))
            {
            goto Error1;
            }
        }
    if (hbmMark == NULL || SelectObject(hMDCBitmap, hbmMark) == NULL)
        {
        if (NULL == (hbmMark = LoadBitmap(hMmwModInstance, 
                                          MAKEINTRESOURCE(idBmMarks+viBmRuler))))
            {
            goto Error1;
            }
        }

    /* Get the font for labelling the ruler ticks. */
    bltbc(&lf, 0, sizeof(LOGFONT));
    lf.lfHeight = -MultDiv(czaPoint * 8, dypLogInch, czaInch);
    if ((hf = CreateFontIndirect(&lf)) != NULL)
        {
        if (SelectObject(vhDCRuler, hf) == NULL)
            {
            DeleteObject(hf);
            }
        }

    /* If this is the first time the ruler is created, then initialize the
    static variables. */
    if (dypRuler == 0)
        {
        int dxpMajor;
        int dxpMinor;
        BITMAP bm;
        int xp;
        int dxpBtn;
        int btn;
        PRECT prc;
        TEXTMETRIC tm;

        /* Initialize the starting position of the buttons. */
        dxpMinor = (dxpMajor = dxpLogInch >> 1) >> 2;
        xp = xpSelBar + dxpMajor + (dxpMajor >> 1);

        /* Get the width and height of the buttons. */
        GetObject(hbmBtn, sizeof(BITMAP), (LPSTR)&bm);
        /* Factor of 2 since we have positive and negative images 
           of each button embedded in the bitmap now ..pault */
        dxpBtn = bm.bmWidth / (btnMaxReal*2);
        dypRuler = bm.bmHeight;

        /* Position the buttons. */
        for (prc = &rgrcRulerBtn[btn = btnMIN]; btn < btnMaxUsed; btn++, prc++)
            {
            prc->left = xp;
            prc->top = 1;
            prc->right = (xp += dxpBtn);
            prc->bottom = bm.bmHeight + 1;
            xp += (btn == btnTABMAX || btn == btnSPACEMAX) ? dxpMajor :
              dxpMinor;
            }

        /* Get the width and height of the tab marks. */
        GetObject(hbmMark, sizeof(BITMAP), (LPSTR)&bm);
        dxpMark = bm.bmWidth / rmkMAX;
        dypMark = bm.bmHeight;

        /* Lastly, initialize the height of the ruler. (Four is for the two
        lines at the bottom of the ruler plus two blank lines.) */
        GetTextMetrics(vhDCRuler, (LPTEXTMETRIC)&tm);
        dypRuler += dypMark + (tm.tmAscent - tm.tmInternalLeading) + 4;
        }

    /* Move the document window to make room for the ruler. */
    pwwdCur->fRuler = TRUE;
    dyp = dypRuler - (pwwdCur->ypMin - 1);
    MoveWindow(wwdCurrentDoc.wwptr, 0, dyp, xpMac, ypMac - dyp, FALSE);

    /* Erase the top of the document window. */
    PatBlt(wwdCurrentDoc.hDC, 0, 0, xpMac, wwdCurrentDoc.ypMin, ropErase);
    rc.left = rc.top = 0;
    rc.right = xpMac;
    rc.bottom = wwdCurrentDoc.ypMin;
    ValidateRect(wwdCurrentDoc.wwptr, (LPRECT)&rc);
    UpdateWindow(wwdCurrentDoc.wwptr);

    /* Move the ruler into position. */
    MoveWindow(vhWndRuler, 0, 0, xpMac, dypRuler, FALSE);
    BringWindowToTop(vhWndRuler);

    /* Set the DC to transparent mode. */
    SetBkMode(vhDCRuler, TRANSPARENT);

    /* Set the background and foreground colors for the ruler. */
    SetBkColor(vhDCRuler, rgbBkgrnd);
    SetTextColor(vhDCRuler, rgbText);

    /* Set the brush and the pen for the ruler. */
    SelectObject(vhDCRuler, hbrBkgrnd);
    if ((hpen = CreatePen(0, 0, rgbText)) == NULL)
        {
        hpen = GetStockObject(BLACK_PEN);
        }
    SelectObject(vhDCRuler, hpen);

    /* Lastly, ensure that the ruler is painted. */
    ShowWindow(vhWndRuler, SHOW_OPENWINDOW);
    UpdateWindow(vhWndRuler);
    return (TRUE);

Error1:
    DestroyWindow(vhWndRuler);
    vhWndRuler = NULL;
Error2:
    WinFailure();
    return (FALSE);
    }


near DestroyRuler()
    {
    /* This routine destroys the ruler window and refreshes the screen. */

    /* First, erase the ruler. */
    PatBlt(vhDCRuler, 0, 0, dxpRuler, dypRuler, ropErase);

    /* Clean up the ruler window. */
    DestroyWindow(vhWndRuler);
    vhWndRuler = NULL;
    ResetRuler();

    /* Move the document window back to the top of the window. */
    pwwdCur->fRuler = FALSE;
    vfEraseWw = TRUE;
    MoveWindow(wwdCurrentDoc.wwptr, 0, 0, dxpRuler, wwdCurrentDoc.ypMac +
      dypRuler - (wwdCurrentDoc.ypMin - 1), FALSE);
    vfEraseWw = FALSE;

    /* Validate the area in the document window above the text. */
    PatBlt(wwdCurrentDoc.hDC, 0, 0, dxpRuler, wwdCurrentDoc.ypMin, ropErase);
    ValidateRect(hParentWw, (LPRECT)NULL);
    }


UpdateRuler()
    {
    /* This routine will redraw as much of the ruler as necessary to reflect the
    current selection. */

    /* Only repaint the ruler if it exists and it is not currently being
    changed. */
    if (vhWndRuler != NULL)
        {
        RulerPaint(FALSE, FALSE, FALSE);
        }
    }

ReframeRuler()
    {
    /* This routine will cause the ruler window to be redrawn,
       when units change - leave update out, since dialog box
       will repaint */

    /* Only repaint the ruler if it exists . */
    if (vhWndRuler != NULL)
        {
        InvalidateRect(vhWndRuler, (LPRECT)NULL, FALSE);
        }
    }



ResetRuler()
    {
    /* Reset the values of the ruler buttons and the ruler margins and tabs so
    they redrawn during the next paint message. */
    if ((btnTabSave = mprlcbtnDown[rlcTAB]) == btnNIL)
        {
        btnTabSave = btnLTAB;
        }

    /* Reset the buttons. */
    if (vfIconic)
        {
        /* All we have to do is reset our internal state. */
        bltc(mprlcbtnDown, btnNIL, rlcBTNMAX);
        }
    else
        {
        /* We had best reset the buttons on the screen as well. */
        UpdateRulerBtn(rlcTAB, btnNIL);
        UpdateRulerBtn(rlcSPACE, btnNIL);
        UpdateRulerBtn(rlcJUST, btnNIL);
        }

    /* Reset the margins and the tabs. */
    bltc(mprmkdxa, -1, rmkMARGMAX);
    bltc(rgtbdRuler, 0, cwTBD * itbdMax);
    }


ResetTabBtn()
    {
    /* This routine resets the tab button on the ruler to the left tab button.
    */
    if (mprlcbtnDown[rlcTAB] != btnLTAB)
        {
        UpdateRulerBtn(rlcTAB, btnLTAB);
        }
    }


RulerPaint(fContentsOnly, fFrameOnly, fInit)
BOOL fContentsOnly;
BOOL fInit;
    {
    /* This routine draws the ruler in the ruler window.  If fContentsOnly is
    set, then only the tabs as they currently exist in rgtbdRuler, and the
    button settings are drawn.  If fFrameOnly is set, then only the ruler frame
    is redrawn.  If fInit is set, then the portion of the ruler to be redrawn
    (tabs, frame or all) is redrawn from scratch. */


    int xpMin = pwwdCur->xpMin;
    HBITMAP hbm;

    /* If fContentsOnly is set, then skip most of this stuff and draw only the
    tabs and the button settings.  */
    if (!fContentsOnly)
        {
        /* We only need to draw the physical ruler itself when the window has
        scrolled horizontally. */
        if (fInit || xpMinCur != xpMin)
            {
            register int xp;
            TEXTMETRIC tm;
            int dypTick;
            int ypTickEnd;
            int ypTickStart;
            int ypTick;
            int iLevel;
            CHAR rgchInch[3];
            int dxpLogUnitInc;
            int dcNextTick;
            int dxpLine;


            extern int utCur;
#define cDivisionMax 8  /* max divisions per ruler unit. e.g. 8 per inch */
            int rgypTick[cDivisionMax];
            int cxpExtra;
            int cDivision;
            int dxpLogUnit;
            int dxpMeas;
            int ypT;

            /* Initialize the y-coordinate of the ticks. */
            GetTextMetrics(vhDCRuler, (LPTEXTMETRIC)&tm);
            ypTickEnd = dypRuler - dypMark - 2;
            ypTickStart = ypTick = ypTickEnd - (dypTick = tm.tmAscent -
              tm.tmInternalLeading);

            /* set up measurements for the ruler based on current unit -
               note that only inch and cm are handled in this version */

            if (utCur == utInch)
                           {
                           dxpLogUnit = dxpLogUnitInc = dxpLogInch;
                           cDivision = 8;  /* # of divisions */
                           dxpMeas = dxpLogUnit >> 3;  /* 1/8" units */
                         /* get extra pixels to distribute if not even multiple */
                         /* note - mod done by hand */
                           cxpExtra = dxpLogUnit - (dxpMeas << 3);
                           dcNextTick = 1;
                          /* fill table of tick lengths */
                           rgypTick[0] = ypT = ypTick;
                           rgypTick[4] = ypT += (dypTick >> 2);
                           rgypTick[2] = rgypTick[6] = ypT += (dypTick >> 2);
                           rgypTick[1] = rgypTick[3] = rgypTick[5] = rgypTick[7]  =
                           ypT += (dypTick >> 2);
                           }
            else
                /* default to cm */
                           {
                           dxpLogUnit = dxpLogUnitInc = dxpLogCm;
                           cDivision = 2;  /* # of divisions */
                           dxpMeas = dxpLogUnit >> 1;  /* 1/2 cm units */
                         /* get extra pixels to distribute if not even multiple */
                           cxpExtra = dxpLogUnit - (dxpMeas << 1);
                           dcNextTick = 1;
                          /* fill table of tick lengths */
                           rgypTick[0] =  ypTick;
                           rgypTick[1] = ypTick + (dypTick >> 1);
                           }

            if (fInit)
                {
                /* Erase the area where the ruler will be drawn. */
                PatBlt(vhDCRuler, 0, 0, dxpRuler, dypRuler, ropErase);

                /* Draw a line across the bottom of the ruler. */
                MoveTo(vhDCRuler, xpSelBar, dypRuler - 1);
                LineTo(vhDCRuler, dxpRuler, dypRuler - 1);

                /* Draw the base of the ruler. */
                MoveTo(vhDCRuler, xpSelBar, ypTickEnd);
                LineTo(vhDCRuler, dxpRuler, ypTickEnd);
                }
            else
                {
                /* Erase the old tick marks. */
                PatBlt(vhDCRuler, 0, ypTickStart, dxpRuler, ypTickEnd -
                  ypTickStart, ropErase);
                }

            /* Set the clip region to be only the ruler. */
            iLevel = SaveDC(vhDCRuler);
            IntersectClipRect(vhDCRuler, xpSelBar, 0, dxpRuler, dypRuler);

            /* Draw the ticks at the each division mark. */
            /* iDivision is the current division with in a unit. It is
               used to determine when extra pixels are distributed and
               which tick mark to use */
            {
            register int iDivision = 0;

            for (xp = (xpSelBar - xpMin); xp < dxpRuler; xp +=
              dxpMeas)
                {
                  /* distribute extra pixels at front */
                if (iDivision < cxpExtra)
                   xp++;

                MoveTo(vhDCRuler, xp, rgypTick[iDivision]);
                LineTo(vhDCRuler, xp, ypTickEnd);

                if (++iDivision == cDivision)
                   iDivision = 0;
                }
            }


            /* Label the tick marks. */
            dxpLine = GetSystemMetrics(SM_CXBORDER);
            rgchInch[0] = rgchInch[1] = rgchInch[2] = '0';
            for (xp = xpSelBar - xpMin;
                 xp < dxpRuler;
                 xp += dxpLogUnitInc, rgchInch[2] += dcNextTick)
                {
                    int isz;
                    int dxpsz;

                    if (rgchInch[2] > '9')
                        {
                        rgchInch[1]++;
                        rgchInch[2] = '0' + (rgchInch[2] - (CHAR) ('9' + 1));
                        }
                    if (rgchInch[1] > '9')
                        {
                        rgchInch[0]++;
                        rgchInch[1] = '0' + (rgchInch[1] - (CHAR) ('9' + 1));
                        }
                    isz = rgchInch[0] == '0' ?
                                (rgchInch[1] == '0' ? 2 : 1):
                                0;
                    dxpsz = LOWORD(GetTextExtent(vhDCRuler,
                                                 (LPSTR)&rgchInch[isz],
                                                 3 - isz));
                    if (dxpsz + dxpLine >= dxpMeas)
                        {
                            PatBlt(vhDCRuler, xp + dxpLine, ypTickStart,
                                   dxpsz, ypTickEnd - ypTickStart, ropErase);
                        }
                    TextOut(vhDCRuler, xp + dxpLine, ypTickStart -
                            tm.tmInternalLeading, (LPSTR)&rgchInch[isz],
                            3 - isz);
                }


            /* Set the clip region back. */
            RestoreDC(vhDCRuler, iLevel);
            }

        /* Draw the buttons on the ruler. */
        if (fInit)
            {
            register PRECT prc = &rgrcRulerBtn[btnMIN];
            int btn;

            /* Ensure that we have the bitmap for the buttons. */
            if (SelectObject(hMDCBitmap, hbmBtn) == NULL)
                {
                if (NULL == (hbmBtn = LoadBitmap(hMmwModInstance, 
                                                 MAKEINTRESOURCE(idBmBtns+viBmRuler)))
                             || SelectObject(hMDCBitmap, hbmBtn) == NULL)
                    {
                    WinFailure();
                    goto NoBtns;
                    }
                }

            /* Now, draw the buttons. */
            for (btn = btnMIN; btn < btnMaxUsed; btn++)
                {
                int dxpBtn = prc->right - prc->left;

                BitBlt(vhDCRuler, prc->left, prc->top, dxpBtn, prc->bottom -
                  prc->top, hMDCBitmap, (btn - btnMIN) * dxpBtn, 0, vfMonochrome
                  ? MERGEMARK : SRCCOPY);
                prc++;
                }
            SelectObject(hMDCBitmap, hbmNullRuler);
NoBtns:;
            }
        }

    /* If fFrame only is set, then we're finished. */
    if (!fFrameOnly)
        {
        /* Lastly, draw the button settings, the margins and the tabs. */
        TSV rgtsv[itsvparaMax];
        register struct TBD *ptbd1;
        int rmk;
        int xpMarkMin = xpSelBar - (dxpMark >> 1);
        int dxpMarkMax = dxpRuler - xpSelBar - (dxpMark >> 1);
        unsigned dxa;

        if (mprlcbtnDown[rlcTAB] == btnNIL)
            {
            /* Initalize the tab button to be left tab. */
            UpdateRulerBtn(rlcTAB, btnTabSave);
            }

        /* Now for the spacing and justification. */
        GetRgtsvPapSel(rgtsv);
        UpdateRulerBtn(rlcSPACE, (rgtsv[itsvSpacing].fGray != 0) ? btnNIL :
          (rgtsv[itsvSpacing].wTsv - czaLine) / (czaLine / 2) + btnSINGLE);
        UpdateRulerBtn(rlcJUST, (rgtsv[itsvJust].fGray != 0) ? btnNIL :
          (rgtsv[itsvJust].wTsv - jcLeft) + btnLEFT);

        /* The margins and the tabs are based off of the first cp of the
        selection. */
        CacheSect(docCur, selCur.cpFirst);
        CachePara(docCur, selCur.cpFirst);

        /* If the window has scrolled horizontally or become wider, we must
        redraw the margins and the tabs. */
        if (!fInit && xpMinCur == xpMin)
            {
            /* Compare to see if the margins have changed. */
            if (mprmkdxa[rmkINDENT] != vpapAbs.dxaLeft + vpapAbs.dxaLeft1)
                {
                goto DrawMargins;
                }
            if (mprmkdxa[rmkLMARG] != vpapAbs.dxaLeft)
                {
                goto DrawMargins;
                }
            if (mprmkdxa[rmkRMARG] != vsepAbs.dxaText - vpapAbs.dxaRight)
                {
                goto DrawMargins;
                }

            /* Compare to see if the tabs has changed. */
                {
                register struct TBD *ptbd2;

                for (ptbd1 = &rgtbdRuler[0], ptbd2 = &vpapAbs.rgtbd[0];
                  ptbd1->dxa == ptbd2->dxa; ptbd1++, ptbd2++)
                    {
                    /* If the end of the list of tabs, then the lists are equal.
                    */
                    if (ptbd1->dxa == 0)
                        {
                        goto SkipTabs;
                        }

                    /* The justification codes must match if they are decimal
                    tabs (everything else collaspes to left tabs). */
                    if (ptbd1->jc != ptbd2->jc && (ptbd1->jc == (jcTabDecimal
                      - jcTabMin) || (ptbd2->jc == (jcTabDecimal - jcTabMin))))
                        {
                        goto DrawMargins;
                        }
                    }
                }
            }

DrawMargins:
#ifdef KINTL
        /* This is really an extra.  xpMinCur will get updated later on.
           But, we need this variable set up right for the MergeRulerMark()
           to draw a mark at the right place.... Oh well. */
        xpMinCur = xpMin;
#endif /* ifdef KINTL */

        /* Redraw the margins from scratch.  Set up the bitmap for hMDCScreen,
        the ruler bar in monochrome format. */
        if ((hbm = CreateBitmap(dxpRuler + dxpMark, dypMark, 1, 1,
          (LPSTR)NULL)) == NULL)
            {
            WinFailure();
            goto SkipTabs;
            }
        DeleteObject(SelectObject(hMDCScreen, hbm));
        PatBlt(hMDCScreen, 0, 0, dxpRuler + dxpMark, dypMark, vfMonochrome ?
          ropErase : WHITENESS);
        PatBlt(vhDCRuler, 0, dypRuler - dypMark - 1, dxpRuler + dxpMark,
          dypMark, ropErase);

        /* Determine the margin positions. */
        mprmkdxa[rmkINDENT] = vpapAbs.dxaLeft + vpapAbs.dxaLeft1;
        mprmkdxa[rmkLMARG] = vpapAbs.dxaLeft;
        mprmkdxa[rmkRMARG] = (vdxaTextRuler = vsepAbs.dxaText) -
          vpapAbs.dxaRight;

        /* Draw the margins marks. */
        for (rmk = rmkMARGMIN; rmk < rmkMARGMAX; rmk++)
            {
            register int dxp = MultDiv(mprmkdxa[rmk], dxpLogInch, czaInch) -
              xpMin;

            /* If the margin mark would not appear on the ruler, scrolled off to
            either end, then don't try to draw it. */
            if (dxp >= 0 && dxp < dxpMarkMax)
                {
                MergeRulerMark(rmk, xpMarkMin + dxp, FALSE);
                }
            }

        /* Redraw the tabs. */
        ptbd1 = &rgtbdRuler[0];
        if (!fInit)
            {
            /* If fInit is set, then rgtbdRuler is not changed. */
            blt(vpapAbs.rgtbd, ptbd1, cwTBD * itbdMax);
            }
        while ((dxa = ptbd1->dxa) != 0)
            {
            register int dxp = MultDiv(dxa, dxpLogInch, czaInch) - xpMin;

            /* If the tab mark would not appear on the ruler, scrolled off to
            either end, then don't try to draw it. */
            if (dxp >= 0 && dxp < dxpMarkMax)
                {
                MergeRulerMark(ptbd1->jc == (jcTabDecimal - jcTabMin) ? rmkDTAB
                  : rmkLTAB, xpMarkMin + dxp, FALSE);
                }
            ptbd1++;
            }
SkipTabs:;
        }

    /* Record the edges of the current window. */
    xpMinCur = xpMin;
    }


RulerMouse(pt)
POINT pt;
    {
    /* Process all mouse messages from a down-click at point pt until the
    corresponding mouse up-click. */

    int btn;
    int rlc;
    int rlcCur;
    int rmkCur;
    int xp;
    int xpCur;
    unsigned xa;
    struct TBD *ptbd;
    struct TBD tbd;
    BOOL fMarkMove = FALSE;
    BOOL fDeleteMark = FALSE;
    BOOL fBtnChanged = FALSE;

    if (!FWriteOk(fwcNil))
        {
        return;
        }

    /* Translate the point into a button group and a button. */
    RulerStateFromPt(pt, &rlcCur, &btn);

    /* Down clicking on the tab rule is a special case. */
    if (rlcCur == rlcRULER)
        {
        unsigned dxa = MultDiv(pt.x - xpSelBar + xpMinCur, czaInch, dxpLogInch);
        int rmk;
        int itbd;

        /* Have we moused down on a margin? */
        for (rmk = rmkMARGMIN; rmk < rmkMARGMAX; rmk++)
            {
#ifdef KINTL
            if (FPointNear(mprmkdxa[rmk], dxa - XaKickBackXa(dxa)))
#else
            if (FPointNear(mprmkdxa[rmk], dxa))
#endif /* if-else-def KINTL */
                {
                int     xpT;

                /* Remember this mark and its position. */
                rmkCur = rmk;
                xpCur = xpSelBar + MultDiv(mprmkdxa[rmk], dxpLogInch, czaInch) -
                  (dxpMark >> 1) - xpMinCur;

InvertMark:
#ifdef KINTL
                /* Adjust for the kick-backs.  */
                /* But don't modify the xpCur. */
                xpT = xpCur + XpKickBackXp(xpCur);
#else
                xpT = xpCur;
#endif /* if-else-def KINTL */

                /* Time to invert the selected mark. */
                PatBlt(vhDCRuler, xpT, dypRuler - dypMark - 1, dxpMark,
                  dypMark, DSTINVERT);
                goto GotMark;
                }
            }

        /* Have we moused down on an existing tab? */
        for (itbd = 0, ptbd = &rgtbdRuler[0]; ; itbd++, ptbd++)
            {
            /* The end of the tabs have been found. */
            if (ptbd->dxa == 0)
                {
                break;
                }

            /* Have we moused down on this tab? */
#ifdef KINTL
            if (FPointNear(ptbd->dxa, dxa - XaKickBackXa(dxa)))
#else
            if (FPointNear(ptbd->dxa, dxa))
#endif /* if-else-def KANJI */
                {
                /* Save this tab descriptor and its location. */
                tbd = *ptbd;
                rmkCur = (tbd.jc + jcTabMin) == jcTabDecimal ? rmkDTAB :
                  rmkLTAB;
                xpCur = xpSelBar + MultDiv(tbd.dxa, dxpLogInch, czaInch) -
                  (dxpMark >> 1) - xpMinCur;
                goto InvertMark;
                }
            }

        /* If one more tab would be too many, then beep and return. */
        if (itbd >= itbdMax - 1)
            {
            _beep();
            return;
            }

        /* Create a tab descriptor for this new tab. */
        bltc(&tbd, 0, cwTBD);
        tbd.dxa = XaQuantize(pt.x);
        tbd.jc = (mprlcbtnDown[rlcTAB] == btnLTAB ? jcTabLeft : jcTabDecimal) -
          jcTabMin;
        rmkCur = (mprlcbtnDown[rlcTAB] - btnLTAB) + rmkLTAB;

        /* A mark for the new tab needs to be drawn. */
        MergeRulerMark(rmkCur, xpCur = xpSelBar + MultDiv(tbd.dxa, dxpLogInch,
          czaInch) - (dxpMark >> 1) - xpMinCur, TRUE);

        /* Inserting a tab is like moving an existing tab. */
        fMarkMove = TRUE;

GotMark:;

#ifdef RULERALSO
        /* Update dialog box */
        if (vhDlgIndent && rmkCur < rmkMARGMAX)
            {
            SetIndentText(rmkCur, dxa);
            }
#endif /* RULERALSO */

        }
    else if (rlcCur != rlcNIL)
        {
        /* Otherwise, if a button has been selected, the reflect the change on
        the ruler. */
        UpdateRulerBtn(rlcCur, btn);
        }
    else
        {
        /* The user has moused down on nothing of importance. */
        return;
        }

    /* Get all of the mouse events until further notice. */
    SetCapture(vhWndRuler);

    /* Process all of the mouse move messages. */
    while (FStillDown(&pt))
        {
        /* Movement on the tab ruler must be handled special. */
        if (rlcCur == rlcRULER)
            {
#ifdef KINTL
            unsigned xaT;
#endif /* ifdef KINTL */

            /* Guarantee that xp is in the range xpSelBar <= xp <= dxpRuler. */
            if ((xp = pt.x) > dxpRuler)
                {
                xp = dxpRuler;
                }
            else if (xp < xpSelBar)
                {
                xp = xpSelBar;
                }

            /* Convert the mouse position to twips. */
#ifdef KINTL
            if ((xa = XaQuantize(xp)) > (xaT = XaQuantizeXa(vdxaTextRuler))
#else
            if ((xa = XaQuantize(xp)) > vdxaTextRuler
#endif /* if-else-def KINTL */
                && rmkCur < rmkMARGMAX)
                {
                /* Margins are confined to the page. */
#ifdef KINTL
                xa = xaT;
#else
                xa = vdxaTextRuler;
#endif
                }

            /* If the cursor is on the ruler, then we may move a tab, but we
            always move the margins. */
            if ((rmkCur < rmkMARGMAX) || (pt.y >= 0 && pt.y < dypRuler + dypMark
              && xa != 0))
                {
                /* If the current mark has not moved, then there is nothing to
                do.  */
                if (fDeleteMark || xa != XaQuantize(xpCur + (dxpMark >> 1)))
                    {
                    /* Indicate that the mark has moved. */
                    fMarkMove = TRUE;

                    /* Restore the screen under the current mark. */
                    if (!fDeleteMark)
                        {
                        MergeRulerMark(rmkCur, xpCur, FALSE);
                        }

                    /* Draw the mark at the new location. */
                    MergeRulerMark(rmkCur, xpCur = MultDiv(xa, dxpLogInch,
                      czaInch) + xpSelBar - xpMinCur - (dxpMark >> 1), TRUE);

                    /* Show this is a valid mark. */
                    fDeleteMark = FALSE;

#ifdef RULERALSO
                    /* Update dialog box */
                    if (vhDlgIndent && rmkCur < rmkMARGMAX)
                        {
                        SetIndentText(rmkCur, xa);
                        }
#endif /* RULERALSO */

                    }
                }
            else
                {
                /* Restore the screen under the current mark. */
                if (!fDeleteMark)
                    {
                    MergeRulerMark(rmkCur, xpCur, FALSE);
                    }

                /* This mark is being deleted. */
                fDeleteMark = TRUE;
                }
            }
        else
            {
            /* If the mouse is on a button within the same button group, then
            reflect the change. */
            RulerStateFromPt(pt, &rlc, &btn);
            if (rlc == rlcCur)
                {
                UpdateRulerBtn(rlc, btn);
                }
            }
        }

    /* We are capturing all mouse events; we can now release them. */
    ReleaseCapture();

    /* Up-clicking on the tab ruler is a special case. */
    if (rlcCur == rlcRULER)
        {
        if (!fDeleteMark)
            {
            /* Restore the screen under the current mark. */
            MergeRulerMark(rmkCur, xpCur, FALSE);
            }

        if (fMarkMove)
            {
            /* Guarantee that xp is in the range xpSelBar <= xp <= dxpRuler. */
            if ((xp = pt.x) > dxpRuler)
                {
                xp = dxpRuler;
                }
            else if (xp < xpSelBar)
                {
                xp = xpSelBar;
                }
            }
        else
            {
            xp = xpCur + (dxpMark >> 1);
            }

        /* Convert the mouse position to twips. */
        if ((xa = XaQuantize(xp)) > vdxaTextRuler && rmkCur < rmkMARGMAX)
            {
            /* Margins are confined to the page. */
            xa = vdxaTextRuler;
            }

        /* If the cursor is on the ruler then we may insert/move a tab, but we
        always move the margins. */
        if ((rmkCur < rmkMARGMAX) || (pt.y >= 0 && pt.y < dypRuler + dypMark &&
          xa != 0))
            {
            /* Draw the mark at the new location. */
            MergeRulerMark(rmkCur, MultDiv(xa, dxpLogInch, czaInch) + xpSelBar -
              xpMinCur - (dxpMark >> 1), FALSE);

            /* We are moving one of the margins. */
            if (rmkCur < rmkMARGMAX)
                {
                if (vfMargChanged = mprmkdxa[rmkCur] != xa)
                    {
                    mprmkdxa[rmkCur] = xa;
                    }

#ifdef RULERALSO
                /* Update dialog box */
                if (vhDlgIndent)
                    {
                    SetIndentText(rmkCur, xa);
                    }
#endif /* RULERALSO */

                }

            /* It is a tab we are inserting/deleting. */
            else
                {
                tbd.dxa = xa;

                /* Is this a new tab? */
                if (ptbd->dxa == 0)
                    {
                    /* Insert the new tab. */
                    InsertRulerTab(&tbd);
                    }

                /* We are moving a tab; if it hasn't really moved, then do
                nothing.  */
                else if (!FCloseXa(ptbd->dxa, xa))
                    {
                    DeleteRulerTab(ptbd);
                    InsertRulerTab(&tbd);
                    }
                }
            }

        /* We are deleting the tab; if its a new, there's nothing to do. */
        else if (ptbd->dxa != 0)
            {
            DeleteRulerTab(ptbd);
            }
        }
    else
        {
        /* If the mouse is on a button within the same button group, then
        reflect the change. */

        int btnT;

        RulerStateFromPt(pt, &rlc, &btnT);
        if (rlc == rlcCur)
            {
            UpdateRulerBtn(rlc, btn = btnT);
            }
        fBtnChanged = btn != mprlcbtnDown[btn];
        }

    /* Do the format only if a button changed */
    if ((fBtnChanged && rlcCur != rlcTAB) || vfMargChanged || vfTabsChanged)
        {
        struct SEL selSave;
        typeCP dcp;
        typeCP dcp2;
        CHAR rgb[1 + cchINT];
        CHAR *pch;
        int sprm;
        int val;
        struct TBD (**hgtbd)[];

        /* Set the selection to cover all of the paragraphs selected. */
        ExpandCurSel(&selSave);
        dcp2 = (dcp = selCur.cpLim - selCur.cpFirst) - (selCur.cpLim > cpMacCur
          ? ccpEol : 0);
        SetUndo(uacRulerChange, docCur, selCur.cpFirst, (rlcCur != rlcRULER ||
          rmkCur < rmkMARGMAX) ? dcp : dcp2, docNil, cpNil, dcp2, 0);

        /* Set the sprm and it's value for the ruler change. */
        switch (rlcCur)
            {
        case rlcSPACE:
            sprm = sprmPDyaLine;
            val = (mprlcbtnDown[rlcSPACE] - btnSINGLE) * (czaLine / 2) +
              czaLine;
            break;

        case rlcJUST:
            sprm = sprmPJc;
            val = mprlcbtnDown[rlcJUST] - btnLEFT + jcLeft;
            break;

        case rlcRULER:
            switch (rmkCur)
                {
            case rmkINDENT:
                sprm = sprmPFIndent;
                val = mprmkdxa[rmkINDENT] - mprmkdxa[rmkLMARG];
                break;

            case rmkLMARG:
                /* Changing the left margin changes the first indent as well.
                First, the indent... */
                val = mprmkdxa[rmkINDENT] - mprmkdxa[rmkLMARG];
                pch = &rgb[0];
                *pch++ = sprmPFIndent;
                bltbyte(&val, pch, cchINT);
                AddOneSprm(rgb, FALSE);

                /* Now for the left margin... */
                sprm = sprmPLMarg;
                val = mprmkdxa[rmkLMARG];
                break;

            case rmkRMARG:
                sprm = sprmPRMarg;
                val = vdxaTextRuler - mprmkdxa[rmkRMARG];
                break;

            case rmkLTAB:
            case rmkDTAB:
                /* Tabs are different.  The change is made by blting the new tab
                table on top of the old. */
                vfTabsChanged = FALSE;
                if ((hgtbd = (**hpdocdod)[docCur].hgtbd) == NULL)
                    {
                    if (FNoHeap(hgtbd = (struct TBD (**)[])HAllocate(itbdMax *
                      cwTBD)))
                        {
                        return;
                        }
                    (**hpdocdod)[docCur].hgtbd = hgtbd;
                    }
                blt(rgtbdRuler, *hgtbd, itbdMax * cwTBD);

                /* Changing the tabs makes everything dirty. */
                (**hpdocdod)[docCur].fDirty = TRUE;
                vdocParaCache = docNil;
                TrashAllWws();
                goto ChangeMade;
                }

            /* Indicate that the margins have been set. */
            vfMargChanged = FALSE;
            }

        /* Now, lets set the sprm to the new value. */
        pch = &rgb[0];
        *pch++ = sprm;
        bltbyte(&val, pch, cchINT);
        AddOneSprm(rgb, FALSE);

ChangeMade:
        /* Reset the selection to it's old value. */
        EndLookSel(&selSave, TRUE);
        }
    }


near RulerStateFromPt(pt, prlc, pbtn)
POINT pt;
int *prlc;
int *pbtn;
    {
    /* This routine return in *prlc and *pbtn, the button group and the button
    at point pt.  The only button in group rlcRULER is btnNIL. */

    int btn;

    /* First check if the point is in a button. */
    for (btn = btnMIN; btn < btnMaxUsed; btn++)
        {
        if (PtInRect((LPRECT)&rgrcRulerBtn[btn], pt))
            {
            goto ButtonFound;
            }
        }

    /* The point is either on the tab ruler or nowhere of any interest. */
    *prlc = (pt.y >= dypRuler - dypMark - 2 && pt.x > xpSelBar - (dxpMark >> 1)
      && pt.x < dxpRuler + (dxpMark >> 1)) ? rlcRULER : rlcNIL;
    *pbtn = btnNIL;
    return;

ButtonFound:
    /* The point is in a button, we just have to decide which button group. */
    switch (btn)
        {
        case btnLTAB:
        case btnDTAB:
            *prlc = rlcTAB;
            break;

        case btnSINGLE:
        case btnSP15:
        case btnDOUBLE:
            *prlc = rlcSPACE;
            break;

        case btnLEFT:
        case btnCENTER:
        case btnRIGHT:
        case btnJUST:
            *prlc = rlcJUST;
            break;
        }
    *pbtn = btn;
    }


void near HighlightButton(fOn, btn)
BOOL fOn; /* true if we should highlight this button, false = unhighlight */
int btn;
    {
    register PRECT prc = &rgrcRulerBtn[btn];
    int dxpBtn = prc->right - prc->left;
    
    /* If we're highlighting, then get the black-on-white button from
       the right group; otherwise copy the white-on-black button ..pt */
    int btnFromBM = btn - btnMIN + (fOn ? btnMaxReal : 0);

    /* Ensure that we have the bitmap for the buttons. */
    if (SelectObject(hMDCBitmap, hbmBtn) == NULL)
        {
        if ((hbmBtn = LoadBitmap(hMmwModInstance, MAKEINTRESOURCE(idBmBtns+viBmRuler))) ==
          NULL || SelectObject(hMDCBitmap, hbmBtn) == NULL)
            {
            WinFailure();
            goto NoBtns;
            }
        }

    BitBlt(vhDCRuler, prc->left, prc->top, dxpBtn, prc->bottom - prc->top, 
           hMDCBitmap, btnFromBM * dxpBtn, 0, SRCCOPY);
    
    SelectObject(hMDCBitmap, hbmNullRuler);
NoBtns:;
    }


near UpdateRulerBtn(rlc, btn)
int rlc;
int btn;
    {
    /* This routine turns off the currently selected button in button group rlc
    and turns on button btn.  It is assumed that rlc is neither rlcNIL nor
    rlcRULER, since neither group has buttons to update. */

    int *pbtnOld = &mprlcbtnDown[rlc];
    int btnOld = *pbtnOld;

    Assert(rlc != rlcNIL && rlc != rlcRULER);

    /* If the button hasn't changed, then there is nothing to do. */
    if (btn != btnOld)
        {
        if (vhDCRuler != NULL)
            {
            /* Invert the old button (back to normal), and then invert the new
            button. */
            if (btnOld != btnNIL)
                {
                /* If there is no old button, then, of course, we can't invert
                it.  */
                HighlightButton(fFalse, btnOld);
                }

            if (btn != btnNIL)
                {
                /* If the new button is not btnNIL, then invert it. */
                HighlightButton(fTrue, btn);
                }
            }

        /* Record whic button is now set. */
        *pbtnOld = btn;
        }
    }

#ifdef KINTL
/* Given xa for a mouse position in a ruler, return the amount of xa for
   a display adjustment. */
unsigned near XaKickBackXa(xa)
    unsigned        xa;
{
    extern int      utCur;
    extern int      dxaAdjustPerCm;
    int             cCm, cCh;

    switch (utCur) {
        case utCm:
            cCm = xa / czaCm;
            return (dxaAdjustPerCm * cCm);
        case utInch:
            return (0);
        default:
            Assert(FALSE);
            return (0);
        }
}

near XpKickBackXp(xp)
    int xp;
{
    /* Computes the amount of a necessary kick-back in xp, if
       a ruler marker is to be drawn at a given xp. */
    extern int utCur;
    extern int dxaAdjustPerCm;

    int        cCm, cCh;

    switch (utCur) {
        case utInch:
            return 0;
        case utCm:
            /* For every cm, we are off by dxaAdjustPerCm twips. */
            cCm = (xp - xpSelBar + xpMinCur + (dxpMark >> 1)) / dxpLogCm;
            return (MultDiv(dxaAdjustPerCm * cCm, dxpLogInch, czaInch));
        default:
            Assert(FALSE);
            return 0;
        }
}
#endif /* ifdef KINTL */


near MergeRulerMark(rmk, xpMark, fHighlight)
int rmk;
int xpMark;
BOOL fHighlight;
    {
    /* This routine merges the ruler mark, rmk, with the contents of the ruler
    bar at xpMark.  To accomodate color, the merging of the mark with the
    background must be done first in a monochrome memory bitmap, then converted
    back to color.  The mark is highlighed if fHighlight is set. */

    int ypMark = dypRuler - dypMark - 1;

    /* Ensure that we have the bitmap for the ruler marks. */
    if (SelectObject(hMDCBitmap, hbmMark) == NULL)
        {
        if ((hbmMark = LoadBitmap(hMmwModInstance, MAKEINTRESOURCE(idBmMarks+viBmRuler))) == NULL
          || SelectObject(hMDCBitmap, hbmMark) == NULL)
            {
            WinFailure();
            return;
            }
        }

#ifdef KINTL
    /* Adjust for the kick back */
    xpMark += XpKickBackXp(xpMark);
#endif /* ifdef KINTL */

    /* Merge the mark into the monochrome bitmap. */
    BitBlt(hMDCScreen, xpMark, 0, dxpMark, dypMark, hMDCBitmap, (rmk - rmkMIN) *
      dxpMark, 0, MERGEMARK);

    /* Display the bitmap on the ruler bar. */
    BitBlt(vhDCRuler, xpMark, ypMark, dxpMark, dypMark, hMDCScreen, xpMark, 0,
      fHighlight ? NOTSRCCOPY : SRCCOPY);

    SelectObject(hMDCBitmap, hbmNullRuler);
    }


BOOL near FPointNear(xaTarget, xaProbe)
unsigned xaTarget;
unsigned xaProbe;
    {
    /* This routine returns TRUE if and only if xaProbe is sufficiently close to
    xaTarget for selection purposes. */

    int dxa;

    if ((dxa = xaTarget - xaProbe) < 0)
        {
        dxa = -dxa;
        }
    return (dxa < MultDiv(dxpMark, czaInch, dxpLogInch) >> 1);
    }


unsigned near XaQuantize(xp)
int xp;
    {
#ifdef KINTL
     /* This routine converts an x-coordinate from the ruler to twips
        rounding it to the nearest sixteenth of an inch if utCur = utInch,
        or to the nearest eighth of a centimeter if utCur = utCm. */
    unsigned xa = MultDiv(xp - xpSelBar + xpMinCur, czaInch, dxpLogInch);
    return (XaQuantizeXa(xa));
#else
    /* This routine converts an x-coordinate from the ruler to twips rounding it
    to the nearest sixteenth of an inch. */

    unsigned xa = MultDiv(xp - xpSelBar + xpMinCur, czaInch, dxpLogInch);

    /* NOTE: This code has been simplified because we "know" czaInch is a
    multiple of 32. */
    return ((xa + czaInch / 32) / (czaInch / 16) * (czaInch / 16));
#endif /* not KINTL */
    }

#ifdef KINTL
unsigned near XaQuantizeXa(xa)
    unsigned xa;
{
    extern int utCur;
    long    xaL;

    switch (utCur) {
        case utInch:
            /* NOTE: This code has been simplified because we "know" czaInch is a
                     multiple of 32. */
            return ((xa + czaInch / 32) / (czaInch / 16) * (czaInch / 16));
        case utCm:
            /* NOTE: Actually, we are calculating:
                     (xa + czaCm / 16) / (czaCm / 8) * (czaCm / 8)
                     but calculated in 16*twips, so that there will
                     be the least rounding error. */
            xaL = ((long) xa) << 4;
            xaL = (xaL + czaCm) / (czaCm << 1) * (czaCm << 1);
            /* Kick back is adjusted in MergeRulerMark. */
            return ((unsigned) (xaL >> 4));
        default:
            Assert(FALSE);
            return (xa); /* Heck, it's better than nothing. */
        }
}
#endif /* KINTL */


near DeleteRulerTab(ptbd)
struct TBD *ptbd;
    {
    /* This routine removes the tab at ptbd from its table. */

    vfTabsChanged = TRUE;
    do
        {
        *ptbd = *(ptbd + 1);
        }
    while ((ptbd++)->dxa != 0);
    }


near InsertRulerTab(ptbd)
struct TBD *ptbd;
    {
    /* This routine inserts the tab *ptbd into rgtbdRuler unless there is one
    close to it already. */

    register struct TBD *ptbdT;
    unsigned dxa = ptbd->dxa;
    unsigned dxaT;

    /* Search the table for a tab that is close to the tab to be inserted. */
    for (ptbdT = &rgtbdRuler[0]; ptbdT->dxa != 0; ptbdT++)
        {
        if (FCloseXa(ptbdT->dxa, dxa))
            {
            /* Overwrite the old tab iff the tab has changed. */
            if (ptbdT->jc != ptbd->jc)
                {
                *ptbdT = *ptbd;
                vfTabsChanged = TRUE;
                }

            /* Clean up the ruler and exit. */
            RulerPaint(TRUE, FALSE, TRUE);
            return;
            }
        }

    vfTabsChanged = TRUE;

    /* Insert the tab at the correctly sorted place. */
    for (ptbdT = &rgtbdRuler[0]; (dxaT = ptbdT->dxa) != 0; ptbdT++)
        {
        if (dxa <= dxaT)
            {
            /* Insert the tab in front of ptbdT and move the remaining tabs up
            one slot.  The last tab will be overwritten to avoid table overflow.
            */
            blt(ptbdT, ptbdT + 1, ((&rgtbdRuler[0] - ptbdT) + (itbdMax - 2)) *
              cwTBD);
            *ptbdT = *ptbd;
            return;
            }
        }

    /* Insert the tab at the end of the table unless the table is full. */
    if (ptbdT - &rgtbdRuler[0] < itbdMax - 1)
        {
        *ptbdT = *ptbd;
        (ptbdT + 1)->dxa = 0;
        }
    }


BOOL near FCloseXa(xa1, xa2)
unsigned xa1;
unsigned xa2;
    {
#ifdef KINTL
    /* This function returns TRUE if xa1 is "close" to xa2;
       FALSE otherwise.  Threshold is determined by utCur. */
    int dxa;
    int dxaThreshold;

    extern int utCur;

    if ((dxa = xa1 - xa2) < 0)
        {
        dxa = -dxa;
        }
    switch (utCur) {
        case utInch:
            dxaThreshold = czaInch / 16;
            break;
        case utCm:
            dxaThreshold = czaCm / 8;
            break;
        default:
            Assert(FALSE);
            dxaThreshold = 0; /* Heck.  It doesn't matter at this point. */
            break;
        }
    return (dxa < dxaThreshold);
#else /* not KINTL */
    /* This function returns TRUE if xa1 is "close" to xa2; FALSE otherwise. */

    int dxa;

    if ((dxa = xa1 - xa2) < 0)
        {
        dxa = -dxa;
        }
    return (dxa < czaInch / 16);
#endif /* not KINTL */
    }



#ifdef DEBUG
RulerMarquee()
    {
    /* This routine displays and scrolls the "marquee" message in the ruler mark
    area. */

    static CHAR szMarquee[] = "Dz}w|d`3Dazgv3{r`3qvv}3qa|ft{g3g|3j|f3qj3Q|q?3Q|q?3Qajr}?3P{z>P{fv}?3r}w3Crg";
    LOGFONT lf;
    HFONT hf;
    HFONT hfOld;

    /* Decode the marquee message. */
    if (szMarquee[0] == 'D')
        {
        int ich;

        for (ich = 0; ich < sizeof(szMarquee) - 1; ich++)
            {
            szMarquee[ich] ^= 0x13;
            }
        }

    /* Get a logical font that will fit in the ruler mark area. */
    bltbc(&lf, 0, sizeof(LOGFONT));
    lf.lfHeight = -dypMark;
    lf.lfPitchAndFamily = FIXED_PITCH;

    /* Can we create such a font. */
    if ((hf = CreateFontIndirect(&lf)) != NULL)
        {
        if ((hfOld = SelectObject(vhDCRuler, hf)) != NULL)
            {
            int xp;
            int yp = dypRuler - dypMark - 1;
            int dxp = LOWORD(GetTextExtent(vhDCRuler, (LPSTR)szMarquee,
              sizeof(szMarquee) - 1));
            int dxpScroll = MultDiv(GetSystemMetrics(SM_CXSCREEN), dypMark,
              2048);
            int iLevel;
            TEXTMETRIC tm;

            /* Erase what is in the ruler mark area. */
            PatBlt(vhDCRuler, 0, yp, dxpRuler, dypMark, ropErase);

            /* Scroll the marquee across the screen. */
            iLevel = SaveDC(vhDCRuler);
            IntersectClipRect(vhDCRuler, xpSelBar, yp, dxpRuler, dypRuler - 1);
            GetTextMetrics(vhDCRuler, (LPTEXTMETRIC)&tm);
            for (xp = dxpRuler; xp > xpSelBar - dxp; xp -= dxpScroll)
                {
                BitBlt(vhDCRuler, xp, yp, min(dxpRuler - (xp + dxpScroll), dxp),
                  dypMark, vhDCRuler, xp + dxpScroll, yp, SRCCOPY);
                PatBlt(vhDCRuler, min(dxpRuler - dxpScroll, xp + dxp), yp,
                  dxpScroll, dypMark, ropErase);
                if (xp + dxp >= dxpRuler)
                    {
                    int dxpch = (dxpRuler - xp) % tm.tmAveCharWidth;
                    int ich = (dxpRuler - xp) / tm.tmAveCharWidth;

                    if (dxpch == 0 && xp < dxpRuler)
                        {
                        dxpch = tm.tmAveCharWidth;
                        ich--;
                        }
                    TextOut(vhDCRuler, dxpRuler - dxpch, yp -
                      tm.tmInternalLeading, (LPSTR)&szMarquee[ich], 1);
                    }
                }
            RestoreDC(vhDCRuler, iLevel);

            /* Cleanup the font and the screen. */
            SelectObject(vhDCRuler, hfOld);
            RulerPaint(TRUE, FALSE, TRUE);
            }
        DeleteObject(hf);
        }
    }
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\ruler3.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* The file contains the message handler for the ruler. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOCLIPBOARD
#define NOMENUS
#define NOCTLMGR
#include <windows.h>

extern HBITMAP hbmNull;

extern HWND vhWndRuler;
extern HDC vhDCRuler;
extern HDC hMDCBitmap;
extern HDC hMDCScreen;
extern HBITMAP hbmBtn;
extern HBITMAP hbmMark;
extern HBITMAP hbmNullRuler;
extern int dxpRuler;
extern int dypRuler;


long FAR PASCAL RulerWndProc(hWnd, message, wParam, lParam)
HWND hWnd;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine processes the messages sent to the ruler window. */

    extern vfCloseFilesInDialog;

    PAINTSTRUCT ps;

    switch (message)
        {
        case WM_PAINT:
            /* Time for the ruler to draw itself. */
            ResetRuler();
            BeginPaint(hWnd, (LPPAINTSTRUCT)&ps);
            RulerPaint(FALSE, TRUE, TRUE);
            EndPaint(hWnd, (LPPAINTSTRUCT)&ps);
            RulerPaint(TRUE, FALSE, FALSE);
            break;

        case WM_SIZE:
            /* We are saving the length of the ruler; we already know it's
            height. */
            dxpRuler = MAKEPOINT(lParam).x;
            break;

        case WM_DESTROY:
            /* Destroy the ruler window. */
            if (hMDCBitmap != NULL)
                {
                DeleteDC(hMDCBitmap);
                }
            if (hMDCScreen != NULL)
                {
                DeleteObject(SelectObject(hMDCScreen, hbmNull));
                DeleteDC(hMDCScreen);
                }
            if (vhDCRuler != NULL)
                {
                DeleteObject(SelectObject(vhDCRuler,
                  GetStockObject(SYSTEM_FONT)));
                SelectObject(vhDCRuler, GetStockObject(WHITE_BRUSH));
                DeleteObject(SelectObject(vhDCRuler,
                  GetStockObject(BLACK_PEN)));
                ReleaseDC(vhWndRuler, vhDCRuler);
                }
            if (hbmNullRuler != NULL)
                {
                DeleteObject(hbmNullRuler);
                hbmNullRuler = NULL;
                }
            vhDCRuler = hMDCScreen = hMDCBitmap = NULL;
            break;

        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
            /* Process mouse events on the ruler. */
            RulerMouse(MAKEPOINT(lParam));
            break;

#ifdef DEBUG
        case WM_RBUTTONDBLCLK:
            /* This the trap door that displays the "marquee" message. */
            if (wParam & MK_SHIFT && wParam & MK_CONTROL)
                {
                RulerMarquee();
                break;
                }
#endif

        default:
            /* All of the messages we are not interested in. */
            return (DefWindowProc(hWnd, message, wParam, lParam));
            break;
        }

    if (vfCloseFilesInDialog)
        CloseEveryRfn( FALSE );

    /* A window procedure should always return something. */
    return (0L);
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\screen.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This routine sets up the screen position used by Word relative to the
current device. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOMENUS
/* HEY!  if you change this to wwsmall.h, talk to bobm!
    (see Assert(LF_FACESIZE == LocalFaceSize)) */
#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "fontdefs.h"


int viffnDefault = -1;
CHAR rgffnFontFamily[6][ibFfnMax];


struct FFN *PffnDefault(ffid)
/* returns pointer to default font structure for this font family ID, which
   is set up when we started the program */

FFID ffid;
    {
    int iffn;
    struct FFN *pffn;

    if (ffid == FF_DONTCARE)
        {
        Assert(viffnDefault >= 0);
        iffn = viffnDefault;
        }
    else
        iffn = MpFfidIffn(ffid);

    pffn = (struct FFN *)(rgffnFontFamily[iffn]);
    if (pffn->szFfn[0] == 0)
        /* haven't gotten this one yet - must be old word document */
        GetDefaultFonts(TRUE, FALSE);

    Assert(pffn->szFfn[0] != 0);
    return(pffn);
    }



GetDefaultFonts(fExtraFonts, fGetAspect)
/* We set up our table of default fonts in two steps.  First we choose a single
   font, to use as the default font for a new document.  Perhaps later, we
   are asked for a set of default fonts for different families to help
   make sense out of an old, word document.  That case is differentiated
   by fExtraFonts being TRUE */

int fExtraFonts, fGetAspect;

    {
    extern int aspectXFont;
    extern int aspectYFont;
    extern HDC vhDCPrinter;
    struct FFN *pffn;
    CHAR rgb[ibFfnMax];

    Assert(LF_FACESIZE == LocalFaceSize);
#ifndef NEWFONTENUM  
    Assert(vhDCPrinter);
    if (fGetAspect && vhDCPrinter != NULL)
        {
        extern FARPROC lpFontFaceEnum;
        int rgw[6];

        rgw[0] = enumFindAspectRatio;
        rgw[1] = rgw[2] = 0xFFFF;
        rgw[3] = GetDeviceCaps(vhDCPrinter, LOGPIXELSY);
        rgw[4] = GetDeviceCaps(vhDCPrinter, LOGPIXELSX);
        rgw[5] = TRUE;
        
        EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
        aspectXFont = rgw[1];
        aspectYFont = rgw[2];
        }
#endif

    if (FInitFontEnum(docNil, fExtraFonts ? 32767 : 1, TRUE))
        {
        pffn = (struct FFN *)rgb;
        while (FEnumFont(pffn))
#ifdef NEWFONTENUM
            DefaultFamilyCheck(pffn->ffid, pffn->szFfn, pffn->chs);
#else
            DefaultFamilyCheck(pffn->ffid, pffn->szFfn);
#endif
        EndFontEnum();
        }

    /* Fill in just in case we missed some.  The order here is important, if
    there are no fonts at all, the default font will be the first one. */
    {
    extern CHAR szModern[];
    extern CHAR szRoman[];
    extern CHAR szSwiss[];
    extern CHAR szScript[];
    extern CHAR szDecorative[];

    DefaultFamilyCheck(FF_MODERN, szModern, NULL);
    if (fExtraFonts)
        {
        DefaultFamilyCheck(FF_ROMAN, szRoman, NULL);
        DefaultFamilyCheck(FF_SWISS, szSwiss, NULL);
        DefaultFamilyCheck(FF_SCRIPT, szScript, NULL);
        DefaultFamilyCheck(FF_DECORATIVE, szDecorative, NULL);
        DefaultFamilyCheck(FF_DONTCARE, szSwiss, NULL);
        }
    }

    }



DefaultFamilyCheck(ffid, sz, chsIfKnown)
FFID ffid;
CHAR *sz;
BYTE chsIfKnown;
    {
    int iffn;
    struct FFN *pffn;

    iffn = MpFfidIffn(ffid);
    pffn = (struct FFN *)(rgffnFontFamily[iffn]);
    if (pffn->szFfn[0] == 0)
        {
#ifdef NEWFONTENUM
        pffn->chs = chsIfKnown;
#endif
        pffn->ffid = ffid;
        bltszLimit(sz, pffn->szFfn, LF_FACESIZE);
        if (viffnDefault < 0)
                /* this font will be chosen for new documents */
                viffnDefault = iffn;
        }
    }


#define iffnSwiss 0
#define iffnRoman 1
#define iffnModern 2
#define iffnScript 3
#define iffnDecorative 4
#define iffnDontCare 5


MpFfidIffn(ffid)
FFID ffid;
    {
    switch (ffid)
        {
        default:
            Assert( FALSE );
            /* FALL THROUGH */
        case FF_DONTCARE:
            return(iffnDontCare);
        case FF_SWISS:
            return(iffnSwiss);
        case FF_ROMAN:
            return(iffnRoman);
        case FF_MODERN:
            return(iffnModern);
        case FF_SCRIPT:
            return(iffnScript);
        case FF_DECORATIVE:
            return(iffnDecorative);
        }
    }


ResetDefaultFonts(fGetAspect)
int fGetAspect;
    {
    /* This routine resets the default mapping from a font family to a font face
    name. */
    bltbc(rgffnFontFamily, 0, 6 * ibFfnMax);
    viffnDefault = -1;
    GetDefaultFonts(FALSE, fGetAspect);
    }




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\rulerdef.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/


/* These statments define indexes into the ruler button table.	They must agree
with the order the bitmaps are read in mmw.c. */

#define btnNIL		(-1)
#define btnMIN		0
#define btnLTAB 	0
#define btnDTAB 	1
#define btnTABMAX	1
#define btnSINGLE	2
#define btnSP15 	3
#define btnDOUBLE	4
#define btnSPACEMAX	4
#define btnLEFT 	5
#define btnCENTER	6
#define btnRIGHT	7
#define btnJUST 	8

/* Whereas Write 2.x inverted the above-mentioned buttons, the Write 3.x
   buttons have been changed to have rounded corners so can't do that.
   Instead we "follow" the first 8 buttons with 8 more that are "filled-in"
   so we blt back and forth between the two ..pault 7/7/89 */

#define btnMaxReal		9
#define btnMaxUsed      9

/* These statements define the different type of places a mouse might button
down on the ruler. */
#define rlcNIL		(-1)
#define rlcTAB		0
#define rlcSPACE	1
#define rlcJUST 	2
#define rlcRULER	3
#define rlcBTNMAX	3
#define rlcMAX		4

/* These statements define the different types of marks that can appear on the
ruler. */
#define rmkMIN		0
#define rmkMARGMIN	0
#define rmkINDENT	0
#define rmkLMARG	1
#define rmkRMARG	2
#define rmkMARGMAX	3
#define rmkLTAB 	3
#define rmkDTAB 	4
#define rmkMAX		5


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\running.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* running.c -- code to handle editing of running header and footer */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
//#define NOATOM
//#define NOGDI
#define NOFONT
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "machdefs.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "cmddefs.h"
#include "editdefs.h"
#include "propdefs.h"
#include "prmdefs.h"
#include "wwdefs.h"
#include "dlgdefs.h"
#include "menudefs.h"
#include "str.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef JAPAN //T-HIROYN Win3.1
#include "kanji.h"
#endif

int NEAR EditHeaderFooter();

    /* Current allowable cp range for display/edit/scroll */
extern typeCP cpMinCur;
extern typeCP cpMacCur;

extern struct DOD (**hpdocdod)[];
extern struct WWD rgwwd[];
extern int docCur;
extern int docScrap;
extern int vfSeeSel;
extern struct SEL selCur;
extern struct PAP vpapAbs;
extern struct SEP vsepNormal;
extern HANDLE       vhWnd;
extern HANDLE       hMmwModInstance;
extern HANDLE       hParentWw;
#ifdef INEFFLOCKDOWN
extern FARPROC      lpDialogRunningHead;
#else
BOOL far PASCAL DialogRunningHead(HWND, unsigned, WORD, LONG);
FARPROC lpDialogRunningHead = NULL;
#endif
extern HANDLE       vhDlgRunningHead;
extern CHAR     stBuf[255];
extern int      utCur;
extern int      ferror;
extern int      vccpFetch;
extern int      vcchFetch;
extern CHAR     *vpchFetch;
extern struct CHP   vchpFetch;
extern typeCP       vcpLimParaCache;
extern HWND     vhWndMsgBoxParent;

    /* Min, Max cp's for header, footer */
typeCP cpMinHeader=cp0;
typeCP cpMacHeader=cp0;
typeCP cpMinFooter=cp0;
typeCP cpMacFooter=cp0;

    /* Min cp for document less header, footer */
    /* Header & footer always appear at the beginning */
typeCP cpMinDocument=cp0;

    /* The following variables are used in this module only */

#define cchWinTextSave  80
static CHAR     (**hszWinTextSave)[]=NULL;
static struct PAP   *ppapDefault;

    /* cpFirst and selection are saved in these during header/footer edit */
typeCP       cpFirstDocSave;
struct SEL   selDocSave;


HWND vhDlgRunning;



fnEditRunning(imi)
{   /* Enter mode so that user is editing the current document's
       running header or footer in the same window as he was editing
       the document, with the header/footer info in the dialog box
       NOT currently in focus ..pault */

#ifndef INEFFLOCKDOWN
  if (!lpDialogRunningHead)
    if (!(lpDialogRunningHead = MakeProcInstance(DialogRunningHead, hMmwModInstance)))
      {
      WinFailure();
      return;
      }
#endif

  Assert(imi == imiHeader || imi == imiFooter);

  if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
  {
    SetFocus(vhDlgRunningHead);
    return;
  }

  if (imi == imiHeader)
    wwdCurrentDoc.fEditHeader = TRUE;
  else
    wwdCurrentDoc.fEditFooter = TRUE;

  EditHeaderFooter();
  if (ferror)
    {    /* Not enough memory to stabilize the running head environs */
    if (wwdCurrentDoc.fEditHeader)
      wwdCurrentDoc.fEditHeader = FALSE;
    else
      wwdCurrentDoc.fEditFooter = FALSE;
    return;
    }
  vhDlgRunningHead = CreateDialog(hMmwModInstance,
                                 MAKEINTRESOURCE(wwdCurrentDoc.fEditHeader ?
                                                dlgRunningHead : dlgFooter),
                                 hParentWw, lpDialogRunningHead);
  if (vhDlgRunningHead)
    {
    SetFocus(wwdCurrentDoc.wwptr);
    }
 else
    { /* recover and bail out */
    fnEditDocument();
#ifdef WIN30
    WinFailure();
#else
    Error(IDPMTNoMemory);
#endif
    }
}



int NEAR EditHeaderFooter()
{   /* Setup for edit of header or footer */
 extern HWND hParentWw;

 int fHeader=wwdCurrentDoc.fEditHeader;
 CHAR szWinTextSave[ cchWinTextSave ];
 typeCP cpFirst;
 typeCP cpLim;
#ifdef DEBUG
    /* TEST Assumption: No changes take place in running head/foot cp range
       during an interval in which no head/foot edits take place */
 typeCP cpMinDocT=cpMinDocument;

 ValidateHeaderFooter( docCur );
 Assert( cpMinDocT == cpMinDocument );
#endif

 if (fHeader)
    {
    cpFirst = cpMinHeader;
    cpLim = cpMacHeader;
    }
 else
    {
    cpFirst = cpMinFooter;
    cpLim = cpMacFooter;
    }

 Assert( wwdCurrentDoc.fEditHeader != wwdCurrentDoc.fEditFooter );

    /* Save the cpFirst of the document window so we get a clean
       transition back to where we were in the document*/
 cpFirstDocSave = wwdCurrentDoc.cpFirst;
 selDocSave = selCur;

 TrashCache();
 TrashWw( wwDocument );

 if (!FWriteOk( fwcNil ))
    goto DontEdit;

 if ( cpFirst == cpLim )
    {
    /* If we are editing the header/footer for the first time in this document,
       insert a para end mark to hold the running h/f properties */
    extern struct PAP *vppapNormal;
    struct PAP papT;

    blt( vppapNormal, &papT, cwPAP );
    papT.rhc = (wwdCurrentDoc.fEditHeader) ?
             rhcDefault : rhcDefault + RHC_fBottom;

    InsertEolPap( docCur, cpFirst, &papT );
    if (ferror)
    return;
    ValidateHeaderFooter( docCur );
    cpLim += ccpEol;
    }
 else
    {
    extern int vccpFetch;
    typeCP cp;

    /* Test for a special case: loading a WORD document which has been
       properly set up to have running head/foot under MEMO.  We must
       force the para end mark at the end of the header/footer to be
       a fresh run.  This is so we will see an end mark when editing one
       of these.  FormatLine only checks for cpMacCur at the start of a run. */

    Assert( cpLim - cpFirst >= ccpEol );

    if ( (cp = cpLim - ccpEol) > cpFirst )
    {
    FetchCp( docCur, cp - 1, 0, fcmBoth );

    if ( vccpFetch > 1)
        {   /* char run does not end with char before EOL */
        /* Insert a char, then delete it */
        extern struct CHP vchpNormal;
        CHAR ch='X';

        InsertRgch( docCur, cp, &ch, 1, &vchpNormal, NULL );
        if (ferror)
        return;
        Replace( docCur, cp, (typeCP) 1, fnNil, fc0, fc0 );
        if (ferror)
        return;
        }
    }
    }

DontEdit:

 /* Save current window text; set string */

 GetWindowText( hParentWw, (LPSTR)szWinTextSave, cchWinTextSave );
 if (FNoHeap(hszWinTextSave=HszCreate( (PCH)szWinTextSave )))
    {
    hszWinTextSave = NULL;
    }
  else
    {
    extern CHAR szHeader[];
    extern CHAR szFooter[];

    SetWindowText( hParentWw, fHeader ? (LPSTR)szHeader:(LPSTR)szFooter );
    }

   /* Set editing limits to just the cp range of the header/footer,
       minus the "invisible" terminating EOL */
 wwdCurrentDoc.cpFirst = wwdCurrentDoc.cpMin = cpMinCur = cpFirst;
 wwdCurrentDoc.cpMac = cpMacCur = CpMax( cpMinCur, cpLim - ccpEol );

    /* Leave the cursor at the beginning of the header/footer regardless */
 Select( cpMinCur, cpMinCur );
    /* Show the display here instead of waiting for Idle() because it looks
       better to have the head/foot text come up right away instead of waiting
       for the dialog box to come up */
 UpdateDisplay( FALSE );
 vfSeeSel = TRUE;   /* Tell Idle() to scroll the selection into view */
 NoUndo();
 ferror = FALSE;    /* If we got this far, we want to go into running
               head mode regardless of errors */
}




fnEditDocument()
{   /* Return to editing document after editing header/footer */
 extern HWND hParentWw;

 Assert( wwdCurrentDoc.fEditFooter != wwdCurrentDoc.fEditHeader );

    /* Restore original window name */
 if (hszWinTextSave != NULL)
    {
    SetWindowText( hParentWw, (LPSTR) (**hszWinTextSave) );
    FreeH( hszWinTextSave );
    hszWinTextSave = NULL;
    }

 TrashCache();

 ValidateHeaderFooter( docCur );    /* This will update from the results of
                       the header/footer edit */
 TrashCache();
 wwdCurrentDoc.cpMin = cpMinCur = cpMinDocument;
 wwdCurrentDoc.cpMac = cpMacCur = CpMacText( docCur );

 TrashWw( wwDocument );
 wwdCurrentDoc.fEditHeader = FALSE;
 wwdCurrentDoc.fEditFooter = FALSE;

    /* Restore saved selection, cpFirst for document */
 wwdCurrentDoc.cpFirst = cpFirstDocSave;
 Select( selDocSave.cpFirst, selDocSave.cpLim );

 Assert( wwdCurrentDoc.cpFirst >= cpMinCur &&
     wwdCurrentDoc.cpFirst <= cpMacCur );

 NoUndo();
 vhDlgRunningHead = (HANDLE)NULL;
}




BOOL far PASCAL DialogRunningHead( hDlg, message, wParam, lParam )
HWND    hDlg;           /* Handle to the dialog box */
unsigned message;
WORD wParam;
LONG lParam;
{
    /* This routine handles input to the Header/Footer dialog box. */

    extern BOOL vfPrinterValid;

    RECT rc;
    CHAR *pch = &stBuf[0];
    struct SEP **hsep = (**hpdocdod)[docCur].hsep;
    struct SEP *psep;
    static int fChecked;
    typeCP dcp;

    switch (message)
    {
    case WM_INITDIALOG:
        vhDlgRunning = hDlg;    /* Put dialog handle in a global for
                       ESC key in document functionality */
        CachePara(docCur, selCur.cpFirst);
        ppapDefault = &vpapAbs;

        FreezeHp();
        /* Get a pointer to the section properties. */
        psep = (hsep == NULL) ? &vsepNormal : *hsep;

        CheckDlgButton(hDlg, idiRHFirst, (ppapDefault->rhc & RHC_fFirst));
        if (wwdCurrentDoc.fEditHeader)
        {
        CchExpZa(&pch, psep->yaRH1, utCur, cchMaxNum);
        }
        else /* footer dialog box */
        {
#ifdef  KOREA    /* 91.3.17 want to guarantee Default >= MIN, Sangl */
              if (vfPrinterValid)
                {   extern int dyaPrOffset;
                    extern int dyaPrPage;
                CchExpZa(&pch, imax(psep->yaMac - psep->yaRH2,
            vsepNormal.yaMac - dyaPrOffset -  dyaPrPage),utCur, cchMaxNum);
                 }
              else
                CchExpZa(&pch, psep->yaMac - psep->yaRH2, utCur, cchMaxNum);
#else
        CchExpZa( &pch, psep->yaMac - psep->yaRH2, utCur, cchMaxNum);
#endif
        }
        SetDlgItemText(hDlg, idiRHDx, (LPSTR)stBuf);
        MeltHp();
        break;

    case WM_ACTIVATE:
        if (wParam)
        {
        vhWndMsgBoxParent = hDlg;
        }
    return(FALSE); /* so that we leave the activate message to
    the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
            switch (wParam)
        {
        int dya;

        case idiRHFirst:
        CheckDlgButton( hDlg, idiRHFirst, !IsDlgButtonChecked(hDlg, idiRHFirst));
        (**hpdocdod) [docCur].fDirty = TRUE;
        break;
        case idiRHInsertPage:
        if (FWriteOk( fwcInsert ))
            {   /* Insert page # at insertion pt */
            extern struct CHP vchpFetch, vchpSel;
            extern int vfSeeSel;
            CHAR ch=schPage;
            struct CHP chp;

            if (selCur.cpFirst == selCur.cpLim)
            {   /* Sel is insertion point -- get props from
                               the vchpSel kludge */
            blt( &vchpSel, &chp, cwCHP );
            }
            else
            {
            FetchCp( docCur, selCur.cpFirst, 0, fcmProps );
            blt( &vchpFetch, &chp, cwCHP );
            }

            chp.fSpecial = TRUE;

#ifdef JAPAN //T-HIROYN Win3.1
            if(NATIVE_CHARSET != GetCharSetFromChp(&chp)) {
                SetFtcToPchp(&chp, GetKanjiFtc(&chp));
            }
#endif

            SetUndo( uacInsert, docCur, selCur.cpFirst, (typeCP) 1,
             docNil, cpNil, cp0, 0 );
            InsertRgch( docCur, selCur.cpFirst, &ch, 1, &chp, NULL );

            vfSeeSel = TRUE;
            }
        break;

        case idiRHClear:
        /* Clear running head/foot */
        dcp = cpMacCur-cpMinCur;

#if defined(OLE)
        {
            BOOL bIsOK;

            ObjPushParms(docCur);
            Select(cpMinCur,cpMacCur);
            bIsOK = ObjDeletionOK(OBJ_DELETING);
            ObjPopParms(TRUE);

            if (!bIsOK)
                break;
        }
#endif

        if (dcp > 0 && FWriteOk( fwcDelete ))
            {
            NoUndo();
            SetUndo( uacDelNS, docCur, cpMinCur, dcp,
             docNil, cpNil, cp0, 0 );
            Replace( docCur, cpMinCur, dcp, fnNil, fc0, fc0 );
            }
        break;

        case idiOk: /* return to document */
BackToDoc:
        if (!FPdxaPosIt(&dya, hDlg, idiRHDx))
            {
            break;
            }
        else if (vfPrinterValid)
            {
            extern struct SEP vsepNormal;
            extern int dxaPrOffset;
            extern int dyaPrOffset;
            extern int dxaPrPage;
            extern int dyaPrPage;
            extern struct WWD rgwwd[];

            int dyaPrBottom = imax(0, vsepNormal.yaMac - dyaPrOffset -
              dyaPrPage);


            if (FUserZaLessThanZa(dya, (wwdCurrentDoc.fEditHeader ?
              dyaPrOffset : dyaPrBottom)))
            {
            int dxaPrRight = imax(0, vsepNormal.xaMac - dxaPrOffset
              - dxaPrPage);

            EnableExcept(vhDlgRunningHead, FALSE);
            ErrorBadMargins(hDlg, dxaPrOffset, dxaPrRight,
              dyaPrOffset, dyaPrBottom);
            EnableExcept(vhDlgRunningHead, TRUE);
            SelectIdiText(hDlg, idiRHDx);
            SetFocus(GetDlgItem(hDlg, idiRHDx));
            break;
            }
            }


        DoFormatRHText( dya, IsDlgButtonChecked( hDlg, idiRHFirst ) );
        fnEditDocument();
        /* force repaint to the whole client area */
        GetClientRect(vhWnd, (LPRECT)&rc);
        InvalidateRect(vhWnd, (LPRECT)&rc, FALSE);
        vhWndMsgBoxParent = (HWND)NULL;
        DestroyWindow(hDlg);
        break;

        case idiCancel:
        goto BackToDoc;
        default:
        return(FALSE);
        }
        break;

#if WINVER < 0x300
    /* Don't really need to process this */
    case WM_CLOSE:
        goto BackToDoc;
#endif

#ifndef INEFFLOCKDOWN
    case WM_NCDESTROY:
        FreeProcInstance(lpDialogRunningHead);
        lpDialogRunningHead = NULL;
        /* fall through to return false */
#endif

    default:
        return(FALSE);
    }
    return(TRUE);
}
/* end of DialogRunningHead */




DoFormatRHText( dya, fFirstPage)
int dya;
int fFirstPage;
{   /* Format cp range for running head/foot currently being edited
       to have the passed running head properties */
extern typeCP vcpLimParaCache;

CHAR rgb[4];
int fHeader=wwdCurrentDoc.fEditHeader;

    /* Note that the Min value for the part we were editing has not changed
       as a result of the edit, so no ValidateHeaderFooter is required */
typeCP cpMin=fHeader ? cpMinHeader : cpMinFooter;
int rhc;
struct SEP **hsep = (**hpdocdod)[docCur].hsep;
struct SEP *psep;

 if (!FWriteOk( fwcNil ))
    return;

/* Ensure that this document has a valid section property
descriptor. */
if (hsep == NULL)
    {
    if (FNoHeap(hsep = (struct SEP **)HAllocate(cwSEP)))
    {
    return;
    }
    blt(&vsepNormal, *hsep, cwSEP);
    (**hpdocdod)[docCur].hsep = hsep;
    }
psep = *hsep;

/* Set running head distance from top/bottom; this is a Section
   property.  This assumes the MEMO model: one section */
if (fHeader)
    psep->yaRH1 = dya;
else
    psep->yaRH2 = psep->yaMac - dya;

/* For MEMO, running heads appear on both odd and even pages;
   appearance on first page is optional */
rhc = RHC_fOdd + RHC_fEven;
if (fFirstPage)
    rhc += RHC_fFirst;
if (!fHeader)
    rhc += RHC_fBottom;

/* Set running head PARA properties by adding an appropriate sprm */

    /* Set CpMacCur to include the "hidden" Eol; this will prevent
       AddOneSprm from adding an extraneous EOL */
CachePara( docCur, CpMax( cpMinCur, cpMacCur-1 ) );
Assert( vpapAbs.rhc != 0 );
cpMacCur = CpMax( cpMacCur, vcpLimParaCache );

selCur.cpFirst = cpMinCur;  /* Expand selection to entire area so sprm */
selCur.cpLim = cpMacCur;    /* applies to it all */

rgb [0] = sprmPRhc;
rgb [1] = rhc;
AddOneSprm(rgb, FALSE);

} /* end of DoFormatRHText */




MakeRunningCps( doc, cp, dcp )
int doc;
typeCP  cp;
typeCP  dcp;
{   /* Make the cp range suitable for inclusion in a runninng head or foot.
       This means: (1) Apply a Sprm to the whole thing so it is formatted
       as a running head/foot, (2) Remove any chSects, replacing them
       with Eol's */
 extern struct UAB vuab;
 CHAR   rgb [4];
 int    rhc;
 int    fAdjCpMacCur;
 typeCP cpLimPara;
 typeCP cpT;
 struct SEL selSave;

 if (dcp==cp0 || !FWriteOk( fwcNil ))
    return;

 selSave = selCur;

 /* Scan the cp range, replacing chSects with Eols */

 for ( cpT = cp;
       CachePara( doc, cpT ), (cpLimPara=vcpLimParaCache) <= cp + dcp;
       cpT = cpLimPara )
    {
    typeCP cpLastPara=cpLimPara-1;

    Assert( cpLimPara > cpT );  /* Otherwise we are locked in the loop */

    FetchCp( doc, cpLastPara, 0, fcmChars );
    if (*vpchFetch == chSect)
    {
    struct PAP papT;

    CachePara( doc, cpT );
    papT = vpapAbs;

    Replace( doc, cpLastPara+ccpEol, (typeCP)1, fnNil, fc0, fc0 );
    InsertEolPap( doc, cpLastPara, &papT );

    if (ferror)
        {
        NoUndo();
        break;
        }

        /* Adjust Undo count to account for extra insertion */
    vuab.dcp += (typeCP)(ccpEol-1);
    CachePara( doc, cpT );
    cpLimPara = vcpLimParaCache;
    }
    }

 /* Apply a Sprm that makes everything a running head/foot */

 rhc = RHC_fOdd + RHC_fEven;
 if (wwdCurrentDoc.fEditFooter)
    rhc += RHC_fBottom;

 selCur.cpFirst = cp;            /* OK to just assign to selCur */
 selCur.cpLim   = cp + dcp;      /* because AddOneSprm will handle */

 /* We must temporarily set cpMacCur so that it includes the Eol
    at the end of the header/footer range. Otherwise, AddOneSprm
    may decide it needs to insert a superfluous Eol */

 CachePara( docCur, selCur.cpLim-1 );
 if (fAdjCpMacCur = (vcpLimParaCache > cpMacCur))
    cpMacCur += ccpEol;

 rgb [0] = sprmPRhc;
 rgb [1] = rhc;
 AddOneSprm(rgb, FALSE);    /* Do not set UNDO; we want to undo the paste,
                   which will take care of undoing the sprm */
 if (fAdjCpMacCur)
     cpMacCur -= ccpEol;

 Select( selSave.cpFirst, selCur.cpLim );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\scrollhz.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOICON
#define NOATOM
#define NOFONT
#define NOBRUSH
#define NOCLIPBOARD
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMETAFILE
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSOUND
#define NOWH
#define NOWNDCLASS
#define NOCOMM
#define NOFONT
#define NOBRUSH
#include <windows.h>
#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "dispdefs.h"
#include "fmtdefs.h"

extern long             ropErase;
extern struct WWD       *pwwdCur;
extern struct WWD       rgwwd[];
extern int              wwCur;
extern int              docCur;
extern typeCP           cpMacCur;
extern struct FLI       vfli;

int NEAR    FOnScreenRect(RECT *);


/* P U T  C P  I N  W W  H Z */
PutCpInWwHz(cp)
typeCP cp;
 /* Ensure that cp is in wwCur */
 /* Make sure it's not off to left or right, too. */

    { /* Just check for horizontal bounding; vertical is done
        by call to CpBeginLine below. */
    int dxpRoom, xp, xpMin;
    int dlT;
    typeCP cpBegin;

    UpdateWw(wwCur, false);
    cpBegin = CpBeginLine(&dlT, cp);
    FormatLine(docCur, cpBegin, (**(pwwdCur->hdndl))[dlT].ichCpMin, cpMacCur, flmSandMode);
/* xpMin is a dummy here */
    xp = DxpDiff(0, (int)(cp - vfli.cpMin), &xpMin) + vfli.xpLeft;
    xpMin = pwwdCur->xpMin;
/* we have: xp = desired position, xpMin = amount of horizontal scroll */
/* width of space in window for text */
    dxpRoom = (pwwdCur->xpMac - xpSelBar);
    if (xp < xpMin )
        { /* cp is left of screen */
        AdjWwHoriz(max(0, xp - min(dxpRoom - 1, cxpAuto)) - xpMin);
        }
    else if (xp >= xpMin + dxpRoom)
        { /* cp is right of screen */
        register int dxpRoomT = min(xpRightMax, xp + min(dxpRoom - 1, cxpAuto))
          - dxpRoom + 1;

        AdjWwHoriz(max(0, dxpRoomT) - xpMin);
        }
    }


/* A D J  W W  H O R I Z */
AdjWwHoriz(dxpScroll)
int dxpScroll;
    {
    /* Scroll a window horizontally */
    if (dxpScroll != 0)
        {
        RECT rc;

/* Reset the value of the horizontal scroll bar */
        SetScrollPos( pwwdCur->hHScrBar,
                      pwwdCur->sbHbar,
                      pwwdCur->xpMin + dxpScroll,
                      TRUE);

#ifdef ENABLE   /* HideSel() */
        HideSel();
#endif /* ENABLE */

        ClearInsertLine();

        SetRect( (LPRECT)&rc, xpSelBar, 0, pwwdCur->xpMac, pwwdCur->ypMac );
        ScrollCurWw( &rc, -dxpScroll, 0 );
        TrashWw(wwCur);
        pwwdCur->xpMin += dxpScroll;

        if (pwwdCur->fRuler)
            {
            UpdateRuler();
            }

        }
    }




/* Scroll specified subrectangle of current window by specified amount */
#include <stdlib.h>
ScrollCurWw( prc, dxp, dyp )
register RECT    *prc;
int     dxp,dyp;
{

 extern int vfScrollInval;
 RECT rcClear;
 if (dxp && dyp)
    return; /* Scroll in both dimensions is an illegal case */

 if (!(dxp || dyp))
    return; /* no scrolling to do */

#if 1
    /** 
        The previous old, old code was getting flaky. (7.14.91) v-dougk
     **/
    if (ScrollDC(pwwdCur->hDC,dxp,dyp,(LPRECT)prc,(LPRECT)prc,NULL,&rcClear))
    {
        PatBlt( pwwdCur->hDC, rcClear.left, rcClear.top, 
            rcClear.right-rcClear.left+1, rcClear.bottom-rcClear.top+1, ropErase );

        if (dxp)
            vfScrollInval =  FALSE;
        else 
            vfScrollInval =  (rcClear.bottom-rcClear.top+1) > abs(dyp); 

         if (vfScrollInval)
         {
            InvalidateRect(pwwdCur->wwptr,&rcClear,FALSE);
            UpdateInvalid();  
         }
    }
    else
        vfScrollInval = FALSE;
    return;
#else

 int FCheckPopupRect( HWND, LPRECT );
 extern int vfScrollInval;
 HDC hDC;
 int dxpAbs = (dxp < 0) ? -dxp : dxp;
 int dypAbs = (dyp < 0) ? -dyp : dyp;
 struct RS { int left, top, cxp, cyp; }
                     rsSource, rsDest, rsClear;
 /* Set rsSource, rsDest, rsClear == prc */

 if ((rsSource.cxp = imin( prc->right, pwwdCur->xpMac ) -
                     (rsSource.left = imax( 0, prc->left ))) <= 0)
        /* Rectangle is null or illegal in X-dimension */
    return;
 if ((rsSource.cyp = imin( prc->bottom, pwwdCur->ypMac ) -
                (rsSource.top = imax( pwwdCur->ypMin, prc->top ))) <= 0)
        /* Rectangle is null or illegal in Y-dimension */
    return;
 bltbyte( &rsSource, &rsDest, sizeof (struct RS ));
 bltbyte( &rsSource, &rsClear, sizeof (struct RS ));

 hDC = pwwdCur->hDC;

 if ((dxpAbs < rsSource.cxp) && (dypAbs < rsSource.cyp))
     {  /* A Real scroll, not the bogus case when we just clear exposed area */
        /* NOTE: We do not bother to compute rsSource.cxp or rsSource.cyp,
           as they are not needed by BitBlt or PatBlt */

        /* If there are PopUp windows, use ScrollWindow to avoid getting
           bogus bits from some popup. Since this is slow, only do it if there
           is some popup that overlaps the scroll rect */
     if ( AnyPopup() )
        {
        extern HANDLE hMmwModInstance;
        static FARPROC lpFCheckPopupRect = (FARPROC)NULL;

        /* First time through, inz ptr to thunk */

        if (lpFCheckPopupRect == NULL)
            lpFCheckPopupRect = MakeProcInstance( (FARPROC) FCheckPopupRect,
                                                  hMmwModInstance );
        EnumWindows( lpFCheckPopupRect, (LONG) (LPRECT) prc );
        }

        /* Under windows 2.0, must also check for any part of the scroll
           rectangle being off the screen (not possible in tiling environment).
           If so, use ScrollWindow to avoid getting bogus bits from outside
           the screen. */
     if (!FOnScreenRect( prc ))
        vfScrollInval = TRUE;

     if (vfScrollInval)
         {   /* vfScrollInval also tells UpdateWw that invalid region
                may have changed */

         extern BOOL vfEraseWw;

         ScrollWindow( pwwdCur->wwptr, dxp, dyp, (LPRECT)prc, (LPRECT)prc );
         vfEraseWw = TRUE;
         UpdateInvalid();    /* Marks repaint area as invalid in our
                                structures so we don't think bits grabbed
                                from a popup are valid */
         vfEraseWw = FALSE;
         return;
         }

     if (dxp != 0)
        rsDest.cxp -= (rsClear.cxp = dxpAbs);
     else
            /* dxp==dyp==0 case is caught below */
        rsDest.cyp -= (rsClear.cyp = dypAbs);

     if (dxp < 0)
        {
        rsSource.left += dxpAbs;
        rsClear.left += rsDest.cxp;
        }
     else if (dxp > 0)
        {
        rsDest.left += dxpAbs;
        }
     else if (dyp < 0)
        {
        rsSource.top += dypAbs;
        rsClear.top += rsDest.cyp;
        }
     else if (dyp > 0)
        {
        rsDest.top += dypAbs;
        }
     else
        return;

    BitBlt( hDC,
            rsDest.left, rsDest.top,
            rsDest.cxp,  rsDest.cyp,
            hDC,
            rsSource.left, rsSource.top,
            SRCCOPY );
    }


#ifdef SMFONT
 /* Vertical refresh will be so bindingly fast, that we do not need to erase the
 old text. */
 if (dxp != 0)
    {
    PatBlt(hDC, rsClear.left, rsClear.top, rsClear.cxp, rsClear.cyp, ropErase);
    }
#else /* not SMFONT */
 PatBlt( hDC, rsClear.left, rsClear.top, rsClear.cxp, rsClear.cyp, ropErase );
#endif /* SMFONT */
#endif
}



int FCheckPopupRect( hwnd, lprc )
HWND hwnd;
LPRECT lprc;
{   /* If the passed window is not a popup, return TRUE;
       If the passed window is a popup, and its coordinates overlap
       those of the passed rect, set vfScrollInval to TRUE and return FALSE.
       Otherwise, return TRUE.
       This is a window enumeration function: a return of TRUE means
       continue enumerating windows, a return of FALSE means
       stop the enumeration */

 extern int vfScrollInval;
 RECT rc;
 POINT ptTopLeft, ptBottomRight;
 RECT rcResult;

 if ( !(GetWindowLong( hwnd, GWL_STYLE ) & WS_POPUP) )
        /* Window is not a popup */
    return TRUE;

 /* Get popup rectangle in screen coordinates */

 GetWindowRect( hwnd, (LPRECT) &rc );

 /* Convert rc from screen coordinates to current document window coordinates */

 ptTopLeft.x = rc.left;
 ptTopLeft.y = rc.top;
 ptBottomRight.x = rc.right;
 ptBottomRight.y = rc.bottom;

 ScreenToClient( pwwdCur->wwptr, (LPPOINT) &ptTopLeft );
 ScreenToClient( pwwdCur->wwptr, (LPPOINT) &ptBottomRight );

 rc.left = ptTopLeft.x;
 rc.top = ptTopLeft.y;
 rc.right = ptBottomRight.x;
 rc.bottom = ptBottomRight.y;

 IntersectRect( (LPRECT) &rcResult, (LPRECT) &rc, (LPRECT)lprc );
 if ( !IsRectEmpty( (LPRECT) &rcResult ) )
    {   /* Popup overlaps passed rectangle */
    vfScrollInval = TRUE;
    return FALSE;
    }

 return TRUE;
}




/* S C R O L L  L E F T */
ScrollLeft(dxp)
int dxp;
        { /* Scroll current window left dxp pixels */
        if ((dxp = min(xpRightLim - pwwdCur->xpMin, dxp)) >0)
                AdjWwHoriz(dxp);
        else
                _beep();
        }


/* S C R O L L  R I G H T */
ScrollRight(dxp)
int dxp;
        {
        if ((dxp = min(pwwdCur->xpMin, dxp)) > 0)
                AdjWwHoriz(-dxp);
        else
                _beep();
        }






/* F O N S C R E E N R E C T

    Returns TRUE iff the rectangle is entirely within the screen
    boundaries.
    Assumes the rectangle belongs to the current window.

 */

int NEAR
FOnScreenRect(prc)
register RECT *prc;
{

    POINT ptTopLeft, ptBottomRight;
    int cxScreen = GetSystemMetrics( SM_CXSCREEN );
    int cyScreen = GetSystemMetrics( SM_CYSCREEN );

    ptTopLeft.x = prc->left;
    ptTopLeft.y = prc->top;
    ptBottomRight.x = prc->right;
    ptBottomRight.y = prc->bottom;

    ClientToScreen( pwwdCur->wwptr, (LPPOINT) &ptTopLeft );
    ClientToScreen( pwwdCur->wwptr, (LPPOINT) &ptBottomRight );

    if ((ptTopLeft.x <= 0) || (ptTopLeft.y <= 0) ||
        (ptBottomRight.x >= cxScreen) || (ptBottomRight.y >= cyScreen))
        return FALSE;

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\scrollvt.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOWNDCLASS
#define NOICON
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOBITMAP
#define NOBRUSH
#define NOCOLOR
#define NODRAWTEXT
#define NOMB
#define NOPOINT
#define NOMSG
#include <windows.h>
#include "mw.h"
#include "docdefs.h"
#include "dispdefs.h"
#include "fmtdefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "propdefs.h"

/* Globals used here only */
struct TR  {       /* Text Row info for CtrBackDyp Cache */
        typeCP cp;
        int dcpDepend;  /* dcpDepend for PREVIOUS edl */
        int ichCp;
        int dyp;
        };
struct TR rgtrCache[ itrMaxCache ];
int wwCache=wwNil;


extern struct PAP       vpapAbs;
extern typeCP           vcpFirstParaCache;
extern struct WWD       *pwwdCur;
extern struct SEL       selCur;
extern int              docCur;
extern typeCP           cpCacheHint;
extern typeCP           cpMinCur;
extern typeCP           cpMacCur;
extern struct FLI       vfli;
extern int              wwCur;
extern int              ctrCache;
extern int              itrFirstCache;
extern int              itrLimCache;
extern int              vfOutOfMemory;




/* P U T  C P  I N  W W  V E R T*/
PutCpInWwVert(cp)
typeCP cp;

    {
/* vertical case */
    typeCP cpMac;
    struct EDL (**hdndl) [] = pwwdCur->hdndl;
    int dlMac=pwwdCur->dlMac;
    struct EDL *pedl = &(**hdndl) [dlMac - 1];
    struct EDL *pedlFirst = &(**hdndl) [0];

    if ((pedl->yp > pwwdCur->ypMac) && (pedl > pedlFirst))
            /* Partial line at the bottom of the window -- this doesn't count
               unless it's all we've got */
        {  pedl--;  dlMac--;  }
    if (cp < pwwdCur->cpFirst ||
        cp > (cpMac = pedl->cpMin + pedl->dcpMac) ||
        (cp == cpMac && !pedl->fIchCpIncr) ||
            /* Covers insertion points before pictures reached via curs keys */
        (CachePara( docCur, cp ),
             (vpapAbs.fGraphics &&
              (selCur.cpFirst == selCur.cpLim) &&
              (pedlFirst->cpMin == selCur.cpFirst) &&
              (pedlFirst->ichCpMin > 0))))
        {
        DirtyCache(pwwdCur->cpFirst = cp);
        pwwdCur->ichCpFirst = 0;
        CtrBackDypCtr( 9999, dlMac >> 1 );
        }
    }




SetCurWwVScrollPos( )
{
 typeCP cp;
 int dr;
 struct EDL (**hdndl)[] = pwwdCur->hdndl;

/* calculate desired elevator position dr */

 if ((cp = pwwdCur->cpMac - pwwdCur->cpMin) == (typeCP) 0)
    dr = 0;
 else
    {
    typeCP CpWinGraphic();
    typeCP cpWinFirst = ((**hdndl) [0].fGraphics && !pwwdCur->fDirty) ?
                            CpWinGraphic( pwwdCur ) : pwwdCur->cpFirst;

    dr = min(drMax - 1,
          (int)(((cpWinFirst - pwwdCur->cpMin) * (drMax - 1) + (cp >> 1)) / cp));
    }

/* Contemplating this 'if' statement should elevate one to a higher plane
of existence. */
 if (dr != pwwdCur->drElevator)
            /* reset the value of the vertical scroll bar */
    SetScrollPos( pwwdCur->hVScrBar,
                  pwwdCur->sbVbar,
                  pwwdCur->drElevator = dr,
                  TRUE);
}




/* A D J  W W  V E R T */
/* Scroll a window down vertically so that UpdateWw can re-use the text
that is still visible. Otherwise, UpdateWw would write over the very
lines it will need later on near the bottom of the window.
*/
AdjWwVert(cdl, dyp)
int cdl;
{
#if defined(JAPAN) & defined(DBCS_IME)
extern	void	IMEManage( );
#endif
        struct EDL *pedl;
        int dl;

        if (cdl == 0) return;

        cdl = umin( cdl, pwwdCur->dlMac ); /* ! don't let it run off the end */

        Assert( dyp > 0 );

        ClearInsertLine();
        DypScroll(wwCur, 0, cdl, pwwdCur->ypMin + dyp);
/* invalidate the first cdl dl's */
        pedl = &(**(pwwdCur->hdndl))[0];
        for (dl = 0; dl < cdl; dl++)
                (pedl++)->fValid = FALSE;
        pwwdCur->fDirty = fTrue;
#if defined(JAPAN) & defined(DBCS_IME)
	IMEManage( FALSE );
#endif
}




ScrollDownCtr(ddr)
int ddr;
{ /* Scroll down in the document by ddr text lines (but < 1 screenful) */
        struct EDL *pedl;

        UpdateWw(wwCur, FALSE); /* Dl's must be correct */

        ddr = min(ddr, max(1, pwwdCur->dlMac - 1));

        pedl = &(**(pwwdCur->hdndl))[ddr - 1]; /* pedl is first line above new screen */
        while (ddr > 0 && pedl->cpMin + pedl->dcpMac > cpMacCur)
                { /* Don't scroll the endmark off the screen */
                --pedl;
                --ddr;
                }

        /* Change the cpFirst of the window and dirty it */
        if (ddr > 0)
                {
                struct TR tr;
                int dcpDepend;

                if (wwCur != wwCache)
                    {   /* If window has changed, invalidate cache here
                           so cp's cached below will be used */
                    TrashCacheS();
                    wwCache = wwCur;
                    }

                HideSel(); /* Don't scroll selection if machine can't handle it */
                ClearInsertLine();

                pwwdCur->cpFirst = pedl->cpMin + pedl->dcpMac;
                pwwdCur->ichCpFirst = pedl->fIchCpIncr ? pedl->ichCpMin + 1 : 0;
                pwwdCur->dcpDepend = pedl->dcpDepend; /* Remember hot spot */

                /* Make tr cache entries for the disappearing lines */
                pedl = &(**(pwwdCur->hdndl))[0];
                if (ctrCache == 0) /* We don't have top line yet */
                    {
                    tr.cp =    pedl->cpMin;
                    tr.ichCp = pedl->ichCpMin;
                    tr.dyp =   pedl->dyp;
                    tr.dcpDepend = pwwdCur->dcpDepend;
                    AppendCachePtr( &tr );
                    }

                while ( ddr-- )
                    {
                    tr.cp = pedl->cpMin + pedl->dcpMac;
                    tr.ichCp = pedl->fIchCpIncr ? pedl->ichCpMin + 1 : 0;
                    tr.dcpDepend = pedl->dcpDepend;
                    tr.dyp = (++pedl)->dyp;
                    AppendCachePtr( &tr );
                    }

                pwwdCur->fDirty = true;
                SetCurWwVScrollPos();
                CheckMode();
                }
        else
                {
                _beep();
                }
}




ScrollUpDypWw()
{   /* Scroll up in the document by one screenfull less 1 line */
int dypKeep=8;
struct EDL *pedl = &(**pwwdCur->hdndl) [0];

if (pedl->fValid)
    {
    dypKeep = pedl->dyp;
    }

if (CtrBackDypCtr( pwwdCur->ypMac - pwwdCur->ypMin - dypKeep,9999 ) == 0)
    {
    _beep();
    }
else
    CheckMode();
}



ScrollUpCtr( ctr )
int ctr;
{   /* Scroll Up ctr text rows in the doc (scroll window down) */
 if (CtrBackDypCtr( 9999, ctr ) == 0)
    {
    _beep();
    }
 else
    CheckMode();
}




int CtrBackDypCtr( dypLim, ctrLim )
int dypLim;
int ctrLim;
{   /* Set pwwdCur->cpFirst to the cpFirst of the text line
       dypLim pixels or ctrLim text rows before the value of
       pwwdCur->cpFirst, whichever limit is reached first.
       Adjust the position of the vert scroll bar according to the new cpFirst.
       Return the number of text rows (tr) we went back. */

 int fAdj = ( (pwwdCur->cpFirst == (**(pwwdCur->hdndl))[0].cpMin) ||
              !(**(pwwdCur->hdndl))[0].fValid );
 typeCP cpFirst = pwwdCur->cpFirst;
 int    ichCpFirst = pwwdCur->ichCpFirst;
 int    ctrGrant = 0;      /* ctr we've backed over so far */
 int    dypGrant = 0;      /* dyp we've backed over so far */
 int    ichFake = 0;

 pwwdCur->fCpBad = false;        /* Reset hot spot warning */
 pwwdCur->fDirty = true;

/* Cache is only valid for one ww -- invalidate if ww has changed */
 if (wwCur != wwCache)
    {
    TrashCacheS();
    wwCache = wwCur;
    }

 if (ctrCache == 0)
        /* Don't have cache entry for first line in Ww -- force formatting
           THROUGH first line of Ww instead of TO it. */
    ++ichFake;

 for ( ;; )
    {
    /* If there is no info in the cache, must replenish it. */

    if (ctrCache <= 1) /* <=: also replenish if 1st line of Ww is only entry */
        {
        typeCP cpStart;         /* cp to start formatting from */
        int    dcpDepend;       /* Dependency of line containing cpStart */
        typeCP cp;
        int    ichCp;
        int    itrTempCacheLim = 0;
        struct TR rgtrTempCache[ itrMaxCache ];
        int    fTempCacheOverflow = false;

        if ((cpFirst <= cpMinCur) && (ichCpFirst == 0))
            {      /* Reached top of document */
            if (fAdj)
                AdjWwVert( ctrGrant, dypGrant );
            pwwdCur->cpFirst = cpMinCur;
            pwwdCur->ichCpFirst = 0;
            pwwdCur->dcpDepend = 0;
            goto SetScroll;
            }

        /* Want to go back BEFORE the earliest point we have in the cache */

        if (ichFake > 0)
                /* Force formatting THROUGH { cpFirst, ichCpFirst }
                   instead of TO */
            --ichFake;
        else if (ichCpFirst > 0)
            --ichCpFirst;
        else
            --cpFirst;

        cpStart = CpHintCache( cpFirst );
        if ( ( CachePara( docCur, cpFirst ), vcpFirstParaCache ) >= cpStart )
            {
            cpStart = vcpFirstParaCache;
            dcpDepend = 0;  /* At para start; we know dependency is 0 */
            }
        else
            dcpDepend = cpMaxTl;    /* real value unknown; use max */

        /* Add TR info for lines from { cpStart, 0 } THROUGH
           { cpFirst, ichCpFirst } to temporary cache */

        for ( cp = cpStart, ichCp = 0;
              (cp < cpFirst) || ((cp == cpFirst) && (ichCp <= ichCpFirst)); )
            {
            struct TR *ptr;

            if (itrTempCacheLim == itrMaxCache)
                {   /* Overflowed the temp cache */
                fTempCacheOverflow = fTrue;
                itrTempCacheLim = 0;
                }

            /* Add one tr to the cache */

            FormatLine( docCur, cp, ichCp, cpMacCur, flmSandMode );
            if (vfOutOfMemory)
                return ctrGrant;
            ptr = &rgtrTempCache[ itrTempCacheLim++ ];
            ptr->cp = cp;
            ptr->ichCp = ichCp;
            ptr->dyp = vfli.dypLine;
            ptr->dcpDepend = dcpDepend; /* Save dcpDepend for prev line */
            dcpDepend = vfli.dcpDepend;

            /* Continue with next line */

            cp = vfli.cpMac;
            ichCp = vfli.ichCpMac;
            }   /* end for */

        /* Add our temporary cache in front of the real one */
        PrependCacheRgtr( rgtrTempCache, itrTempCacheLim );
        if (fTempCacheOverflow)
                /* We wrapped around the end of the temp cache; include the
                   rest of the circle */
            PrependCacheRgtr( &rgtrTempCache[ itrTempCacheLim ],
                              itrMaxCache - itrTempCacheLim );
        }   /* end for */

    /* Walk backward in the cache, eliminating entries,
       until: (1) We have run through enough yp's or tr's  (return) OR
              (2) We have exhausted the cache (loop back to refill it)
       NOTE: Case 2 catches the case when we hit the beginning of the doc */

    Assert( ctrCache >= 1 );
    Assert( itrLimCache > 0 );
    for ( ;; )
        {
        struct TR *ptr = &rgtrCache[ itrLimCache - 1 ];

        if (ctrCache == 1)
            {   /* Only one thing left in cache: the 1st line of the Ww */
            cpFirst = ptr->cp;
            ichCpFirst = ptr->ichCp;
            break;  /* Exhausted cache; loop back to refill it */
            }

        if ( (dypGrant >= dypLim) || (ctrGrant >= ctrLim) )
            {   /* Passed through enough yp's or tr's -- we're done */
            if (fAdj)
                AdjWwVert( ctrGrant, dypGrant );
            pwwdCur->cpFirst = ptr->cp;
            pwwdCur->ichCpFirst = ptr->ichCp;
            pwwdCur->dcpDepend = ptr->dcpDepend;
            goto SetScroll;
            }

            /* Remove end entry from the cache */
        if (--itrLimCache <= 0)
            itrLimCache = itrMaxCache;
        ctrCache--;

        /* Update ctrGrant, dypGrant -- we've granted 1 line of scrollback */

        ctrGrant++;
        dypGrant += rgtrCache [itrLimCache - 1].dyp;
        }   /* end for */

    Assert( ctrCache == 1 );
    }   /* end for */

SetScroll:  /* All done; set vert scroll bar according to new cpFirstWw */
 SetCurWwVScrollPos();
 return ctrGrant;
}




/* A P P E N D  C A C H E  P T R */
AppendCachePtr( ptr )
struct TR *ptr;
{   /* Say we are scrolling up a line, append *ptr to tr cache */

        if (++ctrCache > itrMaxCache)
                { /* Have to push one off the top */
                if (++itrFirstCache == itrMaxCache)
                        itrFirstCache = 0;
                --ctrCache;
                }
        /* Now add one onto the end */
        if (itrLimCache++ == itrMaxCache)
                itrLimCache = 1;
        rgtrCache[ itrLimCache - 1 ] = *ptr;
}




/* P R E P E N D  C A C H E  R G T R */
PrependCacheRgtr( rgtr, ctr )
struct TR rgtr[];
int ctr;
{ /* PREPEND one or more lines JUST BEFORE the ones in the cache */
  /* The tr cache is a ring buffer. rgtrCache[ itrLimCache - 1 ] is the
     tr entry describing the cpFirst of wwCur; rgtrCache[ itrFirstCache ]
     is the tr for the earliest line we know of.  All between are
     contiguous.  ctrCache is the number of tr's we have cached. */

 struct TR *ptr = &rgtr[ ctr ];

 ctrCache += (ctr = min(ctr, itrMaxCache - ctrCache));

    /* Compensate for state introduced by TrashCache -- itrLimCache == 0 */
 if (itrLimCache == 0)
    itrLimCache = itrMaxCache;

 while (ctr-- != 0)
    {   /* Now add each tr */
    if (itrFirstCache-- == 0)
        itrFirstCache = itrMaxCache - 1;
    rgtrCache[ itrFirstCache ] = *(--ptr);
    }
}




/* T R A S H  C A C H E s */
TrashCacheS()
{ /* Invalidate scrolling cache */
        ctrCache = 0;
        cpCacheHint = cp0;
        itrFirstCache = itrLimCache = 0;
}





/* C P  H I N T  C A C H E */
typeCP CpHintCache(cp)
typeCP cp;
{ /* Give the latest cp <= arg cp that begins a line */
 return (cpCacheHint <= cp) ? cpCacheHint : cpMinCur;
}




DirtyCache(cp)
typeCP cp;
{ /* Invalidate cache beyond cp */
        while (ctrCache-- > 1)
                {
                typeCP cpT = rgtrCache[itrLimCache - 1].cp;
                if (--itrLimCache == 0)
                        itrLimCache = itrMaxCache;
                if (cpT < cp)
                        { /* Found our hint; dirty one extra line for word wrap */
                        cpCacheHint = rgtrCache [itrLimCache - 1].cp;
                        itrLimCache = itrFirstCache;
                        ctrCache = 0;
                        return;
                        }
                }

        TrashCacheS();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\scrndefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains definitions for screen dependent positions in twips which
will be converted to pixels later. */

#define cch12pt		80	/* number of "12 pt" chars across the screen */
#define cxa12pt		144	/* width of a 12 pt fixed font in twips */
#define cya12pt		240	/* height of a 12 pt fixed font in twips */

/* size of lines for dnMax estimation purposes */
#define dyaAveInit	240

/* width of the selection bar area to the left of lines */
#define xaSelBar	288

#define dxaScrlBar	270
#define dyaScrlBar	300

#define xaMinScroll	180

/* these define the initial window size and amount of white space above
the first line */
#define yaMaxWwInit	5580

/* should be > than largest window height + height of blank line after
the endmark */
#define yaMaxAll	20000	/* used for invalidation */
#define dyaWwInit	60

#define dyaBand		320	/* formerly dpxyLineSizeMin */

/* height of left portion of a split line */
#define dyaSplitLine	60

#define yaSubSuper	60

#define dxaInfoSize	1800

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\search.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* search.c    Search/Replace    */
/*              Brodie Nov 25 83 */
/*              Lipkie Nov 15 83 */
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCOMM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOFONT

#ifndef JAPAN
#define NOGDI
#endif

#define NOGDICAPMASKS
#define NOHDC
#define NOICON
#define NOKEYSTATE
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOOPENFILE
#define NOPEN
#define NORASTEROPS
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOSHOWWINDOW
#define NOSOUND
#define NOSYSCOMMANDS
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOWINSTYLES
#define NOWNDCLASS
#include <windows.h>

#define NOIDISAVEPRINT
#include "mw.h"
#include "dlgdefs.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "str.h"
#define NOKCCODES
#include "ch.h"
#include "editdefs.h"
#include "propdefs.h"
#include "filedefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "fkpdefs.h"
#include "fmtdefs.h"

#if defined(JAPAN) || defined(KOREA) //T-HIROYN Win3.1
#include "kanji.h"
extern int             vcchFetch;
#endif


#ifdef INEFFLOCKDOWN
extern FARPROC lpDialogFind;
extern FARPROC lpDialogChange;
#else
FARPROC lpDialogFind = NULL;
FARPROC lpDialogChange = NULL;
BOOL far PASCAL DialogFind(HWND, unsigned, WORD, LONG);
BOOL far PASCAL DialogChange(HWND, unsigned, WORD, LONG);
#endif

extern HANDLE hMmwModInstance;
extern HWND   vhDlgFind;
extern HWND   vhDlgChange;
extern HANDLE hParentWw;        /* Handle to the parent window */
extern int vfCursorVisible;
extern int vfOutOfMemory;
extern struct WWD rgwwd[];
extern int       wwMac;
#ifdef ENABLE /* no pDialogCur and ActiveWindow */
extern WINDOWPTR windowSearch;
extern WINDOWPTR windowRep;
extern WINDOWPTR pDialogCur;
extern WINDOWPTR ActiveWindow;
extern int       cxEditScroll;/* not sure how cxEditScroll is used */
extern struct SEL      selSearch;
#endif
extern struct FKPD      vfkpdParaIns;
extern struct PAP       *vppapNormal;
extern typeFC           fcMacPapIns;
extern int              wwCur;
extern struct  WWD      *pwwdCur;
extern struct  CHP      vchpInsert;
extern struct  PAP      vpapPrevIns;
extern int              vfSelecting;
extern typeCP           cpMacCur;
extern typeCP           cpMinCur;
extern int              vfSeeSel;
extern int              vfSeeEdgeSel;
extern int              docCur;
extern struct SEL       selCur;
extern typeCP           vcpFetch;
extern int              vccpFetch;
extern CHAR             *vpchFetch;
extern struct UAB       vuab;
extern int              vfSysFull;
extern struct PAP       vpapAbs;
extern struct CHP       vchpFetch;
extern int              ferror;
extern typeCP           cpWall;
/* Globals used to store settings of flags.  Used to propose responses. */
extern BOOL fParaReplace /* = false initially */;
extern BOOL fReplConfirm /* = TRUE initially */;
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
extern BOOL fSearchDist  /* = true initially */;
#endif
extern BOOL fSearchWord /* = false initially */;
extern BOOL fSearchCase /* = false initially */;
extern BOOL fSpecialMatch;
extern BOOL fMatchedWhite /* = false initially */;
extern CHAR (**hszSearch)[];    /* Default search string */
extern CHAR (**hszReplace)[];    /* Default replace string */
extern CHAR (**hszFlatSearch)[]; /* All lower case version of search string */
extern CHAR (**hszRealReplace)[]; /* used for building replacement text */
extern CHAR (**hszCaseReplace)[]; /* used for building replacement text with
                                appropriate capitalization. */
extern typeCP    cpMatchLim;
extern int       vfDidSearch;
extern CHAR      *szSearch;
extern CHAR      (**HszCreate())[];
extern HWND      vhWndMsgBoxParent;
extern HCURSOR   vhcIBeam;
extern HCURSOR   vhcArrow;
#ifdef INTL
extern CHAR  szAppName[];
extern CHAR  szSepName[];
#endif
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
char    DistSearchString[513];
#endif


NEAR DoSearch(void);
NEAR DoReplace(int, int);
typeCP NEAR CpSearchSz(typeCP, typeCP, CHAR *);
NEAR FMakeFlat(int);
NEAR SetSpecialMatch(void);
NEAR FSetParaReplace(int);
NEAR WCaseCp(typeCP, typeCP);
NEAR SetChangeString(HANDLE, int);
NEAR PutCpInWwVertSrch(typeCP);
#ifndef NOLA
BOOL (NEAR FAbort(void));
#endif
BOOL (NEAR FWordCp(typeCP, typeCP));
BOOL (NEAR FChMatch(int, int *, BOOL));
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
BOOL (NEAR J_FChMatch(CHAR, CHAR, int *,int *));
#endif
NEAR InsertPapsForReplace(typeFC);
NEAR DestroyModeless(HWND *);
NEAR FDlgSzTooLong(HWND, int, CHAR *, int);
NEAR idiMsgResponse(HWND, int, int);

BOOL CheckEnableButton(HANDLE, HANDLE);

BOOL bInSearchReplace = FALSE;  // avoid close when we are searching!


#define CmdReplace(fThenFind)   bInSearchReplace = TRUE; \
                DoReplace(false, fThenFind); \
                bInSearchReplace = FALSE

#define CmdReplaceAll()     bInSearchReplace = TRUE; \
                DoReplace(true, false);  \
                bInSearchReplace = FALSE
#ifndef NOLA
static int fAbortSearch = FALSE;
#endif
static int      fChangeSel;
static int      fSelSave = FALSE;
static struct SEL selSave;

#ifdef DBCS
/* Additional variables to handle white-space matching
   for the DBCS space. */

static int      cbLastMatch;

/* Since CpFirstSty(, styChar) calls on FetchCp(), any assumption
   made about the validity of global variables set by FetchCp()
   is no longer valid.  We explicitly save those variables after
   each FetchCp and use those instead. (Used in CpSearchSz().)*/
static typeCP   cpFetchSave;
static int      ccpFetchSave;
static CHAR    *pchFetchSave;

/* Also, we move some of the local variables out from
   CpSearchSz() so that they can be changed by FChMatch(). */
/*
int             ichDoc;
int             cchMatched;
typeCP          cpFetchNext;
*/
#endif


NEAR DoSearch()
{
int cch;
typeCP cpSearch;
typeCP cpSearchLim;
typeCP cpSearchNext;
typeCP cpWallActual;
typeCP cpMatchFirst;
typeCP CpMin();
int     idpmt;
int     fDidSearch;

if (docCur == docNil)
        return;
cch = CchSz(**hszSearch)-1;
if(cch == 0)
    {
    /* this should only occur if the user execute Repeat last find without having
        previously defined a search string. */
    Error(IDPMTNotFound);
    return;
    }

SetSpecialMatch();
if(!FMakeFlat(cch))
    return;

#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
if(!fSpecialMatch && !fSearchDist)
{
    myHantoZen(**hszFlatSearch,DistSearchString,513);
    cch = CchSz(DistSearchString)-1;
}
#endif
fDidSearch = vfDidSearch;
cpWallActual = fDidSearch ? CpMin(cpWall, cpMacCur) : cpMacCur;
cpSearchNext = fDidSearch ? selCur.cpLim : selCur.cpFirst;
cpSearchLim = (cpSearchNext <= cpWallActual) ? cpWallActual : cpMacCur;

    {
    do
        {
ContinueSearch:
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
        if(!fSpecialMatch && !fSearchDist)
            cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,DistSearchString);
        else
            cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,**hszFlatSearch);
#else
        cpSearch=CpSearchSz(cpSearchNext,cpSearchLim,**hszFlatSearch);
#endif
        if (cpSearch == cpNil)
                {
#ifndef NOLA
                if (fAbortSearch)
                    {
                    Error(IDPMTCancelSearch);
                    fAbortSearch = FALSE;
                    vfDidSearch = FALSE;
                    FreeH(hszFlatSearch);
                    return;
                    }
#endif
                if (cpSearchLim == cpWall && fDidSearch)

                        {
SearchFail:             Error(vfDidSearch ? IDPMTSearchDone :
                                                                IDPMTNotFound);
                        if (vfDidSearch)  /* did we previously have a match?*/
                                { /* Yes, do setup for next pass */

                                /* clear flag so we can search some more */
                                vfDidSearch = false;
                                /* set "Wall" to immediately after last match */
                                cpWall = selCur.cpLim;
                                /* ask that selection be displayed */
                                vfSeeSel = vfSeeEdgeSel = TRUE;
                                }

                        FreeH(hszFlatSearch);
                        return;
                        }
                else
                        {
                        cpSearchNext = cpMinCur;
                        cpSearchLim = cpWall;
                        fDidSearch = true;
                        goto ContinueSearch;
                        }
                }
#ifdef  DBCS        /* was in JAPAN */
        cpSearchNext = CpLastStyChar( cpSearch ) + 1;
#else
        cpSearchNext = CpLastStyChar( cpSearch + 1 );
#endif
        }
/*---    while (fSearchWord && !FWordCp(cpSearch, cpMatchLim-cpSearch));--*/
    while (!FCpValid(cpSearch, cpMatchLim - cpSearch));
    }

if (!vfDidSearch)
        {
        cpWall = cpSearch;
        vfDidSearch = true;
        }

/*Select( CpFirstSty( cpSearch, styChar ), CpLastStyChar( cpMatchLim ) );*/
if ( (cpMatchFirst = CpFirstSty( cpSearch, styChar )) != cpMatchLim )
    Select( cpMatchFirst, cpMatchLim );
PutCpInWwVertSrch(selCur.cpFirst);
vfSeeSel = vfSeeEdgeSel = TRUE;
FreeH(hszFlatSearch);
}


NEAR DoReplace(fReplaceAll, fThenFind)
int     fReplaceAll;
int     fThenFind;
{
/* Replace now works as follows:
        if the current selection is the search text, then replace it with
        the replace text and jump to the next occurrence of the search text.
        Otherwise, just jump to the next occurrence of the search text.
        If fReplaceAll is true, then repeat this operation until the end
        of the document. */
int cch;
typeCP cpSearchStart;
typeCP cpSearch;
typeCP cpSearchNext;
typeCP cpSearchLim;
typeCP cpSearchNow;
typeCP cpSearchLimNow;
typeCP dcp;
BOOL f1CharSel;
BOOL fFirstTime;
int ich;
int cchReplace;
int cwReplace;
int iCurCase;
int iLastCase;
typeFC fcCaseSz;
typeCP cpMacTextT;
typeCP cpWallActual;
int     fDidSearch = vfDidSearch;
struct CHP chp;
typeCP cpMacSave;

iLastCase = -1;  /* indicate that the string pointed to by hszCaseReplace
                    has not been given a value yet. */

if (!FWriteOk(fwcNil) || docCur == docNil)
        /* Out of memory, read only document, etc */
    return;

cch = CchSz(**hszSearch)-1;
if(cch == 0)
    {
    Error(IDPMTNotFound);
    return;
    }

SetSpecialMatch();

if(!FMakeFlat(cch))
    return;

#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
if(!fSpecialMatch && !fSearchDist)
{
    myHantoZen(**hszFlatSearch,DistSearchString,513);
    cch = CchSz(DistSearchString)-1;
}
#endif
cwReplace = CwFromCch(cchReplace = CchSz(**hszReplace));
if(FNoHeap(hszRealReplace = (CHAR (**) [])HAllocate(cwReplace)))
    {
    FreeH(hszFlatSearch);
    return;
    }
bltbyte(**hszReplace, **hszRealReplace, cchReplace);

if(FNoHeap(hszCaseReplace = (CHAR (**) [])HAllocate(cwReplace)))
    {
    FreeH(hszFlatSearch);
    FreeH(hszRealReplace);
    return;
    }

if(!FSetParaReplace(cchReplace))
    {
    FreeH(hszFlatSearch);
    FreeH(hszCaseReplace);
    FreeH(hszRealReplace);
    return;
    }

cch = CchSz(**hszRealReplace)-1;
fFirstTime = TRUE;
cpWallActual = fDidSearch ? CpMin(cpWall, cpMacCur) : cpMacCur;

cpSearchNow = cpSearchStart = selCur.cpFirst;
if (fReplaceAll || !fThenFind)
        cpSearchLim = selCur.cpLim;
else
        cpSearchLim = (cpSearchStart < cpWallActual) ? cpWallActual : cpMacCur;
cpSearchLimNow = selCur.cpLim;

if (fReplaceAll)
        {
        cpWallActual = cpSearchLim;
        fDidSearch = true;
        }

NoUndo();   /* Prevent the SetUndo from getting merged with adjacent stuff */
cpMacTextT = CpMacText(docCur);
if(cpSearchLimNow > cpMacTextT)
        SetUndo(uacDelNS, docCur, cp0, cpMacTextT, docNil, cpNil, cp0, 0);
else
        SetUndo(uacDelNS, docCur, cpSearchStart, cpSearchLimNow - cpSearchStart,
                                        docNil, cpNil, cp0, 0);

if (ferror) goto MemoryError;
cpSearchNext = cpSearchStart;
    {
    do
        {
/*      ForcePmt(IDPMTSearching);*/
        do
            {
ContinueSearch:
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
            if(!fSpecialMatch && !fSearchDist)
                cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,DistSearchString);
            else
                cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,**hszFlatSearch);
#else
            cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,**hszFlatSearch);
#endif
            if (cpSearch == cpNil)
                if ((cpSearchLim == cpWallActual && fDidSearch) || fAbortSearch)

DoneReplacingN:
                        {
DoneReplacingP:
                        FreeH(hszFlatSearch);
                        FreeH(hszCaseReplace);
                        FreeH(hszRealReplace);
                        cpMacTextT = CpMacText(docCur);
                        if (fReplaceAll || fFirstTime)
                                {
                                if(cpSearchLimNow > cpMacTextT)
                                        SetUndo(uacInsert,docCur,cp0,
                                                cpMacTextT,docNil,cpNil,cp0,0);
                                else
                                        SetUndo(uacInsert,docCur,cpSearchStart,
                                                cpSearchLimNow - cpSearchStart,
                                                docNil,cpNil,cp0,0);
                                if (ferror) goto MemoryError;
                                vuab.uac = uacReplGlobal;
                                SetUndoMenuStr(IDSTRUndoBase);
                                /*Select( CpFirstSty( cpSearchStart, styChar ),
                                        CpLastStyChar( cpSearchLimNow ) );*/
                                Select( CpFirstSty( cpSearchStart, styChar ),
                                  (fReplaceAll ? cpSearchStart : cpSearchLimNow) );
                                vfSeeSel = fReplaceAll;
                                if (fReplaceAll)
                                    { /* reestablish the search after a changeall in case of a F3 next time */
                                    vfDidSearch = false;
                                    cpWall = selCur.cpLim;
                                    }
                                }
                        else if (!fReplaceAll)
                                {
                                if (cpSearch == cpNil)
                                    /*Select( CpFirstSty( cpSearchStart, styChar ),
                                            CpLastStyChar( cpSearchLimNow ) );*/
                                    Select( CpFirstSty( cpSearchStart, styChar ),
                                            cpSearchLimNow );
                                else if (!fFirstTime)
                                    /*Select( CpFirstSty( cpSearch, styChar ),
                                            CpLastStyChar( cpMatchLim ) );*/
                                    Select( CpFirstSty( cpSearch, styChar ),
                                            cpMatchLim );
                                PutCpInWwVertSrch(selCur.cpFirst);
                                vfSeeSel = vfSeeEdgeSel = TRUE;
                                }

                        if (fAbortSearch)
                            {
                            fAbortSearch = FALSE;
                            Error(IDPMTCancelSearch);
                            }
                        else if (fFirstTime)
                            Error(fReplaceAll ? IDPMTNoReplace : (vfDidSearch ? IDPMTSearchDone : IDPMTNotFound));
                        return;
                        }
                else
                        {
                        cpSearchNext = cpMinCur;
                        cpSearchLim = cpWallActual;
                        fDidSearch = true;
                        goto ContinueSearch;
                        }
#ifdef  DBCS        /* was in JAPAN */
            cpSearchNext = CpLastStyChar( cpSearch ) + 1;
#else
            cpSearchNext = CpLastStyChar( cpSearch + 1 );
#endif
            }
/*      while(fSearchWord && !FWordCp(cpSearch,cpMatchLim - cpSearch));*/
        while(!FCpValid(cpSearch, cpMatchLim - cpSearch));

        if (!fReplaceAll && (cpSearch != cpSearchNow || cpMatchLim != cpSearchLimNow))
                {
                if (fThenFind)
                        { /* Get here if: Did a Change, then Find. Could not
                                do the change, but did find a next occurence */
                        cpSearchNow = cpSearchNext = cpSearchStart = cpSearch;
                        cpSearchLimNow = cpMatchLim;
                        fFirstTime = false;     /* suppress error message */
                        SetUndo(uacInsert, docCur, cpSearchStart,
                         cpSearchLimNow - cpSearchStart, docNil, cpNil, cp0, 0);
                        if (ferror) goto MemoryError;
                        if (!vfDidSearch)
                                {
                                cpWall = cpSearch;
                                vfDidSearch = true;
                                }
/*----                  continue;----*/
                        goto DoneReplacingN;
                        }
                fFirstTime = true; /* Cause error message */
                cpSearchStart = cpSearchNow;
                cpSearchLim = cpSearchLimNow;
                goto DoneReplacingN;
                }

/*----- vfDidSearch = true;----*/

#ifdef FOOTNOTES
        if(FEditFtn(cpSearch, cpMatchLim))
            {
            ferror = false; /* Reset error condition so that we don't
                                deallocate strings twice (KJS) */
            continue;
            }
#endif

        fFirstTime = FALSE;
        if (vfOutOfMemory || vfSysFull)
            { /* Out of memory (heap or disk) */
            Error(IDPMTNoMemory);
            FreeH(hszFlatSearch);
            FreeH(hszRealReplace);
            FreeH(hszCaseReplace);
            cpMacTextT = CpMacText(docCur);
            if(cpSearchLim > cpMacTextT)
                SetUndo(uacInsert,docCur,cp0,cpMacTextT,docNil,cpNil,cp0,0);
            else
                SetUndo(uacInsert,docCur,cpSearchStart,
                        cpSearchLimNow - cpSearchStart,docNil,cpNil,cp0,0);
            if (ferror)
                NoUndo();
            else
                vuab.uac = uacReplGlobal;
            return;
            }
        FetchCp(docCur, cpSearch, 0, fcmProps); /* Get props of first char
                                                that we are replacing */
        blt(&vchpFetch, &chp, cwCHP);
        chp.fSpecial = false;

        iCurCase = 0; /* assume that the replacement string doesn't
                         require special capitalization */

        /* if we're not matching upper/lower case call WCaseCp to determine
            the capitalization pattern of the matched string */
        if (!fSearchCase)
            iCurCase = WCaseCp(cpSearch, cpMatchLim - cpSearch);

        /* if the new capitalization pattern of the matched string
           doesn't match the current contents of hszCaseReplace,
           copy the replacement string to hszCaseReplace and transform
           hszCaseReplace to conform to the new pattern */
        if (iCurCase != iLastCase)
            switch (iCurCase)
                {
                default:
                case 0:   /* no special capitalization required */
                    bltbyte(**hszRealReplace, **hszCaseReplace, cch+1);
                    break;
                case 1:  /* first character of string must be capitalized */
                    bltbyte(**hszRealReplace, **hszCaseReplace, cch+1);
                    ***hszCaseReplace = ChUpper(***hszRealReplace);
                    break;
                case 2:  /* all characters must be capitalized */
#ifdef DBCS //t-Yoshio
                    for (ich = 0; ich < cch;) {
            if(!IsDbcsLeadByte((BYTE)(**hszRealReplace)[ich])) {
                        (**hszCaseReplace)[ich] =
                            ChUpper((**hszRealReplace)[ich]);
                ich++;
            }
            else {
                        (**hszCaseReplace)[ich] = (**hszRealReplace)[ich];
                        (**hszCaseReplace)[ich+1] = (**hszRealReplace)[ich+1];                          ich+=2;
            }
            }
#else
                    for (ich = 0; ich < cch;ich++)
                        (**hszCaseReplace)[ich] = ChUpper((**hszRealReplace)[ich]);
#endif
                    break;
                }

        /* do CachePara to find the current para props. CachePara has the
           side effect of setting vpapAbs     */
        CachePara(docCur, cpSearch);

        /* if the capitalization pattern has changed OR
              the character properties of the replacement text don't match
                 those of the last insert        OR
              the  paragraph properties of the replacement text don't match
                 those of the last insert, THEN

              1) call NewChpIns to write a run describing the character
                 properties of the previous insertion text,
              2) call FcWScratch to write the characters of the replacement
                 string to the scratch file,
              3) if we are replacing paragraph marks, call InsertPapsForReplace
                 to write runs describing each paragraph in the replacement
                 string */
        if (iCurCase != iLastCase ||
            CchDiffer(&vchpInsert,&chp,cchCHP) != 0 ||
            (fParaReplace && CchDiffer(&vpapPrevIns, &vpapAbs, cchPAP) != 0))
                {
                NewChpIns(&chp);
                fcCaseSz = FcWScratch(**hszCaseReplace,cch);
                if (fParaReplace)
                        InsertPapsForReplace(fcCaseSz);
                }

        /* Now since we have written the proper replacement text to
           the scratch file and have setup the character and paragraph runs to
           describe that text, simply do a replace to insert the replacement
           text into the piece table */
        Replace(docCur, cpSearch, cp0, fnScratch, fcCaseSz, (typeFC) cch);
        if (ferror) goto MemoryError;

#ifdef JAPAN //T-HIROYN Win3.1
/* When we replace from ANSI CharSet string to SHIFTJIS CharSet String
   We needs follows */
        {
            struct CHP savechpT;
            typeCP  cpF, cpFirst, cpLim, kcpF, kcpL;
            int     cchF;
            int     kanjiftc;
            CHAR    *rp;
            CHAR    ch, bSet;
            int     cchS, cblen;
            CHAR    rgch[ cchCHP +  1 ];

            rgch [0] = sprmCSame;

            if(NATIVE_CHARSET != GetCharSetFromChp(&chp)) {
                kanjiftc = GetKanjiFtc(&chp);
                savechpT = chp;
                cpFirst = cpSearch;

                do {
                    FetchCp(docCur, cpFirst, 0, fcmChars);
                    cpF = vcpFetch;
                    cchF = vcchFetch;
                    rp = vpchFetch;

                    if ((cpF+cchF) < cpSearch + cch)
                        cpLim = (cpF+cchF);
                    else
                        cpLim = cpSearch + cch;

                    cpFirst = kcpL;

                    cchS = 0;
                    kcpF = cpF;

                    while ( kcpF < cpLim ) {
                        ch = *rp;

                        bSet = FALSE;
                        if( FKana(ch) || IsDBCSLeadByte(ch) ) {
                            cblen = GetKanjiStringLen(cchS, cchF, rp);
                            bSet = TRUE;
                        } else {
                            cblen = GetAlphaStringLen(cchS, cchF, rp);
                        }

                        kcpL = kcpF + cblen;
                        cchS += cblen;
                        rp  += cblen;

                        if(bSet) {
							SetFtcToPchp(&chp, kanjiftc);
                            bltbyte( &chp,      &rgch [1], cchCHP );
                            AddSprmCps(rgch, docCur, kcpF, kcpL);
                        }
                        kcpF = kcpL;
                    }
					cpFirst = kcpF;
					
                } while ((cpF + cchF) < cpSearch + cch );
                chp = savechpT;
            }
        } // END JAPAN
#endif


        iLastCase = iCurCase; /* record new capitalization pattern */

        /* Now delete the found text from the piece table*/

        cpMacSave = cpMacCur;
        Replace(docCur, cpSearch+cch, cpMatchLim - cpSearch, fnNil, fc0, fc0);
        dcp = cpMacSave - cpMacCur; /* Calculate dcp here because picture
                        paragraphs may have interfered with deleting */
        if (ferror) goto MemoryError;
        if (!fReplaceAll)
                {
                SetUndo(uacInsert, docCur, cpSearch, (typeCP) cch,
                                                        docNil, cpNil, cp0, 0);
                if (ferror) goto MemoryError;
                SetUndoMenuStr(IDSTRUndoBase);
                }
        cpSearchLim += cch - dcp;
        cpMatchLim += cch - dcp;
        cpWallActual += cch - dcp;
#ifdef  DBCS                /* was in JAPAN */
        cpSearchNext = cpMatchLim;
#else
        cpSearchNext = CpLastStyChar( cpMatchLim );
#endif
        if (fReplaceAll)
                cpSearchLimNow = cpSearchLim;
        }
    while (fReplaceAll);
    }
if (fThenFind)
        {
        do
                {
ContinueSearch2:
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
                if(!fSpecialMatch && !fSearchDist)
                    cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,DistSearchString);
                else
                    cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,**hszFlatSearch);
                if(cpSearch == cpNil)
#else
                if ((cpSearch = CpSearchSz(cpSearchNext, cpSearchLim,
                                        **hszFlatSearch)) == cpNil)
#endif
                        {
                        if ((cpSearchLim == cpWallActual && fDidSearch) ||
                            fAbortSearch)
                                {
                                fFirstTime = false; /* Supress error message */
                                /*Select( CpFirstSty( cpSearchStart, styChar ),
                                        CpLastStyChar( cpMatchLim ) );*/
                                Select( CpFirstSty( cpSearchStart, styChar ),
                                        cpMatchLim );
                                PutCpInWwVertSrch(selCur.cpFirst);
                                cpSearchLimNow = cpMatchLim;
                                Error(fAbortSearch ?
                                      IDPMTCancelSearch : IDPMTSearchDone);
                                fAbortSearch = FALSE;
                                vfDidSearch = false;
                                cpWall = selCur.cpLim;
                                goto DoneReplacingP;
                                }
                        else
                                {
                                cpSearchNext = cpMinCur;
                                cpSearchLim = cpWallActual;
                                fDidSearch = true;
                                goto ContinueSearch2;
                                }
                        }
#ifdef  DBCS                    /* was in JAPAN */
                cpSearchNext = CpLastStyChar( cpSearch ) + 1;
#else
                cpSearchNext = CpLastStyChar( cpSearch + 1 );
#endif
                }
/*--    while(fSearchWord && !FWordCp(cpSearch,cpMatchLim - cpSearch));*/
        while(!FCpValid(cpSearch, cpMatchLim - cpSearch));
        if (!vfDidSearch)
                {
                cpWall = cpSearch;
                vfDidSearch = true;
                }
        }
goto DoneReplacingP;

MemoryError:
    FreeH(hszFlatSearch);
    FreeH(hszCaseReplace);
    FreeH(hszRealReplace);
    NoUndo();

    /* counter off the losing insertion point after incomplete change all */
    if (fReplaceAll && fSelSave)
        {
        selCur.cpFirst = selSave.cpFirst;
        selCur.cpLim = selSave.cpLim;
        }
}
#ifdef  DBCS
BOOL fDBCS = FALSE;
#endif

typeCP NEAR CpSearchSz(cpFirst, cpMacSearch, sz)
typeCP cpFirst;
typeCP cpMacSearch;
CHAR *sz;
{{     /* Finds first occurrence of sz in docCur starting at cpFirst */
      /* Returns cpNil if not found */
      /* Ignore case of letters if fSearchCase is FALSE.  This assumes that the
        pattern has already been folded to lower case. */

    CHAR ch;
    BOOL fMatched;
    int ichPat = 0;
    int     ichDoc = 0;
    int cchMatched = 0;
    typeCP cpFetchNext;
    /*EVENT event;*/

#ifdef DBCS
    typeCP cpFound;
    CHAR   rgchT[dcpAvgSent];
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
    CHAR chNext;
    CHAR dch[3];
#endif
#endif


    szSearch = sz;
#ifdef DBCS
    /* Initialize those local variables moved out from this
       function. */
    ichDoc = 0;
    cchMatched = 0;
    pchFetchSave = &rgchT[0];

    cbLastMatch = 1;

#endif


#ifdef DBCS
    FetchCp(docCur, cpFirst, 0, fcmChars + fcmNoExpand);
    cpFetchSave  = vcpFetch;
#ifdef JAPAN //raid 4709 bug fix
    bltbyte(vpchFetch, rgchT, ccpFetchSave =
	 ((vccpFetch > (dcpAvgSent-2)) ? (dcpAvgSent-2) : vccpFetch));

	{
        int inc;
		BOOL bDBCSBreak = FALSE;
		typeCP	saveVcpFetch;
        for(inc = 0;inc < ccpFetchSave;inc++) {
        	if(IsDBCSLeadByte((BYTE)rgchT[inc])) {
				inc++;
				if(inc >= ccpFetchSave) {
					bDBCSBreak = TRUE;
					break;
				}
			}
        }
		if(bDBCSBreak) {
			saveVcpFetch = vcpFetch;
            FetchCp(docCur, cpFetchSave + ccpFetchSave,
			 0, fcmChars + fcmNoExpand);
		    bltbyte(vpchFetch, rgchT+ccpFetchSave,1);
	        ccpFetchSave++;
			vcpFetch = saveVcpFetch;
		}
    }
#else //JAPAN
    bltbyte(vpchFetch, rgchT,
            ccpFetchSave = ((vccpFetch > dcpAvgSent) ? dcpAvgSent : vccpFetch));
    if (vccpFetch > dcpAvgSent) {
        int inc;
        fDBCS = 0;
        for(inc = 0;inc < dcpAvgSent;inc++) {
            if(fDBCS)
                fDBCS = 0;
            else
                fDBCS = IsDBCSLeadByte((BYTE)rgchT[inc]);
        }
        if(fDBCS)
            ccpFetchSave--;
        fDBCS = 0;
    }
#endif //JAPAN
    Assert(cpFetchSave == cpFirst);

    cpFetchNext = cpFetchSave + ccpFetchSave;
#else //DBCS
    FetchCp(docCur, cpFirst, 0, fcmChars + fcmNoExpand);
    Assert(vcpFetch == cpFirst);

    cpFetchNext = vcpFetch + vccpFetch;
#endif //DBCS

    fMatchedWhite = false;

    for (; ;)
        {
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
cbLastMatch = 1;
#endif
        if (szSearch[ichPat] == '\0' )
            {{ /* Found it */
#ifdef DBCS
            typeCP cpFound;
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
            if(IsDBCSLeadByte((BYTE)ch))
                cpMatchLim = vcpFetch+ichDoc - (fMatchedWhite ? 2 : 0);
            else
                cpMatchLim = vcpFetch+ichDoc - (fMatchedWhite ? 1 : 0);
#else
            cpMatchLim = vcpFetch+ichDoc - (fMatchedWhite ? 1 : 0);
#endif
            cpFound = cpFetchSave + ichDoc - cchMatched;
            if (CpFirstSty(cpFound, styChar) == cpFound) {
                /* It is on a Kanji boundary.  We really found it. */
                return (cpFound);
                }
            else {
                /* The last character did not match, try again
                   excluding the last byte match. */
                cchMatched -= cbLastMatch;
                cbLastMatch = 1;

                fMatchedWhite = false;
                goto lblNextMatch;
                }
#else
            cpMatchLim = vcpFetch+ichDoc - (fMatchedWhite ? 1 : 0);

            return vcpFetch + ichDoc - cchMatched;
#endif
            }}

#ifdef DBCS
    if (cpFetchSave + ichDoc >= cpMacSearch)
#else
    if (vcpFetch + ichDoc >= cpMacSearch)
#endif
            {{ /* Not found */
            if(fMatchedWhite && szSearch[ichPat+2] == '\0')
                { /* Found it */
#ifdef DBCS
                cpMatchLim = cpFetchSave + ichDoc;
                cpFound = cpFetchSave + ichDoc - cchMatched;
                if (CpFirstSty(cpFound, styChar) == cpFound) {
                    /* It is on a Kanji boundary, We really found it. */
                    return (cpFound);
                    }
                else {
                    /* The last character did not match, try again
                       excluding the last byte match. */
                    cchMatched -= cbLastMatch;
                    cbLastMatch = 1;

                    fMatchedWhite = false;
                    goto lblNextMatch;
                    }
#else
                cpMatchLim = vcpFetch+ichDoc;
                return vcpFetch + ichDoc - cchMatched;
#endif
                }
            else
                return cpNil;
            }}

#if defined(DBCS)
        if (ichDoc + cbLastMatch - 1 >= ccpFetchSave)
#else
        if (ichDoc >= vccpFetch)
#endif
            { /* Need more cp's */
            {{
#ifndef NOLA /* no look ahead */
/* check if abort search */
                if (FAbort())
                        {
                        fAbortSearch = TRUE;
                        return cpNil;
                        }
#endif /* NOLA */

/*            FetchCp(docNil, cpNil, 0, fcmChars + fcmNoExpand); */
/* we changed from a sequential fetch to a random fetch because a resize of the
window may cause another FetchCp before we reach here */
#ifdef DBCS
            FetchCp(docCur, cpFetchNext, 0, fcmChars + fcmNoExpand);
            cpFetchSave  = vcpFetch;

#ifdef JAPAN //raid 4709 bug fix
		    bltbyte(vpchFetch, rgchT, ccpFetchSave =
			 ((vccpFetch > (dcpAvgSent-2)) ? (dcpAvgSent-2) : vccpFetch));

			{
        		int inc;
				BOOL bDBCSBreak = FALSE;
				typeCP	saveVcpFetch;
		        for(inc = 0;inc < ccpFetchSave;inc++) {
        			if(IsDBCSLeadByte((BYTE)rgchT[inc])) {
						inc++;
						if(inc >= ccpFetchSave) {
							bDBCSBreak = TRUE;
							break;
						}
					}
		        }
				if(bDBCSBreak) {
					saveVcpFetch = vcpFetch;
        		    FetchCp(docCur, cpFetchSave + ccpFetchSave,
					 0, fcmChars + fcmNoExpand);
				    bltbyte(vpchFetch, rgchT+ccpFetchSave,1);
			        ccpFetchSave++;
					vcpFetch = saveVcpFetch;
				}
		    }
#else //JAPAN
            bltbyte(vpchFetch, rgchT,
                    ccpFetchSave = ((vccpFetch > dcpAvgSent) ?
                                      dcpAvgSent : vccpFetch));

            if (vccpFetch > dcpAvgSent) {
                int inc;
                fDBCS = 0;
                for(inc = 0;inc < dcpAvgSent;inc++) {
                    if(fDBCS)
                        fDBCS = 0;
                    else
                        fDBCS = IsDBCSLeadByte((BYTE)rgchT[inc]);
                }
                if(fDBCS)
                    ccpFetchSave--;
                fDBCS = 0;
            }
#endif //JAPAN
            cpFetchNext = cpFetchSave + ccpFetchSave;
#else //DBCS
            FetchCp(docCur, cpFetchNext, 0, fcmChars + fcmNoExpand);
            cpFetchNext = vcpFetch + vccpFetch;
#endif //DBCS
            ichDoc = 0;
            }}
            continue;
            }

#ifdef DBCS
        ch = pchFetchSave[ichDoc++];
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
        if(IsDBCSLeadByte((BYTE)ch))
        {
            chNext = pchFetchSave[ichDoc++];
            cbLastMatch = 2;
        }
        else
        {
            chNext = pchFetchSave[ichDoc];
            cbLastMatch = 1;
        }
#else
        cbLastMatch = 1;
#endif /*JAPAN*/
#else
        ch = vpchFetch[ichDoc++];
#endif
        if(!fSpecialMatch)
            {
            /* NOTE: this is just ChLower() brought in-line for speed */
#ifdef DBCS
            if( fDBCS )
#if defined(KOREA)
                {
                    if(!fSearchCase)
                        if(ch >= 'A' && ch <= 'Z') ch += 'a' - 'A';
                        else if (ch == 0xA3 && (chNext >= 0xC1 && chNext <= 0xDA))
                            chNext = 0x20 + chNext;
                    fDBCS = FALSE;
                }
#else
                fDBCS = FALSE;
#endif
             else
                if(!fSearchCase)
#if defined(TAIWAN) || defined(PRC) 
          if ( !(  fDBCS = IsDBCSLeadByte( ch )))
#endif
                    { /* avoid proc call for common cases */
                    if(ch >= 'A' && ch <= 'Z') ch += 'a' - 'A';
#ifdef JAPAN /*t-Yoshio*/
                    if(ch == 0x82 && (chNext >= 0x60 && chNext <= 0x79))
                        chNext = 0x21 + chNext;
#elif defined(KOREA)
                    else if(ch == 0xA3 && (chNext >= 0xC1 && chNext <= 0xDA))
                        chNext = 0x20 + chNext;
#else
                    else if(ch < 'a' || ch > 'z') ch = ChLower(ch);
#endif
                    }
#else
            if(!fSearchCase)
                { /* avoid proc call for common cases */
                if(ch >= 'A' && ch <= 'Z') ch += 'a' - 'A';
                else if(ch < 'a' || ch > 'z') ch = ChLower(ch);
                }
#endif
#ifdef JAPAN /*t-Yoshio*/
            if(!fSearchDist)
            {
                char han_str[3];
                han_str[0] = ch;han_str[1] = '\0';han_str[2] = '\0';
                if(IsDBCSLeadByte((BYTE)ch))
                {
                    if(szSearch[ichPat] == ch && szSearch[ichPat+1] == chNext)
                    {
                        ichPat+=2;
                        fMatched = true;
                    }
                    else
                        fMatched = false;
                }
                else
                {
                    if(ch >= 0xca && ch <= 0xce)
                    {
                        if(!myIsSonant(szSearch[ichPat],szSearch[ichPat+1]))
                            han_str[1] = '\0';
                        else if(chNext == 0xde || chNext == 0xdf )
                        {
                            han_str[1] = chNext;
                            han_str[2] = '\0';
                            cbLastMatch = 2;
                            ichDoc++;
                        }
                        else
                            han_str[1] = '\0';
                    }
                    else if(ch >= 0xa6 && ch <= 0xc4)
                    {
                        if(!myIsSonant(szSearch[ichPat],szSearch[ichPat+1]))
                            han_str[1] = '\0';
                        else if(chNext == 0xde )
                        {
                            han_str[1] = chNext;
                            han_str[2] = '\0';
                            cbLastMatch = 2;
                            ichDoc++;
                        }
                        else
                            han_str[1] = '\0';

                    }
                    else
                        han_str[1] = '\0';

                    myHantoZen(han_str,dch,3);

                    if(szSearch[ichPat] == dch[0] && szSearch[ichPat+1] == dch[1])
                    {
                        ichPat+=2;
                        fMatched = true;
                    }
                    else if(ch == chReturn || ch == chNRHFile)
                        fMatched = true;
                    else
                        fMatched = false;
                }
            }
            else
            {
                if(IsDBCSLeadByte((BYTE)ch))
                {
                    if(szSearch[ichPat] == ch && szSearch[ichPat+1] == chNext)
                    {
                        ichPat+=2;
                        fMatched = true;
                    }
                    else
                        fMatched = false;
                }
                else if(szSearch[ichPat] == ch)
                {
                    ichPat++;
                    fMatched = true;
                }
                else if(ch == chReturn || ch == chNRHFile)
                    fMatched = true;
                else
                    fMatched = false;
            }
#elif defined(KOREA)
            if(!fSearchDist)
            {
                char han_str[3];
                han_str[0] = ch;han_str[1] = '\0';han_str[2] = '\0';
                if(IsDBCSLeadByte((BYTE)ch))
                {
                    if(szSearch[ichPat] == ch && szSearch[ichPat+1] == chNext)
                    {
                        ichPat+=2;
                        fMatched = true;
                    }
                    else
                        fMatched = false;
                }
                else
                {
                    han_str[1] = '\0';

                    myHantoZen(han_str,dch,3);

                    if(szSearch[ichPat] == dch[0] && szSearch[ichPat+1] == dch[1])
                    {
                        ichPat+=2;
                        fMatched = true;
                    }
                    else if(ch == chReturn || ch == chNRHFile)
                        fMatched = true;
                    else
                        fMatched = false;
                }
            }
            else
            {
                if(IsDBCSLeadByte((BYTE)ch))
                {
                    if(szSearch[ichPat] == ch && szSearch[ichPat+1] == chNext)
                    {
                        ichPat+=2;
                        fMatched = true;
                    }
                    else
                        fMatched = false;
                }
                else if(szSearch[ichPat] == ch)
                {
                    ichPat++;
                    fMatched = true;
                }
                else if(ch == chReturn || ch == chNRHFile)
                    fMatched = true;
                else
                    fMatched = false;
            }
#else

            if(szSearch[ichPat] == ch)
                {
                ichPat++;
                fMatched = true;
                }
            else if(ch == chReturn || ch == chNRHFile)
                fMatched = true;
            else
                fMatched = false;
#endif
            }
        else
        {
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
            fMatched = J_FChMatch(ch,chNext,&ichPat,&ichDoc);
#else
            fMatched = FChMatch(ch, &ichPat, true);
#endif
        }

#ifdef DBCS
//#ifndef JAPAN /*t-Yoshio*/
#if !defined(JAPAN) && !defined(KOREA) /*t-Yoshio*/  
        fDBCS = IsDBCSLeadByte( ch );
#endif
#endif

        if(fMatched)
            {
#if defined(DBCS)
            cchMatched += cbLastMatch;
#else
            cchMatched++;
#endif
            }
        else
            { /* No match; try again */
#ifdef DBCS
lblNextMatch:
#endif
            if ((ichDoc -= cchMatched) < 0) /* Go back # of matched chars */
                {{ /* Overshot the mark */
#ifdef DBCS
                FetchCp(docCur, cpFetchSave + ichDoc, 0, fcmChars + fcmNoExpand);
                cpFetchSave  = vcpFetch;
#ifdef JAPAN //raid 4709 bug fix
			    bltbyte(vpchFetch, rgchT, ccpFetchSave =
				 ((vccpFetch > (dcpAvgSent-2)) ? (dcpAvgSent-2) : vccpFetch));

				{
			        int inc;
					BOOL bDBCSBreak = FALSE;
					typeCP	saveVcpFetch;
			        for(inc = 0;inc < ccpFetchSave;inc++) {
        				if(IsDBCSLeadByte((BYTE)rgchT[inc])) {
							inc++;
							if(inc >= ccpFetchSave) {
								bDBCSBreak = TRUE;
								break;
							}
						}
			        }
					if(bDBCSBreak) {
						saveVcpFetch = vcpFetch;
            			FetchCp(docCur, cpFetchSave + ccpFetchSave,
						 0, fcmChars + fcmNoExpand);
		    			bltbyte(vpchFetch, rgchT+ccpFetchSave,1);
				        ccpFetchSave++;
						vcpFetch = saveVcpFetch;
					}
			    }
#else //JAPAN
                bltbyte(vpchFetch, rgchT,
                        ccpFetchSave = ((vccpFetch > dcpAvgSent) ?
                                          dcpAvgSent : vccpFetch));

                if (vccpFetch > dcpAvgSent) {
                    int inc;
                    fDBCS = 0;
                    for(inc = 0;inc < dcpAvgSent;inc++) {
                        if(fDBCS)
                            fDBCS = 0;
                        else
                            fDBCS = IsDBCSLeadByte((BYTE)rgchT[inc]);
                    }
                    if(fDBCS)
                        ccpFetchSave--;
                    fDBCS = 0;
                }
#endif //JAPAN
                cpFetchNext = cpFetchSave + ccpFetchSave;
#else //DBCS
                FetchCp(docCur, vcpFetch + ichDoc, 0, fcmChars + fcmNoExpand);

/* this is for the next FetchCp in this forever loop that used to depend
on a sequential fetch */
                cpFetchNext = vcpFetch + vccpFetch;
#endif //DBCS
                ichDoc = 0;
                }}
            ichPat = 0;
            cchMatched = 0;
            }
        }
}}


/* set up in hszFlatSearch a copy of hszSearch that is all lower case.
    Note that we assume the old contents of hszFlatSearch were freed.
    Return True if success, False if out of memory.
*/
NEAR FMakeFlat(cch)
int cch; /*CchSz(**hszSearch)-1*/
{
    CHAR *pch1;
    CHAR *pch2;

    hszFlatSearch = (CHAR (**) [])HAllocate(CwFromCch(cch+1));
    if(FNoHeap(hszFlatSearch))
        return(FALSE);

    if(!fSearchCase)
        {
#ifdef DBCS
        for(pch1= **hszSearch, pch2 = **hszFlatSearch;*pch1!='\0';)
            if( IsDBCSLeadByte(*pch1) ) {
#ifdef JAPAN /*t-Yoshio*/
                if(*pch1 == 0x82 && (*(pch1+1) >= 0x60 && *(pch1+1) <= 0x79 ))
                {
                    *pch2++ = *pch1++;
                    *pch2++ = 0x21 + *pch1++;
                }
                else
                {
                    *pch2++ = *pch1++;
                    *pch2++ = *pch1++;
                }
#elif defined(KOREA)
               if(*pch1 == 0xA3 && (*(pch1+1) >= 0xC1 && *(pch1+1) <= 0xDA))
                {
                    *pch2++ = *pch1++;
                    *pch2++ = 0x20 + *pch1++;
                }
                else
                {
                    *pch2++ = *pch1++;
                    *pch2++ = *pch1++;
                }
#else
                *pch2++ = *pch1++;
                *pch2++ = *pch1++;
#endif
            } else
            {
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
                if(*pch1 >= 'A' && *pch1 <= 'Z')
                {
                    *pch2 = *pch1 + 0x20; pch1++; pch2++;
                }
                else
                    *pch2++ = *pch1++;
#else
                *pch2++ = ChLower(*pch1++);
#endif
            }
#else
        for(pch1= **hszSearch, pch2 = **hszFlatSearch;*pch1!='\0';pch1++,pch2++)
            *pch2 = ChLower(*pch1);
#endif
        *pch2 = '\0';
        }
    else
        bltbyte(**hszSearch, **hszFlatSearch, cch+1);
    return(TRUE);
}


/* sets the global fSpecialMatch if the more complicated character matching
    code is needed */
NEAR SetSpecialMatch()
{
    CHAR *pch = **hszSearch;
    CHAR ch;

#ifdef DBCS
    for( ch = *pch ; ch != '\0'; pch = AnsiNext(pch), ch = *pch )
#else
    while((ch = *pch++) != '\0')
#endif
        {
        switch(ch)
            {
            default:
                continue;
            case chMatchAny:
            case chPrefixMatch:
            case chSpace:
            case chHyphen:
                fSpecialMatch = true;
                return;
            }
        }
    fSpecialMatch = false;
    return;
}

/* Sets the global fParaReplace if the user wants to insert Paragraph breaks
    (since special insertion code must be run).  Also sets up the global
    hszRealReplace to reflect any meta characters in hszReplace */
NEAR FSetParaReplace(cch)
int cch; /*CchSz(**hszReplace)*/
{
    CHAR *rgch = **hszRealReplace;
    int ich = 0;
    CHAR ch;
    CHAR chNew;

    fParaReplace = false;

    while((ch = rgch[ich]) != '\0')
        {
#ifdef DBCS
        if(IsDBCSLeadByte(ch)){
            ich +=2;
            continue;
        }
#endif
        switch(ch)
            {
            default:
                break;
            case chPrefixMatch:
                switch(rgch[ich+1])
                    {
                    default:
                        /* just escaping the next char */
                        if(rgch[ich+1] == '\0')
                            chNew = chPrefixMatch;
                        else
                            chNew = rgch[ich+1];
                        break;
                    case chMatchNBSFile:
                        chNew = chNBSFile;
                        break;
                    case chMatchTab:
                        chNew = chTab;
                        break;
                    case chMatchNewLine:
                        chNew = chNewLine;
                        break;
                    case chMatchNRHFile:
                        chNew = chNRHFile;
                        break;
                    case chMatchSect:
                        chNew = chSect;
                        break;
                    case chMatchEol:
                        chNew = chEol;
                        break;
                    }
#ifdef CRLF
                if(chNew != chEol)
                    bltbyte(&(rgch[ich+1]),&(rgch[ich]), cch-ich-1);
#else
                bltbyte(&(rgch[ich+1]),&(rgch[ich]), cch-ich-1);
#endif /*CRLF*/
                if(chNew == chEol)
                    {
                    fParaReplace = true;
#ifdef CRLF
                    rgch[ich++] = chReturn;
#endif /*CRLF*/
                    }
                rgch[ich] = chNew;
                break;
            case chEol:
#ifdef CRLF
                if(ich == 0 || rgch[ich-1] != chReturn)
                    /* they didn't put in a return! */
                    {
                    CHAR (**hsz)[];

                    hsz = (CHAR (**) [])HAllocate(CwFromCch(cch+1));
                    if(FNoHeap(hsz))
                        {
                        return false;
                        }
                    bltbyte(**hszRealReplace, **hsz, ich);
                    (**hsz)[ich] = chReturn;
                    bltbyte((**hszRealReplace)+ich, (**hsz)+ich+1,
                                cch - ich);
                    FreeH(hszRealReplace);
                    hszRealReplace = hsz;
                    rgch = **hszRealReplace;
                    cch++;
                    ich++;
                    }
#endif /*CRLF*/
                fParaReplace = true;
                break;
            }
        ich++;
        }
    return true;
}

NEAR WCaseCp(cp,dcp)
typeCP  cp;
typeCP dcp;
{
    /* Determines capitalization pattern in a piece of text.  Used when doing
        replace to match existing pattern.  returns an int which is one of:
            0 - Not initial capital
            1 - Initial Capital but lower case appears later
            2 - Initial Capital and no lower case in the string
        Assumes a valid cp, dcp pair.
    */
    int ichDoc;

    FetchCp(docCur, cp, 0, fcmChars + fcmNoExpand);
    if(!isupper(vpchFetch[0]))
        return(0);

    /* we now know there is an initial cap.  Are there any lower case chars? */
    for(ichDoc=1; vcpFetch+ichDoc < cp + dcp;)
        {
        if(ichDoc >= vccpFetch)
            {
            FetchCp(docNil, cpNil, 0, fcmChars + fcmNoExpand);
            ichDoc = 0;
            continue;
            }
        if(islower(vpchFetch[ichDoc++]))
            return(1);
        }

    /* No lower case letters were found. */
    return(2);
}

int
FCpValid(cp, dcp)
typeCP cp, dcp;
{
CachePara(docCur, cp);
if (vpapAbs.fGraphics)
        return false;
#ifdef JAPAN  /*t-Yoshio*/
if (0)
#else
if (fSearchWord)
#endif
        return FWordCp(cp, dcp);
return true;
}

NEAR DestroyModeless(phDlg)
HWND * phDlg;
{
        HWND hDlg = *phDlg;

        *phDlg = (HWND)NULL;
        vhWndMsgBoxParent = (HANDLE)NULL;
        DestroyWindow(hDlg);
} /* end of DestroyModeless */


BOOL far PASCAL DialogFind( hDlg, message, wParam, lParam )
HWND    hDlg;                   /* Handle to the dialog box */
unsigned message;
WORD wParam;
LONG lParam;
{
CHAR szBuf[257];
int  cch = 0;
HANDLE hCtlFindNext = GetDlgItem(hDlg, idiFindNext);

/* This routine handles input to the Find dialog box. */
switch (message)
    {
    case WM_INITDIALOG:
#ifdef ENABLE /* not sure how cxEditScroll is used */
        cxEditScroll = 0;
#endif
#ifdef JAPAN /*t-Yoshio*/
        CheckDlgButton(hDlg,  idiDistinguishDandS, fSearchDist);
#elif defined(KOREA)
//bklee CheckDlgButton(hDlg,  idiDistinguishDandS, fSearchDist);
        CheckDlgButton(hDlg,  idiWholeWord, fSearchWord);
#else
        CheckDlgButton(hDlg,  idiWholeWord, fSearchWord);
#endif
        CheckDlgButton(hDlg, idiMatchCase, fSearchCase);
        cch = CchCopySz(**hszSearch, szBuf);
        if (cch == 0)
            {
            EnableWindow(hCtlFindNext, false);
            }
        else
            {
            SetDlgItemText(hDlg, idiFind, (LPSTR)szBuf);
            SelectIdiText(hDlg, idiFind);
            }
        vfDidSearch = false;
        cpWall = selCur.cpLim;
        return( TRUE ); /* ask windows to set focus to the first item also */

    case WM_ACTIVATE:
        if (wParam) /* turns active */
            {
            vhWndMsgBoxParent = hDlg;
            }
        if (vfCursorVisible)
            ShowCursor(wParam);
        return(FALSE); /* so that we leave the activate message to
        the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
        switch (wParam)
            {
            case idiFind:
                if (HIWORD(lParam) == EN_CHANGE)
                    {
                    vfDidSearch = false;
                    cpWall = selCur.cpLim;
                    CheckEnableButton(LOWORD(lParam), hCtlFindNext);
                    }
                break;

#ifdef JAPAN /*t-Yoshio*/
            case idiDistinguishDandS :
#elif defined(KOREA)
            case idiDistinguishDandS :
            case idiWholeWord:
#else
            case idiWholeWord:
#endif
            case idiMatchCase:
                CheckDlgButton(hDlg, wParam, !IsDlgButtonChecked(hDlg, wParam));
                break;
            case idiFindNext:
                if (IsWindowEnabled(hCtlFindNext))
                    {
                    CHAR (**hszSearchT)[] ;

                    if (FDlgSzTooLong(hDlg, idiFind, szBuf, 257))
                        {
                        switch (idiMsgResponse(hDlg, idiFind, IDPMTTruncateSz))
                            {
                            case idiOk:
                                /* show truncated text to user */
                                SetDlgItemText(hDlg, idiFind, (LPSTR)szBuf);
                                break;
                            case idiCancel:
                            default:
                                return(TRUE);
                            }
                        }
                    if (FNoHeap(hszSearchT = HszCreate(szBuf)))
                        break;
                    /* fSearchForward = 1; search direction -- always forward */
                    PostStatusInCaption(IDSTRSearching);
                    StartLongOp();
                    FreeH(hszSearch);
                    hszSearch = hszSearchT;
                    fSearchCase = IsDlgButtonChecked(hDlg, idiMatchCase);
#ifdef JAPAN  /*t-Yoshio*/
                    fSearchWord = 0;
                    fSearchDist = IsDlgButtonChecked(hDlg, idiDistinguishDandS);
#elif defined(KOREA)
//bklee             fSearchDist = IsDlgButtonChecked(hDlg, idiDistinguishDandS);
                    fSearchDist = 1;
                    fSearchWord = IsDlgButtonChecked(hDlg, idiWholeWord);
#else
                    fSearchWord = IsDlgButtonChecked(hDlg, idiWholeWord);
#endif
                    EnableExcept(vhDlgFind, FALSE);
                    DoSearch();
                    EnableExcept(vhDlgFind, TRUE);
                    EndLongOp(vhcIBeam);
                    PostStatusInCaption(NULL);
                    }
                break;
            case idiCancel:
LCancelFind:
                DestroyModeless(&vhDlgFind);
                break;
            default:
                return(FALSE);
            }
        break;

    case WM_CLOSE:
        if (bInSearchReplace)
        return TRUE;

    goto LCancelFind;

#ifndef INEFFLOCKDOWN
    case WM_NCDESTROY:
        FreeProcInstance(lpDialogFind);
        lpDialogFind = NULL;
        /* fall through to return false */
#endif

    default:
        return(FALSE);
    }
return(TRUE);
} /* end of DialogFind */


BOOL far PASCAL DialogChange( hDlg, message, wParam, lParam )
HWND    hDlg;                   /* Handle to the dialog box */
unsigned message;
WORD wParam;
LONG lParam;
{
CHAR szBuf[257]; /* max 255 char + '\0' + 1 so as to detact too long string  */
int  cch = 0;
HANDLE hCtlFindNext = GetDlgItem(hDlg, idiFindNext);
CHAR (**hszSearchT)[];
CHAR (**hszReplaceT)[];

/* This routine handles input to the Change dialog box. */

switch (message)
    {
    case WM_INITDIALOG:
#ifdef ENABLE /* not sure how cxEditScroll is used */
        cxEditScroll = 0;
#endif
        szBuf[0] = '\0';
#ifdef JAPAN  /*t-Yoshio*/
        CheckDlgButton(hDlg, idiDistinguishDandS, fSearchDist);
#elif defined(KOREA)
//bklee CheckDlgButton(hDlg, idiDistinguishDandS, fSearchDist);
        CheckDlgButton(hDlg, idiWholeWord, fSearchWord);
#else
        CheckDlgButton(hDlg, idiWholeWord, fSearchWord);
#endif
        CheckDlgButton(hDlg, idiMatchCase, fSearchCase);
        cch = CchCopySz(**hszSearch, szBuf);
        SetDlgItemText(hDlg, idiFind, (LPSTR)szBuf);
        if (cch > 0)
            {
            SelectIdiText(hDlg, idiFind);
            }
        else
            {
            EnableWindow(hCtlFindNext, false);
            EnableWindow(GetDlgItem(hDlg, idiChangeThenFind), false);
            //EnableWindow(GetDlgItem(hDlg, idiChange), false);
            EnableWindow(GetDlgItem(hDlg, idiChangeAll), false);
            }
        cch = CchCopySz(**hszReplace, szBuf);
        SetDlgItemText(hDlg, idiChangeTo, (LPSTR)szBuf);
        fChangeSel = false;
        vfDidSearch = false;
        SetChangeString(hDlg, selCur.cpFirst == selCur.cpLim);
        cpWall = selCur.cpLim;
        return( TRUE ); /* ask windows to set focus to the first item also */

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            SetChangeString(hDlg, (selCur.cpFirst == selCur.cpLim) || vfDidSearch);
            }
        if (vfCursorVisible)
            ShowCursor(wParam);
        return(FALSE); /* so that we leave the activate message to
        the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
        switch (wParam)
            {
            case idiFind: /* edittext */
                if (HIWORD(lParam) == EN_CHANGE)
                    {
                    vfDidSearch = false;
                    cpWall = selCur.cpLim;
                    if (!CheckEnableButton(LOWORD(lParam), hCtlFindNext))
                        {
                        EnableWindow(GetDlgItem(hDlg, idiChangeThenFind), false);
                        //EnableWindow(GetDlgItem(hDlg, idiChange), false);
                        EnableWindow(GetDlgItem(hDlg, idiChangeAll), false);
                        }
                    else
                        {
                        EnableWindow(GetDlgItem(hDlg, idiChangeThenFind), true);
                        //EnableWindow(GetDlgItem(hDlg, idiChange), true);
                        EnableWindow(GetDlgItem(hDlg, idiChangeAll), true);
                        }
                    return(TRUE);
                    }
                else
                    return(FALSE);

            case idiChangeTo: /* edittext */
                return(FALSE);

            case idiFindNext: /* Button for Find Next */
                /* Windows did not check if the default button is disabled
                   or not, so we have to check that! */
                if (!IsWindowEnabled(hCtlFindNext))
                    break;
            //case idiChange: /* Change, and stay put */
            case idiChangeThenFind: /* Change, then Find button */
            case idiChangeAll: /* Button for Replace All */
                if (wwCur < 0)
                    break;
                if (FDlgSzTooLong(hDlg, idiFind, szBuf, 257))
                    {
                    switch (idiMsgResponse(hDlg, idiFind, IDPMTTruncateSz))
                        {
                        case idiOk:
                            /* show truncated text to user */
                            SetDlgItemText(hDlg, idiFind, (LPSTR)szBuf);
                            break;
                        case idiCancel:
                        default:
                            return(TRUE);
                        }
                    }
                if (FNoHeap(hszSearchT = HszCreate(szBuf)))
                    break;
                if (FDlgSzTooLong(hDlg, idiChangeTo, szBuf, 257))
                    {
                    switch (idiMsgResponse(hDlg, idiChangeTo, IDPMTTruncateSz))
                        {
                        case idiOk:
                            /* show truncated text to user */
                            SetDlgItemText(hDlg, idiChangeTo, (LPSTR)szBuf);
                            break;
                        case idiCancel:
                        default:
                            return(TRUE);
                        }
                    }
                if (FNoHeap(hszReplaceT = HszCreate(szBuf)))
                    break;
                PostStatusInCaption(IDSTRSearching);
                StartLongOp();
                FreeH(hszSearch);
                hszSearch = hszSearchT;
                FreeH(hszReplace);
                hszReplace = hszReplaceT;
                /* fReplConfirm = 1;*/
                fSearchCase = IsDlgButtonChecked(hDlg, idiMatchCase);
#ifdef JAPAN   /*t-Yoshio*/
                fSearchWord = 0;
                fSearchDist = IsDlgButtonChecked(hDlg, idiDistinguishDandS);
#elif defined(KOREA)
//bklee         fSearchDist = IsDlgButtonChecked(hDlg, idiDistinguishDandS);
                fSearchDist = 1;
                fSearchWord = IsDlgButtonChecked(hDlg, idiWholeWord);
#else
                fSearchWord = IsDlgButtonChecked(hDlg, idiWholeWord);
#endif
                EnableExcept(vhDlgChange, FALSE);
                switch (wParam)
                    {
                    case idiFindNext:
                        DoSearch();
                        break;
                    //case idiChange:
                    case idiChangeThenFind:
                        CmdReplace(wParam == idiChangeThenFind);
                        break;
                    case idiChangeAll:
                        TurnOffSel();
                        if (!fChangeSel)
                            {
                            fSelSave = TRUE;
                            selSave.cpFirst = selCur.cpFirst;
                            selSave.cpLim = selCur.cpLim;
                            selCur.cpFirst = cpMinCur;
                            selCur.cpLim = cpMacCur;
                            }
                        CmdReplaceAll();
                        fSelSave = FALSE; /* reset */
                        break;
                    default:
                        Assert(FALSE);
                        break;
                    }
                EnableExcept(vhDlgChange, TRUE);
                SetChangeString(hDlg, vfDidSearch ? true : selCur.cpFirst == selCur.cpLim);
                EndLongOp(vhcIBeam);
                PostStatusInCaption(NULL);
                break;

#ifdef JAPAN /*t-Yoshio*/
            case idiDistinguishDandS:
#elif defined(KOREA)
            case idiDistinguishDandS:
            case idiWholeWord:
#else
            case idiWholeWord:
#endif
            case idiMatchCase:
                CheckDlgButton(hDlg, wParam, !IsDlgButtonChecked(hDlg, wParam));
                break;

            case idiCancel:
LCancelChange:
                DestroyModeless(&vhDlgChange);
                break;

            default:
                return(FALSE);
            }
        break;

#if WINVER < 0x300
    /* Don't really need to process this */
    case WM_CLOSE:
        goto LCancelChange;
#endif

#ifndef INEFFLOCKDOWN
    case WM_NCDESTROY:
        FreeProcInstance(lpDialogChange);
        lpDialogChange = NULL;
        /* fall through to return false */
#endif
    default:
        return(FALSE);
    }
return(TRUE);
} /* end of DialogChange */


NEAR SetChangeString(hDlg, fAll)
HANDLE hDlg;
int    fAll;
{ /* set the last control button in CHANGE to "Change All" or "Change Selection" */
CHAR    sz[256];

if (fAll == fChangeSel)
        {
        PchFillPchId(sz, (fAll ? IDSTRChangeAll : IDSTRChangeSel), sizeof(sz));
        SetDlgItemText(hDlg, idiChangeAll, (LPSTR)sz);
        fChangeSel = !fAll;
        }
}


fnFindText()
    {/* create dialog window only when it is not already created. */
    if (!IsWindow(vhDlgFind))
        {
#ifndef INEFFLOCKDOWN
        if (!lpDialogFind)
            if (!(lpDialogFind = MakeProcInstance(DialogFind, hMmwModInstance)))
                {
                WinFailure();
                return;
                }
#endif
        vhDlgFind = CreateDialog(hMmwModInstance, MAKEINTRESOURCE(dlgFind),
                                 hParentWw, lpDialogFind);
        if (!vhDlgFind)
#ifdef WIN30
            WinFailure();
#else
            Error(IDPMTNoMemory);
#endif
        }
    else
        {
        SendMessage(vhDlgFind, WM_ACTIVATE, true, (LONG)NULL);
        }
    }


fnFindAgain()
{
register HWND hDlg = wwdCurrentDoc.wwptr;
register HWND hWndFrom;

    hWndFrom = GetActiveWindow();

/* Find out where the F3 was executed from */
/* assemble hszSearch if called from Find or Change dialog box */
    if (vhDlgFind || vhDlgChange)
        {
        if (((hDlg = vhDlgFind) && (vhDlgFind == hWndFrom ||
            vhDlgFind == (HANDLE)GetWindowWord(hWndFrom, GWW_HWNDPARENT)))
            ||
            ((hDlg = vhDlgChange) && (vhDlgChange == hWndFrom ||
             vhDlgChange == (HANDLE)GetWindowWord(hWndFrom, GWW_HWNDPARENT))))
            {
            SendMessage(hDlg, WM_COMMAND, idiFindNext, (LONG)0);
            goto Out;
            }
        }
    PostStatusInCaption(IDSTRSearching);
    StartLongOp();
    DoSearch();
    EndLongOp(vhcIBeam);
    PostStatusInCaption(NULL);
Out:
    if (!IsWindowEnabled(wwdCurrentDoc.wwptr))
       EnableWindow(wwdCurrentDoc.wwptr, true);
    if (!IsWindowEnabled(hParentWw))
       EnableWindow(hParentWw, true);
    SendMessage(hParentWw, WM_ACTIVATE, true, (LONG)NULL);
} /* end of fnFindAgain */


fnReplaceText()
{/* create dialog window only when it is not already created. */
    if (!IsWindow(vhDlgChange))
        {
#ifndef INEFFLOCKDOWN
        if (!lpDialogChange)
            if (!(lpDialogChange = MakeProcInstance(DialogChange, hMmwModInstance)))
                {
                WinFailure();
                return;
                }
#endif
        vhDlgChange = CreateDialog(hMmwModInstance, MAKEINTRESOURCE(dlgChange),
                                   hParentWw, lpDialogChange);
        if (!vhDlgChange)
#ifdef WIN30
            WinFailure();
#else
            Error(IDPMTNoMemory);
#endif
        }
    else
        {
        SendMessage(vhDlgChange, WM_ACTIVATE, true, (LONG)NULL);
        }
}


/* P U T  C P  I N  W W  V E R T  S R C H*/
NEAR PutCpInWwVertSrch(cp)
typeCP cp;

        {
/* vertical case */
        typeCP cpMac;
        int    ypMac;
        struct EDL *pedl;
        int dl;
        int dlMac;

        UpdateWw(wwCur, false);
        dlMac = pwwdCur->dlMac - (vfSelecting ? 0 : 1);
        if (dlMac <= 0)
                return;
        pedl = &(**(pwwdCur->hdndl))[dlMac - 1];
        if (cp < pwwdCur->cpFirst ||
                cp > (cpMac = pedl->cpMin + pedl->dcpMac) ||
                cp == cpMac && pedl->fIchCpIncr)
                {
                DirtyCache(pwwdCur->cpFirst = cp);
                pwwdCur->ichCpFirst = 0;
                    /* This call places the search cp vertically on the screen
                       by scrolling. */
                CtrBackDypCtr( (pwwdCur->ypMac - pwwdCur->ypMin) >> 1, 2 );

#ifdef ENABLE /* no ActiveWindow concept yet */
                if (pwwdCur->wwptr != ActiveWindow)
#endif
                        TrashWw(wwCur);
                }
        else
                {
                ypMac = pwwdCur->ypMac / 2;

/* Make sure that cp is still visible (scrolling if neccesary) */
                pedl = &(**(pwwdCur->hdndl))[dl = DlFromYp(ypMac, pwwdCur)];
                if (cp >= pedl->cpMin + pedl->dcpMac)
                        {
                        ScrollDownCtr( max( 1, dl ) );
                        TrashWw(wwCur);
                        UpdateWw(wwCur, false);
                        }
       /* If cp is on bottom dl of the window and the dl is split by the
          split bar, scroll down in doc by one line, to make insertion point
          completely visible  */
                else if (cp >= pedl->cpMin & pedl->yp > ypMac)
                        {
                        ScrollDownCtr( 1 );
                        TrashWw(wwCur);
                        UpdateWw(wwCur,false);
                        }
                }
        }


#ifndef NOLA /* no look ahead */
BOOL (NEAR FAbort())
{
MSG msg;
register WORD vk_key;
register HANDLE hwndMsg;
HANDLE hwndPeek = (vhWndMsgBoxParent) ? vhWndMsgBoxParent : hParentWw;

if (PeekMessage((LPMSG)&msg, (HANDLE)NULL, WM_KEYFIRST, WM_KEYLAST, PM_NOREMOVE))
    {
    hwndMsg = msg.hwnd;
    if ((hwndPeek == (HANDLE)GetWindowWord(hwndMsg, GWW_HWNDPARENT)) ||
        (hwndMsg == hwndPeek))
        {
#ifdef DBCS
// It can be true at DBCS that WM_CHAR is the last message.
//
    PeekMessage((LPMSG)&msg, hwndMsg, WM_KEYFIRST,WM_KEYLAST,PM_REMOVE);
#else
        GetMessage((LPMSG)&msg, hwndMsg, WM_KEYFIRST, WM_KEYLAST);
#endif
        if (msg.message == WM_KEYDOWN &&
            (((vk_key = msg.wParam) == VK_ESCAPE) || (vk_key == VK_CANCEL)))
            {
            while (true)
                {
                GetMessage((LPMSG)&msg, hwndMsg, WM_KEYFIRST, WM_KEYLAST);
                if (msg.message == WM_KEYUP && msg.wParam == vk_key)
                    return(TRUE);
                }
            }
        else if (msg.message >= WM_SYSKEYDOWN && msg.message <= WM_SYSDEADCHAR)
            DispatchMessage((LPMSG)&msg);
        }
    }
return(FALSE);
} /* end of FAbort */
#endif /* NOLA */


BOOL (NEAR FWordCp(cp, dcp))
typeCP cp;
typeCP dcp;
    {
    /* sees if the word starting at cp (with dcp chars) is a separate
        word. */
    int ich;


    /* check the start of the word */
    if(cp != cp0)
        {
        int wbPrev;
        int wbStart;
        FetchCp(docCur,cp-1,0,fcmChars + fcmNoExpand);
        ich = 0;
        wbPrev = WbFromCh(vpchFetch[ich]);
        if(vcpFetch+vccpFetch <= cp)
            {
            FetchCp(docCur,cp,0,fcmChars + fcmNoExpand);
            ich = 0;
            }
        else
            ich++;
#ifdef  DBCS    /* was in JAPAN; KenjiK '90-12-20 */
#ifndef KOREA  
    /* word break is meanless. */
    if(!IsDBCSLeadByte(vpchFetch[ich]))
#endif
#endif
        if(wbPrev == (wbStart = WbFromCh(vpchFetch[ich])))
            {
            if (wbPrev != wbWhite && wbStart != wbWhite)
                return(false);
            }
        }

    /* check the end of the word */
    if(cp+dcp-1 != cp0)
        {
        int wbEnd;
        int wbLim;

        if(vcpFetch+vccpFetch <= cp+dcp-1 || vcpFetch > cp+dcp-1)
            {
            FetchCp(docCur,cp+dcp-1,0,fcmChars + fcmNoExpand);
            ich = 0;
            }
        else
            ich =  (dcp-1) - (vcpFetch-cp);
        wbEnd = WbFromCh(vpchFetch[ich]);
        if(vcpFetch+vccpFetch <= cp+dcp)
            {
            FetchCp(docCur,cp+dcp,0,fcmChars + fcmNoExpand);
            ich = 0;
            }
        else
            ich++;
#ifdef  DBCS    /* was in JAPAN; KenjiK '90-12-20 */
#ifndef KOREA 
    /* word break is meanless. */
    if(!IsDBCSLeadByte(vpchFetch[ich]))
#endif
#endif
        if(vccpFetch != 0 && (wbEnd == (wbLim = WbFromCh(vpchFetch[ich]))))
            {
            if (wbEnd != wbWhite && wbLim != wbWhite)
                return(false);
            }
        }

    return(true);
    }


BOOL (NEAR FChMatch(ch, pichPat, fFwd))
int ch;
int *pichPat;
BOOL fFwd;
    {
    int ich = *pichPat;
    int chSearch = szSearch[ich];
    BOOL fPrefixed = false;
    BOOL fMatched = false;

#ifdef DEBUG
    Assert(fSpecialMatch);
#endif /*DEBUG*/
#ifdef DBCS
    Assert(fFwd);
    cbLastMatch = 1; /* Unless DBCS space. */

#endif

    /* NOTE: this is just ChLower() brought in-line for speed */
#ifdef DBCS
//       No need to make lower char for DBCS second byte
    if(!fDBCS && !fSearchCase && ch >= 'A' && ch <= 'Z' )
#else
    if(!fSearchCase && ch >= 'A' && ch <= 'Z' )
#endif
            ch += 'a' - 'A';
    if(!fFwd && ich > 0 && szSearch[ich-1] == chPrefixMatch)
        /* see if the char is prefixed by a chPrefixMatch */
        {
        chSearch = chPrefixMatch;
        --ich;
        }

    for(;;)
        {
        switch(chSearch)
            {
            default:

//#ifdef JAPAN
#if defined(JAPAN) || defined(KOREA)
                if(IsDBCSLeadByte(chSearch))
                    cbLastMatch = 2;
#endif
                if(ch == chSearch)
                    goto GoodMatch;
                else if(ch == chReturn || ch == chNRHFile)
                    goto EasyMatch;
                break;
            case chSpace:
                if(ch == chSpace || ch == chNBSFile)
                    goto GoodMatch;
                break;
            case chHyphen:
                if(ch == chHyphen || ch == chNRHFile || ch == chNBH)
                    goto GoodMatch;
                break;
            case chMatchAny:
                if(ch == chReturn || ch == chNRHFile)
                    goto EasyMatch;
                if(!fPrefixed || ch == chMatchAny)
                    goto GoodMatch;
                break;
            case chPrefixMatch:
                if(fPrefixed)
                    {
                    if(ch == chPrefixMatch)
                        goto GoodMatch;
                    else
                        break;
                    }
                else
                    {
                    chSearch = szSearch[ich+1];
                    if(fFwd)
                        ++ich;
                    fPrefixed = true;
                    switch(chSearch)
                        {
                        default:
                            continue;
                        case chMatchEol:
                            chSearch = chEol;
                            continue;
                        case chMatchTab:
                            chSearch = chTab;
                            continue;
                        case chMatchWhite:
                            switch(ch)
                                {
                                default:
#ifdef DBCS
lblNonWhite:
#endif
                                    if(fMatchedWhite)
                                        {
                                        if(fFwd)
                                            {
                                            if(szSearch[++ich] =='\0')
                                                {
                                                *pichPat = ich;
                                                goto EasyMatch;
                                                }
                                            }
                                        else
                                            {
                                            ich -= 1;
                                            if(ich < 0)
                                                {
                                                *pichPat = ich;
                                                goto EasyMatch;
                                                }
                                            }
                                        *pichPat = ich;
                                        fMatchedWhite = false;
                                        chSearch = szSearch[ich];
                                        continue;
                                        }
                                    break;
                                case chSpace:
                                case chReturn:
                                case chEol:
                                case chTab:
                                case chNBSFile:
                                case chNewLine:
                                case chSect:
                                    fMatchedWhite = true;
                                    goto EasyMatch;
                                }
                            break;
                        case chMatchNBSFile:
                            chSearch = chNBSFile;
                            continue;
                        case chMatchNewLine:
                            chSearch = chNewLine;
                            continue;
                        case chMatchNRHFile:
                            chSearch = chNRHFile;
                            continue;
                        case chMatchSect:
                            chSearch = chSect;
                            continue;
                        }
                    }
                break;
            }
        fMatchedWhite = false;
        return false;
        }
GoodMatch:
    *pichPat = ich + ((fFwd) ? 1 : (-1));
EasyMatch:
    return true;
    }

/* I N S E R T  P A P S  F O R  R E P L A C E */
/* do AddRunScratch for every distinct paragraph in hszCaseReplace  */
/* This is only needed when hszCaseReplace contains one or more chEols */
NEAR InsertPapsForReplace(fc)
typeFC fc;
        {
        int cchInsTotal = 0;
        CHAR *pchTail;
        CHAR *pchHead;

        for(;;)
                {
                int cch;

                pchHead = **hszCaseReplace + cchInsTotal;
                pchTail = (CHAR *)index(pchHead, chEol);
                if (pchTail == 0) return;
                cch = pchTail - pchHead + 1; /* cch is count including chEol */

                fc += cch;
                cchInsTotal += cch;
                AddRunScratch(&vfkpdParaIns, &vpapAbs, vppapNormal,
                        FParaEq(&vpapAbs, &vpapPrevIns) && vfkpdParaIns.brun != 0 ? -cchPAP : cchPAP,
                        fcMacPapIns = fc);
                blt(&vpapAbs, &vpapPrevIns, cwPAP);
                }
        }


NEAR FDlgSzTooLong(hDlg, idi, pch, cchMax)
HWND hDlg;
int idi;
CHAR *pch;
int cchMax;
{
int cchGet = GetDlgItemText(hDlg, idi, (LPSTR)pch, cchMax);

*(pch+cchMax-2) = '\0'; /* just in case the string is too long */
if (cchGet > (cchMax - 2))
    return(TRUE);
else
    return(FALSE);
}


NEAR idiMsgResponse(hDlg, idi, idpmt)
HWND hDlg;
int idi;
int idpmt;
{
CHAR szT[cchMaxSz];

PchFillPchId(szT, idpmt, sizeof(szT));
SetFocus(GetDlgItem(hDlg, idi));
SendDlgItemMessage(hDlg, idi, EM_SETSEL, (WORD)NULL, MAKELONG(255, 32767));
return(IdPromptBoxSz(hDlg, szT, MB_OKCANCEL | MB_ICONASTERISK));
}


PostStatusInCaption(idstr)
int idstr;
{

extern HWND hParentWw;
extern CHAR szCaptionSave[];

CHAR *pchCaption = &szCaptionSave[0];
CHAR *pchLast;
int  cch;
CHAR szT[256];

if (idstr == NULL)
    {
    /* restore the caption */
    SetWindowText(hParentWw, (LPSTR)pchCaption);
    }
else
    {
    /* save caption */
    GetWindowText(hParentWw, (LPSTR)pchCaption, cchMaxFile);

    /* append status message after app name */
#ifndef INTL
    pchLast = pchCaption + CchSz(pchCaption) - 1;
    while (pchLast-- > pchCaption)
        {
        if (*pchLast == ' ')
            break;
        }
    PchFillPchId(bltbyte(pchCaption, szT, (cch = pchLast - pchCaption + 1)),
                 IDSTRSearching, 13);
#else
    pchLast = pchCaption + CchSz(szAppName) + CchSz(szSepName) - 2;
    PchFillPchId(bltbyte(pchCaption, szT, (cch = pchLast - pchCaption)),
                 IDSTRSearching, 13);
#endif
    SetWindowText(hParentWw, (LPSTR)szT);
    }
}
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
BOOL (NEAR J_FChMatch(ch, chNext, pichPat, pichDoc))
CHAR ch;
CHAR chNext;
int *pichPat;
int *pichDoc;
{
    int ich = *pichPat;
    CHAR chSearch = szSearch[ich];
    CHAR chSearchNext = szSearch[ich+1];
    WORD dchSearch;
    BOOL fPrefixed = false;

    if(!fSearchCase ) {
#ifdef JANPAN
        if(ch == 0x82 && chNext >= 0x60 && chNext <= 0x79 )
            chNext = 0x21 + chNext;
#else
        if(ch == 0xA3 && (chNext >= 0xC1 && chNext <= 0xDA))
            chNext = 0x20 + chNext;
#endif
        else if( ch >= 'A' && ch <= 'Z' )
            ch += 'a' - 'A';
    }

    for(;;) {
        if( chSearch == chPrefixMatch ) {
            if(fPrefixed) {
                if(ch == chPrefixMatch) {
                    *pichPat = ich + 1;
                    return true;
                }
                break;
            }
            chSearch = chSearchNext;
            ich++;
            if(IsDBCSLeadByte(chSearch)) {
                chSearchNext = szSearch[ich+1];
                continue;
            }
            fPrefixed = true;
            switch(chSearch)
            {
                default:
                    continue;
                case chMatchEol:
                    chSearch = chEol;
                    break;
                case chMatchTab:
                    chSearch = chTab;
                    break;
                case chMatchNBSFile:
                    chSearch = chNBSFile;
                    break;
                case chMatchNewLine:
                    chSearch = chNewLine;
                    break;
                case chMatchNRHFile:
                    chSearch = chNRHFile;
                    break;
                case chMatchSect:
                    chSearch = chSect;
                    break;
                case chMatchWhite:
                    if(IsDBCSLeadByte((BYTE)ch)) {
#if defined(JAPAN)
                        if(ch == 0x81 && chNext == 0x40) {
#else
                        if(!fSearchDist && (ch == 0xA1 && chNext == 0xA1)) {
#endif
                            fMatchedWhite = true;
                            return true;
                        }
                    }
                    else if( ch == chSpace || ch == chReturn || ch == chEol ||
                            ch == chNBSFile || ch == chTab || ch == chNewLine || ch == chSect )
                    {
                        fMatchedWhite = true;
                        return true;
                    }
                    if(fMatchedWhite) {
                        if(szSearch[ich+1] =='\0') {
                            *pichPat = ich + 1;
                            return true;
                        }
                        *pichPat = ich++;
                        fMatchedWhite = false;
                        chSearch = szSearch[ich];
                        chSearchNext = szSearch[ich+1];
                        break;
                    }
#ifdef KOREA
                        fMatchedWhite = false;
			return false;
#else
                break;
#endif
            }
        }
        if( chSearch == chMatchAny ) {
            if(ch == chReturn || ch == chNRHFile)
                return true;
            if(!fPrefixed || ch == chMatchAny) {
                *pichPat = ich + 1;
                return true;
            }
            break;
        }
        if(chSearch == chSpace ) {
            if(ch == chSpace || ch == chNBSFile || (ch == 0x81 && chNext == 0x40)) {
                *pichPat = ich + 1;
                return true;
            }
            break;
        }
        if(chSearch == chHyphen ) {
            if(ch == chHyphen || ch == chNRHFile || ch == chNBH) {
                *pichPat = ich + 1;
                return true;
            }
            break;
        }
        if(!fSearchDist)
        {
            CHAR Doc[3];
            CHAR Pat[3];
            CHAR tmp[3];
            Doc[0] = Doc[1] = Doc[2] = '\0';
            Pat[0] = Pat[1] = Pat[2] = '\0';
            if(IsDBCSLeadByte((WORD)chSearch)) {
                Pat[0] = chSearch;
                Pat[1] = chSearchNext;
                ich += 2;
            }
            else {
                tmp[0] = chSearch;
                tmp[1] = tmp[2] = '\0';
                if(chSearch >= 0xca && chSearch <= 0xce) {
                    if(chSearchNext == 0xde || chSearchNext == 0xdf ) {
                        tmp[1] = chNext;
                        ich += 1;
                    }
                }
                else if(chSearch >= 0xa6 && chSearch <= 0xc4) {
                    if(chSearchNext == 0xde ) {
                        tmp[1] = chNext;
                        ich += 1;
                    }
                }
                ich += 1;
                myHantoZen(tmp,Pat,3);
            }
            if(IsDBCSLeadByte((BYTE)ch))
            {
                if(Pat[0] == ch && Pat[1] == chNext)
                {
                    *pichPat = ich;
                    return  true;
                }
                else
                    return false;
            }
            else {
                tmp[0] = ch;
                if(ch >= 0xca && ch <= 0xce) {
                    if(myIsSonant(Pat[0],Pat[1]) && chNext == 0xde || chNext == 0xdf ) {
                        tmp[1] = chNext;
                        cbLastMatch = 2;
                        *pichDoc++;
                    }
                }
                else if(ch >= 0xa6 && ch <= 0xc4) {
                    if(!myIsSonant(Pat[0],Pat[1]) && chNext == 0xde ) {
                        tmp[1] = chNext;
                        cbLastMatch = 2;
                        *pichDoc++;
                    }
                }
                myHantoZen(tmp,Doc,3);

                if(Pat[0] == Doc[0] && Pat[1] == Doc[1])
                {
                    *pichPat = ich;
                    return true;
                }
                else if(ch == chReturn || ch == chNRHFile)
                    return true;
                else
                    return  false;
            }
            return false;
        }
        if( chSearch == ch) {
            if(IsDBCSLeadByte((BYTE)ch)) {
                if(chSearchNext == chNext) {
                    *pichPat = ich + 2;
                    return true;
                }
                else
                    return false;
            }
            *pichPat = ich + 1;
            return true;
        }
        else if(ch == chReturn || ch == chNRHFile)
            return true;
        break;
    }
        /*UnMatched*/
        fMatchedWhite = false;
        return false;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\scrnchng.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This routine sets up the screen position used by Word relative to the
current device. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOATOM
#define NODRAWTEXT
#define NOMSG
#define NOOPENFILE
#define NOSCROLL
#define NOSOUND
/*#define NOTEXTMETRIC*/
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "ch.h"
#include "cmddefs.h"
#include "scrndefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "printdef.h"
#include "str.h"
#include "docdefs.h"
#include "propdefs.h"
#include "machdefs.h"
#include "fontdefs.h"
#include "commdlg.h"

#ifdef	DBCS
#include "kanji.h"
#endif

unsigned dxaPrOffset;
unsigned dyaPrOffset;
extern HCURSOR vhcIBeam;


BOOL FSetWindowColors()
    {
    /* This routine sets up the global variables rgbBkgrnd, rgbText, hbrBkgrnd,
    and ropErase, depending on what the current system colors are.  hWnd is a
    handle to a window on top. */

    extern long ropErase;
    extern long rgbBkgrnd;
    extern long rgbText;
    extern HBRUSH hbrBkgrnd;

    long rgbWindow;
    long rgbWindowText;
    HDC hDC;

    /* Get the color of the background and the text. */
    rgbWindow = GetSysColor(COLOR_WINDOW);
    rgbWindowText = GetSysColor(COLOR_WINDOWTEXT);

    /* If the colors haven't changed, then there is nothing to do. */
    if (rgbWindow == rgbBkgrnd && rgbWindowText == rgbText)
        {
        return (FALSE);
        }

    /* Convert the window colors into "pure" colors. */
    if ((hDC = GetDC(NULL)) == NULL)
        {
        return (FALSE);
        }
    rgbBkgrnd = GetNearestColor(hDC, rgbWindow);
    rgbText = GetNearestColor(hDC, rgbWindowText);
    ReleaseDC(NULL, hDC);
    Assert((rgbBkgrnd & 0xFF000000) == 0 && (rgbText & 0xFF000000) == 0);

    /* Set up the brush for the background. */
    if ((hbrBkgrnd = CreateSolidBrush(rgbBkgrnd)) == NULL)
        {
        /* Can't make the background brush; use the white brush. */
        hbrBkgrnd = GetStockObject(WHITE_BRUSH);
        rgbBkgrnd = RGB(0xff, 0xff, 0xff);
        }

    /* Compute the raster op to erase the screen. */
    if (rgbBkgrnd == RGB(0xff, 0xff, 0xff))
        {
        /* WHITENESS is faster than copying a white brush. */
        ropErase = WHITENESS;
        }
    else if (rgbBkgrnd == RGB(0, 0, 0))
        {
        /* BLACKNESS is faster than copying a black brush. */
        ropErase = BLACKNESS;
        }
    else
        {
        /* For everything else, we have to copy the brush. */
        ropErase = PATCOPY;
        }
    return (TRUE);
    }


int FSetScreenConstants()
    {
    /* This routine sets the value of a variety of global variables that used to
    be constants in Mac Word, but are now varibles because screen resolution can
    only be determined at run time. */

    extern HWND hParentWw;
    extern HDC vhDCPrinter;
    extern HBITMAP hbmNull;
    extern int dxpLogInch;
    extern int dypLogInch;
    extern int dxpLogCm;
    extern int dypLogCm;
    extern int dypMax;
    extern int xpRightMax;
    extern int xpSelBar;
    extern int xpMinScroll;
    extern int xpRightLim;
    extern int dxpInfoSize;
    extern int ypMaxWwInit;
    extern int ypMaxAll;
    extern int dypMax;
    extern int dypAveInit;
    extern int dypWwInit;
    extern int dypBand;
    extern int ypSubSuper;
#ifdef KINTL
    extern int dxaAdjustPerCm;
#endif /* ifdef KINTL */

    HDC hDC;
#ifdef KINTL
    int xaIn16CmFromA, xaIn16CmFromP;
#endif /* ifdef KINTL */


    /* First, let's create and save an empty bitmap. */
    if ((hbmNull = CreateBitmap(1, 1, 1, 1, (LPSTR)NULL)) == NULL)
        {
        return (FALSE);
        }

    /* Get the DC of the parent window to play with. */
    if ((hDC = GetDC(hParentWw)) == NULL)
        {
        return (FALSE);
        }

    /* Save away the height of the screen. */
    dypMax = GetDeviceCaps(hDC, VERTRES);

    /* determine screen pixel dimensions */
    dxpLogInch = GetDeviceCaps(hDC, LOGPIXELSX);
    dypLogInch = GetDeviceCaps(hDC, LOGPIXELSY);

    /* convert above to centimeters */
    dxpLogCm = MultDiv(dxpLogInch, czaCm, czaInch);
    dypLogCm = MultDiv(dypLogInch, czaCm, czaInch);

#ifdef KINTL
    /* Now, calculate the kick back amount of xa per cm. */
    xaIn16CmFromA  = 16 * czaCm;
    xaIn16CmFromP  = MultDiv(16 * dxpLogCm, czaInch, dxpLogInch);
    dxaAdjustPerCm = (xaIn16CmFromP - xaIn16CmFromA) / 16;
#endif /* ifdef KINTL */

#ifdef SYSENDMARK
        {
        extern HFONT      vhfSystem;
        extern struct FMI vfmiSysScreen;
        extern int       vrgdxpSysScreen[];
        TEXTMETRIC        tm;

        /* The use of height below is OK, because we are
           just trying to get the reference height. */
        GetTextMetrics(hDC, (LPTEXTMETRIC) &tm);
        
        /* Set up the fields in vfmiSysScreen for the later use. */
        vfmiSysScreen.dxpOverhang = tm.tmOverhang;
#if defined(KOREA)
        if ((tm.tmPitchAndFamily & 1) == 0)
               vfmiSysScreen.dxpSpace = tm.tmAveCharWidth;
        else
#endif
        vfmiSysScreen.dxpSpace = LOWORD(GetTextExtent(hDC,
                                        (LPSTR)" ", 1)) - tm.tmOverhang;
        vfmiSysScreen.dypAscent = tm.tmAscent;
        vfmiSysScreen.dypDescent = tm.tmDescent;
        vfmiSysScreen.dypBaseline = tm.tmAscent;
        vfmiSysScreen.dypLeading = tm.tmExternalLeading;

#ifdef	DBCS	/* KenjiK '90-10-29 */
		/* We must setup appended members of structure. */
        vfmiSysScreen.dxpDBCS = dxpNil;
#endif	/* DBCS */

        bltc(vrgdxpSysScreen, dxpNil, chFmiMax - chFmiMin);
        vfmiSysScreen.mpchdxp = vrgdxpSysScreen - chFmiMin;
        
        /* This is as good a place to get a handle to the system font as
           any other for LoadFont().....? */
        /* Throw away the old one first, if applicable. */
        if (vhfSystem != NULL) {
            DeleteObject((HANDLE) vhfSystem);
            }
        vhfSystem = GetStockObject(SYSTEM_FONT);
        Assert(vhfSystem != NULL);
        }
#endif /* SYSENDMARK */

    /* We don't need the DC any more. */
    ReleaseDC(hParentWw, hDC);

    /* Calculate the positions. */
    xpSelBar = MultDiv(xaSelBar, dxpLogInch, czaInch);
    xpRightMax = MultDiv(xaRightMax, dxpLogInch, czaInch);
    xpRightLim = xpRightMax - (GetSystemMetrics(SM_CXFULLSCREEN) - xpSelBar -
      GetSystemMetrics(SM_CXVSCROLL) + GetSystemMetrics(SM_CXBORDER));
    xpMinScroll = ((MultDiv(xaMinScroll, dxpLogInch, czaInch)+7)/8)*8;
    dxpInfoSize = MultDiv(dxaInfoSize, dxpLogInch, czaInch);
    ypMaxWwInit = MultDiv(yaMaxWwInit, dypLogInch, czaInch);
    ypMaxAll = MultDiv(yaMaxAll, dypLogInch, czaInch);
    dypWwInit = MultDiv(dyaWwInit, dypLogInch, czaInch);
    dypBand = MultDiv(dyaBand, dypLogInch, czaInch);
    ypSubSuper = MultDiv(yaSubSuper, dypLogInch, czaInch);

    /* dypAveInit is a very rough guess as to the height + leading of a 12 point
    font. */
    dypAveInit = MultDiv(cya12pt, dypLogInch, czaInch);

    /* Time to search the user profile to find a printer. */
    if (!FGetPrinterFromProfile())
        {
        return (FALSE);
        }
    GetPrinterDC(FALSE);

    return (TRUE);
    }


BOOL FGetPrinterFromProfile()
    {
    /* This routine searches the user profile for the name of a printer to use
    and records the name in the printer heap strings.  FALSE is returned iff a
    memory error is encountered. */

    extern HWND hParentWw;
    extern CHAR szWindows[];
    extern CHAR szDevice[];
    extern CHAR szDevices[];
    extern BOOL vfPrDefault;
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];

    CHAR *index(CHAR *, int);
    CHAR *bltbyte(CHAR *, CHAR *, int);

    CHAR szPrinter[cchMaxProfileSz];
    CHAR szDevSpec[cchMaxProfileSz];
    CHAR chNull = '\0';
    CHAR *pch;
    CHAR *pchDriver;
    CHAR *pchPort;
    int cwsz;

    if (!vfPrDefault && hszPrinter != NULL && hszPrPort != NULL)
        {
        /* If the user has selected a printer, then look for that printer in the
        user profile. */

        int cPort;
        int iPort;

        bltsz(&(**hszPrinter)[0], szPrinter);
        GetProfileString((LPSTR)szDevices, (LPSTR)szPrinter, (LPSTR)&chNull,
          (LPSTR)szDevSpec, cchMaxProfileSz);
        cPort = ParseDeviceSz(szDevSpec, &pchPort, &pchDriver);

        /* See if we can find the old port in the list. */
        for (iPort = 0, pch = pchPort; iPort < cPort; iPort++)
            {
            if (WCompSz(&(**hszPrPort)[0], pch) == 0)
                {
                pchPort = pch;
                goto GotPrinter;
                }
            pch += CchSz(pch);
            }

        /* If the port for the current printer has changed, then it must have
        been done by the control panel and we haven't the foggiest idea what
        it is, so grab the first port. */
        goto UnknownPort;
        }

    /* Is there a default Windows printer? */
    GetProfileString((LPSTR)szWindows, (LPSTR)szDevice, (LPSTR)&chNull,
      (LPSTR)szPrinter, cchMaxProfileSz);

#ifdef WIN30
    /* Don't make the assumption like Write 2 did and just grab ANY printer.
       I know, I know -- there's unnecessary code left down below but didn't
       want to mess any special case code up ..pault */
    if ((pch = index(szPrinter, ',')) == 0)
        goto BailOut;
#endif

    /* Does this entry contain the port and driver information. */
    if ((pch = index(szPrinter, ',')) != 0)
        {
        /* Remove any trailing spaces from the printer name. */
        CHAR *pchT;

        for (pchT = pch; *pchT == ' ' && pchT > &szPrinter[0]; pchT--);
        *pchT = '\0';

        /* Parse out the port and the driver names. */
        ParseDeviceSz(pch + 1, &pchPort, &pchDriver);
        }
    
    else
        {
        if (szPrinter[0] == '\0')
            {
            /* No default printer; grab the first one in the list. */
            GetProfileString((LPSTR)szDevices, (LPSTR)NULL, (LPSTR)&chNull,
              (LPSTR)szPrinter, cchMaxProfileSz);

            if (szPrinter[0] == '\0')
                {
BailOut:
                hszPrinter = hszPrDriver = hszPrPort = NULL;
                return (TRUE);
                }
            }

UnknownPort:
        /* Find the device driver and the port of the printer. */
        GetProfileString((LPSTR)szDevices, (LPSTR)szPrinter, (LPSTR)&chNull,
          (LPSTR)szDevSpec, cchMaxProfileSz);
        if (szPrinter[0] == '\0')
            {
            goto BailOut;
            }
        ParseDeviceSz(szDevSpec, &pchPort, &pchDriver);
        }

GotPrinter:
    /* Save the names of the printer, printer driver, and the port. */
    if (FNoHeap(hszPrinter = (CHAR (**)[])HAllocate(cwsz =
      CwFromCch(CchSz(szPrinter)))))
        {
        goto NoHszPrinter;
        }
    blt(szPrinter, &(**hszPrinter)[0], cwsz);
    if (FNoHeap(hszPrDriver = (CHAR (**)[])HAllocate(cwsz =
      CwFromCch(CchSz(pchDriver)))))
        {
        goto NoHszPrDriver;
        }
    blt(pchDriver, &(**hszPrDriver)[0], cwsz);
    if (FNoHeap(hszPrPort = (CHAR (**)[])HAllocate(cwsz =
      CwFromCch(CchSz(pchPort)))))
        {
        FreeH(hszPrDriver);
NoHszPrDriver:
        FreeH(hszPrinter);
NoHszPrinter:
        hszPrinter = hszPrDriver = hszPrPort = NULL;
        return (FALSE);
        }
    blt(pchPort, &(**hszPrPort)[0], cwsz);

    return (TRUE);
    }


int ParseDeviceSz(sz, ppchPort, ppchDriver)
CHAR sz[];
CHAR **ppchPort;
CHAR **ppchDriver;
    {
    /* This routine takes a string that came from the "device" entry in the user
    profile and returns in *ppchPort and *ppchDriver pointers to the port and
    driver sutible for a CreateDC() call.  If no port is found in the string,
    *ppchPort will point to a string containing the name of the null device.
    This routine returns the number of ports for this printer (separated by null
    characters in the string pointed at by *ppchPort).  NOTE: sz may be modified
    by this routine, and the string at *ppchPort may not be a substring of sz
    and should not be modified by the caller. */

    extern CHAR stBuf[];
    extern CHAR szNul[];
    CHAR *index(CHAR *, int);
    CHAR *bltbyte(CHAR *, CHAR *, int);

    register CHAR *pch;
    int cPort = 0;

    /* Remove any leading spaces from the string. */
    for (pch = &sz[0]; *pch == ' '; pch++);

    /* The string starts with the driver name. */
    *ppchDriver = pch;

    /* The next space or comma terminates the driver name. */
    for ( ; *pch != ' ' && *pch != ',' && *pch != '\0'; pch++);

    /* If the string does not have a port associated with it, then the port
    must be the null device. */
    if (*pch == '\0')
        {
        /* Set the port name to "None". */
        *ppchPort = &szNul[0];
        cPort = 1;
        }
    else
        {
        /* As far as we can tell, the port name is valid; parse it from the
        driver name. */
        if (*pch == ',')
            {
            *pch++ = '\0';
            }
        else
            {
            /* Find that comma separating the driver and the port. */
            *pch++ = '\0';
            for ( ; *pch != ',' && *pch != '\0'; pch++);
            if (*pch == ',')
                {
                pch++;
                }
            }

        /* Remove any leading spaces from the port name. */
        for ( ; *pch == ' '; pch++);

        /* Check to see if there is really a port name. */
        if (*pch == '\0')
            {
            /* Set the port name to "None". */
            *ppchPort = &szNul[0];
            cPort = 1;
            }
        else
            {
            /* Set the pointer to the port name. */
            *ppchPort = pch;

            while (*pch != '\0')
                {
                register CHAR *pchT = pch;

                /* Increment the number of ports found for this printer. */
                cPort++;

                /* Remove any trailing spaces from the port name. */
                for ( ; *pchT != ' ' && *pchT != ','; pchT++)
                    {
                    if (*pchT == '\0')
                        {
                        goto EndFound;
                        }
                    }
                *pchT++ = '\0';
                pch = pchT;

                /* Remove any leading spaces in the next port name. */
                for ( ; *pchT == ' '; pchT++);

                /* Throw out the leading spaces. */
                bltbyte(pchT, pch, CchSz(pchT));
                }
EndFound:;
            }
        }

    /* Parse the ".drv" out of the driver. */
    {
      extern CHAR  szExtDrv[];
    if ((pch = index(*ppchDriver, '.')) != 0
         && FRgchSame(pch, szExtDrv, CchSz (szExtDrv) - 1))
        {
        *pch = '\0';
        }
    }

    return (cPort);
    }


SetPrintConstants()
    {
    /* This routine sets the scaling/aspect constants for the printer described
    in vhDCPrinter. */

    extern HDC vhDCPrinter;
    extern BOOL vfPrinterValid;
    extern int dxpPrPage;
    extern int dypPrPage;
    extern int dxaPrPage;
    extern int dyaPrPage;
    extern int dxpLogInch;
    extern int dypLogInch;
    extern int ypSubSuperPr;

    if (vfPrinterValid && vhDCPrinter != NULL)
        {
        POINT rgpt[2];

        /* Get the dimensions of the printer in pixels. */
        dxpPrPage = rgpt[1].x = GetDeviceCaps(vhDCPrinter, HORZRES);
        dypPrPage = rgpt[1].y = GetDeviceCaps(vhDCPrinter, VERTRES);

        /* Put the printer in twips mode to find the dimensions in twips. */
        SetMapMode(vhDCPrinter, MM_TWIPS);
        rgpt[0].x = rgpt[0].y = 0;
        DPtoLP(vhDCPrinter, (LPPOINT)rgpt, 2);

#if WINVER >= 0x300
/* Weird Win bug that we can't decide on the corrective action -- sometimes
   DPtoLP returns x8000 here!  What's that mean?  Well it's SUPPOSED to be
   a large negative number ..pault */
        
        if (rgpt[1].x == 0x8000)
            rgpt[1].x = -(0x7fff);
        if (rgpt[1].y == 0x8000)
            rgpt[1].y = -(0x7fff);
#endif
        
        if ((dxaPrPage = rgpt[1].x - rgpt[0].x) < 0)
            {
            dxaPrPage = -dxaPrPage;
            }
        if ((dyaPrPage = rgpt[0].y - rgpt[1].y) < 0)
            {
            dyaPrPage = -dyaPrPage;
            }
        SetMapMode(vhDCPrinter, MM_TEXT);
        }
    else
        {
        /* Pretend the printer is just like the screen. */
        dxaPrPage = dyaPrPage = czaInch;
        dxpPrPage = dxpLogInch;
        dypPrPage = dypLogInch;
        }

    /* ypSubSuperPr is the offset for subscript and supercript font on the
    printer. */
    ypSubSuperPr = MultDiv(yaSubSuper, dypPrPage, dyaPrPage);
    }


GetPrinterDC(fDC)
BOOL fDC;
    {
    /* This routine sets vhDCPrinter to a new printer DC or IC.  If fDC is TRUE,
    a new DC is created; otherwise, a new IC is created.  In addition, all
    global variables dependent on the printer DC are changed. */

    extern HDC vhDCPrinter;
    extern BOOL vfPrinterValid;
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];
    extern HWND hParentWw;
    extern int docCur;
    extern struct DOD (**hpdocdod)[];
    extern BOOL vfWarnMargins;
    extern BOOL vfInitializing;
    extern PRINTDLG PD;  

    BOOL fCreateError = FALSE;
    
    
    /* We now pass the local PrinterSetup settings to CreateDC/CreateIC
       since Write's settings can differ from the global ones ..pault */
    LPSTR lpDevmodeData=NULL;

    Assert(vhDCPrinter == NULL);

    /* Get a new printer DC. */
#ifdef WIN30
    if (hszPrinter != NULL && hszPrDriver != NULL && hszPrPort != NULL)
        /* We used to only do this check if vfPrinterValid -- don't 
           now because otherwise one has no way to get Write to believe
           it has a valid printer! ..pt */
#else
    if (vfPrinterValid && hszPrinter != NULL && hszPrDriver != NULL && 
        hszPrPort != NULL)
#endif
        {
        HDC (far PASCAL *fnCreate)() = fDC ? CreateDC : CreateIC;

        StartLongOp();

        if (PD.hDevMode == NULL)
            fnPrGetDevmode(); // get PD.hDevMode

        lpDevmodeData = MAKELP(PD.hDevMode,0);

        if ((vhDCPrinter = (*fnCreate)((LPSTR)&(**hszPrDriver)[0],
          (LPSTR)&(**hszPrinter)[0], (LPSTR)&(**hszPrPort)[0], lpDevmodeData)) !=
          NULL)
            {
            EndLongOp(vhcIBeam);
            vfPrinterValid = TRUE;
            }
        else
            {
            /* If we thought the DC was valid, then we better tell the user it
            is not. */
            EndLongOp(vhcIBeam);
            fCreateError = TRUE;
            goto NoDC;
            }
        }
    else
        {
NoDC:
        /* We don't have a printer DC, so use the DC for the screen. */
        vhDCPrinter = GetDC(hParentWw);
        vfPrinterValid = FALSE;

        /* Warn the user if necessary.  This is done after creating the printer
        DC because Error() may force the DC to be created if we had not already
        done so. */
        if (fCreateError)
            {
            BOOL fInit = vfInitializing;

            vfInitializing = FALSE;
#ifdef	DBCS		/* was in JAPAN */
/*	   We have to answer to WM_WININICHANGE immidiately to ReleaseDC with 
**   'dispatch' printer driver.
**      So It's possible for us opening MessageBox deep in SendMessage 
**    call. This code avoid that.. Yutakan.
*/
            if( !InSendMessage() )
#endif
            Error(IDPMTCantPrint);
            vfInitializing = fInit;
            }
        }

    /* Set new values for the "constants" used by this printer. */
    SetPrintConstants();

    /* Set the size of the paper for this printer. */
    SetPageSize();
    vfWarnMargins = FALSE;

    /* The printer may have changed in such a way that it's fonts have changed
    (i.e. portrait to landscape).  We must re-initialize our list of fonts. */
    ResetDefaultFonts(TRUE);
    if (hpdocdod != NULL)
        {
        Assert((**hpdocdod)[docCur].hffntb != NULL);
        (*(**hpdocdod)[docCur].hffntb)->fFontMenuValid = FALSE;
        }
    }


SetPageSize()
    {
    /* Change the size of the paper to the printer described by vhDCPrinter. */

    extern HDC vhDCPrinter;
    extern HWND vhWndMsgBoxParent;
    extern BOOL vfPrinterValid;
    extern typeCP cpMinHeader;
    extern typeCP cpMacHeader;
    extern typeCP cpMinFooter;
    extern typeCP cpMacFooter;
    extern int dxpPrPage;
    extern int dypPrPage;
    extern int dxaPrPage;
    extern int dyaPrPage;
    extern HWND hParentWw;
    extern struct SEP vsepNormal;
    extern struct DOD (**hpdocdod)[];
    extern int docMac;
    extern int docScrap;
    extern int docUndo;
    extern BOOL vfWarnMargins;

    unsigned xaMac;
    unsigned yaMac;
    unsigned dxaRight;
    unsigned dyaBottom;
    unsigned dyaRH2;
    unsigned dxaPrRight = 0;
    unsigned dyaPrBottom = 0;
    BOOL fRH;
    register struct DOD *pdod;
    int doc;
    HWND hWnd;

    if (hpdocdod == NULL || docMac == 0)
        {
        /* Nothing to do if there are no documents. */
        return;
        }

    Assert(vhDCPrinter);
    if (vfPrinterValid && vhDCPrinter != NULL)
        {
        POINT pt;

        /* Get the page size of the printer. */
        if (Escape(vhDCPrinter, GETPHYSPAGESIZE, 0, (LPSTR)NULL, (LPSTR)&pt))
            {
            xaMac = MultDiv(pt.x, dxaPrPage, dxpPrPage);
            yaMac = MultDiv(pt.y, dyaPrPage, dypPrPage);
            }
        else
            {
            /* The printer won't tell us it page size; we'll have to settle
            for the printable area. */
            xaMac = ZaFromMm(GetDeviceCaps(vhDCPrinter, HORZSIZE));
            yaMac = ZaFromMm(GetDeviceCaps(vhDCPrinter, VERTSIZE));
            }

        /* The page size cannot be smaller than the printable area. */
        if (xaMac < dxaPrPage)
            {
            xaMac = dxaPrPage;
            }
        if (yaMac < dyaPrPage)
            {
            yaMac = dyaPrPage;
            }

        /* Determine the offset of the printable area on the page. */
        if (Escape(vhDCPrinter, GETPRINTINGOFFSET, 0, (LPSTR)NULL, (LPSTR)&pt))
            {
            dxaPrOffset = MultDiv(pt.x, dxaPrPage, dxpPrPage);
            dyaPrOffset = MultDiv(pt.y, dyaPrPage, dypPrPage);
            }
        else
            {
            /* The printer won't tell us what the offset is; assume the
            printable area is centered on the page. */
            dxaPrOffset = (xaMac - dxaPrPage) >> 1;
            dyaPrOffset = (yaMac - dyaPrPage) >> 1;
            }
        }
    else
        {
        /* Assume standard page size for now. */
        xaMac = cxaInch * 8 + cxaInch / 2;
        yaMac = cyaInch * 11;
        dxaPrOffset = dyaPrOffset = 0;
        }

    /* Determine the right and bottom margins for the "normal" page. */
    dxaRight = vsepNormal.xaMac - vsepNormal.xaLeft - vsepNormal.dxaText;
    dyaBottom = vsepNormal.yaMac - vsepNormal.yaTop - vsepNormal.dyaText;
    dyaRH2 = vsepNormal.yaMac - vsepNormal.yaRH2;

    /* Determine the minimum dimensions of the printed page. */
    if (vfPrinterValid)
        {
        dxaPrRight = imax(0, xaMac - dxaPrOffset - dxaPrPage);
        dyaPrBottom = imax(0, yaMac - dyaPrOffset - dyaPrPage);

        hWnd = vhWndMsgBoxParent == NULL ? hParentWw : vhWndMsgBoxParent;

#ifdef BOGUS
        /* Check the margins of the "normal" page. */
        fRH = cpMacHeader - cpMacHeader > ccpEol || cpMacFooter - cpMinFooter >
          ccpEol;
        if (vfWarnMargins && (FUserZaLessThanZa(vsepNormal.xaLeft, dxaPrOffset)
          || FUserZaLessThanZa(dxaRight, dxaPrRight) ||
          FUserZaLessThanZa(vsepNormal.yaTop, dyaPrOffset) ||
          FUserZaLessThanZa(dyaBottom, dyaPrBottom) || (fRH &&
          (FUserZaLessThanZa(vsepNormal.yaRH1, dyaPrOffset) ||
          FUserZaLessThanZa(dyaRH2, dyaPrBottom)))))
            {
            /* One of the margins is bad, tell the user about it. */
            ErrorBadMargins(hWnd, dxaPrOffset, dxaPrRight, dyaPrOffset,
              dyaPrBottom);
            vfWarnMargins = FALSE;
            }
#endif /* BOGUS */

        }

    /* Reset the dimensions of the "normal" page. */
    vsepNormal.xaMac = xaMac;
    vsepNormal.dxaText = xaMac - vsepNormal.xaLeft - umax(dxaRight, dxaPrRight);
    vsepNormal.yaMac = yaMac;
    vsepNormal.dyaText = yaMac - vsepNormal.yaTop - umax(dyaBottom,
      dyaPrBottom);
    vsepNormal.yaRH2 = yaMac - umax(dyaRH2, dyaPrBottom);

    /* Reset the page dimensions for all documents. */
    for (doc = 0, pdod = &(**hpdocdod)[0]; doc < docMac; doc++, pdod++)
        {
        if (pdod->hpctb != NULL && pdod->hsep != NULL)
            {
            /* Reset the existing section properties. */
            register struct SEP *psep = *(pdod->hsep);

            /* Determine the right and bottom margins for this page. */
            dxaRight = psep->xaMac - psep->xaLeft - psep->dxaText;
            dyaBottom = psep->yaMac - psep->yaTop - psep->dyaText;
            dyaRH2 = psep->yaMac - psep->yaRH2;

            /* Check the margins for this document. */
            if (vfWarnMargins && vfPrinterValid && doc != docScrap && doc !=
              docUndo && (FUserZaLessThanZa(psep->xaLeft, dxaPrOffset) ||
              FUserZaLessThanZa(dxaRight, dxaPrRight) ||
              FUserZaLessThanZa(psep->yaTop, dyaPrOffset) ||
              FUserZaLessThanZa(dyaBottom, dyaPrBottom) || (fRH &&
              (FUserZaLessThanZa(psep->yaRH1, dyaPrOffset) ||
              FUserZaLessThanZa(dyaRH2, dyaPrBottom)))))
                {
                ErrorBadMargins(hWnd, dxaPrOffset, dxaPrRight, dyaPrOffset,
                  dyaPrBottom);
                vfWarnMargins = FALSE;
                pdod = &(**hpdocdod)[doc];
                psep = *(pdod->hsep);
                }

            /* Set the dimensions of this page. */
            psep->xaMac = xaMac;
            psep->dxaText = xaMac - psep->xaLeft - dxaRight;
            psep->yaMac = yaMac;
            psep->dyaText = yaMac - psep->yaTop - dyaBottom;
            psep->yaRH2 = yaMac - dyaRH2;
            }

        /* Invalidate any caches for this document. */
        InvalidateCaches(doc);
        }
    }



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\select.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* select.c -- MW selection routines */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOWNDCLASS
#define NOICON
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOBITMAP
#define NOBRUSH
#define NOCOLOR
#define NODRAWTEXT
#define NOMB
#define NOPOINT
#define NOMSG
#include <windows.h>
#include "mw.h"
#include "toolbox.h"
#include "docdefs.h"
#include "editdefs.h"
#include "dispdefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "ch.h"
#include "fmtdefs.h"
#include "propdefs.h"
#ifdef DBCS
#include "DBCS.h"
#endif

extern int      vfSeeSel;
extern typeCP       vcpFirstParaCache;
extern typeCP       vcpLimParaCache;
extern typeCP       vcpFetch;
extern CHAR     *vpchFetch;
extern int      vccpFetch;
extern typeCP       cpMinCur;
extern typeCP       cpMacCur;
extern struct SEL   selCur;
extern int      docCur;
extern struct FLI   vfli;
extern struct WWD   rgwwd[];
extern int      vfSelHidden;
extern int      wwCur;
extern struct CHP   vchpFetch;
extern struct PAP   vpapAbs;
extern struct WWD   *pwwdCur;
extern int      vfInsEnd;
extern typeCP       CpBeginLine();
extern int      vfPictSel;
extern int      vfSizeMode;
extern struct CHP   vchpNormal;
extern int      vfInsertOn;
extern struct CHP   vchpSel;    /* Holds the props when the selection
                        is an insert point */
extern int vfMakeInsEnd;
extern typeCP vcpSelect;
extern int vfSelAtPara;
/* true iff the last selection was made by an Up/Down cursor key */
extern int vfLastCursor;
extern int vfDidSearch;
extern typeCP cpWall;


/* C P  L I M  S T Y */
typeCP CpLimSty(cp, sty)
typeCP cp;
int sty;
{    /* Return the first cp which is not part of the same sty unit */
    typeCP CpLastStyChar(), CpLimStySpecial();
    int wb, ch, ich;
    struct EDL *pedl;

    if (cp >= cpMacCur)
        { /* Endmark is own unit */
        return cpMacCur;
        }

    if (cp < cpMinCur)
        cp = cpMinCur;

    switch (sty)
        {
        int dl;
    default:
        Assert( FALSE );
    case styNil:
        return cp;

    case styPara:
        CachePara(docCur, cp);
        if (vcpLimParaCache > cpMacCur)
            { /* No EOL at end of doc */
            return cpMacCur;
            }
        return vcpLimParaCache;
    case styChar:
        /* Because CpLastStyChar() could be returning cpMacCur already. */
        cp = CpLastStyChar( cp ) + 1;
        return ((cp <= cpMacCur) ? cp : cpMacCur);
#ifdef BOGUS
        /* This portion never gets executed...  Why is it in here! */
        CachePara(docCur, cp);
        if (vpapAbs.fGraphics /* && cp > vcpFirstParaCache */)
            return vcpLimParaCache;
#ifdef CRLF
        FetchCp(docCur, cp, 0, fcmChars + fcmNoExpand);
        return *vpchFetch == chReturn ? cp + 2 : cp + 1;
#else /* not CRLF */
        return cp + 1;
#endif
#endif

    case styLine:
        CpBeginLine(&dl, cp);   /* Scrolls cp vertically into view */
        pedl = &(**wwdCurrentDoc.hdndl) [dl];
        return CpMin(pedl->cpMin + pedl->dcpMac, cpMacCur);
    case styDoc:
        return cpMacCur;
    case styWord:
    case stySent:
#ifdef DBCS
        return CpLimStySpecial( CpFirstSty(cp, styChar), sty );
#else
        return CpLimStySpecial( cp, sty );
#endif /* DBCS */
        }

    Assert( FALSE );
}




typeCP  CpLastStyChar( cp )
typeCP cp;
{       /* Return the last cp of the styChar containing cp */
        /* This will be == cp except for pictures & CR-LF  */
        /* And the second byte of DBCS char's.             */

#ifdef DBCS
    typeCP  CpFirstSty();
    CHAR    chRetained;
#endif

    if (cp >= cpMacCur)
            /* Endmark is own unit */
        return cpMacCur;

    if (cp < cpMinCur)
        cp = cpMinCur;

        /* Check for picture */
    CachePara(docCur, cp);
    if (vpapAbs.fGraphics)
        return vcpLimParaCache-1;

        /* Check for CR-LF */
        /* This checking for CR-LF first based on the carriage return */
        /* works only becasue the chReturn is outside of the DBCS     */
        /* range.                             */
#ifdef CRLF
        FetchCp(docCur, cp, 0, fcmChars + fcmNoExpand);
#ifdef DBCS
        if ((chRetained = *vpchFetch) == chReturn) {
        return cp + 1;
        }
        else {
        if (CpFirstSty(cp, styChar) != cp) {
            return cp; /* cp is pointing to the second byte of DBCS. */
            }
        else {
            /* First byte of DBCS or a regular ASCII char. */
            return (IsDBCSLeadByte(chRetained) ? cp + 1 : cp);
            }
        }
#else
        return *vpchFetch == chReturn ? cp + 1 : cp;
#endif /* DBCS */
#else
        return cp;
#endif

}



/* C P  F I R S T  S T Y */
typeCP CpFirstSty(cp, sty)
typeCP cp;
int sty;
{ /* Return the first cp of this sty unit. */
    typeCP CpFirstStySpecial();
    typeCP cpBegin;
    int wb, ch, dcpChunk;
    typeCP cpSent;
    CHAR rgch[dcpAvgSent];
    int ich;
    typeCP cpT;

    if (cp <= cpMinCur)
        return cpMinCur;
    else if (cp >= cpMacCur)
        switch(sty)
            {
            case styNil:
            case styChar:
            return cpMacCur; /* Endmark is own unit */
            default:
            break;
            }

    CachePara( docCur, cp );

    switch (sty)
        {
    default:
        Assert( FALSE );
    case styNil:
        return cp;
    case styPara:
        return vcpFirstParaCache;
    case styChar:
        if (vpapAbs.fGraphics)
            return vcpFirstParaCache;
#ifdef CRLF
        {
        typeCP cpCheckReturn;
        typeCP cpMinScan;

        cpCheckReturn = CpMax( cp, (typeCP) 1) - 1;
#ifdef DBCS
        /* Save vcpFirstParaCache, because it could be changed
           by FetchCp() */
        cpMinScan = vcpFirstParaCache;
#endif /* DBCS */
        FetchCp( docCur, cpCheckReturn, 0, fcmChars + fcmNoExpand );
#ifdef DBCS
        /* This works because chReturn is outside of DBCS range. */
        if (*vpchFetch == chReturn) {
            return cpCheckReturn;
            }
        else {
            typeCP  cpT;
            typeCP  cpRgMin;
            int     ichMacRgch;
            BOOL    fBreakFound;
            int     fkCur;

            cpT = cp;
            do {
            cpRgMin = CpMax( cpT - dcpAvgSent, cpMinScan);
            FetchRgch(&ichMacRgch, rgch, docCur, cpRgMin, cpT,
                  dcpAvgSent);
            ich = ichMacRgch - 1;
            fBreakFound = FALSE;
            while (ich >= 0 && !fBreakFound) {
                if (!IsDBCSLeadByte(rgch[ich])) {
                fBreakFound = TRUE;
                }
                else {
                ich--;
                }
                }
            cpT = cpRgMin;
            } while (!fBreakFound && cpRgMin > cpMinScan);
            if (fBreakFound) {
            ich++;
            }
            else {
            ich = 0;
            }
            fkCur = fkNonDBCS;
            cpT = cpRgMin + ichMacRgch;
            do {
            while (ich < ichMacRgch) {
                 if (fkCur == fkDBCS1) {
                /* Last rgch[] ended with the first byte
                   of a DBCS character. */
                fkCur = fkNonDBCS;
                }
                 else if (IsDBCSLeadByte(rgch[ich])) {
                if (ich + 1 < ichMacRgch) {
                    fkCur = fkNonDBCS;
                    ich++;
                    }
                else {
                    fkCur = fkDBCS1;
                    }
                }
                 else {
                fkCur = fkNonDBCS;
                }
                ich++;
                }
            cpRgMin = cpT;
            cpT += dcpAvgSent;
            if (cpT <= cp) { /* Saves some time. */
                FetchRgch(&ichMacRgch, rgch, docCur, cpRgMin, cpT,
                      dcpAvgSent);
                ich = 0;
                }
            } while (cpT <= cp);

            if (fkCur == fkDBCS1) {
            Assert(cp - 1 <= cpMacCur);
            return (cp - 1);
            }
            else {
            Assert(cp <= cpMacCur);
            return (cp);
            }
            }
#else
        return *vpchFetch == chReturn ? cpCheckReturn : cp;
#endif /* DBCS */
        }
#else
        return cp;
#endif
    case styDoc:
        return cpMinCur;
    case styLine:
        {
        int dlJunk;

        return CpBeginLine( &dlJunk, cp );
        }
    case styWord:
    case stySent:
#ifdef DBCS
        return CpFirstStySpecial( CpFirstSty(cp, styChar), sty );
#else
        return CpFirstStySpecial( cp, sty );
#endif /* DBCS */
        }
    Assert( FALSE );
}




/* S E L E C T */
/* used to make a selection from a cp-interval, for example after a find. */
Select(cpFirst, cpLim)
typeCP cpFirst, cpLim;
{ /* Make a selection */
 typeCP cpFirstOld = selCur.cpFirst;
 typeCP cpLimOld = selCur.cpLim;
 int fOldCursorLine;

 if (cpFirst > cpLim)
    /*     The only time this condition should be true is when we have
       run out of memory.  The following is a senario where
       such is the case (and actually, the reason for this code change).
           Let us suppose that we have cut, pasted to the end of the
       document, and are now executing a "command a" (repeat last
       operation).  The procedure CmdAgain is invoked.  CmdAgain first
       calls replace in order to add the text to the document.  Now it
       must position the cursor properly by calling select.
           A SetUndo operation called by the prior paste gave us the
       number of bytes that were added to the document.  In its call
       to Select, CmdAgain assumes that where it wants to position the
       cursor is at the old last char position plus the SetUndo quantity
       mentioned above.  But, if the replace operation failed (due to
       lack of memory), CmdAgain may be trying to place the cursor beyond
       the physical end of the document.
           Other fixes of this problem, at the caller level (CmdAgain)
       instead of within Select, are probably "better" in the sense of
       programming clarity.  The chosen solution has the one advantage
       of programming expediency. */
    cpFirst = cpLim;
    /* This statement replaces "Assert(cpFirst <= cpLim);" */

    vfInsEnd = fFalse;
/* notation:    + add highlight
        - remove highlight
        .. leave alone
        00 common portion
*/
    if (!vfSelHidden)
    {
    if (cpFirst < cpFirstOld)
        { /* +++... */
        if (cpLim <= cpFirstOld)
        { /* +++   --- */
        goto SeparateSels;
        }
        else
        { /* +++000... */
        ToggleSel(cpFirst, cpFirstOld, true);
        if (cpLim < cpLimOld)
            { /* +++000--- */
            ToggleSel(cpLim, cpLimOld, false);
            }
        else if (cpLim > cpLimOld)
            { /* +++000+++ */
            ToggleSel(cpLimOld, cpLim, true);
            }
/* Handle the case when old selection was an insert bar */
        if (cpFirstOld == cpLimOld)
            ToggleSel(cpFirstOld, cpLimOld, false);
        }
        }
    else
        { /* ---... */
        if (cpLimOld <= cpFirst)
        { /* --- +++ */
SeparateSels:
        fOldCursorLine = cpFirstOld == cpLimOld;
/* prevent flashing if insert point which is ON is repeatedly selected */
/* conditions are: not repeated, not insert point, not ON, not at desired end of line */
        vfInsEnd = vfMakeInsEnd;
        if ( cpFirst != cpFirstOld || cpLim != cpLimOld ||
            !fOldCursorLine || !vfInsertOn ||
            selCur.fEndOfLine != vfMakeInsEnd)
            {
            selCur.fEndOfLine = vfMakeInsEnd;
            if (fOldCursorLine)
            ClearInsertLine();
/* old selection is off if it was a cursor line */
            ToggleSel(cpFirst, cpLim, fTrue);
/* otherwise the old selection is turned off AFTER the new one is made to
make it look faster */
            if (!fOldCursorLine)
            ToggleSel(cpFirstOld, cpLimOld, fFalse);
            }
        }
        else
        { /* ---000... */
        if (cpLimOld < cpLim)
            { /* ---000+++ */
            ToggleSel(cpLimOld, cpLim, true);
            }
        else if (cpLimOld > cpLim)
            { /* ---000--- */
            ToggleSel(cpLim, cpLimOld, false);
            }
        ToggleSel(cpFirstOld, cpFirst, false);
        }
        }
    }

 selCur.cpFirst = cpFirst;
 selCur.cpLim = cpLim;
 selCur.fForward = cpFirst != cpMacCur;
 if (cpFirst == cpLim)
    {
    GetInsPtProps(cpFirst);
    vfDidSearch = FALSE; /* reestablish for searching */
    cpWall = cpLim;
    }
 vfLastCursor = vfSizeMode = vfPictSel = vfMakeInsEnd = false;

 /* Set vfPictSel iff the selection is exactly one picture */

 CachePara( docCur, selCur.cpFirst );
 if (vpapAbs.fGraphics && selCur.cpLim == vcpLimParaCache)
    vfPictSel = TRUE;

}




/* G E T  I N S  P T  P R O P S */
GetInsPtProps(cp)
typeCP cp;
{     /* determine properties of the insertion point */

if (cpMacCur != cpMinCur)
    {
    CachePara(docCur, cp);
    if (vcpFirstParaCache == cpMacCur)
        {
            /* cp is in the last para--use preceding para props */
        CachePara(docCur, vcpFirstParaCache - 1);
        if (vpapAbs.fGraphics)
            {   /* Yet another 10 point kludge -- get default props
               when typing after a picture at doc end */

            goto Default;
            }
        }
    if (vpapAbs.fGraphics)
        /* 10 point kludge: make typing before picture non-vchpNormal */
        goto Default;

    FetchCp(docCur, CpMax(vcpFirstParaCache, cp - 1), 0, fcmProps);
    blt(&vchpFetch, &vchpSel, cwCHP);
    if (vchpFetch.fSpecial && vchpFetch.hpsPos != 0)
        { /* if this char is a footnote or page marker, then ignore */
        vchpSel.hpsPos = 0;       /* super/subscript stuff. */
        vchpSel.hps = HpsAlter(vchpSel.hps, 1);
        }
    vchpSel.fSpecial = FALSE;
    }
else
    {
Default:
    /* force default character properties, font size to be 10 point */
    blt(&vchpNormal, &vchpSel, cwCHP);
    vchpSel.hps = hpsDefault;
    }
}




/* C H A N G E  S E L */
ChangeSel(cp, sty)
typeCP cp;
int sty;
{   /* Make selCur move, expand or contract to cp */
    /* sty is unit to keep in case of movement or flipped selection */
    /* styChar is not supported; it is munged to styNil */
    /* This is because the Write/Word user interface never asks us to */
    /* pivot the selection around a single character, we pivot around */
    /* an insertion point ("styNil") instead */
    int     fNullSelection = (selCur.cpFirst == selCur.cpLim);
    typeCP  cpFirst = selCur.cpFirst;
    typeCP  cpLim = selCur.cpLim;
    int     fForward = selCur.fForward;
    typeCP  cpOffFirst, cpOffLim, cpOnFirst, cpOnLim;

    if (sty == styChar)
    sty = styNil;

    if (cp == cpMinCur - 1 || cp > cpMacCur)
    { /* Trying to flip off the beginning or end */
    _beep();
    return;
    }

    cpOffFirst = cpOffLim = cpOnFirst = cpOnLim = cpNil;

    if (cp <= cpFirst)
    { /* Extend backwards */
    if (cp == cpLim)
        return;
    if (fForward && !fNullSelection)
    { /* Selection flipped */
        if (vfPictSel)
        /* stuck this in to 'correct' behaviour when select pict and
           drag up.  Don't want to unselect first pict (4.22.91) v-dougk */
        {
            cpOnFirst = CpFirstSty( cp, sty);
            cpOffFirst = cpOffLim = cpLim;
        }
        else
        {
            cpOffFirst = selCur.cpLim = CpMin(cpLim, CpLimSty(cpFirst, sty));
            cpOnFirst = CpFirstSty( cp, sty);
            cpOffLim = cpLim;
        }
    }
    else
        {
        if ( fNullSelection )
        cpOffLim = cpOffFirst = selCur.cpFirst;
        cpOnFirst = CpFirstSty( cp, styChar );
        if (cpFirst == cpOnFirst)
        return;
        }
    selCur.fForward = false;

    cpOnLim = cpFirst;
    selCur.cpFirst = cpOnFirst;
    }
    else if (cp >= cpLim)
    { /* Extend forwards */
    if (cp == cpFirst)
        return;
    if (!fForward && !fNullSelection)
        { /* Selection flipped */
        cpOffLim = selCur.cpFirst =
        CpMax( cpFirst, CpFirstSty( (sty ==styNil) ? cpLim : cpLim-1,
                         sty ));
        cpOnLim = CpLimSty(cp, sty);
        cpOffFirst = cpFirst;
        }
    else
        {
        if ( fNullSelection )
        cpOffLim = cpOffFirst = selCur.cpFirst;
        cpOnLim = cp;
        if (cpLim == cpOnLim)
        return;
        }
    selCur.fForward = true;

    cpOnFirst = cpLim;
    selCur.cpLim = cpOnLim;
    if (cpOnLim == cpLim && cpOffLim != cpLim)
        cpOnLim = cpNil;
    }
    else if (fForward)
    { /* Shrink a forward selection */
    cpOffFirst = cp;
    if (selCur.cpLim == cpOffFirst)
        return;
    selCur.cpLim = cpOffFirst;
    cpOffLim = cpLim;
    }
    else
    { /* Shrink a backward selection */
    cpOffLim = cp;
    if (selCur.cpFirst == cpOffLim)
        return;
    selCur.cpFirst = cpOffLim;
    cpOffFirst = cpFirst;
    }

    ToggleSel(cpOnFirst, cpOnLim, true);
    ToggleSel(cpOffFirst, cpOffLim, false);

    /* Check for a stray insert point */

    if (selCur.cpFirst != selCur.cpLim)
    ClearInsertLine();

    /* Set vfPictSel iff the selection is exactly one picture */

    CachePara( docCur, selCur.cpFirst );
    vfPictSel = vpapAbs.fGraphics && (selCur.cpLim == vcpLimParaCache);
}




/* S E L E C T  D L  X P */
SelectDlXp(dl, xp, sty, fDrag)
int dl, xp, sty;
int fDrag;
{ /* Move cursor to the nearest valid CP and select unit */
    typeCP cp;
    typeCP cpFirst;
    typeCP cpLim;
    register struct EDL *pedl;
    int xpStart = xpSelBar - wwdCurrentDoc.xpMin;
    int itcMin, itcLim;
    int xpLeft;
    int xpPos;
    int fPictInsertPoint=FALSE; /* Setting an insert point before a pict */

    UpdateWw(wwCur, false);        /* Synchronize cursor & text */

    xp = max(0, xp - xpStart);
    dl = min( wwdCurrentDoc.dlMax - 1, dl );

    pedl = &(**wwdCurrentDoc.hdndl) [dl];
    cp = pedl->cpMin;

    /* At or Below EMark */
    if (cp >= cpMacCur)
        {
        cp = cpMacCur;
        goto FoundCp;
        }

    if (pedl->fGraphics)
        {  /*
        Special kludge for selecting a picture:
            Select the whole picture (if the hit is inside or to the
                   right of the picture)
            Select an insert point just before the picture if the hit
            is to the left of the picture OR in the selection bar
            when the picture is left-justified) */
        if ( (xp < pedl->xpLeft) || (sty == styLine && xp == 0) )
            fPictInsertPoint = TRUE;

        goto FoundCp;
        }

    if (sty >= styPara)
        { /* Selecting a paragraph, line, doc */
        goto FoundCp;
        }

    /* Must Format to figure out the right cp */

    FormatLine(docCur, cp, pedl->ichCpMin, cpMacCur, flmSandMode); /*HM*/

    CachePara(docCur, cp);
    pedl = &(**wwdCurrentDoc.hdndl) [dl];

    if (vfli.fSplat) /* Selecting in division/page break */
        {
        cp = vfli.cpMin;
        goto FoundCp;
        }

    xpLeft = pedl->xpLeft;

    if (vfli.xpLeft != xpLeft)
        /* This indicates that we are in lo memory conditions; in trouble */
        return;
    /* Assert (vfli.xpLeft == xpLeft); May not be true in lo memory */

    if (xp <= xpLeft)
        {
        itcMin = 0;
        goto FoundCp;
        }

    /* Out of bounds right */
    if (xp >= pedl->xpMac)
        {
        itcMin = vfli.cpMac - cp - 1;
        cp = vfli.cpMac - 1;
        goto CheckPastPara;
        }

    /* Search through the line for the cp at position xp */
    xpPos = xpLeft;
    itcMin = 0;
    itcLim = vfli.cpMac - cp;

    while (itcMin < itcLim && xpPos < xp)
        xpPos += vfli.rgdxp[itcMin++];

    if (itcMin >= 1)
        /* This may not be true if we are so low on memory that
           FormatLine could not do its job */
        itcMin--;

    cp += itcMin;

    CachePara(docCur, cp);
    if ((xpPos < xp + vfli.rgdxp[itcMin] / 2) &&
        (sty == styChar /* || !fDrag */) )
        { /* Actually selecting next character */
    CheckPastPara:
        if (cp + 1 == vcpLimParaCache && !vpapAbs.fGraphics &&
                        (vfSelAtPara || vcpSelect == cpNil))
            /* Return insert point before paragraph mark */
            {
            if (vcpSelect == cpNil)
                vfSelAtPara = true;
            goto FoundCp;
            }
        itcMin++;
        cp++;
        }
//T-HIROYN sync win3.0
#ifdef  DBCS
    /* if itcMin point the second char of kanji, increment itcMin */
    if (itcMin < itcLim && vfli.rgdxp[itcMin]==0)
        goto CheckPastPara; /* Select next character */
#endif /* DBCS */

FoundCp:
        /* Set up selection limits */
    cpFirst = CpFirstSty( cp, sty );
    cpLim = CpLimSty( cp, sty );

    if (sty == styChar)
        {
        if ( !pedl->fGraphics || fPictInsertPoint )
          /* In text or before a pic: don't extend to end of styChar */
        cpLim = cpFirst;

        if ( vcpSelect == cpNil )
        {   /* First time through, remember where we started */

        /* Set if we want to kludge the insert point at the end of *pedl */

        vfMakeInsEnd = (cp == pedl->cpMin + pedl->dcpMac &&
                   cp <= cpMacCur &&
                   !pedl->fGraphics &&
                   !pedl->fSplat);
        vcpSelect = cpFirst;
        }
        }

    if (fDrag)
        ChangeSel( selCur.fForward ? cpLim : cpFirst, sty );
    else
        Select( cpFirst, cpLim );
}




typeCP CpEdge()
{ /* Return edge of selection */
    return selCur.fForward ?
        CpMax( CpFirstSty( selCur.cpLim - 1, styChar ), selCur.cpFirst ) :
        selCur.cpFirst;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\selectsp.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/


#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCTLMGR
#define NOWINMESSAGES
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#include "windows.h"

#include "mw.h"
#include "cmddefs.h"
#include "fmtdefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "prmdefs.h"
#include "editdefs.h"
#include "macro.h"
#include "str.h"
#if defined(OLE)
#include "obj.h"
#endif

/* E X T E R N A L S     */

extern int            vstyCur;
extern int            docCur;
extern typeCP         vcpLimParaCache;
extern struct SEL     selCur;
extern struct PAP     vpapAbs;
extern struct SEL     selPend;
extern struct UAB     vuab;
extern struct CHP     vchpFetch;
extern struct CHP     vchpSel;
extern int            docUndo;
extern int            ferror;
extern typeCP         cpMinCur;
extern typeCP         cpMacCur;
extern int            vfObjSel;




/* L O O K S  M O U S E */
LooksMouse()
{
        int cch;
        char rgb[cchPAP + 2];

        if (vstyCur == styPara || vstyCur == styLine)
                { /* Copy paragraph looks */
                  /* MEMO Version: no effect on tab table */
                int itbd;
                CachePara(docCur, selCur.cpFirst);

#ifdef CASHMERE
                for (itbd = 0; vpapAbs.rgtbd[itbd].dxa != 0; itbd++);
                rgb[1] = (cwPAPBase + (itbd + 1) * cwTBD) * cchINT;
                bltbyte(&vpapAbs, &rgb[2], rgb[1]);
#else
                blt( &vpapAbs, &rgb[2], rgb[1] = cwPAPBase );
#endif
                rgb[0] = sprmPSame;
                Select(selPend.cpFirst, selPend.cpLim);
                AddOneSprm(rgb, fTrue);
                vuab.uac = uacLookParaMouse;
                }
        else
                { /* Copy character looks */
                struct CHP chpT;
                FetchCp(docCur, CpMax(cp0, selCur.cpFirst - 1), 0, fcmProps);
                chpT = vchpFetch;
                Select(selPend.cpFirst, selPend.cpLim);
                vchpSel = chpT;
                if (selPend.cpFirst == selPend.cpLim)
                        return;
                bltbyte(&vchpSel, &rgb[1], cwCHP * cchINT);
                rgb[0] = sprmCSame;
                AddOneSprm(rgb, fTrue);
                vuab.uac = uacLookCharMouse;
                }

        SetUndoMenuStr(IDSTRUndoLook);
}




/* C O P Y  M O U S E */
CopyMouse()
{
        typeCP cpDest, cpSrc, dcp;
        int fKludge = false;

        if (selPend.cpFirst == selPend.cpLim)
                return;

        if (FWriteOk(fwcInsert))
                {
                cpDest = selCur.cpFirst;
                dcp = selPend.cpLim - (cpSrc = selPend.cpFirst);

/*-----         SetUndo(uacInsert, docCur, cpDest, dcp, docNil, cpNil, cp0, 0);--*/
        /* ReplaceCps can't deal with copies from/to the same doc, so use undo
                        buffer as intermediate storage */
                NoUndo();

                ClobberDoc(docUndo, docCur, cpSrc, dcp);
                if (ferror)
                    return;
                else if (!FCheckPicture(&cpDest, dcp, true, docCur))
                    SetUndo(uacInsert, docCur, cpDest, dcp, docNil, cpNil, cp0, 0);

                ReplaceCps(docCur, cpDest, cp0, docUndo, cp0, dcp);
                if (ferror)
                    {
                    NoUndo();
                    return;
                    }
                else 
                {
#if defined(OLE)
                    ObjEnumInRange(docCur,cpDest,cpDest+dcp,ObjCloneObjectInDoc);
#endif
                    if (cpDest >= cpMinCur && cpDest + dcp <= cpMacCur)
                            Select(cpDest, cpDest + dcp);
                }
                }


        SetUndoMenuStr(IDSTRUndoEdit);
}




/* M O V E  M O U S E */
MoveMouse()
{
        typeCP cpSrc, dcp, cpDest;

        if (selPend.cpFirst == selPend.cpLim)
                return;

        if (FWriteOk(fwcInsert))
                {
                cpDest = selCur.cpFirst;
                dcp = selPend.cpLim - (cpSrc = selPend.cpFirst);
                if (FMoveText(docCur, cpSrc, dcp, docCur, &cpDest, fTrue))
                    SetUndoMenuStr(IDSTRUndoEdit);
                }
}





/* F  M O V E  T E X T */
int FMoveText(docSrc, cpSrc, dcp, docDest, pcpDest, fSetUndo)
int docSrc, docDest, fSetUndo;
typeCP cpSrc, dcp, *pcpDest;
{ /* returns true unless moving into yourself */
        int fT;
        typeCP cpT, cpMacT;

        Assert(docSrc == docDest);

            /* Same document; use undo buffer as intermediary */
        if (*pcpDest >= cpSrc && *pcpDest < cpSrc + dcp
#ifdef FOOTNOTES
                || *pcpDest >= CpFirstFtn(docSrc, cpSrc, &fT) &&
                  *pcpDest < CpFirstFtn(docSrc, cpSrc + dcp, &fT)
#endif
           )
                        {
                        Error(IDPMTBadMove);
                        return false;
                        }
        ClobberDoc(docUndo, docSrc, cpSrc, dcp);
        if (ferror)
                return false;

        if (FCheckPicture(pcpDest, dcp, false, docDest))
                if (cpSrc >= *pcpDest)
                        cpSrc += (typeCP)ccpEol;

/* cpMacT will measure the total adjustment incurred by the following replace
as it may be different from dcp-cp0 (e.g. due to Eol inserted in front of
a picture
*/
        cpMacT = cpMacCur;
        ReplaceCps(docDest, *pcpDest, cp0, docUndo, cp0, dcp);
        cpT = *pcpDest;
        if (docDest == docSrc)
                {
                if (cpT < cpSrc)
                        cpSrc += cpMacCur - cpMacT;
                else /* cpT >= cpSrc */
                        cpT -= cpMacCur - cpMacT;
                }
        /* Now delete old text */
        Replace(docSrc, cpSrc, dcp, fnNil, fc0, fc0);

        if (ferror)
            {
            NoUndo();
            return FALSE;
            }
        else
            {
            if (docDest == docCur && cpT >= cpMinCur && cpT + dcp <= cpMacCur)
                Select(cpT, cpT + dcp);
            if (fSetUndo)
                SetUndo(uacMove, docCur, cpSrc, dcp, docCur, cpT, cp0, 0);
            }
        return true;
}




/* F  C H E C K  P I C T U R E */

int FCheckPicture(pcpDest, dcp, fSetUndo, doc)
typeCP *pcpDest, dcp;
int fSetUndo;
int doc;
{
        typeCP cpDest = *pcpDest;
        CachePara(docUndo, cp0);
        if (vpapAbs.fGraphics && cpDest > cp0)
                { /* Special case for inserting a picture paragraph */
                CachePara(doc, cpDest - 1);
                if (vcpLimParaCache == cpDest + 1 && vcpLimParaCache < cpMacCur)
/* this special case is here to move the insertion point from 1 char away
from a para boundary (a common point to select) to the boundary so that
we do not have to insert an ugly extra cr. This does not apply at the
end of the document */
                        {
                        *pcpDest += 1;
                        return fFalse;
                        }
                if (vcpLimParaCache != cpDest)
                        {
                        if (fSetUndo)
                                SetUndo(uacInsert, doc, cpDest, dcp + (typeCP)ccpEol,
                                        docNil, cpNil, cp0, 0);
                        InsertEolPap(doc, cpDest, &vpapAbs);
                        *pcpDest += (typeCP)ccpEol;
                        return true;
                        }
                }
        return false;
}




/* C H E C K  M O V E */
CheckMove()
{
if(vuab.doc == vuab.doc2)
        {
        /* same doc means we might have to worry about shifting cp's */
        if (vuab.cp < vuab.cp2)
                vuab.cp2 -= vuab.dcp;
        else if (vuab.cp > vuab.cp2)
                vuab.cp += vuab.dcp;
#ifdef DEBUG
        else
                Assert(false);
#endif
        }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\select2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Select2.c -- Less-frequently-used selection routines */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOWNDCLASS
#define NOICON
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOBITMAP
#define NOBRUSH
#define NOCOLOR
#define NODRAWTEXT
#define NOMB
#define NOPOINT
#define NOMSG
#include <windows.h>
#include "mw.h"
#include "toolbox.h"
#include "docdefs.h"
#include "editdefs.h"
#include "dispdefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "ch.h"
#include "fmtdefs.h"
#include "propdefs.h"

extern int		vfSeeSel;
extern typeCP		vcpFirstParaCache;
extern typeCP		vcpLimParaCache;
extern typeCP		vcpFetch;
extern CHAR		*vpchFetch;
extern int		vccpFetch;
extern typeCP		cpMinCur;
extern typeCP		cpMacCur;
extern struct SEL	selCur;
extern int		docCur;
extern struct FLI	vfli;
extern struct WWD	rgwwd[];
extern int		vfSelHidden;
extern int		wwCur;
extern struct CHP	vchpFetch;
extern struct PAP	vpapAbs;
extern struct WWD	*pwwdCur;
extern int		vfInsEnd;
extern typeCP		CpBeginLine();
extern int		vfPictSel;
extern int		vfSizeMode;
extern struct CHP	vchpNormal;
extern int		vfInsertOn;
extern struct CHP	vchpSel;	/* Holds the props when the selection
						is an insert point */
extern int vfMakeInsEnd;
extern typeCP vcpSelect;
extern int vfSelAtPara;
/* true iff the last selection was made by an Up/Down cursor key */
extern int vfLastCursor;



/* C P	L I M  S T Y  S P E C I A L */
typeCP CpLimStySpecial(cp, sty)
typeCP cp;
int sty;
{    /* Return the first cp which is not part of the same sty unit */
	int wb, ch, ich;
	struct EDL *pedl;

	/* Other cases covered in CpLimSty, our only caller */

	Assert( cp < cpMacCur );
	Assert( cp >= cpMinCur );
	Assert( sty == styWord || sty == stySent );

/* Special kludge for picture paragraphs */
	CachePara(docCur, cp);
	if (vpapAbs.fGraphics)
		return vcpLimParaCache;

	FetchCp(docCur, cp, 0, fcmChars + fcmNoExpand);

	Assert(vccpFetch != 0);

	/* Must be word or sentence */
	wb = WbFromCh(ch = vpchFetch[ich = 0]);
#ifdef CRLF
	if (ch == chReturn)
		return vcpFetch + 2;
#endif
	if (ch == chEol || ch == chSect || ch == chNewLine || ch == chTab)
		/* EOL is its own unit */
		return vcpFetch + 1;

	if (wb == wbWhite && sty == stySent)
		{ /* Might be between sentences; go back to text */
		FetchCp(docCur, CpFirstSty(cp, styWord), 0, fcmChars + fcmNoExpand);
		wb = WbFromCh(ch = vpchFetch[ich = 0]);
		}

	for (;;)
		{
		if (++ich >= vccpFetch)
			{ /* Get next line and set up */
			FetchCp(docNil, cpNil, 0, fcmChars);
			if (vcpFetch == cpMacCur)
				return cpMacCur; /* End of doc */
			ich = 0;
			}
		if (sty == stySent)
			switch (ch)
				{
			case chDot:
			case chBang:
			case chQMark:
				sty = styWord;
				wb = wbPunct;
				}
		switch (ch = vpchFetch[ich])
			{
		case chTab:
		case chEol:
		case chSect:
		case chNewLine:
#ifdef CRLF
		case chReturn:
#endif
			goto BreakFor;
			}
		if (sty == styWord)
			{ /* Word ends after white space or on text/punct break */
			int wbT = WbFromCh(ch);
			if (wb != wbT && (wb = wbT) != wbWhite)
				break;
			}
		}
	BreakFor:
	return vcpFetch + ich;
}



/* C P	F I R S T  S T Y  S P E C I A L */
typeCP CpFirstStySpecial(cp, sty)
typeCP cp;
int sty;
{ /* Return the first cp of this sty unit. */
	typeCP cpBegin;
	int wb, ch, dcpChunk;
	typeCP cpSent;
	CHAR rgch[dcpAvgSent];
	int ich;
	typeCP cpT;

	/* Other cases were covered by CpFirstSty, our only caller */

	Assert( cp > cpMinCur );
	Assert( sty == stySent || sty == styWord );

	if (cp >= cpMacCur)
	    cpT = cp = cpMacCur;
	else
	    cpT = cp++;

	CachePara(docCur, cpT );
	if ((vcpFirstParaCache == cpT) || vpapAbs.fGraphics)
	    return vcpFirstParaCache;

	dcpChunk = (sty == styWord) ? dcpAvgWord : dcpAvgSent;
	cpBegin = (cp > dcpChunk) ? cp - dcpChunk : cp0;

	FetchRgch(&ich, rgch, docCur, cpBegin, cp, dcpChunk);
	wb = WbFromCh(ch = rgch[--ich]);

#ifdef CRLF
	if(cpBegin + ich == 0)
	    return cp0;

	if (ch == chEol && rgch[ich-1] == chReturn) /* EOL is its own unit */
	    return cpBegin + ich - 1;
	if (ch == chEol || ch == chReturn || ch == chSect || ch == chNewLine || ch == chTab)
	    return cpBegin + ich;
#else /* not CRLF */
	if (ch == chEol || ch == chSect || ch == chNewLine || ch == chTab) /* EOL is its own unit */
	    return cpBegin + ich;
#endif /* CRLF */

	if (wb == wbText)
		cpSent = cpBegin + ich;
	else
		cpSent = cpNil;

	for (;;)
		{
		if (ich == 0)
			{
			if (cpBegin == cpMinCur)
				return cpMinCur; /* beginning of doc */
			cpBegin = (cpBegin > dcpChunk) ? cpBegin - dcpChunk : cp0;
			FetchRgch(&ich, rgch, docCur, cpBegin, cp, dcpChunk);
			}
		ch = rgch[--ich];
		CachePara( docCur, cpBegin + ich ); /* Needed for pictures */
		if (ch == chEol || ch == chSect || ch == chNewLine ||
				   ch == chTab || vpapAbs.fGraphics )
			break; /* EOL Always ends a unit */
		if (sty == styWord)
			{
			if (wb != wbWhite)
				{
				if (WbFromCh(ch) != wb)
					break;
				}
			else
				wb = WbFromCh(ch);
			}
		else
			{ /* Test for sentence. */
			switch (ch)
				{
			case chDot:
			case chBang:
			case chQMark:
				if (cpSent != cpNil)
					return cpSent;
				}
			switch (WbFromCh(ch))
				{
			case wbText:
				cpSent = cpBegin + ich;
				wb = wbText;
				break;
			case wbPunct:
				switch (wb)
					{
				case wbWhite:
					wb = wbPunct;
					break;
				case wbText:
					cpSent = cpBegin + ich;
					}
				break;
			case wbWhite:
				if (wb == wbPunct)
					cpSent = cpBegin + ich + 1;
				wb = wbWhite;
				break;
				}
			}
		}
	return cpBegin + ich + 1;
}



/* W B	F R O M  C H */
int WbFromCh(ch)
int ch;
{ /* Return word-breakness of ch */

	switch (ch)
		{
	case chSpace:
	case chEol:
#ifdef CRLF
	case chReturn:
#endif
	case chSect:
	case chTab:
	case chNewLine:
	case chNBSFile:
		return wbWhite;
	case chNRHFile:
		return wbText;
	default: /* we are using the ANSI char set that windows used */
		return ((isalpha(ch) || isdigit(ch))? wbText : wbPunct);
		}
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\str.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* IDSTRs and IDPMTs are in 5 different groups,
   the high byte is for masking, see MB_ERRxxxx definitions */

#define MB_ERRMASK               0xf000
#define MB_ERRASTR               0x1000
#define MB_ERREXCL               0x2000
#define MB_ERRQUES               0x3000
#define MB_ERRHAND               0x4000

#ifndef NOSTRUNDO
/* NONERROR group, from 0x0001 -- 0x0fff */
/*    Menu and Undo strings */
#define IDSTRUndoBase            0x0001
#define IDSTRUndoEdit            0x0002
#define IDSTRUndoLook            0x0003
#define IDSTRUndoTyping          0x0004
#define IDSTRShowRuler           0x0005
#define IDSTRHideRuler           0x0006
#define IDSTRAbout               0x0007
#define IDSTREdit                0x0008
#define IDSTRCancel              0x0009
#define IDSTRPopupVerbs          0x000A
#define IDSTRSingleVerb          0x0010

    /* UNDO menu string lengths, including terminator */
#define cchSzUndo   (25)

#endif  /* NOSTRUNDO */



#define IDSTRHELPF               0x000b
#define IDSTRChangeSel           0x000c
#define IDSTRChangeAll           0x000d

#define IDSTRChPage              0x000e
#define IDSTRLoading             0x000f

#define IDSTROn                  0x0013
#define IDSTRReplaceFile         0x0016
#define IDSTRChars               0x0017
#define IDSTRSearching           0x0018

#define IDS_MERGE1               0x0019

#define IDSTRConvertText         0x001a
#define IDSTRConvertWord         0x001b

/* OLE strings */
#if defined(OLE)
#define IDSTRMenuVerb   0x0020
#define IDSTRLinkProperties     0x0021
#define IDSTRAuto               0x0022
#define IDSTRManual             0x0023
#define IDSTRFrozen             0x0024
#define IDSTREmbedded           0x0025
#define IDSTRFilter             0x0026
#define IDSTRExtension          0x0027
#define IDSTRAllFilter          0x0028
#define IDSTRRename             0x0029
#define IDSTRServer             0x002A
#define IDSTRInsertfile         0x0032
#define IDSTRChangelink         0x0033
#define IDSTRUpdate             0x0034
#define IDSTRMenuVerbP  0x0035
#endif

/* commdlg strings */
#define IDSTROpenfile           0x0060
#define IDSTRSavefile           0x0061
#define IDSTRDefWriExtension    0x0062
#define IDSTRDefDocExtension    0x0063
#define IDSTRDefTxtExtension    0x0064
#define IDSTRTxtDescr           0x0065
#define IDSTRWriDescr           0x0066
#define IDSTRDocDescr           0x0067
#define IDSTRDocTextDescr       0x0068
#define IDSTROldWriteDescr      0x0069
#define IDSTRAllFilesDescr      0x006a


#define IDSTRBitmap             0x006b
#define IDSTRPicture            0x006c
#define IDSTRDIB                0x006d
#define IDSTRText               0x006e
#define IDSTRBackup             0x006f
#define IDSTRObject             0x0070

#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
#define IDSTRZen1               0x0071
#define IDSTRZen2               0x0072
#endif

/* See ErrorLevel() -- error messages are grouped as follows and then
                       we can quickly determine the severity of an error */

/***** FOLLOWING MESSAGES ARE "*" LEVEL MESSAGES */
/* MB_ERRASTR group, from 0x1000 -- 0x1fff */

#define IDPMTSearchDone          0x1000
#define IDPMTNotFound            0x1001
#define IDPMTNoReplace           0x1002
#define IDPMTCancelSearch        0x1003


/***** FOLLOWING MESSAGES ARE "?" LEVEL MESSAGES */
/* MB_ERRQUES group, from 0x3000 -- 0x3fff */

#define IDPMTAddFont             0x3000
#define IDPMTTruncateSz          0x3001
#define IDPMTConvert             0x3002

#if defined(JAPAN) || defined(KOREA)                  // added  09 Jun. 1992  by Hiraisi
#define IDPMTFontChange          0x3003
#endif

/***** FOLLOWING MESSAGES ARE "!" LEVEL MESSAGES */
/* MB_ERREXCL group, from 0x2000 -- 0x2fff */

#ifndef NOSTRERRORS
#define IDPMTBadFileName         0x202c
#define IDPMTRottenFile          0x202b
#define IDPMTBadFile             0x2006
#define IDPMTCantOpen            0x2019
#define IDPMTDirtyDoc            0x201a
#define IDPMTCantRunM            0x201b
#define IDPMTCantRunF            0x2021
#define IDPMTNoPath              0x201c
#define IDPMTFileNotFound        0x201f
#define IDPMTReadOnly            0x2020
#define IDPMTCantRead            0x202d
#define IDPMTDelObjects          0x2029
#define IDPMTDelPicture          0x202a
#define IDPMTRenameFail          0x2023
#define IDPMTOverwrite           0x2026
#define IDPMTCantShare           0x2027
#if defined(OLE)
#define IDPMTGetFromClipboardFailed         0x2102
#define IDPMTFailedToFreeze                 0x2103
#define IDPMTFailedToLaunchServer           0x2104
#define IDPMTFailedToActivate               0x2105
#define IDPMTFailedToUpdate                 0x2106
#define IDPMTFailedToDeleteObject               0x2108
#define IDPMTServerBusy                         0x2109
#define IDPMTFailedToUpdateLink             0x210b
#define IDPMTImproperLinkOptionsError       0x210c
#define IDPMTFailedToCommWithServer         0x210d
#define IDPMTFailedToReadObject             0x210e
#define IDPMTFailedToCreateObject               0x210f
#define IDPMTFailedToDraw                   0x2110
#define IDPMTInsufficientResources          0x2111
#define IDPMTOLEError                       0x2112
#define IDPMTFileContainsObjects            0x2113
#define IDPMTFailedToLoadObject             0x2114
#define IDSTRFinishObject                   0x2115
#define IDPMTLinkUnavailable                 0x2116
#define IDPMTFormat                         0x2117
#define IDPMTStatic                         0x2118
#define IDSTRUpdateObject                   0x2119
#define IDPMTLinksUnavailable               0x211b
#define IDPMTCutOpenEmb                     0x211c
#define IDPMTExitOpenEmb                    0x211d
#define IDPMTSaveOpenEmb                    0x211e
#define IDPMTDeleteOpenEmb                  0x211f
#define IDPMTInsertOpenEmb                  0x2120
#endif

/*    Dialog field errors */

#define IDPMTNoPage              0x2007
#define IDPMTNOTNUM              0x2008
#define IDPMTBFS                 0x2009
#define IDPMTNPI                 0x200a
#define IDPMTNOTDXA              0x200b
#define IDPMTNPDXA               0x200c
#define IDPMTMTL                 0x200d
#define IDPMTBadFilename         0x200e

#define IDPMT2Complex            0x200f
#define IDPMTBadMove             0x2010
#define IDPMTDFULL               0x2012
#define IDPMTPRFAIL              0x2013
#define IDPMTClipLarge           0x2017
#define IDPMTClipQuest           0x201e
#define IDPMTBadPrinter          0x2018
#define IDPMTCantPrint           0x2022
#define IDPMTPrPictErr           0x2024
#define IDPMTPrDiskErr           0x2025
#define IDPMTDFULLScratch        0x2028

/***** FOLLOWING MESSAGES ARE "<hand>" LEVEL MESSAGES */
/* MB_ERRHAND group, from 0x4000 -- 0x4fff */

#define IDPMTSDE                 0x4000
#define IDPMTSDN                 0x4001
#define IDPMTNoMemory            0x4002
#define IDPMTSFER                0x4003
#define IDPMTMEM                 0x4004
#define IDPMTWinFailure          0x4005
#define IDPMTSDE2                0x4006
#define IDPMTFloppyback          0x4007
#define IDPMTFileback            0x4008
#if defined(JAPAN)               // added  01/21/93 T-HIROYN
#define IDPMTNoMemorySel         0x4009
#endif
#endif        /* NOSTRERRORS */


/***** FOLLOWING MESSAGES ARE EX-GLOBDEFS.H MESSAGES */

#define IDSTRModeDef                        0x7000

#define IDSTRWriteDocPromptDef              0x7001
#define IDSTRScratchFilePromptDef           0x7002
#define IDSTRSaveFilePromptDef              0x7003
#define IDSTRAppNameDef                     0x7004
#define IDSTRUntitledDef                    0x7005

#define IDSTRiCountryDefaultDef             0x7006

#define IDSTRWRITETextDef                   0x7007

#define IDSTRFreeDef                        0x7008

#define IDSTRNoneDef                        0x7009

#define IDSTRHeaderDef                      0x700a
#define IDSTRFooterDef                      0x700b

#define IDSTRLoadFileDef                    0x700c
#define IDSTRCvtLoadFileDef                 0x700d

#define IDSTRInchDef                        0x700e
#define IDSTRCmDef                          0x700f
#define IDSTRP10Def                         0x7010
#define IDSTRP12Def                         0x7011
#define IDSTRPointDef                       0x7012
#define IDSTRLineDef                        0x7013
#define IDSTRAltBSDef                       0x7014

#if defined(JAPAN) || defined(KOREA) //T-HIROYN Win3.1
/* default FontFaceName we use FInitFontEnum() */
#define IDSdefaultFFN0                      0x7091
#define IDSdefaultFFN1                      0x7092
#define IDPMTNotKanjiFont                   0x7093
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\toolbox.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* extracted from original toolbox.h */

#define srcCopy         0       /* Destination = Source                 */
#define srcOr           1       /* Destination = Source OR Destination  */
#define srcXor          2       /* Destination = Source XOR Destination */
#define srcBic          3       /* Destination = Source BIC Destination */
#define notSrcCopy      4       /* Destination = NOT(Source)            */
#define notSrcOr        5       /* Destination = NOT(Source) OR Dest    */
#define notSrcXor       6       /* Destination = NOT(Source) XOR Dest   */
#define notSrcBic       7       /* Destination = NOT(Source) BIC Dest   */
#define patCopy         8       /* Destination = Pattern                */
#define patOr           9       /* Destination = Pattern OR Dest        */
#define patXor          10      /* Destination = Pattern XOR Dest       */
#define patBic          11      /* Destination = Pattern BIC Dest       */
#define notPatCopy      12      /* Destination = NOT(Pattern)           */
#define notPatOr        13      /* Destination = NOT(Pattern) OR Dest   */
#define notPatXor       14      /* Destination = NOT(Pattern) XOR Dest  */
#define notPatBic       15      /* Destination = NOT(Pattern) BIC Dest  */

typedef int *WORDPTR;
typedef WORDPTR WINDOWPTR;
typedef WORDPTR MENUHANDLE;
typedef HANDLE RGNHANDLE;
typedef HANDLE CTRLHANDLE;

typedef struct {
	int ascent;
	int descent;
	int widMax;
	int leading;
} FONTINFO;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\stcdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* stcdefs.h -- definitions of styles */

#define usgCharMin      0
#define usgParaMin      11
#define usgSectMin      26
#define usgMax          33
#define usgCharNormal   0

#define stcNormal       0
#define stcParaMin      30
#define stcSectMin      105
#define stcMax          128

#define stcFtnRef       13
#define stcFolio	19
#define stcFtnText      39
#define stcRunningHead  93

#define cchMaxRemark    28
#define ccpSshtEntry    (1 + 2 + cchMaxRemark + 1)
#define cchMaxStc       40      /* Length of longest usage-variant pair */

/* Fetch Style Modes */
#define fsmDiffer       0
#define fsmSame         1
#define fsmAny          2

struct CHP *PchpFromStc();
struct PAP *PpapFromStc();
struct SEP *PsepFromStc();


struct SYTB
	{ /* Style table */
	int             mpstcbchFprop[stcMax];
	CHAR            grpchFprop[2]; /* Variable size */
	};

#define cwSYTBBase      stcMax

struct SYTB **HsytbCreate();


struct AKD
	{ /* ALT-Key Descriptor */
	CHAR            ch;
	unsigned             fMore : 1;
	unsigned             ustciakd : 7;
	};

#define cchAKD  (sizeof (struct AKD))
#define cwAKD   (cchAKD / sizeof (int))

/* max length of strings used in usages and font names */
#define cchIdstrMax	32

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\trans3.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* trans3.c: more save routines, moved here from trans2.c because of compiler
 heap space errors */

#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOMSG
#define NOKEYSTATE
#define NOSHOWWINDOW
//#define NOGDI
#define NOFONT
#define NOBRUSH
#define NOBITMAP
//#define NOATOM
#define NOMETAFILE
#define NOPEN
#define NOPOINT
#define NORECT
#define NOREGION
#define NOHRGN
#define NOCOLOR
#define NODRAWTEXT
//#define NOTEXTMETRIC
#define NOWINOFFSETS
#define NOCREATESTRUCT
#define NOWH
#define NOSOUND
#define NOSCROLL
#define NOCOMM
#define NOWNDCLASS
/* need memmgr, mb */
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "editdefs.h"
#include "printdef.h"
#define NOSTRUNDO
#include "str.h"
#include "debug.h"
#include "fontdefs.h"
#include "dlgdefs.h"
#include "winddefs.h"
#include "macro.h"
#include "preload.h"
#include "io.h"
#if defined(OLE)
#include "obj.h"
#endif

#define WRITE_PERMISSION 02 /* flag to access() */

CHAR    *index( CHAR *, CHAR );
CHAR    *PchGetPn();
CHAR    *PchFromFc();
static int fOpenedFormatted = TRUE;
int   vfOldWriteFmt=FALSE;  /* delete objects before saving */
DoFileOpen( LPSTR );

BOOL CheckEnableButton(HANDLE, HANDLE);
BOOL NEAR PASCAL CanReadEveryFile(char *szFilename);

extern CHAR    szExtSearch[]; /* store default search spec */
extern CHAR szWriteProduct[];
extern CHAR szBackup[];
extern int vfTextOnlySave;

extern int         vfCursorVisible;
extern int         vfDiskError;
extern int         vfSysFull;
extern HWND        vhWndMsgBoxParent;
extern int         vfnWriting;
extern CHAR        (**vhrgbSave)[];
extern struct DOD      (**hpdocdod)[];
extern int         docCur;
extern int         docScrap;
extern int         docUndo;
extern struct FCB      (**hpfnfcb)[];
extern int         vfBuffersDirty;
extern int         vfDiskFull;
extern typeCP          vcpFetch;
extern CHAR        *vpchFetch;
extern int         vccpFetch;
extern typeCP          vcpLimParaCache;
extern int         vfDeactByOtherApp;
extern BOOL        vfWarnMargins;

#ifdef INTL /* International version */
extern int         vWordFmtMode;
#ifdef INEFFLOCKDOWN
extern FARPROC lpDialogWordCvt;
#else
extern BOOL far PASCAL DialogWordCvt(HWND, unsigned, WORD, LONG);
#endif
#endif  /* International version */

static unsigned wMerge;  /* for message merge code */

extern int         vfBackupSave;

extern int      ferror;
extern CHAR     szExtBackup[];
extern CHAR     (**hszTemp)[];
#ifdef INEFFLOCKDOWN
extern FARPROC lpDialogOpen;
extern FARPROC lpDialogSaveAs;
#endif


extern HANDLE  hMmwModInstance;
extern HANDLE  hParentWw;
extern HCURSOR vhcHourGlass;
extern HCURSOR vhcIBeam;
extern HCURSOR vhcArrow;

    /* Used in this module only */
static CHAR *pchSet;
static CHAR szUser[ cchMaxFile ]; /* store whatever is in idiOpenFile (ANSI) */

#define SF_OLDWRITE 0
#define SF_WORD     1
BOOL WannaDeletePictures(int doc, int fWhichFormat);
BOOL DocHasPictures(int doc);
NEAR DlgAddCorrectExtension(CHAR *, int);
BOOL  (NEAR FSearchSpec(CHAR *));
BOOL far PASCAL DialogOpen(HWND, unsigned, WORD, LONG);
BOOL far PASCAL DialogSaveAs(HWND, unsigned, WORD, LONG);


#ifdef INTL /* International version */
BOOL  FInWordFormat(int);
void ConvertFromWord();
#endif  /* International version */


fnOpenFile(LPSTR lpstrFileName) // filename may be NULL
{
 extern int vfCloseFilesInDialog;
 extern int docCur;
 extern HANDLE hMmwModInstance;
 extern HANDLE hParentWw;
 extern struct SEL selCur;
 extern typeCP cpMinDocument;

 /* Close all files on removable media for every message we get */
 vfCloseFilesInDialog = TRUE;

 /* Close all files on removable media so changing disks is safe */
 CloseEveryRfn( TRUE );

 /* test for dirty file and offer opportunity to save */

 if (FConfirmSave())
    DoFileOpen(lpstrFileName);

 vfCloseFilesInDialog = FALSE;
}

DoFileOpen( LPSTR lpstrFileName ) // filename may be NULL )
{
    /* return whether error.  Use CommDlg for open dialog (3.8.91) D. Kent */
    /* ********* International version changes bz 2/21/86 *************
    For files opened in Word format and converted to Write format
    the following changes are made:
       the vWordFmtMode flag is left set to CONVFROMWORD. The file is
       saved, effecting the change to Word format, but the original
       Word file in not renamed, so it is left untouched, with no need to
       make a backup. On the next save, we ask if the file with that name
       (the Word document) should be replaced, so any file with that
       name that existed will be protected.
    *************************************************************** */

    extern int vfDiskError;
    int fn=fnNil;
    int doc;
    CHAR (**hsz)[] = NULL;
    int nRetval=FALSE;
    CHAR rgch[cchMaxFile];
    extern DoOpenFilenameGet(LPSTR);
    BOOL bOpened=TRUE,      // ObjOpenedDoc has succeeded
         bCancelled=FALSE;

#ifdef INTL /* International version */
int fWordDoc;
#endif  /* International version */

    EnableOtherModeless(FALSE);

    /* prevent WM_PAINT from painting a doc that isn't defined */

    while(1)
    {
        bCancelled = FALSE;

        if (lpstrFileName)
            lstrcpy(rgch,lpstrFileName);
        else if (!DoOpenFilenameGet(rgch))
        {
            bCancelled = TRUE;
            goto KeepTrying;
        }
        else if (rgch[0] == '\0')
        {
            bCancelled = TRUE;
            goto KeepTrying;
        }

#if defined(OLE)
        if (bOpened) 
            if (ObjClosingDoc(docCur,rgch))
            /*  
                If this failed, then we could't close this document, much less
                open a new one.
            */
                break; // from while
            else
            /**
                At this point, docCur is OLE-closed!!!  Gotta be sure we
                open a new one!!! 
            **/
                bOpened = FALSE;
#endif


        if ((fn = FnOpenSz( rgch, dtyNormNoExt, FALSE)) == fnNil)
        /* this has side effect of setting &(**(**hpfnfcb) [fn].hszFile) [0] 
        to "normalized" filename. */
        {
            /* Open failed */
            goto KeepTrying;
        }
        else
        {   /* Opened file OK */
            /* Set caption to "Loading file..." */

            extern CHAR szLoadFile[];
            extern CHAR szCvtLoadFile[];

#ifdef INTL /* International version */
            /* **************************************
            * added check for international version to
                    do Word format conversion. If Word format,
                    bring up another dialog box.
            * ************************************** */

            /* TestWordCvt return values:

            -1 means dialog box failed (error already sent)
            -2 means cancel without conversion.
            FALSE means not a word document.
            TRUE means convert this word document.
            *** as of 2/14/86, we changed the conversion
            to not make a backup, but to save the file
            in write format without renaming the Word
            file, so the word file is effectively
            backed up under its original name. See
            CleanDoc in trans2.c for explanations.
            */

            switch ((fWordDoc = TestWordCvt (fn, hParentWw)))
            {
                case -2: // CANCEL
                    bCancelled = TRUE;
                    // fall through..

                case -1: // ERROR
                    /* Release this fn! */
                    FreeFn(fn);
                    CloseEveryRfn( TRUE );
                    goto KeepTrying;
            }

            /* if true, will convert soon */
            if (fWordDoc)
                {
                SetWindowText(hParentWw, (LPSTR)szCvtLoadFile);
                }
            else
#endif  /* International version */
                SetWindowText(hParentWw, (LPSTR)szLoadFile);

            StartLongOp();

            ReadFilePages( fn );
        }

        Assert( fn != fnNil );
        bltsz( &(**(**hpfnfcb) [fn].hszFile) [0], rgch );

        CchCopySz(rgch, szUser);

        hsz=NULL;

        if ( !FNoHeap(hsz = HszCreate( (PCH) rgch )) )
        {
            if ((doc = DocCreate( fn, hsz, dtyNormal )) != docNil)
            {   /* Succeeded in creating document */

                KillDoc( docCur );
                docCur = doc;
                hsz = NULL; // don't free cause used by doc

#ifdef INTL /* International version */
            /* if a word document to be converted, save it doing conversion. */
                if (fWordDoc)
                {
                    /* save file in write format. */
                    ConvertFromWord();
                    vfTextOnlySave = FALSE;
                    (**hpdocdod)[docCur].fDirty = TRUE;
                }
#endif  /* International version */

                ChangeWwDoc( szUser );
                /* Ensure that the margins of this document is right
                for the printer. */
                vfWarnMargins = TRUE;
                SetPageSize();
                vfWarnMargins = FALSE;
#if defined(OLE)
                if (ObjOpenedDoc(docCur)) 
                /* Couldn't open.  Must try to open a new one */
                    goto KeepTrying;
                else
                {
                    bOpened = TRUE;
                    break; // from while loop 'cause we're done
                }
#endif
            }
#if defined(JAPAN) || defined(KOREA)                  //  added  10 Jun. 1992  by Hiraisi
           else{
               bCancelled = TRUE;
               goto KeepTrying;
           }
#endif
        }

        KeepTrying:
        /* get to here either because error or cancelled */

        vfDiskError = ferror = FALSE;
        SetTitle( **(**hpdocdod)[ docCur ].hszFile );

        if (hsz)
        {
            FreeH( hsz );
            hsz=NULL;
        }

        CloseEveryRfn( TRUE );

        EndLongOp(vhcArrow);

        if (bCancelled)
        /* can't cancel unless we have an opened document */
        {
            if (!bOpened) // currently no open doc
            {
                if (bOpened = !ObjOpenedDoc(docCur)) // returns FALSE if success
                    break;
            }
            else
                break;
        }

    }  // end of while(1)


#if WINVER >= 0x300
    FreeUnreferencedFns();
#endif

    EndLongOp(vhcArrow);
    EnableOtherModeless(TRUE);
    return !bOpened;

} /* end of DoFileOpen */




fnSave()
{   /* Entry point for the "Save" command */
    extern int vfCloseFilesInDialog;
    extern int vfOutOfMemory;
    extern HANDLE vhReservedSpace;
                        
    struct DOD *pdod = &(**hpdocdod)[docCur];
    CHAR *psz = &(**(pdod->hszFile))[0];

    if (!CanReadEveryFile(psz))
        return;

#if WINVER >= 0x300
    if (pdod->fReadOnly)
        {
        /* Read-only doc: tell the user to save under a different name */

        Error( IDPMTReadOnly );
        ferror = FALSE; /* Not really an error */
        
        fnSaveAs();  /* May as well take them there now! ..pault 10/20/89 */
        }
    else if (psz [0] == '\0' || vWordFmtMode == CONVFROMWORD)
        /* Any time the user has converted the current Write document
           from a Word or Text document, we force them through the 
           FileSaveAs dlg box when Saving.  In this way we remind them
           that they might want to change the name -- but if they don't
           want to, that's ok and we'll not bother them any more about it
           (fnSaveAs dialog box will reset vWordFmtMode) ..pault 9/18/89 */
#else /* old windows */
    else if (psz [0] == '\0')
#endif
        fnSaveAs();
    else
        {

        if (vfOldWriteFmt || (vWordFmtMode & ~CONVFROMWORD) || vfTextOnlySave)
        /* then deleting pictures */
        {
            if (vfOldWriteFmt || vfTextOnlySave)
                vcObjects = ObjEnumInDoc(docCur,NULL);
            if (!WannaDeletePictures(docCur,vfOldWriteFmt ? SF_OLDWRITE : SF_WORD))
                return;
        }

        vfCloseFilesInDialog = TRUE;

        /* Close all files on removable media so changing disks is safe */

        CloseEveryRfn( TRUE );

        /* Free the reserved block, to give us memory for the save dialog box
           and for CmdXfSave */
        if (vhReservedSpace != NULL)
            {
            LocalFree(vhReservedSpace);
            vhReservedSpace = NULL;
            }

        PreloadSaveSegs();  /* Advance loading of code to avoid disk swaps */

        CmdXfSave(psz, pdod->fFormatted, pdod->fBackup, vhcIBeam);

        if (vfDiskFull || vfSysFull)
            ferror = FALSE;
#if defined(OLE)
        else
            ObjSavedDoc();
#endif

        if ((vhReservedSpace = LocalAlloc( LHND, cbReserve )) == NULL)
        /* we were unable to re-establish our block of reserved space. */
            Error(IDPMTNoMemory);

        vfCloseFilesInDialog = FALSE;
        }
}


fnSaveAs()
{   /* Entry point for the "Save As..." command */
extern int vfCloseFilesInDialog;
extern int vfOutOfMemory;
extern HANDLE vhReservedSpace;

    if (!CanReadEveryFile((**((**hpdocdod)[docCur].hszFile))))
        return;

    vfCloseFilesInDialog = TRUE;

    /* Close all files on removable media so changing disks is safe */
    CloseEveryRfn( TRUE );

    /* Free the reserved block, to give us memory for the save dialog box
       and for CmdXfSave */
    if (vhReservedSpace != NULL)
        {
        LocalFree(vhReservedSpace);
        vhReservedSpace = NULL;
        }

    PreloadSaveSegs();  /* Advance loading of code to avoid disk swaps */

    DoFileSaveAs();

     if ((vhReservedSpace = LocalAlloc( LHND, cbReserve )) == NULL)
        {   /* Either we were unable to bring up the save dialog
               box, or we were unable to re-establish our
               block of reserved space. */

#if WINVER >= 0x300
                    WinFailure();
#else
                    Error(IDPMTNoMemory);
#endif
        }

    UpdateInvalid();    /* Assure screen gets updated */

    vfCloseFilesInDialog = FALSE;
}


DoFileSaveAs(void)
{
    /* This routine handles input to the Save dialog box. */
    static CHAR szDefault[ cchMaxFile ];
    extern int vfTextOnlySave;
    extern DoSaveAsFilenameGet(LPSTR,LPSTR,int *,int *,int * ,int *);
    BOOL bDontDelPictures=FALSE;
    int fWordFmt, fTextOnly, fBackup, fOldWrite;
    CHAR szFullNameNewDoc[ cchMaxFile ];      // full name of selection
    CHAR szShortNameNewDoc[ cchMaxFile ];      // file name of selection
    CHAR szDocName[ cchMaxFile ];   // file name of current
    #define szFullNameCurDoc (**((**hpdocdod)[docCur].hszFile))  // full name of current
    #define pDod  ((struct DOD *)&(**hpdocdod)[docCur])

    {
        int cch = 0;
        CHAR szDOSPath[ cchMaxFile ];
        if (FNormSzFile( szDOSPath, "", dtyNormal ))
        {
            if ((cch=CchSz( szDOSPath )-2) > 2)
            {
                Assert( szDOSPath[ cch ] == '\\');
                szDOSPath [cch] = '\0';
            }

#if 0
            if (cch > 3)
                szDOSPath [cch] = '\\';
#endif
        }
        else
            szDOSPath[0] = '\0';

        if (szFullNameCurDoc [0] != '\0')
        {       /* Set default string for filename edit area */
            CHAR szDocPath[ cchMaxFile ];   // path to current

            FreezeHp();
            SplitSzFilename( szFullNameCurDoc, szDocPath, szDocName );

            /* Default filename does not include the document's path if
                it is == the current directory path */
            if (WCompSz( szDOSPath, szDocPath ) == 0)
                bltsz(szDocName, szDefault);
            else
                bltsz(szFullNameCurDoc, szDefault);

            MeltHp();
        }
        else
        {
            szDefault[0] = szDocName[0] = '\0';
        }
    }

    fTextOnly = vfTextOnlySave;
    fBackup = vfBackupSave;
    fWordFmt = vWordFmtMode & ~CONVFROMWORD;
    fOldWrite = vfOldWriteFmt;

    EnableOtherModeless(FALSE);

    while(1)
    {
    if (!DoSaveAsFilenameGet(szDefault,szFullNameNewDoc,&fBackup,&fTextOnly,&fWordFmt,&fOldWrite))
        goto end;
    else
    {
        int dty;

        if (szFullNameNewDoc[0] == '\0')
            goto end;

        if (fOldWrite || fWordFmt || fTextOnly)
        {
            if (!WannaDeletePictures(docCur,fOldWrite ? SF_OLDWRITE : SF_WORD))
                continue;
        }

        StartLongOp();

        szFileExtract(szFullNameNewDoc, szShortNameNewDoc);

#ifdef INTL /* International version */
        /* Read the "Microsoft Word Format" button */

        /* vWordFmtMode is used in WriteFn. If true, will convert
            to Word format, if false, no conversion is done.
            Another value, CONVFROMWORD, can be given during an open
            to allow saving a Word document in Write format. */

        if (fWordFmt)
        /* if set, make the default extension be doc instead of
            wri for word docs */

            dty = dtyWordDoc;
        else
#endif  /* International version */

        dty = dtyNormal;

#if WINVER >= 0x300            
/* Currently: FNormSzFile  *TAKES*   an OEM sz, and
                        *RETURNS*  an ANSI sz ..pault */
#endif
        if ( pDod->fReadOnly &&
                WCompSz( szFullNameNewDoc, szFullNameCurDoc ) == 0)
            {   /* Must save read-only file under a different name */
            Error( IDPMTReadOnly );
            goto NSerious;  /* Error not serious, stay in dialog */
            }
#if WINVER >= 0x300
        else if (WCompSz(szFullNameCurDoc, szFullNameNewDoc) == 0 &&
                    vWordFmtMode == CONVFROMWORD &&
                    vfTextOnlySave == fTextOnly)
            /* User has loaded a text file and is going
                to save under the same name without changing
                formats, *OR* has loaded a Word document and
                is going to save in the same format -- don't
                prompt "replace file?" ..pault 1/17/90 */
            ;
#endif
        else if ((WCompSz(szFullNameCurDoc, szFullNameNewDoc) != 0
#ifdef INTL /* International version */
                /* vWordFmtMode hasn't be reset yet */
                || ( vWordFmtMode == CONVFROMWORD)
#endif  /* International version */
                )
                && FExistsSzFile( dtyNormal, szFullNameNewDoc ) )
        {
            /* User changed the default string and specified
                a filename for which the file already exists.
                Or, we did a Word format conversion, forcing the .WRI
                extension on the file, and a file with that name
                exists.(International version only).o

                Note that vfWordFmtMode will be set to True or False
                below, so this check is made only on the first save
                after a Word conversion.

                Prompt to make sure it's ok to trash the existing one */

            CHAR szFileUp[ cchMaxFile  ];
            CHAR szUserOEM[cchMaxFile]; /* ..converted to OEM */
            CHAR szT[ cchMaxSz ];

            CchCopyUpperSz( szShortNameNewDoc, szFileUp );
            MergeStrings (IDSTRReplaceFile, szFileUp, szT);

#if WINVER >= 0x300
            /* access() expects OEM! */
            AnsiToOem((LPSTR) szFullNameNewDoc, (LPSTR) szUserOEM);

            /* Make sure we don't let someone try to save to 
                a file to which we do not have r/w permission */
            Diag(CommSzNum("fnSaveAs: access(write_perm)==", access(szUserOEM, WRITE_PERMISSION)));
            Diag(CommSzNum("          szExists()==", FExistsSzFile( dtyNormal, szFullNameNewDoc )));
            if (access(szUserOEM, WRITE_PERMISSION) == -1)
                {
                /* THIS COULD BE A CASE OF WRITING TO A FILE
                    WITH R/O ATTRIBUTE, *OR* A SHARING ERROR!
                    IMPROVE ERROR MESSAGE HERE ..pault 11/2/89 */                                
                //Error( IDPMTSDE2 );
                Error( IDPMTReadOnly );
                goto NSerious;  /* Error not serious, stay in dialog */
                }
#endif
            }

            vfTextOnlySave = fTextOnly;
            vfBackupSave = fBackup;
            vfOldWriteFmt = fOldWrite;

#ifdef INTL /* International version */
        /* vWordFmtMode is used in WriteFn. If true, will convert
            to Word format, if false, no conversion is done.
            Another value, CONVFROMWORD, can be given during an open
            to allow saving a Word document in Write format. */

            vWordFmtMode = fWordFmt;

#endif  /* International version */

        /* Record whether a backup was made or not. */

        WriteProfileString( (LPSTR)szWriteProduct, (LPSTR)szBackup,
                vfBackupSave ? (LPSTR)"1" : (LPSTR)"0" );

        /* Save the document */

        CmdXfSave( szFullNameNewDoc,!vfTextOnlySave, vfBackupSave, vhcArrow);

        if (vfDiskFull || vfSysFull)
            goto NSerious;

        /* Case 1: Serious error. Leave the dialog. */
        if (vfDiskError)
        {
            EndLongOp( vhcArrow );
            goto end;
        }

        /* Case 2: Saved OK: set the new title, leave the dialog. */
        else if (!WCompSz( szFullNameNewDoc, szFullNameCurDoc ))
            {
#if defined(OLE)
            ObjRenamedDoc(szFullNameNewDoc);
            ObjSavedDoc();
#endif

            SetTitle(szShortNameNewDoc);
#if WINVER >= 0x300
            FreeUnreferencedFns();
#endif

            /* Update the fReadOnly attribute (9.10.91) v-dougk */
            pDod->fReadOnly = FALSE; // can't be readonly if just saved

            EndLongOp( vhcArrow );
            goto end;
            }

        /* Case 3: Nonserious error (disk full, bad path, etc.).
                stay in dialog. */
        else
            {
NSerious:
            ferror = FALSE;
            EndLongOp( vhcArrow );
StayInDialog:
            CloseEveryRfn( TRUE );
            }
    }
    } // end of while(1)


    end:
    EnableOtherModeless(FALSE);


} /* end of DoFileSaveAs */


#ifdef INTL /* International version */

BOOL far PASCAL DialogWordCvt( hDlg, code, wParam, lParam )
HWND    hDlg;           /* Handle to the dialog box */
unsigned code;
WORD wParam;
LONG lParam;
{

    /* This routine handles input to the Convert From Word Format dialog box. */

 switch (code) {

 case WM_INITDIALOG:
     {
     char szFileDescrip[cchMaxSz];
     char szPrompt[cchMaxSz];

       /* do not allow no convert for formatted file */
     if (fOpenedFormatted)
         {
         //EnableWindow(GetDlgItem(hDlg, idiNo), false);
         PchFillPchId(szFileDescrip, IDSTRConvertWord, sizeof(szFileDescrip));
         }
     else
         PchFillPchId(szFileDescrip, IDSTRConvertText, sizeof(szFileDescrip));
         
     MergeStrings(IDPMTConvert, szFileDescrip, szPrompt);
     SetDlgItemText(hDlg, idiConvertPrompt, (LPSTR)szPrompt);
     EnableOtherModeless(FALSE);
     break;
     }

 case WM_SETVISIBLE:
    if (wParam)
        EndLongOp(vhcArrow);
    return(FALSE);

 case WM_ACTIVATE:
    if (wParam)
        vhWndMsgBoxParent = hDlg;
    if (vfCursorVisible)
        ShowCursor(wParam);
    return(FALSE); /* so that we leave the activate message to the dialog
              manager to take care of setting the focus correctly */

 case WM_COMMAND:
    switch (wParam) {

              /* return one of these values:
                 idiOk - convert
                 idiCancel - cancel, no conversion
                 idiNo - read in without conversion */

        case idiNo: /* User hit the "No Conversion" button */
            if (!IsWindowEnabled(GetDlgItem(hDlg, idiNo)))
        /* No convert is grayed -- ignore */
                return(TRUE);
             /* fall in */
    case idiOk:     /* User hit the "Convert" button */
    case idiCancel:
            break;
    default:
            return(FALSE);
    }
      /* here after ok, cancel, no */
     OurEndDialog(hDlg, wParam);
     break;

 default:
    return(FALSE);
 }
 return(TRUE);
} /* end of DialogWordCvt */

/* International version */
#else
BOOL far PASCAL DialogWordCvt( hDlg, code, wParam, lParam )
HWND    hDlg;           /* Handle to the dialog box */
unsigned code;
WORD wParam;
LONG lParam;
{
    Assert(FALSE);
} /* end of DialogWordCvt */
#endif /* Non Iternational version */




IdConfirmDirty()
{   /* Put up a message box saying docCur "Has changed. Save changes?
       Yes/No/Cancel". Return IDYES, IDNO, or IDCANCEL. */
 extern HWND vhWnd;
 extern CHAR szUntitled[];
 extern HANDLE   hszDirtyDoc;
 LPSTR szTmp = MAKELP(hszDirtyDoc,0);
 CHAR szPath[ cchMaxFile ];
 CHAR szName[ cchMaxFile ];
 CHAR szMsg[ cchMaxSz ];
 CHAR (**hszFile)[]=(**hpdocdod)[docCur].hszFile;

 if ((**hszFile)[0] == '\0')
    CchCopySz( szUntitled, szName );
 else
    SplitSzFilename( *hszFile, szPath, szName );

 wsprintf(szMsg,szTmp,(LPSTR)szName);

 return IdPromptBoxSz( vhWnd, szMsg, MB_YESNOCANCEL | MB_ICONEXCLAMATION );
}




SplitSzFilename( szFile, szPath, szName )
CHAR *szFile;
CHAR *szPath;
CHAR *szName;
{   /* Split a normalized filename into path and bare name components.
       By the rules of normalized filenames, the path will have a drive
       letter, and the name will have an extension. If the name is null,
       we provide the default DOS path and a null szName */

 szPath [0] = '\0';
 szName [0] = '\0';

 if (szFile[0] == '\0')
    {
#if WINVER >= 0x300
    /* Currently: FNormSzFile  *TAKES*   an OEM sz, and
                              *RETURNS*  an ANSI sz ..pault */
#endif
    FNormSzFile( szPath, "", dtyNormal ); /* Use default DOS drive & path */
    }
 else
    {
    CHAR *pch;
    int cch;

    lstrcpy(szPath,(LPSTR)szFile);

    pch = szPath + lstrlen(szPath) - 1; // point to last character

#ifdef	DBCS
    while (pch != szPath) {
        CHAR    *szptr;
        szptr = (CHAR near *)AnsiPrev(szPath,pch);
        if (*szptr == '\\')
            break;
        else
                pch = szptr;
    }
#else   /* DBCS */
    while (pch != szPath)
        if (*(pch-1) == '\\')
            break;
        else
            --pch;

#endif

    lstrcpy(szName,(LPSTR)pch);

#ifdef DBCS
#if !defined(TAIWAN) &&  !defined(PRC)
    pch=(CHAR near *)AnsiPrev(szPath,pch);
    *pch = '\0';
#endif
#else
    *(pch-1) = '\0';
#endif

    }
}


BOOL CheckEnableButton(hCtlEdit, hCtlEnable)
HANDLE hCtlEdit;   /* handle to edit item */
HANDLE hCtlEnable; /* handle to control which is to enable or disable */
{
register BOOL fEnable = SendMessage(hCtlEdit, WM_GETTEXTLENGTH, 0, 0L);

    EnableWindow(hCtlEnable, fEnable);
    return(fEnable);
} /* end of CheckEnableButton */




/***        FDeleteFn - Delete a file
 *
 *
 *
 */

int FDeleteFn(fn)
int fn;
{   /* Delete a file & free its fn slot */
    /* Returns TRUE if the file was successfully deleted or if it was not
       found in the first place; FALSE if the file exists but
       cannot be deleted */

int f = FALSE;

if (FEnsureOnLineFn( fn ))  /* Ensure disk w/ file is in drive */
    {
    CloseFn( fn );  /* Ensure file closed */

    f = FDeleteFile( &(**(**hpfnfcb) [fn].hszFile) [0] );
    }

FreeFn( fn );   /* We free the fn even if the file delete failed */

return f;
}



FDeleteFile( szFileName )
CHAR szFileName[];
{   /* Delete szFilename. Return TRUE if the file was deleted,
       or there was no file by that name; FALSE otherwise.
       Before deleting the file, we ask all other WRITE instances whether
       they need it; if one does, we do not delete and return FALSE */

HANDLE HszGlobalCreate( CHAR * );
int fpe=0;
int fOk;
ATOM a;

if ((a = GlobalAddAtom( szFileName )) != NULL)
    {
    fOk = WBroadcastMsg( wWndMsgDeleteFile, a, (LONG) 0, FALSE );
    if (fOk)
    {   /* Ok to delete, no other instance needs it */
    fpe = FpeDeleteSzFfname( szFileName );
    }
#ifdef DEBUG
     else
     Assert( !FIsErrFpe( fpe ) );
#endif
    GlobalDeleteAtom( a );
    }

    /* OK if: (1) Deleted OK  (2) Error was "File not found" */
return (!FIsErrFpe(fpe)) || fpe == fpeFnfError;
}




FDeleteFileMessage( a )
ATOM a;
{   /* We are being notified that the file hName is being deleted.
       a is a global atom.  (Was global handle before fixing for NT 3.5)
       Return TRUE = Ok to delete; FALSE = Don't delete, this instance
        needs the file */

 LPCH lpch;
 CHAR sz[ cchMaxFile ];

 Scribble( 5, 'D' );

 if (GlobalGetAtomName( a, sz, sizeof(sz)) != 0)
    {
    if (FnFromSz( sz ) != fnNil)
       {
       Scribble( 4, 'F' );
       return FALSE;
       }
    }

 Scribble( 4, 'T' );
 return TRUE;
}




/***        FpeRenameFile - rename a file
 *
 */

int FpeRenameFile(szFileCur, szFileNew) /* Both filenames expected in ANSI */
CHAR *szFileCur, *szFileNew;
{
   /* Rename a file.  Return fpeNoErr if successful; error code if not. */
int fn = FnFromSz( szFileCur );
int fpe;
CHAR (**hsz)[];
HANDLE hName;
HANDLE hNewName;

#if WINVER >= 0x300
/* The szPathName field in rgbOpenFileBuf is now treated as OEM
   as opposed to ANSI, so we must do a conversion.  12/5/89..pault */
CHAR szFileOem[cchMaxFile];
AnsiToOem((LPSTR)szFileNew, (LPSTR)szFileOem);
#define sz4OpenFile szFileOem
#else
#define sz4OpenFile szFileNew
#endif

/* If this is a file we know about, try to make sure it's on line */

if (fn != fnNil)
    if (FEnsureOnLineFn( fn ))
    {
    FFlushFn( fn ); /* just in case */
    CloseFn( fn );
    }
    else
    return fpeHardError;

/* if the file exists on disk then try to rename it */
if (szFileCur[0] != 0 && FExistsSzFile(dtyAny, szFileCur))
    {
    int fpe=FpeRenameSzFfname( szFileCur, szFileNew );

    if ( FIsErrFpe( fpe ) )
        /* Rename failed -- return error code */
        return fpe;
    }
else
    return fpeNoErr;

    /* Inform other instances of WRITE */
if ((hName = HszGlobalCreate( szFileCur )) != NULL)
    {
    if ((hNewName = HszGlobalCreate( szFileNew )) != NULL)
    {
    WBroadcastMsg( wWndMsgRenameFile, hName, (LONG)hNewName, -1 );
    GlobalFree( hNewName );
    }
    GlobalFree( hName );
    }

if (fn != fnNil)
    { /* Rename current FCB for file if there is one */
    struct FCB *pfcb;

    FreeH((**hpfnfcb)[fn].hszFile);
    hsz = HszCreate((PCH)szFileNew);
    pfcb = &(**hpfnfcb) [fn];
    pfcb->hszFile = hsz;

    bltbyte( sz4OpenFile, ((POFSTRUCT)pfcb->rgbOpenFileBuf)->szPathName,
         umin( CchSz( sz4OpenFile ), cchMaxFile ) );

#ifdef DFILE
CommSzSz("FpeRenameFile  szFileNew==",szFileNew);
CommSzSz("               szFileCur==",szFileCur);
CommSzSz("               szFileNewOem==",szFileOem);
#endif

#ifdef ENABLE
    pfcb->fOpened = FALSE;  /* Signal OpenFile that it must open
                   from scratch, not OF_REOPEN */
#endif
    }

return fpeNoErr;
}




RenameFileMessage( hName, hNewName )
HANDLE hName;
HANDLE hNewName;
{   /* We are being notified by another instance of WRITE that the name
       of file hName is being changed to hNewName.  hName and hNewName
       are WINDOWS global handles */

 LPCH lpchName;
 LPCH lpchNewName;

 Scribble( 5, 'R' );
 Scribble( 4, ' ' );

 if ((lpchName = GlobalLock( hName )) != NULL)
    {
    if ((lpchNewName = GlobalLock( hNewName )) != NULL)
    {
    CHAR (**hsz) [];
    CHAR szName[ cchMaxFile ];
    CHAR szNewName[ cchMaxFile ];
    int fn;

    bltszx( lpchName, (LPCH) szName );
    bltszx( lpchNewName, (LPCH) szNewName );

    if ((fn=FnFromSz( szName )) != fnNil &&
        !FNoHeap(hsz = HszCreate( szNewName )))
        {
#if WINVER >= 0x300
        /* The szPathName field in rgbOpenFileBuf is now treated as OEM
           as opposed to ANSI, so we must do a conversion.  12/5/89..pault */
        CHAR szNewOem[cchMaxFile];
        AnsiToOem((LPSTR)szNewName, (LPSTR)szNewOem);
        bltsz( szNewOem, ((POFSTRUCT)((**hpfnfcb) [fn].rgbOpenFileBuf))->szPathName );
#else
        bltsz( szNewName, ((POFSTRUCT)((**hpfnfcb) [fn].rgbOpenFileBuf))->szPathName );
#endif

#ifdef ENABLE
        (**hpfnfcb) [fn].fOpened = FALSE;
#endif
        FreeH( (**hpfnfcb) [fn].hszFile );
        (**hpfnfcb) [fn].hszFile = hsz;
        }
    GlobalUnlock( hNewName );
    }
    GlobalUnlock( hName );
    }
}




#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif

STATIC int messageBR;
STATIC WORD wParamBR;
STATIC LONG lParamBR;
STATIC int wStopBR;

STATIC int wResponseBR;

STATIC FARPROC lpEnumAll=NULL;
STATIC FARPROC lpEnumChild=NULL;


WBroadcastMsg( message, wParam, lParam, wStop )
int message;
WORD wParam;
LONG lParam;
WORD wStop;
{   /* Send a message to the document child windows (MDOC) of all
       currently active instances of WRITE (except ourselves).
       Continue sending until all instances have been notified, or until
       one returns the value wStop as a response to the message.
       Return the response given by the last window notified, or
       -1 if no other instances of WRITE were found */

extern HANDLE hMmwModInstance;
int FAR PASCAL BroadcastAllEnum( HWND, LONG );
int FAR PASCAL BroadcastChildEnum( HWND, LONG );

 messageBR = message;
 wParamBR = wParam;
 lParamBR = lParam;
 wStopBR = wStop;
 wResponseBR = -1;

 if (lpEnumAll == NULL)
    {
    lpEnumAll = MakeProcInstance( (FARPROC) BroadcastAllEnum, hMmwModInstance );
    lpEnumChild = MakeProcInstance( (FARPROC) BroadcastChildEnum, hMmwModInstance );
    }

 EnumWindows( lpEnumAll, (LONG)0 );
 return wResponseBR;
}



int FAR PASCAL BroadcastAllEnum( hwnd, lParam )
HWND hwnd;
LONG lParam;
{   /* If hwnd has the class of a WRITE parent (menu) window, call
       (*lpEnumChild)() for each of its children and return
       the value returned by EnumChildWindows
       If the window does not have the class of a WRITE parent, do nothing
       and return TRUE */
 extern CHAR szParentClass[];
 extern HWND hParentWw;

 if ( (hwnd != hParentWw) && FSameClassHwndSz( hwnd, szParentClass ) )
    return EnumChildWindows( hwnd, lpEnumChild, (LONG) 0 );
 else
    return TRUE;
}



int FAR PASCAL BroadcastChildEnum( hwnd, lParam )
HWND hwnd;
LONG lParam;
{   /* If hwnd is of the same class as a WRITE child (document) window,
       send the message { messageBR, wParamBR, lParamBR } to it, else
       return TRUE;
       If the message is sent, return FALSE if the message return value
       matched wStopBR; TRUE if it did not match.
       Set wMessageBR to the message return value.
    */
 extern CHAR szDocClass[];
 extern HWND vhWnd;

 Assert( hwnd != vhWnd );

 if (FSameClassHwndSz( hwnd, szDocClass ))
    {   /* WRITE DOCUMENT WINDOW: pass message along */
    wResponseBR = SendMessage( hwnd, messageBR, wParamBR, lParamBR );
    return wResponseBR != wStopBR;
    }
 else
    return TRUE;
}



FSameClassHwndSz( hwnd, szClass )
HWND hwnd;
CHAR szClass[];
{   /* Compare the Class name of hWnd with szClass; return TRUE
       if they match, FALSE otherwise. */

#define cchClassMax 40  /* longest class name (for compare purposes) */

 CHAR rgchWndClass[ cchClassMax ];
 int cbCopied;

    /* Count returned by GetClassName does not include terminator */
    /* But, the count passed in to it does. */
 cbCopied = GetClassName( hwnd, (LPSTR) rgchWndClass, cchClassMax ) + 1;
 if (cbCopied <= 1)
    return FALSE;

 rgchWndClass[ cbCopied - 1 ] = '\0';

 return WCompSz( rgchWndClass, szClass ) == 0;
}


FConfirmSave()
{   /* Give the user the opportunity to save docCur, if it is dirty.
       Return 1 - Document Saved OR user elected not to save changes
              OR document was not dirty
          0 - User selected "Cancel" or Error during SAVE */
extern HANDLE hMmwModInstance;
extern HANDLE hParentWw;
extern int vfTextOnlySave, vfBackupSave;
struct DOD *pdod=&(**hpdocdod)[docCur];

#if defined(OLE)
    if (CloseUnfinishedObjects(FALSE) == FALSE)
        return FALSE;
#endif

 if (pdod->fDirty)
    {   /* doc has been edited, offer confirm/save before quitting */
    switch ( IdConfirmDirty() )
    {
    case IDYES:
        {
#if 0
#if defined(OLE)
    if (CloseUnfinishedObjects(TRUE) == FALSE)
        return FALSE;
#endif
#endif

        if ( (**(pdod->hszFile))[0] == '\0' )
        goto SaveAs;

#ifdef INTL /* International version */
         /* if saving after a Word conversion, bring up dialog
        box to allow backup/ rename. */

        else if ( vWordFmtMode == CONVFROMWORD)
        goto SaveAs;
#endif /* International version */

        else if (pdod->fReadOnly)
        {
        extern int ferror;

        /* Read-only doc: tell the user to save under a different name */

        Error( IDPMTReadOnly );
        ferror = FALSE; /* Not really an error */

SaveAs:
        fnSaveAs(); /* Bring up "save as" dialog box */
        pdod = &(**hpdocdod)[docCur];
        if (pdod->fDirty)
            /* Save failed or was aborted */
            return FALSE;
        }
        else
        {
            CmdXfSave( *pdod->hszFile, !vfTextOnlySave, vfBackupSave, vhcArrow);

#if defined(OLE)
            if (!ferror)
                ObjSavedDoc();
#endif
        }
        if (ferror)
            /* Don't quit if we got a disk full error */
            return FALSE;
        }
        break;

    case IDNO:
#if 0
#if defined(OLE)
        if (CloseUnfinishedObjects(FALSE) == FALSE)
            return FALSE;
#endif
#endif
        break;

    case IDCANCEL:
    default:
        return FALSE;
    }
    }
#if 0
#if defined(OLE)
 else /* not dirty */
    if (CloseUnfinishedObjects(FALSE) == FALSE)
        return FALSE;
#endif
#endif

 return TRUE;
}




PreloadSaveSegs()
{
#ifdef GREGC /* kludge to get around the windows kernel bug for now */
    LoadF( PurgeTemps );      /* TRANS4 */
    LoadF( IbpEnsureValid );  /* FILE (includes doslib) */
    LoadF( FnCreateSz );      /* CREATEWW */
    LoadF( ClobberDoc );      /* EDIT */
    LoadF( FNormSzFile );     /* FILEUTIL */
    LoadF( CmdXfSave );   /* TRANS2 */
#endif
}




int CchCopyUpperSz(pch1, pch2)
register PCH pch1;
register PCH pch2;
{
int cch = 0;
while ((*pch2 = ChUpper(*pch1++)) != 0)
    {
#ifdef  DBCS    /* KenjiK '90-11-20 */
        if(IsDBCSLeadByte(*pch2))
        {
                pch2++;
                *pch2 = *pch1++;
                cch++;
        }
#endif
    pch2++;
    cch++;
    }
return cch;
} /* end of  C c h C o p y U p p e r S z  */

#ifdef DBCS     // AnsiNext for near call.
static  char NEAR *MyAnsiNext(char *sz)
{
        if(!*sz)                                return sz;

        sz++;
        if(IsDBCSLeadByte(*sz)) return (sz+1);
        else                                    return sz;
}
#endif

#if 0
/* ** Given filename or partial filename or search spec or partial
      search spec, add appropriate extension. */

/*
   fSearching is true when we want to add \*.DOC to the string -
   i.e., we are seeing if string szEdit is a directory. If the string
   is .. or ends in: or \, we know we have a directory name, not a file
   name, and so add \*.DOC or *.DOC to the string. Otherwise, if
   fSearching is true ans szEdit has no wildcard characters,
   add \*.DOC to the string, even if the string contains a period
   (directories can have extensions). If fSearching is false, we will
   add .DOC to the string if no period is found in the last file/directory
   name.

   Note the implicit assumption here that \ and not / will be used as the
   path character. It is held in the defined variable PATHCHAR, but we
   don't handle DOS setups where the / is path and - is the switch character.
*/

#define PATHCHAR ('\\')

NEAR DlgAddCorrectExtension(szEdit, fSearching)
CHAR    *szEdit;
BOOL    fSearching;
{
    register CHAR *pchLast;
    register CHAR *pchT;
    int ichExt;
    BOOL    fDone = FALSE;
    int     cchEdit;

    pchT = pchLast = (szEdit + (cchEdit = CchSz(szEdit) - 1) - 1);

    /* Is szEdit a drive letter followed by a colon (not a filename) ? */
    if (cchEdit == 2
         && *pchLast == ':')
        /* don't use 0 or will interpret "z:" incorrectly as "z:\" ..pault */
        ichExt = 1;
    /* how about ".." (also not a file name)? */
    else if (cchEdit == 2
         && (*pchLast == '.' && *(pchLast-1) == '.'))
        ichExt = 0;
    else if (*pchLast == PATHCHAR)  /* path character */
    ichExt = 1;
    else
    {
        if (fSearching)
            {
             /* any wild card chars? if so, is really a file name */
            if (FSearchSpec(szEdit))
                return;
            ichExt = 0;
            }
        else
            {
            ichExt = 2;
            for (; pchT > szEdit; pchT--) {
                if (*pchT == '.') {
                return;
                }
                if (*pchT == PATHCHAR) {
                /* path character */
                break;
                }
                }
            }

    }
    if (CchSz(szExtSearch+ichExt) + cchEdit > cchMaxFile)
        Error(IDPMTBadFilename);
    else
#ifdef DBCS
        CchCopySz((szExtSearch+ichExt), AnsiNext(pchLast));
#else
        CchCopySz((szExtSearch+ichExt), (pchLast+1));
#endif
}


/* ** return TRUE iff 0 terminated string contains a '*' or '\' */
BOOL  (NEAR FSearchSpec(sz))
register CHAR *sz;
{

#ifdef DBCS
    for (; *sz;sz=AnsiNext(sz)) {
#else
    for (; *sz;sz++) {
#endif
    if (*sz == '*' || *sz == '?')
        return TRUE;
    }
    return FALSE;
}

#endif

szFileExtract(szNormFileName, szExtFileName)
CHAR *szNormFileName; /* input: normalized file name */
CHAR *szExtFileName;  /* output: simple file name with extension added to */
{
    CHAR *pchLast, *pchT;
#ifdef  DBCS    /* KenjiK(MSKK) '90-11-20 */
        for(pchT=szNormFileName;*pchT;pchT++);
        pchLast = pchT;
        do {
                pchT = AnsiPrev(szNormFileName,pchT);
                if (*pchT == '\\')
                        break;
        } while(pchT > szNormFileName);

#else   /* not DBCS */

    pchLast = pchT = szNormFileName + CchSz(szNormFileName) - 1;

    while (pchT > szNormFileName)
    {
    if (*pchT == '\\')
        break;
    pchT --;
    }
#endif

    bltbyte(pchT + 1, szExtFileName, pchLast - pchT);
    //DlgAddCorrectExtension(szExtFileName, FALSE);
}




#ifdef INTL /* International version */

/* ** return TRUE if file opened is in Microsoft Word format */
BOOL  FInWordFormat(fn)
int fn;
{
register struct FCB *pfcb;
int cchT;
       /* Assumption: this routine has been called after FnOpenSz, which
      has already determined whether the file is formatted,
      and if the pnMac entry was 0, it set pnMac to be the same
      as pnFfntb in the file's fcb. So a Word file is a formatted
      file whose pnMac and pnFfntb are the same.

      We are also pretending that unformatted files are word format files
      so we will bring up a dialog box allowing character set conversion. */

    pfcb = &(**hpfnfcb)[fn];
    if (pfcb->fFormatted == false)  /* unformatted treated as a word file */
    return (true);

    return (pfcb->pnMac == pfcb->pnFfntb);
}
#endif  /* International version */


#ifdef INTL /* International version */
void ConvertFromWord ()
{

    /* vWordFmtMode is used by FnWriteFile to translate the
       Word file character set to ANSI. We leave it set to
       CONVFROMWORD so that the next save can check if there was a
       file with extension of szExtDoc.If there is no such file,
       vWordFmtMode is set to true or false by the save dialog code.

       *** as of 2/14/86, no backup is made, but code in CleanDoc checks for
       vWordFmtMode=CONVFROMWORD, and saves without renaming the word
       file instead of making an optional backup

       *** as of 12/3/89, FreeUnreferencedFns() is removing the
       lock on files not referenced by pieces in any documents, so
       the word doc or text file being converted FROM is not being
       "locked" and another app can grab it!  I'm correcting this
       in FreeUnreferencedFns() ..pault
     */

    extern CHAR szExtDoc[];
    struct DOD *pdod=&(**hpdocdod)[docCur];

    vWordFmtMode = CONVFROMWORD;  /* will stay this value until save */
    vfBackupSave = 1;  /* force next save to default to backing up */
      /* always a formatted save, no backup. */
    CmdXfSave( *pdod->hszFile, true, false, vhcArrow);

#if defined(OLE)
    if (!ferror)
        ObjSavedDoc();
#endif
}
#endif  /* International version */


#ifdef INTL /* International version */
TestWordCvt (fn, hWnd)
int fn;
HWND   hWnd;
{
int wordVal;
#ifndef INEFFLOCKDOWN
FARPROC lpDialogWordCvt = MakeProcInstance(DialogWordCvt, hMmwModInstance);
    if (!lpDialogWordCvt)
        {
        WinFailure();
        return(fFalse);
        }
#endif

/* This routine returns the following values:
-1 means dialog box failed (error already sent)
-2 means cancel without conversion.
FALSE means not a word document.
TRUE means convert this word document.
Its parent may change depending on the caller.
*/

if (!(wordVal = FInWordFormat (fn)))
return (FALSE);   /* not a word doc */

/* in word format - ask for conversion */
/* the cvt to word dialog returns 3 values
  other than -1:
     idiOk - convert
     idiCancel - cancel, no conversion
     idiNo - read in without conversion
     vfBackupSave set to reflect whether backup is made */
  /* Note it is a child of this dialog */

fOpenedFormatted = (**hpfnfcb)[fn].fFormatted;  /* used in dialog func */

#ifdef DBCS             /* was in KKBUGFIX */
// [yutakan:05/17/91] (I don't know why) sometimes hWnd would be invalid.
if (!IsWindow(hWnd))    hWnd = hParentWw;
#endif

if ((wordVal = (OurDialogBox( hMmwModInstance,
    MAKEINTRESOURCE(dlgWordCvt), hWnd,
    lpDialogWordCvt))) == -1)
    {
#if WINVER >= 0x300
    WinFailure();
#else
    Error(IDPMTNoMemory);
#endif
        }

#ifndef INEFFLOCKDOWN
    FreeProcInstance(lpDialogWordCvt);
#endif

      /* return -1 if either out of memory or no conversion desired */
      /* will convert an unformatted file if No is the dialog response */
    switch (wordVal)

        {
        case idiNo: /* User hit the "No Conversion" button */
            return(FALSE);  /* treat as non-word file */
        case idiOk: /* User hit the "Convert" button */
            return(TRUE);

        case idiCancel:
            return (-2);

        case -1:
        default:
            return (-1);
        }

}
#endif  /* Kanji / International version */


/* ********** routines for doing message relocation ******* */

VOID MergeInit()
/* get merge spec, guaranteed to be 2 characters, into variable wMerge */
{
char sz[10];

        PchFillPchId( sz, IDS_MERGE1, sizeof(sz) );
        wMerge = *(unsigned *)sz;
}


BOOL MergeStrings (idSrc, szMerge, szDst)
IDPMT idSrc;
CHAR *szMerge;
CHAR *szDst;
{
/* get message from idSrc. Scan it for merge spec. If found, insert string
   szMerge at that point, then append the rest of the message. NOTE!
   merge spec guaranteed to be 2 characters. wMerge loaded at init by
   MergeInit. Returns true if merge done, false otherwise.
*/

CHAR szSrc[cchMaxSz];
register CHAR *pchSrc;
register CHAR *pchDst;

/* get message from resource file */

    PchFillPchId( szSrc, idSrc, sizeof(szSrc) );
    pchSrc = szSrc;
    pchDst = szDst;

    /* find merge spec if any */

    while (*(unsigned *)pchSrc != wMerge)
    {
    *pchDst++ = *pchSrc;

    /* if we reach the end of string before merge spec, just return false */

    if (!*pchSrc++)
        return FALSE;
    }


     /* if merge spec found, insert szMerge there. (check for null merge str */

     if (szMerge)
     while (*szMerge)
         *pchDst++ = *szMerge++;

    /* jump over merge spec */
     pchSrc++;
     pchSrc++;

     /* append rest of string */

     while (*pchDst++ = *pchSrc++)
     ;
     return TRUE;

}

#include "propdefs.h"
BOOL DocHasPictures(int doc)
{
    extern struct PAP      vpapAbs;
    typeCP cpMac = CpMacText(doc),cpNow;
    for ( cpNow = cp0; cpNow < cpMac; cpNow = vcpLimParaCache )
    {
        CachePara( doc, cpNow );
        if (vpapAbs.fGraphics)
            return TRUE;
    }
    return FALSE;
}

BOOL WannaDeletePictures(int doc, int fWhichFormat)
/* assume if SF_OLDWRITE that vcObjects is set */
{
    CHAR szBuf[cchMaxSz];
    BOOL bDoPrompt;

    if (fWhichFormat == SF_OLDWRITE)
    /* warn that OLE pictures will be deleted */
    {
        if (bDoPrompt = (vcObjects > 0))
            PchFillPchId( szBuf, IDPMTDelObjects, sizeof(szBuf) );
    }
    else if (fWhichFormat == SF_WORD)
    /* warn that all pictures will be deleted */
    {
        if (bDoPrompt = DocHasPictures(docCur))
            PchFillPchId( szBuf, IDPMTDelPicture, sizeof(szBuf) );
    }
    else
        return TRUE;

    if (bDoPrompt)
        return (IdPromptBoxSz( vhWnd, szBuf, MB_YESNO | MB_ICONEXCLAMATION ) == IDYES);
    else
        return TRUE;
}

BOOL NEAR PASCAL CanReadEveryFile(char *szFilename)
{
    extern int fnMac;
    int fn;
    BOOL bRetval=TRUE;

    FreezeHp();
    for (fn = 0; fn < fnMac; fn++)
    {
        if ((**hpfnfcb)[fn].fDisableRead)
        {
            /* see if still can't read */
            if (!FAccessFn( fn, dtyNormal ))
            {
                char szMsg[cchMaxSz];
                ferror = FALSE;
                MergeStrings (IDPMTCantRead, szFilename, szMsg);
                IdPromptBoxSz(vhWndMsgBoxParent ? vhWndMsgBoxParent : hParentWw,
                                szMsg, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
                {
                    bRetval = FALSE;
                    break;
                }
            }
        }
    }

    MeltHp();
    return bRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\trans2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* trans2.c -- Save routines for WRITE (also see trans4.c; routines were
   moved because of compiler heap overflows) */

#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
//#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
//#define NOGDI
//#define NOMETAFILE
#define NOBRUSH
#define NOPEN
#define NOFONT
#define NOWNDCLASS
#define NOWH
#define NOWINOFFSETS
#define NOICON
#define NOCOMM
#define NOSOUND
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "propdefs.h"
#define NOUAC
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "printdef.h"
#include "code.h"
#include "heapdefs.h"
#include "heapdata.h"
#define NOSTRUNDO
#include "str.h"
#include "debug.h"
#include "fontdefs.h"
#include "obj.h"
#include "winddefs.h"

CHAR    *PchGetPn();
CHAR    *PchFromFc();
typePN  PnAlloc();
struct  PGTB **HpgtbGet();

#ifdef DEBUG
    /* Make these variables during debug so testers can force limits */
typeFC          fcBound = (pnMaxScratch >> 2) * ((typeFC)cbSector);
int             cpBound = 512;
#else
#define fcBound     ((typeFC) ((pnMaxScratch >> 2) * ((typeFC)cbSector)))
#define cpBound     (512)
#endif

extern  CHAR *PchFillPchId();

extern int             vfOldWriteFmt;  /* delete objects before saving */
extern HANDLE  hParentWw;
extern int             vfnWriting;
extern struct BPS      *mpibpbps;
extern typeTS          tsMruBps;
extern int             vibpWriting;
extern CHAR            (**vhrgbSave)[];
extern struct DOD      (**hpdocdod)[];
extern int             docCur;
extern int             docMac;
extern int             docScrap;
extern int             docUndo;
extern struct FCB      (**hpfnfcb)[];
extern int             fnMac;
extern int             wwMac;
/* extern ENV             vEnvMainLoop; */
extern int             vfBuffersDirty;
extern int             vfDiskFull;
extern int             vfDiskError;
extern typeCP          vcpFetch;
extern CHAR            *vpchFetch;
extern int             vccpFetch;
extern typeFC          fcMacPapIns;
extern typeFC          fcMacChpIns;
extern typeCP          vcpLimParaCache;
extern struct FKPD     vfkpdCharIns;
extern struct FKPD     vfkpdParaIns;
extern struct PAP      vpapPrevIns;
extern struct PAP      vpapAbs;
extern struct PAP      *vppapNormal;
extern struct CHP      vchpNormal;
extern struct CHP      vchpInsert;
extern struct CHP      vchpFetch;
extern struct FPRM     fprmCache;
extern HCURSOR vhcIBeam;

extern int              ferror;
extern CHAR             szExtBackup[];  /* extension for Write backup files */
extern CHAR             szExtWordBak[];  /* extension for Word backup files */
extern CHAR             (**hszTemp)[];
extern CHAR             szExtDoc[];


#ifdef INTL /* International version */

extern int vfTextOnlySave;
extern int  vWordFmtMode; /* used during saves. If false, no conversion is
                              done. True is convert to Word format,CVTFROMWORD
                              is translate chars from Word character set at
                              save */
#endif  /* International version */




/***         CmdXfSave - Save document to passed filename (TRANSFER SAVE)
 *
 *      ENTRY:  szFile - a normalized filename
 *              fFormatted - TRUE  = save as formatted file
 *                           FALSE = save as unformatted file
 *              fBackup    - TRUE = keep a backup copy of the file
 *                           FALSE = don't (but see below)
 *
 *      EXIT:
 *
 *      NOTE: A backup file may be kept even if fBackup is FALSE.
 *            This is because piece tables in documents other than docCur
 *            may refer to the information.  If a backup file is kept for
 *            this reason, the following holds: (1) The file has an fn,
 *            (2) the file's hpfnfcb entry has its fDelete field set to TRUE,
 *            indicating that the file should be deleted when WORD exits,
 *            (3) the file is, in fact, referenced in some document
 *            (PurgeTemps assures that unreferenced files are deleted)
 *
 *      Note 2: Non-formatted save code modified (bz 12/2/85) to allow
 *            similar saving in Word format. The calls to FnCreate and
 *            FWriteFn were changed to allow for formatted saving, but
 *            FWriteFn is changed to convert text from ANSI to OEM character
 *            sets, to not put out the font table and to mark
 *            the file header (fib) so the file will be treated as a Word
 *            file, but, like a non-formatted save, the piece table is not
 *            cleaned up. Note that the backup file is saved  in the original,
 *            Write format.
 *
 */

CmdXfSave(szFile, fFormatted, fBackup, hcAfterward)
CHAR szFile[];
int fFormatted;
int fBackup;
HCURSOR hcAfterward;    /* handle to cursor to display after hourglass */
{
 extern int vfnSaving;   /* Set this so we prompt for "Write Save File"
                            if disk change is necessary */
 extern int vfDiskError;
 extern int vfSysFull;
 extern int vfOutOfMemory;

 int     fSave = vfDiskError;
 int     fDidBackup;
 CHAR    szFileT [cchMaxFile];
 int     fOutOfMemory=vfOutOfMemory;
 int     docTemp;

 /* Make a local copy of string parm in case it is in the heap */

#ifdef DFILE
 CommSzSz("CmdXfSave----szFile (presumed ANSI) ", szFile);
#endif
 StartLongOp();
 bltsz( szFile, szFileT );
 szFileT[ cchMaxFile - 1] = '\0';

 /* Reset error conditions to give us a chance */

 vfOutOfMemory = vfDiskFull = vfSysFull = vfDiskError = ferror = FALSE;

 SetRfnMac( rfnMacSave );    /* Increase # of DOS handles used to speed save */

 /* Memory kludge: To assure that we can actually save this file under low
        memory conditions, free the bogus heap block */
 if (vhrgbSave != 0)
    {
    FreeH(vhrgbSave);        /* Return this memory to free pool. */
    vhrgbSave = 0;
    }
 /* In-Line version of FreeBitmapCache (so we don't have to swap in
   picture.c) */

 /*FreeBitmapCache(); */              /* Give us even more memory */

 {
 extern int vdocBitmapCache;
 extern HBITMAP vhbmBitmapCache;

 vdocBitmapCache = docNil;
 if (vhbmBitmapCache != NULL)
    {
    DeleteObject( vhbmBitmapCache );
    vhbmBitmapCache = NULL;
    }
 }


 /* Can't undo save -- set "Can't Undo"; also clear out docUndo
    for heap space reclamation and to aid PurgeTemps */

 ClobberDoc(docUndo, docNil, cp0, cp0);
 NoUndo();

 (**hpdocdod)[docCur].fBackup = fBackup;

 /*      Note: Non-formatted save code modified (bz 12/2/85) to allow
 *            similar saving in Word format. The calls to FnCreate and
 *            FWriteFn were changed to allow for formatted saving, but
 *            FWriteFn is changed to convert text from ANSI to OEM character
 *            sets, to not put out the font table and to mark
 *            the file header (fib) so the file will be treated as a Word
 *            file, but, like a non-formatted save, the piece table is not
 *            cleaned up. Note that the backup file is saved  in the original,
 *            Write format.
 *            Note that a file CAN be saved both unformatted and in Word format
 *            - in that case, Word format means convert to OEM character set.
 */

#if defined(OLE)
    ObjSavingDoc(fFormatted);
#endif

 if (((**hpdocdod)[docCur].fFormatted && !fFormatted)
#ifdef INTL /* International version */
      || (vWordFmtMode == TRUE) /* convert To Word format? */
#endif  /* International version */
      || (vfOldWriteFmt))
    {

    int fn;
    CHAR (**hsz)[];
    CHAR szT [cchMaxFile];
    CHAR szWriteFile [cchMaxFile];
    CHAR szBak [cchMaxFile];

        /* Set szFileT's path name into szWriteFile, so the temp file
           gets created in the right place when we call FnCreateSz */
    SplitSzFilename( szFileT, szWriteFile, szT );

        /* Create szWrite: a new, uniquely named file */
     if ((fn=FnCreateSz( szWriteFile,
                     fFormatted?(**hpdocdod)[docCur].cpMac:cpNil,
                     dtyNetwork ))==fnNil)
            /* Couldn't create the write file */
        goto SaveDone;
    /* Make backup of szFileT (if it exists); purge all unneeded backups
       which were kept for their pieces but are no longer referenced */
    fDidBackup = FBackupSzFile( szFileT, fBackup, szBak );
    if (ferror)
        goto LXFRet;     /* Backup failed */

    PurgeTemps();

    vfnSaving = fn;

    /* ForcePmt(IDPMTSaving);*/

#ifdef INTL /* International version */

    if ((vWordFmtMode == TRUE)  /* converting To Word format? */
     || (vfTextOnlySave == TRUE)  /* converting To Text format? */
     || (vfOldWriteFmt))
    /* Delete all pictures. To do this, make a copy
      of docCur in docTemp, the go through docTemp, deleting all picture
      paragraphs. Write out this document, then kill it. */
    {
    extern typeCP vcpLimParaCache, vcpFirstParaCache;
    extern typeCP cpMinCur, cpMacCur, cpMinDocument;
    typeCP cpMinCurT = cpMinCur;
    typeCP cpMacCurT = cpMacCur;
    typeCP cpMinDocumentT = cpMinDocument;
    typeCP cpNow;
    typeCP cpLimPara, dcp;
    typeCP cpMac = (**hpdocdod) [docCur].cpMac;

    /* Create copy of document */
    docTemp = DocCreate(fnNil, HszCreate(""), dtyNormal);
    if (docTemp == docNil)
        goto SaveDone; /* Out of memory */
    ClobberDoc(docTemp, docCur, cp0, CpMacText(docCur));
    if (ferror)
        return TRUE;

    /* Expand range of interest to whole document (for CachePara) */

    cpMinCur = cp0;
    cpMacCur = cpMac;

    /* Loop on paras */

    for ( cpNow = cp0; cpNow < cpMac; cpNow = cpLimPara )
        {
        CachePara( docTemp, cpNow );
        if (!vpapAbs.fGraphics)
            /* update to next cplim only if not deleting. If deleting,
                next time will be at same cp */
            {
            cpLimPara = vcpLimParaCache;
            continue;
            }

        /* Now delete graphics paragraph */
        Replace(docTemp, vcpFirstParaCache,
                dcp = (vcpLimParaCache - vcpFirstParaCache),
                fnNil, fc0, fc0);
        cpMac -= dcp;  /* size of doc has been reduced */
        }

    /* Restore cpMinCur, cpMacCur */

    cpMinCur = cpMinCurT;
    cpMacCur = cpMacCurT;
                                    /* destroyed possibly by DocCreate */
    cpMinDocument = cpMinDocumentT;
    vcObjects = 0; // OLE object count
    }
    else
#endif  /* International version */

        {
            docTemp = docCur; // note the else, above #endif (2.7.91) D. Kent
        }

    if (FWriteFn(fn, docTemp, fFormatted))
        {
        int fpe = FpeRenameFile( szWriteFile, szFileT );

        if ( FIsErrFpe( fpe ) )
            {   /* Rename failed -- might be nonexistent path */
            Error( (fpe == fpeBadPathError) ? IDPMTNoPath : IDPMTSDE2 );
            }
        else
            OutSaved(docTemp);

        }
    else
        {       /* Write failed */
        if (fDidBackup && !FIsErrFpe(FpeRenameFile(szBak, szFileT)))
            {
            int fn = FnFromSz(szFileT);
            struct FCB      *pfcb;
            if (fn != fnNil)
                {
                (pfcb = &(**hpfnfcb)[fn])->fDelete = false;
                }
            }
        FDeleteFn( fn );
        }


#ifdef INTL /* International version */
    if (vWordFmtMode == TRUE)  /* converting To Word format? */
        KillDoc (docTemp);
#endif  /* International version */


    (**hpdocdod)[docCur].fDirty = false;  /* document should not
                                                 be dirty after T-S.*/
    FreeH((**hpdocdod)[docCur].hszFile);
    hsz = HszCreate((PCH)szFileT);
    (**hpdocdod)[docCur].hszFile = hsz;
    }
else
    {   /* Save Formatted document */
    CleanDoc( docCur, (**hpdocdod)[docCur].dty, szFileT, fFormatted, fBackup );
    }

 OpenEveryHardFn(); /* Reopen files on nonremoveable media so other net
                       users can't steal them away */

SaveDone:

 SetRfnMac( rfnMacEdit );      /* Reduce # of file handles used */
 vfnSaving = fnNil;

#ifdef NEVER
 /* It doesn't do us much good to Assert here that an error didn't happen.
    After-the-fact checking doesn't make up for ignoring real-time errors.
    ..pault 10/31/89 */

 Assert( !vfOutOfMemory );      /* Our reserved space block was sufficient
                                   to get us through the save */
#endif
 vfOutOfMemory = fOutOfMemory;

/* vhrgbSave is a pointer a clump on the heap used during the save operation.
   By freeing it in the beginning of the save operation, we are assured
   that we will have enough memory to actually do the save.
   At the present point
   in the code, we are finished with the save and wish to reclaim vhrgbSave
   so the next Save operation may perform properly.  The net memory usage
   caused by a save should be minimal.  It only temporarily requires a
   significant chunk of memory. */
 vhrgbSave = (CHAR (**)[]) HAllocate( cwSaveAlloc +
                                     ( (wwMac-1) * cwHeapMinPerWindow ));

/* Restore previous disk err state */

#if WINVER >= 0x300
 /* We currently have no way to FORGET they had a disk error.
    So if this whole operation did not have an error and we
    felt there was one beforehand, we do it now ..pault */
 vfDiskError = (!vfDiskError && fSave) ? fFalse : fSave;
#else
 vfDiskError = fSave;
#endif

LXFRet:
 EndLongOp(hcAfterward);
}




CleanDoc(doc, dty, szFile, fFormatted, fBackup )
int doc, fFormatted;
int dty;
CHAR szFile[];
int     fBackup;
{ /* Write the contents of doc into szFile and clean up piece table */
  /* if dty == dtyNetwork, writes the doc to a unique file & returns the */
  /* filename through szFile */
  /* Returns the fn of the file it wrote to */

/* *************************************
  In the normal backup processing, we rename the existing file. When
  saving in CONVFROMWORD mode, we want to keep the original Word file around,
  so we bypass the backup phase and then skip the renaming phase below.
  This leaves the original file around. At save time we may write over it
  or rename the saving file, as we wish, but this way we have the Word file
  around in case we don't save out of Write.
************************************** */

extern int vdocParaCache;
extern int vfnSaving;   /* Set this so we prompt for "Save" disk if disk
                           changes are necessary */
int fDidBackup=FALSE;
int fn;
CHAR (**hsz)[];

CHAR szBak [cchMaxFile];
CHAR szWrite [cchMaxFile];
int fDummy;

#if WINVER >= 0x300
/* I don't understand WHY the following resets to ROOT directory, but 
   changing it causes problems -- so I'm leaving it!  Obviously code 
   somewhere else expects file to be there and I don't see it ..pault */
#endif
    /* Set path name of szFile into szWrite so the temp file gets created
       in the right place */
 if (dty == dtyNetwork)
    {
    szWrite [0] = '\0'; /* Create temp file on Temp drive in the root */
    }
 else
    {
    CHAR szT [cchMaxFile];

    SplitSzFilename( szFile, szWrite, szT );
    }

    /* Create szWrite: a new, uniquely named file */
 if ((fn=FnCreateSz( szWrite, fFormatted ? (**hpdocdod)[doc].cpMac : cpNil,
                     dtyNetwork )) == fnNil)
        /* Couldn't create the write file */
    return fnNil;

 vfnSaving = fn;

/* *************************************
  In the normal backup processing, we rename the existing file. When
  saving in CONVFROMWORD mode, we want to keep the original Word file around,
  so we bypass the backup phase and then skip the renaming phase below.
  This leaves the original file around. At save time we may write over it
  or rename the saving file, as we wish, but this way we have the Word file
  around in case we don't save out of Write.
************************************** */

 if (doc != docScrap)
    {
    /* Make a backup of szFile (if szFile exists) */

#ifdef INTL /* International version */
    if (vWordFmtMode == CONVFROMWORD) /* converting from a Word document */
        fDidBackup = false;
    else
#endif  /* International version */
        {
        fDidBackup = FBackupSzFile( szFile, fBackup, szBak );
        if (ferror)
            return;     /* Backup failed */
        }

    PurgeTemps();

    }

 if ( dty == dtyNetwork )
    bltsz( szWrite, szFile );

 if (!FWriteFn(fn, doc, fFormatted))
        {   /* Save failed; rename backup file back to original */
            /* note in intl CONVFROMWORD case, fDidBackup will be false
               and this renaming won't happen, which is ok */
        if (fDidBackup && !FIsErrFpe(FpeRenameFile(szBak, szFile)))
                {
                int fn = FnFromSz(szFile);
                struct FCB      *pfcb;
                if (fn != fnNil)
                        {
                        (pfcb = &(**hpfnfcb)[fn])->fDelete = false;
                        }
                }
        FDeleteFn( fn );
        return fnNil;         /* Disk full or write error */
        }

/* *************************************
  Here we rename our temp file szWrite to have the name of the "save as"
  file. In FBackupSzFile, the fdelete flag for the fn of szfile was set
  on so we don't have to explicitly delete the original file.

  When a CONVFROMWORD save is done, we do not rename and did not go
  through the backup procedure, so the original Word file is still
  out there with its original name. We do, however, set the delete bit to
  true, so the file will get deleted after the next save, when a true rename
  will be done.
************************************** */

 if ( dty != dtyNetwork )

#ifdef INTL /* International version */
    if (vWordFmtMode == CONVFROMWORD) /* converting from a Word document */
        {
        (**hpfnfcb)[fn].fDelete = true;
        }
    else
#endif  /* International version */

        {
        int fpe=FpeRenameFile( szWrite, szFile );

        if (FIsErrFpe( fpe ))
            {
            Error( (fpe == fpeBadPathError) ? IDPMTNoPath : IDPMTSDE2 );
            return fnNil;
            }
        }

if (doc == docScrap)
    (**hpfnfcb)[fn].fDelete = true;
else
    OutSaved(doc);

FreeH((**hpdocdod)[doc].hpctb); /* Free old piece table */
FInitPctb(doc, fn);
(**hpdocdod)[doc].fFormatted = fFormatted;
FreeH((**hpdocdod)[doc].hszFile);
hsz = HszCreate((PCH)szFile);
(**hpdocdod)[doc].hszFile = hsz;

if (fFormatted)
    {
    /* reload font table, which may have changed */

    SmashDocFce(doc);
    FreeFfntb(HffntbGet(doc));
    (**hpdocdod)[doc].hffntb = HffntbCreateForFn(fn, &fDummy);
    //SaveFontProfile(doc);
    ResetDefaultFonts(FALSE);
    }

 /* By diddling the document attributes on save, we have invalidated caches */

 InvalidateCaches( doc );
 vdocParaCache = docNil;

 if (!ferror && !vfBuffersDirty && doc != docScrap)
        ReduceFnScratchFn( fn );

 if (fFormatted)
    {  /* Readjust the running head margins.  We munged them back to the
       paper-relative measurements in FWriteFn, so we'll remunge them
       to margin-relative here. */

 /* With the test for doc != docScrap we fix a major bug, and knowingly at the
    last minute introduce a minor one. The old problem was that we would apply
    a sprm to docScrap, then mash the scratch file in ReduceFnScratch, our
    caller, rendering the bfprm bogus, causing rare crashes.  The new problem
    will be that running head text in the scrap will have incorrect margins
    after a save. */

   if (doc != docScrap)
        ApplyRHMarginSprm( doc );
    InvalidateCaches( doc );
    vdocParaCache = docNil;
    }

 return fn;
}





/***        FWriteFn - write a file
 *
 *      Note: Modified (bz 12/2/85) to allow saving in Word format.
 *            FWriteFn is changed to convert text from ANSI to OEM character
 *            sets, to not put out the font table and to mark
 *            the file header (fib) so the file will be treated as a Word
 *            file.
 *
 */

int FWriteFn(fn, doc, fFormatted)
int fn, doc, fFormatted;
{ /* Write characters from a doc to fn */
/* Return true if successful */
#ifdef CASHMERE
extern int docBuffer;
#endif

typeCP cpMac;
CHAR    *pchFprop;
struct RUN *prun;
struct FIB *pfib;
struct FCB *pfcb;
int     cchT;
struct FNTB **hfntb;
struct FFNTB **hffntb=(struct FFNTB **)NULL;

#ifdef CASHMERE
struct SETB **hsetb = 0, **hsetbT;
#else
struct SEP **hsep;
#endif

struct PGTB **hpgtb;
int ised, csed;
struct SED *psed, *psedT;
int cw;
int fFileFlushed;
int rfn;
CHAR mpftcftc[iffnMax];

struct PAP pap;
struct CHP chp;
struct FKP fkp;

vfnWriting = fn;
vibpWriting = IbpEnsureValid(fn, (typePN)0);

cpMac = (**hpdocdod)[doc].cpMac;

/* FIB has already been written. */
if (fFormatted)
        {

/* KLUDGE: If the doc does not contain at least one complete para,
                   and it has a nonnull tab table,
                   add an Eol to its end to hold the tabs in a FPAP */

        CachePara( doc, cp0 );
        if (vcpLimParaCache > cpMac && (doc != docScrap) &&
            (**hpdocdod) [doc].hgtbd != NULL )
            {
            extern int vdocParaCache;

            InsertEolInsert( doc, cpMac );
            vdocParaCache = docNil;
            cpMac = (**hpdocdod) [doc].cpMac;
            }

                /* Write characters */
                /* Modified to handle ANSI to OEM conversion for Word docs */
        FetchCp(doc, cp0, 0, fcmChars + fcmNoExpand);

                {
                Scribble(4, 'T');

                while (vcpFetch < cpMac && !(vfDiskFull || vfDiskError))
                                        {
#ifdef INTL /* International version */

                if (vWordFmtMode == FALSE) /* no conversion */
#endif  /* International version */

                    WriteRgch(fn, vpchFetch, (int)vccpFetch);

#ifdef INTL /* International version */
                else
                   {
                         /* bufT is a buffer for translating from ANSI to
                         OEM chars.  The amount of data from FetchCp
                         must be no > than a disk page, which is
                         cfcFetch, which is itself cbSector. We use
                         bufT to hold the translated chars, then write
                         them out with WriteRgch. */

                    CHAR bufT[cbSector + 1];
                    CHAR *pch;

                    Assert ((int)vccpFetch <= cbSector);
                      /* load chars into bufT and translate to OEM
                         chars, and write out */
                    pch = (CHAR *) bltbyte(vpchFetch, bufT,
                                           (int)vccpFetch);
                    *pch = '\0';
                    if (vWordFmtMode == TRUE)
                     /* from Write/ANSI to Word/OEM */
                        AnsiToOem((LPSTR)bufT, (LPSTR)bufT);
                    else
                         /* from Word/OEM to Write/ANSI */
                        OemToAnsi((LPSTR)bufT, (LPSTR)bufT);
                    WriteRgch(fn, bufT, (int)vccpFetch);
                   }
#endif  /* International version */


                FetchCp(docNil, cpNil, 0, fcmChars + fcmNoExpand);
                                        }
                Scribble(4,' ');
                }

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Go to beginning of next page */
        AlignFn(fn, cbSector, false);
        (**hpfnfcb)[fn].pnChar = (**hpfnfcb)[fn].pnMac;

        /* Now write char props */
        Scribble(4, 'C');
        fkp.fcFirst = cfcPage; /* first fkp starts with first valid fc */
        fkp.crun = 0;
        prun = (struct RUN *) fkp.rgb;
        pchFprop = &fkp.rgb[cbFkp];
        CachePara(doc, cp0);

        /* set up font mapping and new font table */
        if (!FInitMapSave(doc, &hffntb, mpftcftc))
                goto AbortWrite;

        FetchCp(doc, cp0, 0, fcmProps);
        if (!FMapFtcSave(doc, hffntb, &vchpFetch, mpftcftc))
                goto AbortWrite;

        blt(&vchpFetch, &chp, cwCHP);

        while (vcpFetch < cpMac && !(vfDiskFull || vfDiskError))
                { /* This could be optimized by allowing multiple runs to point */
                    /* to one fchp. */

                if (CchDiffer(&vchpFetch, &chp, cchCHP) != 0)
                        {
                        FAddRun(fn, &fkp, &pchFprop, &prun, &chp,
                            &vchpNormal, cchCHP, vcpFetch + cfcPage);
                        blt(&vchpFetch, &chp, cwCHP);
                        }
                FetchCp(docNil, cpNil, 0, fcmProps);
                if (!FMapFtcSave(doc, hffntb, &vchpFetch, mpftcftc))
                        goto AbortWrite;
                }
        Scribble(4,' ');

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Write out last char run. */
        FAddRun(fn, &fkp, &pchFprop, &prun, &chp, &vchpNormal,
            cchCHP, cpMac + cfcPage);
        WriteRgch(fn, &fkp, cbSector);

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Now write para runs; one for every para */
        Scribble(4,'C');
        (**hpfnfcb)[fn].pnPara = (**hpfnfcb)[fn].pnMac;
        fkp.fcFirst = cfcPage; /* first fkp starts with first valid fc */
        fkp.crun = 0;
        prun = (struct RUN *) fkp.rgb;
        pchFprop = &fkp.rgb[cbFkp];
        CachePara(doc, cp0);

        /* KLUDGE: We have running head indents relative to the
                   margins -- subtract out the margins now, because
                   our (WORD-compatible) file format is PAPER-relative */

        if (vpapAbs.rhc)
            {
            struct SEP *psep = *(**hpdocdod)[ doc ].hsep;

            vpapAbs.dxaLeft += psep->xaLeft;
            vpapAbs.dxaRight += psep->xaMac -
                                        (psep->xaLeft + psep->dxaText);
            }

#ifdef INTL
        /* Ensure no pictures in Word documents. This is necessary
           because Word 4.0 uses the fGraphics bit as part of the
           new border type code (btc) property. */
        if (vWordFmtMode == CONVFROMWORD)
            vpapAbs.fGraphics = FALSE;
#endif
        FAddRun(fn, &fkp, &pchFprop, &prun, &vpapAbs, vppapNormal,
            cchPAP, vcpLimParaCache + cfcPage);
        blt(&vpapAbs, &pap, cwPAP);

        while (vcpLimParaCache <= cpMac && !(vfDiskFull || vfDiskError))
                {
                CachePara(doc, vcpLimParaCache);

                /* KLUDGE: We have running head indents relative to the
                   margins -- subtract out the margins now, because
                   our (WORD-compatible) file format is PAPER-relative */

                if (vpapAbs.rhc)
                    {
                    struct SEP *psep = *(**hpdocdod)[ doc ].hsep;

                    vpapAbs.dxaLeft += psep->xaLeft;
                    vpapAbs.dxaRight += psep->xaMac -
                                        (psep->xaLeft + psep->dxaText);
                    }
#ifdef INTL
                /* Ensure no pictures in Word documents. This is necessary
                   because Word 4.0 uses the fGraphics bit as part of the
                   new border type code (btc) property. */
                if (vWordFmtMode == CONVFROMWORD)
                    vpapAbs.fGraphics = FALSE;
#endif
#ifdef BOGUS
 /* this would have erased all tab setting if saving back a Word document */

                /* For MEMO: the only tabs we write are in the first para run;
                   override all other tab tables to keep files compact */
                if (vpapAbs.rgtbd [0].dxa != 0)
                    bltc( vpapAbs.rgtbd, 0, cwTBD * itbdMax );
#endif
                FAddRun(fn, &fkp, &pchFprop, &prun, &vpapAbs, vppapNormal,
                    FParaEq( &vpapAbs, &pap ) ? -cchPAP : cchPAP,
                      vcpLimParaCache + cfcPage);
                blt(&vpapAbs, &pap, cwPAP);
                }
        WriteRgch(fn, &fkp, cbSector);
        Scribble(4,' ');

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Output footnote table */
        Scribble(4,'F');
        (**hpfnfcb)[fn].pnFntb = (**hpfnfcb)[fn].pnMac;

#ifdef FOOTNOTES   /* In MEMO, we NEVER write a footnote table */
        if ((hfntb = HfntbGet(doc)) != 0)
                {
                WriteRgch(fn, *hfntb,
                    ((**hfntb).cfnd * cwFND + cwFNTBBase) * sizeof (int));
                AlignFn(fn, cbSector, false);
                }

        Scribble(4,' ');
        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;
#endif  /* FOOTNOTES */

#ifdef CASHMERE     /* Output section properties, table from hsetb */
        /* Output section properties */
        Scribble(4,'S');
        (**hpfnfcb)[fn].pnSep = (**hpfnfcb)[fn].pnMac;
        if ((hsetb = HsetbGet(doc)) != 0)
                { /* Write out section props */
                cw = cwSETBBase + (**hsetb).csedMax * cwSED;
                csed = (**hsetb).csed;
                hsetbT = (struct SETB **) HAllocate(cw);
                if (FNoHeap(hsetbT))
                        return false;   /* SHOULD REALLY GOTO ABORTWRITE */
                blt(*hsetb, *hsetbT, cw);
                FreezeHp();
                for (psed = &(**hsetb).rgsed[0], psedT = &(**hsetbT).rgsed[0],
                  ised = 0;
                    ised < csed; psed++, psedT++, ised++)
                        if (psed->fc != fcNil)
                                { /* Copy props to file and update setb */
                                int cch;
                                pchFprop = PchFromFc(psed->fn, psed->fc, &cch);
                                Assert(cch >= *pchFprop + 1);
                                psedT->fn = fn;
                                AlignFn(fn, cch = *pchFprop + 1, false);
                                psedT->fc = (**hpfnfcb)[fn].fcMac;
                                WriteRgch(fn, pchFprop, cch);
                                }
                MeltHp();
                AlignFn(fn, cbSector, false);
                }

        Scribble(4,' ');
        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Output section table */
        (**hpfnfcb)[fn].pnSetb = (**hpfnfcb)[fn].pnMac;
        if (hsetb != 0)
            {
            if (csed != 1 || (**hsetb).rgsed[0].fc != fcNil)
                {
                WriteRgch(fn, *hsetbT,
                    ((**hsetb).csed * cwSED + cwSETBBase) * sizeof (int));
                AlignFn(fn, cbSector, false);
                }
            }
#else       /* MEMO VERSION: Write out a section table, 1 element long,
                             if we had nonstandard section properties */
        {
        typeFC fcSect;

            /* Output section properties */
        fcSect = (long)( cfcPage *
                         ((**hpfnfcb)[fn].pnSep = (**hpfnfcb)[fn].pnMac));

        if ((hsep = (**hpdocdod)[doc].hsep) != 0)
            {
            struct  {
                CHAR cch;
                struct SEP sep;
                }  fsep;
            fsep.cch = cchSEP;
            blt( *hsep, &fsep.sep, cwSEP );
            WriteRgch( fn, &fsep, sizeof( fsep ) );
            AlignFn( fn, cbSector, false );
            }

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

            /* Output section table */
        (**hpfnfcb)[fn].pnSetb = (**hpfnfcb)[fn].pnMac;
        if (hsep != 0)
            {   /* Section table has 1 real + 1 dummy entry with cp==cpMac+1
                   This duplicates the output of PC Word 1.15 */
            struct {
                int csed;
                int csedMax;
                struct SED rgsed [2];
                } setb;

            setb.csed = setb.csedMax = 2;
            setb.rgsed [1].cp = 1 +
                               (setb.rgsed [0].cp = (**hpdocdod)[doc].cpMac);
            setb.rgsed [0].fn = fn;
            setb.rgsed [0].fc = fcSect;
            setb.rgsed [1].fn = fnNil;
            setb.rgsed [1].fc = fcNil;

            WriteRgch( fn, &setb, sizeof( setb ) );
            AlignFn( fn, cbSector, false );
            }
        }
#endif  /* not CASHMERE */

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Output buffer or page table */
        (**hpfnfcb)[fn].pnBftb = (**hpfnfcb)[fn].pnMac;

#ifdef CASHMERE /* No docBuffer in WRITE */
        if(doc == docBuffer)
                {
                WriteBftb(fn);
                AlignFn(fn, cbSector, false);
                }
        else
#endif
        if ((hpgtb = HpgtbGet(doc)) != 0)
                {
                WriteRgch(fn, *hpgtb,
                    ((**hpgtb).cpgd * cwPGD + cwPgtbBase) * sizeof (int));
                AlignFn(fn, cbSector, false);
                }

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Output font table */

#ifdef INTL /* International version */

        /* no font table if saving in Word format */
        if (vWordFmtMode != TRUE) /* no conv or conv from word */
#endif  /* International version */

            {
            Scribble(4,'N');
            (**hpfnfcb)[fn].pnFfntb = (**hpfnfcb)[fn].pnMac;
            WriteFfntb(fn, hffntb);         /* hffntb gets freed below */
            AlignFn(fn, cbSector, false);

            Scribble(4,' ');
            if ((vfDiskFull || vfDiskError))
                    goto AbortWrite;
            }

        /* Now update FIB at beginning of file */
        pfib = (struct FIB *) PchGetPn(fn, pn0, &cchT, true);
        pfib->pnPara = (pfcb = &(**hpfnfcb)[fn])->pnPara;
        pfib->pnFntb = pfcb->pnFntb;
        pfib->pnSep = pfcb->pnSep;
        pfib->pnSetb = pfcb->pnSetb;
        pfib->pnBftb = pfcb->pnBftb;

        /* mark file type if objects are in there */
        if (vcObjects)
            pfib->wIdent = wOleMagic;
        else
            pfib->wIdent = wMagic;

#ifdef INTL /* International version */

        if (vWordFmtMode != TRUE)  /* saving in Write format */
#endif  /* International version */

            {
            pfib->pnFfntb = pfcb->pnFfntb;
            pfib->pnMac = pfcb->pnMac;
            }

#ifdef INTL /* International version */

        else
            {
             /* in Word format there is no font table. pnFfntb is the
                end of the file,so is set to pnMac. The Write pnMac field
                is not used in Word and is set to 0. */
            pfib->pnFfntb = pfcb->pnMac;
            pfib->pnMac = 0;
            }
#endif  /* International version */

        pfib->fcMac = pfcb->fcMac = cpMac + cfcPage;
        if ((**hpdocdod)[doc].dty == dtyNormal)
                {
                CHAR (**hszSsht)[];
#ifdef STYLES
#ifdef DEBUG
                Assert((**hpdocdod)[doc].docSsht != docNil);
#endif
                hszSsht = (**hpdocdod)[(**hpdocdod)[doc].docSsht].hszFile;
#else
                hszSsht = HszCreate((PCH)"");
#endif /* STYLES */
                if (!FNoHeap(hszSsht))
                        {
                        bltbyte(**hszSsht, pfib->szSsht, CchSz(**hszSsht));
#ifndef STYLES
#if WINVER >= 0x300
                        /* Here we WERE allowing the hszSsht from just above
                           to be overwritten by another alloc!  This code
                           really shouldn't even be here because Write knows
                           nothing about style sheets but we want to make as
                           few changes now as possible ..pault 2/12/90 */
                        FreeH(hszSsht);
#endif
#endif
                        hszSsht = HszCreate((PCH)pfib->szSsht); /* HEAP MOVES */
#if WINVER >= 0x300
                        /* Just in case hszSsht has already been assigned
                           here, we'll free it up ..pault 2/12/90 */
                        if ((**hpfnfcb)[fn].hszSsht != NULL)
                            FreeH((**hpfnfcb)[fn].hszSsht);
#endif
                        (**hpfnfcb)[fn].hszSsht = hszSsht;
                        }
                else
                        (**hpfnfcb)[fn].hszSsht = 0;
                }

AbortWrite:
        vfnWriting = fnNil;

        FreeFfntb(hffntb);

        if (vfDiskFull || vfDiskError)
            fFileFlushed = FALSE;
        else
            fFileFlushed = FFlushFn(fn);
        CloseEveryRfn( TRUE );

        if (!fFileFlushed)  /* Writing the file has failed due to disk full */
                {
#ifdef CASHMERE
                if (hsetb != 0)
                        FreeH(hsetbT);
#endif
LFlushFailed:
                FUndirtyFn(fn);  /* Undirty all of the buffer pages
                                    holding parts of the unsuccessfully
                                    written file. */
                return false;
                }

        if (!FMakeRunTables(fn)) /* HM */
                (**hpfnfcb)[fn].fFormatted = false;

        /* Success! */
#ifdef CASHMERE
        if (hsetb != 0)
                { /* HM */
                FreeH(hsetb);
                (**hpdocdod)[doc].hsetb = hsetbT;
                }
#endif
        }
else
        {
        WriteUnformatted(fn, doc);
        vfnWriting = fnNil;
        if (vfDiskFull || vfDiskError)
            fFileFlushed = FALSE;
        else
            fFileFlushed = FFlushFn(fn);
        CloseEveryRfn( TRUE );

        if (!fFileFlushed)
            goto LFlushFailed;
        }
CloseEveryRfn( TRUE );  /* Be real sure the save file is closed */
                        /* This fixes the "pasting between Write
                           instances with the sharer loaded" bug */


return true;
}





/*----------------------------------------------------------------------------
-- Routine: ReduceFnScratchFn
-- Description: this routine is called after successful TS, TGS, GTS and
    !vfBuffersDirty.  Its purpose is to make sure that no doc has pointers
    to fnScratch and that we can empty fnScratch so as to reduce program
    disk space
-- Arguments: none
-- Returns: none
-- Side Effects: docScrap is cleaned up and becomes a new doc that has no
    pointers into fnScratch.  FnScratch is emptied, all global variables
    associated with this new fnScratch are initialized.
-- Bugs:
-- History:
     Apr 16 '84 -- created (chic)
     Aug 9  '85 -- modified it so it puts the scratch file on the same disk
                   as the passed fn to reduce disk swapping on floppy
                   systems.
----------------------------------------------------------------------------*/

ReduceFnScratchFn( fn )
{
int        doc;
struct DOD *pdod;

CHAR       sz[cchMaxFile];

int        cchT;
struct FCB *pfcb;

#ifdef BOGUSBL  /* Because of disk switching, always worth doing */
if ((**hpfnfcb)[fnScratch].fcMac > fcBound)  /* worth doing */
#endif

    {
    for (pdod = &(**hpdocdod)[0],doc = 0; doc < docMac; pdod++,doc++)
        {
        /* don't do anything if any of the allocated doc (hpctb != 0)
           except docScrap is dirty */
        /* docUndo may be dirty, but it also should be empty */

        if (doc != docScrap && pdod->hpctb != 0 && pdod->fDirty &&
            doc != docUndo)
            {
            Assert(0);
            return;
            }
        } /* end of for loop */

    Assert( (**hpdocdod) [docUndo].cpMac == cp0 );

    /* now no doc can possibly has pointers to fnScratch except docScrap */
    pdod = &(**hpdocdod)[docScrap];


#if 0
        This check was only for speed considerations.  With the 64K
        transcendence we *must* clean docScrap no matter what.
        (7.10.91) v-dougk

    if (pdod->cpMac > cpBound) /* too big to be cleaned up */
    {
        Assert(0);
        /**
            But we don't know if docScrap points into fnScratch.  We only need
            to clear docScrap if it points into fnScratch.  We shouldn't
            abort here unless we know that docScrap does indeed point into
            fnScratch.  If it doesn't then we needn't clear it and can proceed
            to clear fnScratch.

            We know that docScratch will not point to any large
            OLE object data in fnScratch because object data is never put
            into fnScratch at a time that the user could select it.
            That is, it is unlikely that the size of docScratch will
            exceed cpBound on account of object data alone.

            Only the presence of large textual data in docScratch
            is likely to cause this failure.
            (7.10.91) v-dougk
         **/
        return;
    }
    else    /* small enough to be cleaned up */
#endif
        {
        if (pdod->cpMac > cp0)
            {
#ifdef STYLES
            /* doc has to have a valid style sheet before CleanDoc */
            pdod->docSsht = (**hpdocdod)[docCur].docSsht;
#endif /* STYLES */
            CachePara(docScrap,cp0);

                /* Save docScrap to new, unique file; name in sz */
            CleanDoc( docScrap, dtyNetwork, sz, true, false );
#ifdef STYLES
            (**hpdocdod)[docScrap].docSsht = docNil;
#endif /* STYLES */
            }
        if (!ferror)  /* in case something went wrong in rename or make backup file in CleanDoc */
            {
            typePN pnMacScratch;

            pfcb = &(**hpfnfcb)[fnScratch];
            pnMacScratch = pfcb->pnMac;
            ResetFn(fnScratch); /* empty FnScratch */

#ifdef DEBUG
            OutputDebugString("*** Reduced scratch file ***\n\r");
#endif

            /* Put the scratch file on the same disk as the save file,
               to reduce disk swapping in floppy environments */

            if ( (fn != fnNil) &&
             !((POFSTRUCT)(**hpfnfcb) [fnScratch].rgbOpenFileBuf)->fFixedDisk )
                {   /* fnScratch is on removable media */
                extern CHAR szExtDoc[];
                CHAR szNewScratch[ cchMaxFile ];
                CHAR (**hszScratch)[] = (**hpfnfcb) [fnScratch].hszFile;
                CHAR chDrive = (**(**hpfnfcb) [fn].hszFile) [0];

                Assert( fn != fnScratch );
                if (FEnsureOnLineFn( fn ))
                    if (GetTempFileName( TF_FORCEDRIVE | chDrive,
                               (LPSTR)(szExtDoc+1), 0, (LPSTR) szNewScratch))
                        {   /* Created new file on same disk as fn */
                        CHAR (**hsz)[];
                        CHAR szNew [cchMaxFile];

#if WINVER >= 0x300
            /* Currently: FNormSzFile  *TAKES*   an OEM sz, and
                                      *RETURNS*  an ANSI sz ..pault */
#endif
                        FNormSzFile( szNew, szNewScratch, dtyNormal );
                        if (!FNoHeap( hsz = HszCreate(szNew)))
                            {
                            struct FCB *pfcb = &(**hpfnfcb)[fnScratch];

                            /* Delete old scratch file */

                            if (FEnsureOnLineFn( fnScratch ))
                                FDeleteFile( &(**hszScratch)[0] );

                            /* Put new scratch file back on line and
                               open it, so OpenFile gets its buffer info */

                            pfcb->hszFile = hsz;
                            pfcb->fOpened = FALSE;

                            FEnsureOnLineFn( fn );
                            FAccessFn( fnScratch, dtyNormal);
                            }
                        }
                }

            pfcb->pnMac = pnMacScratch;
            /* reset all global varibales associated with an empty fnScratch */
            fprmCache.cch = 0;
            fcMacPapIns = 0;
            fcMacChpIns = 0;
            /* just in case */
            pfcb->pnChar = pfcb->pnPara = pfcb->pnFntb = pfcb->pnSep = pfcb->pnSetb = pfcb->pnBftb = pn0;
            vfkpdParaIns.brun = vfkpdCharIns.brun = 0;
            vfkpdParaIns.bchFprop = vfkpdCharIns.bchFprop = cbFkp;
            vfkpdParaIns.pn = PnAlloc(fnScratch);
            ((struct FKP *)PchGetPn(fnScratch, vfkpdParaIns.pn,
                                    &cchT, true))->fcFirst = fc0;
            vfkpdCharIns.pn = PnAlloc(fnScratch);
            ((struct FKP *)PchGetPn(fnScratch, vfkpdCharIns.pn,
                                    &cchT, true))->fcFirst = fc0;
            vfkpdParaIns.ibteMac = vfkpdCharIns.ibteMac = 0;
            blt(&vchpNormal, &vchpInsert, cwCHP);
            blt(vppapNormal, &vpapPrevIns, cwPAPBase + cwTBD);
            } /* end of ferror */
            else
                Assert(0);
        } /* end of small enough to be cleaned up */
    } /* end of worth doing */
} /* end of ReduceFnScratchFn */






ResetFn(fn)
{ /* make fn look as if no characters have been written */
  /* but don't try to reuse fn (in that case, must rehash) */
int ibp;
register struct BPS *pbps;
struct FCB *pfcb;

Assert( fn != fnNil );
(pfcb = &(**hpfnfcb)[fn])->fcMac = fc0;
pfcb->pnMac = pn0;
for (ibp = 0, pbps = &mpibpbps [0]; ibp < ibpMax; ++ibp, ++pbps)
        {    /* find all buffer pages and "clear" them */
        if (pbps->fn == fn)
                {
#ifdef CKSM
#ifdef DEBUG
                extern unsigned (**hpibpcksm) [];

                if (!pbps->fDirty)
                    Assert( (**hpibpcksm) [ibp] == CksmFromIbp( ibp ) );
#endif
#endif
                pbps->fDirty = false;
                pbps->cch = 0;
#ifdef CKSM
#ifdef DEBUG
                    /* Recompute checksum to account for cch change */
                (**hpibpcksm) [ibp] = CksmFromIbp( ibp );
#endif
#endif
                }
        }
}



/***        FBackupSzFile - Make a backup copy of the passed szFile
 *
 *  ENTRY:  szFile - the (assumed normalized) name of the
 *                   file to back up
 *          fBackup - whether the user is interested in seeing
 *                    a backup copy of szFile
 *  EXIT:   szBak - the (normalized) name of the backup
 *                  file is returned through here
 *  RETURNS:    TRUE=We made a backup copy, szBak of szFile
 *              FALSE=We didn't/couldn't make a backup copy
 *
 *  NOTE: We try to put the backup file into the directory used
 *        as the default by GetTempFileName; in general, this
 *        effort will succeed if the directory is on the same
 *        physical drive as the original.
 *  NOTE: we may keep around a backup copy regardless of the
 *  setting of fBackup, to have access to pieces in it.
 *  However, the file's fDelete flag will be set to TRUE, marking
 *  it for eventual deletion
 */

FBackupSzFile( szFile, fBackup, szBak )    /* filenames taken as ANSI */
CHAR szFile[];
int     fBackup;
CHAR szBak[];
{ /* Copy szFile into a backup copy, and give backup old fn. */
  /* Also, return name of backup file */
int fnOld;
int f;
int fDelete = false;
int rfn;
int fTryAgain=FALSE;
CHAR chDriveTempFile;
int fn;
CHAR rgbBuf[ cbOpenFileBuf ];

#ifdef ENABLE
 if ((fn = FnFromSz( szFile )) != fnNil)
        /* Avoid share violations while checking for existence */
    CloseFn( fn );
 if (OpenFile( (LPSTR) szFile, (LPOFSTRUCT) rgbBuf, OF_EXIST ) != -1)
#endif

 if (FExistsSzFile( dtyAny, szFile ))
    {   /* File exists; make backup (even if it's on another floppy) */
    int fSame;

        /* szBak <-- backup file name (it'll be normalized since szFile is) */
    bltsz( szFile, szBak );

#ifdef INTL /* International version */
     /* if file has .WRI extension, put Write .BKP extension on,
        otherwise put Word backup extension (.BAK) on instead. */

    AppendSzExt( szBak, szExtDoc, TRUE );
    fSame = FSzSame( szFile, szBak );   /* Whether file is .WRI */
    AppendSzExt( szBak, (fSame ? szExtBackup : szExtWordBak),
                TRUE );
#else
    AppendSzExt( szBak, szExtBackup, TRUE );
#endif  /* International version */


    fSame = FSzSame( szFile, szBak );   /* Whether file is .BAK already */

    Assert( szBak [1] == ':' );
    chDriveTempFile = szBak[0];    /* Drive on which to create temp file */

    for( ;; )
        {

        if (!fBackup || fSame )
            {    /* This is just being kept for its pieces OR the file
                    happens to be .BAK already: give backup a unique name */
            CHAR szBakT [cchMaxFile];

            if (!fTryAgain)
                {   /* First time through; try not forcing the drive
                       letter to see how we fare.  The advantage is that
                       if we succeed, the temp file is in a more standard
                       place. If the rename fails, we end up at the
                       branch below. */

                fTryAgain = TRUE;       /* Try a second time if we fail */
                if (!GetTempFileName( chDriveTempFile,
                                      (LPSTR)(szExtDoc+1), 0, (LPSTR)szBakT))
                    continue;
                }
            else
                {   /* Second time through -- try forcing the drive */
                    /* Grab a temp file on the same drive as the original */

                fTryAgain = FALSE;  /* No more tries */
                if (!GetTempFileName( chDriveTempFile | TF_FORCEDRIVE,
                                      (LPSTR)(szExtDoc+1), 0, (LPSTR) szBakT))
                    {
                    Error( IDPMTSDE2 ); /* should probably GOTO HARDCORE instead */
                    return FALSE;
                    }
                }

                /* szBakT <-- Temp name in OEM */
                /* szBak  <-- Normalized temporary name in ANSI */
            FNormSzFile( szBak, szBakT, dtyNormal );
            fDelete = TRUE;
            }

        if ((fnOld = FnFromSz(szBak)) != fnNil)
            { /* We have backup open */
            CHAR szT[cchMaxFile];

            FBackupSzFile( szBak, false, szT );
            }

        if ((fnOld = FnFromSz(szFile)) != fnNil)
            { /* We have file open */
/* ? */     FFlushFn(fnOld);
            CloseFn( fnOld );
            }

        /* Rename szFile to be temp name (must delete the empty temp file) */

        if (!FDeleteFile( szBak ) || FIsErrFpe(FpeRenameFile( szFile, szBak )))
            {
            extern HWND vhWnd;
            CHAR szT [cchMaxSz];
            CHAR *pchSrc;

            if (fTryAgain)
                    /* Failed with temp name on the default drive; try again */
                continue;

            /* HARDCORE FAILURE: Could not rename file */
HardCore:
            /* pchSrc <-- ptr to start of filename (sans path) */
#ifdef DBCS //T-HIROYN 1992.07.13
            pchSrc = &szFile [CchSz( szFile )];
            while (pchSrc > szFile) {
                pchSrc = AnsiPrev(szFile,pchSrc);
                if (*pchSrc == '\\')
                    {
                    pchSrc++;
                    break;
                    }
            }
#else
            pchSrc = &szFile [CchSz( szFile ) - 1];
            while (pchSrc > szFile)
                if (*(--pchSrc) == '\\')
                    {
                    pchSrc++;
                    break;
                    }
#endif
            Assert( pchSrc > szFile );  /* Always "X:\" in normalized name */

            MergeStrings (IDPMTRenameFail, pchSrc, szT);
            IdPromptBoxSz( vhWnd, szT, ErrorLevel( IDPMTRenameFail ) );

            return FALSE;  /* We couldn't rename this file to the backup name */
            }

        if (fnOld != fnNil)
            {   /* We had an fn for the renamed file; must update fcb */
            CHAR (**hszBak)[];
            struct FCB *pfcb;

            FreeH((**hpfnfcb)[fnOld].hszFile);  /* HM */
            hszBak = HszCreate((PCH)szBak);

            pfcb = &(**hpfnfcb)[fnOld];
            pfcb->hszFile = hszBak;
            pfcb->fDelete = fDelete;
            }

        else if (!fBackup)
            {   /* Delete this NOW. (!fBackup indicates that the user
                   doesn't care about the backup copy, and Word can't care
                   about its pieces since it doesn't have an fn. So nobody
                   wants it, so we get rid of it) */
            FDeleteFile( szBak );
            return false;
            }

        return true;
        }   /* end   for( ;; ) */
    }   /* end if (FExists... */


return false;   /* file did not exist; make no backup */
}





int FExistsSzFile(dty, szFile)
int dty;
CHAR szFile[];
{ /* Return true iff file exists */
CHAR rgbBuf[ 128 ];     /* Buffer used by OpenFile */
int bRetval;

#ifdef DEBUG
    {
    int junk;
    Assert(FValidFile(szFile, CchSz(szFile)-1, &junk));
    }
#endif /*DEBUG*/

/* Use FnFromSz to avoid share violations on files we have open */

    if (FnFromSz( szFile ) != fnNil)
        return TRUE;

    SetErrorMode(1);
    bRetval = OpenFile( (LPSTR) szFile, (LPOFSTRUCT) rgbBuf, OF_EXIST ) != -1;
    SetErrorMode(0);
    return bRetval;
}





struct PGTB **HpgtbGet(doc)
int doc;
{ /* Return hpgtb if doc has one, 0 if none  */
struct DOD *pdod;

if ((pdod = &(**hpdocdod)[doc])->dty != dtyNormal)
        return 0;
else
        return pdod->hpgtb;
}





FreeFn( fn )
int fn;
{   /* Forget about the existence of file fn.  Assumes no document holds
       pieces from fn.  Frees all heap items in (**hpfnfcb) [fn] and
       marks the fcb as free (rfn == rfnNil).
      */
#define IibpHash(fn,pn) ((int) ((fn + 1) * (pn + 1)) & 077777) % iibpHashMax

 extern int iibpHashMax;
 extern CHAR *rgibpHash;
 extern struct BPS *mpibpbps;

 register struct BPS *pbps;
 int pn;

 extern CHAR (**hszTemp)[];

 register struct FCB *pfcb = &(**hpfnfcb)[fn];
 CHAR (**hsz)[] = pfcb->hszFile;
 CHAR (**hszSsht)[] = pfcb->hszSsht;
 typeFC (**hgfcChp)[]=pfcb->hgfcChp;
 typeFC (**hgfcPap)[]=pfcb->hgfcPap;

 FreezeHp();

 CloseFn( fn );

/* Purge buffer slots holding pages of fn; maintain integrity of hash chains */

 for ( pn = 0; pn < pfcb->pnMac; pn++ )
    FreeBufferPage( fn, pn );

#ifdef DEBUG
 CheckIbp();
#endif

 pfcb->fDelete = FALSE;
 pfcb->hszFile = hszTemp;
 pfcb->rfn = rfnFree;
 MeltHp();

 if ( hsz != hszTemp )
    FreeH( hsz );
#if WINVER >= 0x300
 /* Previously we allocated a small block ("") for the
    style sheet but never freed it!  ..pault 2/12/90 */
 if (hszSsht != NULL)
    FreeH(hszSsht);
#endif
 if (hgfcChp)
    FreeH( hgfcChp );
 if (hgfcPap)
    FreeH( hgfcPap );
}




/***          FUndirtyFn
 *
 *
 */

FUndirtyFn(fn)
int fn;
/*
        Description:    Mark all buffer pages holding parts of this file
                        as non-dirty.
                        Called after a disk full caused writing a file
                        to fail (in FWriteFn).
        Returns:        nothing.
*/
{
#ifdef CKSM
#ifdef DEBUG
        extern unsigned (**hpibpcksm) [];
#endif
#endif
        int ibp;
        struct BPS *pbps;
        for (ibp = 0, pbps = mpibpbps; ibp < ibpMax; ibp++,
                                                     pbps++)
                {
                if (pbps->fn == fn)
                    {
                    pbps->fDirty = FALSE;
#ifdef CKSM
#ifdef DEBUG
                    /* Update checksum */
                    (**hpibpcksm) [ibp] = CksmFromIbp( ibp );
#endif
#endif
                    }
                }

}




/***        IbpWriting - Find buffer page while writing file
 *
 *
 *
 */

IbpWriting(fn)
int fn;
/* called when trying to find a slot in the file page "cache" buffer and */
/* vfnWriting != fnNil (currently in the process of writing some file) */
{
        typeTS dTs;
        int ibp;

        if (fn == vfnWriting)
                {       /* writing a piece of the vfnWriting file */
                /* vibpWriting is the previous slot used to hold file */
                /* contents.  Keep slots contiguous and in the first */
                /* (upper) half of the buffer area. */
                if (vibpWriting > 0)
                    {   /* We may have read multiple pages last time */
                        /* Advance past all slots holding contiguous pages */
                    struct BPS *pbps=&mpibpbps[ vibpWriting ];
                    int pn=(pbps-1)->pn;

                    while ( pbps->fn == fn && pbps->pn == ++pn )
                        {
                        pbps++;
                        vibpWriting++;
                        }
                    vibpWriting--;
                    }

                if (++vibpWriting >= (ibpMax >> 1))
                        vibpWriting = 0;

                /* We must abide by the restriction that */
                /* we do not clobber the cbpMustKeep most recently used */
                /* slots in the process. */
                dTs = tsMruBps - mpibpbps[vibpWriting].ts;
                dTs = ((dTs & 0x8000) ? (~dTs + 1) : dTs);/* absolute value */
                if (dTs < cbpMustKeep)
                        vibpWriting = ibp = IbpLru(0);
                else    /* adjacent slot is o.k. - not too recently used */
                        ibp = vibpWriting;
                }
        else
                /* If currently writing a file (but the current page is */
                /* not part of it), try to find a slot in the lower half */
                /* of the buffer.  This decreases the possibility that the */
                /* adjacent slot to vibpWriting will be too recently used. */
                ibp = IbpLru(ibpMax >> 1);
        return(ibp);
}




WriteFfntb(fn, hffntb)
int fn;
struct FFNTB **hffntb;
{       /* Append a font table (ffntb) to fn */
struct FFNTB *pffntb;
struct FFN *pffn;
int iffn, cbffn;
int cchPageSpace = cbSector;
int cchWrite;
int wEndOfPage = -1;
int wEndOfTable = 0;
int cbT;

pffntb = *hffntb;
cbT = pffntb->iffnMac;
WriteRgch( fn, &cbT, sizeof (int) );
cchPageSpace = cbSector - sizeof (int);

for (iffn = 0; iffn < pffntb->iffnMac; iffn++)
    {
    pffn = *pffntb->mpftchffn[iffn];
    cchWrite = (cbffn = CbFfn(CchSz(pffn->szFfn))) + (2 * sizeof(int));

    if (cchWrite > cchPageSpace)
        {   /* This entry will not fit on the page; start new page */

        Assert( cchPageSpace >= sizeof (int ));
        WriteRgch( fn, &wEndOfPage, sizeof (int) );
        AlignFn( fn, cbSector, false );
        cchPageSpace = cbSector;
        }

    Assert( cchWrite <= cchPageSpace );

#ifdef NEWFONTENUM
    /* let's just pretend we never added a charset field... pault */
    cbffn -= sizeof(BYTE);
    WriteRgch( fn, &cbffn, sizeof (int) );  /* Write entry size in bytes */
    WriteRgch( fn, &pffn->ffid, cbffn );    /* Write the entry */
#else
    WriteRgch( fn, &cbffn, sizeof (int) );  /* Write entry size in bytes */
    WriteRgch( fn, pffn, cbffn );           /* Write the entry */
#endif
    cchPageSpace -= cbffn + sizeof (int);
    }

Assert( cchPageSpace >= sizeof (int) );
WriteRgch( fn, &wEndOfTable, sizeof(int) ); /* Table is terminated with 0000 */
}



FMapFtcSave(doc, hffntb, pchp, mpftcftc)
/* attempt to map the ftc for this chp into it's new ftc in hffntb, according
   to the mapping in mpftcftc.  If there's no entry yet for this ftc, then
   add it to the table.  Returns FALSE if there was some problem */

int doc;
struct FFNTB **hffntb;
struct CHP *pchp;
CHAR *mpftcftc;
{
int ftc, ftcNew;
struct FFN *pffn;
CHAR rgbFfn[ibFfnMax];

ftc = pchp->ftc + (pchp->ftcXtra << 6);
ftcNew = mpftcftc[ftc];
if (ftcNew == ftcNil)
        {
        /* haven't encountered this font yet - add it to hffntb and mpftcftc */
        pffn = *(*HffntbGet(doc))->mpftchffn[ftc];
        bltbyte(pffn, rgbFfn, CbFromPffn(pffn));
        ftcNew = FtcAddFfn(hffntb, pffn);
        if (ftcNew == ftcNil)
                /* some problem adding the font */
                return(FALSE);
        mpftcftc[ftc] = ftcNew;
        }

pchp->ftc = ftcNew & 0x003f;
pchp->ftcXtra = (ftcNew & 0x00c0) >> 6;
return(TRUE);
}



FInitMapSave(doc, phffntb, mpftcftc)
/* sets up for ftc mapping */

int doc;
struct FFNTB ***phffntb;
CHAR *mpftcftc;
{
bltbc( mpftcftc, ftcNil, iffnMax );
return(FNoHeap(*phffntb = HffntbAlloc()) == FALSE);
}




/* O U T  S A V E D */
OutSaved(doc)
int doc;
{
 extern int docMode;
 extern CHAR szMode[];
 int NEAR CchExpCp( CHAR *, typeCP );
 char szTmp[cchMaxSz];

 LoadString(hINSTANCE, IDSTRChars, szTmp, sizeof(szTmp));
 wsprintf(szMode,szTmp,(DWORD)(**hpdocdod)[doc].cpMac);
 docMode = docNil;
 DrawMode();
}




/* C C H  E X P  C P */
int NEAR CchExpCp(pch, cp)
CHAR *pch;
typeCP cp;
{
        int cch = 0;

        if (cp >= 10)
                {
                cch = CchExpCp(pch, cp / 10);
                pch += cch;
                cp %= 10;
                }
        *pch = '0' + cp;
        return cch + 1;
}



#if 0

SaveFontProfile(doc)
/* updates our mru font entries in win.ini */

int doc;
    {
    extern CHAR szWriteProduct[];
    extern CHAR szFontEntry[];
    int iffn;
    struct FFN *pffn;
    CHAR *pchFontNumber, *pchT;
    CHAR rgbProf[LF_FACESIZE + 10]; /* for good measure */
    CHAR rgbFfn[ibFfnMax];

    if (FInitFontEnum(doc, iffnProfMax, FALSE))
        {
        pffn = (struct FFN *)rgbFfn;
        pchFontNumber = szFontEntry + CchSz(szFontEntry) - 2;
        for (iffn = 0; iffn < iffnProfMax; iffn++)
            {
            if (!FEnumFont(pffn))
                break;
#ifdef NEWFONTENUM
#endif
            pchT = (CHAR *)bltbyte(pffn->szFfn, rgbProf, CchSz(pffn->szFfn))-1;
            *pchT++ = ',';
            ncvtu(pffn->ffid, &pchT);
#ifdef NEWFONTENUM
            /* Save the font's charset value as well */
            *pchT++ = ',';
            ncvtu(pffn->chs, &pchT);
#endif
            *pchT = '\0';

            *pchFontNumber = '1' + iffn;
            WriteProfileString((LPSTR)szWriteProduct, (LPSTR)szFontEntry,
                (LPSTR)rgbProf);
            }
        EndFontEnum();
        }
    }

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\txb.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*---------------------------------------------------------------------------
-- Structure: TXB
-- Description and Usage:
    Describes a buffer.  
    Maps the name of a buffer to the associated text, which is stored in 
	docBuffer.
-- Fields:
    hszName	- pointer to a null terminated string in the heap which is
		    the name of this buffer.
    cp		- location in docBuffer
    dcp		- amount of interest in docBuffer
----------------------------------------------------------------------------*/
struct TXB
    {
    CHAR (**hszName)[];
    typeCP	cp;
    typeCP	dcp;
    };


#define cbTxb (sizeof(struct TXB))
#define cwTxb (cbTxb / sizeof(int))
#define hszNil	(0)
#define cidstrRsvd (2)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\undo.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* NOTE: the routines in this file are not written in a manner which minimizes
            code space.  It is anticipated that these routines will be swappable
            and that a reasonable optimizer will be used when compiling the code        */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
//#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
//#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "docdefs.h"
#include "editdefs.h"
#include "cmddefs.h"
#include "str.h"
#include "txb.h"
#include "ch.h"
#include "code.h"
#include "wwdefs.h"
#include "printdef.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifndef CASHMERE
#include "propdefs.h"
#endif /* not CASHMERE */

struct UAB      vuab;

#ifdef ENABLE
VAL rgvalAgain[ivalMax];
#endif

extern struct WWD *pwwdCur;
extern typeCP   cpMacCur;
extern typeCP   cpMinCur;
extern int      vfSeeSel;
extern int      docMac;
extern int      docCur;
extern int      docScrap;
extern int      docUndo;
extern int      docBuffer;
extern int      vdocPageCache;
extern struct DOD (**hpdocdod)[];
extern struct SEL selCur;
extern CHAR (**hszReplace)[];
extern struct TXB (**hgtxb)[];
/*extern int      idstrUndoBase;*/
extern int      vfPictSel;
extern int      ferror;
extern int      docMode;
extern int      vfOwnClipboard; /* Whether this instance owns the clip contents */

#ifndef CASHMERE
extern int      vdocSectCache;
#endif /* not CASHMERE */


fnUndoEdit()
    {
    extern HCURSOR vhcIBeam;
    StartLongOp();
    CmdUndo();
    EndLongOp(vhcIBeam);
    }


/*
The routines in this file implement the "undo" and "again" features in
Multi-Tool Word.  The basic idea is that whenever an editing operation is
about to be done, the global structure "vuab" will be updated to contain
information sufficient to undo or repeat that operation.  The structure
(defined in editdefs.h, declared in this file) looks like this:
    struct UAB
            { UNDO Action Block
            int             uac;     UNDO Action Code (see cmddefs.h)
            int             doc;
            typeCP          cp;
            typeCP          dcp;
            int             doc2;
            typeCP          cp2;
            typeCP          dcp2;
            short               itxb;
            };
Setting up this structure is taken care of by "SetUndo()" which does a lot
of plugging in of values and a couple pseudo-smart things.  These smartish
things are:
    a) If an insert is made and the last operation was a delete
        the two are combined into one "replace" operation.
        This means that undo-ing and again-ing apply to the replace and
        not just the insertion.

    b) When needed (see the code for details) the undo buffer (docUndo)
        is filled with any text that needs preservation for future
        undo-ing or again-ing.  The main example of this is storing away
        the old value of the scrap when an operation is about to clobber
        the scrap.

Here is a list of the various uac values and what info is stored
    other info may be clobbered by the process.
    are defined in cmddefs.h.  Note that none of the "undo" codes
    (those starting with "uacU...") should be set outside of CmdUndo(),
    since they may assume things like contents of docUndo which could
    be wrong.
Note: This list store information used by the again and undo commands.
    Other info may be clobbered by the process.

uacNil          No action stored.
uacInsert
    doc = document text was inserted into
    cp = location at which text was inserted
    dcp = length of inserted text
uacUInsert
    doc = document from which text was removed (un-inserted)
    cp = location at which text was removed
    docUndo = text which was removed
uacReplNS
    doc = document in which replacement occurred
    cp = location at which replacement occurred
    dcp = length of inserted text
    dcp2 = length of deleted text
    docUndo = deleted text
uacUReplNS
    doc = document in which replace occrred
    cp = location of the replace
    dcp = length of re-inserted text
    dcp2 = length of un-inserted text
    docUndo = un-inserted text
uacReplGlobal
uacChLook
uacChLookSect
uacFormatChar
uacFormatPara
uacFormatSection
uacGalFormatChar
uacGalFormatPara
uacGalFormatSection
uacFormatCStyle
uacFormatPStyle
uacFormatSStyle
uacFormatRHText
uacLookCharMouse
uacLookParaMouse
uacClearAllTab
uacFormatTabs
uacClearTab
uacOvertype
    Similar to uacReplNS except that they are agained differently.
uacDelNS
    doc = document from which text was deleted
    cp = location at which text was deleted
    dcp = length of deleted text
    docUndo = deleted text
uacUDelNS
    doc = document in which text was re-inserted
    cp = location at which text was re-inserted
    dcp = length of re-inserted text
uacMove
    doc = document from which text was deleted
    cp = location at which text was deleted
    dcp = length of deleted text
            (also serves as length of inserted text)
    doc2 = document in which text was inserted
    cp2 = location at which text was inserted
uacDelScrap
    doc = document from which text was deleted
    cp = location at which text was deleted
    dcp = length of deleted text
    docUndo = old contents of scrap
uacUDelScrap
    doc = document in which text was re-inserted
    cp = location at which text was re-inserted
    dcp = length of re-inserted text
uacReplScrap
    doc = document in which replacement occurred
    cp = location at which replacement occurred
    dcp = length of inserted text
    docUndo = old contents of scrap
uacUReplScrap
    doc = document in which replacement was undone
    cp = location at which replacement was undone
    dcp = length of re-inserted text
    docUndo = deleted text (was originally inserted)
uacDelBuf
    doc = document from which text was deleted
    cp = location at which text was deleted
    cp2 = location in docBuffer of old contents of buffer
    dcp2 = size of old contents of buffer
    itxb = index of buffer in question
uacUDelBuf
    doc = document in which text was re-inserted
    cp = location of re-insertion
    dcp = amount of text re-inserted
    itxb = index of buffer involved
uacReplBuf
    doc = document in which replace took place
    cp = location of replace
    dcp = length of inserted text
    cp2 = location of old buffer contents in docBuffer
    dcp2 = length of old buffer contents
    itxb = index of buffer involved
uacUReplBuf
    doc = document in which original replace took place
    cp = location of replace
    dcp = length of text which was restored in document
    itxb = index of buffer involved
    docUndo = un-inserted text
uacCopyBuf
    cp = location of old buffer contents in docBuffer
    dcp = length of old buffer contents
    itxb = index of buffer involved
uacUCopyBuf
    cp = location of undone buffer contents in docBuffer
    dcp = length of undone buffer contents
    itxb = index of buffer involved
*/


CmdUndo()
{ /* UNDO */
    typeCP dcpT,cpT,dcpT2;
    int docT;
    int f;
    struct DOD *pdod, *pdodUndo;
    int uac;

#ifndef CASHMERE
    struct SEP **hsep;
    struct TBD (**hgtbd)[];
    struct PGTB **hpgtb;
    struct PGTB **hpgtbUndo;
    struct PGTB **hpgtbT;

    BOOL near FCopyPgtb(int, struct PGTB ***);
#endif /* not CASHMERE */

    TurnOffSel();
    ClearInsertLine();
    switch (uac = vuab.uac)
        {
        struct TXB *ptxb;
        default:/* case uacNil: */
            Assert(false);  /* Won't get here cause menu should be greyed */
            return;
        case uacInsert:
        case uacInsertFtn:
        case uacUDelNS:
            ClobberDoc(docUndo, vuab.doc, vuab.cp, vuab.dcp);
            Replace(vuab.doc, vuab.cp, vuab.dcp, fnNil, fc0, fc0);
            dcpT = cp0;
            vuab.uac = (uac == uacUDelNS) ? uacDelNS : uacUInsert;
/*          idstrUndoBase = uac == uacUDelNS ? IDSTRUndoBase : IDSTRUndoRedo;*/
            SetUndoMenuStr(IDSTRUndoBase);
            if (uac == uacInsertFtn)
                TrashAllWws();  /* Simple, but effective */
            break;
        case uacUInsert:
        case uacDelNS:
            ReplaceCps(vuab.doc, vuab.cp, cp0, docUndo, cp0, dcpT = vuab.dcp);
            vuab.uac = (uac == uacUInsert) ? uacInsert : uacUDelNS;
/*          idstrUndoBase = uac == uacUInsert ? IDSTRUndoBase : IDSTRUndoRedo;*/
            SetUndoMenuStr(IDSTRUndoBase);
            break;

        case uacDelScrap:   /* UNDO CUT */
            if ( !vfOwnClipboard )
                ferror = TRUE;
            else
                {
                ReplaceCps(vuab.doc, vuab.cp, cp0, docScrap, cp0,
                                                dcpT = CpMacText(docScrap));
                vuab.uac = uacUDelScrap;
/*              idstrUndoBase = IDSTRUndoRedo;*/
                SetUndoMenuStr(IDSTRUndoBase);
                ClobberDoc( docScrap, docUndo, cp0, CpMacText( docUndo ) );
                ChangeClipboard();
                }
            break;

        case uacUDelScrap:  /* REDO CUT */
            ClobberDoc( docUndo, docScrap, cp0, CpMacText( docScrap ) );
/*          idstrUndoBase = IDSTRUndoBase;*/
            SetUndoMenuStr(IDSTRUndoBase);
            vuab.uac = uacDelScrap;

            ClobberDoc(docScrap, vuab.doc, vuab.cp, vuab.dcp);
            Replace(vuab.doc, vuab.cp, vuab.dcp, fnNil, fc0, fc0);
            ChangeClipboard();

            dcpT = 0;
            break;
        case uacReplScrap:      /* UNDO COPY */
            if (!vfOwnClipboard)
                ferror = TRUE;
            else
                {
                dcpT = CpMacText(docScrap);
                ReplaceCps(vuab.doc, vuab.cp + vuab.dcp, cp0,
                           docScrap, cp0, dcpT);

                ClobberDoc( docScrap, docUndo, cp0, CpMacText( docUndo ) );

/*              idstrUndoBase = IDSTRUndoRedo;*/
                SetUndoMenuStr(IDSTRUndoBase);
                vuab.uac = uacUReplScrap;

                ClobberDoc(docUndo, vuab.doc, vuab.cp, vuab.dcp);
                Replace(vuab.doc, vuab.cp, vuab.dcp, fnNil, fc0, fc0);
                vuab.dcp = dcpT;
                ChangeClipboard();
                }
            break;
        case uacUReplScrap:      /* REDO COPY */
            dcpT = CpMacText(docUndo);
            ReplaceCps(vuab.doc, vuab.cp + vuab.dcp, cp0,
                       docUndo, cp0, dcpT);

            ClobberDoc( docUndo, docScrap, cp0, CpMacText( docScrap ));
/*          idstrUndoBase = IDSTRUndoBase;*/
            SetUndoMenuStr(IDSTRUndoBase);
            vuab.uac = uacReplScrap;

            ClobberDoc(docScrap, vuab.doc, vuab.cp, vuab.dcp);
            Replace(vuab.doc, vuab.cp, vuab.dcp, fnNil, fc0, fc0);
            vuab.dcp = dcpT;

            ChangeClipboard();
            break;
#ifdef DEBUG
        case uacUCopyBuf:
        case uacCopyBuf:
        case uacUReplBuf:
        case uacReplBuf:
        case uacUDelBuf:
        case uacDelBuf:

            Assert( FALSE );    /* No buffers in MEMO */
#ifdef ENABLE
            DoUndoTxb(); /* Moved to txb.c */
#endif
            break;
#endif  /* DEBUG */
        case uacMove:
            if (!FMoveText(vuab.doc2, vuab.cp2, vuab.dcp, vuab.doc, &vuab.cp, fFalse))
                return;
            dcpT = vuab.dcp;
            cpT = vuab.cp;
            vuab.cp = vuab.cp2;
            vuab.cp2 = cpT;
            docT = vuab.doc;
            vuab.doc = vuab.doc2;
            vuab.doc2 = docT;
            CheckMove();
            break;
        case uacUReplNS:
        case uacChLook:
        case uacChLookSect:
        case uacReplNS:
        case uacFormatChar:
        case uacFormatPara:
        case uacGalFormatChar:
        case uacGalFormatPara:
        case uacGalFormatSection:
        case uacReplGlobal:
        case uacFormatCStyle:
        case uacFormatPStyle:
        case uacFormatSStyle:
        case uacFormatRHText:
        case uacLookCharMouse:
        case uacLookParaMouse:
        case uacClearAllTab:
        case uacClearTab:
        case uacOvertype:

#ifdef CASHMERE
        case uacFormatTabs:
        case uacFormatSection:
#endif /* CASHMERE */

#ifdef BOGUS
            /* Must do insertion first, in front, in case footnote */
/*          if (uac == uacOvertype)
                vuab.dcp2 = CpMin(vuab.dcp, vuab.dcp2);*/
            dcpT = vuab.dcp2;
            ReplaceCps(vuab.doc, vuab.cp, cp0, docUndo, cp0, dcpT);
            ClobberDoc(docUndo, vuab.doc, vuab.cp + dcpT, vuab.dcp);
            Replace(vuab.doc, vuab.cp + dcpT, vuab.dcp, fnNil, fc0, fc0);
            vuab.dcp2 = vuab.dcp;
            vuab.dcp = dcpT;
            if(uac == uacReplNS)
                vuab.uac = uacUReplNS;
            else if(uac == uacUReplNS)
                vuab.uac = uacReplNS;
/*          idstrUndoBase = uac != uacUReplNS ? IDSTRUndoRedo : IDSTRUndoBase;*/
            SetUndoMenuStr(IDSTRUndoBase);
            break;
#endif
        case uacReplPic:
        case uacUReplPic:
        case uacPictSel:
            dcpT = uac != uacPictSel ? vuab.dcp2 : vuab.dcp;
            ReplaceCps(docUndo, dcpT, cp0, vuab.doc, vuab.cp, vuab.dcp);
            ReplaceCps(vuab.doc, vuab.cp, vuab.dcp, docUndo, cp0, dcpT);
            Replace(docUndo, cp0, dcpT, fnNil, fc0, fc0);
            if (uac != uacPictSel)
                {
                vuab.dcp2 = vuab.dcp;
                vuab.dcp = dcpT;
                }
            if (uac == uacPictSel)
                {
                dcpT = (**hpdocdod)[vuab.doc].cpMac - vuab.cp;
                AdjustCp(vuab.doc, vuab.cp, dcpT, dcpT);
                }
            if(uac == uacReplPic)
                vuab.uac = uacUReplPic;
            else if(uac == uacUReplPic)
                vuab.uac = uacReplPic;
            else if(uac == uacReplNS)
                vuab.uac = uacUReplNS;
            else if(uac == uacUReplNS)
                vuab.uac = uacReplNS;
/*          switch(uac)                                          */
/*          {                                                    */
/*          case uacUReplPic:                                    */
/*          case uacUReplNS:                                     */
/*              idstrUndoBase = IDSTRUndoBase;                   */
/*              break;                                           */
/*          case uacReplPic:                                     */
/*          case uacReplNS:                                      */
/*              idstrUndoBase = IDSTRUndoRedo;                   */
/*              break;                                           */
/*          default:                                             */
/*              idstrUndoBase = (idstrUndoBase ==                */
/*                IDSTRUndoRedo) ? IDSTRUndoBase : IDSTRUndoRedo;*/
/*              break;                                           */
/*          }                                                    */
/*---       idstrUndoBase = (uac != uacUReplPic && uac != uacUReplNS) ?
                                                IDSTRUndoRedo : IDSTRUndoBase;---*/
            SetUndoMenuStr(IDSTRUndoBase);
            Select( CpFirstSty( selCur.cpFirst, styChar ),
                    CpLastStyChar( selCur.cpLim ) );
            break;

#ifndef CASHMERE
        case uacRepaginate:
            /* Make a copy of the document's page table. */
            if (!FCopyPgtb(vuab.doc, &hpgtb) || !FCopyPgtb(docUndo, &hpgtbUndo))
                {
                break;
                }

            /* Swap the contents of the entire document with docUndo. */
            dcpT = CpMacText(vuab.doc);
            dcpT2 = CpMacText(docUndo);
            ReplaceCps(docUndo, dcpT2, cp0, vuab.doc, cp0, dcpT);
            ReplaceCps(vuab.doc, cp0, dcpT, docUndo, cp0, dcpT2);
            Replace(docUndo, cp0, dcpT2, fnNil, fc0, fc0);

            /* Swap the page tables of the two documents. */
            if ((hpgtbT = (**hpdocdod)[vuab.doc].hpgtb) != NULL)
                {
                FreeH(hpgtbT);
                }
            (**hpdocdod)[vuab.doc].hpgtb = hpgtbUndo;
            if ((hpgtbT = (**hpdocdod)[docUndo].hpgtb) != NULL)
                {
                FreeH(hpgtbT);
                }
            (**hpdocdod)[docUndo].hpgtb = hpgtb;
            vdocPageCache = docNil;
            break;
        case uacFormatSection:
            pdod = &(**hpdocdod)[vuab.doc];
            pdodUndo = &(**hpdocdod)[docUndo];
            hsep = pdod->hsep;
            pdod->hsep = pdodUndo->hsep;
            pdodUndo->hsep = hsep;
            hpgtb = pdod->hpgtb;
            pdod->hpgtb = pdodUndo->hpgtb;
            pdodUndo->hpgtb = hpgtb;
/*          idstrUndoBase = (idstrUndoBase == IDSTRUndoRedo) ? IDSTRUndoBase :*/
/*            IDSTRUndoRedo;*/
            SetUndoMenuStr(IDSTRUndoBase);
            vdocSectCache = vdocPageCache = docMode = docNil;
            TrashAllWws();
            break;
        case uacRulerChange:
            ReplaceCps(docUndo, vuab.dcp2, cp0, vuab.doc, vuab.cp, vuab.dcp);
            ReplaceCps(vuab.doc, vuab.cp, vuab.dcp, docUndo, cp0, vuab.dcp2);
            Replace(docUndo, cp0, vuab.dcp2, fnNil, fc0, fc0);
            dcpT = vuab.dcp;
            vuab.dcp = vuab.dcp2;
            vuab.dcp2 = dcpT;

            /* This is a kludge to indicate that this is an undone ruler change.
            */
            vuab.itxb = 1 - vuab.itxb;
        case uacFormatTabs:
            pdod = &(**hpdocdod)[vuab.doc];
            pdodUndo = &(**hpdocdod)[docUndo];
            hgtbd = pdod->hgtbd;
            pdod->hgtbd = pdodUndo->hgtbd;
            pdodUndo->hgtbd = hgtbd;
/*          idstrUndoBase = (idstrUndoBase == IDSTRUndoRedo) ? IDSTRUndoBase :*/
/*            IDSTRUndoRedo;*/
            SetUndoMenuStr(IDSTRUndoBase);
            TrashAllWws();
            break;
#endif /* not CASHMERE */

#if UPDATE_UNDO
#if defined(OLE)
        case uacObjUpdate:
        case uacUObjUpdate:
            ObjDoUpdateUndo(vuab.doc,vuab.cp);
            if (uac == uacObjUpdate)
            {
                vuab.uac = uacUObjUpdate;
                SetUndoMenuStr(IDSTRUndoBase);
            }
        break;
#endif
#endif
        }
    if (ferror)
        NoUndo();
    pdod = &(**hpdocdod)[vuab.doc];
    pdodUndo = &(**hpdocdod)[docUndo];
    f = pdod->fDirty;
    pdod->fDirty = pdodUndo->fDirty;
    pdodUndo->fDirty = f;
    f = pdod->fFormatted;
    pdod->fFormatted = pdodUndo->fFormatted;
    pdodUndo->fFormatted = f;

#ifdef CASHMERE
    if (uac != uacMove
#else /* not CASHMERE */
    if (uac != uacMove && uac != uacFormatTabs && uac != uacFormatSection &&
      uac != uacRulerChange
#endif /* not CASHMERE */

      && docCur != docNil && vuab.doc == docCur && vuab.cp >= cpMinCur &&
      vuab.cp + dcpT <= cpMacCur)
        {
        if (uac == uacPictSel)
                {
                Select(vuab.cp, CpLimSty(vuab.cp, styPara));
                vfPictSel = true;
                }
        else
#ifdef BOGUS
                Select( vuab.cp,
                        (dcpT == cp0) ? CpLastStyChar( vuab.cp ) :
                                        vuab.cp + dcpT );
#endif
                Select( vuab.cp, vuab.cp + dcpT );
        vfSeeSel = true;
        }
}


BOOL near FCopyPgtb(doc, phpgtb)
int doc;
struct PGTB ***phpgtb;
    {
    /* This sets *phpgtb to a copy of the page table associated with doc.  FALSE
    is returned iff an error occurs in creating the copy of the page table. */

    struct PGTB **hpgtbT;

    if ((hpgtbT = (**hpdocdod)[doc].hpgtb) == NULL)
        {
        *phpgtb = NULL;
        }
    else
        {
        int cwpgtb = cwPgtbBase + (**hpgtbT).cpgdMax * cwPGD;

        if (FNoHeap(*phpgtb = (struct PGTB **)HAllocate(cwpgtb)))
            {
            return (FALSE);
            }
        blt(*hpgtbT, **phpgtb, cwpgtb);
        }
    return (TRUE);
    }


#ifdef CASHMERE     /* No Repeat-last-command in MEMO */
CmdAgain()
{ /* use the undo action block to repeat a command */
    int uac;
    typeCP dcpT;
    typeCP cpFirst;
    typeCP cpLim;
    typeCP dcp;
    struct DOD *pdod, *pdodUndo;

    /* First check error conditions; this may change selCur */
    switch (uac = vuab.uac)
        {
        case uacReplBuf:
        case uacUReplBuf:
        case uacDelBuf:
        case uacUDelBuf:
        case uacUDelNS:
        case uacDelNS:
        case uacUDelScrap:
        case uacDelScrap:
        case uacUReplNS:
        case uacOvertype:
        case uacReplNS:
        case uacReplGlobal:
        case uacReplScrap:
        case uacUReplScrap:
            /* Ensure OK to delete here */
            if (!FWriteOk(fwcDelete))
                return;
            break;
        case uacUCopyBuf:
        case uacCopyBuf:
            if (false)
                return;
            break;
        case uacUInsert:
        case uacInsert:
            if (!FWriteOk(fwcInsert))
                    return;
            break;
        case uacMove:
            /* Ensure OK to edit here */
            if (!FWriteOk(fwcInsert))
                return;
            break;
        default:
            break;
        }

    /* Now set up cp's and dispatch */
    cpFirst = selCur.cpFirst;
    cpLim = selCur.cpLim;
    dcp = cpLim - cpFirst;
    switch (uac = vuab.uac)
        {
        struct TXB *ptxb;
        default:
        /* case uacNil: */
            _beep();
            return;
#ifdef ENABLE       /* NO GLOSSARY IN MEMO */
        case uacReplBuf:
        case uacUReplBuf:
        case uacDelBuf:
        case uacUDelBuf:
        case uacUCopyBuf:
        case uacCopyBuf:
            DoAgainTxb(dcp, cpFirst);
            break;
#endif  /* ENABLE */
        case uacUInsert:
            ReplaceCps(docCur, cpFirst, cp0, docUndo, cp0, vuab.dcp);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst+vuab.dcp));
            vuab.uac = uacInsert;
            break;
        case uacInsert:
            ClobberDoc(docUndo, vuab.doc, vuab.cp, vuab.dcp);
            ReplaceCps(docCur, cpFirst, cp0, docUndo, cp0, vuab.dcp);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst+vuab.dcp));
            break;
        case uacUDelNS:
        case uacDelNS:
            ClobberDoc(docUndo, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            vuab.dcp = dcp;
            vuab.uac = uacDelNS;
            Select(cpFirst,CpLastStyChar(cpFirst));
            break;
        case uacUDelScrap:
        case uacDelScrap:
            ClobberDoc(docUndo,docScrap,cp0,CpMacText(docScrap));
            ClobberDoc(docScrap, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            vuab.dcp = dcp;
            vuab.uac = uacDelScrap;
            Select(cpFirst, CpLastStyChar(cpFirst));
            break;
        case uacUReplNS:
            vuab.dcp2 = vuab.dcp;
            ReplaceCps(docCur, cpLim, cp0, docUndo, cp0,
                        vuab.dcp = CpMacText(docUndo));
            ClobberDoc(docUndo, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst + vuab.dcp));
            vuab.uac = uacReplNS;
            break;
        case uacOvertype:
            /* for this one vuab.cp2 is the DCP of how much was actually
                inserted */
            vuab.dcp = vuab.cp2;
            /* fall through...*/
        case uacReplNS:
            ClobberDoc(docUndo, vuab.doc, vuab.cp, vuab.dcp);
            ReplaceCps(docCur, cpLim, cp0, docUndo, cp0, vuab.dcp);
            ClobberDoc(docUndo, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            dcpT = vuab.dcp;
            vuab.dcp2 = dcp;
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            vuab.uac = uacReplNS;
            if (ferror) /* the operation (cmd "a") could not be completed
                           due to out of memory */
                NoUndo();
            else
                Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst + dcpT));
            break;
        case uacChLook:
        case uacChLookSect:
#ifdef ENABLE   /* ChLook stuff is not hooked up yet */

            DoChLook(chAgain,0);
#endif
            break;
        case uacReplGlobal:
            ClobberDoc(docUndo, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            vuab.dcp2 = dcp;
            dcp = (typeCP)(CchSz(**hszReplace) - 1);
            InsertRgch(docCur, cpFirst, **hszReplace, dcp, 0, 0);
            vuab.dcp = dcp;
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst + vuab.dcp));
            vuab.uac = uacReplNS;
            break;
        case uacReplScrap:
            ClobberDoc(docUndo, vuab.doc, vuab.cp, vuab.dcp);
            ReplaceCps(docCur, cpLim, cp0, docUndo, cp0, vuab.dcp);
            ClobberDoc(docUndo,docScrap,cp0,CpMacText(docScrap));
            ClobberDoc(docScrap, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst + vuab.dcp));
            break;
#ifdef ENABLE   /* Not used in SAND */
        case uacFormatCStyle:
            DoFormatCStyle(rgvalAgain);
            break;
        case uacFormatPStyle:
            DoFormatPStyle(rgvalAgain);
            break;
        case uacFormatSStyle:
            DoFormatSStyle(rgvalAgain);
            break;
#endif /* ENABLE */
#ifdef ENABLE   /* Not hooked up yet */
        case uacLookCharMouse:
            AgainLookCharMouse();
            break;
        case uacLookParaMouse:
            AgainLookParaMouse();
            break;
#endif /* ENABLE */
#ifdef ENABLE   /* Not used in SAND */
        case uacClearTab:
            DoClearTab(true);
            vuab.uac = uac;
            break;
        case uacClearAllTab:
            CmdClearAllTab();
            vuab.uac = uac;
            break;
#endif /* ENABLE */
#ifdef ENABLE       /* Formatting menu stuff is not hooked up yet */
        case uacFormatTabs:
            DoFormatTabs(true);
            vuab.uac = uac;
            break;
        case uacFormatRHText:
            DoFormatRHText(rgvalAgain);
            break;
        case uacFormatChar:
            DoFormatChar(rgvalAgain);
            break;
        case uacFormatPara:
            DoFormatPara(rgvalAgain);
            break;
        case uacFormatSection:
            DoFormatSection(rgvalAgain);
            break;
#endif  /* ENABLE */
#ifdef STYLES
        case uacGalFormatChar:
            DoGalFormatChar(rgvalAgain);
            break;
        case uacGalFormatPara:
            DoGalFormatPara(rgvalAgain);
            break;
        case uacGalFormatSection:
            DoGalFormatSection(rgvalAgain);
            break;
#endif /* STYLES */
        case uacUReplScrap:
            ReplaceCps(docCur, cpLim, cp0, docUndo, cp0,
                        vuab.dcp = CpMacText(docUndo));
            ClobberDoc(docUndo,docScrap,cp0,CpMacText(docScrap));
            ClobberDoc(docScrap, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst + vuab.dcp));
            vuab.uac = uacReplScrap;
            break;
        case uacMove:
            if (!FMoveText(vuab.doc2, vuab.cp2, vuab.dcp, docCur, &cpFirst, fFalse))
                return;
            vuab.cp = vuab.cp2;
            vuab.cp2 = cpFirst;
            vuab.doc = vuab.doc2;
            vuab.doc2 = docCur;
            CheckMove();
            break;
        }
    vfSeeSel = true;
}
#endif  /* CASHMERE */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\transbuf.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "code.h"
#include "txb.h"
#include "str.h"
#include "docdefs.h"
#include "cmddefs.h"
#include "filedefs.h"
#include "ch.h"
#include "propdefs.h"
#include "fmtdefs.h"
#include "dispdefs.h"
#include "stcdefs.h"
/*#include "toolbox.h"*/
#include "wwdefs.h"

/* New functionality for Sand:  Jan 17, 1984
        Kenneth J. Shapiro                      */

/*---------------------------------------------------------------------------
The following routines form the interface between the buffer code and the
rest of multi-word:
    CmdXfBufClear()     - used by "Transfer Buffer Clear"
    CmdXfBufLoad()      - used by "Transfer Buffer Load"
    CmdXfBufSave()      - used by "Transfer Buffer Save"
----------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
External global references:
----------------------------------------------------------------------------*/
extern int vfSeeSel;
extern struct DOD (**hpdocdod)[];
extern VAL rgval[];
extern int docCur;
extern struct SEL selCur;
extern int YCOCMD;
extern typeCP cpMacCur;
extern int      docScrap;
/*extern WINDOWPTR  ActiveWindow;
extern WINDOWPTR  windowGlos;
*/
extern CHAR       stBuf[];
extern struct WWD *pwwdCur;

extern struct   TXB     (**hgtxb)[]; /* array of txbs.  Sorted for binary search */
extern short    itxbMac;  /* indicates current size of hgtxb */
extern int      docBuffer; /* doc containing all buffer text */
extern int      vfBuffersDirty;
extern int      rfnMac;
extern struct   ERFN     dnrfn[];

#ifdef ENABLE
/*---------------------------------------------------------------------------
-- Routine: CmdXfBufClear()
-- Description and Usage:
    Called by the menu routines to execute "Transfer Buffer Clear"
    rgval[0] contains a list of buffer names, stored in an hsz.
        The list is just as the user typed it.
    Makes the user confirm the action, and then removes all of the named
        buffers.  If no buffers are named, it clear ALL buffers.
-- Arguments: none
-- Returns: nothing
-- Side-effects:
    Clears some subset of the named buffers.
-- Bugs:
-- History:
    3/25/83     - created (tsr)
    4/27/83     - modified to handle list of names (tsr)
----------------------------------------------------------------------------*/
CmdXfBufClear()
    {
#ifdef DEMOA
        DemoErr();
#else
    int ich;
    int itxb;

    if(!cnfrm(IDPMTBufCnfrm))
        return;
    NoUndo();
    if(CchSz(**(CHAR(**)[])rgval[0])==1)
        {
        for(itxb=0; itxb < itxbMac ; itxb++)
            {
            FreeH((**hgtxb)[itxb].hszName);
            }
        FreeH(hgtxb);
        hgtxb = HAllocate(cwTxb);
#ifdef DEBUG
        /* We just freed the space, so it shouldn't be bad now */
        Assert(!FNoHeap(hgtxb));
#endif /*DEBUG*/
        (**hgtxb)[0].hszName = hszNil;
        itxbMac = 0;
        KillDoc(docBuffer);
        docBuffer = DocCreate(fnNil, (CHAR (**)[]) 0, dtyBuffer);
        }
    else
        FClearBuffers(**(CHAR(**)[])rgval[0], CchSz(**(CHAR(**)[])rgval[0])-1,
                    TRUE, &ich);
#endif /* DEMOA */
    }
#endif      /* ENABLE */

#ifdef ENABLE
/*---------------------------------------------------------------------------
-- Routine: CmdXfBufLoad()
-- Description and Usage:
    Called by the menu routines to execute "Transfer Buffer Load"
    rgval[0] contains the name of the file to load.
    Merges references to the loaded buffers into the buffer list stored in
        hgtxb.  Requires additions to docBuffer for each newly one.
-- Arguments: none
-- Returns: nothing
-- Side-effects:
    Can define/clobber many buffers.
-- Bugs:
-- History:
    3/22/83     - created (tsr)
----------------------------------------------------------------------------*/
CmdXfBufLoad()
    {
#ifdef DEMOA
        DemoErr();
#else
    extern CHAR (**hszGlosFile)[];
    /* for each buffer definition in the file:
        a) add the related text to the end of docBuffer
        b) insert or replace the reference for that buffer name
    */
    CHAR (**hszFile)[] = (CHAR (**)[]) rgval[0];
    int fn;
    if ((fn = FnOpenSz(**hszFile, dtyBuffer, TRUE)) == fnNil)
        {
        Error(IDPMTBadFile);
        return;
        }
    NoUndo();
    MergeTxbsFn(fn);
    if ((**hszGlosFile)[0] == 0)
        {
        FreeH(hszGlosFile);
        hszGlosFile = hszFile;
        }
    vfBuffersDirty = true;
#endif /* DEMOA */
    }
#endif  /* ENABLE */


#ifdef ENABLE
/*---------------------------------------------------------------------------
-- Routine: MergeTxbsFn(fn)
-- Description and Usage:
    Given an fn which contains a buffer document, this function reads in
        the text of the file, appending it to docBuffer.  It also reads
        the Bftb from the file in order to build the appropriate mapping
        from buffer name to text.
-- Arguments:
    fn  - file containing buffer definitions.
-- Returns:
    nothing
-- Side-effects:
    builds new buffers onto docBuffer and hgtxb
-- Bugs:
-- History:
    3/24/83     - created (tsr)
----------------------------------------------------------------------------*/
MergeTxbsFn(fn)
int     fn;
    {
    extern struct FCB (**hpfnfcb)[];
    extern short ItxbFromHsz();
    unsigned pbftbFile;
    typePN pn;
    int cchT;
    CHAR (**hbftb)[];
    int *pwBftb;
    int cw;
    int ich;
    short itxbNew;
    struct TXB *ptxbNew;
    typeCP cp, dcp;
    typeCP cpBufMac;
    CHAR(**hszNew)[];
    int docNew;

    CHAR sz[cchMaxSz];

#ifdef DEBUG
    Assert(fn != fnNil && (**hpfnfcb)[fn].fFormatted);
#endif
    if ((pn = (**hpfnfcb)[fn].pnBftb) ==(**hpfnfcb)[fn].pnFfntb)
            return;
    pbftbFile = (unsigned) PchGetPn(fn, pn, &cchT, false);

    hbftb = (CHAR (**) []) HAllocate(cw=((**hpfnfcb)[fn].pnFfntb - (**hpfnfcb)[fn].pnBftb)*cwSector);
    if (FNoHeap((int)hbftb))
        return;
    pwBftb =  *(int **)hbftb;

    blt(pbftbFile, pwBftb, min(cwSector, cw));

    while ((cw -= cwSector) > 0)
            { /* Copy the records to heap */
            blt(PchGetPn(fn, ++pn, &cchT, false), pwBftb += cwSector,
                min(cwSector, cw));
            }

    ich = 0;
    cp = cp0;
    cpBufMac = CpMacText(docBuffer);
    bltsz(**(**hpfnfcb)[fn].hszFile, sz);
    docNew = DocCreate(fn, HszCreate(sz), dtyBuffer); /* HEAP MOVES */
    while((**hbftb)[ich] != '\0')
        {
        bltsz(&(**hbftb)[ich], sz);
        sz[cchMaxSz - 1] = 0;
        hszNew = (CHAR(**)[]) HszCreate(sz); /*** HEAP MOVES ***/
        ich += CchSz(sz);
        bltbyte(&(**hbftb)[ich], &dcp, sizeof(typeCP));
        ich += sizeof(typeCP);
        itxbNew = ItxbFromHsz(hszNew);
#ifdef DEBUG
        Assert(itxbNew >= 0);
#endif /* DEBUG */
        ReplaceCps(docBuffer, cpBufMac, cp0, docNew, cp, dcp); /*HEAP MOVES*/
        ptxbNew = &(**hgtxb)[itxbNew];
        ptxbNew->cp=cpBufMac;
        ptxbNew->dcp=dcp;
        cpBufMac += dcp;
        cp += dcp;
        }
    KillDoc(docNew);
    FreeH((int **)hbftb);
    }
#endif  /* ENABLE */

#ifdef ENABLE
/*---------------------------------------------------------------------------
-- Routine: CmdXfBufSave()
-- Description and Usage:
    Called by the menu routines to execute "Transfer Buffer Save"
    rgval[0] contains the name of the file to save the buffers in.
    Creates a single doc to contain all of the buffers and updates
        hgtxb to reference that doc, cleaning up all of the temporary
        docs that were around.
    Stores that doc in the file, putting a table at the end of the file
        which maps buffer names to locations within the file.
-- Arguments: none
-- Returns: nothing
-- Side-effects:
-- Bugs:
-- History:
    3/22/83     - created (tsr)
----------------------------------------------------------------------------*/
CmdXfBufSave(szFile)
CHAR szFile[];
{
#ifndef WDEMO
        CHAR (**hszFile)[];
        CHAR szBak[cchMaxFile];
        long ltype;

    /* Move file name to local */
/*    bltbyte(**hszFile, szFile, cchMaxFile);*/

    BackupSzFile(szFile, true, szBak, &ltype);
/*    ForcePmt(IDPMTSaving);*/
    NoUndo();
#ifdef STYLES
    (**hpdocdod)[docBuffer].docSsht = (**hpdocdod)[docCur].docSsht;
#endif
    CachePara(docBuffer, cp0);
    CleanDoc(docBuffer, szFile, true, true);
    (**hpdocdod)[docBuffer].docSsht = docNil;
    if (!FNoHeap(hszFile = HszCreate(szFile)))
        {
        FreeH(hszGlosFile);
        hszGlosFile = hszFile;
        }

    vfBuffersDirty = false;
#endif /* not WDEMO */
}
#endif  /* ENABLE */


#ifdef ENABLE
/*---------------------------------------------------------------------------
-- Routine: CleanBuffers()
-- Description and Usage:
    Creates a new docBuffer containing only currently referenced buffer text.
        This is to keep old buffer values from lying around through
        eternity.
-- Arguments: none
-- Returns: nothing
-- Side-effects:
    creates a new doc for docBuffer.
    kills old docBuffer.
-- Bugs:
-- History:
    3/24/83     - create (tsr)
----------------------------------------------------------------------------*/
CleanBuffers()
    {
#ifdef DEMOA

#else
    int docNew;
    short itxb;
    struct TXB *ptxb;
    typeCP cp, cpOld;
    typeCP dcp;


    docNew = DocCreate(fnNil, (CHAR (**)[]) 0, dtyBuffer);
    for(cp=0, itxb=0;itxb<itxbMac;itxb++, cp+=dcp)
        {
        ptxb = &(**hgtxb)[itxb];
        cpOld = ptxb->cp;
        ptxb->cp = cp;
        /* HEAP MOVEMENT */
        ReplaceCps(docNew, cp, cp0, docBuffer, cpOld, dcp = ptxb->dcp);
        }
    KillDoc(docBuffer);
    docBuffer = docNew;
    NoUndo();
#endif /* DEMOA */
    }
#endif  /* ENABLE    */


/*---------------------------------------------------------------------------
-- Routine: WriteBftb(fn)
-- Description and Usage:
    Given an fn for a buffer file that is being written, this routine
        actually writes out the Bftb which maps buffer names to pieces of
        text stored in the file.
-- Arguments:
    fn  - file being written.
-- Returns: nothing
-- Side-effects:
    Writes to the file described by fn.
-- Bugs:
-- History:
    3/24/83     - created (tsr)
----------------------------------------------------------------------------*/
WriteBftb(fn)
int     fn;
    {
#ifdef DEMOA

#else
    short       itxb;
    struct TXB *ptxb;

    for(itxb = 0 ; itxb < itxbMac ; itxb ++ )
        {
        ptxb = &(**hgtxb)[itxb];
        WriteRgch(fn, &(**(ptxb->hszName))[0], CchSz(**(ptxb->hszName)));
        ptxb = &(**hgtxb)[itxb];
        WriteRgch(fn, (CHAR *)&(ptxb->dcp), sizeof(typeCP));
        }
    WriteRgch(fn, "", sizeof(CHAR));
#endif /* DEMOA */
    }

#ifdef ENABLE
int CchCurGlosFile(pfld, pch, fNew, ival)
struct fld *pfld;
CHAR *pch;
int fNew, ival;
{
int cch;
extern CHAR (**hszGlosFile)[];

CleanBuffers();
CloseEveryRfnTB(true);
if((cch = CchSz(**hszGlosFile)-1) == 0)
        cch = CchFillSzId(pch, IDSTRGLYN);
else
        bltbyte(**hszGlosFile, pch, cch);
return(cch);
}
#endif  /* ENABLE */

#ifdef ENABLE
/* F N  N E W  F I L E */
ClearGlosBuf ()
{

                rgval[0] = HszCreate("");
                CmdXfBufClear();
                RecreateListbox(cidstrRsvd + itxbMac);
                return;
}
#endif      /* ENABLE */

#ifdef ENABLE
CloseEveryRfnTB(fRetry)
int fRetry;
    {
    int rfn;

    for(rfn = 0; rfn < rfnMac; rfn++)
        {
        if(dnrfn[rfn].fn != fnNil)
            CloseRfn( rfn );
        }
    }
#endif      /* ENABLE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\transfer.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#include <windows.h>
#include "mw.h"
#include "doslib.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "str.h"
#include "debug.h"

extern int  vfnWriting;


#define IibpHash(fn,pn) ((int) ((fn + 1) * (pn + 1)) & 077777) % iibpHashMax

#define FcMin(a,b) CpMin(a,b)

extern CHAR *rgibpHash;
extern int vfSysFull;
extern struct BPS      *mpibpbps;
extern struct FCB      (**hpfnfcb)[];
extern typeTS tsMruBps;
extern CHAR                     (*rgbp)[cbSector];
#ifdef CKSM
#ifdef DEBUG
extern unsigned (**hpibpcksm) [];
#endif
#endif

/* WriteDirtyPages kicks out of memory as much of the previous files as it can
    in order to fill the page buffers with a new file.  This is called on
    every transfer load of a file. */
WriteDirtyPages()
{/*
    Description: Cleans the buffer pool of all dirty pages by writing them
                 out to disk.  If a disk full condition is reached, only
                 pages which actually made it to disk are marked as non
                 dirty.
    Returns:     nothing.
 */
    int ibp;
    struct BPS *pbps = &mpibpbps [0];

    for (ibp = 0; ibp < ibpMax; ++ibp, ++pbps)
            {
#ifdef CKSM
#ifdef DEBUG
            if (pbps->fn != fnNil && !pbps->fDirty)
                Assert( (**hpibpcksm) [ibp] == CksmFromIbp( ibp ) );
#endif
#endif
            if (pbps->fn != fnNil && pbps->fDirty)
                    {
                    FFlushFn(pbps->fn);
                         /* keep on flushing if failure ? */
                    }
            }
}


ReadFilePages(fn)
int fn;
    {
/*
        Description: ReadFilePages tries to read in as much of a file as
                it can. The idea is to fill the page buffers in anticipation of
                much access.  This is called on every Transfer Load of a file.
                If fn == fnNil or there are no characters in the file, ReadFilePages
                simply returns.
        Returns: nothing
 */
    int ibp;
    int cfcRead;
    int cpnRead;
    int dfcMac;
    typeFC fcMac;
    int ibpReadMax;
    int cfcLastPage;
    int iibp;
    struct FCB *pfcb;
        typeTS ts;

    if (fn == fnNil)
            return;

    /* Write ALL dirty pages to disk */
    WriteDirtyPages(); /* Just in case */

    pfcb = &(**hpfnfcb)[fn];

    /* we read as much of the file as will fit in the page buffers */
    /* Note that we assume that fcMax is coercable to an integer.  This
        is valid as long as ibpMax*cbSector < 32k */
    dfcMac = (int) FcMin(pfcb->fcMac, (typeFC) (ibpMax * cbSector));
    if (dfcMac == 0)
        return;
    if (vfSysFull) /* call to FFlushFn in WriteDirtyPages failed.
                      the buffer algorithm assures us that the first
                      cbpMustKeep ibp's do not contain scratch file
                      information.  Thus, there is no danger in overwriting
                      these ibps. */
        dfcMac = imin( dfcMac, (cbpMustKeep * cbSector) );

    Assert( ((int)dfcMac) >= 0 );

    /* Read pages from the file */

    cfcRead = CchReadAtPage( fn, (typePN) 0, rgbp [0], (int) dfcMac, FALSE );

    /* cfcRead contains a count of bytes read from the file */
    ibpReadMax = ((cfcRead-1) / cbSector) + 1;
    cfcLastPage = cfcRead - (ibpReadMax-1)*cbSector;
    ts = ibpMax;

    /* order time stamps so the beginning slots have the greatest ts.
    Lru allocation will start at the end of the buffer table and work
    backward.  Thus, the first page of the current file is considered
    the most recently used item.
    */

    /* describe the newly filled pages */
    for(ibp = 0; ibp < ibpReadMax; ++ibp)
        {
        struct BPS *pbps = &mpibpbps[ibp];
        pbps->fn = fn;
        pbps->pn = ibp;
        pbps->ts = --ts;
        pbps->fDirty = false;
        pbps->cch = cbSector;
        pbps->ibpHashNext = ibpNil;
        }

#ifdef CKSM
#ifdef DEBUG
    {
    int ibpT;

    for ( ibpT = 0; ibpT < ibpReadMax; ibpT++ )
        (**hpibpcksm) [ibpT] = CksmFromIbp( ibpT );
    }
#endif
#endif

    /* fix some boundary conditions */
    mpibpbps[ibpReadMax-1].cch = cfcLastPage; /* ?????? */
#ifdef CKSM
#ifdef DEBUG
    (**hpibpcksm) [ibpReadMax - 1] = CksmFromIbp( ibpReadMax - 1 );
#endif
#endif

    /* update descriptions of untouched page buffers */
    for (ibp=ibpReadMax; ibp < ibpMax; ibp++)
        {
        struct BPS *pbps = &mpibpbps[ibp];
        pbps->ts = --ts;
        pbps->fDirty = false;
        pbps->ibpHashNext = ibpNil;

#ifdef CKSM
#ifdef DEBUG
        if (pbps->fn != fnNil)
            (**hpibpcksm) [ibp] = CksmFromIbp( ibp );
#endif
#endif
        }

        tsMruBps = ibpMax - 1;

    /* recalculate the hash table */
    RehashRgibpHash();

} /* end of  R e a d F i l e P a g e s  */


RehashRgibpHash()
{
int iibp;
register struct BPS *pbps;
struct BPS *pbpsMax = &mpibpbps[ibpMax];
int iibpHash;
int ibpT;
int ibpPrev;
int ibp;

    for (iibp = 0; iibp < iibpHashMax; iibp++)
        rgibpHash[iibp] = ibpNil;

    for (ibp = 0, pbps = &mpibpbps[0]; pbps < pbpsMax; pbps++, ibp++)
        {
        if (pbps->fn == fnNil)
            continue;
        iibpHash = IibpHash(pbps->fn, pbps->pn);
        ibpT = rgibpHash[iibpHash];
        ibpPrev = ibpNil;
        while (ibpT != ibpNil)
            {
            ibpPrev = ibpT;
            ibpT = mpibpbps[ibpT].ibpHashNext;
            }
        if (ibpPrev == ibpNil)
            rgibpHash[iibpHash] = ibp;
        else
            mpibpbps[ibpPrev].ibpHashNext = ibp;
        }
#ifdef DEBUG
    CheckIbp();
#endif
} /* end of RehashRgibpHash */



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\trans4.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* trans4.c -- routines brought from trans2.c due to compiler stack overflow */

#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "propdefs.h"
#define NOUAC
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "editdefs.h"
#include "printdef.h"
#define NOKCCODES
#include "ch.h"
#define NOSTRUNDO
#define NOSTRERRORS
#include "str.h"
#include "debug.h"
#include "fontdefs.h"


CHAR    *PchGetPn();
CHAR    *PchFromFc();
typePN  PnAllocT2();
struct  PGTB **HpgtbGet();


extern int             vfnWriting;
extern struct BPS      *mpibpbps;
extern typeTS          tsMruBps;
extern int             vibpWriting;
extern CHAR            (**vhrgbSave)[];
extern struct DOD      (**hpdocdod)[];
extern int             docCur;
extern int             docMac;
extern int             docScrap;
extern int             docUndo;
extern struct FCB      (**hpfnfcb)[];
extern int             fnMac;
extern int             wwMac;
extern int             vfBuffersDirty;
extern int             vfDiskFull;
extern int             vfDiskError;
extern typeCP          vcpFetch;
extern CHAR            *vpchFetch;
extern int             vccpFetch;
extern typeFC          fcMacPapIns;
extern typeFC          fcMacChpIns;
extern typeCP          vcpLimParaCache;
extern struct FKPD     vfkpdCharIns;
extern struct FKPD     vfkpdParaIns;
extern struct PAP      vpapPrevIns;
extern struct PAP      vpapAbs;
extern struct PAP      *vppapNormal;
extern struct CHP      vchpNormal;
extern struct CHP      vchpInsert;
extern struct CHP      vchpFetch;
extern unsigned        cwHeapFree;
extern struct FPRM     fprmCache;

extern int              ferror;
extern CHAR             szExtBackup[];
extern CHAR             (**hszTemp)[];

#ifdef INTL /* International version */

extern int  vWordFmtMode; /* used during saves. If false, no conversion is
			      done. True is convert to Word format,CVTFROMWORD
			      is translate chars from Word character set at
			      save */
#endif  /* International version */


/***        WriteUnformatted - Write unformatted document to file
 *
 *
 *
 */


WriteUnformatted(fn, doc)
int fn;
int doc;
{
 extern typeCP vcpLimParaCache;
 extern typeCP cpMinCur, cpMacCur;
 typeCP cpMinCurT = cpMinCur;
 typeCP cpMacCurT = cpMacCur;
 typeCP cpNow;
 typeCP cpLimPara;
 typeCP cpMac = (**hpdocdod) [doc].cpMac;

 /* Expand range of interest to whole document (for CachePara) */

 cpMinCur = cp0;
 cpMacCur = cpMac;

 /* Loop on paras */

 cpNow = cp0;
 for ( cpNow = cp0; cpNow < cpMac; cpNow = cpLimPara )
    {
LRestart:    
    CachePara( doc, cpNow );
    cpLimPara = vcpLimParaCache;
    if (vpapAbs.fGraphics)
        continue;

    /* Now write out the para, a run at a time */

                
    while ((cpNow < cpLimPara && cpNow < cpMacCur) 
		   && !(vfDiskFull || vfDiskError))
        {
		extern typeCP CpMin();
        extern int vccpFetch;
        int ccpAccept;
		CHAR bufT[cbSector + 1];
		CHAR *pch;

        FetchCp( doc, cpNow, 0, fcmChars + fcmNoExpand );
		Assert (vccpFetch <= cbSector);
#ifdef WINVER >= 0x300        
        if (vccpFetch == 0)
            {
            /* In this case we've had an error with a "hole" in the
               the piece table due to hitting a mem-alloc error -- we 
               won't ever advance cpNow!  To get around this we bump 
               cpNow to the cpMin of the next piece and continue by 
               doing a CachePara on the next piece  3/14/90..pault */

            struct PCTB *ppctb = *(**hpdocdod)[doc].hpctb;
            int ipcd = IpcdFromCp(ppctb, cpNow);
            struct PCD *ppcd = &ppctb->rgpcd[ipcd + 1]; /* NEXT piece */

            cpNow = ppcd->cpMin;
            goto LRestart;
            }
#endif
        ccpAccept = (int) CpMin( (typeCP)vccpFetch, (cpLimPara - cpNow));

#ifdef INTL /* International version */
		if (vWordFmtMode != TRUE)  /* no character set conversion */
#endif  /* International version */

			WriteRgch( fn, vpchFetch, ccpAccept );

#ifdef INTL /* International version */
        else   /* convert to OEM set */
			{
			 /* convert ANSI chars to OEM for Word format file */
			/* load chars into bufT and translate to OEM
			 chars, and write out */
			pch = (CHAR *) bltbyte(vpchFetch, bufT, 
			  (int)ccpAccept);
			*pch = '\0';
			AnsiToOem((LPSTR)bufT, (LPSTR)bufT);
			WriteRgch(fn, bufT, (int)ccpAccept);
		   }
#endif  /* International version */

        cpNow += ccpAccept;
        }
        if ((vfDiskFull || vfDiskError))
                break;

    }

 /* Restore cpMinCur, cpMacCur */

 cpMinCur = cpMinCurT;
 cpMacCur = cpMacCurT;
}




/***        PurgeTemps - Delete all temporary files not referenced in any doc
 *
 */

PurgeTemps()
{ /* Delete all temporary files not referenced in any doc */
int fn;
struct FCB *pfcb, *mpfnfcb;
struct DOD *pdod;
struct PCD *ppcd;
int doc;

Assert(fnScratch == 0);
FreezeHp();
mpfnfcb = &(**hpfnfcb)[0];

#ifdef DFILE
    CommSz("PurgeTemps:\n\r");
#endif

/* Prime the doc/piece table loop */
/* Find the first valid doc (there is guaranteed to be one) */
/* Set up doc, pdod, ppcd */
for (doc = 0, pdod = &(**hpdocdod)[0]; pdod->hpctb == 0; doc++, pdod++)
        continue;
ppcd = &(**pdod->hpctb).rgpcd[0];

/* Now go through the deletable files, looking for references */
for (fn = fnScratch + 1, pfcb = &mpfnfcb[fnScratch + 1];
    fn < fnMac; fn++, pfcb++)
        { /* For each file (don't bother with scratch file) */
        /* Fn must be valid, deletable, and not previously referenced */
        /* if (pfcb->rfn != rfnFree && pfcb->fDelete && !pfcb->fReferenced &&
            fn != fnPrint) */
        if (pfcb->rfn != rfnFree && pfcb->fDelete && !pfcb->fReferenced)
                { /* For each deletable fn */
                int fnT;

                for (;;)
                        { /* Until we determine there is or isn't a ref */
                        if (doc >= docMac)
                                goto OutOfDocs;
                        while ((fnT = ppcd->fn) == fnNil)
                                { /* End of pctb */
#ifdef CASHMERE
                                struct SETB **hsetb = pdod->hsetb;
                                if (hsetb != 0)
                                        { /* Check section table. Doesn't need to be quite
                                                as smart as piece table checker; smaller. */
                                        int csed = (**hsetb).csed;
                                        struct SED *psed = &(**hsetb).rgsed[0];
                                        while (csed--)
                                                {
                                                fnT = psed->fn;
                                                if (fnT == fn) /* Referenced. */
                                                        goto NextFn;
                                                if (fnT > fn) /* Future fn referenced */
                                                        mpfnfcb[fnT].fReferenced = true;
                                                psed++;
                                                }
                                        }
#endif
                                while (++doc < docMac && (++pdod)->hpctb == 0)
                                        continue;
                                if (doc >= docMac)
                                    {
OutOfDocs:                            /* No references to this fn, delete it */
                                    MeltHp();
#ifdef DFILE
        {
        char rgch[200];
        wsprintf(rgch,"    fn %d, %s \n\r", fn,(LPSTR)(**pfcb->hszFile));
        CommSz(rgch);
        }
#endif        
                                    FDeleteFn(fn);    /* HEAP MOVEMENT */
                                    FreezeHp();

                                    /* NOTE: Once we get here, there is no   */
                                    /* further use of pdod or ppcd; we zip   */
                                    /* through the remaining fn's and just   */
                                    /* test fcb fields.  Therefore, pdod     */
                                    /* and ppcd are not updated although     */
                                    /* there was (maybe) heap movement above */

                                    mpfnfcb = &(**hpfnfcb)[0];
                                    pfcb = &mpfnfcb[fn];

                                    goto NextFn;
                                    }
                                ppcd = &(**pdod->hpctb).rgpcd[0];
                                }
                        if (fnT == fn) /* A reference to this fn */
                                goto NextFn;
                        if (fnT > fn) /* Ref to a future fn */
                                mpfnfcb[fnT].fReferenced = true;
                        ++ppcd;
                        }
                }
        else
                pfcb->fReferenced = false;
NextFn: ;
        }
MeltHp();
}


#if WINVER >= 0x300
/* We only use one document at a time, thus in general we won't have
   doc's referencing pieces from multiple fns (unless they've been 
   pasted and reference docscrap or something).  

   In any case we want to free up these files esp. for network user 
   convenience.  The dilemma in particular is when someone's opened
   a file on the net and then does a File.New, File.SaveAs, or File.Open
   and is using another file -- we don't release the previous one so
   another user will get a sharing error even though it seems that file
   should be free!

   Modeled after PurgeTemps() above  ..pault 10/23/89 */

void FreeUnreferencedFns()
    {
    int fn;
    struct FCB *pfcb, *mpfnfcb;
    struct DOD *pdod;
    struct PCD *ppcd;
    int doc;

    Assert(fnScratch == 0);
    FreezeHp();
    mpfnfcb = &(**hpfnfcb)[0];
    
    /* Prime the doc/piece table loop */
    /* Find the first valid doc (there is guaranteed to be one) */
    /* Set up doc, pdod, ppcd */
    for (doc = 0, pdod = &(**hpdocdod)[0]; pdod->hpctb == 0; doc++, pdod++)
        continue;
    ppcd = &(**pdod->hpctb).rgpcd[0];
#ifdef DFILE
    CommSz("FreeUnreferencedFns: \n\r");
#endif

    for (fn = fnScratch + 1, pfcb = &mpfnfcb[fnScratch + 1]; fn < fnMac; fn++, pfcb++)
        { /* For each file (don't bother with scratch file) */
        
#ifdef DFILE
        {
        char rgch[200];
        wsprintf(rgch,"    fn %d, %s \trfnFree %d fRefd %d fDelete %d  ",
                fn,(LPSTR)(**pfcb->hszFile),pfcb->rfn==rfnFree,pfcb->fReferenced,pfcb->fDelete);
        CommSz(rgch);
        }
#endif        
        /* For each unreferenced fn, we ask: is this file the current
           document being edited?  If so then we definitely don't want
           to free up the file.  However PREVIOUS documents that were
           being edited can now "be free".  Temp files are not freed
           here because we want them to be remembered so they are deleted
           at the end of the Write session 2/1/90 ..pault */
        
        if ((WCompSz(*(**hpdocdod)[ docCur ].hszFile,**pfcb->hszFile)==0)
            || pfcb->fDelete)
            goto LRefd;
        else if (pfcb->rfn != rfnFree && !pfcb->fReferenced)
            {
            int fnT;

            for (;;)
                { /* Until we determine there is or isn't a ref */
                if (doc >= docMac)
                    {
                    goto OutOfDocs;
                    }
                while ((fnT = ppcd->fn) == fnNil)
                    { /* End of pctb */
                    while (++doc < docMac && (++pdod)->hpctb == 0)
                        continue;
                    if (doc >= docMac)
                        {
OutOfDocs:              /* No references to this fn, delete it */

                        MeltHp();
#ifdef DFILE
                        CommSz(" FREEING!");
#endif                        
                        FreeFn(fn);    /* HEAP MOVEMENT */
                        FreezeHp();

                        /* NOTE: Once we get here, there is no   */
                        /* further use of pdod or ppcd; we zip   */
                        /* through the remaining fn's and just   */
                        /* test fcb fields.  Therefore, pdod     */
                        /* and ppcd are not updated although     */
                        /* there was (maybe) heap movement above */

                        mpfnfcb = &(**hpfnfcb)[0];
                        pfcb = &mpfnfcb[fn];

                        goto NextFn;
                        }
                    ppcd = &(**pdod->hpctb).rgpcd[0];
                    }
                if (fnT == fn) /* A reference to this fn */
                    {
                    goto NextFn;
                    }
                if (fnT > fn) /* Ref to a future fn */
                    {
                    mpfnfcb[fnT].fReferenced = true;
                    }
                ++ppcd;
                }
            }
        else
            {
LRefd:
            pfcb->fReferenced = false;
            }
NextFn: ;
#ifdef DFILE
        CommSz("\n\r");
#endif        
        }
    MeltHp();
    }
#endif /* WIN30 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\util.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* util.c -- more frequently used utility routines */
#define NOCOLOR
#define NOCOMM
#define NOCLIPBOARD
#define NOCTLMGR
#define NOGDICAPMASKS
#define NOMENUS
#define NOSOUND
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#include <windows.h>

#if WINVER < 0x300
#define SM_CURSORLEVEL 25
#endif

#include "mw.h"
#include "doslib.h"
#include "str.h"
#include "machdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "docdefs.h"
#include "debug.h"
#include "editdefs.h"
#include "wwdefs.h"
#define NOKCCODES
#include "ch.h"

extern struct DOD   (**hpdocdod)[];
extern HANDLE       hMmwModInstance;

CHAR *PchFillPchId(PCH, int);

typeCP CpMax(cp1, cp2)
typeCP cp1, cp2;
{{ /* return larger of two cps */
    return((cp1 > cp2) ? cp1 : cp2);
}} /* end of C p M a x  */


typeCP CpMin(cp1, cp2)
typeCP cp1, cp2;
{{ /* return smaller of two cps */
    return((cp1 < cp2) ? cp1 : cp2);
}} /* end of C p M i n  */


unsigned umin( w1, w2 )
register unsigned w1, w2;
{  return (w1 < w2) ? w1 : w2;  }


unsigned umax( w1, w2 )
register unsigned w1, w2;
{  return (w1 > w2) ? w1 : w2;  }


int imin( i1, i2 )
register int i1, i2;
{  return (i1 < i2) ? i1 : i2;  }


int imax( i1, i2 )
register int i1, i2;
{  return (i1 > i2) ? i1 : i2;  }


#define BZNATIVE
#ifndef BZNATIVE
/* C C H  D I F F E R */
/* commented out, moved to native code in lib.asm bz 6/20/85 */
int CchDiffer(rgch1, rgch2, cch)
register CHAR *rgch1, *rgch2;
int cch;
{{ /* Return cch of shortest prefix leaving a common remainder */
int ich;

for (ich = cch - 1; ich >= 0; ich--)
    if (rgch1[ich] != rgch2[ich])
        break;
return ich + 1;
}}
#endif


int CchSz(sz)
register CHAR  sz[];
{ /* Returns length of string in bytes, including trailing 0 */
    register int cch = 1;
    while (*sz++ != 0)
        cch++;
    return cch;
} /* end of  C c h S z */



typeCP CpMacText(doc)
register int doc;
{
#ifdef FOOTNOTES
    struct FNTB **hfntb;
    if ((hfntb = HfntbGet(doc)) != 0)
        return((**hfntb).rgfnd[0].cpFtn - ccpEol);
    else
#endif /* FOOTNOTES */
        return((**hpdocdod)[doc].cpMac);

} /* end of C p M a c T e x t */


struct FNTB **HfntbGet(doc)
register int doc;
{ /* Return hfntb if doc has one, 0 if none or style sheet */
#ifdef STYLES
    register struct DOD *pdod;

    if ((pdod = &(**hpdocdod)[doc])->dty == dtySsht)
        return 0;
    else
#endif
        return (**hpdocdod)[doc].hfntb;
} /* end of  H F n t b G e t  */


/* N O  U N D O */
NoUndo()
{
    extern struct UAB vuab;
    vuab.uac = uacNil;
    SetUndoMenuStr(IDSTRUndoBase);
} /* end of  N o U n d o  */




SetUndoMenuStr(idstr)
int idstr;
{
    extern int idstrCurrentUndo;

    idstrCurrentUndo = idstr;
}


/* Returns number chars copied EXCLUDING zero terminator */

int CchCopySz(pchFrom, pchTo)
register PCH pchFrom;
register PCH pchTo;
{
int cch = 0;
while ((*pchTo = *pchFrom++) != 0)
    {
    pchTo++;
    cch++;
    }
return cch;
} /* end of  C c h C o p y S z  */




/*---------------------------------------------------------------------------
-- Routine: WCompSz(psz1,psz2)
-- Description and Usage:
    Alphabetically compares the two null-terminated strings lpsz1 and lpsz2.
    Upper case alpha characters are mapped to lower case.
    Comparison of non-alpha characters is by ascii code.
    Returns 0 if they are equal, a negative number if lpsz1 precedes lpsz2, and
    a non-zero positive number if lpsz2 precedes lpsz1.
-- Arguments:
    psz1, psz2  - pointers to two null-terminated strings to compare
-- Returns:
    a short - 0 if strings are equal, negative number if lpsz1 precedes lpsz2,
    and non-zero positive number if psz2 precedes psz1.
-- Side-effects: none
-- Bugs:
-- History:
    3/14/83 - created (tsr)
    6/12/86 - Kanji Version (yxy)
----------------------------------------------------------------------------*/
short

WCompSz(psz1,psz2)
register PCH psz1;
register PCH psz2;
{
    int ch1;
    int ch2;

    for(ch1=ChLower(*psz1++),ch2=ChLower(*psz2++);
      ch1==ch2;
    ch1=ChLower(*psz1++),ch2=ChLower(*psz2++))
    {
    if(ch1 == '\0')
        return(0);
    }
    return(ch1-ch2);
} /* end of  W C o m p S z   */


/*---------------------------------------------------------------------------
-- Routine: ChLower(ch)
-- Description and Usage:
    Converts its argument to lower case iff its argument is upper case.
    Returns the de-capitalized character or the initial char if it wasn't caps.
-- Arguments:
    ch      - character to be de-capitalized
-- Returns:
    a character - initial character, de-capitalized if needed.
-- Side-effects:
-- Bugs:
-- History:
    3/14/83 - created (tsr)
----------------------------------------------------------------------------*/
int
ChLower(ch)
register CHAR    ch;
{ /* use Windows' ANSI char set, the difference of upper/lower case
     is also 20 (HEX) for foreign chars */
#ifdef JAPAN
// check for half-size katakana.
    extern struct WWD       rgwwd[];
    extern BOOL IsKanaInDBCS(int);
    static TEXTMETRIC   tm;


/**/
    BOOL ret1;
    BOOL ret2;
#if 0 //T-HIROYN
    ret1 = IsWindow(wwdCurrentDoc.wwptr);
    ret2 = GetTextMetrics(wwdCurrentDoc.hDC,(LPTEXTMETRIC)&tm);
    if(ret1 && ret2)
    {
        if(tm.tmCharSet == SHIFTJIS_CHARSET && IsKanaInDBCS((int)ch))
            return (int)(0x00ff&ch);
    }
#else
    ret1 = IsWindow(wwdCurrentDoc.wwptr);
    if (ret1)
    {
        ret2 = GetTextMetrics(wwdCurrentDoc.hDC,(LPTEXTMETRIC)&tm);
        if(ret2)
        {
            if(tm.tmCharSet == SHIFTJIS_CHARSET && IsKanaInDBCS((int)ch))
                return (int)(0x00ff&ch);
        }
    }
#endif
#if 0
    if(IsWindow(wwdCurrentDoc.wwptr)
        && GetTextMetrics(wwdCurrentDoc.hDC,(LPTEXTMETRIC)&tm)){
        if(tm.tmCharSet == SHIFTJIS_CHARSET && IsKanaInDBCS((int)ch))
            return (int)(0x00ff&ch);
    }
#endif
#endif

#ifdef  KOREA
    if(isupper(ch) && !((ch > 0xa1) && (ch < 0xfe)))
#else
    if(isupper(ch))
#endif

    return(ch + ('a' - 'A')); /* foreign is taken care of */
    else
    return ch;
} /* end of  C h L o w e r  */



static int cLongOpCount = 0; /* to ensure we don't do too much hide cursor */

StartLongOp()
{
extern int vfInLongOperation;
extern int vfCursorVisible;
extern int vfMouseExist;
extern HCURSOR vhcHourGlass;

int cursorlevel;

if (cLongOpCount++ == 0)
    {
    vfInLongOperation = TRUE;
    vfCursorVisible = TRUE;

    if (!vfMouseExist)
    { /* in a mouseless system, set the cursor to middle of window */
    extern HWND vhWndMsgBoxParent;
    extern HWND hParentWw;
    extern int  vfInitializing;
    RECT  rect;
    POINT pt;
    HWND  hWnd = vhWndMsgBoxParent;

    if (vhWndMsgBoxParent == NULL)
        hWnd = hParentWw; /* next choice */
    if (!vfInitializing && hWnd != NULL && IsWindow(hWnd))
        { /* we have a good window to put in */
        GetClientRect(hWnd, (LPRECT)&rect);
        pt.x = (rect.right - rect.left) / 2;
        pt.y = (rect.bottom - rect.top) / 2;
        ClientToScreen(hWnd, (LPPOINT)&pt);
        }
    else
        { /* put in the middle of screen */
        HDC hDCScreen = GetDC(NULL);
        if (hDCScreen == NULL)
        goto Out; /* the worst, setcursor only */
        pt.x = GetDeviceCaps(hDCScreen, HORZRES) / 2;
        pt.y = GetDeviceCaps(hDCScreen, VERTRES) / 2;
        ReleaseDC(NULL, hDCScreen);
        }
    SetCursorPos(pt.x, pt.y);
    }
Out:
    SetCursor(vhcHourGlass);
#if WINVER < 0x300
    ShowCursor(TRUE);

    /* precaution - make sure the cusor is visible */
    cursorlevel = GetSystemMetrics(SM_CURSORLEVEL);
#else
    /* use a supported method to get cursor level! ..pault 2/6/90 */
    cursorlevel = ShowCursor(TRUE);
#endif
    while (cursorlevel++ < 0)
        ShowCursor(TRUE);
    }
}


EndLongOp(hc)
HCURSOR hc; /* cursor to be changed to */
{
extern int vfInLongOperation;
extern int vfCursorVisible;
extern int vfMouseExist;
extern int          vfDeactByOtherApp;

int cursorlevel;

#ifdef JAPAN   // added by Hiraisi (BUG#3628/WIN31)
{
   RECT rc;
   POINT pt;
   extern int xpSelBar, dxpScrlBar, dypScrlBar;
   extern HWND hParentWw;
   extern HCURSOR vhcArrow, vhcBarCur;

   GetClientRect(hParentWw, (LPRECT)&rc);
   rc.right -= dxpScrlBar;
   rc.bottom -= dypScrlBar;
   GetCursorPos((LPPOINT)&pt);
   ScreenToClient(hParentWw,(LPPOINT)&pt);
   if( !PtInRect((LPRECT)&rc, pt) )     // out of edit area
      hc = vhcArrow;
   else
      if( pt.x <= xpSelBar )            // within selection bar
         hc = vhcBarCur;
}
#endif

if (cLongOpCount > 0)
    {
    if (vfDeactByOtherApp && (cLongOpCount == 1)) // OLE presents this case
    {
        vfInLongOperation = FALSE;
        vfCursorVisible = FALSE;
        SetCursor(vfMouseExist ? hc : NULL);
    }
    else if (--cLongOpCount == 0)
    {
    vfInLongOperation = FALSE;
    vfCursorVisible = FALSE;
#if WINVER < 0x300
    ShowCursor(FALSE);
    SetCursor(vfMouseExist ? hc : NULL);

    /* make sure the cursor is still visible in a mouse system
    and invisible in a mouseless system */
    cursorlevel = GetSystemMetrics(SM_CURSORLEVEL);
#else
    /* use a supported method to get cursor level! ..pault 2/6/90 */
    cursorlevel = ShowCursor(FALSE);
    SetCursor(vfMouseExist ? hc : NULL);
#endif
    if (vfMouseExist)
        {
        while (cursorlevel++ < 0)
        ShowCursor(TRUE);
        }
    else /* no mouse */
        {
        while (cursorlevel-- >= 0)
            ShowCursor(FALSE);
        }
    }
    }
}


/* String utility functions - moved here from string.c */

/* I N D E X */
/* ** Returns pointer to first occurrence of character ch found in null-
      terminated string pch, or 0 if ch does not appear.  If ch==0, we
      return a pointer to the null terminator. */
/*    In Kanji version, a kanji character is excluded from the search. */

CHAR *index(pch, ch)
REG1 CHAR *pch;
REG2 CHAR ch;  // fixed bug, previously int (2.11.91) D. Kent
    {
    while (low(*pch)!=ch)
        {
#ifdef  DBCS    /* KenjiK '90-11-20 */
        if (*pch=='\0')
#else
        if (*pch++=='\0')
#endif
            return(NULL);
#ifdef  DBCS    /* KenjiK '90-11-20 */
        pch = AnsiNext(pch);
#endif
        }
    return(pch);
    }

/* We may want to make these 'type' functions into macros */
/* These are designed for ANSI character set (used by windows) only */

/* I S  A L P H A */
/* ** TRUE if ch is a letter, FALSE otherwise */

isalpha(ch)
REG1 CHAR ch;
    {/* Note: even though DF and FF are lowercase, they have no
           corresponding uppercase, so they are excluded from the
           lowercase class, and simply mapped to themselves */
    return(islower(ch) || isupper(ch) || ch == 0x00FF || ch == 0x00DF);
    }


/* ** TRUE if ch is a lowercase letter, FALSE otherwise */

/* I S  L O W E R */
islower(ch)
REG1 CHAR ch;
    {/* Note: even though DF and FF are lowercase, they have no
           corresponding uppercase, so they are excluded from the
           lowercase class, and simply mapped to themselves */
    return((ch >= 'a' && ch <= 'z') ||
        /* foreign */
        (ch >= 0x00E0 && ch <= 0x00F6) ||
        (ch >= 0x00F8 && ch <= 0x00FE) );
    }

/* ** TRUE if ch is an uppercase letter, FALSE otherwise */

isupper(ch)
REG1 CHAR ch;
    {
    return((ch >= 'A' && ch <= 'Z') ||
        /* foreign */
        (ch >= 0x00C0 && ch <= 0x00D6) ||
        (ch >= 0x00D8 && ch <= 0x00DE));
    }

/* ** TRUE if ch is a digit, FALSE otherwise */

isdigit(ch)
REG1 CHAR ch;
    {
    return(ch>='0' && ch<='9');
    }


#ifdef ENABLE
/* ** TRUE if ch is a character or a digit, FALSE otherwise */

isalnum(ch)
REG1 CHAR ch;
    {
    return(isalpha(ch) || isdigit(ch));
    }
#endif



int ChUpper(ch)
REG1 CHAR ch;
{
#ifdef DBCS
  return AnsiUpper( ch );
#else
#ifdef BOGUS
return (ch >= 'a' && ch <= 'z') ? ch + ('A' - 'a') : ch;
#endif
/* use Windows' ANSI char set, the difference of upper/lower case
     is also 20 (HEX) for foreign chars */

    if (islower(ch))
    return(ch + ('A' - 'a')); /* foreign is taken care of */
    else return(ch);
#endif
}




/* similar to blcomp except compares by bytes and is not case sensitive */
BOOL FRgchSame(rgch1, rgch2, cch)
CHAR rgch1[], rgch2[];
int cch;
    {
    short ich;

    for(ich = 0; ich < cch; ich++)
    {
    if(ChLower(rgch1[ich]) != ChLower(rgch2[ich]))
        return(FALSE);
    }
    return(TRUE);
    }

/* PchStartBaseNameSz() ---- returns a character pointer to the
                 beginning of a base file name.  If
                 the name only consists of a base
                 name, sz is returned.

   Note: If sz ends with a back-slash or a colon, pch returned
     is pointing to the null terminator of the given string. */

CHAR *PchStartBaseNameSz(sz)
    CHAR    *sz;
{
    CHAR *pchBS, *pchC, *pchLast;
    CHAR *PchLastSzCh();

    pchBS = PchLastSzCh(sz, '\\');
    pchC  = PchLastSzCh(sz, ':');
    pchLast = (pchBS > pchC) ? pchBS : pchC;
    if (pchLast == NULL) {
    pchLast = sz;
    }
    else {
    pchLast++;
    }
    return (pchLast);
}

/* PchLastSzCh() ----- returns a pointer to the last occurrence of a given
               character in a given string.  If it does not occur
               in the string, it returns NULL.  If the given
               character is '\0', it returns sz itself.
   Note: All kanji characters are excluded from the search.        */

CHAR *PchLastSzCh(sz, ch)
    CHAR    *sz;
    CHAR    ch;
{
    if (ch == '\0') {
    return (sz);
    }
    else {
    CHAR    *pchCur, *pchLast;

#ifdef  DBCS
    for (pchLast = pchCur = sz; *pchCur != '\0'; pchCur = AnsiNext(pchCur))
#else
    for (pchLast = pchCur = sz; *pchCur != '\0'; pchCur++)
#endif
    {
             {
        if (low(*pchCur) == ch) {
            pchLast = pchCur;
            }
        }
        }
    return ((pchLast == sz) ? NULL : pchLast);
    }
}

#ifdef DEBUG
_Assert(pch, line, f)
PCH pch;
int line;
BOOL f;
    {
    if (!f)
    Do_Assert(pch, line, f);
    }
#endif

#ifdef JAPAN /*t-Yoshio*/
myHantoZen(char *han_str,char *zen_str,int buffsize)
{
    extern CHAR Zenstr1[256];
    extern CHAR Zenstr2[256];
    CHAR far    *ZenTbl;
    int length = 0;
    int sub;

    while((CHAR)*han_str) {
        if(length+3 > buffsize)
            break;

        if((CHAR)*han_str >= 0x20 && (CHAR)*han_str < 0x7f) {
            ZenTbl = Zenstr1;
            sub = ((CHAR)*han_str-0x20)*2;
            han_str++;
            *zen_str = ZenTbl[sub];
            *(zen_str+1) = ZenTbl[sub+1];
            zen_str+=2;
            length+=2;
            continue;
        }
        else if((CHAR)*han_str >= 0xa1 && (CHAR)*han_str <= 0xdd) {
            ZenTbl = Zenstr2;
            if((CHAR)*han_str >= 0xca && (CHAR)*han_str <= 0xce) {
                if((CHAR)*(han_str+1) == 0xde ) {
                    sub = ((CHAR)*han_str-0xa1+35)*2;
                    han_str+=2;
                }
                else if((CHAR)*(han_str+1) == 0xdf ) {
                    sub = ((CHAR)*han_str-0xa1+40)*2;
                    han_str+=2;
                }
                else {
                    sub = ((CHAR)*han_str-0xa1)*2;
                    han_str++;
                }
            }
            else if((CHAR)*han_str >= 0xa6 && (CHAR)*han_str <= 0xc4) {
                if((CHAR)*(han_str+1) == 0xde ) {
                    sub = ((CHAR)*han_str-0xa1+40)*2;
                    han_str+=2;
                }
                else {
                    sub = ((CHAR)*han_str-0xa1)*2;
                    han_str++;
                }
            }
            else {
                sub = ((CHAR)*han_str-0xa1)*2;
                han_str++;
            }

            *zen_str = ZenTbl[sub];
            *(zen_str+1) = ZenTbl[sub+1];
            zen_str+=2;
            length+=2;
            continue;
        }
        else {
            if(IsDBCSLeadByte((BYTE)(*han_str))) {
                *zen_str = *han_str;
                *(zen_str+1) = (CHAR)*(han_str+1);
                zen_str+=2;
                length+=2;
                han_str+=2;
            }
            else {
                *zen_str = *han_str;
                *zen_str++;length++;han_str++;
            }
            continue;
        }
    }
    *zen_str = '\0';
}
myIsSonant(BYTE dbcshi,BYTE dbcslow)
{
    static unsigned short hanzen[] = {
    0x834b, 0x834d, 0x834f, 0x8351, 0x8353,
    0x8355, 0x8357, 0x8359, 0x835b, 0x835d,
    0x835f, 0x8361, 0x8364, 0x8366, 0x8368,
    0x836f, 0x8370, 0x8372, 0x8373, 0x8375,
    0x8376, 0x8378, 0x8379, 0x837b, 0x837c
    };
    unsigned int dbyte;
    int i;

    dbyte = (((WORD)(dbcshi) << 8) | ((WORD)(dbcslow) & 0x00ff));
    for(i = 0;i < 25;i++)
    {
        if(dbyte == hanzen[i])
            return TRUE;
    }
    return FALSE;
}
#elif defined(KOREA)
myHantoZen(char *han_str,char *zen_str,int buffsize)
{
    extern CHAR Zenstr1[256];
    CHAR far    *ZenTbl;
    int length = 0;
    int sub;

    while((CHAR)*han_str) {
        if(length+3 > buffsize)
            break;

        if((CHAR)*han_str >= 0x20 && (CHAR)*han_str < 0x7f) {
            ZenTbl = Zenstr1;
            sub = ((CHAR)*han_str-0x20)*2;
            han_str++;
            *zen_str = ZenTbl[sub];
            *(zen_str+1) = ZenTbl[sub+1];
            zen_str+=2;
            length+=2;
            continue;
        }
        else {
            if(IsDBCSLeadByte((BYTE)(*han_str))) {
                *zen_str = *han_str;
                *(zen_str+1) = (CHAR)*(han_str+1);
                zen_str+=2;
                length+=2;
                han_str+=2;
            }
            else {
                *zen_str = *han_str;
                *zen_str++;length++;han_str++;
            }
            continue;
        }
    }
    *zen_str = '\0';
}
myIsSonant(BYTE dbcshi,BYTE dbcslow)
{
    static unsigned short hanzen[] = {
    0x834b, 0x834d, 0x834f, 0x8351, 0x8353,
    0x8355, 0x8357, 0x8359, 0x835b, 0x835d,
    0x835f, 0x8361, 0x8364, 0x8366, 0x8368,
    0x836f, 0x8370, 0x8372, 0x8373, 0x8375,
    0x8376, 0x8378, 0x8379, 0x837b, 0x837c
    };
    unsigned int dbyte;
    int i;

    dbyte = (((WORD)(dbcshi) << 8) | ((WORD)(dbcslow) & 0x00ff));
    for(i = 0;i < 25;i++)
    {
        if(dbyte == hanzen[i])
            return TRUE;
    }
    return FALSE;
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\util2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* util2.c -- less frequently used utility routines */
#define NOVIRTUALKEYCODES
#define NOCTLMGR
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOCOMM
#define NOSOUND
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "str.h"
#include "machdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "docdefs.h"
#include "debug.h"
#include "editdefs.h"
#include "wwdefs.h"
#define NOKCCODES
#include "ch.h"

extern struct DOD	(**hpdocdod)[];
extern HANDLE		hMmwModInstance;
extern CHAR		vchDecimal;  /* "decimal point" character */
extern int     viDigits;
extern BOOL    vbLZero;
CHAR *PchFillPchId(PCH, int, int);



FillStId(st, idpmt, cchIn)
CHAR *st;
IDPMT idpmt;
int  cchIn;
{ /* load string from resource file to buffer, the string is zero
     terminated, make it into a st, i.e. cch (excluding '\0' is stored
     in the 1st byte of the string) */

	int cch = LoadString(hMmwModInstance, idpmt, (LPSTR)&st[1], cchIn-1);
	Assert(cch != 0);
	st[0] = cch;
} /* FillStId */


CHAR *PchFillPchId(sz, idstr, cchIn)
register CHAR * sz;
register int idstr;
int cchIn;
{ /*
     Description: load string from resource file to buffer, the
		  string loaded is zero terminated
     Returns:	  pointer to '\0' last loaded
*/
	int cch = LoadString(hMmwModInstance, idstr, (LPSTR)sz, cchIn);
 /* Note: cch does not include the '\0' */
{
    char msg[80];
    if (cch == 0)
    {
        wsprintf(msg,"bad resource id: 0x%x\n\r",idstr);
        OutputDebugString(msg);
    }
	Assert(cch != 0);
}
	return(sz + cch);
} /* end of PchFillPchId */


int FDirtyDoc(doc)
register int doc;
{ /* Return true if killing this doc would lose editing */
	register struct DOD *pdod;
	return ((pdod = &(**hpdocdod)[doc])->fDirty && pdod->cref == 1);
} /* end of  F D i r t y D o c */


int ncvtu(n, ppch)
register int n;
CHAR **ppch;
{
	register int cch = 0;

	if (n < 0)
		{
		*(*ppch)++ = '-';
		n = -n;
		++cch;
		}

	if (n >= 10)
		{
		cch += ncvtu(n / 10, ppch);
		n %= 10;
		}
    else if ((n == 0) && !vbLZero) // then no leading zero
	    return 0;

	*(*ppch)++ = '0' + n;
	return cch + 1;
} /* end of n c v t uR */


HANDLE HszGlobalCreate( sz )
CHAR *sz;
{   /* Create handle for string in global windows heap. return the handle. */
 HANDLE h;
 LPCH lpch;
 int cch=CchSz( sz );

 if ((h=GlobalAlloc( GMEM_MOVEABLE, (LONG)cch )) != NULL)
    {
    if ((lpch = GlobalLock( h )) != NULL )
	{
	bltbx( (LPSTR) sz, lpch, cch );
	GlobalUnlock( h );
	}
    else
	{
	GlobalFree( h );
	return NULL;
	}
    }
 return h;
}




#ifdef DEBUG
fnScribble( dchPos, ch )
int dchPos;
CHAR ch;
{    /* Scribble a char dchPos char positions from the UR screen corner */
     /* We create a special device context to avoid interfering with the */
     /* ones MEMO uses */
 extern struct WWD rgwwd[];

 static unsigned dxpScribbleChar=0;
 static unsigned dypScribbleChar;
 static unsigned ypScribble;

 int xp = wwdCurrentDoc.xpMac - (dxpScribbleChar * (dchPos+1));
 int ilevel = SaveDC( wwdCurrentDoc.hDC );

 SelectObject( wwdCurrentDoc.hDC, GetStockObject(ANSI_FIXED_FONT) );

 if ( dxpScribbleChar == 0 )
    {	/* First time through */
    TEXTMETRIC tm;

    GetTextMetrics( wwdCurrentDoc.hDC, (LPTEXTMETRIC)&tm );
    dxpScribbleChar = tm.tmAveCharWidth;
    dypScribbleChar = tm.tmHeight + tm.tmInternalLeading;
    ypScribble = (dypScribbleChar >> 2) + wwdCurrentDoc.ypMin;
    }
 PatBlt( wwdCurrentDoc.hDC, xp, ypScribble, dxpScribbleChar, dypScribbleChar,
	 WHITENESS );
 TextOut( wwdCurrentDoc.hDC, xp, ypScribble, (LPSTR) &ch, 1 );
 RestoreDC( wwdCurrentDoc.hDC, ilevel );
}
#endif	/* DEBUG */


/* original util3.c  starts from here */

#define iMaxOver10    3276
extern int	utCur;

/* Must agree with cmddefs.h */
extern CHAR    *mputsz[];

/* Must agree with cmddefs.h */
unsigned mputczaUt[utMax] =
	{
	czaInch,	czaCm,	      czaP10,	     czaP12,	  czaPoint,
	czaLine
	};



int FZaFromSs(pza, ss, cch, ut)
int	*pza;
CHAR	ss[];
int	cch,
	ut;
{ /* Return za in *pza from string representation in ss.  True if valid za */
long	lza	 = 0;
register CHAR	 *pch	 = ss;
register CHAR  *pchMac = &ss[cch];
int	ch;
unsigned czaUt;
int	fNeg;

if (cch <= 0)
	return false;

switch (*--pchMac)
	{ /* Check for units */
case 'n': /* inch */
	if (*--pchMac != 'i')
		goto NoUnits;
case '"': /* inch */
	ut = utInch;
	break;

#ifdef CASHMERE /* units such as pt, pt12, pt10 */
case '0': /* pt10 */
	if (*--pchMac != '1' || *--pchMac != 'p')
		goto NoUnits;
	ut = utP10;
	break;
case '2': /* pt12 */
	if (*--pchMac != '1' || *--pchMac != 'p')
		goto NoUnits;
	ut = utP12;
	break;
case 'i': /* line */
	if (*--pchMac != 'l')
		goto NoUnits;
	ut = utLine;
	break;
case 't': /* pt */
	if (*--pchMac != 'p')
		goto NoUnits;
	ut = utPoint;
	break;
#endif /* CASHMERE */

case 'm': /* cm */
	if (*--pchMac != 'c')
		goto NoUnits;
	ut = utCm;
	break;
default:
	++pchMac;
	break;
NoUnits:
	pchMac = &ss[cch];
	}

while (pch < pchMac && *(pchMac - 1) == chSpace)
	--pchMac;

czaUt = mputczaUt[ut];

/* extract leading blanks */
while (*pch == ' ')
    pch++;

fNeg = *pch == '-';
if (fNeg) ++pch;	/* skip past minus sign */
while ((ch = *pch++) != vchDecimal)
	{
	if ((ch < '0' || ch > '9') || lza >= iMaxOver10)
		return false;
	lza = lza * 10 + (ch - '0') * czaUt;
	if (pch >= pchMac)
		goto GotNum;
	}

while (pch < pchMac)
	{
	ch = *pch++;
	if (ch < '0' || ch > '9')
		return false;
	lza += ((ch - '0') * czaUt + 5) / 10;
	czaUt = (czaUt + 5) / 10;
	}

GotNum:
if (lza > ((long) (22 * czaInch)))
	return false;

*pza = fNeg ? (int) -lza : (int) lza;
return true;
}



int
CchExpZa(ppch, za, ut, cchMax)
CHAR **ppch;
int ut, cchMax;
register int za;
{ /* Stuff the expansion of linear measure za in unit ut into pch.
	Return # of chars stuffed.  Don't exceed cchMax. */
register int cch = 0;
unsigned czaUt;
int zu;

/* If not in point mode and even half line, display as half lines v. points */
if (ut == utPoint && utCur != utPoint &&
    (za / (czaLine / 2) * (czaLine / 2)) == za)
	ut = utLine;


czaUt = mputczaUt[ut];
if (cchMax < cchMaxNum)
	return 0;

if (za < 0)
	{ /* Output minus sign and make positive */
	*(*ppch)++ = '-';
	za = -za;
	cch++;
	}

/* round off to two decimal places */
za += czaUt / 200;

zu = za / czaUt;	/* Get integral part */

cch += ncvtu(zu, ppch); /* Expand integral part */

za -= zu * czaUt; /* Retain fraction part */

if (((za *= 10) >= czaUt || za * 10 >= czaUt) && (viDigits > 0))
	{ /* Check *10 first because of possible overflow */
	zu = za / czaUt;

    *(*ppch)++ = vchDecimal;
    cch++;

	*(*ppch)++ = '0' + zu;
	cch++;
	zu = ((za - zu * czaUt) * 10) / czaUt;
	if ((zu != 0) && (viDigits > 1))
		{
		*(*ppch)++ = '0' + zu;
		cch++;
		}
	}

if (cch <= 1)
/* force zeroes */
{
    if ((cch == 0) && vbLZero) // then no leading zero
    {
	    *(*ppch)++ = '0';
        cch++;
    }
    *(*ppch)++ = vchDecimal;
	cch++;
    if (viDigits > 0)
    {
	    *(*ppch)++ = '0';
		cch++;
    }
    if (viDigits > 1)
    {
	    *(*ppch)++ = '0';
		cch++;
    }
}

cch += CchStuff(ppch, mputsz[ut], cchMax - cch);

return cch;
}


#ifdef KEEPALL /* Use FPdxaFromItDxa2Id */
int DxaFromSt(st, ut)
register CHAR	 *st;
int	ut;
{
int	za;

if (*st > 0 && FZaFromSs(&za, st+1, *st, ut))  /* see util.c */
	return za;
else
	return valNil;
}

int DxaFromItem(it)
int	it;
{
int	za;
register CHAR	 stBuf[32];

GetItTextValue(it, stBuf);

if (*stBuf > 0 && FZaFromSs(&za, stBuf+1, *stBuf, utCur))  /* see util.c */
	return (za == valNil) ? 0 : za;
else
	return valNil;
}
#endif

int CchStuff(ppch, sz, cchMax)
CHAR **ppch, sz[];
int cchMax;
{
register int cch = 0;
register CHAR *pch = *ppch;

while (cchMax-- > 0 && (*pch = *sz++) != 0)
	{
	cch++;
	pch++;
	}

if (cchMax < 0)
	bltbyte("...", pch - 3, 3);

*ppch = pch;
return cch;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\winddefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* MS-Windows specific definitions */

#define tidCaret            7734    /* Timer ID for caret blink (stand on your
				    head to read it) */

/*  dwHsecKeyDawdle is the number of hundredths of seconds that we loop,
    waiting for keys, before we update the display. See insert.c */

#define dwHsecKeyDawdle     35

/* File rename/deletion coordination messages sent btwn WRITE instances */

#define wWndMsgDeleteFile   (WM_USER + 36)
#define wWndMsgRenameFile   (WM_USER + 37)

/* System information message posted to self */

#define wWndMsgSysChange    (WM_USER + 38)

#define wWininiChangeToWindows  1   /* used in posting above message */
#define wWininiChangeToDevices  2
#define wWininiChangeToIntl     4
#define wWininiChangeMax        ((1|2|4) + 1)

#ifndef NOMETAFILE
/*              *** PICTURE THINGS ***                          */

#define dypPicSizeMin       16  /* Smallest y-extent of a picture, in pixels */
                                /* Also the dl height in a picture */

#define MM_NIL          -1
#define MM_BITMAP       99      /* A Phony mapping mode code used within MEMO */
                                /* xExt, yExt must be filled out as for MM_TEXT */
#define MM_OLE          100     /* Another phony mapping mode code used 
                                   with Objects/Links */

#define MM_EXTENDED     0x80    /* Bit set for New file format */

/* A Bitmap or Picture appears in a file as a PICINFO or PICINFOX
   + an Array of Bits,
   if it's a bitmap, or the contents of a memory metafile, if it's a picture.
   This all appears in the cp stream
   A PICINFO is a PICINFOX without the extended format fields.
   a PICINFO has the mfp.mm MM_EXTENDED bit cleared
   a PICINFOX has the mfp.mm MM_EXTENDED bit set
*/

/* If you change this, you must change "cchOldPICINFO" */

struct PICINFOX {
 METAFILEPICT mfp;
 int  dxaOffset;
 int  dxaSize;
 int  dyaSize;
 unsigned  cbOldSize;      /* For old file support only */
 BITMAP bm;                /* Additional info for bitmaps only */

 /* Extended format -- add these fields */

 unsigned cbHeader;        /* Size of this header (sizeof (struct PICINFOX)) */
 unsigned long  cbSize;    /* This field replaces cbOldSize on new files */

 unsigned mx, my;               /* Multiplier for scaled bitmap */
};

#define mxMultByOne     1000    /* mx == 1 implies same size; 2 doubles, etc. */
#define myMultByOne     1000


#define cchOldPICINFO   (sizeof(struct PICINFOX) - sizeof(long) - \
                         sizeof(unsigned) - 2 * sizeof (int))

#define cchPICINFOX     (sizeof(struct PICINFOX))
#endif /* ifndef NOMETAFILE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\wwdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#ifdef ONLINEHELP
#define wwMax           3
#else
#define wwMax           2
#endif

#define wwNil           (15)

#define itrMaxCache     32

/* Window create modes */
#define wcmHoriz        0
#define wcmVert         1
#define wcmFtn          2

typeCP CpSelectCursor(), CpGetCache(), CpHintCache(), CpParaBounds();
typeCP CpFirstSty(), CpLimSty(), CpBeginLine(), CpFromDlTc();
typeCP CpFromCursor(), CpEdge(), CpInsPoint();
typeCP CpFirstFtn(), CpMacText();

/* WWD reorg. CS Sept 1 */
struct WWD
        { /* Window descriptor */
        unsigned char fDirty : 1; /* ww needs updating */
        unsigned char fCpBad : 1; /* cpFirst needs updating */
        unsigned char fWrite : 1; /* Can edit this window */
/* true iff lower of a split pair. False means window is not split */
        unsigned char fLower : 1;
/* true means window is split and this is the upper pane */
        unsigned char fSplit : 1;
/* in the top window false means the bottom half has the active selection */
/* used for window activation. remembered at deactivation */
        unsigned char fActive : 1;
        unsigned char fFtn : 1; /* This is a footnote window */
        unsigned char fRuler : 1; /* Draw tab and margin ruler */
#ifdef SPLITTERS    /* Only if we have split windows */
/* points to lower ww if fSplit, to upper ww if fLower */
        unsigned char ww;
#endif
        unsigned char fEditHeader: 1;   /* We are editing the running head */
        unsigned char fEditFooter: 1;   /* We are editing the running foot */

        unsigned char dcpDepend;  /* hot spot for first line */
        unsigned char dlMac;      /* number of actual dls for this ww */
        unsigned char dlMax;      /* number of allocated dls for this ww */
        unsigned char doc;

        int xpMac; /* window rel position of last displayable pixel +1 */
/* note: area starts at: xpSelBar, see dispdefs */
        int ichCpFirst; /* ich within cpFirst */

/* first pixel pos to display; determines horizontal scroll */
        int xpMin;
/* these will be changed to yp's later */
        int ypMac; /* pos of bottom of window */
        int ypMin; /* pos of top of writeable area of window */

/* invalid band in the window */
        int ypFirstInval;
        int ypLastInval;

        typeCP cpFirst; /* First cp in ww */
        typeCP cpMin; /* Min cp for this ww if fFtn */
        typeCP cpMac; /* Mac cp for this ww if fFtn */
        unsigned char drElevator; /* dr where elevator is currently */
        unsigned char fScrap : 1; /* on for scrap window */
/* new fields, consolidating various arrays */
        struct SEL sel; /* current selection in ww */
/* must be at end of struct, see cwWWDclr kludge below */

#ifndef SAND        /* MEMO fields */
        HWND wwptr;                 /* window handle */
        HWND hHScrBar;              /* Handle to horiz scroll bar */
        HWND hVScrBar;              /* Handle to vert scroll bar */
        HDC  hDC;                   /* Handle to device context */
        unsigned char sbHbar;       /* Type of horiz scroll bar (SB_CTL or SB_HORIZ) */
        unsigned char sbVbar;       /* Type of vert scroll bar (SB_CTL or SB_VERT) */
#else
        WINDOWPTR wwptr; /* Sand window handle */
#endif
/* heap pointer to array of edl's. */
        struct EDL (**hdndl)[];
        };

#define cwWWD   (sizeof(struct WWD) / sizeof(int))
#define cwWWDclr  ((sizeof(struct WWD) - (4*sizeof(HANDLE)) - (2*sizeof(char)) - sizeof(int)) / sizeof(int))

/* These macros will gain code size advantage from the fixed usage
   of rgwwd in MEMO, while permitting easy conversion to multiple
   document windows in CASHMERE. Only code that does not have to support both
   the clipboard and the document should use these macros */

extern int wwClipboard;

#ifdef ONLINEHELP
extern int wwHelp;
#define wwdHelp         (rgwwd [ wwHelp ])
#endif

#define wwDocument      0

#define wwdCurrentDoc   (rgwwd [wwDocument])
#define wwdClipboard    (rgwwd [wwClipboard])

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\wwactde.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "fmtdefs.h"
#include "printdef.h"   /* printdefs.h */

/*         E X T E R N A L S        */

extern int wwCur;
extern struct WWD rgwwd[];
extern struct DOD (**hpdocdod)[];
extern struct SEL selCur;
extern int docCur;
extern int    vdocPageCache;
extern typeCP vcpMinPageCache;
extern typeCP vcpMacPageCache;
extern int    vipgd;
extern struct WWD *pwwdCur;
extern typeCP cpMinCur;
extern typeCP cpMacCur;
extern int docMode;
extern int vfPictSel;
extern int vfSizeMode;
extern struct PAP vpapAbs;
extern typeCP vcpLimParaCache;
extern struct CHP vchpFetch;
extern struct CHP vchpSel;
extern struct FLI vfli;
extern int ichpMacFormat;
extern struct CHP (**vhgchpFormat)[];
extern int wwMac;
extern int docScrap;
extern int docUndo;

extern  CHAR (**vhrgbSave)[];




/* N E W  C U R  W W */
NewCurWw(ww, fHighlight)
int ww, fHighlight;
        {
        extern HWND vhWnd;
        struct   PGTB  **hpgtb;

        Assert( (ww >= 0) && (ww < wwMac) );

        if ( wwCur != wwNil )
            {   /* Clean up from old window */
            /* Discard the screen fonts. */
            FreeFonts( TRUE, FALSE );
            pwwdCur->sel = selCur;
            }

        if (ww >= 0)
                {
                docCur = (pwwdCur = &rgwwd[wwCur = ww])->doc;

                vhWnd = pwwdCur->wwptr;

/* If the new current document has no page table or has no page descriptors */
/*  in its page table, all text in the document is considered to be on */
/*  page 1 of the document. In this case, preload the cache used by    */
/*  procedure CachePage.                                               */
                hpgtb = (**hpdocdod)[docCur].hpgtb;
                if (hpgtb == 0 || (**hpgtb).cpgd == 0)
                        {
                        vdocPageCache = docCur;
                        vcpMinPageCache = cp0;
                        vcpMacPageCache = cpMax;
                        vipgd = -1;
                        }

#ifdef ENABLE /* we now do if in ChangeWwDoc where it is more appropriate */
/* Since we are changing windows, ensure that we don't use parameters
                set by a search in a previous window by setting flag false */
                vfDidSearch = false;
                cpWall = selCur.cpLim;
#endif

/* active bit is valid only in upper panes. Means when window is active
upper pane is active. False means lower pane is active */
#ifdef SPLITTERS
                if (pwwdCur->fLower)
                        rgwwd[pwwdCur->ww].fActive = fFalse;
                else
#endif
                        pwwdCur->fActive = fTrue;

                selCur = pwwdCur->sel;
#ifdef ENABLE
                if (pwwdCur->fFtn)
                        { /* It's a footnote window */
                        cpMinCur = pwwdCur->cpMin;
                        cpMacCur = pwwdCur->cpMac;
                        if (fHighlight &&
                           ((selCur.cpFirst < cpMinCur) ||
                            (selCur.cpLim > cpMacCur)))
                            {
                            Select(cpMinCur, CpLastStyChar(cpMinCur));
                            }
                        }
                else
#endif
#ifdef ONLINEHELP
                if (ww == wwHelp)
                        {   /* It's the help document window */
                            /* Limit cp range to the current help topic */
                        cpMinCur = pwwdCur->cpMin;
                        cpMacCur = pwwdCur->cpMac;
                        }
                else
#endif

                if (ww == wwClipboard)
                        {   /* Displaying the clipboard contents */
                        cpMinCur = cp0;
                        cpMacCur = CpMacText( docScrap );
                        Assert( docCur == docScrap );
                        goto SetWwCps;
                        }
                else
                        { /* Normal window -- editing document, header, or footer */
                        Assert( !(pwwdCur->fEditFooter && pwwdCur->fEditHeader) );
                        ValidateHeaderFooter( docCur );

                        if (pwwdCur->fEditHeader)
                            {
                            extern typeCP cpMinHeader, cpMacHeader;

                            cpMinCur = cpMinHeader;
                            cpMacCur = cpMacHeader - ccpEol;
                            }
                        else if (pwwdCur->fEditFooter)
                            {
                            extern typeCP cpMinFooter, cpMacFooter;

                            cpMinCur = cpMinFooter;
                            cpMacCur = cpMacFooter - ccpEol;
                            }
                        else
                            {   /* Editing document */
                            extern typeCP cpMinDocument;

                            cpMinCur = cpMinDocument;
                            cpMacCur = CpMacText( docCur );
                            }
 SetWwCps:
                        cpMacCur = CpMax( cpMacCur, cpMinCur );
                        pwwdCur->cpMin = cpMinCur;
                        pwwdCur->cpMac = cpMacCur;
                        }
                }
#ifdef ENABLE   /* wwCur change is sensed in CtrBackTrs so we don't
                   trash the cache until we really have to */
        TrashCache();           /* Cache valid for wwCur only */
#endif
#ifdef ENABLE   /* We only switch among doc, clipbrd, help - no need */
        docMode = docNil;       /* Invalidate page display */
#endif
        vfSizeMode = false;

        if (selCur.cpFirst >= cp0)
                {
                if ((selCur.cpFirst == selCur.cpLim) && (docCur != docScrap) )
                        GetInsPtProps(selCur.cpFirst);
                CachePara(docCur, selCur.cpFirst);
                vfPictSel = vpapAbs.fGraphics &&
                                    (selCur.cpLim == vcpLimParaCache);
                }
#ifdef ENABLE
        if (fHighlight)
                { /* Shrink heap blocks for FormatLine.  Call this when it's
                possible that the contents of the screen have gotten less complex */
                if (ichpMacFormat > 2 * ichpMacInitFormat)
                        { /* If it's not that big, don't worry about it */
                        vfli.doc = docNil;
                        ichpMacFormat = ichpMacInitFormat;
                        FChngSizeH(vhgchpFormat, ichpMacInitFormat * cwCHP, true);
                        }
                }
#endif /* ENABLE */
        }




WwAlloc( hWnd, doc )
HWND hWnd;
int   doc;
{       /* Allocate a new ww entry. This is used in MEMO for the clipboard
           and for the HELP document window. Some of the code is specific
           to these windows (e.g. "style" scroll bars used instead of controls)
           WARNING: The caller must set the scroll bar range 0-drMax;
           MEMO does NOT use the windows default values and we don't set them
           here because of the clipboard */

#define dlMaxGuess  10

 extern int wwMac;
 extern int wwCur;
 extern struct WWD rgwwd[];
 extern struct WWD *pwwdCur;
 extern int docScrap;
 int ww;
 register struct WWD *pwwd;

 if (wwMac >= wwMax)
    {
    Assert( FALSE );
    return wwNil;
    }
 pwwd = &rgwwd[ ww = wwMac ];

        /* Start with all fields == 0 */
 bltc( pwwd, 0, cwWWDclr );

 pwwd->doc = doc;

    /* Set the remaining fields as in [CREATEWW] WwNew */
 if (FNoHeap( pwwd->hdndl=(struct EDL (**)[])HAllocate(dlMaxGuess * cwEDL) ))
        return wwNil;
 bltc( *(pwwd->hdndl), 0, dlMaxGuess * cwEDL );
 pwwd->dlMac = pwwd->dlMax = dlMaxGuess;
 pwwd->hHScrBar = pwwd->hVScrBar = pwwd->wwptr = hWnd;
 pwwd->sbHbar = SB_HORZ;
 pwwd->sbVbar = SB_VERT;
 pwwd->fDirty = TRUE;
 pwwd->fActive = TRUE;
 pwwd->sel.fForward = TRUE;
 pwwd->cpMac = CpMacText( pwwd->doc );
 pwwd->ypFirstInval = ypMaxAll;        /* See WwNew() */

 wwMac++;

 return ww;
}



FreeWw( ww )
register int ww;
{       /* Free the wwd entry for the clipboard or help window. Close up
           rgwwd & null out wwClipboard or wwHelp, as appropriate */
 if (ww == wwDocument)
    {
    Assert( FALSE );
    return;
    }

 FreeH( rgwwd [ww].hdndl );
 if (ww == wwClipboard)
    wwClipboard = wwNil;
#ifdef ONLINEHELP
 else if (ww == wwHelp)
    wwHelp = wwNil;
#endif
 else
    Assert( FALSE );


 if (ww < --wwMac)
    {   /* Left hole in wwd structure, close it up */
    bltbyte( &rgwwd[ ww + 1], &rgwwd[ ww ],
             sizeof( struct WWD ) * (wwMac - ww) );

    if (wwClipboard > ww)
        wwClipboard--;
#ifdef ONLINEHELP
    else if (wwHelp > ww)
        wwHelp--;
#endif
    else
        Assert( FALSE );
    }
}





#ifdef CASHMERE
/* C L O S E  W W */
CloseWw(ww)
int     ww;
{       /* Close a window */
        struct WWD      *pwwd, *pwwdT;
        int wwCurNew = wwCur;
        int wwT;
        int cdl;
/* note ww and wwCur are not necessarily the same because of the scrap */
        if (wwCur > 0)
                blt(&selCur, &(rgwwd[wwCur].sel), cwSEL);
        pwwd = &rgwwd[ww];
        --wwMac;
        if (!pwwd->fLower && !pwwd->fSplit)
                {
                KillDoc(pwwd->doc);
                if (wwCurNew >= wwMac)
                        wwCurNew = wwMac - 1;
                }
        else
                { /* split or lower */
                wwCurNew = pwwd->ww;
                }

/* Free up the space that was used by this window */
        FreeH(pwwd->hdndl);
        /* Deallocate part of the emergency space reserved for save operations
                since we now have one less window and thus one less potential
                save to do. */
        FChngSizeH(vhrgbSave, max((cwSaveAlloc+(wwMac-1)*cwHeapMinPerWindow),
                                                                cwSaveAlloc), true);


/* Close up the gap in wwd's */
        if (ww != wwMac && wwMac > 0)
                blt(pwwd + 1, pwwd, cwWWD * (wwMac - ww));
        else
                rgwwd[wwMac].wwptr = 0l;

        if (wwCurNew > ww)
                --wwCurNew;

        /* Update links to windows above the closure */
        for (pwwd = &rgwwd[0], wwT = 0; wwT < wwMac; pwwd++, wwT++)
                {
                if ((pwwd->fSplit || pwwd->fLower) && pwwd->ww > ww)
                        pwwd->ww--;
                }

/* Don't make the Clipboard window into the current window */
        if (wwCurNew >= 0)
                {
                if (rgwwd[wwCurNew].doc == docScrap)
                        {
                        if (wwCurNew > 0) /* Try the one before this */
                                wwCurNew--;
                        else if (wwMac > 1) /* 0 is scrap, try higher one */
                                wwCurNew++;
                        else
                                goto NoWw;
                        }
                NewCurWw(wwCurNew, true);
                }
        else
                {
NoWw:           wwCur = -1;
                }
        /* Really stomp this! */
        ClobberDoc(docUndo, docNil, cp0, cp0);
        NoUndo();
}
#endif      /* CASHMERE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\genwowit.c ===
/* generate wowit.h and wowit.c from wow.it
 *
 *   20-Feb-1997 DaveHart created
 */

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <sys\stat.h>
#include <fcntl.h>
#include <windows.h>


VOID ErrorAbort(PSZ pszMsg);
BYTE GetReturnOpcode(PSZ *ppsz);
PSZ GetApiName(PSZ *ppsz);
PSZ GetApi32Name(PSZ *ppsz, PSZ pszApi16);
BYTE GetArgOpcode(PSZ *ppsz);
PSZ GetOpcodeName(BYTE bInstr);
PSZ GetLine(PSZ pszBuf, int cbBuf, FILE *fp);
VOID ReadTypeNames(FILE *fIn, PSZ szTypesPrefix, PSZ *OpcodeNamesArray, int *pnOpcodeNames);
PSZ DateTimeString(VOID);

#define IS_RET_OPCODE(b) (b & 0x80)

#define MAX_IT_INSTR 16

typedef struct tagITINSTR {
    int  cbInstr;
    int  offSwamp;
    BYTE Instr[MAX_IT_INSTR];
} ITINSTR;

#define MAX_INSTR_TABLE_SIZE 512
ITINSTR InstrTable[MAX_INSTR_TABLE_SIZE];
int     iNextInstrSlot = 0;

typedef struct tagTHUNKTABLESLOT {
    PSZ   pszAPI;
    PSZ   pszAPI32;                 // if Win32 routine name doesn't match pszAPI
    int   iInstrSlot;
    int   cbInstr;                  // how much of this slot we're using
} THUNKTABLESLOT;

#define MAX_THUNK_TABLE_SIZE 1024
THUNKTABLESLOT ThunkTable[MAX_THUNK_TABLE_SIZE];
int iNextThunkSlot = 0;

#define MAX_ARG_OPCODE_NAMES 32
PSZ ArgOpcodeNames[MAX_ARG_OPCODE_NAMES];
int nArgOpcodeNames = 0;

#define MAX_RET_OPCODE_NAMES 32
PSZ RetOpcodeNames[MAX_RET_OPCODE_NAMES];
int nRetOpcodeNames = 0;

static char szArgumentTypes[] = "Argument Types:";
static char szReturnTypes[] = "Return Types:";

int __cdecl main(int argc, char **argv)
{
    FILE *fIn, *fOutH, *fOutC;
    char szBuf[256], szOff1[32], szOff2[32];
    PSZ psz, pszAPI, pszAPI32;
    ITINSTR ThisInstr;
    BYTE bRetInstr;
    BYTE *pbInstr;
    int i, iSwampOffset;
    int iMaxArgs = 0;
    int cbDiff;

    if (argc != 2) {
        ErrorAbort("Usage:\n  genwowit <inputfile>\n");
    }

    if (!(fIn = fopen(argv[1], "rt"))) {
        ErrorAbort("Unable to open input file\n");
    }

    //
    // The input file (wow.it) uses # to begin comment lines.
    // Aside from comments, it must begin with two special lines
    // to define the available type names for arguments and
    // function return values.
    //
    // They look like:
    //
    // Argument Types: WORD, INT, DWORD, LPDWORD, PTR, PTRORATOM, HGDI, HUSER, COLOR, HINST, HICON, POINT, 16ONLY, 32ONLY;
    // Return Types: DWORD, WORD, INT, HGDI, HUSER, ZERO, HICON, ONE, HPRNDWP;
    //
    // Read these lines into the ArgOpcodeNames and RetOpcodeNames arrays.
    //

    ReadTypeNames(fIn, szArgumentTypes, ArgOpcodeNames, &nArgOpcodeNames);
    if(nArgOpcodeNames > MAX_ARG_OPCODE_NAMES) {
        ErrorAbort("Too many ARG op codes!\n");
    }
    ReadTypeNames(fIn, szReturnTypes, RetOpcodeNames, &nRetOpcodeNames);
    if(nRetOpcodeNames > MAX_RET_OPCODE_NAMES) {
        ErrorAbort("Too many RET op codes!\n");
    }

    //
    // Each input line in the main part has a very restricted syntax:
    //
    // RETTYPE Api16[=Api32](TYPE1, TYPE2, ... TYPEn);  # comment
    //
    // If Api32 isn't specified it's the same as Api16.
    // The types come from the set above only.
    //
    // Actually everything following the ) is ignored now.
    //

    while (GetLine(szBuf, sizeof szBuf, fIn)) {

        psz = szBuf;

        //
        // Pick up the type, space-delimited, leaving psz at API name start
        //

        bRetInstr = GetReturnOpcode(&psz);

        //
        // Pick up the API name, leaving psz pointing past the open-paren or
        // to '=' char
        //

        pszAPI = GetApiName(&psz);

        //
        // Pick up the 32-bit name if it exists
        //

        pszAPI32 = GetApi32Name(&psz, pszAPI);

        //
        // Pick up the arg types into Instr array
        //

        memset(&ThisInstr, 0, sizeof ThisInstr);
        pbInstr = ThisInstr.Instr;

        while (*psz && *psz != ')') {
            *pbInstr++ = GetArgOpcode(&psz);
        }

        //
        // Keep track of the max used args
        //

        iMaxArgs = max(iMaxArgs, (pbInstr - ThisInstr.Instr));

        //
        // Tack on the return opcode
        //

        *pbInstr++ = bRetInstr;

        //
        // Record instruction bytes used for this one.
        //

        ThisInstr.cbInstr = (pbInstr - ThisInstr.Instr);

        //
        // Make sure we haven't overrun
        //

        if ( ThisInstr.cbInstr > MAX_IT_INSTR ) {
            printf("Thunk for %s too many args (%d) increase MAX_IT_INSTR beyond %d.\n",
                   pszAPI, ThisInstr.cbInstr, MAX_IT_INSTR);
            ErrorAbort("Increase MAX_IT_INSTR in intthunk.h\n");
        }

        //
        // Now we have a fully-formed opcode stream, see if we can pack it
        // in with any previously recorded ones.  Walk through the table
        // from the start looking for any entry which already contains this
        // opcode sequence (possibly as part of a longer sequence) or which
        // is itself contained by this opcode sequence.  If we find one,
        // change it to be the longer sequence if needed and use it.  We'll
        // distinguish later between the multiple uses using the cbInstr in
        // each thunk table entry.  The logic here assumes the matches will
        // always be at the end, since ret opcodes always have 0x80 bit set
        // and no others do, and each sequence ends with one.
        //

        for (i = 0; i < iNextInstrSlot; i++) {
            //if (0 == memcmp(Instr, InstrTable[i], sizeof Instr)) {
            //    break;
            //}

            //
            // Is ThisInstr a subsequence of this table entry?
            //

            if (ThisInstr.cbInstr <= InstrTable[i].cbInstr &&
                0 == memcmp(ThisInstr.Instr,
                            InstrTable[i].Instr + (InstrTable[i].cbInstr -
                                                   ThisInstr.cbInstr),
                            ThisInstr.cbInstr)) {

                break;
            }

            //
            // Is this table entry a subsequence of ThisInstr?
            //

            if (InstrTable[i].cbInstr < ThisInstr.cbInstr &&
                0 == memcmp(InstrTable[i].Instr,
                            ThisInstr.Instr + (ThisInstr.cbInstr -
                                               InstrTable[i].cbInstr),
                            InstrTable[i].cbInstr)) {

                //
                // Blast the longer ThisInstr over the existing shorter
                // instruction.
                //

                memcpy(&InstrTable[i], &ThisInstr, sizeof InstrTable[i]);
                break;
            }

            //
            // Check the next instruction table entry.
            //
        }

        //
        // If we didn't find a match, add to the end.
        //

        if (i == iNextInstrSlot) {
            memcpy(&InstrTable[i], &ThisInstr, sizeof InstrTable[i]);
            iNextInstrSlot++;

            if (iNextInstrSlot == MAX_INSTR_TABLE_SIZE) {
                ErrorAbort("Increase MAX_INSTR_TABLE_SIZE in genwowit.c\n");
            }
        }

        //
        // Add this one to the thunk table.
        //

        ThunkTable[iNextThunkSlot].pszAPI = pszAPI;
        ThunkTable[iNextThunkSlot].pszAPI32 = pszAPI32;
        ThunkTable[iNextThunkSlot].iInstrSlot = i;
        ThunkTable[iNextThunkSlot].cbInstr = ThisInstr.cbInstr;
        iNextThunkSlot++;

        if (iNextThunkSlot == MAX_THUNK_TABLE_SIZE) {
            ErrorAbort("Increase MAX_THUNK_TABLE_SIZE in genwowit.c\n");
        }
    }

    fclose(fIn);

    //
    // Now we're ready to output the results.
    //

    if (!(fOutH = fopen("wowit.h", "wt"))) {
        ErrorAbort("Cannot open wowit.h output file\n");
    }

    fprintf(fOutH,
            "//\n"
            "// DO NOT EDIT.\n"
            "//\n"
            "// wowit.h generated by genwowit.exe from wow.it on\n"
            "//\n"
            "//   %s\n"
            "//\n\n", DateTimeString());

    fprintf(fOutH, "#include \"intthunk.h\"\n\n");

    fprintf(fOutH, "#define MAX_IT_ARGS  %d\n\n", iMaxArgs);

    //
    // Spit out the two types of opcode manifests.
    //

    for (i = 0; i < nArgOpcodeNames; i++) {
        fprintf(fOutH, "#define IT_%-20s ( (UCHAR) 0x%x )\n", ArgOpcodeNames[i], i);
    }

    fprintf(fOutH, "\n#define IT_RETMASK              ( (UCHAR) 0x80 )\n");

    for (i = 0; i < nRetOpcodeNames; i++) {
        sprintf(szBuf, "%sRET", RetOpcodeNames[i]);
        fprintf(fOutH, "#define IT_%-20s ( IT_RETMASK | (UCHAR) 0x%x )\n", szBuf, i);
    }

    fprintf(fOutH, "\n");

    //
    // ITID_ manifests map an API name to its slot
    // in the thunk table.  Each one looks like:
    //
    // #define ITID_ApiName               0
    //

    for (i = 0; i < iNextThunkSlot; i++) {
        fprintf(fOutH, "#define ITID_%-40s %d\n", ThunkTable[i].pszAPI, i);
    }

    fprintf(fOutH, "\n#define ITID_MAX %d\n", i-1);

    fclose(fOutH);


    //
    // wowit.c has two tables, the instruction table and
    // the thunk table.
    //

    if (!(fOutC = fopen("wowit.c", "wt"))) {
        ErrorAbort("Cannot open wowit.c output file\n");
    }

    fprintf(fOutC,
            "//\n"
            "// DO NOT EDIT.\n"
            "//\n"
            "// wowit.c generated by genwowit.exe from wow.it on\n"
            "//\n"
            "//   %s\n"
            "//\n\n", DateTimeString());


    fprintf(fOutC, "#include \"precomp.h\"\n");
    fprintf(fOutC, "#pragma hdrstop\n");
    fprintf(fOutC, "#define WOWIT_C\n");
    fprintf(fOutC, "#include \"wowit.h\"\n\n");

    //
    // Spit out the instruction table, packing bytes in the process
    // and filling in the aoffInstrTable array with offsets for each
    // entry in this program's InstrTable.  Those offsets are used
    // in writing the final thunk table.
    //

    iSwampOffset = 0;

    fprintf(fOutC, "CONST BYTE InstrSwamp[] = {\n");

    for (i = 0; i < iNextInstrSlot; i++) {

        fprintf(fOutC, "    /* %3d  0x%-3x */ ", i, iSwampOffset);

        pbInstr = InstrTable[i].Instr;
        InstrTable[i].offSwamp = iSwampOffset;

        do {
            fprintf(fOutC, "%s, ", GetOpcodeName(*pbInstr));
            iSwampOffset++;
        } while (!IS_RET_OPCODE(*pbInstr++));

        fprintf(fOutC, "\n");

    }

    fprintf(fOutC, "};\n\n");

    fprintf(fOutC, "CONST INT_THUNK_TABLEENTRY IntThunkTable[] = {\n");

    for (i = 0; i < iNextThunkSlot; i++) {

        //
        // Concatenate the API name followed by a comma into
        // szBuf, so the combination can be left-justified in the output.
        //

        sprintf(szBuf, "%s,", ThunkTable[i].pszAPI32);

        //
        // cbDiff is the offset into the instruction stream where
        // this thunks instruction stream begins.
        //

        cbDiff = InstrTable[ ThunkTable[i].iInstrSlot ].cbInstr -
                 ThunkTable[i].cbInstr;

        //
        // Format the swamp offset so it can be left-justified in the output.
        //

        sprintf(szOff1, "%x",
                InstrTable[ ThunkTable[i].iInstrSlot ].offSwamp + cbDiff);

        //
        // If this thunk table entry will point past the start of
        // an instruction (because of sharing), format the offset
        // past the start of the instruction into szOff2
        //

        if (cbDiff) {
            sprintf(szOff2, "+ %d ", cbDiff);
        } else {
            szOff2[0] = '\0';
        }

        fprintf(fOutC,
                "    /* %3d */ { (FARPROC) %-32s InstrSwamp + 0x%-4s },  /* %d %s*/ \n",
                i,
                szBuf,
                szOff1,
                ThunkTable[i].iInstrSlot,
                szOff2);
    }

    fprintf(fOutC, "};\n\n");

    fclose(fOutC);

    printf("Generated wowit.h and wowit.c from wow.it\n"
           "%d thunks, %d unique instruction streams, %d instruction bytes, %d max args.\n",
           iNextThunkSlot, iNextInstrSlot, iSwampOffset, iMaxArgs);

    return 0;
}



BYTE GetReturnOpcode(PSZ *ppsz)
{
    int i;
    char szBuf[32];
    PSZ psz;

    //
    // Copy the name up to the first space to szBuf,
    // then skip any remaining spaces leaving caller's
    // pointer pointing at API name.
    //

    psz = szBuf;
    while (**ppsz != ' ') {
        *psz++ = *((*ppsz)++);
    };

    *psz = 0;

    if(strlen(szBuf) > 32-1) {
        ErrorAbort("Return Opcode too long.\n");
    }

    // advance to the API name start
    while (**ppsz == ' ') {
        (*ppsz)++;
    };

    i = 0;
    while (i < nRetOpcodeNames &&
           strcmp(szBuf, RetOpcodeNames[i])) {
        i++;
    }

    if (i == nRetOpcodeNames) {
        printf("%s is not a valid return type.\n", szBuf);
        ErrorAbort("Invalid return type.\n");
    }

    return (BYTE)i | 0x80;
}



PSZ GetApiName(PSZ *ppsz)
{
    char szBuf[128];
    PSZ psz;

    //
    // Copy the name up to the first space or open-paren or equals sign
    // to szBuf, then skip any remaining spaces and open-parens leaving caller's
    // pointer pointing at first arg type or equals sign
    //

    psz = szBuf;
    while (**ppsz != ' ' && **ppsz != '(' && **ppsz != '=') {
        *psz++ = *((*ppsz)++);
    };

    *psz = 0;

    if(strlen(szBuf) > 128-1) {
        ErrorAbort("API Name too long.\n");
    }

    // advance to 1st parameter type or '=' char if any
    while (**ppsz == ' ' || **ppsz == '(') {
        (*ppsz)++;
    };

    if (!strlen(szBuf)) {
        ErrorAbort("Empty API name\n");
    }

    return _strdup(szBuf);
}



PSZ GetApi32Name(PSZ *ppsz, PSZ pszApi16)
{
    char szBuf[128];
    PSZ psz;

    if (**ppsz != '=') {
        return pszApi16;
    }

    (*ppsz)++;  // skip =

    //
    // Copy the name up to the first space or open-paren
    // to szBuf, then skip any remaining spaces and open-parens leaving caller's
    // pointer pointing at first arg type
    //

    psz = szBuf;
    while (**ppsz != ' ' && **ppsz != '(') {
        *psz++ = *((*ppsz)++);
    };

    *psz = 0;

    if(strlen(szBuf) > 128-1) {
        ErrorAbort("API32 Name too long.\n");
    }

    // advance to the 1st parameter type
    while (**ppsz == ' ' || **ppsz == '(') {
        (*ppsz)++;
    };

    if (!strlen(szBuf)) {
        ErrorAbort("Empty API32 name\n");
    }

    return _strdup(szBuf);
}




BYTE GetArgOpcode(PSZ *ppsz)
{
    char szBuf[32];
    PSZ psz;
    int i;

    //
    // Copy the name up to the first space or comma close-paren
    // to szBuf, then skip any remaining spaces and commas,
    // leaving caller's pointer pointing at next arg type
    // or close-paren.
    //

    psz = szBuf;
    while (**ppsz != ' ' && **ppsz != ',' && **ppsz != ')') {
        *psz++ = *((*ppsz)++);
    };

    *psz = 0;

    if(strlen(szBuf) > 32-1) {
        ErrorAbort("Opcode too long.\n");
    }


    while (**ppsz == ' ' || **ppsz == ',') {
        (*ppsz)++;
    };

    //
    // szBuf has the type name, find it in the table.
    //

    i = 0;
    while (i < nArgOpcodeNames &&
           strcmp(szBuf, ArgOpcodeNames[i])) {
        i++;
    }

    if (i == nArgOpcodeNames) {
        printf("%s is not a valid arg type.\n", szBuf);
        ErrorAbort("Invalid arg type.\n");
    }

    return (BYTE)i;
}



PSZ GetOpcodeName(BYTE bInstr)
{
    char szBuf[64];

    if (!IS_RET_OPCODE(bInstr)) {
        sprintf(szBuf, "IT_%s", ArgOpcodeNames[bInstr]);
    } else {
        sprintf(szBuf, "IT_%sRET", RetOpcodeNames[bInstr & 0x7f]);
    }

    return _strdup(szBuf);
}



VOID ErrorAbort(PSZ pszMsg)
{
    printf("GENWOWIT : fatal error GWI0001: Unable to process wow.it: %s\n", pszMsg);
    exit(1);
}


//
// Read a line from the input file skipping
// comment lines with '#' in the first column.
//

PSZ GetLine(PSZ pszBuf, int cbBuf, FILE *fp)
{
    do {

        pszBuf = fgets(pszBuf, cbBuf, fp);

    } while (pszBuf && '#' == *pszBuf);

    if(pszBuf) {
        pszBuf[cbBuf-1] = '\0';
    }
    return pszBuf;
}


//
// Read one of the two special lines at the start that
// define the available types.
//


VOID ReadTypeNames(FILE *fIn, PSZ pszTypesPrefix, PSZ *OpcodeNamesArray, int *pnOpcodeNames)
{
    char chSave, szBuf[512];
    PSZ psz, pszType;

    if ( ! GetLine(szBuf, sizeof szBuf, fIn) ||
         _memicmp(szBuf, pszTypesPrefix, strlen(pszTypesPrefix)) ) {

        ErrorAbort("First line of input file must be 'Argument Types:', second 'Return Types:' ...\n");
    }

    psz = szBuf + strlen(pszTypesPrefix);

    //
    // Skip whitespace and commas
    //

    while (' ' == *psz || '\t' == *psz) {
        psz++;
    }

    if ( ! *psz) {
        ErrorAbort("No types found.\n");
    }

    do {
        //
        // Now we're looking at the first character of the type name.
        //

        pszType = psz;

        //
        // Find next whitespace, comma, semi, or null and turn it into a null.
        // This turns this type name into a zero-terminated string.
        //

        while (*psz && ' ' != *psz && '\t' != *psz && ',' != *psz && ';' != *psz) {
            psz++;
        }

        chSave = *psz;
        *psz = 0;

        OpcodeNamesArray[*pnOpcodeNames] = _strdup(pszType);
        (*pnOpcodeNames)++;

        *psz = chSave;

        //
        // Skip whitespace and commas
        //

        while (' ' == *psz || '\t' == *psz || ',' == *psz) {
            psz++;
        }

    } while (*psz && ';' != *psz);

    if(';' != *psz) {
        ErrorAbort("Semi-colon not found. Size of szBuf[] probably needs to be increased.\n");
    }

    if ( ! *pnOpcodeNames) {
        ErrorAbort("No types found.\n");
    }
}

//
// Return a formatted date/time string for now.
// Only checks system time once so that wowit.c and wowit.h
// will have same date/time string.
//

PSZ DateTimeString(VOID)
{
    static char sz[256];
    static int fSetupAlready;

    if (!fSetupAlready) {
        time_t UnixTimeNow;
        struct tm *ptmNow;

        fSetupAlready = TRUE;

        _tzset();

        time(&UnixTimeNow);

        ptmNow = localtime(&UnixTimeNow);

        strftime(sz, sizeof sz, "%#c", ptmNow);

        strcat(sz, " (");
        strcat(sz, _strupr(_tzname[0]));   // naughty me
        strcat(sz, ")");
    }

    return sz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\intthunk.c ===
/*++
 *  intthunk.c
 *
 *  WOW v5.0
 *
 *  Copyright 1996, Microsoft Corporation.  All Rights Reserved.
 *
 *  WOW32.C
 *  WOW32 16-bit API support
 *
 *  History:
 *  Created 7-Dec-96 DaveHart
 *
--*/

#include "precomp.h"
#pragma hdrstop
#include "wowit.h" // this is generated by genthunk.exe and is placed in
                   // .\daytona\obj\i386 along with wowit.c

MODNAME(intthunk.c);

extern DWORD WK32ICallProc32MakeCall(DWORD pfn, DWORD cbArgs, VOID *pArgs);

//
// On x86 we don't bother aligning pointers to DWORDs
// passed to APIs.  Perhaps we shouldn't for Alpha?
//

#ifdef _X86_
    #define ALIGNDWORDS 0
#else
    #define ALIGNDWORDS 1
#endif

ULONG FASTCALL InterpretThunk(PVDMFRAME pFrame, DWORD dwIntThunkID)
{
    PINT_THUNK_TABLEENTRY pit = &IntThunkTable[ dwIntThunkID ];
    CONST BYTE * pbInstr = pit->pbInstr;
    DWORD dwArgs32[MAX_IT_ARGS];
    PDWORD pdwArg32 = dwArgs32;
    #if ALIGNDWORDS
        BOOL fAlignedUsed = FALSE;
        DWORD adwAligned[MAX_IT_ARGS];
        PDWORD pdwAligned = adwAligned;
        DWORD avpAligned[MAX_IT_ARGS];
        PDWORD pvpAligned = avpAligned;
    #endif
    WORD UNALIGNED *pwArg16 = (WORD UNALIGNED *) ((PBYTE)&pFrame->bArgs + pFrame->cbArgs - 2);
    DWORD dwReturn;
    DWORD dw;

    WOW32ASSERTMSGF(dwIntThunkID <= ITID_MAX,
                    ("WOW32 InterpretThunk error ID %d out of range (%d max).\n",
                     dwIntThunkID, ITID_MAX));

    while ( ! (*pbInstr & IT_RETMASK)) {
        switch (*pbInstr) {

        case IT_WORD:
            *pdwArg32 = *pwArg16;
            break;

        case IT_INT:
            *pdwArg32 = INT32(*pwArg16);
            break;

        case IT_DWORD:
            *pdwArg32 = *(DWORD UNALIGNED *) --pwArg16;
            break;

        case IT_LPDWORD:
            #if ALIGNDWORDS
                if (! fAlignedUsed) {
                    fAlignedUsed = TRUE;
                    RtlZeroMemory(avpAligned, sizeof avpAligned);
                }
                *pvpAligned = *(DWORD UNALIGNED *) --pwArg16;
                if (*pvpAligned) {
                    *pdwArg32 = (DWORD) pdwAligned;
                    *pdwAligned = *(DWORD UNALIGNED *) GetPModeVDMPointer(*pvpAligned, 4);
                } else {
                    *pdwArg32 = 0;
                }
                break;
            #else
                //
                // If we aren't aligning DWORDs use the generic
                // pointer code.
                //

                /* FALL THROUGH TO IT_PTR */
            #endif

        case IT_PTR:
            dw = *(DWORD UNALIGNED *) --pwArg16;
        do_IT_PTR_with_dw:
            *pdwArg32 = (DWORD) GetPModeVDMPointer(dw, 0);
            break;

        case IT_PTRORATOM:
            dw = *(DWORD UNALIGNED *) --pwArg16;
            if (HIWORD(dw)) {
                goto do_IT_PTR_with_dw;
            }
            *pdwArg32 = dw;    // atom
            break;

        case IT_HGDI:
            *pdwArg32 = (DWORD) GDI32( (HAND16) *pwArg16 );
            break;

        case IT_HUSER:
            *pdwArg32 = (DWORD) USER32( (HAND16) *pwArg16 );
            break;

        case IT_COLOR:
            dw = *(DWORD UNALIGNED *) --pwArg16;
            *pdwArg32 = COLOR32(dw);
            break;

        case IT_HINST:
            *pdwArg32 = (DWORD) HINSTRES32( (HAND16) *pwArg16 );
            break;

        case IT_HICON:
            *pdwArg32 = (DWORD) HICON32( (HAND16) *pwArg16 );
            break;

        case IT_HCURS:
            *pdwArg32 = (DWORD) HCURSOR32( (HAND16) *pwArg16 );
            break;

        case IT_16ONLY:
            //
            // This is for params that appear on 16-bit side but not 32-bit side,
            // for example the hinstOwner passed to CopyImage in Win16 but not in Win32.
            //
            pdwArg32--;
            break;

        case IT_32ONLY:
            //
            // This is for params that appear on 32-bit side but not 16-bit side,
            // we pass zero for the 32-bit argument.
            //
            *pdwArg32 = 0;
            pwArg16++;
            break;

        default:
            WOW32ASSERTMSGF(FALSE, ("WOW32 InterpretThunk error unknown opcode 0x%x.\n", *pbInstr));
        }

        pwArg16--;
        pdwArg32++;
        pbInstr++;
        #if ALIGNDWORDS
            pdwAligned++;
            pvpAligned++;
        #endif

        WOW32ASSERT((pbInstr - pit->pbInstr) <= (MAX_IT_ARGS + 1));
    }

    //
    // Call API
    //

    dwReturn = WK32ICallProc32MakeCall(
                   (DWORD) pit->pfnAPI,
                   (PBYTE) pdwArg32 - (PBYTE) dwArgs32,
                   dwArgs32
                   );

    #ifdef DEBUG
        pFrame = NULL;         // Memory movement may have occurred.
    #endif

    //
    // If we passed aligned DWORD pointers, copy the values back.
    //

    #if ALIGNDWORDS
        if (fAlignedUsed) {
            pdwAligned = adwAligned;
            pvpAligned = avpAligned;

            while (pvpAligned < (PDWORD)((PBYTE)avpAligned + sizeof avpAligned)) {
                if (*pvpAligned) {
                    *(DWORD UNALIGNED *) GetPModeVDMPointer(*pvpAligned, 4) = *pdwAligned;
                }

                pdwAligned++;
                pvpAligned++;
            }
        }
    #endif

    //
    // Thunk return value using last instruction opcode
    //

    WOW32ASSERT(*pbInstr & IT_RETMASK);

    switch (*pbInstr) {

    case IT_DWORDRET:
        // dwReturn is correct
        break;

    case IT_WORDRET:
        dwReturn = GETWORD16(dwReturn);
        break;

    case IT_INTRET:
        dwReturn = (DWORD) GETINT16(dwReturn);
        break;

    case IT_HGDIRET:
        dwReturn = GDI16( (HAND32) dwReturn );
        break;

    case IT_HUSERRET:
        dwReturn = USER16( (HAND32) dwReturn );
        break;

    case IT_ZERORET:
        dwReturn = 0;
        break;

    case IT_HICONRET:
        dwReturn = GETHICON16( (HAND32) dwReturn );
        break;

    case IT_HCURSRET:
        dwReturn = GETHCURSOR16( (HAND32) dwReturn );
        break;

    case IT_ONERET:
        dwReturn = 1;
        break;

    case IT_HPRNDWPRET:
        dwReturn = GetPrn16( (HAND32) dwReturn );
        break;

    default:
        WOW32ASSERTMSGF(FALSE, ("WOW32 InterpretThunk error unknown return opcode 0x%x.\n", *pbInstr));
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\intthunk.h ===
/*++
 *  intthunk.h
 *
 *  WOW v5.0
 *
 *  Copyright 1996, Microsoft Corporation.  All Rights Reserved.
 *
 *  WOW32.C
 *  WOW32 16-bit API support
 *
 *  History:
 *  Created 7-Dec-96 DaveHart
 *
--*/

ULONG FASTCALL InterpretThunk(PVDMFRAME pFrame, DWORD dwIntThunkID);

//
// Win32 "APIs" which aren't in any headers.
//

BOOL APIENTRY SetMagicColors(HDC,PALETTEENTRY,ULONG);   // from ntgdi\inc\ntgdi.h
int APIENTRY GetRelAbs(HDC,INT);
int APIENTRY SetRelAbs(HDC,INT);

//
// IT() Macro for use in WOW thunk tables (w?tbl2.h)
//

#define IT(Name)        ((LPFNW32) ITID_##Name )

typedef struct _INT_THUNK_TABLEENTRY {
    FARPROC pfnAPI;
    CONST BYTE *pbInstr;
} INT_THUNK_TABLEENTRY;
typedef CONST INT_THUNK_TABLEENTRY * PINT_THUNK_TABLEENTRY;

#ifndef WOWIT_C
extern CONST INT_THUNK_TABLEENTRY IntThunkTable[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\isz.h ===
//---------------------------------------------------------------------------
// Isz.h : String resource IDs for WOW32
//
// Copyright (c) Microsoft Corporation, 1990-1995
//---------------------------------------------------------------------------

#define CCH_MAX_STRING_RESOURCE 512

//
// String resource IDs must start at 0 and continue consecutively until
// the the last critical string, so that they can be used to index
// aszCriticalStrings in the most straightforward fashion.
//

#define iszApplicationError        0x0
#define iszTheWin16Subsystem       0x1
#define iszChooseClose             0x2
#define iszChooseCancel            0x3
#define iszChooseIgnore            0x4
#define iszCausedException         0x5
#define iszCausedAV                0x6
#define iszCausedStackOverflow     0x7
#define iszCausedAlignmentFault    0x8
#define iszCausedIllegalInstr      0x9
#define iszCausedInPageError       0xa
#define iszCausedIntDivideZero     0xb
#define iszCausedFloatException    0xc
#define iszChooseIgnoreAlignment   0xd

#define CRITICAL_STRING_COUNT      0xe

#define iszWIN16InternalError      0x100
#define iszSystemError             0x101
#define iszCantEndTask             0x102
#define iszUnableToEndSelTask      0x103
#define iszNotResponding           0x104
#define iszEventHook               0x105
#define iszApplication             0x106
#define iszStartupFailed           0x107
#define iszOLEMemAllocFailedFatal  0x108
#define iszOLEMemAllocFailed       0x109

#define iszWowFaxLocalPort         0x10a

#define iszMisMatchedBinary        0x10b
#define iszMisMatchedBinaryTitle   0x10c
#define iszHeavyUse                0x10d
#define iszYouShouldNotDoThat      0x10e

//
// Macro to fetch critical string pointer based on name without preceeding isz
//

#define CRITSTR(name)      (aszCriticalStrings[isz##name])

#ifndef WOW32_C
extern LPSTR aszCriticalStrings[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\isvwow.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  ISVWOW.H
 *  WOW32 ISV Support. Public Functions and Macros for Multi-Media extensions
 *  to the WOW thunking mechanism.
 *
 *  History:
 *  Created 18-Feb-1992 by Stephen Estrop (StephenE)
--*/


/*
** Public functions that allow for extensions to the WOW thunking
** system.  These two functions enable extension thunk dlls such as
** Multi-Media video recording to callback into 16 bit code to simulate
** a hardware interrupt callback and to use the same handle mapping that
** WOW uses.
*/
LPVOID
WOW32ResolveMemory(
    VPVOID  vp
    );

BOOL APIENTRY
WOW32DriverCallback(
    DWORD dwCallback,
    DWORD dwFlags,
    WORD wID,
    WORD wMsg,
    DWORD dwUser,
    DWORD dw1,
    DWORD dw2
    );

BOOL APIENTRY
WOW32ResolveHandle(
    UINT uHandleType,
    UINT uMappingDirection,
    WORD wHandle16_In,
    LPWORD lpwHandle16_Out,
    DWORD dwHandle32_In,
    LPDWORD lpdwHandle32_Out
    );


/*
** Constants for use with WOW32ResolveHandle
*/

#define WOW32_DIR_16IN_32OUT        0x0001
#define WOW32_DIR_32IN_16OUT        0x0002

#define WOW32_USER_HANDLE           0x0001  // Generic user handle
#define WOW32_GDI_HANDLE            0x0002  // Generic gdi handle
                                            // Kernel handles are not mapped

#define WOW32_WAVEIN_HANDLE         0x0003
#define WOW32_WAVEOUT_HANDLE        0x0004
#define WOW32_MIDIOUT_HANDLE        0x0005
#define WOW32_MIDIIN_HANDLE         0x0006



/*
** These MultiMedia messages expect dwParam1 to be a generic pointer and
** dwParam2 to be a generic DWORD.  auxOutMessage, waveInMessage,
** waveOutMessage, midiInMessage and midiOutMessage all respect this
** convention and are thunked accordingly on WOW.
*/
#define DRV_BUFFER_LOW      (DRV_USER - 0x1000)     // 0x3000
#define DRV_BUFFER_USER     (DRV_USER - 0x0800)     // 0x3800
#define DRV_BUFFER_HIGH     (DRV_USER - 0x0001)     // 0x3FFF


/*
** The flags are extensions to those normally used with GetWindowFlags,
** they allow 16 bit applications to detect if they are running on NT
** and if the Intel cpu is being emulated.
*/
#define WF1_WINNT   0x40    // You are running on NT WOW
#define WF1_CPUEM   0x01    // NT WOW on MIPS or Alpha
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\makefile.inc ===
$(O)\wowit.c $(O)\wowit.h: ..\genwowit.c ..\wow.it
    -erase wow.it
    -erase $(WINDIR)\idw\genwowit.exe
    -erase $(O)\genwowit.obj
    -erase $(O)\genwowit.exe
    set PASS0ONLY=
    set MAKEDLL=
    nmake $(O)\genwowit.obj USE_MSVCRT=1 MAKE_GENWOWIT=1
    nmake $(O)\genwowit.res USE_MSVCRT=1 MAKE_GENWOWIT=1
    $(LINK_NAME) -out:$(O)\genwowit.exe @<<
-STACK:262144,4096
-MERGE:_PAGE=PAGE
-MERGE:_TEXT=.text
-SECTION:INIT,d
-OPT:REF
-OPT:ICF
-INCREMENTAL:NO
-RELEASE
-FULLBUILD
-FORCE:MULTIPLE
-IGNORE:4001,4037,4039,4065,4070,4078,4087,4089
-NODEFAULTLIB
-debug
-version:5.00
-osversion:5.00
-subsystem:console,4.00
-base:@$(COFFBASE_TXT_FILE),usermode
-entry:mainCRTStartup
$(O)\genwowit.obj
$(O)\genwowit.res
$(SDK_LIB_PATH)\msvcrt.lib
$(SDK_LIB_PATH)\kernel32.lib
<<
    cd $(O)
    genwowit.exe $(MAKEDIR)\..\wow.it
    cd $(MAKEDIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\precomp.h ===
/*++ BUILD Version: 0001
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  precomp.h
 *  Combined precompiled header source
 *
 *  This file is a collection of all the common .h files used by the
 *  various source files in this directory. It is precompiled by the
 *  build process to speed up the overall build time.
 *
 *  Put new .h files in here if it has to be seen by multiple source files.
 *  Keep in mind that the definitions in these .h files are potentially
 *  visible to all source files in this project.
 *
 *  History:
 *  Created 19-Oct-1993 by Neil Sandlin (neilsa)
--*/

#include <stddef.h>
#include <nt.h>
#include "wow32.h"
#include "wowtbl.h"
#include "doswow.h"
#include "wdos.h"
#include "wmdisp32.h"
#include "mapembed.h"
#include "wowusr.h"
#include "waccel.h"
#include "wcall16.h"
#include "wuclass.h"
#include "wsubcls.h"
#include <mmsystem.h>
#include "wkman.h"
#include "wcall32.h"
#include "wudlg.h"
#include "tdb16.h"
#include "wcntl32.h"
#include "wcuricon.h"
#include "wmsg16.h"
#include "wmsgbm.h"
#include "wmtbl32.h"
#include "wcommdlg.h"
#include "wowcmdlg.h"
#include <commdlg.h>
#include "wres16.h"
#include "wres32.h"
#include "wowkrn.h"
#include "wdde.h"
#include <dde.h>
#include "wuclip.h"
#include "wgmeta.h"
#include "wowgdi.h"
#include "wgdi.h"
#include "wgprnset.h"
#include "wgfont.h"
#include "wgdi31.h"
#include "wgpal.h"
#include "wgtext.h"
#include "wheap.h"
#include "wowkbd.h"
#include "wkbman.h"
#include "wkernel.h"
#include "wkfileio.h"
#include <winbase.h>
#include "oemuni.h"
#include "vrnmpipe.h"
#include "wkgthunk.h"
#include "wowhooks.h"
#include "wutmr.h"
#include "wreldc.h"
#include "vdmapi.h"
#include "wowinfo.h"
#include "dbgexp.h"
#include "wucomm.h"
#include "wowmmcb.h"
#include "isz.h"
#include "wkmem.h"
#include <mmddk.h>
#include "wowmmed.h"
#include "wmmstruc.h"
#include "wmmedia.h"
#include "isvwow.h"
#include <string.h>
#include <digitalv.h>
#include "wmsgcb.h"
#include "wmsgem.h"
#include "wmsglb.h"
#include "wmsgsbm.h"
#include "wumsg.h"
#include "wuman.h"
#include "vdm.h"
#include "wucaret.h"
#include "wucursor.h"
#include "wuhook.h"
#include "wumenu.h"
#include "wuser.h"
#include "wutext.h"
#include "wuwind.h"
#include "wuser31.h"
#include "wulang.h"
#include "winsockp.h"
#include "wowsnd.h"
#include "wsman.h"
#include "wowshell.h"
#include "wshell.h"
#include "wowth.h"
#include "wusercli.h"
#include "wole2.h"
#include "win95.h"
#include "wparam.h"
#include <limits.h>
#include <commctrl.h>
#include "wshimdb.h"
#include "dpmtbls.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\mapembed.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mapembed.c

Abstract:

    This module contains the functions that perform the mapping
    between the "embedding" section of win.ini, and the subkeys
    of HKEY_CLASSES_ROOT.

    This mapping is a hack implemented on Win3.1, that must also
    exist on NT.
    It is implemnted in the WOW layer, since only some win16 apps
    that read or write to the "embedding" section ( WinWord and
    MsMail) depend on it.



Author:


    Jaime F. Sasson (jaimes) 25-Nov-1992



--*/

#include "precomp.h"
#pragma hdrstop

MODNAME(mapembed.c);


#define WININITIMEOUT   2000
#define BUFFER_SIZE     128

#define EMPTY_STRING        ""

DWORD   _LastTimeUpdated = 0;



BOOL
IsWinIniHelper(
    IN LPSTR    FileName
    )


/*++

Routine Description:

    Determine if the name passed as argument refers to the file win.ini.
    Used by IS_WIN_INI macro, which assures the argument is non-null and
    deals with exact match of "win.ini".

Arguments:

    FileName -  File name to be examined.


Return Value:

    BOOL - Returns TRUE if 'Name' refers to win.ini.
              Otherwise, returns FALSE.

--*/

{
    CHAR    BufferForFullPath[MAX_PATH];
    PSTR    PointerToName;
    DWORD   SizeOfFullPath;

    BOOL    Result;

#ifdef DEBUG
    //
    // Filename argument must already be lowercase.  Be sure.
    //

    {
        int  len;
        char Lowercase[MAX_PATH];

        len = strlen(FileName);
        if(len >= MAX_PATH) {
            WOW32ASSERT((FALSE));
            return FALSE;
        }
        strcpy(Lowercase, FileName);
        WOW32_strlwr(Lowercase);
        WOW32ASSERT(!WOW32_strcmp(FileName, Lowercase));
    }
#endif

    if (!WOW32_strcmp(FileName, szWinDotIni)) {
        Result = TRUE;
        goto Done;
    }

    SizeOfFullPath = GetFullPathName( FileName,
                                      sizeof BufferForFullPath,
                                      BufferForFullPath,
                                      &PointerToName );


    if((SizeOfFullPath == 0) || (SizeOfFullPath > sizeof(BufferForFullPath))) {
        WOW32ASSERT((FALSE));
        Result = FALSE;
        goto Done;
    }

    WOW32ASSERTMSG(pszWinIniFullPath && pszWinIniFullPath[0],
                   "WOW32 ERROR pszWinIniFullPath not initialized.\n");

    Result = !WOW32_stricmp( pszWinIniFullPath, BufferForFullPath );

Done:
    return Result;
}



VOID
UpdateEmbeddingAllKeys(
        )

/*++

Routine Description:

    Update the "embedding" section of win.ini based on the information
    stored on the subkeys of HKEY_CLASSES_ROOT.

Arguments:

    None.


Return Value:

    None.

--*/

{
    LONG iClass;
    CHAR szClass[MAX_PATH + 1];
    LONG Status;

    for (iClass = 0;
        (Status = RegEnumKey(HKEY_CLASSES_ROOT,iClass,szClass,sizeof( szClass ))) != ERROR_NO_MORE_ITEMS;
        iClass++)
      {
        if( Status == ERROR_SUCCESS ) {
            UpdateEmbeddingKey( szClass );
        }
      }
}




VOID
UpdateEmbeddingKey(
    IN  LPSTR   KeyName
    )


/*++

Routine Description:

    Update one key of the "embedding" section of win.ini based on the
    information stored on the correspondent subkey of HKEY_CLASSES_ROOT.

    The embedding section in NT is found at: 
        HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Embedding

    A typical value is SoundRec which is defined with:
      REG_SZ: "Sound,Sound,sndrec32.exe,picture"
    where              ^      ^--- sndrec32.exe is the "server"
                       '--- Sound is the "ClassName"

    The code below is an improved version of the function
    "UpdateWinIni" extracted from Win 3.1 (shell\library\dbf.c).

Arguments:

    KeyName - Name of the key to be updated.


Return Value:

    None.

--*/

{
    LONG    Status;
    HKEY    Key;
    PSTR    szClass;

    LPSTR   szClassName;
    CHAR    BufferForClassName[BUFFER_SIZE];
//    char szClassName[60];

    LPSTR   szServer;
    CHAR    BufferForServer[BUFFER_SIZE];
//    char szServer[64];

    LPSTR   szLine;
    CHAR    BufferForLine[2*BUFFER_SIZE];
//    char szLine[128];

    char szOldLine[2*BUFFER_SIZE];
//    char szOldLine[128];
    LPSTR lpDesc, lpForms;
    int nCommas;

    LONG cchClassNameSize;
    LONG cchServerSize;
    LONG cchLineSize;


    if( KeyName == NULL ) {
        return;
    }

    szClass = KeyName;
    Key = NULL;

    szClassName = BufferForClassName;
    cchClassNameSize = sizeof( BufferForClassName );

    szServer = BufferForServer;
    cchServerSize = sizeof( BufferForServer );

    szLine = BufferForLine;


    if( RegOpenKey( HKEY_CLASSES_ROOT, szClass, &Key ) != ERROR_SUCCESS )
        goto NukeClass;

    Status = RegQueryValue(Key,NULL,szClassName,&cchClassNameSize);
    if( ( Status != ERROR_SUCCESS ) &&
        ( Status != ERROR_MORE_DATA ) )
        goto NukeClass;

    if( Status == ERROR_MORE_DATA ) {
        cchClassNameSize++;
        szClassName = ( PSTR )malloc_w( cchClassNameSize );
        if( szClassName == NULL )
            goto NukeClass;

        Status = RegQueryValue(Key,NULL,szClassName,&cchClassNameSize);
        if( Status != ERROR_SUCCESS )
            goto NukeClass;
    }

    if (!*szClassName)
        goto NukeClass;


    Status = RegQueryValue(Key,szServerKey,szServer,&cchServerSize);
    if( ( Status != ERROR_SUCCESS ) &&
        ( Status != ERROR_MORE_DATA ) )
        goto NukeClass;

    if( Status == ERROR_MORE_DATA ) {
        cchServerSize++;
        szServer = malloc_w( cchServerSize );
        if( szServer == NULL )
            goto NukeClass;

        Status = RegQueryValue(Key,szServerKey,szServer,&cchServerSize);
        if( Status != ERROR_SUCCESS )
            goto NukeClass;
    }

    if (!*szServer)
        goto NukeClass;


    if (GetProfileString(szEmbedding, szClass, EMPTY_STRING,
          szOldLine, sizeof(szOldLine)))
      {
        for (lpForms=szOldLine, nCommas=0; ; lpForms=AnsiNext(lpForms))
          {
            while (*lpForms == ',')
              {
                *lpForms++ = '\0';
                if (++nCommas == 3)
                    goto FoundForms;
              }
            if (!*lpForms)
                goto DoDefaults;
          }
FoundForms:
        lpDesc = szOldLine;
      }
    else
      {
DoDefaults:
        lpDesc = szClassName;
        lpForms = szPicture;
      }

    // we have a class, a classname, and a server, so its an le class

    cchLineSize = strlen( lpDesc ) +
                  strlen( szClassName ) +
                  strlen( szServer ) +
                  strlen( lpForms ) +
                  3 +
                  1;

    if( cchLineSize > sizeof( BufferForLine ) ) {
        szLine = malloc_w( cchLineSize );
        if( szLine == NULL )
            goto NukeClass;
    }
    wsprintf(szLine, "%s,%s,%s,%s",
             lpDesc, (LPSTR)szClassName, (LPSTR)szServer, lpForms);

    WriteProfileString(szEmbedding, szClass, szLine);
    if( Key != NULL ) {
        RegCloseKey( Key );
    }
    if( szClassName != BufferForClassName ) {
        free_w( szClassName );
    }
    if( szServer != BufferForServer ) {
        free_w( szServer );
    }
    if( szLine != BufferForLine ) {
        free_w( szLine );
    }
    return;

NukeClass:
/*
    Don't nuke the class because someone else may use it!

*/
    if( Key != NULL ) {
        RegCloseKey( Key );
    }
    if( szClassName != BufferForClassName ) {
        free_w( szClassName );
    }
    if( szServer != BufferForServer ) {
        free_w( szServer );
    }
    if( szLine != BufferForLine ) {
        free_w( szLine );
    }
    WriteProfileString(szEmbedding,szClass,NULL);
}



VOID
UpdateClassesRootSubKey(
    IN  LPSTR   KeyName,
    IN  LPSTR   Value
    )

/*++

Routine Description:

    Update a subkeys of HKEY_CLASSES_ROOT, based on the corresponding
    key in the "embedding" section of win.ini.

    The code below is an improved version of the function
    "UpdateFromWinIni" extracted from Win 3.1 (shell\library\dbf.c).

Arguments:

    KeyName - Name of the subkey to be updated

    Value - The value associated to the key, that was already written
            to the "embedding" section of win.ini.


Return Value:

    None.

--*/

{
    LPSTR   szLine;
    LPSTR lpClass,lpServer,lpClassName;
    LPSTR lpT;
    HKEY key = NULL;
    HKEY key1 = NULL;

    if( ( KeyName == NULL ) || ( Value == NULL ) ) {
        return;
    }

    lpClass = KeyName;
    szLine = Value;

    if (!(lpClassName=WOW32_strchr(szLine, ',')))
        return;
    // get the server name and null terminate the class name
    if (!(lpServer=WOW32_strchr(++lpClassName, ','))) {
        return;
    }
    *lpServer++ = '\0';

    // null terminate the server
    if (!(lpT=WOW32_strchr(lpServer, ','))) {
        return;
    }
    *lpT++ = '\0';

    // make sure the classname is nonblank
    while (*lpClassName == ' ')
            lpClassName++;
    if (!*lpClassName)
        return;

    // make sure the server name is nonblank
    while (*lpServer == ' ')
        lpServer++;
    if (!*lpServer)
        return;

    // we now have a valid entry
    key = NULL;
    if( ( RegCreateKey( HKEY_CLASSES_ROOT, lpClass, &key ) != ERROR_SUCCESS ) ||
        ( RegSetValue( key, NULL, REG_SZ, lpClassName, strlen( lpClassName ) ) != ERROR_SUCCESS ) ) {
        if( key != NULL ) {
            RegCloseKey( key );
        }
        return;
    }
    if( ( RegCreateKey( key, szServerKey, &key1 ) != ERROR_SUCCESS ) ||
        ( RegSetValue( key1, NULL, REG_SZ, lpServer, strlen( lpServer ) ) != ERROR_SUCCESS ) ) {
        if( key != NULL ) {
            RegCloseKey( key );
        }
        if( key1 != NULL ) {
            RegCloseKey( key1 );
        }
        return;
    }
    RegCloseKey( key );
    RegCloseKey( key1 );
}



VOID
SetLastTimeUpdated(
    )

/*++

Routine Description:

    Set the variable that contains the information of when the "embedding"
    section of win.ini was last updated.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _LastTimeUpdated = GetTickCount();
}



BOOL
WasSectionRecentlyUpdated(
    )

/*++

Routine Description:

    Inform the caller whether the "embedding" section of win.ini
    was recently updated ( less than 2 seconds ).

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if the "embedding" section was updated less than
              2 seconds ago.

--*/

{
    DWORD   Now;

    Now = GetTickCount();
    return( ( ( Now - _LastTimeUpdated ) < WININITIMEOUT ) ? TRUE : FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\sources.inc ===
INDENTED_DIRECTIVES=1

DLLORDER=..\wow32.prf

!if "$(ALT_PROJECT)" == "DAYTONA"
ALT_PROJECT_FE=daytona
!else
ALT_PROJECT_FE=fe
!endif

MVDM_TREE=$(PROJECT_ROOT)\mvdm

TARGETNAME=wow32
TARGETTYPE=DYNLINK
TARGETPATH=obj

!if "$(ALT_PROJECT)" == "DAYTONA"
PASS1_PUBLISH={$(O)\wow32.lib=$(SDK_LIB_PATH)\wow32.lib}
!endif

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernl32p.lib \
    $(WINDOWS_LIB_PATH)\gdi32p.lib \
    $(WINDOWS_LIB_PATH)\user32p.lib \
    $(WINDOWS_LIB_PATH)\apphelp.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\shell32.lib \
    $(SDK_LIB_PATH)\ntvdm.lib \
    $(MVDM_TREE)\oemuni\$(ALT_PROJECT_FE)\$(O)\oemuni.lib     \
    $(SDK_LIB_PATH)\comdlg32.lib \
    $(SDK_LIB_PATH)\version.lib \
    $(SDK_LIB_PATH)\userenv.lib

DLLENTRY=W32DllInitialize
DLLBASE=0xffb0000
DLLDEF=$(O)\wow32.def

NTTARGETFILES=
NTTARGETFILE0=$(O)\wowit.h $(O)\wowit.c

INCLUDES=\
    $(O);\
    ..;\
    ..\..\inc;\
    $(SHELL_INC_PATH);\
    $(WINDOWS_INC_PATH);\
    $(TERMSRV_INC_PATH);\
    ..\..\vdd\h

USE_NTDLL = 1

SOURCES= \
    ..\wow32.c     \
    ..\wowtbl.c    \
    ..\intthunk.c  \
    $(O)\wowit.c   \
    ..\win95.c     \
    ..\mapembed.c  \
    ..\walias.c    \
    ..\wstruc.c    \
    ..\wcall16.c   \
    ..\wcall32.c   \
    ..\wcntl32.c   \
    ..\wdde.c      \
    ..\wres16.c    \
    ..\wres32.c    \
    ..\wmsg16.c    \
    ..\wmdisp32.c  \
    ..\wmsgbm.c    \
    ..\wmsgcb.c    \
    ..\wmsgem.c    \
    ..\wmsglb.c    \
    ..\wmsgsbm.c   \
    ..\wmtbl32.c   \
    ..\wgdi31.c    \
    ..\wgdi.c      \
    ..\wgfont.c    \
    ..\wgmeta.c    \
    ..\wgpal.c     \
    ..\wgprnset.c  \
    ..\wgtext.c    \
    ..\wkbman.c    \
    ..\wkmem.c     \
    ..\wkgthunk.c  \
    ..\wkman.c     \
    ..\wkfileio.c  \
    ..\wkernel.c   \
    ..\wow32fax.c  \
    ..\wsman.c     \
    ..\wshell.c    \
    ..\wuser31.c   \
    ..\wuman.c     \
    ..\wucaret.c   \
    ..\wuclass.c   \
    ..\wuclip.c    \
    ..\wucomm.c    \
    ..\wucursor.c  \
    ..\wudlg.c     \
    ..\wuhook.c    \
    ..\wulang.c    \
    ..\wumenu.c    \
    ..\wumsg.c     \
    ..\wuser.c     \
    ..\wutext.c    \
    ..\wutmr.c     \
    ..\wuwind.c    \
    ..\wowhooks.c  \
    ..\wdos.c      \
    ..\wreldc.c    \
    ..\wcuricon.c  \
    ..\wsubcls.c   \
    ..\wmmedia.c   \
    ..\wmmedia1.c  \
    ..\wmmstru1.c  \
    ..\wmmalias.c  \
    ..\walloc16.c  \
    ..\waccel.c    \
    ..\wsdata.c    \
    ..\wsext.c     \
    ..\wsraw.c     \
    ..\wcommdlg.c  \
    ..\wheap.c     \
    ..\wspool.c    \
    ..\wusercli.c  \
    ..\wdib.c      \
    ..\wole2.c     \
    ..\wparam.c    \
    ..\wnman.c     \
    ..\wwmman.c    \
    ..\wow32.rc    \
    ..\wshimdb.c   \
    ..\wdpm.c

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IF "$(WOWPROFILE)" == ""
C_DEFINES=-DWIN_32
ASM_DEFINES=-DWIN_32
!ELSE
C_DEFINES=-DWIN_32 -DWOWPROFILE
ASM_DEFINES=-DWIN_32 -DWOWPROFILE
!ENDIF

UMTYPE=windows

!IFNDEF MAKE_GENWOWIT
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
!ENDIF

# Let build.exe know that subwtype.h is included under #ifdef (by d3dtypes.h)
# so it won't complain if it can't be found.

CONDITIONAL_INCLUDES=subwtype.h

W32_SB=1

SOURCES_USED=..\sources.inc


!if "$(ALT_PROJECT)" != "DAYTONA"
LINKER_FLAGS=$(LINKER_FLAGS) /pdb:$(O)\wow32_$(ALT_PROJECT).pdb
!endif

# No overflow checking for the VDM
BUFFER_OVERFLOW_CHECKS=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\mapembed.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mapembed.c

Abstract:

    This module contains the the prototypes of the functions that
    perform the mapping between the "embedding" section of win.ini,
    and the subkeys of HKEY_CLASSES_ROOT.

    This mapping is a hack implemented on Win3.1, that must also
    exist on NT.
    It is implemnted in the WOW layer, since only some win16 apps
    that read or write to the "embedding" section ( Excel and
    MsMail) depend on it.



Author:


    Jaime F. Sasson (jaimes) 25-Nov-1992



--*/

#if !defined( _MAP_EMBEDDING_SECTION_ )

#define _MAP_EMBEDDING_SECTION_

#define IS_EMBEDDING_SECTION(pszSection)                                     \
    ( ! (pszSection == NULL || WOW32_stricmp( pszSection, szEmbedding )) )

BOOL
IsWinIniHelper(
    IN  LPSTR   Filename
    );

//
// WARNING Filename argument to IS_WIN_INI must already be lowercase.
//

#define IS_WIN_INI(Filename) (                                               \
    (Filename)                                                               \
    ? (WOW32_strstr((Filename), szWinDotIni)                                 \
          ? IsWinIniHelper((Filename))                                       \
          : FALSE)                                                           \
     : FALSE)

VOID
UpdateEmbeddingAllKeys( VOID );

VOID
SetLastTimeUpdated( VOID );

VOID
UpdateEmbeddingKey(
    IN  LPSTR   KeyName
    );

VOID
UpdateClassesRootSubKey(
    IN  LPSTR   KeyName,
    IN  LPSTR   Value
    );

BOOL
WasSectionRecentlyUpdated( VOID );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\waccel.c ===
//*****************************************************************************
//
// LoadAccelerator - compatibility support.
//     So much code for such a thing.
//
// 23-Jul-92  NanduriR   Created.
//*****************************************************************************

#include "precomp.h"
#pragma hdrstop

MODNAME(waccel.c);

extern ULONG SetCursorIconFlag(HAND16 hAccel16, BOOL bFlag);

LPACCELALIAS lpAccelAlias = NULL;


//*****************************************************************************
// WU32LoadAccelerators -
//   This gets called from WU32NotifyWow. I use the familiar name WU32...
//   because this gets called indirectly in response to LoadAccelerator
//
//   returs TRUE for success.
//*****************************************************************************


ULONG FASTCALL WU32LoadAccelerators(VPVOID vpData)
{
    PLOADACCEL16 ploadaccel16;
    HACCEL  hAccel;
    BOOL    fReturn = (BOOL)FALSE;


    GETVDMPTR(vpData, sizeof(LOADACCEL16), ploadaccel16);

    if (FindAccelAlias((HANDLE)FETCHWORD(ploadaccel16->hAccel),
                                                              HANDLE_16BIT)) {
        LOGDEBUG(0, ("AccelAlias already exists\n"));
        return (ULONG)TRUE;
    }

    if (hAccel = CreateAccel32(ploadaccel16->pAccel, ploadaccel16->cbAccel)) {
        fReturn =  (BOOL)SetupAccelAlias(FETCHWORD(ploadaccel16->hInst),
                                         FETCHWORD(ploadaccel16->hAccel),
                                         hAccel, TRUE);
    }


    FREEVDMPTR(ploadaccel16);
    return (ULONG)fReturn;
}


//*****************************************************************************
// SetupAccelAlias -
//    sets up the alias. the alias list is doubly linked. nothing fancy.
//
//    returns pointer to the alias.
//*****************************************************************************

LPACCELALIAS SetupAccelAlias(
    HAND16 hInstance,
    HAND16 hAccel16,
    HAND32 hAccel32,
    BOOL   f16
) {
    LPACCELALIAS lpT;
    WORD         hTask16;

    hTask16 = CURRENTPTD()->htask16;
    lpT = FindAccelAlias((HANDLE)hAccel16, HANDLE_16BIT);
    if (lpT == (LPACCELALIAS)NULL) {
        lpT = malloc_w_small(sizeof(ACCELALIAS));
        if (lpT) {
            lpT->lpNext = lpAccelAlias;
            lpT->lpPrev = (LPACCELALIAS)NULL;

            if (lpAccelAlias)
                lpAccelAlias->lpPrev = lpT;

            lpAccelAlias = lpT;
        }
    }
    else {
        LOGDEBUG(0, ("SetupAccelAlias: Alias Already exists. how & why?\n"));
        WOW32ASSERT(FALSE);
    }

    if (lpT) {
        lpT->hInst   = hInstance;
        lpT->hTask16 = CURRENTPTD()->htask16;
        lpT->h16     = hAccel16;
        lpT->h32     = hAccel32;
        lpT->f16     = (WORD)f16;

        // mark this so we can remove it from the alias list when
        // FreeResource() (in user.exe) calls GlobalFree() (in krnl386)
        SetCursorIconFlag(hAccel16, TRUE);
    }
    else {
        WOW32ASSERT(FALSE);
    }


    return (LPACCELALIAS)lpT;
}


//*****************************************************************************
// DestroyAccelAlias -
//    Deletes the 32bit table and Frees the memory
//
//    returns TRUE for success
//*****************************************************************************

BOOL  DestroyAccelAlias(WORD hTask16)
{
    WORD hCurTask16;
    LPACCELALIAS lpT;
    LPACCELALIAS lpTFree;

    hCurTask16 = CURRENTPTD()->htask16;
    lpT = lpAccelAlias;
    while (lpT) {
         if (lpT->hTask16 == hCurTask16) {
             if (lpT->lpPrev)
                 lpT->lpPrev->lpNext = lpT->lpNext;

             if (lpT->lpNext)
                 lpT->lpNext->lpPrev = lpT->lpPrev;

             if ( lpT->f16 ) {
                 DestroyAcceleratorTable(lpT->h32);
             } else {
                 // this function - DestroyAccelAlias- gets called during
                 // taskexit time and the 16bit task cleanup code has already
                 // freed this memory handle. so this callback is not needed.
                 //                                                - nanduri
                 // WOWGlobalFree16( lpT->h16 );
             }

             lpTFree = lpT;
             lpT = lpT->lpNext;
             if (lpTFree == lpAccelAlias)
                 lpAccelAlias = lpT;

             free_w_small(lpTFree);
         }
         else
             lpT = lpT->lpNext;
    }


    return TRUE;
}


//*****************************************************************************
// FindAccelAlias -
//    maps 16 bit handle to 32bit handle and vice versa
//
//    returns TRUE for success
//*****************************************************************************

LPACCELALIAS FindAccelAlias(HANDLE hAccel, UINT fSize)
{
    WORD hCurTask16;
    LPACCELALIAS lpT;

    hCurTask16 = CURRENTPTD()->htask16;
    lpT = lpAccelAlias;
    while (lpT) {
        if (lpT->hTask16 == hCurTask16) {
            if (fSize & HANDLE_16BIT) {
                if (lpT->h16 == (HAND16)hAccel)
                    return lpT;
            }
            else {
                if (lpT->h32 == (HAND32)hAccel)
                    return lpT;
            }
        }

        lpT = lpT->lpNext;
    }

    return NULL;
}


//*****************************************************************************
// GetAccelHandle32 -
//    Returns h32, given h16.
//
//*****************************************************************************

HAND32 GetAccelHandle32(HAND16 h16)
{
  LPACCELALIAS lpT;

  if (!(lpT = FindAccelAlias((HANDLE)(h16), HANDLE_16BIT))) {
      DWORD cbAccel16;
      VPVOID vpAccel16;
      HACCEL hAccel;

      if (vpAccel16 = RealLockResource16(h16, &cbAccel16)) {
          if (hAccel = CreateAccel32(vpAccel16, cbAccel16)) {
              lpT = SetupAccelAlias(CURRENTPTD()->hInst16,  h16,  hAccel, TRUE);
          }
          GlobalUnlock16(h16);
      }
  }
  return  (lpT) ? lpT->h32 : (HAND32)NULL;

}

//*****************************************************************************
// GetAccelHandle16 -
//    Returns h16, given h32.
//
//*****************************************************************************

HAND16 GetAccelHandle16(HAND32 h32)
{
    LPACCELALIAS lpT;
    HAND16  hAccel16;

    if (!(lpT = FindAccelAlias((HANDLE)(h32), HANDLE_32BIT))) {
        //
        // There isn't a corresponding 16-bit accelerator table handle already
        // so create one.
        //
        if ( (hAccel16 = CreateAccel16(h32)) != 0 ) {
            lpT = SetupAccelAlias(CURRENTPTD()->hInst16, hAccel16, h32, FALSE );
        }
    }

    return  (lpT) ? lpT->h16 : (HAND16)NULL;
}

//*****************************************************************************
// CreateAccel32 -
//   This gets called from WU32NotifyWow.
//
//   returs TRUE for success.
//*****************************************************************************


HACCEL CreateAccel32(VPVOID vpAccel16, DWORD cbAccel16)
{
    PSZ          pAccel16;
    DWORD        nElem16;

    LPACCEL lpAccel;
    HACCEL  hAccel = (HACCEL)NULL;
    UINT    i;
#if DBG
    UINT    LastKeyIndex = 0xffffffff;
#endif

    //
    // pAccel16 is pointer to an array of records of length:
    //    (BYTE+WORD+WORD)
    //

    GETVDMPTR(vpAccel16 , cbAccel16, pAccel16);
    if (pAccel16) {

        //
        // convert the 16bit accel table to 32bit format and create it.
        //

        nElem16 = cbAccel16 / (sizeof(BYTE) + 2 * sizeof(WORD));
        lpAccel = (LPACCEL)malloc_w(nElem16 * sizeof(ACCEL));
        if (lpAccel) {
            for (i=0; i<nElem16; ++i) {
                 lpAccel[i].fVirt = *(LPBYTE)(pAccel16);
#if DBG
                 if ((lpAccel[i].fVirt & 0x80) && i < LastKeyIndex) {
                    LastKeyIndex = i;
                 }
#endif
                 ((LPBYTE)pAccel16)++;
                 lpAccel[i].key   = FETCHWORD(*(LPWORD)pAccel16);
                 ((LPWORD)pAccel16)++;
                 lpAccel[i].cmd   = FETCHWORD(*(LPWORD)pAccel16);
                 ((LPWORD)pAccel16)++;
            }

#if DBG
            if (LastKeyIndex == 0xffffffff) {
                LOGDEBUG(LOG_ALWAYS, ("WOW::CreateAccel32 : no LastKey found in 16-bit haccel\n"));
            } else if (LastKeyIndex < nElem16-1) {
                LOGDEBUG(LOG_ALWAYS, ("WOW::CreateAccel32 : bogus LastKey flags ignored in 16-bit haccel\n"));
            }
#endif
            hAccel = CreateAcceleratorTable(lpAccel, i);
            free_w(lpAccel);
        }
        FREEVDMPTR(pAccel16);
    }

    return hAccel;
}

//*****************************************************************************
// CreateAccel16 -
//   This gets called from WU32NotifyWow.
//
//   returns HACCEL16 for success.
//*****************************************************************************

HAND16 CreateAccel16(HACCEL hAccel32)
{
    UINT    iEntries;
    UINT    cbSize;
    LPACCEL lpAccel32;
    HAND16  hAccel16;
    VPVOID  vpAccel16;
    LPBYTE  lpAccel16;
    LPBYTE  lpAccel16Original;
    UINT    i;

    iEntries = CopyAcceleratorTable( hAccel32, NULL, 0 );

    if ( iEntries == 0 ) {      // Invalid hAccel32
        return( 0 );
    }

    lpAccel32 = (LPACCEL)malloc_w(iEntries * sizeof(ACCEL));
    if ( lpAccel32 == NULL ) {
        LOGDEBUG(LOG_ERROR, ("WOW::CreateAccel16 : Failed to alloc memory for 32-bit accel\n"));
        return( 0 );
    }

    iEntries = CopyAcceleratorTable( hAccel32, lpAccel32, iEntries );

    cbSize = iEntries * (sizeof(BYTE) + 2 * sizeof(WORD));

    vpAccel16 = GlobalAllocLock16( GMEM_MOVEABLE, cbSize, &hAccel16 );

    if ( vpAccel16 == 0 ) {     // Out of 16-bit memory
        LOGDEBUG(LOG_ERROR, ("WOW::CreateAccel16 : Failed to alloc memory for 16-bit haccel\n"));
        free_w( lpAccel32 );
        return( 0 );
    }

    GETVDMPTR(vpAccel16, cbSize, lpAccel16 );

    WOW32ASSERT( lpAccel16 != NULL );

    lpAccel16Original = lpAccel16;

    //
    // Now iterate through the entries changing them and moving them into
    // the 16-bit memory.
    //

    i = 0;

    while ( i < iEntries ) {
        if ( i == iEntries-1 ) {
            // Last one, set the last bit
            *lpAccel16++ = lpAccel32[i].fVirt | 0x80;
        } else {
            *lpAccel16++ = lpAccel32[i].fVirt;
        }
        *((PWORD16)lpAccel16) = lpAccel32[i].key;
        lpAccel16 += sizeof(WORD);
        *((PWORD16)lpAccel16) = lpAccel32[i].cmd;
        lpAccel16 += sizeof(WORD);

        i++;
    }

    FLUSHVDMPTR(vpAccel16, cbSize, lpAccel16Original);
    FREEVDMPTR(lpAccel16Original);

    GlobalUnlock16( hAccel16 );

    return( hAccel16 );
}



// this gets called indirectly from GlobalFree() in krnl386.exe
// via WK32WowCursorIconOp() in wcuricon.c
void FreeAccelAliasEntry(LPACCELALIAS lpT) {

    if (lpT == lpAccelAlias)
        lpAccelAlias = lpT->lpNext;

    if (lpT->lpPrev)
        lpT->lpPrev->lpNext = lpT->lpNext;

    if (lpT->lpNext)
        lpT->lpNext->lpPrev = lpT->lpPrev;

    if ( lpT->f16 ) {
        DestroyAcceleratorTable(lpT->h32);
    } else {
         // this function - FreeAccelAliasEntry -- is being called
         // indirectly from GlobalFree() in krnl386.  GlobalFree()
         // takes care of freeing h16 so this callback is not needed.
         //                                                - a-craigj
         // WOWGlobalFree16( lpT->h16 );
    }

    free_w_small(lpT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wcall16.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WCALL16.H
 *  WOW32 16-bit message/callback support
 *
 *  History:
 *  Created 11-Mar-1991 by Jeff Parsons (jeffpar)
 *  Changed 18-Aug-1992 by Mike Tricker (MikeTri) Added DOS PDB and SFT prototypes
--*/


/* Function prototypes
 */
HANDLE  LocalAlloc16(WORD wFlags, INT cb, HANDLE hInstance);
HANDLE  LocalReAlloc16(HANDLE hMem, INT cb, WORD wFlags);
VPVOID  LocalLock16(HANDLE hMem);
BOOL    LocalUnlock16(HANDLE hMem);
WORD    LocalSize16(HANDLE hMem);
HANDLE  LocalFree16(HANDLE hMem);
BOOL    LockSegment16(WORD wSeg);
BOOL    UnlockSegment16(WORD wSeg);
HAND16  GetExePtr16( HAND16 hInstance );
WORD    ChangeSelector16( WORD wSeg );
VPVOID  RealLockResource16( HMEM16 hMem, PINT pcb );
WORD    GetModuleFileName16( HAND16 hInst, VPVOID lpszModuleName, WORD cchModuleName );

BOOL CallBack16(INT iRetID, PPARM16 pParms, VPPROC vpfnProc, PVPVOID pvpReturn);


VPVOID FASTCALL malloc16(UINT cb);
BOOL   FASTCALL free16(VPVOID vp);
VPVOID FASTCALL stackalloc16(UINT cb);

#ifdef DEBUG
VOID   FASTCALL StackFree16(VPVOID vp, UINT cb);
#define stackfree16(vp,cb) StackFree16(vp,cb)
#else
VOID   FASTCALL StackFree16(UINT cb);
#define stackfree16(vp,cb) StackFree16(cb)
#endif

ULONG  GetDosPDB16(VOID);
ULONG  GetDosSFT16(VOID);
int WINAPI WOWlstrcmp16(LPCWSTR lpString1, LPCWSTR lpString2);

/* Function prototypes for 16-bit Global memory functions are now in
 * \nt\public\sdk\inc\winntwow.h with slightly different names.  The
 * old names are supported by the following defines:
 */

#define GlobalAllocLock16  WOWGlobalAllocLock16
#define GlobalLock16       WOWGlobalLockSize16
#define GlobalUnlock16     WOWGlobalUnlock16
#define GlobalUnlockFree16 WOWGlobalUnlockFree16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wcall16.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WCALL16.C
 *  WOW32 16-bit message/callback support
 *
 *  History:
 *  Created 11-Mar-1991 by Jeff Parsons (jeffpar)
 *  Changed 18-Aug-1992 by Mike Tricker (MikeTri) Added DOS PDB and SFT functions
--*/


#include "precomp.h"
#pragma hdrstop


MODNAME(wcall16.c);

#define WOWFASTEDIT

#ifdef WOWFASTEDIT

typedef struct _LOCALHANDLEENTRY {
    WORD    lhe_address;    // actual address of object
    BYTE    lhe_flags;      // flags and priority level
    BYTE    lhe_count;      // lock count
} LOCALHANDLEENTRY, *PLOCALHANDLEENTRY;

#define LA_MOVEABLE     0x0002      // moveable or fixed?

#define LHE_DISCARDED   0x0040      // Marks objects that have been discarded.

#endif

/* Common callback functions
 */
HANDLE LocalAlloc16(WORD wFlags, INT cb, HANDLE hInstance)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    if (LOWORD(hInstance) == 0 ) {     /* if lo word == 0, then this is a 32-bit
					   hInstance, which makes no sense */
	WOW32ASSERT(LOWORD(hInstance));
        return (HANDLE)0;
    }

    if (cb < 0 || cb > 0xFFFF) {
        WOW32ASSERT(cb > 0 && cb <= 0xFFFF);
        return (HANDLE)0;
    }

    Parm16.WndProc.wMsg = LOWORD(hInstance) | 1;

    Parm16.WndProc.wParam = wFlags;
    Parm16.WndProc.lParam = cb;
    CallBack16(RET_LOCALALLOC, &Parm16, 0, &vp);

    if (LOWORD(vp) == 0)
        vp = 0;

    return (HANDLE)vp;
}


HANDLE LocalReAlloc16(HANDLE hMem, INT cb, WORD wFlags)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    if (HIWORD(hMem) == 0 || cb < 0 || cb > 0xFFFF) {
        WOW32ASSERT(HIWORD(hMem) && cb >= 0 && cb <= 0xFFFF);
        return (HANDLE)0;
    }

    LOGDEBUG(4,("LocalRealloc DS = %x, hMem = %x, bytes = %x, flags = %x\n",HIWORD(hMem),LOWORD(hMem),cb,wFlags));
    Parm16.WndProc.lParam = (LONG)hMem;
    Parm16.WndProc.wParam = wFlags;
    Parm16.WndProc.wMsg = (WORD)cb;
    CallBack16(RET_LOCALREALLOC, &Parm16, 0, &vp);

    if (LOWORD(vp) == 0)
        vp = 0;

    return (HANDLE)vp;
}

#ifndef WOWFASTEDIT

VPVOID LocalLock16(HANDLE hMem)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem) != 0);
        return (VPVOID)0;
    }

    Parm16.WndProc.lParam = (LONG)hMem;
    CallBack16(RET_LOCALLOCK, &Parm16, 0, &vp);

    return vp;
}

BOOL LocalUnlock16(HANDLE hMem)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem));
        return FALSE;
    }

    Parm16.WndProc.lParam = (LONG)hMem;
    CallBack16(RET_LOCALUNLOCK, &Parm16, 0, &vp);

    return (BOOL)vp;
}

#else

VPVOID LocalLock16(HANDLE hMem)
{
    WORD    h16;
    LONG    retval;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem) != 0);
        return (VPVOID)0;
    }

    h16 = LOWORD(hMem);
    retval = (VPVOID)hMem;

    if (h16 & LA_MOVEABLE) {
        PLOCALHANDLEENTRY plhe;

        GETVDMPTR(hMem, sizeof(*plhe), plhe);

        if (plhe->lhe_flags & LHE_DISCARDED) {
            goto LOCK1;
        }

        plhe->lhe_count++;
        if (!plhe->lhe_count)
            plhe->lhe_count--;

LOCK1:
        LOW(retval) = plhe->lhe_address;
        FLUSHVDMPTR((ULONG)hMem, sizeof(*plhe), plhe);
        FREEVDMPTR(plhe);
    }

    if (LOWORD(retval) == 0)
        retval = 0;

    return retval;
}

BOOL LocalUnlock16(HANDLE hMem)
{
    WORD    h16;
    BOOL    rc;
    PLOCALHANDLEENTRY plhe;
    BYTE    count;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem));
        return FALSE;
    }

    rc = FALSE;
    h16 = LOWORD(hMem);

    if (!(h16 & LA_MOVEABLE)) {
        goto UNLOCK2;
    }

    GETVDMPTR(hMem, sizeof(*plhe), plhe);

    if (plhe->lhe_flags & LHE_DISCARDED)
        goto UNLOCK1;

    count = plhe->lhe_count;
    count--;

    if (count >= (BYTE)(0xff-1))
        goto UNLOCK1;

    plhe->lhe_count = count;
    rc = (BOOL)((SHORT)count);

    FLUSHVDMPTR((ULONG)hMem, sizeof(*plhe), plhe);

UNLOCK1:
    FREEVDMPTR(plhe);

UNLOCK2:
    return rc;
}

#endif  // WOWFASTEDIT


WORD LocalSize16(HANDLE hMem)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem));
        return FALSE;
    }

    Parm16.WndProc.lParam = (LONG)hMem;
    CallBack16(RET_LOCALSIZE, &Parm16, 0, &vp);

    return (WORD)vp;
}


HANDLE LocalFree16(HANDLE hMem)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem));
        return (HANDLE)0;
    }

    Parm16.WndProc.lParam = (LONG)hMem;
    CallBack16(RET_LOCALFREE, &Parm16, 0, &vp);

    if (LOWORD(vp) == 0) {
        vp = 0;
    } else {
        WOW32ASSERT(LOWORD(vp) == LOWORD(hMem));
        vp = (VPVOID)hMem;
    }

    return (HANDLE)vp;
}


BOOL LockSegment16(WORD wSeg)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    Parm16.WndProc.wParam = wSeg;
    CallBack16(RET_LOCKSEGMENT, &Parm16, 0, &vp);

    return (BOOL)vp;
}


BOOL UnlockSegment16(WORD wSeg)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    Parm16.WndProc.wParam = wSeg;
    CallBack16(RET_UNLOCKSEGMENT, &Parm16, 0, &vp);

    return (BOOL)vp;
}


VPVOID  WOWGlobalAllocLock16(WORD wFlags, DWORD cb, HMEM16 *phMem)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    Parm16.WndProc.wParam = wFlags;
    Parm16.WndProc.lParam = cb;
    CallBack16(RET_GLOBALALLOCLOCK, &Parm16, 0, &vp);

    if (vp) {

        // Get handle of 16-bit object
        if (phMem) {
            *phMem = Parm16.WndProc.wParam;
        }
    }
    return vp;
}


HMEM16 WOWGlobalAlloc16(WORD wFlags, DWORD cb)
{
    HMEM16 hMem;
    VPVOID vp;

    if (vp = WOWGlobalAllocLock16(wFlags, cb, &hMem)) {
        WOWGlobalUnlock16(hMem);
    } else {
        hMem = 0;
    }

    return hMem;
}


VPVOID  WOWGlobalLockSize16(HMEM16 hMem, PDWORD pcb)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    Parm16.WndProc.wParam = hMem;
    CallBack16(RET_GLOBALLOCK, &Parm16, 0, &vp);

    // Get size of 16-bit object    (will be 0 if lock failed)
    if (pcb) {
        *pcb = Parm16.WndProc.lParam;
    }

    return vp;
}


VPVOID WOWGlobalLock16(HMEM16 hMem)
{
    return WOWGlobalLockSize16(hMem, NULL);
}


BOOL WOWGlobalUnlock16(HMEM16 hMem)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    Parm16.WndProc.wParam = hMem;
    CallBack16(RET_GLOBALUNLOCK, &Parm16, 0, &vp);

    return (BOOL)vp;
}


HMEM16 WOWGlobalUnlockFree16(VPVOID vpMem)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    Parm16.WndProc.lParam = vpMem;
    CallBack16(RET_GLOBALUNLOCKFREE, &Parm16, 0, &vp);

    return (HMEM16)vp;
}


HMEM16 WOWGlobalFree16(HMEM16 hMem)
{
    VPVOID vp;

    if (vp = WOWGlobalLock16(hMem)) {
        hMem = WOWGlobalUnlockFree16(vp);
    } else {
        // On failure we return the passed-in handle,
        // so there's nothing to do.
    }

    return hMem;
}


HAND16 GetExePtr16( HAND16 hInst )
{
    PARM16 Parm16;
    ULONG ul;
    PTD ptd;
    INT i;

    if (hInst == 0) return (HAND16)0;

    //
    // see if this is the hInst for the current task
    //

    ptd = CURRENTPTD();

    if (hInst == ptd->hInst16) {
        return ptd->hMod16;
    }

    //
    // check the cache
    //

    for (i = 0; i < CHMODCACHE; i++) {
        if (ghModCache[i].hInst16 == hInst)
            return ghModCache[i].hMod16;
    }

    /*
    ** Function returns a hModule, given an hInstance
    */
    Parm16.WndProc.wParam = hInst;
    CallBack16(RET_GETEXEPTR, &Parm16, 0, &ul);


    //
    // GetExePtr(hmod) returns hmod, don't cache these.
    //

    if (hInst != (HAND16)LOWORD(ul)) {

        //
        // update the cache
        // slide everybody down 1 entry, put this new guy at the top
        //

        RtlMoveMemory(ghModCache+1, ghModCache, sizeof(HMODCACHE)*(CHMODCACHE-1));
        ghModCache[0].hInst16 = hInst;
        ghModCache[0].hMod16 = (HAND16)LOWORD(ul);
    }

    return (HAND16)LOWORD(ul);
}


WORD GetModuleFileName16( HAND16 hInst, VPVOID lpszModuleName, WORD cchModuleName )
{
    PARM16 Parm16;
    ULONG ul;


    if (hInst == 0) return 0;

    Parm16.WndProc.wParam = hInst;
    Parm16.WndProc.lParam = lpszModuleName;
    Parm16.WndProc.wMsg   = cchModuleName;
    CallBack16(RET_GETMODULEFILENAME, &Parm16, 0, &ul );

    return( LOWORD(ul) );
}


ULONG GetDosPDB16(VOID)
{
    PARM16 Parm16;
    DWORD dwReturn = 0;

    CallBack16(RET_GETDOSPDB, &Parm16, 0, &dwReturn);

    return (ULONG)dwReturn;
}


ULONG GetDosSFT16(VOID)
{
    PARM16 Parm16;
    DWORD dwReturn = 0;

    CallBack16(RET_GETDOSSFT, &Parm16, 0, &dwReturn);

    return (ULONG)dwReturn;
}

// Given a data selector change it into a code selector

WORD ChangeSelector16(WORD wSeg)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    Parm16.WndProc.wParam = wSeg;
    CallBack16(RET_CHANGESELECTOR, &Parm16, 0, &vp);

    return LOWORD(vp);
}

VPVOID RealLockResource16(HMEM16 hMem, PINT pcb)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    Parm16.WndProc.wParam = hMem;
    CallBack16(RET_LOCKRESOURCE, &Parm16, 0, &vp);

    // Get size of 16-bit object    (will be 0 if lock failed)
    if (pcb) {
        *pcb = Parm16.WndProc.lParam;
    }

    return vp;
}

int WINAPI WOWlstrcmp16(LPCWSTR lpString1, LPCWSTR lpString2)
{
    PARM16 Parm16;
    DWORD dwReturn = 0;
    DWORD cb1, cb2;
    VPSTR vp1, vp2;
    LPSTR p1, p2;

    //
    // to handle DBCS correctly allocate enough room
    // for two DBCS bytes for every unicode char.
    //

    cb1 = sizeof(WCHAR) * (wcslen(lpString1) + 1);
    cb2 = sizeof(WCHAR) * (wcslen(lpString2) + 1);

    // be sure allocation size matches stackfree16() size below
    vp1 = stackalloc16(cb1 + cb2);
    vp2 = vp1 + cb1;

    p1 = VDMPTR(vp1, cb1);
    p2 = p1 + cb1;

    RtlUnicodeToMultiByteN(
        p1,
        cb1,
        NULL,
        (LPWSTR) lpString1,   // cast because arg isn't declared const
        cb1
        );

    RtlUnicodeToMultiByteN(
        p2,
        cb2,
        NULL,
        (LPWSTR) lpString2,   // cast because arg isn't declared const
        cb2
        );

    FREEVDMPTR(p1);

    Parm16.lstrcmpParms.lpstr1 = vp1;
    Parm16.lstrcmpParms.lpstr2 = vp2;

    CallBack16(RET_LSTRCMP, &Parm16, 0, &dwReturn);

    stackfree16(vp1, (cb1 + cb2));

    return (int)(short int)LOWORD(dwReturn);
}


DWORD WOWCallback16(DWORD vpFn, DWORD dwParam)
{
    PARM16 Parm16;
    VPVOID vp;

    //
    // Copy DWORD parameter to PARM16 structure.
    //

    RtlCopyMemory(&Parm16.WOWCallback16.wArgs, &dwParam, sizeof(dwParam));

    //
    // Use semi-slimy method to pass argument size to CallBack16.
    //

    vp = (VPVOID) sizeof(dwParam);

    CallBack16(RET_WOWCALLBACK16, &Parm16, (VPPROC)vpFn, &vp);

    return (DWORD)vp;
}


BOOL WOWCallback16Ex(
         DWORD vpFn,
         DWORD dwFlags,
         DWORD cbArgs,
         PVOID pArgs,
         PDWORD pdwRetCode
         )
{
#ifdef DEBUG
    static BOOL fFirstTime = TRUE;

    if (fFirstTime) {

        //
        // Ensure that wownt32.h's definition of WCB16_MAX_CBARGS
        // matches wow.h's definition of PARMWCB16.
        //

        WOW32ASSERT( WCB16_MAX_CBARGS == sizeof(PARMWCB16) );

        //
        // If the PARMWCB16 structure is smaller than the PARM16
        // union, we should increase the size of PARMWCB16 and
        // WCB16_MAX_CBARG to allow the use of the extra bytes.
        //

        WOW32ASSERT( sizeof(PARMWCB16) == sizeof(PARM16) );

        fFirstTime = FALSE;
    }
#endif // DEBUG

    if (cbArgs > sizeof(PARM16)) {
        LOGDEBUG(LOG_ALWAYS, ("WOWCallback16V: cbArgs = %u, must be <= %u",
                              cbArgs, (unsigned) sizeof(PARM16)));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // For cdecl functions we don't want to "sub SP, cbArgs" after calling
    // the function, so we pass 0 as cbArgs to the 16-bit side.
    //

    if (dwFlags & WCB16_CDECL) {
        cbArgs = 0;
    }

    //
    // Use semi-slimy method to pass argument size to CallBack16.
    //

    *pdwRetCode = cbArgs;

    CallBack16(RET_WOWCALLBACK16, (PPARM16)pArgs, (VPPROC)vpFn, (PVPVOID)pdwRetCode);

    return TRUE;
}


BOOL CallBack16(INT iRetID, PPARM16 pParm16, VPPROC vpfnProc, PVPVOID pvpReturn)
{
#ifdef DEBUG
    static PSZ apszCallBacks[] = {
    "ERROR:RETURN",         // RET_RETURN       (not a callback!)
    "ERROR:DEBUGRETURN",    // RET_DEBUGRETURN  (not a callback!)
    "DEBUG",                // RET_DEBUG
    "WNDPROC",              // RET_WNDPROC
    "ENUMFONTPROC",         // RET_ENUMFONTPROC
    "ENUMWINDOWPROC",       // RET_ENUMWINDOWPROC
    "LOCALALLOC",           // RET_LOCALALLOC
    "LOCALREALLOC",         // RET_LOCALREALLOC
    "LOCALLOCK",            // RET_LOCALLOCK
    "LOCALUNLOCK",          // RET_LOCALUNLOCK
    "LOCALSIZE",            // RET_LOCALSIZE
    "LOCALFREE",            // RET_LOCALFREE
    "GLOBALALLOCLOCK",      // RET_GLOBALALLOCLOCK
    "GLOBALLOCK",           // RET_GLOBALLOCK
    "GLOBALUNLOCK",         // RET_GLOBALUNLOCK
    "GLOBALUNLOCKFREE",     // RET_GLOBALUNLOCKFREE
    "FINDRESOURCE",         // RET_FINDRESOURCE
    "LOADRESOURCE",         // RET_LOADRESOURCE
    "FREERESOURCE",         // RET_FREERESOURCE
    "LOCKRESOURCE",         // RET_LOCKRESOURCE
    "UNLOCKRESOURCE",       // RET_UNLOCKRESOURCE
    "SIZEOFRESOURCE",       // RET_SIZEOFRESOURCE
    "LOCKSEGMENT",          // RET_LOCKSEGMENT
    "UNLOCKSEGMENT",        // RET_UNLOCKSEGMENT
    "ENUMMETAFILEPROC",     // RET_ENUMMETAFILEPROC
    "TASKSTARTED    ",      // RET_TASKSTARTED
    "HOOKPROC",             // RET_HOOKPROC
    "SUBCLASSPROC",         // RET_SUBCLASSPROC
    "LINEDDAPROC",          // RET_LINEDDAPROC
    "GRAYSTRINGPROC",       // RET_GRAYSTRINGPROC
    "FORCETASKEXIT",        // RET_FORCETASKEXIT
    "SETCURDIR",            // RET_SETCURDIR
    "ENUMOBJPROC",          // RET_ENUMOBJPROC
    "SETCURSORICONFLAG",    // RET_SETCURSORICONFLAG
    "SETABORTPROC",         // RET_SETABORTPROC
    "ENUMPROPSPROC",        // RET_ENUMPROPSPROC
    "FORCESEGMENTFAULT",    // RET_FORCESEGMENTFAULT
    "LSTRCMP",              // RET_LSTRCMP
    "UNUSEDFUNC",           // 
    "UNUSEDFUNC",           // 
    "UNUSEDFUNC",           // 
    "UNUSEDFUNC",           // 
    "GETEXEPTR",            // RET_GETEXEPTR
    "UNUSEDFUNC",           // 
    "FORCETASKFAULT",       // RET_FORCETASKFAULT
    "GETEXPWINVER",         // RET_GETEXPWINVER
    "GETCURDIR",            // RET_GETCURDIR
    "GETDOSPDB",            // RET_GETDOSPDB
    "GETDOSSFT",            // RET_GETDOSSFT
    "FOREGROUNDIDLE",       // RET_FOREGROUNDIDLE
    "WINSOCKBLOCKHOOK",     // RET_WINSOCKBLOCKHOOK
    "WOWDDEFREEHANDLE",     // RET_WOWDDEFREEHANDLE
    "CHANGESELECTOR",       // RET_CHANGESELECTOR
    "GETMODULEFILENAME",    // RET_GETMODULEFILENAME
    "WORDBREAKPROC",        // RET_WORDBREAKPROC
    "WINEXEC",              // RET_WINEXEC
    "WOWCALLBACK16",        // RET_WOWCALLBACK16
    "GETDIBSIZE",           // RET_GETDIBSIZE
    "GETDIBFLAGS",          // RET_GETDIBFLAGS
    "SETDIBSEL",            // RET_SETDIBSEL
    "FREEDIBSEL",           // RET_FREEDIBSEL
    };
#endif
    register PTD ptd;
    register PVDMFRAME pFrame;
    register PCBVDMFRAME pCBFrame;
    WORD wAX;
    BOOL fComDlgSync = FALSE;
    INT  cStackAlloc16;
    VPVOID   vpCBStack;  // See NOTES in walloc16.c\stackalloc16()

    USHORT SaveIp;

#ifdef DEBUG
    VPVOID   vpStackT;
#endif

    WOW32ASSERT(iRetID != RET_RETURN && iRetID != RET_DEBUGRETURN);

    ptd = CURRENTPTD();

    // ssync 16-bit & 32-bit common dialog structs (see wcommdlg.c)
    if(ptd->CommDlgTd) {

        // only ssync for stuff that might actually callback into the app
        // ie. we don't need to ssync every time wow32 calls GlobalLock16
        switch(iRetID) {
            case RET_WNDPROC:           // try to get these in a most frequently
            case RET_HOOKPROC:          // used order
            case RET_WINSOCKBLOCKHOOK:
            case RET_ENUMFONTPROC:
            case RET_ENUMWINDOWPROC:
            case RET_ENUMOBJPROC:
            case RET_ENUMPROPSPROC:
            case RET_LINEDDAPROC:
            case RET_GRAYSTRINGPROC:
            case RET_SETWORDBREAKPROC:
            case RET_SETABORTPROC:
                // Note: This call can invalidate flat ptrs to 16-bit mem
                Ssync_WOW_CommDlg_Structs(ptd->CommDlgTd, w32to16, 0);
                fComDlgSync = TRUE;   // set this for return ssync
                break;
            default:
                break;
        }
    }

    GETFRAMEPTR(ptd->vpStack, pFrame);

    // Just making sure that this thread matches the current 16-bit task

    WOW32ASSERT((pFrame->wTDB == ptd->htask16) ||
                (ptd->dwFlags & TDF_IGNOREINPUT) ||
                (ptd->htask16 == 0));


    // set up the callback stack frame from the correct location
    // & make it word aligned.
    // if stackalloc16() hasn't been called since the app called into wow32
    if (ptd->cStackAlloc16 == 0) {
        vpCBStack = ptd->vpStack;
        ptd->vpCBStack = (ptd->vpStack - sizeof(CBVDMFRAME)) & (~0x1);
    }
    else {
        vpCBStack = ptd->vpCBStack;
        ptd->vpCBStack = (ptd->vpCBStack - sizeof(CBVDMFRAME)) & (~0x1);
    }

    GETFRAMEPTR(ptd->vpCBStack, (PVDMFRAME)pCBFrame);
    pCBFrame->vpStack    = ptd->vpStack;
    pCBFrame->wRetID     = (WORD)iRetID;
    pCBFrame->wTDB       = pFrame->wTDB;
    pCBFrame->wLocalBP   = pFrame->wLocalBP;

    // save the current context stackalloc16() count and set the count to
    // 0 for the next context.  This will force ptd->vpCBStack to be calc'd
    // correctly in any future calls to stackalloc16() if the app callsback
    // into WOW
    cStackAlloc16      = ptd->cStackAlloc16;
    ptd->cStackAlloc16 = 0;

#ifdef DEBUG
    // Save

    vpStackT = ptd->vpStack;
#endif

    if (pParm16)
        RtlCopyMemory(&pCBFrame->Parm16, pParm16, sizeof(PARM16));

    //if (vpfnProc)     // cheaper to just do it
        STOREDWORD(pCBFrame->vpfnProc, vpfnProc);

    wAX = HIWORD(ptd->vpStack);         // Put SS in AX register for callback

    if ( iRetID == RET_WNDPROC ) {
        if ( pParm16->WndProc.hInst )
            wAX = pParm16->WndProc.hInst | 1;
    }

    pCBFrame->wAX = wAX;                // Use this AX for the callback

    //
    // Semi-slimy way we pass byte count of arguments into this function
    // for generic callbacks (WOWCallback16).
    //

    if (RET_WOWCALLBACK16 == iRetID) {
        pCBFrame->wGenUse1 = (WORD)(DWORD)*pvpReturn;
    }

#ifdef DEBUG
    if (iRetID == RET_WNDPROC) {
        LOGDEBUG(9,("%04X          Calling WIN16 WNDPROC(%08lx:%04x,%04x,%04x,%04x,%04x)\n",
            pFrame->wTDB,
            vpfnProc,
            pParm16->WndProc.hwnd,
            pParm16->WndProc.wMsg,
            pParm16->WndProc.wParam,
            HIWORD(pParm16->WndProc.lParam),
            LOWORD(pParm16->WndProc.lParam)
           )
        );

    } else if (iRetID == RET_HOOKPROC) {
        LOGDEBUG(9,("%04X         Calling WIN16 HOOKPROC(%08lx: %04x,%04x,%04x,%04x)\n",
            pFrame->wTDB,
            vpfnProc,
            pParm16->HookProc.nCode,
            pParm16->HookProc.wParam,
            HIWORD(pParm16->HookProc.lParam),
            LOWORD(pParm16->HookProc.lParam)
            )
        );


    } else {
        LOGDEBUG(9,("%04X         Calling WIN16 %s(%04x,%04x,%04x)\n",
            pFrame->wTDB,
            apszCallBacks[iRetID],
            pParm16->WndProc.wParam,
            HIWORD(pParm16->WndProc.lParam),
            LOWORD(pParm16->WndProc.lParam)
           )
        );
    }
#endif

    FREEVDMPTR(pFrame);
    FLUSHVDMPTR(ptd->vpCBStack, sizeof(CBVDMFRAME), pCBFrame);
    FREEVDMPTR(pCBFrame);

    // Set up to use the right 16-bit stack for this thread

    SETVDMSTACK(ptd->vpCBStack);


    //
    // do the callback!
    //

    // Time to get the IEU running task-time code again
    SaveIp = getIP();
    host_simulate();
    setIP(SaveIp);
    ptd->vpStack = VDMSTACK();


    // after return from callback ptd->vpStack will point to PCBVDMFRAME
    ptd->vpCBStack = ptd->vpStack;

    // reset the stackalloc16() count back to this context
    ptd->cStackAlloc16 = cStackAlloc16;

    GETFRAMEPTR(ptd->vpCBStack, (PVDMFRAME)pCBFrame);

    // Just making sure that this thread matches the current 16-bit task

    WOW32ASSERT((pCBFrame->wTDB == ptd->htask16) ||
        (ptd->htask16 == 0));

    if (pvpReturn) {
        LOW(*pvpReturn) = pCBFrame->wAX;
        HIW(*pvpReturn) = pCBFrame->wDX;
    } 

    switch(iRetID) {

        case RET_GLOBALLOCK: 
        case RET_LOCKRESOURCE:
            if(pParm16) {
                pParm16->WndProc.lParam = 
                            pCBFrame->wGenUse2 | (LONG)pCBFrame->wGenUse1 << 16;
            }
            break;

        case RET_GLOBALALLOCLOCK:
            if(pParm16) {
                    pParm16->WndProc.wParam = pCBFrame->wGenUse1;
                }
            break;

        case RET_FINDRESOURCE:
            if(pParm16) {
                pParm16->WndProc.lParam = (ULONG)pCBFrame->wGenUse1;
            }
            break;

    } // end switch

    LOGDEBUG(9,("%04X          WIN16 %s returning: %lx\n",
        pCBFrame->wTDB, apszCallBacks[iRetID], (pvpReturn) ? *pvpReturn : 0));

    // restore the stack to its original value.
    // ie. fake the 'pop' of callback stack by resetting the vpStack
    // to its original value. The ss:sp will actually be updated when
    // the 'api thunk' returns.

    // consistency check
    WOW32ASSERT(pCBFrame->vpStack == vpStackT);

    // restore the stack & callback frame ptrs to original values
    ptd->vpStack = pCBFrame->vpStack;
    ptd->vpCBStack = vpCBStack;

    // ssync 16-bit & 32-bit common dialog structs (see wcommdlg.c)
    if(fComDlgSync) {
        // Note: This call can invalidate flat ptrs to 16-bit mem
        Ssync_WOW_CommDlg_Structs(ptd->CommDlgTd, w16to32, 0);
    }

    FREEVDMPTR(pCBFrame);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wcall32.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WCALL32.C
 *  WOW32 16-bit resource support
 *
 *  History:
 *  Created 11-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wcall32.c);

//
// the 16-bit local handles are treated as 32-bit quantities.
// the low word contains the 16-bit handle and the high word
// contains the data segment for the block.
// when we do a callback to WOW16LocalAlloc it will
// return the DS in the high word (which is normally unused).
// on subsequent callbacks to realloc/lock/unlock/size/free
// the 16-bit code sets the DS to this value.
//


HANDLE APIENTRY W32LocalAlloc(UINT dwFlags, UINT dwBytes, HANDLE hInstance)
{

    //
    // If hInstance is not ours, then make Win32 call and return the
    // result to USER.
    //

    if (LOWORD (hInstance) == 0) {
        return (LocalAlloc(dwFlags, dwBytes));
    }


#if !defined(i386)
    if (dwBytes != 0)
        dwBytes += 4;
#endif

    return LocalAlloc16((WORD)dwFlags, (INT)dwBytes, hInstance);
}

// This api takes an extra pointer which is optional
// In case of an edit control reallocating the memory inside apps memory 
// space it is used to update the thunk data (see wparam.c)

HANDLE APIENTRY W32LocalReAlloc(
    HANDLE hMem,        // memory to be reallocated
    UINT dwBytes,       // size to reallocate to
    UINT dwFlags,       // reallocation flags
    HANDLE hInstance,   // Instance to identify ptr
    PVOID* ppv)         // Pointer to the pointer that needs an update
{
    //
    // If hInstance is not ours, then make Win32 call and return the
    // result to USER.
    //

    if (LOWORD (hInstance) == 0) {
        return (LocalReAlloc(hMem, dwBytes, dwFlags));
    }



#if !defined(i386)
    if (dwBytes != 0)
        dwBytes += 4;
#endif

    hMem = LocalReAlloc16(hMem, (INT)dwBytes, (WORD)dwFlags);

    // this code is used in User/Client (edit control) to realloc 
    // memory for text storage
    // update what ppv points to using wparam.c 

    if (NULL != ppv && NULL != *ppv) {
        *ppv = ParamMapUpdateNode((DWORD)*ppv, PARAM_32, NULL);
    }

    return hMem;
}

LPSTR  APIENTRY W32LocalLock(HANDLE hMem, HANDLE hInstance)
{
    VPVOID vp;

    //
    // If hInstance is not ours, then make Win32 call and return the
    // result to USER.
    //

    if (LOWORD (hInstance) == 0) {
        return (LocalLock(hMem));
    }

    if (vp = LocalLock16(hMem)) {
        return (LPSTR)VDMPTR(vp, 0);
    }
    else
        return NULL;
}




BOOL APIENTRY W32LocalUnlock(HANDLE hMem, HANDLE hInstance)
{

    //
    // If hInstance is not ours, then make Win32 call and return the
    // result to USER.
    //

    if (LOWORD (hInstance) == 0) {
        return (LocalUnlock(hMem));
    }


    return LocalUnlock16(hMem);
}


DWORD  APIENTRY W32LocalSize(HANDLE hMem, HANDLE hInstance)
{
    DWORD   dwSize;



    //
    // If hInstance is not ours, then make Win32 call and return the
    // result to USER.
    //

    if (LOWORD (hInstance) == 0) {
        return (LocalSize(hMem));
    }



    dwSize = LocalSize16(hMem);

#if !defined(i386)
    if (dwSize >= 4)
        dwSize -= 4;
#endif

    return dwSize;
}


HANDLE APIENTRY W32LocalFree(HANDLE hMem, HANDLE hInstance)
{

    //
    // If hInstance is not ours, then make Win32 call and return the
    // result to USER.
    //

    if (LOWORD (hInstance) == 0) {
        return (LocalFree(hMem));
    }

    return LocalFree16(hMem);
}

ULONG APIENTRY W32GetExpWinVer(HANDLE hInst)
{
    PARM16 Parm16;
    ULONG ul;

    // makes a direct call to krnl286:GetExpWinVer
    //

    if (LOWORD((DWORD)hInst) == (WORD) NULL) {

        //
        // Window is created by a 32 bit DLL, which is
        // linked to NTVDM process. So, we should not
        // passs it to the 16 bit kernel.
        //

        return (WOWRtlGetExpWinVer(hInst));
    }
    else {
        LPBYTE lpNewExeHdr;
        VPVOID vp = (DWORD)hInst & 0xffff0000;

        GETMISCPTR(vp, lpNewExeHdr);
        if (lpNewExeHdr) {
            ul = MAKELONG(*(PWORD16)&lpNewExeHdr[NE_LOWINVER_OFFSET],
                          (*(PWORD16)&lpNewExeHdr[NE_HIWINVER_OFFSET] &
                                                           FLAG_NE_PROPFONT));
        }
        else {
            Parm16.WndProc.wParam = LOWORD(hInst);
            CallBack16(RET_GETEXPWINVER, &Parm16, 0, &ul );
        }
        return ul;
    }


}


WORD    APIENTRY W32GlobalAlloc16(UINT uFlags, DWORD dwBytes)
{
    return HIWORD(GlobalAllocLock16((WORD)uFlags, dwBytes, NULL));
}


VOID    APIENTRY W32GlobalFree16(WORD selector)
{
    GlobalUnlockFree16(MAKELONG(0, selector));
    return;
}



int     APIENTRY W32EditNextWord (LPSZ lpszEditText, int ichCurrentWord,
                                  int cbEditText, int action, DWORD dwProc16)
{
    PARM16  Parm16;
    ULONG   lReturn = 0;
    PBYTE   lpstr16;
    VPVOID  vpstr16;
    VPVOID  vpfn;

    if (vpstr16 = malloc16 (cbEditText)) {
        GETMISCPTR (vpstr16, lpstr16);
        if (lpstr16) {
            lstrcpyn (lpstr16, lpszEditText, cbEditText);
            lpstr16[cbEditText-1] = '\0';

            // take out the marker bits and fix the RPL bits
            UnMarkWOWProc (dwProc16, vpfn);

            Parm16.WordBreakProc.action = GETINT16(action);
            Parm16.WordBreakProc.cbEditText = GETINT16(cbEditText);
            Parm16.WordBreakProc.ichCurrentWord = GETINT16(ichCurrentWord);
            Parm16.WordBreakProc.lpszEditText = vpstr16;

            CallBack16(RET_SETWORDBREAKPROC, &Parm16, vpfn, (PVPVOID)&lReturn);

            FREEMISCPTR (lpstr16);
        }

        free16(vpstr16);
    }

    return (INT32(LOWORD(lReturn)));
}


/***************************************************************************\
* WOWRtlGetExpWinVer
*
* Returns the expected windows version, in the same format as Win3.1's
* GetExpWinVer(). This takes it out of the module header.
*
* 09-9-92 ChandanC       Created.
\***************************************************************************/

DWORD WOWRtlGetExpWinVer(
    HANDLE hmod)
{
    PIMAGE_NT_HEADERS pnthdr;
    DWORD dwMajor = 3;
    DWORD dwMinor = 0xA;

    if (hmod != NULL) {
        try {
            pnthdr = (PIMAGE_NT_HEADERS)RtlImageNtHeader((PVOID)hmod);
            dwMajor = pnthdr->OptionalHeader.MajorSubsystemVersion;
            dwMinor = pnthdr->OptionalHeader.MinorSubsystemVersion;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            dwMajor = 3;        // just to be safe
            dwMinor = 0xA;
        }
    }

// !!! HACK until linker is fixed!!! 05-Aug-1992 Bug #3211
if (((dwMajor == 3) && (dwMinor == 1)) || (dwMajor == 1)) {
    dwMajor = 0x3;
    dwMinor = 0xA;
}
#ifdef FE_SB
    if (GetSystemDefaultLangID() == 0x411 &&
        CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_BCW45J_COMMDLG &&
        dwMajor >= 4) {
        // When application display win3.x style DialogBox,
        // System requires return value of version 3.10
        dwMajor = 0x3;
        dwMinor = 0xA;
    }
#endif // FE_SB


    /*
     * Return this is a win3.1 compatible format:
     *
     * 0x030A == win3.1
     * 0x0300 == win3.0
     * 0x0200 == win2.0, etc.
     *
     */

    return (DWORD)MAKELONG(MAKEWORD((BYTE)dwMinor, (BYTE)dwMajor), 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\waccel.h ===
//*****************************************************************************
//
// LoadAccelerator - compatibility support.
//
//
// 23-Jul-92  NanduriR   Created.
//*****************************************************************************


typedef struct _ACCELALIAS {
    struct _ACCELALIAS FAR *lpNext;
    struct _ACCELALIAS FAR *lpPrev;
    HAND16  hInst;
    HTASK16 hTask16;
    WORD    f16;            // WORD only for padding, could be BOOL,DWORD
    HAND16  h16;
    HAND32  h32;
} ACCELALIAS, FAR *LPACCELALIAS;


ULONG FASTCALL WU32LoadAccelerators(VPVOID vpData);
LPACCELALIAS SetupAccelAlias(HAND16 hInstance, HAND16 hAccel16, HAND32 hAccel32, BOOL f16);
BOOL  DestroyAccelAlias(WORD hTask16);
LPACCELALIAS FindAccelAlias(HANDLE hAccel, UINT fSize);
HAND32 GetAccelHandle32(HAND16 h16);
HAND16 GetAccelHandle16(HAND32 h32);
HACCEL CreateAccel32(VPVOID vpAccel16, DWORD cbAccel16);
HAND16 CreateAccel16(HACCEL hAccel32);


#define HANDLE_16BIT       0x01
#define HANDLE_32BIT       0x02
#define HACCEL32(h16)      GetAccelHandle32(h16)
#define GETHACCEL16(h32)   GetAccelHandle16(h32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\walias.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WALIAS.H
 *  WOW32 16-bit handle alias support
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
 *  Modified 12-May-1992 by Mike Tricker (miketri) to add MultiMedia support
--*/

typedef HANDLE HAND32;

#define _WALIAS_
#include "wspool.h"
#include "wowuserp.h"


//
//
// The WC structure is present in every CLS structure in the system,
// although USER32 defines it as an array of 2 DWORDs.  FindPWC(hwnd)
// returns a read-only pointer to the WC structure for a given window's
// class.  Note that only classes registered by Win16 applications will
// have meaningful values in the structure.  To change elements of the
// structure, use SETWC (== SetClassLong) with the appropriate GCL_WOW*
// offset defined below.
//

#define SETWC(hwnd, nIndex, l)  SetClassLong(hwnd, nIndex, l)

#define SETWL(hwnd, nIndex, l)          SetWindowLong(hwnd, nIndex, l)

typedef struct _HDW {
    struct _HDW *Next;      // pointer to next hDDE alias
    HANDLE  hdwp32;         // handle of WOW allocated 32 bit object
} HDW, *PHDW;


/* Handle mapping macros
 */

//
//  The 32-bit hInstance for a 16-bit task will be hMod / hInst.
//  The hModule/hInstnace for a 32-bit entity will be xxxx / 0000.
//
//    FritzS  8/13/92
//

#define HINSTRES32(h16)            ((h16)?HMODINST32(h16):(HANDLE)NULL)

//
// The THREADID32 and HTASK32 macros are nearly equivalent, but the
// WOWHandle mapping uses the one which will detect aliases (see WOLE2.C).
// Most other functions don't need alias detection and it is too late
// to test with the more general.
//

#ifdef DEBUG

//
// Check for task aliases that will cause us to fault if we dereference the NULL
// pointer returned by SEGPTR(htask16,0).
//

#define THREADID32(htask16)                                                   \
        ((htask16)                                                            \
             ? (ISTASKALIAS(htask16)                                          \
                    ? (WOW32ASSERTMSGF(FALSE,                                 \
                           ("WOW32 ERROR %s line %d Task alias "              \
                            "to THREADID32, use HTASK32 instead.\n",          \
                            szModule, __LINE__)), 0)                          \
                    : ((PTDB)SEGPTR((htask16),0))->TDB_ThreadID)              \
             : 0)
#else
#define THREADID32(htask16)  ((htask16)                                       \
                                  ? ((PTDB)SEGPTR((htask16),0))->TDB_ThreadID \
                                  : 0)
#endif

#define HTASK32(htask16)           (Htask16toThreadID32(htask16))
#define GETHTASK16(htask32)        (ThreadID32toHtask16((DWORD)htask32))

#define ISINST16(h32)              (((INT)(h32) & 0x0000fffe) != 0)
#define HMODINST32(h16)            ((HANDLE) MAKELONG(h16, GetExePtr16(h16)))
#define GETHINST16(h32)            ((HAND16)(INT)(h32))
#define GETHMOD16(h32)             ((HAND16)(INT)(HIWORD(h32)))

#define ISMEM16(h32)               (((INT)(h32) & 0xFFFF0000) == 0)
#define HMEM32(h16)                ((HANDLE)(INT)(h16))
#define GETHMEM16(h32)             ((HMEM16)(INT)(h32))

#define ISRES16(h32)               ((INT)(h32)&1)
#define HRES32(p)                  ((p)?(HANDLE)((INT)(p)|1):(HANDLE)NULL)
#define GETHRES16(h32)             ((PRES)((INT)(h32)&~1))

#define USER32(h16)                ((HAND32)(INT)(SHORT)(h16))
#define USER16(h32)                ((HAND16)h32)

#define HWND32(h16)                USER32(h16)
#define FULLHWND32(h16)            (pfnOut.pfnGetFullUserHandle)(h16)
#define GETHWND16(h32)             USER16(h32)
#define GETHWNDIA16(h32)           GETHWND16(h32)
#define HWNDIA32(h16)              HWND32(h16)

#define HMENU32(h16)               USER32(h16)
#define GETHMENU16(h32)            USER16(h32)


#define SERVERHANDLE(h)            (HIWORD(h))

#define GDI32(h16)                 (HANDLE) hConvert16to32(h16)
#define GDI16(h32)                 ((HAND16) hConvert32to16((DWORD)h32))

#define HGDI16(hobj32)             GDI16((HAND32)(hobj32))

#define HDC32(hdc16)               GDI32((HAND16)(hdc16))
#define GETHDC16(hdc32)            GDI16((HAND32)(hdc32))

#define HFONT32(hobj16)            GDI32((HAND16)(hobj16))
#define GETHFONT16(hobj32)         GDI16((HAND32)(hobj32))

#define HMETA32(hobj16)            ((HANDLE)HMFFromWinMetaFile((HAND16)(hobj16),FALSE))
#define GETHMETA16(hobj32)         ((HAND16)WinMetaFileFromHMF((HMETAFILE)(hobj32),FALSE))

#define HRGN32(hobj16)             GDI32((HAND16)(hobj16))
#define GETHRGN16(hobj32)          GDI16((HAND32)(hobj32))

#define HBITMAP32(hobj16)          GDI32((HAND16)(hobj16))
#define GETHBITMAP16(hobj32)       GDI16((HAND32)(hobj32))

#define HBRUSH32(hobj16)           GDI32((HAND16)(hobj16))
#define GETHBRUSH16(hobj32)        GDI16((HAND32)(hobj32))

#define HPALETTE32(hobj16)         GDI32((HAND16)(hobj16))
#define GETHPALETTE16(hobj32)      GDI16((HAND32)(hobj32))

#define HPEN32(hobj16)             GDI32((HAND16)(hobj16))
#define GETHPEN16(hobj32)          GDI16((HAND32)(hobj32))

#define HOBJ32(hobj16)             GDI32((HAND16)(hobj16))
#define GETHOBJ16(hobj32)          GDI16((HAND32)(hobj32))

#define HDROP32(hobj16)            (HDROP)DropFilesHandler((HAND16)(hobj16), 0, HDROP_H16 | HDROP_ALLOCALIAS)
#define GETHDROP16(hobj32)         (HAND16)DropFilesHandler(0, (HAND32)(hobj32), HDROP_H32 | HDROP_ALLOCALIAS)
#define FREEHDROP16(hobj16)        (HDROP)DropFilesHandler((HAND16)(hobj16), 0,  HDROP_H16 | HDROP_FREEALIAS)

#define HMODULE32(h16)             ((HANDLE)(h16))     // bogus
#define GETHMODULE16(h32)          ((HAND16)(h32))     // bogus

#define HLOCAL32(h16)              ((HANDLE)(h16))     // bogus
#define GETHLOCAL16(h32)           ((HAND16)(h32))     // bogus

#define HANDLE32(h16)              ((HANDLE)(h16))     // bogus (used in wucomm.c)
#define GETHANDLE16(h32)           ((HAND16)(h32))     // bogus (used in wucomm.c)

#define BOGUSHANDLE32(h16)         ((DWORD)(h16))      // bogus

#define HDWP32(hdwp16)             Prn32((HAND16)(hdwp16))
#define GETHDWP16(hdwp32)          GetPrn16((HAND32)(hdwp32))
#define FREEHDWP16(h16)            FreePrn((HAND16)(h16))

#define COLOR32(clr)               (COLORREF)( ( ((DWORD)(clr) >= 0x03000000) &&  \
                                                 (HIWORD(clr) != 0x10ff) )        \
                                               ? ((clr) & 0xffffff) : (clr) )

/*
 * MultiMedia handle mappings - MikeTri 12-May-1992
 *
 * change WOWCLASS_UNKNOWN to WOWCLASS_WIN16 MikeTri 210292
 */

#define HDRVR32(hdrvr16)           GetMMedia32((HAND16)(hdrvr16))
#define GETHDRVR16(hdrvr32)        GetMMedia16((HAND32)(hdrvr32), WOWCLASS_WIN16)
#define FREEHDRVR16(hdrvr16)       FreeMMedia16((HAND16)(hdrvr16))

#define HMMIO32(hmmio16)           GetMMedia32((HAND16)(hmmio16))
#define GETHMMIO16(hmmio32)        GetMMedia16((HAND32)(hmmio32), WOWCLASS_WIN16)
#define FREEHMMIO16(hmmio16)       FreeMMedia16((HAND16)(hmmio16))

#define HMIDIIN32(hmidiin16)       GetMMedia32((HAND16)(hmidiin16))
#define GETHMIDIIN16(hmidiin32)    GetMMedia16((HAND32)(hmidiin32), WOWCLASS_WIN16)
#define FREEHMIDIIN16(hmidiin16)   FreeMMedia16((HAND16)(hmidiin16))

#define HMIDIOUT32(hmidiout16)     GetMMedia32((HAND16)(hmidiout16))
#define GETHMIDIOUT16(hmidiout32)  GetMMedia16((HAND32)(hmidiout32), WOWCLASS_WIN16)
#define FREEHMIDIOUT16(hmidiout16) FreeMMedia16((HAND16)(hmidiout16))

#define HWAVEIN32(hwavein16)       GetMMedia32((HAND16)(hwavein16))
#define GETHWAVEIN16(hwavein32)    GetMMedia16((HAND32)(hwavein32), WOWCLASS_WIN16)
#define FREEHWAVEIN16(hwavein16)   FreeMMedia16((HAND16)(hwavein16))

#define HWAVEOUT32(hwaveout16)     GetMMedia32((HAND16)(hwaveout16))
#define GETHWAVEOUT16(hwaveout32)  GetMMedia16((HAND32)(hwaveout32), WOWCLASS_WIN16)
#define FREEHWAVEOUT16(hwaveout16) FreeMMedia16((HAND16)(hwaveout16))

/* Function prototypes
 */

INT     GetStdClassNumber(PSZ pszClass);
WNDPROC GetStdClassWndProc(DWORD iClass);
DWORD   GetStdClassThunkProc(INT iClass);

PWC     FindClass16 (LPCSTR pszClass, HINST16 hInst16);
#define FindPWC(h32) (PWC) GetClassLong((h32), GCL_WOWWORDS)
#define FindPWW(h32) (PWW) GetWindowLong((h32), GWL_WOWWORDS)

HAND16  GetMMedia16 (HANDLE h32, INT iClass);  //MultiMedia additions - MikeTri 12-May-1992
HANDLE  GetMMedia32 (HAND16 h16);
VOID    FreeMMedia16 (HAND16 h16);

HAND16  GetWinsock16 (INT h32, INT iClass);  //Winsock additions - DavidTr 4-Oct-1992
DWORD   GetWinsock32 (HAND16 h16);
VOID    FreeWinsock16 (HAND16 h16);

BOOL    MessageNeedsThunking (UINT uMsg);

DWORD   Htask16toThreadID32(HTASK16 htask16);

/* Data structure used in thunking LB_GETTEXT special case
 */

typedef struct _THUNKTEXTDWORD  {
    BOOL               fDWORD;     // dword used or text
    DWORD              dwDataItem; // dword 
} THUNKTEXTDWORD, *PTHUNKTEXTDWORD;

typedef union _MSGTHUNKBUFFER {
    MSG                msg;
    DRAWITEMSTRUCT     ditem;
    MEASUREITEMSTRUCT  mitem;
    DELETEITEMSTRUCT   delitem;
    COMPAREITEMSTRUCT  cmpitem;
    RECT               rect;
    CREATESTRUCT       cstruct;
    WINDOWPOS          winpos;
    CLIENTCREATESTRUCT clcstruct;
    MDINEXTMENU        mnm;
    MDICREATESTRUCT    mdis;
    DROPSTRUCT         dps;
    POINT              pt[5];                               // WM_GETMINMAXINFO
    UINT               uinteger[2];                         // SBM_GETRANGE
    BYTE               cmdichild[sizeof(CREATESTRUCT) +
                                  sizeof(MDICREATESTRUCT)]; // FinishThunking...
    BYTE               cmdiclient[sizeof(CREATESTRUCT) +
                               sizeof(CLIENTCREATESTRUCT)]; // FinishThunking...
    BYTE               calcsz[sizeof(NCCALCSIZE_PARAMS) +
                                        sizeof(WINDOWPOS)];
    THUNKTEXTDWORD     thkdword;                            // LB_GETTEXT w/no HASSTRINGS
} MSGTHUNKBUFFER, *LPMSGTHUNKBUFFER;

typedef struct _MSGPARAMEX *LPMSGPARAMEX;
typedef BOOL   (FASTCALL *LPFNTHUNKMSG16)(LPMSGPARAMEX lpmpex);
typedef VOID   (FASTCALL *LPFNUNTHUNKMSG16)(LPMSGPARAMEX lpmpex);

typedef struct _MSGPARAMEX {
    PARM16 Parm16;
    HWND hwnd;
    UINT uMsg;
    UINT uParam;
    LONG lParam;
    LONG   lReturn;
    LPFNUNTHUNKMSG16 lpfnUnThunk16;
    PWW            pww;
    INT            iMsgThunkClass;          // thunking aid
    INT            iClass;
    MSGTHUNKBUFFER MsgBuffer[1];
} MSGPARAMEX;

#define MSG16NEEDSTHUNKING(lpmpex) ((lpmpex)->iClass != WOWCLASS_NOTHUNK)

// Used for compatibility sake. If app gets The hInstance of a 32bit window
// (the loword of 32bit hinstance is zero) then return a bogus gdt.
//
// Subsequently, if the app does a getmodulefilename on it we will return a
// a fake 32bit modulename.
//
// This is required for a couple of HDC apps and 16bit recorder.
//
//                                                       - Nanduri
//

#define BOGUSGDT 0xfff0
#define VALIDHMOD(h32) (((h32) && !(WORD)(h32)) ? BOGUSGDT : (WORD)(h32))



// For DEVMODE struct handling
// We add a little extra to devmode sizes that we return to 16-bit apps
// including a signature "DM31" at the end of the driver extra stuff
// See notes in wstruc.c

typedef struct _WOWDM31 {
    DWORD dwWOWSig;
    WORD  dmSpecVersion;
    WORD  dmSize;
    WORD  dmDriverExtra;
    WORD  reserved;        // pad to even DWORD (required for ptr arithmetic)
} WOWDM31;
typedef WOWDM31 UNALIGNED *PWOWDM31;

// WOW DEVMODE magic signature
#define WOW_DEVMODE31SIG 0x444d3331   // "DM31"

// Win3.1 DEVMODE spec
#define WOW_DEVMODE31SPEC  0x30A

// Constant we add to Win3.1 DevMode->DriverExtra to account for the NT Devmode
// fields not in the Win3.1 devmode & the WOW thunk info we add to the end
#define WOW_DEVMODEEXTRA  ((sizeof(DEVMODE)-sizeof(DEVMODE31))+sizeof(WOWDM31))



extern WORD gUser16hInstance;
ULONG GetGCL_HMODULE(HWND hwnd);

#define ISFUNCID(dwcallid)  (!((DWORD)(dwcallid) & 0xffff0000))
#define POSTMSG(dwLocal)    (ISFUNCID(dwLocal =  \
                                      FRAMEPTR(CURRENTPTD()->vpStack)->wCallID) ?         \
                                        (aw32WOW[dwLocal].lpfnW32 == WU32PostMessage) :   \
                                        (dwLocal == (DWORD) WU32PostMessage))

ULONG WOW32FaxHandler(UINT iFun, LPSTR lpIn);


#define BAD_GDI32_HANDLE 0xFFFF  // bad GDI32 handle

#define END_OF_LIST      0       // end of free list

// State flags
#define SLOT_FREE        0x0000  // table index is free
#define IN_USE           0x0001  // table index is in use
#define H16_DELETED      0x0002  // marks index as candidate for being reclaimed
#define GDI_STOCK_OBJECT 0x0003  // marks stock objects (non-deletable)

// defines entries in the GDI16 handle mapping table
typedef struct _tagGDIH16MAP {
    HANDLE  h32;       // store the full h32
    WORD    State;     // Either SLOT_FREE, IN_USE or H16_DELETED
    WORD    NextFree;  // points to next free index or END_OF_LIST
} GDIH16MAP, *PGDIH16MAP;

// defines entries in the GDI32 handle mapping table
typedef struct _tagGDIH32MAP {
    WORD  h16index;
} GDIH32MAP, *PGDIH32MAP;

void   DeleteGdiHandleMappingTables(void);
BOOL   InitializeGdiHandleMappingTable(void);
void   RebuildGdiHandleMappingTables(void);
void   DeleteWOWGdiHandle(HANDLE h32, HAND16 h16);
HAND16 GetWOWGdiHandleInfo(HANDLE h32);
HAND16 IsGDIh32Mapped(HANDLE h32);


INT GetIClass(PWW pww, HWND hwnd);

/*
//
// if it's a standard class (fast method) ? 
//    return it :
// else if the window is initialized ?
//    we know it's a private app class : else get the class the hard way
//
// Note: GetiClassTheHardWay() may stiil return a standard class.  See walias.c
//

#define GETICLASS(pww, hwnd) (                                                 \
(((((PWW)pww)->fnid & 0xfff) >= FNID_START) &&                                 \
                                   ((((PWW)pww)->fnid & 0xfff) <= FNID_END)) ? \
    (pfnOut.aiWowClass[(((PWW)pww)->fnid & 0xfff) - FNID_START]) :             \
((((PWW)pww)->state2 & WINDOW_IS_INITIALIZED) ?                                \
    WOWCLASS_WIN16 : GetiClassTheHardWay(hwnd)) )
*/
#define GETICLASS(pww, hwnd) GetIClass(pww, hwnd)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\walias.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WALIAS.C
 *  WOW32 16-bit handle alias support
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
 *  Modified 12-May-1992 by Mike Tricker (miketri) to add MultiMedia support
--*/

#include "precomp.h"
#pragma hdrstop

MODNAME(walias.c);

extern HANDLE hmodWOW32;

extern CRITICAL_SECTION gcsWOW;
extern PTD gptdTaskHead;

//BUGBUG - this must be removed once MM_MCISYSTEM_STRING is defined in MMSYSTEM.H.
#ifndef MM_MCISYSTEM_STRING
    #define MM_MCISYSTEM_STRING 0x3CA
#endif

#ifdef  DEBUG
extern  BOOL fSkipLog;          // TRUE to temporarily skip certain logging
#endif

typedef struct _stdclass {
    LPSTR   lpszClassName;
    ATOM    aClassAtom;
    WNDPROC lpfnWndProc;
    INT     iOrdinal;
    DWORD   vpfnWndProc;
} STDCLASS;

// Some cool defines stolen from USERSRV.H
#define MENUCLASS       MAKEINTATOM(0x8000)
#define DESKTOPCLASS    MAKEINTATOM(0x8001)
#define DIALOGCLASS     MAKEINTATOM(0x8002)
#define SWITCHWNDCLASS  MAKEINTATOM(0x8003)
#define ICONTITLECLASS  MAKEINTATOM(0x8004)

// See WARNING below!
STDCLASS stdClasses[] = {
    NULL,           0,                      NULL,   0,                      0,  // WOWCLASS_UNKNOWN
    NULL,           0,                      NULL,   0,                      0,  // WOWCLASS_WIN16
    "BUTTON",       0,                      NULL,   FUN_BUTTONWNDPROC,      0,  // WOWCLASS_BUTTON,
    "COMBOBOX",     0,                      NULL,   FUN_COMBOBOXCTLWNDPROC, 0,  // WOWCLASS_COMBOBOX,
    "EDIT",         0,                      NULL,   FUN_EDITWNDPROC,        0,  // WOWCLASS_EDIT,
    "LISTBOX",      0,                      NULL,   FUN_LBOXCTLWNDPROC,     0,  // WOWCLASS_LISTBOX,
    "MDICLIENT",    0,                      NULL,   FUN_MDICLIENTWNDPROC,   0,  // WOWCLASS_MDICLIENT,
    "SCROLLBAR",    0,                      NULL,   FUN_SBWNDPROC,          0,  // WOWCLASS_SCROLLBAR,
    "STATIC",       0,                      NULL,   FUN_STATICWNDPROC,      0,  // WOWCLASS_STATIC,
    "#32769",       (WORD)DESKTOPCLASS,     NULL,   FUN_DESKTOPWNDPROC,     0,  // WOWCLASS_DESKTOP,
    "#32770",       (WORD)DIALOGCLASS,      NULL,   FUN_DEFDLGPROCTHUNK,    0,  // WOWCLASS_DIALOG,
    "#32772",       (WORD)ICONTITLECLASS,   NULL,   FUN_TITLEWNDPROC,       0,  // WOWCLASS_ICONTITLE,
    "#32768",       (WORD)MENUCLASS,        NULL,   FUN_MENUWNDPROC,        0,  // WOWCLASS_MENU,
    "#32771",       (WORD)SWITCHWNDCLASS,   NULL,   0,                      0,  // WOWCLASS_SWITCHWND,
    "COMBOLBOX",    0,                      NULL,   FUN_LBOXCTLWNDPROC,     0,  // WOWCLASS_COMBOLBOX
};
//
// WARNING! The above sequence and values must be maintained otherwise the
// table in WMSG16.C for message thunking must be changed.  Same goes for
// the #define's in WALIAS.H
//
// The above COMBOLBOX case is special because it is class that is
// almost identical to a listbox.  Therefore we lie about it.

INT GetStdClassNumber(
    PSZ pszClass
) {
    INT     i;

    if ( HIWORD(pszClass) ) {

        // They passed us a string

        for ( i = WOWCLASS_BUTTON; i < NUMEL(stdClasses); i++ ) {
            if ( WOW32_stricmp(pszClass, stdClasses[i].lpszClassName) == 0 ) {
                return( i );
            }
        }
    } else {

        // They passed us an atom

        for ( i = WOWCLASS_BUTTON; i < NUMEL(stdClasses); i++ ) {
            if ( stdClasses[i].aClassAtom == 0 ) {
                // RegisterWindowMessage is an undocumented way of determining
                // an atom value in the context of the server-side heap.
                stdClasses[i].aClassAtom = (ATOM)RegisterWindowMessage(stdClasses[i].lpszClassName);
            }
            if ( (ATOM)LOWORD(pszClass) == stdClasses[i].aClassAtom ) {
                return( i );
            }
        }
    }
    return( WOWCLASS_WIN16 );  // private 16-bit class created by the app
}

// Returns a 32 window proc given a class index

WNDPROC GetStdClassWndProc(
    DWORD   iClass
) {
    WNDPROC lpfn32;

    if ( iClass < WOWCLASS_WIN16 || iClass > WOWCLASS_MAX ) {
        WOW32ASSERT(FALSE);
        return( NULL );
    }

    lpfn32 = stdClasses[iClass].lpfnWndProc;

    if ( lpfn32 == NULL ) {
        WNDCLASS    wc;
        BOOL        f;

        f = GetClassInfo( NULL, stdClasses[iClass].lpszClassName, &wc );

        if ( f ) {
            VPVOID  vp;
       DWORD UNALIGNED * lpdw;

            lpfn32 = wc.lpfnWndProc;
            stdClasses[iClass].lpfnWndProc = lpfn32;

            vp = GetStdClassThunkProc(iClass);
            vp = (VPVOID)((DWORD)vp - sizeof(DWORD)*3);

            GETVDMPTR( vp, sizeof(DWORD)*3, lpdw );

            WOW32ASSERT(*lpdw == SUBCLASS_MAGIC);   // Are we editing the right stuff?

            if (!lpdw)
                *(lpdw+2) = (DWORD)lpfn32;

            FLUSHVDMCODEPTR( vp, sizeof(DWORD)*3, lpdw );
            FREEVDMPTR( lpdw );

        }
    }
    return( lpfn32 );
}

// Returns a 16 window proc thunk given a class index

DWORD GetStdClassThunkProc(
    INT     iClass
) {
    DWORD   dwResult;
    SHORT   iOrdinal;
    PARM16  Parm16;

    if ( iClass < WOWCLASS_WIN16 || iClass > WOWCLASS_MAX ) {
        WOW32ASSERT(FALSE);
        return( 0 );
    }

    iOrdinal = (SHORT)stdClasses[iClass].iOrdinal;

    if ( iOrdinal == 0 ) {
        return( (DWORD)NULL );
    }

    // If we've already gotten this proc, then don't bother calling into 16-bit
    dwResult = stdClasses[iClass].vpfnWndProc;

    if ( dwResult == (DWORD)NULL ) {

        // Callback into the 16-bit world asking for the 16:16 address

        Parm16.SubClassProc.iOrdinal = iOrdinal;

        if (!CallBack16(RET_SUBCLASSPROC, &Parm16, (VPPROC)NULL,
                          (PVPVOID)&dwResult)) {
            WOW32ASSERT(FALSE);
            return( 0 );
        }
        // Save it since it is a constant.
        stdClasses[iClass].vpfnWndProc = dwResult;
    }
    return( dwResult );
}

/*
 * PWC GetClassWOWWords(hInst, pszClass)
 *   is a ***private*** API for WOW only. It returns a pointer to the
 *   WOW Class structure in the server's window class structure.
 *   This is similar to GetClassLong(hwnd32, GCL_WOWWORDS) (see FindPWC),
 *   but in this case we don't have a hwnd32, we have the class name
 *   and instance handle.
 */

PWC FindClass16(LPCSTR pszClass, HAND16 hInst)
{
    register PWC pwc;

    pwc = (PWC)(pfnOut.pfnGetClassWOWWords)(HMODINST32(hInst), pszClass);
    WOW32WARNMSGF(
        pwc,
        ("WOW32 warning: GetClassWOWWords('%s', %04x) returned NULL\n", pszClass, hInst)
        );

    return (pwc);
}



#ifdef DEBUG

INT nAliases;
INT iLargestListSlot;

PSZ apszHandleClasses[] = {
    "Unknown",      // WOWCLASS_UNKNOWN
    "Window",       // WOWCLASS_WIN16
    "Button",       // WOWCLASS_BUTTON
    "ComboBox",     // WOWCLASS_COMBOBOX
    "Edit",         // WOWCLASS_EDIT
    "ListBox",      // WOWCLASS_LISTBOX
    "MDIClient",    // WOWCLASS_MDICLIENT
    "Scrollbar",    // WOWCLASS_SCROLLBAR
    "Static",       // WOWCLASS_STATIC
    "Desktop",      // WOWCLASS_DESKTOP
    "Dialog",       // WOWCLASS_DIALOG
    "Menu",         // WOWCLASS_MENU
    "IconTitle",    // WOWCLASS_ICONTITLE
    "Accel",        // WOWCLASS_ACCEL
    "Cursor",       // WOWCLASS_CURSOR
    "Icon",         // WOWCLASS_ICON
    "DC",           // WOWCLASS_DC
    "Font",         // WOWCLASS_FONT
    "MetaFile",     // WOWCLASS_METAFILE
    "Region",       // WOWCLASS_RGN
    "Bitmap",       // WOWCLASS_BITMAP
    "Brush",        // WOWCLASS_BRUSH
    "Palette",      // WOWCLASS_PALETTE
    "Pen",          // WOWCLASS_PEN
    "Object"        // WOWCLASS_OBJECT
};


BOOL MessageNeedsThunking(UINT uMsg)
{
    switch (uMsg) {
        case WM_CREATE:
        case WM_ACTIVATE:
        case WM_SETFOCUS:
        case WM_KILLFOCUS:
        case WM_SETTEXT:
        case WM_GETTEXT:
        case WM_ERASEBKGND:
        case WM_WININICHANGE:
        case WM_DEVMODECHANGE:
        case WM_ACTIVATEAPP:
        case WM_SETCURSOR:
        case WM_MOUSEACTIVATE:
        case WM_GETMINMAXINFO:
        case WM_ICONERASEBKGND:
        case WM_NEXTDLGCTL:
        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        case WM_DELETEITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_SETFONT:
        case WM_GETFONT:
        case WM_QUERYDRAGICON:
        case WM_COMPAREITEM:
        case WM_OTHERWINDOWCREATED:
        case WM_OTHERWINDOWDESTROYED:
        case WM_COMMNOTIFY:
        case WM_WINDOWPOSCHANGING:
        case WM_WINDOWPOSCHANGED:
        case WM_NCCREATE:
        case WM_NCCALCSIZE:
        case WM_COMMAND:
        case WM_HSCROLL:
        case WM_VSCROLL:
        case WM_INITMENU:
        case WM_INITMENUPOPUP:
        case WM_MENUSELECT:
        case WM_MENUCHAR:
        case WM_ENTERIDLE:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        case WM_PARENTNOTIFY:
        case WM_MDICREATE:
        case WM_MDIDESTROY:
        case WM_MDIACTIVATE:
        case WM_MDIGETACTIVE:
        case WM_MDISETMENU:
        case WM_RENDERFORMAT:
        case WM_PAINTCLIPBOARD:
        case WM_VSCROLLCLIPBOARD:
        case WM_SIZECLIPBOARD:
        case WM_ASKCBFORMATNAME:
        case WM_CHANGECBCHAIN:
        case WM_HSCROLLCLIPBOARD:
        case WM_PALETTEISCHANGING:
        case WM_PALETTECHANGED:
        case MM_JOY1MOVE:
        case MM_JOY2MOVE:
        case MM_JOY1ZMOVE:
        case MM_JOY2ZMOVE:
        case MM_JOY1BUTTONDOWN:
        case MM_JOY2BUTTONDOWN:
        case MM_JOY1BUTTONUP:
        case MM_JOY2BUTTONUP:
        case MM_MCINOTIFY:
        case MM_MCISYSTEM_STRING:
        case MM_WOM_OPEN:
        case MM_WOM_CLOSE:
        case MM_WOM_DONE:
        case MM_WIM_OPEN:
        case MM_WIM_CLOSE:
        case MM_WIM_DATA:
        case MM_MIM_OPEN:
        case MM_MIM_CLOSE:
        case MM_MIM_DATA:
        case MM_MIM_LONGDATA:
        case MM_MIM_ERROR:
        case MM_MIM_LONGERROR:
        case MM_MOM_OPEN:
        case MM_MOM_CLOSE:
        case MM_MOM_DONE:
            LOGDEBUG(LOG_IMPORTANT,
                ("MessageNeedsThunking: WM_msg %04x is not thunked\n", uMsg));
            return TRUE;

        default:
            return FALSE;

    }
}

#endif


PTD ThreadProcID32toPTD(DWORD dwThreadID, DWORD dwProcessID)
{
    PTD ptd, ptdThis;
    PWOAINST pWOA;

    //
    // If we have active child instances of WinOldAp,
    // try to map the process ID of a child Win32 app
    // to the corresponding WinOldAp PTD.
    //

    ptdThis = CURRENTPTD();

    EnterCriticalSection(&ptdThis->csTD);

    pWOA = ptdThis->pWOAList;

    while (pWOA && pWOA->dwChildProcessID != dwProcessID) {
        pWOA = pWOA->pNext;
    }

    if (pWOA) {

        ptd = pWOA->ptdWOA;

        LeaveCriticalSection(&ptdThis->csTD);

    } else {

        LeaveCriticalSection(&ptdThis->csTD);

        //
        // We didn't find a WinOldAp PTD to return, see
        // if the thread ID matches one of our app threads.
        //

        EnterCriticalSection(&gcsWOW);

        ptd = gptdTaskHead;

        while (ptd && ptd->dwThreadID != dwThreadID) {
            ptd = ptd->ptdNext;
        }

        LeaveCriticalSection(&gcsWOW);
    }

    return ptd;

}

PTD Htask16toPTD(
    HTASK16 htask16
) {
    PTD  ptd;

    EnterCriticalSection(&gcsWOW);

    ptd = gptdTaskHead;

    while(ptd) {

        if ( ptd->htask16 == htask16 ) {
            break;
        }
        ptd = ptd->ptdNext;
    }

    LeaveCriticalSection(&gcsWOW);

    return ptd;
}


HTASK16 ThreadID32toHtask16(
    DWORD   ThreadID32
) {
    PTD ptd;
    HTASK16 htask16;


    if ( ThreadID32 == 0 ) {
        WOW32ASSERTMSG(ThreadID32, "WOW::ThreadID32tohTask16: Thread ID is 0\n");
        htask16 = 0;
    } else {

        ptd = ThreadProcID32toPTD( ThreadID32, (DWORD)-1 );
        if ( ptd ) {
            // Good, its one of our wow threads.
            htask16 = ptd->htask16;
        } else {
            // Nope, its is some other 32-bit thread
            htask16 = FindHtaskAlias( ThreadID32 );
            if ( htask16 == 0 ) {
                //
                // See the comment in WOLE2.C for a nice description
                //
                htask16 = AddHtaskAlias( ThreadID32 );
            }
        }
    }

    return htask16;
}

DWORD Htask16toThreadID32(
    HTASK16 htask16
) {
    if ( htask16 == 0 ) {
        return( 0 );
    }

    if ( ISTASKALIAS(htask16) ) {
        return( GetHtaskAlias(htask16,NULL) );
    } else {
        return( THREADID32(htask16) );
    }
}

//***************************************************************************
// GetGCL_HMODULE - returns the valid hmodule if the window corresponds to
//                  a 16bit class else returns the hmodule of 16bit user.exe
//                  if the window is of a standard class.
//
// These cases are required for compatibility sake.
//         apps like VirtualMonitor, hDC etc depend on such behaviour.
//                                                              - Nanduri
//***************************************************************************
WORD gUser16hInstance = 0;

ULONG GetGCL_HMODULE(HWND hwnd)
{
    ULONG    ul;
    PTD      ptd;
    PWOAINST pWOA;
    DWORD    dwProcessID;

    ul = (ULONG)GetClassLong(hwnd, GCL_HMODULE);

    //
    // hMod32 = 0xZZZZ0000
    //

    if (ul != 0 && LOWORD(ul) == 0) {

        //
        // If we have active WinOldAp children, see if this window
        // belongs to a Win32 process spawned by one of the
        // active winoldap's.  If it is, return the hmodule
        // of the corresponding winoldap.  Otherwise we
        // return user.exe's hinstance (why not hmodule?)
        //

        dwProcessID = (DWORD)-1;
        GetWindowThreadProcessId(hwnd, &dwProcessID);

        ptd = CURRENTPTD();

        EnterCriticalSection(&ptd->csTD);

        pWOA = ptd->pWOAList;
        while (pWOA && pWOA->dwChildProcessID != dwProcessID) {
            pWOA = pWOA->pNext;
        }

        if (pWOA) {
            ul = pWOA->ptdWOA->hMod16;
            LOGDEBUG(LOG_ALWAYS, ("WOW32 GetClassLong(0x%x, GWW_HMODULE) returning 0x%04x\n",
                                  hwnd, ul));
        } else {
            ul = (ULONG) gUser16hInstance;
            WOW32ASSERT(ul);
        }

        LeaveCriticalSection(&ptd->csTD);
    }
    else {
        ul = (ULONG)GETHMOD16(ul);      // 32-bit hmod is HMODINST32
    }

    return ul;
}

//
// EXPORTED handle mapping functions.  WOW32 code should use the
// macros defined in walias.h -- these functions are for use by
// third-party 32-bit code running in WOW, for example called
// using generic thunks from WOW-specific 16-bit code.
//

HANDLE WOWHandle32 (WORD h16, WOW_HANDLE_TYPE htype)
{
    switch (htype) {
        case WOW_TYPE_HWND:
            return HWND32(h16);
        case WOW_TYPE_HMENU:
            return HMENU32(h16);
        case WOW_TYPE_HDWP:
            return HDWP32(h16);
        case WOW_TYPE_HDROP:
            return HDROP32(h16);
        case WOW_TYPE_HDC:
            return HDC32(h16);
        case WOW_TYPE_HFONT:
            return HFONT32(h16);
        case WOW_TYPE_HMETAFILE:
            return HMETA32(h16);
        case WOW_TYPE_HRGN:
            return HRGN32(h16);
        case WOW_TYPE_HBITMAP:
            return HBITMAP32(h16);
        case WOW_TYPE_HBRUSH:
            return HBRUSH32(h16);
        case WOW_TYPE_HPALETTE:
            return HPALETTE32(h16);
        case WOW_TYPE_HPEN:
            return HPEN32(h16);
        case WOW_TYPE_HACCEL:
            return HACCEL32(h16);
        case WOW_TYPE_HTASK:
            return (HANDLE)HTASK32(h16);
        case WOW_TYPE_FULLHWND:
            return (HANDLE)FULLHWND32(h16);
        default:
            return(INVALID_HANDLE_VALUE);
    }
}

WORD WOWHandle16 (HANDLE h32, WOW_HANDLE_TYPE htype)
{
    switch (htype) {
        case WOW_TYPE_HWND:
            return GETHWND16(h32);
        case WOW_TYPE_HMENU:
            return GETHMENU16(h32);
        case WOW_TYPE_HDWP:
            return GETHDWP16(h32);
        case WOW_TYPE_HDROP:
            return GETHDROP16(h32);
        case WOW_TYPE_HDC:
            return GETHDC16(h32);
        case WOW_TYPE_HFONT:
            return GETHFONT16(h32);
        case WOW_TYPE_HMETAFILE:
            return GETHMETA16(h32);
        case WOW_TYPE_HRGN:
            return GETHRGN16(h32);
        case WOW_TYPE_HBITMAP:
            return GETHBITMAP16(h32);
        case WOW_TYPE_HBRUSH:
            return GETHBRUSH16(h32);
        case WOW_TYPE_HPALETTE:
            return GETHPALETTE16(h32);
        case WOW_TYPE_HPEN:
            return GETHPEN16(h32);
        case WOW_TYPE_HACCEL:
            return GETHACCEL16(h32);
        case WOW_TYPE_HTASK:
            return GETHTASK16(h32);
        default:
            return(0xffff);
    }
}

extern PVOID GdiQueryTable();

PVOID gpGdiHandleInfo = (PVOID)-1;

//WARNING: This structure must match ENTRY in ntgdi\inc\hmgshare.h
//         and in ..\vdmexts\wow.c

typedef struct _ENTRYWOW
{
    LONG   l1;
    LONG   l2;
    USHORT FullUnique;
    USHORT us1;
    LONG   l3;
} ENTRYWOW, *PENTRYWOW;


/*++
 Notes on GDI handle mapping:

 Since NT 3.1, GDI has been limited to handles that had values < 16K. The reason
 for this limitation is not known. But we do know that on Windows 3.1 the same 
 limitation existed since GDI handles were really just hLocalMem handles which
 in reality were just offsets into GDI's local heap.  The local heap manager
 always returned handles with the two lowest bits set to 0. The 2nd bit, the 2's
 bit, was used by the Win 3.1 heap manager to mark memory as fixed. The 1's bit 
 we assume was not set because memory offsets probably weren't odd.  Therefore 
 they only had 14-bits available for handle values.  There are notes in WOW that
 16-bit applications were aware of this and used the two lowest bits for their 
 own evil purposes. In fact, we use the lowest bit at times in WOW for evil
 purposes of our own! (see notes in GetDC() thunk in wuser.c) 

 GDI32 handles are made up of two parts, the loword of the handle is the handle 
 value which, until Windows XP, was < 16K as mentioned above.  The hiword of the
 handle consists of a bunch of "uniqueness" (bad name for these really) bits. 
 Prior to Windows XP, WOW thunked GDI32 handles by stripping off the hiword 
 uniqueness bits and then left-shifted the loword handle value by 2 -- exposing
 the two low order bits for apps to use to their heart's content. Since the 
 handle value was < 16K, we didn't lose any relevant handle information by left-
 shiftng by two. To un-thunk the handle back to 32-bits, we right-shifted it by
 2 and OR'd the uniqueness bits back onto the hiword (we get the uniqueness bits
 from a table that GDI32 exposes to us). This scheme allowed a very nice one-to-
 one mapping of the handles back-and-forth so there was never any need to create
 a mapping table.

 Enter Windows XP. The GDI group, with good reason, needed to increase the 
 number of handles system-wide, so they changed their handles to use all 16-bits
 in the loword handle values. Unfortunately, when we do our left-shift thunk
 thing, any handles values > 16K get trashed and things go south pretty quickly.
 We found this whole issue out very late in the XP client ship cycle (3 weeks to
 RTM) and couldn't do too much about it at that point. So we just tested the
 handles values to see if they were > 16K and told the user that the 16-bit
 subsystem was out of resources & that they needed to reboot their system --
 then we killed the VDM. Gack! Not something somebody running an enterprise
 server wants to see. So...

 For the .NET Server & SP1 releases of XP we decided that we needed to come up 
 with a mapping algorithm that allows WOW to use handles with values above 16K. 
 Here it is:

 1. We allocate a mapping table with 64K entries to accomodate all possible 
    32-bit handles.  The loword of an h32 is used to index directly into this 
    table.  An entry in this table is the index of the corresponding h16 in the 
    h16 mapping table.

 2. We reserve a mapping table with 16K entries in virtual memory.  Each entry
    in the table contains the corresponding h32, an index to the next free entry
    in the table, and a State.  The State can be one of the following: IN_USE,
    SLOT_FREE, H16_DELETE, and GDI_STOCK_OBJECT.  Initially we only commit one
    "table page" of memory in the table -- enough to map 1K handles.

 3. When an app calls an API such as CreateBrush(), we map the returned handle
    into the first available slot in the free list. The index of the selected
    slot is left-shifted by 2 (to open up the lower two bits as before) and that
    value is used as the h16 that we return to the app.

 4. When the app calls an API using an h16 such as SelectObject(), we right
    shift the handle back into an index into our table and retreive the mapped
    h32 that we stored at the index location.

 5. When an app calls DeleteObject(), we originally released all the mapping
    information and returned the associated slot index to the end of the free
    list. This didn't work so good.  We found that many apps will try to use old
    handles that they already free'd.  They also depend on getting back the same
    handle value that they had just free'd -- not good. So, we implemented a
    "lazy-deletion" algorithm to leave all the mapping info in the table as long
    as possible before finally returning it to the free list.  Things got much
    better. We also try to re-map recycled 32-bit handles back to the same index
    mapping that they previously had.

 6. If our free list becomes empty (most slots are marked IN_USE or H16_DELETE
    for lazy-deletion) we will be forced into a reclaim function to try to 
    reclaim leaked handles (handles that an app created but never deleted) and
    also finally free *some* of the lazy-delete handles.  Reclaimed handles are
    added to the end of the free list. We try not to reclaim all the lazy-delete
    handles during reclaim because that would kind of put a hiccup in our lazy
    deletion scheme.  If we are unable to reclaim enough handles, we then commit
    a new table page from our virtual memory reserve and add the new slots to 
    the front of the free list.
    
 7. We do have to be careful of handle leaks in our table. One potential leak is
    for messages of the WM_PAINTCLIPBOARD nature. Assume that a 16-bit app put
    something on the clipboard in a format only understood by that app.  Now, a
    32-bit app wants to paste what is on the clipboard onto his client window.o     After a query, the 32-bit app finds that our 16-bit can do the painting for
    him, so the 32-bit app sends a WM_PAINTCLIPBOARD message to the 16-bit app
    complete with an hDC to 32-bit client window.  Problem is, GDI handles are
    only good in the process they were created in.  User32, intercepts the
    message and just before dispatching it to the 16-bit app, it essentially
    does a CreateCompatibleDC() in the context of the 16-bit app's process and
    passes on the new handle.  Works great.  We just need to make sure that we
    know when to un-map the new handle from our table or we'll get a leak.  See
    code for WM_PAINTCLIPBOARD in wmdisp32.c to see how we do this.  There are
    other issues of this nature that aren't so easy because there are no 
    reliable clues as to when we can delete these handles that are created by
    external elements on our behalf.  To try to keep our table fromm leaking too
    badly we check all handles in our table at reclaim time to see if they are 
    still valid.  And finally, if the only running task in the VDM is wowexec,
    we just throw away the tables altogether & re-build them from scratch.

--*/

/*+++

 Here are some restrictions to 16-bit GDI handles:
  - An h16 can't = 0 since that means failure from API's that return handles.
    If an app specifies an hDC = 0, it usually means the DISPLAY DC.
  - We can't give out handles with values <= COLOR_ENDCOLORS since the
    hbrBackground member of WNDCLASS structs can specify ordinals in that 
    range.
  - We can't give out handle values > 0x3FFF (16K).
  - GDI16 caches the stock objects at WOW32 boot time.  We need to make sure
    that the stock object handles are always mapped the same -- across all
    WOW processes.

 So we reduce the size of our table to deal with handles in the range of
 COLOR_ENDCOLORS+1 -> 0x3FFF. Since we left shift table index values by 2 (ie.
 multiply by 4) to get the h16 we give to the app, we can calculate the first
 allowable index value by COLOR_ENDCOLORS/4 + 1.

--*/
#define FIRST_ALLOWABLE_INDEX ((COLOR_ENDCOLORS/4) + 1)
#define LAST_ALLOWABLE_INDEX  0x3FFF // Allows for 
                                     // FIRST_ALLOWABLE_INDEX -> 0x3FFF entries

// These two constants give us the absolute maximum number of GDI16 handles
// we can support and the maximum size of the GDI16 handle table.
// If the table is static we should define MAX_GDI16_HANDLES as follows:
//#define MAX_GDI16_HANDLES ((LAST_ALLOWABLE_INDEX - FIRST_ALLOWABLE_INDEX) + 1)
// Since the 16-bit mapping table is to grow dynamically, we'll make all pages
// the same size to simplify things and waste the first few entries in the first
// page.
#define MAX_GDI16_HANDLES 0x4000   // 16K handles
#define MAX_GDI16_HANDLE_TABLE_SIZE (MAX_GDI16_HANDLES * sizeof(GDIH16MAP))

#define GDI16_HANDLES_PER_PAGE  512
#define GDI16_HANDLE_PAGE_SIZE  (GDI16_HANDLES_PER_PAGE * sizeof(GDIH16MAP))


// This table *has to* have 64K entries so we can index the 32-bit GDI handles 
// directly by the low word of the h32.  
#define GDI32_HANDLE_TABLE_ENTRIES 0x10000
#define GDI32_HANDLE_TABLE_SIZE (GDI32_HANDLE_TABLE_ENTRIES * sizeof(GDIH32MAP))

// Max number of handles to reclaim when we're short
#define GDI16_RECLAIM_SIZE 64

WORD MapGdi32Handle(HANDLE h32, WORD State);
void RegisterStockObjects(void);
BOOL ReclaimTableEntries(void);
BOOL DeleteMappedGdi32Handle(HANDLE h32, WORD index, BOOL bReclaim);
BOOL OkToDeleteThis(HANDLE h32, WORD index, BOOL bReclaim);
BOOL CommitNewGdi16TablePage(PGDIH16MAP pTable16);
PGDIH16MAP AllocGDI16Table(void);

// This is a global so it can be tuned via app comaptflag if necessary.
int              gGdi16ReclaimSize = GDI16_RECLAIM_SIZE;

WORD             gH16_deleted_count = 0;
WORD             ghGdi16NextFree = 0;
WORD             ghGdi16LastFree = 0;
HANDLE           hGdi32TableHeap = NULL;
UINT             gMaxGdiHandlesPerProcess = 0;
WORD             gLastAllowableIndex = 0;
WORD             gFirstNonStockObject = 0;
WORD             gwNextReclaimStart = 0;
DWORD            gdwPageCommitSize = 0;
PGDIH16MAP       pGdiH16MappingTable = NULL;
PGDIH32MAP       pGdiH32MappingTable = NULL;
#ifdef DEBUG
WORD             gprevNextFree = 0xFFFF;
UINT             gAllocatedHandleCount = 0;
#endif


// This routine converts a 16bit GDI handle to a GDI32 handle.
HANDLE hConvert16to32(int h16)
{
    WORD   index;
    DWORD  h32;
    DWORD  h_32;

    // Apps can specify a NULL handle.  For instance hDC = NULL => DISPLAY
    if(h16 == 0)
        return(0);

    // right shift out our left shift thing
    index = (WORD)(h16 >> 2); 

    if((index < FIRST_ALLOWABLE_INDEX) || (index > gLastAllowableIndex)) {

        // Some WM_CTLCOLOR messages return wierd values for brushes
        WOW32WARNMSG((FALSE),"WOW::hConvert16to32:Bad index value!\n");

        // bad handles get mapped to 0
        return(0);
    }
    
    h32 = (DWORD)pGdiH16MappingTable[index].h32;

    WOW32WARNMSG((h32),"WOW::hConvert16to32:h32 missing from table!\n");

    // We might get this because an app is using a handle it already deleted.
    // These can probably be ignored if they come from ReleaseCachedDCs().
    WOW32WARNMSG((pGdiH32MappingTable[LOWORD(h32)].h16index == index),
                 "WOW::hConvert16to32:indicies don't jive!\n");

    // Update the uniqueness bits to match what they currently are in GDI32's
    // handle table. This will give us the "previous" behavior.
    // See bug #498038 -- we might possibly want to remove this.
    h_32 = h32 & 0x0000FFFF;
    h_32 = h_32 | (DWORD)(((PENTRYWOW)gpGdiHandleInfo)[h_32].FullUnique) << 16; 
    if(h32 != h_32) {
        WOW32WARNMSG((FALSE),"WOW::hConvert16to32:uniqueness bits !=\n");

        h32 = h_32;
        pGdiH16MappingTable[index].h32 = (HANDLE)h32; 
    }
    
    return((HANDLE)h32);
}



// This routine converts a GDI32 handle to a 16bit GDI handle
HAND16 hConvert32to16(DWORD h32)
{
    WORD   index;
    WORD   State;
    HANDLE h_32;
    
    // A handle == 0 isn't necessarily bad, we just don't do anything with it.
    if(h32 == 0) {
        return(0);
    }
    
    // See if we have already mapped a 16-bit version of this handle
    index = pGdiH32MappingTable[LOWORD(h32)].h16index;
    h_32  = pGdiH16MappingTable[index].h32;
    State = pGdiH16MappingTable[index].State;
                 
    // If it looks like we may have already registered this handle...
    if(index) {

        WOW32ASSERTMSG((index <= gLastAllowableIndex),
                       "WOW::hConvert32to16:Bad index!\n");
                     
        // Verify the handle indicies match
        if(LOWORD(h32) == LOWORD(h_32)) {
 
            // If the 16-bit mapping is marked "IN_USE" will be true for 
            // two reasons:
            //   1. The mapping is still valid
            //   2. h32 got deleted without our knowledge and is comming back as
            //      a recycled handle.  We might as well use the same mapping as
            //      before.
            if(State == IN_USE) {
        
                // All we need to do is effectively update the uniqueness bits 
                // in the 16-bit table entry.
                if(HIWORD(h32) != HIWORD(h_32)) {
                    LOGDEBUG(12, ("WOW::hConvert32to16:recycled handle!\n"));
                    pGdiH16MappingTable[index].h32 = (HANDLE)h32;
                }
            }

            // If the mapping was marked for deletion, let's renew it.  h32 has
            // been recycled. We might as well use the same mapping as before.
            else if(State == H16_DELETED) {
                pGdiH16MappingTable[index].h32 = (HANDLE)h32;
                pGdiH16MappingTable[index].State = IN_USE;
                gH16_deleted_count--;
            }
            // else h32 is a GDI_STOCK_OBJECT in which case the index is OK
            else if(State != GDI_STOCK_OBJECT) {
                WOW32ASSERTMSG((FALSE),"WOW::hConvert32to16:SLOT_FREE!\n");
                return(0); // debug this
            }
        }

        // Else if the handle indicies don't match, the h32 got deleted without
        // our knowledge and is now coming back as a recycled handle. We'll use
        // the same mapping as before.
        else {
            pGdiH16MappingTable[index].h32 = (HANDLE)h32;
            pGdiH16MappingTable[index].State = IN_USE;
        }
    }

    // looks like we need to create a new mapping
    else {

        index = MapGdi32Handle((HANDLE)h32, IN_USE);
    }

    // If we couldn't get an index, go see if we can reclaim some entries and
    // find one.
    if(!index) {
        if(ReclaimTableEntries()) {
            index = MapGdi32Handle((HANDLE)h32, IN_USE);
        }
    }

    if((index < FIRST_ALLOWABLE_INDEX) || (index > gLastAllowableIndex)) {
#ifdef DEBUG
        if(index < FIRST_ALLOWABLE_INDEX) {
            WOW32ASSERTMSG((FALSE),"WOW::hConvert32to16:index too small!\n");
        }
        else {
            WOW32ASSERTMSG((FALSE),"WOW::hConvert32to16:index too big!\n");
        }
#endif
        return(0);
    }

    // Do our left shift thing and we're done
    return(index << 2);
}





WORD MapGdi32Handle(HANDLE h32, WORD State)
{
    WORD   index = 0;


    // If all free entries are gone -- nothing to do
    if(ghGdi16NextFree != END_OF_LIST) {

        index = ghGdi16NextFree;

        ghGdi16NextFree = pGdiH16MappingTable[index].NextFree;

#ifdef DEBUG
        if(ghGdi16NextFree == END_OF_LIST) {
            gprevNextFree = index;
            WOW32WARNMSG((FALSE),"WOW::MapGdi32Handle:Bad NextFree!\n");
        }
#endif
        // Set the state (either IN_USE or GDI_STOCK_OBJECT)
        pGdiH16MappingTable[index].State = State;

        // Map the 32bit handle with the 16-bit handle
        pGdiH16MappingTable[index].h32 = h32;
        pGdiH32MappingTable[LOWORD(h32)].h16index = index;

#ifdef DEBUG
        gAllocatedHandleCount++;
#endif
    }

    return(index);
}



// Requires that index & h32 are both non-null.
// Assumes that index is an *index* and *not* an h16 (not an index << 2).
// bReclaim specifies that the handle needs to be added to the freelist.
BOOL DeleteMappedGdi32Handle(HANDLE h32, WORD index, BOOL bReclaim)
{
    BOOL bRet = FALSE;
    
    
    if(OkToDeleteThis(h32, index, bReclaim)) {

        // We don't actually want to *remove* the mapping from our table unless
        // we are reclaiming entries. Lame apps call us with old deleted handles
        // and we want to pass on the same mapping that they had when the handle
        // was still good. This also allows us to reuse old mappings for h32 
        // handles that get recycled.
        if(bReclaim) {

            // re-initialized the slot
            pGdiH16MappingTable[index].State    = SLOT_FREE;  
            pGdiH16MappingTable[index].h32      = NULL;
            pGdiH16MappingTable[index].NextFree = END_OF_LIST;  

            // add this slot to the end of the free list
            pGdiH16MappingTable[ghGdi16LastFree].NextFree = index;

            pGdiH32MappingTable[LOWORD(h32)].h16index = 0;

            ghGdi16LastFree = index;

#ifdef DEBUG
            if(gAllocatedHandleCount > 0)  gAllocatedHandleCount--;
#endif
        }

        // else just mark this as potentially deleted
        else {
            pGdiH16MappingTable[index].State = H16_DELETED;
            gH16_deleted_count++;
        }

        bRet = TRUE;
    }
    
    return(bRet);
}



// Check list of "What can go wrong?'s"
BOOL OkToDeleteThis(HANDLE h32, WORD index, BOOL bReclaim)
{
    
    HANDLE  h_32;
    WORD    NextFree;
    WORD    index16;
    WORD    State;

    // If we see this, it may be an app error calling DeleteObject(0).
    if(index == 0) {
        WOW32WARNMSG((FALSE),"WOW::OkToDeleteThis:Null index");
        return(FALSE);
    }

    // Debug why we get this
    if(h32 == NULL) {
        WOW32ASSERTMSG((FALSE),"WOW::OkToDeleteThis:Null h32\n");
        return(FALSE);
    }

    // Debug why we get this.  May be just an app being stupid
    if((index < FIRST_ALLOWABLE_INDEX) || (index > gLastAllowableIndex)) {
        WOW32ASSERTMSG((FALSE),"WOW::OkToDeleteThis:index bad\n");
        return(FALSE);
    }

    h_32 = pGdiH16MappingTable[index].h32; 
    State = pGdiH16MappingTable[index].State;
    NextFree = pGdiH16MappingTable[index].NextFree; 
    index16 = pGdiH32MappingTable[LOWORD(h32)].h16index;

    // Don't remove stock objects from the table!
    if(State == GDI_STOCK_OBJECT) {
        return(FALSE);
    }

    // Check for the "IN_USE" flag.  If it isn't currently in use then it is
    // already in the free list and we don't want to mess with it.  Apps 
    // have been known to call DeleteObject() twice on the same handle.
    if(!bReclaim && (State != IN_USE)) {
        WOW32WARNMSG((FALSE),"WOW::OkToDeleteThis:Not IN_USE\n");
        return(FALSE);
    }

    // We should allow this since the index is obviously pointing to an old h32.
    if(h32 != h_32) {
        WOW32WARNMSG((FALSE),"WOW::OkToDeleteThis:h32 != h_32\n");
        return(TRUE);
    }

    // Don't mark it for delete if the object is still valid.
    if(GetObjectType(h32)) {
        return(FALSE);
    }

#ifdef DEBUG
    // Debug this.  We should probably let the table repair itself.
    if(index16 == 0) {
        WOW32ASSERTMSG((FALSE),"WOW::OkToDeleteThis:index=0 in h32 table\n");
        return(TRUE);
    }
#endif

    return(TRUE);
}




// This should be called by functions outside this file to delete mapped h16's.
void DeleteWOWGdiHandle(HANDLE h32, HAND16 h16)
{
    WORD index;

    // convert h16 back into table index
    index = (WORD)(h16 >> 2);

    DeleteMappedGdi32Handle(h32, index, FALSE);
}

        
        

// This should be called by functions outside this file to retrieve the WOWInfo
// associated with an h32.
// Returns:
//    The 16-bit mapping for this h32
//    0 - if h32 is valid but not mapped in our table
//    -1 - if h32 is 0 or bad (BAD_GDI32_HANDLE)
HAND16 IsGDIh32Mapped(HANDLE h32)
{
    WORD   index;
    HANDLE h_32 = NULL;

    if(h32) {

        if(GetObjectType(h32)) {

            index = pGdiH32MappingTable[LOWORD(h32)].h16index;

            if(index) {
                h_32 = pGdiH16MappingTable[index].h32;
            }
            
            if(h_32 == h32) {
                return((HAND16)index<<2);
            }
            return(0);
        }
    }
    return(BAD_GDI32_HANDLE);
}

    
#if 0
// This is really for a sanity check that the GDI guys haven't increased the
// GdiProcessHandleQuota past 16K. 
int DisplayYouShouldNotDoThatMsg(int nMsg)
{
    CHAR   szWarn[512];
    CHAR   szText[256];

    LoadString(hmodWOW32, 
               iszYouShouldNotDoThat,
               szWarn, 
               sizeof(szWarn)/sizeof(CHAR));

    LoadString(hmodWOW32, 
               nMsg,
               szText, 
               sizeof(szText)/sizeof(CHAR));

    if((strlen(szWarn) + strlen(szText)) < 512) {
        strcat(szWarn, szText);
    }
 
    LoadString(hmodWOW32, 
               iszHeavyUse,
               szText, 
               sizeof(szText)/sizeof(CHAR));

    if((strlen(szWarn) + strlen(szText)) < 512) {
        strcat(szWarn, szText);
    }

    return(MessageBox(NULL,
                      szWarn,
                      NULL,
                      MB_YESNO       | 
                      MB_DEFBUTTON2  | 
                      MB_SYSTEMMODAL | 
                      MB_ICONEXCLAMATION));
}

#endif



BOOL InitializeGdiHandleMappingTable(void)
{
    HKEY   hKey = 0;
    DWORD  dwType;
    DWORD  cbSize = sizeof(DWORD);
    CHAR   szError[256];

    gpGdiHandleInfo = GdiQueryTable();

    // The GDI per-process handle limit has to be obtained from the registry.
    // ie. It can be changed by a user! (not doc'd but you know how that goes)
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    "Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows",
                    0, 
                    KEY_READ, 
                    &hKey ) == ERROR_SUCCESS) {

        RegQueryValueEx(hKey, 
                        "GdiProcessHandleQuota", 
                        0, 
                        &dwType, 
                        (LPBYTE)&gMaxGdiHandlesPerProcess, 
                        &cbSize);

        RegCloseKey(hKey);
    }

    WOW32ASSERTMSG((gMaxGdiHandlesPerProcess != 0),
                   "WOW::InitializeGdiHandleMappingTable:Default GDI max!\n");

    // We have to be <= ~16K or we wouldn't have to do all this stuff.
    if(gMaxGdiHandlesPerProcess > MAX_GDI16_HANDLES) {

        // limit them at the max.
        gMaxGdiHandlesPerProcess = MAX_GDI16_HANDLES;
    }
    
    // Allocate the 32-bit handle mapping table.
    hGdi32TableHeap = HeapCreate(HEAP_NO_SERIALIZE,
                                 GDI32_HANDLE_TABLE_SIZE,
                                 GROW_HEAP_AS_NEEDED);

    if(hGdi32TableHeap == NULL) {
        goto IGHMT_error;
    }

    pGdiH32MappingTable = HeapAlloc(hGdi32TableHeap, 
                                    HEAP_ZERO_MEMORY, 
                                    GDI32_HANDLE_TABLE_SIZE);

    if(pGdiH32MappingTable == NULL) {
        goto IGHMT_error;
    }

    pGdiH16MappingTable = AllocGDI16Table();

    if(pGdiH16MappingTable == NULL) {
        goto IGHMT_error;
    }

    // Add the stock objects as the first entries in the GDI handle mapping 
    // tables.
    RegisterStockObjects();

    return(TRUE);

IGHMT_error:
    cbSize = LoadString(hmodWOW32, 
                        iszStartupFailed,
                        szError, 
                        sizeof(szError)/sizeof(CHAR));

    if((cbSize == 0) || (cbSize >= 256)) {

        strcpy(szError, "Not enough memory to load 16-bit subsystem.");
    }

    WOWSysErrorBox(NULL, szError, SEB_OK, 0, 0);

    if(pGdiH32MappingTable) {
        HeapFree(hGdi32TableHeap, HEAP_NO_SERIALIZE, pGdiH32MappingTable);
    }

    if(hGdi32TableHeap) {
        HeapDestroy(hGdi32TableHeap);
    }

    return(FALSE);
}



PGDIH16MAP AllocGDI16Table(void)
{
    SIZE_T     dwSize;
    PGDIH16MAP pTable16;

#ifdef DEBUG
    SYSTEM_INFO sSysInfo;

    GetSystemInfo(&sSysInfo);

    // If either of these go off we need to come up with a way to align our 
    // struct within memory page sizes.
    WOW32ASSERTMSG((!(sSysInfo.dwPageSize % sizeof(GDIH16MAP))),
                   "WOW::AllocGDI16Table:Page alignment issue!\n");
    WOW32ASSERTMSG(
       (!((sizeof(GDIH16MAP) * GDI16_HANDLES_PER_PAGE) % sSysInfo.dwPageSize)),
       "WOW::AllocGDI16Table:Page alignment issue 2!\n");
#endif

    // Reserve the biggest table we'll ever need. 
    // (This is a call to VirtualAlloc() in disguise).
    dwSize = MAX_GDI16_HANDLE_TABLE_SIZE;
    pTable16 = NULL;
    if(!NT_SUCCESS(NtAllocateVirtualMemory(ghProcess,
                                           (PVOID *)&pTable16,
                                           0,
                                           &dwSize,
                                           MEM_RESERVE,
                                           PAGE_READWRITE))) {
        WOW32ASSERTMSG((FALSE),
                       "WOW::AllocGDI16Table:Alloc reserve failed!\n");
        return(NULL);
    }

    // Commit the first "table page"
    gdwPageCommitSize = 0;
    gLastAllowableIndex = (WORD)-1; // cheese!
    ghGdi16NextFree = END_OF_LIST;
    if(!CommitNewGdi16TablePage(pTable16)) {
        dwSize = 0;
        NtFreeVirtualMemory(ghProcess,
                            (PVOID *)&pTable16,
                            &dwSize,
                            MEM_RELEASE);
        return(NULL);
    }

    ghGdi16NextFree = FIRST_ALLOWABLE_INDEX; // adjust this for init case
    ghGdi16LastFree = gLastAllowableIndex;
    gH16_deleted_count = 0;

    return(pTable16);    
}




BOOL CommitNewGdi16TablePage(PGDIH16MAP pTable16)
{
    WORD   index;
    WORD   wFirstNewIndex, wLastNewIndex;
    SIZE_T dwSize;
    PVOID  p;

    // If we've allocated the last table page already -- we can't grow any more.
    if(gdwPageCommitSize >= MAX_GDI16_HANDLE_TABLE_SIZE) {
        WOW32WARNMSG((FALSE),
                     "WOW::CommitNewGDI16TablePage:End of table!\n");
        return(FALSE);
    }

    // Try to grow the number of comitted pages in our table.
    dwSize = GDI16_HANDLE_PAGE_SIZE;
    p = (PVOID)(((LPBYTE)pTable16) + gdwPageCommitSize);
    if(!NT_SUCCESS(NtAllocateVirtualMemory(ghProcess,
                                           &p,
                                           0,
                                           &dwSize,
                                           MEM_COMMIT,
                                           PAGE_READWRITE))) {
        WOW32ASSERTMSG((FALSE),
                       "WOW::CommitNewGDI16TablePage:Commit failed!\n");

        return(FALSE);
    }

    WOW32ASSERTMSG((dwSize == GDI16_HANDLE_PAGE_SIZE),
                   "WOW::CommitNewGDI16TablePage:Page boundary mismatch!\n");

    // Build the free list in the new page.
    // Note: NtAllocateVirtualMemory() zero init's memory, therefore the h32 and
    // State members of each GDIH16MAP entry are NULL & SLOT_FREE by default.
    wFirstNewIndex = gLastAllowableIndex + 1;
    wLastNewIndex  = wFirstNewIndex + GDI16_HANDLES_PER_PAGE - 1;
    for(index = wFirstNewIndex; index < wLastNewIndex; index++) {
        pTable16[index].NextFree = index + 1; 
    }
    gLastAllowableIndex += GDI16_HANDLES_PER_PAGE;

    // Put these new entries at the head of the free list.
    pTable16[gLastAllowableIndex].NextFree = ghGdi16NextFree;
    ghGdi16NextFree = wFirstNewIndex;

    gdwPageCommitSize += GDI16_HANDLE_PAGE_SIZE;

    return(TRUE);
}




// Add the list of stock objects to begining of our table.  
void RegisterStockObjects(void)
{
    WORD   index = 0;
    HANDLE h32;
    int    i;

    for(i = WHITE_BRUSH; i <= STOCK_MAX; i++) {

        h32 = GetStockObject(i);

        // currently there is no stock object ordinal == 9
        if(h32) {

            // Marking the State as GDI_STOCK_OBJECT assures us that stock
            // objects won't get deleted from the table.
            index = MapGdi32Handle(h32, GDI_STOCK_OBJECT);
        }
    }
    gFirstNonStockObject = index + 1;
    gwNextReclaimStart  = gFirstNonStockObject;
}





// Reclaim some of the lazily deleted handles (State == H16_DELETE) into the
// free list. Also attempt to clean up handles that may have leaked and are
// no longer valid.
BOOL ReclaimTableEntries(void) 
{
    WORD   index;
    WORD   State;
    WORD   wReclaimStart, wReclaimEnd;
    WORD   PrevLastFree = ghGdi16LastFree;
    HANDLE h32;
    WORD   i;
    int    cFree;
    BOOL   bFirst = TRUE;

    // Note that we attempt to somewhat preserve the lazy-deletion scheme
    // to avoid putting a large hiccup in the scheme.
    
    // First determine if we can reclaim without deleting too many H16_DELETE
    // entries.  If we can't keep a minimal number around, it's time to commit
    // a new table page.
    if(gH16_deleted_count < (gGdi16ReclaimSize * 2)) {
        if(CommitNewGdi16TablePage(pGdiH16MappingTable)) {
            return(TRUE);
        }
        // if the commit failed, all we can do is reclaim
    }

    // This is an attempt to keep from always reclaiming from the front of the
    // table.  It might not be that important to do this as things get pretty 
    // well shuffled over time.  Probably advisable during table's early life.
    // The first time through we start at where we left off last time.  The
    // 2nd time through we start from the beginning.
    wReclaimStart = gwNextReclaimStart;
    wReclaimEnd   = gLastAllowableIndex;
    cFree = 0;
    for(i = 0; i < 2; i++) {
        for(index = wReclaimStart; index <= wReclaimEnd; index++){

            State = pGdiH16MappingTable[index].State;
            h32   = pGdiH16MappingTable[index].h32;

            // If it is marked as deleted...
            if(State == H16_DELETED) {

                // ...destroy the mapping and add it to the free list
                if(DeleteMappedGdi32Handle(h32, index, TRUE)) {
                    cFree++;
                    gH16_deleted_count--;

                    // If this is the first index we're reclaiming and the free
                    // list is empty, make index to the new previous lastfree
                    // the new start of the free list. This is kind of tricky.
                    // It will be the case where the call to MapGdi32Handle()
                    // returns index == 0 in hConvert32to16() and this function
                    // is called as a result.  What has happened is that the
                    // ghGdi16NextFree ptr has caught up with ghGdi16LastFree
                    // ptr and then we get another call to hConvert32to16() to
                    // map a new h32.  ghGdi16NextFree is now == 0 at this point
                    // so we fail the call to MapGdi32Handle(). This forces this
                    // reclaim function to be called. Here ghGdi16NextFree is 
                    // set back to ghGdi16LastFree while ghGdi16LastFree will be
                    // set to the value of the first handle to be reclaimed via
                    // DeleteMappedGdi32Handle(). While in this reclaim loop,
                    // the freelist will quickly grow again and there will be
                    // plenty of room between ghGdi16NextFree & ghGdi16LastFree
                    // again.
                    if(bFirst && (ghGdi16NextFree == END_OF_LIST)) {
                        ghGdi16NextFree = PrevLastFree;
                    }
                    bFirst = FALSE;
 
                    // if we've reclaimed enough, we're done.
                    if(cFree >= gGdi16ReclaimSize) {
                        gwNextReclaimStart = index + 1;
                        goto Done;
                    }
                }
            }
            // else if it is marked in use...
            else if(State == IN_USE) {

                // ...see if the handle is still valid, if not, it is a leak. 
                if(!GetObjectType(h32)) {

                    // Mark it H16_DELETED.
                    DeleteMappedGdi32Handle(h32, index, FALSE);
                }
            }

        } // end for

        wReclaimEnd   = wReclaimStart;
        wReclaimStart = gFirstNonStockObject;

        // If we started at the beginning the first time, no sense in doing
        // it again.
        if(wReclaimEnd == gFirstNonStockObject) {
            goto Done;
        }
    } // end for

    gwNextReclaimStart = index;

Done:
    if(gwNextReclaimStart == gLastAllowableIndex) {
        gwNextReclaimStart = gFirstNonStockObject;
    }
        
    WOW32ASSERTMSG((cFree),"WOW::ReclaimTableEntries:cFree = 0!\n");
    return(cFree);
}



// NOTE: This should only be called if nWOWTasks == 1!
// If the only task running is wowexec, we can cleanup any handles that
// the WOW process leaked. 
// Note: This can break the debug wowexec if anybody ever changes it to use
//       any GDI handles other than stock objects.
void RebuildGdiHandleMappingTables(void)
{
    SIZE_T dwSize;
    PGDIH16MAP pTable16 = pGdiH16MappingTable;
#if 0
// We should look at this to see if we can clean up any leaks for our process in
// GDI32.  We have to be careful though because there may be handles that were
// allocated on our behalf from such components as USER32 who might have cached
// the handle.  If we call DeleteObject() on a handle that is in a USER32 cache
// it might be disasterous. In short, we would like to do this but probably
// can't.
    DWORD  dwType;
    HANDLE h32;
    WORD   index;

    // Go free any GDI handles that this process might have.
    for(index = FIRST_ALLOWABLE_INDEX; index <= gLastAllowableIndex; index++) {

        h32 = pGdiH16MappingTable[index].h32;

        // if the handle is still valid in our process...
        dwType = GetObjectType(h32);
        if(h32 && dwType) {

            // formally delete the handle
            switch(dwType) {

                // No way to tell which DC allocation mechanism this came 
                // from (CreateDC(), BeginPaint(), GetxxxDC() etc).  We can
                // really mess things up if we call the wrong delete 
                // function, so we'll just let the GDI32 & USER32 process 
                // clean-up code deal with these.
                case OBJ_DC:
                    break;

                // The rest we can use DeleteObject()
                default:
                    DeleteObject(h32);
                    break;
            }
        }
    }
#endif

    // De-commit entire 16-bit handle table & re-build both tables. This could
    // burn us if the debug version of wowexec is running with its window open
    // and they get a GDI handle but I don't think it is likely. We're also
    // somewhat protected by the fact the GDI16 caches the stock objects.
    dwSize = gdwPageCommitSize;
    if(NT_SUCCESS(NtFreeVirtualMemory(ghProcess,
                                      (PVOID *)&pTable16,
                                      &dwSize,
                                      MEM_DECOMMIT))) {

        RtlZeroMemory(pGdiH32MappingTable, GDI32_HANDLE_TABLE_SIZE);

        // Commit the first "table page" again
        gdwPageCommitSize = 0;
        gLastAllowableIndex = (WORD)-1; // cheese!
        ghGdi16NextFree = END_OF_LIST;
#ifdef DEBUG
        gAllocatedHandleCount = 0;
#endif
        if(!CommitNewGdi16TablePage(pTable16)) {
            dwSize = 0;
            NtFreeVirtualMemory(ghProcess,
                                (PVOID *)&pTable16,
                                &dwSize,
                                MEM_RELEASE);
            WOW32ASSERTMSG((FALSE),
                           "WOW::RebuildGdiHandleMappingTables:Panic!\n");
            return;
        }

        ghGdi16NextFree = FIRST_ALLOWABLE_INDEX; // adjust this for init case
        ghGdi16LastFree = gLastAllowableIndex;
        gH16_deleted_count = 0;
 
        // re-register the stock object & we're on our way!
        RegisterStockObjects();
    }
}




void DeleteGdiHandleMappingTables(void)
{
    SIZE_T dwSize;

    dwSize = 0;
    NtFreeVirtualMemory(ghProcess,
                        (PVOID *)&pGdiH16MappingTable,
                        &dwSize,
                        MEM_RELEASE);

    HeapFree(hGdi32TableHeap, HEAP_NO_SERIALIZE, pGdiH32MappingTable);
    HeapDestroy(hGdi32TableHeap);
}




// We probably don't need to worry about this buffer being too small since we're
// really only interested in the predefined standard classes which tend to
// be rather short-named.
#define MAX_CLASSNAME_LEN  64

// There is a time frame (from when an app calls CreateWindow until USER32 gets
// a message at one of its WndProc's for the window - see FritzS) during which
// the fnid (class type) can't be set officially for the window.  If the
// GETICLASS macro is invoked during this period, it will be unable to find the
// iClass for windows created on any of the standard control classes using the
// fast fnid index method (see walias.h).  Once the time frame is passed, the
// fast fnid method will work fine for these windows.
//
// This is manifested in apps that set CBT hooks and try to subclass the
// standard classes while in their hook proc.  See bug #143811.

INT GetIClass(PWW pww, HWND hwnd)
{
    INT   iClass;
    DWORD dwClassAtom;

    // if it is a standard class
    if(((pww->fnid & 0xfff) >= FNID_START) &&
                 ((pww->fnid & 0xfff) <= FNID_END)) {

        // return the class id for this initialized window
        iClass = pfnOut.aiWowClass[( pww->fnid & 0xfff) - FNID_START];

    }

    else {

       iClass = WOWCLASS_WIN16;       // default return: app private class           
   
       dwClassAtom = GetClassLong(hwnd, GCW_ATOM);
   
       if(dwClassAtom) {
           iClass = GetStdClassNumber((PSZ)dwClassAtom);
       }
    }

    return(iClass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\walloc16.c ===
//*****************************************************************************
//
// MESSAGE HEAP 16 -
//
//     Heap allocation functions for 32-16 message thunks.
//
//     NOTE: these are NOT general purpose heap managment routines.
//
//
// 07-17-92  NanduriR   Created.
//
//*****************************************************************************

#include "precomp.h"
#pragma hdrstop

MODNAME(walloc16.c);

//*****************************************************************************
// General Notes:
//
// This heap maanger is for specific 'performance gains' and is thus not
// intended for general purpose use and therfore much of the overhead has
// been eliminated.
//
// This heap manager is intended mainly for thunks - where we are sure that
// an alloced block will definitely be freed. Thus it is meant for our use.
//
// The heap is conceptually an array  of constant-size blocks. The size of the
// block is predefined. The code is optimized for allocation requests of one
// blocksize or less. It is slower if the allocation request needs more than
// one block.
//
// The heap header is a static array. The header has two flags. One to note
// that a particular heapblock is in use and the other to note whether the
// block forms a part of a linked/chained set of contiguous blocks. The blocks
// are linked when the allocation request is for more than the predefined
// block size.
//
//*****************************************************************************


#define HEAP16_TOTALSIZE  0x2000
#define HEAP16_BLOCKSIZE  0x100    // We should set it to an optimum value
#define HEAP16_BLOCKCOUNT (HEAP16_TOTALSIZE/HEAP16_BLOCKSIZE)

#define HHDR16_FINUSE     0x01
#define HHDR16_FLINKED    0x02

#define ISBLOCKINUSE(block)    ((block) & HHDR16_FINUSE)
#define ISBLOCKLINKED(block) ((block) & HHDR16_FLINKED)


//*****************************************************************************
//
// Globals -
//
// vahdr - is the heap header. This header is 32bit memory and not part of the
//         16bit heap - this is so that the 16bit heap is put to maximum use.
//
// vpHeap16 - far pointer to the start of 16bit heap
//
// viFreeIndex - the index from which we start searching for a freeblock.
//               Normally this is set to the memoryblock that was most
//               recently freed, thus increasing the chances of finding
//               a freeblock instantly.
//*****************************************************************************

BYTE    vahdr[HEAP16_BLOCKCOUNT];
LPBYTE  vpHeap16 = (LPBYTE)NULL;
UINT    viFreeIndex = 0;            // First look for Free block here.



//*****************************************************************************
//
// malloc16 -
//
//      Allocs memory from 16bit block.
//      If heap is full, does normal GlobalAlloc
//
//      Returns farpointer to memoryblock;
//
//*****************************************************************************

VPVOID FASTCALL malloc16(UINT cb)
{
    INT i, j;
    INT cBlocksRequired;
    INT fContiguousFreeBlocks;
    INT vpT;

    if (vpHeap16 == (LPBYTE)NULL) {
        vpHeap16 = (LPBYTE)GlobalAllocLock16(GMEM_MOVEABLE | GMEM_SHARE, HEAP16_TOTALSIZE,
                                                                         NULL);
        if (vpHeap16 != NULL) {

            //
            // Initialize heap header.
            // LATER: is this necessary?. Heaphdr is a static array so
            //        is it already intialized to ZERO?
            //

            for(i = 0; i < HEAP16_BLOCKCOUNT ; i++) {
                vahdr[i] = 0;
            }

        }

    }

    if (vpHeap16 != (LPBYTE)NULL) {
        if (cb <= HEAP16_BLOCKSIZE && !ISBLOCKINUSE(vahdr[viFreeIndex])) {

            //
            // If 'single' block and the 'current' index is free.
            //

            vahdr[viFreeIndex] = HHDR16_FINUSE;
            i = viFreeIndex++;
            if (viFreeIndex == HEAP16_BLOCKCOUNT)
                viFreeIndex = 0;
            return (VPVOID)((LPBYTE)vpHeap16 + i * HEAP16_BLOCKSIZE);
        }
        else {

            //
            // if the 'current' index is not free or if 'multiple' blocks
            //

            cBlocksRequired = (cb / HEAP16_BLOCKSIZE) + 1;
            for (i = 0; i < HEAP16_BLOCKCOUNT ; i++ ) {
                 if ((viFreeIndex + i + cBlocksRequired) <=
                                                          HEAP16_BLOCKCOUNT) {
                     fContiguousFreeBlocks = TRUE;
                     for (j = 0; j < cBlocksRequired; j++) {
                         if (ISBLOCKINUSE(vahdr[viFreeIndex + i + j])) {
                             fContiguousFreeBlocks = FALSE;
                             i += j;
                             break;
                         }
                     }

                     if (fContiguousFreeBlocks) {
                         for (j = 0; j < (cBlocksRequired - 1); j++) {
                              vahdr[viFreeIndex + i + j] =
                                             (HHDR16_FINUSE |  HHDR16_FLINKED);
                         }
                         vahdr[viFreeIndex + i + j] = HHDR16_FINUSE;

                         i += viFreeIndex;
                         viFreeIndex = i + cBlocksRequired;
                         if (viFreeIndex == HEAP16_BLOCKCOUNT)
                             viFreeIndex = 0;
                         return (VPVOID)((LPBYTE)vpHeap16 + i * HEAP16_BLOCKSIZE);
                     }
                 }
                 else {

                     //
                     // Outside the heaphdr range. Reset viFreeIndex, so that
                     // we search from the start of heaphdr.
                     //

                     viFreeIndex = -(i+1);
                 }
            }
            viFreeIndex = 0;
        }

    }

    //
    // Here - if allocation from heap failed
    //

    vpT = (VPVOID)GlobalAllocLock16(GMEM_MOVEABLE, cb, NULL);
    if (vpT) {
        return vpT;
    }
    else {
        LOGDEBUG(0,("malloc16: failed\n"));
        return (VPVOID)NULL;
    }
}



//*****************************************************************************
//
// free16 -
//
//      frees 16bit memory block.
//      If the block is not part of the 16bit heap, does GlobalFree.
//
//      Returns TRUE;
//
//*****************************************************************************

BOOL FASTCALL free16(VPVOID vp)
{
    INT iStartIndex;
    BOOL fLinked;

    iStartIndex = ((LPBYTE)vp - (LPBYTE)vpHeap16) / HEAP16_BLOCKSIZE;

    //
    // Invalid iStartIndex implies that the block was GlobalAlloced
    //

    if (iStartIndex >= 0 && iStartIndex < HEAP16_BLOCKCOUNT) {

        //
        // If   'single'   block: get out fast
        // else 'multiple' block: loop for all the blocks
        //

        viFreeIndex = iStartIndex;
        if (!ISBLOCKLINKED(vahdr[iStartIndex])) {
            WOW32ASSERT(ISBLOCKINUSE(vahdr[iStartIndex]));
            vahdr[iStartIndex] = 0;
        }
        else {
            while (ISBLOCKINUSE(vahdr[iStartIndex])) {
                fLinked = ISBLOCKLINKED(vahdr[iStartIndex]);
                vahdr[iStartIndex] = 0;
                if (fLinked)
                    iStartIndex++;
                else
                    break;
            }
        }
    }
    else {
        WOW32ASSERT(LOWORD(vp)==0);  // GlobalAlloced pointers have offset = 0
        GlobalUnlockFree16(vp);
    }
    return (BOOL)TRUE;
}


//*****************************************************************************
//
// stackalloc16 -
//
//      Allocs memory from current task's 16bit stack.
//      Returns farpointer to memoryblock;
//
// NOTES!!!!!:
// - This is not intended to be a full blown memory manager. It is intended to 
//   replace the TDF_INITCALLBACKSTACKFLAG to avoid problems with ptd->vpCBStack
//   getting hosed by multiple stackalloc16 calls. (See bug #393267 et al)
// - All calls to stackalloc16() and stackfree16() must be properly nested.
//   If you can't assure that your usage is properly nested, you'd better use
//   GlobalAllocLock16() & GlobalUnlockFree16() instead.
//   Beware individual message thunks may have calls to stackalloc16() that
//   aren't readily apparent.
// - The request size passed to stackfree16() needs to be the same as the size
//   of the corresponding stackalloc16() call.
// - Run your changes involving stackalloc16() under debug WOW32.DLL.  The
//   built-in sanity checking will help you catch any gotcha's
// - ptd->vpCBStack *SHOULD NOT* be referenced or used outside of stackalloc16()
//   stackfree16(), and callback16().
// - If this mechanism gets out of whack, chances are the symptom will be
//   a 16-bit stack fault message.
//*****************************************************************************
VPVOID FASTCALL stackalloc16(UINT cb)
{
#ifdef DEBUG
    VPVOID   vp;
    DWORD   *psig, cb16;
#endif
    register PTD ptd;


    // get current task's 16bit stack
    ptd = CURRENTPTD();

#ifdef DEBUG
    // Save requested allocation size. Assume it will always be less than 64K
    cb16 = (DWORD)cb;      

    // Add a dword (for signature) to the requested size
    cb += sizeof(DWORD);   

    // Get the current callback sp
    if (ptd->cStackAlloc16 == 0) {
        vp = ptd->vpStack;
    } else {
        vp = ptd->vpCBStack;
    }
#endif

    // grow ss:sp and return this imaginary pointer.
    if (ptd->cStackAlloc16 == 0) {
        ptd->vpCBStack = ptd->vpStack - cb;
    }
    else {
        ptd->vpCBStack -= cb;
    }

#ifdef DEBUG
        // Slide our DWORD signature in after the allocated request
        vp -= sizeof(DWORD);
        GETVDMPTR(vp, sizeof(DWORD), psig);

        // The signature hiword is the offset (sp) we're returning.
        // The signature loword is the requested size.
        *psig = ((ptd->vpCBStack & 0x0000FFFF) << 16) | cb16;
        FLUSHVDMPTR(vp, sizeof(DWORD), psig);
        FREEVDMPTR(psig);
#endif

    ptd->cStackAlloc16++;
    WOW32ASSERT((ptd->cStackAlloc16 >= 1));

    return (VPVOID)ptd->vpCBStack;
}





//*****************************************************************************
//
// StackFree16 -
//
//  Decrements count of memory alloc'd by stackalloc16 
//
//  NOTES:  
//  - This is #define'd as stackfree16(vp,cb) StackFree16(cb) in free builds
//    and stackfree16(vp,cb) StackFree16(vp, cb) in DEBUG builds (wcall16.h)
//  - See stackalloc16() NOTES above
//
//*****************************************************************************
#ifdef DEBUG
VOID FASTCALL StackFree16(VPVOID vp, UINT cb)
#else
VOID FASTCALL StackFree16(UINT cb)
#endif
{
    register PTD ptd;
#ifdef DEBUG
    DWORD  *psig, sig;

    // reconstruct what our signature should be 
    sig = ((vp & 0x0000FFFFF) << 16) | cb;
#endif

    ptd = CURRENTPTD();

    ptd->vpCBStack += cb;

#ifdef DEBUG
    // vpCBStack should now be pointing at our signature.
    GETVDMPTR(ptd->vpCBStack, sizeof(DWORD), psig);

    // you are hitting this assertion for one of the following reasons:
    //  - calls to stackalloc16() & stackfree16() are not properly nested
    //  - the signature got overwritten
    //  - somebody changed ptd->vpCBStack incorrectly
    WOW32ASSERTMSG((*psig == sig), ("WOW::StackFree16 out of synch!!\n"));

    // adjust for the signature DWORD we added to the request
    ptd->vpCBStack += sizeof(DWORD);
#endif

    if(ptd->cStackAlloc16 > 0) {
        ptd->cStackAlloc16--;
    } else { 
        WOW32ASSERTMSG((FALSE), ("WOW::StackFree16:cStackAlloc16 <= 0!\n"));
        ptd->cStackAlloc16 = 0;  // if it was less than 0 somehow
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wcall32.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WCALL32.H
 *  WOW32 16-bit resource support
 *
 *  History:
 *  Created 11-Mar-1991 by Jeff Parsons (jeffpar)
--*/


/* Function prototypes
 */
HANDLE  APIENTRY W32LocalAlloc(UINT dwFlags, UINT dwBytes, HANDLE hInstance);
HANDLE	APIENTRY W32LocalReAlloc(HANDLE hMem, UINT dwBytes, UINT dwFlags, HANDLE hInstance, PVOID* ppv);
LPSTR	APIENTRY W32LocalLock(HANDLE hMem, HANDLE hInstance);
BOOL	APIENTRY W32LocalUnlock(HANDLE hMem, HANDLE hInstance);
DWORD	APIENTRY W32LocalSize(HANDLE hMem, HANDLE hInstance);
HANDLE	APIENTRY W32LocalFree(HANDLE hMem, HANDLE hInstance);
ULONG   APIENTRY W32GetExpWinVer(HANDLE Inst);
DWORD   APIENTRY W32InitDlg(HWND hDlg, LONG lParam);
WORD    APIENTRY W32GlobalAlloc16(UINT uFlags, DWORD dwBytes);
VOID	APIENTRY W32GlobalFree16(WORD selector);
DWORD	WOWRtlGetExpWinVer(HANDLE hmod);
int     APIENTRY W32EditNextWord (LPSZ lpszEditText, int ichCurrentWord,
                                  int cbEditText, int action, DWORD dwProc16);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wcntl32.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WMSG32.C
 *  WOW32 32-bit message thunks
 *
 *  History:
 *  Created 19-Feb-1992 by Chandan Chauhan (ChandanC)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wcntl32.c);

// This function thunks the button control messages,
//
//  BM_GETCHECK
//  BM_SETCHECK
//  BM_GETSTATE
//  BM_SETSTATE
//  BM_SETSTYLE
//

BOOL FASTCALL WM32BMControl(LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - BM_GETCHECK));
    }

    return (TRUE);
}


BOOL FASTCALL WM32BMClick (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WIN31_BM_CLICK);
    }

    return (TRUE);
}



// This function thunks the following edit control messages,
//
//  EM_GETSEL
//  EM_GETMODIFY
//  EM_SETMODIFY
//  EM_GETLINECOUNT
//  EM_GETLINEINDEX
//  EM_LINELENGTH
//  EM_LIMITTEX
//  EM_CANUNDO
//  EM_UNDO
//  EM_FMTLINES
//  EM_LINEFROMCHAR
//  EM_SETPASSWORDCHAR
//  EM_EMPTYUNDOBUFFER

BOOL FASTCALL WM32EMControl(LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
    }

    return (TRUE);
}


// This function thunks the button control messages,
//
//  EM_SETSEL
//

BOOL FASTCALL WM32EMSetSel (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        LOW(lpwm32mpex->Parm16.WndProc.lParam) = (WORD) lpwm32mpex->uParam;
        HIW(lpwm32mpex->Parm16.WndProc.lParam) = (WORD)
                    ((lpwm32mpex->lParam != -1) ? lpwm32mpex->lParam :  32767);
    }

    return (TRUE);
}


// This function thunks the edit control messages,
//
//  EM_GETRECT
//

BOOL FASTCALL WM32EMGetRect (LPWM32MSGPARAMEX lpwm32mpex)
{
    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        lpwm32mpex->Parm16.WndProc.lParam = malloc16(sizeof(RECT16));
        if (!(lpwm32mpex->Parm16.WndProc.lParam))
            return FALSE;
    } else {
        GETRECT16( lpwm32mpex->Parm16.WndProc.lParam, (LPRECT)lpwm32mpex->lParam );
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    return (TRUE);
}


// This function thunks the edit control messages,
//
//  EM_SETRECT
//  EM_SETRECTNP
//

BOOL FASTCALL WM32EMSetRect (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        lpwm32mpex->Parm16.WndProc.lParam = malloc16(sizeof(RECT16));
        if (!(lpwm32mpex->Parm16.WndProc.lParam))
            return FALSE;
        PUTRECT16( lpwm32mpex->Parm16.WndProc.lParam, (LPRECT)lpwm32mpex->lParam );
    } else {
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    return (TRUE);
}


// This function thunks the edit control messages,
//
//  EM_LINESCROLL
//

BOOL FASTCALL WM32EMLineScroll (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        LOW(lpwm32mpex->Parm16.WndProc.lParam) = (WORD) lpwm32mpex->lParam;
        HIW(lpwm32mpex->Parm16.WndProc.lParam) = (WORD) lpwm32mpex->uParam;
    }

    return (TRUE);
}


// This function thunks the edit control messages,
//
//  EM_REPLACESEL
//

BOOL FASTCALL WM32EMReplaceSel (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        if (lpwm32mpex->lParam) {
            INT cb;

            cb = strlen((LPSZ)lpwm32mpex->lParam)+1;
            lpwm32mpex->dwTmp[0] = (DWORD)cb; // save allocation size

            // winworks2.0a requires DS based string pointers for this message

            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_DSBASEDSTRINGPOINTERS) {

                // be sure allocation size matches stackfree16() size below
                lpwm32mpex->Parm16.WndProc.lParam = stackalloc16(cb);

            } else {
                lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
            }

            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;
            putstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, cb);
        }
    } else {
        if (lpwm32mpex->Parm16.WndProc.lParam) {
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_DSBASEDSTRINGPOINTERS) {

                stackfree16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam,
                            ((UINT)lpwm32mpex->dwTmp[0]));
            } else {
                free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
            }
        }
    }

    return (TRUE);
}


BOOL FASTCALL WM32EMSetFont (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
    }

    LOGDEBUG(0,(" Window %08lX is receiving Control Message %s(%08x)\n", lpwm32mpex->hwnd, (LPSZ)GetWMMsgName(lpwm32mpex->uMsg), lpwm32mpex->uMsg));
    return (TRUE);
}


// This function thunks the edit control messages,
//
//  EM_GETLINE
//

BOOL FASTCALL WM32EMGetLine (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        if (lpwm32mpex->lParam) {
            INT cb;
            PBYTE lp;

            // the first WORD is what USER uses.

            cb = *(UNALIGNED WORD *)(lpwm32mpex->lParam);
            lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;
            ALLOCVDMPTR(lpwm32mpex->Parm16.WndProc.lParam,2,lp);
            *((UNALIGNED WORD *)lp) = (WORD)cb;
            FLUSHVDMPTR(lpwm32mpex->Parm16.WndProc.lParam,2,lp);  /* first 2 bytes modified */
        }
    } else {
        if (lpwm32mpex->Parm16.WndProc.lParam) {
            PBYTE lp;

            GETMISCPTR(lpwm32mpex->Parm16.WndProc.lParam,lp);
            RtlCopyMemory((PBYTE)lpwm32mpex->lParam,lp,lpwm32mpex->lReturn);
            FREEVDMPTR(lp);
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
        }
    }

    LOGDEBUG(3,(" Window %08lX is receiving Control Message %s(%08x)\n", lpwm32mpex->hwnd, (LPSZ)GetWMMsgName(lpwm32mpex->uMsg), lpwm32mpex->uMsg));

    return (TRUE);
}


BOOL FASTCALL WM32EMSetWordBreakProc (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));

        // take out the marker bits and fix the RPL bits
        UnMarkWOWProc (lpwm32mpex->lParam,lpwm32mpex->Parm16.WndProc.lParam);

        LOGDEBUG(3,(" Window %08lX is receiving Control Message %s(%08x)\n", lpwm32mpex->hwnd, (LPSZ)GetWMMsgName(lpwm32mpex->uMsg), lpwm32mpex->uMsg));
    }

    return (TRUE);
}


BOOL FASTCALL WM32EMGetWordBreakProc (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        LOGDEBUG(3,(" Window %08lX is receiving Control Message %s(%08x)\n", lpwm32mpex->hwnd, (LPSZ)GetWMMsgName(lpwm32mpex->uMsg), lpwm32mpex->uMsg));
    }
    else {

        // Mark the address as WOW Proc and store the high bits in the RPL field
        MarkWOWProc (lpwm32mpex->lReturn,lpwm32mpex->lReturn);
    }


    return (TRUE);
}


// This function thunks the edit control messages,
//
//  EM_SETTABSTOPS
//

BOOL FASTCALL WM32EMSetTabStops (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        if (lpwm32mpex->uParam != 0) {
            lpwm32mpex->Parm16.WndProc.lParam = malloc16(lpwm32mpex->uParam * sizeof(WORD));
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;
            putintarray16((VPINT16)lpwm32mpex->Parm16.WndProc.lParam, (INT)lpwm32mpex->uParam, (LPINT)lpwm32mpex->lParam);
        }
    } else {
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);

    }

    return (TRUE);
}


// This function thunks the following combo box control messages,
//
//  CB_GETEDITSEL
//  CB_LIMITTEXT
//  CB_SETEDITSEL
//  CB_DELETESTRING
//  CB_GETCOUNT
//  CB_GETCURSEL
//  CB_GETLBTEXTLEN
//  CB_SETCURSEL
//  CB_SHOWDROPDOWN
//  CB_GETITEMDATA
//  CB_SETITEMDATA


BOOL FASTCALL  WM32CBControl (LPWM32MSGPARAMEX lpwm32mpex)
{


    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - CB_GETEDITSEL));
    }

    return (TRUE);
}


// This function thunks the following combo box control messages,
//
//  CB_ADDSTRING
//  CB_INSERTSTRING
//  CB_FINDSTRING
//  CB_SELECTSTRING

BOOL FASTCALL  WM32CBAddString (LPWM32MSGPARAMEX lpwm32mpex)
{
    PWW pww;




    if ( lpwm32mpex->fThunk ) {
        if (!(pww = lpwm32mpex->pww)) {
            if (pww = FindPWW (lpwm32mpex->hwnd))
                lpwm32mpex->pww = pww;
            else
                return FALSE;
        }

        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - CB_GETEDITSEL));

        //
        // Determine if this combobox has string pointers or handles passed
        // in with CB_ADDSTRING messages.  Normal comboboxes have string
        // pointers passed.  Owner-draw comboboxes that don't have the
        // CBS_HASSTRINGS style bit set have handles passed in.  These handles
        // are simply passed back to the owner at paint time.  If the
        // CBS_HASSTRINGS style bit is set, strings are used instead of
        // handles as the "cookie" which is passed back to the application
        // at paint time.
        //
        // We treat lpwm32mpex->dwParam as a BOOL indicating this combobox
        // takes handles instead of strings.
        //

        lpwm32mpex->dwParam =
            (pww->style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)) &&
            !(pww->style & CBS_HASSTRINGS);

        if ( !lpwm32mpex->dwParam ) {        // if strings are used
            if (lpwm32mpex->lParam) {
                INT cb;

                cb = strlen((LPSZ)lpwm32mpex->lParam)+1;
                lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
                if (!(lpwm32mpex->Parm16.WndProc.lParam))
                    return FALSE;
                putstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, cb);
            }
        }
    } else {
        if ( !lpwm32mpex->dwParam ) {        // if strings are used
            if (lpwm32mpex->Parm16.WndProc.lParam) {
                getstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, -1);
                free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
            }
        }
    }

    LOGDEBUG(3,(" Window %08lX is receiving Control Message %s(%08x)\n", lpwm32mpex->hwnd, (LPSZ)GetWMMsgName(lpwm32mpex->uMsg), lpwm32mpex->uMsg));

    return(TRUE);

}


// This function thunks the following combo box control messages,
//
//  CB_DIR
//
//  Code in this routine references code in wparam.c in order to circumvent
//  copying memory to 16-bit memory space.
//  GetParam16 verifies that the parameter we get (lparam) had not originated
//  in 16-bit code. If it did come from 16-bit code, then we send an original
//  16:16 pointer to the application.
//  This fixes PagePlus 3.0 application and (if implemented on a broader scale)
//  will positively affect performance of applications which send a lot of
//  standard messages and use subclassing a lot.
//  -- VadimB

BOOL FASTCALL  WM32CBDir (LPWM32MSGPARAMEX lpwm32mpex)
{
    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - CB_GETEDITSEL));
        if (lpwm32mpex->lParam) {
            INT cb;

            if (W32CheckThunkParamFlag()) {
                LONG lParam = (LONG)GetParam16(lpwm32mpex->lParam);
                if (lParam) {
                    lpwm32mpex->Parm16.WndProc.lParam = lParam;
                    return (TRUE);
                }
            }

            cb = strlen((LPSZ)lpwm32mpex->lParam)+1;
            lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;
            putstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, cb);
        }
    } else {
        if (W32CheckThunkParamFlag()) {
            if (DeleteParamMap(lpwm32mpex->Parm16.WndProc.lParam, PARAM_16, NULL)) {
                return TRUE;
            }
        }
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    return(TRUE);
}


// This function thunks the following combo box control messages,
//
//  CB_GETLBTEXT

BOOL FASTCALL WM32CBGetLBText (LPWM32MSGPARAMEX lpwm32mpex)
{
    PWW   pww;



    if ( lpwm32mpex->fThunk ) {
        INT cb;

        if (!(pww = lpwm32mpex->pww)) {
            if (pww = FindPWW (lpwm32mpex->hwnd))
                lpwm32mpex->pww = pww;
            else
                return FALSE;
        }

        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - CB_GETEDITSEL));

        //
        // Determine if this combobox has string pointers or handles passed
        // in with CB_ADDSTRING messages.  Normal comboboxes have string
        // pointers passed.  Owner-draw comboboxes that don't have the
        // CBS_HASSTRINGS style bit set have handles passed in.  These handles
        // are simply passed back to the owner at paint time.  If the
        // CBS_HASSTRINGS style bit is set, strings are used instead of
        // handles as the "cookie" which is passed back to the application
        // at paint time.
        //
        // We treat lpwm32mpex->dwParam as a BOOL indicating this combobox
        // takes handles instead of strings.
        //

        lpwm32mpex->dwParam =
            (pww->style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)) &&
            !(pww->style & CBS_HASSTRINGS);

        //
        // Determine the size of the buffer to allocate on the 16-bit side
        // to receive the text.
        //

        if (lpwm32mpex->dwParam) {           // if handles are used
            cb = 4;
        } else {
            cb = SendMessage(lpwm32mpex->hwnd, CB_GETLBTEXTLEN, lpwm32mpex->uParam, 0);
            if (cb == CB_ERR) {
                //
                // lpwm32mpex->dwTmp[0] is initialized to 0 so that nothing
                // gets copied to the buffer by getstr16() while unthunking
                // this message.
                //
                // bug # 24415, ChandanC
                //

                cb = SIZE_BOGUS;
                lpwm32mpex->dwTmp[0] = 0;
            }
            else {
                //
                // Add one for NULL character.
                //
                cb = cb + 1;
                (INT) lpwm32mpex->dwTmp[0] = (INT) -1;
            }
        }
        if (lpwm32mpex->lParam) {
            BYTE *lpT;

            // See comment on similar code below

            lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;
            GETVDMPTR((lpwm32mpex->Parm16.WndProc.lParam), sizeof(BYTE), lpT);
            *lpT = 0;
            FREEVDMPTR(lpT);
        }
    }
    else {
        if (lpwm32mpex->lParam && lpwm32mpex->Parm16.WndProc.lParam) {
            if (lpwm32mpex->dwParam) {       // if handles are used
                UNALIGNED DWORD *lpT;
                GETVDMPTR((lpwm32mpex->Parm16.WndProc.lParam), sizeof(DWORD), lpT);
                *(UNALIGNED DWORD *)lpwm32mpex->lParam = *lpT;
                FREEVDMPTR(lpT);
            }
            else {
                getstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam,
                         (INT) lpwm32mpex->dwTmp[0]);
            }

            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);

        }
    }

    return(TRUE);
}


// This function thunks the following combo box control messages,
//
//  CB_GETDROPPEDCONTROLRECT

BOOL FASTCALL WM32CBGetDropDownControlRect (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - CB_GETEDITSEL));
        lpwm32mpex->Parm16.WndProc.lParam = malloc16(sizeof(RECT16));
        if (!(lpwm32mpex->Parm16.WndProc.lParam))
            return FALSE;
    } else {
        GETRECT16( lpwm32mpex->Parm16.WndProc.lParam, (LPRECT)lpwm32mpex->lParam );
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    return(TRUE);
}


// This function thunks the following combo box control messages,
//
//  CBEC_SETCOMBOFOCUS           (WM_USER+CB_MSGMAX+1)
//  CBEC_KILLCOMBOFOCUS          (WM_USER+CB_MSGMAX+2)
// These undocumented messages are used by Excel 5.0
//

BOOL FASTCALL  WM32CBComboFocus (LPWM32MSGPARAMEX lpwm32mpex)
{
#if (CBEC_SETCOMBOFOCUS != 0x166)
#error The USER Guys changed CBEC_SETCOMBOFOCUS again
#endif

#if (CBEC_KILLCOMBOFOCUS != 0x167)
#error The USER Guys changed CBEC_KILLCOMBOFOCUS again
#endif    

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg =
                (WORD)((lpwm32mpex->uMsg-CBEC_SETCOMBOFOCUS) + OLDCBEC_SETCOMBOFOCUS);
    }

    return (TRUE);
}


// This function thunks the list box control messages
//
//  LB_RESETCONTENT
//  LB_SETCURSEL
//  LB_GETSEL
//  LB_GETCURSEL
//  LB_GETTEXTLEN
//  LB_GETCOUNT
//  LB_GETCARETINDEX
//  LB_GETTOPINDEX
//  LB_GETSELCOUNT
//  LB_GETHORIZONTALEXTENT
//  LB_SETHORIZONTALEXTENT
//  LB_SETCOLUMNWIDTH
//  LB_SETTOPINDEX
//  LB_SETCARETINDEX
//  LB_SETITEMDATA
//  LB_SELITEMRANGE
//  LB_SETITEMHEIGHT
//  LB_GETITEMHEIGHT
//  LB_DELETESTRING
//

BOOL FASTCALL  WM32LBControl (LPWM32MSGPARAMEX lpwm32mpex)
{


    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));
    }

    return (TRUE);
}

// This function thunks the list box control messages
//
//  LB_GETTEXT

BOOL FASTCALL WM32LBGetText (LPWM32MSGPARAMEX lpwm32mpex)
{
    PWW   pww;



    if ( lpwm32mpex->fThunk ) {
        INT cb;

        if (!(pww = lpwm32mpex->pww)) {
            if (pww = FindPWW (lpwm32mpex->hwnd))
                lpwm32mpex->pww = pww;
            else
                return FALSE;
        }

        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));

        //
        // Determine if this listbox has string pointers or handles passed
        // in with LB_ADDSTRING messages.  Owner-draw listboxes that don't
        // have the LBS_HASSTRINGS style bit set have handles passed in.
        // These handles are simply passed back to the owner at paint time.
        // If the LBS_HASSTRINGS style bit is set, strings are used instead of
        // handles as the "cookie" which is passed back to the application
        // at paint time.
        //
        // We treat lpwm32mpex->dwParam as a BOOL indicating this listbox
        // takes handles instead of strings.
        //

        lpwm32mpex->dwParam =
            (pww->style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)) &&
            !(pww->style & LBS_HASSTRINGS);

        if (lpwm32mpex->dwParam) {    // if this listbox takes handles
            cb = 4;
        }
        else {
            cb = SendMessage(lpwm32mpex->hwnd, LB_GETTEXTLEN, lpwm32mpex->uParam, 0);

            // Check for LB_ERR (which is -1) on the above SendMessage().
            // When cb is equal to LB_ERR make the size as SIZE_BOGUS (256 bytes),
            // and allocate a buffer just in case if the app diddles the lParam.
            // We will free the buffer while unthunking the message (LB_GETTEXT).
            // This fix makes the app MCAD happy.
            // ChandanC 4-21-93.

            if (cb == LB_ERR) {
                cb = SIZE_BOGUS;
            }
            else {
                //
                // Add one for NULL character.
                //
                cb = cb + 1;
            }

        }

        if (lpwm32mpex->lParam) {
            BYTE *lpT;

            lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;

            // The reason for this code to be here is that sometimes thunks
            // are executed on a buffer that has not been initialized, e.g.
            // if the hooks are installed by a wow app. That means we will
            // alloc 16-bit buffer while thunking (boils down to uninitialized
            // data buffer and will try to copy the buffer back while unthunking
            // overwriting the stack sometimes (as user allocates temp bufs from
            // the stack). This code initializes data so problem is avoided
            // App: Grammatik/Windows v6.0 -- VadimB

            GETVDMPTR((lpwm32mpex->Parm16.WndProc.lParam), sizeof(BYTE), lpT);
            *lpT = 0;
            FREEVDMPTR(lpT);
        }
    }
    else {

        if ((lpwm32mpex->lReturn != LB_ERR) && lpwm32mpex->lParam && lpwm32mpex->Parm16.WndProc.lParam) {
            if (lpwm32mpex->dwParam) {   // if this listbox takes handles
                UNALIGNED DWORD *lpT;
                GETVDMPTR((lpwm32mpex->Parm16.WndProc.lParam), sizeof(DWORD), lpT);
                *(UNALIGNED DWORD *)lpwm32mpex->lParam = *lpT;
                FREEVDMPTR(lpT);
            }
            else {
                getstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, -1);
            }
        }

        if (lpwm32mpex->Parm16.WndProc.lParam) {
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
        }
    }

    return(TRUE);
}

// This function thunks the list box control messages
//
//  LB_GETTEXTLEN

BOOL FASTCALL  WM32LBGetTextLen (LPWM32MSGPARAMEX lpwm32mpex)
{


    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));

        // USER32 and so do we send the LB_GETTEXTLEN message whenever an
        // LB_GETTEXT message is sent. This LB_GETTEXTLEN message is an
        // additional message that an app normally wouldn't see in WIN31.
        // lParam by definition is NULL.
        //
        // Super Project dies (at times) when it receives the LB_GETTEXTLEN
        // message. It doesn't expect to see this message and as a result does
        // strlen(lParam) and dies.
        //                                               - nanduri

        if (CURRENTPTD()->dwWOWCompatFlags &  WOWCF_LB_NONNULLLPARAM) {

            // be sure allocation size matches stackfree16() size below
            LPBYTE lpT = (LPBYTE)stackalloc16(0x2);  // just an even number

            lpwm32mpex->Parm16.WndProc.lParam = (LONG)lpT;
            GETVDMPTR(lpT, 0x2, lpT);
            *lpT = '\0';
        }
    } else {
        if (CURRENTPTD()->dwWOWCompatFlags &  WOWCF_LB_NONNULLLPARAM) {
            if(lpwm32mpex->Parm16.WndProc.lParam) {
                stackfree16((VPVOID)lpwm32mpex->Parm16.WndProc.lParam, 0x2);
            }
        }
    }

    return (TRUE);
}



// This function thunks the list box control messages
//
//  LB_DIR

BOOL FASTCALL WM32LBDir (LPWM32MSGPARAMEX lpwm32mpex)
{
    INT cb;
    VPVOID vp;


    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));
        if (lpwm32mpex->lParam) {
            cb = strlen((LPSTR)lpwm32mpex->lParam)+1;
            if (!(vp = malloc16(cb))) {
                LOGDEBUG(0,(" WOW32.DLL : WM32LBDir() :: Could not allocate memory for string, ChandanC\n"));
                WOW32ASSERT(vp);
                return FALSE;
            }
            putstr16(vp, (LPSTR) lpwm32mpex->lParam, cb);
            lpwm32mpex->Parm16.WndProc.lParam = vp;
        }
    }
    else {
        if (lpwm32mpex->Parm16.WndProc.lParam) {
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
        }
    }

    return(TRUE);
}

// This function thunks the list box control messages
//
//  LB_GETSELITEMS

BOOL FASTCALL WM32LBGetSelItems (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));
        if (lpwm32mpex->lParam) {
            INT cb;

            cb = lpwm32mpex->uParam * sizeof(WORD);
            lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;

        }
    } else {
        getintarray16((VPRECT16)lpwm32mpex->Parm16.WndProc.lParam, (INT)lpwm32mpex->uParam, (LPINT)lpwm32mpex->lParam);
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    return(TRUE);
}


// This function thunks the list box control messages
//
//  LB_SETTABSTOPS

BOOL FASTCALL WM32LBSetTabStops (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));
        if (lpwm32mpex->uParam != 0) {
            lpwm32mpex->Parm16.WndProc.lParam = malloc16(lpwm32mpex->uParam * sizeof(WORD));
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;
            putintarray16((VPRECT16)lpwm32mpex->Parm16.WndProc.lParam, (INT)lpwm32mpex->uParam, (LPINT)lpwm32mpex->lParam);
        }
    } else {
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    return(TRUE);
}

// This function thunks the list box control messages
//
//  LB_GETITEMRECT

BOOL FASTCALL WM32LBGetItemRect (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));
        lpwm32mpex->Parm16.WndProc.lParam = malloc16(sizeof(RECT16));
        if (!(lpwm32mpex->Parm16.WndProc.lParam))
            return FALSE;
    } else {
        GETRECT16( lpwm32mpex->Parm16.WndProc.lParam, (LPRECT)lpwm32mpex->lParam );
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    LOGDEBUG(3,(" Window %08lX is receiving Control Message %s(%08x)\n", lpwm32mpex->hwnd, (LPSZ)GetWMMsgName(lpwm32mpex->uMsg), lpwm32mpex->uMsg));

    return(TRUE);

}


// This function thunks the list box control messages
//
//  LB_ADDSTRING
//  LB_INSERTSTRING
//  LB_FINDSTRING
//  LB_SELECTSTRING

BOOL FASTCALL WM32LBAddString (LPWM32MSGPARAMEX lpwm32mpex)
{
    PWW   pww;


    if ( lpwm32mpex->fThunk ) {
        if (!(pww = lpwm32mpex->pww)) {
            if (pww = FindPWW (lpwm32mpex->hwnd))
                lpwm32mpex->pww = pww;
            else
                return FALSE;
        }

        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));

        //
        // Determine if this listbox has string pointers or handles passed
        // in with LB_ADDSTRING messages.  Owner-draw listboxes that don't
        // have the LBS_HASSTRINGS style bit set have handles passed in.
        // These handles are simply passed back to the owner at paint time.
        // If the LBS_HASSTRINGS style bit is set, strings are used instead of
        // handles as the "cookie" which is passed back to the application
        // at paint time.
        //
        // We treat lpwm32mpex->dwParam as a BOOL indicating this listbox
        // takes handles instead of strings.
        //

        lpwm32mpex->dwParam =
            (pww->style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)) &&
            !(pww->style & LBS_HASSTRINGS);

        if ( !lpwm32mpex->dwParam ) {   // if this listbox takes strings
            if (lpwm32mpex->lParam) {
                INT cb;

                cb = strlen((LPSZ)lpwm32mpex->lParam)+1;
                lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
                if (!(lpwm32mpex->Parm16.WndProc.lParam))
                    return FALSE;
                putstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, cb);
            }
        }
    } else {
        if ( !lpwm32mpex->dwParam ) {   // if this listbox takes strings
            if (lpwm32mpex->Parm16.WndProc.lParam) {
                getstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, -1);
                free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
            }
        }
    }

    return(TRUE);
}

// This function thunks the scrollbar control messages,
//
//  SBM_SETPOS
//  SBM_GETPOS
//  SBM_ENABLE_ARROWS
//

BOOL FASTCALL WM32SBMControl (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = WM_USER + (lpwm32mpex->uMsg - SBM_SETPOS);
    }

    return (TRUE);
}


//  SBM_GETRANGE

BOOL FASTCALL WM32SBMGetRange (LPWM32MSGPARAMEX lpwm32mpex)
{
    //
    // Changed semantics for this message to support 32-bit
    // scroll bar ranges (vs. 16-bit).
    //
    // Win16:
    //   posMin = LOWORD(SendMessage(hwnd, SBM_GETRANGE, 0, 0));
    //   posMax = HIWORD(SendMessage(hwnd, SBM_GETRANGE, 0, 0));
    //
    // Win32:
    //   SendMessage(hwnd, SBM_GETRANGE,
    //               (WPARAM) &posMin, (LPARAM) &posMax);
    //

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = OLDSBM_GETRANGE;
    } else {
        *(DWORD *)lpwm32mpex->uParam = INT32(LOWORD(lpwm32mpex->lReturn));
        *(DWORD *)lpwm32mpex->lParam = INT32(HIWORD(lpwm32mpex->lReturn));
        lpwm32mpex->lReturn = 0;
    }

    return (TRUE);
}


//  SBM_SETRANGE
//  SBM_SETRANGEREDRAW (new for Win32)

BOOL FASTCALL WM32SBMSetRange (LPWM32MSGPARAMEX lpwm32mpex)
{

    //
    // Changed semantics to support 32-bit scroll bar range:
    //
    // Win16:
    //   SendMessage(hwnd, SBM_SETRANGE, fRedraw, MAKELONG(posMin, posMax);
    //
    // Win32:
    //   SendMessage(hwnd, fRedraw ? SBM_SETRANGE : SBM_SETRANGEREDRAW,
    //               posMin, posMax);
    //

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg   = OLDSBM_SETRANGE;
        lpwm32mpex->Parm16.WndProc.wParam = (SBM_SETRANGEREDRAW == lpwm32mpex->uMsg);
        lpwm32mpex->Parm16.WndProc.lParam = MAKELONG( (WORD)lpwm32mpex->uParam, (WORD)lpwm32mpex->lParam);
    }

    return (TRUE);
}


//  LB_SETSEL

BOOL FASTCALL  WM32LBSetSel (LPWM32MSGPARAMEX lpwm32mpex)
{


    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));
        lpwm32mpex->Parm16.WndProc.wParam = (WORD) lpwm32mpex->uParam;
        lpwm32mpex->Parm16.WndProc.lParam = (WORD)lpwm32mpex->lParam;  // loword = index, hiword = 0
    }

    return (TRUE);
}


// This function thunks the static control messages,
//
//  STM_SETICON
//  STM_GETICON
//

BOOL FASTCALL WM32STMControl (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        switch (lpwm32mpex->uMsg) {
            case STM_SETICON:
                lpwm32mpex->Parm16.WndProc.wParam = (WORD)GETHICON16(lpwm32mpex->uParam);
                break;

            case STM_GETICON:
                break;

        }
        lpwm32mpex->Parm16.WndProc.wMsg = WM_USER + (lpwm32mpex->uMsg - STM_SETICON);
    }
    else {
        lpwm32mpex->lReturn = (LONG)HICON32(lpwm32mpex->lReturn);
    }


    return (TRUE);
}


// This function thunks the messages,
//
// MN_FINDMENUWINDOWFROMPOINT
//

// NT -    wparam = (PUINT)pitem  lParam = MAKELONG(pt.x, pt.y)
//         returns flags or hwnd    *pitem = index or -1
//
// win31   wParam = 0   lParam = same
//         returns 0 or MAKELONG(-1, item) or MAKELONG(-2, item) or MAKELONG(hwnd, item)


BOOL FASTCALL WM32MNFindMenuWindow (LPWM32MSGPARAMEX lpwm32mpex)
{
    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = WIN30_MN_FINDMENUWINDOWFROMPOINT;
        lpwm32mpex->Parm16.WndProc.wParam = 0;

    } else {
        USHORT n =  LOWORD(lpwm32mpex->lReturn);

        *(PLONG)lpwm32mpex->uParam = (SHORT)HIWORD(lpwm32mpex->lReturn);
        lpwm32mpex->lReturn = (LONG)HWND32(n);  // this sign-extends -1, -2 and leaves 0 as 0
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wcommdlg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    wcomdlg.c

Abstract:

    32-bit support for thunking COMMDLG in WOW

Author:

    John Vert (jvert) 31-Dec-1992

Revision History:

    John Vert (jvert) 31-Dec-1992
        created

--*/
#include "precomp.h"
#pragma   hdrstop
#include <cderr.h>
#include <dlgs.h>
#include <wowcmndg.h>

MODNAME(wcommdlg.c);

//
// Debugging stuff...
//
#if DEBUG
void WCDDumpCHOOSECOLORData16(PCHOOSECOLORDATA16 p16);
void WCDDumpCHOOSECOLORData32(CHOOSECOLOR *p32);
void WCDDumpCHOOSEFONTData16(PCHOOSEFONTDATA16 p16);
void WCDDumpCHOOSEFONTData32(CHOOSEFONT *p32);
void WCDDumpFINDREPLACE16(PFINDREPLACE16 p16);
void WCDDumpFINDREPLACE32(FINDREPLACE *p32);
void WCDDumpOPENFILENAME16(POPENFILENAME16 p16);
void WCDDumpOPENFILENAME32(OPENFILENAME *p32);
void WCDDumpPRINTDLGData16(PPRINTDLGDATA16 p16);
void WCDDumpPRINTDLGData32(PRINTDLG *p32);

// macros to dump the 16 & 32 bit structs
#define WCDDUMPCHOOSECOLORDATA16(p16)  WCDDumpCHOOSECOLORData16(p16)

#define WCDDUMPCHOOSECOLORDATA32(p32)  WCDDumpCHOOSECOLORData32(p32)

#define WCDDUMPCHOOSEFONTDATA16(p16)   WCDDumpCHOOSEFONTData16(p16)

#define WCDDUMPCHOOSEFONTDATA32(p32)   WCDDumpCHOOSEFONTData32(p32)

#define WCDDUMPFINDREPLACE16(p16)      WCDDumpFINDREPLACE16(p16)

#define WCDDUMPFINDREPLACE32(p32)      WCDDumpFINDREPLACE32(p32)

#define WCDDUMPOPENFILENAME16(p16)     WCDDumpOPENFILENAME16(p16)

#define WCDDUMPOPENFILENAME32(p32)     WCDDumpOPENFILENAME32(p32)

#define WCDDUMPPRINTDLGDATA16(p16)     WCDDumpPRINTDLGData16(p16)

#define WCDDUMPPRINTDLGDATA32(p32)     WCDDumpPRINTDLGData32(p32)

#else // !DEBUG

#define WCDDUMPCHOOSECOLORDATA16(p16)
#define WCDDUMPCHOOSECOLORDATA32(p32)
#define WCDDUMPCHOOSEFONTDATA16(p16)
#define WCDDUMPCHOOSEFONTDATA32(p32)
#define WCDDUMPOPENFILENAME16(p16)
#define WCDDUMPOPENFILENAME32(p32)
#define WCDDUMPPRINTDLGDATA16(p16)
#define WCDDUMPPRINTDLGDATA32(p32)
#define WCDDUMPFINDREPLACE16(p16)
#define WCDDUMPFINDREPLACE32(p32)

#endif  // !DEBUG




// global data
WORD msgCOLOROK        = 0;
WORD msgFILEOK         = 0;
WORD msgWOWLFCHANGE    = 0;
WORD msgWOWDIRCHANGE   = 0;
WORD msgWOWCHOOSEFONT  = 0;
WORD msgSHAREVIOLATION = 0;
WORD msgFINDREPLACE    = 0;

/* external global stuff */
extern WORD gwKrnl386CodeSeg1;
extern WORD gwKrnl386CodeSeg2;
extern WORD gwKrnl386CodeSeg3;
extern WORD gwKrnl386DataSeg1;


ULONG dwExtError = 0;
#define SETEXTENDEDERROR(Code) (dwExtError=Code)

/*+++ For reference only -- which flags are set on output
#define FR_OUTPUTFLAGS (FR_DOWN          | FR_WHOLEWORD     | FR_MATCHCASE  | \
                        FR_FINDNEXT      | FR_REPLACE       | FR_REPLACEALL | \
                        FR_DIALOGTERM    | FR_SHOWHELP      | FR_NOUPDOWN   | \
                        FR_NOMATCHCASE   | FR_NOWHOLEWORD   | FR_HIDEUPDOWN | \
                        FR_HIDEMATCHCASE | FR_HIDEWHOLEWORD)

#define PD_OUTPUTFLAGS (PD_ALLPAGES    | PD_COLLATE    | PD_PAGENUMS | \
                        PD_PRINTTOFILE | PD_SELECTION)

#define FO_OUTPUTFLAGS (OFN_READONLY | OFN_EXTENSIONDIFFERENT)

#define CF_OUTPUTFLAGS (CF_NOFACESEL | CF_NOSIZESEL | CF_NOSTYLESEL)
---*/


// private typedefs and structs
typedef BOOL (APIENTRY* FILENAMEPROC)(LPOPENFILENAME);
typedef HWND (APIENTRY* FINDREPLACEPROC)(LPFINDREPLACE);


// exported by comdlg32.dll to allow us to ultimately keep 16-bit common dialog
// structs in sync with the UNICODE version maintained by comdlg32.
extern VOID Ssync_ANSI_UNICODE_Struct_For_WOW(HWND  hDlg,
                                              BOOL  fANSI_To_UNICODE,
                                              DWORD dwID);

// private function prototypes
VOID
Thunk_OFNstrs16to32(IN OPENFILENAME    *pOFN32,
                    IN POPENFILENAME16  pOFN16);

BOOL
Alloc_OFN32_strs(IN OPENFILENAME    *pOFN32,
                 IN POPENFILENAME16  pOFN16);

VOID
Free_OFN32_strs(IN OPENFILENAME *pOFN32);

PCOMMDLGTD
GetCommdlgTd(IN HWND Hwnd32);

HINSTANCE
ThunkCDTemplate16to32(IN     HAND16  hInst16,
                      IN     DWORD   hPrintTemp16,
                      IN     VPVOID  vpTemplateName,
                      IN     DWORD   dwFlags16,
                      IN OUT DWORD  *pFlags,
                      IN     DWORD   ETFlag,
                      IN     DWORD   ETHFlag,
                      OUT    PPRES   pRes,
                      OUT    PBOOL   fError);

VOID
FreeCDTemplate32(IN PRES      pRes,
                 IN HINSTANCE hInst,
                 IN BOOL      bETFlag,
                 IN BOOL      bETHFlag);

PRES
GetTemplate16(IN HAND16  hInstance,
              IN VPCSTR  TemplateName,
              IN BOOLEAN UseHandle);


HGLOBAL
ThunkhDevMode16to32(IN HAND16 hDevMode16);

VOID
ThunkhDevMode32to16(IN OUT HAND16 *phDevMode16,
                    IN     HANDLE  hDevMode32);

HANDLE
ThunkhDevNames16to32(IN HAND16 hDevNames16);

VOID
ThunkhDevNames32to16(IN OUT HAND16 *phDevNames16,
                     IN     HANDLE  hDevNames);

VOID
ThunkCHOOSECOLOR16to32(OUT CHOOSECOLOR         *pCC32,
                       IN  PCHOOSECOLORDATA16   pCC16);

VOID
ThunkCHOOSECOLOR32to16(OUT PCHOOSECOLORDATA16  pCC16,
                       IN  CHOOSECOLOR        *pCC32);

VOID
ThunkCHOOSEFONT16to32(OUT CHOOSEFONT        *pCF32,
                      IN  PCHOOSEFONTDATA16  pCF16);

VOID
ThunkCHOOSEFONT32to16(OUT PCHOOSEFONTDATA16  pCF16,
                      IN  CHOOSEFONT        *pCF32);

VOID
ThunkFINDREPLACE16to32(OUT FINDREPLACE    *pFR32,
                       IN  PFINDREPLACE16  pFR16);

VOID
ThunkFINDREPLACE32to16(OUT PFINDREPLACE16  pFR16,
                       IN  FINDREPLACE    *pFR32);

BOOL
ThunkOPENFILENAME16to32(OUT OPENFILENAME    *pOFN32,
                        IN  POPENFILENAME16  pOFN16);

VOID
ThunkOPENFILENAME32to16(OUT POPENFILENAME16  pOFN16,
                        IN  OPENFILENAME    *pOFN32,
                        IN  BOOLEAN          bUpperStrings);

VOID
ThunkPRINTDLG16to32(OUT PRINTDLG        *pPD32,
                    IN  PPRINTDLGDATA16  pPD16);

VOID
ThunkPRINTDLG32to16(IN  VPVOID    vppd,
                    OUT PRINTDLG *pPD32);

VOID
ThunkCDStruct16to32(IN HWND         hDlg,
                    IN CHOOSECOLOR *pCC,
                    IN VPVOID       vp);

VOID
ThunkCDStruct32to16(IN HWND         hDlg,
                    IN VPVOID       vp,
                    IN CHOOSECOLOR *pCC);

UINT APIENTRY
WCD32CommonDialogProc(HWND       hdlg,
                      UINT       uMsg,
                      WPARAM     uParam,
                      LPARAM     lParam,
                      PCOMMDLGTD pCTD,
                      VPVOID     vpfnHook);

UINT APIENTRY
WCD32PrintSetupDialogProc(HWND   hdlg,
                          UINT   uMsg,
                          WPARAM uParam,
                          LPARAM lParam);

UINT APIENTRY
WCD32DialogProc(HWND   hdlg,
                UINT   uMsg,
                WPARAM uParam,
                LPARAM lParam);

ULONG
WCD32GetFileName(IN PVDMFRAME    pFrame,
                 IN FILENAMEPROC Function);

ULONG
WCD32FindReplaceText(IN PVDMFRAME       pFrame,
                     IN FINDREPLACEPROC Function);

UINT APIENTRY
WCD32FindReplaceDialogProc(HWND   hdlg,
                           UINT   uMsg,
                           WPARAM uParam,
                           LPARAM lParam);

#define VALID_OFN16_FLAGS (OFN_READONLY              | \
                           OFN_OVERWRITEPROMPT       | \
                           OFN_HIDEREADONLY          | \
                           OFN_NOCHANGEDIR           | \
                           OFN_SHOWHELP              | \
                           OFN_ENABLEHOOK            | \
                           OFN_ENABLETEMPLATE        | \
                           OFN_ENABLETEMPLATEHANDLE  | \
                           OFN_NOVALIDATE            | \
                           OFN_ALLOWMULTISELECT      | \
                           OFN_EXTENSIONDIFFERENT    | \
                           OFN_PATHMUSTEXIST         | \
                           OFN_FILEMUSTEXIST         | \
                           OFN_CREATEPROMPT          | \
                           OFN_SHAREAWARE            | \
                           OFN_NOREADONLYRETURN      | \
                           OFN_NOTESTFILECREATE)

//
// unique message thunks
//

// This function thunks the private messages
//      msgCOLOROK
BOOL FASTCALL
WM32msgCOLOROK(LPWM32MSGPARAMEX lpwm32mpex)
{
    LPCHOOSECOLOR       pCC32;
    PCHOOSECOLORDATA16  pCC16;

    GETVDMPTR((VPVOID)lpwm32mpex->Parm16.WndProc.lParam,
              sizeof(CHOOSECOLORDATA16),
              pCC16);

    pCC32 = (LPCHOOSECOLOR)lpwm32mpex->lParam;

    if(pCC16 && pCC32) {

        if(lpwm32mpex->fThunk) {
            ThunkCHOOSECOLOR32to16(pCC16, pCC32);
        }
        else {
            ThunkCHOOSECOLOR16to32(pCC32, pCC16);
        }
    }
    else {
        return(FALSE);
    }

    FREEVDMPTR(pCC16);

    return (TRUE);
}




// This function thunks the private messages
//      msgFILEOK
BOOL FASTCALL
WM32msgFILEOK(LPWM32MSGPARAMEX lpwm32mpex)
{
    VPOPENFILENAME   vpof;
    POPENFILENAME16  pOFN16;
    OPENFILENAME    *pOFN32;


    vpof = (VPOPENFILENAME)(GetCommdlgTd(lpwm32mpex->hwnd)->vpData);

    pOFN32 = (OPENFILENAME *)lpwm32mpex->lParam;
    //
    // Approach sends its own fileok message when you click on its
    // secret listbox that it displays over lst1 sometimes.  It
    // sends NULL for the LPARAM instead of the address of the
    // openfilename structure.
    if(pOFN32 == NULL) {
        lpwm32mpex->Parm16.WndProc.lParam = (LPARAM)NULL;
        return(TRUE);
    }

    GETVDMPTR(vpof, sizeof(OPENFILENAME16), pOFN16);

    if (lpwm32mpex->fThunk) {
        UpdateDosCurrentDirectory(DIR_NT_TO_DOS);
        lpwm32mpex->Parm16.WndProc.lParam = (LPARAM)vpof;

        // sudeepb 12-Mar-1996
        //
        // The selected file name needs to be uppercased for
        // apps like symanatec QA 4.0. So changed the following parameter
        // in ThunkOpenFileName from FALSE to TRUE.
        ThunkOPENFILENAME32to16(pOFN16, pOFN32, TRUE);

    } else {
        ThunkOPENFILENAME16to32(pOFN32, pOFN16);
    }

    FREEVDMPTR(pOFN16);

    return (TRUE);
}




// This function thunks the private messages
//      msgWOWDIRCHANGE
BOOL FASTCALL
WM32msgWOWDIRCHANGE(LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        UpdateDosCurrentDirectory(DIR_NT_TO_DOS);
    }

    return (TRUE);
}





// This function thunks the private message
//      msgWOWLFCHANGE
BOOL FASTCALL
WM32msgWOWLFCHANGE(LPWM32MSGPARAMEX lpwm32mpex)
{
    VPCHOOSEFONTDATA  vpcf;
    PCHOOSEFONTDATA16 pCF16;


    vpcf = (VPCHOOSEFONTDATA)(GetCommdlgTd(lpwm32mpex->hwnd)->vpData);

    GETVDMPTR(vpcf, sizeof(CHOOSEFONTDATA16), pCF16);

    if(!pCF16) {
        WOW32ASSERT(pCF16);
        return(FALSE);
    }

    if (lpwm32mpex->fThunk) {
        PUTLOGFONT16(DWORD32(pCF16->lpLogFont),
                     sizeof(LOGFONT),
                     (LPLOGFONT)lpwm32mpex->lParam);
    }

    FREEVDMPTR(pCF16);

    return(TRUE);
}





// This function thunks the private message
//      msgSHAREVIOLATION
BOOL FASTCALL
WM32msgSHAREVIOLATION(LPWM32MSGPARAMEX lpwm32mpex)
{
    INT cb;
    PLONG plParamNew = &lpwm32mpex->Parm16.WndProc.lParam;


    if (lpwm32mpex->fThunk) {
        if (lpwm32mpex->lParam) {
            cb = strlen((LPSZ)lpwm32mpex->lParam)+1;
            if (!(*plParamNew = malloc16(cb))) {
                return(FALSE);
            }
            putstr16((VPSZ)*plParamNew, (LPSZ)lpwm32mpex->lParam, cb);
        }
    } else {
        if (*plParamNew) {
            free16((VPVOID) *plParamNew);
        }
    }

    return (TRUE);
}





// This function thunks the private messages
//      WM_CHOOSEFONT_GETLOGFONT
BOOL FASTCALL
WM32msgCHOOSEFONTGETLOGFONT(LPWM32MSGPARAMEX lpwm32mpex)
{
    LOGFONT LogFont32;

    // The mere fact that we access the buffer after allowing the 16-bit
    // hook proc to step in breaks Serif PagePlus app which wants it's
    // hook proc to always have a shot and commdlg to check the return value.

    // If hook proc returns TRUE, no further action is taken
    //
    // This is the message an app sends the dialog if it wants to find
    // out what font is currently selected.
    //
    // We thunk this by sending yet another hackorama message to comdlg32,
    // who will then fill in the 32-bit structure we pass in so we can
    // thunk it back to the 16-bit structure.  Then we return TRUE so
    // comdlg32 doesn't reference the 16-bit logfont.
    //
    if (!lpwm32mpex->fThunk && !lpwm32mpex->lReturn) {
        SendMessage(lpwm32mpex->hwnd, msgWOWCHOOSEFONT, 0, (LPARAM)&LogFont32);

        PUTLOGFONT16(lpwm32mpex->lParam, sizeof(LOGFONT), &LogFont32);

        lpwm32mpex->lReturn = TRUE;
    }

    return (TRUE);
}






//
// Dialog callback hook thunks
//
UINT APIENTRY
WCD32DialogProc(HWND hdlg,
                UINT uMsg,
                WPARAM uParam,
                LPARAM lParam)
/*++

Routine Description:

    This is the hook proc used by ChooseColor, ChooseFont, GetOpenFileName,
    GetSaveFileName, and PrintDlg.  It pulls the 16-bit callback
    out of the thread data and calls the common dialog proc to do
    the rest of the work.

--*/
{
    PCOMMDLGTD Td;

    Td = GetCommdlgTd(hdlg);
    if(Td) {
        return(WCD32CommonDialogProc(hdlg,
                                     uMsg,
                                     uParam,
                                     lParam,
                                     Td,
                                     Td->vpfnHook));
    } else {
        return(0);
    }
}




UINT APIENTRY
WCD32PrintSetupDialogProc(HWND hdlg,
                          UINT uMsg,
                          WPARAM uParam,
                          LPARAM lParam)
/*++

Routine Description:

    This is the hook proc used by PrintSetup.  It is only used when
    the Setup button on the Print dialog directly creates the PrintSetup
    dialog.  We find the correct TD by looking for the TD of our owner
    window (which is the print dialog)

    It calls the common dialog proc to do the rest of the work.

--*/

{
    PCOMMDLGTD pTD;

    pTD = CURRENTPTD()->CommDlgTd;
    if(pTD) {
        while (pTD->SetupHwnd != GETHWND16(hdlg)) {
            pTD = pTD->Previous;
            if(!pTD) {
                WOW32ASSERT(FALSE);
                return(0);
            }
        }

        return(WCD32CommonDialogProc(hdlg,
                                     uMsg,
                                     uParam,
                                     lParam,
                                     pTD,
                                     pTD->vpfnSetupHook));
    } else {
        return(0);
    }

}




UINT APIENTRY
WCD32FindReplaceDialogProc(HWND hdlg,
                           UINT uMsg,
                           WPARAM uParam,
                           LPARAM lParam)
/*++

Routine Description:

    This is the hook proc used by FindText and ReplaceText. It does cleanup
    on WM_DESTROY and calls WCD32CommonDialogProc to handle the 16-bit
    dialog hook callback on all messages, if needed.

--*/

{
    PFINDREPLACE16 pFR16;
    VPFINDREPLACE  vpfr;
    LPFINDREPLACE  pFR32;
    PCOMMDLGTD     ptdDlg;
    PCOMMDLGTD     ptdOwner;
    UINT           uRet = FALSE;

    // If the ptdDlg is invalid, do nothing.
    ptdDlg = GetCommdlgTd(hdlg);
    if (ptdDlg == NULL) {
        return(uRet);
    }

    if (uMsg != WM_DESTROY) {

        // this will be FALSE if the app didn't specify a 16-bit hookproc
        // we always set the 32-bit hookproc in ThunkFINDREPLACE16to32()
        if (ptdDlg->vpfnHook) {

           uRet = WCD32CommonDialogProc(hdlg,
                                        uMsg,
                                        uParam,
                                        lParam,
                                        ptdDlg,
                                        ptdDlg->vpfnHook);
        }
    }
    else {

        pFR32 = (LPFINDREPLACE)ptdDlg->pData32;

        // UnLink both per thread data structs from the list.
        ptdOwner = GetCommdlgTd(pFR32->hwndOwner);
        if(ptdOwner == NULL) {
            WOW32ASSERT(FALSE);
            return(uRet);
        }
  
        CURRENTPTD()->CommDlgTd = ptdDlg->Previous;
        WOW32ASSERT(ptdOwner->Previous == ptdDlg);

        vpfr = ptdDlg->vpData;

        GETVDMPTR(vpfr, sizeof(FINDREPLACE16), pFR16);

        if(!pFR16) {
            WOW32ASSERT(FALSE);
            return(uRet);
        }

        // CleanUp template if used.
        FreeCDTemplate32((PRES)ptdDlg->pRes,
                         pFR32->hInstance,
                         DWORD32(pFR16->Flags) & FR_ENABLETEMPLATE,
                         DWORD32(pFR16->Flags) & FR_ENABLETEMPLATEHANDLE);


        FREEVDMPTR(pFR16);

        // Free the per thread data structs.
        free_w(ptdDlg);
        free_w(ptdOwner);

        // Free the 32-bit FINDREPLACE structure.
        free_w(pFR32->lpstrFindWhat);
        free_w(pFR32->lpstrReplaceWith);
        free_w(pFR32);
    }

    if (uMsg == WM_INITDIALOG) {
        // Force COMDLG32!FindReplaceDialogProc to handle WM_INITDIALOG.
        uRet = TRUE;
    }

    return(uRet);
}





UINT APIENTRY
WCD32CommonDialogProc(HWND hdlg,
                      UINT uMsg,
                      WPARAM uParam,
                      LPARAM lParam,
                      PCOMMDLGTD pCTD,
                      VPVOID vpfnHook)
/*++

Routine Description:

    This thunks the 32-bit dialog callback into a 16-bit callback
    This is the common code used by all the dialog callback thunks that
    actually calls the 16-bit callback.

--*/

{
    BOOL            fSuccess;
    LPFNM32         pfnThunkMsg;
    WM32MSGPARAMEX  wm32mpex;
    BOOL            fMessageNeedsThunking;

    // If the app has GP Faulted we don't want to pass it any more input
    // This should be removed when USER32 does clean up on task death so
    // it doesn't call us - mattfe june 24 92

    // LOGDEBUG(10, ("CommonDialogProc In: %lX %X %X %lX\n",
    //         (DWORD)hdlg,
    //         uMsg,
    //         uParam,
    //         lParam));

    if(CURRENTPTD()->dwFlags & TDF_IGNOREINPUT) {

        LOGDEBUG(6,
                 ("    WCD32OpenFileDialog Ignoring Input Messsage %04X\n",
                 uMsg));

        WOW32ASSERTMSG(gfIgnoreInputAssertGiven,
         "WCD32CommonDialogProc: TDF_IGNOREINPUT hack was used, shouldn't be, "
         "please email DaveHart with repro instructions.  Hit 'g' to ignore "
         "this and suppress this assertion from now on.\n");

        gfIgnoreInputAssertGiven = TRUE;
        goto SilentError;
    }

    if(pCTD==NULL) {
        LOGDEBUG(0,("    WCD32OpenFileDialog ERROR: pCTD==NULL\n"));
        goto Error;
    }

    // If pCTD->vpfnHook is NULL, then something is broken;  we
    // certainly can't continue because we don't know what 16-bit func to call
    if(!vpfnHook) {
        LOGDEBUG(0,("    WCD32OpenFileDialog ERROR: no hook proc for message %04x Dlg = %08lx\n", uMsg, hdlg ));
        goto Error;
    }

    wm32mpex.Parm16.WndProc.hwnd   = GETHWND16(hdlg);
    wm32mpex.Parm16.WndProc.wMsg   = (WORD)uMsg;
    wm32mpex.Parm16.WndProc.wParam = (WORD)uParam;
    wm32mpex.Parm16.WndProc.lParam = (LONG)lParam;
    wm32mpex.Parm16.WndProc.hInst  = (WORD)GetWindowLong(hdlg, GWL_HINSTANCE);

    // On Win3.1, the app & the system share the ptr to the same structure that
    // the app passed to the common dialog API.  Therefore, when one side makes
    // a change to the struct, the other is aware of the change.  This is not
    // the case on NT since we thunk the struct into a 32-bit ANSI struct which
    // is then thunked into a 32-bit UNICODE struct in the comdlg32 code.  We
    // attempt to synchronize all these structs by rethunking them for every
    // message sent to the 16-bit side & for every API call the app makes.
    // See sync code in callback16() and w32Dispatch().
    // ComDlg32 thunks UNICODEtoANSI before calling us & ASNItoUNICODE when we
    // return.  Ug!!!  Apparently a fair number of apps depend on this
    // behavior since we've debugged this problem about 6 times to date and
    // each time we have put in special hacks for each case.  With any luck
    // this should be a general fix.   08/97   CMJones

    if(uMsg < 0x400) {

        LOGDEBUG(3,
                 ("%04X (%s)\n",
                 CURRENTPTD()->htask16,
                 (aw32Msg[uMsg].lpszW32)));

        pfnThunkMsg = aw32Msg[uMsg].lpfnM32;

        if(uMsg == WM_INITDIALOG) {

            // The address of the 16-bit structure that the app passed to the
            // original common dialog API is passed in lParam in WM_INITDIALOG
            // messages in Win 3.1
            wm32mpex.Parm16.WndProc.lParam = lParam = (LPARAM)pCTD->vpData;
        }

    // Check for unique messages
    } else if(uMsg >= 0x400) {
        if (uMsg == msgFILEOK) {
            pfnThunkMsg = WM32msgFILEOK;
        } else if(uMsg == msgCOLOROK) {
            wm32mpex.Parm16.WndProc.lParam = (LPARAM)pCTD->vpData;
            pfnThunkMsg = WM32msgCOLOROK;
        } else if(uMsg == msgSHAREVIOLATION) {
            pfnThunkMsg = WM32msgSHAREVIOLATION;
        } else if(uMsg == msgWOWDIRCHANGE) {
            pfnThunkMsg = WM32msgWOWDIRCHANGE;
        } else if(uMsg == msgWOWLFCHANGE) {
            pfnThunkMsg = WM32msgWOWLFCHANGE;
        } else if(pCTD->Flags & WOWCD_ISCHOOSEFONT) {

            // special ChooseFont thunks to handle goofy GETLOGFONT message
            if(uMsg == WM_CHOOSEFONT_GETLOGFONT) {

                pfnThunkMsg = WM32msgCHOOSEFONTGETLOGFONT;

            } else if(uMsg == msgWOWCHOOSEFONT) {
                //
                // no wow app will expect this, so don't send it.
                //
                return(FALSE);
            } else {
                pfnThunkMsg = WM32NoThunking;
            }
        } else {
            pfnThunkMsg = WM32NoThunking;
        }
    }

    fMessageNeedsThunking = (pfnThunkMsg != WM32NoThunking);
    if(fMessageNeedsThunking) {
        wm32mpex.fThunk = THUNKMSG;
        wm32mpex.hwnd = hdlg;
        wm32mpex.uMsg = uMsg;
        wm32mpex.uParam = uParam;
        wm32mpex.lParam = lParam;
        wm32mpex.pww = NULL;
        wm32mpex.lpfnM32 = pfnThunkMsg;

        if(!(pfnThunkMsg)(&wm32mpex)) {
            LOGDEBUG(LOG_ERROR,("    WCD32OpenFileDialog ERROR: cannot thunk 32-bit message %04x\n", uMsg));
            goto Error;
        }
    } else {
        LOGDEBUG(6,("WCD32CommonDialogProc, No Thunking was required for the 32-bit message %s(%04x)\n", (LPSZ)GetWMMsgName(uMsg), uMsg));
    }

    // this call may cause 16-bit memory to move
    // this call will call 32->16 sync code before the callback & the 16->32
    // sync upon return from the callback
    fSuccess = CallBack16(RET_WNDPROC,
                          &wm32mpex.Parm16,
                          vpfnHook,
                          (PVPVOID)&wm32mpex.lReturn);

    // flat ptrs to 16-bit mem are now invalid due to possible memory movement

    // the callback function of a dialog is of type FARPROC whose return value
    // is of type 'int'. Since dx:ax is copied into lReturn in the above
    // CallBack16 call, we need to zero out the hiword, otherwise we will be
    // returning an erroneous value.
    wm32mpex.lReturn = (LONG)LOWORD(wm32mpex.lReturn);

    if(fMessageNeedsThunking) {
        wm32mpex.fThunk = UNTHUNKMSG;
        (pfnThunkMsg)(&wm32mpex);
    }

    if(!fSuccess)
        goto Error;

Done:
    // Uncomment this to receive message on exit
    // LOGDEBUG(10, ("CommonDialogProc Out: Return %lX\n", wm32mpex.lReturn));

    return wm32mpex.lReturn;

Error:
    LOGDEBUG(5,("    WCD32OpenFileDialog WARNING: cannot call back, using default message handling\n"));
SilentError:
    wm32mpex.lReturn = 0;
    goto Done;
}






ULONG FASTCALL
WCD32ExtendedError( IN PVDMFRAME pFrame )
/*++

Routine Description:

    32-bit thunk for CommDlgExtendedError()

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    error code to be returned

--*/
{
    if (dwExtError != 0) {
        return(dwExtError);
    }
    return(CommDlgExtendedError());
}







ULONG FASTCALL
WCD32ChooseColor(PVDMFRAME pFrame)
/*++

Routine Description:

    This routine thunks the 16-bit ChooseColor common dialog to the 32-bit
    side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    ULONG                   ul = GETBOOL16(FALSE);
    register PCHOOSECOLOR16 parg16;
    VPCHOOSECOLORDATA       vpcc;
    CHOOSECOLOR             CC32;
    PCHOOSECOLORDATA16      pCC16;
    PRES                    pRes = NULL;
    COMMDLGTD               ThreadData;
    COLORREF                CustColors32[16];  // on stack for DWORD alignment
    DWORD                   dwFlags16;
    BOOL                    fError = FALSE;


    GETARGPTR(pFrame, sizeof(CHOOSECOLOR16), parg16);
    vpcc = parg16->lpcc;

    SETEXTENDEDERROR( 0 );

    // invalidate this now
    FREEVDMPTR( parg16 );

    // initialize unique window message
    if (msgCOLOROK == 0) {
        if(!(msgCOLOROK = (WORD)RegisterWindowMessage(COLOROKSTRING))) {
            SETEXTENDEDERROR( CDERR_REGISTERMSGFAIL );
            LOGDEBUG(2,("WCD32ChooseColor:RegisterWindowMessage failed\n"));
            return(0);
        }
    }

    GETVDMPTR(vpcc, sizeof(CHOOSECOLORDATA16), pCC16);

    WCDDUMPCHOOSECOLORDATA16(pCC16);

    if(!pCC16 || (DWORD32(pCC16->lStructSize) != sizeof(CHOOSECOLORDATA16))) {
        SETEXTENDEDERROR( CDERR_STRUCTSIZE );
        FREEVDMPTR(pCC16);
        return(0);
    }

    RtlZeroMemory(&ThreadData, sizeof(COMMDLGTD));
    ThreadData.Previous = CURRENTPTD()->CommDlgTd;
    ThreadData.hdlg     = (HWND16)-1;
    ThreadData.pData32  = &CC32;
    ThreadData.Flags    = 0;
    if(DWORD32(pCC16->Flags) & CC_ENABLEHOOK) {
        ThreadData.vpfnHook = DWORD32(pCC16->lpfnHook);
        if(!ThreadData.vpfnHook) {
            SETEXTENDEDERROR(CDERR_NOHOOK);
            FREEVDMPTR(pCC16);
            return(0);
        }
        ThreadData.vpData   = vpcc;
    }
    else {
        STOREDWORD(pCC16->lpfnHook, 0);
    }

    RtlZeroMemory(&CC32, sizeof(CHOOSECOLOR));
    CC32.lpCustColors = CustColors32;
    ThunkCHOOSECOLOR16to32(&CC32, pCC16);
    dwFlags16 = DWORD32(pCC16->Flags);

    // this call invalidates flat ptrs to 16-bit memory
    CC32.hInstance = (HWND)ThunkCDTemplate16to32(WORD32(pCC16->hInstance),
                                                 0,
                                                 DWORD32(pCC16->lpTemplateName),
                                                 dwFlags16,
                                                 &(CC32.Flags),
                                                 CC_ENABLETEMPLATE,
                                                 CC_ENABLETEMPLATEHANDLE,
                                                 &pRes,
                                                 &fError);

    if(fError) {
        goto ChooseColorExit;
    }

    // invalidate flat ptrs to 16-bit memory
    FREEVDMPTR(pCC16);

    WCDDUMPCHOOSECOLORDATA32(&CC32);

    // Set this just before the calling into comdlg32.  This prevents the
    // synchronization stuff from firing until we actually need it.
    CURRENTPTD()->CommDlgTd = &ThreadData;

    // this call invalidates flat ptrs to 16-bit memory
    ul = GETBOOL16(ChooseColor(&CC32));

    CURRENTPTD()->CommDlgTd = ThreadData.Previous;

    if (ul) {

        WCDDUMPCHOOSECOLORDATA32(&CC32);

        GETVDMPTR(vpcc, sizeof(CHOOSECOLOR16), pCC16);
        ThunkCHOOSECOLOR32to16(pCC16, &CC32);

        WCDDUMPCHOOSECOLORDATA16(pCC16);
        FREEVDMPTR(pCC16);

    }

ChooseColorExit:

    FreeCDTemplate32(pRes,
                     (HINSTANCE)CC32.hInstance,
                     dwFlags16 & CC_ENABLETEMPLATE,
                     dwFlags16 & CC_ENABLETEMPLATEHANDLE);

    FREEVDMPTR(pCC16);

    return(ul);
}




VOID
ThunkCHOOSECOLOR16to32(OUT CHOOSECOLOR        *pCC32,
                       IN  PCHOOSECOLORDATA16  pCC16)
{
    COLORREF *pCustColors16;
    DWORD     Flags;


    if(pCC16 && pCC32) {

        pCC32->lStructSize = sizeof(CHOOSECOLOR);
        pCC32->hwndOwner   = HWND32(pCC16->hwndOwner);

        // hInstance thunked separately

        pCC32->rgbResult   = DWORD32(pCC16->rgbResult);

        if(pCC32->lpCustColors) {
            GETVDMPTR(pCC16->lpCustColors, 16*sizeof(COLORREF), pCustColors16);
            if(pCustColors16) {
                RtlCopyMemory(pCC32->lpCustColors,
                              pCustColors16,
                              16*sizeof(COLORREF));
            }
            FREEVDMPTR(pCustColors16);
        }

        // preserve the template flag state while copying flags
        // 1. save template flag state
        //     note: we never will have a 32-bit CC_ENABLETEMPLATE flag
        // 2. copy flags from 16-bit struct (add the WOWAPP flag)
        // 3. turn off all template flags
        // 4. restore original template flag state
        Flags         = pCC32->Flags & CC_ENABLETEMPLATEHANDLE;
        pCC32->Flags  = DWORD32(pCC16->Flags) | CD_WOWAPP;
        pCC32->Flags &= ~(CC_ENABLETEMPLATE | CC_ENABLETEMPLATEHANDLE);
        pCC32->Flags |= Flags;

        pCC32->lCustData   = DWORD32(pCC16->lCustData);

        if((DWORD32(pCC16->Flags) & CC_ENABLEHOOK) && DWORD32(pCC16->lpfnHook)){
            pCC32->lpfnHook = WCD32DialogProc;
        }

        // lpTemplateName32 is thunked separately
    }
}




VOID
ThunkCHOOSECOLOR32to16(OUT PCHOOSECOLORDATA16  pCC16,
                       IN  CHOOSECOLOR        *pCC32)
{
    COLORREF *pCustColors16;
    DWORD     Flags, Flags32;


    if(pCC16 && pCC32) {

        STOREDWORD(pCC16->rgbResult, pCC32->rgbResult);

        // preserve the template flag state while copying flags
        // 1. save template flag state
        // 2. copy flags from 32-bit struct
        // 3. turn off all template flags and the WOWAPP flag
        // 4. restore original template flag state
        Flags    = DWORD32(pCC16->Flags) & (CC_ENABLETEMPLATE |
                                            CC_ENABLETEMPLATEHANDLE);
        Flags32  = pCC32->Flags;
        Flags32 &= ~(CC_ENABLETEMPLATE | CC_ENABLETEMPLATEHANDLE | CD_WOWAPP);
        Flags32 |= Flags;
        STOREDWORD(pCC16->Flags, Flags32);

        GETVDMPTR(pCC16->lpCustColors, 16*sizeof(COLORREF), pCustColors16);
        if(pCustColors16) {
            RtlCopyMemory(pCustColors16,
                          pCC32->lpCustColors,
                          16*sizeof(COLORREF));
            FREEVDMPTR(pCustColors16);
        }
    }
}





ULONG FASTCALL
WCD32ChooseFont( PVDMFRAME pFrame )
/*++

Routine Description:

    This routine thunks the 16-bit ChooseFont common dialog to the 32-bit
    side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    ULONG                   ul = GETBOOL16(FALSE);
    register PCHOOSEFONT16  parg16;
    VPCHOOSEFONTDATA        vpcf;
    CHOOSEFONT              CF32;
    LOGFONT                 LogFont32;
    PCHOOSEFONTDATA16       pCF16;
    PRES                    pRes = NULL;
    COMMDLGTD               ThreadData;
    DWORD                   dwFlags16;
    CHAR                    sStyle[2 * LF_FACESIZE];
    BOOL                    fError = FALSE;


    GETARGPTR(pFrame, sizeof(CHOOSEFONT16), parg16);
    vpcf = parg16->lpcf;

    SETEXTENDEDERROR( 0 );

    // invalidate this now
    FREEVDMPTR( parg16 );

    // initialize unique window messages
    if (msgWOWCHOOSEFONT == 0) {

        // private WOW<->comdlg32 message for handling WM_CHOOSEFONT_GETLOGFONT
        if(!(msgWOWCHOOSEFONT  =
                     (WORD)RegisterWindowMessage("WOWCHOOSEFONT_GETLOGFONT"))) {
            SETEXTENDEDERROR( CDERR_REGISTERMSGFAIL );
            LOGDEBUG(2,("WCD32ChooseFont:RegisterWindowMessage failed\n"));
            return(0);
        }
    }
    if (msgWOWLFCHANGE == 0) {

        // private message for thunking logfont changes
        if(!(msgWOWLFCHANGE = (WORD)RegisterWindowMessage("WOWLFChange"))) {
            SETEXTENDEDERROR( CDERR_REGISTERMSGFAIL );
            LOGDEBUG(2,("WCD32ChooseFont:RegisterWindowMessage 2 failed\n"));
            return(0);
        }
    }

    GETVDMPTR(vpcf, sizeof(CHOOSEFONTDATA16), pCF16);

    WCDDUMPCHOOSEFONTDATA16(pCF16);

    if(!pCF16 || DWORD32(pCF16->lStructSize) != sizeof(CHOOSEFONTDATA16)) {
        SETEXTENDEDERROR( CDERR_STRUCTSIZE );
        FREEVDMPTR(pCF16);
        return(0);
    }

    RtlZeroMemory(&ThreadData, sizeof(COMMDLGTD));
    ThreadData.Previous = CURRENTPTD()->CommDlgTd;
    ThreadData.hdlg     = (HWND16)-1;
    ThreadData.pData32  = &CF32;
    ThreadData.Flags    = WOWCD_ISCHOOSEFONT;
    if(DWORD32(pCF16->Flags) & CF_ENABLEHOOK) {
        ThreadData.vpfnHook = DWORD32(pCF16->lpfnHook);
        if(!ThreadData.vpfnHook) {
            SETEXTENDEDERROR(CDERR_NOHOOK);
            FREEVDMPTR(pCF16);
            return(0);
        }
        ThreadData.vpData   = vpcf;
    }
    else {
        STOREDWORD(pCF16->lpfnHook, 0);
    }

    RtlZeroMemory(&CF32, sizeof(CHOOSEFONT));
    CF32.lpLogFont = &LogFont32;
    CF32.lpszStyle = sStyle;
    sStyle[0] = '\0';
    ThunkCHOOSEFONT16to32(&CF32, pCF16);
    dwFlags16 = DWORD32(pCF16->Flags);

    // this call invalidates flat ptrs to 16-bit memory
    CF32.hInstance = ThunkCDTemplate16to32(WORD32(pCF16->hInstance),
                                           0,
                                           DWORD32(pCF16->lpTemplateName),
                                           dwFlags16,
                                           &(CF32.Flags),
                                           CF_ENABLETEMPLATE,
                                           CF_ENABLETEMPLATEHANDLE,
                                           &pRes,
                                           &fError);

    if(fError) {
        goto ChooseFontExit;
    }

    // invalidate flat ptrs to 16-bit memory
    FREEVDMPTR(pCF16);

    WCDDUMPCHOOSEFONTDATA32(&CF32);

    // Set this just before the calling into comdlg32.  This prevents the
    // synchronization stuff from firing until we actually need it.
    CURRENTPTD()->CommDlgTd = &ThreadData;

    // this call invalidates flat ptrs to 16-bit memory
    ul = GETBOOL16(ChooseFont(&CF32));

    CURRENTPTD()->CommDlgTd = ThreadData.Previous;

    if (ul) {

        WCDDUMPCHOOSEFONTDATA32(&CF32);

        GETVDMPTR(vpcf, sizeof(CHOOSEFONT16), pCF16);
        ThunkCHOOSEFONT32to16(pCF16, &CF32);

        WCDDUMPCHOOSEFONTDATA16(pCF16);

    }

ChooseFontExit:

    FreeCDTemplate32(pRes,
                     CF32.hInstance,
                     dwFlags16 & CF_ENABLETEMPLATE,
                     dwFlags16 & CF_ENABLETEMPLATEHANDLE);

    FREEVDMPTR(pCF16);

    return(ul);
}





VOID
ThunkCHOOSEFONT16to32(OUT CHOOSEFONT        *pCF32,
                      IN  PCHOOSEFONTDATA16  pCF16)
{
    LPSTR lpstr;
    DWORD Flags;


    if(pCF16 && pCF32) {

        pCF32->lStructSize = sizeof(CHOOSEFONT);
        pCF32->hwndOwner   = HWND32(pCF16->hwndOwner);

        if(DWORD32(pCF16->Flags) & CF_PRINTERFONTS) {
            pCF32->hDC = HDC32(pCF16->hDC);
        }

        if(DWORD32(pCF16->lpLogFont) && pCF32->lpLogFont) {
            GETLOGFONT16(DWORD32(pCF16->lpLogFont), pCF32->lpLogFont);
        }

        pCF32->iPointSize  = INT32(pCF16->iPointSize);

        // preserve the template flag state while copying flags
        // 1. save template flag state
        //     note: we never will have a 32-bit CF_ENABLETEMPLATE flag
        // 2. copy flags from 16-bit struct (add the WOWAPP flag)
        // 3. turn off all template flags
        // 4. restore original template flag state
        Flags         = pCF32->Flags & CF_ENABLETEMPLATEHANDLE;
        pCF32->Flags  = DWORD32(pCF16->Flags) | CD_WOWAPP;
        pCF32->Flags &= ~(CF_ENABLETEMPLATE | CF_ENABLETEMPLATEHANDLE);
        pCF32->Flags |= Flags;

        pCF32->rgbColors   = DWORD32(pCF16->rgbColors);
        pCF32->lCustData   = DWORD32(pCF16->lCustData);

        if((DWORD32(pCF16->Flags) & CF_ENABLEHOOK) && pCF16->lpfnHook) {
            pCF32->lpfnHook = WCD32DialogProc;
        }

        // lpTemplateName32 is thunked separately
        // hInstance thunked separately

        // Note: we shouldn't have to free or re-alloc this since they
        //       will only need LF_FACESIZE bytes to handle the string
        GETPSZPTR(pCF16->lpszStyle, lpstr);
        if(lpstr && pCF32->lpszStyle) {
            if(DWORD32(pCF16->Flags) & CF_USESTYLE) {
                strncpy(pCF32->lpszStyle, lpstr, LF_FACESIZE);
                pCF32->lpszStyle[LF_FACESIZE - 1] = '\0';
            }
            FREEPSZPTR(lpstr);
        }

        pCF32->nFontType   = WORD32(pCF16->nFontType);
        pCF32->nSizeMin    = INT32(pCF16->nSizeMin);
        pCF32->nSizeMax    = INT32(pCF16->nSizeMax);
    }
}





VOID
ThunkCHOOSEFONT32to16(OUT PCHOOSEFONTDATA16  pCF16,
                      IN  CHOOSEFONT        *pCF32)
{
    LPSTR lpstr;
    DWORD Flags, Flags32;


    if(pCF16 && pCF32) {

        STOREWORD(pCF16->iPointSize, pCF32->iPointSize);
        STOREDWORD(pCF16->rgbColors, pCF32->rgbColors);
        STOREWORD(pCF16->nFontType,  pCF32->nFontType);

        // preserve the template flag state while copying flags
        // 1. save template flag state
        // 2. copy flags from 32-bit struct
        // 3. turn off all template flags and the WOWAPP flag
        // 4. restore original template flag state
        Flags    = DWORD32(pCF16->Flags) & (CF_ENABLETEMPLATE |
                                            CF_ENABLETEMPLATEHANDLE);
        Flags32  = pCF32->Flags;
        Flags32 &= ~(CF_ENABLETEMPLATE | CF_ENABLETEMPLATEHANDLE | CD_WOWAPP);
        Flags32 |= Flags;
        STOREDWORD(pCF16->Flags, Flags32);

        if(DWORD32(pCF16->lpLogFont) && pCF32->lpLogFont) {
            PUTLOGFONT16(DWORD32(pCF16->lpLogFont),
                         sizeof(LOGFONT),
                         pCF32->lpLogFont);
        }

        GETPSZPTR(pCF16->lpszStyle, lpstr);
        if(lpstr && pCF32->lpszStyle) {
            if(DWORD32(pCF16->Flags) & CF_USESTYLE) {
                strcpy(lpstr, pCF32->lpszStyle);
            }
            FREEPSZPTR(lpstr);
        }
    }
}







ULONG FASTCALL
WCD32PrintDlg(IN PVDMFRAME pFrame)
/*++

Routine Description:

    This routine thunks the 16-bit PrintDlg common dialog to the 32-bit
    side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned

--*/
{
    ULONG                  ul = GETBOOL16(FALSE);
    register PPRINTDLG16   parg16;
    VPPRINTDLGDATA         vppd;
    PRINTDLG               PD32;
    PPRINTDLGDATA16        pPD16;
    PRES                   hSetupRes = NULL;
    PRES                   hPrintRes = NULL;
    COMMDLGTD              ThreadData;
    DWORD                  dwFlags16;
    HMEM16                 hDM16;
    HMEM16                 hDN16;
    BOOL                   fError = FALSE;


    GETARGPTR(pFrame, sizeof(PRINTDLG16), parg16);
    vppd = parg16->lppd;

    // invalidate this now
    FREEARGPTR(parg16);

    SETEXTENDEDERROR(0);

    GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

    WCDDUMPPRINTDLGDATA16(pPD16);

    if(!pPD16 ||DWORD32(pPD16->lStructSize) != sizeof(PRINTDLGDATA16)) {
        SETEXTENDEDERROR( CDERR_STRUCTSIZE );
        FREEVDMPTR(pPD16);
        return(0);
    }

    if(DWORD32(pPD16->Flags) & PD_RETURNDEFAULT) {
        // spec says these must be NULL
        if(WORD32(pPD16->hDevMode) || WORD32(pPD16->hDevNames)) {
            SETEXTENDEDERROR(PDERR_RETDEFFAILURE);
            FREEVDMPTR(pPD16);
            return(0);
        }
    }

    RtlZeroMemory((PVOID)&PD32, sizeof(PRINTDLG));
    RtlZeroMemory((PVOID)&ThreadData, sizeof(COMMDLGTD));
    ThreadData.Previous = CURRENTPTD()->CommDlgTd;
    ThreadData.hdlg     = (HWND16)-1;
    ThreadData.pData32  = (PVOID)&PD32;
    ThreadData.Flags    = 0;

    // this flag causes the system to put up the setup dialog rather
    // than the print dialog
    if(DWORD32(pPD16->Flags) & PD_PRINTSETUP) {
        if(DWORD32(pPD16->Flags) & PD_ENABLESETUPHOOK) {
            ThreadData.vpfnHook = DWORD32(pPD16->lpfnSetupHook);
            if(!ThreadData.vpfnHook) {
                SETEXTENDEDERROR(CDERR_NOHOOK);
                FREEVDMPTR(pPD16);
                return(0);
            }
            ThreadData.vpData = vppd;
            PD32.lpfnSetupHook = WCD32DialogProc;
        }
    } else {
        if (DWORD32(pPD16->Flags) & PD_ENABLEPRINTHOOK) {
            ThreadData.vpfnHook = DWORD32(pPD16->lpfnPrintHook);
            if(!ThreadData.vpfnHook) {
                SETEXTENDEDERROR(CDERR_NOHOOK);
                FREEVDMPTR(pPD16);
                return(0);
            }
            ThreadData.vpData = vppd;
            PD32.lpfnPrintHook = WCD32DialogProc;
        }
        if (DWORD32(pPD16->Flags) & PD_ENABLESETUPHOOK) {
            ThreadData.vpfnSetupHook = DWORD32(pPD16->lpfnSetupHook);
            if(!ThreadData.vpfnSetupHook) {
                SETEXTENDEDERROR(CDERR_NOHOOK);
                FREEVDMPTR(pPD16);
                return(0);
            }
            ThreadData.vpData    = vppd;
            ThreadData.SetupHwnd = (HWND16)1;
            PD32.lpfnSetupHook   = WCD32PrintSetupDialogProc;
        }
    }

    // lock the original 16-bit hDevMode & hDevNames so they won't get thrown
    // out by our thunking.  (we need to restore them to the original handles
    // if there is an error in PrintDlg() ).
    hDM16 = WORD32(pPD16->hDevMode);
    hDN16 = WORD32(pPD16->hDevNames);
    WOWGlobalLock16(hDM16);
    WOWGlobalLock16(hDN16);

    dwFlags16 = DWORD32(pPD16->Flags);

    // get a new 32-bit devmode struct
    PD32.hDevMode  = ThunkhDevMode16to32(WORD32(pPD16->hDevMode));

    // get a new 32-bit devnames struct
    PD32.hDevNames = ThunkhDevNames16to32(WORD32(pPD16->hDevNames));

    ThunkPRINTDLG16to32(&PD32, pPD16);

    GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

    // this call invalidates flat ptrs to 16-bit memory
    PD32.hPrintTemplate
              = ThunkCDTemplate16to32(WORD32(pPD16->hInstance),
                                      MAKELONG(WORD32(pPD16->hPrintTemplate),1),
                                      DWORD32(pPD16->lpPrintTemplateName),
                                      dwFlags16,
                                      &(PD32.Flags),
                                      PD_ENABLEPRINTTEMPLATE,
                                      PD_ENABLEPRINTTEMPLATEHANDLE,
                                      &hPrintRes,
                                      &fError);

    if(fError) {
        goto PrintDlgError;
    }

    // memory may have moved - invalidate flat pointers now
    FREEVDMPTR(pPD16);

    GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

    // this call invalidates flat ptrs to 16-bit memory
    PD32.hSetupTemplate
              = ThunkCDTemplate16to32(WORD32(pPD16->hInstance),
                                      MAKELONG(WORD32(pPD16->hSetupTemplate),1),
                                      DWORD32(pPD16->lpSetupTemplateName),
                                      dwFlags16,
                                      &(PD32.Flags),
                                      PD_ENABLESETUPTEMPLATE,
                                      PD_ENABLESETUPTEMPLATEHANDLE,
                                      &hSetupRes,
                                      &fError);

PrintDlgError:
    if(fError) {
        WOWGlobalUnlock16(hDM16);
        WOWGlobalUnlock16(hDN16);
        goto PrintDlgExit;
    }

    // memory may have moved - invalidate flat pointers now
    FREEVDMPTR(pPD16);

    WCDDUMPPRINTDLGDATA32(&PD32);

    // Set this just before the calling into comdlg32.  This prevents the
    // synchronization stuff from firing until we actually need it.
    CURRENTPTD()->CommDlgTd = &ThreadData;

    ul = GETBOOL16(PrintDlg(&PD32));

    CURRENTPTD()->CommDlgTd = ThreadData.Previous;

    // blow away our locks so these really can be free'd if needed
    WOWGlobalUnlock16(hDM16);
    WOWGlobalUnlock16(hDN16);

    if(ul) {

        WCDDUMPPRINTDLGDATA32(&PD32);

        // this call invalidates flat ptrs to 16-bit mem
        ThunkPRINTDLG32to16(vppd, &PD32);

        GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

        WCDDUMPPRINTDLGDATA16(pPD16);

        // throw out the old ones if the structs were updated
        if(WORD32(pPD16->hDevMode) != hDM16) {
            WOWGlobalFree16(hDM16);
        }
        if(WORD32(pPD16->hDevNames) != hDN16) {
            WOWGlobalFree16(hDN16);
        }

    } else {

        // throw away any new hDevMode's & hDevNames that we might have created
        // as a result of our thunking & restore the originals
        GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);
        if(WORD32(pPD16->hDevMode) != hDM16) {
            WOWGlobalFree16(WORD32(pPD16->hDevMode));
            STOREWORD(pPD16->hDevMode, hDM16);
        }
        if(WORD32(pPD16->hDevNames) != hDN16) {
            WOWGlobalFree16(WORD32(pPD16->hDevNames));
            STOREWORD(pPD16->hDevNames, hDN16);
        }
    }

PrintDlgExit:

    WOWGLOBALFREE(PD32.hDevMode);
    WOWGLOBALFREE(PD32.hDevNames);

    if(PD32.hPrintTemplate) {
        FreeCDTemplate32(hPrintRes,
                         PD32.hPrintTemplate,
                         dwFlags16 & PD_ENABLEPRINTTEMPLATE,
                         dwFlags16 & PD_ENABLEPRINTTEMPLATEHANDLE);
    }

    if(PD32.hSetupTemplate) {
        FreeCDTemplate32(hSetupRes,
                         PD32.hSetupTemplate,
                         dwFlags16 & PD_ENABLESETUPTEMPLATE,
                         dwFlags16 & PD_ENABLESETUPTEMPLATEHANDLE);
    }

    FREEVDMPTR(pPD16);

    return(ul);
}


#define PD_TEMPLATEMASK32        (PD_ENABLEPRINTTEMPLATE         | \
                                  PD_ENABLESETUPTEMPLATE)

#define PD_TEMPLATEHANDLEMASK32  (PD_ENABLEPRINTTEMPLATEHANDLE   | \
                                  PD_ENABLESETUPTEMPLATEHANDLE)



VOID
ThunkPRINTDLG16to32(OUT PRINTDLG        *pPD32,
                    IN  PPRINTDLGDATA16  pPD16)
{
    DWORD  Flags;
    HANDLE h32New;
    LPVOID lp32New;
    LPVOID lp32Cur;

    if(pPD16 && pPD32) {

        pPD32->lStructSize = sizeof(PRINTDLG);
        pPD32->hwndOwner   = HWND32(pPD16->hwndOwner);

        // get a new 32-bit devmode thunked from the 16-bit one...
        if(h32New = ThunkhDevMode16to32(WORD32(pPD16->hDevMode))) {
            lp32New = GlobalLock(h32New);
            lp32Cur = GlobalLock(pPD32->hDevMode);

            // ...and copy it over the current 32-bit devmode struct
            if(lp32New && lp32Cur) {
                RtlCopyMemory(lp32Cur,
                              lp32New,
                              ((LPDEVMODE)lp32New)->dmSize);
                GlobalUnlock(pPD32->hDevMode);
                GlobalUnlock(h32New);
            }
            WOWGLOBALFREE(h32New);
        }

        // we assume that the DEVNAMES struct will never change

        // hDC filled on output only

        // preserve the template flag state while copying flags
        // 1. save original template flags
        //     note: we never set the 32-bit PD_ENABLExxxxTEMPLATE flags
        // 2. copy flags from 16-bit struct (and add WOWAPP flag)
        // 3. turn off all template flags
        // 4. restore original template flag state
        Flags         = pPD32->Flags & PD_TEMPLATEHANDLEMASK32;
        pPD32->Flags  = DWORD32(pPD16->Flags) | CD_WOWAPP;
        pPD32->Flags &= ~(PD_TEMPLATEMASK32 | PD_TEMPLATEHANDLEMASK32);
        pPD32->Flags |= Flags;

        pPD32->nFromPage   = WORD32(pPD16->nFromPage);
        pPD32->nToPage     = WORD32(pPD16->nToPage);
        pPD32->nMinPage    = WORD32(pPD16->nMinPage);
        pPD32->nMaxPage    = WORD32(pPD16->nMaxPage);
        pPD32->nCopies     = WORD32(pPD16->nCopies);
        pPD32->lCustData   = DWORD32(pPD16->lCustData);

        // hInstance thunked separately

        // hPrintTemplate & hSetupTemplate thunked separately
    }

}



#define PD_TEMPLATEMASK16  (PD_ENABLEPRINTTEMPLATE         | \
                            PD_ENABLESETUPTEMPLATE         | \
                            PD_ENABLEPRINTTEMPLATEHANDLE   | \
                            PD_ENABLESETUPTEMPLATEHANDLE)

VOID
ThunkPRINTDLG32to16(IN  VPVOID    vppd,
                    OUT PRINTDLG *pPD32)
{
    HAND16           hDevMode16;
    HAND16           hDevNames16;
    PPRINTDLGDATA16  pPD16;
    DWORD            Flags, Flags16;


    GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

    if(pPD16 && pPD32) {

        if(pPD32->Flags & (PD_RETURNIC | PD_RETURNDC)) {
            STOREWORD(pPD16->hDC, GETHDC16(pPD32->hDC));
        }

        // thunk 32-bit DEVMODE structure back to 16-bit
        // hDevXXXX16 take care of RISC alignment problems
        hDevMode16  = WORD32(pPD16->hDevMode);
        hDevNames16 = WORD32(pPD16->hDevNames);

        // this call invalidates flat ptrs to 16-bit mem
        ThunkhDevMode32to16(&hDevMode16, pPD32->hDevMode);
        FREEVDMPTR(pPD16);

        GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

        // this call invalidates flat ptrs to 16-bit mem
        ThunkhDevNames32to16(&hDevNames16, pPD32->hDevNames);
        FREEVDMPTR(pPD16);

        GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

        STOREWORD(pPD16->hDevMode, hDevMode16);
        STOREWORD(pPD16->hDevNames, hDevNames16);

        // preserve the template flag state while copying flags
        // 1. save original template flags
        // 2. copy flags from 32-bit struct
        // 3. turn off all template flags and WOWAPP flag
        // 4. restore original template flag state
        Flags    = DWORD32(pPD16->Flags) & PD_TEMPLATEMASK16;
        Flags16  = pPD32->Flags;
        Flags16 &= ~(PD_TEMPLATEMASK16 | CD_WOWAPP);
        Flags16 |= Flags;
        STOREDWORD(pPD16->Flags, Flags16);

        STOREWORD(pPD16->nFromPage, GETUINT16(pPD32->nFromPage));
        STOREWORD(pPD16->nToPage,   GETUINT16(pPD32->nToPage));
        STOREWORD(pPD16->nMinPage,  GETUINT16(pPD32->nMinPage));
        STOREWORD(pPD16->nMaxPage,  GETUINT16(pPD32->nMaxPage));
        STOREWORD(pPD16->nCopies,   GETUINT16(pPD32->nCopies));
        FREEVDMPTR(pPD16);
    }
}





HGLOBAL
ThunkhDevMode16to32(IN HAND16 hDevMode16)
{
    INT         nSize;
    LPDEVMODE   lpdm32, pdm32;
    HGLOBAL     hDevMode32 = NULL;
    VPDEVMODE31 vpDevMode16;


    if (hDevMode16) {

        vpDevMode16 = GlobalLock16(hDevMode16, NULL);

        if(FETCHDWORD(vpDevMode16)) {

            if(pdm32 = ThunkDevMode16to32(vpDevMode16)) {

                nSize = FETCHWORD(pdm32->dmSize) + 
                        FETCHWORD(pdm32->dmDriverExtra);

                hDevMode32 = WOWGLOBALALLOC(GMEM_MOVEABLE, nSize);

                if(lpdm32 = GlobalLock(hDevMode32)) {
                    RtlCopyMemory((PVOID)lpdm32, (PVOID)pdm32, nSize);
                    GlobalUnlock(hDevMode32);
                }

                free_w(pdm32);
            }
            GlobalUnlock16(hDevMode16);
        }
    }

    return(hDevMode32);
}





VOID
ThunkhDevMode32to16(IN OUT HAND16 *phDevMode16,
                    IN     HANDLE  hDevMode32)
/*++

Routine Description:

    This routine thunks a 32-bit DevMode structure back into the 16-bit one.
    It will reallocate the 16-bit global memory block as necessary.

    WARNING: This may cause 16-bit memory to move, invalidating flat pointers.

Arguments:

    hDevMode    - Supplies a handle to a movable global memory object that
                  contains a 32-bit DEVMODE structure

    phDevMode16 - Supplies a pointer to a 16-bit handle to a movable global
                  memory object that will return the 16-bit DEVMODE structure.
                  If the handle is NULL, the object will be allocated.  It
                  may also be reallocated if its current size is not enough.

Return Value:

    None

--*/
{
    UINT        CurrentSize;
    UINT        RequiredSize;
    VPDEVMODE31 vpDevMode16;
    LPDEVMODE   lpDevMode32;

    if (hDevMode32 == NULL) {
        *phDevMode16 = (HAND16)NULL;
        return;
    }

    lpDevMode32 = GlobalLock(hDevMode32);
    if (lpDevMode32==NULL) {
        *phDevMode16 = (HAND16)NULL;
        return;
    }

    RequiredSize = lpDevMode32->dmSize        +
                   lpDevMode32->dmDriverExtra +
                   sizeof(WOWDM31);  // see notes in wstruc.c

    if (*phDevMode16 == (HAND16)NULL) {
        vpDevMode16 = GlobalAllocLock16(GMEM_MOVEABLE,
                                        RequiredSize,
                                        phDevMode16);
    } else {
        vpDevMode16 = GlobalLock16(*phDevMode16, &CurrentSize);

        if (CurrentSize < RequiredSize) {
            GlobalUnlockFree16(vpDevMode16);
            vpDevMode16 = GlobalAllocLock16(GMEM_MOVEABLE,
                                            RequiredSize,
                                            phDevMode16);
        }
    }

    if(ThunkDevMode32to16(vpDevMode16, lpDevMode32, RequiredSize)) {
        GlobalUnlock16(*phDevMode16);
    }
    else {
        *phDevMode16 = (HAND16)NULL;
    }

    GlobalUnlock(hDevMode32);
}




HANDLE
ThunkhDevNames16to32(IN HAND16 hDevNames16)
{
    INT         nSize;
    HANDLE      hDN32 = NULL;
    LPDEVNAMES  pdn32;
    PDEVNAMES16 pdn16;


    if(FETCHDWORD(hDevNames16)) {

        VPDEVNAMES vpDevNames;

        vpDevNames = GlobalLock16(hDevNames16, &nSize);

        if(nSize) {

            GETVDMPTR(vpDevNames, sizeof(DEVNAMES16), pdn16);

            if(pdn16) {

                hDN32 = WOWGLOBALALLOC(GMEM_MOVEABLE, nSize);

                if(pdn32 = GlobalLock(hDN32)) {
                    RtlCopyMemory((PVOID)pdn32, (PVOID)pdn16, nSize);
                    GlobalUnlock(hDN32);
                } else {
                    LOGDEBUG(0, ("ThunkhDEVNAMES16to32, 32-bit allocation(s) failed!\n"));
                }

                FREEVDMPTR(pdn16);
            }
            GlobalUnlock16(hDevNames16);
        }

    }

    return(hDN32);
}




VOID
ThunkhDevNames32to16(IN OUT HAND16 *phDevNames16,
                     IN     HANDLE  hDevNames)
/*++

Routine Description:

    This routine thunks a 32-bit DevNames structure back into the 16-bit one.
    It will reallocate the 16-bit global memory block as necessary.

    WARNING: This may cause 16-bit memory to move, invalidating flat pointers.

Arguments:

    hDevNames - Supplies a handle to a movable global memory object that
               contains a 32-bit DEVNAMES structure

    phDevNames16 - Supplies a pointer to a 16-bit handle to a movable global
               memory object that will return the 16-bit DEVNAMES structure.
               If the handle is NULL, the object will be allocated.  It
               may also be reallocated if its current size is not enough.

Return Value:

    None

--*/
{
    UINT CurrentSize;
    UINT RequiredSize;
    UINT CopySize;
    UINT MaxOffset;
    PDEVNAMES16 pdn16;
    VPDEVNAMES DevNames16;
    LPDEVNAMES DevNames32;


    if (hDevNames==NULL) {
        *phDevNames16=(HAND16)NULL;
        return;
    }

    DevNames32 = GlobalLock(hDevNames);
    if (DevNames32==NULL) {
        *phDevNames16=(HAND16)NULL;
        return;
    }
    MaxOffset = max(max(DevNames32->wDriverOffset,DevNames32->wDeviceOffset),
                    DevNames32->wOutputOffset);

    // ProComm Plus copies 0x48 constant bytes after Print Setup.
    CopySize = MaxOffset + strlen((PCHAR)DevNames32+MaxOffset) + 1;
    RequiredSize = max(CopySize, 0x48);

    if (*phDevNames16==(HAND16)NULL) {
        DevNames16 = GlobalAllocLock16(GMEM_MOVEABLE,
                                       RequiredSize,
                                       phDevNames16);
    } else {
        DevNames16 = GlobalLock16(*phDevNames16, &CurrentSize);
        if (CurrentSize < RequiredSize) {
            GlobalUnlockFree16(DevNames16);
            DevNames16 = GlobalAllocLock16(GMEM_MOVEABLE,
                                           RequiredSize,
                                           phDevNames16);
        }
    }

    GETVDMPTR(DevNames16, RequiredSize, pdn16);
    if (pdn16==NULL) {
        *phDevNames16=(HAND16)NULL;
        GlobalUnlock(hDevNames);
        return;
    }
    RtlCopyMemory(pdn16,DevNames32,CopySize);
    FREEVDMPTR(pdn16);
    GlobalUnlock16(*phDevNames16);
    GlobalUnlock(hDevNames);
}






ULONG FASTCALL
WCD32GetOpenFileName( PVDMFRAME pFrame )
/*++

Routine Description:

    This routine thunks the 16-bit GetOpenFileName common dialog to the
    32-bit side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    return(WCD32GetFileName(pFrame,GetOpenFileName));
}




ULONG FASTCALL
WCD32GetSaveFileName( PVDMFRAME pFrame )
/*++

Routine Description:

    This routine thunks the 16-bit GetOpenFileName common dialog to the
    32-bit side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    return(WCD32GetFileName(pFrame,GetSaveFileName));
}





ULONG
WCD32GetFileName(IN PVDMFRAME pFrame,
                 IN FILENAMEPROC Function)
/*++

Routine Description:

    This routine is called by WCD32GetOpenFileName and WCD32GetSaveFileName.
    It does all the real thunking work.

Arguments:

    pFrame - Supplies 16-bit argument frame

    Function - supplies a pointer to the 32-bit function to call (either
               GetOpenFileName or GetSaveFileName)

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    ULONG                       ul = 0;
    register PGETOPENFILENAME16 parg16;
    VPOPENFILENAME              vpof;
    OPENFILENAME                OFN32;
    POPENFILENAME16             pOFN16;
    COMMDLGTD                   ThreadData;
    PRES                        pRes = NULL;
    DWORD                       dwFlags16 = 0;
    USHORT                      cb;
    PBYTE                       lpcb;
    BOOL                        fError = FALSE;


    GETARGPTR(pFrame, sizeof(GETOPENFILENAME16), parg16);
    vpof = parg16->lpof;

    SETEXTENDEDERROR(0);

    // invalidate this now
    FREEARGPTR(parg16);

    // initialize unique window messages
    if (msgFILEOK == 0) {

        if(!(msgSHAREVIOLATION = (WORD)RegisterWindowMessage(SHAREVISTRING))) {
            SETEXTENDEDERROR( CDERR_REGISTERMSGFAIL );
            LOGDEBUG(2,("WCD32GetFileName:RegisterWindowMessage failed\n"));
            return(0);
        }
        if(!(msgFILEOK = (WORD)RegisterWindowMessage(FILEOKSTRING))) {
            SETEXTENDEDERROR( CDERR_REGISTERMSGFAIL );
            LOGDEBUG(2,("WCD32GetFileName:RegisterWindowMessage 2 failed\n"));
            return(0);
        }

        // initialize private WOW-comdlg32 message
        msgWOWDIRCHANGE = (WORD)RegisterWindowMessage("WOWDirChange");
    }

    GETVDMPTR(vpof, sizeof(OPENFILENAME16), pOFN16);

    WCDDUMPOPENFILENAME16(pOFN16);

    if(!pOFN16 || DWORD32(pOFN16->lStructSize) != sizeof(OPENFILENAME16)) {
        SETEXTENDEDERROR( CDERR_STRUCTSIZE );
        FREEVDMPTR(pOFN16);
        return(0);
    }

    RtlZeroMemory(&ThreadData, sizeof(COMMDLGTD));
    ThreadData.Previous = CURRENTPTD()->CommDlgTd;
    ThreadData.hdlg     = (HWND16)-1;
    ThreadData.pData32  = (PVOID)&OFN32;
    ThreadData.Flags    = WOWCD_ISOPENFILE;
    if(DWORD32(pOFN16->Flags) & OFN_ENABLEHOOK) {
        ThreadData.vpfnHook = DWORD32(pOFN16->lpfnHook);
        if(!ThreadData.vpfnHook) {
            SETEXTENDEDERROR(CDERR_NOHOOK);
            FREEVDMPTR(pOFN16);
            return(0);
        }
        ThreadData.vpData   = vpof;
    }
    RtlZeroMemory(&OFN32, sizeof(OPENFILENAME));

    if(!Alloc_OFN32_strs(&OFN32, pOFN16)) {
        SETEXTENDEDERROR(CDERR_MEMALLOCFAILURE);
        goto GetFileNameExit;
    }

    // On Win3.1, the system sets these flags in the app's struct under the
    // shown conditions so we need to update the 16-bit struct too.
    dwFlags16 = DWORD32(pOFN16->Flags);
    if(dwFlags16 & OFN_CREATEPROMPT) {
        dwFlags16 |= OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
    }
    else if(dwFlags16 & OFN_FILEMUSTEXIST) {
        dwFlags16 |= OFN_PATHMUSTEXIST;
    }

    // A bug in Serif PagePlus 3.0 sets the high word to 0xFFFF which causes
    // the new moniker stuff in comdlg32 to break. #148137 - cmjones
    // VadimB: the mask below causes apps that do want lfn to break, so check
    // for those apps via the compat flag and let them go unpunished

    if ((dwFlags16 & OFN_LONGNAMES) &&
        (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_ALLOWLFNDIALOGS)) {
          dwFlags16 = (dwFlags16 & VALID_OFN16_FLAGS) | OFN_LONGNAMES;
    }
    else {
          dwFlags16 &= VALID_OFN16_FLAGS;
    }

    STOREDWORD(pOFN16->Flags, dwFlags16);

    if(!ThunkOPENFILENAME16to32(&OFN32, pOFN16)) {
        SETEXTENDEDERROR(CDERR_MEMALLOCFAILURE);
        goto GetFileNameExit;
    }

    dwFlags16 = DWORD32(pOFN16->Flags);  // get updated flags

    // make sure the current directory is up to date
    UpdateDosCurrentDirectory(DIR_DOS_TO_NT);

    // this call invalidates flat ptrs to 16-bit memory
    OFN32.hInstance = ThunkCDTemplate16to32(WORD32(pOFN16->hInstance),
                                            0,
                                            DWORD32(pOFN16->lpTemplateName),
                                            dwFlags16,
                                            &(OFN32.Flags),
                                            OFN_ENABLETEMPLATE,
                                            OFN_ENABLETEMPLATEHANDLE,
                                            &pRes,
                                            &fError);

    if(fError) {
        goto GetFileNameExit;
    }

    // memory may move - free flat pointers now
    FREEVDMPTR(pOFN16);

    WCDDUMPOPENFILENAME32(&OFN32);

    // Set this just before the calling into comdlg32.  This prevents the
    // synchronization stuff from firing until we actually need it.
    CURRENTPTD()->CommDlgTd = &ThreadData;

    // this call invalidates flat ptrs to 16-bit memory
    ul = GETBOOL16((*Function)(&OFN32));

    CURRENTPTD()->CommDlgTd = ThreadData.Previous;

    WCDDUMPOPENFILENAME32(&OFN32);

    UpdateDosCurrentDirectory(DIR_NT_TO_DOS);

    GETVDMPTR(vpof, sizeof(OPENFILENAME16), pOFN16);

    if (ul) {
        ThunkOPENFILENAME32to16(pOFN16, &OFN32, TRUE);

    }

    // else if the buffer is too small, lpstrFile contains the required buffer
    // size for the specified file
    else if (CommDlgExtendedError() == FNERR_BUFFERTOOSMALL) {

        SETEXTENDEDERROR(FNERR_BUFFERTOOSMALL);

        if(OFN32.lpstrFile && pOFN16->lpstrFile) {

            cb = *((PUSHORT)(OFN32.lpstrFile));  // is a WORD for comdlg32 too

            // 3 is the documented minimum size of the lpstrFile buffer
            GETVDMPTR(pOFN16->lpstrFile, 3, lpcb);

            // Win3.1 assumes that lpstrFile buffer is at least 3 bytes long
            // we'll try to be a little smarter than that...
            if(lpcb && (cb > pOFN16->nMaxFile)) {

                if(pOFN16->nMaxFile)
                    lpcb[0] = LOBYTE(cb);
                if(pOFN16->nMaxFile > 1)
                    lpcb[1] = HIBYTE(cb);
                if(pOFN16->nMaxFile > 2)
                    lpcb[2] = 0;  // Win3.1 appends a NULL

                FREEVDMPTR(lpcb);
            }
        }
    }

    WCDDUMPOPENFILENAME16(pOFN16);

GetFileNameExit:

    FreeCDTemplate32(pRes,
                     OFN32.hInstance,
                     dwFlags16 & OFN_ENABLETEMPLATE,
                     dwFlags16 & OFN_ENABLETEMPLATEHANDLE);

    Free_OFN32_strs(&OFN32);

    FREEVDMPTR(pOFN16);

    return(ul);
}




BOOL
ThunkOPENFILENAME16to32(OUT OPENFILENAME    *pOFN32,
                        IN  POPENFILENAME16  pOFN16)
/*++

Routine Description:

    This routine thunks a 16-bit OPENFILENAME structure to the 32-bit
    OPENFILENAME structure

Arguments:

    pOFN16 - Supplies a flat pointer to the 16-bit OPENFILENAME structure.

    pOFN32 - Supplies a pointer to the 32-bit OPENFILENAME structure.

Return Value:

    None.

--*/
{
    DWORD Flags;

    if(pOFN16 && pOFN32) {

        // Re-thunk all of the strings!!!
        // Persuasion 3.0 changes the various ptrs to strings depending on which
        // dialog buttons are pushed so we might have to dynamically re-alloc
        // some of the 32-bit string buffers.
        Thunk_OFNstrs16to32(pOFN32, pOFN16);

        pOFN32->lStructSize    = sizeof(OPENFILENAME);
        pOFN32->hwndOwner      = HWND32(pOFN16->hwndOwner);
        // hInstance thunked separately
        pOFN32->nMaxCustFilter = DWORD32(pOFN16->nMaxCustFilter);
        pOFN32->nFilterIndex   = DWORD32(pOFN16->nFilterIndex);
        pOFN32->nMaxFile       = DWORD32(pOFN16->nMaxFile);
        pOFN32->nMaxFileTitle  = DWORD32(pOFN16->nMaxFileTitle);

        // preserve the template flag state while copying flags
        // 1. save template flag state
        //     note: we never will have a 32-bit OFN_ENABLETEMPLATE flag
        //           we may or may not have a OFN_ENABLETEMPLATEHANDLE flag
        // 2. copy flags from 16-bit struct
        // 3. turn off all template flags
        // 4. restore original template flag state
        // 5. add the WOWAPP and no-long-names flags
        Flags          = pOFN32->Flags & OFN_ENABLETEMPLATEHANDLE;
        pOFN32->Flags  = DWORD32(pOFN16->Flags);
        pOFN32->Flags &= ~(OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE);
        pOFN32->Flags |= Flags;

        if ((pOFN32->Flags & OFN_LONGNAMES) &&
            (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_ALLOWLFNDIALOGS)) {
            pOFN32->Flags |= CD_WOWAPP;
        }
        else {
            pOFN32->Flags |= (OFN_NOLONGNAMES | CD_WOWAPP);
        }

        pOFN32->nFileOffset    = WORD32(pOFN16->nFileOffset);
        pOFN32->nFileExtension = WORD32(pOFN16->nFileExtension);
        pOFN32->lCustData      = DWORD32(pOFN16->lCustData);
        if(DWORD32(pOFN16->Flags) & OFN_ENABLEHOOK) {
            pOFN32->lpfnHook   = WCD32DialogProc;
        }
        // lpTemplateName32 is thunked separately

        // This is a hack to fix a bug in Win3.1 commdlg.dll.
        // Win3.1 doesn't check nMaxFileTitle before copying the FileTitle str.
        // (see Win3.1 src's \\pucus\win31aro\src\sdk\commdlg\fileopen.c)
        // TaxCut'95 depends on the title string being returned.
        if(pOFN32->lpstrFileTitle) {

            // if nMaxFileTitle > 0, NT will copy lpstrFileTitle
            if(pOFN32->nMaxFileTitle == 0) {
                pOFN32->nMaxFileTitle = 13;  // 8.3 filename + NULL
            }
        }

        return(TRUE);
    }

    return(FALSE);
}





VOID
ThunkOPENFILENAME32to16(OUT POPENFILENAME16  pOFN16,
                        IN  OPENFILENAME    *pOFN32,
                        IN  BOOLEAN          bUpperStrings)
/*++

Routine Description:

    This routine thunks a 32-bit OPENFILENAME structure back to a 16-bit
    OPENFILENAME structure.

Arguments:

    pOFN32 - Supplies a pointer to the 32-bit OPENFILENAME struct.

    pOFN16 - Supplies a flat pointer to the 16-bit OPENFILENAME struct

Return Value:

    None.

--*/
{
    int   len;
    LPSTR lpstr;
    DWORD Flags, Flags32;


    if(pOFN16 && pOFN32) {

        STOREWORD(pOFN16->nFileOffset,    pOFN32->nFileOffset);
        STOREWORD(pOFN16->nFileExtension, pOFN32->nFileExtension);
        STOREDWORD(pOFN16->nFilterIndex,  pOFN32->nFilterIndex);

        // preserve the template flag state while copying flags
        // 1. save template flag state
        // 2. copy flags from 32-bit struct
        // 3. turn off all template flags and the WOWAPP flag
        // 4. restore original template flag state
        Flags    = DWORD32(pOFN16->Flags) & (OFN_ENABLETEMPLATE |
                                             OFN_ENABLETEMPLATEHANDLE);
        Flags32  = pOFN32->Flags;
        Flags32 &= ~(OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE | CD_WOWAPP);
        Flags32 |= Flags;
        STOREDWORD(pOFN16->Flags, Flags32);

        if(bUpperStrings && pOFN32->lpstrFile) {

            // Note we have to upcase the pOFN32 here because some apps
            // (notably QC/Win) do case-sensitive compares on the extension.
            // In Win3.1, the upcasing happens as a side-effect of the
            // OpenFile call.  Here we do it explicitly.
            CharUpperBuff(pOFN32->lpstrFile, strlen(pOFN32->lpstrFile));
        }
        GETPSZPTR(pOFN16->lpstrFile, lpstr);
        if(lpstr && pOFN32->lpstrFile) {
            len = strlen(pOFN32->lpstrFile);
            len = min(len, (int)(DWORD32(pOFN16->nMaxFile)-1));
            strncpy(lpstr, pOFN32->lpstrFile, len);
            lpstr[len] = '\0';
            FREEPSZPTR(lpstr);
        }

        GETPSZPTR(pOFN16->lpstrFilter, lpstr);
        if(lpstr && pOFN32->lpstrFilter) {
            Multi_strcpy(lpstr, pOFN32->lpstrFilter);
            FREEPSZPTR(lpstr);
        }

        GETPSZPTR(pOFN16->lpstrCustomFilter, lpstr);
        if(lpstr && pOFN32->lpstrCustomFilter) {
            Multi_strcpy(lpstr, pOFN32->lpstrCustomFilter);
            FREEPSZPTR(lpstr);
        }

        if(bUpperStrings && (pOFN32->lpstrFileTitle)) {

            // Not sure if we really need to upcase this or not, but I figure
            // somewhere there is an app that depends on this being uppercased
            // like Win3.1
            CharUpperBuff(pOFN32->lpstrFileTitle,
                          strlen(pOFN32->lpstrFileTitle));
        }
        GETPSZPTR(pOFN16->lpstrFileTitle , lpstr);
        if(lpstr && pOFN32->lpstrFileTitle) {
            len = strlen(pOFN32->lpstrFileTitle);
            len = min(len, (int)(DWORD32(pOFN16->nMaxFileTitle)-1));
            strncpy(lpstr, pOFN32->lpstrFileTitle, len);
            lpstr[len] = '\0';
            FREEPSZPTR(lpstr);
        }

        // even though this is doc'd as being filled by the app only, Adobe
        // distiller depends on it being copied back to the app
        GETPSZPTR(pOFN16->lpstrInitialDir , lpstr);
        if(lpstr && pOFN32->lpstrInitialDir) {
            // we have no clue as to how large the dest buf the app sent us is
            strcpy(lpstr, pOFN32->lpstrInitialDir);
            FREEPSZPTR(lpstr);
        }

        // who knows who depends on this
        GETPSZPTR(pOFN16->lpstrTitle, lpstr);
        if(lpstr && pOFN32->lpstrTitle) {
            // we have no clue as to how large the dest buf the app sent us is
            strcpy(lpstr, pOFN32->lpstrTitle);
            FREEPSZPTR(lpstr);
        }
    }
}




BOOL
Alloc_OFN32_strs(IN OPENFILENAME    *pOFN32,
                 IN POPENFILENAME16  pOFN16)
{

    if(DWORD32(pOFN16->lpstrFilter)) {
        if(!(pOFN32->lpstrFilter =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrFilter),
                                         TRUE,
                                         0))) {
            goto ErrorExit;
        }
    }

    if(DWORD32(pOFN16->lpstrCustomFilter)) {
        if(!(pOFN32->lpstrCustomFilter =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrCustomFilter),
                                         TRUE,
                                         DWORD32(pOFN16->nMaxCustFilter) ))) {
            goto ErrorExit;
        }
    }

    if(DWORD32(pOFN16->lpstrFile)) {
        if(!(pOFN32->lpstrFile =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrFile),
                                         FALSE,
                                         DWORD32(pOFN16->nMaxFile) ))) {
            goto ErrorExit;
        }
    }

    if(DWORD32(pOFN16->lpstrFileTitle)) {
        if(!(pOFN32->lpstrFileTitle =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrFileTitle),
                                         FALSE,
                                         DWORD32(pOFN16->nMaxFileTitle) ))) {
            goto ErrorExit;
        }
    }

    if(DWORD32(pOFN16->lpstrInitialDir)) {
        if(!(pOFN32->lpstrInitialDir =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrInitialDir),
                                         FALSE,
                                         0))) {
            goto ErrorExit;
        }
    }

    if(DWORD32(pOFN16->lpstrTitle)) {
        if(!(pOFN32->lpstrTitle =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrTitle),
                                         FALSE,
                                         0))) {
            goto ErrorExit;
        }
    }

    if(DWORD32(pOFN16->lpstrDefExt)) {
        if(!(pOFN32->lpstrDefExt =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrDefExt),
                                         FALSE,
                                         0))) {
            goto ErrorExit;
        }
    }

    return(TRUE);

ErrorExit:
    LOGDEBUG(0, ("Alloc_OFN32_strs, 32-bit allocation(s) failed!\n"));
    Free_OFN32_strs(pOFN32);
    return(FALSE);

}





VOID
Free_OFN32_strs(IN OPENFILENAME *pOFN32)
{
    if(pOFN32->lpstrFilter) {
        free_w((PVOID)pOFN32->lpstrFilter);
        pOFN32->lpstrFilter = NULL;
    }

    if(pOFN32->lpstrCustomFilter) {
        free_w((PVOID)pOFN32->lpstrCustomFilter);
        pOFN32->lpstrCustomFilter = NULL;
    }

    if(pOFN32->lpstrFile) {
        free_w((PVOID)pOFN32->lpstrFile);
        pOFN32->lpstrFile = NULL;
    }

    if(pOFN32->lpstrFileTitle) {
        free_w((PVOID)pOFN32->lpstrFileTitle);
        pOFN32->lpstrFileTitle = NULL;
    }

    if(pOFN32->lpstrInitialDir) {
        free_w((PVOID)pOFN32->lpstrInitialDir);
        pOFN32->lpstrInitialDir = NULL;
    }

    if(pOFN32->lpstrTitle) {
        free_w((PVOID)pOFN32->lpstrTitle);
        pOFN32->lpstrTitle = NULL;
    }

    if(pOFN32->lpstrDefExt) {
        free_w((PVOID)pOFN32->lpstrDefExt);
        pOFN32->lpstrDefExt = NULL;
    }
}




VOID
Thunk_OFNstrs16to32(IN OPENFILENAME    *pOFN32,
                    IN POPENFILENAME16  pOFN16)
{
   pOFN32->lpstrFilter
                  = ThunkStr16toStr32((LPSTR)pOFN32->lpstrFilter,
                                      DWORD32(pOFN16->lpstrFilter),
                                      MAX_PATH,
                                      TRUE);

   pOFN32->lpstrCustomFilter
                  = ThunkStr16toStr32(pOFN32->lpstrCustomFilter,
                                      DWORD32(pOFN16->lpstrCustomFilter),
                                      DWORD32(pOFN16->nMaxCustFilter),
                                      TRUE);

   pOFN32->lpstrFile
                  = ThunkStr16toStr32(pOFN32->lpstrFile,
                                      DWORD32(pOFN16->lpstrFile),
                                      DWORD32(pOFN16->nMaxFile),
                                      FALSE);

   pOFN32->lpstrFileTitle
                  = ThunkStr16toStr32(pOFN32->lpstrFileTitle,
                                      DWORD32(pOFN16->lpstrFileTitle),
                                      DWORD32(pOFN16->nMaxFileTitle),
                                      FALSE);

   pOFN32->lpstrInitialDir
                  = ThunkStr16toStr32((LPSTR)pOFN32->lpstrInitialDir,
                                      DWORD32(pOFN16->lpstrInitialDir),
                                      MAX_PATH,
                                      FALSE);

   pOFN32->lpstrTitle
                  = ThunkStr16toStr32((LPSTR)pOFN32->lpstrTitle,
                                      DWORD32(pOFN16->lpstrTitle),
                                      MAX_PATH,
                                      FALSE);

   pOFN32->lpstrDefExt
                  = ThunkStr16toStr32((LPSTR)pOFN32->lpstrDefExt,
                                      DWORD32(pOFN16->lpstrDefExt),
                                      10,
                                      FALSE);
}




ULONG FASTCALL
WCD32FindText(PVDMFRAME pFrame)
/*++

Routine Description:

    This routine thunks the 16-bit FindText common dialog to the
    32-bit side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    return(WCD32FindReplaceText(pFrame, FindText));
}





ULONG FASTCALL
WCD32ReplaceText(PVDMFRAME pFrame)
/*++

Routine Description:

    This routine thunks the 16-bit ReplaceText common dialog to the
    32-bit side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    return(WCD32FindReplaceText(pFrame, ReplaceText));
}




ULONG
WCD32FindReplaceText(IN PVDMFRAME       pFrame,
                     IN FINDREPLACEPROC Function)
/*++

Routine Description:

    This routine is called by WCD32FindText and WCD32RepalceText.
    It copies a 16-bit FINDREPLACE structure to a 32-bit structure.
    Two per thread data entries are maintained. One is indexed by the
    owner hwnd, the other is indexed by the dialog hwnd. The dialog is
    always hooked by WCD32FindReplaceDialogProc, which dispatches to the
    16-bit hookproc, and takes care of clean-up on  WM_DESTROY, with dialog
    per thread data providing context. WCD32UpdateFindReplaceTextAndFlags
    updates the 16-bit FINDREPLACE structure when called by the WOW message
    dispatching logic upon reciept of a WM_NOTIFYWOW message from COMDLG32.
    The owner per thread data provides context for this operation.

Arguments:

    pFrame - Supplies 16-bit argument frame

    Function - supplies a pointer to the 32-bit function to call (either
               FindText or RepalceText)

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    register PFINDTEXT16  parg16;
    VPFINDREPLACE         vpfr;
    FINDREPLACE          *pFR32;
    PFINDREPLACE16        pFR16;
    PCOMMDLGTD            pTDDlg;
    PCOMMDLGTD            pTDOwner;
    HWND                  hwndDlg = NULL;
    DWORD                 dwFlags16 = 0;
    BOOL                  fError = FALSE;


    GETARGPTR(pFrame, sizeof(FINDREPLACE16), parg16);
    vpfr = parg16->lpfr;

    SETEXTENDEDERROR(0);

    // invalidate this now
    FREEVDMPTR( parg16 );

    GETVDMPTR(vpfr, sizeof(FINDREPLACE16), pFR16);

    WCDDUMPFINDREPLACE16(pFR16);

    if(!pFR16 || DWORD32(pFR16->lStructSize) != sizeof(FINDREPLACE16)) {
        SETEXTENDEDERROR( CDERR_STRUCTSIZE );
        FREEVDMPTR(pFR16);
        return(0);
    }

    if(!DWORD32(pFR16->lpstrFindWhat) ||
       !WORD32(pFR16->wFindWhatLen) ||
       !IsWindow(HWND32(pFR16->hwndOwner))) {
        SETEXTENDEDERROR(FRERR_BUFFERLENGTHZERO);
        FREEVDMPTR(pFR16);
        return(0);
    }

    // check the hook proc
    if(DWORD32(pFR16->Flags) & FR_ENABLEHOOK) {
        if(!DWORD32(pFR16->lpfnHook)) {
            SETEXTENDEDERROR(CDERR_NOHOOK);
            FREEVDMPTR(pFR16);
            return(0);
        }
    }
    else {
        STOREDWORD(pFR16->lpfnHook, 0);
    }

    // WCD32UpdateFindReplaceTextAndFlags will update the 16-bit FINDREPLACE
    // struct and help thunk the WM_NOTIFYWOW message to the
    // "commdlg_FindReplace" registered message.
    if (msgFINDREPLACE == 0) {
        if(!(msgFINDREPLACE = (WORD)RegisterWindowMessage(FINDMSGSTRING))) {
            LOGDEBUG(2,("WCD32FindReplaceText:RegisterWindowMessage failed\n"));
            SETEXTENDEDERROR( CDERR_REGISTERMSGFAIL );
            FREEVDMPTR(pFR16);
            return(0);
        }
    }

    // Allocate the required memory
    // Note: these can't be alloc'd off our stack since FindText & ReplaceText
    //       eventually call CreateDialogIndirectParam which returns immediately
    //       after displaying the dialog box.
    pFR32 = (FINDREPLACE *)malloc_w_zero(sizeof(FINDREPLACE));
    if(pFR32) {
        pFR32->lpstrFindWhat = (LPTSTR)malloc_w(WORD32(pFR16->wFindWhatLen));
        pFR32->lpstrReplaceWith
                             = (LPTSTR)malloc_w(WORD32(pFR16->wReplaceWithLen));
        pTDDlg   = malloc_w_zero(sizeof(COMMDLGTD));
        pTDOwner = malloc_w_zero(sizeof(COMMDLGTD));
    }

    if(  (pFR32                    &&
          pFR32->lpstrFindWhat     &&
          pFR32->lpstrReplaceWith  &&
          pTDDlg                   &&
          pTDOwner) == FALSE) {

        LOGDEBUG(0, ("WCD32FindReplaceText, 32-bit allocation(s) failed!\n"));
        SETEXTENDEDERROR(CDERR_MEMALLOCFAILURE);
        goto FindReplaceError;
    }

    pTDDlg->pData32 = pTDOwner->pData32 = (PVOID)pFR32;
    pTDDlg->vpData  = pTDOwner->vpData  = vpfr;

    // Set the per thread data indicies
    pTDDlg->hdlg   = (HWND16)-1;
    pTDOwner->hdlg = GETHWND16(pFR16->hwndOwner);

    // save the hook proc if any
    if(DWORD32(pFR16->Flags) & FR_ENABLEHOOK) {
        pTDDlg->vpfnHook = pTDOwner->vpfnHook = DWORD32(pFR16->lpfnHook);
    }

    ThunkFINDREPLACE16to32(pFR32, pFR16);
    dwFlags16 = DWORD32(pFR16->Flags);

    // this call invalidates flat ptrs to 16-bit memory
    pFR32->hInstance = ThunkCDTemplate16to32(WORD32(pFR16->hInstance),
                                             0,
                                             DWORD32(pFR16->lpTemplateName),
                                             dwFlags16,
                                             &(pFR32->Flags),
                                             FR_ENABLETEMPLATE,
                                             FR_ENABLETEMPLATEHANDLE,
                                             &(PRES)(pTDDlg->pRes),
                                             &fError);

    if(fError) {
        goto FindReplaceError;
    }

    // invalidate flat ptrs to 16-bit memory
    FREEVDMPTR(pFR16);

    WCDDUMPFINDREPLACE32(pFR32);

    // Link both per thread data structs into the list
    // do this just before calling into comdlg32
    pTDDlg->Previous        = CURRENTPTD()->CommDlgTd;
    pTDOwner->Previous      = pTDDlg;
    CURRENTPTD()->CommDlgTd = pTDOwner;

    // this call invalidates flat ptrs to 16-bit memory
    hwndDlg = (*Function)(pFR32);

    if (hwndDlg) {
        pTDDlg->hdlg = (HWND16)hwndDlg;
    } else {

FindReplaceError:
        LOGDEBUG(0, ("WCD32FindReplaceText, Failed!\n"));
        if(pTDDlg) {

            CURRENTPTD()->CommDlgTd = pTDDlg->Previous;

            FreeCDTemplate32(pTDDlg->pRes,
                             pFR32->hInstance,
                             dwFlags16 & FR_ENABLETEMPLATE,
                             dwFlags16 & FR_ENABLETEMPLATEHANDLE);
            free_w(pTDDlg);
        }

        if(pFR32) {

            if(pFR32->lpstrFindWhat)
                free_w(pFR32->lpstrFindWhat);

            if(pFR32->lpstrReplaceWith)
                free_w(pFR32->lpstrReplaceWith);

            free_w(pFR32);
        }

        if(pTDOwner)
            free_w(pTDOwner);
    }

    return(GETHWND16(hwndDlg));
}





VOID
ThunkFINDREPLACE16to32(OUT FINDREPLACE    *pFR32,
                       IN  PFINDREPLACE16  pFR16)
/*++

Routine Description:

    This routine thunks a 16-bit FINDREPLACE structure to the 32-bit
    structure

Arguments:

    pFR32 - Supplies a pointer to the 32-bit FINDREPLACE structure.

    pFR16 - Supplies a pointer to the 16-bit FINDREPLACE structure.

Return Value:

    None.

--*/
{
    LPSTR  lpstr;
    DWORD  Flags;


    if(pFR16 && pFR32) {

        pFR32->lStructSize = sizeof(FINDREPLACE);
        pFR32->hwndOwner   = HWND32(pFR16->hwndOwner);

        // hInstance is thunked separately

        // preserve the template flag state while copying flags
        // 1. save template flag state
        //     note: we never will have a 32-bit FR_ENABLETEMPLATE flag
        // 2. copy flags from 16-bit struct (add the WOWAPP flag)
        // 3. turn off all template flags
        // 4. restore original template flag state
        Flags         = pFR32->Flags & FR_ENABLETEMPLATEHANDLE;
        pFR32->Flags  = DWORD32(pFR16->Flags) | CD_WOWAPP;
        pFR32->Flags &= ~(FR_ENABLETEMPLATE | FR_ENABLETEMPLATEHANDLE);
        pFR32->Flags |= Flags;

        GETPSZPTR(pFR16->lpstrFindWhat, lpstr);
        if(lpstr && pFR32->lpstrFindWhat) {

            WOW32_strncpy(pFR32->lpstrFindWhat, lpstr, WORD32(pFR16->wFindWhatLen));
            pFR32->lpstrFindWhat[WORD32(pFR16->wFindWhatLen)-1] = '\0';
            FREEPSZPTR(lpstr);
        }

        GETPSZPTR(pFR16->lpstrReplaceWith, lpstr);
        if(lpstr && pFR32->lpstrReplaceWith) {
            WOW32_strncpy(pFR32->lpstrReplaceWith, lpstr, WORD32(pFR16->wReplaceWithLen));
            pFR32->lpstrReplaceWith[WORD32(pFR16->wReplaceWithLen)-1] = '\0';
            FREEPSZPTR(lpstr);
        }

        pFR32->wFindWhatLen    = WORD32(pFR16->wFindWhatLen);
        pFR32->wReplaceWithLen = WORD32(pFR16->wReplaceWithLen);
        pFR32->lCustData       = DWORD32(pFR16->lCustData);

        // we always put this WOW hook in so we can destroy the modeless dialog.
        // WCD32FindReplaceDialogPRoc will determine whether to really dispatch
        // to a 16-bit hookproc or not.  pFR16->lpfnHook will be NULL if there
        // isn't a 16-bit hook proc
        pFR32->lpfnHook  = WCD32FindReplaceDialogProc;
        pFR32->Flags    |= FR_ENABLEHOOK;

        // lpTemplateName32 is thunked separately
    }
}





VOID
ThunkFINDREPLACE32to16(OUT PFINDREPLACE16  pFR16,
                       IN  FINDREPLACE    *pFR32)
{
    LPSTR  lpstr;
    DWORD  Flags, Flags32;


    if(pFR16 && pFR32) {

        // Update the 16-bit structure.

        // preserve the template flag state while copying flags
        // 1. save template flag state
        // 2. copy flags from 32-bit struct
        // 3. turn off all template flags and the WOWAPP flag
        // 4. restore original template flag state
        Flags    = DWORD32(pFR16->Flags) & (FR_ENABLETEMPLATE |
                                            FR_ENABLETEMPLATEHANDLE);
        Flags32  = pFR32->Flags;
        Flags32 &= ~(FR_ENABLETEMPLATE | FR_ENABLETEMPLATEHANDLE | CD_WOWAPP);
        Flags32 |= Flags;

        // we may have to turn off the hookproc flag if we added it in
        // ThunkFINDREPLACE16to32().
        if(!DWORD32(pFR16->lpfnHook)) {
            Flags32 &= ~FR_ENABLEHOOK;
        }
        STOREDWORD(pFR16->Flags, Flags32);

        GETPSZPTR(pFR16->lpstrFindWhat, lpstr);
        if(lpstr && pFR32->lpstrFindWhat) {
            WOW32_strncpy(lpstr, pFR32->lpstrFindWhat, WORD32(pFR16->wFindWhatLen));
            lpstr[WORD32(pFR16->wFindWhatLen)-1] = '\0';
            FREEPSZPTR(lpstr);
        }

        GETPSZPTR(pFR16->lpstrReplaceWith, lpstr);
        if(lpstr && pFR32->lpstrReplaceWith) {
            WOW32_strncpy(lpstr,
                    pFR32->lpstrReplaceWith,
                    WORD32(pFR16->wReplaceWithLen));
            lpstr[WORD32(pFR16->wReplaceWithLen)-1] = '\0';
            FREEPSZPTR(lpstr);
        }
    }
}





LONG APIENTRY
WCD32UpdateFindReplaceTextAndFlags(HWND hwndOwner,
                                   LPARAM lParam)
{
    PCOMMDLGTD           ptdOwner;
    PFINDREPLACE16       pFR16;
    VPFINDREPLACE        vpfr;
    LPFINDREPLACE        pFR32 = (LPFINDREPLACE) lParam;
    LONG                 lRet = 0;


    ptdOwner = GetCommdlgTd(hwndOwner);
    if(ptdOwner == NULL) {
        WOW32ASSERT(FALSE);
        return(0);
    }

    vpfr = ptdOwner->vpData;
    GETVDMPTR(vpfr, sizeof(FINDREPLACE16), pFR16);

    ThunkFINDREPLACE32to16(pFR16, pFR32);

    WCDDUMPFINDREPLACE16(pFR16);

    FREEVDMPTR(pFR16);

    return(vpfr);
}





PCOMMDLGTD
GetCommdlgTd(IN HWND Hwnd32)
/*++

Routine Description:

    Searches the thread's chain of commdlg data for the given 32-bit window.
    If the window is not already in the chain, it is added.

Arguments:

    Hwnd32 - Supplies the 32-bit hwnd that the dialog procedure was called
    with.

Return Value:

    Pointer to commdlg data.

--*/
{
    PCOMMDLGTD pTD;

    if ((pTD = CURRENTPTD()->CommDlgTd) == NULL) {
        return(NULL);
    }

    // look for the CommDlgTD struct for this dialog -- usually will be first
    // unless there are nested dialogs
    while (pTD->hdlg != GETHWND16(Hwnd32)) {

        pTD = pTD->Previous;

        // If Hwnd32 isn't in the list, we're probably getting called back
        // from user32 via WOWTellWOWThehDlg().  This means that the dialog
        // window was just created in user32.  Note that this can be either a
        // new dialog or a PrintSetup dialog.
        if (pTD==NULL) {

            pTD = CURRENTPTD()->CommDlgTd;
 
            if(pTD == NULL) {
                WOW32ASSERT(FALSE);
                return(NULL);
            }

            while (pTD->hdlg != (HWND16)-1) {

                // Check to see if this is the first call for a PrintSetupHook.
                // It will share the same CommDlgTD as the PrintDlgHook.
                // Note: SetupHwnd will be 1 if this is the 1st time the user
                //       clicks the Setup button in the PrintDlg. Otherwise
                //       it will be the old Hwnd32 from the previous time he
                //       clicked the Setup button from within the same instance
                //       of the PrintDlg. Either way it is non-zero.
                if(pTD->SetupHwnd) {

                    // if the current CommDlgTD->hdlg is the owner of Hwnd32,
                    // we found the CommDlgTD for the PrintSetup dialog.
                    if(pTD->hdlg == GETHWND16(GetWindow(Hwnd32, GW_OWNER))) {
                        pTD->SetupHwnd = GETHWND16(Hwnd32);
                        return(pTD);
                    }
                }

                pTD = pTD->Previous;

                if(pTD == NULL) {
                    WOW32ASSERT(FALSE);
                    return(NULL);
                }
            }

            // set the hdlg for this CommDlgTD
            pTD->hdlg = GETHWND16(Hwnd32);
            return(pTD);
        }
    }

    return(pTD);
}





// Thunks 16-bit Common dialog templates to 32-bit
// Note: this calls back to 16-bit code causing possible 16-bit memory movement
// Note: GetTemplate16 call SETEXTENDEDERROR for *most* failures
HINSTANCE
ThunkCDTemplate16to32(IN     HAND16  hInst16,
                      IN     DWORD   hPT16,  // for PrintDlg only
                      IN     VPVOID  vpTemplateName,
                      IN     DWORD   dwFlags16,
                      IN OUT DWORD  *pFlags,
                      IN     DWORD   ETFlag,   // XX_ENABLETEMPLATE flag
                      IN     DWORD   ETHFlag,  // XX_ENABLETEMPLATEHANDLE flag
                      OUT    PPRES   pRes,
                      OUT    PBOOL   fError)
{
    // Note: struct->hInstance == NULL if neither xx_ENABLExxx flag is set
    HINSTANCE hInst32 = NULL;
    HAND16    hPrintTemp16 = (HAND16)NULL;


    SETEXTENDEDERROR( CDERR_NOTEMPLATE );  // most common error ret

    if(hPT16) {
        hPrintTemp16 = (HAND16)LOWORD(hPT16);
    }

    *pRes = NULL;
    if(dwFlags16 & ETFlag) {

        if(!vpTemplateName) {
            *fError = TRUE;
            return(NULL);
        }

        if(!hInst16) {
            SETEXTENDEDERROR( CDERR_NOHINSTANCE );
            *fError = TRUE;
            return(NULL);
        }

	    // Note: calls to GetTemplate16 may cause 16-bit memory to move
        *pRes = GetTemplate16(hInst16, vpTemplateName, FALSE);

	    if(*pRes == NULL) {
            *fError = TRUE;
            return(NULL);
        }

        hInst32 = (HINSTANCE)LockResource16(*pRes);

        if(!hInst32) {
            *fError = TRUE;
            SETEXTENDEDERROR( CDERR_LOCKRESFAILURE );
            return(NULL);
        }

        *pFlags &= ~ETFlag;
        *pFlags |= ETHFlag;

    } else if(dwFlags16 & ETHFlag) {

        // Win'95 does the following if !hInst && ETHFlag.
        // Note: the return val == FALSE in all cases except the last PD case
        //    CC  (0x00040) -> CDERR_NOTEMPLATE
        //    CF  (0x00020) -> No error (comdlg32 err = CDERR_LOCKRESFAILURE)
        //    FR  (0x02000) -> CDERR_LOCKRESFAILURE
        //    OFN (0x00080) -> CDERR_LOCKRESFAILURE
        //    PD  (0x10000) -> CDERR_LOCKRESFAILURE  (hInstance)
        //    PD  (0x20040) -> CDERR_LOCKRESFAILURE  (with PD_PRINTSETUP)
        //    PD  (0x20000) -> CDERR_LOCKRESFAILURE
        //
        // I think the error value is probably irrelavant since most of these
        // are pathological cases that only developers would see while building
        // and debugging their app.  In the cases where the Win'95 error code is
        // CDERR_LOCKRESFAILURE, comdlg32 sets it to CDERR_NOTEMPLATE (as we
        // now return for WOW) for 32-bit apps

        // one of the hTemplate's should always be set with the
        // ENABLETEMPLATEHANDLE flag

        // if it's a printdlg...
        if(hPT16) {

            // ...the hTemplate should be in either hPrintTemplate or
            // hPrintSetupTemplate
            if(!hPrintTemp16) {
                *fError = TRUE;
            }
        }

        // else for non-printdlg's, the hTemplate should be in hInstance
        else {
            if(!hInst16) {
                *fError = TRUE;
            }
        }

        if(*fError) {
            return(NULL);
        }

	    // Note: calls to GetTemplate16 may cause 16-bit memory to move
        if(hPT16) {
            hInst32 = (HINSTANCE) GetTemplate16(hPrintTemp16,(VPCSTR)NULL,TRUE);
        } else {
            hInst32 = (HINSTANCE) GetTemplate16(hInst16, (VPCSTR)NULL, TRUE);
        }
        if(!hInst32) {
            *fError = TRUE;
            return(NULL);
        }
        *pFlags |= ETHFlag;
    }

    SETEXTENDEDERROR( 0 ); // reset to no error

    return(hInst32);
}




VOID
FreeCDTemplate32(IN PRES      pRes,
                 IN HINSTANCE hInst,
                 IN BOOL      bETFlag,
                 IN BOOL      bETHFlag)
{
    if(pRes && bETFlag) {
        UnlockResource16(pRes);
        FreeResource16(pRes);
    } else if(hInst && bETHFlag) {
        free_w((PVOID)hInst);
    }
}



PRES
GetTemplate16(IN HAND16 hInstance,
              IN VPCSTR lpTemplateName,
              IN BOOLEAN UseHandle)
/*++

Routine Description:

    Finds and loads the specified 16-bit dialog template.

    WARNING: This may cause memory movement, invalidating flat pointers

Arguments:

    hInstance - Supplies the data block containing the dialog box template

    TemplateName - Supplies the name of the resource file for the dialog
        box template.  This may be either a null-terminated string or
        a numbered resource created with the MAKEINTRESOURCE macro.

    UseHandle - Indicates that hInstance identifies a pre-loaded dialog
        box template.  If this is TRUE, Templatename is ignored.

Return Value:

    success - A pointer to the loaded resource

    failure - NULL, dwLastError will be set.

--*/
{
    LPSZ    TemplateName=NULL;
    PRES    pRes;
    PBYTE   pDlg = NULL;
    INT     cb;
    INT     cb16;

    if (!UseHandle) {

        GETPSZIDPTR(lpTemplateName, TemplateName);

        // Both custom instance handle and the dialog template name are
        // specified.  Locate the 16-bit dialog resource in the specified
        // instance block and load it.
        pRes = FindResource16(hInstance,
                              TemplateName,
                              (LPSZ)RT_DIALOG);

        if (HIWORD(lpTemplateName) != 0) {
            FREEVDMPTR(TemplateName);
        }
        if (!pRes) {
            SETEXTENDEDERROR( CDERR_FINDRESFAILURE );
            return(NULL);
        }
        if (!(pRes = LoadResource16(hInstance,pRes))) {
            SETEXTENDEDERROR( CDERR_LOADRESFAILURE );
            return(NULL);
        }

        return(pRes);
    } else {

        VPVOID pDlg16;

        if (pDlg16 = RealLockResource16(hInstance, &cb16)) {
            cb = ConvertDialog16(NULL, pDlg16, 0, cb16);
            if (cb != 0) {
                if (pDlg = malloc_w(cb)) {
                    ConvertDialog16(pDlg, pDlg16, cb, cb16);
                }
            }
            GlobalUnlock16(hInstance);
        }
        else {
            SETEXTENDEDERROR( CDERR_LOCKRESFAILURE );
        }
        return((PRES)pDlg);
    }

}





// When an app calls a ComDlg API it passes a ptr to the appropriate structure.
// On Win3.1 the app & the system share a ptr to the same structure, so when
// either updates the struct, the other is aware of the change.  On NT we thunk
// the 16-bit struct to a 32-bit ANSI struct which is then thunked to a 32-bit
// UNICODE struct by the ComDlg32 code.  We need a mechanism to put all three
// structs in sync.  We attempt to do this by calling ThunkCDStruct32to16()
// from the WCD32xxxxDialogProc()'s (xxxx = Common OR FindReplace) for
// WM_INITDIALOG and WM_COMMAND messages before we callback the 16-bit hook
// proc.  We call ThunkCDStruct16to32() when we return from the 16-bit hook.
VOID
ThunkCDStruct16to32(IN HWND         hDlg,
                    IN CHOOSECOLOR *p32,
                    IN VPVOID       vp)
{

    PCHOOSECOLORDATA16  p16;

    GETVDMPTR(vp, sizeof(CHOOSECOLORDATA16), p16);

    if(p16) {

        switch(p16->lStructSize) {

            case sizeof(CHOOSECOLORDATA16):
                ThunkCHOOSECOLOR16to32(p32, p16);
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, TRUE, WOW_CHOOSECOLOR);
                break;

            case sizeof(CHOOSEFONTDATA16):
                ThunkCHOOSEFONT16to32((CHOOSEFONT *) p32,
                                      (PCHOOSEFONTDATA16) p16);
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, TRUE, WOW_CHOOSEFONT);
                break;

            case sizeof(FINDREPLACE16):
                ThunkFINDREPLACE16to32((FINDREPLACE *) p32,
                                       (PFINDREPLACE16) p16);
                // Find/Replace ANSI-UNICODE sync's are handled by
                // WCD32UpdateFindReplaceTextAndFlags() mechanism
                break;

            case sizeof(OPENFILENAME16):
                ThunkOPENFILENAME16to32((OPENFILENAME *) p32,
                                        (POPENFILENAME16) p16);
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, TRUE, WOW_OPENFILENAME);
                break;

            case sizeof(PRINTDLGDATA16):
                ThunkPRINTDLG16to32((PRINTDLG *) p32, (PPRINTDLGDATA16) p16);
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, TRUE, WOW_PRINTDLG);
                break;

        }

        FREEVDMPTR(p16);

    }
}





VOID
ThunkCDStruct32to16(IN HWND         hDlg,
                    IN VPVOID       vp,
                    IN CHOOSECOLOR *p32)
{

    PCHOOSECOLORDATA16  p16;

    GETVDMPTR(vp, sizeof(CHOOSECOLORDATA16), p16);

    if(p16) {

        switch(p16->lStructSize) {

            case sizeof(CHOOSECOLORDATA16):
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, FALSE, WOW_CHOOSECOLOR);
                ThunkCHOOSECOLOR32to16(p16, p32);
                break;

            case sizeof(CHOOSEFONTDATA16):
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, FALSE, WOW_CHOOSEFONT);
                ThunkCHOOSEFONT32to16((PCHOOSEFONTDATA16) p16,
                                      (CHOOSEFONT *) p32);
                break;

            case sizeof(FINDREPLACE16):
                // Find/Replace ANSI-UNICODE sync's are handled by
                // WCD32UpdateFindReplaceTextAndFlags() mechanism
                ThunkFINDREPLACE32to16((PFINDREPLACE16) p16,
                                       (FINDREPLACE *) p32);
                break;

            case sizeof(OPENFILENAME16):
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, FALSE, WOW_OPENFILENAME);
                ThunkOPENFILENAME32to16((POPENFILENAME16) p16,
                                        (OPENFILENAME *) p32,
                                        TRUE);
                break;

            case sizeof(PRINTDLGDATA16):
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, FALSE, WOW_PRINTDLG);
                ThunkPRINTDLG32to16(vp, (PRINTDLG *) p32);
                break;

        }

        FREEVDMPTR(p16);

    }
}




VOID Multi_strcpy(LPSTR dst, LPCSTR src)
/*++
  strcpy for string lists that have several strings that are separated by
  a null char and is terminated by two NULL chars.
--*/
{
    if(src && dst) {

        while(*src) {
            while(*dst++ = *src++)
                ;
        }
        *dst = '\0';
    }
}



INT Multi_strlen(LPCSTR str)
/*++
  strlen for string lists that have several strings that are separated by
  a null char and is terminated by two NULL chars.

  Returns len of str including all NULL *separators* but not the 2nd NULL
  terminator.  ie.  cat0dog00 would return len = 8;
--*/
{
    INT i = 0;

    if(str) {

        while(*str) {
            while(*str++)
                i++;
            i++;  // count the NULL separator
        }
    }

    return(i);
}




VOID Ssync_WOW_CommDlg_Structs(PCOMMDLGTD pTDIn,
                               BOOL f16to32,
                               DWORD dwThunkCSIP)
{
    HWND       hDlg;
    WORD       wCS16;
    PCOMMDLGTD pTDPrev;
    PCOMMDLGTD pTD = pTDIn;


    // we shouldn't sync for calls from krnl386 into wow32 (we found out)
    // eg. when kernel is handling segment not present faults etc.
    if(dwThunkCSIP) {

        wCS16 = HIWORD(dwThunkCSIP);

        if((wCS16 == gwKrnl386CodeSeg1) ||
           (wCS16 == gwKrnl386CodeSeg2) ||
           (wCS16 == gwKrnl386CodeSeg3))    {
                return;
        }
    }

    // since we don't have an hwnd to compare with we really don't know which
    // PCOMMDLGTD is the one we want -- so we have to sync them all.
    // This is only a problem for nested dialogs which is fairly rare.
    while(pTD) {

        // if this hasn't been initialized yet there is nothing to do
        if(pTD->hdlg == (HWND16)-1) {
            break;
        }

        hDlg = HWND32(pTD->hdlg);

        WOW32ASSERTMSG(hDlg,
                       ("WOW:Ssync_WOW_CommDlg_Structs: hDlg not found!\n"));

        //BlockWOWIdle(TRUE);

        if(f16to32) {
            ThunkCDStruct16to32(hDlg, (CHOOSECOLOR *)pTD->pData32, pTD->vpData);
        }
        else {
            ThunkCDStruct32to16(hDlg, pTD->vpData, (CHOOSECOLOR *)pTD->pData32);
        }

        //BlockWOWIdle(FALSE);

        pTDPrev = pTD->Previous;

        // multiple PCOMMDLGTD's in the list means 1 of 2 things:
        //   1. This is a find/replace text dialog
        //   2. This is a screwy nested dialog situation
        if(pTDPrev) {

            // 1. check for find/replace (it uses two PCOMMDLGTD structs and
            //    shares the same pData32 pointer with both)
            if(pTDPrev->pData32 == pTD->pData32) {

                // nothing to do -- they share the same data which was thunked
                // above so we'll go on to the next PCOMMDLGTD in the list
                pTD = pTDPrev->Previous;
            }

            // 2. there are nested dialogs lurking about & we need to sync
            //    each one!
            else {
                pTD = pTDPrev;
            }
        } else {
            break;
        }
    }
}




// There is a special case issue (we found) where certain dialog box
// API calls can pass a pszptr that is in a common dialog struct ie:
// GetDlgItemText(hDlg, id, OFN16->lpstrFile, size).  Our synchronization
// mechanism actually trashes OFN16->lpstrFile when we sync 32->16 upon
// returning from the API call.  To avoid this we will sync 16->32 upon
// returning from the API call (if needed as per the conditions below)
// before we sync 32->16 thus preserving the string returned in the 16-bit
// buffer.  The special case API's identified so far are:
//   GetDlgItemText, GetWindowText(), DlgDirSelectxxxx, and SendDlgItemMessage.
VOID Check_ComDlg_pszptr(PCOMMDLGTD ptd, VPVOID vp)
{
    VPVOID             vpData;
    POPENFILENAME16    p16;


    if(ptd) {

        vpData = ptd->vpData;
        if(vpData) {

            GETVDMPTR(vpData, sizeof(CHOOSECOLORDATA16), p16);

            if(p16) {

                switch(p16->lStructSize) {

                    // Only these 2 ComDlg structures have OUTPUT buffers.

                    case sizeof(CHOOSEFONTDATA16):
                        if((VPVOID)((PCHOOSEFONTDATA16)p16)->lpszStyle == vp) {
                            Ssync_WOW_CommDlg_Structs(ptd, w16to32, 0);
                        }
                        break;

                    case sizeof(OPENFILENAME16):
                        if(((VPVOID)p16->lpstrFilter       == vp) ||
                           ((VPVOID)p16->lpstrCustomFilter == vp) ||
                           ((VPVOID)p16->lpstrFile         == vp) ||
                           ((VPVOID)p16->lpstrFileTitle    == vp) ||
                           ((VPVOID)p16->lpstrInitialDir   == vp) ||
                           ((VPVOID)p16->lpstrTitle        == vp) ||
                           ((VPVOID)p16->lpstrDefExt       == vp))   {

                            Ssync_WOW_CommDlg_Structs(ptd, w16to32, 0);
                        }

                        break;

                } // end switch
            }
        }
    }
}




VOID FASTCALL WOWTellWOWThehDlg(HWND hDlg)
{

    if(CURRENTPTD() && CURRENTPTD()->CommDlgTd) {
        if(GetCommdlgTd(hDlg) == NULL) {
            WOW32WARNMSGF(FALSE,
                          ("WOW::WOWTellWOWThehDlg: No unassigned hDlgs\n"));
        }
    }

}





#ifdef DEBUG
void WCDDumpCHOOSECOLORData16(PCHOOSECOLORDATA16 p16)
{
    if (p16 && fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("CHOOSECOLORDATA16:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %x\n",(p16)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %lx\n",(p16)->hwndOwner));
        LOGDEBUG(10, ("\thInstance        = %lx\n",(p16)->hInstance));
        LOGDEBUG(10, ("\trgbResult        = %lx\n",(p16)->rgbResult));
        LOGDEBUG(10, ("\tlpCustColors     = %lx\n",(p16)->lpCustColors));
        LOGDEBUG(10, ("\tFlags            = %lx\n",(p16)->Flags));
        LOGDEBUG(10, ("\tlCustData        = %lx\n",(p16)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook         = %lx\n",(p16)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName = %lx\n",(p16)->lpTemplateName));
    }
}


void WCDDumpCHOOSECOLORData32(CHOOSECOLOR *p32)
{
    if (p32 && fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("CHOOSECOLORDATA32:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %x\n",(p32)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %lx\n",(p32)->hwndOwner));
        LOGDEBUG(10, ("\thInstance        = %lx\n",(p32)->hInstance));
        LOGDEBUG(10, ("\trgbResult        = %lx\n",(p32)->rgbResult));
        LOGDEBUG(10, ("\tlpCustColors     = %lx\n",(p32)->lpCustColors));
        LOGDEBUG(10, ("\tFlags            = %lx\n",(p32)->Flags));
        LOGDEBUG(10, ("\tlCustData        = %lx\n",(p32)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook         = %lx\n",(p32)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName = %lx\n",(p32)->lpTemplateName));
    }
}


void WCDDumpCHOOSEFONTData16(PCHOOSEFONTDATA16 p16)
{
    if (p16 && fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("CHOOSEFONT16:\n"));
        LOGDEBUG(10, ("\tlStructSize   = %lx\n",(p16)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner     = %lx\n",(p16)->hwndOwner));
        LOGDEBUG(10, ("\thDC           = %lx\n",(p16)->hDC));
        LOGDEBUG(10, ("\tlpLogFont     = %lx\n",(p16)->lpLogFont));
        LOGDEBUG(10, ("\tiPointSize    = %x\n",(p16)->iPointSize));
        LOGDEBUG(10, ("\tiFlags        = %lx\n",(p16)->Flags));
        LOGDEBUG(10, ("\trbgColors     = %lx\n",(p16)->rgbColors));
        LOGDEBUG(10, ("\tlCustData     = %lx\n",(p16)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook      = %lx\n",(p16)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName= %lx\n",(p16)->lpTemplateName));
        LOGDEBUG(10, ("\thInstance     = %lx\n",(p16)->hInstance));
        LOGDEBUG(10, ("\tlpszStyle     = %lx\n",(p16)->lpszStyle));
        LOGDEBUG(10, ("\tnFontType     = %x\n",(p16)->nFontType));
        LOGDEBUG(10, ("\tnSizeMin      = %x\n",(p16)->nSizeMin));
        LOGDEBUG(10, ("\tnSizeMax      = %x\n",(p16)->nSizeMax));
    }
}


void WCDDumpCHOOSEFONTData32(CHOOSEFONT *p32)
{
    if (p32 && fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("CHOOSEFONT32:\n"));
        LOGDEBUG(10, ("\tlStructSize   = %lx\n",(p32)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner     = %lx\n",(p32)->hwndOwner));
        LOGDEBUG(10, ("\thDC           = %lx\n",(p32)->hDC));
        LOGDEBUG(10, ("\tlpLogFont     = %lx\n",(p32)->lpLogFont));
        LOGDEBUG(10, ("\tiPointSize    = %lx\n",(p32)->iPointSize));
        LOGDEBUG(10, ("\tiFlags        = %lx\n",(p32)->Flags));
        LOGDEBUG(10, ("\trbgColors     = %lx\n",(p32)->rgbColors));
        LOGDEBUG(10, ("\tlCustData     = %lx\n",(p32)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook      = %lx\n",(p32)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName= %lx\n",(p32)->lpTemplateName));
        LOGDEBUG(10, ("\thInstance     = %lx\n",(p32)->hInstance));
        LOGDEBUG(10, ("\tlpszStyle     = %lx\n",(p32)->lpszStyle));
        LOGDEBUG(10, ("\tnFontType     = %x\n",(p32)->nFontType));
        LOGDEBUG(10, ("\tnSizeMin      = %lx\n",(p32)->nSizeMin));
        LOGDEBUG(10, ("\tnSizeMax      = %lx\n",(p32)->nSizeMax));
    }
}


void WCDDumpFINDREPLACE16(PFINDREPLACE16 p16)
{
    if (p16 && fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("FINDREPLACE16:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %lx\n",(p16)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %x\n",(p16)->hwndOwner));
        LOGDEBUG(10, ("\thInstance        = %x\n",(p16)->hInstance));
        LOGDEBUG(10, ("\tFlags            = %x\n",(p16)->Flags));
        LOGDEBUG(10, ("\tlpstrFindWhat    = %lx\n",(p16)->lpstrFindWhat));
        LOGDEBUG(10, ("\tlpstrReplaceWith = %lx\n",(p16)->lpstrReplaceWith));
        LOGDEBUG(10, ("\twFindWhatLen     = %x\n",(p16)->wFindWhatLen));
        LOGDEBUG(10, ("\twReplaceWithLen  = %x\n",(p16)->wReplaceWithLen));
        LOGDEBUG(10, ("\tlCustData     = %lx\n",(p16)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook      = %lx\n",(p16)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName= %lx\n",(p16)->lpTemplateName));
    }
}


void WCDDumpFINDREPLACE32(FINDREPLACE *p32)
{
    if (p32 && fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("FINDREPLACE32:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %lx\n",(p32)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %x\n",(p32)->hwndOwner));
        LOGDEBUG(10, ("\thInstance        = %x\n",(p32)->hInstance));
        LOGDEBUG(10, ("\tFlags            = %x\n",(p32)->Flags));
        LOGDEBUG(10, ("\tlpstrFindWhat    = %s\n",(p32)->lpstrFindWhat));
        LOGDEBUG(10, ("\tlpstrReplaceWith = %s\n",(p32)->lpstrReplaceWith));
        LOGDEBUG(10, ("\twFindWhatLen     = %x\n",(p32)->wFindWhatLen));
        LOGDEBUG(10, ("\twReplaceWithLen  = %x\n",(p32)->wReplaceWithLen));
        LOGDEBUG(10, ("\tlCustData     = %lx\n",(p32)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook      = %lx\n",(p32)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName= %lx\n",(p32)->lpTemplateName));
    }
}


void WCDDumpOPENFILENAME16(POPENFILENAME16 p16)
{
    if (p16 && fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("OPENFILENAME16:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %x\n",(p16)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %lx\n",(p16)->hwndOwner));
        LOGDEBUG(10, ("\thInstance        = %lx\n",(p16)->hInstance));
        LOGDEBUG(10, ("\tlpstrFilter      = %lx\n",(p16)->lpstrFilter));
        LOGDEBUG(10, ("\tlpstrCustomFilter= %lx\n",(p16)->lpstrCustomFilter));
        LOGDEBUG(10, ("\tnMaxCustFilter   = %lx\n",(p16)->nMaxCustFilter));
        LOGDEBUG(10, ("\tnFilterIndex     = %lx\n",(p16)->nFilterIndex));
        LOGDEBUG(10, ("\tlpstrFile        = %lx\n",(p16)->lpstrFile));
        LOGDEBUG(10, ("\tnMaxFile         = %lx\n",(p16)->nMaxFile));
        LOGDEBUG(10, ("\tlpstrFileTitle   = %lx\n",(p16)->lpstrFileTitle));
        LOGDEBUG(10, ("\tnMaxFileTitle    = %lx\n",(p16)->nMaxFileTitle));
        LOGDEBUG(10, ("\tlpstrInitialDir  = %lx\n",(p16)->lpstrInitialDir));
        LOGDEBUG(10, ("\tlpstrTitle       = %lx\n",(p16)->lpstrTitle));
        LOGDEBUG(10, ("\tFlags            = %lx\n",(p16)->Flags));
        LOGDEBUG(10, ("\tnFileOffset      = %lx\n",(p16)->nFileOffset));
        LOGDEBUG(10, ("\tnFileExtension   = %lx\n",(p16)->nFileExtension));
        LOGDEBUG(10, ("\tlpstrDefExt      = %lx\n",(p16)->lpstrDefExt));
        LOGDEBUG(10, ("\tlCustData        = %lx\n",(p16)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook         = %lx\n",(p16)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName   = %lx\n",(p16)->lpTemplateName));
    }
}


void WCDDumpOPENFILENAME32(OPENFILENAME *p32)
{
    if (p32 && fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("OPENFILENAME32:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %x\n",(p32)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %lx\n",(p32)->hwndOwner));
        LOGDEBUG(10, ("\thInstance        = %lx\n",(p32)->hInstance));
        LOGDEBUG(10, ("\tlpstrFilter      = %s\n",(p32)->lpstrFilter));
        LOGDEBUG(10, ("\tlpstrCustomFilter= %s\n",(p32)->lpstrCustomFilter));
        LOGDEBUG(10, ("\tnMaxCustFilter   = %lx\n",(p32)->nMaxCustFilter));
        LOGDEBUG(10, ("\tnFilterIndex     = %lx\n",(p32)->nFilterIndex));
        LOGDEBUG(10, ("\tlpstrFile        = %s\n",(p32)->lpstrFile));
        LOGDEBUG(10, ("\tnMaxFile         = %lx\n",(p32)->nMaxFile));
        LOGDEBUG(10, ("\tlpstrFileTitle   = %s\n",(p32)->lpstrFileTitle));
        LOGDEBUG(10, ("\tnMaxFileTitle    = %lx\n",(p32)->nMaxFileTitle));
        LOGDEBUG(10, ("\tlpstrInitialDir  = %s\n",(p32)->lpstrInitialDir));
        LOGDEBUG(10, ("\tlpstrTitle       = %s\n",(p32)->lpstrTitle));
        LOGDEBUG(10, ("\tFlags            = %lx\n",(p32)->Flags));
        LOGDEBUG(10, ("\tnFileOffset      = %lx\n",(p32)->nFileOffset));
        LOGDEBUG(10, ("\tnFileExtension   = %lx\n",(p32)->nFileExtension));
        LOGDEBUG(10, ("\tlpstrDefExt      = %s\n",(p32)->lpstrDefExt));
        LOGDEBUG(10, ("\tlCustData        = %lx\n",(p32)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook         = %lx\n",(p32)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName   = %lx\n",(p32)->lpTemplateName));
    }
}


void WCDDumpPRINTDLGData16(PPRINTDLGDATA16 p16)
{
    if (p16 && fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("PRINTDLGData16:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %x\n",(p16)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %lx\n",(p16)->hwndOwner));
        LOGDEBUG(10, ("\thDevMode         = %lx\n",(p16)->hDevMode));
        LOGDEBUG(10, ("\thDevNames        = %lx\n",(p16)->hDevNames));
        LOGDEBUG(10, ("\thDC              = %lx\n",(p16)->hDC));
        LOGDEBUG(10, ("\tFlags            = %lx\n",(p16)->Flags));
        LOGDEBUG(10, ("\tnFromPage        = %d\n",(p16)->nFromPage));
        LOGDEBUG(10, ("\tnToPage          = %d\n",(p16)->nToPage));
        LOGDEBUG(10, ("\tnMinPage         = %d\n",(p16)->nMinPage));
        LOGDEBUG(10, ("\tnMaxPage         = %d\n",(p16)->nMaxPage));
        LOGDEBUG(10, ("\tnCopies          = %d\n",(p16)->nCopies));
        LOGDEBUG(10, ("\thInstance        = %lx\n",(p16)->hInstance));
        LOGDEBUG(10, ("\tlCustData        = %lx\n",(p16)->lCustData));
        LOGDEBUG(10, ("\tlpfnPrintHook    = %lx\n",(p16)->lpfnPrintHook));
        LOGDEBUG(10, ("\tlpfnSetupHook    = %lx\n",(p16)->lpfnSetupHook));
        LOGDEBUG(10, ("\tlpPrintTemplateName = %lx\n",(p16)->lpPrintTemplateName));
        LOGDEBUG(10, ("\tlpSetupTemplateName = %lx\n",(p16)->lpSetupTemplateName));
        LOGDEBUG(10, ("\thPrintTemplate   = %lx\n",(p16)->hPrintTemplate));
        LOGDEBUG(10, ("\thSetupTemplate   = %lx\n",(p16)->hSetupTemplate));
    }
}


void WCDDumpPRINTDLGData32(PRINTDLG *p32)
{
    if (p32 && fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("PRINTDLGData32:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %x\n",(p32)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %lx\n",(p32)->hwndOwner));
        LOGDEBUG(10, ("\thDevMode         = %lx\n",(p32)->hDevMode));
        LOGDEBUG(10, ("\thDevNames        = %lx\n",(p32)->hDevNames));
        LOGDEBUG(10, ("\thDC              = %lx\n",(p32)->hDC));
        LOGDEBUG(10, ("\tFlags            = %lx\n",(p32)->Flags));
        LOGDEBUG(10, ("\tnFromPage        = %d\n",(p32)->nFromPage));
        LOGDEBUG(10, ("\tnToPage          = %d\n",(p32)->nToPage));
        LOGDEBUG(10, ("\tnMinPage         = %d\n",(p32)->nMinPage));
        LOGDEBUG(10, ("\tnMaxPage         = %d\n",(p32)->nMaxPage));
        LOGDEBUG(10, ("\tnCopies          = %d\n",(p32)->nCopies));
        LOGDEBUG(10, ("\thInstance        = %lx\n",(p32)->hInstance));
        LOGDEBUG(10, ("\tlCustData        = %lx\n",(p32)->lCustData));
        LOGDEBUG(10, ("\tlpfnPrintHook    = %lx\n",(p32)->lpfnPrintHook));
        LOGDEBUG(10, ("\tlpfnSetupHook    = %lx\n",(p32)->lpfnSetupHook));
        LOGDEBUG(10, ("\tlpPrintTemplateName = %lx\n",(p32)->lpPrintTemplateName));
        LOGDEBUG(10, ("\tlpSetupTemplateName = %lx\n",(p32)->lpSetupTemplateName));
        LOGDEBUG(10, ("\thPrintTemplate   = %lx\n",(p32)->hPrintTemplate));
        LOGDEBUG(10, ("\thSetupTemplate   = %lx\n",(p32)->hSetupTemplate));
    }
}

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wcmdgtbl.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1993, Microsoft Corporation
 *
 *  WCMDGTBL.h
 *  WOW32 16-bit Commdlg tables
 *
 *  History:
 *      John Vert (jvert) 31-Dec-1992 - created
 *
 *  This file is included into the master thunk table.
 *
--*/

    {W32FUN(UNIMPLEMENTEDAPI,              "DUMMYENTRY",           MOD_COMMDLG,    0)},
    {W32FUN(WCD32GetOpenFileName,          "GETOPENFILENAME",      MOD_COMMDLG,    sizeof(GETOPENFILENAME16))},
    {W32FUN(WCD32GetSaveFileName,          "GETSAVEFILENAME",      MOD_COMMDLG,    sizeof(GETSAVEFILENAME16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(WCD32ChooseColor,              "CHOOSECOLOR",          MOD_COMMDLG,    sizeof(CHOOSECOLOR16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},

  /*** 0010 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(WCD32FindText,                 "FINDTEXT",             MOD_COMMDLG,    sizeof(FINDREPLACE16))},
    {W32FUN(WCD32ReplaceText,              "REPLACETEXT",          MOD_COMMDLG,    sizeof(FINDREPLACE16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(WCD32ChooseFont,               "CHOOSEFONT",           MOD_COMMDLG,    sizeof(CHOOSEFONT16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},

  /*** 0020 ***/
    {W32FUN(WCD32PrintDlg,                 "PRINTDLG",             MOD_COMMDLG,    sizeof(PRINTDLG16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(WCD32ExtendedError,            "COMMDLGEXTENDEDERROR", MOD_COMMDLG,    0)},

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wcntl32.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WCNTL32.H
 *  WOW32 32-bit message thunks
 *
 *  History:
 *  Created 19-Feb-1992 by ChandanC (ChandanC)
--*/


LPFNM32PROTO WM32BMControl;
LPFNM32PROTO WM32BMClick;
LPFNM32PROTO WM32EMControl;
LPFNM32PROTO WM32EMSetSel;
LPFNM32PROTO WM32EMGetRect;
LPFNM32PROTO WM32EMSetRect;
LPFNM32PROTO WM32EMSetRectNP;
LPFNM32PROTO WM32EMScroll;
LPFNM32PROTO WM32EMLineScroll;
LPFNM32PROTO WM32EMSetHandle;
LPFNM32PROTO WM32EMGetHandle;
LPFNM32PROTO WM32EMGetThumb;
LPFNM32PROTO WM32EMReplaceSel;
LPFNM32PROTO WM32EMSetFont;
LPFNM32PROTO WM32EMGetLine;
LPFNM32PROTO WM32EMSetWordBreak;
LPFNM32PROTO WM32EMSetWordBreakProc;
LPFNM32PROTO WM32EMGetWordBreakProc;
LPFNM32PROTO WM32EMSetTabStops;
LPFNM32PROTO WM32CBControl;
LPFNM32PROTO WM32CBAddString;
LPFNM32PROTO WM32CBDir;
LPFNM32PROTO WM32CBGetLBText;
LPFNM32PROTO WM32CBResetContent;
LPFNM32PROTO WM32CBGetDropDownControlRect;
LPFNM32PROTO WM32CBComboFocus;
LPFNM32PROTO WM32LBControl;
LPFNM32PROTO WM32LBGetText;
LPFNM32PROTO WM32LBGetTextLen;
LPFNM32PROTO WM32LBDir;
LPFNM32PROTO WM32LBGetSelItems;
LPFNM32PROTO WM32LBSetTabStops;
LPFNM32PROTO WM32LBGetItemRect;
LPFNM32PROTO WM32LBAddString;
LPFNM32PROTO WM32SBMControl;
LPFNM32PROTO WM32SBMGetRange;
LPFNM32PROTO WM32SBMSetRange;
LPFNM32PROTO WM32LBSetSel;
LPFNM32PROTO WM32STMControl;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wcuricon.c ===
//*****************************************************************************
//
// Cursor and Icon compatibility Support -
//
//     Support for apps - which do a GlobalLock on Cursors and Icons to
//     create headaches for us.
//
//     A compatibility issue.
//
//
// 21-Apr-92  NanduriR   Created.
//
//*****************************************************************************

#include "precomp.h"
#pragma hdrstop

MODNAME(wcuricon.c);


extern void FreeAccelAliasEntry(LPACCELALIAS lpT);

LPCURSORICONALIAS lpCIAlias = NULL;
UINT              cPendingCursorIconUpdates = 0;

//*****************************************************************************
//
// W32CreateCursorIcon32 -
//
//     Creates a 32bit Cursor or Icon given a WIN31 Cursor or Icon HANDLE.
//     The Cursor of Icon handle must correspond to an object that has
//     been created (like CreateIcon). That is because the format of a
//     resource cursor differs from that of a 'created'  cursor.
//
//     Returns the 32bit handle
//
//*****************************************************************************


HANDLE W32CreateCursorIcon32(LPCURSORICONALIAS lpCIAliasIn)
{
    HANDLE  hT;
    PCURSORSHAPE16 pcurs16;
    UINT   flType;

    int     nWidth;
    int     nHeight;
    int     nPlanes;
    int     nBitsPixel;
    DWORD   nBytesAND;
    LPBYTE  lpBitsAND;
    LPBYTE  lpBitsXOR;
    int     ScanLen16;


    pcurs16 = (PCURSORSHAPE16)lpCIAliasIn->pbDataNew;

    flType = lpCIAliasIn->flType;
    if (flType & HANDLE_TYPE_UNKNOWN) {
        if (PROBABLYCURSOR(FETCHWORD(pcurs16->BitsPixel),
                                              FETCHWORD(pcurs16->Planes)))
            flType = HANDLE_TYPE_CURSOR;
        else
            flType = HANDLE_TYPE_ICON;
    }

    nWidth     = INT32(FETCHWORD(pcurs16->cx));
    nHeight    = INT32(FETCHWORD(pcurs16->cy));

    nPlanes    = 1;
    nBitsPixel = 1;                                  // Monochrome

    // Get the AND mask bits

    ScanLen16 = (((nWidth*nBitsPixel)+15)/16) * 2 ;  // bytes/scan in 16 bit world
                                                     // effectively nBitsPixel is 1
    nBytesAND = ScanLen16*nHeight*nPlanes;
    lpBitsAND = (LPBYTE)pcurs16 + sizeof(CURSORSHAPE16);

    // Get the XOR mask bits

    if (flType == HANDLE_TYPE_ICON) {
        nPlanes    = INT32(FETCHWORD(pcurs16->Planes));
        nBitsPixel = INT32(FETCHWORD(pcurs16->BitsPixel));  // the actual value
    }

    lpBitsXOR = (LPBYTE)lpBitsAND + nBytesAND;

    lpCIAliasIn->flType = (BYTE)flType;

    if (flType & HANDLE_TYPE_CURSOR) {
        hT = CreateCursor(HMODINST32(lpCIAliasIn->hInst16),
                              (INT)FETCHWORD(pcurs16->xHotSpot),
                              (INT)FETCHWORD(pcurs16->yHotSpot),
                              nWidth, nHeight, lpBitsAND, lpBitsXOR);
    }
    else if (flType & HANDLE_TYPE_ICON) {
        hT = CreateIcon(HMODINST32(lpCIAliasIn->hInst16), nWidth, nHeight,
                              (BYTE)nPlanes, (BYTE)nBitsPixel, lpBitsAND, lpBitsXOR);

    }

    return hT;
}


//*****************************************************************************
//
// W32Create16BitCursorIcon -
//
//     Creates a WIN31 compatible Cursor or Icon  given the full 16bit
//     definition of the object to be created.
//
//
//*****************************************************************************


HAND16 W32Create16BitCursorIcon(HAND16 hInst16, INT xHotSpot, INT yHotSpot,
                         INT nWidth, INT nHeight,
                         INT nPlanes, INT nBitsPixel,
                         LPBYTE lpBitsAND, LPBYTE lpBitsXOR,
                         INT   nBytesAND, INT nBytesXOR                    )
{
    WORD h16 = 0;
    WORD wTotalSize;
    PCURSORSHAPE16 pcshape16;
    VPVOID vp;
    LPBYTE lpT;

    UNREFERENCED_PARAMETER(hInst16);

    wTotalSize = (WORD)(sizeof(CURSORSHAPE16) + nBytesAND + nBytesXOR);

    vp = GlobalAllocLock16(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE,
                                                             wTotalSize, &h16);
    if (vp != (VPVOID)NULL) {
        GETVDMPTR(vp, wTotalSize, pcshape16);

        STOREWORD(pcshape16->xHotSpot, xHotSpot);
        STOREWORD(pcshape16->yHotSpot, yHotSpot);
        STOREWORD(pcshape16->cx, nWidth);
        STOREWORD(pcshape16->cy, nHeight);
        STOREWORD(pcshape16->cbWidth, (((nWidth + 0x0F) & ~0x0F) >> 3));
        pcshape16->Planes = (BYTE)nPlanes;
        pcshape16->BitsPixel = (BYTE)nBitsPixel;

        lpT = (LPBYTE)pcshape16 + sizeof(CURSORSHAPE16);
        RtlCopyMemory(lpT, lpBitsAND, nBytesAND);
        RtlCopyMemory(lpT+nBytesAND, lpBitsXOR, nBytesXOR);

        FLUSHVDMPTR(vp, wTotalSize, pcshape16);
        FREEVDMPTR(pcshape16);
    }

    GlobalUnlock16(h16);
    return (HAND16)h16;
}



//*****************************************************************************
//
// GetCursorIconAlias32 -
//
//     Returns a 32bit handle  given a 16bit Cursor or Icon HANDLE
//     Creates the 32bit Cursor or Icon if necessary.
//
//     Returns the 32bit handle
//
//*****************************************************************************


HANDLE GetCursorIconAlias32(HAND16 h16, UINT flType)
{

    LPCURSORICONALIAS lpT;
    VPVOID vp;
    UINT   cb;
    PCURSORSHAPE16 pcurs16;

    if (h16 == (HAND16)0)
        return (ULONG)NULL;

    lpT = FindCursorIconAlias((ULONG)h16, HANDLE_16BIT);
    if (lpT) {
        return lpT->h32;
    }
    else {

        //
        // BEGIN: Check for Bogus handle
        //

        if (BOGUSHANDLE(h16))
            return (HANDLE)NULL;

#if defined(FE_SB)
        //In Excel95, XLVISEX.EXE use wrong cursor handle
        //that is already freed. So, we double check this handle
        //whether it is valid or not. 09/27/96 bklee.

        if (!FindCursorIconAliasInUse((ULONG)h16))
            return (HANDLE)NULL;
#endif

        vp = RealLockResource16(h16, (PINT)&cb);
        if (vp == (VPVOID)NULL)
            return (ULONG)NULL;

        GETVDMPTR(vp, cb, pcurs16);

        if (pcurs16->cbWidth !=  (SHORT)(((pcurs16->cx + 0x0f) & ~0x0f) >> 3))
            return (ULONG)NULL;

        //
        // END: Check for Bogus handle
        //

        lpT = AllocCursorIconAlias();
        if (!lpT) {
            return (ULONG)NULL;
        }

        lpT->h16 = h16;
        lpT->hTask16 = CURRENTPTD()->htask16;

        lpT->vpData = vp;
        lpT->cbData = (WORD)cb;
        lpT->pbDataNew = (LPBYTE)pcurs16;

        lpT->pbDataOld = malloc_w(cb);
        if (lpT->pbDataOld) {
            RtlCopyMemory(lpT->pbDataOld, lpT->pbDataNew, cb);
        }

        lpT->h32  = (HAND32)W32CreateCursorIcon32(lpT);

        GlobalUnlock16(h16);
        FREEVDMPTR(pcurs16);
        lpT->pbDataNew = (LPBYTE)NULL;

        if (lpT->h32) {
            lpT->fInUse = TRUE;
            SetCursorIconFlag(h16, TRUE);
        }
        else
            lpT->fInUse = FALSE;

        return lpT->h32;
    }
}


//*****************************************************************************
//
// GetCursorIconAlias16 -
//
//     Returns a 16bit handle  given a 32bit Cursor or Icon HANDLE
//     Creates the 16bit Cursor or Icon if necessary.
//
//     Returns the 16bit handle
//
//*****************************************************************************


HAND16 GetCursorIconAlias16(HAND32 h32, UINT flType)
{

    LPCURSORICONALIAS lpT;

    if (h32 == (HAND32)0)
        return (HAND16)NULL;

    lpT = FindCursorIconAlias((ULONG)h32, HANDLE_32BIT);
    if (lpT) {
        return lpT->h16;
    }
    else {
        HAND16 h16;

        // HACK:
        // From experience: numeric values of 32bit standard cursors and icons
        //                  are very small. so check for these handles.
        //                  we should not create aliases for standard cursors and
        //                  icons here.

        WOW32ASSERT((UINT)h32 >= 100);

        //
        // Always generate valid handles.
        //

        h16 = W32Create16BitCursorIconFrom32BitHandle(h32, (HAND16)NULL,
                                                                  (PUINT)NULL);
        if (h16) {
            h16 = SetupCursorIconAlias((HAND16)NULL, h32, h16, flType,
                                                      NULL, (WORD)NULL);
        }
        return h16;
    }
}


//*****************************************************************************
//
// AllocCursorIconAlias -
//
//     Allocates and reurns pointer to CURSORICONALIAS buffer.
//
//*****************************************************************************


LPCURSORICONALIAS AllocCursorIconAlias()
{
    LPCURSORICONALIAS  lpT;

    for (lpT = lpCIAlias; lpT != NULL; lpT = lpT->lpNext) {
         if (!lpT->fInUse)
             break;
    }

    if (lpT == NULL) {
        lpT = (LPCURSORICONALIAS)malloc_w_small(sizeof(CURSORICONALIAS));
        if (lpT) {
            lpT->lpNext = lpCIAlias;
            lpCIAlias = lpT;
        }
        else {
            LOGDEBUG(0, ("AllocCursorIconAlias: malloc_w_small for alias failed\n"));
        }
    }

    if (lpT != NULL) {
        lpT->fInUse = TRUE;
        lpT->h16 = (HAND16)0;
        lpT->h32 = (HAND32)0;
        lpT->vpData   = (VPVOID)NULL;
        lpT->cLock    = 0;
        lpT->cbData   = 0;
        lpT->pbDataOld = (LPBYTE)NULL;
        lpT->pbDataNew = (LPBYTE)NULL;
        lpT->lpszName  = (LPBYTE)NULL;

        lpT->flType = HANDLE_TYPE_UNKNOWN;
        lpT->hInst16 = (HAND16)0;
        lpT->hMod16  = (HAND16)0;
        lpT->hTask16 = (HTASK16)0;
        lpT->hRes16 = 0;
    }

    return lpT;
}


//*****************************************************************************
//
// FindCursorIconAlias -
//
//     Searches for the given handle and returns corresponding
//     LPCURSORICONALIAS.
//
//*****************************************************************************


LPCURSORICONALIAS FindCursorIconAlias(ULONG hCI, UINT flHandleSize)
{
    LPCURSORICONALIAS  lpT;
    LPCURSORICONALIAS  lpTprev;

    lpTprev = (LPCURSORICONALIAS)NULL;
    for (lpT = lpCIAlias; lpT != NULL; lpTprev = lpT, lpT = lpT->lpNext) {
         if (lpT->fInUse) {
             if ((flHandleSize == HANDLE_16BIT && lpT->h16 == (HAND16)hCI) ||
                      (flHandleSize == HANDLE_32BIT && lpT->h32 == (HAND32)hCI))
                 break;
             else if (flHandleSize == HANDLE_16BITRES && lpT->hRes16 &&
                                 (lpT->hRes16 == (HAND16)hCI))


                 break;
         }

    }

    if (lpT) {
        if (lpTprev) {
            lpTprev->lpNext = lpT->lpNext;
            lpT->lpNext = lpCIAlias;
            lpCIAlias = lpT;
        }
    }
    return lpT;
}

#if defined(FE_SB)
//*****************************************************************************
//
// FindCursorIconAliasInUse -
//
//     Searches for the given handle and returns corresponding
//     lpT->fInUse.
//
//     09/27/96 bklee
//*****************************************************************************


BOOL FindCursorIconAliasInUse(ULONG hCI)
{
    LPCURSORICONALIAS  lpT;
    LPCURSORICONALIAS  lpTprev;

    lpTprev = (LPCURSORICONALIAS)NULL;
    for (lpT = lpCIAlias; lpT != NULL; lpTprev = lpT, lpT = lpT->lpNext) {
         if (lpT->h16 == (HAND16)hCI)
               return lpT->fInUse;
    }

    return TRUE;
}
#endif


//*****************************************************************************
//
// DeleteCursorIconAlias -
//
//     Searches for the given handle and if a 16bit handle frees the memory
//     allocated for the Object. The alias table is not freed.
//
//*****************************************************************************


BOOL DeleteCursorIconAlias(ULONG hCI, UINT flHandleSize)
{
    LPCURSORICONALIAS  lpT;

    WOW32ASSERT(flHandleSize == HANDLE_16BIT);

    for (lpT = lpCIAlias; lpT != NULL; lpT = lpT->lpNext) {
         if (lpT->fInUse && !(lpT->flType & HANDLE_TYPE_WOWGLOBAL)) {

             // Have we found the handle mapping?

             if (flHandleSize == HANDLE_16BIT && lpT->h16 == (HAND16)hCI) {

                 if (lpT->hTask16) {

                     // We don't want to free the handle mapping when
                     // the handle corresponds to a 16-bit resource, i.e.
                     // hRes16 is non-null.

                     if (!(lpT->hRes16)) {
                         SetCursorIconFlag(lpT->h16, FALSE);
                         GlobalUnlockFree16(RealLockResource16((HMEM16)hCI, NULL));
                         free_w(lpT->pbDataOld);
                         lpT->fInUse = FALSE;
                         return TRUE;
                     }
                 }
                 else {
                     WOW32ASSERT(FALSE);
                 }

                 break;
             }
         }

    }

    return FALSE;
}




//*****************************************************************************
//
// FreeCursorIconAlias -
//
//     Frees all Cursors and Icons of the specified task.
//
//
//*****************************************************************************


BOOL FreeCursorIconAlias(HAND16 hand16, ULONG ulFlags)
{
    LPCURSORICONALIAS  lpT;

    for (lpT = lpCIAlias; lpT != NULL; lpT = lpT->lpNext) {
         if (lpT->fInUse &&
            (((ulFlags & CIALIAS_HMOD)  && (lpT->hMod16  == hand16)) ||
             ((ulFlags & CIALIAS_HTASK) && (lpT->hTask16 == hand16)))) {

             if (ulFlags & CIALIAS_TASKISGONE) {
                 // We're here if this function is called after the task
                 // cleanup on the 16bit side... then we really can't
                 // callback. Setting appropriate fields to NULL will
                 // avoid callbacks, but will leak the corresponding
                 // memory. The asserts will catch this on a checked
                 // build.
                 WOW32ASSERT(lpT->h16==(HAND16)NULL);
                 WOW32ASSERT(lpT->hRes16==(HAND16)NULL);
                 lpT->h16 = (HAND16)NULL;
                 lpT->hRes16 = (HAND16)NULL;
             }
             InvalidateCursorIconAlias(lpT);
         }
    }

    return TRUE;
}


//*****************************************************************************
//
// SetupCursorIconAlias -
//
//     Sets up association (alias) between a 32bit and a 16bit handle.
//     given both the handles.
//
//
//*****************************************************************************


HAND16 SetupCursorIconAlias(HAND16 hInst16, HAND32 h32, HAND16 h16, UINT flType,
                            LPBYTE lpResName, WORD hRes16)

{
    LPCURSORICONALIAS  lpT;
    VPVOID             vp;
    INT                cb;

    lpT = AllocCursorIconAlias();
    // paranoid check for memory exaust 
    if (!lpT) {
      return (HAND16)NULL;
    }

    lpT->fInUse = TRUE;
    lpT->h16 = h16;
    lpT->h32 = h32;
    lpT->flType = (BYTE)flType;
    if (!(flType & HANDLE_TYPE_WOWGLOBAL)) {
        lpT->hInst16 = hInst16;
        lpT->hMod16  = GETHMOD16(HMODINST32(hInst16));
        lpT->hTask16 = CURRENTPTD()->htask16;
        lpT->hRes16 = hRes16;

        vp = RealLockResource16(h16, &cb);
        if (vp == (VPVOID)NULL)
            return (HAND16)NULL;

        lpT->vpData = vp;
        lpT->cbData = (WORD)cb;
        GETVDMPTR(vp, cb, lpT->pbDataNew);

        lpT->pbDataOld = malloc_w(cb);
        if (lpT->pbDataOld) {
            RtlCopyMemory(lpT->pbDataOld, lpT->pbDataNew, cb);
        }

        if (hRes16) {
            lpT->lpszName = lpResName;
            // if this is a string...
            if ((WORD)HIWORD(lpResName) != (WORD)NULL) {
                UINT   cbStr;
                cbStr = strlen(lpResName)+1;
                // note: strlen+1 will force memcpy to copy the null from the
                //       src string.
                if (lpT->lpszName = malloc_w_small(cbStr)) {
                    memcpy (lpT->lpszName, lpResName, cbStr);
                }
            }
        }


    }
    // the alias has been setup. Now turn on the GAH_CURSORICON flag.

    SetCursorIconFlag(h16, TRUE);

    return h16;
}



//*****************************************************************************
//
// SetupResCursorIconAlias -
//
//     Sets up association (alias) between a 32bit and a 16bit handle.
//     given the 32bit handle and a handle to a 16bit resource.
//
//
//*****************************************************************************


HAND16 SetupResCursorIconAlias(HAND16 hInst16, HAND32 h32, LPBYTE lpResName, WORD hRes16, UINT flType)
{
    LPCURSORICONALIAS  lpT;
    HAND16 h16 = 0;
    HAND16 h16Res = 0;
    UINT   cb;


    if (hRes16) {
        // 16bit resource has been loaded. We always want to return the
        // SAME 16bit handle no matter howmany times the 'LoadIcon' or
        // LoadCursor has been called.

        h16Res = LOWORD(hRes16);
        lpT = FindCursorIconAlias(h16Res, HANDLE_16BITRES);
    }
    else {

        // Resource handle is NULL. The Resource must have been a
        // standard predefined resource like ARROW etc.

        lpT = FindCursorIconAlias((ULONG)h32, HANDLE_32BIT);
        flType |= HANDLE_TYPE_WOWGLOBAL;
    }

    if (lpT == NULL) {
        h16 = W32Create16BitCursorIconFrom32BitHandle(h32, hInst16, &cb);
        h16 = SetupCursorIconAlias(hInst16, h32, h16, flType, lpResName, hRes16);
    }
    else {
        if (lpT->flType & HANDLE_TYPE_WOWGLOBAL) {

            // eachtime we should get the same h32 from usersrv.
            //

            WOW32ASSERT(lpT->h32 == h32);
        }
        else {
            if (lpT->h32 != h32) {
                if (lpT->flType == HANDLE_TYPE_CURSOR)
                    DestroyCursor(h32);
                else
                    DestroyIcon(h32);
            }
            ReplaceCursorIcon(lpT);
        }

        h16 = lpT->h16;
    }

    return h16;
}


//*****************************************************************************
//
// SetCursorIconFlag  -
//
//     Sets/Clears the GAH_CURSORICONFLAG in the global arean header. This flag
//     is used to identify Cursors and Icon when they are GlobaLocked and
//     GlobalUnlocked
//
//*****************************************************************************

ULONG SetCursorIconFlag(HAND16 h16, BOOL fSet)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    Parm16.WndProc.wParam = h16;
    Parm16.WndProc.wMsg = (WORD)fSet;
    CallBack16(RET_SETCURSORICONFLAG, &Parm16, 0, &vp);
    return (ULONG)0;
}


//*****************************************************************************
//
// UpdateCursorIcon  -
//
//     Compares the new object data with the old. If any of the bytes differ
//     the old object is replaced with the new.
//
//*****************************************************************************

VOID UpdateCursorIcon()
{
    LPCURSORICONALIAS  lpT;
    UINT               cbData;
    LPBYTE             lpBitsNew, lpBitsOld;
    UINT               i = 0;

    for (lpT = lpCIAlias; lpT != NULL ; lpT = lpT->lpNext) {
         if (lpT->fInUse && lpT->cLock) {
             GETVDMPTR(lpT->vpData, lpT->cbData, lpT->pbDataNew);
             if (lpT->hRes16) {
                 if (lpT->flType == HANDLE_TYPE_ICON) {
                     lpBitsNew = lpT->pbDataNew + sizeof(BITMAPINFOHEADER16);
                     lpBitsOld = lpT->pbDataOld + sizeof(BITMAPINFOHEADER16);
                     cbData    = lpT->cbData    - sizeof(BITMAPINFOHEADER16);
                 }
                 else {
                     lpBitsNew = lpT->pbDataNew + sizeof(CURSORRESOURCE16);
                     lpBitsOld = lpT->pbDataOld + sizeof(CURSORRESOURCE16);
                     cbData    = lpT->cbData    - sizeof(CURSORRESOURCE16);
                 }

             }
             else {
                 lpBitsNew = lpT->pbDataNew + sizeof(CURSORSHAPE16);
                 lpBitsOld = lpT->pbDataOld + sizeof(CURSORSHAPE16);
                 cbData    = lpT->cbData    - sizeof(CURSORSHAPE16);
             }

             if (! RtlEqualMemory(lpBitsNew, lpBitsOld, cbData))
                 ReplaceCursorIcon(lpT);

             if (cPendingCursorIconUpdates == ++i)
                 break;
         }

    }

}

//*****************************************************************************
//
// ReplaceCursorIcon  -
//
//     Updates the current cursor or icon. Creates a new icon or cursor and
//     replaces the contents of the old handle with that of the new.
//
//     returns TRUE for success.
//
//*****************************************************************************

BOOL ReplaceCursorIcon(LPCURSORICONALIAS lpIn)
{
    HANDLE hT32;


    if (lpIn != NULL) {

        // Get the data

        GETVDMPTR(lpIn->vpData, lpIn->cbData, lpIn->pbDataNew);

        // Create the object

        hT32  = (HAND32)W32CreateCursorIcon32(lpIn);

        // SetCursorConents will replace the contents of OLD cursor/icon
        // with that of the new handle and destroy the new handle

        SetCursorContents(lpIn->h32, hT32);

        // replace the old object data with the new

        RtlCopyMemory(lpIn->pbDataOld, lpIn->pbDataNew, lpIn->cbData);
        FREEVDMPTR(lpIn->pbDataNew);
        lpIn->pbDataNew = (LPBYTE)NULL;

    }


    return (BOOL)TRUE;

}


//*****************************************************************************
//
// WK32WowCursorIconOp -
//
//     Gets called when/from  GlobalLock or GlobalUnlock are called. The fLock
//     flag is TRUE if called from GlobalLock else it is FALSE.
//
//*****************************************************************************

BOOL FASTCALL WK32WowCursorIconOp(PVDMFRAME pFrame)
{

    PWOWCURSORICONOP16 prci16;
    HAND16 h16;
    LPCURSORICONALIAS lpT;
    BOOL   fLock;
    WORD   wFuncId;
    UINT   cLockT;


    GETARGPTR(pFrame, sizeof(WOWCURSORICONOP16), prci16);
    wFuncId = FETCHWORD(prci16->wFuncId);
    h16 = (HAND16)FETCHWORD(prci16->h16);

    lpT = FindCursorIconAlias((ULONG)h16, HANDLE_16BIT);
    // This is a Cursor or Icon
    if (lpT != NULL) {

        if (wFuncId == FUN_GLOBALLOCK || wFuncId == FUN_GLOBALUNLOCK) {

            if (!(lpT->flType & HANDLE_TYPE_WOWGLOBAL)) {

                fLock = (wFuncId == FUN_GLOBALLOCK);

                // Store the current lockcount.

                cLockT = lpT->cLock;

                // Update the Lock count

                lpT->cLock = fLock ? ++lpT->cLock : --lpT->cLock;

                if (lpT->cLock == 0) {

                    // New lock count == 0 implies that it was decremented from
                    // 1 to 0 thereby impling that it was one of the cursors that
                    // was being updated regularly.

                    // Decrement the global count and update the cursor one last
                    // time

                    cPendingCursorIconUpdates--;
                    ReplaceCursorIcon(lpT);
                }
                else if (fLock && cLockT == 0) {

                    // If previous Lockcount was zero and the object is being locked
                    // then it means that this is the very first time that the object
                    // is being locked

                    cPendingCursorIconUpdates++;
                }
            }
        }
        else if (wFuncId == FUN_GLOBALFREE) {

            // The h16 has not yet been GlobalFreed. We return TRUE if h16 can
            // be freed else FALSE. The h16 can be freed only if it is not a
            // global handle. ie, it doesn't correspond to a predefined cursor

            // Also we donot free the handle if h16 corresponds to a resource.
            // CorelDraw 3.0 calls FreeResource(h16) and then SetCursor(h16)
            // thus  GPing.

            BOOL fFree;

            fFree = !((lpT->flType & HANDLE_TYPE_WOWGLOBAL) || lpT->hRes16);
            if (fFree) {
                // Set handle to NULL so that InvalidateCursorIconAlias
                // doesn't try to free it.

                lpT->h16 = 0;
                InvalidateCursorIconAlias(lpT);
            }

            return (BOOL)fFree;

        }
        else {
            LOGDEBUG(0, ("WK32WowCursorIconOp: Unknown Func Id\n"));
        }
    }

    // else if this is a GlobalFree call
    else if (wFuncId == FUN_GLOBALFREE) {

        // and if this is a handle to an accelerator
        if(lpT = (LPCURSORICONALIAS)FindAccelAlias((HANDLE)h16, HANDLE_16BIT)) {

            // free it from the accelerator alias list
            FreeAccelAliasEntry((LPACCELALIAS) lpT);

            // cause this hMem16 to really be free'd in 16-bit GlobalFree
            return TRUE;
        }
    }

    return TRUE;
}


//*****************************************************************************
//
// W32Create16BitResCursorIconFrom32BitHandle -
//
//     Creates a WIN31 compatible Cursor or Icon given a 32bit cursor or icon
//     handle. This is primarily used to create a 16bit Cursor or Icon which
//     has been loaded from a 16bit resource.
//
//
//     returns 16bit handle
//*****************************************************************************


HAND16 W32Create16BitCursorIconFrom32BitHandle(HANDLE h32, HAND16 hInst16,
                                                 PUINT pcbData)
{
    HAND16   h16 = 0;
    ICONINFO iinfo;
    BITMAP   bm;
    BITMAP   bmClr;
    UINT     nBytesAND = 0;
    UINT     nBytesXOR = 0;
    LPBYTE   lpBitsAND, lpBitsXOR;

    if (GetIconInfo(h32, &iinfo)) {
        if (GetObject(iinfo.hbmMask, sizeof(BITMAP), &bm)) {
            nBytesAND = GetBitmapBits(iinfo.hbmMask, 0, (LPBYTE)NULL);
            WOW32WARNMSG(nBytesAND,("WOW: W32C16BCIFBH: nBytesAND == 0\n"));
            if (iinfo.hbmColor) {
                GetObject(iinfo.hbmColor, sizeof(BITMAP), &bmClr);
                nBytesXOR = GetBitmapBits(iinfo.hbmColor, 0, (LPBYTE)NULL);
                WOW32WARNMSG(nBytesXOR,("WOW: W32C16BCIFBH: nBytesAND == 0\n"));
            }
            else {
                bm.bmHeight /= 2;
                nBytesAND /= 2;
                nBytesXOR = nBytesAND;
            }


            if (pcbData) {
                *pcbData = nBytesAND + nBytesXOR + sizeof(CURSORSHAPE16);
            }

            lpBitsAND = malloc_w(nBytesAND + nBytesXOR);
            if (lpBitsAND != NULL) {
                lpBitsXOR = lpBitsAND + nBytesAND;
                GetBitmapBits(iinfo.hbmMask,
                              (iinfo.hbmColor) ? nBytesAND : (nBytesAND * 2),
                                                                    lpBitsAND);
                if (iinfo.hbmColor)
                    GetBitmapBits(iinfo.hbmColor, nBytesXOR, lpBitsXOR);

                h16 = W32Create16BitCursorIcon(hInst16,
                                       iinfo.xHotspot, iinfo.yHotspot,
                                       bm.bmWidth, bm.bmHeight,
                                       (iinfo.hbmColor) ? bmClr.bmPlanes :
                                                                    bm.bmPlanes,
                                       (iinfo.hbmColor) ? bmClr.bmBitsPixel :
                                                                 bm.bmBitsPixel,
                                       lpBitsAND, lpBitsXOR,
                                       (INT)nBytesAND, (INT)nBytesXOR);
                free_w(lpBitsAND);

            }

        }
        DeleteObject(iinfo.hbmMask);
        if (iinfo.hbmColor) {
            DeleteObject(iinfo.hbmColor);
        }
    }

    return h16;

}

//*****************************************************************************
//
// GetClassCursorIconAlias32 -
//
//     Returns a 32bit handle  given a 16bit Cursor or Icon HANDLE
//     DOES NOT Create the 32bit Cursor or Icon if there is no alias.
//     This is called in RegisterClass only - to support those apps which
//     pass a bogus handle for WNDCLASS.hIcon.
//
//     Returns the 32bit handle
//
//*****************************************************************************


HANDLE GetClassCursorIconAlias32(HAND16 h16)
{

    LPCURSORICONALIAS lpT;

    if (h16 == (HAND16)0)
        return (ULONG)NULL;

    lpT = FindCursorIconAlias((ULONG)h16, HANDLE_16BIT);
    if (lpT) {
        return lpT->h32;
    }
    else
        return (HANDLE)NULL;
}



//*****************************************************************************
//
// InvalidateCursorIconAlias -
//
//     Frees the allocated objects.
//
//*****************************************************************************


VOID InvalidateCursorIconAlias(LPCURSORICONALIAS lpT)
{
    VPVOID vp=0;
    PARM16 Parm16;

    if (!lpT->fInUse)
        return;

    if (lpT->h16) {
        SetCursorIconFlag(lpT->h16, FALSE);
        GlobalUnlockFree16(RealLockResource16((HMEM16)lpT->h16, NULL));
    }

    if (lpT->hRes16) {
        Parm16.WndProc.wParam = (HAND16) lpT->hRes16;
        CallBack16(RET_FREERESOURCE, &Parm16, 0, &vp);
    }

    if (lpT->h32) {
        if (lpT->flType == HANDLE_TYPE_CURSOR)
            DestroyCursor(lpT->h32);
        else
            DestroyIcon(lpT->h32);
    }

    if (lpT->pbDataOld)
        free_w(lpT->pbDataOld);

    if (lpT->cLock)
        cPendingCursorIconUpdates--;


    if ((WORD)HIWORD(lpT->lpszName) != (WORD)NULL) {
        free_w_small ((PVOID)lpT->lpszName);
    }

    lpT->fInUse = FALSE;
}


//*****************************************************************************
//
// InitStdCursorIconAlias -
//
//     Creates the aliases of standard cursors and icons.
//
// NOTES:
//
// The idea is to createaliases for all the standard cursors and icons to
// make sure that we indeed generate valid handles.
//
// This problem cameup because of the following scenario
// the app turbotax does the following:
//
//          h16Cursor1 = GetClassWord(hwndEditControl, GCL_HCURSOR);
//                              (bydefault, this is an I-beam)
//                         .....
//          h16Cursor2 = LoadCursor(NULL, IDC_IBEAM);
// Because of the way we create and maintain our 32-16 alias hCursor1 is a
// a WOW bogus handle (ie > 0xf000) and  since by default the "Edit" class is
// registered with hCursor = IDC_IBEAM, the h32s are same ie.
//
//     GetClassWord(hwndEditControl, GCL_HCURSOR) == LoadCursor(..IDC_IBEAM);
//
// Thus h16Cursor2 will be same as h16Cursor1 and that's a problem because we
// are NOT returning a valid wow handle for a predefined cursor.
//
//
// The solution is to createaliases for all standard cursors and icons during
// init time so that we don't run into this problem. However I think this
// approach as wasteful and am creating the alias for the only known case
// ie IDC_IBEAM.
//
//                                           - Nanduri Ramakrishna
//*****************************************************************************

DWORD InitCursorIds[] = {
                          (DWORD)IDC_ARROW,
                          (DWORD)IDC_IBEAM,
                          (DWORD)IDC_WAIT,
                          (DWORD)IDC_CROSS,
                          (DWORD)IDC_UPARROW,
                          (DWORD)IDC_SIZE,
                          (DWORD)IDC_ICON,
                          (DWORD)IDC_SIZENWSE,
                          (DWORD)IDC_SIZENESW,
                          (DWORD)IDC_SIZEWE,
                          (DWORD)IDC_SIZENS
                        };

BOOL InitStdCursorIconAlias()
{

    HCURSOR h32;
    UINT i;

    for (i = 0; i < (sizeof(InitCursorIds) / sizeof(DWORD)); i++) {

         //
         // Create the alias for each standard cursor in the list
         //

         h32 = (HCURSOR)LoadCursor((HINSTANCE)NULL, (LPCSTR)InitCursorIds[i]);
         WOW32ASSERT(h32);

         if (h32) {
             SetupResCursorIconAlias((HAND16)NULL, (HAND32)h32, NULL, (WORD)NULL,
                                                          HANDLE_TYPE_CURSOR);
         }

    }

    //
    // Add similar lines for  standard icons.
    //

    return TRUE;
}


//*****************************************************************************
//
// W32CheckIfAlreadyLoaded -
//
//     returns h16 if a cursoricon has previously been loaded.
//
//*****************************************************************************

HAND16 W32CheckIfAlreadyLoaded(VPVOID pData, WORD ResType)
{
    LPCURSORICONALIAS  lpT;
    PICONCUR16 parg16;
    PSZ psz;


    GETMISCPTR(pData, parg16);
    GETPSZIDPTR(parg16->lpStr, psz);

    ResType = (ResType == NW_LOADCURSOR) ?  HANDLE_TYPE_CURSOR : HANDLE_TYPE_ICON;
    for (lpT = lpCIAlias; lpT != NULL; lpT = lpT->lpNext) {
         if (lpT->fInUse) {
             LPBYTE lpszNameT = lpT->lpszName;
             if (lpszNameT &&  (lpT->flType & ResType) &&
                                            lpT->hInst16 == parg16->hInst) {
                 WOW32ASSERT(!(lpT->flType & HANDLE_TYPE_WOWGLOBAL));
                 if (HIWORD(lpszNameT) && HIWORD(psz)) {
                     if (!(WOW32_stricmp(psz, (LPSTR)lpszNameT)))
                         break;
                 }
                 else if (lpszNameT == psz) {
                    break;
                 }
             }
         }
    }


    FREEPSZIDPTR(psz);
    FREEMISCPTR(parg16);


    if (lpT && lpT->cLock)
        ReplaceCursorIcon(lpT);

    return (lpT ? lpT->h16 : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wcuricon.h ===
//*****************************************************************************
//
// Cursor and Icon compatibility Support -
//
//     Support for apps - which do a GlobalLock on Cursors and Icons to
//     create headaches for us.
//
//     A compatibility issue.
//
//
// 21-Apr-92  NanduriR   Created.
//
//*****************************************************************************

#define HANDLE_TYPE_UNKNOWN  0x01
#define HANDLE_TYPE_ICON     0x02
#define HANDLE_TYPE_CURSOR   0x04

#define HANDLE_TYPE_WOWGLOBAL 0x08

#define HANDLE_16BIT       0x01
#define HANDLE_32BIT       0x02
#define HANDLE_16BITRES    0x04

#define CIALIAS_TASKISGONE  0x01
#define CIALIAS_HMOD        0x02
#define CIALIAS_HTASK       0x04

typedef struct _CURSORICONALIAS {
    struct _CURSORICONALIAS FAR *lpNext;
    BYTE   fInUse;
    BYTE   flType;
    HAND16 h16;
    HAND32 h32;
    HAND16 hInst16;
    HAND16 hMod16;
    HTASK16 hTask16;
    WORD    hRes16;         // 16bit resource handle
    WORD    cbData;
    UINT    cLock;
    VPVOID  vpData;
    LPBYTE  pbDataOld;
    LPBYTE  pbDataNew;
    LPBYTE  lpszName;       // name of 16bit resource
} CURSORICONALIAS, FAR *LPCURSORICONALIAS;


#define PROBABLYCURSOR(BitsPixel, Planes) ((((BitsPixel) == 1) &&  \
                                                     ((Planes) == 1)) || \
                                            (BitsPixel) == 0 || (Planes) == 0)
#define BOGUSHANDLE(h) (~(h) & 0x4)

extern  UINT   cPendingCursorIconUpdates;

HANDLE W32CreateCursorIcon32(LPCURSORICONALIAS lpCIAlias);
HAND16 W32Create16BitCursorIcon(HAND16 hInst16, INT xHotSpot, INT yHotSpot,
         INT nWidth, INT nHeight, INT nPlanes, INT nBitsPixel,
         LPBYTE lpBitsAND, LPBYTE lpBitsXOR, INT   nBytesAND, INT nBytesXOR);

HANDLE GetCursorIconAlias32(HAND16 h16, UINT flType);
HAND16 GetCursorIconAlias16(HAND32 h32, UINT flType);
LPCURSORICONALIAS AllocCursorIconAlias();
LPCURSORICONALIAS FindCursorIconAlias(ULONG hCI, UINT flHandleSize);
BOOL DeleteCursorIconAlias(ULONG hCI, UINT flHandleSize);
BOOL FreeCursorIconAlias(HAND16 hand16, ULONG ulFLags);
HAND16 SetupCursorIconAlias(HAND16 hInst16, HAND32 h32, HAND16 h16, UINT flType,
                               LPBYTE lpResName, WORD hRes16);
HAND16 SetupResCursorIconAlias(HAND16 hInst16, HAND32 h32, LPBYTE lpResName, WORD hRes16, UINT flType);
ULONG SetCursorIconFlag(HAND16 h16, BOOL fSet);
BOOL  ReplaceCursorIcon(LPCURSORICONALIAS lpCIAliasIn);
BOOL FASTCALL  WK32WowCursorIconOp(PVDMFRAME pFrame);
VOID  UpdateCursorIcon(VOID);
HAND16 W32Create16BitCursorIconFrom32BitHandle(HANDLE h32, HAND16 hMod16,
                                                                 PUINT cbData);
BOOL  InitStdCursorIconAlias(VOID);

#if defined(FE_SB)
BOOL FindCursorIconAliasInUse(ULONG hCI);
#endif

#define HCURSOR32(hobj16)       GetCursorIconAlias32((HAND16)(hobj16), HANDLE_TYPE_CURSOR)
#define GETHCURSOR16(hobj32)    GetCursorIconAlias16((HAND32)(hobj32), HANDLE_TYPE_CURSOR)
#define FREEHCURSOR16(hobj16)   DeleteCursorIconAlias((ULONG)(hobj16), HANDLE_16BIT)

#define HICON32(hobj16)         GetCursorIconAlias32((HAND16)(hobj16), HANDLE_TYPE_ICON)
#define GETHICON16(hobj32)      GetCursorIconAlias16((HAND32)(hobj32), HANDLE_TYPE_ICON)
#define FREEHICON16(hobj16)     DeleteCursorIconAlias((ULONG)(hobj16), HANDLE_16BIT)

#define HICON32_REGCLASS(hobj16)  GetClassCursorIconAlias32((HAND16)(hobj16))
HANDLE GetClassCursorIconAlias32(HAND16 h16);
VOID InvalidateCursorIconAlias(LPCURSORICONALIAS lpT);

//
// In win32 USER
//

HANDLE WINAPI WOWLoadCursorIcon(HANDLE hInstance, LPCSTR lpIconName,
                                                 LPTSTR rt, LPHANDLE lphRes16);
HAND16 W32CheckIfAlreadyLoaded(VPVOID pData, WORD ResType);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wcommdlg.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1993, Microsoft Corporation
 *
 *  WCOMDLG.H
 *  WOW32 16-bit COMMDLG support
 *
 *  History:
 *      John Vert (jvert) 31-Dec-1992 - created
--*/



ULONG FASTCALL   WCD32ChooseColor(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32ChooseFont(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32ExtendedError(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32GetOpenFileName(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32GetSaveFileName(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32PrintDlg(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32FindText(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32ReplaceText(PVDMFRAME pFrame);

LONG APIENTRY WCD32UpdateFindReplaceTextAndFlags(HWND hwnd, LPARAM lParam);

VOID Multi_strcpy(LPSTR  dst, LPCSTR src);

INT  Multi_strlen(LPCSTR str);

VOID FASTCALL WOWTellWOWThehDlg(HWND hDlg);

VOID Check_ComDlg_pszptr(PCOMMDLGTD ptd, VPVOID vp);
VOID Ssync_WOW_CommDlg_Structs(PCOMMDLGTD pTD, BOOL f16to32, VPVOID wThunkCSIP);

// these flags are combined to form the dwStat parameter in
// Ssync_WOW_CommDlg_Structs() calls
#define  w32to16     0
#define  w16to32     1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wctlm32.h ===
//*****************************************************************************
//
// 32bit Control message thunking
//
//
// 01-FEB-92 NanduriR Created
//*****************************************************************************


BOOL ThunkEMMsg32(HWND hwnd, UINT uMsg, UINT uParam, LONG lParam,
                  PWORD pwMsgNew, PWORD pwParamNew, PLONG plParamNew);
BOOL ThunkCBMsg32(HWND hwnd, UINT uMsg, UINT uParam, LONG lParam,
                  PWORD pwMsgNew, PWORD pwParamNew, PLONG plParamNew);
BOOL ThunkLBMsg32(HWND hwnd, UINT uMsg, UINT uParam, LONG lParam,
                  PWORD pwMsgNew, PWORD pwParamNew, PLONG plParamNew);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wdde.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WDDE.H
 *  WOW32 DDE worker routines.
 *
 *  History:
 *  WOW DDE support designed and developed by ChandanC
 *
--*/

#include "wowclip.h"

typedef struct _DDENODE {
    HAND16  Initiator;
    struct _DDENODE *Next;
} DDENODE, *LPDDENODE;


/* DDE h16 and h32 object alias structure
 */

typedef struct _HDDE {
    struct _HDDE *pDDENext;    // pointer to next hDDE alias
    HAND16  To_hwnd;           // window that will receive this message
    HAND16  From_hwnd;         // window that sent this message
    HAND16  hMem16;            // handle of WOW app allocated 16 bit object
    HANDLE  hMem32;            // handle of WOW allocated 32 bit object
    WORD    DdeMsg;            // message id
    WORD    DdeFormat;         // message format
    WORD    DdeFlags;          // indicates if it is metafile handle
    HAND16  h16;               // original h16 for bad apps doing EXECUTE
} HDDE, *PHDDE;


typedef struct _DDEINFO {
    WORD    Msg;               // message id
    WORD    Format;            // message format
    WORD    Flags;             // indicates if it is metafile handle
    HAND16  h16;               // original h16 for bad apps doing EXECUTE
} DDEINFO, *PDDEINFO;


typedef struct _CPDATA {
    struct _CPDATA *Next;      // pointer to next CopyData alias
    HAND16  To_hwnd;           // window that will receive this message
    HAND16  From_hwnd;         // window that sent this message
    DWORD   Mem16;             // handle of allocated 16 bit object
    DWORD   Mem32;             // handle of allocated 32 bit object
    DWORD   Flags;             // No real structure is complete without flags
} CPDATA, *PCPDATA;


// This is used by GetMessage to thunk a 32 bit message to the 16 bit
// message.

#define FREEDDEML               0x0001
#define DDE_EXECUTE_FREE_H16    0x0001
#define DDE_EXECUTE_FREE_MEM    0x0002
#define DDE_METAFILE            0x0004
#define DDE_PACKET              0x0008


// This flag is used when a 16 bit app sends data using WM_COPYDATA message
//

#define COPYDATA_16             0x0001

/*----------------------------------------------------------------------------
|       DDEDATA structure
|
|       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
   unsigned short wStatus;
   short    cfFormat;
   HAND16   Value;
} DDEDATA16;

typedef struct {
   unsigned short wStatus;
   short    cfFormat;
   HANDLE   Value;
} DDEDATA32;


VOID    WI32DDEAddInitiator (HAND16 Initiator);
VOID    WI32DDEDeleteInitiator(HAND16 Initiator);
BOOL    WI32DDEInitiate(HAND16 Initiator);
BOOL    DDEDeletehandle(HAND16 h16, HANDLE h32);
HANDLE  DDEFind32(HAND16 h16);
HAND16  DDEFind16(HANDLE h32);
BOOL    DDEAddhandle(HAND16 To_hwnd, HAND16 From_hwnd, HAND16 hMem16, HANDLE hMem32, PDDEINFO pDdeInfo);
HAND16  DDECopyhData16(HAND16 To_hwnd, HAND16 From_hwnd, HANDLE h32, PDDEINFO pDdeInfo);
HANDLE  DDECopyhData32(HAND16 To_hwnd, HAND16 From_hwnd, HAND16 h16, PDDEINFO pDdeInfo);
VOID    W32MarkDDEHandle (HAND16 hMem16);
VOID    W32UnMarkDDEHandle (HAND16 hMem16);
HANDLE  DDEFindPair32(HAND16 To_hwnd, HAND16 From_hwnd, HAND16 hMem16);
HAND16  DDEFindPair16(HAND16 To_hwnd, HAND16 From_hwnd, HANDLE hMem32);
BOOL    W32DDEFreeGlobalMem32 (HANDLE h32);
ULONG FASTCALL WK32WowDdeFreeHandle (PVDMFRAME pFrame);
BOOL    W32DdeFreeHandle16 (HAND16 h16);
PHDDE   DDEFindNode16 (HAND16 h16);
PHDDE   DDEFindNode32 (HANDLE h32);
PHDDE   DDEFindAckNode (HAND16 To_hwnd, HAND16 From_hwnd, HANDLE hMem32);
BOOL    CopyDataAddNode (HAND16 To_hwnd, HAND16 From_hwnd, DWORD Mem16, DWORD Mem32, DWORD Flags);
VPVOID  CopyDataFindData16 (HWND16 To_hwnd, HWND16 From_hwnd, DWORD Mem);
PCPDATA CopyDataFindData32 (HWND16 To_hwnd, HWND16 From_hwnd, DWORD Mem);
BOOL    CopyDataDeleteNode (HWND16 To_hwnd, HWND16 From_hwnd, DWORD Mem);
BOOL    DDEIsTargetMSDraw(HAND16 To_hwnd);
HAND16  Copyh32Toh16 (int cb, LPBYTE lpMem32);
HANDLE  Copyh16Toh32 (int cb, LPBYTE lpMem16);
VOID    FixMetafile32To16 (LPMETAFILEPICT lpMemMeta32, LPMETAFILEPICT16 lpMemMeta16);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wddeml32.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WDDEML.H
 *  WOW32 16-bit DDEML API support
 *
 *  History:
 *  Created Jan-23-1993 by Chandan Chauhan (ChandanC)
--*/

#define MAX_CONVS   3200

typedef struct _BIND1632 {
    DWORD  x16;
    DWORD  x32;
} BIND1632;

ULONG FASTCALL WD32DdeInitialize(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeUninitialize(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeConnectList(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeQueryNextServer(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeDisconnectList(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeConnect(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeDisconnect(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeQueryConvInfo(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeSetUserHandle(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeClientTransaction(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeAbandonTransaction(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdePostAdvise(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeCreateDataHandle(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeAddData(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeGetData(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeAccessData(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeUnaccessData(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeFreeDataHandle(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeGetLastError(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeCreateStringHandle(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeFreeStringHandle(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeQueryString(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeKeepStringHandle(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeEnableCallback(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeNameService(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeCmpStringHandles(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeReconnect(PVDMFRAME pFrame);
HDDEDATA W32DdemlCallBack(UINT type, UINT fmt, HCONV hconv, HSZ hsz1,
                        HSZ hsz2, HDDEDATA hData, DWORD dwData1,
                        DWORD dwData2);
VOID WOWDdemlBind (DWORD x16, DWORD x32, BIND1632 aBind[]);
VOID WOWDdemlUnBind (DWORD x32, BIND1632 aBind[]);
DWORD WOWDdemlGetBind16 (DWORD x32, BIND1632 aBind[]);
DWORD WOWDdemlGetBind32 (DWORD x16, BIND1632 aBind[]);
BOOL DdeDataBuf16to32(PVOID p16DdeData, LPBYTE *pp32DdeData, PDWORD pcbData,
        PDWORD pcbOffset, UINT format);
BOOL DdeDataBuf32to16(PVOID p16DdeData, PVOID p32DdeData, DWORD cbData,
        DWORD cbOffset, UINT format);
VOID DdeDataSize16to32(DWORD *pcbData, DWORD *pcbOff, UINT format);
VOID DdeDataSize32to16(DWORD *pcbData, DWORD *pcbOff, UINT format);
VOID W32GetConvContext (VPVOID vp, PCONVCONTEXT pCC32);
VOID W32PutConvContext (VPVOID vp, PCONVCONTEXT pCC32);

/*
 * Imports from user32.dll - need to eventually be moved to winuserp.h
 * or ddemlp.h
 */
BOOL DdeIsDataHandleInitialized(HDDEDATA hData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wdde.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WDDE.C
 *  WOW32 DDE worker routines.
 *
 *  History:
 *  WOW DDE support designed and developed by ChandanC
 *
--*/


#include "precomp.h"
#pragma hdrstop

LPDDENODE DDEInitiateList = NULL;
STATIC PHDDE phDDEFirst = NULL;       // pointer to first hDDE entry
STATIC PCPDATA pCPDataFirst = NULL;       // pointer to first CopyData entry

MODNAME(wdde.c);


// This routine maintains a list of client windows that are in
// Initiate mode. This is called from THUNKING of DDE_INITIATE
// message (from both the WMDISP32.C and WMSG16.C).
//

VOID WI32DDEAddInitiator (HAND16 Initiator)
{
    LPDDENODE Node;

    Node = (LPDDENODE) malloc_w(sizeof(DDENODE));

    if (Node) {

        //
        // Initialize Node with the Initiator's window handle
        //

        Node->Initiator = Initiator;

        //
        // Insert this Node into the linked list of DDE_Initiate message
        // in progress.
        //

        Node->Next = DDEInitiateList;
        DDEInitiateList = Node;

        LOGDEBUG(12, ("WOW::WI32DDEInitiator(): thunking -- adding an Initiator %04lX\n", Initiator));
    }
    else {

        //
        // We could not allocate memory.
        //

        LOGDEBUG(12, ("WOW::WI32DDEInitiator(): thunking -- Couldn't allocate memory\n"));
        WOW32ASSERT (FALSE);
    }
}


// This routine deletes the client window that was in Initiate mode. Because
// the initiate message is completed now. This is called from UNTHUNKING
// of DDE_INITIATE message (from both the WMDISP32.C and WMSG16.C).
//

VOID WI32DDEDeleteInitiator(HAND16 Initiator)
{
    LPDDENODE Node, Temp1;

    Node = DDEInitiateList;

    if (Node) {

        while (Node) {
            if (Node->Initiator == Initiator) {

                if (Node == DDEInitiateList) {

                    //
                    // first guy in the list
                    //

                    DDEInitiateList = Node->Next;
                }
                else {

                    //
                    // update the list
                    //

                    Temp1->Next = Node->Next;
                }

                LOGDEBUG(12, ("WOW::WI32DDEDeleteInitiator(): unthunking -- deleting an Initiator %08lX\n", Initiator));

                //
                // free up the memory
                //

                free_w(Node);
                Node = NULL;
            }
            else {

                //
                // traverse the list
                //

                Temp1 = Node;
                Node = Node->Next;
            }
        }

    }
    else {

        // This is an ERROR condition, which should never occur. If it does
        // talk to CHANDANC as soon as possible.
        //

        LOGDEBUG(0, ("WOW::WI32DDEDeletInitiator(): unthunking -- no Initiator\n"));
        WOW32ASSERT (FALSE);
    }
}


// This routine is used by DDE_ACK thunk to figure out how to thunk the
// DDE_ACK message, ie, whether lParam is a combination of 2 atoms or
// its a pointer to 32 bit packed structure.
//

BOOL WI32DDEInitiate(HAND16 Initiator)
{
    LPDDENODE Node;

    Node = DDEInitiateList;

    while (Node) {
        if (Node->Initiator == Initiator) {
            //
            // DDE_Initiate is in progress for this Window
            //

            LOGDEBUG(12, ("WOW::WI32DDEInitiate(): thunking -- found an Initiator %08lX\n", Initiator));
            return (TRUE);
        }
        else {
            Node = Node->Next;
        }
    }
    LOGDEBUG(12, ("WOW::WI32DDEInitiate(): thunking -- did not find an Initiator %08lX\n", Initiator));

    //
    // DDE_Initiate is not in progress for this Window
    //

    return (FALSE);
}


//
// This routine determines if the current dde operation is a poke to MSDRAW
// Pokes to MSDRAW for metafilepicts are special because the metafile pict
// is part of the POKE block.
//

BOOL DDEIsTargetMSDraw(HAND16 To_hwnd)
{
    BOOL   fStatus = FALSE;
    HANDLE hInst;
    HAND16 hModuleName;
    LPSTR  lpszModuleName16, lpszMsDraw = "MSDRAW.EXE";
    WORD   cchModuleName = MAX_PATH, cchMsDraw = 10;
    VPVOID vp;
    LPSTR  lpszNewMsDrawKey = "MSDRAW\\protocol\\StdFileEditing\\verb";
    HKEY   hKey = NULL;
    LONG   Status;

    //
    // To check if the target is msdraw, check the following.
    //
    //  - That the destination window hInst is that of a 16 bit task (this is
    //    checking to see if the LOWORD of the hInst is not 0.
    //  - That the module name is MSDRAW.
    //
    // NOTE: THERE ARE THREE CALLBACK16 ROUTINES IN THIS CALL, MAKING IT AN
    //       EXPENSIVE CALL.  HOWEVER THIS CALL IS RARELY MADE.
    //

    if ((hInst = (HANDLE)GetWindowLong((HWND)HWND32(To_hwnd),GWL_HINSTANCE))
        && (LOWORD(hInst) != 0 )) {

        if(vp = GlobalAllocLock16(GMEM_MOVEABLE, cchModuleName, &hModuleName)) {

            //
            // Callback 16 to get the module name of the current hInst
            //

            if (cchModuleName = GetModuleFileName16( LOWORD(hInst), 
                                                     vp, 
                                                     cchModuleName )) {
                GETMISCPTR(vp, lpszModuleName16);

                fStatus = (cchModuleName >= cchMsDraw) &&  !WOW32_stricmp( lpszModuleName16 +  (cchModuleName - cchMsDraw),  lpszMsDraw ) && (Status = RegOpenKeyEx( HKEY_CLASSES_ROOT, lpszNewMsDrawKey, 0, KEY_READ, &hKey)) != ERROR_SUCCESS;

                if (hKey) {
                    RegCloseKey( hKey );
                }
                FREEMISCPTR(lpszModuleName16);
            }

            // Cleanup
            GlobalUnlockFree16(vp);
        }
    }

    return ( fStatus );
}



// This routine converts a 32 bit DDE memory object into a 16 bit DDE
// memory object. It also, does the data conversion from 32 bit to 16 bit
// for the type of data.
//
// WARNING: The Copyh32Toh16() calls may cause 16-bit memory movement
//

HAND16 DDECopyhData16(HAND16 To_hwnd, HAND16 From_hwnd, HANDLE h32, PDDEINFO pDdeInfo)
{
    HAND16  h16 = 0;
    VPVOID  vp1, vp2;
    DDEDATA *lpMem32;
    DDEDATA16 *lpMem16;
    int cb;

    //
    // NULL handle ?
    //

    if (!h32) {
        LOGDEBUG(12, ("WOW::DDECopyhData16(): h32 is %08x\n", h32));
        return 0;
    }

    cb = GlobalSize(h32);
    lpMem32 = GlobalLock(h32);

    if(lpMem32) {
        LOGDEBUG(12, 
                 ("WOW::DDECopyhData16(): CF_FORMAT is %04x\n", 
                 lpMem32->cfFormat));

        switch (lpMem32->cfFormat) {

            default:

            // This is intentional to let it thru to "case statements".
            // ChandanC 5/11/92.

            case CF_TEXT:
            case CF_DSPTEXT:
            case CF_SYLK:
            case CF_DIF:
            case CF_TIFF:
            case CF_OEMTEXT:
            case CF_PENDATA:
            case CF_RIFF:
            case CF_WAVE:
            case CF_OWNERDISPLAY:
                h16 = Copyh32Toh16 (cb, (LPBYTE) lpMem32);

                pDdeInfo->Format = lpMem32->cfFormat;
                break;

            case CF_BITMAP:
            case CF_DSPBITMAP:
                vp1 = GlobalAllocLock16(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HAND16)), &h16);
                if (vp1) {
                    pDdeInfo->Format = lpMem32->cfFormat;
                    GETMISCPTR(vp1, lpMem16);
                    RtlCopyMemory(lpMem16, lpMem32, 4);
                    STOREWORD(lpMem16->Value, GETHBITMAP16(*((HANDLE *)lpMem32->Value)));
                    FLUSHVDMPTR(vp1,(sizeof(DDEDATA)-1+sizeof(HAND16)),lpMem16);
                    FREEMISCPTR(lpMem16);
                    GlobalUnlock16(h16);
                }
                break;

            case CF_PALETTE:
                vp1 = GlobalAllocLock16(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HAND16)), &h16);
                if (vp1) {
                    pDdeInfo->Format = lpMem32->cfFormat;
                    GETMISCPTR(vp1, lpMem16);
                    RtlCopyMemory(lpMem16, lpMem32, 4);
                    STOREWORD(lpMem16->Value, GETHPALETTE16(*((HANDLE *)lpMem32->Value)));
                    FLUSHVDMPTR(vp1,(sizeof(DDEDATA)-1+sizeof(HAND16)),lpMem16);
                    FREEMISCPTR(lpMem16);
                    GlobalUnlock16(h16);
                }
                break;
    
            case CF_DIB:
            {
                LPBYTE lpMemDib32;
                HAND16 hDib16 = 0;
                HANDLE hDib32;
    
                vp1 = GlobalAllocLock16(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HAND16)), &h16);
                if (vp1) {
    
                    GETMISCPTR(vp1, lpMem16);
                    RtlCopyMemory(lpMem16, lpMem32, 4);
                    FREEMISCPTR(lpMem16);
    
                    hDib32 = (*((HANDLE *)lpMem32->Value));
                    if (hDib32) {
                        lpMemDib32 = GlobalLock(hDib32);
                        if(lpMemDib32) {
                            cb = GlobalSize(hDib32);
                            hDib16 = Copyh32Toh16 (cb, (LPBYTE) lpMemDib32);
                            GlobalUnlock(hDib32);
                            pDdeInfo->Format = lpMem32->cfFormat;
                            pDdeInfo->Flags = 0;
                            pDdeInfo->h16 = 0;
                            DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hDib16, hDib32, pDdeInfo);
                        }
                    }
                    GETMISCPTR(vp1, lpMem16);
                    STOREWORD(lpMem16->Value, hDib16);
                    GlobalUnlock16(h16);
                    FLUSHVDMPTR(vp1,(sizeof(DDEDATA)-1+sizeof(HAND16)),lpMem16);
                    FREEMISCPTR(lpMem16);
                }
            }
            break;
    
            case CF_METAFILEPICT:
            case CF_DSPMETAFILEPICT:
            {
                HANDLE hMeta32, hMF32 = NULL;
                HAND16 hMeta16 = 0, hMF16 = 0;
                LPMETAFILEPICT lpMemMeta32;
                LPMETAFILEPICT16 lpMemMeta16;
                BOOL IsMSDRAWPoke;
    
                //
                // We need to find out if the to_handle is MSDRAW, in which case
                // we should copy the METAFILEPICT data to the DDEPOKE instead
                // of a handle to the METAFILEPICT.
    
                if( IsMSDRAWPoke = ((pDdeInfo->Msg == WM_DDE_POKE) && DDEIsTargetMSDraw(To_hwnd)) ) {
                    cb  = sizeof(DDEPOKE)-1+sizeof(METAFILEPICT16);
                }
                else {
                    cb  = sizeof(DDEDATA)-1+sizeof(HAND16);
                }
                vp1 = GlobalAllocLock16(GMEM_DDESHARE, cb, &h16);
    
    
                if (vp1) {
                    GETMISCPTR(vp1, lpMem16);
                    RtlCopyMemory(lpMem16, lpMem32, 4);
                    hMeta32 = (*((HANDLE *)lpMem32->Value));
    
                    if ( IsMSDRAWPoke ) {
    
                        lpMemMeta16 = (LPMETAFILEPICT16)((PBYTE)lpMem16 + sizeof(DDEPOKE) - 1);
                        RtlZeroMemory( (PVOID)lpMemMeta16, sizeof (METAFILEPICT16) );
                        if (hMeta32) {
                            lpMemMeta32 = GlobalLock(hMeta32);
                            if(lpMemMeta32) {
                                FixMetafile32To16 (lpMemMeta32, lpMemMeta16);
                                FREEMISCPTR(lpMem16);
    
                                hMF32 = lpMemMeta32->hMF;
                                if (hMF32) {
                                    hMF16 = WinMetaFileFromHMF(hMF32, FALSE);
                                    pDdeInfo->Format = lpMem32->cfFormat;
                                    pDdeInfo->h16 = 0;
                                    pDdeInfo->Flags = DDE_METAFILE;
                                    DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hMF16, hMF32, pDdeInfo);
                                }
                            }
                            GETMISCPTR(vp1, lpMem16);
                            lpMemMeta16 = (LPMETAFILEPICT16)((PBYTE)lpMem16 + sizeof(DDEPOKE) - 1);
                            STOREWORD(lpMemMeta16->hMF, hMF16);
                            GlobalUnlock(hMeta32);
                        }
    
                    }
                    else {
                        if (hMeta32) {
                            lpMemMeta32 = GlobalLock(hMeta32);
                            if(lpMemMeta32) {
                                // 16-bit memory may move -- invalidate ptr
                                FREEMISCPTR(lpMem16);
                                vp2 = GlobalAllocLock16(GMEM_DDESHARE, sizeof(METAFILEPICT16), &hMeta16);
                                WOW32ASSERT(vp2);
                                if (vp2) {
                                    GETMISCPTR(vp2, lpMemMeta16);
                                    FixMetafile32To16(lpMemMeta32, lpMemMeta16);
                                    FREEMISCPTR(lpMemMeta16);
    
                                    pDdeInfo->Format = lpMem32->cfFormat;
                                    pDdeInfo->Flags = 0;
                                    pDdeInfo->h16 = 0;
                                    DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hMeta16, hMeta32, pDdeInfo);
                                    hMF32 = lpMemMeta32->hMF;
                                    if (hMF32) {
                                        hMF16 = WinMetaFileFromHMF(hMF32,FALSE);
                                        pDdeInfo->Flags = DDE_METAFILE;
                                        DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hMF16, hMF32, pDdeInfo);
                                    }
    
                                    GETMISCPTR(vp2, lpMemMeta16);
                                    STOREWORD(lpMemMeta16->hMF, hMF16);
                                    GlobalUnlock16(hMeta16);
                                    FLUSHVDMPTR(vp2, 8, lpMemMeta16);
                                    FREEMISCPTR(lpMemMeta16);
                                }
                                GlobalUnlock(hMeta32);
                            }
                        }
                        GETMISCPTR(vp1, lpMem16);
                        STOREWORD(lpMem16->Value, hMeta16);
                    }
    
                    GlobalUnlock16(h16);
                    FLUSHVDMPTR(vp1, cb, lpMem16);
                    FREEMISCPTR(lpMem16);
                }
            }
            break;
        }

        GlobalUnlock(h32);
    }

    return (h16);
}




// This routine converts a 16 bit DDE memory object into a 32 bit DDE
// memory object. It also, does the data conversion from 16 bit to 32 bit
// for the type of data.
//

HANDLE  DDECopyhData32(HAND16 To_hwnd, HAND16 From_hwnd, HAND16 h16, PDDEINFO pDdeInfo)
{
    HANDLE  h32 = NULL;
    INT     cb;
    VPVOID  vp;
    DDEDATA *lpMem16;
    DDEDATA32 *lpMem32;

    //
    // AmiPro passes a NULL handle.
    //

    if (!h16) {
        LOGDEBUG(12, ("WOW::DDECopyhData32(): h16 is %04x\n", h16));
        return (HANDLE) NULL;
    }

    vp = GlobalLock16(h16, &cb);
    GETMISCPTR(vp, lpMem16);
    LOGDEBUG(12, ("WOW::DDECopyhData32(): CF_FORMAT is %04x\n", lpMem16->cfFormat));

    switch(lpMem16->cfFormat) {

        default:

        // This is intentional to let it thru to the "case statements".
        // ChandanC 5/11/92.

        case CF_TEXT:
        case CF_DSPTEXT:
        case CF_SYLK:
        case CF_DIF:
        case CF_TIFF:
        case CF_OEMTEXT:
        case CF_PENDATA:
        case CF_RIFF:
        case CF_WAVE:
        case CF_OWNERDISPLAY:
            h32 = Copyh16Toh32 (cb, (LPBYTE) lpMem16);

            pDdeInfo->Format = lpMem16->cfFormat;
        break;

        case CF_BITMAP:
        case CF_DSPBITMAP:
            h32 = WOWGLOBALALLOC(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HANDLE)));
            if (h32) {
                pDdeInfo->Format = lpMem16->cfFormat;
                lpMem32 = GlobalLock(h32);
                if(lpMem32) {
                    RtlCopyMemory(lpMem32, lpMem16, 4);
                    lpMem32->Value = HBITMAP32(FETCHWORD(*((WORD *)lpMem16->Value)));
                    GlobalUnlock(h32);
                }
            }
            break;

        case CF_PALETTE:
            h32 = WOWGLOBALALLOC(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HANDLE)));
            if (h32) {
                pDdeInfo->Format = lpMem16->cfFormat;
                lpMem32 = GlobalLock(h32);
                if(lpMem32) {
                    RtlCopyMemory(lpMem32, lpMem16, 4);
                    lpMem32->Value = HPALETTE32(FETCHWORD(*((WORD *)lpMem16->Value)));
                    GlobalUnlock(h32);
                }
            }
            break;

        case CF_DIB:
        {
            LPBYTE lpMemDib16;
            HAND16 hDib16;
            HANDLE hDib32 = NULL;

            h32 = WOWGLOBALALLOC(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HANDLE)));
            if (h32) {
                lpMem32 = GlobalLock(h32);
                if(lpMem32) {
                    RtlCopyMemory(lpMem32, lpMem16, 4);

                    hDib16 = FETCHWORD(*((WORD *)lpMem16->Value));
                    if (hDib16) {
                        vp = GlobalLock16(hDib16, &cb);
                        GETMISCPTR(vp, lpMemDib16);
                        hDib32 = Copyh16Toh32 (cb, (LPBYTE) lpMemDib16);

                        pDdeInfo->Format = lpMem16->cfFormat;
                        pDdeInfo->Flags = 0;
                        pDdeInfo->h16 = 0;
                        DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hDib16, hDib32, pDdeInfo);

                        GlobalUnlock16(hDib16);
                        FREEMISCPTR(lpMemDib16);
                    }
                    lpMem32->Value = hDib32;
                    GlobalUnlock(h32);
                }
            }
        }
        break;

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
        {
            HANDLE hMeta32 = NULL, hMF32 = NULL;
            HAND16 hMeta16, hMF16 = 0;
            LPMETAFILEPICT lpMemMeta32;
            LPMETAFILEPICT16 lpMemMeta16;

            h32 = WOWGLOBALALLOC(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HANDLE)));
            if (h32) {
                lpMem32 = GlobalLock(h32);
                if(lpMem32) {
                    RtlCopyMemory(lpMem32, lpMem16, 4);

                    //
                    // MSDRAW has the METAFILEPICT in the DDEPOKE block instead
                    // of a handle to the METAFILEPICT.  So we need to find out 
                    // if the to handle belongs to MSDRAW.  Since MSDRAW is a 16
                    // bit server we needn't thunk the metafilepict at all, we
                    // just use NULL as the 32 bit handle to the metafilepict.
                    //

                    hMeta32 = NULL;
                    if( !((pDdeInfo->Msg == WM_DDE_POKE) && DDEIsTargetMSDraw(To_hwnd)) ) {

                        hMeta16 = FETCHWORD(*((WORD *)lpMem16->Value));

                        //
                        // Make sure that a valid metafile pict handle has been
                        // passed in otherwise use NULL again as the hMeta32.
                        //
        
                        if (hMeta16 && (vp = GlobalLock16(hMeta16, &cb))) {
                            GETMISCPTR(vp, lpMemMeta16);
                            hMeta32 = WOWGLOBALALLOC(GMEM_DDESHARE, sizeof(METAFILEPICT));
                            WOW32ASSERT(hMeta32);
                            if (hMeta32) {
                                lpMemMeta32 = GlobalLock(hMeta32);
                                if(lpMemMeta32) {
                                    lpMemMeta32->mm = (LONG) FETCHSHORT(lpMemMeta16->mm);
                                    lpMemMeta32->xExt = (LONG) FETCHSHORT(lpMemMeta16->xExt);
                                    lpMemMeta32->yExt = (LONG) FETCHSHORT(lpMemMeta16->yExt);
                                    pDdeInfo->Format = lpMem16->cfFormat;
                                    pDdeInfo->Flags = 0;
                                    pDdeInfo->h16 = 0;
                                    DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hMeta16, hMeta32, pDdeInfo);

                                    hMF16 = FETCHWORD(lpMemMeta16->hMF);
    
                                    if (hMF16) {
                                        hMF32 = (HMETAFILE) HMFFromWinMetaFile(hMF16, FALSE);
                                        pDdeInfo->Flags = DDE_METAFILE;
                                        DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hMF16, hMF32, pDdeInfo);
                                    }

                                    lpMemMeta32->hMF = (HMETAFILE) hMF32;
                                    GlobalUnlock(hMeta32);
                                }
                            }
                            GlobalUnlock16(hMeta16);
                            FREEMISCPTR(lpMemMeta16);
                        }
                    }
                    lpMem32->Value = hMeta32;
                    GlobalUnlock(h32);
                }
            }
        }
        break;
    }

    GlobalUnlock16(h16);

    FREEMISCPTR(lpMem16);
    return (h32);
}


/****** These routines maintain a linked list of dde handles, which
******* are the h16 and h32 pairs.
******/



//  This routine adds the given h16-h32 pair to the linked list, and updates
//  the list.
//

BOOL DDEAddhandle(HAND16 To_hwnd, HAND16 From_hwnd, HAND16 hMem16, HANDLE hMem32, PDDEINFO pDdeInfo)
{
    PHDDE   phTemp;

    if (hMem16 && hMem32) {
        if (phTemp = malloc_w (sizeof(HDDE))) {
            phTemp->hMem16    = hMem16;
            phTemp->hMem32    = hMem32;
            phTemp->To_hwnd   = To_hwnd;
            phTemp->From_hwnd = From_hwnd;

            phTemp->DdeMsg    = pDdeInfo->Msg;
            phTemp->DdeFormat = pDdeInfo->Format;
            phTemp->DdeFlags  = pDdeInfo->Flags;

            phTemp->h16       = pDdeInfo->h16;

            phTemp->pDDENext  = phDDEFirst;     // insert at the top
            phDDEFirst        = phTemp;         // update list head

            // Mark the GAH_WOWDDEFREEHANDLE (ie GAH_PAHTOM) bit in the global
            // arena of this handle.

            W32MarkDDEHandle (hMem16);

            return (TRUE);
        }
        else {
            LOGDEBUG(2, ("WOW::DDEAddhandle(): *** memory allocation failed *** \n"));
            return (FALSE);
        }
    }

    LOGDEBUG(2,("WOW::DDEAddhandle(): *** ERROR *** one of the handles is NULL \n"));
    return (FALSE);
}


//  This routine deletes the given h16-h32 pair from the list and frees up
//   the memory.
//

BOOL DDEDeletehandle(HAND16 h16, HANDLE h32)
{
    PHDDE   phTemp1, phTemp2;

    phTemp1 = phDDEFirst;

    if ((phTemp1->hMem16 == h16) && (phTemp1->hMem32 == h32)) {  // first node
        phDDEFirst = phTemp1->pDDENext;
        free_w(phTemp1);
        return (TRUE);
    }
    else {                // rest of the list
        phTemp2 = phTemp1;
        phTemp1 = phTemp1->pDDENext;

        while (phTemp1) {
            if ((phTemp1->hMem16 == h16) && (phTemp1->hMem32 == h32)) {
                phTemp2->pDDENext = phTemp1->pDDENext;
                free_w(phTemp1);
                return (TRUE);
            }
            phTemp2 = phTemp1;
            phTemp1 = phTemp1->pDDENext;
        }

        LOGDEBUG(2,("WOW::DDEDeleteHandle : Can't find a 16-32 memory pair\n"));

        return (FALSE);
    }
}




// This routine finds a hMem16 for a DDE conversation, if one exists.
//

HAND16 DDEFindPair16(HAND16 To_hwnd, HAND16 From_hwnd, HANDLE hMem32)
{
    PHDDE   phTemp;

    phTemp = phDDEFirst;

    while (phTemp) {
        if ((phTemp->To_hwnd == To_hwnd) &&
            (phTemp->From_hwnd == From_hwnd) &&
            (phTemp->hMem32 == hMem32)) {
                return (phTemp->hMem16);
        }
        else {
            phTemp = phTemp->pDDENext;
        }
    }
    return (HAND16) NULL;
}


// This routine finds a hMem32 for a DDE conversation, if one exists.
//

HANDLE DDEFindPair32(HAND16 To_hwnd, HAND16 From_hwnd, HAND16 hMem16)
{
    PHDDE   phTemp;

    phTemp = phDDEFirst;

    while (phTemp) {
        if ((phTemp->To_hwnd == To_hwnd) &&
            (phTemp->From_hwnd == From_hwnd) &&
            (phTemp->hMem16 == hMem16)) {
                return (phTemp->hMem32);
        }
        else {
            phTemp = phTemp->pDDENext;
        }
    }
    return (HANDLE) NULL;
}


// This routine find the DDE node that is doing DDE conversation
//

PHDDE DDEFindNode16 (HAND16 h16)
{
    PHDDE   phTemp;

    phTemp = phDDEFirst;

    while (phTemp) {
        if (phTemp->hMem16 == h16) {
            return (phTemp);
        }
        phTemp = phTemp->pDDENext;
    }

    return (NULL);
}


// This routine find the DDE node that is doing DDE conversation
//

PHDDE DDEFindNode32 (HANDLE h32)
{
    PHDDE   phTemp;

    phTemp = phDDEFirst;

    while (phTemp) {
        if (phTemp->hMem32 == h32) {
            return (phTemp);
        }
        phTemp = phTemp->pDDENext;
    }

    return (NULL);
}


// This routine returns a pointer to the DDE node, if the conversation exists,
// else it retunrs NULL

PHDDE DDEFindAckNode (HAND16 To_hwnd, HAND16 From_hwnd, HANDLE hMem32)
{
    PHDDE   phTemp;

    phTemp = phDDEFirst;

    while (phTemp) {
        if ((phTemp->To_hwnd == To_hwnd) &&
            (phTemp->From_hwnd == From_hwnd) &&
            (phTemp->hMem32 == hMem32)) {
                return (phTemp);
        }
        else {
            phTemp = phTemp->pDDENext;
        }
    }
    return (PHDDE) NULL;
}


//  This function marks GAH_WOWDDEFREEHANDLE bit in the global arena of the
//  hMem16.
//

VOID W32MarkDDEHandle (HAND16 hMem16)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    Parm16.WndProc.wParam = hMem16;
    Parm16.WndProc.wMsg = 1;
    CallBack16(RET_WOWDDEFREEHANDLE, &Parm16, 0, &vp);
}

VOID W32UnMarkDDEHandle (HAND16 hMem16)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    Parm16.WndProc.wParam = hMem16;
    Parm16.WndProc.wMsg = 0;
    CallBack16(RET_WOWDDEFREEHANDLE, &Parm16, 0, &vp);
}

// This function frees the 32 and 16 bit memory. It is called by 32 bit
// BASE by GlobalFree.
//

BOOL W32DDEFreeGlobalMem32 (HANDLE h32)
{
    HAND16 h16;
    PHDDE pDdeNode;
    BOOL fOkToFree = TRUE;

    if (h32) {
        if (pDdeNode = DDEFindNode32(h32)) {

            if (pDdeNode->DdeFlags & DDE_METAFILE) {
                LOGDEBUG (12, ("WOW32: W32DDEFreeGlobalMem32: Freeing MetaFile hMF32 %x\n", h32));
                DeleteMetaFile (h32);
                fOkToFree = FALSE;
            }

            while ((pDdeNode) && (h16 = pDdeNode->hMem16)) {
                W32UnMarkDDEHandle (h16);
                GlobalUnlockFree16(GlobalLock16(h16, NULL));
                DDEDeletehandle(h16, h32);
                pDdeNode = DDEFindNode32(h32);
            }
        }
        else {

            LOGDEBUG (2, ("WOW32: W32DDEFreeGlobalMem32: Can't find a 16-32 memory pair\n"));
        }
    }
    else {
        WOW32WARNMSG(FALSE, "WOW32: W32DDEFreeGlobalMem32: h32 is NULL to Win32 GlobalFree\n");
        /*
         * since in this case the Failure and Success return values from
         * GlobalFree are NULL, just return false so things are faster
         * in GlobalFree.
         */
        fOkToFree = FALSE;
    }

    return(fOkToFree);
}


// This function frees only the 32 bit memory because the 16 bit memory
// is being free'd by the 16 bit app. We are just getting the
// notification of this fact.  So free the corresponding 32 bit memory.
//

ULONG FASTCALL WK32WowDdeFreeHandle (PVDMFRAME pFrame)
{
    ULONG  ul;
    HAND16 h16;
    PWOWDDEFREEHANDLE16 parg16;

    GETARGPTR(pFrame, sizeof(WOWDDEFREEHANDLE16), parg16);

    h16 = (HAND16) parg16->h16;

    ul = W32DdeFreeHandle16 (h16);

    FREEARGPTR(parg16);
    RETURN (ul);
}


BOOL W32DdeFreeHandle16 (HAND16 h16)
{
    HANDLE h32;
    PHDDE pDdeNode;

    if (!(pDdeNode = DDEFindNode16(h16))) {
        LOGDEBUG (12, ("WOW::W32DdeFreeHandle16 : Not found h16 -> %04x\n", h16));

        // in this case look for a 16:32 pair in the list of hdrop handles
        // see file wshell.c for comments
        FindAndReleaseHDrop16(h16);

        return (TRUE);
    }

    LOGDEBUG (12, ("WOW::W32DdeFreeHandle16 : Entering... h16 -> %04x\n", h16));

    if (pDdeNode->DdeMsg == WM_DDE_EXECUTE) {
        LOGDEBUG (12, ("WOW::W32DdeFreeHandle16 : App TRYING  !!! to freeing EXECUTE h16 -> %04x\n", h16));
        pDdeNode->DdeFlags = pDdeNode->DdeFlags | DDE_EXECUTE_FREE_MEM;
        return (FALSE);
    }
    else {
        while ((pDdeNode) && (h32 = pDdeNode->hMem32)) {
            if (pDdeNode->DdeFlags & DDE_METAFILE) {
                DDEDeletehandle(h16, h32);
                DeleteMetaFile (h32);
            }
            else {
                /*
                 * REMOVE THE PAIR FIRST!!!
                 * Since GlobalFree will hook back to W32DDEFreeGlobalMem32
                 * we want to remove the handle from our tables before
                 * the call.
                 */
                DDEDeletehandle(h16, h32);
                WOWGLOBALFREE(h32);
            }

            pDdeNode = DDEFindNode16(h16);
        }
    }

    LOGDEBUG (12, ("WOW::W32DdeFreeHandle16 : Leaving ...\n"));
    return (TRUE);
}


//  This routine adds the given h16-h32 CopyData pair to the linked list,
//  and updates the list.
//

BOOL CopyDataAddNode (HAND16 To_hwnd, HAND16 From_hwnd, DWORD Mem16, DWORD Mem32, DWORD Flags)
{
    PCPDATA pTemp;

    if (Mem16 && Mem32) {
        if (pTemp = malloc_w (sizeof(CPDATA))) {
            pTemp->Mem16    = Mem16;
            pTemp->Mem32    = Mem32;
            pTemp->To_hwnd  = To_hwnd;
            pTemp->From_hwnd= From_hwnd;
            pTemp->Flags    = Flags;
            pTemp->Next     = pCPDataFirst;     // insert at the top
            pCPDataFirst    = pTemp;         // update list head

            return (TRUE);
        }
        else {
            LOGDEBUG(2, ("WOW::CopyDataAddNode: *** memory allocation failed *** \n"));
            return (FALSE);
        }
    }

    LOGDEBUG(2,("WOW::CopyDataAddNode: *** ERROR *** one of the memory pointers is NULL \n"));
    return (FALSE);
}


VPVOID CopyDataFindData16 (HWND16 To_hwnd, HWND16 From_hwnd, DWORD Mem)
{
    PCPDATA pTemp;

    pTemp = pCPDataFirst;

    while (pTemp) {
        if ((pTemp->To_hwnd == To_hwnd) &&
            (pTemp->From_hwnd == From_hwnd) &&
            (pTemp->Mem32 == Mem)) {
                return (pTemp->Mem16);
        }
        else {
            pTemp = pTemp->Next;
        }
    }
    return 0;
}


PCPDATA CopyDataFindData32 (HWND16 To_hwnd, HWND16 From_hwnd, DWORD Mem)
{
    PCPDATA pTemp;

    pTemp = pCPDataFirst;

    while (pTemp) {
        if ((pTemp->To_hwnd == To_hwnd) &&
            (pTemp->From_hwnd == From_hwnd) &&
            (pTemp->Mem16 == Mem)) {
                return (pTemp);
        }
        else {
            pTemp = pTemp->Next;
        }
    }
    return 0;
}


//  This routine deletes the given h16-h32 pair from the list.
//
//

BOOL CopyDataDeleteNode (HWND16 To_hwnd, HWND16 From_hwnd, DWORD Mem)
{
    PCPDATA pTemp1;
    PCPDATA pTemp2;

    pTemp1 = pCPDataFirst;

    if ((pTemp1->To_hwnd == To_hwnd) &&
        (pTemp1->From_hwnd == From_hwnd) &&
        (pTemp1->Mem32 == Mem)) {
        pCPDataFirst = pTemp1->Next;
        free_w (pTemp1);
        return (TRUE);
    }
    else {
        pTemp2 = pTemp1;
        pTemp1 = pTemp1->Next;

        while (pTemp1) {
            if ((pTemp1->To_hwnd == To_hwnd) &&
                (pTemp1->From_hwnd == From_hwnd) &&
                (pTemp1->Mem32 == Mem)) {
                    pTemp2->Next = pTemp1->Next;
                    free_w (pTemp1);
                    return (TRUE);
            }

            pTemp2 = pTemp1;
            pTemp1 = pTemp1->Next;
        }
        return (FALSE);
    }

}


// While allocating GMEM_DDESHARE memory object should we have GMEM_MOVEABLE
// flag or not ???????????????????
// ChandanC Sept 23rd 1993.
//
// WARNING: This function may cause 16-bit memory movement.
//

HAND16  Copyh32Toh16 (int cb, LPBYTE lpMem32)
{
    HAND16  h16 = 0;
    LPBYTE  lpMem16;
    VPVOID  vp;

    vp = GlobalAllocLock16(GMEM_DDESHARE | GMEM_MOVEABLE, cb, &h16);
    WOW32ASSERT(vp);
    if (vp) {
        GETMISCPTR(vp, lpMem16);
        RtlCopyMemory(lpMem16, lpMem32, cb);
        GlobalUnlock16(h16);
        FLUSHVDMPTR(vp, cb, lpMem16);
        FREEMISCPTR(lpMem16);
    }

    return (h16);
}


HANDLE  Copyh16Toh32 (int cb, LPBYTE lpMem16)
{
    HANDLE hMem32;
    LPBYTE  lpMem32;

    hMem32 = WOWGLOBALALLOC(GMEM_DDESHARE | GMEM_MOVEABLE, cb);
    WOW32ASSERT(hMem32);
    if (hMem32) {
        lpMem32 = GlobalLock(hMem32);
        if(lpMem32) {
            RtlCopyMemory (lpMem32, lpMem16, cb);
            GlobalUnlock(hMem32);
        }
    }

    return (hMem32);
}


VOID  FixMetafile32To16 (LPMETAFILEPICT lpMemMeta32, LPMETAFILEPICT16 lpMemMeta16)
{

    if (lpMemMeta32->mm == MM_ANISOTROPIC) {
        LONG xExt = lpMemMeta32->xExt;
        LONG yExt = lpMemMeta32->yExt;

        while (xExt < (LONG)(SHORT)MINSHORT
            || xExt > (LONG)(SHORT)MAXSHORT
            || yExt < (LONG)(SHORT)MINSHORT
            || yExt > (LONG)(SHORT)MAXSHORT) {
            xExt = xExt / 2;
            yExt = yExt / 2;
        }
        STORESHORT(lpMemMeta16->mm,   MM_ANISOTROPIC);
        STORESHORT(lpMemMeta16->xExt, xExt);
        STORESHORT(lpMemMeta16->yExt, yExt);
    }
    else {
        STORESHORT(lpMemMeta16->mm,   lpMemMeta32->mm);
        STORESHORT(lpMemMeta16->xExt, lpMemMeta32->xExt);
        STORESHORT(lpMemMeta16->yExt, lpMemMeta32->yExt);
    }
}

//
// CHEESE ALERT: This function is exported for the OLE DDE code
// to call so it can correctly free up metafile handle pairs in
// a VDM. This function is NOT found in any header files. If you
// change this, you need to find its use in the OLE project.
// Probably best to just leave it alone.
//
BOOL WINAPI WOWFreeMetafile( HANDLE h32 )
{
    return( W32DDEFreeGlobalMem32( h32 ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wddetbl2.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WDDETBL2.h
 *  WOW32 16-bit DDEML API tables
 *
 *  History:
 *  Created 26-Jan-1993 by Chandan Chauhan (ChandanC)
--*/


    {W32FUN(UNIMPLEMENTEDAPI,                 "DUMMYENTRY",               MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(WD32DdeInitialize,                "DDEINITIALIZE",            MOD_DDEML,   sizeof(DDEINITIALIZE16))},
    {W32FUN(WD32DdeUninitialize,              "DDEUNINITIALIZE",          MOD_DDEML,   sizeof(DDEUNINITIALIZE16))},
    {W32FUN(WD32DdeConnectList,               "DDECONNECTLIST",           MOD_DDEML,   sizeof(DDECONNECTLIST16))},
    {W32FUN(WD32DdeQueryNextServer,           "DDEQUERYNEXTSERVER",       MOD_DDEML,   sizeof(DDEQUERYNEXTSERVER16))},
    {W32FUN(WD32DdeDisconnectList,            "DDEDISCONNECTLIST",        MOD_DDEML,   sizeof(DDEDISCONNECTLIST16))},
    {W32FUN(WD32DdeConnect,                   "DDECONNECT",               MOD_DDEML,   sizeof(DDECONNECT16))},
    {W32FUN(WD32DdeDisconnect,                "DDECONNECT",               MOD_DDEML,   sizeof(DDEDISCONNECT16))},
    {W32FUN(WD32DdeQueryConvInfo,             "DDEQUERYCONVINFO",         MOD_DDEML,   sizeof(DDEQUERYCONVINFO16))},
    {W32FUN(WD32DdeSetUserHandle,              "DDESETUSERHANDLE",        MOD_DDEML,   sizeof(DDESETUSERHANDLE16))},

  /*** 0011 ***/
    {W32FUN(WD32DdeClientTransaction,         "DDECLIENTTRANSACTION",     MOD_DDEML,   sizeof(DDECLIENTTRANSACTION16))},
    {W32FUN(WD32DdeAbandonTransaction,        "DDEABANDONTRANSACTION",    MOD_DDEML,   sizeof(DDEABANDONTRANSACTION16))},
    {W32FUN(WD32DdePostAdvise,                "DDEPOSTADVISE",            MOD_DDEML,   sizeof(DDEPOSTADVISE16))},
    {W32FUN(WD32DdeCreateDataHandle,          "DDECREATEDATAHANDLE",      MOD_DDEML,   sizeof(DDECREATEDATAHANDLE16))},
    {W32FUN(WD32DdeAddData,                   "DDEADDDATA",               MOD_DDEML,   sizeof(DDEADDDATA16))},
    {W32FUN(WD32DdeGetData,                   "DDEGETDATA",               MOD_DDEML,   sizeof(DDEGETDATA16))},
    {W32FUN(WD32DdeAccessData,                "DDEACCESSDATA",            MOD_DDEML,   sizeof(DDEACCESSDATA16))},
    {W32FUN(WD32DdeUnaccessData,              "DDEUNACCESSDATA",          MOD_DDEML,   sizeof(DDEUNACCESSDATA16))},
    {W32FUN(WD32DdeFreeDataHandle,            "DDEFREEDATAHANDLE",        MOD_DDEML,   sizeof(DDEFREEDATAHANDLE16))},
    {W32FUN(WD32DdeGetLastError,              "DDEGETLASTERROR",          MOD_DDEML,   sizeof(DDEGETLASTERROR16))},

  /*** 0021 ***/
    {W32FUN(WD32DdeCreateStringHandle,        "DDECREATESTRINGHANDLE",    MOD_DDEML,   sizeof(DDECREATESTRINGHANDLE16))},
    {W32FUN(WD32DdeFreeStringHandle,          "DDEFREESTRINGHANDLE",      MOD_DDEML,   sizeof(DDEFREESTRINGHANDLE16))},
    {W32FUN(WD32DdeQueryString,               "DDEQUERYSTRING",           MOD_DDEML,   sizeof(DDEQUERYSTRING16))},
    {W32FUN(WD32DdeKeepStringHandle,          "DDEKEEPSTRINGHANDLE",      MOD_DDEML,   sizeof(DDEKEEPSTRINGHANDLE16))},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(WD32DdeEnableCallback,            "DDEENABLECALLBACK",        MOD_DDEML,   sizeof(DDEENABLECALLBACK16))},
    {W32FUN(WD32DdeNameService,               "DDENAMESERVICE",           MOD_DDEML,   sizeof(DDENAMESERVICE16))},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},

  /*** 0031 ***/
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(WD32DdeCmpStringHandles,          "DDECMPSTRINGHANDLES",      MOD_DDEML,   sizeof(DDECMPSTRINGHANDLES16))},
    {W32FUN(WD32DdeReconnect,                 "DDERECONNECT",             MOD_DDEML,   sizeof(DDERECONNECT16))},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wdib.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WDIB.C
 *  DIB.DRV support
 *
 *  History:
 *  28-Apr-1994 Sudeep Bharati
 *  Created.
 *
--*/


#include "precomp.h"
#pragma hdrstop
#include "wowgdip.h"
#include "wdib.h"
#include "memapi.h"

MODNAME(wdib.c);

#define CJSCAN(width,planes,bits) ((((width)*(planes)*(bits)+31) & ~31) / 8)
#define ABS(X) (((X) < 0 ) ? -(X) : (X))

BOOL W32CheckDibColorIndices(LPBITMAPINFOHEADER lpbmi);

// VGA colors
RGBQUAD rgbVGA[] = {
//    Blue  Green   Red
      0x00, 0x00, 0x00, 0,    // 0  ; black
      0x00, 0x00, 0x80, 0,    // 1  ; dark red
      0x00, 0x80, 0x00, 0,    // 2  ; dark green
      0x00, 0x80, 0x80, 0,    // 3  ; mustard
      0x80, 0x00, 0x00, 0,    // 4  ; dark blue
      0x80, 0x00, 0x80, 0,    // 5  ; purple
      0x80, 0x80, 0x00, 0,    // 6  ; dark turquoise
      0xc0, 0xc0, 0xc0, 0,    // 7  ; gray
      0x80, 0x80, 0x80, 0,    // 8  ; dark gray
      0x00, 0x00, 0xff, 0,    // 9  ; red
      0x00, 0xff, 0x00, 0,    // a  ; green
      0x00, 0xff, 0xff, 0,    // b  ; yellow
      0xff, 0x00, 0x00, 0,    // c  ; blue
      0xff, 0x00, 0xff, 0,    // d  ; magenta
      0xff, 0xff, 0x00, 0,    // e  ; cyan
      0xff, 0xff, 0xff, 0     // f  ; white
};

RGBQUAD rgb4[] = {
      0xc0, 0xdc, 0xc0, 0,    // 8
      0xf0, 0xca, 0xa6, 0,    // 9
      0xf0, 0xfb, 0xff, 0,    // 246
      0xa4, 0xa0, 0xa0, 0     // 247
};

PDIBINFO pDibInfoHead = NULL;
PDIBSECTIONINFO pDibSectionInfoHead = NULL;

HDC W32HandleDibDrv (PVPVOID vpbmi16)
{
    HDC             hdcMem = NULL;
    HBITMAP         hbm = NULL;
    PVOID           pvBits, pvIntelBits;
    STACKBMI32      bmi32;
    LPBITMAPINFO    lpbmi32;
    DWORD           dwClrUsed,nSize,nAlignmentSpace;
    PBITMAPINFOHEADER16 pbmi16;
    INT             nbmiSize,nBytesWritten;
    HANDLE          hfile=NULL,hsec=NULL;
    ULONG           RetVal,OriginalSelLimit,ulSelectorLimit,OriginalFlags;
    PARM16          Parm16;
    CHAR            pchTempFile[MAX_PATH];
    BOOL            bRet = FALSE;
    PVPVOID         vpBase16 = (PVPVOID) ((ULONG) vpbmi16 & 0xffff0000);

    if ((hdcMem = W32FindAndLockDibInfo((USHORT)HIWORD(vpbmi16))) != (HDC)NULL) {
        return hdcMem;
    }

    // First create a memory device context compatible to
    // the app's current screen
    if ((hdcMem = CreateCompatibleDC (NULL)) == NULL) {
        LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv CreateCompatibleDC failed\n"));
        return NULL;
    }

    // Copy bmi16 to bmi32. DIB.DRV only supports DIB_RGB_COLORS
    lpbmi32 = CopyBMI16ToBMI32(
                     vpbmi16,
                     (LPBITMAPINFO)&bmi32,
                     (WORD) DIB_RGB_COLORS);

    // this hack for Director 4.0 does essentially what WFW does
    // if this bitmap is 0 sized, just return an hDC for something simple
    if(bmi32.bmiHeader.biSizeImage == 0 &&
       (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_DIBDRVIMAGESIZEZERO)) {
        LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv:Zero biSizeImage, returning memory DC!\n"));
        return hdcMem;
    }

    try {

        // Copy the whole thing into a temp file. First get a temp file name
        if ((nSize = DPM_GetTempPath (MAX_PATH, pchTempFile)) == 0 ||
             nSize >= MAX_PATH)
            goto hdd_err;

        if (DPM_GetTempFileName (pchTempFile,
                             "DIB",
                             0,
                             pchTempFile) == 0)
            goto hdd_err;

        if ((hfile = DPM_CreateFile (pchTempFile,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_WRITE,
                                NULL,
                                CREATE_ALWAYS,
                                (FILE_ATTRIBUTE_NORMAL |
                                 FILE_ATTRIBUTE_TEMPORARY |
                                 FILE_FLAG_DELETE_ON_CLOSE),
                                NULL)) == INVALID_HANDLE_VALUE) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv CreateFile failed\n"));
            goto hdd_err;
        }

        // call back to get the size of the global object
        // associated with vpbmi16
        Parm16.WndProc.wParam = HIWORD(vpbmi16);

        CallBack16(RET_GETDIBSIZE,
                   &Parm16,
                   0,
                   (PVPVOID)&ulSelectorLimit);

        Parm16.WndProc.wParam = HIWORD(vpbmi16);

        if (ulSelectorLimit == 0xffffffff || ulSelectorLimit == 0) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv Invalid Selector %x\n",HIWORD(vpbmi16)));
            goto hdd_err;
        }

        ulSelectorLimit++;

        OriginalSelLimit = ulSelectorLimit;

        CallBack16(RET_GETDIBFLAGS,
                   &Parm16,
                   0,
                   (PVPVOID)&OriginalFlags);

        if (OriginalFlags == 0x4) { //GA_DGROUP
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv GA_DGROUP Not Handled\n"));
            goto hdd_err;
        }

        GETVDMPTR(vpBase16, ulSelectorLimit, pbmi16);

        nbmiSize = GetBMI16Size(vpbmi16, (WORD) DIB_RGB_COLORS, &dwClrUsed);

        // Under NT CreateDIBSection will fail if the offset to the bits
        // is not dword aligned. So we may have to add some space at the top
        // of the section to get the offset correctly aligned.

        nAlignmentSpace = (nbmiSize+LOWORD(vpbmi16)) % 4;

        if (nAlignmentSpace) {
            if (DPM_WriteFile (hfile,
                           pbmi16,
                           nAlignmentSpace,
                           &nBytesWritten,
                           NULL) == FALSE ||
                           nBytesWritten != (INT) nAlignmentSpace)
            goto hdd_err;
        }

        //
        // detect a clinical case of bitedit screwing around dib.drv
        //
        // code below is using dib macros declared in wdib.h
        // namely:
        //      DibNumColors - yields max number of colors in dib
        //      DibColors    - yields pointer to a dib color table
        //
        // Function W32CheckDibColorIndices checks to see if DIB color
        // table looks like a number (defined usually by biClrImportant)
        // of WORD indices in a sequential order (0, 1, 2, ...)
        // if this is the case, app is trying to use undocumented feature
        // of DIB.DRV that turns color matching off in this case.
        // Since we cannot enforce that rule, we approximate it by filling
        // color table by a number of known (and always same) entries
        // When blitting occurs, no color matching will be performed (when
        // both target and destination are of this very nature).
        // For no reason at all we fill color table with vga colors.
        // Sequential indices could have worked just as well.
        //
        // Modifications are made to memory pointed to by lpbmi32

        if (W32CheckDibColorIndices((LPBITMAPINFOHEADER)lpbmi32)) {
            BYTE i;
            INT nColors;
            LPBITMAPINFOHEADER lpbmi = (LPBITMAPINFOHEADER)lpbmi32;
            LPRGBQUAD lprgbq = (LPRGBQUAD)DibColors(lpbmi);

            nColors = DibNumColors(lpbmi);
            lpbmi->biClrImportant = nColors;

            switch (lpbmi->biBitCount) {
                case 1:
                    lprgbq[0] = rgbVGA[0];
                    lprgbq[1] = rgbVGA[0x0f];
                    break;

                case 4:
                    RtlCopyMemory(lprgbq, rgbVGA, sizeof(rgbVGA));
                    break;

                case 8:
                    RtlCopyMemory(lprgbq,     rgbVGA,   8*sizeof(RGBQUAD));
                    RtlCopyMemory(lprgbq+248, rgbVGA+8, 8*sizeof(RGBQUAD));
                    RtlCopyMemory(lprgbq+8,   rgb4,   2*sizeof(RGBQUAD));
                    RtlCopyMemory(lprgbq+246, rgb4+2, 2*sizeof(RGBQUAD));
                    for (i = 10; i < 246; ++i) {
                        lprgbq[i].rgbBlue = i;
                        lprgbq[i].rgbGreen= 0;
                        lprgbq[i].rgbRed  = 0;
                        lprgbq[i].rgbReserved = 0;
                    }
                    break;

                default: // this should never happen
                    break;
            }
        }

        if (DPM_WriteFile (hfile,
                       pbmi16,
                       ulSelectorLimit,
                       &nBytesWritten,
                       NULL) == FALSE || nBytesWritten != (INT) ulSelectorLimit)
            goto hdd_err;

        if (ulSelectorLimit < 64*1024) {
            if (DPM_SetFilePointer (hfile,
                                64*1024+nAlignmentSpace,
                                NULL,
                                FILE_BEGIN) == -1)
                goto hdd_err;

            if (DPM_SetEndOfFile (hfile) == FALSE)
                goto hdd_err;

            ulSelectorLimit = 64*1024;
        }

        if ((hsec = CreateFileMapping (hfile,
                                       NULL,
                                       PAGE_READWRITE | SEC_COMMIT,
                                       0,
                                       ulSelectorLimit+nAlignmentSpace,
                                       NULL)) == NULL) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv CreateFileMapping Failed\n"));
            goto hdd_err;
        }

        // Now create the DIB section
        if ((hbm = CreateDIBSection (hdcMem,
                                lpbmi32,
                                DIB_RGB_COLORS,
                                &pvBits,
                                hsec,
                                nAlignmentSpace + LOWORD(vpbmi16) + nbmiSize
                                )) == NULL) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv CreateDibSection Failed\n"));
            goto hdd_err;
        }

        FREEVDMPTR(pbmi16);

        if((pvBits = MapViewOfFile(hsec,
                         FILE_MAP_WRITE,
                         0,
                         0,
                         ulSelectorLimit+nAlignmentSpace)) == NULL) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv MapViewOfFile Failed\n"));
            goto hdd_err;
        }

        pvBits = (PVOID) ((ULONG)pvBits + nAlignmentSpace);

        SelectObject (hdcMem, hbm);

        GdiSetBatchLimit(1);

#ifndef i386
        if (!NT_SUCCESS(VdmAddVirtualMemory((ULONG)pvBits,
                                            (ULONG)ulSelectorLimit,
                                            (PULONG)&pvIntelBits))) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv VdmAddVirtualMemory failed\n"));
            goto hdd_err;
        }

        // On risc platforms, the intel base + the intel linear address
        // of the DIB section is not equal to the DIB section's process
        // address. This is because of the VdmAddVirtualMemory call
        // above. So here we zap the correct address into the flataddress
        // array.
        if (!VdmAddDescriptorMapping(HIWORD(vpbmi16),
                                    (USHORT) ((ulSelectorLimit+65535)/65536),
                                    (ULONG) pvIntelBits,
                                    (ULONG) pvBits)) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv VdmAddDescriptorMapping failed\n"));
            goto hdd_err;
        }

#else
        pvIntelBits = pvBits;
#endif

        // Finally set the selectors to the new DIB
        Parm16.WndProc.wParam = HIWORD(vpbmi16);
        Parm16.WndProc.lParam = (LONG)pvIntelBits;
        Parm16.WndProc.wMsg   = 0x10; // GA_NOCOMPACT
        Parm16.WndProc.hwnd   = 1;    // set so it's not randomly 0

        CallBack16(RET_SETDIBSEL,
                   &Parm16,
                   0,
                   (PVPVOID)&RetVal);

        if (!RetVal) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv Callback set_sel_for_dib failed\n"));
            goto hdd_err;
        }


        // Store all the relevant information so that DeleteDC could
        // free all the resources later.
        if (W32AddDibInfo(hdcMem,
                          hfile,
                          hsec,
                          nAlignmentSpace,
                          pvBits,
                          pvIntelBits,
                          hbm,
                          OriginalSelLimit,
                          (USHORT)OriginalFlags,
                          (USHORT)((HIWORD(vpbmi16)))) == FALSE)
            goto hdd_err;


        // Finally spit out the dump for debugging
        LOGDEBUG(6,("\t\tWOW::W32HandleDibDrv hdc=%04x nAlignment=%04x\n\t\tNewDib=%x OldDib=%04x:%04x DibSize=%x DibFlags=%x\n",hdcMem,nAlignmentSpace,pvBits,HIWORD(vpbmi16),LOWORD(vpbmi16),OriginalSelLimit,(USHORT)OriginalFlags));

        bRet = TRUE;
hdd_err:;
    }
    finally {
        if (!bRet) {

            if (hdcMem) {
                DeleteDC (hdcMem);
                hdcMem = NULL;
            }
            if (hfile)
                DPM_CloseHandle (hfile);

            if (hsec)
                CloseHandle (hsec);

            if (hbm)
                CloseHandle (hbm);
        }
    }
    return hdcMem;
}


BOOL W32AddDibInfo (
    HDC hdcMem,
    HANDLE hfile,
    HANDLE hsec,
    ULONG  nalignment,
    PVOID  newdib,
    PVOID  newIntelDib,
    HBITMAP hbm,
    ULONG dibsize,
    USHORT originaldibflags,
    USHORT originaldibsel
    )
{
    PDIBINFO pdi;

    if ((pdi = malloc_w (sizeof (DIBINFO))) == NULL)
        return FALSE;

    pdi->di_hdc     = hdcMem;
    pdi->di_hfile   = hfile;
    pdi->di_hsec    = hsec;
    pdi->di_nalignment    = nalignment;
    pdi->di_newdib  = newdib;
    pdi->di_newIntelDib = newIntelDib;
    pdi->di_hbm     = hbm;
    pdi->di_dibsize = dibsize;
    pdi->di_originaldibsel = originaldibsel;
    pdi->di_originaldibflags = originaldibflags;
    pdi->di_next    = pDibInfoHead;
    pdi->di_lockcount = 1;
    pDibInfoHead    = pdi;

    return TRUE;
}

BOOL W32FreeDibInfoHandle(PDIBINFO pdi, PDIBINFO pdiLast)
{
    if (W32RestoreOldDib (pdi) == 0) {
        LOGDEBUG(LOG_ALWAYS,("\nWOW::W32RestoreDib failed\n"));
        return FALSE;
    }
#ifndef i386
    VdmRemoveVirtualMemory((ULONG)pdi->di_newIntelDib);
#endif
    UnmapViewOfFile ((LPVOID)((ULONG)pdi->di_newdib - pdi->di_nalignment));

    DeleteObject (pdi->di_hbm);
    CloseHandle (pdi->di_hsec);
    DPM_CloseHandle (pdi->di_hfile);

    DeleteDC(pdi->di_hdc);
    W32FreeDibInfo (pdi, pdiLast);

    return TRUE;
}


BOOL    W32CheckAndFreeDibInfo (HDC hdc)
{
    PDIBINFO pdi = pDibInfoHead,pdiLast=NULL;

    while (pdi) {
        if (pdi->di_hdc == hdc){

            if (--pdi->di_lockcount) {
                //
                // This must be a releasedc within a nested call to createdc.
                // Just return, as this should be released again later.
                //
                LOGDEBUG(LOG_ALWAYS, ("\nW32CheckAndFreeDibInfo: lockcount!=0\n"));
                return TRUE;
            }

            return W32FreeDibInfoHandle(pdi, pdiLast);
        }
        pdiLast = pdi;
        pdi = pdi->di_next;
    }

    return FALSE;
}

VOID W32FreeDibInfo (PDIBINFO pdiCur, PDIBINFO pdiLast)
{
    if (pdiLast == NULL)
        pDibInfoHead = pdiCur->di_next;
    else
        pdiLast->di_next = pdiCur->di_next;

    free_w (pdiCur);
}

ULONG W32RestoreOldDib (PDIBINFO pdi)
{
    PARM16          Parm16;
    ULONG           retval;

    // callback to allocate memory and copy the dib from dib section

    Parm16.WndProc.wParam = pdi->di_originaldibsel;
    Parm16.WndProc.lParam = (LONG) (pdi->di_newdib);
    Parm16.WndProc.wMsg = pdi->di_originaldibflags;

    CallBack16(RET_FREEDIBSEL,
               &Parm16,
               0,
               (PVPVOID)&retval);

    return retval;
}


HDC W32FindAndLockDibInfo (USHORT sel)
{
    PDIBINFO pdi = pDibInfoHead;

    while (pdi) {

        if (pdi->di_originaldibsel == sel){
            pdi->di_lockcount++;
            return (pdi->di_hdc);

        }
        pdi = pdi->di_next;

    }
    return (HDC) NULL;
}

//
//  This function is called from krnl386 if GlobalReAlloc or GlobalFree is
//  trying to operate on memory which we suspect is dib-mapped. It finds
//  dib by original selector and restores it, thus allowing respective function
//  to succeede. Bitedit is the app that does globalrealloc before DeleteDC
//
//

ULONG FASTCALL WK32FindAndReleaseDib(PVDMFRAME pvf)
{
    USHORT sel;
    PFINDANDRELEASEDIB16 parg;
    PDIBINFO pdi;
    PDIBINFO pdiLast = NULL;

    // get the argument pointer, see wowkrnl.h
    GETARGPTR(pvf, sizeof(*parg), parg);

    // get selector from the handle
    sel = parg->hdib | (USHORT)0x01; // "convert to sel"

    // find this said sel in the dibinfo
    pdi = pDibInfoHead;
    while (pdi) {
        if (pdi->di_originaldibsel == sel) {

            // found ! this is what we are releasing or reallocating
            LOGDEBUG(LOG_ALWAYS, ("\nWOW: In FindAndReleaseDIB function %d\n", (DWORD)parg->wFunId));

            // see if we need to nuke...
            if (--pdi->di_lockcount) {
                // the problem with lock count...
                LOGDEBUG(LOG_ALWAYS, ("\nWOW: FindAndReleaseDib failed (lock count!)\n"));
                return FALSE;
            }

            return W32FreeDibInfoHandle(pdi, pdiLast);
        }

        pdiLast = pdi;
        pdi = pdi->di_next;
    }

    return FALSE;
}


BOOL W32CheckDibColorIndices(LPBITMAPINFOHEADER lpbmi)
{
    WORD i, nColors;
    LPWORD lpw = (LPWORD)DibColors(lpbmi);

    nColors = DibNumColors(lpbmi);
    if (lpbmi->biClrImportant) {
        nColors = min(nColors, (WORD)lpbmi->biClrImportant);
    }

    for (i = 0; i < nColors; ++i) {
        if (*lpw++ != i) {
            return FALSE;
        }
    }

    LOGDEBUG(LOG_ALWAYS, ("\nUndocumented Dib.Drv behaviour used\n"));

    return TRUE;
}

/******************************Public*Routine******************************\
* DIBSection specific calls
*
* History:
*  04-May-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG cjBitmapBitsSize(CONST BITMAPINFO *pbmi)
{
// Check for PM-style DIB

    if (pbmi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER))
    {
        LPBITMAPCOREINFO pbmci;
        pbmci = (LPBITMAPCOREINFO)pbmi;
        return(CJSCAN(pbmci->bmciHeader.bcWidth,pbmci->bmciHeader.bcPlanes,
                      pbmci->bmciHeader.bcBitCount) *
                      pbmci->bmciHeader.bcHeight);
    }

// not a core header

    if ((pbmi->bmiHeader.biCompression == BI_RGB) ||
        (pbmi->bmiHeader.biCompression == BI_BITFIELDS))
    {
        return(CJSCAN(pbmi->bmiHeader.biWidth,pbmi->bmiHeader.biPlanes,
                      pbmi->bmiHeader.biBitCount) *
               ABS(pbmi->bmiHeader.biHeight));
    }
    else
    {
        return(pbmi->bmiHeader.biSizeImage);
    }
}

ULONG FASTCALL WG32CreateDIBSection(PVDMFRAME pFrame)
{
    ULONG              ul = 0;
    STACKBMI32         bmi32;
    LPBITMAPINFO       lpbmi32;
    HBITMAP            hbm32;
    PVOID              pv16, pvBits, pvIntelBits;
    PVPVOID            vpbmi16;
    PVOID              pvBits32;
    DWORD              dwArg16;

    register PCREATEDIBSECTION16 parg16;

    GETARGPTR(pFrame, sizeof(CREATEDIBSECTION16), parg16);

    // this is performance hack so we don't generate extra code
    dwArg16 = FETCHDWORD(parg16->f4); // do it once here
    pv16 = (PVOID)GetPModeVDMPointer(dwArg16, sizeof(DWORD)); // aligned here!

    WOW32ASSERTMSG(((parg16->f5 == 0) && (parg16->f6 == 0)),
                   ("WOW:WG32CreateDIBSection, hSection/dwOffset non-null\n"));

    vpbmi16 = (PVPVOID)FETCHDWORD(parg16->f2);
    lpbmi32 = CopyBMI16ToBMI32(vpbmi16,
                               (LPBITMAPINFO)&bmi32,
                               FETCHWORD(parg16->f3));

    hbm32 = CreateDIBSection(HDC32(parg16->f1),
                             lpbmi32,
                             WORD32(parg16->f3),
                             &pvBits,
                             NULL,
                             0);

    if (hbm32 != 0)
    {
        PARM16          Parm16;
        PDIBSECTIONINFO pdi;
        ULONG           ulSelectorLimit;

        ulSelectorLimit = (ULONG)cjBitmapBitsSize(lpbmi32);
#ifndef i386
        if (!NT_SUCCESS(VdmAddVirtualMemory((ULONG)pvBits,
                                            ulSelectorLimit,
                                            (PULONG)&pvIntelBits))) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::WG32CreateDibSection VdmAddVirtualMemory failed\n"));
            goto cds_err;
        }

#else
        pvIntelBits = pvBits;
#endif

        // Create a selector array for the bits backed by pvIntelBits

        Parm16.WndProc.wParam = (WORD)-1;           // -1 => allocate selectors
        Parm16.WndProc.lParam = (LONG) pvIntelBits; // backing pointer
        Parm16.WndProc.wMsg = 0x10;                 // GA_NOCOMPACT
        Parm16.WndProc.hwnd = (WORD)((ulSelectorLimit+65535)/65536);// selector count

        CallBack16(RET_SETDIBSEL,
                   &Parm16,
                   0,
                   (PVPVOID)&pvBits32);

        // 16:16 pointer is still valid as call above makes no difference
        if (pv16 != NULL) {
            *(UNALIGNED PVOID*)pv16 = pvBits32;
        }

        if (pvBits32 == NULL) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::WG32CreateDibSection, Callback set_sel_for_dib failed\n"));
            goto cds_err;
        }

#ifndef i386
        // okay, that was successful - map the descriptors properly

        if (!VdmAddDescriptorMapping(HIWORD(pvBits32),
                                    (USHORT) ((ulSelectorLimit+65535)/65536),
                                    (ULONG) pvIntelBits,
                                    (ULONG) pvBits)) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::WG32CreateDibSection VdmAddDescriptorMapping failed\n"));
            goto cds_err;
        }
#endif

        LOGDEBUG(LOG_ALWAYS, ("\nWOW:CreateDIBSection: [16:16 %x] [Intel %x] [Flat %x]\n",
                             pvBits32, pvIntelBits, pvBits));

        ul = GETHBITMAP16(hbm32);

        // Add it to the list used for cleanup at DeleteObject time.

        if ((pdi = malloc_w (sizeof (DIBSECTIONINFO))) != NULL) {
         