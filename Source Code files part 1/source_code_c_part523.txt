ata;
    LPBYTE pBuffer = (LPBYTE)pdwState;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_APPPOOL_STATE,    // server state
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = m_pIABase->GetData(
             hObjHandle,
             m_wszPath,
             &mdrMDData,
             &dwBufferSize
             );
    
    if( hr == MD_ERROR_DATA_NOT_FOUND )
    {
        //
        // If the data is not there, but the path exists, then the
        // most likely cause is that the app pool is not running and
        // this object was just created.
        //
        // Since MD_APPPOOL_STATE would be set as stopped if the
        // app pool were running when the key is added, we'll just 
        // say that it's stopped. 
        // 
        *pdwState = MD_APPPOOL_STATE_STOPPED;
        hr = S_FALSE;
    }
    else
    {
        if(FAILED(hr))
        {
            goto error;
        }
    }

error:

    return(hr);
}

HRESULT
CAppPoolMethod::IISGetAppPoolWin32Error(
    METADATA_HANDLE hObjHandle,
    HRESULT*        phrError)
{
    DBG_ASSERT(phrError != NULL);

    long    lWin32Error = 0;
    DWORD   dwLen;

    METADATA_RECORD mr = {
        MD_WIN32_ERROR, 
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        sizeof(DWORD),
        (unsigned char*)&lWin32Error,
        0
        };  
    
    HRESULT hr = m_pIABase->GetData(
        hObjHandle,
        m_wszPath,
        &mr,
        &dwLen);
    if(hr == MD_ERROR_DATA_NOT_FOUND)
    {
        hr = S_FALSE;
    }

    //
    // Set out param
    //
    *phrError = HRESULT_FROM_WIN32(lWin32Error);

    return hr;
}

HRESULT CAppPoolMethod::ExecMethod(
    DWORD dwControl)
{
    DWORD dwTargetState;
    DWORD dwState = 0;
    DWORD dwSleepTotal = 0L;
    HRESULT hr       = S_OK;
    HRESULT hrMbNode = S_OK;
    METADATA_HANDLE  hKey = 0;

    switch(dwControl)
    {
    case MD_APPPOOL_COMMAND_STOP:
        dwTargetState = MD_APPPOOL_STATE_STOPPED;
        break;

    case MD_APPPOOL_COMMAND_START:
        dwTargetState = MD_APPPOOL_STATE_STARTED;
        break;

    default:
        hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        if(FAILED(hr))
        {
            goto error;
        }
    }

    hr = IISGetAppPoolState(METADATA_MASTER_ROOT_HANDLE, &dwState);
    if(FAILED(hr))
    {
        goto error;
    }
 
    if (dwState == dwTargetState) 
    {
        return (hr);
    }

    //
    // Write the command to the metabase
    //
    hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        m_wszPath,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        DEFAULT_TIMEOUT_VALUE,         // 30 seconds
        &hKey);
    if(FAILED(hr))
    {
        goto error;
    }

    hr = IISSetDword(hKey, MD_WIN32_ERROR, 0);
    if(FAILED(hr))
    {
        m_pIABase->CloseKey(hKey);
        goto error;
    }
    hr = IISSetDword(hKey, MD_APPPOOL_COMMAND, dwControl);
    if(FAILED(hr))
    {
        m_pIABase->CloseKey(hKey);
        goto error;
    }
    m_pIABase->CloseKey(hKey);

    while (dwSleepTotal < MAX_SLEEP_INST) 
    {
        hr       = IISGetAppPoolState(METADATA_MASTER_ROOT_HANDLE, &dwState);
        if(FAILED(hr))
        {
            goto error;
        }
        hrMbNode = 0;
        hr       = IISGetAppPoolWin32Error(METADATA_MASTER_ROOT_HANDLE, &hrMbNode);
        if(FAILED(hr))
        {
            goto error;
        }

        //
        // Done one way or another
        //
        if (dwState == dwTargetState)
        {
            break;
        }
        
        //
        // If we haven't check the Win32 Error from the metabase
        //
        if(FAILED(hrMbNode))
        {
            hr = hrMbNode;
            goto error;
        }

        //
        // Still pending...
        //
        ::Sleep(SLEEP_INTERVAL);

        dwSleepTotal += SLEEP_INTERVAL;
    }

    if (dwSleepTotal >= MAX_SLEEP_INST)
    {
        //
        // Timed out.  If there is a real error in the metabase
        // use it, otherwise use a generic timeout error
        //

        hr = HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT);
    }

error :

    return (hr);
}

HRESULT
CAppPoolMethod::IISSetDword(
    METADATA_HANDLE hKey,
    DWORD dwPropId,
    DWORD dwValue
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)&dwValue;

    if (MD_WIN32_ERROR == dwPropId) {
        MD_SET_DATA_RECORD(&mdrMDData,
                           dwPropId,
                           METADATA_VOLATILE,
                           IIS_MD_UT_SERVER,
                           DWORD_METADATA,
                           dwBufferSize,
                           pBuffer);

    }
    else {
        MD_SET_DATA_RECORD(&mdrMDData,
                           dwPropId,
                           METADATA_NO_ATTRIBUTES,
                           IIS_MD_UT_SERVER,
                           DWORD_METADATA,
                           dwBufferSize,
                           pBuffer);
    }

    hr = m_pIABase->SetData(
             hKey,
             L"",
             &mdrMDData
             );
    if(FAILED(hr))
    {
        goto error;
    }

error:

    return(hr);

}

//
// CWebAppMethod
//

CWebAppMethod::CWebAppMethod()
{ 
    HRESULT hr = CoCreateInstance(
        CLSID_WamAdmin,
        NULL,
        CLSCTX_ALL,
        IID_IIISApplicationAdmin,
        (void**)&m_pAppAdmin
        );

    hr = CoCreateInstance(
        CLSID_WamAdmin,
        NULL,
        CLSCTX_ALL,
        IID_IWamAdmin2,
        (void**)&m_pWamAdmin2
        );

    THROW_ON_ERROR(hr);
}

CWebAppMethod::~CWebAppMethod()
{
    if(m_pAppAdmin)
        m_pAppAdmin->Release();

    if(m_pWamAdmin2)
        m_pWamAdmin2->Release();
}


HRESULT CWebAppMethod::AppCreate( 
    LPCWSTR szMetaBasePath, 
    bool bInProcFlag
    )
{
    HRESULT hr;
    LPWSTR szActualName  = NULL;
    BOOL bActualCreation = FALSE;

    hr = m_pAppAdmin->CreateApplication(
        szMetaBasePath,
        bInProcFlag ? 0 : 1,  // 0 for InProc, 1 for Out of Proc
        szActualName,
        bActualCreation   // Don't create - DefaultAppPool should already be there
        );

    return hr;
}

HRESULT CWebAppMethod::AppCreate2( 
    LPCWSTR szMetaBasePath, 
    long lAppMode
    )
{
    HRESULT hr;
    LPWSTR szActualName = NULL;
    BOOL bActualCreation = FALSE;

    hr = m_pAppAdmin->CreateApplication(
        szMetaBasePath,
        lAppMode,
        szActualName,
        bActualCreation   // Don't create - DefaultAppPool should already be there
        );

    return hr;
}

HRESULT CWebAppMethod::AppCreate3( 
    LPCWSTR szMetaBasePath, 
    long lAppMode,
    LPCWSTR szAppPoolName,
    bool bCreatePool
    )
{
    HRESULT hr;
    LPWSTR szActualName;
    BOOL bActualCreation = FALSE;

    if (szAppPoolName) {
        szActualName = (LPWSTR)szAppPoolName;
    }
    else {
        szActualName = NULL;
    }

    if (bCreatePool != true) {
        bActualCreation = FALSE;
    }
    else {
        bActualCreation = TRUE;
    }

    hr = m_pAppAdmin->CreateApplication(
        szMetaBasePath,
        lAppMode,
        szActualName,
        bActualCreation   // Don't create - DefaultAppPool should already be there
        );

    return hr;
}

HRESULT CWebAppMethod::AppDelete( 
    LPCWSTR szMetaBasePath, 
    bool bRecursive
    )
{
    HRESULT hr;
    hr = m_pAppAdmin->DeleteApplication(
        szMetaBasePath, 
        bRecursive ? TRUE : FALSE  // Don't mix bool w/ BOOL
        );

    return hr;
}

HRESULT CWebAppMethod::AppUnLoad( 
    LPCWSTR szMetaBasePath, 
    bool bRecursive
    )
{
    HRESULT hr;
    hr = m_pWamAdmin2->AppUnLoad(
        szMetaBasePath, 
        bRecursive ? TRUE : FALSE  // Don't mix bool w/ BOOL
        );

    return hr;
}

HRESULT CWebAppMethod::AppDisable( 
    LPCWSTR szMetaBasePath, 
    bool bRecursive
    )
{
    HRESULT hr;
    hr = m_pWamAdmin2->AppDeleteRecoverable(
        szMetaBasePath, 
        bRecursive ? TRUE : FALSE  // Don't mix bool w/ BOOL
        );

    return hr;
}

HRESULT CWebAppMethod::AppEnable( 
    LPCWSTR szMetaBasePath, 
    bool bRecursive
    )
{
    HRESULT hr;
    hr = m_pWamAdmin2->AppRecover(
        szMetaBasePath, 
        bRecursive ? TRUE : FALSE  // Don't mix bool w/ BOOL
        );

    return hr;
}

HRESULT CWebAppMethod::AppGetStatus( 
    LPCWSTR szMetaBasePath, 
    DWORD* pdwStatus
    )
{
    HRESULT hr;
    hr = m_pWamAdmin2->AppGetStatus(
        szMetaBasePath, 
        pdwStatus);

    return hr;
}

HRESULT CWebAppMethod::AspAppRestart(
    LPCWSTR a_szMetaBasePath
    )
{
    HRESULT         hr = S_OK;
    DWORD           dwState = 0;
    METADATA_HANDLE t_hKey = NULL;
    CMetabase       t_mb;
    
    // open key
    t_hKey = t_mb.OpenKey(a_szMetaBasePath, true);

    // check app
    hr = t_mb.WebAppCheck(t_hKey);
    THROW_ON_ERROR(hr);

    // get state
    hr = t_mb.WebAppGetStatus(t_hKey, &dwState);
    THROW_ON_ERROR(hr);

    // change state value
    dwState = dwState ? 0 : 1;
    hr = t_mb.WebAppSetStatus(t_hKey, dwState);
    THROW_ON_ERROR(hr);

    // re-set back state value
    dwState = dwState ? 0 : 1;
    hr = t_mb.WebAppSetStatus(t_hKey, dwState);
    THROW_ON_ERROR(hr);

    t_mb.CloseKey(t_hKey);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\adminacl.cpp ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    adminacl.cpp

Abstract:

    Contains implementation of CAdminACL

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#define REF
#define BUFFER_SIZE 512

#include "iisprov.h"
#include "adminacl.h"
#include <adserr.h>

CAdminACL::CAdminACL()
{
    m_pADs  = NULL;
    m_pSD   = NULL;
    m_pDACL = NULL;
    bIsInherit = FALSE;
}

CAdminACL::~CAdminACL()
{
    CloseSD();
}

void CAdminACL::CloseSD()
{
    if(m_pDACL)
    {
        m_pDACL->Release();
        m_pDACL = NULL;
    }

    if(m_pSD)
    {
        m_pSD->Release();
        m_pSD = NULL;
    }

    if(m_pADs)
    {
        m_pADs->Release();
        m_pADs = NULL;
    }
}

HRESULT CAdminACL::GetObjectAsync(
    IWbemClassObject* pObj,
    ParsedObjectPath* pParsedObject,
    WMI_CLASS*        pWMIClass)
{
    DBG_ASSERT(m_pSD);
    DBG_ASSERT(m_pDACL);

    HRESULT hr = S_OK;

    if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL )
    {
        hr = PopulateWmiAdminACL(pObj);
    }
    else if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE )
    {
        _bstr_t bstrTrustee;
        GetTrustee(pObj, pParsedObject, bstrTrustee); 
        CACEEnumOperation_FindAndReturn op(this, pObj, bstrTrustee, bIsInherit);
        hr = EnumACEsAndOp(REF op);
    }
    else
    {
        DBG_ASSERT(false && "Only valid on AdminACL and AdminACE classes");
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CAdminACL::EnumerateACEsAndIndicate(
    BSTR             i_bstrNameValue,
    CWbemServices&   i_refNamespace,
    IWbemObjectSink& i_refWbemObjectSink)
{
    DBG_ASSERT(m_pSD);
    DBG_ASSERT(m_pDACL);

    CACEEnumOperation_IndicateAll op(
        i_bstrNameValue,
        REF i_refNamespace, 
        REF i_refWbemObjectSink,
        bIsInherit);
    return EnumACEsAndOp(REF op);
}

HRESULT CAdminACL::DeleteObjectAsync(
    ParsedObjectPath* pParsedObject)
{
    HRESULT hr = S_OK;
    _bstr_t bstrTrustee;

    //
    // get the trustee from key
    //
    GetTrustee(NULL, pParsedObject, bstrTrustee); 

    //
    // remove the ACE
    //
    DBG_ASSERT(m_pDACL);
    CACEEnumOperation_FindAndRemove op(this, bstrTrustee);
    hr = EnumACEsAndOp(REF op);

    //
    // set the modified AdminACL back into the metabase
    //
    if(SUCCEEDED(hr))
        hr = SetSD();

    return hr;
}

HRESULT CAdminACL::PutObjectAsync(
    IWbemClassObject* pObj,
    ParsedObjectPath* pParsedObject,
    WMI_CLASS*        pWMIClass)
{
    DBG_ASSERT(m_pSD);
    DBG_ASSERT(m_pDACL);

    HRESULT hr = S_OK;

    if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL )
    {
        hr = SetADSIAdminACL(pObj);
    }
    else if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE )
    {
        _bstr_t bstrTrustee;
        GetTrustee(NULL, pParsedObject, bstrTrustee);

        CACEEnumOperation_FindAndUpdate op(this, pObj, bstrTrustee);
        hr = EnumACEsAndOp(REF op);
        if(hr == WBEM_E_NOT_FOUND)
        {
            hr = AddACE(pObj, bstrTrustee);
        }
    }
    else
    {
        DBG_ASSERT(false && "Only valid on AdminACL and AdminACE");
        hr = E_INVALIDARG;
    }

    // set the modified AdminACL back into the metabase
    if(SUCCEEDED(hr))
        hr = SetSD();

    return hr;
}

HRESULT CAdminACL::PopulateWmiAdminACL(
    IWbemClassObject* pObj
    )
{
    VARIANT     vt;
    HRESULT     hr = S_OK;

    VARIANT vtTrue;
    vtTrue.boolVal = VARIANT_TRUE;
    vtTrue.vt      = VT_BOOL;

    // Owner
    vt.vt = VT_BSTR;
    hr = m_pSD->get_Owner(&vt.bstrVal);
    if(SUCCEEDED(hr))
    {
        hr = pObj->Put(L"Owner", 0, &vt, 0);
        VariantClear(&vt);
    }

    if(bIsInherit && SUCCEEDED(hr))
    {
        hr = CUtils::SetPropertyQualifiers(
            pObj, L"Owner", &g_wszIsInherit, &vtTrue, 1);
    }

    // Group
    vt.vt = VT_BSTR;
    if(SUCCEEDED(hr))
       hr = m_pSD->get_Group(&vt.bstrVal);
    if(SUCCEEDED(hr))
    {
        hr = pObj->Put(L"Group", 0, &vt, 0);
        VariantClear(&vt);
    }
    
    if(bIsInherit && SUCCEEDED(hr))
    {
        hr = CUtils::SetPropertyQualifiers(
            pObj, L"Group", &g_wszIsInherit, &vtTrue, 1);
    }

    // ControlFlags
    vt.vt = VT_I4;
    if(SUCCEEDED(hr))
        hr = m_pSD->get_Control(&vt.lVal);
    if(SUCCEEDED(hr))
    {
        hr = pObj->Put(L"ControlFlags", 0, &vt, 0);
        VariantClear(&vt);
    }

    if(bIsInherit && SUCCEEDED(hr))
    {
        hr = CUtils::SetPropertyQualifiers(
            pObj, L"ControlFlags", &g_wszIsInherit, &vtTrue, 1);
    }

    return hr;
}

HRESULT CAdminACL::SetADSIAdminACL(
    IWbemClassObject* pObj
    )
{
    VARIANT     vt;
    HRESULT     hr;

    // Owner
    hr = pObj->Get(L"Owner", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_BSTR)
        hr = m_pSD->put_Owner(vt.bstrVal);
    VariantClear(&vt);

    // Owner
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"Group", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_BSTR)
        hr = m_pSD->put_Group(vt.bstrVal);
    VariantClear(&vt);

    // ControlFlags
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"ControlFlags", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = m_pSD->put_Control(vt.lVal); 
    VariantClear(&vt);

    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
    }
    return hr;
}

HRESULT CAdminACL::OpenSD(
    LPCWSTR         wszMbPath,
    IMSAdminBase2*  pAdminBase)
{
    DBG_ASSERT(wszMbPath);

    CComVariant svar;
    METADATA_HANDLE hObjHandle = NULL;
    HRESULT     hr    = S_OK;
    DWORD dwBufferSize = 0;
    METADATA_RECORD mdrMDData;
    BYTE pBuffer[BUFFER_SIZE];

    // close SD interface first
    CloseSD();

    CComBSTR sbstrAdsPath;
    hr = GetAdsPath(wszMbPath, &sbstrAdsPath);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }

    // get m_pADs
    hr = ADsGetObject(
         sbstrAdsPath,
         IID_IADs,
         (void**)&m_pADs
         );
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }
     
    // get m_pSD
    hr = m_pADs->Get(L"AdminACL",&svar);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        if(hr == E_ADS_PROPERTY_NOT_SUPPORTED)
        {
            //
            // Do this, so WMI does not fail query operations.
            //
            hr = WBEM_E_NOT_FOUND;
        }
        return hr;
    }
    
    hr = V_DISPATCH(&svar)->QueryInterface(
        IID_IADsSecurityDescriptor,
        (void**)&m_pSD
        );
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }

    // get m_pDACL
    CComPtr<IDispatch> spDisp;
    hr = m_pSD->get_DiscretionaryAcl(&spDisp);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }

    hr = spDisp->QueryInterface(
       IID_IADsAccessControlList, 
       (void**)&m_pDACL
       );
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }
    
    // set bIsInherit

    hr = pAdminBase->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            wszMbPath,
            METADATA_PERMISSION_READ,
            DEFAULT_TIMEOUT_VALUE,
            &hObjHandle
            );
    if(FAILED(hr))
        return hr;

    MD_SET_DATA_RECORD(&mdrMDData,
                   MD_ADMIN_ACL,  // ID for "AdminAcl"
                   METADATA_INHERIT | METADATA_ISINHERITED,
                   ALL_METADATA,
                   ALL_METADATA,
                   BUFFER_SIZE,
                   pBuffer);

    hr = pAdminBase->GetData(
            hObjHandle,
            L"",
            &mdrMDData,
            &dwBufferSize
            );

    hr = S_OK;

    bIsInherit = mdrMDData.dwMDAttributes & METADATA_ISINHERITED;
    
    if (hObjHandle && pAdminBase) {
        pAdminBase->CloseKey(hObjHandle);
    }

    return hr;
}


HRESULT CAdminACL::SetSD()
{
    VARIANT    var;
    HRESULT    hr    = S_OK;
    IDispatch* pDisp = NULL;

    // put m_pDACL
    hr = m_pDACL->QueryInterface(
       IID_IDispatch, 
       (void**)&pDisp
       );
    if(FAILED(hr))
        return hr;

    hr = m_pSD->put_DiscretionaryAcl(pDisp);
    pDisp->Release();
    if(FAILED(hr))
       return hr;

    //
    // put AdminACL
    //
    hr = m_pSD->QueryInterface(
        IID_IDispatch,
        (void**)&pDisp
        );
    if(FAILED(hr))
       return hr;

    VariantInit(&var);

    var.vt = VT_DISPATCH;
    var.pdispVal = pDisp;
    hr = m_pADs->Put(L"AdminACL",var);  // pDisp will be released by this call Put().
    if(FAILED(hr))
       return hr;

    //
    // Commit the change to the active directory
    //
    hr = m_pADs->SetInfo();

    return hr;
}

HRESULT CAdminACL::GetAdsPath(
    LPCWSTR     i_wszMbPath,
    BSTR*       o_pbstrAdsPath)
{
    DBG_ASSERT(i_wszMbPath);
    DBG_ASSERT(o_pbstrAdsPath);
    DBG_ASSERT(*o_pbstrAdsPath == NULL);

    CComBSTR sbstr(L"IIS://LocalHost");
    if(sbstr.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // trim the first three characters "/LM"
    //
    sbstr += (i_wszMbPath+3);
    if(sbstr.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // Set out params if everything succeeds
    //
    *o_pbstrAdsPath = sbstr.Detach();
    return S_OK;
}

HRESULT CAdminACL::EnumACEsAndOp(
    CACEEnumOperation_Base&  refOp)
/*++

Synopsis: 
    This enumerates all the aces for the current acl.

Arguments: [refOp] - Implements Do, and Done.  It is okay if Do throws exceptions.
                     This function will cleanup correctly.
           
Return Value: 

--*/
{
    HRESULT                         hr = S_OK;
    CComVariant                     var;
    CComPtr<IEnumVARIANT>           spEnum;
    ULONG                           lFetch;
    CComPtr<IADsAccessControlEntry> spACE;

    hr = GetACEEnum(&spEnum);
    if ( FAILED(hr) )
        return hr;

    //
    // Enumerate ACEs
    //
    hr = spEnum->Next( 1, &var, &lFetch );
    while( hr == S_OK )
    {
        if (lFetch == 1)
        {
            if (VT_DISPATCH != V_VT(&var))
            {
                hr = E_UNEXPECTED;
                break;
            }

            //
            // Get the individual ACE
            //
            hr = V_DISPATCH(&var)->QueryInterface(
                IID_IADsAccessControlEntry, 
                (void**)&spACE);

            if ( SUCCEEDED(hr) )
            {
                hr = refOp.Do(spACE);
                if(FAILED(hr))
                {
                    DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
                    return hr;
                }
                if(refOp.Done() == CACEEnumOperation_Base::eDONE_YES)
                {
                    break;
                }
                spACE = NULL;
           }
        }
        var.Clear();

        hr = spEnum->Next( 1, &var, &lFetch );
        if(hr == S_FALSE && refOp.Done() == CACEEnumOperation_Base::eDONE_NO)
        {
            hr = WBEM_E_NOT_FOUND;
            DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
            return hr;
        }
    }

    return hr;
}

void CAdminACL::GetTrustee(
    IWbemClassObject* pObj,
    ParsedObjectPath* pPath,    
    _bstr_t&          bstrTrustee 
    )
/*++

Synopsis: 
    parse ParsedObjectPath to get the Trustee key

Arguments: [pObj] - 
           [pPath] - 
           [bstrTrustee] - 
           
--*/
{
    KeyRef* pkr;
    WCHAR*  pszKey = L"Trustee";

    VARIANT vtTrue;
    vtTrue.boolVal = VARIANT_TRUE;
    vtTrue.vt      = VT_BOOL;

    pkr = CUtils::GetKey(pPath, pszKey);
    if(pkr->m_vValue.vt == VT_BSTR && pkr->m_vValue.bstrVal != NULL)
    {
        bstrTrustee = pkr->m_vValue;
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_OBJECT);
    }

    if (pObj)
    {
        _bstr_t bstr = pkr->m_pName;
        HRESULT hr = pObj->Put(bstr, 0, &pkr->m_vValue, 0);
        THROW_ON_ERROR(hr);

        if(bIsInherit && SUCCEEDED(hr))
        {
            hr = CUtils::SetPropertyQualifiers(
                pObj, L"Trustee", &g_wszIsInherit, &vtTrue, 1);

            THROW_ON_ERROR(hr);
        }
    }
}


HRESULT CAdminACL::GetACEEnum(
    IEnumVARIANT** pEnum)
{
    HRESULT hr = S_OK;
    LPUNKNOWN  pUnk = NULL;

    DBG_ASSERT(pEnum);

    if(*pEnum)
    {
        (*pEnum)->Release();
    }

    hr = m_pDACL->get__NewEnum( &pUnk );
    if ( SUCCEEDED(hr) )
    {
        hr = pUnk->QueryInterface( IID_IEnumVARIANT, (void**) pEnum );
    }

    return hr;
}

HRESULT CAdminACL::AddACE(
    IWbemClassObject* pObj,
    _bstr_t& bstrTrustee
    )
/*++

Synopsis: 
    Add an ACE.

Arguments: [pObj] - 
           [bstrTrustee] - 
           
Return Value: 

--*/
{
    HRESULT hr = m_pDACL->put_AclRevision(ADS_SD_REVISION_DS);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }

    // create a ACE
    IADsAccessControlEntry* pACE = NULL; 
    hr = NewACE(
        pObj,
        bstrTrustee,
        &pACE);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }

    // add the ACE
    IDispatch* pDisp = NULL;
    hr = pACE->QueryInterface(IID_IDispatch,(void**)&pDisp);
    if(SUCCEEDED(hr))
    {
        hr = m_pDACL->AddAce(pDisp);
        pDisp->Release();
    }

    pACE->Release();

    return hr;
}

HRESULT CAdminACL::NewACE(
    IWbemClassObject* pObj,
    _bstr_t& bstrTrustee,
    IADsAccessControlEntry** ppACE
    )
/*++

Synopsis: 
    function to create an ACE

Arguments: [pObj] - 
           [bstrTrustee] - 
           [ppACE] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(ppACE);

    HRESULT hr = CoCreateInstance(
        CLSID_AccessControlEntry,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IADsAccessControlEntry,
        (void**)ppACE);

    //
    // Trustee
    //
    if(SUCCEEDED(hr))
        hr = (*ppACE)->put_Trustee(bstrTrustee); 

    if(SUCCEEDED(hr))
        hr = SetDataOfACE(pObj, *ppACE);

    return hr;
}


HRESULT CAdminACL::SetDataOfACE(
    IWbemClassObject* pObj,
    IADsAccessControlEntry* pACE
    )
{
    HRESULT     hr;
    CComVariant vt;

    //
    // AccessMask
    //
    hr = pObj->Get(L"AccessMask", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = pACE->put_AccessMask(vt.lVal); 
    vt.Clear();

    //
    // AceType
    //
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"AceType", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = pACE->put_AceType(vt.lVal); 
    vt.Clear();

    //
    // AceFlags
    //
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"AceFlags", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = pACE->put_AceFlags(vt.lVal); 
    vt.Clear();

    //
    // Flags
    //
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"Flags", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = pACE->put_Flags(vt.lVal); 
    vt.Clear();

    //
    // ObjectType
    //
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"ObjectType", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_BSTR)
        hr = pACE->put_ObjectType(vt.bstrVal); 
    vt.Clear();

    //
    // InheritedObjectType
    //
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"InheritedObjectType", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_BSTR)
        hr = pACE->put_InheritedObjectType(vt.bstrVal); 
    vt.Clear();

    return hr;
}

//
// CACEEnumOperation_Base
//

HRESULT CACEEnumOperation_Base::PopulateWmiACE(
    IWbemClassObject* pObj,
    IADsAccessControlEntry* pACE,
    BOOL bIsInherit
    )
{
    _variant_t vt;
    BSTR bstr;
    long lVal;
    HRESULT hr;

    VARIANT vtTrue;
    vtTrue.boolVal = VARIANT_TRUE;
    vtTrue.vt      = VT_BOOL;

    // AccessMask
    hr = pACE->get_AccessMask(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"AccessMask", 0, &vt, 0);

        if(bIsInherit && SUCCEEDED(hr))
        {
            hr = CUtils::SetPropertyQualifiers(
                pObj, L"AccessMask", &g_wszIsInherit, &vtTrue, 1);
        }

    }

    // AceType
    if(SUCCEEDED(hr))
       hr = pACE->get_AceType(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"AceType", 0, &vt, 0);

        if(bIsInherit && SUCCEEDED(hr))
        {
            hr = CUtils::SetPropertyQualifiers(
                pObj, L"AceType", &g_wszIsInherit, &vtTrue, 1);
        }
    }
    
    // AceFlags
    if(SUCCEEDED(hr))
       hr = pACE->get_AceFlags(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"AceFlags", 0, &vt, 0);
    
        if(bIsInherit && SUCCEEDED(hr))
        {
            hr = CUtils::SetPropertyQualifiers(
                pObj, L"AceFlags", &g_wszIsInherit, &vtTrue, 1);
        }
    }

    // Flags
    if(SUCCEEDED(hr))
       hr = pACE->get_Flags(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"Flags", 0, &vt, 0);

        if(bIsInherit && SUCCEEDED(hr))
        {
            hr = CUtils::SetPropertyQualifiers(
                pObj, L"Flags", &g_wszIsInherit, &vtTrue, 1);
        }
    }
    
    // ObjectType
    if(SUCCEEDED(hr))
       hr = pACE->get_ObjectType(&bstr);
    if(SUCCEEDED(hr))
    {
        vt = bstr;
        hr = pObj->Put(L"ObjectType", 0, &vt, 0);
        
        if(bIsInherit && SUCCEEDED(hr))
        {
            hr = CUtils::SetPropertyQualifiers(
                pObj, L"ObjectType", &g_wszIsInherit, &vtTrue, 1);
        }

        SysFreeString(bstr);
    }

    // InheritedObjectType
    if(SUCCEEDED(hr))
       hr = pACE->get_InheritedObjectType(&bstr);
    if(SUCCEEDED(hr))
    {
        vt = bstr;
        hr = pObj->Put(L"InheritedObjectType", 0, &vt, 0);

        if(bIsInherit && SUCCEEDED(hr))
        {
            hr = CUtils::SetPropertyQualifiers(
                pObj, L"InheritedObjectType", &g_wszIsInherit, &vtTrue, 1);
        }

        SysFreeString(bstr);
    }
 
    return hr;
}

//
// CACEEnumOperation_IndicateAll
//

HRESULT CAdminACL::CACEEnumOperation_IndicateAll::Do(
    IADsAccessControlEntry* pACE)
{
    DBG_ASSERT(pACE);

    if(FAILED(m_hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", m_hr));
        return m_hr;
    }

    CComPtr<IWbemClassObject> spInstance;

    HRESULT hr = m_spClass->SpawnInstance(0, &spInstance);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    hr = spInstance->Put(
        WMI_CLASS_DATA::s_ACE.pszKeyName,
        0,
        &m_vNameValue,
        0);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    CComBSTR sbstrTrustee;
    hr = pACE->get_Trustee(&sbstrTrustee);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    VARIANT vTrustee;
    vTrustee.bstrVal = sbstrTrustee;
    vTrustee.vt      = VT_BSTR;
    hr = spInstance->Put(L"Trustee", 0, &vTrustee, 0);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    hr = PopulateWmiACE(spInstance, pACE, bLocalIsInherit);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    hr = m_pWbemObjectSink->Indicate(1, &spInstance);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    return hr;
}

//
// CACEEnumOperation_Find
//

HRESULT CAdminACL::CACEEnumOperation_Find::Do(
    IADsAccessControlEntry* pACE)
{
    DBG_ASSERT(pACE);
    DBG_ASSERT(m_eDone == eDONE_NO);

    CComBSTR sbstr;

    HRESULT hr = pACE->get_Trustee(&sbstr);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    if(_wcsicmp(sbstr, m_bstrTrustee) == 0)
    {
        m_eDone = eDONE_YES;
        hr = DoOnMatch(pACE);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
            return hr;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\appladmin.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    appladmin.h

Abstract:

    This file contains definition of:
        CAppPoolMethod, CWebAppMethod

Author:

    ???

Revision History:

    Mohit Srivastava            21-Jan-01

--*/

#ifndef _appladmin_h_
#define _appladmin_h_

#include <atlbase.h>

class CAppPoolMethod
{
public:
    CAppPoolMethod();
    ~CAppPoolMethod();

    void GetCurrentMode(
        VARIANT* io_pvtServerMode);

    void Start(
        LPCWSTR i_wszMbPath);

    void Stop(
        LPCWSTR i_wszMbPath);

    void RecycleAppPool(
        LPCWSTR  i_wszMbPath);

    void EnumAppsInPool(
        LPCWSTR  i_wszMbPath,
        VARIANT* io_pvtApps);

    void DeleteAppPool(
        LPCWSTR  i_wszMbPath);

private:

    void GetPtrToAppPool(
        LPCWSTR  i_wszMbPath,
        LPCWSTR* o_pwszAppPool);

    HRESULT IISGetAppPoolState(
        METADATA_HANDLE hObjHandle,
        LPDWORD pdwState);

    HRESULT IISSetDword(
        METADATA_HANDLE hKey,
        DWORD dwPropId,
        DWORD dwValue);

    HRESULT IISGetAppPoolWin32Error(
        METADATA_HANDLE hObjHandle,
        HRESULT* phrError);

    HRESULT ExecMethod(
        DWORD dwControl);

    CComPtr<IIISApplicationAdmin> m_spAppAdmin;

    CMetabase              metabase;
    CComPtr<IMSAdminBase> m_pIABase;
    LPCWSTR          m_wszPath; // full metabase path of loc where we will execute method
};

class CWebAppMethod
{
private:

    IIISApplicationAdmin*   m_pAppAdmin;
    IWamAdmin2*             m_pWamAdmin2;

public:

    CWebAppMethod();
    ~CWebAppMethod();
    
    HRESULT AppCreate(LPCWSTR, bool);
    HRESULT AppCreate2(LPCWSTR, long);
    HRESULT AppCreate3(LPCWSTR, long, LPCWSTR, bool);
    HRESULT AppDelete(LPCWSTR, bool);
    HRESULT AppUnLoad(LPCWSTR, bool);
    HRESULT AppDisable(LPCWSTR, bool);
    HRESULT AppEnable(LPCWSTR, bool);
    HRESULT AppGetStatus(LPCWSTR, DWORD*);
    HRESULT AspAppRestart(LPCWSTR);
};

#endif // _appladmin_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\assocaclace.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocACLACE.h

Abstract:

    Definition of:
    CAssocACLACE

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _AssocACLACE_h_
#define _AssocACLACE_h_

#include <windows.h>
#include <ole2.h>
#include <stdio.h>

#include <genlex.h>
#include "sqllex.h"
#include "sql_1ext.h"
#include <opathlex.h>
#include <objpath.h>

#include <wbemprov.h>

#include "WbemServices.h"
#include "AssocBase.h"
#include "adminacl.h"

class CAssocACLACE : public CAssocBase
{
public:
    CAssocACLACE(        
        CWbemServices*   i_pNamespace,
        IWbemObjectSink* i_pResponseHandler);

    //
    // IAssocBase
    //
    void GetInstances(
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp = NULL);

private:
    
    CMetabase   m_metabase;

    class CACEEnumOperation_IndicateAllAsAssoc : public CACEEnumOperation_Base
    {
    public:
        CACEEnumOperation_IndicateAllAsAssoc(
            CAssocACLACE*     i_pAssocACLACE,
            const BSTR        i_bstrACLObjPath,
            ParsedObjectPath* i_pParsedACEObjPath) : m_bstrACLObjPath(i_bstrACLObjPath)
        {
            m_pAssocACLACE      = i_pAssocACLACE;
            m_pParsedACEObjPath = i_pParsedACEObjPath;
        }

        virtual HRESULT Do(
            IADsAccessControlEntry* pACE);

        virtual eDone Done() { return eDONE_DONT_KNOW; }

    private:
        CAssocACLACE*     m_pAssocACLACE;
        const BSTR        m_bstrACLObjPath;
        ParsedObjectPath* m_pParsedACEObjPath;
    };
};

#endif // _AssocACLACE_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\assocaclace.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocACLACE.cpp

Abstract:

    Implementation of:
    CAssocACLACE

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#include "iisprov.h"
#include <dbgutil.h>
#include <atlbase.h>
#include "AssocACLACE.h"
#include "utils.h"
#include "SmartPointer.h"

CAssocACLACE::CAssocACLACE(
    CWbemServices*     i_pNamespace,
    IWbemObjectSink*   i_pResponseHandler) : 
    CAssocBase(i_pNamespace, i_pResponseHandler, &WMI_ASSOCIATION_DATA::s_AdminACLToACE)
{
}

void CAssocACLACE::GetInstances(
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp) //defaultvalue(NULL)
{
    DBG_ASSERT(m_pNamespace);
    DBG_ASSERT(i_pExp);

    SQL_LEVEL_1_TOKEN* pTokenACL  = NULL;  // left part of assoc
    SQL_LEVEL_1_TOKEN* pTokenACE = NULL;   // right part of assoc

    //
    // Walk thru tokens
    // Don't do query if we find OR or NOT
    // Record match for left and/or right part of association.
    //
    bool  bDoQuery = true;
    ProcessQuery(
        i_pExp,
        m_pWmiAssoc,
        &pTokenACL, // points to i_pExp, does not need to be cleaned up
        &pTokenACE, // points to i_pExp, does not need to be cleaned up
        &bDoQuery);

    if( !bDoQuery || (pTokenACL == NULL && pTokenACE == NULL))
    {
        GetAllInstances(m_pWmiAssoc);
        return;
    }

    //
    // We need to get just a single association instance.  If we were provided
    // at least a ACL or a ACE part, we have enough information.
    //
    DBG_ASSERT(pTokenACL != NULL || pTokenACE != NULL);

    if(pTokenACL && pTokenACE)
    {
        Indicate(pTokenACL->vConstValue.bstrVal, pTokenACE->vConstValue.bstrVal);
    }
    else if(pTokenACE)
    {
        _bstr_t sbstrPath;

        TSmartPointer<ParsedObjectPath> spParsedACLObjPath = NULL;
        if (m_PathParser.Parse(pTokenACE->vConstValue.bstrVal, &spParsedACLObjPath) 
            != CObjectPathParser::NoError)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
        }

        KeyRef* pkr = CUtils::GetKey(
            spParsedACLObjPath, 
            m_pWmiAssoc->pcRight->pszKeyName);

        sbstrPath = pkr->m_vValue.bstrVal;

        //
        // Make the ACL Object Path
        //
        BOOL    bRet = true;

        bRet = spParsedACLObjPath->SetClassName(
            m_pWmiAssoc->pcLeft->pszClassName);
        THROW_ON_FALSE(bRet);

        VARIANT vtPath;
        vtPath.vt      = VT_BSTR;
        vtPath.bstrVal = sbstrPath;
        spParsedACLObjPath->ClearKeys();
        bRet = spParsedACLObjPath->AddKeyRef(
            m_pWmiAssoc->pcLeft->pszKeyName,
            &vtPath);
        THROW_ON_FALSE(bRet);

        Indicate(spParsedACLObjPath, pTokenACE->vConstValue.bstrVal);
    }
    else
    {
        //
        // pTokenACL && !pTokenACE
        //
        CComBSTR           sbstr;

        TSmartPointer<ParsedObjectPath> spParsedACEObjPath = NULL;
        if (m_PathParser.Parse(pTokenACL->vConstValue.bstrVal, &spParsedACEObjPath) 
            != CObjectPathParser::NoError)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
        }


        //
        // Start with the ACL part of the association.  Convert it to an ACE part.
        //
        if(!spParsedACEObjPath->SetClassName(m_pWmiAssoc->pcRight->pszClassName))
        {
            THROW_ON_ERROR(WBEM_E_FAILED);
        }

        sbstr =  m_pWmiAssoc->pcLeft->pszMetabaseKey;
		sbstr += L"/";

        KeyRef* pkr = CUtils::GetKey(
            spParsedACEObjPath, 
            m_pWmiAssoc->pcLeft->pszKeyName);
        DBG_ASSERT(pkr);

        sbstr += pkr->m_vValue.bstrVal;
        if(sbstr.m_str == NULL)
        {
            THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
        }

        //
        // CloseSD called automatically
        //
        CAdminACL AdminAcl;
        HRESULT hr = AdminAcl.OpenSD(sbstr, m_metabase);
        THROW_ON_ERROR(hr);

        CACEEnumOperation_IndicateAllAsAssoc op(
            this,
            pTokenACL->vConstValue.bstrVal,
            spParsedACEObjPath);
        hr = AdminAcl.EnumACEsAndOp(/*ref*/ op);
        THROW_ON_ERROR(hr);
    }
}

HRESULT CAssocACLACE::CACEEnumOperation_IndicateAllAsAssoc::Do(
    IADsAccessControlEntry* pACE)
{
    DBG_ASSERT(pACE);

    CComBSTR sbstrTrustee;

    HRESULT hr = pACE->get_Trustee(&sbstrTrustee);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // add keyref
    //
    VARIANT vTrustee;
    vTrustee.bstrVal = sbstrTrustee;
    vTrustee.vt      = VT_BSTR;
    THROW_ON_FALSE(m_pParsedACEObjPath->AddKeyRefEx(L"Trustee",&vTrustee));

    m_pAssocACLACE->Indicate(m_bstrACLObjPath, m_pParsedACEObjPath);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\assoccomponent.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocComponent.h

Abstract:

    Definition of:
    CAssocComponent

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _AssocComponent_h_
#define _AssocComponent_h_

#include <windows.h>
#include <ole2.h>
#include <stdio.h>

#include <genlex.h>
#include "sqllex.h"
#include <sql_1ext.h>
#include <opathlex.h>
#include <objpath.h>

#include <wbemprov.h>

#include "WbemServices.h"
#include "AssocBase.h"

class CAssocComponent : public CAssocBase
{
public:
    CAssocComponent(
        CWbemServices*              i_pNamespace,
        IWbemObjectSink*            i_pResponseHandler,
        WMI_ASSOCIATION*            i_pWmiAssoc);

    //
    // IAssocBase
    //
    void GetInstances(
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp = NULL);

private:
    void EnumParts(
        SQL_LEVEL_1_TOKEN* pTokenLeft);

    void GetGroup(
        SQL_LEVEL_1_TOKEN* pTokenRight);
};

#endif // _AssocComponent_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\assocbase.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocBase.h

Abstract:

    Definition of:
    CAssocBase

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _assocbase_h_
#define _assocbase_h_

#include <windows.h>
#include <ole2.h>
#include <stdio.h>

#include <genlex.h>
#include "sqllex.h"
#include <sql_1ext.h>
#include <opathlex.h>
#include <objpath.h>

#include <wbemprov.h>

#include "WbemServices.h"
#include "WbemObjectSink.h"
#include "schema.h"

class CAssocBase
{
public:
    CAssocBase(
        CWbemServices*              i_pNamespace,
        IWbemObjectSink*            i_pResponseHandler,
        WMI_ASSOCIATION*            i_pWmiAssoc);

    virtual void GetInstances(
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp = NULL) = 0;

protected:
    void GetAllInstances(
        WMI_ASSOCIATION*            i_pWmiAssoc);

    void ProcessQuery(
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp,
        WMI_ASSOCIATION*                i_pWmiAssoc,
        SQL_LEVEL_1_TOKEN**             o_ppTokenLeft,
        SQL_LEVEL_1_TOKEN**             o_ppTokenRight,
        bool*                           o_pbDoQuery);

    void Indicate(
        BSTR                        i_bstrObjPathLeft,
        BSTR                        i_bstrObjPathRight,
        bool                        i_bVerifyLeft  = true,
        bool                        i_bVerifyRight = true);

    void Indicate(
        const BSTR                  i_bstrLeftObjPath,
        ParsedObjectPath*           i_pParsedRightObjPath,
        bool                        i_bVerifyLeft  = true,
        bool                        i_bVerifyRight = true);

    void Indicate(
        ParsedObjectPath*           i_pParsedLeftObjPath,
        const BSTR                  i_bstrRightObjPath,
        bool                        i_bVerifyLeft  = true,
        bool                        i_bVerifyRight = true);

    bool LookupKeytypeInMb(
        LPCWSTR          i_wszWmiPath,
        WMI_CLASS*       i_pWmiClass);

    CWbemServices*      m_pNamespace;
    CWbemObjectSink     m_InstanceMgr;
    WMI_ASSOCIATION*    m_pWmiAssoc;
    CObjectPathParser   m_PathParser;

private:
    IWbemObjectSink*    m_pResponseHandler;
};

#endif // _assocbase_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: WMI IIS Instance provider
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "iisprov.h"


//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;    
}

CProvFactory::~CProvFactory(void)
{
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(
    REFIID riid,
    PPVOID ppv
    )
{
    *ppv=NULL;

    if (IID_IUnknown == riid || IID_IClassFactory == riid)
        *ppv=this;

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    long lNewCount = InterlockedDecrement((long *)&m_cRef);

    if (0L == lNewCount)
        delete this;
    
    return lNewCount>0 ? lNewCount : 0;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid, PPVOID ppvObj
    )
{
    CIISInstProvider *pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj = new CIISInstProvider();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr = pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\assoccomponent.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocComponent.cpp

Abstract:

    Implementation of:
    CAssocComponent

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

//
// Needed for metabase.h
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <mddefw.h>
#include <dbgutil.h>
#include <atlbase.h>
#include "AssocComponent.h"
#include "utils.h"
#include "metabase.h"
#include "SmartPointer.h"

CAssocComponent::CAssocComponent(
    CWbemServices*   i_pNamespace,
    IWbemObjectSink* i_pResponseHandler,
    WMI_ASSOCIATION* i_pWmiAssoc) : 
    CAssocBase(i_pNamespace, i_pResponseHandler, i_pWmiAssoc)
{
}

void CAssocComponent::GetInstances(
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp) //defaultvalue(NULL)
{
    DBG_ASSERT(m_pNamespace);
    DBG_ASSERT(i_pExp);

    SQL_LEVEL_1_TOKEN* pTokenGroup  = NULL;  // left part of assoc
    SQL_LEVEL_1_TOKEN* pTokenPart   = NULL;  // right part of assoc

    //
    // Walk thru tokens
    // Don't do query if we find OR or NOT
    // Record match for left and/or right part of association.
    //
    bool  bDoQuery = true;
    ProcessQuery(i_pExp, m_pWmiAssoc, &pTokenGroup, &pTokenPart, &bDoQuery);

    if( !bDoQuery || (pTokenGroup == NULL && pTokenPart == NULL) )
    {
        GetAllInstances(
            m_pWmiAssoc);
        return;
    }

    DBG_ASSERT(pTokenGroup != NULL || pTokenPart != NULL);

    BSTR  bstrLeft  = NULL;
    BSTR  bstrRight = NULL;

    if(pTokenGroup && pTokenPart)
    {
        Indicate(
            pTokenGroup->vConstValue.bstrVal,
            pTokenPart->vConstValue.bstrVal);
    }
    else if(pTokenGroup)
    {
        EnumParts(
            pTokenGroup);
    }
    else
    {
        GetGroup(
            pTokenPart);
    }
}

void CAssocComponent::EnumParts(
    SQL_LEVEL_1_TOKEN* pTokenLeft)
{
    DBG_ASSERT(pTokenLeft != NULL);

    HRESULT hr = S_OK;

    //
    // Parse the left part of the association
    //
    TSmartPointer<ParsedObjectPath> spParsedObject;
    if( m_PathParser.Parse(pTokenLeft->vConstValue.bstrVal, &spParsedObject)
        != CObjectPathParser::NoError)
    {
        THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
    }

    //
    // Get the key from the left part of the association
    //
    KeyRef* pkr = NULL;
    pkr = CUtils::GetKey(spParsedObject, m_pWmiAssoc->pcLeft->pszKeyName);

    CComBSTR sbstrMbPath =  m_pWmiAssoc->pcLeft->pszMetabaseKey; // Eg: /LM
    sbstrMbPath          += L"/";                                // Eg: /LM/
    sbstrMbPath          += pkr->m_vValue.bstrVal;               // Eg: /LM/w3svc
    if(sbstrMbPath.m_str == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }

    //
    // Convert parsed object to right part
    //
    if(!spParsedObject->SetClassName(m_pWmiAssoc->pcRight->pszClassName))
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }
    spParsedObject->ClearKeys();

    CMetabase metabase;
    WCHAR wszMDName[METADATA_MAX_NAME_LEN+1] = {0};
    DWORD dwIndex = 0;
    do
    {
        METABASE_KEYTYPE* pkt = m_pWmiAssoc->pcRight->pkt;
		wszMDName[0]          = L'\0';
        hr = metabase.EnumKeys(
            METADATA_MASTER_ROOT_HANDLE,
            sbstrMbPath,
            wszMDName,
            &dwIndex,
            pkt,
            true);
        dwIndex++;
        if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
        {
            break;
        }
        THROW_ON_ERROR(hr);

		LPWSTR pStart =  sbstrMbPath;
		pStart        += wcslen(m_pWmiAssoc->pcRight->pszMetabaseKey);
		pStart        += (*pStart == L'/')  ? 1 : 0;

        CComBSTR sbstr =  pStart;
        sbstr          += (*pStart == L'\0') ? L"" : L"/"; // Eg. "w3svc/"
        sbstr          += wszMDName;					   // Eg. "w3svc/1"
        if(sbstr.m_str == NULL)
        {
            THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
        }

        VARIANT vt;
        vt.vt       = VT_BSTR;
        vt.bstrVal  = sbstr;

        if(!spParsedObject->AddKeyRefEx(m_pWmiAssoc->pcRight->pszKeyName, &vt))
        {
            THROW_ON_ERROR(WBEM_E_FAILED);
        }
      
        Indicate(
            pTokenLeft->vConstValue.bstrVal,
            spParsedObject,
            false,
            false);
    }
    while(1);
}

void CAssocComponent::GetGroup(
    SQL_LEVEL_1_TOKEN* pTokenRight)
{
    TSmartPointer<ParsedObjectPath> spParsedObject;
    if( m_PathParser.Parse(pTokenRight->vConstValue.bstrVal, &spParsedObject)
        != CObjectPathParser::NoError)
    {
        THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
    }

    //
    // Get the key from the right part of the association
    //
    KeyRef* pkr = NULL;
    pkr = CUtils::GetKey(spParsedObject, m_pWmiAssoc->pcRight->pszKeyName);

    const BSTR bstrRight = pkr->m_vValue.bstrVal;
    ULONG      cchRight  = wcslen(bstrRight);

    CComBSTR sbstrLeft;
    LPWSTR pSlash = wcsrchr(bstrRight, L'/');

    //
    // Trim off the last part and construct the Group (i.e. Left) obj path
    //
    if(pSlash == NULL)
    {
        if(m_pWmiAssoc->pcLeft == &WMI_CLASS_DATA::s_Computer)
        {
            sbstrLeft =  WMI_CLASS_DATA::s_Computer.pszClassName;
            sbstrLeft += "='LM'";
        }
        else
        {
            return;
        }
    }
    else
    {
        *pSlash = L'\0';
        sbstrLeft =  m_pWmiAssoc->pcLeft->pszClassName;
        sbstrLeft += L"='";
        sbstrLeft += (LPWSTR)bstrRight;
        sbstrLeft += L"'";

        //
        // Verify the group part actually exists.
        // Put back the slash in the string we modified.
        //
        if(!LookupKeytypeInMb(bstrRight, m_pWmiAssoc->pcLeft))
        {
            *pSlash = L'/';
            return;
        }
        *pSlash = L'/';
    }

    if(sbstrLeft.m_str == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }

    Indicate(
        sbstrLeft,
        pTokenRight->vConstValue.bstrVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\assocbase.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocSameLevel.cpp

Abstract:

    Implementation of:
    CAssocSameLevel

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

//
// Needed for metabase.h
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <dbgutil.h>

#include "AssocBase.h"

#include "InstanceHelper.h"
#include "metabase.h"
#include "enum.h"
#include "utils.h"

CAssocBase::CAssocBase(
    CWbemServices*              i_pNamespace,
    IWbemObjectSink*            i_pResponseHandler,
    WMI_ASSOCIATION*            i_pWmiAssoc) : 
    m_InstanceMgr(i_pResponseHandler),
    m_PathParser(e_ParserAcceptRelativeNamespace)
{
    DBG_ASSERT(i_pNamespace);
    DBG_ASSERT(i_pResponseHandler);
    DBG_ASSERT(i_pWmiAssoc);

    m_pWmiAssoc        = i_pWmiAssoc;
    m_pNamespace       = i_pNamespace;
    m_pResponseHandler = i_pResponseHandler;
}

void CAssocBase::GetAllInstances(
    WMI_ASSOCIATION*    i_pWmiAssoc)
{
    DBG_ASSERT(i_pWmiAssoc);

    ParsedObjectPath    ParsedObject;            //deconstructer frees memory
    CObjectPathParser   PathParser(e_ParserAcceptRelativeNamespace);

    CEnum EnumAssociation;
    EnumAssociation.Init(
        m_pResponseHandler,
        m_pNamespace,
        &ParsedObject,
        i_pWmiAssoc->pcRight->pszMetabaseKey,
        i_pWmiAssoc
        );
    EnumAssociation.Recurse(
        NULL,
        &METABASE_KEYTYPE_DATA::s_IIsComputer,        
        NULL,
        i_pWmiAssoc->pcRight->pszKeyName,
        i_pWmiAssoc->pcRight->pkt
        );
}

void CAssocBase::ProcessQuery(
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp,
    WMI_ASSOCIATION*                i_pWmiAssoc,
    SQL_LEVEL_1_TOKEN**             o_ppTokenLeft,
    SQL_LEVEL_1_TOKEN**             o_ppTokenRight,
    bool*                           o_pbDoQuery)
{
    int                iNumTokens = i_pExp->m_pSqlExpr->nNumTokens;
    SQL_LEVEL_1_TOKEN* pToken     = i_pExp->m_pSqlExpr->pArrayOfTokens;

    SQL_LEVEL_1_TOKEN* pTokenLeft  = NULL;  // left part of assoc
    SQL_LEVEL_1_TOKEN* pTokenRight = NULL;  // right part of assoc

    //
    // Walk thru tokens
    // Don't do query if we find OR or NOT
    // Record match for left and/or right part of association.
    //
    bool  bDoQuery = true;
    for(int i = 0; i < iNumTokens; i++, pToken++)
    {

        switch(pToken->nTokenType)
        {
        case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
            if( !pTokenLeft &&
                _wcsicmp(i_pWmiAssoc->pType->pszLeft, pToken->pPropertyName) == 0)
            {
                pTokenLeft = pToken;
            }
            if( !pTokenRight &&
                _wcsicmp(i_pWmiAssoc->pType->pszRight, pToken->pPropertyName) == 0)
            {
                pTokenRight = pToken;
            }
            break;
        case SQL_LEVEL_1_TOKEN::TOKEN_OR:
        case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
            bDoQuery = false;
            break;
        }
    }

    if(bDoQuery)
    {
        if(pTokenLeft && pTokenLeft->vConstValue.vt != VT_BSTR)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
        }
        if(pTokenRight && pTokenRight->vConstValue.vt != VT_BSTR)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
        }
    }

    if(o_pbDoQuery)
    {
        *o_pbDoQuery = bDoQuery;
    }
    *o_ppTokenLeft  = pTokenLeft;
    *o_ppTokenRight = pTokenRight;
}

void CAssocBase::Indicate(
    const BSTR        i_bstrLeftObjPath,
    ParsedObjectPath* i_pParsedRightObjPath,
    bool              i_bVerifyLeft,
    bool              i_bVerifyRight)
{
    DBG_ASSERT(i_bstrLeftObjPath);
    DBG_ASSERT(i_pParsedRightObjPath);

    LPWSTR wszUnparsed = NULL;
    if (m_PathParser.Unparse(i_pParsedRightObjPath, &wszUnparsed) 
        != CObjectPathParser::NoError)
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }

    CComBSTR sbstrRightObjPath = wszUnparsed;
    delete [] wszUnparsed;
    wszUnparsed = NULL;
    
    if(sbstrRightObjPath.m_str == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }

    Indicate(
        i_bstrLeftObjPath,
        sbstrRightObjPath,
        i_bVerifyLeft,
        i_bVerifyRight);
}

void CAssocBase::Indicate(
    ParsedObjectPath* i_pParsedLeftObjPath,
    const BSTR        i_bstrRightObjPath,
    bool              i_bVerifyLeft,
    bool              i_bVerifyRight)
{
    DBG_ASSERT(i_bstrRightObjPath);
    DBG_ASSERT(i_pParsedLeftObjPath);

    LPWSTR wszUnparsed = NULL;
    if (m_PathParser.Unparse(i_pParsedLeftObjPath, &wszUnparsed) 
        != CObjectPathParser::NoError)
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }

    CComBSTR sbstrLeftObjPath = wszUnparsed;
    delete [] wszUnparsed;
    wszUnparsed = NULL;
    
    if(sbstrLeftObjPath.m_str == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }

    Indicate(
        sbstrLeftObjPath,
        i_bstrRightObjPath,
        i_bVerifyLeft,
        i_bVerifyRight);
}

void CAssocBase::Indicate(
    const BSTR        i_bstrObjPathLeft,
    const BSTR        i_bstrObjPathRight,
    bool              i_bVerifyLeft,
    bool              i_bVerifyRight)
{
    DBG_ASSERT(i_bstrObjPathLeft  != NULL);
    DBG_ASSERT(i_bstrObjPathRight != NULL);

    VARIANT vtObjPathLeft;
    VARIANT vtObjPathRight;

    vtObjPathLeft.vt        = VT_BSTR;
    vtObjPathLeft.bstrVal   = (BSTR)i_bstrObjPathLeft;  // this is okay, AddKeyRef makes copy
    vtObjPathRight.vt       = VT_BSTR;
    vtObjPathRight.bstrVal  = (BSTR)i_bstrObjPathRight; // this is okay, AddKeyRef makes copy

    ParsedObjectPath ParsedAssocObjPath;
    if(!ParsedAssocObjPath.SetClassName(m_pWmiAssoc->pszAssociationName))
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }
    if(!ParsedAssocObjPath.AddKeyRef(m_pWmiAssoc->pType->pszLeft, &vtObjPathLeft))
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }
    if(!ParsedAssocObjPath.AddKeyRef(m_pWmiAssoc->pType->pszRight, &vtObjPathRight))
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }

    CInstanceHelper  InstanceHelper(&ParsedAssocObjPath, m_pNamespace);
    DBG_ASSERT(InstanceHelper.IsAssoc());

    CComPtr<IWbemClassObject> spObj;
    InstanceHelper.GetAssociation(&spObj, i_bVerifyLeft, i_bVerifyRight);

    m_InstanceMgr.Indicate(spObj);
}

bool CAssocBase::LookupKeytypeInMb(
    LPCWSTR          i_wszWmiPath,
    WMI_CLASS*       i_pWmiClass)
/*++

Synopsis: 
    GetInstances calls this for each side of the association to determine
    if the two sides actually exist in the metabase.  If at least one doesn't,
    there is no point in returning the association.

    If we are unsure (i.e. we get path busy), it is safer to return true.

Arguments: [i_wszWmiPath] - The value part of the object path (i.e. w3svc/1)
           [i_pWmiClass] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_wszWmiPath);
    DBG_ASSERT(i_pWmiClass);

    CMetabase metabase;

    _bstr_t sbstrMbPath;
    sbstrMbPath =  i_pWmiClass->pszMetabaseKey;
    sbstrMbPath += L"/";
    sbstrMbPath += i_wszWmiPath;

    HRESULT hr = metabase.CheckKey(sbstrMbPath, i_pWmiClass->pkt);
    switch(hr)
    {
    case HRESULT_FROM_WIN32(ERROR_PATH_BUSY):
        return true;
    case HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
        return false;
    default:
        return true;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\assocsamelevel.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocSameLevel.h

Abstract:

    Definition of:
    CAssocSameLevel

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _assocsamelevel_h_
#define _assocsamelevel_h_

#include <windows.h>
#include <ole2.h>
#include <stdio.h>

#include <genlex.h>
#include "sqllex.h"
#include <sql_1ext.h>

#include <wbemprov.h>

#include "WbemServices.h"
#include "AssocBase.h"
#include "schema.h"

class CAssocSameLevel : public CAssocBase
{
public:
    CAssocSameLevel(
        CWbemServices*   i_pNamespace,
        IWbemObjectSink* i_pResponseHandler,
        WMI_ASSOCIATION* i_pWmiAssoc);

    //
    // IAssocBase
    //
    void GetInstances(
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp = NULL);
};

#endif // _assocsamelevel_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\assocsamelevel.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocSameLevel.cpp

Abstract:

    Implementation of:
    CAssocSameLevel

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <mdmsg.h>
#include <dbgutil.h>
#include "AssocSameLevel.h"
#include "utils.h"
#include "instancehelper.h"
#include "metabase.h"
#include "SmartPointer.h"

CAssocSameLevel::CAssocSameLevel(
    CWbemServices*   i_pNamespace,
    IWbemObjectSink* i_pResponseHandler,
    WMI_ASSOCIATION* i_pWmiAssoc) : 
    CAssocBase(i_pNamespace, i_pResponseHandler, i_pWmiAssoc)
{
}

void CAssocSameLevel::GetInstances(
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp) //defaultvalue(NULL)
{
    DBG_ASSERT(i_pExp);

    SQL_LEVEL_1_TOKEN* pTokenLeft  = NULL;  // left part of assoc
    SQL_LEVEL_1_TOKEN* pTokenRight = NULL;  // right part of assoc

    //
    // Walk thru tokens
    // Don't do query if we find OR or NOT
    // Record match for left and/or right part of association.
    //
    bool  bDoQuery = true;
    ProcessQuery(
        i_pExp,
        m_pWmiAssoc,
        &pTokenLeft,
        &pTokenRight,
        &bDoQuery);

    if( !bDoQuery || (pTokenLeft == NULL && pTokenRight == NULL) )
    {
        GetAllInstances(
            m_pWmiAssoc);
        return;
    }

    //
    // We need to get just a single association instance.  If we were provided
    // at least a left or a right part, we have enough information.
    //
    DBG_ASSERT(pTokenLeft != NULL || pTokenRight != NULL);

    VARIANT  vtLeft;
    VARIANT  vtRight;
    VariantInit(&vtLeft);
    VariantInit(&vtRight);

    CComBSTR sbstr;

    if(pTokenLeft && pTokenRight)
    {
        vtLeft.vt       = VT_BSTR;
        vtLeft.bstrVal  = pTokenLeft->vConstValue.bstrVal;
        vtRight.vt      = VT_BSTR;
        vtRight.bstrVal = pTokenRight->vConstValue.bstrVal;
    }
    else
    {
        //
        // An association contains two object paths.  We are going to construct
        // the missing one by simply replacing the class.
        //
        // Eg. IIsWebServer='w3svc/1' => IIsWebServerSetting='w3svc/1'
        //
        CObjectPathParser  PathParser(e_ParserAcceptRelativeNamespace);

        SQL_LEVEL_1_TOKEN* pTokenCur    = (pTokenLeft) ? pTokenLeft : pTokenRight;
        WMI_CLASS*         pWmiClass    =
            (pTokenLeft) ? m_pWmiAssoc->pcLeft : m_pWmiAssoc->pcRight;
        WMI_CLASS*         pWmiClassOpposite = 
            (pTokenLeft) ? m_pWmiAssoc->pcRight : m_pWmiAssoc->pcLeft;

        TSmartPointer<ParsedObjectPath> spParsedObject;
        if (PathParser.Parse(pTokenCur->vConstValue.bstrVal, &spParsedObject) 
            != CObjectPathParser::NoError)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
        }

        KeyRef* pkr          = CUtils::GetKey(spParsedObject, pWmiClass->pszKeyName);
        if( !LookupKeytypeInMb(pkr->m_vValue.bstrVal, pWmiClass) &&
            !LookupKeytypeInMb(pkr->m_vValue.bstrVal, pWmiClassOpposite) )
        {
            //
            // One of the two classes in the assoc must be an element.
            //
            return;
        }

        if(!spParsedObject->SetClassName(pWmiClassOpposite->pszClassName))
        {
            THROW_ON_ERROR(WBEM_E_FAILED);
        }

        LPWSTR wszUnparsed = NULL;
        if (PathParser.Unparse(spParsedObject, &wszUnparsed) 
            != CObjectPathParser::NoError)
        {
            THROW_ON_ERROR(WBEM_E_FAILED);
        }
        sbstr = wszUnparsed;
        delete [] wszUnparsed; 
        wszUnparsed = NULL;

        if(sbstr.m_str == NULL)
        {
            THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
        }

        if(pTokenLeft)
        {
            vtLeft.vt        = VT_BSTR;
            vtLeft.bstrVal   = pTokenLeft->vConstValue.bstrVal;
            vtRight.vt       = VT_BSTR;
            vtRight.bstrVal  = sbstr;
        }
        else
        {
            vtRight.vt       = VT_BSTR;
            vtRight.bstrVal  = pTokenRight->vConstValue.bstrVal;
            vtLeft.vt        = VT_BSTR;
            vtLeft.bstrVal   = sbstr;
        }
    }

    Indicate(
        vtLeft.bstrVal,
        vtRight.bstrVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\certmap.h ===
#if !defined( _CERT_INCLUDED )
#define _CERT_INCLUDED


class CCertMapperMethod
{
#define IISMAPPER_LOCATE_BY_CERT    1
#define IISMAPPER_LOCATE_BY_NAME    2
#define IISMAPPER_LOCATE_BY_ACCT    3
#define IISMAPPER_LOCATE_BY_INDEX   4

private:

    IMSAdminBase*       m_pIABase;   //interface pointer
    METADATA_HANDLE     m_hmd;
    LPWSTR m_pszMetabasePath;

    HRESULT Init(LPCWSTR);        
    HRESULT Locate(LONG, VARIANT, LPWSTR);
    HRESULT SetString(LONG, VARIANT, BSTR, DWORD);       
    HRESULT SetBSTR(BSTR*, DWORD, LPBYTE);
    HRESULT SetVariantAsByteArray(VARIANT*, DWORD, LPBYTE);
    HRESULT SetVariantAsBSTR(VARIANT*, DWORD, LPBYTE);
    HRESULT SetVariantAsLong(VARIANT*, DWORD);
    HRESULT GetStringAFromBSTR(BSTR, LPSTR*, LPDWORD, BOOL fAddDelimInCount = true);
    HRESULT GetBlobFromVariant(VARIANT*, LPBYTE*, LPDWORD, BOOL fAddDelimInCount = true);
    HRESULT OpenMd(LPWSTR, DWORD dwPermission = METADATA_PERMISSION_READ);
    HRESULT CloseMd(BOOL fSave = FALSE);
    HRESULT DeleteMdObject(LPWSTR);
    HRESULT CreateMdObject(LPWSTR);
    HRESULT OpenAdminBaseKey(LPWSTR, DWORD);
    void CloseAdminBaseKey();


public:

    CCertMapperMethod(LPCWSTR);
    ~CCertMapperMethod();

    HRESULT CreateMapping(VARIANT, BSTR, BSTR, BSTR, LONG);

    HRESULT GetMapping(LONG, VARIANT, VARIANT*, VARIANT*, VARIANT*, VARIANT*, VARIANT*);
    HRESULT DeleteMapping(LONG, VARIANT);
    HRESULT SetEnabled(LONG, VARIANT, LONG);
    HRESULT SetName(LONG, VARIANT, BSTR);
    HRESULT SetPwd(LONG, VARIANT, BSTR);
    HRESULT SetAcct(LONG, VARIANT, BSTR);

    HRESULT SetMdData(LPWSTR, DWORD, DWORD, DWORD, LPBYTE);
    HRESULT GetMdData(LPWSTR, DWORD, DWORD, LPDWORD, LPBYTE*);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\certmap.cpp ===
////////////////////////////////////////////////////
//
// Copyright (c) 1997  Microsoft Corporation
// 
// Module Name: certmap.cpp
//
// Abstract: IIS privider cert mapper object methods
//
// Author: Philippe Choquier (phillich)    10-Apr-1997
//
// History: Zeyong Xu borrowed the source code from ADSI object 
//          (created by Philippe Choquier at 10-Apr-1997) at 20-Oct-1999
//
///////////////////////////////////////////////////

#include "iisprov.h"
#include "certmap.h"

const DWORD MAX_CERT_KEY_LEN = METADATA_MAX_NAME_LEN + 1;
const DWORD SHA1_HASH_SIZE = 20;

//
// CCertMapperMethod
//

CCertMapperMethod::CCertMapperMethod(LPCWSTR pszMetabasePathIn)
{ 
    DBG_ASSERT(pszMetabasePathIn != NULL);

    m_hmd = NULL; 

    HRESULT hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void**)&m_pIABase
        );

    THROW_ON_ERROR(hr);
    
    hr = Init(pszMetabasePathIn);

    THROW_ON_ERROR(hr);
}


CCertMapperMethod::~CCertMapperMethod()
{
    if ( m_pszMetabasePath )
    {
        free( m_pszMetabasePath );
    }

    if(m_pIABase)
        m_pIABase->Release();
}



HRESULT
GetCertificateHashString(
    PBYTE pbCert,
    DWORD cbCert,
    WCHAR *pwszCertHash,
    DWORD cchCertHashBuffer)
/*++

Routine Description:

    verifies validity of cert blob by creating cert context
    and retrieves SHA1 hash and converts it to WCHAR *

Arguments:

    pbCert - X.509 certificate blob
    cbCert - size of the cert blob in bytes
    pwszCertHash - buffer must be big enough to fit SHA1 hash in hex string form
                   (2 * SHA1_HASH_SIZE + terminating 0 )
    cchCertHashBuffer - size of the CertHash buffer in WCHARs (includes trminating string)
Returns:

    HRESULT

--*/
    
{
    HRESULT         hr = E_FAIL;
    BYTE            rgbHash[ SHA1_HASH_SIZE ];
    DWORD           cbSize = SHA1_HASH_SIZE;

    #ifndef HEX_DIGIT
    #define HEX_DIGIT( nDigit )                            \
    (WCHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + L'a'                          \
        : (nDigit) + L'0')
    #endif

    PCCERT_CONTEXT pCertContext = NULL;
    pCertContext = CertCreateCertificateContext(
                                    X509_ASN_ENCODING, 
                                    (const BYTE *)pbCert, 
                                    cbCert );
    
    if ( pCertContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr; 
    }

    //
    // get hash of the certificate to be verified
    //
    if ( !CertGetCertificateContextProperty( pCertContext,
                                             CERT_SHA1_HASH_PROP_ID,
                                             rgbHash,
                                             &cbSize ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        CertFreeCertificateContext( pCertContext );
        pCertContext = NULL;
        return hr;
    }
    
    CertFreeCertificateContext( pCertContext );
    pCertContext = NULL;

    if ( cchCertHashBuffer < SHA1_HASH_SIZE * 2 + 1 )
    {
        // we don't have big enough buffer to store
        // hex string of the SHA1 hash each byte takes 2 chars + terminating 0 
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        return hr;
    }

    //
    // convert to text
    //
    for (int i = 0; i < sizeof(rgbHash); i ++ )
    {
        *(pwszCertHash++) = HEX_DIGIT( ( rgbHash[ i ] >> 4 ) );
        *(pwszCertHash++) = HEX_DIGIT( ( rgbHash[ i ] & 0x0F ) );
    }
    *(pwszCertHash) = L'\0';
    #undef HEX_DIGIT
    return S_OK;
}


//
// CreateMapping(): Create a mapping entry
//
// Arguments:
//
//    vCert - X.509 certificate
//    bstrNtAcct - NT acct to map to
//    bstrNtPwd - NT pwd
//    bstrName - friendly name for mapping entry
//    lEnabled - 1 to enable mapping entry, 0 to disable it
//
HRESULT
CCertMapperMethod::CreateMapping(
    VARIANT     vCert,
    BSTR        bstrNtAcct,
    BSTR        bstrNtPwd,
    BSTR        bstrName,
    LONG        lEnabled
    )
{
    HRESULT     hr;
    LPBYTE      pbCert = NULL;
    DWORD       cbCert;
    LPBYTE      pRes;
    DWORD       cRes;
    VARIANT     vOldAcct;
    VARIANT     vOldCert;
    VARIANT     vOldPwd;
    VARIANT     vOldName;
    VARIANT     vOldEnabledFlag;
    PCCERT_CONTEXT pcCert = NULL;
    WCHAR       wszCertHash[ 2*SHA1_HASH_SIZE + 1];
    BOOL        fFoundExisting = FALSE;

    //
    // Do some sanity checks on the cert 
    //
    if ( SUCCEEDED( hr = GetBlobFromVariant( &vCert, 
                                               &pbCert,
                                               &cbCert ) ) )
    {
        //
        // verify validity of certificate blob
        // and retrieve certificate hash
        //

        if ( FAILED( hr = GetCertificateHashString( 
                                                pbCert,
                                                cbCert, 
                                                wszCertHash,
                                                sizeof( wszCertHash )/sizeof( WCHAR ) ) ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Invalid cert passed to CreateMapping() 0x%x\n", hr));
            //
            // If the decoding fails, GetLastError() returns an ASN1 decoding
            // error that is obtained by subtracting CRYPT_E_OSS_ERROR from the returned
            // error and looking in file asn1code.h for the actual error. To avoid the
            // cryptic ASN1 errors, we'll just return a general "invalid arg" error 
            //
            goto Exit;
        }
    }
    else
    {
        goto Exit;
    }

    //
    // check if we already have a mapping for this cert; if we do, we'll replace that mapping
    // with the new one
    //
    
    WCHAR       achIndex[MAX_CERT_KEY_LEN];
    
    if ( SUCCEEDED( hr = OpenMd( L"Cert11/Mappings", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( IISMAPPER_LOCATE_BY_CERT, 
                                      vCert,
                                      achIndex )) )
        {
            fFoundExisting = TRUE;
            DBGPRINTF((DBG_CONTEXT,
                       "Replacing old 1-1 cert mapping with new mapping\n"));
            
            
            if ( FAILED( hr = SetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, 
                                               sizeof(DWORD), (LPBYTE)&lEnabled ) ) ||
                 FAILED( hr = SetMdData( achIndex, MD_MAPNAME, STRING_METADATA, 
                                           sizeof(WCHAR) * (SysStringLen(bstrName) + 1 ), 
                                           (LPBYTE)bstrName ) ) ||
                 FAILED( hr = SetMdData( achIndex, MD_MAPNTPWD, STRING_METADATA, 
                                           sizeof(WCHAR) * (SysStringLen(bstrNtPwd) + 1 ), 
                                           (LPBYTE)bstrNtPwd ) ) ||
                 FAILED( hr = SetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, 
                                           sizeof(WCHAR) * (SysStringLen(bstrNtAcct) + 1 ),
                                           (LPBYTE)bstrNtAcct ) ) ||
                 FAILED( hr = SetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, 
                                           cbCert, (LPBYTE)pbCert ) ) )
            {
                //NOP - Something failed 
            }
        }
        CloseMd( SUCCEEDED( hr ) );
    }
    
    //
    // New mapping
    //
    if ( !fFoundExisting )
    {
        //
        // check mapping exists, create if not
        //
        hr = OpenMd( L"Cert11/Mappings", METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ );

        if ( hr == RETURNCODETOHRESULT( ERROR_PATH_NOT_FOUND ) )
        {
            if ( SUCCEEDED( hr = OpenMd( L"", 
                                           METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
            {
                hr = CreateMdObject( L"Cert11/Mappings" );
                CloseMd( FALSE );

                // Reopen to the correct node.
                hr = OpenMd( L"Cert11/Mappings", METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ );
            }
        }

        if ( FAILED( hr ) )
        {
            goto Exit;
        }

        //
        // adding the new mapping under it's CertHash node
        //

        if ( SUCCEEDED( hr = CreateMdObject( wszCertHash ) ) )
        {

            if ( FAILED( hr = SetMdData( wszCertHash, MD_MAPENABLED, DWORD_METADATA, 
                                           sizeof(DWORD), (LPBYTE)&lEnabled ) ) ||
                 FAILED( hr = SetMdData( wszCertHash, MD_MAPNAME, STRING_METADATA, 
                                           sizeof(WCHAR) * (SysStringLen(bstrName) + 1 ), 
                                           (LPBYTE)bstrName ) ) ||
                 FAILED( hr = SetMdData( wszCertHash, MD_MAPNTPWD, STRING_METADATA, 
                                           sizeof(WCHAR) * (SysStringLen(bstrNtPwd) + 1 ), 
                                           (LPBYTE)bstrNtPwd ) ) ||
                 FAILED( hr = SetMdData( wszCertHash, MD_MAPNTACCT, STRING_METADATA, 
                                           sizeof(WCHAR) * (SysStringLen(bstrNtAcct) + 1 ),
                                           (LPBYTE)bstrNtAcct ) ) ||
                 FAILED( hr = SetMdData( wszCertHash, MD_MAPCERT, BINARY_METADATA, 
                                           cbCert, (LPBYTE)pbCert ) ) )
            {
            }
        }
    }

Exit:
    if( pbCert != NULL )
    {
        free( pbCert );
        pbCert = NULL;
    }
    CloseMd( SUCCEEDED( hr ) );
    return hr;
}

//
// GetMapping: Get a mapping entry using key
//
// Arguments:
//
//    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
//    vKey - key to use to locate mapping
//    pvCert - X.509 certificate
//    pbstrNtAcct - NT acct to map to
//    pbstrNtPwd - NT pwd
//    pbstrName - friendly name for mapping entry
//    plEnabled - 1 to enable mapping entry, 0 to disable it
//

HRESULT
CCertMapperMethod::GetMapping(
    LONG        lMethod,
    VARIANT     vKey,
    VARIANT*    pvCert,
    VARIANT*    pbstrNtAcct,
    VARIANT*    pbstrNtPwd,
    VARIANT*    pbstrName,
    VARIANT*    plEnabled
    )
{
    WCHAR       achIndex[MAX_CERT_KEY_LEN];
    HRESULT     hr;
    DWORD       dwLen;
    LPBYTE      pbData = NULL;

    VariantInit( pvCert );
    VariantInit( pbstrNtAcct );
    VariantInit( pbstrNtPwd );
    VariantInit( pbstrName );
    VariantInit( plEnabled );

    if ( SUCCEEDED( hr = OpenMd( L"Cert11/Mappings", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( lMethod, vKey, achIndex )) )
        {
            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                if ( FAILED( hr = SetVariantAsByteArray( pvCert, dwLen, pbData ) ) )
                {
                    goto Done;
                }
                free( pbData );
                pbData = NULL;

            }
            else
            {
                if ( hr != MD_ERROR_DATA_NOT_FOUND || 
                     FAILED( hr = SetVariantAsByteArray( pvCert, 0, (PBYTE)"" ) ) )
                {
                    goto Done;
                }
            }

            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                if ( FAILED( hr = SetVariantAsBSTR( pbstrNtAcct, dwLen, pbData ) ) )
                {
                    goto Done;
                }
                free( pbData );
                pbData = NULL;
            }
            else
            {
                if ( hr != MD_ERROR_DATA_NOT_FOUND ||
                     FAILED ( hr = SetVariantAsBSTR( pbstrNtAcct, 
                                                       sizeof(L""), (LPBYTE)L"" ) ) )
                {
                    goto Done;
                }
            }

            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPNTPWD, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                if ( FAILED( hr = SetVariantAsBSTR( pbstrNtPwd, dwLen, pbData ) ) )
                { 
                    goto Done;
                }
                free( pbData );
                pbData = NULL;
            }
            else
            {
                if ( hr != MD_ERROR_DATA_NOT_FOUND ||
                    FAILED( hr = SetVariantAsBSTR( pbstrNtPwd, 
                                                     sizeof(L""), (LPBYTE)L"" ) ) )
                { 
                    goto Done;
                }
            }

            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPNAME, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                if ( FAILED( hr = SetVariantAsBSTR( pbstrName, dwLen, pbData ) ) )
                { 
                    goto Done;
                }
                free( pbData );
                pbData = NULL;
            }
            else
            {
                if ( hr != MD_ERROR_DATA_NOT_FOUND ||
                    FAILED( hr = SetVariantAsBSTR( pbstrName, sizeof(L""), (LPBYTE)L"" ) ) )
                { 
                    goto Done;
                }
            }

            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, &dwLen, 
                                           &pbData ) ) )
            {
                if ( FAILED( hr = SetVariantAsLong( plEnabled, *(LPDWORD)pbData ) ) )
                { 
                    goto Done;
                }
                free( pbData );
                pbData = NULL;
            }
            else
            {
                if ( hr != MD_ERROR_DATA_NOT_FOUND ||
                     FAILED( hr = SetVariantAsLong( plEnabled, FALSE ) ) )
                { 
                    goto Done;
                }
                hr = S_OK;
            }


        }

    Done:
        if ( pbData != NULL )
        {
            free( pbData );
            pbData = NULL;
        }
        CloseMd( FALSE );
    }

    return hr;
}

//
// Delete a mapping entry using key
//
HRESULT
CCertMapperMethod::DeleteMapping(
    LONG        lMethod,
    VARIANT     vKey
    )
{
    WCHAR       achIndex[MAX_CERT_KEY_LEN];
    HRESULT     hr;

    if ( SUCCEEDED( hr = OpenMd( L"Cert11/Mappings", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( lMethod, vKey, achIndex )) )
        {
            hr = DeleteMdObject( achIndex );
        }
        CloseMd( TRUE );
    }

    return hr;
}

//
// Set the enable flag on a mapping entry using key
//
HRESULT
CCertMapperMethod::SetEnabled(
    LONG        lMethod,
    VARIANT     vKey,
    LONG        lEnabled
    )
{
    WCHAR       achIndex[MAX_CERT_KEY_LEN];
    HRESULT     hr;

    if ( SUCCEEDED( hr = OpenMd( L"Cert11/Mappings", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( lMethod, vKey, achIndex )) )
        {
            hr = SetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, sizeof(DWORD), (LPBYTE)&lEnabled );
        }
        CloseMd( SUCCEEDED( hr ) );
    }

    return hr;
}

//
// Set the Name on a mapping entry using key
//
HRESULT CCertMapperMethod::SetName(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrName
    )
{
    return SetString( lMethod, vKey, bstrName, MD_MAPNAME );
}

//
// Set a string property on a mapping entry using key
//
HRESULT CCertMapperMethod::SetString(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrName,
    DWORD       dwProp
    )
{
    WCHAR       achIndex[MAX_CERT_KEY_LEN];
    LPSTR       pszName = NULL;
    HRESULT     hr;
    DWORD       dwLen;


    if ( SUCCEEDED( hr = OpenMd( L"Cert11/Mappings", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( lMethod, vKey, achIndex )) )
        {
            hr = SetMdData( achIndex, dwProp, STRING_METADATA, 
                sizeof(WCHAR) * (SysStringLen(bstrName) + 1 ),
                (LPBYTE)bstrName );
        }
        CloseMd( SUCCEEDED( hr ) );
    }

    return hr;
}

//
// Set the Password on a mapping entry using key
//
HRESULT
CCertMapperMethod::SetPwd(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrPwd
    )
{
    return SetString( lMethod, vKey, bstrPwd, MD_MAPNTPWD );
}

//
// Set the NT account name on a mapping entry using key
//
HRESULT
CCertMapperMethod::SetAcct(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrAcct
    )
{
    return SetString( lMethod, vKey, bstrAcct, MD_MAPNTACCT );
}


HRESULT
CCertMapperMethod::OpenMd(
    LPWSTR  pszOpenPath,
    DWORD   dwPermission
    )
{
    HRESULT hr;
    LPWSTR  pszPath;
    UINT    cL = wcslen( m_pszMetabasePath );

    pszPath = (LPWSTR)malloc( (wcslen(pszOpenPath) + 1 + cL + 1)*sizeof(WCHAR) );

    if ( pszPath == NULL )
    {
        return E_OUTOFMEMORY;
    }

    memcpy( pszPath, m_pszMetabasePath, cL * sizeof(WCHAR) );
    if ( cL && m_pszMetabasePath[cL-1] != L'/' && *pszOpenPath && *pszOpenPath != L'/' )
    {
        pszPath[cL++] = L'/';
    }
    wcscpy( pszPath + cL, pszOpenPath );

    hr = OpenAdminBaseKey(
                pszPath,
                dwPermission
                );

    free( pszPath );

    return hr;
}


HRESULT
CCertMapperMethod::CloseMd(
    BOOL fSave
    )
{
    CloseAdminBaseKey();
    m_hmd = NULL;
    
    if ( m_pIABase && fSave )
    {
        m_pIABase->SaveData();
    }

    return S_OK;
}


HRESULT
CCertMapperMethod::DeleteMdObject(
    LPWSTR  pszKey
    )
{
    return m_pIABase->DeleteKey( m_hmd, pszKey );
}


HRESULT
CCertMapperMethod::CreateMdObject(
    LPWSTR  pszKey
    )
{
    return m_pIABase->AddKey( m_hmd, pszKey );
}


HRESULT
CCertMapperMethod::SetMdData( 
    LPWSTR  achIndex, 
    DWORD   dwProp,
    DWORD   dwDataType,
    DWORD   dwDataLen,
    LPBYTE  pbData 
    )
{
    METADATA_RECORD     md;

    md.dwMDDataLen = dwDataLen;
    md.dwMDDataType = dwDataType;
    md.dwMDIdentifier = dwProp;
    md.dwMDAttributes = (dwProp == MD_MAPNTPWD) ? METADATA_SECURE : 0;
    md.pbMDData = pbData;

    return m_pIABase->SetData( m_hmd, achIndex, &md );
}


HRESULT
CCertMapperMethod::GetMdData( 
    LPWSTR  achIndex, 
    DWORD   dwProp,
    DWORD   dwDataType,
    LPDWORD pdwDataLen,
    LPBYTE* ppbData 
    )
{
    HRESULT             hr;
    METADATA_RECORD     md;
    DWORD               dwRequired;

    md.dwMDDataLen = 0;
    md.dwMDDataType = dwDataType;
    md.dwMDIdentifier = dwProp;
    md.dwMDAttributes = 0;
    md.pbMDData = NULL;

    if ( FAILED(hr = m_pIABase->GetData( m_hmd, achIndex, &md, &dwRequired )) )
    {
        if ( hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) )
        {
            if ( (*ppbData = (LPBYTE)malloc(dwRequired)) == NULL )
            {
                return E_OUTOFMEMORY;
            }
            md.pbMDData = *ppbData;
            md.dwMDDataLen = dwRequired;
            hr = m_pIABase->GetData( m_hmd, achIndex, &md, &dwRequired );
            *pdwDataLen = md.dwMDDataLen;
        }
    }
    else
    {
       *pdwDataLen = 0;
       *ppbData = NULL;
    }

    return hr;
}

//
// Locate a mapping entry based on key 
// OpenMd() must be called 1st
//
HRESULT
CCertMapperMethod::Locate(
    LONG    lMethod,
    VARIANT vKey,
    LPWSTR  pszResKey
    )
{
    
    HRESULT     hr;
    PBYTE       pbKeyData = NULL;
    DWORD       cbKeyData =0;
    PBYTE       pbCert = NULL;
    DWORD       cbCert =0;
    DWORD       dwProp;
    LPSTR       pRes;
    DWORD       cRes;
    BOOL        fAddDelim = TRUE;
    VARIANT     vKeyUI4;
    VARIANT     vKeyBSTR;

    WCHAR       achIndex[ METADATA_MAX_NAME_LEN + 1 ];
    DWORD       dwIndex = 0;
    DWORD       cbData = 0;
    PBYTE       pbData = NULL;


    VariantInit( &vKeyUI4 );  
    VariantInit( &vKeyBSTR );  
    if ( lMethod == IISMAPPER_LOCATE_BY_INDEX )
    {
        //
        // Convert index to numeric value VT_UI4 (within variant)
        //

        if ( FAILED( hr = VariantChangeType( &vKeyUI4, &vKey, 0, VT_UI4 ) ) )
        {
            goto Exit;
        }
        if ( V_UI4( &vKeyUI4 ) == 0 )
        {
            // Error PATH_NOT_FOUND chosen for backward compatibility
            // with version IIS5.1 and older
            //
            hr = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
            goto Exit;
        }
        //
        // Index is 1 - based
        //
        hr = m_pIABase->EnumKeys( m_hmd,
                                    L"",
                                    achIndex,
                                    V_UI4( &vKeyUI4 ) - 1
                                    );
        if ( hr == HRESULT_FROM_WIN32( ERROR_NO_MORE_ITEMS ) )
        {
            // Error PATH_NOT_FOUND chosen for backward compatibility
            // with version IIS5.1 and older
            //
            hr = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
        }
        goto Exit;
    }

    //
    // get ptr to data
    //

    

    if ( lMethod == IISMAPPER_LOCATE_BY_CERT )
    {
        // Now this is really wacky. Because of the legacy of the bad 
        // decision in the past the CERT is not enforced to be byte array
        // It can be passed as string. That causes problems with
        // conversions between byte array and UNICODE and back 
        // but we got to stick with it for compatibility with previous versions.
        //
        
        if ( FAILED( hr = GetBlobFromVariant( &vKey, &pbCert, &cbCert ) ) )
        {
            goto Exit;
        }
        pbKeyData = pbCert;
        cbKeyData = cbCert;
    }
    else
    {
        //
        // the rest of the lookups (by mapping, name or by account name)
        // assumes string
        //
        if ( FAILED( hr = VariantChangeType( &vKeyBSTR, &vKey, 0, VT_BSTR ) ) )
        {
            goto Exit;
        }
        pbKeyData = (PBYTE) V_BSTR( &vKeyBSTR );
        cbKeyData = ( SysStringLen(V_BSTR( &vKeyBSTR )) + 1 ) * sizeof(WCHAR);
    }
    

    //
    // enumerate all entries to find match
    // Now this is really slooow if many mappings are configured
    //
    for(;;)
    {
        hr = m_pIABase->EnumKeys(  m_hmd,
                                     L"",
                                     achIndex,
                                     dwIndex
                                     );
        if ( FAILED( hr ) )
        {
            if ( hr == HRESULT_FROM_WIN32( ERROR_NO_MORE_ITEMS ) )
            {
                // Error PATH_NOT_FOUND chosen for backward compatibility
                // with version IIS5.1 and older
                //
                hr = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
            }
            goto Exit;
        }
        
        switch ( lMethod )
        {
        case IISMAPPER_LOCATE_BY_CERT:
            hr = GetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, &cbData, 
                                                  &pbData );
            if ( hr == MD_ERROR_DATA_NOT_FOUND )
            {
                cbData = 0;
                pbData = NULL;
            }
            else if ( FAILED( hr ) )
            {
                // goto next entry
                break;
            }
            //
            // compare if key is matching value read from metabase
            //

            if ( cbData == cbKeyData )
            {
                if ( ( cbData == 0 ) || 
                     memcmp( pbKeyData, pbData, cbData ) == 0 )
                {
                    // we found match
                    hr = S_OK;
                    goto Exit;
                }
            }
            break;
        case IISMAPPER_LOCATE_BY_ACCT:
            hr = GetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, &cbData, 
                                              &pbData );
            if ( hr == MD_ERROR_DATA_NOT_FOUND )
            {
                cbData = sizeof(L"");
                pbData = (PBYTE) L"";
            }
            else if ( FAILED( hr ) )
            {
                // goto next entry
                break;
            }

            if ( cbData == cbKeyData )
            {
                if ( _wcsicmp( (WCHAR *) pbKeyData, (WCHAR *) pbData ) == 0 )
                {
                    // we found match
                    hr = S_OK;
                    goto Exit;
                }
            }
            
            break;
        case IISMAPPER_LOCATE_BY_NAME:
            hr = GetMdData( achIndex, MD_MAPNAME, STRING_METADATA, &cbData, 
                                              &pbData );
            if ( hr == MD_ERROR_DATA_NOT_FOUND )
            {
                cbData = sizeof(L"");
                pbData = (PBYTE) L"";
            }
            else if ( FAILED( hr ) )
            {
                // goto next entry
                break;
            }

            if ( cbData == cbKeyData )
            {
                if ( _wcsicmp( (WCHAR *) pbKeyData, (WCHAR *) pbData ) == 0 )
                {
                    // we found match
                    hr = S_OK;
                    goto Exit;
                }
            }

            break;
        }
        if ( pbData != NULL )
        {
            free( pbData );
            pbData = NULL;
        }

        dwIndex++;
    }

Exit:

    if ( pbData != NULL )
    {
        free( pbData );
        pbData = NULL;
    }
    
    if ( pbCert != NULL )
    {
        free( pbCert );
        pbCert = NULL;
    }

    if ( SUCCEEDED( hr ) )
    {
        wcsncpy( pszResKey, achIndex, METADATA_MAX_NAME_LEN + 1 );
        pszResKey[ METADATA_MAX_NAME_LEN ] ='\0';
    }
    VariantClear( &vKeyUI4 );  
    VariantClear( &vKeyBSTR );

    return hr;
}


//
// GetStringFromBSTR: Allocate string buffer from BSTR
//
// Arguments:
//
//    bstr - bstr to convert from
//    psz - updated with ptr to buffer, to be freed with free()
//    pdwLen - updated with strlen(string), incremented by 1 if fAddDelimInCount is TRUE
//    fAddDelimInCount - TRUE to increment *pdwLen 
//
HRESULT CCertMapperMethod::GetStringAFromBSTR( 
    BSTR    bstr,
    LPSTR*  psz,
    LPDWORD pdwLen,
    BOOL    fAddDelimInCount
    )
{
    UINT    cch = SysStringLen(bstr);
    UINT    cchT;

    // include NULL terminator

    *pdwLen = cch + (fAddDelimInCount ? 1 : 0);

    CHAR *szNew = (CHAR*)malloc((2 * cch) + 1);         // * 2 for worst case DBCS string
    if (szNew == NULL)
    {
        return E_OUTOFMEMORY;
    }

    cchT = WideCharToMultiByte(CP_ACP, 0, bstr, cch + 1, szNew, (2 * cch) + 1, NULL, NULL);

    *psz = szNew;

    return NOERROR;
}

//
// GetStringFromVariant: Allocate string buffer from BSTR
//
// Arguments:
//
//    pVar - variant to convert from. Recognizes BSTR, VT_ARRAY|VT_UI1, ByRef or ByVal
//    psz - updated with ptr to buffer, to be freed with FreeString()
//    pdwLen - updated with size of input, incremented by 1 if fAddDelimInCount is TRUE
//    fAddDelimInCount - TRUE to increment *pdwLen 
//
HRESULT CCertMapperMethod::GetBlobFromVariant( 
    VARIANT*    pVar,
    LPBYTE*     ppbOut,
    LPDWORD     pcbOut,
    BOOL        fAddDelim
    )
{
    LPBYTE  pbV = NULL;
    UINT    cV;
    HRESULT hr;
    WORD    vt = V_VT(pVar);
    BOOL    fByRef = FALSE;
    VARIANT vOut;

    // Set out params to 0
    *ppbOut    = NULL;
    *pcbOut    = 0;

    VariantInit( &vOut );

    if ( vt & VT_BYREF )
    {
        vt &= ~VT_BYREF;
        fByRef = TRUE;
    }

    // if pVar is BSTR, convert to multibytes

    if ( vt == VT_VARIANT )
    {
        pVar = (VARIANT*)V_BSTR(pVar);
        vt = V_VT(pVar);
        if ( fByRef = vt & VT_BYREF )
        {
            vt &= ~VT_BYREF;
        }
    }

    if ( vt == VT_BSTR )
    {
        hr = GetStringAFromBSTR( fByRef ? 
                                    *(BSTR*)V_BSTR(pVar) :
                                    V_BSTR(pVar), 
                                  (LPSTR *)ppbOut, 
                                  pcbOut,
                                  FALSE );
    }
    else if( vt == (VT_ARRAY | VT_UI1) )
    {
        long        lBound, uBound, lItem;
        BYTE        bValue;
        SAFEARRAY*  pSafeArray;

   
        // array of VT_UI1 (probably OctetString)
   
        pSafeArray  = fByRef ? *(SAFEARRAY**)V_BSTR(pVar) : V_ARRAY( pVar );

        hr = SafeArrayGetLBound(pSafeArray, 1, &lBound);
        hr = SafeArrayGetUBound(pSafeArray, 1, &uBound);

        cV = uBound - lBound + 1;

        if ( !(pbV = (LPBYTE)malloc( cV )) )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = S_OK;

        for( lItem = lBound; lItem <= uBound ; lItem++ )
        {
            hr  = SafeArrayGetElement( pSafeArray, &lItem, &bValue );
            if( FAILED( hr ) )
            {
                break;
            }
            pbV[lItem-lBound] = bValue;
        }

        *ppbOut = pbV;
        *pcbOut = cV;
    }
    else if( vt == (VT_ARRAY | VT_VARIANT) )
    {
        long        lBound, uBound, lItem;
        VARIANT     vValue;
        BYTE        bValue;
        SAFEARRAY*  pSafeArray;

   
        // array of VT_VARIANT (probably VT_I4 )
   
        pSafeArray  = fByRef ? *(SAFEARRAY**)V_BSTR(pVar) : V_ARRAY( pVar );

        hr = SafeArrayGetLBound(pSafeArray, 1, &lBound);
        hr = SafeArrayGetUBound(pSafeArray, 1, &uBound);

        cV = uBound - lBound + 1;

        if ( !(pbV = (LPBYTE)malloc( cV )) )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = S_OK;

        for( lItem = lBound; lItem <= uBound ; lItem++ )
        {
            hr  = SafeArrayGetElement( pSafeArray, &lItem, &vValue );
            if( FAILED( hr ) )
            {
                break;
            }
            if ( V_VT(&vValue) == VT_UI1 )
            {
                bValue = V_UI1(&vValue);
            }
            else if ( V_VT(&vValue) == VT_I2 )
            {
                bValue = (BYTE)V_I2(&vValue);
            }
            else if ( V_VT(&vValue) == VT_I4 )
            {
                bValue = (BYTE)V_I4(&vValue);
            }
            else
            {
                bValue = 0;
            }
            pbV[lItem-lBound] = bValue;
        }

        *ppbOut = pbV;
        *pcbOut = cV;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

Exit:
    VariantClear( &vOut );

    return hr;
}


HRESULT CCertMapperMethod::SetBSTR( 
    BSTR*   pbstrRet,
    DWORD   cch, 
    LPBYTE  sz 
    )
{
    BSTR bstrRet;
    
    if (sz == NULL)
    {
        *pbstrRet = NULL;
        return(NOERROR);
    }
        
    // Allocate a string of the desired length
    // SysAllocStringLen allocates enough room for unicode characters plus a null
    // Given a NULL string it will just allocate the space
    bstrRet = SysAllocStringLen(NULL, cch);
    if (bstrRet == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    // If we were given "", we will have cch=0.  return the empty bstr
    // otherwise, really copy/convert the string
    // NOTE we pass -1 as 4th parameter of MultiByteToWideChar for DBCS support

    if (cch != 0)
    {
        UINT cchTemp = 0;
        if (MultiByteToWideChar(CP_ACP, 0, (LPSTR)sz, -1, bstrRet, cch+1) == 0)
        {
            SysFreeString(bstrRet);
            return(HRESULT_FROM_WIN32(GetLastError()));
        }

        // If there are some DBCS characters in the sz(Input), then, the character count of BSTR(DWORD) is 
        // already set to cch(strlen(sz)) in SysAllocStringLen(NULL, cch), we cannot change the count, 
        // and later call of SysStringLen(bstr) always returns the number of characters specified in the
        // cch parameter at allocation time.  Bad, because one DBCS character(2 bytes) will convert
        // to one UNICODE character(2 bytes), not 2 UNICODE characters(4 bytes).
        // Example: For input sz contains only one DBCS character, we want to see SysStringLen(bstr) 
        // = 1, not 2.
        bstrRet[cch] = 0;
        cchTemp = wcslen(bstrRet);
        if (cchTemp < cch)
        {
            BSTR bstrTemp = SysAllocString(bstrRet);
            SysFreeString(bstrRet);
            if (NULL == bstrTemp)
            {
                return (E_OUTOFMEMORY);
            }
            bstrRet = bstrTemp; 
            cch = cchTemp;
        }
    }

    bstrRet[cch] = 0;
    *pbstrRet = bstrRet;

    return(NOERROR);
}

HRESULT CCertMapperMethod::Init( 
    LPCWSTR  pszMetabasePath 
    )
{
    DBG_ASSERT(pszMetabasePath != NULL);

    UINT cL;

    cL = wcslen( pszMetabasePath );
    while ( cL && pszMetabasePath[cL-1] != L'/' && pszMetabasePath[cL-1] != L'\\' )
    {
        --cL;
    }
    if ( m_pszMetabasePath = (LPWSTR)malloc( cL*sizeof(WCHAR)  ) )
    {
        memcpy( m_pszMetabasePath, pszMetabasePath, cL * sizeof(WCHAR) );
    }
    else
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


HRESULT CCertMapperMethod::SetVariantAsByteArray(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
{
    SAFEARRAYBOUND  rgsabound[1];
    BYTE *          pbData = NULL;

    // Set the variant type of the output parameter

    V_VT(pvarReturn) = VT_ARRAY|VT_UI1;
    V_ARRAY(pvarReturn) = NULL;

    // Allocate a SafeArray for the data

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cbLen;

    V_ARRAY(pvarReturn) = SafeArrayCreate(VT_UI1, 1, rgsabound);
    if (V_ARRAY(pvarReturn) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(SafeArrayAccessData(V_ARRAY(pvarReturn), (void **) &pbData)))
    {
        return E_UNEXPECTED;
    }

    memcpy(pbData, pbIn, cbLen );

    SafeArrayUnaccessData(V_ARRAY(pvarReturn));

    return NOERROR;
}


HRESULT CCertMapperMethod::SetVariantAsBSTR(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
{
    V_VT(pvarReturn) = VT_BSTR;
    return SetBSTR( &V_BSTR(pvarReturn), cbLen, pbIn );
}


HRESULT CCertMapperMethod::SetVariantAsLong(
    VARIANT*    pvarReturn, 
    DWORD       dwV
    )
{
    V_VT(pvarReturn) = VT_I4;
    V_I4(pvarReturn) = dwV;

    return S_OK;
}

HRESULT CCertMapperMethod::OpenAdminBaseKey(
    LPWSTR pszPathName,
    DWORD dwAccessType
    )
{
    if(m_hmd)
        CloseAdminBaseKey();
    
    HRESULT t_hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        pszPathName,
        dwAccessType,
        DEFAULT_TIMEOUT_VALUE,       // 30 seconds
        &m_hmd 
        );

    if(FAILED(t_hr))
        m_hmd = NULL;

    return t_hr;
}


VOID CCertMapperMethod::CloseAdminBaseKey()
{
    if(m_hmd && m_pIABase)
    {
        m_pIABase->CloseKey(m_hmd);
        m_hmd = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\enum.h ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    enum.h.cpp

Abstract:

    Enumerates metabase tree.

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#ifndef _enum_h_
#define _enum_h_

#include "WbemObjectSink.h"

#include <genlex.h>
#include "sqllex.h"
#include <sql_1ext.h>

class CEnum
{
public:
    CEnum();
    ~CEnum();
    
    void Init(
        IWbemObjectSink FAR*, 
        CWbemServices*, 
        ParsedObjectPath*, 
        LPWSTR, 
        WMI_ASSOCIATION*,
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* pExp=NULL);
    
    void Recurse(
        LPCWSTR, 
        METABASE_KEYTYPE*, 
        LPCWSTR, 
        LPCWSTR, 
        METABASE_KEYTYPE*);

private:
    bool ContinueRecurse(METABASE_KEYTYPE*, METABASE_KEYTYPE*);
    void SetObjectPath(LPCWSTR, LPCWSTR, IWbemClassObject*);
    void DoPing(LPCWSTR, LPCWSTR, LPCWSTR);
    void PingAssociation(LPCWSTR);
    void PingObject();
    void DoPingAdminACL(METABASE_KEYTYPE*, LPCWSTR, LPCWSTR);
    void PingAssociationAdminACL(LPCWSTR);
    void EnumACE(LPCWSTR);
    void DoPingIPSecurity(METABASE_KEYTYPE*, LPCWSTR, LPCWSTR);
    void PingAssociationIPSecurity(LPCWSTR);
    
    CMetabase                       m_metabase;
    CWbemObjectSink*                m_pInstMgr;
    CWbemServices*                  m_pNamespace;
    WMI_ASSOCIATION*                m_pAssociation;
    ParsedObjectPath*               m_pParsedObject;
    METADATA_HANDLE                 m_hKey;
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* m_pExp;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\enum.cpp ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    enum.cpp

Abstract:

    Enumerates metabase tree.

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/


#include "iisprov.h"
#include "enum.h"
#include "ipsecurity.h"
#include "adminacl.h"
#include "WbemObjectSink.h"
#include "instancehelper.h"
#include "SmartPointer.h"

#include <adserr.h>

extern CDynSchema* g_pDynSch;


///////////////////////////////////////
//
// CEnum class
//
///////////////////////////////////////

CEnum::CEnum()
{
    m_pInstMgr        = NULL;
    m_pNamespace      = NULL;
    m_pAssociation    = NULL;
    m_pParsedObject   = NULL;
    m_hKey            = NULL;
}

CEnum::~CEnum()
{
    if(m_hKey)
        m_metabase.CloseKey(m_hKey);

    delete m_pInstMgr;
}

void CEnum::Init(
    IWbemObjectSink FAR*            a_pHandler,
    CWbemServices*                  a_pNamespace,
    ParsedObjectPath*               a_pParsedObject,
    LPWSTR                          a_pszKey,
    WMI_ASSOCIATION*                a_pAssociation,
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* a_pExp)            // default(NULL)
{
    if (!a_pHandler || !a_pNamespace || !a_pParsedObject)
        throw WBEM_E_FAILED;

    m_pInstMgr = new CWbemObjectSink(a_pHandler);
    if(!m_pInstMgr)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }

    m_pNamespace      = a_pNamespace;
    m_pAssociation    = a_pAssociation;
    m_pParsedObject   = a_pParsedObject;
    m_pExp            = a_pExp;

    m_hKey = m_metabase.OpenKey(a_pszKey, false);  // read only
}

void CEnum::SetObjectPath(
    LPCWSTR              a_pszPropertyName,
    LPCWSTR              a_pszObjectPath,
    IWbemClassObject*    a_pObj
    )
{
    _bstr_t bstr(a_pszPropertyName);
    _variant_t v(a_pszObjectPath);

    HRESULT hr = a_pObj->Put(bstr, 0, &v, 0);
    THROW_ON_ERROR(hr);
}

void CEnum::PingObject()
{
    CComPtr<IWbemClassObject> spObj;

    CInstanceHelper InstanceHelper(m_pParsedObject, m_pNamespace);

    DBG_ASSERT(!InstanceHelper.IsAssoc());

    try
    {
        InstanceHelper.GetInstance(false, &m_metabase, &spObj, m_pExp);
    }
    catch(HRESULT hr)
    {
        if(hr != E_ADS_PROPERTY_NOT_SUPPORTED && hr != WBEM_E_NOT_FOUND)
        {
            throw;
        }
    }

    if(spObj != NULL)
    {
        m_pInstMgr->Indicate(spObj);
    }
}

void CEnum::PingAssociation(
    LPCWSTR a_pszLeftKeyPath
    )
{
    HRESULT                   hr;
    CComPtr<IWbemClassObject> spObj;
    CComPtr<IWbemClassObject> spClass;
    TSmartPointerArray<WCHAR> swszObjectPath;
    CObjectPathParser         PathParser(e_ParserAcceptRelativeNamespace);

    if( m_pAssociation->pType != &WMI_ASSOCIATION_TYPE_DATA::s_ElementSetting &&
        m_pAssociation->pType != &WMI_ASSOCIATION_TYPE_DATA::s_Component )
    {
        return;
    }

    hr = m_pNamespace->GetObject(
        m_pAssociation->pszAssociationName,
        0, 
        NULL, 
        &spClass, 
        NULL
        );
    THROW_ON_ERROR(hr);

    hr = spClass->SpawnInstance(0, &spObj);
    THROW_ON_ERROR(hr);

    //
    // first right side
    //
    if (!m_pParsedObject->SetClassName(m_pAssociation->pcRight->pszClassName))
        throw WBEM_E_FAILED;

    if (PathParser.Unparse(m_pParsedObject,&swszObjectPath))
        throw WBEM_E_FAILED;

    SetObjectPath(m_pAssociation->pType->pszRight, swszObjectPath, spObj);
    swszObjectPath.Delete();

    //
    // then left side
    //
    if (m_pAssociation->pType == &WMI_ASSOCIATION_TYPE_DATA::s_Component)
    {
        // clear keyref first
        m_pParsedObject->ClearKeys();
 
        // add a keyref
        _variant_t vt;            
        if(m_pAssociation->pcLeft->pkt == &METABASE_KEYTYPE_DATA::s_IIsComputer)
            vt = L"LM";              // IIsComputer.Name = "LM"
        else
            vt = a_pszLeftKeyPath;

        THROW_ON_FALSE(m_pParsedObject->AddKeyRef(m_pAssociation->pcLeft->pszKeyName,&vt));
    }

    if (!m_pParsedObject->SetClassName(m_pAssociation->pcLeft->pszClassName))
        throw WBEM_E_FAILED;

    if (PathParser.Unparse(m_pParsedObject,&swszObjectPath))
        throw WBEM_E_FAILED;

    SetObjectPath(m_pAssociation->pType->pszLeft, swszObjectPath, spObj);
    swszObjectPath.Delete();

    m_pInstMgr->Indicate(spObj);
}

void CEnum::DoPing(
    LPCWSTR a_pszKeyName,
    LPCWSTR a_pszKeyPath,
    LPCWSTR a_pszParentKeyPath
    )
{
    // add keyref
    _variant_t v(a_pszKeyPath);
    THROW_ON_FALSE(m_pParsedObject->AddKeyRef(a_pszKeyName,&v));

    // ping
    if (!m_pAssociation) 
        PingObject();
    else
        PingAssociation(a_pszParentKeyPath);
 
    // clear keyref
    m_pParsedObject->ClearKeys();
}

void CEnum::Recurse(
    LPCWSTR           a_pszMetabasePath, // Current metabase location relative to m_hKey
    METABASE_KEYTYPE* a_pktParentKeyType,// Current keytype
    LPCWSTR           a_pszLeftPath,
    LPCWSTR           a_pszWmiPrimaryKey,// "Name" - WMI only - nothing to do with MB
    METABASE_KEYTYPE* a_pktSearch		 // the kt we are looking for
    )
{
    DWORD   i = 0;
    HRESULT hr;
    WCHAR   szSubKey[METADATA_MAX_NAME_LEN];
    METABASE_KEYTYPE* pktCurrent;

    DBGPRINTF((DBG_CONTEXT, "Recurse (Path = %ws, Left = %ws)\n", a_pszMetabasePath, a_pszLeftPath));

    do 
    {
        pktCurrent = a_pktSearch;

        //
        // Enumerate all subkeys of a_pszMetabasePath until we find a potential
        // (grand*)parent of pktCurrent
        //
        hr = m_metabase.EnumKeys(
                m_hKey,
                a_pszMetabasePath,
                szSubKey,
                &i,
                pktCurrent
                );
        i++;

        if( hr == ERROR_SUCCESS)
        {
            _bstr_t bstrMetabasePath;
            if(a_pszMetabasePath)
            {
                bstrMetabasePath = a_pszMetabasePath;
                bstrMetabasePath += L"/";
            }
            bstrMetabasePath += szSubKey;

            //
            // With the exception of AdminACL, AdminACE, IPSecurity, we will only
            // ping the object if we have found a keytype match in the metabase.
            //
            if( pktCurrent == a_pktSearch &&
                !( m_pAssociation && 
                   m_pAssociation->pType == &WMI_ASSOCIATION_TYPE_DATA::s_Component && 
                   m_pAssociation->pcLeft->pkt != a_pktParentKeyType
                   )
                )
            {
                DoPing(a_pszWmiPrimaryKey, bstrMetabasePath, a_pszLeftPath);
            }
            else if( a_pktSearch == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||   // AdminACL
                a_pktSearch == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE
                     )
            {
				if( (m_pAssociation == NULL || // should never be
					 m_pAssociation->pType != &WMI_ASSOCIATION_TYPE_DATA::s_AdminACL ||
					 m_pAssociation->pcLeft->pkt == pktCurrent ||
					 m_pAssociation == &WMI_ASSOCIATION_DATA::s_AdminACLToACE) )
                {
                    DoPingAdminACL(a_pktSearch, a_pszWmiPrimaryKey, bstrMetabasePath);
                }
            }
            else if( a_pktSearch == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity )   // IPSecurity
            {
                if( !(m_pAssociation &&
                      m_pAssociation->pType == &WMI_ASSOCIATION_TYPE_DATA::s_IPSecurity && 
                      m_pAssociation->pcLeft->pkt != pktCurrent
                      )
                    )
                {
                    DoPingIPSecurity(a_pktSearch, a_pszWmiPrimaryKey, bstrMetabasePath);
                }
            }
            
            // recusive
            if(ContinueRecurse(pktCurrent, a_pktSearch))
            {
                Recurse(
                    bstrMetabasePath, 
                    pktCurrent, 
                    bstrMetabasePath, 
                    a_pszWmiPrimaryKey, 
                    a_pktSearch);
            }
        }

    }while(hr == ERROR_SUCCESS);

    DBGPRINTF((DBG_CONTEXT, "Recurse Exited\n"));
}

// DESC: You are looking for a_eKeyType by traversing thru the tree. You are
//       currently at a_eParentKeyType and need to determine if you should keep
//       on going.
// COMM: This seems very similar to CMetabase::CheckKey
bool CEnum::ContinueRecurse(
    METABASE_KEYTYPE*  a_pktParentKeyType,
    METABASE_KEYTYPE*  a_pktKeyType
    )
{
    bool bRet = false;

    if( a_pktKeyType == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||
        a_pktKeyType == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE ||
        a_pktKeyType == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity )
    {
        return true;
    }

    return g_pDynSch->IsContainedUnder(a_pktParentKeyType, a_pktKeyType);

    /*switch(a_pktKeyType)
    {
    case &METABASE_KEYTYPE_DATA::s_IIsLogModule:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsLogModules )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsFtpInfo:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpService )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsFtpServer:
         if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpService )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsWebInfo:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsFilters:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsFilter:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFilters 
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsCompressionSchemes:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFilters 
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsCompressionScheme:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFilters ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsCompressionSchemes )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsWebServer:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsCertMapper:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer 
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsWebDirectory:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsWebFile:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory
            )
            bRet = true;
        break;

    case TYPE_AdminACL:
    case TYPE_AdminACE:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir
            )
            bRet = true;
        break;

    case TYPE_IPSecurity:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir
            )
            bRet = true;
        break;

    default:
        break;
    }*/

    //return bRet;
    //return true;
}

void CEnum::DoPingAdminACL(
    METABASE_KEYTYPE*  a_pktKeyType, // Search key
    LPCWSTR            a_pszKeyName, // Wmi Primary key - nothing to do with MB
    LPCWSTR            a_pszKeyPath  // Current metabase path relative to m_hKey
    )
{
    // add keyref
    _variant_t v(a_pszKeyPath);
    THROW_ON_FALSE(m_pParsedObject->AddKeyRef(a_pszKeyName,&v));

    if(a_pktKeyType == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE)
    {
        EnumACE(a_pszKeyPath);
    }
    else if(a_pktKeyType == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL)
    {
        // ping
        if (!m_pAssociation) 
            PingObject();
        else
            PingAssociationAdminACL(a_pszKeyPath);
    }
    
    // clear keyref
    m_pParsedObject->ClearKeys();
}


// for AdminACL
void CEnum::EnumACE(
    LPCWSTR pszKeyPath
    )
{
    HRESULT hr = S_OK;
    _variant_t var;
    CComPtr<IEnumVARIANT> spEnum;
    ULONG   lFetch;
    CComBSTR bstrTrustee;
    IDispatch* pDisp = NULL;
    CComPtr<IADsAccessControlEntry> spACE;
    _bstr_t bstrMbPath;
    WMI_CLASS* pWMIClass;

    // get the metabase path of the object
    BOOL fClass = FALSE;
    if(m_pAssociation)
        fClass = CUtils::GetClass(m_pAssociation->pcLeft->pszClassName,&pWMIClass);
    else
        fClass = CUtils::GetClass(m_pParsedObject->m_pClass,&pWMIClass);
    
    if(!fClass)
        return;

    CUtils::GetMetabasePath(NULL,m_pParsedObject,pWMIClass,bstrMbPath);
   
    // open ADSI
    CAdminACL objACL;
    hr = objACL.OpenSD(bstrMbPath, m_metabase);
    if(SUCCEEDED(hr))
        hr = objACL.GetACEEnum(&spEnum);
    if ( FAILED(hr) )
        return;

    //////////////////////////////////////////////
    // Enumerate ACEs
    //////////////////////////////////////////////
    hr = spEnum->Next( 1, &var, &lFetch );
    while( hr == S_OK )
    {
        if ( lFetch == 1 )
        {
            if ( VT_DISPATCH != V_VT(&var) )
            {
                break;
            }

            pDisp = V_DISPATCH(&var);

            /////////////////////////////
            // Get the individual ACE
            /////////////////////////////
            hr = pDisp->QueryInterface( 
                IID_IADsAccessControlEntry, 
                (void**)&spACE 
                ); 

            if ( SUCCEEDED(hr) )
            {
                hr = spACE->get_Trustee(&bstrTrustee);

                if( SUCCEEDED(hr) )
                {
                    // add keyref
                    _variant_t v(bstrTrustee);
                    //m_pParsedObject->RemoveKeyRef(L"Trustee");
                    THROW_ON_FALSE(m_pParsedObject->AddKeyRefEx(L"Trustee",&v));

                    // ping
                    if (!m_pAssociation) 
                        PingObject();
                    else
                        PingAssociationAdminACL(pszKeyPath);
                }

                bstrTrustee = (LPWSTR)NULL;
                spACE       = NULL;
            }
        }

        hr = spEnum->Next( 1, &var, &lFetch );
    }
}


void CEnum::PingAssociationAdminACL(
    LPCWSTR a_pszLeftKeyPath
    )
{
    HRESULT                   hr;
    CComPtr<IWbemClassObject> spObj;
    CComPtr<IWbemClassObject> spClass;
    TSmartPointerArray<WCHAR> swszObjectPath;
    CObjectPathParser    PathParser(e_ParserAcceptRelativeNamespace);
    _bstr_t              bstrMbPath;
    WMI_CLASS*           pWMIClass;


    if(m_pAssociation->pType != &WMI_ASSOCIATION_TYPE_DATA::s_AdminACL)
    {
        return;
    }

    // get the metabase path of the object
    if (CUtils::GetClass(m_pAssociation->pcLeft->pszClassName,&pWMIClass))
    {
        CUtils::GetMetabasePath(NULL,m_pParsedObject,pWMIClass,bstrMbPath);
    }
    else
    {
        return;
    }

    // check if AdminACL existed
    CAdminACL objACL;
    hr = objACL.OpenSD(bstrMbPath, m_metabase);
    objACL.CloseSD();
    if(FAILED(hr))
    {
        return;
    }
    

    hr = m_pNamespace->GetObject(
        m_pAssociation->pszAssociationName,
        0, 
        NULL, 
        &spClass, 
        NULL
        );
    THROW_ON_ERROR(hr);

    hr = spClass->SpawnInstance(0, &spObj);
    THROW_ON_ERROR(hr);

    //
    // first right side
    //
    if (!m_pParsedObject->SetClassName(m_pAssociation->pcRight->pszClassName))
    {
        throw WBEM_E_FAILED;
    }

    if (PathParser.Unparse(m_pParsedObject,&swszObjectPath))
    {
        throw WBEM_E_FAILED;
    }

    SetObjectPath(m_pAssociation->pType->pszRight, swszObjectPath, spObj);
    swszObjectPath.Delete();

    //
    // then left side
    //
	if(m_pAssociation == &WMI_ASSOCIATION_DATA::s_AdminACLToACE)
    {
        // clear keyref first
        m_pParsedObject->ClearKeys();
 
        // add a keyref
        _variant_t vt = a_pszLeftKeyPath;
        THROW_ON_FALSE(m_pParsedObject->AddKeyRef(m_pAssociation->pcLeft->pszKeyName,&vt));
    }

    if (!m_pParsedObject->SetClassName(m_pAssociation->pcLeft->pszClassName))
    {
        throw WBEM_E_FAILED;
    }

    if (PathParser.Unparse(m_pParsedObject,&swszObjectPath))
    {
        throw WBEM_E_FAILED;
    }

    SetObjectPath(m_pAssociation->pType->pszLeft, swszObjectPath, spObj);
    swszObjectPath.Delete();

    m_pInstMgr->Indicate(spObj);
}


// for IPSecurity
void CEnum::DoPingIPSecurity(
    METABASE_KEYTYPE*  a_pktKeyType,
    LPCWSTR            a_pszKeyName,
    LPCWSTR            a_pszKeyPath
    )
{
    // add keyref
    _variant_t v(a_pszKeyPath);
    THROW_ON_FALSE(m_pParsedObject->AddKeyRef(a_pszKeyName,&v));

    // ping
    if (!m_pAssociation) 
        PingObject();
    else
        PingAssociationIPSecurity(a_pszKeyPath);
    
    // clear keyref
    m_pParsedObject->ClearKeys();
}

// for IPSecurity
void CEnum::PingAssociationIPSecurity(
    LPCWSTR a_pszLeftKeyPath
    )
{
    HRESULT                   hr;
    CComPtr<IWbemClassObject> spObj;
    CComPtr<IWbemClassObject> spClass;
    TSmartPointerArray<WCHAR> swszObjectPath;
    CObjectPathParser         PathParser(e_ParserAcceptRelativeNamespace);
    _bstr_t                   bstrMbPath;
    WMI_CLASS*                pWMIClass;


    if(m_pAssociation->pType != &WMI_ASSOCIATION_TYPE_DATA::s_IPSecurity)
        return;

    // get the metabase path of the object
    if (CUtils::GetClass(m_pAssociation->pcLeft->pszClassName,&pWMIClass))
    {
        CUtils::GetMetabasePath(NULL,m_pParsedObject,pWMIClass,bstrMbPath);
    }
    else
        return;

    // check if IPSecurity existed
    CIPSecurity objIPsec;
    hr = objIPsec.OpenSD(bstrMbPath, m_metabase);
    objIPsec.CloseSD();
    if(FAILED(hr))
        return;
    
    hr = m_pNamespace->GetObject(
        m_pAssociation->pszAssociationName,
        0, 
        NULL, 
        &spClass, 
        NULL
        );
    THROW_ON_ERROR(hr);

    hr = spClass->SpawnInstance(0, &spObj);
    THROW_ON_ERROR(hr);

    //
    // first right side
    //
    if (!m_pParsedObject->SetClassName(m_pAssociation->pcRight->pszClassName))
        throw WBEM_E_FAILED;

    if (PathParser.Unparse(m_pParsedObject,&swszObjectPath))
    {
        throw WBEM_E_FAILED;
    }

    SetObjectPath(m_pAssociation->pType->pszRight, swszObjectPath, spObj);
    swszObjectPath.Delete();

    //
    // then left side
    //
    if (!m_pParsedObject->SetClassName(m_pAssociation->pcLeft->pszClassName))
        throw WBEM_E_FAILED;

    if (PathParser.Unparse(m_pParsedObject,&swszObjectPath))
        throw WBEM_E_FAILED;

    SetObjectPath(m_pAssociation->pType->pszLeft, swszObjectPath, spObj);
    swszObjectPath.Delete();

    m_pInstMgr->Indicate(spObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\globdata.cpp ===
#include "iisprov.h"

//
// Initialize WMI_ASSOCIATION_TYPE_DATA
//
WMI_ASSOCIATION_TYPE WMI_ASSOCIATION_TYPE_DATA::s_ElementSetting = 
    { L"Element", L"Setting", g_wszElementSettingAssocParent, g_wszExtElementSettingAssocParent };
WMI_ASSOCIATION_TYPE WMI_ASSOCIATION_TYPE_DATA::s_Component = 
    { L"GroupComponent", L"PartComponent", g_wszGroupPartAssocParent, g_wszExtGroupPartAssocParent };
WMI_ASSOCIATION_TYPE WMI_ASSOCIATION_TYPE_DATA::s_AdminACL =
    { L"GroupComponent", L"PartComponent", g_wszGroupPartAssocParent, g_wszExtGroupPartAssocParent };
WMI_ASSOCIATION_TYPE WMI_ASSOCIATION_TYPE_DATA::s_IPSecurity =
    { L"Element", L"Setting", g_wszElementSettingAssocParent, g_wszExtElementSettingAssocParent };

//
// Initialize METABASE_KEYTYPE_DATA
//
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsApplicationPool = 
{
    L"IIsApplicationPool", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsApplicationPools = 
{
    L"IIsApplicationPools", NULL, L"/LM/w3svc/AppPools"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsCertMapper = 
{
    L"IIsCertMapper", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsCompressionScheme = 
{
    L"IIsCompressionScheme", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsCompressionSchemes = 
{
    L"IIsCompressionSchemes", NULL, L"/LM/w3svc/Filters/Compression/Parameters"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsComputer = 
{
    L"IIsComputer", NULL, L"/LM"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsCustomLogModule = 
{
    L"IIsCustomLogModule", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsFilter = 
{
    L"IIsFilter", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsFilters = 
{
    L"IIsFilters", NULL, L"/LM/w3svc/filters"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsFtpInfo = 
{
    L"IIsFtpInfo", NULL, L"/LM/msftpsvc/info"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsFtpServer = 
{
    L"IIsFtpServer", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsFtpService = 
{
    L"IIsFtpService", NULL, L"/LM/msftpsvc"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir = 
{
    L"IIsFtpVirtualDir", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsImapInfo = 
{
    L"IIsImapInfo", NULL, L"/LM/imapsvc/info"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsImapService = 
{
    L"IIsImapService", NULL, L"/LM/imapsvc"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsLogModule = 
{
    L"IIsLogModule", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsLogModules = 
{
    L"IIsLogModules", NULL, L"/LM/Logging"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsMimeMap = 
{
    L"IIsMimeMap", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsNntpInfo = 
{
    L"IIsNntpInfo", NULL, L"/LM/nntpsvc/info"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsNntpService = 
{
    L"IIsNntpService", NULL, L"/LM/nntpsvc"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsObject = 
{
    L"IIsObject", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsPop3Info = 
{
    L"IIsPop3Info", NULL, L"/LM/pop3svc/info"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsPop3Service = 
{
    L"IIsPop3Service", NULL, L"/LM/pop3svc"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsSmtpInfo = 
{
    L"IIsSmtpInfo", NULL, L"/LM/smtpsvc/info"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsSmtpService = 
{
    L"IIsSmtpService", NULL, L"/LM/smtpsvc"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsWebDirectory = 
{
    L"IIsWebDirectory", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsWebFile = 
{
    L"IIsWebFile", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsWebInfo = 
{
    L"IIsWebInfo", NULL, L"/LM/w3svc/info"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsWebServer = 
{
    L"IIsWebServer", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsWebService = 
{
    L"IIsWebService", NULL, L"/LM/w3svc"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir = 
{
    L"IIsWebVirtualDir", NULL, NULL
};

//
// These are special.  They don't get put into the hashtable of keytypes
//
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_TYPE_AdminACL = { NULL, NULL };
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_TYPE_AdminACE = { NULL, NULL };
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity = { NULL, NULL };
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_NO_TYPE = { NULL, NULL };

METABASE_KEYTYPE* METABASE_KEYTYPE_DATA::s_MetabaseKeyTypes[] = 
{
    &s_IIsApplicationPool,
    &s_IIsApplicationPools,
    &s_IIsCertMapper,
    &s_IIsCompressionScheme,
    &s_IIsCompressionSchemes,
    &s_IIsComputer,
    &s_IIsCustomLogModule,
    &s_IIsFilter,
    &s_IIsFilters,
    &s_IIsFtpInfo,
    &s_IIsFtpServer,
    &s_IIsFtpService,
    &s_IIsFtpVirtualDir,
    &s_IIsImapInfo,
    &s_IIsImapService,
    &s_IIsLogModule,
    &s_IIsLogModules,
    &s_IIsMimeMap,
    &s_IIsNntpInfo,
    &s_IIsNntpService,
    &s_IIsObject,
    &s_IIsPop3Info,
    &s_IIsPop3Service,
    &s_IIsSmtpInfo,
    &s_IIsSmtpService,
    &s_IIsWebDirectory,
    &s_IIsWebFile,
    &s_IIsWebInfo,
    &s_IIsWebServer,
    &s_IIsWebService,
    &s_IIsWebVirtualDir,

    &s_TYPE_AdminACL,
    &s_TYPE_AdminACE,
    &s_TYPE_IPSecurity,
    &s_NO_TYPE,

    NULL
};


///
// initialize METABASE_PROPERTY_DATA
//
METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AppRoot =
    { L"AppRoot",MD_APP_ROOT, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, TRUE, NULL };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_Path =
    { L"Path", MD_VR_PATH, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE, NULL };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerBindings =
    { L"ServerBindings",MD_SERVER_BINDINGS, IIS_MD_UT_SERVER, MULTISZ_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE, NULL };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ApplicationDependencies =
    { L"ApplicationDependencies", MD_APP_DEPENDENCIES, IIS_MD_UT_SERVER, MULTISZ_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE, NULL };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_WebSvcExtRestrictionList =
    { L"WebSvcExtRestrictionList", MD_WEB_SVC_EXT_RESTRICTION_LIST, IIS_MD_UT_SERVER, MULTISZ_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE, NULL };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerComment =
    { L"ServerComment",MD_SERVER_COMMENT, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT, FALSE, L"" };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_KeyType =
    { L"", MD_KEY_TYPE, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE, L"IIsObject", 0 };

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_MetabaseProperties[] = 
{
    &s_AppRoot,
    &s_Path,
    &s_ServerBindings,
    &s_ApplicationDependencies,
    &s_WebSvcExtRestrictionList,
    &s_ServerComment,
    &s_KeyType,
    NULL
};


//
//initiailze WMI_METHOD_PARAM_DATA
//
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_Description = { L"Description", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_Extension = { L"Extension", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_Extensions = { L"Extensions", CIM_STRING | VT_ARRAY, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_ExtensionFile = { L"ExtensionFile", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_ExtensionFiles = { L"ExtensionFiles", CIM_STRING | VT_ARRAY, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_Application = { L"Application", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_GroupID = { L"GroupID", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_Applications = { L"Applications", CIM_STRING | VT_ARRAY, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_AppMode = { L"AppMode", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_BackupDateTimeOut = { L"BackupDateTimeOut", CIM_DATETIME, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_BackupFlags = { L"BackupFlags", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_BackupLocation = { L"BackupLocation", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_BackupLocation_io = { L"BackupLocation", CIM_STRING, PARAM_INOUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_BackupVersion = { L"BackupVersion", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_BackupVersionOut = { L"BackupVersionOut", CIM_SINT32, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_DestPath = { L"DestPath", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_EnumIndex = { L"EnumIndex", CIM_SINT32, PARAM_IN};
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_FileName = { L"FileName", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_HistoryTime = { L"HistoryTime", CIM_DATETIME, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_IEnabled = { L"IEnabled", CIM_BOOLEAN, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_IEnabled_o = { L"IEnabled", CIM_BOOLEAN, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_IMethod = { L"IMethod", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_IndexIn = { L"IndexIn", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_InProcFlag = { L"InProcFlag", CIM_BOOLEAN, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_AppPoolName = { L"AppPoolName", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_bEnable = { L"bEnable", CIM_BOOLEAN, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_bCanDelete = { L"bCanDelete", CIM_BOOLEAN, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_bCreate = { L"bCreate", CIM_BOOLEAN, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MajorVersion = { L"MajorVersion", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MajorVersion_o = { L"MajorVersion", CIM_SINT32, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MDFlags = { L"MDFlags", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MDHistoryLocation = { L"MDHistoryLocation", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MDHistoryLocation_io = { L"MDHistoryLocation", CIM_STRING, PARAM_INOUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MinorVersion = { L"MinorVersion", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MinorVersion_o = { L"MinorVersion", CIM_SINT32, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_NtAcct = { L"NtAcct", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_NtAcct_o = { L"NtAcct", CIM_STRING, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_NtPwd = { L"NtPwd", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_NtPwd_o = { L"NtPwd", CIM_STRING, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_Password = { L"Password", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_Passwd = { L"Passwd", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_PathOfRootVirtualDir = { L"PathOfRootVirtualDir", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_Recursive = { L"Recursive", CIM_BOOLEAN, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_ServerComment = { L"ServerComment", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_ServerBindings = { L"ServerBindings", VT_ARRAY | VT_UNKNOWN, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_ServerId = { L"ServerId", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_SourcePath = { L"SourcePath", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_strName = { L"strName", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_strName_o = { L"strName", CIM_STRING, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_vCert = { L"vCert", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_vCert_o = { L"vCert", CIM_STRING, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_vKey = { L"vKey", CIM_STRING, PARAM_IN };

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceEnableApplication[] =
{ 
    &s_Application,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceRemoveApplication[] =
{ 
    &s_Application,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceListApplications[] =
{ 
    &s_Applications,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceQueryGroupIDStatus[] =
{ 
    &s_GroupID,
    &s_Applications,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceAddDependency[] =
{ 
    &s_Application,
    &s_GroupID,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceRemoveDependency[] =
{ 
    &s_Application,
    &s_GroupID,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceEnableWebServiceExtension[] =
{ 
    &s_Extension,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceDisableWebServiceExtension[] =
{ 
    &s_Extension,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceListWebServiceExtensions[] =
{ 
    &s_Extensions,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceEnableExtensionFile[] =
{ 
    &s_ExtensionFile,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceDisableExtensionFile[] =
{ 
    &s_ExtensionFile,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceAddExtensionFile[] =
{ 
    &s_ExtensionFile,
    &s_bEnable,
    &s_GroupID,
    &s_bCanDelete,
    &s_Description,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceDeleteExtensionFile[] =
{ 
    &s_ExtensionFile,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceListExtensionFiles[] =
{ 
    &s_ExtensionFiles,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceCreateNewServer[] =
{ 
    &s_ServerComment,
    &s_ServerBindings,
    &s_PathOfRootVirtualDir,
    &s_ServerId,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppCreate[] =
{
    &s_InProcFlag,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppCreate2[] =
{
    &s_AppMode,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppCreate3[] =
{
    &s_AppMode,
    &s_AppPoolName,
    &s_bCreate,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppDelete[] =
{
    &s_Recursive,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppUnLoad[] =
{
    &s_Recursive,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppEnable[] =
{
    &s_Recursive,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppDisable[] =
{
    &s_Recursive,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_BackupWithPasswd[] =
{
    &s_BackupLocation,
    &s_BackupVersion,
    &s_BackupFlags,
    &s_Password,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_DeleteBackup[] =
{
    &s_BackupLocation,
    &s_BackupVersion,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_EnumBackups[] =
{
    &s_BackupLocation_io,
    &s_IndexIn,
    &s_BackupVersionOut,
    &s_BackupDateTimeOut,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_RestoreWithPasswd[] =
{
    &s_BackupLocation,
    &s_BackupVersion,
    &s_BackupFlags,
    &s_Password,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_Export[] =
{
    &s_Passwd,
    &s_FileName,
    &s_SourcePath,
    &s_MDFlags,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_Import[] =
{
    &s_Passwd,
    &s_FileName,
    &s_SourcePath,
    &s_DestPath,
    &s_MDFlags,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_RestoreHistory[] =
{
    &s_MDHistoryLocation,
    &s_MajorVersion,
    &s_MinorVersion,
    &s_MDFlags,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_EnumHistory[] =
{
    &s_MDHistoryLocation_io,
    &s_MajorVersion_o,
    &s_MinorVersion_o,
    &s_HistoryTime,
    &s_EnumIndex,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_CreateMapping[] =
{
    &s_vCert,
    &s_NtAcct,
    &s_NtPwd,
    &s_strName,
    &s_IEnabled,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_DeleteMapping[] =
{
    &s_IMethod,
    &s_vKey,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_GetMapping[] =
{
    &s_IMethod,
    &s_vKey,
    &s_vCert_o,
    &s_NtAcct_o,
    &s_NtPwd_o,
    &s_strName_o,
    &s_IEnabled_o,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_SetAcct[] =
{
    &s_IMethod,
    &s_vKey,
    &s_NtAcct,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_SetEnabled[] =
{
    &s_IMethod,
    &s_vKey,
    &s_IEnabled,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_SetName[] =
{
    &s_IMethod,
    &s_vKey,
    &s_strName,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_SetPwd[] =
{
    &s_IMethod,
    &s_vKey,
    &s_NtPwd,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_EnumAppsInPool[] =
{
    &s_Applications,
    NULL
};


//
//initialize WMI_METHOD_DATA
//
WMI_METHOD WMI_METHOD_DATA::s_ServiceListExtensionFiles = {L"ListExtensionFiles", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceListExtensionFiles, L"Lists WebSvcExtRestrictionList property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceAddExtensionFile = {L"AddExtensionFile", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceAddExtensionFile, L"Modifies WebSvcExtRestrictionList property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceDeleteExtensionFile = {L"DeleteExtensionFileRecord", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceDeleteExtensionFile, L"Modifies WebSvcExtRestrictionList property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceEnableExtensionFile = {L"EnableExtensionFile", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceEnableExtensionFile, L"Modifies WebSvcExtRestrictionList property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceDisableExtensionFile = {L"DisableExtensionFile", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceDisableExtensionFile, L"Modifies WebSvcExtRestrictionList property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceEnableWebServiceExtension = {L"EnableWebServiceExtension", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceEnableWebServiceExtension, L"Modifies WebSvcExtRestrictionList property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceDisableWebServiceExtension = {L"DisableWebServiceExtension", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceDisableWebServiceExtension, L"Modifies WebSvcExtRestrictionList property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceListWebServiceExtensions = {L"ListWebServiceExtensions", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceListWebServiceExtensions, L"Lists WebSvcExtRestrictionList property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceEnableApplication = {L"EnableApplication", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceEnableApplication, L"Modifies ApplicationDependencies property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceRemoveApplication = {L"RemoveApplication", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceRemoveApplication, L"Modifies ApplicationDependencies property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceListApplications = {L"ListApplications", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceListApplications, L"Lists ApplicationDependencies property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceQueryGroupIDStatus = {L"QueryGroupIDStatus", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceQueryGroupIDStatus, L"Lists Applications that depends on the given GroupID." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceAddDependency = {L"AddDependency", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceAddDependency, L"Modifies ApplicationDependencies property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceRemoveDependency = {L"RemoveDependency", 0, NULL, WMI_METHOD_PARAM_DATA::s_ServiceRemoveDependency, L"Modifies ApplicationDependencies property." };
WMI_METHOD WMI_METHOD_DATA::s_ServiceCreateNewServer = {L"CreateNewSite", 0, CIM_STRING, WMI_METHOD_PARAM_DATA::s_ServiceCreateNewServer, L"Creates a new site." };
WMI_METHOD WMI_METHOD_DATA::s_GetCurrentMode = {L"GetCurrentMode", 0, CIM_SINT32, NULL, L"Returns what mode -- Full Isolation (= 1) or Shared Isolation (= 0) -- the W3SVC is running in." };

WMI_METHOD WMI_METHOD_DATA::s_ServerStart = {L"Start", MD_SERVER_COMMAND_START, NULL, NULL, L"Starts the server." };
WMI_METHOD WMI_METHOD_DATA::s_ServerStop = {L"Stop", MD_SERVER_COMMAND_STOP, NULL, NULL, L"Stops the server." };
WMI_METHOD WMI_METHOD_DATA::s_ServerContinue = {L"Continue", MD_SERVER_COMMAND_CONTINUE, NULL, NULL, L"Continues the server." };
WMI_METHOD WMI_METHOD_DATA::s_ServerPause = {L"Pause", MD_SERVER_COMMAND_PAUSE, NULL, NULL, L"Pauses the server." };

WMI_METHOD WMI_METHOD_DATA::s_AppCreate = {L"AppCreate", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppCreate, L"Creates an application at the specified metabase key(parameter is a Boolean)." };
WMI_METHOD WMI_METHOD_DATA::s_AppCreate2 = {L"AppCreate2", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppCreate2, L"Creates an application at the specified metabase key(parameter is a Long)." };
WMI_METHOD WMI_METHOD_DATA::s_AppCreate3 = {L"AppCreate3", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppCreate3, L"Creates an application at the specified metabase key." };
WMI_METHOD WMI_METHOD_DATA::s_AppDelete = {L"AppDelete", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppDelete, L"Deletes an application definition at the specified key (and its subkeys)." };
WMI_METHOD WMI_METHOD_DATA::s_AppUnLoad = {L"AppUnLoad", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppUnLoad, L"Unloads an application at the specified key (and its subkeys)." };
WMI_METHOD WMI_METHOD_DATA::s_AppDisable = {L"AppDisable", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppDisable, NULL };
WMI_METHOD WMI_METHOD_DATA::s_AppEnable = {L"AppEnable", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppEnable, NULL };
WMI_METHOD WMI_METHOD_DATA::s_AppGetStatus = {L"AppGetStatus", 0, CIM_UINT32, NULL, NULL };
WMI_METHOD WMI_METHOD_DATA::s_AspAppRestart = {L"AspAppRestart", 0, NULL, NULL, L"Restarts the ASP application that invoked it." };

WMI_METHOD WMI_METHOD_DATA::s_SaveData = {L"SaveData", 0, NULL, NULL, L"Explicitly saves the metabase data to disk." };
WMI_METHOD WMI_METHOD_DATA::s_BackupWithPasswd = {L"BackupWithPassword", 0, NULL, WMI_METHOD_PARAM_DATA::s_BackupWithPasswd, L"Saves the metabase to long-term storage." };
WMI_METHOD WMI_METHOD_DATA::s_DeleteBackup = {L"DeleteBackup", 0, NULL, WMI_METHOD_PARAM_DATA::s_DeleteBackup, L"Deletes a metabase backup from long-term storage." };
WMI_METHOD WMI_METHOD_DATA::s_EnumBackups = {L"EnumBackups", 0, NULL, WMI_METHOD_PARAM_DATA::s_EnumBackups, L"Enumerates metabase backups in long-term storage." };
WMI_METHOD WMI_METHOD_DATA::s_RestoreWithPasswd = {L"RestoreWithPassword", 0, NULL, WMI_METHOD_PARAM_DATA::s_RestoreWithPasswd, L"Restores a metabase backup from long-term storage." };
WMI_METHOD WMI_METHOD_DATA::s_Export = {L"Export", 0, NULL, WMI_METHOD_PARAM_DATA::s_Export, NULL };
WMI_METHOD WMI_METHOD_DATA::s_Import = {L"Import", 0, NULL, WMI_METHOD_PARAM_DATA::s_Import, NULL };
WMI_METHOD WMI_METHOD_DATA::s_RestoreHistory = {L"RestoreHistory", 0, NULL, WMI_METHOD_PARAM_DATA::s_RestoreHistory, NULL };
WMI_METHOD WMI_METHOD_DATA::s_EnumHistory = {L"EnumHistory", 0, NULL, WMI_METHOD_PARAM_DATA::s_EnumHistory, NULL };

WMI_METHOD WMI_METHOD_DATA::s_CreateMapping = {L"CreateMapping", 0, NULL, WMI_METHOD_PARAM_DATA::s_CreateMapping, L"Maps a certificate to a Windows account." };
WMI_METHOD WMI_METHOD_DATA::s_DeleteMapping = {L"DeleteMapping", 0, NULL, WMI_METHOD_PARAM_DATA::s_DeleteMapping, L"Deletes an existing certificate mapping." };
WMI_METHOD WMI_METHOD_DATA::s_GetMapping = {L"GetMapping", 0, NULL, WMI_METHOD_PARAM_DATA::s_GetMapping, L"Retrieves a certificate and the mapping data from an existing certificate mapping." };
WMI_METHOD WMI_METHOD_DATA::s_SetAcct = {L"SetAcct", 0, NULL, WMI_METHOD_PARAM_DATA::s_SetAcct, L"Sets a new value for the Windows account string in an existing certificate mapping." };
WMI_METHOD WMI_METHOD_DATA::s_SetEnabled = {L"SetEnabled", 0, NULL, WMI_METHOD_PARAM_DATA::s_SetEnabled, L"Enables or disables an existing certificate mapping." };
WMI_METHOD WMI_METHOD_DATA::s_SetName = {L"SetName", 0, NULL, WMI_METHOD_PARAM_DATA::s_SetName, L"Sets a new value for the name string in an existing certificate mapping." };
WMI_METHOD WMI_METHOD_DATA::s_SetPwd = {L"SetPwd", 0, NULL, WMI_METHOD_PARAM_DATA::s_SetPwd, L"Sets a new value for the Windows password string in an existing certificate mapping." };

WMI_METHOD WMI_METHOD_DATA::s_RecycleAppPool = {L"Recycle", 0, NULL, NULL, L"Recycle an already enabled application pool on demand" };
WMI_METHOD WMI_METHOD_DATA::s_EnumAppsInPool = {L"EnumAppsInPool", 0, NULL, WMI_METHOD_PARAM_DATA::s_EnumAppsInPool, L"Determine which applications are currently routed to the given application pool" };
WMI_METHOD WMI_METHOD_DATA::s_Start = {L"Start", 0, NULL, NULL, L"Starts an application pool"};
WMI_METHOD WMI_METHOD_DATA::s_Stop = {L"Stop", 0, NULL, NULL, L"Stops an application pool"};


WMI_METHOD* WMI_METHOD_DATA::s_WebServiceMethods[] = 
{
    &s_ServiceListExtensionFiles,
    &s_ServiceAddExtensionFile,
    &s_ServiceDeleteExtensionFile,
    &s_ServiceEnableExtensionFile,
    &s_ServiceDisableExtensionFile,
    &s_ServiceEnableWebServiceExtension, 
    &s_ServiceDisableWebServiceExtension,
    &s_ServiceListWebServiceExtensions,
    &s_ServiceEnableApplication,
    &s_ServiceRemoveApplication,
    &s_ServiceListApplications,
    &s_ServiceQueryGroupIDStatus,
    &s_ServiceAddDependency,
    &s_ServiceRemoveDependency,
    &s_ServiceCreateNewServer,
    &s_GetCurrentMode,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_ServiceMethods[] = 
{
    &s_ServiceCreateNewServer,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_ServerMethods[] = 
{
    &s_ServerStart,
    &s_ServerStop,
    &s_ServerContinue,
    &s_ServerPause,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_WebAppMethods[] = 
{
    &s_AppCreate,
    &s_AppCreate2,
    &s_AppCreate3,
    &s_AppDelete,
    &s_AppUnLoad,
    &s_AppDisable,
    &s_AppEnable,
    &s_AppGetStatus,
    &s_AspAppRestart,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_ComputerMethods[] = 
{
    &s_SaveData,
    &s_BackupWithPasswd,
    &s_DeleteBackup,
    &s_EnumBackups,
    &s_RestoreWithPasswd,
    &s_Export,
    &s_Import,
    &s_RestoreHistory,
    &s_EnumHistory,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_CertMapperMethods[] = 
{
    &s_CreateMapping,
    &s_DeleteMapping,
    &s_GetMapping,
    &s_SetAcct,
    &s_SetEnabled,
    &s_SetName,
    &s_SetPwd,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_AppPoolMethods[] =
{
    &s_EnumAppsInPool,
    &s_RecycleAppPool,
    &s_Start,
    &s_Stop,
    NULL
};


//
// initialize WMI_CLASS_DATA
//
//** Computer
WMI_CLASS WMI_CLASS_DATA::s_Computer   =
    {L"IIsComputer", L"", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsComputer, WMI_METHOD_DATA::s_ComputerMethods, SHIPPED_TO_MOF, L"CIM_ApplicationSystem", false, NULL};
WMI_CLASS WMI_CLASS_DATA::s_ComputerSetting   =
    {L"IIsComputerSetting", L"", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsComputer, NULL, SHIPPED_TO_MOF, g_wszSettingParent, false, NULL};

//** FtpService
WMI_CLASS WMI_CLASS_DATA::s_FtpService = 
    {L"IIsFtpService", L"/LM", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsFtpService, WMI_METHOD_DATA::s_ServiceMethods, SHIPPED_TO_MOF, g_awszParentClassWithNamePK[eWin32_Service], false, NULL};

//** FtpServer
WMI_CLASS WMI_CLASS_DATA::s_FtpServer  = 
    {L"IIsFtpServer", L"/LM", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsFtpServer, WMI_METHOD_DATA::s_ServerMethods, SHIPPED_TO_MOF, g_wszElementParent, true, NULL};

//** FtpVirtualDir
WMI_CLASS WMI_CLASS_DATA::s_FtpVirtualDir = 
    {L"IIsFtpVirtualDir",L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir, NULL, SHIPPED_TO_MOF, g_awszParentClassWithNamePK[eIIsDirectory], true, NULL};

//** WebService
WMI_CLASS WMI_CLASS_DATA::s_WebService =    
    {L"IIsWebService", L"/LM", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsWebService, WMI_METHOD_DATA::s_WebServiceMethods, SHIPPED_TO_MOF, g_awszParentClassWithNamePK[eWin32_Service], false, NULL};

//** WebFilter
WMI_CLASS WMI_CLASS_DATA::s_WebFilter =
    {L"IIsFilter", L"/LM", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsFilter, NULL, SHIPPED_TO_MOF, g_wszElementParent, true, NULL};

//** WebServer
WMI_CLASS WMI_CLASS_DATA::s_WebServer =
    {L"IIsWebServer", L"/LM", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsWebServer, WMI_METHOD_DATA::s_ServerMethods, SHIPPED_TO_MOF, g_wszElementParent, true, NULL};

//** Web CertMapper
WMI_CLASS WMI_CLASS_DATA::s_WebCertMapper = 
    {L"IIsCertMapper",L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsCertMapper, WMI_METHOD_DATA::s_CertMapperMethods, SHIPPED_TO_MOF, g_wszElementParent, true, NULL};

//** Web VirtualDir
WMI_CLASS WMI_CLASS_DATA::s_WebVirtualDir = 
    {L"IIsWebVirtualDir",L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir, WMI_METHOD_DATA::s_WebAppMethods, SHIPPED_TO_MOF, g_awszParentClassWithNamePK[eIIsDirectory], true, NULL};

//** Web Directory
WMI_CLASS WMI_CLASS_DATA::s_WebDirectory = 
    {L"IIsWebDirectory",L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsWebDirectory, WMI_METHOD_DATA::s_WebAppMethods, SHIPPED_TO_MOF, g_awszParentClassWithNamePK[eIIsDirectory], true, NULL};

//** Web File
WMI_CLASS WMI_CLASS_DATA::s_WebFile = 
    {L"IIsWebFile",L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsWebFile, NULL, SHIPPED_TO_MOF, g_awszParentClassWithNamePK[eIIsDirectory], true, NULL};

//** Application Pool
WMI_CLASS WMI_CLASS_DATA::s_ApplicationPool =
    {L"IIsApplicationPool",L"/LM",L"Name",NULL, &METABASE_KEYTYPE_DATA::s_IIsApplicationPool, WMI_METHOD_DATA::s_AppPoolMethods, SHIPPED_TO_MOF, g_wszElementParent, true, NULL};

//** AdminACL
WMI_CLASS WMI_CLASS_DATA::s_AdminACL = 
    {L"IIsAdminACL", L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL, NULL, SHIPPED_NOT_TO_MOF, g_wszElementParent, true, NULL};

WMI_CLASS WMI_CLASS_DATA::s_ACE = 
    {L"IIsACE", L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE, NULL, SHIPPED_NOT_TO_MOF, g_wszElementParent, true, NULL};

//** IPSecurity
WMI_CLASS WMI_CLASS_DATA::s_IPSecurity = 
    {L"IIsIPSecuritySetting", L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity, NULL, SHIPPED_NOT_TO_MOF, g_wszSettingParent, true, NULL};

WMI_CLASS* WMI_CLASS_DATA:: s_WmiClasses[] = 
{
    &s_Computer,
    &s_ComputerSetting,

    &s_FtpService,
    &s_FtpServer,
    &s_FtpVirtualDir,

    &s_WebService,
    &s_WebFilter,
    &s_WebServer,
    &s_WebCertMapper,
    &s_WebVirtualDir,
    &s_WebDirectory,
    &s_WebFile,

    &s_ApplicationPool,

    &s_AdminACL,
    &s_ACE,    
    &s_IPSecurity,

    NULL
};


//** Hard-coded Associations
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_AdminACLToACE = 
    { L"IIsAdminACL_IIsACE", &WMI_CLASS_DATA::s_AdminACL, &WMI_CLASS_DATA::s_ACE, &WMI_ASSOCIATION_TYPE_DATA::s_AdminACL, 0, SHIPPED_TO_MOF, g_wszGroupPartAssocParent};

WMI_ASSOCIATION* WMI_ASSOCIATION_DATA:: s_WmiAssociations[] = 
{
    &s_AdminACLToACE,
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\iisfiles.h ===
#ifndef _iisfiles_h_
#define _iisfiles_h_

#include <iadmw.h>
#include <wincrypt.h>
#include <iiscnfgp.h>   // got from inetsrv\iis\inc\$(O) (build iis)
#include <iwamreg.h>    // public\sdk\inc
#include <dbgutil.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\globalconstants.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    GlobalConstants.h

Abstract:

    Global include file.

Author:

    ???

Revision History:

    Mohit Srivastava            22-Mar-01

--*/

#ifndef _globalconstants_H_
#define _globalconstants_H_

#include <windows.h>

//
// Provider name
//
static LPCWSTR g_wszIIsProvider = L"IIS__PROVIDER";

//
// Instance level property qualifiers
//
static LPCWSTR       g_wszIsInherit              = L"IsInherit";
static const ULONG   g_cchIsInherit              = wcslen(g_wszIsInherit);
static LPCWSTR       g_wszIsDefault              = L"IsDefault";
static const ULONG   g_cchIsDefault              = wcslen(g_wszIsDefault);
static LPCWSTR       g_wszForcePropertyOverwrite = L"ForcePropertyOverwrite";
static const ULONG   g_cchForcePropertyOverwrite = wcslen(g_wszForcePropertyOverwrite);

static const ULONG   g_fIsInherit                = 0x1;
static const ULONG   g_fIsDefault                = 0x2;
static const ULONG   g_fForcePropertyOverwrite   = 0x4;

//
// Instance level qualifiers
//
static LPCWSTR       g_wszInstanceName           = L"InstanceName";
static const ULONG   g_cchInstanceName           = wcslen(g_wszInstanceName);
static LPCWSTR       g_wszInstanceExists         = L"InstanceExists";
static const ULONG   g_cchInstanceExists         = wcslen(g_wszInstanceExists);

static const ULONG   g_idxInstanceName            = 0;
static const ULONG   g_idxInstanceExists          = 1;

//
// These contants are used by globdata.cpp
//

static const ULONG ALL_BITS_ON = 0xFFFFFFFF;

static const ULONG PARAM_IN    = 0;
static const ULONG PARAM_OUT   = 1;
static const ULONG PARAM_INOUT = 2;

static const LPWSTR g_wszGroupPartAssocParent       = L"CIM_Component";
static const LPWSTR g_wszElementSettingAssocParent  = L"CIM_ElementSetting";
static const LPWSTR g_wszElementParent              = L"CIM_LogicalElement";
static const LPWSTR g_wszSettingParent              = L"IIsSetting";

static const LPWSTR g_wszExtGroupPartAssocParent       = L"IIsUserDefinedComponent";
static const LPWSTR g_wszExtElementSettingAssocParent  = L"IIsUserDefinedElementSetting";
static const LPWSTR g_wszExtElementParent              = L"IIsUserDefinedLogicalElement";
static const LPWSTR g_wszExtSettingParent              = L"IIsUserDefinedSetting";

//
// This is used by globdata, mofgen, and pusher
// A few base classes already have a "Name" primary key.  We should not
// be putting the "Name" property in child classes.
//
static enum tagParentClassWithNamePK
{
    eIIsDirectory  = 0,
    eWin32_Service = 1
} eParentClassWithNamePK;
static const LPWSTR g_awszParentClassWithNamePK[] = { L"IIsDirectory", L"Win32_Service", NULL };

//
// Used by dwExtended field of WMI_CLASS and WMI_ASSOCIATION
//
static const ULONG SHIPPED_TO_MOF                      = 1;
static const ULONG SHIPPED_NOT_TO_MOF                  = 2;
static const ULONG EXTENDED                            = 3;
static const ULONG USER_DEFINED_TO_REPOSITORY          = 4;
static const ULONG USER_DEFINED_NOT_TO_REPOSITORY      = 5;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\iisprov.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    iisprov.h

Abstract:

    Global include file.  This file is included by pretty much everything, so
    to minimize dependencies, only put stuff in here that will be used by majority 
    of files.

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#ifndef _iisprov_H_
#define _iisprov_H_

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <objbase.h>
#include <initguid.h>

#include <windows.h>
#include <wbemprov.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <comdef.h>
#include <stdio.h>

#include <atlbase.h>
#include "iisfiles.h"
#include <eventlog.hxx>

#include "ProviderBase.h"
#include "schema.h"
#include "schemadynamic.h"
#include "hashtable.h"
#include "metabase.h"
#include "utils.h"
#include "globalconstants.h"
#include "safecs.h"

//
// These variables keep track of when the module can be unloaded
//
extern long  g_cLock;

//
// Provider interfaces are provided by objects of this class
//
class CIISInstProvider : public CProviderBase
{
public:
    static bool     ms_bInitialized; // If Initialize succeeded
    static CSafeAutoCriticalSection *m_SafeCritSec;

    //
    // Implemented
    //
    CIISInstProvider(
        BSTR ObjectPath = NULL, 
        BSTR User = NULL, 
        BSTR Password = NULL, 
        IWbemContext* pCtx = NULL)
    {}

    HRESULT STDMETHODCALLTYPE DoInitialize(
        LPWSTR                      i_wszUser,
        LONG                        i_lFlags,
        LPWSTR                      i_wszNamespace,
        LPWSTR                      i_wszLocale,
        IWbemServices*              i_pNamespace,
        IWbemContext*               i_pCtx,
        IWbemProviderInitSink*      i_pInitSink);

    HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
        const BSTR                  i_ClassName,
        long                        i_lFlags, 
        IWbemContext __RPC_FAR*     i_pCtx, 
        IWbemObjectSink __RPC_FAR*  i_pHandler);

    HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
        const BSTR                  i_ObjectPath, 
        long                        i_lFlags,
        IWbemContext __RPC_FAR*     i_pCtx,
        IWbemObjectSink __RPC_FAR*  i_pHandler);

    HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        const BSTR                  i_strObjectPath,                   
        const BSTR                  i_strMethodName,
        long                        i_lFlags,                       
        IWbemContext*               i_pCtx,                 
        IWbemClassObject*           i_pInParams,
        IWbemObjectSink*            i_pHandler);

    HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        const BSTR                  i_ObjectPath, 
        long                        i_lFlags,
        IWbemContext __RPC_FAR*     i_pCtx,
        IWbemObjectSink __RPC_FAR*  i_pHandler);

    HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
        IWbemClassObject __RPC_FAR* i_pObj,
        long                        i_lFlags,
        IWbemContext __RPC_FAR*     i_pCtx,
        IWbemObjectSink __RPC_FAR*  i_pHandler);

    HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
        const BSTR                  i_bstrQueryLanguage,
        const BSTR                  i_bstrQuery,
        long                        i_lFlags,
        IWbemContext __RPC_FAR*     i_pCtx,
        IWbemObjectSink __RPC_FAR*  i_pResponseHandler);

private:
    IWbemClassObject* ConstructExtendedStatus(
        const CIIsProvException* i_pException) const;

    IWbemClassObject* ConstructExtendedStatus(
        HRESULT i_hr) const;

    void ValidatePutParsedObject(
        ParsedObjectPath*    i_pParsedObject,
        IWbemClassObject*    i_pObj,
        bool*                io_pbInstanceNameSame,
        bool*                io_pbInstanceExists,
        WMI_CLASS**          o_ppWmiClass = NULL);

    //
    // Worker methods called by public methods
    //
    void WorkerGetObjectAsync(
        IWbemClassObject**   o_ppObj,
        BSTR                 i_bstrObjPath,
        bool                 i_bCreateKeyIfNotExist);

    void WorkerGetObjectAsync(
        IWbemClassObject**   o_ppObj,
        ParsedObjectPath*    i_pParsedObjPath,
        bool                 i_bCreateKeyIfNotExist);

    void WorkerExecMethodAsync(
        BSTR                 i_strObjectPath,
        BSTR                 i_strMethodName,
        IWbemContext*        i_pCtx, 
        IWbemClassObject*    i_pInParams,
        IWbemObjectSink*     i_pHandler);

    void WorkerDeleteObjectAsync(
        ParsedObjectPath*    i_pParsedObject);

    void WorkerPutObjectAsync(
        IWbemClassObject*    i_pObj,
        IWbemClassObject*    i_pObjOld,               // can be NULL
        ParsedObjectPath*    i_pParsedObject,
        long                 i_lFlags,
        bool                 i_bInstanceExists,
        BSTR*                o_pbstrObjPath);

    void WorkerEnumObjectAsync(
        BSTR                 i_bstrClassName,
        IWbemObjectSink FAR* i_pHandler);

    //
    // These methods should only be called by WorkerExecMethodAsync
    //
    void WorkerExecFtpServiceMethod(
        LPCWSTR             i_wszMbPath,
        WMI_CLASS*          i_pClass,
        WMI_METHOD*         i_pMethod,
        IWbemContext*       i_pCtx, 
        IWbemClassObject*   i_pInParams,
        IWbemObjectSink*    i_pHandler);

    void WorkerExecWebServiceMethod(
        LPCWSTR             i_wszMbPath,
        WMI_CLASS*          i_pClass,
        WMI_METHOD*         i_pMethod,
        IWbemContext*       i_pCtx, 
        IWbemClassObject*   i_pInParams,
        IWbemObjectSink*    i_pHandler);

    static void WorkerExecWebAppMethod(
        LPCWSTR             i_wszMbPath,
        LPCWSTR             i_wszClassName,
        WMI_METHOD*         i_pMethod,
        IWbemContext*       i_pCtx, 
        IWbemClassObject*   i_pInParams,
        IWbemObjectSink*    i_pHandler,
        CWbemServices*      i_pNameSpace);

    static void WorkerExecComputerMethod(
        LPCWSTR             i_wszMbPath,
        LPCWSTR             i_wszClassName,
        WMI_METHOD*         i_pMethod,
        IWbemContext*       i_pCtx, 
        IWbemClassObject*   i_pInParams,
        IWbemObjectSink*    i_pHandler,
        CWbemServices*      i_pNameSpace);

    static void WorkerExecCertMapperMethod(
        LPCWSTR             i_wszMbPath,
        LPCWSTR             i_wszClassName,
        WMI_METHOD*         i_pMethod,
        IWbemContext*       i_pCtx, 
        IWbemClassObject*   i_pInParams,
        IWbemObjectSink*    i_pHandler,
        CWbemServices*      i_pNameSpace);

    static void WorkerExecAppPoolMethod(
        LPCWSTR             i_wszMbPath,
        LPCWSTR             i_wszClassName,
        WMI_METHOD*         i_pMethod,
        IWbemContext*       i_pCtx, 
        IWbemClassObject*   i_pInParams,
        IWbemObjectSink*    i_pHandler,
        CWbemServices*      i_pNameSpace);
};


// This class is the class factory for CInstPro objects.

class CProvFactory : public IClassFactory
{
protected:
    ULONG           m_cRef;

public:
    CProvFactory(void);
    ~CProvFactory(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, PPVOID);
    STDMETHODIMP         LockServer(BOOL);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\hashtable.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hashtable.h

Abstract:

    Implementation of:
    CPool<T>, CStringPool, CHashTableElement<T>

Author:

    Mohit Srivastava            10-Nov-2000

Revision History:

--*/

#include "iisprov.h"

template CPool<METABASE_PROPERTY>;
template CHashTable<METABASE_PROPERTY*>;

template CPool<WMI_CLASS>;
template CHashTable<WMI_CLASS*>;

template CPool<WMI_ASSOCIATION>;
template CHashTable<WMI_ASSOCIATION*>;

template CPool<METABASE_KEYTYPE>;
template CHashTable<METABASE_KEYTYPE*>;

template CArrayPool<wchar_t, ::STRING_POOL_STRING_SIZE>;
template CArrayPool<METABASE_PROPERTY*, 10>;
template CArrayPool<BYTE, 10>;

template CPool<METABASE_KEYTYPE_NODE>;

//
// CPool<T>
//

template <class T>
HRESULT CPool<T>::Initialize(ULONG i_iFirstBucketSize)
/*++

Synopsis: 
    Set up data structures:
        Initialize array to size CPool::ARRAY_SIZE
        Create first bucket of size i_iFirstBucketSize

Arguments: [i_iFirstBucketSize] - 
           
Return Value: 
    S_OK, E_OUTOFMEMORY

--*/
{
    DBG_ASSERT(m_bInitCalled     == false);
    DBG_ASSERT(m_bInitSuccessful == false);
    m_bInitCalled = true;

    HRESULT hr = S_OK;

    m_apBuckets = new T*[ARRAY_SIZE];
    if(m_apBuckets == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    m_iArraySize     = ARRAY_SIZE;
    m_iArrayPosition = 1;

    m_apBuckets[0] = new T[i_iFirstBucketSize];
    if(m_apBuckets[0] == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    m_iCurrentBucketSize     = i_iFirstBucketSize;
    m_iFirstBucketSize       = i_iFirstBucketSize;
    m_iCurrentBucketPosition = 0;

exit:
    if(SUCCEEDED(hr))
    {
        m_bInitSuccessful = true;
    }
    return hr;
}

template <class T>
HRESULT CPool<T>::GetNewElement(T** o_ppElement)
/*++

Synopsis: 
    Normally, just a matter of returning pointer to next spot in bucket.
    May have to create a new bucket and/or grow the array, however.

Arguments: [o_ppElement] - 
           
Return Value: 
    S_OK, E_OUTOFMEMORY

--*/{
    DBG_ASSERT(m_bInitCalled == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(o_ppElement != NULL);

    HRESULT hr = S_OK;

    //
    // Check to see if we need to move on to the next bucket
    //
    if(m_iCurrentBucketPosition == m_iCurrentBucketSize)
    {
        //
        // Check to see if we need to grow the array
        //
        if(m_iArrayPosition == m_iArraySize)
        {
            T** apBucketsNew;
            apBucketsNew = new T*[m_iArraySize*2];
            if(apBucketsNew == NULL)
            {
                return E_OUTOFMEMORY;
            }
            memcpy(apBucketsNew, m_apBuckets, m_iArraySize * sizeof(T*));            
            delete [] m_apBuckets;
            m_apBuckets   = apBucketsNew;
            m_iArraySize *= 2;
        }

        T* pBucketNew;
        pBucketNew = new T[m_iCurrentBucketSize*2];
        if(pBucketNew == NULL)
        {
            return E_OUTOFMEMORY;
        }
        m_apBuckets[m_iArrayPosition] = pBucketNew;
        m_iCurrentBucketSize *= 2;
        m_iCurrentBucketPosition = 0;
        m_iArrayPosition++;
    }
    *o_ppElement = &m_apBuckets[m_iArrayPosition-1][m_iCurrentBucketPosition];
    m_iCurrentBucketPosition++;

    return hr;
}


template <class T>
T* CPool<T>::Lookup(ULONG i_idx) const
/*++

Synopsis: 
    Looks up data in pool by index

Arguments: [i_idx] - Valid Range is 0 to GetUsed()-1
           
Return Value: 
    A pointer to the data unless i_idx is out of range.

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);

    //
    // Total element capacity of all buckets up to and including the current one
    // in the for loop below
    //
    ULONG iElementsCovered = 0;

    ULONG iBucketPos = 0;

    if (i_idx >= GetUsed())
    {
        return NULL;
    }
    for(ULONG i = 0; i < m_iArrayPosition; i++)
    {
        iElementsCovered = iElementsCovered + (1 << i)*(m_iFirstBucketSize);
        if(i_idx < iElementsCovered)
        {
            iBucketPos = 
                i_idx - ( iElementsCovered - (1 << i)*(m_iFirstBucketSize) );
            return &m_apBuckets[i][iBucketPos];
        }            
    }
    return NULL;
}


//
// CArrayPool
//

template <class T, ULONG size>
HRESULT CArrayPool<T, size>::Initialize()
/*++

Synopsis: 
    should only be called once

Return Value: 

--*/
{
    HRESULT hr = S_OK;
    hr = m_PoolFixedSize.Initialize(FIRST_BUCKET_SIZE);
    if(FAILED(hr))
    {
        return hr;
    }
    hr = m_PoolDynamic.Initialize(FIRST_BUCKET_SIZE);
    if(FAILED(hr))
    {
        return hr;
    }
    return hr;
}

template <class T, ULONG size>
HRESULT CArrayPool<T, size>::GetNewArray(ULONG i_cElem, T** o_ppElem)
/*++

Synopsis: 
    Fills o_ppElem from either the fixedsize or dynamic pool based on the
    requested size.

Arguments: [i_cElem] - number of elements caller wants in new array
           [o_ppElem] - receives the new array
           
Return Value: 

--*/
{
    DBG_ASSERT(o_ppElem != NULL);

    HRESULT hr = S_OK;
    T** ppNew = NULL;
    T*  pNew  = NULL;
    if(i_cElem <= size)
    {
        hr = m_PoolFixedSize.GetNewElement((CArrayPoolEntry<T,size>**)&pNew);
        if(FAILED(hr))
        {
            return hr;
        }
        ppNew = &pNew;
    }
    else
    {
        hr = m_PoolDynamic.GetNewElement(&ppNew);
        if(FAILED(hr))
        {
            return hr;
        }
        *ppNew = NULL;
        *ppNew = new T[i_cElem+1];
        if(*ppNew == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }
    *o_ppElem = *ppNew;
    return hr;
}

//
// for debugging only
// if msb set, goto dynamic pool
// else use fixedsize pool
//
template <class T, ULONG size>
T* CArrayPool<T, size>::Lookup(ULONG i_idx) const
{
    ULONG i_msb;
    i_msb = i_idx >> 31;

    if(i_msb == 0)
    {
        return (T *)(m_PoolFixedSize.Lookup(i_idx));
    }
    else {
        T** pElem = m_PoolDynamic.Lookup( i_idx - (ULONG)(1 << 31) );
        if(pElem == NULL)
        {
            return NULL;
        }
        else
        {
            return *pElem;
        }
    }
}


//
// CStringPool
//

HRESULT CStringPool::GetNewString(LPCWSTR i_wsz, ULONG i_cch, LPWSTR* o_pwsz)
{
    DBG_ASSERT(o_pwsz != NULL);

    HRESULT hr;

    hr = GetNewArray(i_cch+1, o_pwsz);
    if(FAILED(hr))
    {
        return hr;
    }

    memcpy(*o_pwsz, i_wsz, (i_cch+1)*sizeof(wchar_t));
    return hr;
}

HRESULT CStringPool::GetNewString(LPCWSTR i_wsz, LPWSTR* o_pwsz) 
{
    return GetNewString(i_wsz, wcslen(i_wsz), o_pwsz);
}

//
// for debugging only
//
void CStringPool::ToConsole() const
{
    ULONG i;

    for(i = 0; i < m_PoolFixedSize.GetUsed(); i++)
    {
        wprintf(L"%s\n", Lookup(i));
    }
    for(i = 0; i < m_PoolDynamic.GetUsed(); i++)
    {
        wprintf( L"%s\n", Lookup( i | (1 << 31) ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\iisprov.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    iisprov.cpp

Abstract:

    Defines the CIISInstProvider class.  An object of this class is
    created by the class factory for each connection.

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#define WMI_HR(hr)  \
    (FAILED(hr) && HRESULT_FACILITY(hr) != FACILITY_ITF) ? WBEM_E_FAILED : hr

#include "iisprov.h"
#include "appladmin.h"
#include "enum.h"
#include "ipsecurity.h"
#include "adminacl.h"
#include "certmap.h"
#include "iiswmimsg.h"
#include "pusher.h"
#include "instancehelper.h"
#include "webservicemethod.h"
#include "queryhelper.h"
#include "smartpointer.h"
#include "secconlib.h"
#include "MultiSzHelper.h"

#define PARAMS  WMI_METHOD_PARAM_DATA
#define METHODS WMI_METHOD_DATA
#define CLASSES WMI_CLASS_DATA
#define PROPS   METABASE_PROPERTY_DATA

extern CDynSchema* g_pDynSch; // Initialized to NULL in schemadynamic.cpp
bool CIISInstProvider::ms_bInitialized = false;
CSafeAutoCriticalSection* CIISInstProvider::m_SafeCritSec = NULL;

HRESULT CIISInstProvider::DoInitialize(
    LPWSTR                  i_wszUser,
    LONG                    i_lFlags,
    LPWSTR                  i_wszNamespace,
    LPWSTR                  i_wszLocale,
    IWbemServices*          i_pNamespace,
    IWbemContext*           i_pCtx,
    IWbemProviderInitSink*  i_pInitSink)
/*++

Synopsis: 
    According to stevm from WMI, calls to Initialize are guaranteed to be
    synchronized - so long as all providers are in the same namespace.

Arguments: [wszUser] - 
           [lFlags] - 
           [wszNamespace] - 
           [wszLocale] - 
           [pNamespace] - 
           [pCtx] - 
           [pInitSink] - 
           
Return Value: 

--*/
{
    HRESULT   hr = S_OK;
    CSafeLock csSafe(*m_SafeCritSec);

    hr = csSafe.Lock();
    hr = HRESULT_FROM_WIN32(hr);
    if(FAILED(hr))
    {
        return hr;
    }

    CPusher            pusher;
    CSchemaExtensions* pcatalog = NULL;
    hr                          = WBEM_S_NO_ERROR;    // return value
    LONG               lStatus  = WBEM_S_INITIALIZED; // param to SetStatus

    CComPtr<IWbemContext>  spCtx       = i_pCtx;     // must AddRef according to doc

    //
    // If we hit this, we are leaking memory, because m_pNamespace is 
    // initilaized in this function only and cleaned up by the destructor only.
    //
    DBG_ASSERT(m_pNamespace == NULL);

    //
    // Initialize members
    //
    m_pNamespace = new CWbemServices(i_pNamespace); 
    if(m_pNamespace == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        i_pInitSink->SetStatus(WBEM_E_FAILED,0);
        return hr;
    }

    //
    // If we've already initialized globals, jump to the end.
    // Else, we're going to initialize globals.
    //
    if(ms_bInitialized)
    {
        goto exit;
    }

    pcatalog = new CSchemaExtensions();
    if(pcatalog == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }

    //
    // Initialize the g_pDynSch
    // Populate pCatalog
    //
    DBGPRINTF((DBG_CONTEXT, "=> Instantiating CDynSchema\n"));
    DBG_ASSERT(!g_pDynSch);
    g_pDynSch = new CDynSchema();
    if(g_pDynSch == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }

    try
    {
        hr = g_pDynSch->Initialize();

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = g_pDynSch->RunRules(pcatalog);

        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // Use pCatalog, g_pDynSch to update repository
        //
        hr = pusher.Initialize(m_pNamespace, i_pCtx);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = pusher.Push(
            pcatalog,
            g_pDynSch->GetHashClasses(),
            g_pDynSch->GetHashAssociations());
    }
    
    catch (CIIsProvException e)
    {
        hr = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...) 
    {
        hr = WBEM_E_FAILED;
    }

    if(FAILED(hr))
    {
        goto exit;
    }
    
    ms_bInitialized = true;
    
exit:
    //
    // Destructor makes IST calls, so call before we unload dispenser dll.
    //
    delete pcatalog;
    pcatalog = NULL;

    if(FAILED(hr))
    {
        DBG_ASSERT(ms_bInitialized == false);
        DBGPRINTF((DBG_CONTEXT, "<= Deleting CDynSchema\n"));
        delete g_pDynSch;
        g_pDynSch = NULL;
        lStatus = WBEM_E_FAILED;
    }

    //
    //Let CIMOM know you are initialized
    //
    i_pInitSink->SetStatus(lStatus,0);

    csSafe.Unlock();
    return hr;
}

HRESULT CIISInstProvider::DoCreateInstanceEnumAsync( 
    const BSTR              i_ClassName,
    long                    i_lFlags, 
    IWbemContext*           i_pCtx, 
    IWbemObjectSink FAR*    i_pHandler
    )
/*++

Synopsis:
    Asynchronously enumerates the instances.

Arguments: 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_pNamespace != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObject FAR* pes = NULL;
  
    //
    // Do a check of arguments.
    //
    if(i_ClassName == NULL || i_pHandler == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try 
    {
        WorkerEnumObjectAsync(i_ClassName, i_pHandler);
    }
    catch (CIIsProvException e)
    {
        pes = ConstructExtendedStatus(&e);
        hr = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...) 
    {
        hr = WBEM_E_FAILED;
    }
   
    //
    // Set status
    //
    if(!pes)
    {
        pes = ConstructExtendedStatus(hr);
    }
    SCODE sc = i_pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, pes);
    if(pes)
    {
        pes->Release();
    }

    return sc;
}

HRESULT CIISInstProvider::DoDeleteInstanceAsync( 
    const BSTR          i_ObjectPath, 
    long                i_lFlags,
    IWbemContext*       i_pCtx,
    IWbemObjectSink*    i_pHandler
    )
{
    DBG_ASSERT(m_pNamespace != NULL);

    CObjectPathParser PathParser(e_ParserAcceptRelativeNamespace);
    ParsedObjectPath* pParsedObject = NULL;
    IWbemClassObject* pes = NULL;
    HRESULT           hr = WBEM_S_NO_ERROR;

    if(i_ObjectPath == NULL || i_pHandler == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    try
    {
        hr = CUtils::ParserErrToHR( PathParser.Parse(i_ObjectPath, &pParsedObject) );
        THROW_ON_ERROR(hr);
        DBG_ASSERT(pParsedObject);

        WorkerDeleteObjectAsync(pParsedObject);
    }
    catch (CIIsProvException e)
    {
        pes = ConstructExtendedStatus(&e);
        hr = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...) 
    {
        hr = WBEM_E_FAILED;
    }

    if (pParsedObject)
    {
        PathParser.Free(pParsedObject);
    }

    //
    // Set status
    //
    if(!pes)
    {
        pes = ConstructExtendedStatus(hr);
    }
    SCODE sc = i_pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, pes);
    if(pes)
    {
        pes->Release();
    }

    return sc;
}

HRESULT CIISInstProvider::DoExecMethodAsync(
    const BSTR          i_strObjectPath,                   
    const BSTR          i_strMethodName,
    long                i_lFlags,                       
    IWbemContext*       i_pCtx,                 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler
    )
{
    DBG_ASSERT(m_pNamespace != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObject* pes = NULL;

    //
    // Do a check of arguments and make sure we have pointer to Namespace
    //
    if( i_pHandler == NULL || 
        i_strMethodName == NULL || 
        i_strObjectPath == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try 
    {
        WorkerExecMethodAsync(
            i_strObjectPath,
            i_strMethodName, 
            i_pCtx,
            i_pInParams,
            i_pHandler
            );
    }
    catch (_com_error c)
    {
        hr = c.Error();
    }
    catch (CIIsProvException e) 
    {
        pes = ConstructExtendedStatus(&e);
        hr = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...)
    {
        hr = WBEM_E_FAILED;
    }

    //
    // Set status
    //
    if(!pes)
    {
        pes = ConstructExtendedStatus(hr);
    }
    SCODE sc = i_pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, pes);
    if(pes)
    {
        pes->Release();
    }

    return sc;
}

HRESULT CIISInstProvider::DoGetObjectAsync(
    const BSTR          i_ObjectPath, 
    long                i_lFlags,
    IWbemContext*       i_pCtx,
    IWbemObjectSink*    i_pHandler
    )
/*++

Synopsis:
    Creates an instance given a particular path value.

Arguments: 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_pNamespace != NULL);

    IWbemClassObject* pObj = NULL;
    IWbemClassObject* pes = NULL;
    HRESULT           hr = WBEM_S_NO_ERROR;

    if(i_ObjectPath == NULL || i_pHandler == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    try
    {
        WorkerGetObjectAsync(&pObj, i_ObjectPath, false);
    
        hr = i_pHandler->Indicate(1,&pObj);
        pObj->Release();
    }
    catch (CIIsProvException e)
    {
        pes = ConstructExtendedStatus(&e);
        hr = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...) 
    {
        hr = WBEM_E_FAILED;
    }

    //
    // Set status
    //
    if(!pes)
    {
        pes = ConstructExtendedStatus(hr);
    }
    SCODE sc = i_pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, pes);
    if(pes)
    {
        pes->Release();
    }

    return sc;
}
    
HRESULT CIISInstProvider::DoPutInstanceAsync( 
    IWbemClassObject*    i_pObj,
    long                 i_lFlags,
    IWbemContext*        i_pCtx,
    IWbemObjectSink*     i_pHandler
    )
{
    DBG_ASSERT(m_pNamespace != NULL);

    HRESULT                    hr = WBEM_S_NO_ERROR;
    CObjectPathParser          PathParser(e_ParserAcceptRelativeNamespace);
    ParsedObjectPath*          pParsedObject = NULL;
    CComPtr<IWbemClassObject>  spObjOld;
    CComBSTR                   sbstrObjPath;
    IWbemClassObject*          pes = NULL;

    if(i_pObj == NULL || i_pCtx == NULL || i_pHandler == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try 
    {
        _bstr_t    bstr = L"__RelPath"; 
        _variant_t vtObjPath;
        hr = i_pObj->Get(bstr, 0, &vtObjPath, NULL, NULL);
        THROW_ON_ERROR(hr);

        if (vtObjPath.vt != VT_BSTR)
        {
            bstr = L"__Class";
            vtObjPath.Clear();
            hr = i_pObj->Get(bstr, 0, &vtObjPath, NULL, NULL);
            THROW_ON_ERROR(hr);

            //
            // This means the user is trying to create an instance but did not
            // specify a primary key.
        }

        if(vtObjPath.vt != VT_BSTR)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_OBJECT);
        }

        hr = CUtils::ParserErrToHR( PathParser.Parse(vtObjPath.bstrVal, &pParsedObject) );
        THROW_ON_ERROR(hr);
        DBG_ASSERT(pParsedObject != NULL);

        bool      bInstanceExists = false; // existing or new instance

        WMI_CLASS* pWmiClass = NULL;
        ValidatePutParsedObject(
            pParsedObject, 
            i_pObj, 
            NULL, 
            &bInstanceExists,
            &pWmiClass);

        //
        // We auto-generate primary key only for IIsWebServer and IIsFtpServer
        //
        if( pParsedObject->m_dwNumKeys == 0 && 
            (pWmiClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebServer || 
             pWmiClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsFtpServer) )
        {
            //
            // Get the ServerComment
            //
            _variant_t vtServerComment;
            hr = i_pObj->Get(PROPS::s_ServerComment.pszPropName, 
                0, &vtServerComment, NULL, NULL);
            if(hr == WBEM_E_NOT_FOUND || vtServerComment.vt != VT_BSTR)
            {
                vtServerComment.Clear();
                vtServerComment.bstrVal = NULL;
                vtServerComment.vt      = VT_BSTR;
                hr = WBEM_S_NO_ERROR;
            }
            THROW_ON_ERROR(hr);

            //
            // Create the site
            //
            eSC_SUPPORTED_SERVICES eServiceId;
            _bstr_t sbstrKeyValue;
            DWORD   dwSiteId      = 0;
            WCHAR   wszSiteId[11] = {0};

            if( pWmiClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebServer )
            {
                eServiceId      = SC_W3SVC;
                sbstrKeyValue   = "w3svc/";
            }
            else
            {
                eServiceId      = SC_MSFTPSVC;
                sbstrKeyValue   = "msftpsvc/";
            }
            CServiceMethod method(eServiceId);
            hr = method.Init();
            THROW_ON_ERROR(hr);
            hr = method.CreateNewSite(vtServerComment.bstrVal, &dwSiteId);
            THROW_ON_ERROR(hr);
            sbstrKeyValue += _itow(dwSiteId, wszSiteId, 10);

            VARIANT vtKeyValue;
            vtKeyValue.bstrVal = sbstrKeyValue;
            vtKeyValue.vt      = VT_BSTR;
            THROW_ON_FALSE(pParsedObject->AddKeyRefEx(pWmiClass->pszKeyName, &vtKeyValue));
        }

        if( pWmiClass->pkt != &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE &&
            pWmiClass->pkt != &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL &&
            pWmiClass->pkt != &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity )
        {
            WorkerGetObjectAsync(&spObjOld, pParsedObject, true);
        }

        WorkerPutObjectAsync(
            i_pObj, 
            spObjOld, 
            pParsedObject, 
            i_lFlags, 
            bInstanceExists,
            &sbstrObjPath);
    }    
    catch (CIIsProvException e)
    {
        pes = ConstructExtendedStatus(&e);
        hr  = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...)
    {
        hr = WBEM_E_FAILED;
    }

    if (pParsedObject)
    {
        PathParser.Free(pParsedObject);
    }

    //
    // Set status
    //
    if(!pes)
    {
        pes = ConstructExtendedStatus(hr);
    }
    SCODE sc = i_pHandler->SetStatus(
        WBEM_STATUS_COMPLETE, hr, sbstrObjPath, pes);
    if(pes)
    {
        pes->Release();
    }

    return sc;
}

HRESULT CIISInstProvider::DoExecQueryAsync( 
    const BSTR                  i_bstrQueryLanguage,
    const BSTR                  i_bstrQuery,
    long                        i_lFlags,
    IWbemContext*               i_pCtx,
    IWbemObjectSink*            i_pResponseHandler)
{
    if( i_bstrQueryLanguage == NULL ||
        i_bstrQuery         == NULL ||
        i_pCtx              == NULL ||
        i_pResponseHandler  == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    DBG_ASSERT(m_pNamespace != NULL);

    HRESULT                     hr  = WBEM_S_NO_ERROR;
    IWbemClassObject*           pes = NULL;

    try
    {
        CQueryHelper QueryHelper(
            i_bstrQueryLanguage,
            i_bstrQuery,
            m_pNamespace,
            i_pResponseHandler);
        if(QueryHelper.IsAssoc())
        {
            QueryHelper.GetAssociations();
        }
        else
        {
            QueryHelper.GetInstances();
        }
    }
    catch (CIIsProvException e)
    {
        pes = ConstructExtendedStatus(&e);
        hr  = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...)
    {
        hr = WBEM_E_FAILED;
    }

    //
    // Set status
    //
    if(!pes)
    {
        pes = ConstructExtendedStatus(hr);
    }
    SCODE sc = i_pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, pes);
    if(pes)
    {
        pes->Release();
    }

    return sc;
}

IWbemClassObject* CIISInstProvider::ConstructExtendedStatus(
    HRESULT i_hr) const
{
    IWbemClassObject* pes     = NULL;

    //
    // We only need extended status on failure.
    //
    if(SUCCEEDED(i_hr))
    {
        return NULL;
    }

    CIIsProvException e;
    e.SetHR(i_hr);

    pes = ConstructExtendedStatus(&e);

    return pes;
}

IWbemClassObject* CIISInstProvider::ConstructExtendedStatus(
    const CIIsProvException* i_pException) const
{
    DBG_ASSERT(m_pNamespace != NULL);
    DBG_ASSERT(i_pException != NULL);

    HRESULT hr;
    CComPtr<IWbemClassObject> spClass;
    CComPtr<IWbemClassObject> spES;
    IWbemClassObject*         pESRet = NULL;

    CComBSTR sbstr = L"__ExtendedStatus";
    if(sbstr.m_str == NULL)
    {
        return NULL;
    }

    //
    // Get the __ExtendedStatus class and Spawn and instance
    //
    hr = m_pNamespace->GetObject(
        sbstr,
        0,
        NULL,
        &spClass,
        NULL
        );
    if(FAILED(hr))
    {
        return NULL;
    }

    hr = spClass->SpawnInstance(0, &spES);
    if(FAILED(hr))
    {
        return NULL;
    }

    //
    // Set the description.
    //
    CComVariant svt;
    sbstr.Empty();
    sbstr = i_pException->GetErrorText();
    svt = sbstr.Detach();
    if(svt.vt == VT_BSTR && svt.bstrVal != NULL)
    {
        hr = spES->Put(L"Description", 0, &svt, 0);
        if(FAILED(hr))
        {
            return NULL;
        }
    }

    //
    // Set the status code.
    //
    svt = i_pException->GetHR();
    hr = spES->Put(L"StatusCode", 0, &svt, 0);
    if(FAILED(hr))
    {
        return NULL;
    }

    //
    // Set the parameter info.
    //
    svt = i_pException->GetParams();
    if(svt.vt == VT_BSTR && svt.bstrVal != NULL)
    {
        hr = spES->Put(L"ParameterInfo", 0, &svt, 0);
        if(FAILED(hr))
        {
            return NULL;
        }
    }

    //
    // Set the provider name.
    //
    svt = g_wszIIsProvider;
    if(svt.vt == VT_BSTR && svt.bstrVal != NULL)
    {
        hr = spES->Put(L"ProviderName", 0, &svt, 0);
        if(FAILED(hr))
        {
            return NULL;
        }
    }

    //
    // If everything succeeded...
    //
    spES.CopyTo(&pESRet);
    return pESRet;
}

void CIISInstProvider::WorkerExecMethodAsync(
    BSTR                i_strObjectPath,
    BSTR                i_strMethodName,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler
    )
{ 
    DBG_ASSERT(i_strObjectPath != NULL);
    DBG_ASSERT(i_strMethodName != NULL);
    DBG_ASSERT(i_pHandler      != NULL);
    DBG_ASSERT(m_pNamespace    != NULL);

    WMI_CLASS*          pWMIClass;
    CObjectPathParser   PathParser(e_ParserAcceptRelativeNamespace);
    TSmartPointer<ParsedObjectPath> spParsedObjPath;
    _bstr_t             bstrMbPath;
    WMI_METHOD*         pmethod;
    HRESULT             hr   = WBEM_S_NO_ERROR;

    hr = CUtils::ParserErrToHR( PathParser.Parse(i_strObjectPath, &spParsedObjPath) );
    THROW_ON_ERROR(hr);
    DBG_ASSERT(spParsedObjPath != NULL);

    if (!CUtils::GetClass(spParsedObjPath->m_pClass,&pWMIClass))
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS);
    }

    if (!CUtils::GetMethod(i_strMethodName, pWMIClass->ppMethod, &pmethod ))
    {
        THROW_ON_ERROR(WBEM_E_INVALID_METHOD);
    }

    CUtils::GetMetabasePath(NULL,spParsedObjPath,pWMIClass,bstrMbPath);    

    if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsFtpService)
    {
        WorkerExecFtpServiceMethod(
            bstrMbPath, 
            pWMIClass,
            pmethod,
            i_pCtx,
            i_pInParams,
            i_pHandler);
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebService)
    {
        WorkerExecWebServiceMethod(
            bstrMbPath, 
            pWMIClass,
            pmethod,
            i_pCtx,
            i_pInParams,
            i_pHandler);
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
        pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebServer)
    {
        CMetabase metabase;
        HRESULT hr = S_OK;
        metabase.PutMethod(bstrMbPath, pmethod->dwMDId);
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
        pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory)
    {
        WorkerExecWebAppMethod(
            bstrMbPath, 
            pWMIClass->pszClassName,
            pmethod,
            i_pCtx,
            i_pInParams,
            i_pHandler,
            m_pNamespace
            );
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsComputer)
    {
        WorkerExecComputerMethod(
            bstrMbPath, 
            pWMIClass->pszClassName,
            pmethod,
            i_pCtx,
            i_pInParams,
            i_pHandler,
            m_pNamespace
            );
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsCertMapper)
    {
        WorkerExecCertMapperMethod(
            bstrMbPath, 
            pWMIClass->pszClassName,
            pmethod,
            i_pCtx,
            i_pInParams,
            i_pHandler,
            m_pNamespace
            );
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsApplicationPool)
    {
        WorkerExecAppPoolMethod(
            bstrMbPath, 
            pWMIClass->pszClassName,
            pmethod,
            i_pCtx,
            i_pInParams,
            i_pHandler,
            m_pNamespace
            );
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_METHOD);
    }
}

void CIISInstProvider::WorkerDeleteObjectAsync(
    ParsedObjectPath*    i_pParsedObject
    )
{ 
    DBG_ASSERT(m_pNamespace    != NULL);
    DBG_ASSERT(i_pParsedObject != NULL);

    HRESULT              hr   = WBEM_S_NO_ERROR;
    _bstr_t              bstrMbPath;
    WMI_CLASS*           pWMIClass;
    METADATA_HANDLE      hKey = NULL;
    CMetabase            metabase;

    if (!CUtils::GetClass(i_pParsedObject->m_pClass,&pWMIClass))
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS);
    }

    //
    // get the meta path of object
    //
    CUtils::GetMetabasePath(NULL,i_pParsedObject,pWMIClass,bstrMbPath);

    // Special case - we want to be able to delete
    // IIsIPSecurity instances without deleting the node
    // and without checking the KeyType

    if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity)
    {
        hKey = metabase.OpenKey(bstrMbPath, true);
        try
        {
            metabase.DeleteData(hKey, MD_IP_SEC, BINARY_METADATA);
        }
        catch (HRESULT hrError)
        {
            metabase.CloseKey(hKey);
            THROW_ON_ERROR(hrError)
        }
        catch (...)
        {
            metabase.CloseKey(hKey);
            THROW_ON_ERROR(WBEM_E_FAILED)
        }

        metabase.CloseKey(hKey);
        return;
    }

    // if AdminACL
    //
    if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL )
    {
        THROW_ON_ERROR(WBEM_E_NOT_SUPPORTED);
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE)
    {
        CAdminACL objACL;
        CMetabase   metabase;
        hr = objACL.OpenSD(bstrMbPath, metabase);
        if(SUCCEEDED(hr))
            hr = objACL.DeleteObjectAsync(i_pParsedObject);
        THROW_ON_ERROR(hr);
        return;
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsApplicationPool)
    {
        CAppPoolMethod objAppPool;
        objAppPool.DeleteAppPool(bstrMbPath);
        return;
    }

    // check that the KeyType is correct
    _variant_t vt;
    hKey = metabase.OpenKey(bstrMbPath, false);    
    metabase.Get(hKey, &METABASE_PROPERTY_DATA::s_KeyType, m_pNamespace, vt, NULL, NULL);
    metabase.CloseKey(hKey);
    if( vt.vt != VT_BSTR   || 
        vt.bstrVal == NULL ||
        !CUtils::CompareKeyType(vt.bstrVal, pWMIClass->pkt) )
    {
        CIIsProvException e;
        e.SetMC(WBEM_E_NOT_FOUND, IISWMI_INVALID_KEYTYPE, NULL);
        throw e;
    }
    vt.Clear();
    
    if( pWMIClass->pkt->m_pszDisallowDeletionNode &&
        _wcsicmp(bstrMbPath, pWMIClass->pkt->m_pszDisallowDeletionNode) == 0 )
    {
        CIIsProvException e;
        e.SetMC(WBEM_E_INVALID_OPERATION, IISWMI_INSTANCE_DELETION_DISALLOWED, NULL);
        throw e;
    }

    DBG_ASSERT(((LPWSTR)(bstrMbPath))[0] == L'/');
    DBG_ASSERT(((LPWSTR)(bstrMbPath))[1] != L'\0');
    LPWSTR pParent = wcsrchr(bstrMbPath, L'/');

    WCHAR wcStore = *pParent;
    *pParent      = L'\0';

    hKey     = metabase.OpenKey(bstrMbPath, true);
    *pParent = wcStore;
    hr       = metabase.DeleteKey(hKey, pParent);
    THROW_ON_ERROR(hr);
  
    metabase.CloseKey(hKey);
}

void CIISInstProvider::WorkerGetObjectAsync(
    IWbemClassObject**   o_ppObj,
    ParsedObjectPath*    i_pParsedObjPath,
    bool                 i_bCreateKeyIfNotExist)
{
    WMI_CLASS*       pWmiClass = NULL;
    WMI_ASSOCIATION* pWmiAssoc = NULL;
    CMetabase        metabase;

    CInstanceHelper  InstanceHelper(i_pParsedObjPath, m_pNamespace);

    if(!InstanceHelper.IsAssoc())
    {
        InstanceHelper.GetInstance(
            i_bCreateKeyIfNotExist,     // in
            &metabase,                  // in/out
            o_ppObj);                   // out
    }
    else
    {
        InstanceHelper.GetAssociation(
            o_ppObj);                   // out
    }
}

void CIISInstProvider::WorkerGetObjectAsync(
    IWbemClassObject**   o_ppObj,
    BSTR                 i_bstrObjPath,
    bool                 i_bCreateKeyIfNotExist)
{
    WMI_CLASS*       pWmiClass = NULL;
    WMI_ASSOCIATION* pWmiAssoc = NULL;
    CMetabase        metabase;

    CInstanceHelper  InstanceHelper(i_bstrObjPath, m_pNamespace);

    if(!InstanceHelper.IsAssoc())
    {
        InstanceHelper.GetInstance(
            i_bCreateKeyIfNotExist,     // in
            &metabase,                  // in/out
            o_ppObj);                   // out
    }
    else
    {
        InstanceHelper.GetAssociation(
            o_ppObj);                   // out
    }
}

void CIISInstProvider::ValidatePutParsedObject(
    ParsedObjectPath*    i_pParsedObject,
    IWbemClassObject*    i_pObj,
    bool*                io_pbInstanceNameSame,
    bool*                io_pbInstanceExists,
    WMI_CLASS**          o_ppWmiClass
    )
/*++

Synopsis: 
    Validates stuff before a Put operation.

      - Checks to see that the user is not changing the instance's
        primary key.

      - Verifies the parent metabase node exists.

      - Checks the container class list of the parent node in the metabase
        to see if it contains the node we are trying to insert.

      - Throws on failure.  You should not continue with the put operation.

Arguments: [i_pParsedObject] - 
           
--*/
{    
    DBG_ASSERT(i_pParsedObject != NULL);
    DBG_ASSERT(i_pObj          != NULL);
    DBG_ASSERT(m_pNamespace    != NULL);

    WMI_CLASS*           pWMIClass  = NULL;
    WMI_ASSOCIATION*     pWMIAssoc  = NULL;
    _bstr_t              bstrMbPath;
    HRESULT              hr         = WBEM_S_NO_ERROR;

    if(CUtils::GetClass(i_pParsedObject->m_pClass,&pWMIClass))
    {
    }
    else if(CUtils::GetAssociation(i_pParsedObject->m_pClass,&pWMIAssoc))
    {
        THROW_ON_ERROR(WBEM_E_INVALID_OPERATION);
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS)
    }
    if(o_ppWmiClass)
    {
        *o_ppWmiClass = pWMIClass;
    }

    bool bSpecialPut = false;
    if( i_pParsedObject->m_dwNumKeys == 0)
    {
        if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsFtpServer )
        {
            bSpecialPut = true;
        }
        else
        {
            THROW_ON_ERROR(WBEM_E_INVALID_OBJECT);
        }
    }

    if(!bSpecialPut)
    {
        CUtils::GetMetabasePath(NULL, i_pParsedObject, pWMIClass, bstrMbPath);
        DBG_ASSERT(((LPWSTR)bstrMbPath) != NULL);
    }

    //
    // Get the instance qualifiers in order to eventually evaluate
    // that the user has not tried to change the primary key on
    // this instance.
    //
    const ULONG iQuals = 2;
    _variant_t  avtQualValues[iQuals];
    LPCWSTR     awszQualNames[iQuals];

    DBG_ASSERT(g_idxInstanceExists < iQuals);
    DBG_ASSERT(g_idxInstanceName   < iQuals);

    awszQualNames[g_idxInstanceExists] = g_wszInstanceExists;
    awszQualNames[g_idxInstanceName]   = g_wszInstanceName;
    hr = CUtils::GetQualifiers(i_pObj, awszQualNames, avtQualValues, iQuals);
    THROW_ON_ERROR(hr);

    //
    // We assume the instance names are the same unless we can explicitly
    // detect they are not.
    //
    bool bInstanceNameSame = true;
    if( avtQualValues[g_idxInstanceName].vt == VT_BSTR &&
        avtQualValues[g_idxInstanceName].bstrVal != NULL)
    {
        if(!bSpecialPut)
        {
            if(_wcsicmp(avtQualValues[g_idxInstanceName].bstrVal, bstrMbPath) != 0)
            {
                bInstanceNameSame = false;
            }
        }
        else
        {
            bInstanceNameSame = false;
        }
    }

    bool bInstanceExists = false;
    if( avtQualValues[g_idxInstanceExists].vt == VT_BOOL &&
        avtQualValues[g_idxInstanceExists].boolVal )
    {
        bInstanceExists = true;
    }

    if(bInstanceExists && !bInstanceNameSame)
    {
        //
        // Someone has tried to change the primary key.
        //
        CIIsProvException e;
        e.SetMC(WBEM_E_FAILED, IISWMI_CANNOT_CHANGE_PRIMARY_KEY_FIELD, NULL);
        DBGPRINTF((DBG_CONTEXT, "Cannot change primary key field\n"));
        throw e;
    }

    if(io_pbInstanceExists)
    {
        *io_pbInstanceExists   = bInstanceExists;
    }
    if(io_pbInstanceNameSame)
    {
        *io_pbInstanceNameSame = bInstanceNameSame;
    }

    //
    // Now verify that if this is a new class, creation is allowed.
    //
    if(!bInstanceExists && !pWMIClass->bCreateAllowed)
    {
        CIIsProvException e;
        e.SetMC(WBEM_E_FAILED, IISWMI_INSTANCE_CREATION_DISALLOWED, NULL);
        DBGPRINTF((DBG_CONTEXT, "Instance creation disallowed\n"));
        throw e;
    }

    if(bSpecialPut)
    {
        return;
    }

    //
    // Now, validate the keytype against the parent's container
    // class list.  The return cases below are the few times
    // we actually won't do this validation.
    //
    METADATA_HANDLE      hKey = NULL;

    if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE ||
        pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||
        pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity)
    {
        return;
    }
    if(((LPWSTR)bstrMbPath) && _wcsicmp(bstrMbPath, L"/LM") == 0)
    {
        return;
    }

    ULONG cch = wcslen(bstrMbPath);
    CComBSTR sbstrMbParentPath(cch);
    if(sbstrMbParentPath.m_str == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }
    hr = CUtils::GetParentMetabasePath(
        bstrMbPath,
        sbstrMbParentPath);
    if(FAILED(hr))
    {
        //
        // There is no parent node in the string specified
        //
        return;
    }

    //
    // Get parent keytype from metabase
    //
    WMI_CLASS* pWMIParentClass = NULL;
    CMetabase  metabase;
    _variant_t vt;

    hKey = metabase.OpenKey(sbstrMbParentPath, false);
    metabase.Get(hKey, &METABASE_PROPERTY_DATA::s_KeyType, m_pNamespace, vt, NULL, NULL);
    metabase.CloseKey(hKey);

    if( vt.vt != VT_BSTR)
    {
        CIIsProvException e;
        e.SetMC(
            WBEM_E_INVALID_OBJECT, 
            IISWMI_NO_PARENT_KEYTYPE, 
            NULL, 
            pWMIClass->pkt->m_pszName);
        DBGPRINTF((DBG_CONTEXT, "No parent keytype.\n"));
        throw e;
    }

    //
    // Walk thru the current class's inverse container class list and see
    // if the parent keytype is there.
    //
    if(!CUtils::GetClass(vt.bstrVal, &pWMIParentClass))
    {
        if( _wcsicmp(vt.bstrVal, L"IIs_ROOT") == 0 &&
            pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsComputer )
        {
            return;
        }
        else
        {
            CIIsProvException e;
            e.SetMC(
                WBEM_E_INVALID_OBJECT, 
                IISWMI_INVALID_PARENT_KEYTYPE, 
                NULL, 
                pWMIClass->pkt->m_pszName, 
                L"<NULL>");
            DBGPRINTF((DBG_CONTEXT, "Invalid parent keytype.\n"));
            throw e;
        }
    }
    METABASE_KEYTYPE_NODE* pKtNode = pWMIClass->pkt->m_pKtListInverseCCL;
    while(pKtNode != NULL)
    {
        if(pWMIParentClass->pkt == pKtNode->m_pKt)
        {
            break;
        }
        pKtNode = pKtNode->m_pKtNext;
    }
    if(pKtNode == NULL)
    {
        CIIsProvException e;
        e.SetMC(
            WBEM_E_INVALID_OBJECT, 
            IISWMI_INVALID_PARENT_KEYTYPE, 
            NULL, 
            pWMIClass->pkt->m_pszName, 
            pWMIParentClass->pkt->m_pszName);
        DBGPRINTF((DBG_CONTEXT, "Invalid parent keytype.\n"));
        throw e;
    }
}

void CIISInstProvider::WorkerPutObjectAsync(
    IWbemClassObject*    i_pObj,
    IWbemClassObject*    i_pObjOld,               // can be NULL
    ParsedObjectPath*    i_pParsedObject,
    long                 i_lFlags,
    bool                 i_bInstanceExists,
    BSTR*                o_pbstrObjPath
    )
{ 
    DBG_ASSERT(i_pObj          != NULL);
    DBG_ASSERT(i_pParsedObject != NULL);
    DBG_ASSERT(m_pNamespace    != NULL);
    DBG_ASSERT(o_pbstrObjPath  != NULL);
    DBG_ASSERT(*o_pbstrObjPath == NULL);

    *o_pbstrObjPath = NULL;

    CComBSTR             sbstrObjPath;
    HRESULT              hr        = WBEM_S_NO_ERROR;
    METABASE_PROPERTY**  ppmbp;
    _bstr_t              bstrMbPath;
    WMI_CLASS*           pWMIClass;
    METADATA_HANDLE      hKey = NULL;
    DWORD                dwQuals = 0;

    if (!CUtils::GetClass(i_pParsedObject->m_pClass,&pWMIClass))
        throw (HRESULT)WBEM_E_INVALID_CLASS;

    CUtils::GetMetabasePath(NULL,i_pParsedObject,pWMIClass,bstrMbPath);

    //
    // if AdminACL
    //
    if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||
        pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE
        )
    {
        CAdminACL objACL;
        CMetabase   metabase;
        hr = objACL.OpenSD(bstrMbPath, metabase);
        if( SUCCEEDED(hr) )        
            hr = objACL.PutObjectAsync(i_pObj, i_pParsedObject, pWMIClass);
        THROW_ON_ERROR(hr);
        return;
    }
    //
    // IPSecurity
    //
    if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity )
    {
        CIPSecurity objIPSec;
        CMetabase   metabase;
        hr = objIPSec.OpenSD(bstrMbPath, metabase);
        if( SUCCEEDED(hr) )        
            hr = objIPSec.PutObjectAsync(i_pObj);
        THROW_ON_ERROR(hr);
        return;
    }

    //
    // Walk thru the properties
    //
    CMetabase metabase;
    hKey = metabase.CreateKey(bstrMbPath);

    _variant_t  vt;
    _variant_t  vtOld;
    _variant_t* pvtOld;
    _bstr_t     bstrPropName;

    for (ppmbp=pWMIClass->ppmbp;*ppmbp && hr==WBEM_S_NO_ERROR; ppmbp++) 
    {
        bstrPropName = (*ppmbp)->pszPropName;
        hr = i_pObj->Get(bstrPropName, 0, &vt, NULL, NULL);

        //
        // Just ignore properties that are not in the repository.
        //
        if(FAILED(hr))
        {
            hr = WBEM_S_NO_ERROR;
            continue;
        }

        //
        // Get the property qualifiers
        //
        hr = CUtils::GetPropertyQualifiers(i_pObj, bstrPropName, &dwQuals);
        THROW_E_ON_ERROR(hr,*ppmbp);

        pvtOld = NULL;
        if(i_pObjOld != NULL) 
        {
            hr = i_pObjOld->Get(bstrPropName, 0, &vtOld, NULL, NULL);
            pvtOld = &vtOld;
            THROW_E_ON_ERROR(hr,*ppmbp);
        }
        THROW_E_ON_ERROR(hr,*ppmbp);
        
        if (vt.vt == VT_NULL) 
        {
            //
            // Only delete non-flag properties.
            //
            if ((*ppmbp)->dwMDMask == 0 && vtOld.vt != VT_NULL)
            {
                if(i_bInstanceExists)
                {
                    metabase.DeleteData(hKey, *ppmbp, true);
                }
                else
                {
                    metabase.DeleteData(hKey, *ppmbp, false);
                }
            }
            continue;
        }

        metabase.Put(
            hKey, 
            *ppmbp, 
            m_pNamespace,
            vt, 
            pvtOld, 
            dwQuals, 
            i_bInstanceExists);
        vt.Clear();
        vtOld.Clear();
    }
    
    if( pWMIClass->pkt != NULL && 
        pWMIClass->pkt->m_pszName != NULL &&
        pWMIClass->pkt != &METABASE_KEYTYPE_DATA::s_IIsObject )
    {
        vt = pWMIClass->pkt->m_pszName;
        metabase.PutString(hKey, &METABASE_PROPERTY_DATA::s_KeyType, vt, NULL);
    }

    metabase.CloseKey(hKey);

    hr = CUtils::ConstructObjectPath(bstrMbPath, pWMIClass, &sbstrObjPath);
    THROW_ON_ERROR(hr);

    //
    // Set out parameters if everything succeeds
    //
    *o_pbstrObjPath = sbstrObjPath.Detach();
}

void CIISInstProvider::WorkerEnumObjectAsync(
    BSTR                    i_bstrClassName, 
    IWbemObjectSink FAR*    i_pHandler
    )
{
    WMI_CLASS*          pClass;
    WMI_ASSOCIATION*    pAssociation = NULL;
    ParsedObjectPath    ParsedObject;            //deconstructer frees memory

    if (CUtils::GetAssociation(i_bstrClassName,&pAssociation))
    {
        CEnum EnumAssociation;
        EnumAssociation.Init(
            i_pHandler,
            m_pNamespace,
            &ParsedObject,
            pAssociation->pcRight->pszMetabaseKey,
            pAssociation
            );
        EnumAssociation.Recurse(
            NULL,
            &METABASE_KEYTYPE_DATA::s_IIsComputer,        
            NULL,
            pAssociation->pcRight->pszKeyName,
            pAssociation->pcRight->pkt
            );
    } 
    else if (CUtils::GetClass(i_bstrClassName,&pClass))
    {
        if (!ParsedObject.SetClassName(pClass->pszClassName))
            throw (HRESULT)WBEM_E_FAILED;

        CEnum EnumObject;
        EnumObject.Init(
            i_pHandler,
            m_pNamespace,
            &ParsedObject,
            pClass->pszMetabaseKey,
            NULL
            );
        EnumObject.Recurse(
            NULL,
            &METABASE_KEYTYPE_DATA::s_NO_TYPE,
            NULL,
            pClass->pszKeyName, 
            pClass->pkt
            );
    }
    else
        throw (HRESULT)WBEM_E_INVALID_CLASS;
}


void CIISInstProvider::WorkerExecWebAppMethod(
    LPCWSTR             i_wszMbPath,
    LPCWSTR             i_wszClassName,
    WMI_METHOD*         i_pMethod,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler,
    CWbemServices*      i_pNameSpace 
    )
{
    HRESULT    hr = WBEM_S_NO_ERROR;
    _variant_t vt;                      // stores the parameter value
    _variant_t vt2;                      // stores the parameter value
    _variant_t vt3;                      // stores the parameter value
    CWebAppMethod obj;                  // encapsulates all the web app methods

    if(i_pMethod == &METHODS::s_AppCreate)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_InProcFlag.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.AppCreate(i_wszMbPath, vt); 
    }
    else if(i_pMethod == &METHODS::s_AppCreate2)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }
        
        hr = i_pInParams->Get(PARAMS::s_AppMode.pszParamName, 0, &vt, NULL, NULL);   
        THROW_ON_ERROR(hr);

        hr = obj.AppCreate2(i_wszMbPath, vt); 
    }
    else if(i_pMethod == &METHODS::s_AppCreate3)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }
        
        hr = i_pInParams->Get(PARAMS::s_AppMode.pszParamName, 0, &vt, NULL, NULL);   
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_AppPoolName.pszParamName, 0, &vt2, NULL, NULL);   
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_bCreate.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);

        if (vt3.vt != VT_BOOL) {
            hr = obj.AppCreate3(i_wszMbPath, vt, 
                                CUtils::ExtractBstrFromVt(&vt2, PARAMS::s_AppPoolName.pszParamName),
                                false);
        }
        else {
            hr = obj.AppCreate3(i_wszMbPath, vt, 
                                CUtils::ExtractBstrFromVt(&vt2, PARAMS::s_AppPoolName.pszParamName),
                                vt3);
        }
    }
    else if(i_pMethod == &METHODS::s_AppDelete)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Recursive.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.AppDelete(i_wszMbPath, vt);
    }
    else if(i_pMethod == &METHODS::s_AppDisable)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Recursive.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.AppDisable(i_wszMbPath, vt);
    }
    else if(i_pMethod == &METHODS::s_AppEnable)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Recursive.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.AppEnable(i_wszMbPath, vt);
    }
    else if(i_pMethod == &METHODS::s_AppUnLoad)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Recursive.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.AppUnLoad(i_wszMbPath, vt);
    }
    else if(i_pMethod == &METHODS::s_AppGetStatus)
    {
        //
        // call method - AppGetStatus
        //
        DWORD dwStatus;
        hr = obj.AppGetStatus(i_wszMbPath, &dwStatus);
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams = NULL;
        hr = CUtils::CreateEmptyMethodInstance(
            i_pNameSpace,
            i_pCtx,
            i_wszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        //
        // put it into the output object
        //
        vt.vt   = VT_I4;
        vt.lVal = dwStatus;
        hr = spOutParams->Put(L"ReturnValue", 0, &vt, 0);      
        THROW_ON_ERROR(hr); 

        //
        // Send the output object back to the client via the sink. Then 
        // release the pointers and free the strings.
        //
        hr = i_pHandler->Indicate(1, &spOutParams);
    }
    else if(i_pMethod == &METHODS::s_AspAppRestart)
    {
        hr = obj.AspAppRestart(i_wszMbPath);
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }

    THROW_ON_ERROR(hr);
}

void CIISInstProvider::WorkerExecFtpServiceMethod(
    LPCWSTR             i_wszMbPath,
    WMI_CLASS*          i_pClass,
    WMI_METHOD*         i_pMethod,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler)
{
    DBG_ASSERT(i_pClass       != NULL);
    DBG_ASSERT(i_pHandler     != NULL);
    DBG_ASSERT(m_pNamespace   != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    if(i_pMethod == &METHODS::s_ServiceCreateNewServer)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        CServiceMethod ServiceMethod(SC_MSFTPSVC);
        hr = ServiceMethod.Init();
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams;
        hr = ServiceMethod.CreateNewSite(
            m_pNamespace,
            i_wszMbPath,
            i_pCtx,
            i_pClass,
            i_pMethod,
            i_pInParams,
            &spOutParams);
        THROW_ON_ERROR(hr);

        hr = i_pHandler->Indicate(1, &spOutParams);
        THROW_ON_ERROR(hr);
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }

    THROW_ON_ERROR(hr);
}


void CIISInstProvider::WorkerExecWebServiceMethod(
    LPCWSTR             i_wszMbPath,
    WMI_CLASS*          i_pClass,
    WMI_METHOD*         i_pMethod,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler
    )
{
    DBG_ASSERT(i_pHandler   != NULL);
    DBG_ASSERT(m_pNamespace != NULL);

    HRESULT   hr          = WBEM_S_NO_ERROR;
    _variant_t vt;                      // stores the parameter value
    _variant_t vt2;                     // stores the parameter value
    _variant_t vt3;                     // stores the parameter value
    _variant_t vt4;                     // stores the parameter value
    _variant_t vt5;                     // stores the parameter value
    METADATA_HANDLE hKey  = 0;

    if(i_pMethod == &METHODS::s_GetCurrentMode)
    {
        _variant_t     vtServerMode;
        CAppPoolMethod obj;
        obj.GetCurrentMode(&vtServerMode);

        //
        // Set out params
        //
        CComPtr<IWbemClassObject> spOutParams = NULL;
        hr = CUtils::CreateEmptyMethodInstance(
            m_pNamespace,
            i_pCtx,
            i_pClass->pszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        hr = spOutParams->Put(L"ReturnValue", 0, &vtServerMode, 0);
        THROW_ON_ERROR(hr);

        hr = i_pHandler->Indicate(1, &spOutParams);
        THROW_ON_ERROR(hr);
    }
    else if(i_pMethod == &METHODS::s_ServiceCreateNewServer)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        CServiceMethod ServiceMethod(SC_W3SVC);
        hr = ServiceMethod.Init();
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams;
        hr = ServiceMethod.CreateNewSite(
            m_pNamespace,
            i_wszMbPath,
            i_pCtx,
            i_pClass,
            i_pMethod,
            i_pInParams,
            &spOutParams);
        THROW_ON_ERROR(hr);

        hr = i_pHandler->Indicate(1, &spOutParams);
        THROW_ON_ERROR(hr);
    }
    else if (i_pMethod == &METHODS::s_ServiceEnableApplication)
    {
        if (i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Application.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        CSecConLib consoleHelper;
		_bstr_t bstrTemp(vt);
        WCHAR* pTemp = bstrTemp;

        if (!pTemp)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);    
        }

        hr = consoleHelper.EnableApplication(pTemp, i_wszMbPath);
    }
    else if (i_pMethod == &METHODS::s_ServiceRemoveApplication)
    {
        if (i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Application.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        CSecConLib consoleHelper;
        hr = consoleHelper.RemoveApplication(_bstr_t(vt), i_wszMbPath);
    }
    else if (i_pMethod == &METHODS::s_ServiceListApplications)
    {
        WCHAR *pBuf = NULL;
        DWORD  dwBufLen;
        CSecConLib consoleHelper;
        hr = consoleHelper.ListApplications(i_wszMbPath, &pBuf, &dwBufLen);
        THROW_ON_ERROR(hr);

        CComVariant vBuf;
        VariantInit(&vBuf);
        CMultiSz MultiSz;
        hr = MultiSz.ToWmiForm( pBuf, &vBuf );
        if (pBuf)
        {
            delete [] pBuf;
        }
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams = NULL;
        hr = CUtils::CreateEmptyMethodInstance(
            m_pNamespace,
            i_pCtx,
            i_pClass->pszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        hr = spOutParams->Put(PARAMS::s_Applications.pszParamName, 0, &vBuf, 0);
        THROW_ON_ERROR(hr);

        hr = i_pHandler->Indicate(1, &spOutParams);
        THROW_ON_ERROR(hr);
    }
    else if (i_pMethod == &METHODS::s_ServiceQueryGroupIDStatus)
    {
        if (i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_GroupID.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        WCHAR *pBuf = NULL;
        DWORD  dwBufLen;
        CSecConLib consoleHelper;
        hr = consoleHelper.QueryGroupIDStatus(i_wszMbPath, _bstr_t(vt), &pBuf, &dwBufLen);
        THROW_ON_ERROR(hr);

        CComVariant vBuf;
        VariantInit(&vBuf);
        CMultiSz MultiSz;
        hr = MultiSz.ToWmiForm( pBuf, &vBuf );
        if (pBuf)
        {
            delete [] pBuf;
        }
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams = NULL;
        hr = CUtils::CreateEmptyMethodInstance(
            m_pNamespace,
            i_pCtx,
            i_pClass->pszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        hr = spOutParams->Put(PARAMS::s_Applications.pszParamName, 0, &vBuf, 0);
        THROW_ON_ERROR(hr);

        hr = i_pHandler->Indicate(1, &spOutParams);
        THROW_ON_ERROR(hr);
    }
    else if (i_pMethod == &METHODS::s_ServiceAddDependency)
    {
        if (i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Application.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_GroupID.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);

        CSecConLib consoleHelper;
        hr = consoleHelper.AddDependency(_bstr_t(vt), _bstr_t(vt2), i_wszMbPath);
    }
    else if (i_pMethod == &METHODS::s_ServiceRemoveDependency)
    {
        if (i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Application.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_GroupID.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);

        CSecConLib consoleHelper;
        hr = consoleHelper.RemoveDependency(_bstr_t(vt), _bstr_t(vt2), i_wszMbPath);
    }
    else if (i_pMethod == &METHODS::s_ServiceEnableWebServiceExtension)
    {
        if (i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Extension.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        CSecConLib consoleHelper;
        hr = consoleHelper.EnableWebServiceExtension(_bstr_t(vt), i_wszMbPath);
    }
    else if (i_pMethod == &METHODS::s_ServiceDisableWebServiceExtension)
    {
        if (i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Extension.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        CSecConLib consoleHelper;
        hr = consoleHelper.DisableWebServiceExtension(_bstr_t(vt), i_wszMbPath);
    }
    else if (i_pMethod == &METHODS::s_ServiceListWebServiceExtensions)
    {
        WCHAR *pBuf = NULL;
        DWORD  dwBufLen;
        CSecConLib consoleHelper;
        hr = consoleHelper.ListWebServiceExtensions(i_wszMbPath, &pBuf, &dwBufLen);
        THROW_ON_ERROR(hr);

        CComVariant vBuf;
        VariantInit(&vBuf);
        CMultiSz MultiSz;
        hr = MultiSz.ToWmiForm( pBuf, &vBuf );
        if (pBuf)
        {
            delete [] pBuf;
        }
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams = NULL;
        hr = CUtils::CreateEmptyMethodInstance(
            m_pNamespace,
            i_pCtx,
            i_pClass->pszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        hr = spOutParams->Put(PARAMS::s_Extensions.pszParamName, 0, &vBuf, 0);
        THROW_ON_ERROR(hr);

        hr = i_pHandler->Indicate(1, &spOutParams);
        THROW_ON_ERROR(hr);
    }
    else if (i_pMethod == &METHODS::s_ServiceEnableExtensionFile)
    {
        if (i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_ExtensionFile.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        CSecConLib consoleHelper;
        hr = consoleHelper.EnableExtensionFile(_bstr_t(vt), i_wszMbPath);
    }
    else if (i_pMethod == &METHODS::s_ServiceDisableExtensionFile)
    {
        if (i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_ExtensionFile.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        CSecConLib consoleHelper;
        hr = consoleHelper.DisableExtensionFile(_bstr_t(vt), i_wszMbPath);
    }
    else if (i_pMethod == &METHODS::s_ServiceAddExtensionFile)
    {
        if (i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_ExtensionFile.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_bEnable.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_GroupID.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_bCanDelete.pszParamName, 0, &vt4, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_Description.pszParamName, 0, &vt5, NULL, NULL);
        THROW_ON_ERROR(hr);

        CSecConLib consoleHelper;
        hr = consoleHelper.AddExtensionFile(_bstr_t(vt), bool(vt2), 
                                            _bstr_t(vt3), bool(vt4),
                                            _bstr_t(vt5), i_wszMbPath);
    }
    else if (i_pMethod == &METHODS::s_ServiceDeleteExtensionFile)
    {
        if (i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_ExtensionFile.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        CSecConLib consoleHelper;
        hr = consoleHelper.DeleteExtensionFileRecord(_bstr_t(vt), i_wszMbPath);
    }
    else if (i_pMethod == &METHODS::s_ServiceListExtensionFiles)
    {
        WCHAR *pBuf = NULL;
        DWORD  dwBufLen;
        CSecConLib consoleHelper;
        hr = consoleHelper.ListExtensionFiles(i_wszMbPath, &pBuf, &dwBufLen);
        THROW_ON_ERROR(hr);

        CComVariant vBuf;
        VariantInit(&vBuf);
        CMultiSz MultiSz;
        hr = MultiSz.ToWmiForm( pBuf, &vBuf );
        if (pBuf)
        {
            delete [] pBuf;
        }
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams = NULL;
        hr = CUtils::CreateEmptyMethodInstance(
            m_pNamespace,
            i_pCtx,
            i_pClass->pszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        hr = spOutParams->Put(PARAMS::s_ExtensionFiles.pszParamName, 0, &vBuf, 0);
        THROW_ON_ERROR(hr);

        hr = i_pHandler->Indicate(1, &spOutParams);
        THROW_ON_ERROR(hr);
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }

    THROW_ON_ERROR(hr); 
}

void CIISInstProvider::WorkerExecComputerMethod(
    LPCWSTR             i_wszMbPath,
    LPCWSTR             i_wszClassName,
    WMI_METHOD*         i_pMethod,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler,
    CWbemServices*      i_pNameSpace 
    )
{
    HRESULT hr;
    _variant_t vt1, vt2, vt3, vt4, vt5, vt6;
    CMetabase obj;

    if(i_pMethod == &METHODS::s_SaveData)
    {
        hr = obj.SaveData();
        THROW_ON_ERROR(hr);
    }
    else if(i_pMethod == &METHODS::s_EnumBackups)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        //
        // get in params
        //
        hr = i_pInParams->Get(PARAMS::s_BackupLocation.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_IndexIn.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
       
        //
        // make in/out params
        //
        WCHAR BackupLocation[MD_BACKUP_MAX_LEN] = {0};
        if(vt1.vt == VT_BSTR && vt1.bstrVal != NULL)
        {
            ULONG cchBackupLocation = wcslen(vt1.bstrVal);
            if(cchBackupLocation < MD_BACKUP_MAX_LEN)
            {
                memcpy(
                    BackupLocation, 
                    vt1.bstrVal, 
                    sizeof(WCHAR)*(cchBackupLocation+1));
            }
            else
            {
                CIIsProvException e;
                e.SetHR(
                    WBEM_E_INVALID_PARAMETER, 
                    PARAMS::s_BackupLocation.pszParamName);
                throw e;
            }            
        }

        //
        // define out params
        //
        DWORD    BackupVersionOut; 
        FILETIME BackupDateTimeOut;

        //
        // call method - EnumBackups.
        //
        hr = obj.EnumBackups(
            BackupLocation, 
            &BackupVersionOut, 
            &BackupDateTimeOut, 
            CUtils::ExtractLongFromVt(&vt2, PARAMS::s_IndexIn.pszParamName));
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams;
        hr = CUtils::CreateEmptyMethodInstance(
            i_pNameSpace,
            i_pCtx,
            i_wszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        //
        // put it into the output object
        // out BackupLocation
        //
        vt1 = BackupLocation;
        hr = spOutParams->Put(PARAMS::s_BackupLocation.pszParamName, 0, &vt1, 0);      
        THROW_ON_ERROR(hr); 
        //
        // out BackupVersionOut        
        //
        vt1.vt = VT_I4;
        vt1.lVal = BackupVersionOut;
        hr = spOutParams->Put(PARAMS::s_BackupVersionOut.pszParamName, 0, &vt1, 0);      
        THROW_ON_ERROR(hr); 
        //
        // out BackupDateTimeOut (UTC time)
        //
        WCHAR datetime[30];
        CUtils::FileTimeToWchar(&BackupDateTimeOut, datetime);
        vt1 = datetime;
        hr = spOutParams->Put(PARAMS::s_BackupDateTimeOut.pszParamName, 0, &vt1, 0);
        THROW_ON_ERROR(hr); 

        //
        // Send the output object back to the client via the sink. Then 
        // release the pointers and free the strings.
        //
        hr = i_pHandler->Indicate(1, &spOutParams);
    }
    else if(i_pMethod == &METHODS::s_BackupWithPasswd)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_PARAMETER);
        }

        hr = i_pInParams->Get(PARAMS::s_BackupLocation.pszParamName, 0, &vt1, NULL, NULL);   
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_BackupVersion.pszParamName, 0, &vt2, NULL, NULL);   
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_BackupFlags.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_Password.pszParamName, 0, &vt4, NULL, NULL);   
        THROW_ON_ERROR(hr);

        hr = obj.BackupWithPasswd(
            CUtils::ExtractBstrFromVt(&vt1, PARAMS::s_BackupLocation.pszParamName),
            CUtils::ExtractLongFromVt(&vt2, PARAMS::s_BackupVersion.pszParamName),
            CUtils::ExtractLongFromVt(&vt3, PARAMS::s_BackupFlags.pszParamName),
            CUtils::ExtractBstrFromVt(&vt4, PARAMS::s_Password.pszParamName));
    }
    else if(i_pMethod == &METHODS::s_DeleteBackup)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_BackupLocation.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_BackupVersion.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.DeleteBackup(
            CUtils::ExtractBstrFromVt(&vt1, PARAMS::s_BackupLocation.pszParamName), 
            CUtils::ExtractLongFromVt(&vt2, PARAMS::s_BackupVersion.pszParamName));
    }
    else if(i_pMethod == &METHODS::s_RestoreWithPasswd)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }
        
        hr = i_pInParams->Get(PARAMS::s_BackupLocation.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_BackupVersion.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_BackupFlags.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_Password.pszParamName, 0, &vt4, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.RestoreWithPasswd(
            CUtils::ExtractBstrFromVt(&vt1, PARAMS::s_BackupLocation.pszParamName), 
            CUtils::ExtractLongFromVt(&vt2, PARAMS::s_BackupVersion.pszParamName),
            CUtils::ExtractLongFromVt(&vt3, PARAMS::s_BackupFlags.pszParamName),
            CUtils::ExtractBstrFromVt(&vt4, PARAMS::s_Password.pszParamName));
    }
    else if(i_pMethod == &METHODS::s_Export)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Passwd.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_FileName.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_SourcePath.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_MDFlags.pszParamName, 0, &vt4, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.Export(
            CUtils::ExtractBstrFromVt(&vt1, PARAMS::s_Passwd.pszParamName), 
            CUtils::ExtractBstrFromVt(&vt2, PARAMS::s_FileName.pszParamName), 
            CUtils::ExtractBstrFromVt(&vt3, PARAMS::s_SourcePath.pszParamName), 
            CUtils::ExtractLongFromVt(&vt4, PARAMS::s_MDFlags.pszParamName));
    }
    else if(i_pMethod == &METHODS::s_Import)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Passwd.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_FileName.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_SourcePath.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_DestPath.pszParamName, 0, &vt4, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_MDFlags.pszParamName, 0, &vt5, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.Import(
            CUtils::ExtractBstrFromVt(&vt1, PARAMS::s_Passwd.pszParamName),
            CUtils::ExtractBstrFromVt(&vt2, PARAMS::s_FileName.pszParamName),
            CUtils::ExtractBstrFromVt(&vt3, PARAMS::s_SourcePath.pszParamName),
            CUtils::ExtractBstrFromVt(&vt4, PARAMS::s_DestPath.pszParamName),
            CUtils::ExtractLongFromVt(&vt5, PARAMS::s_MDFlags.pszParamName));
    }
    else if(i_pMethod == &METHODS::s_RestoreHistory)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_MDHistoryLocation.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_MajorVersion.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_MinorVersion.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_MDFlags.pszParamName, 0, &vt4, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.RestoreHistory(
            CUtils::ExtractBstrFromVt(&vt1, PARAMS::s_MDHistoryLocation.pszParamName), 
            CUtils::ExtractLongFromVt(&vt2, PARAMS::s_MajorVersion.pszParamName),
            CUtils::ExtractLongFromVt(&vt3, PARAMS::s_MinorVersion.pszParamName),
            CUtils::ExtractLongFromVt(&vt4, PARAMS::s_MDFlags.pszParamName));
    }
    else if(i_pMethod == &METHODS::s_EnumHistory)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        //
        // get in params
        //
        hr = i_pInParams->Get(PARAMS::s_MDHistoryLocation.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_EnumIndex.pszParamName, 0, &vt2, NULL, NULL);  
        THROW_ON_ERROR(hr);
       
        //
        // make in/out params
        //
        WCHAR MDHistoryLocation[MD_BACKUP_MAX_LEN] = {0};
        if(vt1.vt == VT_BSTR && vt1.bstrVal != NULL)
        {
            ULONG cchHistoryLocation = wcslen(vt1.bstrVal);
            if(cchHistoryLocation < MD_BACKUP_MAX_LEN)
            {
                memcpy(
                    MDHistoryLocation, 
                    vt1.bstrVal, 
                    sizeof(WCHAR)*(cchHistoryLocation+1));
            }
            else
            {
                CIIsProvException e;
                e.SetHR(
                    WBEM_E_INVALID_PARAMETER,
                    PARAMS::s_MDHistoryLocation.pszParamName);
                throw e;
            }            
        }

        //
        // define out params
        //
        DWORD HistoryMajorVersionOut; 
        DWORD HistoryMinorVersionOut; 
        FILETIME HistoryDateTimeOut;

        //
        // call method - EnumHistory.
        //
        hr = obj.EnumHistory(
            MDHistoryLocation, 
            &HistoryMajorVersionOut, 
            &HistoryMinorVersionOut, 
            &HistoryDateTimeOut, 
            CUtils::ExtractLongFromVt(&vt2, PARAMS::s_EnumIndex.pszParamName));
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams;
        hr = CUtils::CreateEmptyMethodInstance(
            i_pNameSpace,
            i_pCtx,
            i_wszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        //
        // put it into the output object
        // out MDHistoryLocation
        //
        vt1 = MDHistoryLocation;
        hr = spOutParams->Put(PARAMS::s_MDHistoryLocation.pszParamName, 0, &vt1, 0);      
        THROW_ON_ERROR(hr);
 
        //
        // out HistoryMajorVersionOut        
        //
        vt1.vt = VT_I4;
        vt1.lVal = HistoryMajorVersionOut;
        hr = spOutParams->Put(PARAMS::s_MajorVersion.pszParamName, 0, &vt1, 0);      
        THROW_ON_ERROR(hr); 

        //
        // out HistoryMinorVersionOut        
        //
        vt1.vt = VT_I4;
        vt1.lVal = HistoryMinorVersionOut;
        hr = spOutParams->Put(PARAMS::s_MinorVersion.pszParamName, 0, &vt1, 0);      
        THROW_ON_ERROR(hr); 

        //
        // out HistoryDateTimeOut (UTC time)
        //
        WCHAR datetime[30];
        CUtils::FileTimeToWchar(&HistoryDateTimeOut, datetime);
        vt1 = datetime;
        hr = spOutParams->Put(PARAMS::s_HistoryTime.pszParamName, 0, &vt1, 0);      
        THROW_ON_ERROR(hr); 

        //
        // Send the output object back to the client via the sink. Then 
        // release the pointers and free the strings.
        //
        hr = i_pHandler->Indicate(1, &spOutParams);
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }

    THROW_ON_ERROR(hr);
}

void CIISInstProvider::WorkerExecAppPoolMethod(
    LPCWSTR             i_wszMbPath,
    LPCWSTR             i_wszClassName,
    WMI_METHOD*         i_pMethod,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler,
    CWbemServices*      i_pNameSpace 
    )
{
    DBG_ASSERT(i_wszMbPath  != NULL);
    DBG_ASSERT(i_pNameSpace != NULL);
    DBG_ASSERT(i_pHandler   != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    CAppPoolMethod obj;

    if(i_pMethod == &METHODS::s_EnumAppsInPool)
    {
        CComVariant vtApplications;
        obj.EnumAppsInPool(i_wszMbPath, &vtApplications);


        CComPtr<IWbemClassObject> spOutParams;
        hr = CUtils::CreateEmptyMethodInstance(
            i_pNameSpace,
            i_pCtx,
            i_wszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        hr = spOutParams->Put(PARAMS::s_Applications.pszParamName, 0, &vtApplications, 0);
        THROW_ON_ERROR(hr);

        hr = i_pHandler->Indicate(1, &spOutParams);
        THROW_ON_ERROR(hr);
    }
    else if(i_pMethod == &METHODS::s_RecycleAppPool)
    {
        obj.RecycleAppPool(i_wszMbPath);
    }
    else if(i_pMethod == &METHODS::s_Start)
    {
        obj.Start(i_wszMbPath);
    }
    else if(i_pMethod == &METHODS::s_Stop)
    {
        obj.Stop(i_wszMbPath);
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_METHOD);
    }
}


void CIISInstProvider::WorkerExecCertMapperMethod(
    LPCWSTR             i_wszMbPath,
    LPCWSTR             i_wszClassName,
    WMI_METHOD*         i_pMethod,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler,
    CWbemServices*      i_pNameSpace 
    )
{
    HRESULT hr;
    _variant_t vt1, vt2, vt3=L"1", vt4=L"1", vt5=L"1", vt6=L"1", vt7=L"1";
    CCertMapperMethod obj(i_wszMbPath);

    if(i_pMethod == &METHODS::s_CreateMapping)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS)
        }

        hr = i_pInParams->Get(PARAMS::s_vCert.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_NtAcct.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_NtPwd.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_strName.pszParamName, 0, &vt4, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_IEnabled.pszParamName, 0, &vt5, NULL, NULL);
        THROW_ON_ERROR(hr);
      
        //
        // call method - CreateMapping.
        //
        hr = obj.CreateMapping(vt1, vt2.bstrVal, vt3.bstrVal, vt4.bstrVal, vt5);
    }
    else if(i_pMethod == &METHODS::s_DeleteMapping)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_IMethod.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_vKey.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
      
        //
        // call method - DeleteMapping.
        //
        hr = obj.DeleteMapping(vt1, vt2);
    }
    else if(i_pMethod == &METHODS::s_GetMapping)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        //
        // get in params
        //
        hr = i_pInParams->Get(PARAMS::s_IMethod.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_vKey.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
       
        //
        // call method - GetMapping.
        //
        hr = obj.GetMapping(vt1, vt2, &vt3, &vt4, &vt5, &vt6, &vt7);
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams;
        hr = CUtils::CreateEmptyMethodInstance(
            i_pNameSpace,
            i_pCtx,
            i_wszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        //
        // put them into the output object
        //
        hr = spOutParams->Put(PARAMS::s_vCert.pszParamName, 0, &vt3, 0);      
        THROW_ON_ERROR(hr); 
        hr = spOutParams->Put(PARAMS::s_NtAcct.pszParamName, 0, &vt4, 0);
        THROW_ON_ERROR(hr); 
        hr = spOutParams->Put(PARAMS::s_NtPwd.pszParamName, 0, &vt5, 0);      
        THROW_ON_ERROR(hr); 
        hr = spOutParams->Put(PARAMS::s_strName.pszParamName, 0, &vt6, 0);      
        THROW_ON_ERROR(hr); 
        hr = spOutParams->Put(PARAMS::s_IEnabled.pszParamName, 0, &vt7, 0);
        THROW_ON_ERROR(hr); 

        //
        // Send the output object back to the client via the sink. Then 
        // release the pointers and free the strings.
        //
        hr = i_pHandler->Indicate(1, &spOutParams);
    }
    else if(i_pMethod == &METHODS::s_SetAcct)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }
        
        hr = i_pInParams->Get(PARAMS::s_IMethod.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_vKey.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_NtAcct.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
      
        //
        // call method - SetAcct.
        //
        hr = obj.SetAcct(vt1, vt2, vt3.bstrVal);
    }
    else if(i_pMethod == &METHODS::s_SetEnabled)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_IMethod.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_vKey.pszParamName, 0, &vt2, NULL, NULL);  
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_IEnabled.pszParamName, 0, &vt3, NULL, NULL);  
        THROW_ON_ERROR(hr);
      
        //
        // call method - SetEnabled.
        //
        hr = obj.SetEnabled(vt1, vt2, vt3);
    }
    else if(i_pMethod == &METHODS::s_SetName)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_IMethod.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_vKey.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_strName.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
      
        //
        // call method - SetName.
        //
        hr = obj.SetName(vt1, vt2, vt3.bstrVal);
    }
    else if(i_pMethod == &METHODS::s_SetPwd)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_IMethod.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_vKey.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_NtPwd.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
      
        //
        // call method - SetPwd.
        //
        hr = obj.SetPwd(vt1, vt2, vt3.bstrVal);
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }

    THROW_ON_ERROR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\instancehelper.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    instancehelper.cpp

Abstract:

    Implementation of:
    CInstanceHelper

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

//
// for metabase.h
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <comdef.h>
#include "iisfiles.h"

#include "instancehelper.h"
#include "utils.h"
#include "iiswmimsg.h"

#include "globalconstants.h"
#include "adminacl.h"
#include "ipsecurity.h"
#include "metabase.h"
#include "SmartPointer.h"
#include "schemadynamic.h"

extern CDynSchema* g_pDynSch;

CInstanceHelper::CInstanceHelper(
    ParsedObjectPath* i_pParsedObjPath,
    CWbemServices*    i_pNamespace) : 
    m_PathParser(e_ParserAcceptRelativeNamespace)
/*++

Synopsis: 
    Use this constructor when you have already parsed the object path.
    Caller owns the ParsedObjectPath.

Arguments: [i_pParsedObjPath] - 
           [i_pNamespace] - 
           
--*/
{
    Init(i_pParsedObjPath, i_pNamespace);
}


CInstanceHelper::CInstanceHelper(
    BSTR           i_bstrObjPath,
    CWbemServices* i_pNamespace) :
    m_PathParser(e_ParserAcceptRelativeNamespace)
/*++

Synopsis: 
    Use this constructor when have not already parsed the object path.

Arguments: [i_bstrObjPath] - 
           [i_pNamespace] - 
           
--*/
{
    DBG_ASSERT(i_bstrObjPath != NULL);
    DBG_ASSERT(i_pNamespace  != NULL);

    TSmartPointer<ParsedObjectPath> spParsedObject;

    HRESULT hr = WBEM_S_NO_ERROR;
    hr = CUtils::ParserErrToHR( m_PathParser.Parse(i_bstrObjPath, &spParsedObject) );
    THROW_ON_ERROR(hr);

    Init(spParsedObject, i_pNamespace);

    m_pParsedObjPath  = spParsedObject;
    spParsedObject    = NULL;

    m_bOwnObjPath = true;
}

void CInstanceHelper::Init(
    ParsedObjectPath* i_pParsedObjPath,
    CWbemServices*    i_pNamespace)
/*++

Synopsis: 
    Called by constructors.

Arguments: [i_pParsedObjPath] - 
           [i_pNamespace] - 
           
--*/
{
    m_pWmiClass = NULL;
    m_pWmiAssoc = NULL;

    DBG_ASSERT(i_pParsedObjPath != NULL);
    DBG_ASSERT(i_pNamespace     != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    if(CUtils::GetClass(i_pParsedObjPath->m_pClass,&m_pWmiClass))
    {
    }
    else if(CUtils::GetAssociation(i_pParsedObjPath->m_pClass,&m_pWmiAssoc))
    {
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS);
    }

    m_pParsedObjPath = i_pParsedObjPath;
    m_bOwnObjPath    = false;
    m_pNamespace     = i_pNamespace;

    THROW_ON_ERROR(hr);
}

void CInstanceHelper::GetAssociation(
    IWbemClassObject**       o_ppObj,
    bool                     i_bVerifyLeft,  //default(true)
    bool                     i_bVerifyRight) //default(true)
/*++

Synopsis: 
    Specifying i_bVerifyLeft or i_bVerifyRight can be expensive, especially
    during enumeration.  If you have already verified prior to calling this
    function that the left and/or right parts exist, then set these params
    to false.

Arguments: [o_ppObj] -        The WMI association that you "indicate" to WMI.
           [i_bVerifyLeft] -  Verify left part of the association is valid.
           [i_bVerifyRight] - Verify right part of association is valid.
           
--*/
{
    DBG_ASSERT(o_ppObj != NULL);

    CComPtr<IWbemClassObject>   spObj;   // This is the obj that the client gets back
    HRESULT                     hr = WBEM_S_NO_ERROR;

    if(m_pParsedObjPath->m_dwNumKeys < 2)
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS);
    }

    KeyRef* pkrLeft  = NULL;
    KeyRef* pkrRight = NULL;
    for(ULONG i = 0; i < m_pParsedObjPath->m_dwNumKeys; i++)
    {
        KeyRef* pkr = m_pParsedObjPath->m_paKeys[i];
        if(pkr->m_pName)
        {
            if( !pkrLeft &&
                _wcsicmp(pkr->m_pName, m_pWmiAssoc->pType->pszLeft) == 0 )
            {
                pkrLeft = pkr;
            }
            if( !pkrRight &&
                _wcsicmp(pkr->m_pName, m_pWmiAssoc->pType->pszRight) == 0 )
            {
                pkrRight = pkr;
            }
        }
    }

    if( !pkrLeft || !pkrRight                 ||
        pkrLeft->m_vValue.vt       != VT_BSTR ||
        pkrRight->m_vValue.vt      != VT_BSTR ||
        pkrLeft->m_vValue.bstrVal  == NULL    ||
        pkrRight->m_vValue.bstrVal == NULL )
    {
        THROW_ON_ERROR(WBEM_E_INVALID_OBJECT_PATH);
    }

    //
    // Now verify the two object paths are valid
    //
    bool    abVerify[2];
    abVerify[0] = i_bVerifyLeft;
    abVerify[1] = i_bVerifyRight;
    KeyRef* apKr[2];
    apKr[0] = pkrLeft;
    apKr[1] = pkrRight;
    if(abVerify[0] || abVerify[1])
    {
        CMetabase metabase;
        CComPtr<IWbemClassObject> spObjTemp;
        for(ULONG i = 0; i < 2; i++)
        {
            if(abVerify[i])
            {
                spObjTemp = NULL;
                CInstanceHelper InstanceHelper(apKr[i]->m_vValue.bstrVal, m_pNamespace);
                if(InstanceHelper.IsAssoc())
                {
                    THROW_ON_ERROR(WBEM_E_NOT_FOUND);
                }
                InstanceHelper.GetInstance(
                    false,
                    &metabase,
                    &spObjTemp);
            }
        }
    }

    hr = CUtils::CreateEmptyInstance(m_pParsedObjPath->m_pClass, m_pNamespace, &spObj);
    THROW_ON_ERROR(hr);

    hr = spObj->Put(pkrLeft->m_pName, 0, &pkrLeft->m_vValue, 0);
    THROW_ON_ERROR(hr);

    hr = spObj->Put(pkrRight->m_pName, 0, &pkrRight->m_vValue, 0);
    THROW_ON_ERROR(hr);

    //
    // Set out parameters on success
    //
    *o_ppObj = spObj;
    (*o_ppObj)->AddRef();
}

void CInstanceHelper::GetInstance(
    bool                            i_bCreateKeyIfNotExist,
    CMetabase*                      io_pMetabase,
    IWbemClassObject**              o_ppObj,
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp)     // default(NULL)
/*++

Synopsis: 
    Will throw an exception on failure (generallly instance not found in mb).
    If GetInstance finds the instance in the metabase, but i_pExp was specified,
    it is possible *o_ppObj will not be populated with an instance.  
    This is a SUCCESS case.

Arguments: [i_bCreateKeyIfNotExist] - 
           [io_pMetabase] - 
           [o_ppObj] - The only success case where *o_ppObj will be NULL
                       is if it the instance is found in the metabase but i_pExp
                       (i.e. a query) is specified and the query doesn't match.
           [i_pExp] -  An optional query.
           
--*/
{ 
    DBG_ASSERT(o_ppObj         != NULL);
    DBG_ASSERT(io_pMetabase    != NULL);

    *o_ppObj = NULL;
    CComPtr<IWbemClassObject> spObj;

    HRESULT              hr = WBEM_S_NO_ERROR;
    METABASE_PROPERTY**  ppmbp;
    _bstr_t              bstrMbPath;
    METADATA_HANDLE      hKey = NULL;

    VARIANT    vtTrue;
    vtTrue.boolVal    = VARIANT_TRUE;
    vtTrue.vt         = VT_BOOL;

    hr = CUtils::CreateEmptyInstance(m_pParsedObjPath->m_pClass, m_pNamespace, &spObj);
    THROW_ON_ERROR(hr);

    CUtils::GetMetabasePath(spObj, m_pParsedObjPath, m_pWmiClass, bstrMbPath);

    //
    // if AdminACL 
    //
    if( m_pWmiClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||
        m_pWmiClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE
        )
    {
        CAdminACL objACL;
        hr = objACL.OpenSD(bstrMbPath, *io_pMetabase);
        if(SUCCEEDED(hr))
            hr  = objACL.GetObjectAsync(spObj, m_pParsedObjPath, m_pWmiClass);
        THROW_ON_ERROR(hr);
        *o_ppObj = spObj;
        (*o_ppObj)->AddRef();
        return;
    }
    //
    // if IPSecurity
    //
    else if( m_pWmiClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity )
    {
        CIPSecurity IPSecurity;
        hr = IPSecurity.OpenSD(bstrMbPath, *io_pMetabase);
        if(SUCCEEDED(hr))
            hr  = IPSecurity.GetObjectAsync(spObj);
        THROW_ON_ERROR(hr);
        *o_ppObj = spObj;
        (*o_ppObj)->AddRef();
        return;
    }

    if(!i_bCreateKeyIfNotExist)
    {
        hKey = io_pMetabase->OpenKey(bstrMbPath, false);    
    }
    else
    {
        hKey = io_pMetabase->CreateKey(bstrMbPath);
    }

    _variant_t vt;

    //
    // If anything throws, CacheFree and then CloseKey is called automatically
    //
    io_pMetabase->CacheInit(hKey);

    //
    // Make sure requested keytype matches the keytype set at the node
    //
    if(!i_bCreateKeyIfNotExist)
    {
        io_pMetabase->Get(hKey, &METABASE_PROPERTY_DATA::s_KeyType, m_pNamespace, vt, NULL, NULL);
        if( vt.vt != VT_BSTR   || 
            vt.bstrVal == NULL ||
            !CUtils::CompareKeyType(vt.bstrVal, m_pWmiClass->pkt) )
        {
            CIIsProvException e;
            e.SetMC(WBEM_E_NOT_FOUND, IISWMI_INVALID_KEYTYPE, NULL);
            throw e;
        }
        vt.Clear();
    }

    //
    // User wants to filter number of instances returned
    // Walk thru all filters, and try and get these first.
    //
    if(i_pExp && !i_pExp->GetContainsOrOrNot())
    {
        SQL_LEVEL_1_TOKEN* pToken    = i_pExp->m_pSqlExpr->pArrayOfTokens;
        METABASE_PROPERTY* pMbpQuery = NULL;
        for(int i = 0; i < i_pExp->m_pSqlExpr->nNumTokens; i++, pToken++)
        {
            BOOL bInherited    = false;
            BOOL bDefault      = false;
            if( pToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION )
            {
                hr = g_pDynSch->GetHashProps()->Wmi_GetByKey(
                    pToken->pPropertyName,
                    &pMbpQuery);
                if(FAILED(hr))
                {
                    if(_wcsicmp(pToken->pPropertyName, m_pWmiClass->pszKeyName) == 0)
                    {
                        //
                        // User requested the name property which is not in the schema by
                        // design.
                        //
                        hr = spObj->Get(m_pWmiClass->pszKeyName, 0, &vt, NULL, NULL);
                        THROW_ON_ERROR(hr);
                    }
                    else
                    {
                        //
                        // User requested a property that is not in the schema
                        //
                        DBGPRINTF( (DBG_CONTEXT, 
                            "Property %ws not in schema\n", pToken->pPropertyName) );
                        THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
                    }
                }
                else
                {
                    io_pMetabase->Get(hKey, pMbpQuery, m_pNamespace, vt, &bInherited, &bDefault);
                }

                if(!CheckForQueryMatch(pToken, &vt))
                {
                    //
                    // We don't need to return this instance.
                    // value from metabase is not what user wanted.
                    //
					io_pMetabase->CacheFree();
					io_pMetabase->CloseKey(hKey);
                    return;
                }

                PutProperty(spObj, pToken->pPropertyName, &vt, bInherited, bDefault);

                vt.Clear();
            }
        }
    }

    //
    // Walk thru all the properties in the class and put them in an instance
    // we will return back to WMI
    //
    for (ppmbp=m_pWmiClass->ppmbp;*ppmbp; ppmbp++) 
    {            
        BOOL bInherited = false;
        BOOL bDefault   = false;

        BOOL bSkipProp  = false;
        if(i_pExp)
        {
            if(!i_pExp->FindRequestedProperty((*ppmbp)->pszPropName))
            {
                //
                // User did not request this property
                //
                bSkipProp = true;
            }
            else if(!i_pExp->GetContainsOrOrNot() && i_pExp->GetFilter((*ppmbp)->pszPropName))
            {
                //
                // Right above for loop, we handled all filters already.
                //
                bSkipProp = true;
            }
        }

        if( !bSkipProp )
        {
            io_pMetabase->Get(hKey, *ppmbp, m_pNamespace, vt, &bInherited, &bDefault);

            _bstr_t bstrPropName = (*ppmbp)->pszPropName;
            
            PutProperty(spObj, bstrPropName, &vt, bInherited, bDefault);

            vt.Clear();
        }
    }

    io_pMetabase->CacheFree();        
    io_pMetabase->CloseKey(hKey);
    hKey = NULL;

    //
    // Set qualifiers
    //
    LPCWSTR  awszNames[2] = { g_wszInstanceName, g_wszInstanceExists };
    VARIANT  apvValues[2];
    apvValues[0].bstrVal = bstrMbPath;
    apvValues[0].vt      = VT_BSTR;
    apvValues[1].boolVal = vtTrue.boolVal;
    apvValues[1].vt      = vtTrue.vt;

    hr = CUtils::SetQualifiers(spObj, awszNames, apvValues, 2,
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
    THROW_ON_ERROR(hr);

    //
    // Set out parameters on success
    //
    *o_ppObj = spObj;
    (*o_ppObj)->AddRef();
}

void CInstanceHelper::PutProperty(
    IWbemClassObject*        i_pInstance,
    const BSTR               i_bstrPropName,
    VARIANT*                 i_vtPropValue,
    BOOL                     i_bIsInherited,
    BOOL                     i_bIsDefault)
{
    DBG_ASSERT(i_pInstance);
    DBG_ASSERT(i_bstrPropName);
    DBG_ASSERT(i_vtPropValue);

    HRESULT hr = WBEM_S_NO_ERROR;

    VARIANT vtTrue;
    vtTrue.boolVal = VARIANT_TRUE;
    vtTrue.vt      = VT_BOOL;

    //
    // TODO: Log error if Put fails.
    //
    hr = i_pInstance->Put(i_bstrPropName, 0, i_vtPropValue, 0);
    if(FAILED(hr))
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "The property %ws in class %ws is not in repository\n", 
            i_bstrPropName, 
            m_pWmiClass->pszClassName));
    }

    if(i_bIsInherited && SUCCEEDED(hr))
    {
        hr = CUtils::SetPropertyQualifiers(
            i_pInstance, i_bstrPropName, &g_wszIsInherit, &vtTrue, 1);
        THROW_ON_ERROR(hr);
    }
    else if(i_bIsDefault && SUCCEEDED(hr))
    {
        hr = CUtils::SetPropertyQualifiers(
            i_pInstance, i_bstrPropName, &g_wszIsDefault, &vtTrue, 1);
        THROW_ON_ERROR(hr);
    }
}

bool CInstanceHelper::CheckForQueryMatch(
    const SQL_LEVEL_1_TOKEN* i_pToken,
    const VARIANT*           i_pvtMatch)
/*++

Synopsis: 
    It's okay to return true even if there is not a match, but we should
    never do the opposite.

Arguments: [i_pToken] - 
           [i_pvtMatch] - 
           
Return Value: 

--*/{
    DBG_ASSERT(i_pToken);
    DBG_ASSERT(i_pvtMatch);
    DBG_ASSERT(i_pToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION);

    bool bTypesMatch = false;


    //
    // Used only for VT_BOOL and VT_I4
    //
    ULONG ulToken = 0;
    ULONG ulMatch = 0;
    
    if( i_pvtMatch->vt == i_pToken->vConstValue.vt )
    {
        bTypesMatch = true;
    }

    if(bTypesMatch)
    {
        switch(i_pvtMatch->vt)
        {
        case VT_BOOL:
            ulMatch = i_pvtMatch->boolVal ? 1 : 0;
            ulToken = i_pToken->vConstValue.boolVal ? 1 : 0;
            //
            // deliberate fall thru
            //
        case VT_I4:
            if(i_pvtMatch->vt == VT_I4)
            {
                ulMatch = i_pvtMatch->lVal;
                ulToken = i_pToken->vConstValue.lVal;
            }
            switch(i_pToken->nOperator)
            {
            case SQL_LEVEL_1_TOKEN::OP_EQUAL:
                if(ulMatch != ulToken)
                {
                    return false;
                }
                break;
            case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                if(ulMatch == ulToken)
                {
                    return false;
                }
                break;
            case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                if(ulMatch < ulToken)
                {
                    return false;
                }
                break;
            case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                if(ulMatch > ulToken)
                {
                    return false;
                }
                break;
            case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
                if(ulMatch >= ulToken)
                {
                    return false;
                }
                break;
            case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                if(ulMatch <= ulToken)
                {
                    return false;
                }
                break;
            }
            break;
        case VT_BSTR:
            if(i_pToken->vConstValue.bstrVal && i_pvtMatch->bstrVal)
            {
                int iWcsCmp = _wcsicmp(i_pvtMatch->bstrVal, i_pToken->vConstValue.bstrVal);
                switch(i_pToken->nOperator)
                {
                case SQL_LEVEL_1_TOKEN::OP_EQUAL:
                    if(iWcsCmp != 0)
                    {
                        return false;
                    }
                    break;
                case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                    if(iWcsCmp == 0)
                    {
                        return false;
                    }
                    break;
                case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                    if(iWcsCmp < 0)
                    {
                        return false;
                    }
                    break;
                case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                    if(iWcsCmp > 0)
                    {
                        return false;
                    }
                    break;
                case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
                    if(iWcsCmp >= 0)
                    {
                        return false;
                    }
                    break;
                case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                    if(iWcsCmp <= 0)
                    {
                        return false;
                    }
                    break;
                }
            }
            break;
        default:
            break;
        }
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\instancehelper.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    instancehelper.h

Abstract:

    Definition of:
    CInstanceHelper

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _instancehelper_h_
#define _instancehelper_h_

#include <windows.h>
#include <wbemprov.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <atlbase.h>

#include "sqllex.h"
#include <sql_1ext.h>

#include "schema.h"
#include "wbemservices.h"

//
// forward decl
//
class CMetabase;

class CInstanceHelper
{
public:
    CInstanceHelper(
        ParsedObjectPath* i_pParsedObjPath, 
        CWbemServices*    i_pNamespace);

    CInstanceHelper(
        BSTR              i_bstrObjPath,    
        CWbemServices*    i_pNamespace);

    ~CInstanceHelper()
    {
        if(m_pParsedObjPath && m_bOwnObjPath)
        {
            m_PathParser.Free(m_pParsedObjPath);
        }
    }

    void GetAssociation(
        IWbemClassObject**       o_ppObj,
        bool                     i_bVerifyLeft =true,
        bool                     i_bVerifyRight=true);

    void GetInstance(
        bool                            i_bCreateKeyIfNotExist,
        CMetabase*                      io_pMetabase,
        IWbemClassObject**              o_ppObj,
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp=NULL);

    bool IsAssoc() 
    { 
        return (m_pWmiAssoc != NULL);
    }

private:
    void Init(
        ParsedObjectPath* i_pParsedObjPath, 
        CWbemServices*    i_pNamespace);

    void PutProperty(
        IWbemClassObject*        i_pInstance,
        const BSTR               i_bstrPropName,
        VARIANT*                 i_vtPropValue,
        BOOL                     i_bIsInherited,
        BOOL                     i_bIsDefault);

    bool CheckForQueryMatch(
        const SQL_LEVEL_1_TOKEN* i_pToken,
        const VARIANT*           i_pvtMatch);

    bool                   m_bOwnObjPath;
    ParsedObjectPath*      m_pParsedObjPath;
    CObjectPathParser      m_PathParser;

    WMI_CLASS*             m_pWmiClass;
    WMI_ASSOCIATION*       m_pWmiAssoc;

    CWbemServices*         m_pNamespace;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\ipsecurity.h ===
#ifndef _IPSecurity_h_
#define _IPSecurity_h_



#import "adsiis.tlb" no_namespace named_guids
#include <iads.h>
#include <adshlp.h>

class CIPSecurity
{
private:

    IISIPSecurity* m_pIPSec;
    IADs* m_pADs;
    BOOL bIsInherit;

public:

    CIPSecurity();
    ~CIPSecurity();

    HRESULT GetObjectAsync(
        IWbemClassObject* pObj
        ); 

    HRESULT PutObjectAsync(
        IWbemClassObject* pObj
        );

    HRESULT OpenSD(
        _bstr_t        bstrAdsPath,
        IMSAdminBase2* pAdminBase);
    void CloseSD();

private:

    HRESULT SetSD();
    HRESULT GetAdsPath(_bstr_t& bstrAdsPath);    
    HRESULT LoadBstrArrayFromVariantArray(VARIANT& i_vtVariant, VARIANT& o_vtBstr);
    HRESULT LoadVariantArrayFromBstrArray(VARIANT& i_vtBstr, VARIANT& o_vtVariant);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\hashtable.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hashtable.h

Abstract:

    Definition of:
    CPool<T>, CStringPool, CHashTableElement<T>

    Implementation of:
    CHashTable<T>

Author:

    Mohit Srivastava            10-Nov-2000

Revision History:

--*/

#ifndef _hashtable_h_
#define _hashtable_h_

#include <lkrhash.h>

const ULONG POOL_ARRAY_SIZE         = 10;
const ULONG HASH_TABLE_POOL_SIZE    = 10;
const ULONG STRING_POOL_STRING_SIZE = 64;

//
// This is an array of pointers to arrays (aka buckets).
// -You pass the size of the first bucket to Initialize.
// -When first bucket is full, a new bucket is created
//  that is twice as big as the last one.
// -When the array itself is full, it is doubled and the
//  bucket pointers from the old array are copied.  Then
//  the old array is cleaned up.
//

template <class T> class CPool
{
public:
    CPool() : 
        m_bInitCalled(false),
        m_bInitSuccessful(false),
        m_apBuckets(NULL),
        m_iArrayPosition(0),
        m_iArraySize(0),
        m_iCurrentBucketPosition(0),
        m_iCurrentBucketSize(0),
        m_iFirstBucketSize(0) {}
    ~CPool()
    {
        for(ULONG i = 0; i < m_iArrayPosition; i++)
        {
            delete [] m_apBuckets[i];
        }
        delete [] m_apBuckets;
    }
    HRESULT Initialize(ULONG i_iFirstBucketSize);
    HRESULT GetNewElement(T** o_ppElement);
    T* Lookup(ULONG i_idx) const;
    ULONG GetUsed() const
    {
        return (GetSize() - m_iCurrentBucketSize) + m_iCurrentBucketPosition;
    }
    ULONG GetSize() const
    {
        return (2 * m_iCurrentBucketSize - m_iFirstBucketSize);
    }

private:
    //
    // Change this as necessary for best performance.
    //
    static const ULONG ARRAY_SIZE = ::POOL_ARRAY_SIZE;

    bool m_bInitCalled;
    bool m_bInitSuccessful;

    ULONG m_iCurrentBucketPosition;
    ULONG m_iCurrentBucketSize;
    ULONG m_iFirstBucketSize;

    ULONG m_iArraySize;
    ULONG m_iArrayPosition;
    T**   m_apBuckets;
};


//
// CArrayPool contains two pools.
// If a user calls GetNewArray with i <= size, then we serve request from fixedsize pool.
// If i > size, then we serve request from dynamic pool.  In this case, we need to perform
// a new since the dynamic pool is a pool of ptrs to T.
//

template <class T, ULONG size>
struct CArrayPoolEntry
{
    T m_data[size];
};

template <class T, ULONG size> class CArrayPool
{
public:
    CArrayPool() {}
    virtual ~CArrayPool()
    {
        T* pElem;
        for(ULONG i = 0; i < m_PoolDynamic.GetUsed(); i++)
        {
            pElem = *m_PoolDynamic.Lookup(i);
            delete [] pElem;
        }
    }
    HRESULT Initialize();
    HRESULT GetNewArray(ULONG i_cElem, T** o_ppElem);
    T* Lookup(ULONG i_idx) const;

protected:
    CPool< CArrayPoolEntry<T, size> >  m_PoolFixedSize;
    CPool< T * >                       m_PoolDynamic;

private:
    //
    // This is  passed to constructor of the embedded CPools.
    //
    static const FIRST_BUCKET_SIZE = 10;
};


class CStringPool: public CArrayPool<wchar_t, ::STRING_POOL_STRING_SIZE>
{
public:
    void ToConsole() const;
    HRESULT GetNewString(LPCWSTR i_wsz, LPWSTR* o_pwsz);
    HRESULT GetNewString(LPCWSTR i_wsz, ULONG i_cch, LPWSTR* o_pwsz);
};


template <class T> class CHashTableElement
{
public:
    LPWSTR                m_wszKey;
    T                     m_data;
    ULONG                 m_idx;
};

template <class T>
class CHashTable : public CTypedHashTable<CHashTable, const CHashTableElement<T>, const WCHAR*>
{
public:
    CHashTable() : CTypedHashTable<CHashTable, const CHashTableElement<T>, const WCHAR*>("IISWMI")
    {
        m_idxCur = 0;
    }

    ~CHashTable()
    {
    }

public:
    //
    // These 4 functions are callbacks and must be implemented.
    // The user of CHashTable should NOT call these explicitly.
    //
    static const WCHAR* ExtractKey(
        const CHashTableElement<T>* i_pElem)
    { 
        return i_pElem->m_wszKey;
    }
    static DWORD CalcKeyHash(
        const WCHAR* i_wszKey) 
    { 
        return HashStringNoCase(i_wszKey); 
    }
    static bool EqualKeys(
        const WCHAR* i_wszKey1,
        const WCHAR* i_wszKey2)
    { 
        return ( _wcsicmp( i_wszKey1, i_wszKey2 ) == 0 ); 
    }  
    static void AddRefRecord(
        const CHashTableElement<T>* i_pElem,
        int                         i_iIncrementAmount)
    { 
        //
        // do nothing
        //
    }

    //
    // The following functions are the functions that the user should
    // actually call.
    //
    HRESULT Wmi_Initialize()
    {
        return m_pool.Initialize(HASH_TABLE_POOL_SIZE);
    }

    HRESULT Wmi_Insert(LPWSTR i_wszKey, T i_DataNew)
    {
        DBG_ASSERT(i_wszKey != NULL);

        HRESULT    hr = WBEM_S_NO_ERROR;
        LK_RETCODE lkrc;

        CHashTableElement<T>* pElementNew;

        hr = m_pool.GetNewElement(&pElementNew);
        if(FAILED(hr))
        {
            goto exit;
        }

        pElementNew->m_data   = i_DataNew;
        pElementNew->m_wszKey = i_wszKey;
        pElementNew->m_idx    = m_idxCur;

        lkrc = InsertRecord(pElementNew);
        if(lkrc != LK_SUCCESS)
        {
            hr = Wmi_LKRToHR(lkrc);
            goto exit;
        }

    exit:
        if(SUCCEEDED(hr))
        {
            m_idxCur++;
        }
        return hr;
    }

    HRESULT Wmi_GetByKey(LPCWSTR i_wszKey, T* o_pData, ULONG *o_idx)
    {
        DBG_ASSERT(i_wszKey != NULL);
        DBG_ASSERT(o_pData  != NULL);

        *o_pData = NULL;

        HRESULT                     hr = WBEM_S_NO_ERROR;
        LK_RETCODE                  lkrc;
        const CHashTableElement<T>* pElem = NULL;

        lkrc = FindKey(i_wszKey, &pElem);
        if(lkrc != LK_SUCCESS)
        {
            hr = Wmi_LKRToHR(lkrc);
            return hr;
        }

        *o_pData = pElem->m_data;
        if(o_idx != NULL)
        {
            *o_idx = pElem->m_idx;
        }
        return hr;
    }

    HRESULT Wmi_GetByKey(LPCWSTR i_wszKey, T* o_pData)
    {
        return Wmi_GetByKey(i_wszKey, o_pData, NULL);
    }

    HRESULT Wmi_LKRToHR(LK_RETCODE i_lkrc)
    {
        if(i_lkrc == LK_SUCCESS)
        {
            return WBEM_S_NO_ERROR;
        }

        switch(i_lkrc)
        {
        case LK_ALLOC_FAIL:
            return WBEM_E_OUT_OF_MEMORY;
        default:
            return E_FAIL;
        }
    }

    ULONG Wmi_GetNumElements()
    {
        CLKRHashTableStats stats;
        stats = GetStatistics();
        DBG_ASSERT(stats.RecordCount == m_idxCur);
        return m_idxCur;
    }

private:
    CPool< CHashTableElement<T> > m_pool;
    ULONG m_idxCur;
};

//

#endif // _hashtable_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\ipsecurity.cpp ===
//***************************************************************************
//
//  IPSecurity.cpp
//
//  Module: WBEM Instance provider
//
//  Purpose: IIS IPSecurity class 
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************



#include "iisprov.h"
#include "ipsecurity.h"

#define DEFAULT_TIMEOUT_VALUE 30000
#define BUFFER_SIZE 512

CIPSecurity::CIPSecurity()
{
    m_pADs = NULL;
    m_pIPSec = NULL;
    bIsInherit = FALSE;
}


CIPSecurity::~CIPSecurity()
{
    CloseSD();
}


void CIPSecurity::CloseSD()
{
    if(m_pIPSec)
    {
        m_pIPSec->Release();
        m_pIPSec = NULL;
    }

    if(m_pADs)
    {
        m_pADs->Release();
        m_pADs = NULL;
    }
}


HRESULT CIPSecurity::GetObjectAsync(
    IWbemClassObject* pObj
    )
{
    VARIANT vt;
    VARIANT vtBstrArray;
    HRESULT hr;

    VARIANT vtTrue;
    vtTrue.boolVal = VARIANT_TRUE;
    vtTrue.vt      = VT_BOOL;

    // IPDeny
    hr = m_pIPSec->get_IPDeny(&vt);
    if(SUCCEEDED(hr))
    {
        hr = LoadBstrArrayFromVariantArray(vt, vtBstrArray);
        VariantClear(&vt);

        if(SUCCEEDED(hr))
        {
            hr = pObj->Put(L"IPDeny", 0, &vtBstrArray, 0);
            VariantClear(&vtBstrArray);
        }

        if(bIsInherit && SUCCEEDED(hr))
        {
            hr = CUtils::SetPropertyQualifiers(
                pObj, L"IPDeny", &g_wszIsInherit, &vtTrue, 1);
        }
    }

    // IPGrant
    if(SUCCEEDED(hr))
    {
        hr = m_pIPSec->get_IPGrant(&vt);

        if(SUCCEEDED(hr))
        {
            hr = LoadBstrArrayFromVariantArray(vt, vtBstrArray);
            VariantClear(&vt);

            if(SUCCEEDED(hr))
            {
                hr = pObj->Put(L"IPGrant", 0, &vtBstrArray, 0);
                VariantClear(&vtBstrArray);
            }    
 
            if(bIsInherit && SUCCEEDED(hr))
            {
                hr = CUtils::SetPropertyQualifiers(
                    pObj, L"IPGrant", &g_wszIsInherit, &vtTrue, 1);
            }
        }
    }

    // DomainDeny
    if(SUCCEEDED(hr))
    {
        hr = m_pIPSec->get_DomainDeny(&vt);

        if(SUCCEEDED(hr))
        {
            hr = LoadBstrArrayFromVariantArray(vt, vtBstrArray);
            VariantClear(&vt);

            if(SUCCEEDED(hr))
            {
                hr = pObj->Put(L"DomainDeny", 0, &vtBstrArray, 0);
                VariantClear(&vtBstrArray);
            }

            if(bIsInherit && SUCCEEDED(hr))
            {
                hr = CUtils::SetPropertyQualifiers(
                    pObj, L"DomainDeny", &g_wszIsInherit, &vtTrue, 1);
            }
        }
    }

    // DomainGrant
    if(SUCCEEDED(hr))
    {
        hr = m_pIPSec->get_DomainGrant(&vt);
    
        if(SUCCEEDED(hr))
        {
            hr = LoadBstrArrayFromVariantArray(vt, vtBstrArray);
            VariantClear(&vt);

            if(SUCCEEDED(hr))
            {
                hr = pObj->Put(L"DomainGrant", 0, &vtBstrArray, 0);
                VariantClear(&vtBstrArray);
            }

            if(bIsInherit && SUCCEEDED(hr))
            {
                hr = CUtils::SetPropertyQualifiers(
                    pObj, L"DomainGrant", &g_wszIsInherit, &vtTrue, 1);
            }
        }   
    }

    // GrantByDefault
    if(SUCCEEDED(hr))
        hr = m_pIPSec->get_GrantByDefault(&vt.boolVal);
    if(SUCCEEDED(hr))
    {
        vt.vt = VT_BOOL;
        hr = pObj->Put(L"GrantByDefault", 0, &vt, 0);
        
        if(bIsInherit && SUCCEEDED(hr))
        {
            hr = CUtils::SetPropertyQualifiers(
                pObj, L"GrantByDefault", &g_wszIsInherit, &vtTrue, 1);
        }
    }

    return hr;
}

// Convert SAFEARRAY of BSTRs to SAFEARRAY of VARIANTs
HRESULT CIPSecurity::LoadVariantArrayFromBstrArray(
    VARIANT&    i_vtBstr,
    VARIANT&    o_vtVariant)
{
    SAFEARRAYBOUND  aDim;
    SAFEARRAY*      pBstrArray = NULL;
    SAFEARRAY*      pVarArray = NULL;
    BSTR*           paBstr = NULL;
    VARIANT         vt;
    LONG            i=0;
    HRESULT         hr = ERROR_SUCCESS;

    try
    {
        // Verify that the input VARIANT is a BSTR array or NULL.
        if (i_vtBstr.vt != (VT_ARRAY | VT_BSTR) &&
            i_vtBstr.vt != VT_NULL) {
            hr = WBEM_E_INVALID_PARAMETER;
            THROW_ON_ERROR(hr);
        }

        // Initialize the output VARIANT (Set type to VT_EMPTY)
        VariantInit(&o_vtVariant);

        // Handle the case when there is no input array
        if (i_vtBstr.vt == VT_NULL) {
            aDim.lLbound = 0;
            aDim.cElements = 0;
        }
        else {
            // Verify that the input VARIANT contains a SAFEARRAY
            pBstrArray = i_vtBstr.parray;
            if (pBstrArray == NULL) {
                hr = WBEM_E_INVALID_PARAMETER;
                THROW_ON_ERROR(hr);
            }

            // Get the size of the BSTR SAFEARRAY.
            aDim.lLbound = 0;
            aDim.cElements = pBstrArray->rgsabound[0].cElements;
        }

        // Create the new VARIANT SAFEARRAY
        pVarArray = SafeArrayCreate(VT_VARIANT, 1, &aDim);
        if (pVarArray == NULL) {
            hr = E_OUTOFMEMORY;
            THROW_ON_ERROR(hr);
        }

        // Put the new VARIANT SAFEARRAY into our output VARIANT
        o_vtVariant.vt = VT_ARRAY | VT_VARIANT;
        o_vtVariant.parray = pVarArray;

        if(aDim.cElements > 0) {
            // Get the BSTR SAFEARRAY pointer.
            hr = SafeArrayAccessData(pBstrArray, (void**)&paBstr);
            THROW_ON_ERROR(hr);

            // Copy all the BSTRS to VARIANTS
            VariantInit(&vt);
            vt.vt = VT_BSTR;
            for(i = aDim.lLbound; i < (long) aDim.cElements; i++)
            {
                vt.bstrVal = SysAllocString(paBstr[i]);
                if (vt.bstrVal == NULL) {
                    hr = E_OUTOFMEMORY;
                    THROW_ON_ERROR(hr);
                }
                hr = SafeArrayPutElement(pVarArray, &i, &vt);
                VariantClear(&vt);
                THROW_ON_ERROR(hr);
            }

            hr = SafeArrayUnaccessData(pBstrArray);
            THROW_ON_ERROR(hr);
        }
    }
    catch(...)
    {
        // Destroy the VARIANT, the contained SAFEARRAY and the VARIANTs in the SAFEARRAY.
        // It also free the BSTRS contained in the VARIANTs
        VariantClear(&o_vtVariant);
    }
    return hr;
}

HRESULT CIPSecurity::LoadBstrArrayFromVariantArray(
    VARIANT&    i_vtVariant,
    VARIANT&    o_vtBstr
    )
{
    SAFEARRAYBOUND  aDim;
    SAFEARRAY*      pVarArray = NULL;
    SAFEARRAY*      pBstrArray = NULL;
    VARIANT*        paVar = NULL;
    BSTR            bstr = NULL;
    LONG            i = 0;
    HRESULT         hr = ERROR_SUCCESS;

    try 
    {
        // Verify the Variant array.
        if (i_vtVariant.vt != (VT_ARRAY | VT_VARIANT)) {
            hr = WBEM_E_INVALID_PARAMETER;
            THROW_ON_ERROR(hr);
        }

        // Verify that the variant contains a safearray.
        pVarArray = i_vtVariant.parray;
        if (pVarArray == NULL) {
            hr = WBEM_E_INVALID_PARAMETER;
            THROW_ON_ERROR(hr);
        }

        // Initialize the out paramter.
        VariantInit(&o_vtBstr);

        // Get the size of the array.
        aDim.lLbound = 0;
        aDim.cElements = pVarArray->rgsabound[0].cElements;

        // Create the new BSTR array
        pBstrArray = SafeArrayCreate(VT_BSTR, 1, &aDim);
        if (pBstrArray == NULL) {
            hr = E_OUTOFMEMORY;
            THROW_ON_ERROR(hr);
        }

        // Put the array into the variant.
        o_vtBstr.vt = VT_ARRAY | VT_BSTR;
        o_vtBstr.parray = pBstrArray;

        // Get the variant array pointer.
        hr = SafeArrayAccessData(pVarArray, (void**)&paVar);
        THROW_ON_ERROR(hr);

        // Copy all the bstrs.
        for (i = aDim.lLbound; i < (long) aDim.cElements; i++)
        {
            if (paVar[i].vt != VT_BSTR) {
                hr = WBEM_E_FAILED;
                THROW_ON_ERROR(hr);
            }
            bstr = SysAllocString(paVar[i].bstrVal);
            if (bstr == NULL) {
                hr = E_OUTOFMEMORY;
                THROW_ON_ERROR(hr);
            }
            hr = SafeArrayPutElement(pBstrArray, &i, bstr);
            SysFreeString(bstr);
            bstr = NULL;
            THROW_ON_ERROR(hr);
        }

        hr = SafeArrayUnaccessData(pVarArray);
        THROW_ON_ERROR(hr);
    }
    catch (...)
    {
        // Destroy the variant, the safearray and the bstr's in the array.
        VariantClear(&o_vtBstr);
    }

    return hr;
}



HRESULT CIPSecurity::PutObjectAsync(
    IWbemClassObject* pObj
    )
{
    VARIANT vt;
    VARIANT vtVarArray;
    HRESULT hr;

    // IPDeny
    hr = pObj->Get(L"IPDeny", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr)) {
        hr = LoadVariantArrayFromBstrArray(vt, vtVarArray);
        VariantClear(&vt);
    
        if(SUCCEEDED(hr)) {
            hr = m_pIPSec->put_IPDeny(vtVarArray);
            VariantClear(&vtVarArray);
        }
    }

    // IPGrant
    if(SUCCEEDED(hr)) {
        hr = pObj->Get(L"IPGrant", 0, &vt, NULL, NULL);

        if(SUCCEEDED(hr)) {
            hr = LoadVariantArrayFromBstrArray(vt, vtVarArray);
            VariantClear(&vt);
        
            if(SUCCEEDED(hr)) {
                hr = m_pIPSec->put_IPGrant(vtVarArray);
                VariantClear(&vtVarArray);
            }
        }
    }

    // DomainDeny
    if(SUCCEEDED(hr)) {
        hr = pObj->Get(L"DomainDeny", 0, &vt, NULL, NULL);

        if(SUCCEEDED(hr)) {
            hr = LoadVariantArrayFromBstrArray(vt, vtVarArray);
            VariantClear(&vt);
        
            if(SUCCEEDED(hr)) {
                hr = m_pIPSec->put_DomainDeny(vtVarArray);
                VariantClear(&vtVarArray);
            }
        }
    }

    // DomainGrant
    if(SUCCEEDED(hr)) {
        hr = pObj->Get(L"DomainGrant", 0, &vt, NULL, NULL);

        if(SUCCEEDED(hr)) {
            hr = LoadVariantArrayFromBstrArray(vt, vtVarArray);
            VariantClear(&vt);
        
            if(SUCCEEDED(hr)) {
                hr = m_pIPSec->put_DomainGrant(vtVarArray);
                VariantClear(&vtVarArray);
            }
        }
    }

    // GrantByDefault
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"GrantByDefault", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr))
        hr = m_pIPSec->put_GrantByDefault(vt.boolVal); 
    VariantClear(&vt);

    // set the modified IPSecurity back into the metabase
    if(SUCCEEDED(hr))
        hr = SetSD();

    return hr;
}


HRESULT CIPSecurity::OpenSD(
    _bstr_t        bstrAdsPath,
    IMSAdminBase2* pAdminBase)
{
    _variant_t var;
    HRESULT hr;
    IDispatch* pDisp = NULL;
    METADATA_HANDLE hObjHandle = NULL;
    DWORD dwBufferSize = 0;
    METADATA_RECORD mdrMDData;
    BYTE pBuffer[BUFFER_SIZE];
    _bstr_t oldPath;

    try
    {    // close SD interface first
        CloseSD();

        oldPath = bstrAdsPath.copy();

        hr = GetAdsPath(bstrAdsPath);
        if(FAILED(hr))
           return hr;

        // get m_pADs
        hr = ADsGetObject(
             bstrAdsPath,
             IID_IADs,
             (void**)&m_pADs
             );
        if(FAILED(hr))
            return hr;
     
        // get m_pSD
        hr = m_pADs->Get(L"IPSecurity",&var);
        if(FAILED(hr))
            return hr;  
    
        hr = V_DISPATCH(&var)->QueryInterface(
            IID_IISIPSecurity,
            (void**)&m_pIPSec
            );
        if(FAILED(hr))
            return hr;

        // set bIsInherit

        hr = pAdminBase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                oldPath,
                METADATA_PERMISSION_READ,
                DEFAULT_TIMEOUT_VALUE,
                &hObjHandle
                );
        if(FAILED(hr))
            return hr;

        MD_SET_DATA_RECORD(&mdrMDData,
                       MD_IP_SEC,  // ID for "IPSecurity"
                       METADATA_INHERIT | METADATA_ISINHERITED,
                       ALL_METADATA,
                       ALL_METADATA,
                       BUFFER_SIZE,
                       pBuffer);
    
        hr = pAdminBase->GetData(
                hObjHandle,
                L"",
                &mdrMDData,
                &dwBufferSize
                );

        hr = S_OK;

        bIsInherit = mdrMDData.dwMDAttributes & METADATA_ISINHERITED;

    }
    catch(...)
    {
        hr = E_FAIL;
    }

    if (hObjHandle && pAdminBase) {
        pAdminBase->CloseKey(hObjHandle);
    }

    return hr;
}


HRESULT CIPSecurity::SetSD()
{
    _variant_t var;
    HRESULT hr;
    IDispatch* pDisp = NULL;

    try
    {
        // put IPSecurity
        hr = m_pIPSec->QueryInterface(
            IID_IDispatch,
            (void**)&pDisp
            );
        if(FAILED(hr))
           return hr;

        var.vt = VT_DISPATCH;
        var.pdispVal = pDisp;
        hr = m_pADs->Put(L"IPSecurity",var);  // pDisp will be released by this call Put().
        if(FAILED(hr))
           return hr;

        // Commit the change to the active directory
        hr = m_pADs->SetInfo();
    }
    catch(...)
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT CIPSecurity::GetAdsPath(_bstr_t& bstrAdsPath)
{
    DBG_ASSERT(((LPWSTR)bstrAdsPath) != NULL);

    WCHAR* p = new WCHAR[bstrAdsPath.length() + 1];
    if(p == NULL)
        return E_OUTOFMEMORY;

    lstrcpyW(p, bstrAdsPath);

    try
    {
        bstrAdsPath = L"IIS://LocalHost";

        // trim first three charaters "/LM" 
        bstrAdsPath += (p+3);
    }
    catch(_com_error e)
    {
        delete [] p;
        return e.Error();
    }

    delete [] p;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\metabase.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    metabase.cpp

Abstract:

    This file contains implementation of:
        CMetabase, CServerMethod

    CMetabase encapsulates an IMSAdminBase pointer.

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/


#include "iisprov.h"
#include "MultiSzHelper.h"

extern CDynSchema* g_pDynSch;

//
// CMetabaseCache
//
HRESULT CMetabaseCache::Populate(
    IMSAdminBase*   i_pIABase,
    METADATA_HANDLE i_hKey)
{
    DBG_ASSERT(i_pIABase);
    DBG_ASSERT(m_pBuf == NULL); // only call populate once

    DWORD dwDataSetNumber      = 0;
    DWORD dwRequiredBufSize    = 0;

    HRESULT hr                 = WBEM_S_NO_ERROR;

    m_pBuf  = m_pBufFixed;
    m_cbBuf = m_cbBufFixed;
    hr = i_pIABase->GetAllData(
        i_hKey,
        NULL,
        METADATA_INHERIT | METADATA_ISINHERITED,
        ALL_METADATA,
        ALL_METADATA,
        &m_dwNumEntries,
        &dwDataSetNumber,
        m_cbBuf,
        m_pBuf,
        &dwRequiredBufSize);
    if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    {
        m_pBufDynamic = new BYTE[dwRequiredBufSize];
        if(m_pBufDynamic == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
        m_pBuf  = m_pBufDynamic;
        m_cbBuf = dwRequiredBufSize;
        hr = i_pIABase->GetAllData(
            i_hKey,
            NULL,
            METADATA_INHERIT | METADATA_ISINHERITED,
            ALL_METADATA,
            ALL_METADATA,
            &m_dwNumEntries,
            &dwDataSetNumber,
            m_cbBuf,
            m_pBuf,
            &dwRequiredBufSize);
        if(FAILED(hr))
        {
            DBG_ASSERT(hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
            goto exit;
        }
    }
    else if(FAILED(hr))
    {
        goto exit;
    }

    //
    // If we are here, we have a valid data buffer
    //
    m_hKey = i_hKey;

exit:
    if(FAILED(hr))
    {
        m_pBuf  = NULL;
        m_cbBuf = 0;
    }
    return hr;
}

HRESULT CMetabaseCache::GetProp(
    DWORD                          i_dwId,
    DWORD                          i_dwUserType,
    DWORD                          i_dwDataType,
    LPBYTE*                        o_ppData,
    METADATA_GETALL_RECORD**       o_ppmr) const
{
    DBG_ASSERT(o_ppmr   != NULL);
    DBG_ASSERT(o_ppData != NULL);

    *o_ppmr   = NULL;
    *o_ppData = NULL;

    if(m_pBuf == NULL)
    {
        return MD_ERROR_DATA_NOT_FOUND;
    }

    for(ULONG i = 0; i < m_dwNumEntries; i++)
    {
        METADATA_GETALL_RECORD* pmr = ((METADATA_GETALL_RECORD*)m_pBuf) + i;
        if( i_dwId       == pmr->dwMDIdentifier &&
            i_dwUserType == pmr->dwMDUserType &&
            i_dwDataType == pmr->dwMDDataType)
        {
            *o_ppmr   = pmr;
            *o_ppData = m_pBuf + pmr->dwMDDataOffset;
            return S_OK;
        }
    }

    return MD_ERROR_DATA_NOT_FOUND;
}

//
// CMetabase
//

CMetabase::CMetabase()
{
    m_pNodeCache = NULL;
    HRESULT hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase2,
        (void**)&m_pIABase
        );

    THROW_ON_ERROR(hr);
}

CMetabase::~CMetabase()
{
    CacheFree();

    const LIST_ENTRY* ple = m_keyList.GetHead()->Flink;
    while(ple != m_keyList.GetHead())
    {
        const CMetabaseKeyList::CKeyListNode* pNode = 
            CONTAINING_RECORD(ple, CMetabaseKeyList::CKeyListNode, m_leEntry);
        DBG_ASSERT(pNode);
        ple = ple->Flink;
        CloseKey(pNode->hKey);
    }

    if(m_pIABase)
        m_pIABase->Release();
}


HRESULT CMetabase::SaveData()
{
    HRESULT hr = m_pIABase->SaveData();
    return hr;
}


HRESULT CMetabase::BackupWithPasswd( 
    LPCWSTR i_wszMDBackupLocation, 
    DWORD   i_dwMDVersion, 
    DWORD   i_dwMDFlags, 
    LPCWSTR i_wszPassword 
    )
{
    HRESULT hr;
    hr = m_pIABase->BackupWithPasswd(
        i_wszMDBackupLocation, 
        i_dwMDVersion,
        i_dwMDFlags,
        i_wszPassword);
    return hr;
}

HRESULT CMetabase::DeleteBackup( 
    LPCWSTR i_wszMDBackupLocation, 
    DWORD   i_dwMDVersion 
    )
{
    HRESULT hr;
    hr = m_pIABase->DeleteBackup(
        i_wszMDBackupLocation, 
        i_dwMDVersion
        );

    return hr;
}

HRESULT CMetabase::EnumBackups( 
    LPWSTR    io_wszMDBackupLocation, 
    DWORD*    o_pdwMDVersion, 
    PFILETIME o_pftMDBackupTime, 
    DWORD     i_dwMDEnumIndex 
    )
{
    HRESULT hr;

    FILETIME tempTime;

    hr = m_pIABase->EnumBackups(
        io_wszMDBackupLocation, 
        o_pdwMDVersion,
        &tempTime,
        i_dwMDEnumIndex
        );

    if (FAILED(hr))
    {
        return hr;
    }

    if (!FileTimeToLocalFileTime( &tempTime, o_pftMDBackupTime)){
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    
    return hr;
}

HRESULT CMetabase::RestoreWithPasswd( 
    LPCWSTR i_wszMDBackupLocation, 
    DWORD   i_dwMDVersion, 
    DWORD   i_dwMDFlags, 
    LPCWSTR i_wszPassword 
    )
{
    HRESULT hr;
    hr = m_pIABase->RestoreWithPasswd(
        i_wszMDBackupLocation, 
        i_dwMDVersion,
        i_dwMDFlags,
        i_wszPassword);
    return hr;
}

HRESULT CMetabase::Export( 
    LPCWSTR i_wszPasswd,
    LPCWSTR i_wszFileName,
    LPCWSTR i_wszSourcePath,
    DWORD   i_dwMDFlags)
{
    HRESULT hr;
    hr = m_pIABase->Export(
        i_wszPasswd, 
        i_wszFileName,
        i_wszSourcePath,
        i_dwMDFlags);
    return hr;
}

HRESULT CMetabase::Import( 
    LPCWSTR i_wszPasswd,
    LPCWSTR i_wszFileName,
    LPCWSTR i_wszSourcePath,
    LPCWSTR i_wszDestPath,
    DWORD   i_dwMDFlags)
{
    HRESULT hr;
    hr = m_pIABase->Import(
        i_wszPasswd, 
        i_wszFileName,
        i_wszSourcePath,
        i_wszDestPath,
        i_dwMDFlags);
    return hr;
}

HRESULT CMetabase::RestoreHistory( 
    LPCWSTR i_wszMDHistoryLocation,
    DWORD   i_dwMDMajorVersion,
    DWORD   i_dwMDMinorVersion,
    DWORD   i_dwMDFlags)
{
    HRESULT hr;
    hr = m_pIABase->RestoreHistory(
        i_wszMDHistoryLocation, 
        i_dwMDMajorVersion,
        i_dwMDMinorVersion,
        i_dwMDFlags);
    return hr;
}

HRESULT CMetabase::EnumHistory( 
    LPWSTR    io_wszMDHistoryLocation,
    DWORD*    o_pdwMDMajorVersion,
    DWORD*    o_pdwMDMinorVersion,
    PFILETIME o_pftMDHistoryTime,
    DWORD     i_dwMDEnumIndex)
{
    HRESULT hr;
    hr = m_pIABase->EnumHistory(
        io_wszMDHistoryLocation, 
        o_pdwMDMajorVersion,
        o_pdwMDMinorVersion,
        o_pftMDHistoryTime,
        i_dwMDEnumIndex);
    return hr;
}
 
void CMetabase::CloseKey(METADATA_HANDLE i_hKey)
{
    m_keyList.Remove(i_hKey);
    if(i_hKey && m_pIABase)
    {
        m_pIABase->CloseKey(i_hKey);
        DBGPRINTF((DBG_CONTEXT, "Close Key: %x\n", i_hKey));
    }
}

METADATA_HANDLE CMetabase::OpenKey(LPCWSTR i_wszKey, BOOL i_bWrite)
{
    METADATA_HANDLE hKey = NULL;

    DWORD dwMDAccessRequested;
    if(i_bWrite)
        dwMDAccessRequested = METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE;
    else
        dwMDAccessRequested = METADATA_PERMISSION_READ;
   
    HRESULT hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        i_wszKey,
        dwMDAccessRequested,
        DEFAULT_TIMEOUT_VALUE,         // 30 seconds
        &hKey 
        );

    THROW_ON_ERROR(hr);

    hr = m_keyList.Add(hKey);
    if(FAILED(hr))
    {
        m_pIABase->CloseKey(hKey);
        THROW_ON_ERROR(hr);
    }

    DBGPRINTF((DBG_CONTEXT, "Open Key on %ws, returned handle %x\n", i_wszKey, hKey));
    return hKey;
}

//
// force to create or open a key by read/write permision
//
METADATA_HANDLE CMetabase::CreateKey(LPCWSTR i_wszKey)
{
    HRESULT hr;
    METADATA_HANDLE hKey;

    // open and return key if exists
    hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        i_wszKey,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        DEFAULT_TIMEOUT_VALUE,       // 30 seconds
        &hKey
        );

    if(FAILED(hr)) 
    {
        //  create key if not there
        hr = m_pIABase->OpenKey( 
            METADATA_MASTER_ROOT_HANDLE,
            NULL,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            DEFAULT_TIMEOUT_VALUE,       // 30 seconds
            &hKey
            );
        THROW_ON_ERROR(hr);

        // add key
        hr = m_pIABase->AddKey(hKey, i_wszKey);

        // close this root key first
        m_pIABase->CloseKey(hKey);
        THROW_ON_ERROR(hr);

        // now open the key just created
        hr = m_pIABase->OpenKey( 
            METADATA_MASTER_ROOT_HANDLE,
            i_wszKey,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            DEFAULT_TIMEOUT_VALUE,    // 30 seconds
            &hKey 
            );
    
        THROW_ON_ERROR(hr);
    }

    hr = m_keyList.Add(hKey);
    if(FAILED(hr))
    {
        m_pIABase->CloseKey(hKey);
        THROW_ON_ERROR(hr);
    }

    DBGPRINTF((DBG_CONTEXT, "Create Key on %ws, returned handle %x\n", i_wszKey, hKey));
    return hKey;
}

//
// Check if the key is existed
//
bool CMetabase::CheckKey(LPCWSTR i_wszKey)
{
    METADATA_HANDLE hKey = NULL;

    HRESULT hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        i_wszKey,
        METADATA_PERMISSION_READ,
        DEFAULT_TIMEOUT_VALUE,       // 30 seconds
        &hKey 
        );
    
    if(hr == ERROR_SUCCESS)  
    {
        DBGPRINTF((DBG_CONTEXT, "Open Key on %ws, returned handle %x\n", i_wszKey, hKey));
        CloseKey(hKey);
    }
    
    return (hr == ERROR_PATH_BUSY) || (hr == ERROR_SUCCESS) ? true : false;
}

//
// Check if the key is existed
//
HRESULT CMetabase::CheckKey(
    LPCWSTR           i_wszKey,
    METABASE_KEYTYPE* i_pktSearchKeyType)
{
    WCHAR wszBuf[MAX_BUF_SIZE];
    METADATA_RECORD mr = {
        MD_KEY_TYPE, 
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        STRING_METADATA,
        MAX_BUF_SIZE*sizeof(WCHAR),
        (unsigned char*)wszBuf,
        0    
        };

    DWORD dwLen;
    HRESULT hr = m_pIABase->GetData(
        METADATA_MASTER_ROOT_HANDLE,
        i_wszKey,
        &mr,
        &dwLen);
    if( hr == MD_ERROR_DATA_NOT_FOUND &&
        METABASE_PROPERTY_DATA::s_KeyType.pDefaultValue )
    {
        mr.pbMDData = (LPBYTE)METABASE_PROPERTY_DATA::s_KeyType.pDefaultValue;
        hr = S_OK;
    }
    else if(FAILED(hr))
    {
        return hr;
    }

    if( i_pktSearchKeyType && 
        CUtils::CompareKeyType((LPCWSTR)mr.pbMDData, i_pktSearchKeyType) )
    {
        return S_OK;
    }

    return MD_ERROR_DATA_NOT_FOUND;
}

HRESULT CMetabase::DeleteKey(
    METADATA_HANDLE  i_hKey,
    LPCWSTR          i_wszKeyPath)
{
    return m_pIABase->DeleteKey( 
        i_hKey,
        i_wszKeyPath
        );
}

void CMetabase::CacheInit(
    METADATA_HANDLE i_hKey)
{
    HRESULT hr = S_OK;
    delete m_pNodeCache;
    m_pNodeCache = new CMetabaseCache();
    if(m_pNodeCache == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }
    
    hr = m_pNodeCache->Populate(
        m_pIABase,
        i_hKey);
    THROW_ON_ERROR(hr);
}

void CMetabase::CacheFree()
{
    delete m_pNodeCache;
    m_pNodeCache = NULL;
}

void CMetabase::Get(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    CWbemServices*      i_pNamespace,
    _variant_t&         io_vt,
    BOOL*               io_pbIsInherited,
    BOOL*               io_pbIsDefault
    )
{
    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    switch (i_pmbp->dwMDDataType) 
    {
    case DWORD_METADATA:
        GetDword(i_hKey, i_pmbp, io_vt, io_pbIsInherited, io_pbIsDefault);
        break;

    case EXPANDSZ_METADATA:
    case STRING_METADATA:
        GetString(i_hKey, i_pmbp, io_vt, io_pbIsInherited, io_pbIsDefault);
        break;

    case MULTISZ_METADATA:
        GetMultiSz(i_hKey, i_pmbp, i_pNamespace, io_vt, io_pbIsInherited, io_pbIsDefault);
        break;

    case BINARY_METADATA:
        GetBinary(i_hKey, i_pmbp, io_vt, io_pbIsInherited, io_pbIsDefault);
        break;

    default:        
        DBGPRINTF((DBG_CONTEXT,
            "[CMetabase::Get] Cannot retrieve %ws because type %u is unknown\n",
            i_pmbp->pszPropName,
            i_pmbp->dwMDDataType));
        break;
    }
}

//
// GetDword 
//
// A long or bool is returned in the VARIANT.  The value is a bool if the
// METABASE_PROPERTY has a mask otherwise the DWORD is returned as a long.
// The METADATA_HANDLE is expected to be valid and open.
//
void CMetabase::GetDword(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    _variant_t&         io_vt,
    BOOL*               io_pbIsInherited,
    BOOL*               io_pbIsDefault
    )
{
    DWORD    dw    = 0;
    DWORD    dwRet = 0;
    HRESULT  hr    = WBEM_S_NO_ERROR;

    BOOL     bIsInherited = false;
    BOOL     bIsDefault   = false;

    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    METADATA_RECORD mr = {
        i_pmbp->dwMDIdentifier, 
        i_pmbp->dwMDAttributes | METADATA_ISINHERITED,
        i_pmbp->dwMDUserType,
        i_pmbp->dwMDDataType,
        sizeof(DWORD),
        (unsigned char*)&dw,
        0
        };

    if(m_pNodeCache && m_pNodeCache->GetHandle() == i_hKey)
    {
        METADATA_GETALL_RECORD* pmr = NULL;
        hr = m_pNodeCache->GetProp(
            i_pmbp->dwMDIdentifier,
            i_pmbp->dwMDUserType,
            i_pmbp->dwMDDataType,
            &mr.pbMDData,
            &pmr);
        if(SUCCEEDED(hr))
        {
            DBG_ASSERT(pmr);
            mr.dwMDAttributes = pmr->dwMDAttributes;
            dw                = *((DWORD*)mr.pbMDData);
        }
    }
    else
    {
        hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);
    }

    //
    // Set out parameters
    //
    if (hr == MD_ERROR_DATA_NOT_FOUND)
    {
        bIsInherited = false;
        if(i_pmbp->pDefaultValue == NULL)
        {
            io_vt.vt        = VT_NULL;
            bIsDefault      = false;
        }
        else
        {
            if(i_pmbp->dwMDMask)
            {
                io_vt.vt      = VT_BOOL;
                io_vt.boolVal = (i_pmbp->dwDefaultValue & i_pmbp->dwMDMask ? -1 : 0);
            }
            else
            {
                io_vt.vt    = VT_I4;
                io_vt.lVal  = i_pmbp->dwDefaultValue;
            }
            bIsDefault      = true;
        }
    }
    else
    {
        THROW_E_ON_ERROR(hr,i_pmbp);
        if (i_pmbp->dwMDMask) 
        {
            io_vt.vt      = VT_BOOL;
            io_vt.boolVal = (dw & i_pmbp->dwMDMask? -1 : 0);
        }
        else 
        {
            io_vt.vt      = VT_I4;
            io_vt.lVal    = dw;
        }
        bIsDefault        = false;
        bIsInherited      = mr.dwMDAttributes & METADATA_ISINHERITED;
    }

    if(io_pbIsInherited != NULL)
    {
        *io_pbIsInherited = bIsInherited;
    }
    if(io_pbIsDefault != NULL)
    {
        *io_pbIsDefault = bIsDefault;
    }
}


//
// GetStringFromMetabase 
//
void CMetabase::GetString(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    _variant_t&         io_vt,
    BOOL*               io_pbIsInherited,
    BOOL*               io_pbIsDefault
    )
{
    DWORD    dwRet;
    HRESULT  hr;
    WCHAR    wszBufStack[MAX_BUF_SIZE];

    BOOL     bIsDefault   = false;
    BOOL     bIsInherited = false;

    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    METADATA_RECORD mr = {
        i_pmbp->dwMDIdentifier, 
        i_pmbp->dwMDAttributes | METADATA_ISINHERITED,
        i_pmbp->dwMDUserType,
        i_pmbp->dwMDDataType,
        MAX_BUF_SIZE*sizeof(WCHAR),
        (LPBYTE)wszBufStack,
        0
        };

    if(m_pNodeCache && m_pNodeCache->GetHandle() == i_hKey)
    {
        METADATA_GETALL_RECORD* pmr = NULL;
        hr = m_pNodeCache->GetProp(
            i_pmbp->dwMDIdentifier,
            i_pmbp->dwMDUserType,
            i_pmbp->dwMDDataType,
            &mr.pbMDData,
            &pmr);
        if(SUCCEEDED(hr))
        {
            DBG_ASSERT(pmr);
            mr.dwMDAttributes = pmr->dwMDAttributes;
        }
    }
    else
    {
        hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);
    }

    //
    // Set out parameters.
    //
    if (hr == MD_ERROR_DATA_NOT_FOUND) 
    {
        bIsInherited = false;
        if(i_pmbp->pDefaultValue == NULL)
        {
            io_vt.vt   = VT_NULL;
            bIsDefault = false;
        }
        else
        {
            io_vt      = (LPWSTR)i_pmbp->pDefaultValue;
            bIsDefault = true;
        }
    }
    else
    {
        THROW_E_ON_ERROR(hr, i_pmbp);

        io_vt        = (LPWSTR)mr.pbMDData;
        bIsInherited = mr.dwMDAttributes & METADATA_ISINHERITED;
        bIsDefault   = false;
    }

    if(io_pbIsDefault)
    {
        *io_pbIsDefault   = bIsDefault;
    }
    if(io_pbIsInherited)
    {
        *io_pbIsInherited = bIsInherited;
    }
}

//
// GetMultiSz 
//
void CMetabase::GetMultiSz(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    CWbemServices*      i_pNamespace,
    _variant_t&         io_vt,
    BOOL*               io_pbIsInherited,
    BOOL*               io_pbIsDefault
    )
{
    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    DWORD    dwRet;
    HRESULT  hr;
    WCHAR    *buffer = NULL;

    BOOL     bIsDefault   = false;
    BOOL     bIsInherited = false;

    METADATA_RECORD mr;
    mr.dwMDIdentifier = i_pmbp->dwMDIdentifier;
    mr.dwMDAttributes = i_pmbp->dwMDAttributes | METADATA_ISINHERITED;
    mr.dwMDUserType   = i_pmbp->dwMDUserType;
    mr.dwMDDataType   = i_pmbp->dwMDDataType;
    mr.pbMDData       = NULL;
    mr.dwMDDataLen    = 0;
    mr.dwMDDataTag    = 0;

    try 
    {
        if(m_pNodeCache && m_pNodeCache->GetHandle() == i_hKey)
        {
            METADATA_GETALL_RECORD* pmr = NULL;
            hr = m_pNodeCache->GetProp(
                i_pmbp->dwMDIdentifier,
                i_pmbp->dwMDUserType,
                i_pmbp->dwMDDataType,
                &mr.pbMDData,
                &pmr);
            if(SUCCEEDED(hr))
            {
                DBG_ASSERT(pmr);
                mr.dwMDAttributes = pmr->dwMDAttributes;
            }
        }
        else
        {
            buffer = new WCHAR[10*MAX_BUF_SIZE];
            if(buffer == NULL)
            {
                throw WBEM_E_OUT_OF_MEMORY;
            }
            buffer[0]      = L'\0';
            mr.pbMDData    = (LPBYTE)buffer;
            mr.dwMDDataLen = 10*MAX_BUF_SIZE*sizeof(WCHAR);

            hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);

            if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
            {
                delete [] buffer;
                buffer = new WCHAR[dwRet/sizeof(WCHAR) + 1];
                if(buffer == NULL)
                {
                    throw (HRESULT)WBEM_E_OUT_OF_MEMORY;
                }
                buffer[0]      = L'\0';
                mr.pbMDData    = (LPBYTE)buffer;
                mr.dwMDDataLen = sizeof(WCHAR) + dwRet;
        
                hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);
            }
        }

        CMultiSz MultiSz(i_pmbp, i_pNamespace);
        if (hr == MD_ERROR_DATA_NOT_FOUND) 
        {
            bIsInherited = false;
            if(i_pmbp->pDefaultValue == NULL)
            {
                io_vt.vt   = VT_NULL;
                bIsDefault = false;
            }
            else
            {
                hr = MultiSz.ToWmiForm((LPWSTR)i_pmbp->pDefaultValue, &io_vt);
                THROW_E_ON_ERROR(hr,i_pmbp);
                bIsDefault = true;
            }
        }
        else
        {
            THROW_E_ON_ERROR(hr,i_pmbp);
            hr = MultiSz.ToWmiForm((LPWSTR)mr.pbMDData,&io_vt);
            THROW_E_ON_ERROR(hr,i_pmbp);
            bIsInherited = mr.dwMDAttributes & METADATA_ISINHERITED;
            bIsDefault   = false;
        }

        if(io_pbIsDefault)
        {
            *io_pbIsDefault   = bIsDefault;
        }
        if(io_pbIsInherited)
        {
            *io_pbIsInherited = bIsInherited;
        }

        //
        // Cleanup
        //
        delete [] buffer;
    }
    catch (...)
    {
        delete [] buffer;
        throw;
    }
}

void CMetabase::GetBinary(
    METADATA_HANDLE    i_hKey,
    METABASE_PROPERTY* i_pmbp,
    _variant_t&        io_vt,
    BOOL*              io_pbIsInherited,
    BOOL*              io_pbIsDefault
    )
{
    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    DWORD      dwRet  = 0;
    HRESULT    hr     = S_OK;
    CHAR*      pszBuf = NULL;
    SAFEARRAY* safeArray = NULL;

    BOOL       bIsDefault   = false;
    BOOL       bIsInherited = false;

    pszBuf = new CHAR[10*MAX_BUF_SIZE];
    if(pszBuf == NULL)
    {
        throw (HRESULT)WBEM_E_OUT_OF_MEMORY;
    }

    METADATA_RECORD mr = {
        i_pmbp->dwMDIdentifier, 
        (i_pmbp->dwMDAttributes  & !METADATA_REFERENCE) | METADATA_ISINHERITED,
        i_pmbp->dwMDUserType,
        i_pmbp->dwMDDataType,
        10*MAX_BUF_SIZE*sizeof(CHAR),
        (unsigned char*)pszBuf,
        0
        };

    hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);
    if (hr == ERROR_INSUFFICIENT_BUFFER)
    {
        delete [] pszBuf;
        pszBuf = new CHAR[dwRet/sizeof(CHAR) + 1];
        if(pszBuf == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
        mr.pbMDData = (unsigned char*)pszBuf;
        mr.dwMDDataLen = dwRet/sizeof(CHAR) + 1;
        hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);
    }
    if (hr == MD_ERROR_DATA_NOT_FOUND) 
    {
        bIsInherited = false;
        if(i_pmbp->pDefaultValue == NULL)
        {
            io_vt.vt   = VT_NULL;
            bIsDefault = false;
            hr = S_OK;
        }
        else
        {
            hr = CUtils::LoadSafeArrayFromByteArray(
                (LPBYTE)i_pmbp->pDefaultValue, 
                i_pmbp->dwDefaultValue,
                io_vt);
            if(FAILED(hr))
            {
                goto exit;
            }
            bIsDefault = true;
        }
    }
    else if(FAILED(hr))
    {
        goto exit;
    }
    else
    {
        hr = CUtils::LoadSafeArrayFromByteArray((LPBYTE)pszBuf, mr.dwMDDataLen, io_vt);
        if(FAILED(hr))
        {
            goto exit;
        }
        bIsInherited = mr.dwMDAttributes & METADATA_ISINHERITED;
        bIsDefault   = false;
    }

    //
    // If everything succeeded, set out parameters.
    //
    if(io_pbIsInherited)
    {
        *io_pbIsInherited = bIsInherited;
    }
    if(io_pbIsDefault)
    {
        *io_pbIsDefault   = bIsDefault;
    }

exit:
    delete [] pszBuf;
    if(FAILED(hr))
    {
        throw (HRESULT)hr;
    }
}

//
// Put
//
void CMetabase::Put(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    CWbemServices*      i_pNamespace,
    _variant_t&         i_vt,
    _variant_t*         i_pvtOld,            // can be NULL
    DWORD               i_dwQuals,           // optional
    BOOL                i_bDoDiff            // optional
    )
{
    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    switch(i_pmbp->dwMDDataType)
    {
    case DWORD_METADATA:
        PutDword(i_hKey, i_pmbp, i_vt, i_pvtOld, i_dwQuals, i_bDoDiff);
        break;

    case STRING_METADATA:
    case EXPANDSZ_METADATA:
        PutString(i_hKey, i_pmbp, i_vt, i_pvtOld, i_dwQuals, i_bDoDiff);
        break;

    case MULTISZ_METADATA:
        PutMultiSz(i_hKey, i_pmbp, i_pNamespace, i_vt, i_pvtOld, i_dwQuals, i_bDoDiff);
        break;

    case BINARY_METADATA:
        PutBinary(i_hKey, i_pmbp, i_vt, i_pvtOld, i_dwQuals, i_bDoDiff);
        break;

    default:
        DBGPRINTF((DBG_CONTEXT,
            "[CMetabase::Put] Cannot set %ws because type %u is unknown\n",
            i_pmbp->pszPropName,
            i_pmbp->dwMDDataType));
        break;
    }
}

//
// PutDword 
//
void CMetabase::PutDword(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    _variant_t&         i_vt,
    _variant_t*         i_pvtOld,            // can be NULL
    DWORD               i_dwQuals,           // optional
    BOOL                i_bDoDiff            // optional
    )
{
    DWORD    dw=0;
    DWORD    dwOld=0;
    DWORD    dwRet=0;
    HRESULT  hr=0;

    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    METADATA_RECORD mr;
    mr.dwMDIdentifier = i_pmbp->dwMDIdentifier;
    mr.dwMDAttributes = i_pmbp->dwMDAttributes;
    mr.dwMDUserType   = i_pmbp->dwMDUserType;
    mr.dwMDDataType   = i_pmbp->dwMDDataType;
    mr.dwMDDataLen    = sizeof(DWORD_METADATA);
    mr.pbMDData       = (unsigned char*)&dwOld;
    mr.dwMDDataTag    = 0;

    // if it's the bit of a flag
    if (i_vt.vt == VT_BOOL && i_pmbp->dwMDMask != 0)
    {
        // Read the entire flag from in the metabase so we can set the bit
        hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);

        if(hr == MD_ERROR_DATA_NOT_FOUND)
        {
            if(i_pmbp->pDefaultValue != NULL)
            {
                dwOld = i_pmbp->dwDefaultValue;
            }
            else
            {
                dwOld = 0;
            }
            hr = ERROR_SUCCESS;
        }

        if (hr == ERROR_SUCCESS)
        {
            if (i_vt.boolVal)
                dw = dwOld | i_pmbp->dwMDMask;
            else
                dw = dwOld & ~i_pmbp->dwMDMask;
        }
        else
            THROW_ON_ERROR(hr);

        if(dw == -1)
            dw = 1;  // true
    }
    else if (i_vt.vt  == VT_I4)
    {
        dw = i_vt.lVal;
    }
    else if (i_vt.vt == VT_BOOL)
    {
        DBG_ASSERT(false && "i_pmbp->dwMDMask should not be 0");
        dw = i_vt.bVal;
    }
    else 
        throw WBEM_E_INVALID_OBJECT;
   
    // Decide whether to write to metabase
    bool bWriteToMb    = true;
    if( (i_dwQuals & g_fForcePropertyOverwrite) == 0 && i_bDoDiff )
    {
        bool bMatchOld     = i_pvtOld != NULL && 
                             (i_pvtOld->vt == VT_I4 || i_pvtOld->vt == VT_BOOL) &&
                             *i_pvtOld == i_vt;
        bWriteToMb = !bMatchOld;
    }

    if (bWriteToMb)
    {    
        if( i_pmbp->fReadOnly )
        {
            THROW_E_ON_ERROR(WBEM_E_READ_ONLY, i_pmbp);
        }
        mr.pbMDData = (unsigned char*)&dw;
        hr = m_pIABase->SetData(i_hKey, NULL, &mr);
    }

    THROW_E_ON_ERROR(hr,i_pmbp);
}


//
// PutString 
//
void CMetabase::PutString(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    _variant_t&         i_vt,
    _variant_t*         i_pvtOld,            // can be NULL
    DWORD               i_dwQuals,           // optional
    BOOL                i_bDoDiff            // optional
    )
{
    HRESULT  hr=0;

    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    if(i_vt.vt != VT_BSTR)
    {
        throw (HRESULT)WBEM_E_INVALID_OBJECT;
    }

    METADATA_RECORD mr;
    mr.dwMDIdentifier = i_pmbp->dwMDIdentifier;
    mr.dwMDAttributes = i_pmbp->dwMDAttributes;
    mr.dwMDUserType   = i_pmbp->dwMDUserType;
    mr.dwMDDataType   = i_pmbp->dwMDDataType;
    mr.dwMDDataTag    = 0;

    // Decide whether to write to metabase
    bool bWriteToMb    = true;
    if( (i_dwQuals & g_fForcePropertyOverwrite) == 0 && i_bDoDiff )
    {
        bool bMatchOld     = i_pvtOld != NULL && 
                             i_pvtOld->vt == VT_BSTR &&
                             _wcsicmp(i_pvtOld->bstrVal, i_vt.bstrVal) == 0;
        bWriteToMb = !bMatchOld;
    }

    // Set the value, only if old and new values differ.
    if(bWriteToMb)
    {   
        if( i_pmbp->fReadOnly )
        {
            THROW_E_ON_ERROR(WBEM_E_READ_ONLY, i_pmbp);
        }
        mr.dwMDDataLen = (wcslen(i_vt.bstrVal)+1)*sizeof(WCHAR);
        mr.pbMDData = (unsigned char*)i_vt.bstrVal;

        hr = m_pIABase->SetData(i_hKey, NULL, &mr);
    }

    THROW_E_ON_ERROR(hr,i_pmbp);
}


//
// PutMultiSz 
//
void CMetabase::PutMultiSz(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    CWbemServices*      i_pNamespace,
    _variant_t&         i_vt,
    _variant_t*         i_pvtOld,            // can be NULL
    DWORD               i_dwQuals,           // optional
    BOOL                i_bDoDiff            // optional
    )
{
    int      iLen = 0;
    int      iCounter = 0;
    int      iAdd = 0;
    DWORD    dwRet;
    DWORD    dwRetOld;
    WCHAR    *buffer = NULL;
    WCHAR    *bufferOld = NULL;
    WCHAR    *pwszBiggerBuffer = NULL;
    HRESULT  hr=0;
    WCHAR    *pBuffer = NULL;
    WCHAR    *pBigger = NULL;

    DBG_ASSERT(i_hKey       != NULL);
    DBG_ASSERT(i_pmbp       != NULL);
    DBG_ASSERT(i_pNamespace != NULL);

    if(i_vt.vt != (VT_ARRAY | VT_BSTR) && i_vt.vt != (VT_ARRAY | VT_UNKNOWN))
    {
        throw (HRESULT)WBEM_E_INVALID_OBJECT;
    }

    METADATA_RECORD mr;
    mr.dwMDIdentifier = i_pmbp->dwMDIdentifier;
    mr.dwMDAttributes = i_pmbp->dwMDAttributes;
    mr.dwMDUserType   = i_pmbp->dwMDUserType;
    mr.dwMDDataType   = i_pmbp->dwMDDataType;
    mr.dwMDDataTag    = 0;

    try
    {
        CMultiSz MultiSz(i_pmbp, i_pNamespace);
        hr = MultiSz.ToMetabaseForm(&i_vt, &buffer, &dwRet);
        THROW_ON_ERROR(hr);
 
        // Decide whether to write to metabase
        bool bWriteToMb    = true;
        if( (i_dwQuals & g_fForcePropertyOverwrite) == 0 && i_bDoDiff )
        {
            bool bMatchOld = false;
            if(i_pvtOld != NULL && 
              (i_pvtOld->vt == (VT_ARRAY | VT_BSTR) || i_pvtOld->vt == (VT_ARRAY | VT_UNKNOWN)))
            {
                hr = MultiSz.ToMetabaseForm(i_pvtOld, &bufferOld, &dwRetOld);
                THROW_ON_ERROR(hr);
                if(CUtils::CompareMultiSz(buffer, bufferOld))
                {
                    bMatchOld = true;
                }
                delete [] bufferOld;
                bufferOld = NULL;
            }
            bWriteToMb = !bMatchOld;
        }
 
        if (bWriteToMb)
        {    
            if( i_pmbp->fReadOnly )
            {
             THROW_E_ON_ERROR(WBEM_E_READ_ONLY, i_pmbp);
            }

            // need a special work-around case for MD_SECURE_BINDINGS
            if ( MD_SECURE_BINDINGS == i_pmbp->dwMDIdentifier )
            {

                pBuffer = buffer;
                while (iLen = wcslen(pBuffer))
                {
                    if (pBuffer[iLen-1] != L':')
                    {
                        iAdd++;
                    }

                    iCounter += iLen+1;

                    if (iCounter < dwRet)
                    {
                        pBuffer = buffer + iCounter;
                    }
                    else
                    {
                        // the string wasn't double null terminated - BAD
                        hr = E_FAIL;
                        THROW_ON_ERROR(hr);
                    }
                }

                pwszBiggerBuffer = new WCHAR[dwRet + iAdd];  // iAdd = number of colons to be added

                pBuffer = buffer;
                pBigger = pwszBiggerBuffer;

                while (iLen = wcslen(pBuffer))
                {
                    wcscpy(pBigger, pBuffer);

                    if (pBuffer[iLen-1] != L':')
                    {
                        wcscat(pBigger, L":");
                        pBigger++;
                    }

                    // this is okay
                    // previously we guaranteed pBuffer was double null terminated
                    pBuffer += iLen+1;
                    pBigger += iLen+1;
                }

                // put on the final null
                pwszBiggerBuffer[dwRet + iAdd - 1] = 0;

                mr.pbMDData = (unsigned char*)pwszBiggerBuffer;
                mr.dwMDDataLen = (dwRet + iAdd)*sizeof(WCHAR);
            }
            else
            {
                mr.pbMDData = (unsigned char*)buffer;
                mr.dwMDDataLen = dwRet*sizeof(WCHAR);
            }

            if(buffer != NULL)
            {
                hr = m_pIABase->SetData(i_hKey, NULL, &mr);
            }
            else
            {
                //
                // non-fatal if it fails
                //
                m_pIABase->DeleteData(i_hKey, 
                    NULL, 
                    i_pmbp->dwMDIdentifier, 
                    ALL_METADATA);
            }

        }
        delete [] buffer;

        if (pwszBiggerBuffer)
        {
          delete [] pwszBiggerBuffer;
          pwszBiggerBuffer = NULL;
        }

        buffer = NULL;
        THROW_E_ON_ERROR(hr,i_pmbp);
    }

    catch (...)
    {
        delete [] buffer;
        delete [] bufferOld;

        if (pwszBiggerBuffer)
        {
            delete [] pwszBiggerBuffer;
            pwszBiggerBuffer = NULL;
        }
         
        throw;
    }   
}

//
// PutBinary 
//
void CMetabase::PutBinary(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    _variant_t&         i_vt,
    _variant_t*         i_pvtOld,            // can be NULL
    DWORD               i_dwQuals,           // optional
    BOOL                i_bDoDiff            // optional
    )
{
    DWORD    dwRet;
    DWORD    dwRetOld;
    LPBYTE   buffer = NULL;
    LPBYTE   bufferOld = NULL;
    HRESULT  hr=0;

    bool bWriteToMb    = true;

    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    if(i_vt.vt != (VT_ARRAY | VT_UI1))
    {
        throw (HRESULT)WBEM_E_INVALID_OBJECT;
    }

    METADATA_RECORD mr;
    mr.dwMDIdentifier = i_pmbp->dwMDIdentifier;
    mr.dwMDAttributes = i_pmbp->dwMDAttributes & !METADATA_REFERENCE;
    mr.dwMDUserType   = i_pmbp->dwMDUserType;
    mr.dwMDDataType   = i_pmbp->dwMDDataType;
    mr.dwMDDataTag    = 0;

    hr = CUtils::CreateByteArrayFromSafeArray(i_vt, &buffer, &dwRet);
    if(FAILED(hr))
    {
        goto exit;
    }

    // Decide whether to write to metabase
    if( (i_dwQuals & g_fForcePropertyOverwrite) == 0 && i_bDoDiff )
    {
        bool bMatchOld = false;
        if(i_pvtOld != NULL && 
           i_pvtOld->vt == (VT_ARRAY | VT_UI1))
        {
            hr = CUtils::CreateByteArrayFromSafeArray(*i_pvtOld, &bufferOld, &dwRetOld);                
            if(FAILED(hr))
            {
                goto exit;
            }
            if(CUtils::CompareByteArray(buffer, dwRet, bufferOld, dwRetOld))
            {
                bMatchOld = true;
            }
            delete [] bufferOld;
            bufferOld = NULL;
        }
        bWriteToMb = !bMatchOld;
    }

    if (bWriteToMb)
    {    
        if( i_pmbp->fReadOnly )
        {
            hr = WBEM_E_READ_ONLY;
            goto exit;
        }

        mr.pbMDData    = buffer;
        mr.dwMDDataLen = dwRet;
        
        if(buffer != NULL)
        {
            hr = m_pIABase->SetData(i_hKey, NULL, &mr);
        }
        else
        {
            //
            // non-fatal if it fails
            //
            m_pIABase->DeleteData(i_hKey, 
                NULL, 
                i_pmbp->dwMDIdentifier, 
                ALL_METADATA);
        }

    }
    delete [] buffer;
    buffer = NULL;
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    delete [] buffer;
    delete [] bufferOld;
    THROW_E_ON_ERROR(hr, i_pmbp);
}


//
// DeleteData
//
void CMetabase::DeleteData(
    METADATA_HANDLE     i_hKey,
    DWORD               i_dwMDIdentifier,
    DWORD               i_dwMDDataType)
{
    HRESULT hr;

    if(i_hKey == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    hr = m_pIABase->DeleteData(
        i_hKey, 
        NULL, 
        i_dwMDIdentifier, 
        i_dwMDDataType
        );

    // special case - throw on data not found if we're
    // trying to delete an IIsIPSecuritySetting

    if ((hr == MD_ERROR_DATA_NOT_FOUND && MD_IP_SEC != i_dwMDIdentifier) || hr == ERROR_SUCCESS)
        return;

    THROW_ON_ERROR(hr);
}


//
// DeleteData 
//
void CMetabase::DeleteData(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    bool                i_bThrowOnRO)
{
    HRESULT hr;

    if(i_hKey == NULL || i_pmbp == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    if(i_pmbp->fReadOnly && i_bThrowOnRO)
    {
        THROW_E_ON_ERROR(WBEM_E_READ_ONLY, i_pmbp);
    }

    hr = m_pIABase->DeleteData(
        i_hKey, 
        NULL, 
        i_pmbp->dwMDIdentifier, 
        i_pmbp->dwMDDataType
        );

    if (hr == MD_ERROR_DATA_NOT_FOUND || hr == ERROR_SUCCESS)
        return;

    THROW_E_ON_ERROR(hr,i_pmbp);
}

//
// Enumuerates all the subkeys of i_wszMDPath under i_hKey.
// If we hit a 'valid' subkey, set io_pktKeyTypeSearch to this subkey and return.
// A 'valid' subkey is one where io_pktKeyTypeSearch can be a (grand*)child.
//
HRESULT CMetabase::EnumKeys(
    METADATA_HANDLE    i_hKey,
    LPCWSTR            i_wszMDPath,          //path to the key
    LPWSTR             io_wszMDName,         //receives the name of the subkey --must be METADATA_MAX_NAME_LEN
    DWORD*             io_pdwMDEnumKeyIndex, //index of the subkey
    METABASE_KEYTYPE*& io_pktKeyTypeSearch,
    bool               i_bLookForMatchAtCurrentLevelOnly
    )
{
    HRESULT  hr;
    DWORD    dwRet;
    WCHAR    wszBuf[MAX_BUF_SIZE];

    // DBG_ASSERT(i_hKey != NULL);
    // DBG_ASSERT(i_wszMDPath != NULL);
    DBG_ASSERT(io_wszMDName != NULL);
    DBG_ASSERT(io_pdwMDEnumKeyIndex != NULL);
    DBG_ASSERT(io_pktKeyTypeSearch != NULL);
   
    while(1)
    {
        hr = m_pIABase->EnumKeys(
            i_hKey,
            i_wszMDPath,
            io_wszMDName,
            *io_pdwMDEnumKeyIndex);
        if(hr != ERROR_SUCCESS)
        {
            break;
        }

        wszBuf[0] = L'\0';

        METADATA_RECORD mr = {
            METABASE_PROPERTY_DATA::s_KeyType.dwMDIdentifier, 
            METADATA_NO_ATTRIBUTES,
            IIS_MD_UT_SERVER,
            STRING_METADATA,
            MAX_BUF_SIZE*sizeof(WCHAR),
            (unsigned char*)wszBuf,
            0    
            };

        //
        // Eg. blah/
        //
        _bstr_t bstrPath = L"";
        if(i_wszMDPath)
        {
            bstrPath += i_wszMDPath;
            bstrPath += L"/";
        }
        //
        // Eg. blah/1
        //
        bstrPath += io_wszMDName;

        DBGPRINTF((DBG_CONTEXT, "CMetabase::EnumKeys::GetData (Key = 0x%x, bstrPath = %ws)\n", i_hKey, (LPWSTR)bstrPath));
        hr = m_pIABase->GetData(
            i_hKey, 
            bstrPath,
            &mr, 
            &dwRet);
        if( hr == MD_ERROR_DATA_NOT_FOUND && 
            METABASE_PROPERTY_DATA::s_KeyType.pDefaultValue )
        {
            mr.pbMDData = (LPBYTE)METABASE_PROPERTY_DATA::s_KeyType.pDefaultValue;
            hr = S_OK;
        }

        //
        // If this is a 'valid' subkey, then set io_pktKeyTypeSearch and return.
        //
        if (hr == ERROR_SUCCESS)
        {
            if(i_bLookForMatchAtCurrentLevelOnly == false)
            {
                if(CheckKeyType((LPCWSTR)mr.pbMDData,io_pktKeyTypeSearch))
                {
                    break;
                }
            }
            else
            {
                if(CUtils::CompareKeyType((LPWSTR)mr.pbMDData,io_pktKeyTypeSearch))
                {
                    break;
                }
            }
        }

        //
        // Otherwise, go to next subkey.
        //
        (*io_pdwMDEnumKeyIndex) = (*io_pdwMDEnumKeyIndex)+1;
    }

    return hr;
}

void CMetabase::PutMethod(
    LPWSTR          i_wszPath,
    DWORD           i_id)
{
    HRESULT hr = S_OK;

    CServerMethod method;
    hr = method.Initialize(m_pIABase, i_wszPath);
    THROW_ON_ERROR(hr);

    hr = method.ExecMethod(i_id);
    THROW_ON_ERROR(hr);
}

//
// You are currently at i_wszKeyTypeCurrent in the metabase.  You want to see
// if io_pktKeyTypeSearch can be contained somewhere further down the tree.
//
bool CMetabase::CheckKeyType(
    LPCWSTR             i_wszKeyTypeCurrent,
    METABASE_KEYTYPE*&  io_pktKeyTypeSearch 
    )
{
    bool bRet = false;
    METABASE_KEYTYPE*  pktKeyTypeCurrent = &METABASE_KEYTYPE_DATA::s_NO_TYPE;

    if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_NO_TYPE)
    {
        return false;
    }

    if(FAILED(g_pDynSch->GetHashKeyTypes()->Wmi_GetByKey(i_wszKeyTypeCurrent, &pktKeyTypeCurrent)))
    {
        return (io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsObject) ? true : false;
    }

    if(pktKeyTypeCurrent == io_pktKeyTypeSearch)
    {
        return true;
    }

    if( io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||
        io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE ||
        io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity )
    {
        bRet = true;
    }
    else
    {
        bRet = g_pDynSch->IsContainedUnder(pktKeyTypeCurrent, io_pktKeyTypeSearch);
    }

    if(bRet)
    {
        io_pktKeyTypeSearch = pktKeyTypeCurrent;
    }

    return bRet;

    /*if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsLogModule)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsLogModules )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsFtpInfo)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpService )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsFtpServer)
    {
         if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpService )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsWebInfo)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsFilters)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsFilter)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFilters
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsCompressionSchemes)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFilters )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsCompressionScheme)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFilters ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsCompressionSchemes)
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsWebServer)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsCertMapper)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer 
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsWebFile)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||
        io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebFile ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebFile ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir
            )
            bRet = true;
    }*/
}

HRESULT CMetabase::WebAppCheck(
    METADATA_HANDLE a_hKey
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize;
    METADATA_RECORD mdrMDData;
    WCHAR DataBuf[MAX_PATH];
    DWORD dwState;

    dwBufferSize = MAX_PATH;
    MD_SET_DATA_RECORD(
        &mdrMDData,
        MD_APP_ROOT,
        METADATA_INHERIT|METADATA_ISINHERITED,
        IIS_MD_UT_FILE,
        STRING_METADATA,
        dwBufferSize,
        &DataBuf
        );

    hr = m_pIABase->GetData(
        a_hKey,
        NULL,
        &mdrMDData,
        &dwBufferSize
        );
    THROW_ON_ERROR(hr);

    if (mdrMDData.dwMDAttributes & METADATA_ISINHERITED)
    {
        hr = MD_ERROR_DATA_NOT_FOUND;
        THROW_ON_ERROR(hr);
    }

    dwBufferSize = sizeof(DWORD);
    MD_SET_DATA_RECORD(
        &mdrMDData,
        MD_APP_ISOLATED,
        METADATA_INHERIT|METADATA_ISINHERITED,
        IIS_MD_UT_WAM,
        DWORD_METADATA,
        dwBufferSize,
        &dwState
        );

    hr = m_pIABase->GetData(
        a_hKey,
        NULL,
        &mdrMDData,
        &dwBufferSize
        );
    THROW_ON_ERROR(hr);

    if (mdrMDData.dwMDAttributes & METADATA_ISINHERITED)
    {
        hr = MD_ERROR_DATA_NOT_FOUND;
        THROW_ON_ERROR(hr);
    }

    return hr;
}

HRESULT CMetabase::WebAppGetStatus(
    METADATA_HANDLE a_hKey,
    PDWORD pdwState)
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;

    MD_SET_DATA_RECORD(
        &mdrMDData,
        MD_ASP_ENABLEAPPLICATIONRESTART, 
        METADATA_INHERIT,
        ASP_MD_UT_APP,
        DWORD_METADATA,
        dwBufferSize,
        pdwState
        );

    hr = m_pIABase->GetData(
        a_hKey,
        NULL,
        &mdrMDData,
        &dwBufferSize
        );

    return hr;
}



HRESULT CMetabase::WebAppSetStatus(
    METADATA_HANDLE a_hKey,
    DWORD dwState
    )
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;

    MD_SET_DATA_RECORD(
        &mdrMDData,
        MD_ASP_ENABLEAPPLICATIONRESTART,
        METADATA_INHERIT,
        ASP_MD_UT_APP,
        DWORD_METADATA,
        dwBufferSize,
        &dwState
        );

    hr = m_pIABase->SetData(
        a_hKey,
        NULL,
        &mdrMDData
        );

    return hr;
}


HRESULT
CServerMethod::ExecMethod(
    DWORD dwControl
    )
{
    DWORD dwTargetState;
    DWORD dwPendingState;
    DWORD dwState = 0;
    DWORD dwSleepTotal = 0L;

    METADATA_HANDLE  hKey = 0;

    HRESULT hr       = S_OK;
    HRESULT hrMbNode = S_OK;

    switch(dwControl)
    {
    case MD_SERVER_COMMAND_STOP:
        dwTargetState = MD_SERVER_STATE_STOPPED;
        dwPendingState = MD_SERVER_STATE_STOPPING;
        break;

    case MD_SERVER_COMMAND_START:
        dwTargetState = MD_SERVER_STATE_STARTED;
        dwPendingState = MD_SERVER_STATE_STARTING;
        break;

    case MD_SERVER_COMMAND_CONTINUE:
        dwTargetState = MD_SERVER_STATE_STARTED;
        dwPendingState = MD_SERVER_STATE_CONTINUING;
        break;

    case MD_SERVER_COMMAND_PAUSE:
        dwTargetState = MD_SERVER_STATE_PAUSED;
        dwPendingState = MD_SERVER_STATE_PAUSING;
        break;

    default:
        hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        if(FAILED(hr))
        {
            goto error;
        }
    }

    hr = IISGetServerState(METADATA_MASTER_ROOT_HANDLE, &dwState);
    if(FAILED(hr))
    {
        goto error;
    }
 
    if (dwState == dwTargetState) 
    {
        return (hr);
    }

    //
    // Write the command to the metabase
    //
    hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        m_wszPath,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        DEFAULT_TIMEOUT_VALUE,         // 30 seconds
        &hKey);
    if(FAILED(hr))
    {
        goto error;
    }

    hr = IISSetDword(hKey, MD_WIN32_ERROR, 0, METADATA_VOLATILE);
    if(FAILED(hr))
    {
        m_pIABase->CloseKey(hKey);
        goto error;
    }
    hr = IISSetDword(hKey, MD_SERVER_COMMAND, dwControl, METADATA_VOLATILE);
    if(FAILED(hr))
    {
        m_pIABase->CloseKey(hKey);
        goto error;
    }
    m_pIABase->CloseKey(hKey);

    while (dwSleepTotal < MAX_SLEEP_INST) 
    {
        hr       = IISGetServerState(METADATA_MASTER_ROOT_HANDLE, &dwState);
        if(FAILED(hr))
        {
            goto error;
        }
        hrMbNode = 0;
        hr       = IISGetServerWin32Error(METADATA_MASTER_ROOT_HANDLE, &hrMbNode);
        if(FAILED(hr))
        {
            goto error;
        }

        //
        // First check if we've hit target state
        //
        if (dwState != dwPendingState)
        {
            //
            // Done one way or another
            //
            if (dwState == dwTargetState)
            {
                break;
            }
        }
        //
        // If we haven't check the Win32 Error from the metabase
        //
        if(FAILED(hrMbNode))
        {
            hr = hrMbNode;
            goto error;
        }

        //
        // Still pending...
        //
        ::Sleep(SLEEP_INTERVAL);

        dwSleepTotal += SLEEP_INTERVAL;
    }

    if (dwSleepTotal >= MAX_SLEEP_INST)
    {
        //
        // Timed out.  If there is a real error in the metabase
        // use it, otherwise use a generic timeout error
        //

        hr = HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT);
    }

error :

    return (hr);
}

//
// Helper routine for ExecMethod.
// Gets Win32 error from the metabase
//
HRESULT
CServerMethod::IISGetServerWin32Error(
    METADATA_HANDLE hObjHandle,
    HRESULT*        phrError)
{
    DBG_ASSERT(phrError != NULL);

    long    lWin32Error = 0;
    DWORD   dwLen;

    METADATA_RECORD mr = {
        MD_WIN32_ERROR, 
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        sizeof(DWORD),
        (unsigned char*)&lWin32Error,
        0
        };  
    
    HRESULT hr = m_pIABase->GetData(
        hObjHandle,
        m_wszPath,
        &mr,
        &dwLen);
    if(hr == MD_ERROR_DATA_NOT_FOUND)
    {
        hr = S_FALSE;
    }

    //
    // Set out param
    //
    *phrError = HRESULT_FROM_WIN32(lWin32Error);

    return hr;
}

//
// Helper routine for ExecMethod.
// Gets server state from the metabase.
//
HRESULT
CServerMethod::IISGetServerState(
    METADATA_HANDLE hObjHandle,
    PDWORD pdwState
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)pdwState;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_SERVER_STATE,    // server state
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = m_pIABase->GetData(
             hObjHandle,
             m_wszPath,
             &mdrMDData,
             &dwBufferSize
             );
    
    if( hr == MD_ERROR_DATA_NOT_FOUND )
    {
        //
        // If the data is not there, but the path exists, then the
        // most likely cause is that the service is not running and
        // this object was just created.
        //
        // Since MD_SERVER_STATE would be set as stopped if the
        // service were running when the key is added, we'll just 
        // say that it's stopped. 
        // 
        // Note: starting the server or service will automatically set 
        // the MB value.
        //
        *pdwState = MD_SERVER_STATE_STOPPED;
        hr = S_FALSE;
    }
    else
    {
        if(FAILED(hr))
        {
            goto error;
        }
    }

error:

    return(hr);
}

//
// Helper routine for ExecMethod.
// Used to sets the command or Win32Error in the metabase.
//
HRESULT
CServerMethod::IISSetDword(
    METADATA_HANDLE hKey,
    DWORD dwPropId,
    DWORD dwValue,
    DWORD dwAttrib
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)&dwValue;

    MD_SET_DATA_RECORD(&mdrMDData,
                       dwPropId,
                       dwAttrib,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = m_pIABase->SetData(
             hKey,
             L"",
             &mdrMDData
             );
    if(FAILED(hr))
    {
        goto error;
    }

error:

    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\maindll.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    maindll.cpp

Abstract:

    Contains DLL entry points.  Also has code that controls
    when the DLL can be unloaded by tracking the number of
    objects and locks as well as routines that support
    self registration.

Author:

    ???

Revision History:

    Mohit Srivastava            06-Feb-01

--*/

//#include <objbase.h>
//#include <initguid.h>
#include "iisprov.h"

HMODULE g_hModule;

//
// Count number of objects and number of locks.
//
long               g_cObj=0;
long               g_cLock=0;

extern CDynSchema* g_pDynSch; // Initialized to NULL in schemadynamic.cpp

//
// GuidGen generated GUID for the IIS WMI Provider.
// the GUID in somewhat more legible terms: {D78F1796-E03B-4a81-AFE0-B3B6B0EEE091}
//
DEFINE_GUID(CLSID_IISWbemProvider, 0xd78f1796, 0xe03b, 0x4a81, 0xaf, 0xe0, 0xb3, 0xb6, 0xb0, 0xee, 0xe0, 0x91);

//
// Debugging Stuff
//
#include "pudebug.h"
DECLARE_DEBUG_PRINTS_OBJECT()

//
// Forward declaration(s)
//
HRESULT MofCompile(TCHAR *i_tszPathMofFile, ULONG i_cch);
STDAPI  RegisterEventLog();
STDAPI  UnregisterEventLog();

//
// Entry points
//

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD ulReason, LPVOID pvReserved)
/*++

Synopsis: 
    Entry point for the DLL

Arguments: [hInstance] - 
           [ulReason] - 
           [pvReserved] - 
           
Return Value: 

--*/
{
    switch( ulReason )
    {
    case DLL_PROCESS_ATTACH:
        g_hModule = hInstance;
#ifndef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("IISWMI");
#else
        CREATE_DEBUG_PRINT_OBJECT("IISWMI");
#endif
        CIISInstProvider::m_SafeCritSec = new CSafeAutoCriticalSection();

        break;
        
    case DLL_PROCESS_DETACH:
        DBGPRINTF((DBG_CONTEXT, "<= Deleting CDynSchema\n"));	
        DELETE_DEBUG_PRINT_OBJECT( );
        delete g_pDynSch;
        g_pDynSch = NULL;

        delete CIISInstProvider::m_SafeCritSec;
        CIISInstProvider::m_SafeCritSec = NULL;
        break;     
    }
    
    return TRUE;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
/*++

Synopsis: 
    Called by Ole when some client wants a class factory.  Return
    one only if it is the sort of class this DLL supports.

Arguments: [rclsid] - 
           [riid] - 
           [ppv] - 
           
Return Value: 

--*/
{
    HRESULT        hr   = S_OK;
    IClassFactory* pObj = NULL;

    if (CLSID_IISWbemProvider == rclsid)
    {
        pObj=new CProvFactory();

        if(NULL == pObj)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    hr = pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
    {
        delete pObj;
        pObj = NULL;
    }

    return hr;
}

STDAPI DllCanUnloadNow(void)
/*++

Synopsis: 
    Called periodically by Ole in order to determine if the DLL can be freed.

Arguments: [void] - 
           
Return Value: 
    S_OK if there are no objects in use and the class factory isn't locked.
    S_FALSE otherwise.

--*/
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc = (0L>=g_cObj && 0L>=g_cLock) ? S_OK : S_FALSE;

    return sc;
}

STDAPI DllRegisterServer(void)
/*++

Synopsis: 
    Called during setup or by regsvr32

Arguments: [void] - 
           
Return Value: 
    NOERROR if registration successful, error otherwise.

--*/
{   
    WCHAR   szID[MAX_PATH+1];
    WCHAR   wcID[MAX_PATH+1];
    WCHAR   szCLSID[MAX_PATH+1];
    WCHAR   szModule[MAX_PATH+1];
    WCHAR * pName = L"Microsoft Internet Information Server Provider";
    WCHAR * pModel = L"Both";
    HKEY hKey1, hKey2;

    // Create the path.
    StringFromGUID2(CLSID_IISWbemProvider, wcID, MAX_PATH);
    lstrcpyW(szID, wcID);
    lstrcpyW(szCLSID, L"Software\\classes\\CLSID\\");
    lstrcatW(szCLSID, szID);

    // Create entries under CLSID
    LONG lRet;
    lRet = RegCreateKeyExW(HKEY_LOCAL_MACHINE, 
                          szCLSID, 
                          0, 
                          NULL, 
                          0, 
                          KEY_ALL_ACCESS, 
                          NULL, 
                          &hKey1, 
                          NULL);
    if(lRet != ERROR_SUCCESS)
        return SELFREG_E_CLASS;

    RegSetValueExW(hKey1, 
                  NULL,
                  0, 
                  REG_SZ, 
                  (BYTE *)pName, 
                  lstrlenW(pName)*sizeof(WCHAR)+1);

    lRet = RegCreateKeyExW(hKey1,
                          L"InprocServer32", 
                          0, 
                          NULL, 
                          0, 
                          KEY_ALL_ACCESS, 
                          NULL, 
                          &hKey2, 
                          NULL);
        
    if(lRet != ERROR_SUCCESS)
    {
        RegCloseKey(hKey1);
        return SELFREG_E_CLASS;
    }

    GetModuleFileNameW(g_hModule, szModule,  MAX_PATH);
    RegSetValueExW(hKey2, 
                  NULL, 
                  0, 
                  REG_SZ, 
                  (BYTE*)szModule, 
                  lstrlenW(szModule) * sizeof(WCHAR) + 1);
    RegSetValueExW(hKey2, 
                  L"ThreadingModel", 
                  0, 
                  REG_SZ, 
                  (BYTE *)pModel, 
                  lstrlenW(pModel) * sizeof(WCHAR) + 1);

    RegCloseKey(hKey1);
    RegCloseKey(hKey2);

    //
    // Register other stuff
    //
    HRESULT hr = RegisterEventLog();
    if(FAILED(hr))
    {
        return hr;
    }

    return hr;
}

STDAPI DllUnregisterServer(void)
/*++

Synopsis: 
    Called when it is time to remove the registry entries.

Arguments: [void] - 
           
Return Value: 
    NOERROR if registration successful, error otherwise.

--*/
{
    WCHAR      szID[MAX_PATH+1];
    WCHAR      wcID[MAX_PATH+1];
    WCHAR      szCLSID[MAX_PATH+1];
    HKEY       hKey;

    //
    // Create the path using the CLSID
    //
    StringFromGUID2(CLSID_IISWbemProvider, wcID, 128);
    lstrcpyW(szID, wcID);
    lstrcpyW(szCLSID, L"Software\\classes\\CLSID\\");
    lstrcatW(szCLSID, szID);

    //
    // First delete the InProcServer subkey.
    //
    LONG lRet;
    lRet = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, 
        szCLSID, 
        0,
        KEY_ALL_ACCESS,
        &hKey
        );

    if(lRet == ERROR_SUCCESS)
    {
        RegDeleteKeyW(hKey, L"InProcServer32");
        RegCloseKey(hKey);
    }

    lRet = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, 
        L"Software\\classes\\CLSID",
        0,
        KEY_ALL_ACCESS,
        &hKey
        );

    if(lRet == ERROR_SUCCESS)
    {
        RegDeleteKeyW(hKey,szID);
        RegCloseKey(hKey);
    }

    UnregisterEventLog();

    return S_OK;
}

STDAPI DoMofComp(void)
/*++

Synopsis: 
    Called by NT Setup to put MOF in repository.

Arguments: [void] - 
           
Return Value: 
    NOERROR if registration successful, error otherwise.

--*/
{
    ULONG     cchWinPath;
    LPCTSTR   tszSysPath = TEXT("\\system32\\wbem\\");
    ULONG     cchSysPath = _tcslen(tszSysPath);

    LPCTSTR   tszMOFs[]  = { TEXT("iiswmi.mof"), TEXT("iiswmi.mfl"), NULL };
    ULONG     idx        = 0;
    LPCTSTR   tszCurrent = NULL;
    TCHAR     tszMOFPath[_MAX_PATH];

    HRESULT hres = S_OK;

    hres = CoInitialize(NULL);
    if (FAILED(hres))
    {
        return hres;
    }

    //
    // After this block, tszMOFPath = C:\winnt, len = cchWinPath
    //
    cchWinPath = GetSystemWindowsDirectory(tszMOFPath, _MAX_PATH);
    if(cchWinPath == 0)
    {
        hres = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
    if(cchWinPath > _MAX_PATH)
    {
        hres = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto exit;
    }
    if(tszMOFPath[cchWinPath-1] == TEXT('\\'))
    {
        tszMOFPath[cchWinPath-1] = TEXT('\0');
        cchWinPath--;
    }

    //
    // After this block, tszMOFPath = C:\winnt\system32\wbem\, len = cchWinPath+cchSysPath
    //
    if(cchWinPath+cchSysPath+1 > _MAX_PATH)
    {
        hres = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto exit;
    }
    memcpy(&tszMOFPath[cchWinPath], tszSysPath, sizeof(TCHAR)*(cchSysPath+1));

    //
    // Verify each file exists, and compile it.
    //
    for(idx = 0, tszCurrent = tszMOFs[0]; 
        tszCurrent != NULL; 
        tszCurrent = tszMOFs[++idx])
    {
        ULONG cchCurrent = _tcslen(tszCurrent);
        if(cchWinPath+cchSysPath+cchCurrent+1 > _MAX_PATH)
        {
            hres = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto exit;
        }
        memcpy(&tszMOFPath[cchWinPath+cchSysPath], 
               tszCurrent, 
               sizeof(TCHAR)*(cchCurrent+1));
        if (GetFileAttributes(tszMOFPath) == 0xFFFFFFFF)
        {
            hres = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        hres = MofCompile(tszMOFPath, cchWinPath+cchSysPath+cchCurrent);       
        if(FAILED(hres))
        {
            goto exit;
        }
    }

exit:
    CoUninitialize();
    return hres;
}

//
// Below this line are helper functions.
// They are not actually exported.
//

HRESULT MofCompile(TCHAR *i_tszPathMofFile, ULONG i_cch)
/*++

Synopsis: 
    NOT Exported.  Call by DoMofComp (above)

Arguments: [i_tszPathMofFile] - 
           [i_cch] - count of chars NOT including null terminator.
           
Return Value: 
    HRESULT

--*/
{
    DBG_ASSERT(i_tszPathMofFile != NULL);
    DBG_ASSERT(i_cch < _MAX_PATH);
    DBG_ASSERT(i_cch > 0);
    DBG_ASSERT(i_tszPathMofFile[i_cch] == TEXT('\0'));

    HRESULT hRes = E_FAIL;
    WCHAR wszFileName[_MAX_PATH];
    CComPtr<IMofCompiler>       spMofComp;
    WBEM_COMPILE_STATUS_INFO    Info;
  
    hRes = CoCreateInstance( CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID *)&spMofComp);
    if (FAILED(hRes))
    {
        goto exit;
    }

    //
    // Ensure that the string is WCHAR.
    //
#if defined(UNICODE) || defined(_UNICODE)
    memcpy(wszFileName, i_tszPathMofFile, sizeof(TCHAR)*(i_cch+1));
#else
    if(MultiByteToWideChar( CP_ACP, 0, i_tszPathMofFile, -1, wszFileName, _MAX_PATH) == 0)
    {
        hres = GetLastError();
        hres = HRESULT_FROM_WIN32(hres);
        goto exit;
    }
#endif

    hRes = spMofComp->CompileFile (
                (LPWSTR) wszFileName,
                NULL,			// load into namespace specified in MOF file
                NULL,           // use default User
                NULL,           // use default Authority
                NULL,           // use default Password
                0,              // no options
                0,				// no class flags
                0,              // no instance flags
                &Info);
    if(FAILED(hRes))
    {
        goto exit;
    }

exit:
	return hRes;
}

STDAPI RegisterEventLog(void)
/*++

Synopsis: 
    Sets up iiswmi.dll in the EventLog registry for resolution of NT EventLog
    message strings

Arguments: [void] - 
           
Return Value: 
    HRESULT

--*/
{
    HKEY  hk;
    WCHAR wszModuleFullPath[MAX_PATH];
    DWORD dwTypesSupported = 0;

    DWORD   dwRet;
    HRESULT hr = S_OK;

    dwRet = GetModuleFileNameW(g_hModule, wszModuleFullPath, MAX_PATH);
    if(dwRet == 0)
    {
        return SELFREG_E_CLASS;
    }

    //
    // Create the key
    //
    dwRet = RegCreateKeyW(
        HKEY_LOCAL_MACHINE,
		L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\IISWMI", &hk);
    if(dwRet != ERROR_SUCCESS)
    {
        return SELFREG_E_CLASS;
    }

    //
    // Set the "EventMessageFile" value
    //
    dwRet = RegSetValueExW(
        hk,                                            // subkey handle
        L"EventMessageFile",                           // value name
        0,                                             // must be zero
        REG_EXPAND_SZ,                                 // value type
        (LPBYTE)wszModuleFullPath,                     // address of value data
        sizeof(WCHAR)*(wcslen(wszModuleFullPath)+1) ); // length of value data
    if(dwRet != ERROR_SUCCESS)
    {
        hr = SELFREG_E_CLASS;
        goto exit;
    }

    //
    // Set the "TypesSupported" value
    //
    dwTypesSupported = 
        EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
    dwRet = RegSetValueExW(
        hk,                                            // subkey handle
        L"TypesSupported",                             // value name
        0,                                             // must be zero
        REG_DWORD,                                     // value type
        (LPBYTE)&dwTypesSupported,                     // address of value data
        sizeof(DWORD) );                               // length of value data
    if(dwRet != ERROR_SUCCESS)
    {
        hr = SELFREG_E_CLASS;
        goto exit;
    }

exit:
    RegCloseKey(hk);
    return hr;
}

STDAPI UnregisterEventLog(void)
/*++

Synopsis: 
    Called by DllUnregisterServer.
    Called when it is time to remove the registry entries for event logging.

Arguments: [void] - 
           
Return Value: 
    HRESULT

--*/
{
    //
    // Delete the key
    //
    RegDeleteKeyW(
        HKEY_LOCAL_MACHINE,
        L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\IISWMI");

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\metabase.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    metabase.h

Abstract:

    This file contains implementation of:
        CMetabase, CServerMethod

    CMetabase encapsulates an IMSAdminBase pointer.

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#ifndef _metabase_h_
#define _metabase_h_

#include <iadmw.h>
#include <comdef.h>

//
// Used by CMetabase
//
#define MAX_METABASE_PATH 1024
#define DEFAULT_TIMEOUT_VALUE 30000

//
// Period to sleep while waiting for service to attain desired state
// Used by CServerMethod
//
#define SLEEP_INTERVAL (500L)
#define MAX_SLEEP_INST (60000)       // For an instance

class CMetabase;

//
// CMetabaseCache
//

class CMetabaseCache
{
private:
    static const m_cbBufFixed = 1024;
    BYTE         m_pBufFixed[m_cbBufFixed];
    LPBYTE       m_pBufDynamic;

    LPBYTE       m_pBuf;
    DWORD        m_cbBuf;

    DWORD        m_dwNumEntries;

    METADATA_HANDLE m_hKey;

public:
    CMetabaseCache()
    {
        memset(m_pBufFixed, 0, sizeof(m_pBufFixed));
        m_pBufDynamic  = NULL;

        m_pBuf         = NULL;
        m_cbBuf        = 0;

        m_dwNumEntries = 0;

        m_hKey         = 0;
    }

    ~CMetabaseCache()
    {
        delete [] m_pBufDynamic;
        m_pBufDynamic = NULL;
        m_pBuf        = NULL;
    }

    METADATA_HANDLE GetHandle()
    {
        return m_hKey;
    }

    HRESULT Populate(
        IMSAdminBase*           i_pIABase,
        METADATA_HANDLE         i_hKey);

    HRESULT GetProp(
        DWORD                    i_dwId,
        DWORD                    i_dwUserType,
        DWORD                    i_dwDataType,
        LPBYTE*                  o_ppData,
        METADATA_GETALL_RECORD** o_ppmr) const;
};

class CMetabaseKeyList
{
public:
    CMetabaseKeyList()
    {
        InitializeListHead(&m_leHead);
    }

    ~CMetabaseKeyList()
    {
        while(!IsListEmpty(&m_leHead))
        {
            CKeyListNode* pNode = 
                CONTAINING_RECORD(m_leHead.Flink, CKeyListNode, m_leEntry);
            DBG_ASSERT(pNode != NULL);
            RemoveEntryList(&pNode->m_leEntry);
            delete pNode;
            pNode = NULL;
        }
    }

    HRESULT Add(METADATA_HANDLE i_hKey)
    {
        CKeyListNode* pNew = new CKeyListNode;
        if(pNew == NULL)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        pNew->hKey  = i_hKey;
        InsertHeadList(&m_leHead, &pNew->m_leEntry);

        return WBEM_S_NO_ERROR;
    }

    HRESULT Remove(METADATA_HANDLE i_hKey)
    {
        LIST_ENTRY* pleEntry = &m_leHead;
        while(pleEntry->Flink != pleEntry)
        {
            CKeyListNode* pNode = 
                CONTAINING_RECORD(pleEntry->Flink, CKeyListNode, m_leEntry);
            if(pNode->hKey == i_hKey)
            {
                RemoveEntryList(&pNode->m_leEntry);
                delete pNode;
                pNode = NULL;
                return WBEM_S_NO_ERROR;
            }
            pleEntry = pleEntry->Flink;
        }
        return WBEM_E_FAILED;
    }

    struct CKeyListNode
    {
        LIST_ENTRY      m_leEntry;
        METADATA_HANDLE hKey;
    };

    const LIST_ENTRY* GetHead() const { return &m_leHead; }

private:
    LIST_ENTRY    m_leHead;
};

//
// CMetabase
//

class CMetabase
{
private:

    IMSAdminBase2*    m_pIABase;
    CMetabaseKeyList  m_keyList;
    CMetabaseCache*   m_pNodeCache;

    bool CheckKeyType(
        LPCWSTR             i_wszKeyTypeCurrent,
        METABASE_KEYTYPE*&  io_pktKeyTypeSearch);

public:

    CMetabase();
    ~CMetabase();

    operator IMSAdminBase2*()
    {
        return m_pIABase;
    }

    //
    // IMSAdminBase/IMSAdminBase2 methods exposed thru WMI
    //
    HRESULT SaveData();

    HRESULT BackupWithPasswd( 
        LPCWSTR i_wszMDBackupLocation, 
        DWORD   i_dwMDVersion, 
        DWORD   i_dwMDFlags, 
        LPCWSTR i_wszPassword);

    HRESULT DeleteBackup( 
        LPCWSTR i_wszMDBackupLocation, 
        DWORD   i_dwMDVersion);

    HRESULT EnumBackups( 
        LPWSTR    io_wszMDBackupLocation, 
        DWORD*    o_pdwMDVersion, 
        PFILETIME o_pftMDBackupTime, 
        DWORD     i_dwMDEnumIndex);

    HRESULT RestoreWithPasswd( 
        LPCWSTR i_wszMDBackupLocation, 
        DWORD   i_dwMDVersion, 
        DWORD   i_dwMDFlags, 
        LPCWSTR i_wszPassword);

    HRESULT Export(
        LPCWSTR i_wszPasswd, 
        LPCWSTR i_wszFileName, 
        LPCWSTR i_wszSourcePath, 
        DWORD   i_dwMDFlags);
        
    HRESULT Import(
        LPCWSTR i_wszPasswd,
        LPCWSTR i_wszFileName,
        LPCWSTR i_wszSourcePath,
        LPCWSTR i_wszDestPath,
        DWORD   i_dwMDFlags);
        
    HRESULT RestoreHistory( 
        LPCWSTR i_wszMDHistoryLocation,
        DWORD   i_dwMDMajorVersion,
        DWORD   i_dwMDMinorVersion,
        DWORD   i_dwMDFlags);
        
    HRESULT EnumHistory( 
        LPWSTR    io_wszMDHistoryLocation,
        DWORD*    o_pdwMDMajorVersion,
        DWORD*    o_pdwMDMinorVersion,
        PFILETIME o_pftMDHistoryTime,
        DWORD     i_dwMDEnumIndex);

    //
    // Other IMSAdminBase methods
    //
    void CloseKey(METADATA_HANDLE i_hKey);
    METADATA_HANDLE OpenKey(LPCWSTR i_wszKey, BOOL i_bWrite);
    METADATA_HANDLE CreateKey(LPCWSTR i_wszKey);
    bool CheckKey(LPCWSTR i_wszKey);
    HRESULT CheckKey(LPCWSTR i_wszKey, METABASE_KEYTYPE* i_pktSearchKeyType);
    HRESULT DeleteKey(METADATA_HANDLE i_hKey, LPCWSTR i_wszKeyPath);

    //
    // Cache
    //
    void CacheInit(METADATA_HANDLE i_hKey);
    void CacheFree();

    //
    // Get Data from metabase and convert to WMI-friendly format
    //
    void Get(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        CWbemServices*      i_pNamespace,
        _variant_t&         io_vt,
        BOOL*               io_pbIsInherited,
        BOOL*               io_pbIsDefault);

    void GetDword(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        _variant_t&         io_vt,
        BOOL*               io_pbIsInherited,
        BOOL*               io_pbIsDefault);

    void GetString(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        _variant_t&         io_vt,
        BOOL*               io_pbIsInherited,
        BOOL*               io_pbIsDefault);

    void GetMultiSz(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        CWbemServices*      i_pNamespace,
        _variant_t&         io_vt,
        BOOL*               io_pbIsInherited,
        BOOL*               io_pbIsDefault);

    void GetBinary(
        METADATA_HANDLE    i_hKey,
        METABASE_PROPERTY* i_pmbp,
        _variant_t&        io_vt,
        BOOL*              io_pbIsInherited,
        BOOL*              io_pbIsDefault);

    //
    // Put data to metabase (converting from WMI-friendly format in the process)
    //
    void Put(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        CWbemServices*      i_pNamespace,
        _variant_t&         i_vt,
        _variant_t*         i_pvtOld, // can be NULL
        DWORD               i_dwQuals=0,
        BOOL                i_bDoDiff=false);

    void PutDword(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        _variant_t&         i_vt,
        _variant_t*         i_pvtOld, // can be NULL
        DWORD               i_dwQuals=0,
        BOOL                i_bDoDiff=false);

    void PutString(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        _variant_t&         i_vt,
        _variant_t*         i_pvtOld, // can be NULL
        DWORD               i_dwQuals=0,
        BOOL                i_bDoDiff=false);

    void PutMultiSz(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        CWbemServices*      i_pNamespace,
        _variant_t&         i_vt,
        _variant_t*         i_pvtOld,            // can be NULL
        DWORD               i_dwQuals=0,
        BOOL                i_bDoDiff=false);

    void PutBinary(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        _variant_t&         i_vt,
        _variant_t*         i_pvtOld,            // can be NULL
        DWORD               i_dwQuals=0,
        BOOL                i_bDoDiff=false);

    void PutMethod(
        LPWSTR          i_wszPath,
        DWORD           i_id);

    //
    // Delete from metabase
    //
    void DeleteData(
        METADATA_HANDLE     i_hKey,
        DWORD               i_dwMDIdentifier,
        DWORD               i_dwMDDataType);

    void DeleteData(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        bool                i_bThrowOnRO);

    HRESULT EnumKeys(
        METADATA_HANDLE    i_hKey,
        LPCWSTR            i_wszMDPath,
        LPWSTR             io_wszMDName,
        DWORD*             io_pdwMDEnumKeyIndex,
        METABASE_KEYTYPE*& io_pktKeyTypeSearch,
        bool               i_bLookForMatchAtCurrentLevelOnly=false);

    HRESULT WebAppCheck(METADATA_HANDLE);
    HRESULT WebAppGetStatus(METADATA_HANDLE, PDWORD);
    HRESULT WebAppSetStatus(METADATA_HANDLE, DWORD);
};

//
// Handles the Server.{Start,Stop,Pause,Continue} methods
//
class CServerMethod
{
private:
    LPWSTR          m_wszPath; // full metabase path of loc where we will execute method
    IMSAdminBase*   m_pIABase;

    HRESULT IISGetServerState(
        METADATA_HANDLE hObjHandle,
        LPDWORD pdwState);

    HRESULT IISGetServerWin32Error(
        METADATA_HANDLE hObjHandle,
        HRESULT* phrError);

    HRESULT IISSetDword(
        METADATA_HANDLE hKey,
        DWORD dwPropId,
        DWORD dwValue,
        DWORD dwAttrib);

public:
    CServerMethod()
    {
        m_wszPath = 0;
    }
    HRESULT Initialize(IMSAdminBase* i_pIABase, LPWSTR i_wszPath)
    {
        m_pIABase = i_pIABase;
        m_wszPath = new WCHAR[wcslen(i_wszPath)+1];
        if(m_wszPath == NULL)
        {
            return E_OUTOFMEMORY;
        }
        wcscpy(m_wszPath, i_wszPath);

        return S_OK;
    }
    ~CServerMethod()
    {
        delete [] m_wszPath;
    }

    HRESULT ExecMethod(DWORD dwControl);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\multiszdata.h ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    MultiSzHelper.h

Abstract:

    Defines the TFormattedMultiSz datatype.

Author:

    Mohit Srivastava            22-March-01

Revision History:

--*/

#ifndef _multiszdata_h_
#define _multiszdata_h_

#include <windows.h>
#include <dbgutil.h>

//
// Max Number of fields in a MultiSz
// For example, apServerBindings has 3: IP, Port, Hostname
//
static const ULONG MAX_FIELDS = 10;

struct TFormattedMultiSz
{
    DWORD        dwPropId;
    LPWSTR       wszWmiClassName;
    WCHAR        wcDelim;
    LPCWSTR*     awszFields;
};

//
// Used as the astrFields parameter of TFormattedMultiSz
//
struct TFormattedMultiSzFields
{
    static LPCWSTR             apCustomErrorDescriptions[];
    static LPCWSTR             apHttpCustomHeaders[];
    static LPCWSTR             apHttpErrors[];
    static LPCWSTR             apScriptMaps[];
    static LPCWSTR             apSecureBindings[];
    static LPCWSTR             apServerBindings[];
    static LPCWSTR             apApplicationDependencies[];
    static LPCWSTR             apWebSvcExtRestrictionList[];
    static LPCWSTR             apMimeMaps[];
};

//
// Collection of TFormmatedMultiSz's
//
struct TFormattedMultiSzData
{
    static TFormattedMultiSz   CustomErrorDescriptions;
    static TFormattedMultiSz   HttpCustomHeaders;
    static TFormattedMultiSz   HttpErrors;
    static TFormattedMultiSz   ScriptMaps;
    static TFormattedMultiSz   SecureBindings;
    static TFormattedMultiSz   ServerBindings;
    static TFormattedMultiSz   ApplicationDependencies;
    static TFormattedMultiSz   WebSvcExtRestrictionList;
    static TFormattedMultiSz   MimeMaps;

    static TFormattedMultiSz*  apFormattedMultiSz[];

    static TFormattedMultiSz*  Find(ULONG i_dwPropId)
    {
        DBG_ASSERT(apFormattedMultiSz != NULL);
        for(ULONG i = 0; apFormattedMultiSz[i] != NULL; i++)
        {
            if(i_dwPropId == apFormattedMultiSz[i]->dwPropId)
            {
                return apFormattedMultiSz[i];
            }
        }

        return NULL;
    }
};

#endif  // _multiszdata_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\multiszdata.cpp ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    MultiSzData.cpp

Abstract:

Author:

    Mohit Srivastava            22-March-01

Revision History:

--*/

#include "MultiSzData.h"
#include <iiscnfg.h>

//
// CustomErrorDescriptions
//
LPCWSTR TFormattedMultiSzFields::apCustomErrorDescriptions[] =
{
    L"ErrorCode", L"ErrorSubCode", L"ErrorText", L"ErrorSubcodeText", L"FileSupportOnly", NULL
};
TFormattedMultiSz TFormattedMultiSzData::CustomErrorDescriptions =
{
    MD_CUSTOM_ERROR_DESC,
    L"CustomErrorDescription",
    L',',
    TFormattedMultiSzFields::apCustomErrorDescriptions
};

//
// HttpCustomHeaders
//
LPCWSTR TFormattedMultiSzFields::apHttpCustomHeaders[] =
{
    L"Keyname", L"Value", NULL
};
TFormattedMultiSz TFormattedMultiSzData::HttpCustomHeaders =
{
    MD_HTTP_CUSTOM,
    L"HttpCustomHeader",
    L',',
    TFormattedMultiSzFields::apHttpCustomHeaders
};

//
// HttpErrors
//
LPCWSTR TFormattedMultiSzFields::apHttpErrors[] =
{
    L"HttpErrorCode", L"HttpErrorSubcode", L"HandlerType", L"HandlerLocation", NULL
};
TFormattedMultiSz TFormattedMultiSzData::HttpErrors =
{
    MD_CUSTOM_ERROR,
    L"HttpError",
    L',',
    TFormattedMultiSzFields::apHttpErrors
};

//
// ScriptMaps
//
LPCWSTR TFormattedMultiSzFields::apScriptMaps[] =
{
    L"Extensions", L"ScriptProcessor", L"Flags", L"IncludedVerbs", NULL
};
TFormattedMultiSz TFormattedMultiSzData::ScriptMaps =
{
    MD_SCRIPT_MAPS,
    L"ScriptMap",
    L',',
    TFormattedMultiSzFields::apScriptMaps
};

//
// SecureBindings
//
LPCWSTR TFormattedMultiSzFields::apSecureBindings[] =
{
    L"IP", L"Port", NULL
};
TFormattedMultiSz TFormattedMultiSzData::SecureBindings =
{ 
    MD_SECURE_BINDINGS, 
    L"SecureBinding", 
    L':', 
    TFormattedMultiSzFields::apSecureBindings 
};

//
// ServerBindings
//
LPCWSTR TFormattedMultiSzFields::apServerBindings[] =
{
    L"IP", L"Port", L"Hostname", NULL
};
TFormattedMultiSz TFormattedMultiSzData::ServerBindings =
{ 
    MD_SERVER_BINDINGS, 
    L"ServerBinding",
    L':', 
    TFormattedMultiSzFields::apServerBindings 
};

//
// ApplicationDependencies
//
LPCWSTR TFormattedMultiSzFields::apApplicationDependencies[] =
{
    L"AppName", L"Extensions", NULL
};
TFormattedMultiSz TFormattedMultiSzData::ApplicationDependencies =
{ 
    MD_APP_DEPENDENCIES, 
    L"ApplicationDependency",
    L';', 
    TFormattedMultiSzFields::apApplicationDependencies 
};

//
// WebSvcExtRestrictionList
//
LPCWSTR TFormattedMultiSzFields::apWebSvcExtRestrictionList[] =
{
    L"Access", L"FilePath", L"Deletable", L"ServerExtension", L"Description", NULL
};
TFormattedMultiSz TFormattedMultiSzData::WebSvcExtRestrictionList =
{ 
    MD_WEB_SVC_EXT_RESTRICTION_LIST, 
    L"WebSvcExtRestrictionList",
    L',', 
    TFormattedMultiSzFields::apWebSvcExtRestrictionList 
};

//
// MimeMap
//
LPCWSTR TFormattedMultiSzFields::apMimeMaps[] =
{
    L"Extension", L"MimeType", NULL
};
TFormattedMultiSz TFormattedMultiSzData::MimeMaps =
{ 
    MD_MIME_MAP, 
    L"MimeMap",
    L',', 
    TFormattedMultiSzFields::apMimeMaps 
};

//
// Collection of Formatted MultiSz's
//
TFormattedMultiSz* TFormattedMultiSzData::apFormattedMultiSz[] =
{
    &CustomErrorDescriptions,
    &HttpCustomHeaders,
    &HttpErrors,
    &ScriptMaps,
    &SecureBindings,
    &ServerBindings,
    &ApplicationDependencies,
    &WebSvcExtRestrictionList,
    &MimeMaps,
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\safecs.cpp ===
#include <unicode.h>
#include <windows.h>
#include "SafeCS.h"


//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        SafeCS.cpp
//
// Contents:    CSafeAutoCriticalSection implementation
//              CSafeLock implementation
//
//------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Class:      CSafeAutoCriticalSection
//
//  Purpose:    Wrapper for initializing critical-sections.
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- initializes the critical section
//				Detructor		- uninitializes the critical section 
//
//  Notes:		This provides a convenient way to ensure that you're
//              you wrap InitializeCriticalSection and 
//              UnInitializeCriticalSection in try catches which is useful 
//              in low-mem conditions
//
//---------------------------------------------------------------------------

//+-------------------------------------------------------------------------- 
// Default constructor - Initializes the critical section and sets the state 
// flag to initialized
//+-------------------------------------------------------------------------- 

CSafeAutoCriticalSection::CSafeAutoCriticalSection()
{
    m_lState = STATE_UNINITIALIZED;
	m_dwError = ERROR_SUCCESS;

    __try
    {
	    LONG  lPreviousState;

        // try to set state flag
        lPreviousState = InterlockedCompareExchange(&m_lState,
                                                    STATE_INITIALIZED,
                                                    STATE_UNINITIALIZED);

        // if this critical section was not initialized
        if(STATE_UNINITIALIZED == lPreviousState)
        {
			//
			// Note we can call InitializeCriticalSectionAndSpinCount here
			// and thereby eliminate the need for a try catch in 
			// EnterCriticalSection. But the docs say that 
			// InitializeCriticalSectionAndSpinCount is valid on NT4.0 SP3
			// onwards and we need to run on plain NT4.0 - hence we call
			// InitializeCriticalSection
			//

			InitializeCriticalSection(&m_cs);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        m_dwError = _exception_code();
    }

    // failed to initialize - need to reset
    if(ERROR_SUCCESS != m_dwError)
    {
        m_lState = STATE_UNINITIALIZED;
    }

}

//+-------------------------------------------------------------------------- 
// Destructor
//+-------------------------------------------------------------------------- 

CSafeAutoCriticalSection::~CSafeAutoCriticalSection()
{
    LONG                lPreviousState;

    // try to reset the the state to uninitialized
    lPreviousState = InterlockedCompareExchange(&m_lState,
                                                STATE_UNINITIALIZED,
                                                STATE_INITIALIZED);

    // if the object was initialized delete the critical section
    if(STATE_INITIALIZED == lPreviousState)
    {
        DeleteCriticalSection(&m_cs);
    }
}

//+-------------------------------------------------------------------------- 
// Enters critical section, if needed initializes critical section
// before entering
//
// Returns 
//	DWORD -	ERROR_SUCCESS if everything is fine
//			ERROR_OUTOFMEMORY if failed to create or enter critical section
//+-------------------------------------------------------------------------- 

DWORD CSafeAutoCriticalSection::Lock()
{
    DWORD dwError = ERROR_SUCCESS;

    if(!IsInitialized())
    {
        return m_dwError;
    }

    __try
    {
        EnterCriticalSection(&m_cs);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
	    dwError = _exception_code();
    }

    return dwError;
}

//+-------------------------------------------------------------------------- 
// Leaves critical section
//+-------------------------------------------------------------------------- 
DWORD CSafeAutoCriticalSection::Unlock()
{
    if(!IsInitialized())
    {
        return m_dwError;
    }

    LeaveCriticalSection(&m_cs);

    return ERROR_SUCCESS;

}

//+--------------------------------------------------------------------------
//
//  Class:      CSafeLock
//
//  Purpose:    Auto-unlocking critical-section services
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- locks the critical section (unless told 
//								  otherwise)
//				Detructor		- unlocks the critical section if its locked
//
//  Notes:		This provides a convenient way to ensure that you're
//              unlocking a CSemExclusive, which is useful if your routine
//              can be left via several returns and/or via exceptions....
//
//---------------------------------------------------------------------------

CSafeLock::CSafeLock(CSafeAutoCriticalSection* val) : 
m_pSem(val),
m_locked(FALSE)
{
}

CSafeLock::CSafeLock(CSafeAutoCriticalSection& val) : 
m_pSem(&val),
m_locked(FALSE)
{
}

CSafeLock::~CSafeLock() 
{	
	if (m_locked) 
	{
		m_pSem->Unlock(); 
	}
}

DWORD CSafeLock::Lock() 
{
	DWORD dwError = ERROR_SUCCESS;

	if(!m_locked) 
	{ 
		dwError = m_pSem->Lock(); 

		if(ERROR_SUCCESS == dwError)
		{
			m_locked = TRUE; 
		}
	}

	return dwError;
}


DWORD CSafeLock::Unlock() 
{
	DWORD dwError = ERROR_SUCCESS;

	if(m_locked) 
	{ 
		dwError = m_pSem->Unlock(); 
		m_locked = FALSE; 
	}

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\multiszhelper.cpp ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    MultiSzHelper.cpp

Abstract:

    Implements the CMultiSzHelper class

Author:

    Mohit Srivastava            22-March-01

Revision History:

--*/

#include "MultiSzHelper.h"
#include <iiscnfg.h>
#include <dbgutil.h>
#include <atlbase.h>

#include "utils.h"

//
// CMultiSz
//

CMultiSz::CMultiSz()
{
    m_pMbp              = NULL;
    m_pNamespace        = NULL;
    m_pFormattedMultiSz = NULL;
}

CMultiSz::CMultiSz(
    METABASE_PROPERTY* i_pMbp,
    CWbemServices*     i_pNamespace)
{
    DBG_ASSERT(i_pMbp       != NULL);
    DBG_ASSERT(i_pNamespace != NULL);

    m_pMbp              = i_pMbp;
    m_pNamespace        = i_pNamespace;
    m_pFormattedMultiSz = NULL;

    if(m_pMbp != NULL)
    {
        TFormattedMultiSz* pFormattedMultiSz = NULL;
        for(ULONG i = 0; ; i++)
        {
            pFormattedMultiSz = TFormattedMultiSzData::apFormattedMultiSz[i];
            if(pFormattedMultiSz == NULL)
            {
                break;
            }
            else if(pFormattedMultiSz->dwPropId == m_pMbp->dwMDIdentifier)
            {
                m_pFormattedMultiSz = pFormattedMultiSz;
                break;
            }
        }
    }
}

CMultiSz::~CMultiSz()
{
}

HRESULT CMultiSz::ToMetabaseForm(
    const VARIANT* i_pvt,
    LPWSTR*        o_pmsz,
    PDWORD         io_pdw)
{
    DBG_ASSERT(i_pvt   != NULL);
    DBG_ASSERT(o_pmsz  != NULL);
    DBG_ASSERT(io_pdw  != NULL);

    *o_pmsz  = NULL;
    *io_pdw  = NULL;

    return CreateMultiSzFromSafeArray(
        *i_pvt,
        o_pmsz,
        io_pdw);
}

HRESULT CMultiSz::ToWmiForm(
    LPCWSTR        i_msz,
    VARIANT*       io_pvt)
{
    DBG_ASSERT(i_msz  != NULL);
    DBG_ASSERT(io_pvt != NULL);

    return LoadSafeArrayFromMultiSz(
        i_msz,
        *io_pvt);
}

//
// private
//

HRESULT CMultiSz::CreateMultiSzFromSafeArray(
    const VARIANT&     i_vt,
    WCHAR**            o_pmsz,
    DWORD*             io_pdw
    )
/*++

Synopsis: 

Arguments: [i_vt] - 
           [o_pmsz] - 
           [io_pdw] - 
           
--*/
{
    DBG_ASSERT(i_vt.vt == (VT_ARRAY | VT_BSTR) || i_vt.vt == (VT_ARRAY | VT_UNKNOWN));
    DBG_ASSERT(o_pmsz != NULL);
    DBG_ASSERT(io_pdw != NULL);

    HRESULT hr = S_OK;

    if(i_vt.parray == NULL)
    {
        *o_pmsz = NULL;
        *io_pdw  = 0;
    }

    WCHAR*          msz = NULL;
    long            iLo,iUp,c;
    SAFEARRAY*      psa = i_vt.parray;
    long            i = 0;
    BSTR            bstr = NULL;

    hr = SafeArrayGetLBound(psa,1,&iLo);
    if(FAILED(hr))
    {
        goto exit;
    }
    hr = SafeArrayGetUBound(psa,1,&iUp);
    if(FAILED(hr))
    {
        goto exit;
    }

    for (*io_pdw=0, c = iLo; c <= iUp; c++)
    {
        if(m_pFormattedMultiSz)
        {
            DBG_ASSERT(m_pMbp       != NULL);
            DBG_ASSERT(m_pNamespace != NULL);

            CComPtr<IWbemClassObject> spObj;
            hr = SafeArrayGetElement(psa, &c, &spObj);
            if(FAILED(hr))
            {
                goto exit;
            }
            hr = UnparseEntry(spObj, &bstr);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
        else
        {
            hr = SafeArrayGetElement(psa,&c,&bstr);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
        *io_pdw = *io_pdw + wcslen(bstr) + 1;
        hr = MzCat(&msz,bstr);
        if(FAILED(hr))
        {
            goto exit;
        }
        SysFreeString(bstr);
        bstr = NULL;
    }
    *io_pdw +=1;
    *o_pmsz = msz;

exit:
    if(FAILED(hr))
    {
        delete [] msz;
        msz = NULL;
    }
    SysFreeString(bstr);
    bstr = NULL;

    return hr;
}

HRESULT CMultiSz::MzCat(
    WCHAR**        io_ppdst,
    const WCHAR*   i_psz
    )
/*++

Synopsis: 
    The metabase has this animal called METADATA_STRINGSZ which has the 
    following form: <string><null><string><null><null>.  MzCat concatenates
    strings in the defined way.  *io_ppdst has the new pointer upon exit.  The
    previous value of *io_ppdst is delelted.  *io_ppdst == NULL is handled.

Arguments: [io_ppdst] - 
           [i_psz] - 
           
--*/
{
    DBG_ASSERT(io_ppdst != NULL);

    WCHAR  *psrc;
    WCHAR  *pdst;
    WCHAR  *pnew;
    int    ilen;

    if (i_psz == NULL)
        return WBEM_E_FAILED;

    if (*io_ppdst) 
    {
        for ( ilen=0, psrc = *io_ppdst
            ; *psrc || *(psrc+1)
            ; psrc++, ilen++
            )
        {
            ;
        }

        ilen = ilen + wcslen(i_psz)+3;
    }
    else ilen = wcslen(i_psz)+2;

    pnew = pdst = new WCHAR[ilen];

    if (!pdst)
        return WBEM_E_OUT_OF_MEMORY;
    
    if (*io_ppdst) 
    {
        for ( psrc = *io_ppdst
            ; *psrc || *(psrc+1)
            ; pdst++, psrc++
            )
        {
            *pdst = *psrc;
        }

        *pdst = L'\0';
        pdst++;
    }
    wcscpy(pdst,i_psz);
    *(pnew+ilen-1)=L'\0';

    delete *io_ppdst;
    *io_ppdst=pnew;

    return WBEM_S_NO_ERROR;
}

HRESULT CMultiSz::LoadSafeArrayFromMultiSz(
    LPCWSTR      i_msz,
    VARIANT&     io_vt)
/*++

Synopsis: 

Arguments: [i_msz] - 
           [io_vt] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_msz        != NULL);

    LPCWSTR           msz;
    HRESULT           hr = WBEM_S_NO_ERROR;
    DWORD             c;
    SAFEARRAYBOUND    aDim;
    SAFEARRAY*        psa = NULL;
    long              i = 0;
    VARTYPE           vtypeData = (m_pFormattedMultiSz) ? VT_UNKNOWN : VT_BSTR;
    CComPtr<IWbemClassObject> spClass;

    //
    // figure the dimensions of the multisz
    //
    for (c=1,msz=i_msz; *msz||*(msz+1); msz++)
    {
        if(!*msz) 
        {
            c++;
        }
    }

    aDim.lLbound    = 0;
    aDim.cElements= c;

    psa = SafeArrayCreate(vtypeData, 1, &aDim);
    if (!psa)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }

    if( m_pFormattedMultiSz )
    {
        HRESULT hr = S_OK;

        hr = m_pNamespace->GetObject(
            m_pFormattedMultiSz->wszWmiClassName, 
            0, 
            NULL, 
            &spClass, 
            NULL);

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    for (msz=i_msz; ; i++) 
    {
        if(m_pFormattedMultiSz)
        {
            DBG_ASSERT(m_pMbp       != NULL);
            DBG_ASSERT(m_pNamespace != NULL);

            CComPtr<IWbemClassObject> spObj;
            hr = spClass->SpawnInstance(0, &spObj);
            if(FAILED(hr))
            {
                goto exit;
            }

            hr = ParseEntry(msz, spObj);
            if(FAILED(hr))
            {
                goto exit;
            }

            hr = SafeArrayPutElement(psa, &i, spObj);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
        else
        {
            CComBSTR sbstr = msz;
            if(sbstr.m_str == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto exit;
            }
            hr = SafeArrayPutElement(psa, &i, (BSTR)sbstr);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
    
        msz += wcslen(msz) + 1;
        if (!*msz)
        {
            break;
        }
    }
    io_vt.vt = VT_ARRAY | vtypeData;
    io_vt.parray = psa;

exit:
    if (psa && FAILED(hr)) 
    {
        SafeArrayDestroy(psa);
    }

    return hr;
}

HRESULT CMultiSz::ParseEntry(
    LPCWSTR            i_wszEntry,
    IWbemClassObject*  io_pObj)
/*++

Synopsis: 

Arguments: [i_wszEntry] - 
           [io_pObj] - WMI object corresponding to the particular entry.
                       SpawnInstance should have been called by caller.
           
Return Value: 

--*/
{
    DBG_ASSERT(i_wszEntry          != NULL);
    DBG_ASSERT(io_pObj             != NULL);
    DBG_ASSERT(m_pFormattedMultiSz != NULL);

    HRESULT hr       = WBEM_S_NO_ERROR;

    ULONG   idx                     = 0;
    LPCWSTR wszValue                = NULL;
    ULONG   NrFields                = 0;
    CComPtr<IWbemClassObject> spObj = io_pObj; // dest object

    //
    // Make a copy of the entry.  Put on stack or heap depending on size.
    //
    WCHAR  wszBufStack[64];
    LPWSTR wszBufDyn       = NULL;
    LPWSTR wszEntry        = NULL;
    ULONG  cchEntry        = wcslen(i_wszEntry);
    if((cchEntry+1) < 64)
    {
        wszEntry = wszBufStack;
    }
    else
    {
        wszBufDyn = new WCHAR[cchEntry+1];
        if(wszBufDyn == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
        wszEntry = wszBufDyn;
    }
    memcpy(wszEntry, i_wszEntry, sizeof(WCHAR) * (cchEntry + 1));

    //
    // get the number of fields
    //
    if(m_pFormattedMultiSz->awszFields != NULL)
    {
        for(idx = 0; m_pFormattedMultiSz->awszFields[idx] != NULL; idx++)
        {
        }
        NrFields = idx;
        DBG_ASSERT(NrFields <= MAX_FIELDS);
    }

    //
    // Parse
    //
    ULONG jdx = 0;
    LONG  idxEndOfLastString = -1;
    for(idx = 0; idx < (cchEntry+1) && jdx < NrFields; idx++)
    {
        if( wszEntry[idx] == m_pFormattedMultiSz->wcDelim ||
            wszEntry[idx] == L'\0' )
        {
            //
            // If there's only one spot left in our array, we take the remaining
            // string -- including delimeters -- and put it as the last element
            //
            if(jdx != NrFields-1)
            {
                wszEntry[idx]            = L'\0';
            }

            CComVariant vtEntry;
            vtEntry = wszEntry + idxEndOfLastString + 1;
            if(vtEntry.vt == VT_ERROR)
            {
                hr = vtEntry.scode;
                goto exit;
            }

            hr = spObj->Put(
                m_pFormattedMultiSz->awszFields[jdx],
                0,
                &vtEntry,
                0);
            if(FAILED(hr))
            {
                goto exit;
            }

            jdx++;
            idxEndOfLastString       = idx;
        }
    }
    
exit:
    delete [] wszBufDyn;
    wszBufDyn = NULL;
    return hr;
}

HRESULT CMultiSz::UnparseEntry(
    IWbemClassObject* i_pObj,
    BSTR*             o_pbstrEntry)
{
    DBG_ASSERT(i_pObj              != NULL);
    DBG_ASSERT(o_pbstrEntry       != NULL);
    DBG_ASSERT(m_pFormattedMultiSz != NULL);

    *o_pbstrEntry = NULL;

    HRESULT  hr            = S_OK;
    LPCWSTR* awszFields    = m_pFormattedMultiSz->awszFields;
    CComBSTR sbstrUnparsed;

    if(awszFields == NULL)
    {
        goto exit;
    }

    WCHAR wszDelim[2];
    wszDelim[0] = m_pFormattedMultiSz->wcDelim;
    wszDelim[1] = L'\0';

    for(ULONG i = 0; awszFields[i] != NULL; i++)
    {
        CComVariant vtValue;
        hr = i_pObj->Get(
            awszFields[i],
            0,
            &vtValue,
            NULL,
            NULL);
        if(FAILED(hr))
        {
            goto exit;
        }
        if(vtValue.vt == VT_BSTR && vtValue.bstrVal != NULL)
        {
            sbstrUnparsed += vtValue.bstrVal;
            if(sbstrUnparsed.m_str == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto exit;
            }
        }
        if(awszFields[i+1] != NULL)
        {
            sbstrUnparsed += wszDelim;
            if(sbstrUnparsed.m_str == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto exit;
            }
        }
    }

    //
    // Set out parameters if everything succeeded
    //
    *o_pbstrEntry = sbstrUnparsed.Detach();

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\safecs.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        SafeCS.h
//
// Contents:    CSafeAutoCriticalSection, protects CriticalSection against AV via try,catch
//
//------------------------------------------------------------------------
#ifndef _SAFECS_H_
#define _SAFECS_H_

class CSafeAutoCriticalSection
{
public:


    CSafeAutoCriticalSection();
    ~CSafeAutoCriticalSection();

    DWORD Lock();
    DWORD  Unlock();

    BOOL IsInitialized() { return (STATE_INITIALIZED == m_lState);}

private:

    enum
    {
        STATE_UNINITIALIZED = 0,
        STATE_INITIALIZED   = 1
    };

    CRITICAL_SECTION    m_cs;
    LONG                m_lState;
	DWORD               m_dwError;

};

class CSafeLock 
{
public:
	CSafeLock (CSafeAutoCriticalSection* val);
	CSafeLock (CSafeAutoCriticalSection& val);

	~CSafeLock ();

	DWORD Lock ();
	DWORD Unlock ();
private:

private:
	BOOL m_locked;
	CSafeAutoCriticalSection* m_pSem;
};

#endif // _SAFECS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\multiszhelper.h ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    MultiSzHelper.h

Abstract:

    Defines the CMultiSzHelper class

Author:

    Mohit Srivastava            22-March-01

Revision History:

--*/

#ifndef _multiszhelper_h_
#define _multiszhelper_h_

#include <windows.h>
#include <comutil.h>
#include <wbemprov.h>
#include "schema.h"
#include "WbemServices.h"
#include "MultiSzData.h"

class CMultiSz
{
public:
    CMultiSz(
        METABASE_PROPERTY* i_pMbp,
        CWbemServices*     i_pNamespace);

    CMultiSz();

    virtual ~CMultiSz();

    HRESULT ToMetabaseForm(
        const VARIANT* i_pvt,
        LPWSTR*        o_msz,
        PDWORD         io_pdw);

    HRESULT ToWmiForm(
        LPCWSTR        i_msz,
        VARIANT*       io_pvt);

private:
    HRESULT CreateMultiSzFromSafeArray(
        const VARIANT&     i_vt,
        WCHAR**            o_pmsz,
        DWORD*             io_pdw);

    HRESULT MzCat(
        WCHAR**        io_ppdst,
        const WCHAR*   i_psz);

    HRESULT LoadSafeArrayFromMultiSz(
        LPCWSTR      i_msz,
        VARIANT&     io_vt);

    HRESULT ParseEntry(
        LPCWSTR            i_wszEntry,
        IWbemClassObject*  io_pObj);

    HRESULT UnparseEntry(
        IWbemClassObject*  i_pObj,
        BSTR*              o_pbstrEntry);

    METABASE_PROPERTY*  m_pMbp;
    CWbemServices*      m_pNamespace;
    TFormattedMultiSz*  m_pFormattedMultiSz;
};

#endif  // _multiszhelper_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\queryhelper.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    queryhelper.cpp

Abstract:

    Implementation of:
    CQueryHelper

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

//
// Needed for metabase.h
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include "iisprov.h"
#include "assocbase.h"
#include "assocsamelevel.h"
#include "assocACLACE.h"
#include "assocComponent.h"

#include "adminacl.h"
#include "queryhelper.h"
#include "instancehelper.h"
#include "utils.h"
#include "metabase.h"
#include "enum.h"
#include "SmartPointer.h"

#include <opathlex.h>
#include <objpath.h>

CQueryHelper::CQueryHelper(
    BSTR              i_bstrQueryLanguage,
    BSTR              i_bstrQuery,
    CWbemServices*    i_pNamespace,
    IWbemObjectSink*  i_pResponseHandler) :
    m_pWmiClass(NULL),
    m_pWmiAssoc(NULL),
    m_pExp(NULL),
    m_pNamespace(NULL)
{
    DBG_ASSERT(i_bstrQueryLanguage != NULL);
    DBG_ASSERT(i_bstrQuery         != NULL);
    DBG_ASSERT(i_pNamespace        != NULL);
    DBG_ASSERT(i_pResponseHandler  != NULL);

    if(_wcsicmp(i_bstrQueryLanguage, L"WQL") != 0)
    {
        DBGPRINTF((DBG_CONTEXT, "Invalid query language: %ws\n", i_bstrQueryLanguage));
        THROW_ON_ERROR(WBEM_E_INVALID_QUERY_TYPE);
    }

    m_spResponseHandler = i_pResponseHandler;
    m_pNamespace        = i_pNamespace;

    //
    // Get the class name from the query
    //
    WCHAR                       wszClass[512];
    wszClass[0] = L'\0';
    CTextLexSource              src(i_bstrQuery);
    SQL1_Parser                 parser(&src);

    int nRes = parser.GetQueryClass(wszClass, 511);
    if(nRes)
    {
        THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
    }

    //
    // Determine if class, association, or neither
    //
    if( CUtils::GetClass(wszClass, &m_pWmiClass) )
    {
    }
    else if( CUtils::GetAssociation(wszClass,&m_pWmiAssoc) )
    {
        DBG_ASSERT(m_pWmiClass == NULL);
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS);
    }
    DBG_ASSERT((m_pWmiClass == NULL) || (m_pWmiAssoc == NULL));
    DBG_ASSERT((m_pWmiClass != NULL) || (m_pWmiAssoc != NULL));

    //
    // Parse
    //
    m_pExp = new SQL_LEVEL_1_RPN_EXPRESSION_EXT;

    nRes = parser.Parse(&(m_pExp->m_pSqlExpr));
    if(nRes)
    {
        THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
    }
}

CQueryHelper::~CQueryHelper()
{
    delete m_pExp;
    m_pExp       = NULL;
    m_pNamespace = NULL;
    m_pWmiClass  = NULL;
    m_pWmiAssoc  = NULL;
}

void CQueryHelper::GetAssociations()
{
    DBG_ASSERT(IsAssoc());

    TSmartPointer<CAssocBase> spAssocBase;

    if( m_pWmiAssoc == &WMI_ASSOCIATION_DATA::s_AdminACLToACE )
    {
        //
        // Special association
        //
        spAssocBase = new CAssocACLACE(m_pNamespace, m_spResponseHandler);
    }
    else if( m_pWmiAssoc->pType == &WMI_ASSOCIATION_TYPE_DATA::s_IPSecurity ||
        m_pWmiAssoc->pType == &WMI_ASSOCIATION_TYPE_DATA::s_AdminACL   ||
        m_pWmiAssoc->pType == &WMI_ASSOCIATION_TYPE_DATA::s_ElementSetting )
    {
        spAssocBase = new CAssocSameLevel(m_pNamespace, m_spResponseHandler, m_pWmiAssoc);
    }
    else if( m_pWmiAssoc->pType == &WMI_ASSOCIATION_TYPE_DATA::s_Component )
    {
        spAssocBase = new CAssocComponent(m_pNamespace, m_spResponseHandler, m_pWmiAssoc);
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS);
    }

    if(spAssocBase == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }

    spAssocBase->GetInstances(m_pExp);
}

void CQueryHelper::GetInstances()
{
    DBG_ASSERT(!IsAssoc());
    DBG_ASSERT(m_pWmiClass != NULL);

    if(m_pExp)
    {
        m_pExp->SetContainsOrOrNot();
    }

    //
    // Optimization: Just return the instance
    //
    const SQL_LEVEL_1_TOKEN* pToken = NULL;
    if( m_pExp                                                 && // query?
        !m_pExp->GetContainsOrOrNot()                          && // simple enough?
        (pToken = m_pExp->GetFilter(m_pWmiClass->pszKeyName))  && // filtering w/PK?
        pToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION && // expression
        pToken->nOperator  == SQL_LEVEL_1_TOKEN::OP_EQUAL )       // only can optimize ==
    {
        if(pToken)
        {
            if(m_pWmiClass != &WMI_CLASS_DATA::s_ACE)
            {
                ParsedObjectPath popInstance;

                if(!popInstance.SetClassName(m_pWmiClass->pszClassName))
                {
                    THROW_ON_ERROR(WBEM_E_FAILED);
                }
                if(!popInstance.AddKeyRef(m_pWmiClass->pszKeyName, &pToken->vConstValue))
                {
                    THROW_ON_ERROR(WBEM_E_FAILED);
                }

                CComPtr<IWbemClassObject> spInstance;
                CInstanceHelper InstanceHelper(&popInstance, m_pNamespace);
                DBG_ASSERT(!IsAssoc());
                try
                {
                    InstanceHelper.GetInstance(
                        false,
                        &CMetabase(),
                        &spInstance);
                }
                catch(...)
                {
                }
                if(spInstance != NULL)
                {
                    HRESULT hr = m_spResponseHandler->Indicate(1, &spInstance);
                    THROW_ON_ERROR(hr);
                }
            }
            else
            {
                if(pToken->vConstValue.vt != VT_BSTR)
                {
                    THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
                }

                _bstr_t bstrMbPath = WMI_CLASS_DATA::s_ACE.pszMetabaseKey;
                bstrMbPath        += L"/";
                bstrMbPath        += pToken->vConstValue.bstrVal;

                //
                // CloseSD called automatically.
                //
                CAdminACL AdminACL;
                CMetabase metabase;
                HRESULT hr = AdminACL.OpenSD(bstrMbPath, metabase);
                THROW_ON_ERROR(hr);

                hr = AdminACL.EnumerateACEsAndIndicate(
                    pToken->vConstValue.bstrVal,
                    *m_pNamespace,
                    *m_spResponseHandler);
                THROW_ON_ERROR(hr);
            }
            return;
        }
    }

    ParsedObjectPath    ParsedObject;            //deconstructer frees memory

    if (!ParsedObject.SetClassName(m_pWmiClass->pszClassName))
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }
    CEnum EnumObject;
    EnumObject.Init(
        m_spResponseHandler,
        m_pNamespace,
        &ParsedObject,
        m_pWmiClass->pszMetabaseKey,
        NULL,
        m_pExp);
    EnumObject.Recurse(
        NULL,
        &METABASE_KEYTYPE_DATA::s_NO_TYPE,
        NULL,
        m_pWmiClass->pszKeyName, 
        m_pWmiClass->pkt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\queryhelper.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    queryhelper.h

Abstract:

    Definition of:
    CQueryHelper

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _queryhelper_h_
#define _queryhelper_h_

#include <windows.h>
#include <wbemprov.h>
#include <stdio.h>
#include <atlbase.h>

#include <genlex.h>
#include "sqllex.h"
#include <sql_1ext.h>
#include <dbgutil.h>

#include "wbemservices.h"
#include "schema.h"

class CQueryHelper
{
public:
    CQueryHelper(
        BSTR              i_bstrQueryLanguage,
        BSTR              i_bstrQuery,
        CWbemServices*    i_pNamespace,
        IWbemObjectSink*  i_pResponseHandler);

    ~CQueryHelper();

    void GetAssociations();

    void GetInstances();

    bool IsAssoc() const
    {
        return (m_pWmiAssoc != NULL);
    }

private:
    WMI_CLASS*                  m_pWmiClass;
    WMI_ASSOCIATION*            m_pWmiAssoc;

    CWbemServices*              m_pNamespace;
    CComPtr<IWbemObjectSink>    m_spResponseHandler;

    SQL_LEVEL_1_RPN_EXPRESSION_EXT* m_pExp;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\schema.h ===
#ifndef _schema_h_
#define _schema_h_

#include "globalconstants.h"

//
// Forward declarations
//
struct METABASE_KEYTYPE;
struct METABASE_KEYTYPE_NODE;


//
// DataTypes
//
struct METABASE_KEYTYPE
{
    //
    // Not populated automatically for static data
    //
    LPWSTR m_pszName; 

    //
    // This is the list of keytypes that can contain this keytype
    // (the opposite of the container class list)
    //
    // Populated automatically even for static data
    //
    METABASE_KEYTYPE_NODE* m_pKtListInverseCCL;

    //
    // Not populated automatically for static data
    //
    LPCWSTR m_pszDisallowDeletionNode;
};

struct METABASE_KEYTYPE_NODE
{
    const METABASE_KEYTYPE* m_pKt;
    METABASE_KEYTYPE_NODE*  m_pKtNext;
};

struct WMI_METHOD_PARAM
{
    LPWSTR   pszParamName;
    CIMTYPE  type;
    ULONG    iInOut;
};

struct WMI_METHOD 
{
    LPWSTR   pszMethodName;
    DWORD    dwMDId;
    
    CIMTYPE            typeRetVal;
    WMI_METHOD_PARAM** ppParams;

    LPWSTR   pszDescription;
};

struct METABASE_PROPERTY
{
    LPWSTR pszPropName;
    DWORD  dwMDIdentifier;
    DWORD  dwMDUserType; 
    DWORD  dwMDDataType; 
    DWORD  dwMDMask;  // if this is set to all bits on, it means this is bool, but not part of a flag.
    DWORD  dwMDAttributes;
    BOOL   fReadOnly;

    // if DWORD_METADATA, pDefaultValue points to the above dwDefaultValue.
    // otherwise it points to memory in pool.
    LPVOID pDefaultValue;

    // used for DWORD_METADATA
    DWORD  dwDefaultValue;
}; 

struct WMI_CLASS
{
    LPWSTR               pszClassName;
    LPWSTR               pszMetabaseKey;
    LPWSTR               pszKeyName;
    METABASE_PROPERTY**  ppmbp;
    METABASE_KEYTYPE*    pkt;
    WMI_METHOD**         ppMethod;
    DWORD                dwExtended;

    // This is only set for hardcoded wmi classes.  Otherwise, the defaults
    // at the top of this file are used.
    LPWSTR               pszParentClass;

    //
    // Whether we let users create instances of this class.
    // Some examples where this is false are IIsFtpService, IIsWebService, etc.
    //
    bool                 bCreateAllowed;

    // This pointer is only valid during initialization time.
    // It points to mbschema.bin
    LPWSTR               pszDescription;
}; 

struct WMI_ASSOCIATION_TYPE
{
    LPWSTR pszLeft;
    LPWSTR pszRight;

    LPWSTR pszParent;
    LPWSTR pszExtParent;
};

struct WMI_ASSOCIATION 
{
    LPWSTR                    pszAssociationName;
    WMI_CLASS*                pcLeft;
    WMI_CLASS*                pcRight;
    WMI_ASSOCIATION_TYPE      *pType;
    DWORD                     fFlags;
    DWORD                     dwExtended;
    
    LPWSTR                    pszParentClass;
};


//
// Hardcoded Data
//
struct METABASE_KEYTYPE_DATA
{
    static METABASE_KEYTYPE s_IIsApplicationPool;
    static METABASE_KEYTYPE s_IIsApplicationPools;
    static METABASE_KEYTYPE s_IIsCertMapper;
    static METABASE_KEYTYPE s_IIsCompressionScheme;
    static METABASE_KEYTYPE s_IIsCompressionSchemes;
    static METABASE_KEYTYPE s_IIsComputer;
    static METABASE_KEYTYPE s_IIsCustomLogModule;
    static METABASE_KEYTYPE s_IIsFilter;
    static METABASE_KEYTYPE s_IIsFilters;
    static METABASE_KEYTYPE s_IIsFtpInfo;
    static METABASE_KEYTYPE s_IIsFtpServer;
    static METABASE_KEYTYPE s_IIsFtpService;
    static METABASE_KEYTYPE s_IIsFtpVirtualDir;
    static METABASE_KEYTYPE s_IIsImapInfo;
    static METABASE_KEYTYPE s_IIsImapService;
    static METABASE_KEYTYPE s_IIsLogModule;
    static METABASE_KEYTYPE s_IIsLogModules;
    static METABASE_KEYTYPE s_IIsMimeMap;
    static METABASE_KEYTYPE s_IIsNntpInfo;
    static METABASE_KEYTYPE s_IIsNntpService;
    static METABASE_KEYTYPE s_IIsObject;
    static METABASE_KEYTYPE s_IIsPop3Info;
    static METABASE_KEYTYPE s_IIsPop3Service;
    static METABASE_KEYTYPE s_IIsSmtpInfo;
    static METABASE_KEYTYPE s_IIsSmtpService;
    static METABASE_KEYTYPE s_IIsWebDirectory;
    static METABASE_KEYTYPE s_IIsWebFile;
    static METABASE_KEYTYPE s_IIsWebInfo;
    static METABASE_KEYTYPE s_IIsWebServer;
    static METABASE_KEYTYPE s_IIsWebService;
    static METABASE_KEYTYPE s_IIsWebVirtualDir;

    static METABASE_KEYTYPE s_TYPE_AdminACL;
    static METABASE_KEYTYPE s_TYPE_AdminACE;
    static METABASE_KEYTYPE s_TYPE_IPSecurity;
    static METABASE_KEYTYPE s_NO_TYPE;

    static METABASE_KEYTYPE* s_MetabaseKeyTypes[];
};

struct METABASE_PROPERTY_DATA
{
    static METABASE_PROPERTY s_KeyType;
    static METABASE_PROPERTY s_ServerComment;
    static METABASE_PROPERTY s_ServerBindings;
    static METABASE_PROPERTY s_ApplicationDependencies;
    static METABASE_PROPERTY s_WebSvcExtRestrictionList;
    static METABASE_PROPERTY s_Path;
    static METABASE_PROPERTY s_AppRoot;

    static METABASE_PROPERTY* s_MetabaseProperties[];
};

struct WMI_METHOD_PARAM_DATA
{
    static WMI_METHOD_PARAM s_Description;
    static WMI_METHOD_PARAM s_bEnable;
    static WMI_METHOD_PARAM s_bCanDelete;
    static WMI_METHOD_PARAM s_Extension; 
    static WMI_METHOD_PARAM s_Extensions;
    static WMI_METHOD_PARAM s_ExtensionFile; 
    static WMI_METHOD_PARAM s_ExtensionFiles;
    static WMI_METHOD_PARAM s_Application;
    static WMI_METHOD_PARAM s_Applications;
    static WMI_METHOD_PARAM s_AppMode;
    static WMI_METHOD_PARAM s_BackupDateTimeOut;
    static WMI_METHOD_PARAM s_BackupFlags;
    static WMI_METHOD_PARAM s_BackupLocation;
    static WMI_METHOD_PARAM s_BackupLocation_io;
    static WMI_METHOD_PARAM s_BackupVersion;
    static WMI_METHOD_PARAM s_BackupVersionOut;
    static WMI_METHOD_PARAM s_DestPath;
    static WMI_METHOD_PARAM s_GroupID;
    static WMI_METHOD_PARAM s_EnumIndex;
    static WMI_METHOD_PARAM s_FileName;
    static WMI_METHOD_PARAM s_HistoryTime;
    static WMI_METHOD_PARAM s_IEnabled;
    static WMI_METHOD_PARAM s_IEnabled_o;
    static WMI_METHOD_PARAM s_IMethod;
    static WMI_METHOD_PARAM s_IndexIn;
    static WMI_METHOD_PARAM s_InProcFlag;
    static WMI_METHOD_PARAM s_AppPoolName;
    static WMI_METHOD_PARAM s_bCreate;
    static WMI_METHOD_PARAM s_MajorVersion;
    static WMI_METHOD_PARAM s_MajorVersion_o;
    static WMI_METHOD_PARAM s_MDFlags;
    static WMI_METHOD_PARAM s_MDHistoryLocation;
    static WMI_METHOD_PARAM s_MDHistoryLocation_io;
    static WMI_METHOD_PARAM s_MinorVersion;
    static WMI_METHOD_PARAM s_MinorVersion_o;
    static WMI_METHOD_PARAM s_NtAcct;
    static WMI_METHOD_PARAM s_NtAcct_o;
    static WMI_METHOD_PARAM s_NtPwd;
    static WMI_METHOD_PARAM s_NtPwd_o;
    static WMI_METHOD_PARAM s_Password;
    static WMI_METHOD_PARAM s_Passwd;
    static WMI_METHOD_PARAM s_PathOfRootVirtualDir;
    static WMI_METHOD_PARAM s_Recursive;
    static WMI_METHOD_PARAM s_ServerComment;
    static WMI_METHOD_PARAM s_ServerBindings;
    static WMI_METHOD_PARAM s_ServerId;
    static WMI_METHOD_PARAM s_SourcePath;
    static WMI_METHOD_PARAM s_strName;
    static WMI_METHOD_PARAM s_strName_o;
    static WMI_METHOD_PARAM s_vCert;
    static WMI_METHOD_PARAM s_vCert_o;
    static WMI_METHOD_PARAM s_vKey;

    static WMI_METHOD_PARAM* s_ServiceCreateNewServer[];
    static WMI_METHOD_PARAM* s_ServiceEnableApplication[];
    static WMI_METHOD_PARAM* s_ServiceRemoveApplication[];
    static WMI_METHOD_PARAM* s_ServiceQueryGroupIDStatus[];
    static WMI_METHOD_PARAM* s_ServiceListApplications[];
    static WMI_METHOD_PARAM* s_ServiceAddDependency[];
    static WMI_METHOD_PARAM* s_ServiceRemoveDependency[];
    static WMI_METHOD_PARAM* s_ServiceEnableWebServiceExtension[];
    static WMI_METHOD_PARAM* s_ServiceDisableWebServiceExtension[];
    static WMI_METHOD_PARAM* s_ServiceListWebServiceExtensions[];
    static WMI_METHOD_PARAM* s_ServiceEnableExtensionFile[];
    static WMI_METHOD_PARAM* s_ServiceDisableExtensionFile[];
    static WMI_METHOD_PARAM* s_ServiceAddExtensionFile[];
    static WMI_METHOD_PARAM* s_ServiceDeleteExtensionFile[];
    static WMI_METHOD_PARAM* s_ServiceListExtensionFiles[];

    static WMI_METHOD_PARAM* s_AppCreate[];
    static WMI_METHOD_PARAM* s_AppCreate2[];
    static WMI_METHOD_PARAM* s_AppCreate3[];
    static WMI_METHOD_PARAM* s_AppDelete[];
    static WMI_METHOD_PARAM* s_AppUnLoad[];
    static WMI_METHOD_PARAM* s_AppDisable[];
    static WMI_METHOD_PARAM* s_AppEnable[];

    static WMI_METHOD_PARAM* s_BackupWithPasswd[];
    static WMI_METHOD_PARAM* s_DeleteBackup[];
    static WMI_METHOD_PARAM* s_EnumBackups[];
    static WMI_METHOD_PARAM* s_RestoreWithPasswd[];
    static WMI_METHOD_PARAM* s_Export[];
    static WMI_METHOD_PARAM* s_Import[];
    static WMI_METHOD_PARAM* s_RestoreHistory[];
    static WMI_METHOD_PARAM* s_EnumHistory[];

    static WMI_METHOD_PARAM* s_CreateMapping[];
    static WMI_METHOD_PARAM* s_DeleteMapping[];
    static WMI_METHOD_PARAM* s_GetMapping[];
    static WMI_METHOD_PARAM* s_SetAcct[];
    static WMI_METHOD_PARAM* s_SetEnabled[];
    static WMI_METHOD_PARAM* s_SetName[];
    static WMI_METHOD_PARAM* s_SetPwd[];

    static WMI_METHOD_PARAM* s_EnumAppsInPool[];
};

struct WMI_METHOD_DATA
{
    static WMI_METHOD s_ServiceEnableApplication;
    static WMI_METHOD s_ServiceRemoveApplication;
    static WMI_METHOD s_ServiceListApplications;
    static WMI_METHOD s_ServiceQueryGroupIDStatus;
    static WMI_METHOD s_ServiceAddDependency;
    static WMI_METHOD s_ServiceRemoveDependency;
    static WMI_METHOD s_ServiceEnableWebServiceExtension;
    static WMI_METHOD s_ServiceDisableWebServiceExtension;
    static WMI_METHOD s_ServiceListWebServiceExtensions;
    static WMI_METHOD s_ServiceEnableExtensionFile;
    static WMI_METHOD s_ServiceDisableExtensionFile;
    static WMI_METHOD s_ServiceAddExtensionFile;
    static WMI_METHOD s_ServiceDeleteExtensionFile;
    static WMI_METHOD s_ServiceListExtensionFiles;
    static WMI_METHOD s_ServiceCreateNewServer;
    static WMI_METHOD s_GetCurrentMode;

    static WMI_METHOD s_ServerStart;
    static WMI_METHOD s_ServerStop;
    static WMI_METHOD s_ServerContinue;
    static WMI_METHOD s_ServerPause;

    static WMI_METHOD s_AppCreate;
    static WMI_METHOD s_AppCreate2;
    static WMI_METHOD s_AppCreate3;
    static WMI_METHOD s_AppDelete;
    static WMI_METHOD s_AppUnLoad;
    static WMI_METHOD s_AppDisable;
    static WMI_METHOD s_AppEnable;
    static WMI_METHOD s_AppGetStatus;
    static WMI_METHOD s_AspAppRestart;

    static WMI_METHOD s_SaveData;
    static WMI_METHOD s_BackupWithPasswd;
    static WMI_METHOD s_DeleteBackup;
    static WMI_METHOD s_EnumBackups;
    static WMI_METHOD s_RestoreWithPasswd;
    static WMI_METHOD s_Export;
    static WMI_METHOD s_Import;
    static WMI_METHOD s_RestoreHistory;
    static WMI_METHOD s_EnumHistory;

    static WMI_METHOD s_CreateMapping;
    static WMI_METHOD s_DeleteMapping;
    static WMI_METHOD s_GetMapping;
    static WMI_METHOD s_SetAcct;
    static WMI_METHOD s_SetEnabled;
    static WMI_METHOD s_SetName;
    static WMI_METHOD s_SetPwd;

    static WMI_METHOD s_EnumAppsInPool;
    static WMI_METHOD s_RecycleAppPool;
    static WMI_METHOD s_Start;
    static WMI_METHOD s_Stop;

    static WMI_METHOD* s_WebServiceMethods[];
    static WMI_METHOD* s_ServiceMethods[];
    static WMI_METHOD* s_ServerMethods[];
    static WMI_METHOD* s_WebAppMethods[];
    static WMI_METHOD* s_ComputerMethods[];
    static WMI_METHOD* s_CertMapperMethods[];
    static WMI_METHOD* s_AppPoolMethods[];
};

struct WMI_CLASS_DATA
{
    static WMI_CLASS s_Computer;
    static WMI_CLASS s_ComputerSetting;
    static WMI_CLASS s_FtpService;
    static WMI_CLASS s_FtpServer;
    static WMI_CLASS s_FtpVirtualDir;
    static WMI_CLASS s_WebService;
    static WMI_CLASS s_WebFilter;
    static WMI_CLASS s_WebServer;
    static WMI_CLASS s_WebCertMapper;
    static WMI_CLASS s_WebVirtualDir;
    static WMI_CLASS s_WebDirectory;
    static WMI_CLASS s_WebFile;
    static WMI_CLASS s_ApplicationPool;

    static WMI_CLASS s_AdminACL;
    static WMI_CLASS s_ACE;
    static WMI_CLASS s_IPSecurity;

    static WMI_CLASS* s_WmiClasses[];
};

struct WMI_ASSOCIATION_TYPE_DATA
{
    static WMI_ASSOCIATION_TYPE s_ElementSetting;
    static WMI_ASSOCIATION_TYPE s_Component;
    static WMI_ASSOCIATION_TYPE s_AdminACL;
    static WMI_ASSOCIATION_TYPE s_IPSecurity;
};

struct WMI_ASSOCIATION_DATA
{
    static WMI_ASSOCIATION s_AdminACLToACE;
    static WMI_ASSOCIATION* s_WmiAssociations[];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\pusher.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pusher.h

Abstract:

    This file contains the definition of the CPusher class.
    This class contains the logic for pushing schema to the repository.

Author:

    Mohit Srivastava            28-Nov-00

Revision History:

--*/

#ifndef _pusher_h_
#define _pusher_h_

#include "schemaextensions.h"

//
// Property Names
//
static LPCWSTR g_wszProp_Class         = L"__CLASS";
static LPCWSTR g_wszProp_Name          = L"Name";

//
// Property Qualifier Names
//
static LPCWSTR g_wszPq_Key             = L"Key";
static LPCWSTR g_wszPq_CimType         = L"CIMTYPE";
static LPCWSTR g_wszPq_Read            = L"Read";
static LPCWSTR g_wszPq_Write           = L"Write";

//
// Class Qualifier Names
//
static LPCWSTR   g_wszCq_Provider      = L"provider";
static LPCWSTR   g_wszCq_Dynamic       = L"dynamic";
static LPCWSTR   g_wszCq_Extended      = L"extended";
static LPCWSTR   g_wszCq_SchemaTS      = L"MbSchemaTimeStamp";

//
// Method Qualifier Names
//
static LPCWSTR   g_wszMq_Implemented   = L"Implemented";
static LPCWSTR   g_wszMq_Bypass_Getobject = L"bypass_getobject";
                                       
//
// Class Qualifier Values
//
static LPCWSTR   g_wszCqv_Provider     = L"IIS__PROVIDER";

class CPusher
{
public:
    CPusher() : m_pNamespace(NULL), 
        m_pCtx(NULL),
        m_bInitCalled(false),
        m_bInitSuccessful(false)
    {
    }

    virtual ~CPusher();

    HRESULT Initialize(
        CWbemServices* i_pNamespace,
        IWbemContext*  i_pCtx);

    HRESULT Push(
        const CSchemaExtensions*      i_pCatalog,
        CHashTable<WMI_CLASS *>*      i_phashClasses,
        CHashTable<WMI_ASSOCIATION*>* i_phashAssocs);

private:
    //
    // These are called by Push.
    //
    HRESULT RepositoryInSync(
        const CSchemaExtensions* i_pCatalog,
        bool*                    io_pbInSync);

    HRESULT PushClasses(
        CHashTable<WMI_CLASS *>* i_phashTable);

    HRESULT PushAssocs(
        CHashTable<WMI_ASSOCIATION *>* i_phashTable);

    HRESULT SetTimeStamp(
        const CSchemaExtensions* i_pCatalog);

    //
    // Called by PushClasses and PushAssocs
    //
    HRESULT DeleteChildren(
        LPCWSTR i_wszExtSuperClass);

    bool NeedToDeleteAssoc(
        IWbemClassObject* i_pObj) const;

    HRESULT GetObject(
        LPCWSTR            i_wszClass, 
        IWbemClassObject** o_ppObj);

    HRESULT SetClassInfo(
        IWbemClassObject* i_pObj,
        LPCWSTR           i_wszClassName,
        ULONG             i_iShipped);

    //
    // Called by PushClasses
    //
    HRESULT PrepareForPutClass(
        const WMI_CLASS* i_pElement,
        bool*            io_pbPutNeeded);

    HRESULT SetProperties(
        const WMI_CLASS*  i_pElement, 
        IWbemClassObject* i_pObject) const;

    HRESULT SetMethods(
        const WMI_CLASS*  i_pElement,
        IWbemClassObject* i_pObject) const;

    //
    // Called by PushAssocs
    //
    HRESULT SetAssociationComponent(
        IWbemClassObject* i_pObject, 
        LPCWSTR           i_wszComp, 
        LPCWSTR           i_wszClass) const;


    CWbemServices* m_pNamespace;
    IWbemContext*  m_pCtx;

    //
    // These are base classes that are opened in "Initialize" to
    // prevent repeated WMI calls to m_pNamespace->GetObject().
    //
    CComPtr<IWbemClassObject> m_spBaseElementObject;
    CComPtr<IWbemClassObject> m_spBaseSettingObject;
    CComPtr<IWbemClassObject> m_spBaseElementSettingObject;
    CComPtr<IWbemClassObject> m_spBaseGroupPartObject;

    //
    // Class qualifier name/value pairs
    // Used in PushClasses and PushAssocs
    //
    LPCWSTR     m_awszClassQualNames[2];
    CComVariant m_avtClassQualValues[2];

    bool m_bInitCalled;
    bool m_bInitSuccessful;
};

#endif // _pusher_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\pusher.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pusher.cpp

Abstract:

    This file contains the implementation of the CPusher class.
    This class contains the logic for pushing schema to the repository.

Author:

    Mohit Srivastava            28-Nov-00

Revision History:

--*/

#include "iisprov.h"
#include "pusher.h"
#include "MultiSzData.h"
#include "schema.h"

extern CDynSchema* g_pDynSch; // Initialized to NULL in schemadynamic.cpp

HRESULT CPusher::RepositoryInSync(
    const CSchemaExtensions* i_pCatalog,
    bool*                    io_pbInSync)
{
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(io_pbInSync       != NULL);
    DBG_ASSERT(i_pCatalog        != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    CComBSTR                  sbstrTemp;
    CComVariant               svtTimeStamp;
    CComPtr<IWbemClassObject> spObjIIsComputer;

    sbstrTemp = WMI_CLASS_DATA::s_Computer.pszClassName;
    if(sbstrTemp.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    hr = m_pNamespace->GetObject(sbstrTemp, 0, m_pCtx, &spObjIIsComputer, NULL);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Try to get timestamp from repository
    //
    hr = CUtils::GetQualifiers(spObjIIsComputer, &g_wszCq_SchemaTS, &svtTimeStamp, 1);
    if(FAILED(hr) || svtTimeStamp.vt != VT_BSTR)
    {
        *io_pbInSync = false;
        return WBEM_S_NO_ERROR;
    }

    //
    // Get timestamp of mbschema.xml
    //
    FILETIME FileTime;
    hr = i_pCatalog->GetMbSchemaTimeStamp(&FileTime);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Finally, compare the timestamps
    //
    WCHAR wszFileTime[30];
    CUtils::FileTimeToWchar(&FileTime, wszFileTime);
    if(_wcsicmp(wszFileTime, svtTimeStamp.bstrVal) == 0)
    {
        *io_pbInSync = true;
    }
    else
    {
        *io_pbInSync = false;
    }
    return hr;
}

HRESULT CPusher::SetTimeStamp(
    const CSchemaExtensions* i_pCatalog)
{
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pCatalog        != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    CComBSTR                  sbstrTemp;
    CComVariant               svtTimeStamp;
    CComPtr<IWbemClassObject> spObjIIsComputer;

    sbstrTemp = WMI_CLASS_DATA::s_Computer.pszClassName;
    if(sbstrTemp.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    hr = m_pNamespace->GetObject(sbstrTemp, 0, m_pCtx, &spObjIIsComputer, NULL);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Get timestamp of mbschema.xml
    //
    FILETIME FileTime;
    hr = i_pCatalog->GetMbSchemaTimeStamp(&FileTime);
    if(FAILED(hr))
    {
        return hr;
    }
    WCHAR wszFileTime[30];
    CUtils::FileTimeToWchar(&FileTime, wszFileTime);

    //
    // Finally, Set the timestamp in the repository
    //
    svtTimeStamp = wszFileTime;
    if(svtTimeStamp.vt != VT_BSTR || svtTimeStamp.bstrVal == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    hr = CUtils::SetQualifiers(
        spObjIIsComputer,
        &g_wszCq_SchemaTS,
        &svtTimeStamp,
        1,
        0);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Finally, put the class
    //
    hr = m_pNamespace->PutClass(spObjIIsComputer, WBEM_FLAG_OWNER_UPDATE, m_pCtx, NULL);
    if(FAILED(hr))
    {
        return hr;
    }

    return hr;
}

HRESULT CPusher::Initialize(CWbemServices* i_pNamespace,
                            IWbemContext*  i_pCtx)
/*++

Synopsis: 
    Only call once.

Arguments: [i_pNamespace] - 
           [i_pCtx] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pNamespace      != NULL);
    DBG_ASSERT(i_pCtx            != NULL);
    DBG_ASSERT(m_bInitCalled     == false);
    DBG_ASSERT(m_bInitSuccessful == false);

    HRESULT  hr = WBEM_S_NO_ERROR;
    CComBSTR bstrTemp;

    m_bInitCalled           = true;
    m_pCtx                  = i_pCtx;
    m_pNamespace            = i_pNamespace;
    m_awszClassQualNames[1] = g_wszCq_Dynamic;
    m_avtClassQualValues[1] = (bool)true;
    m_awszClassQualNames[0] = g_wszCq_Provider;
    m_avtClassQualValues[0] = g_wszCqv_Provider;;
    if(m_avtClassQualValues[0].bstrVal == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }

    //
    // Get pointers to most commonly used base classes
    //
    bstrTemp = g_wszExtElementParent;
    if(bstrTemp.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }
    hr = m_pNamespace->GetObject(bstrTemp, 0, m_pCtx, &m_spBaseElementObject, NULL);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }

    bstrTemp = g_wszExtSettingParent;
    if(bstrTemp.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }
    hr = m_pNamespace->GetObject(bstrTemp, 0, m_pCtx, &m_spBaseSettingObject, NULL);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }

    bstrTemp = g_wszExtElementSettingAssocParent;
    if(bstrTemp.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }
    hr = m_pNamespace->GetObject(bstrTemp, 0, m_pCtx, &m_spBaseElementSettingObject, NULL);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }

    bstrTemp = g_wszExtGroupPartAssocParent;
    if(bstrTemp.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }
    hr = m_pNamespace->GetObject(bstrTemp, 0, m_pCtx, &m_spBaseGroupPartObject, NULL);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }

exit:
    if(SUCCEEDED(hr))
    {
        m_bInitSuccessful = true;
    }
    return hr;
}

CPusher::~CPusher()
{
}

HRESULT CPusher::Push(
    const CSchemaExtensions*      i_pCatalog,
    CHashTable<WMI_CLASS *>*      i_phashClasses,
    CHashTable<WMI_ASSOCIATION*>* i_phashAssocs)
{
    DBG_ASSERT(i_pCatalog        != NULL);
    DBG_ASSERT(i_phashClasses    != NULL);
    DBG_ASSERT(i_phashAssocs     != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT hr = WBEM_S_NO_ERROR;

    bool bInSync= false;

    hr = RepositoryInSync(i_pCatalog, &bInSync);
    if(FAILED(hr))
    {
        return hr;
    }

    if(!bInSync)
    {
        hr = PushClasses(i_phashClasses);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::Push failed, hr=0x%x\n", hr));
            return hr;
        }
        hr = PushAssocs(i_phashAssocs);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::Push failed, hr=0x%x\n", hr));
            return hr;
        }
        hr = SetTimeStamp(i_pCatalog);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::Push failed, hr=0x%x\n", hr));
            return hr;
        }
    }

    return hr;
}

HRESULT CPusher::PushClasses(
    CHashTable<WMI_CLASS *>* i_phashTable)
/*++

Synopsis: 
    Public function to push classes to repository.
    1) Precondition: All USER_DEFINED_TO_REPOSITORY classes are not in repository.
    2) Pushes all USER_DEFINED_TO_REPOSITORY classes to repository.
    3) Deletes and recreates SHIPPED_TO_MOF, SHIPPED_NOT_TO_MOF, and
       EXTENDED classes if necessary.

Arguments: [i_phashTable] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_phashTable      != NULL);
    DBG_ASSERT(m_pNamespace      != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT hr = WBEM_S_NO_ERROR;
    CComPtr<IWbemClassObject>  spObject = NULL;
    CComPtr<IWbemClassObject>  spChildObject = NULL;

    //
    // Vars needed for iteration
    //
    CHashTable<WMI_CLASS*>::Record*  pRec = NULL;
    CHashTable<WMI_CLASS*>::iterator iter;
    CHashTable<WMI_CLASS*>::iterator iterEnd;

    CComVariant v;    

    //
    // DeleteChildren of extended base classes
    //
    LPWSTR awszBaseClasses[] = { 
        g_wszExtElementParent, 
        g_wszExtSettingParent,
        NULL };

    for(ULONG idx = 0; awszBaseClasses[idx] != NULL; idx++)
    {
        hr = DeleteChildren(awszBaseClasses[idx]);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
            goto exit;
        }
    }

    //
    // Walk thru the hashtable of classes
    //
    bool  bPutNeeded;
    iterEnd = i_phashTable->end();
    for(iter = i_phashTable->begin(); iter != iterEnd; ++iter)
    {
        pRec = iter.Record();
        DBG_ASSERT(pRec != NULL);

        //
        // Deletes SHIPPED_TO_MOF, SHIPPED_NOT_TO_MOF, EXTENDED classes if necessary.
        //
        hr = PrepareForPutClass(pRec->m_data, &bPutNeeded);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
            goto exit;
        }

        if(bPutNeeded)
        {
            hr = GetObject(pRec->m_data->pszParentClass, &spObject);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                goto exit;
            }

            hr = spObject->SpawnDerivedClass(0, &spChildObject);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                goto exit;
            }
            spObject = NULL;

            //
            // Push class qualifiers and special __CLASS property.
            //
            hr = SetClassInfo(
                spChildObject, 
                pRec->m_wszKey,
                pRec->m_data->dwExtended);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                goto exit;
            }

            //
            // Name property and corresponding qualifier
            // Base class may contain Name.  Handle this case
            //
            bool bPutNameProperty = true;
            for(ULONG j = 0; g_awszParentClassWithNamePK[j] != NULL; j++)
            {
                //
                // Deliberate ==
                //
                if(g_awszParentClassWithNamePK[j] == pRec->m_data->pszParentClass)
                {
                    bPutNameProperty = false;
                }
            }
            if( bPutNameProperty )
            {
                hr = spChildObject->Put(g_wszProp_Name, 0, NULL, CIM_STRING);
                if(FAILED(hr))
                {
                    DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                    goto exit;
                }
                v = (bool)true;
                hr = CUtils::SetPropertyQualifiers(
                    spChildObject, 
                    g_wszProp_Name, // Property name
                    &g_wszPq_Key,   // Array of qual names
                    &v,             // Array of qual values
                    1               // Nr of quals
                    );
                if(FAILED(hr))
                {
                    DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                    goto exit;
                }
            }

            //
            // All other properties
            //
            hr = SetProperties(pRec->m_data, spChildObject);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                goto exit;
            }

            //
            // Any methods
            //
            hr = SetMethods(pRec->m_data, spChildObject);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                goto exit;
            }

            //
            // Finally, put the class
            //
            hr = m_pNamespace->PutClass(spChildObject, WBEM_FLAG_OWNER_UPDATE, m_pCtx, NULL);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                goto exit;
            }

            spChildObject = NULL;
        }
    }

exit:
    return hr;
}

HRESULT CPusher::PushAssocs(
    CHashTable<WMI_ASSOCIATION*>* i_phashTable)
/*++

Synopsis: 
    Public function to push assocs to repository.
    - Precondition: All USER_DEFINED_TO_REPOSITORY assocs are not in repository.
    - Pushes all USER_DEFINED_TO_REPOSITORY assocs to repository.

Arguments: [i_phashTable] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_phashTable      != NULL);
    DBG_ASSERT(m_pNamespace      != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT hr = WBEM_S_NO_ERROR;
    CComPtr<IWbemClassObject>  spObject = NULL;
    CComPtr<IWbemClassObject>  spChildObject = NULL;

    //
    // Vars needed for iteration
    //
    CHashTable<WMI_ASSOCIATION*>::Record*  pRec = NULL;
    CHashTable<WMI_ASSOCIATION*>::iterator iter;
    CHashTable<WMI_ASSOCIATION*>::iterator iterEnd;

    //
    // DeleteChildren of extended base classes
    //
    LPWSTR awszBaseClasses[] = { 
        g_wszExtElementSettingAssocParent, 
        g_wszExtGroupPartAssocParent,
        NULL };

    for(ULONG idx = 0; awszBaseClasses[idx] != NULL; idx++)
    {
        hr = DeleteChildren(awszBaseClasses[idx]);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
            goto exit;
        }
    }

    //
    // Walk thru the hashtable of assocs
    //
    for(iter = i_phashTable->begin(), iterEnd = i_phashTable->end();
        iter != iterEnd; 
        ++iter)
    {
        pRec = iter.Record();
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
            goto exit;
        }

        if(pRec->m_data->dwExtended == USER_DEFINED_TO_REPOSITORY)
        {
            hr = GetObject(pRec->m_data->pszParentClass, &spObject);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
                goto exit;
            }

            hr = spObject->SpawnDerivedClass(0, &spChildObject);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
                goto exit;
            }
            spObject = NULL;

            //
            // Push class qualifiers and special __CLASS property.
            //
            hr = SetClassInfo(
                spChildObject, 
                pRec->m_wszKey,
                pRec->m_data->dwExtended);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
                goto exit;
            }

            //
            // Push the two ref properties of the association.
            //
            hr = SetAssociationComponent(
                spChildObject,
                pRec->m_data->pType->pszLeft,
                pRec->m_data->pcLeft->pszClassName);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
                goto exit;
            }
            hr = SetAssociationComponent(
                spChildObject,
                pRec->m_data->pType->pszRight,
                pRec->m_data->pcRight->pszClassName);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
                goto exit;
            }

            hr = m_pNamespace->PutClass(
                spChildObject, 
                WBEM_FLAG_OWNER_UPDATE | WBEM_FLAG_CREATE_ONLY, 
                m_pCtx, 
                NULL);
            if(FAILED(hr))
            {
                if(hr == WBEM_E_ALREADY_EXISTS)
                {
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
                    goto exit;
                }
            }

            spChildObject = NULL;
        }
    }

exit:
    return hr;
}

HRESULT CPusher::PrepareForPutClass(
    const WMI_CLASS* i_pClass,
    bool*            io_pbPutNeeded)
/*++

Synopsis: 
    Deletes and recreates SHIPPED_TO_MOF, SHIPPED_NOT_TO_MOF, and
    EXTENDED classes if necessary.  Sets io_pbPutNeeded accordingly.

Arguments: [i_pClass] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pClass          != NULL);
    DBG_ASSERT(io_pbPutNeeded    != NULL);

    HRESULT  hr               = WBEM_S_NO_ERROR;
    CComPtr<IWbemClassObject> spObj;
    CComBSTR bstrClass        = i_pClass->pszClassName;
    if(bstrClass.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    bool bExtendedQual        = false;
    bool bPutNeeded           = false;

    HRESULT hrGetObject = m_pNamespace->GetObject(
        bstrClass, 
        WBEM_FLAG_RETURN_WBEM_COMPLETE, 
        m_pCtx, 
        &spObj, 
        NULL);
    if( hrGetObject != WBEM_E_INVALID_CLASS && 
        hrGetObject != WBEM_E_NOT_FOUND)
    {
        hr = hrGetObject;
    }
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Determine if the [extended] qualifier is set.
    //
    if(SUCCEEDED(hrGetObject))
    {
        VARIANT  vtExtended;
        VariantInit(&vtExtended);

        HRESULT hrGetQuals = 
            CUtils::GetQualifiers(spObj, &g_wszCq_Extended, &vtExtended, 1);
        if(FAILED(hrGetQuals))
        {
            bExtendedQual = false;
        }
        else if(vtExtended.vt == VT_BOOL)
        {
            bExtendedQual = vtExtended.boolVal ? true : false;
        }
    }

    //
    // Pretty much, don't do a Put class if both the catalog and repository
    // versions are shipped.  This is an optimization for the normal case.
    //
    switch(i_pClass->dwExtended)
    {
    case EXTENDED:
        if( hrGetObject != WBEM_E_INVALID_CLASS && 
            hrGetObject != WBEM_E_NOT_FOUND)
        {
            hr = m_pNamespace->DeleteClass(
                bstrClass,
                WBEM_FLAG_OWNER_UPDATE,
                m_pCtx,
                NULL);
            if(FAILED(hr))
            {
                return hr;
            }
        }
        bPutNeeded = true;
        break;
    case USER_DEFINED_NOT_TO_REPOSITORY:
        bPutNeeded = false;
        break;
    case USER_DEFINED_TO_REPOSITORY:
        if( hrGetObject != WBEM_E_INVALID_CLASS && 
            hrGetObject != WBEM_E_NOT_FOUND)
        {
            //
            // There is already a class in the repository with the same name
            // as this user-defined class.
            // TODO: Log an error.
            //
            bPutNeeded = false;
        }
        else
        {
            bPutNeeded = true;
        }
        break;
    case SHIPPED_TO_MOF:
    case SHIPPED_NOT_TO_MOF:
        if(bExtendedQual)
        {
            if( hrGetObject != WBEM_E_INVALID_CLASS && 
                hrGetObject != WBEM_E_NOT_FOUND)
            {
                hr = m_pNamespace->DeleteClass(
                    bstrClass,
                    WBEM_FLAG_OWNER_UPDATE,
                    m_pCtx,
                    NULL);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            bPutNeeded = true;
        }
        else
        {
            bPutNeeded = (hrGetObject == WBEM_E_INVALID_CLASS || 
                          hrGetObject == WBEM_E_NOT_FOUND) ? true : false;
        }
        break;
    default:
        DBG_ASSERT(false && "Unknown i_pClass->dwExtended");
        break;
    }

    *io_pbPutNeeded = bPutNeeded;

    return hr;
}

HRESULT CPusher::SetClassInfo(
    IWbemClassObject* i_pObj,
    LPCWSTR           i_wszClassName,
    ULONG             i_iShipped)
/*++

Synopsis: 
    Sets class qualifiers and special __CLASS property on i_pObj

Arguments: [i_pObj]         - The class or association
           [i_wszClassName] - Will be value of __CLASS property
           [i_iShipped]     - Determines if we set g_wszCq_Extended qualifier
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pObj            != NULL);
    DBG_ASSERT(i_wszClassName    != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);
    HRESULT     hr;
    CComVariant v;

    //
    // Class qualifiers (propagated to instance)
    //
    hr = CUtils::SetQualifiers(
        i_pObj, 
        m_awszClassQualNames, 
        m_avtClassQualValues, 
        2,
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Another class qualifier (not propagated to instance)
    //
    if(i_iShipped == EXTENDED)
    {
        v = (bool)true;
        hr = CUtils::SetQualifiers(
            i_pObj, 
            &g_wszCq_Extended, 
            &v, 
            1, 
            0);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // Special __CLASS property
    //
    v = i_wszClassName;
    if(v.bstrVal == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }
    hr = i_pObj->Put(g_wszProp_Class, 0, &v, 0);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    return hr;
}

HRESULT CPusher::SetMethods(
    const WMI_CLASS*  i_pElement,
    IWbemClassObject* i_pObject) const
/*++

Synopsis: 
    Called by PushClasses.
    Sets the methods in i_pObject using i_pElement

Arguments: [i_pElement] -
           [i_pObject] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pElement        != NULL);
    DBG_ASSERT(i_pObject         != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT hr = WBEM_S_NO_ERROR;

    if(i_pElement->ppMethod == NULL)
    {
        return WBEM_S_NO_ERROR;
    }

    CComPtr<IWbemClassObject> spParamsIn;
    CComPtr<IWbemClassObject> spParamsOut;

    //
    // Run thru all the methods
    //
    WMI_METHOD* pMethCurrent = NULL;
    for(ULONG i = 0; i_pElement->ppMethod[i] != NULL; i++)
    {
        pMethCurrent = i_pElement->ppMethod[i];
        spParamsIn   = NULL;
        spParamsOut  = NULL;

        if(pMethCurrent->ppParams != NULL)
        {
            WMI_METHOD_PARAM* pParamCur = NULL;

            //
            // The index to indicate to WMI the order of the parameters
            // wszId is the qualifier name.  svtId is a variant so we can give to WMI.
            //
            static LPCWSTR    wszId     = L"ID";
            static LPCWSTR    wszOpt    = L"OPTIONAL";
            CComVariant       svtId     = (int)0;
            CComVariant       svtOpt    = (bool)true;

            //
            // Run thru all the parameters
            //
            for(ULONG j = 0; pMethCurrent->ppParams[j] != NULL; j++)
            {
                //
                // This will just hold spParamsIn and spParamsOut so we
                // don't need to duplicate the code.
                //
                IWbemClassObject* apParamInOut[] = { NULL, NULL };

                //
                // Create the WMI instance for the in and/or out params as needed.
                //
                pParamCur = pMethCurrent->ppParams[j];
                if( pParamCur->iInOut == PARAM_IN ||
                    pParamCur->iInOut == PARAM_INOUT )
                {
                    if(spParamsIn == NULL)
                    {
                        hr = m_pNamespace->GetObject(L"__Parameters", 0, m_pCtx, &spParamsIn, NULL);
                        if(FAILED(hr))
                        {
                            DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
                            goto exit;
                        }
                    }
                    apParamInOut[0] = spParamsIn;
                }
                if( pParamCur->iInOut == PARAM_OUT ||
                    pParamCur->iInOut == PARAM_INOUT )
                {
                    if(spParamsOut == NULL)
                    {
                        hr = m_pNamespace->GetObject(L"__Parameters", 0, m_pCtx, &spParamsOut, NULL);
                        if(FAILED(hr))
                        {
                            DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
                            goto exit;
                        }
                    }
                    apParamInOut[1] = spParamsOut;
                }

                //
                // Finally set them.  First ins then outs.
                //
                for(ULONG k = 0; k < 2; k++)
                {
                    if(apParamInOut[k] == NULL)
                    {
                        continue;
                    }
                    hr = apParamInOut[k]->Put(
                        pParamCur->pszParamName, 0, NULL, pParamCur->type);
                    if(FAILED(hr))
                    {
                        DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
                        goto exit;
                    }

                    hr = CUtils::SetPropertyQualifiers(
                        apParamInOut[k], pParamCur->pszParamName, &wszId, &svtId, 1);
                    if(FAILED(hr))
                    {
                        DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
                        goto exit;
                    }
                }

                // set Optional qualifier on CreateNewSite param ServerId
                if (pMethCurrent == &(WMI_METHOD_DATA::s_ServiceCreateNewServer) &&
                    pParamCur == &(WMI_METHOD_PARAM_DATA::s_ServerId)) {

                    DBG_ASSERT(apParamInOut[0] != NULL);

                    hr = CUtils::SetPropertyQualifiers(
                        apParamInOut[0], pParamCur->pszParamName, &wszOpt, &svtOpt, 1);

                    if(FAILED(hr))
                    {
                        DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
                        goto exit;
                    }
                }

                if(apParamInOut[0] || apParamInOut[1])
                {
                    svtId.lVal++;
                }
            }
        }

        //
        // Special: Return Value
        //
        if(pMethCurrent->typeRetVal)
        {
            if(spParamsOut == NULL)
            {
                hr = m_pNamespace->GetObject(L"__Parameters", 0, m_pCtx, &spParamsOut, NULL);
                if(FAILED(hr))
                {
                    DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
                    goto exit;
                }
            }
            hr = spParamsOut->Put(
                L"ReturnValue", 0, NULL, pMethCurrent->typeRetVal);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "%s failed, hr=0x%x\n", __FUNCTION__, hr));
                goto exit;
            }
        }

        //
        // Put the method.
        //
        hr = i_pObject->PutMethod(
            pMethCurrent->pszMethodName, 0, spParamsIn, spParamsOut);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
            goto exit;
        }

        // Set the qualifiers on the method
        LPCWSTR aQuals[2] = { g_wszMq_Implemented, g_wszMq_Bypass_Getobject };

        VARIANT vTrue;
        vTrue.boolVal = VARIANT_TRUE;
        vTrue.vt      = VT_BOOL;
        
        VARIANT aVariants[2];
        aVariants[0] = vTrue;
        aVariants[1] = vTrue;

        hr = CUtils::SetMethodQualifiers(
            i_pObject,
            pMethCurrent->pszMethodName,
            aQuals,
            aVariants,
            2);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
            goto exit;
        }

        /*if(pMethCurrent->pszDescription)
        {
            VARIANT vDesc;
            vDesc.bstrVal = pMethCurrent->pszDescription;
            vDesc.vt      = VT_BSTR;
            hr = CUtils::SetMethodQualifiers(
                i_pObject, 
                pMethCurrent->pszMethodName, 
                &g_wszMq_Description,
                &vDesc, 
                1);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
                goto exit;
            }
        }*/
    }

exit:
    return hr;
}

HRESULT CPusher::SetProperties(
    const WMI_CLASS*  i_pElement, 
    IWbemClassObject* i_pObject) const
/*++

Synopsis: 
    Called by PushClasses.
    Sets the properties in i_pObject using i_pElement

Arguments: [i_pElement] -
           [i_pObject] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pElement        != NULL);
    DBG_ASSERT(i_pObject         != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT            hr                = WBEM_S_NO_ERROR;
    METABASE_PROPERTY* pPropCurrent      = NULL;
    TFormattedMultiSz* pFormattedMultiSz = NULL;
    CIMTYPE typeProp;

    CComPtr<IWbemQualifierSet> spQualSet;
    VARIANT v;
    VariantInit(&v);

    if(i_pElement->ppmbp == NULL)
    {
        return hr;
    }

    for(ULONG i = 0; i_pElement->ppmbp[i] != NULL; i++)
    {
        pPropCurrent      = i_pElement->ppmbp[i];
        pFormattedMultiSz = NULL;
        switch(pPropCurrent->dwMDDataType)
        {
        case DWORD_METADATA:
            if(pPropCurrent->dwMDMask != 0)
            {
                typeProp = CIM_BOOLEAN;
            }
            else
            {
                typeProp = CIM_SINT32;
            }
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            typeProp = CIM_STRING;
            break;
        case MULTISZ_METADATA:
            typeProp = VT_ARRAY | CIM_STRING;
            
            pFormattedMultiSz = 
                TFormattedMultiSzData::Find(pPropCurrent->dwMDIdentifier);
            if(pFormattedMultiSz)
            {
                typeProp = VT_ARRAY | CIM_OBJECT;
            }
            break;
        case BINARY_METADATA:
            typeProp = VT_ARRAY | CIM_UINT8;
            break;
        default:
            //
            // Non fatal if we cannot recognize type
            //
            continue;
        }

        hr = i_pObject->Put(pPropCurrent->pszPropName, 0, NULL, typeProp);
        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // qualifiers
        //
        hr = i_pObject->GetPropertyQualifierSet(pPropCurrent->pszPropName, &spQualSet);
        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // qualifier for read-only
        //
        V_VT(&v)   = VT_BOOL;
        V_BOOL(&v) = (pPropCurrent->fReadOnly) ? VARIANT_FALSE : VARIANT_TRUE;
        hr = spQualSet->Put(g_wszPq_Write, &v, 0);
        if(FAILED(hr))
        {
            goto exit;
        }
        V_BOOL(&v) = VARIANT_TRUE;
        hr = spQualSet->Put(g_wszPq_Read, &v, 0);
        if(FAILED(hr))
        {
            goto exit;
        }
        VariantClear(&v);

        //
        // CIMType qualifier
        //
        if(pFormattedMultiSz)
        {
            DBG_ASSERT(typeProp == (VT_ARRAY | CIM_OBJECT));

            CComBSTR sbstrValue = L"object:";
            if(sbstrValue.m_str == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto exit;
            }
            sbstrValue += pFormattedMultiSz->wszWmiClassName;
            if(sbstrValue.m_str == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto exit;
            }

            //
            // Deliberately not smart variant.  We will let sbstrValue do deconstruction.
            //
            VARIANT vValue;
            vValue.vt      = VT_BSTR;
            vValue.bstrVal = sbstrValue;
            hr = spQualSet->Put(g_wszPq_CimType, &vValue, 0);
            if(FAILED(hr))
            {
                goto exit;
            }
        }

        spQualSet = NULL;
    }

exit:
    VariantClear(&v);
    return hr;
}

HRESULT CPusher::SetAssociationComponent(
    IWbemClassObject* i_pObject, 
    LPCWSTR           i_wszComp, 
    LPCWSTR           i_wszClass) const
/*++

Synopsis: 
    Called by PushAssocs
    Sets a ref property of an association, i_pObj, using i_wszComp and i_wszClass

Arguments: [i_pObject] - the association
           [i_wszComp] - property name (Eg. Group, Part)
           [i_wszClass] - the class we are "ref"fing to.
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pObject         != NULL);
    DBG_ASSERT(i_wszComp         != NULL);
    DBG_ASSERT(i_wszClass        != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT                    hr = WBEM_S_NO_ERROR;
    CComPtr<IWbemQualifierSet> spQualSet;
    VARIANT                    v;
    VariantInit(&v);

    //
    // Store "Ref:[class name]" in a bstr.
    //
    ULONG                      cchClass = wcslen(i_wszClass);
    CComBSTR                   sbstrClass(4 + cchClass);
    if(sbstrClass.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }
    memcpy(sbstrClass.m_str    , L"Ref:",    sizeof(WCHAR)*4);
    memcpy(sbstrClass.m_str + 4, i_wszClass, sizeof(WCHAR)*(cchClass+1));

    //
    // Put the property (Eg. Group, Part, etc.)
    //
    hr = i_pObject->Put(i_wszComp, 0, NULL, CIM_REFERENCE);
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Set Qualifiers on the property
    //
    hr = i_pObject->GetPropertyQualifierSet(i_wszComp, &spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }

    V_VT(&v) = VT_BOOL;
    V_BOOL(&v) = VARIANT_TRUE;
    hr = spQualSet->Put(g_wszPq_Key, &v, 0);
    if(FAILED(hr))
    {
        goto exit;
    }

    V_VT(&v)   = VT_BSTR;
    V_BSTR(&v) = sbstrClass.m_str;
    if(V_BSTR(&v) == NULL)
    {
        V_VT(&v) = VT_EMPTY;
        hr       = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }
    hr = spQualSet->Put(g_wszPq_CimType, &v, 0);
    V_VT(&v)   = VT_EMPTY;
    V_BSTR(&v) = NULL;
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    return hr;
}

bool CPusher::NeedToDeleteAssoc(
    IWbemClassObject*  i_pObj) const
/*++

Synopsis: 
    Sees if the association i_pObj is already in hashtable.
    If it is, no point in deleting i_pObj from repository only to recreate
    it later.

Arguments: [i_pObj] -   An IWbemClassObject representation of an assoc
           
Return Value: 
    true  if i_pObj not in hashtable
    false otherwise

--*/
{
    DBG_ASSERT(i_pObj            != NULL);
    DBG_ASSERT(g_pDynSch         != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT     hr     = WBEM_S_NO_ERROR;
    bool        bMatch = false;
    
    CComVariant vt;
    LPWSTR      wsz;

    CComPtr<IWbemQualifierSet>     spQualSet;

    CHashTable<WMI_ASSOCIATION *>* pHash  = g_pDynSch->GetHashAssociations();
    WMI_ASSOCIATION*               pAssoc;

    DBG_ASSERT(pHash != NULL);

    //
    // Compare the association names
    //
    hr = i_pObj->Get(g_wszProp_Class, 0, &vt, NULL, NULL);
    if(FAILED(hr) || vt.vt != VT_BSTR)
    {
        goto exit;
    }
    hr = pHash->Wmi_GetByKey(vt.bstrVal, &pAssoc);
    if(FAILED(hr))
    {
        goto exit;
    }
    vt.Clear();

    //
    // This is the only case we care about
    //
    if(pAssoc->dwExtended != USER_DEFINED_TO_REPOSITORY)
    {
        goto exit;
    }

    //
    // Compare the left association component
    //
    hr = i_pObj->GetPropertyQualifierSet(
        pAssoc->pType->pszLeft,
        &spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }
    spQualSet->Get(g_wszPq_CimType, 0, &vt, NULL);
    spQualSet = NULL;
    if(FAILED(hr) || vt.vt != VT_BSTR)
    {
        goto exit;
    }
    if( (wsz = wcschr(vt.bstrVal, L':')) == NULL )
    {
        goto exit;
    }
    wsz++;
    if(_wcsicmp(wsz, pAssoc->pcLeft->pszClassName) != 0)
    {
        goto exit;
    }
    vt.Clear();

    //
    // Compare the right association component
    //
    hr = i_pObj->GetPropertyQualifierSet(
        pAssoc->pType->pszRight,
        &spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }
    spQualSet->Get(g_wszPq_CimType, 0, &vt, NULL);
    spQualSet = NULL;
    if(FAILED(hr) || vt.vt != VT_BSTR)
    {
        goto exit;
    }
    if( (wsz = wcschr(vt.bstrVal, L':')) == NULL )
    {
        goto exit;
    }
    wsz++;
    if(_wcsicmp(wsz, pAssoc->pcRight->pszClassName) != 0)
    {
        goto exit;
    }
    vt.Clear();

    bMatch = true;
    pAssoc->dwExtended = USER_DEFINED_NOT_TO_REPOSITORY;

exit:
    return !bMatch;
}

HRESULT CPusher::DeleteChildren(LPCWSTR i_wszExtSuperClass)
{
    DBG_ASSERT(i_wszExtSuperClass != NULL);
    DBG_ASSERT(m_bInitSuccessful  == true);

    //
    // Only can be called from inside Initialize
    //
    DBG_ASSERT(m_bInitCalled      == true);
    DBG_ASSERT(m_bInitSuccessful  == true);

    IEnumWbemClassObject*pEnum     = NULL;
    HRESULT              hr        = WBEM_S_NO_ERROR;

    IWbemClassObject*    apObj[10] = {0};
    ULONG                nrObj     = 0;
    ULONG                i = 0;

    VARIANT              v;
    VariantInit(&v);

    CComBSTR bstrExtSuperClass = i_wszExtSuperClass;
    if(bstrExtSuperClass.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }

    hr = m_pNamespace->CreateClassEnum(
        bstrExtSuperClass, 
        WBEM_FLAG_FORWARD_ONLY, 
        m_pCtx,
        &pEnum);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = pEnum->Next(WBEM_INFINITE, 10, apObj, &nrObj);
    while(SUCCEEDED(hr) && nrObj > 0)
    {
        for(i = 0; i < nrObj; i++)
        {
            bool bDelete;
            if( i_wszExtSuperClass == g_wszExtElementSettingAssocParent ||
                i_wszExtSuperClass == g_wszExtGroupPartAssocParent)
            {
                bDelete = NeedToDeleteAssoc(apObj[i]);
            }
            else
            {
                bDelete = true;
            }
            if(bDelete)
            {
                hr = apObj[i]->Get(g_wszProp_Class, 0, &v, NULL, NULL);
                if(FAILED(hr))
                {
                    goto exit;
                }

                hr = m_pNamespace->DeleteClass(v.bstrVal, WBEM_FLAG_OWNER_UPDATE, m_pCtx, NULL);
                if(FAILED(hr))
                {
                    goto exit;
                }

                VariantClear(&v);
            }
            apObj[i]->Release();
            apObj[i] = NULL;
        }
        
        hr = pEnum->Next(WBEM_INFINITE, 10, apObj, &nrObj);
    }
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    if(pEnum)
    {
        pEnum->Release();
        pEnum = NULL;
    }
    VariantClear(&v);
    for(i = 0; i < 10; i++)
    {
        if(apObj[i])
        {
            apObj[i]->Release();
        }
    }
    return hr;
}

HRESULT CPusher::GetObject(
    LPCWSTR            i_wszClass, 
    IWbemClassObject** o_ppObj)
{
    DBG_ASSERT(o_ppObj != NULL);
    DBG_ASSERT(m_bInitCalled == true);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObject* pObject;

    if(i_wszClass == g_wszExtElementParent)
    {
        *o_ppObj = m_spBaseElementObject;
        (*o_ppObj)->AddRef();
    }
    else if(i_wszClass == g_wszExtSettingParent)
    {
        *o_ppObj = m_spBaseSettingObject;
        (*o_ppObj)->AddRef();
    }
    else if(i_wszClass == g_wszExtElementSettingAssocParent)
    {
        *o_ppObj = m_spBaseElementSettingObject;
        (*o_ppObj)->AddRef();
    }
    else if(i_wszClass == g_wszExtGroupPartAssocParent)
    {
        *o_ppObj = m_spBaseGroupPartObject;
        (*o_ppObj)->AddRef();
    }
    else
    {
        const CComBSTR sbstrClass = i_wszClass;
        if(sbstrClass.m_str == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
        hr = m_pNamespace->GetObject(sbstrClass, 0, m_pCtx, &pObject, NULL);
        if(FAILED(hr))
        {
            goto exit;
        }
        *o_ppObj = pObject;
    }

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\schemadynamic.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    schemadynamic.h

Abstract:

    This file contains the definition of the CDynSchema class.
    This class contains the dynamic schema structures.
    It also contains the rules for populating the schema structures.

Author:

    Mohit Srivastava            28-Nov-00

Revision History:

--*/

#ifndef _schemadynamic_h_
#define _schemadynamic_h_

#include "hashtable.h"
#include "schema.h"
#include "schemaextensions.h"

//
// Prefix added to all auto-generated classes/associations
//
const LPWSTR g_wszIIs_ =     L"";
const ULONG  g_cchIIs_ =     wcslen(g_wszIIs_);

//
// Suffix added to "Settings" classes
//
const WCHAR  g_wszSettings[] = L"Setting";
const ULONG  g_cchSettings   = sizeof(g_wszSettings)/sizeof(WCHAR) - 1;

//
// These properties are ignored when building the property list
// for a class.
//
const DWORD  g_adwPropIgnoreList[]  = { MD_LOCATION, MD_KEY_TYPE, MD_IP_SEC, MD_ADMIN_ACL };
const ULONG  g_cElemPropIgnoreList  = sizeof(g_adwPropIgnoreList) / sizeof(DWORD);

class CDynSchema
{
public:
    CDynSchema() : m_bInitCalled(false),
        m_bInitSuccessful(false),
        m_bRulesRun(false),
        m_abKtContainers(NULL)
    {
    }
    ~CDynSchema()
    {
        delete [] m_abKtContainers;
    }
    CHashTable<METABASE_PROPERTY *> *GetHashProps()
    {
        return &m_hashProps;
    }
    CHashTable<WMI_CLASS *> *GetHashClasses()
    {
        return &m_hashClasses;
    }
    CHashTable<WMI_ASSOCIATION *> *GetHashAssociations()
    {
        return &m_hashAssociations;
    }
    CHashTable<METABASE_KEYTYPE *> *GetHashKeyTypes()
    {
        return &m_hashKeyTypes;
    }

    HRESULT Initialize();
    HRESULT RunRules(CSchemaExtensions* catalog, bool biUseExtensions = true);
    bool IsContainedUnder(METABASE_KEYTYPE* i_pktParent, METABASE_KEYTYPE* i_pktChild);
    void ToConsole();

private:
    void    LogConflicts(LPCWSTR wszSettingsClassName);
    HRESULT RulePopulateFromStatic();
    HRESULT Rule2PopulateFromStatic();
    HRESULT RulePopulateFromDynamic(
        CSchemaExtensions* i_pCatalog,
        BOOL               i_bUserDefined);

    //
    // KeyType stuff
    //
    HRESULT RuleKeyType(
        const CTableMeta *i_pTableMeta);

    HRESULT RuleWmiClassInverseCCL(
        const METABASE_KEYTYPE* pktGroup, 
        METABASE_KEYTYPE*       pktPart);

    HRESULT ConstructFlatInverseContainerList();

    void ConstructFlatInverseContainerListHelper(
        const METABASE_KEYTYPE* i_pkt, 
        bool*                   io_abList);    

    //
    // Wmi Class
    //
    HRESULT RuleWmiClass(
        const CTableMeta* i_pTableMeta, 
        WMI_CLASS**       o_ppElementClass, 
        WMI_CLASS**       o_ppSettingClass,
        DWORD             io_adwIgnoredProps[],
        BOOL              i_bUserDefined);

    HRESULT RuleProperties(
        const CTableMeta*          i_pTableMeta, 
        ULONG                      i_cPropsAndTagsRO, 
        WMI_CLASS*                 io_pWmiClass,
        ULONG                      i_cPropsAndTagsRW, 
        WMI_CLASS*                 io_pWmiSettingsClass,
        DWORD                      io_adwIgnoredProps[]);

    HRESULT RulePropertiesHelper(
        const CColumnMeta*        i_pColumnMeta, 
        METABASE_PROPERTY**       o_ppMbp,
        ULONG*                    i_idxTag);

    HRESULT RuleWmiClassDescription(
        const CTableMeta* i_pTableMeta, 
        WMI_CLASS*        i_pElementClass, 
        WMI_CLASS*        i_pSettingClass) const;

    void RuleWmiClassServices(
        WMI_CLASS* i_pElement,
        WMI_CLASS* i_pSetting);

    //
    // Associations
    //
    HRESULT RuleGroupPartAssociations(
        const CTableMeta *i_pTableMeta);

    HRESULT RuleGenericAssociations(
        WMI_CLASS*            i_pcElement, 
        WMI_CLASS*            i_pcSetting, 
        WMI_ASSOCIATION_TYPE* i_pAssocType,
        ULONG                 i_iShipped);

    HRESULT RuleSpecialAssociations(
        DWORD      i_adwIgnoredProps[],
        WMI_CLASS* i_pElement);

#if 0
    bool IgnoreProperty(LPCWSTR i_wszProp);
#endif
    bool IgnoreProperty(
        METABASE_KEYTYPE* io_pkt, 
        DWORD             i_dwPropId, 
        DWORD             io_adwIgnored[]);

    CHashTable<METABASE_PROPERTY *> m_hashProps;
    CPool<METABASE_PROPERTY> m_poolProps;

    CHashTable<WMI_CLASS *> m_hashClasses;
    CPool<WMI_CLASS> m_poolClasses;

    CHashTable<WMI_ASSOCIATION *> m_hashAssociations;
    CPool<WMI_ASSOCIATION> m_poolAssociations;

    CHashTable<METABASE_KEYTYPE *> m_hashKeyTypes;
    CPool<METABASE_KEYTYPE> m_poolKeyTypes;
    bool* m_abKtContainers;

    CStringPool                        m_spoolStrings;
    CArrayPool<METABASE_PROPERTY*, 10> m_apoolPMbp;
    CArrayPool<BYTE, 10>               m_apoolBytes;

    CPool<METABASE_KEYTYPE_NODE> m_poolKeyTypeNodes;

    bool m_bInitCalled;
    bool m_bInitSuccessful;

    bool m_bRulesRun;
};

#endif // _schemadynamic_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\schemaextensions.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    schemaextensions.cpp

Abstract:

    This file contains the implementation of the CSchemaExtensions class.
    This is the only class that talks to the catalog.

Author:

    MarcelV

Revision History:

    Mohit Srivastava            28-Nov-00

--*/

#include "iisprov.h"
#include "schemaextensions.h"
#include "metabase.hxx"

LPWSTR g_wszDatabaseName = L"Metabase";

HRESULT GetMetabasePath(LPTSTR io_tszPath)
/*++

Synopsis:
    This beast was copied and modified from
    \%sdxroot%\iis\svcs\infocomm\metadata\dll\metasub.cxx

Arguments: [io_tszPath] - must be at least size MAX_PATH

Return Value:

--*/
{
    DBG_ASSERT(io_tszPath != NULL);

    HRESULT hresReturn = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
    TCHAR tszBuffer[MAX_PATH] = {0};
    HKEY hkRegistryKey = NULL;
    DWORD dwRegReturn;
    DWORD dwType;
    DWORD dwSize = MAX_PATH * sizeof(TCHAR);

    dwRegReturn = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        SETUP_REG_KEY,  // TEXT("SOFTWARE\\Microsoft\\InetStp")
        &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS)
    {
        dwSize = MAX_PATH * sizeof(TCHAR);
        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                      INSTALL_PATH_VALUE,
                                      NULL,
                                      &dwType,
                                      (BYTE *) tszBuffer,
                                      &dwSize);
        if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ))
        {
            hresReturn = HRESULT_FROM_WIN32(dwRegReturn);
        }
        RegCloseKey( hkRegistryKey );
    }
    else
    {
        hresReturn = HRESULT_FROM_WIN32(dwRegReturn);
    }

    _tcscpy(io_tszPath, tszBuffer);

    if(FAILED(hresReturn))
    {
        DBGPRINTF((DBG_CONTEXT, "Could not get metabase path, hr=0x%x\n", hresReturn));
    }
    return hresReturn;
}

int __cdecl
CompDBNames (const void * pDBMetaLHS, const void * pDBMetaRHS)
{
    const tDATABASEMETARow *pLHS = static_cast<const tDATABASEMETARow *> (pDBMetaLHS );
    const tDATABASEMETARow *pRHS = static_cast<const tDATABASEMETARow *> (pDBMetaRHS );

    return _wcsicmp (pLHS->pInternalName, pRHS->pInternalName);
}

int __cdecl
CompTableMeta (const void * pTableMetaLHS, const void * pTableMetaRHS)
{
    const CTableMeta *pLHS = static_cast<const CTableMeta *> (pTableMetaLHS );
    const CTableMeta *pRHS = static_cast<const CTableMeta *> (pTableMetaRHS );

    return _wcsicmp (pLHS->TableMeta.pInternalName, pRHS->TableMeta.pInternalName);
}

int __cdecl
CompTableDBName (const void * pTableMetaLHS, const void * pTableMetaRHS)
{
    const CTableMeta *pLHS = static_cast<const CTableMeta *> (pTableMetaLHS );
    const CTableMeta *pRHS = static_cast<const CTableMeta *> (pTableMetaRHS );

    return _wcsicmp (pLHS->TableMeta.pDatabase, pRHS->TableMeta.pDatabase);
}

// sorted by table name and index
int __cdecl
CompColumnMetas (const void * pColumnMetaLHS, const void * pColumnMetaRHS)
{
    const CColumnMeta *pLHS = static_cast<const CColumnMeta *> (pColumnMetaLHS );
    const CColumnMeta *pRHS = static_cast<const CColumnMeta *> (pColumnMetaRHS );

    int iCmp = _wcsicmp (pLHS->ColumnMeta.pTable, pRHS->ColumnMeta.pTable);
    if (iCmp != 0)
    {
        return iCmp;
    }

    return (*pLHS->ColumnMeta.pIndex) - (*pRHS->ColumnMeta.pIndex);
}

// sorted by table name and index
int __cdecl
CompTagMetas (const void * pTagMetaLHS, const void * pTagMetaRHS)
{
    const tTAGMETARow *pLHS = static_cast<const tTAGMETARow *> (pTagMetaLHS );
    const tTAGMETARow *pRHS = static_cast<const tTAGMETARow *> (pTagMetaRHS );

    int iCmp = _wcsicmp (pLHS->pTable, pRHS->pTable);
    if (iCmp != 0)
    {
        return iCmp;
    }

    int iResult = (*pLHS->pColumnIndex) - (*pRHS->pColumnIndex);
    if (iResult != 0)
    {
        return iResult;
    }

    return (*pLHS->pValue) - (*pRHS->pValue);
}

CSchemaExtensions::CSchemaExtensions ()
{
    m_paTableMetas   = 0;
    m_cNrTables      = 0;

    m_paColumnMetas  = 0;
    m_cNrColumns     = 0;

    m_paTags         = 0;
    m_cNrTags        = 0;

    m_pQueryCells    = 0;
    m_cQueryCells    = 0;

    m_wszBinFileName = 0;
    m_tszBinFilePath = 0;

    m_bBinFileLoaded = false;
}

CSchemaExtensions::~CSchemaExtensions()
{
    if(m_bBinFileLoaded)
    {
        m_spIMbSchemaComp->ReleaseBinFileName(m_wszBinFileName);
    }

    delete [] m_paTableMetas;
    delete [] m_paColumnMetas;
    delete [] m_paTags;

    delete [] m_pQueryCells;
    delete [] m_wszBinFileName;
    delete [] m_tszBinFilePath;
}

HRESULT CSchemaExtensions::Initialize(bool i_bUseExtensions)
{
    HRESULT hr  = S_OK;
    ULONG   cch = 0;

    //
    // Get the dispenser
    //
    hr = DllGetSimpleObjectByIDEx(eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&m_spDispenser, WSZ_PRODUCT_IIS);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Could not get dispenser, hr=0x%x\n", hr));
        return hr;
    }

    //
    // Override the default logging mechanism
    //
    CComPtr<IAdvancedTableDispenser> spDispAdv;
    hr = m_spDispenser->QueryInterface(
        IID_IAdvancedTableDispenser,
        reinterpret_cast<LPVOID*>(&spDispAdv));
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Couldn't get Advanced Dispenser interface [0x%x]\n", hr));
        return hr;
    }
    CComPtr<ICatalogErrorLogger2> spNullLogger = new NULL_Logger();
    if(!spNullLogger)
    {
        DBGPRINTF((DBG_CONTEXT, "Out of memory\n"));
        return hr;
    }
    hr = spDispAdv->SetCatalogErrorLogger(spNullLogger);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Couldn't set logger [0x%x]\n", hr));
        return hr;
    }

    //
    // Get the schema compiler interface from the dispenser which will help us
    // get the bin file name.
    //
    hr = m_spDispenser->QueryInterface(IID_IMetabaseSchemaCompiler,
                                       (LPVOID*)&m_spIMbSchemaComp);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Couldn't get SchemaCompiler interface, hr=0x%x\n", hr));
        return hr;
    }

    //
    // Get the path of mbschema.xml
    //
    m_tszBinFilePath = new TCHAR[MAX_PATH+1];
    if(m_tszBinFilePath == NULL)
    {
        return E_OUTOFMEMORY;
    }
    hr = GetMetabasePath(m_tszBinFilePath);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Couldn't get metabase path, hr=0x%x\n", hr));
        return hr;
    }

    //
    // Convert it to Unicode, Set Bin Path
    //
#ifndef UNICODE
    // we want to convert an MBCS string in lpszA
    int nLen = MultiByteToWideChar(CP_ACP, 0,m_tszBinFilePath, -1, NULL, NULL);
    LPWSTR lpszW = new WCHAR[nLen];
    if(lpszW == NULL)
    {
        return E_OUTOFMEMORY;
    }
    if(MultiByteToWideChar(CP_ACP, 0, m_tszBinFilePath, -1, lpszW, nLen) == 0)
    {
        delete [] lpszW;
        hr = GetLastError();
        return HRESULT_FROM_WIN32(hr);
    }
    hr = m_spIMbSchemaComp->SetBinPath(lpszW);
    delete [] lpszW;
#else
    hr = m_spIMbSchemaComp->SetBinPath(m_tszBinFilePath);
#endif
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Get Bin FileName
    //
    hr = m_spIMbSchemaComp->GetBinFileName(NULL, &cch);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Couldn't get schema bin filename size, hr=0x%x\n", hr));
        return hr;
    }
    m_wszBinFileName = new WCHAR[cch+1];
    if(m_wszBinFileName == NULL)
    {
        return E_OUTOFMEMORY;
    }
    hr = m_spIMbSchemaComp->GetBinFileName(m_wszBinFileName, &cch);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Couldn't get schema bin filename, hr=0x%x\n", hr));
        return hr;
    }
    m_bBinFileLoaded = true;

    //
    // Set up the query cells
    //
    m_cQueryCells = 2;
    m_pQueryCells = new STQueryCell[m_cQueryCells];
    if(m_pQueryCells == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if(i_bUseExtensions)
    {
        m_pQueryCells[0].pData     = (LPVOID)m_wszBinFileName;
    }
    else
    {
        m_pQueryCells[0].pData     = (LPVOID)NULL;
    }

    m_pQueryCells[0].eOperator = eST_OP_EQUAL;
    m_pQueryCells[0].iCell     = iST_CELL_SCHEMAFILE;
    m_pQueryCells[0].dbType    = DBTYPE_WSTR;
    m_pQueryCells[0].cbSize    = 0;

    m_pQueryCells[1].pData = (void *) g_wszDatabaseName;
    m_pQueryCells[1].eOperator = eST_OP_EQUAL;
    m_pQueryCells[1].iCell = iCOLLECTION_META_Database;
    m_pQueryCells[1].dbType = DBTYPE_WSTR;
    m_pQueryCells[1].cbSize = 0;

    hr = GenerateIt();
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "GenerateIt failed, hr=0x%x\n", hr));
        return hr;
    }

    return hr;
}

HRESULT CSchemaExtensions::GetMbSchemaTimeStamp(
    FILETIME* io_pFileTime) const
{
    DBG_ASSERT(io_pFileTime     != NULL);
    DBG_ASSERT(m_tszBinFilePath != NULL);

    HRESULT hr = S_OK;

    ULONG cchBinFilePath     = _tcslen(m_tszBinFilePath);
    ULONG cchSchFileName     = _tcslen(MD_SCHEMA_FILE_NAME);

    TCHAR* tszPathPlusName = new TCHAR[cchBinFilePath+1+cchSchFileName+1];
    TCHAR* tszCurPos       = tszPathPlusName;
    if(tszPathPlusName == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Copy the path
    //
    tszCurPos = tszPathPlusName;
    memcpy(tszCurPos, m_tszBinFilePath, sizeof(TCHAR)*(cchBinFilePath+1));

    //
    // Concat a \ if necessary, and the filename,
    //
    tszCurPos = tszPathPlusName + cchBinFilePath;
    if(m_tszBinFilePath[cchBinFilePath-1] != TEXT('\\'))
    {
        memcpy(tszCurPos, TEXT("\\"), sizeof(TCHAR)*2);
        tszCurPos++;
    }
    memcpy(tszCurPos, MD_SCHEMA_FILE_NAME, sizeof(TCHAR)*(cchSchFileName+1));

    //
    // Now get the file info
    //
    {
        WIN32_FIND_DATA FindFileData;
        memset(&FindFileData, 0, sizeof(WIN32_FIND_DATA));

        HANDLE hFindFile = FindFirstFile(tszPathPlusName, &FindFileData);
        if(hFindFile == INVALID_HANDLE_VALUE)
        {
            hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
            goto exit;
        }
        FindClose(hFindFile);

        //
        // Set out parameters if everything succeeded
        //
        memcpy(io_pFileTime, &FindFileData.ftLastWriteTime, sizeof(FILETIME));
    }

exit:
    delete [] tszPathPlusName;
    return hr;
}

HRESULT
CSchemaExtensions::GenerateIt ()
{
    HRESULT hr = S_OK;

    hr = GetTables ();
    if (FAILED (hr))
    {
        return hr;
    }


    hr = GetColumns ();
    if (FAILED (hr))
    {
        return hr;
    }

    hr = GetTags ();
    if (FAILED (hr))
    {
        return hr;
    }

    hr = BuildInternalStructures ();
    if (FAILED (hr))
    {
        return hr;
    }

    return hr;
}


HRESULT
CSchemaExtensions::GetTables ()
{
    HRESULT hr = S_OK;

    ULONG one = 1;

    hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_TABLEMETA,
                                  m_pQueryCells, (void *)&one, eST_QUERYFORMAT_CELLS, 0, (void **) &m_spISTTableMeta);
    if (FAILED (hr))
    {
        return hr;
    }

    hr = m_spISTTableMeta->GetTableMeta (0, 0, &m_cNrTables, 0);
    if (FAILED (hr))
    {
        return hr;
    }

    if (m_cNrTables == 0)
    {
        return S_OK;
    }

    m_paTableMetas = new CTableMeta [m_cNrTables];
    if (m_paTableMetas == 0)
    {
        return E_OUTOFMEMORY;
    }


    for (ULONG idx =0; idx < m_cNrTables; ++idx)
    {
        hr = m_spISTTableMeta->GetColumnValues (idx, sizeof (tTABLEMETARow)/sizeof (ULONG *), 0, 0, (void **) &m_paTableMetas[idx].TableMeta);
        if (FAILED (hr))
        {
            return hr;
        }

        if (m_paTableMetas[idx].ColCount () > 0)
        {
            // set number of columns
            m_paTableMetas[idx].paColumns = new LPCColumnMeta[m_paTableMetas[idx].ColCount()];
            if (m_paTableMetas[idx].paColumns == 0)
            {
                return E_OUTOFMEMORY;
            }
        }
    }

    // and sort them by table name

    qsort (m_paTableMetas, m_cNrTables, sizeof (CTableMeta), CompTableMeta);
    return hr;
}

HRESULT
CSchemaExtensions::GetColumns ()
{
    HRESULT hr = S_OK;

    ULONG one = 1;

    hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA,
                                  m_pQueryCells, (void *)&one, eST_QUERYFORMAT_CELLS, 0, (void **) &m_spISTColumnMeta);
    if (FAILED (hr))
    {
        return hr;
    }

    hr = m_spISTColumnMeta->GetTableMeta (0, 0, &m_cNrColumns, 0);
    if (FAILED (hr))
    {
        return hr;
    }

    if (m_cNrColumns == 0)
    {
        return E_FAIL;
    }

    m_paColumnMetas = new CColumnMeta[m_cNrColumns];
    if (m_paColumnMetas == 0)
    {
        return E_OUTOFMEMORY;
    }

    ULONG acbSizes[cCOLUMNMETA_NumberOfColumns];
    for (ULONG idx =0; idx < m_cNrColumns; ++idx)
    {
        hr = m_spISTColumnMeta->GetColumnValues (idx, sizeof (tCOLUMNMETARow)/sizeof (ULONG *), 0, acbSizes, (void **) &m_paColumnMetas[idx].ColumnMeta);
        m_paColumnMetas[idx].cbDefaultValue = acbSizes[iCOLUMNMETA_DefaultValue];
        if (FAILED (hr))
        {
            return hr;
        }
    }

    qsort (m_paColumnMetas, m_cNrColumns, sizeof (CColumnMeta), CompColumnMetas);

    return hr;
}

HRESULT
CSchemaExtensions::GetTags ()
{
    HRESULT hr = S_OK;

    ULONG one = 1;

    hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_TAGMETA,
                                  m_pQueryCells, (void *)&one, eST_QUERYFORMAT_CELLS, 0, (void **) &m_spISTTagMeta);
    if (FAILED (hr))
    {
        return hr;
    }

    hr = m_spISTTagMeta->GetTableMeta (0, 0, &m_cNrTags, 0);
    if (FAILED (hr))
    {
        return hr;
    }

    if (m_cNrTags == 0)
    {
        return E_FAIL;
    }

    m_paTags = new tTAGMETARow[m_cNrTags];
    if (m_paTags == 0)
    {
        return E_OUTOFMEMORY;
    }

    for (ULONG idx =0; idx < m_cNrTags; ++idx)
    {
        hr = m_spISTTagMeta->GetColumnValues (idx, sizeof (tTAGMETARow)/sizeof (ULONG *), 0, 0, (void **) &m_paTags[idx]);
        if (FAILED (hr))
        {
            return hr;
        }
    }
    qsort (m_paTags, m_cNrTags, sizeof (tTAGMETARow), CompTagMetas);

    return hr;
}

HRESULT
CSchemaExtensions::BuildInternalStructures ()
{
    HRESULT hr = S_OK;

    // attach the tags to the tables

    ULONG idx = 0;
    while (idx < m_cNrTags)
    {
        // find the correct column
        CColumnMeta dummyColumnMeta;
        dummyColumnMeta.ColumnMeta.pTable = m_paTags[idx].pTable;
        dummyColumnMeta.ColumnMeta.pIndex = m_paTags[idx].pColumnIndex;
        // get column
        CColumnMeta *pColMeta = (CColumnMeta *) bsearch (&dummyColumnMeta,
                                                         m_paColumnMetas,
                                                         m_cNrColumns,
                                                         sizeof (CColumnMeta),
                                                         CompColumnMetas);

        DBG_ASSERT (pColMeta != NULL);

        if (NULL == pColMeta) {
            return E_FAIL;
        }

        DBG_ASSERT (wcscmp(pColMeta->ColumnMeta.pTable, m_paTags[idx].pTable) == 0 &&
            *pColMeta->ColumnMeta.pIndex == *m_paTags[idx].pColumnIndex);

        // get count
        ULONG iStartIdx = idx;
        pColMeta->cNrTags = 1;
        idx++; // skip over this element
        while ((idx < m_cNrTags) &&
               (wcscmp(pColMeta->ColumnMeta.pTable, m_paTags[idx].pTable) == 0) &&
               (*pColMeta->ColumnMeta.pIndex == *m_paTags[idx].pColumnIndex))
        {
            idx++;
            pColMeta->cNrTags += 1;
        }

        if (pColMeta->cNrTags > 0)
        {
            // allocate memory and copy the stuff
            pColMeta->paTags = new LPtTAGMETA[pColMeta->cNrTags];
            if (pColMeta->paTags == 0)
            {
                return E_OUTOFMEMORY;
            }
            for (ULONG tagIdx = 0; tagIdx < pColMeta->cNrTags; ++tagIdx)
            {
                pColMeta->paTags[tagIdx] = &m_paTags[iStartIdx + tagIdx];
            }
        }
    }

    // attach the columns to the tables
    for (idx=0; idx < m_cNrColumns; ++idx)
    {
        CTableMeta dummyTableMeta;
        dummyTableMeta.TableMeta.pInternalName = m_paColumnMetas[idx].ColumnMeta.pTable;
        // find table
        CTableMeta *pTableMeta =  (CTableMeta *) bsearch (&dummyTableMeta, m_paTableMetas,
                                                          m_cNrTables,
                                                          sizeof (CTableMeta),
                                                          CompTableMeta);
        DBG_ASSERT (pTableMeta != 0);
        DBG_ASSERT (wcscmp(pTableMeta->TableMeta.pInternalName, m_paColumnMetas[idx].ColumnMeta.pTable) == 0);

        // add Column to table

        ULONG iColumnIndex = *(m_paColumnMetas[idx].ColumnMeta.pIndex);
        DBG_ASSERT (iColumnIndex < pTableMeta->ColCount ());
        pTableMeta->paColumns[iColumnIndex] = &m_paColumnMetas[idx];
    }

    return hr;
}

CTableMeta* CSchemaExtensions::EnumTables(ULONG *io_idx)
{
    DBG_ASSERT(io_idx != NULL);

    CTableMeta* pRet = NULL;

    while(1)
    {
        if(*io_idx < m_cNrTables)
        {
            pRet = &m_paTableMetas[*io_idx];
            if( _wcsicmp(pRet->TableMeta.pDatabase, g_wszDatabaseName) == 0 &&
                !(*pRet->TableMeta.pMetaFlags & fTABLEMETA_HIDDEN) )
            {
                *io_idx = 1 + *io_idx;
                return pRet;
            }
            else
            {
                *io_idx = 1 + *io_idx;
            }
        }
        else
        {
            *io_idx = 1 + *io_idx;
            return NULL;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\schemaextensions.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    schemaextensions.h

Abstract:

    This file contains the definition of the CSchemaExtensions class.
    This is the only class that talks to the catalog.

Author:

    MarcelV

Revision History:

    Mohit Srivastava            28-Nov-00

--*/

#ifndef _schemaextensions_h_
#define _schemaextensions_h_

#include "catalog.h"
#include "catmeta.h"
#include <atlbase.h>

//forward decl
struct CTableMeta;

struct CColumnMeta
{
    CColumnMeta() {paTags = 0; cbDefaultValue = 0; cNrTags = 0;}
    ~CColumnMeta() {delete [] paTags;}
    tCOLUMNMETARow ColumnMeta;
    ULONG cbDefaultValue;
    ULONG cNrTags;
    tTAGMETARow **paTags;
};

struct CTableMeta
{
    CTableMeta () {paColumns=0;}
    ~CTableMeta () {delete []paColumns;}

    ULONG ColCount () const
    {
        return *(TableMeta.pCountOfColumns);
    }

    tTABLEMETARow TableMeta;
    CColumnMeta **paColumns;
};



typedef tTAGMETARow * LPtTAGMETA;
typedef CColumnMeta * LPCColumnMeta;
    
/********************************************************************++
 
Class Name:
 
    NULL_Logger
 
Class Description:
 
    We don't want any IST errors logged to the event log or the text
    log.  We are only reading the schema bin file.  Any errors we see
    will probably be redundant with those in IIS anyways.
 
Constraints
 
--********************************************************************/
class NULL_Logger : public ICatalogErrorLogger2
{
public:
    NULL_Logger() : m_cRef(0){}
    virtual ~NULL_Logger(){}

//IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv)
    {
        if (NULL == ppv) 
            return E_INVALIDARG;
        *ppv = NULL;

        if (riid == IID_ICatalogErrorLogger2)
            *ppv = (ICatalogErrorLogger2*) this;
        else if (riid == IID_IUnknown)
            *ppv = (ICatalogErrorLogger2*) this;

        if (NULL == *ppv)
            return E_NOINTERFACE;

        ((ICatalogErrorLogger2*)this)->AddRef ();
        return S_OK;
    }
	STDMETHOD_(ULONG,AddRef)		()
    {
        return InterlockedIncrement((LONG*) &m_cRef);
    }
	STDMETHOD_(ULONG,Release)		()
    {
        long cref = InterlockedDecrement((LONG*) &m_cRef);
        if (cref == 0)
            delete this;

        return cref;
    }

//ICatalogErrorLogger2
	STDMETHOD(ReportError) (ULONG      i_BaseVersion_DETAILEDERRORS,
                            ULONG      i_ExtendedVersion_DETAILEDERRORS,
                            ULONG      i_cDETAILEDERRORS_NumberOfColumns,
                            ULONG *    i_acbSizes,
                            LPVOID *   i_apvValues){return S_OK;}
private:
    ULONG           m_cRef;
};

class CSchemaExtensions
{
public:
    CSchemaExtensions ();
    ~CSchemaExtensions ();
    
    HRESULT Initialize (bool i_bUseExtensions = true);
    CTableMeta* EnumTables(ULONG *io_idx);

    HRESULT GetMbSchemaTimeStamp(FILETIME* io_pFileTime) const;

private:

    HRESULT GenerateIt ();

    HRESULT GetTables ();
    HRESULT GetColumns ();
    HRESULT GetTags ();
    HRESULT GetRelations ();    
    
    HRESULT BuildInternalStructures ();

    CComPtr<ISimpleTableDispenser2>  m_spDispenser;
    CComPtr<IMetabaseSchemaCompiler> m_spIMbSchemaComp;

    CComPtr<ISimpleTableRead2> m_spISTTableMeta;
    CComPtr<ISimpleTableRead2> m_spISTColumnMeta;
    CComPtr<ISimpleTableRead2> m_spISTTagMeta;
    CComPtr<ISimpleTableRead2> m_spISTRelationMeta;
    
    LPWSTR              m_wszBinFileName;
    
    LPTSTR              m_tszBinFilePath;

    CTableMeta*         m_paTableMetas;     // all table information
    ULONG               m_cNrTables;

    CColumnMeta*        m_paColumnMetas;    // all column information
    ULONG               m_cNrColumns;

    tTAGMETARow*        m_paTags;           // all tag information
    ULONG               m_cNrTags;

    ULONG               m_cQueryCells;
    STQueryCell*        m_pQueryCells;

    bool                m_bBinFileLoaded;
};

#endif // _schemaextensions_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\schemadynamic.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    schemadynamic.cpp

Abstract:

    This file contains the implementation of the CDynSchema class.
    This class contains the dynamic schema structures.
    It also contains the rules for populating the schema structures.

Author:

    Mohit Srivastava            28-Nov-00

Revision History:

--*/

#include "iisprov.h"

#define USE_DEFAULT_VALUES
#define USE_DEFAULT_BINARY_VALUES

CDynSchema* g_pDynSch = NULL;

HRESULT CDynSchema::Initialize()
/*++

Synopsis: 
    If fails, object must be destroyed.
    If succeeds, object is ready for use.

Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == false);
    DBG_ASSERT(m_bInitSuccessful == false);

    HRESULT hr = WBEM_S_NO_ERROR;

    m_bInitCalled = true;

    hr = m_hashProps.Wmi_Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }
    
    hr = m_hashClasses.Wmi_Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_hashAssociations.Wmi_Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_hashKeyTypes.Wmi_Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_poolAssociations.Initialize(10);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_poolClasses.Initialize(10);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_poolProps.Initialize(10);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_poolKeyTypes.Initialize(10);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_poolKeyTypeNodes.Initialize(10);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_spoolStrings.Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_apoolPMbp.Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_apoolBytes.Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    if(SUCCEEDED(hr))
    {
        m_bInitSuccessful = true;
    }
    return hr;
}

void CDynSchema::LogConflicts(LPCWSTR wszSettingsClassName)
// Logs an error in system events if a schema conflict occurs
{
    WMI_ASSOCIATION *pWmiAssoc   = NULL;
    WMI_CLASS* pWmiSettingsClass = NULL;

    if (SUCCEEDED(m_hashClasses.Wmi_GetByKey(wszSettingsClassName, &pWmiSettingsClass)) ||
        SUCCEEDED(m_hashAssociations.Wmi_GetByKey(wszSettingsClassName, &pWmiAssoc))) {

        const WCHAR * EventLogStrings[2];
        const LPCWSTR wszErrorString = L"WMI Schema warning - class already exists";

        EventLogStrings[0] = wszSettingsClassName;
        EventLogStrings[1] = wszErrorString;

        EVENT_LOG m_EventLog(L"WMI Schema");

        m_EventLog.LogEvent(
            TYPE_E_NAMECONFLICT,     // message id
            2,                                      // count of strings
            EventLogStrings,                        // array of strings
            0                                       // error code
            );
    }
}

HRESULT CDynSchema::RulePopulateFromStatic()
/*++

Synopsis: 
    Populates hashtables with pointers to hardcoded schema.

Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT hr = WBEM_S_NO_ERROR;

    //
    // Populate Properties
    //
    if(METABASE_PROPERTY_DATA::s_MetabaseProperties != NULL)
    {
        METABASE_PROPERTY* pStatMbpCurrent;
        for(ULONG i = 0; ; i++)
        {
            pStatMbpCurrent = METABASE_PROPERTY_DATA::s_MetabaseProperties[i];
            if(pStatMbpCurrent == NULL)
            {
                break;
            }
            hr = m_hashProps.Wmi_Insert(pStatMbpCurrent->pszPropName, pStatMbpCurrent);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
    }

    //
    // Populate KeyTypes
    //
    METABASE_KEYTYPE** apMetabaseKeyTypes;
    apMetabaseKeyTypes = METABASE_KEYTYPE_DATA::s_MetabaseKeyTypes;
    for(ULONG i = 0; apMetabaseKeyTypes[i] != NULL; i++)
    {
        if( apMetabaseKeyTypes[i]->m_pszName != NULL )
        {
            apMetabaseKeyTypes[i]->m_pKtListInverseCCL = NULL;
            hr = m_hashKeyTypes.Wmi_Insert(apMetabaseKeyTypes[i]->m_pszName,
                apMetabaseKeyTypes[i]);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
    }

exit:
    return hr;
}

HRESULT CDynSchema::Rule2PopulateFromStatic()
/*++

Synopsis: 
    Populates hashtables with pointers to hardcoded schema.

Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled == true);
    DBG_ASSERT(m_bInitSuccessful == true);    

    HRESULT hr = S_OK;
    int i;

    //
    // Populate Classes
    //
    WMI_CLASS* pStatWmiClassCurrent;
    for(i = 0; ; i++)
    {
        pStatWmiClassCurrent = WMI_CLASS_DATA::s_WmiClasses[i];
        if(pStatWmiClassCurrent == NULL)
        {
            break;
        }
        hr = m_hashClasses.Wmi_Insert(
            pStatWmiClassCurrent->pszClassName,
            pStatWmiClassCurrent);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // Populate Associations
    //
    WMI_ASSOCIATION* pStatWmiAssocCurrent;
    for(i = 0; ; i++)
    {
        pStatWmiAssocCurrent = WMI_ASSOCIATION_DATA::s_WmiAssociations[i];
        if(pStatWmiAssocCurrent == NULL)
        {
            break;
        }
        hr = m_hashAssociations.Wmi_Insert(
            pStatWmiAssocCurrent->pszAssociationName, 
            pStatWmiAssocCurrent);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CDynSchema::RuleKeyType(
    const CTableMeta *i_pTableMeta)
/*++

Synopsis: 
    If not already in hashtable of keytypes, a keytype structure
    is allocated thru the keytype pool.  Then, a pointer to it is inserted
    in hashtable.

Arguments: [i_pTableMeta] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pTableMeta != NULL);

    HRESULT           hr     = WBEM_S_NO_ERROR;
    HRESULT           hrTemp = WBEM_S_NO_ERROR;
    METABASE_KEYTYPE* pktNew;
    LPWSTR            wszNew;

    hrTemp = m_hashKeyTypes.Wmi_GetByKey(
        i_pTableMeta->TableMeta.pInternalName,
        &pktNew);
    if(FAILED(hrTemp))
    {
        hr = m_spoolStrings.GetNewString(i_pTableMeta->TableMeta.pInternalName, &wszNew);
        if(FAILED(hr))
        {
            goto exit;
        }
        hr = m_poolKeyTypes.GetNewElement(&pktNew);
        if(FAILED(hr))
        {
            goto exit;
        }
        pktNew->m_pszName           = wszNew;
        pktNew->m_pKtListInverseCCL = NULL;
        m_hashKeyTypes.Wmi_Insert(wszNew, pktNew);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CDynSchema::RuleWmiClassDescription(
    const CTableMeta* i_pTableMeta, 
    WMI_CLASS*        i_pElementClass, 
    WMI_CLASS*        i_pSettingClass) const
/*++

Synopsis:
    Sets WMI_CLASS::pDescription if needed.
    This pointer will be invalid after initialization since it points to 
    catalog.

Arguments: [i_pTableMeta] -
           [i_pElementClass] -
           [i_pSettingClass] -

Return Value:

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pTableMeta      != NULL);
    DBG_ASSERT(i_pElementClass   != NULL);
    DBG_ASSERT(i_pSettingClass   != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    if(i_pTableMeta->TableMeta.pDescription != NULL)
    {
        i_pElementClass->pszDescription = i_pTableMeta->TableMeta.pDescription;
        i_pSettingClass->pszDescription = i_pTableMeta->TableMeta.pDescription;
    }

    return hr;
}

HRESULT CDynSchema::RuleWmiClass(
    const CTableMeta* i_pTableMeta,
    WMI_CLASS**       o_ppElementClass,
    WMI_CLASS**       o_ppSettingClass,
    DWORD             io_adwIgnoredProps[],
    BOOL              i_bUserDefined)
/*++

Synopsis: 
    Creates an Element and Setting class based on 
    i_pTableMeta->TableMeta.pInternalName.  If not in hashtable of classes,
    these classes are inserted.

    At bottom,
        RuleProperties is called to set up list of properties for each class.

Arguments: [i_pTableMeta] - 
           [o_ppElementClass] - can be NULL
           [o_ppSettingClass] - can be NULL
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pTableMeta      != NULL);

    WMI_CLASS* pWmiClass = NULL;
    WMI_CLASS* pWmiSettingsClass = NULL;
    LPWSTR wszClassName, wszSettingsClassName;
    LPWSTR wszParentClassName, wszParentSettingsClassName;
    HRESULT hr     = WBEM_S_NO_ERROR;
    HRESULT hrTemp = WBEM_S_NO_ERROR;

    ULONG cPropsAndTagsRW = 0;
    ULONG cPropsAndTagsRO = 0;

    ULONG iShipped = 0;

    CColumnMeta* pColumnMeta;
    ULONG  cchTable;

    //
    // Ignore table if it has no name
    //
    if(i_pTableMeta->TableMeta.pInternalName == NULL)
    {
        hr = WBEM_S_NO_ERROR;
        goto exit;
    }

    //
    // Determine iShipped and Parent Classes
    //
    if(fTABLEMETA_USERDEFINED & *i_pTableMeta->TableMeta.pSchemaGeneratorFlags)
    {
        iShipped                   = USER_DEFINED_TO_REPOSITORY;
        DBG_ASSERT(iShipped != USER_DEFINED_NOT_TO_REPOSITORY);
        wszParentClassName         = g_wszExtElementParent;
        wszParentSettingsClassName = g_wszExtSettingParent;
    }
    else
    {
        if(fTABLEMETA_EXTENDED & *i_pTableMeta->TableMeta.pSchemaGeneratorFlags)
        {
            iShipped = EXTENDED;
        }
        else
        {
            iShipped = SHIPPED_TO_MOF;
        }
        wszParentClassName = g_wszElementParent;
        wszParentSettingsClassName = g_wszSettingParent;
    }

    //
    // Determine number of RO and RW properties
    //
    for(ULONG idxProps = 0; idxProps < i_pTableMeta->ColCount(); idxProps++)
    {
        pColumnMeta = i_pTableMeta->paColumns[idxProps];
        if(*pColumnMeta->ColumnMeta.pSchemaGeneratorFlags &
            fCOLUMNMETA_CACHE_PROPERTY_MODIFIED)
        {
            cPropsAndTagsRW += pColumnMeta->cNrTags + 1;
        }
        else
        {
            cPropsAndTagsRO += pColumnMeta->cNrTags + 1;
        }
    }

    cchTable = wcslen(i_pTableMeta->TableMeta.pInternalName);

    //
    // The keytype should already exist.
    //
    METABASE_KEYTYPE* pktTemp;
    hrTemp = m_hashKeyTypes.Wmi_GetByKey(i_pTableMeta->TableMeta.pInternalName, &pktTemp);
    if( FAILED(hrTemp) )
    {
        goto exit;
    }

    //
    // The Element class (named PrefixC)
    //
    hr = m_spoolStrings.GetNewArray(g_cchIIs_+cchTable+1, &wszClassName);
    if(FAILED(hr))
    {
        goto exit;
    }
    memcpy(wszClassName, g_wszIIs_, sizeof(WCHAR)*g_cchIIs_);
    memcpy(&wszClassName[g_cchIIs_], 
        i_pTableMeta->TableMeta.pInternalName, 
        sizeof(WCHAR)*(cchTable+1));

    if (i_bUserDefined) {
        LogConflicts(wszClassName);
    }

    if(FAILED(m_hashClasses.Wmi_GetByKey(wszClassName, &pWmiClass)))
    {
        hr = m_poolClasses.GetNewElement(&pWmiClass);
        if(FAILED(hr))
        {
            goto exit;
        }
        pWmiClass->pkt            = pktTemp;
        pWmiClass->pszClassName   = wszClassName;
        pWmiClass->pszMetabaseKey = L"/LM";
        pWmiClass->pszKeyName     = L"Name";
        pWmiClass->ppMethod       = NULL;
        pWmiClass->pszParentClass = wszParentClassName;
        pWmiClass->bCreateAllowed = true;
        pWmiClass->pszDescription = NULL;

        hr = m_hashClasses.Wmi_Insert(wszClassName, pWmiClass);
        if(FAILED(hr))
        {
            goto exit;
        }
    }
    pWmiClass->ppmbp          = NULL;
    pWmiClass->dwExtended     = iShipped;

    //
    // The Settings class (named PrefixCSetting)
    //
    hr = m_spoolStrings.GetNewArray(g_cchIIs_+cchTable+g_cchSettings+1, &wszSettingsClassName);
    if(FAILED(hr))
    {
        goto exit;
    }
    memcpy(wszSettingsClassName, g_wszIIs_, sizeof(WCHAR)*g_cchIIs_);
    memcpy(&wszSettingsClassName[g_cchIIs_], 
        i_pTableMeta->TableMeta.pInternalName, 
        sizeof(WCHAR)*cchTable);
    memcpy(&wszSettingsClassName[g_cchIIs_+cchTable],
        g_wszSettings,
        sizeof(WCHAR)*(g_cchSettings+1));

    if (i_bUserDefined) {
        LogConflicts(wszSettingsClassName);
    }

    if(FAILED(m_hashClasses.Wmi_GetByKey(wszSettingsClassName, &pWmiSettingsClass)))
    {
        hr = m_poolClasses.GetNewElement(&pWmiSettingsClass);
        if(FAILED(hr))
        {
            goto exit;
        }
        pWmiSettingsClass->pkt            = pktTemp;
        pWmiSettingsClass->pszClassName   = wszSettingsClassName;
        pWmiSettingsClass->pszMetabaseKey = L"/LM";
        pWmiSettingsClass->pszKeyName     = L"Name";
        pWmiSettingsClass->ppMethod       = NULL;
        pWmiSettingsClass->pszParentClass = wszParentSettingsClassName;
        pWmiSettingsClass->bCreateAllowed = true;
        pWmiSettingsClass->pszDescription = NULL;

        hr = m_hashClasses.Wmi_Insert(wszSettingsClassName, pWmiSettingsClass);
        if(FAILED(hr))
        {
            goto exit;
        }
    }
    pWmiSettingsClass->ppmbp          = NULL;
    pWmiSettingsClass->dwExtended     = iShipped;

    //
    // Fill in the ppmbp field
    //
    hr = RuleProperties(
        i_pTableMeta,
        cPropsAndTagsRO, 
        pWmiClass,
        cPropsAndTagsRW, 
        pWmiSettingsClass,
        io_adwIgnoredProps);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    if(SUCCEEDED(hr))
    {
        if(o_ppElementClass != NULL)
        {
            *o_ppElementClass = pWmiClass;
        }
        if(o_ppSettingClass != NULL)
        {
            *o_ppSettingClass = pWmiSettingsClass;
        }
    }
    return hr;
}

HRESULT CDynSchema::RuleProperties(
    const CTableMeta*          i_pTableMeta, 
    ULONG                      i_cPropsAndTagsRO,
    WMI_CLASS*                 io_pWmiClass,
    ULONG                      i_cPropsAndTagsRW,
    WMI_CLASS*                 io_pWmiSettingsClass,
    DWORD                      io_adwIgnoredProps[])
/*++

Synopsis: 
    Given i_pTableMeta, puts the properties either under the Element class
    or under the Setting class.

Arguments: [i_pTableMeta] - 
           [i_cPropsAndTagsRO] - 
           [o_papMbp] - 
           [i_cPropsAndTagsRW] - 
           [o_papMbpSettings] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled        == true);
    DBG_ASSERT(m_bInitSuccessful    == true);
    DBG_ASSERT(i_pTableMeta         != NULL);
    DBG_ASSERT(io_pWmiClass         != NULL);
    DBG_ASSERT(io_pWmiSettingsClass != NULL);
    // DBG_ASSERT(sizeof(io_awszIgnoredProps) >= sizeof(g_awszPropIgnoreList));

    HRESULT            hr = WBEM_S_NO_ERROR;
    CColumnMeta*       pColumnMeta = NULL;
    METABASE_PROPERTY* pMbp;
    ULONG              idxProps = 0;
    ULONG              idxTags = 0;

    ULONG              idxPropsAndTagsRO = 0;
    ULONG              idxPropsAndTagsRW = 0;

    METABASE_PROPERTY*** papMbp         = &io_pWmiClass->ppmbp;
    METABASE_PROPERTY*** papMbpSettings = &io_pWmiSettingsClass->ppmbp;

    //
    // Allocate enough memory for the RO properties
    //
    if(i_cPropsAndTagsRO > 0)
    {
        hr = m_apoolPMbp.GetNewArray(i_cPropsAndTagsRO+1, papMbp);
        if(FAILED(hr))
        {
            goto exit;
        }
        memset(*papMbp, 0, (1+i_cPropsAndTagsRO)*sizeof(METABASE_PROPERTY*));
    }

    //
    // Allocate enough memory for the RW properties
    //
    if(i_cPropsAndTagsRW > 0)
    {
        hr = m_apoolPMbp.GetNewArray(i_cPropsAndTagsRW+1, papMbpSettings);
        if(FAILED(hr))
        {
            goto exit;
        }
        memset(*papMbpSettings, 0, (1+i_cPropsAndTagsRW)*sizeof(METABASE_PROPERTY*));
    }

    //
    // Walk thru all the properties
    //
    for (idxProps=0, idxPropsAndTagsRO = 0, idxPropsAndTagsRW = 0; 
         idxProps < i_pTableMeta->ColCount();
         ++idxProps)
    {
        pColumnMeta = i_pTableMeta->paColumns[idxProps];

        //
        // Ignore property if its in g_adwPropIgnoreList and store the prop in
        // io_adwIgnoredProps
        //
        if( (*pColumnMeta->ColumnMeta.pSchemaGeneratorFlags & fCOLUMNMETA_HIDDEN) ||
            IgnoreProperty(io_pWmiClass->pkt, *(pColumnMeta->ColumnMeta.pID), io_adwIgnoredProps) )
        {
            continue;
        }

        //
        // Call RulePropertiesHelper if Property is not already in the 
        // properties hashtable
        //
        if(FAILED(m_hashProps.Wmi_GetByKey(pColumnMeta->ColumnMeta.pInternalName, &pMbp)))
        {
            hr = RulePropertiesHelper(pColumnMeta, &pMbp, NULL);
            if(FAILED(hr))
            {
                goto exit;
            }
        }

        //
        // If RW, put pointer to property in Setting class, else in Element
        // class.
        //
        if(*pColumnMeta->ColumnMeta.pSchemaGeneratorFlags &
            fCOLUMNMETA_CACHE_PROPERTY_MODIFIED)
        {
            (*papMbpSettings)[idxPropsAndTagsRW] = pMbp;
            idxPropsAndTagsRW++;
        }
        else
        {
            (*papMbp)[idxPropsAndTagsRO] = pMbp;
            idxPropsAndTagsRO++;
        }

        //
        // Same steps as above, except for the tags.
        //
        for(idxTags=0; idxTags < pColumnMeta->cNrTags; idxTags++)
        {
            if(FAILED(m_hashProps.Wmi_GetByKey(pColumnMeta->paTags[idxTags]->pInternalName, &pMbp)))
            {
                hr = RulePropertiesHelper(pColumnMeta, &pMbp, &idxTags);
                if(FAILED(hr))
                {
                    goto exit;
                }
            }
            if(*pColumnMeta->ColumnMeta.pSchemaGeneratorFlags &
                fCOLUMNMETA_CACHE_PROPERTY_MODIFIED)
            {
                (*papMbpSettings)[idxPropsAndTagsRW] = pMbp;
                idxPropsAndTagsRW++;
            }
            else
            {
                (*papMbp)[idxPropsAndTagsRO] = pMbp;
                idxPropsAndTagsRO++;
            }
        }        
    }

exit:
    return hr;
}

HRESULT CDynSchema::RulePropertiesHelper(
    const CColumnMeta*        i_pColumnMeta, 
    METABASE_PROPERTY**       o_ppMbp,
    ULONG*                    i_idxTag)
/*++

Synopsis: 
    This class creates a property and inserts it into the hashtable of props.
    PRECONDITION: The property does not exist in the hashtable yet.
    i_idxTag is null if you want to insert the property.  else you want to
    insert a tag, and *i_idxTag is the index of the tag

Arguments: [i_pColumnMeta] - 
           [o_ppMbp] - 
           [i_idxTag] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pColumnMeta     != NULL);
    DBG_ASSERT(o_ppMbp           != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    METABASE_PROPERTY* pMbp = NULL;
    
    hr = m_poolProps.GetNewElement(&pMbp);
    if(FAILED(hr))
    {
        goto exit;
    }

    if(i_idxTag == NULL)
    {
        pMbp->dwMDMask   = 0;
        hr = m_spoolStrings.GetNewString(
            i_pColumnMeta->ColumnMeta.pInternalName,
            &(pMbp->pszPropName));
        if(FAILED(hr))
        {
            goto exit;
        }
    }
    else
    {
        pMbp->dwMDMask   = *(i_pColumnMeta->paTags[*i_idxTag]->pValue);
        hr = m_spoolStrings.GetNewString(
            i_pColumnMeta->paTags[*i_idxTag]->pInternalName,
            &(pMbp->pszPropName));
        if(FAILED(hr))
        {
            goto exit;
        }
    }
    pMbp->dwMDIdentifier = *(i_pColumnMeta->ColumnMeta.pID);
    pMbp->dwMDUserType   = *(i_pColumnMeta->ColumnMeta.pUserType);

    switch(*(i_pColumnMeta->ColumnMeta.pType))
    {
    case eCOLUMNMETA_int32:
        if(fCOLUMNMETA_BOOL & *(i_pColumnMeta->ColumnMeta.pMetaFlags))
        {
            if(pMbp->dwMDMask == 0)
            {
                pMbp->dwMDMask = ALL_BITS_ON;
            }
        }
        pMbp->dwMDDataType   = DWORD_METADATA;
        pMbp->pDefaultValue  = NULL;
#ifdef USE_DEFAULT_VALUES
        if(i_pColumnMeta->ColumnMeta.pDefaultValue != NULL)
        {
            pMbp->dwDefaultValue = *((DWORD*)(i_pColumnMeta->ColumnMeta.pDefaultValue));
            pMbp->pDefaultValue  = &pMbp->dwDefaultValue;
        }
#endif
        break;
    case eCOLUMNMETA_String:
        if(fCOLUMNMETA_MULTISTRING & *(i_pColumnMeta->ColumnMeta.pMetaFlags))
        {
            pMbp->dwMDDataType   = MULTISZ_METADATA;
        }
        else if(fCOLUMNMETA_EXPANDSTRING & *(i_pColumnMeta->ColumnMeta.pMetaFlags))
        {
            pMbp->dwMDDataType   = EXPANDSZ_METADATA;
        }
        else
        {
            pMbp->dwMDDataType   = STRING_METADATA;
        }
        //
        // Default values.
        //
        pMbp->pDefaultValue = NULL;
#ifdef USE_DEFAULT_VALUES
        if(i_pColumnMeta->ColumnMeta.pDefaultValue != NULL)
        {
            if(pMbp->dwMDDataType != MULTISZ_METADATA)
            {
                hr = m_spoolStrings.GetNewString(
                    (LPWSTR)i_pColumnMeta->ColumnMeta.pDefaultValue,
                    (LPWSTR*)&pMbp->pDefaultValue);
                if(FAILED(hr))
                {
                    goto exit;
                }
            }
            else
            {
                bool  bLastCharNull = false;
                ULONG idx  = 0;
                ULONG iLen = 0;
                LPWSTR msz =  (LPWSTR)i_pColumnMeta->ColumnMeta.pDefaultValue;

                do
                {
                    bLastCharNull = msz[idx] == L'\0' ? true : false;
                }
                while( !(msz[++idx] == L'\0' && bLastCharNull) );
                iLen = idx+1;

                hr = m_spoolStrings.GetNewArray(
                    iLen,
                    (LPWSTR*)&pMbp->pDefaultValue);
                if(FAILED(hr))
                {
                    goto exit;
                }
                memcpy(
                    pMbp->pDefaultValue,
                    i_pColumnMeta->ColumnMeta.pDefaultValue,
                    sizeof(WCHAR)*iLen);
            }
        }
#endif
        break;
    case eCOLUMNMETA_BYTES:
        pMbp->dwMDDataType   = BINARY_METADATA;
        pMbp->pDefaultValue  = NULL;
#ifdef USE_DEFAULT_VALUES
#ifdef USE_DEFAULT_BINARY_VALUES
        if( i_pColumnMeta->ColumnMeta.pDefaultValue != NULL )
        {
            hr = m_apoolBytes.GetNewArray(
                i_pColumnMeta->cbDefaultValue,
                (BYTE**)&pMbp->pDefaultValue);
            if(FAILED(hr))
            {
                goto exit;
            }
            memcpy(
                pMbp->pDefaultValue,
                i_pColumnMeta->ColumnMeta.pDefaultValue,
                i_pColumnMeta->cbDefaultValue);
            //
            // Use dwDefaultValue to store the length.
            //
            pMbp->dwDefaultValue = i_pColumnMeta->cbDefaultValue;
        }
#endif
#endif
        break;
    default:
        pMbp->dwMDDataType   = -1;
        pMbp->pDefaultValue  = NULL;
        break;
    }
    pMbp->dwMDAttributes = *(i_pColumnMeta->ColumnMeta.pAttributes);
    if(*i_pColumnMeta->ColumnMeta.pSchemaGeneratorFlags &
        fCOLUMNMETA_CACHE_PROPERTY_MODIFIED)
    {
        pMbp->fReadOnly = FALSE;
    }
    else
    {
        pMbp->fReadOnly = TRUE;
    }

    hr = m_hashProps.Wmi_Insert(pMbp->pszPropName, pMbp);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    if(SUCCEEDED(hr))
    {
        *o_ppMbp = pMbp;
    }
    return hr;
}

bool CDynSchema::IgnoreProperty(
    METABASE_KEYTYPE* io_pkt,
    DWORD             i_dwPropId,
    DWORD             io_adwIgnored[])
/*++

Synopsis: 
    Checks to see if i_wszProp is in g_adwPropIgnoreList.
    If it is, sets next free element in io_adwIgnored to point to this.

Arguments: [i_wszProp] - 
           [io_adwIgnored] - Must be as big as g_adwPropIgnoreList.
                              Allocated AND must be memset to 0 by caller.
           
Return Value: 
    true if property is in the ignore list.
    false otherwise.

--*/
{
    DBG_ASSERT(io_pkt);

    if(g_adwPropIgnoreList == NULL)
    {
        return false;
    }

    if( io_pkt == &METABASE_KEYTYPE_DATA::s_IIsObject &&
        i_dwPropId == MD_KEY_TYPE )
    {
        return false;
    }

    for(ULONG i = 0; i < g_cElemPropIgnoreList; i++)
    {
        if(i_dwPropId == g_adwPropIgnoreList[i])
        {
            for(ULONG j = 0; j < g_cElemPropIgnoreList; j++)
            {
                if(io_adwIgnored[j] == NULL)
                {
                    io_adwIgnored[j] = g_adwPropIgnoreList[i];
                    break;
                }
            }
            return true;
        }
    }

    return false;
}

#if 0
bool CDynSchema::IgnoreProperty(LPCWSTR i_wszProp)
/*++

Synopsis: 
    Checks to see if i_wszProp is in g_adwPropIgnoreList

Arguments: [i_wszProp] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_wszProp != NULL);

    if(g_adwPropIgnoreList == NULL)
    {
        return false;
    }

    for(ULONG i = 0; i < g_cElemPropIgnoreList; i++)
    {
        if(_wcsicmp(i_wszProp, g_adwPropIgnoreList[i]) == 0)
        {
            return true;
        }
    }

    return false;
}
#endif


HRESULT CDynSchema::RuleGenericAssociations(
    WMI_CLASS*            i_pcElement, 
    WMI_CLASS*            i_pcSetting, 
    WMI_ASSOCIATION_TYPE* i_pAssocType,
    ULONG                 i_iShipped)
/*++

Synopsis: 
    Create the Element/Setting association.    

Arguments: [i_pcElement] - 
           [i_pcSetting] - 
           [i_iShipped] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pcElement       != NULL);
    DBG_ASSERT(i_pcSetting       != NULL);
    DBG_ASSERT(i_pAssocType      != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    LPWSTR wszElement = i_pcElement->pszClassName;
    LPWSTR wszSetting = i_pcSetting->pszClassName;
    LPWSTR wszParent  = NULL;
    LPWSTR wszAssocName;
    WMI_ASSOCIATION* pWmiAssoc;

    ULONG  cchElement = wcslen(wszElement);
    ULONG  cchSetting = wcslen(wszSetting);

    hr = m_spoolStrings.GetNewArray(cchElement+cchSetting+2+1, &wszAssocName);
    if(FAILED(hr))
    {
        goto exit;
    }
    wcscpy(wszAssocName, wszElement);
    wcscat(wszAssocName, L"_");
    wcscat(wszAssocName, wszSetting);

    hr = m_poolAssociations.GetNewElement(&pWmiAssoc);
    if(FAILED(hr))
    {
         goto exit;
    }

    if(i_iShipped == USER_DEFINED_TO_REPOSITORY ||
       i_iShipped == USER_DEFINED_NOT_TO_REPOSITORY)
    {
        wszParent = i_pAssocType->pszExtParent;
    }
    else
    {
        wszParent = i_pAssocType->pszParent;
    }

    pWmiAssoc->pszAssociationName   = wszAssocName;
    pWmiAssoc->pcLeft               = i_pcElement;
    pWmiAssoc->pcRight              = i_pcSetting;
    pWmiAssoc->pType                = i_pAssocType;
    pWmiAssoc->fFlags               = 0;
    pWmiAssoc->pszParentClass       = wszParent;
    pWmiAssoc->dwExtended           = i_iShipped;

    hr = m_hashAssociations.Wmi_Insert(wszAssocName, pWmiAssoc);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    return hr;
}

void CDynSchema::RuleWmiClassServices(
    WMI_CLASS* i_pElement,
    WMI_CLASS* i_pSetting)
/*++

Synopsis: 
    Sets the bCreateAllowed fields to false if necessary.
    i_pSetting must be the corresponding Setting class to i_pElement.

    Also sets i_pElement->pszParentClass

Arguments: [i_pElement] - 
           [i_pSetting] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pElement        != NULL);
    DBG_ASSERT(i_pSetting        != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    //
    // Element Class Suffixes for which Create will be disallowed
    //
    static LPCWSTR const wszService = L"Service";
    static const ULONG   cchService = wcslen(wszService);

    //
    // We only care about shipped classes
    //
    if( i_pElement->dwExtended != SHIPPED_TO_MOF &&
        i_pElement->dwExtended != SHIPPED_NOT_TO_MOF )
    {
        return;
    }

    ULONG cchElement = wcslen(i_pElement->pszClassName);

    if( cchElement >= cchService &&
        _wcsicmp(wszService, &i_pElement->pszClassName[cchElement-cchService]) == 0 )
    {
        i_pElement->bCreateAllowed = false;
        i_pElement->pszParentClass = L"Win32_Service";
        i_pSetting->bCreateAllowed = false;
    }
}

HRESULT CDynSchema::RuleWmiClassInverseCCL(
    const METABASE_KEYTYPE* pktGroup, 
    METABASE_KEYTYPE*       pktPart)
/*++

Synopsis: 
    Adds pktGroup to pktPart's inverse container class list

Arguments: [pktGroup] - 
           [pktPart] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(pktGroup          != NULL);
    DBG_ASSERT(pktPart           != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    METABASE_KEYTYPE_NODE* pktnode = NULL;

    hr = m_poolKeyTypeNodes.GetNewElement(&pktnode);
    if(FAILED(hr))
    {
        goto exit;
    }

    pktnode->m_pKt               = pktGroup;
    pktnode->m_pKtNext           = pktPart->m_pKtListInverseCCL;

    pktPart->m_pKtListInverseCCL = pktnode;

exit:
    return hr;
}

HRESULT CDynSchema::RuleGroupPartAssociations(
    const CTableMeta *i_pTableMeta)
/*++

Synopsis: 
    Walks thru container class list to create Group/Part associations.
    Also calls RuleWmiClassInverseCCL for each contained class to create inverse
    container class list.

Arguments: [i_pTableMeta] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pTableMeta      != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    WMI_ASSOCIATION *pWmiAssoc;
    WMI_CLASS       *pWmiClassLeft;
    WMI_CLASS       *pWmiClassRight;

    LPWSTR wszCCL        = NULL;    // Needs to be cleaned up
    LPWSTR wszGroupClass = NULL;    // Ptr to catalog
    LPWSTR wszPartClass  = NULL;    // Ptr to catalog
    LPWSTR wszAssocName  = NULL;    // Ptr to pool
    LPWSTR wszTemp       = NULL;    // Needs to be cleaned up

    static LPCWSTR wszSeps = L", ";

    ULONG cchGroupClass = 0;
    ULONG cchPartClass  = 0;
    ULONG cchCCL        = 0;

    wszGroupClass = i_pTableMeta->TableMeta.pInternalName;
    cchGroupClass = wcslen(wszGroupClass);
    hr = m_hashClasses.Wmi_GetByKey(wszGroupClass, &pWmiClassLeft);
    if(FAILED(hr))
    {
        goto exit;
    }

    if(i_pTableMeta->TableMeta.pContainerClassList &&
       i_pTableMeta->TableMeta.pContainerClassList[0] != L'\0')
    {   
        //
        // Make copy of CCL so we can wcstok
        // 
        cchCCL = wcslen(i_pTableMeta->TableMeta.pContainerClassList);
        wszCCL = new WCHAR[cchCCL+1];
        if(wszCCL == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
        memcpy(wszCCL, i_pTableMeta->TableMeta.pContainerClassList, sizeof(WCHAR)*(cchCCL+1));

        //
        // we will use wszTemp to construct assoc name (GroupClass_PartClass)
        //
        wszTemp = new WCHAR[cchGroupClass+1+cchCCL+1];
        if(wszTemp == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }

        for(wszPartClass =  wcstok(wszCCL, wszSeps); 
            wszPartClass != NULL; 
            wszPartClass =  wcstok(NULL, wszSeps))
        {
            hr = m_hashClasses.Wmi_GetByKey(wszPartClass, &pWmiClassRight);
            if(FAILED(hr))
            {
                //
                // This just means there is a class in the container list that
                // doesn't exist.
                //
                hr = WBEM_S_NO_ERROR;
                continue;
            }

            //
            // Construct association name
            //
            cchPartClass = wcslen(wszPartClass);
            memcpy(wszTemp,               wszGroupClass, sizeof(WCHAR)*cchGroupClass);
            memcpy(wszTemp+cchGroupClass, L"_",          sizeof(WCHAR));
            memcpy(
                wszTemp + cchGroupClass + 1, 
                wszPartClass, 
                sizeof(WCHAR)*(cchPartClass+1));

            hr = m_hashAssociations.Wmi_GetByKey(wszTemp, &pWmiAssoc);
            if(SUCCEEDED(hr))
            {
                if( pWmiClassLeft->dwExtended  != USER_DEFINED_TO_REPOSITORY &&
                    pWmiClassLeft->dwExtended  != USER_DEFINED_NOT_TO_REPOSITORY &&
                    pWmiClassRight->dwExtended != USER_DEFINED_TO_REPOSITORY &&
                    pWmiClassRight->dwExtended != USER_DEFINED_NOT_TO_REPOSITORY )
                {
                    //
                    // This means we already put this shipped association in, but it is
                    // not a conflict.
                    // We need this because this method is called twice for each
                    // group class.
                    //
                    continue;
                }
            }
            hr = WBEM_S_NO_ERROR;

            //
            // TODO: Move this outside?
            //
            hr = RuleWmiClassInverseCCL(pWmiClassLeft->pkt, pWmiClassRight->pkt);
            if(FAILED(hr))
            {
                goto exit;
            }

            hr = m_spoolStrings.GetNewString(
                wszTemp,
                cchGroupClass+1+cchPartClass, // cch
                &wszAssocName);
            if(FAILED(hr))
            {
                goto exit;
            }

            hr = m_poolAssociations.GetNewElement(&pWmiAssoc);
            if(FAILED(hr))
            {
                goto exit;
            }

            pWmiAssoc->pszAssociationName = wszAssocName;
            pWmiAssoc->pcLeft = pWmiClassLeft;
            pWmiAssoc->pcRight = pWmiClassRight;
            pWmiAssoc->pType = &WMI_ASSOCIATION_TYPE_DATA::s_Component;
            pWmiAssoc->fFlags = 0;            

            if( pWmiClassLeft->dwExtended  == EXTENDED || 
                pWmiClassLeft->dwExtended  == USER_DEFINED_TO_REPOSITORY ||
                pWmiClassRight->dwExtended == EXTENDED ||
                pWmiClassRight->dwExtended == USER_DEFINED_TO_REPOSITORY)
            {
                pWmiAssoc->pszParentClass = g_wszExtGroupPartAssocParent;
                pWmiAssoc->dwExtended     = USER_DEFINED_TO_REPOSITORY;
            }
            else
            {
                pWmiAssoc->pszParentClass = g_wszGroupPartAssocParent;
                pWmiAssoc->dwExtended     = SHIPPED_TO_MOF;
            }
            hr = m_hashAssociations.Wmi_Insert(wszAssocName, pWmiAssoc);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
    }

exit:
    delete [] wszCCL;
    delete [] wszTemp;
    return hr;
}

HRESULT CDynSchema::RuleSpecialAssociations(
    DWORD      i_adwIgnoredProps[],
    WMI_CLASS* i_pElement)
/*++

Synopsis: 
    Creates IPSecurity and AdminACL associations

Arguments: [i_adwIgnoredProps[]] - 
           [i_pElement] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pElement != NULL);
    
    HRESULT hr                   = WBEM_S_NO_ERROR;
    bool    bCreateIPSecAssoc    = false;
    bool    bCreateAdminACLAssoc = false;
    DWORD   dwExtended = SHIPPED_TO_MOF;

    if(i_pElement->dwExtended != SHIPPED_TO_MOF && i_pElement->dwExtended != EXTENDED && 
       i_pElement->dwExtended != USER_DEFINED_TO_REPOSITORY)
    {
        return hr;
    }

    if (USER_DEFINED_TO_REPOSITORY == i_pElement->dwExtended)
    {
        dwExtended = USER_DEFINED_TO_REPOSITORY;
    }

    for(ULONG i = 0; 
        i < g_cElemPropIgnoreList && i_adwIgnoredProps[i] != 0;
        i++)
    {
        if(i_adwIgnoredProps[i] == MD_IP_SEC)
        {
            bCreateIPSecAssoc = true;
        }
        else if(i_adwIgnoredProps[i] == MD_ADMIN_ACL)
        {
            bCreateAdminACLAssoc = true;
        }
    }

    if(bCreateIPSecAssoc)
    {
        hr = RuleGenericAssociations(
            i_pElement,
            &WMI_CLASS_DATA::s_IPSecurity,
            &WMI_ASSOCIATION_TYPE_DATA::s_IPSecurity,
            dwExtended);
        if(FAILED(hr))
        {
            return hr;
        }
    }

    if(bCreateAdminACLAssoc)
    {
        hr = RuleGenericAssociations(
            i_pElement,
            &WMI_CLASS_DATA::s_AdminACL,
            &WMI_ASSOCIATION_TYPE_DATA::s_AdminACL,
            dwExtended);
        if(FAILED(hr))
        {
            return hr;
        }
    }

    return hr;
}

HRESULT CDynSchema::ConstructFlatInverseContainerList()
/*++

Synopsis: 
    Constructs an "inverse flat container class list".
    This list is stored in m_abKtContainers, an array of size iNumKeys*iNumKeys.
    The first iNumKeys entries are for Key #1 and then so on.  Let's call this row 1.
    In row 1, entry i corresponds to Key #i.
    This entry [1,i] is set to true if Key #1 can be contained somewhere under Key #i.
    For instance, [IIsWebDirectory, IIsWebService] is true since an IIsWebService
    can contain an IIsWebServer which can contain an IIsWebDirectory.

Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);

    ULONG iNumKeys = m_hashKeyTypes.Wmi_GetNumElements();

    m_abKtContainers = new bool[iNumKeys * iNumKeys];
    if(m_abKtContainers == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    memset(m_abKtContainers, 0, iNumKeys * iNumKeys * sizeof(bool));

    CHashTable<METABASE_KEYTYPE*>::iterator iter;
    CHashTable<METABASE_KEYTYPE*>::iterator iterEnd = m_hashKeyTypes.end();
    for (iter = m_hashKeyTypes.begin(); iter != iterEnd; ++iter)
    {
        CHashTable<METABASE_KEYTYPE*>::Record* pRec = iter.Record();
        METABASE_KEYTYPE_NODE* pktnode = pRec->m_data->m_pKtListInverseCCL;
        while(pktnode != NULL)
        {
            ConstructFlatInverseContainerListHelper(
                pktnode->m_pKt, 
                &m_abKtContainers[pRec->m_idx * iNumKeys]);
            pktnode = pktnode->m_pKtNext;
        }
    }

    return WBEM_S_NO_ERROR;
}

//
// TODO: Prove this will always terminate.
//
void CDynSchema::ConstructFlatInverseContainerListHelper(
    const METABASE_KEYTYPE* i_pkt, 
    bool*                   io_abList)
/*++

Synopsis: 
    This walks the inverse container class list of i_pkt.
    For each entry, we call ConstructFlatInverseContainerListHelper and mark all the keytypes
    we see on the way.
    We terminate when we hit a keytype we've already seen or if there are no more keytypes
    in the inverse container class list.

Arguments: [i_pkt] - 
           [io_abList] - 
           
--*/
{
    DBG_ASSERT(m_bInitCalled == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pkt != NULL);
    DBG_ASSERT(io_abList != NULL);

    ULONG idx;
    METABASE_KEYTYPE* pktDummy;
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = m_hashKeyTypes.Wmi_GetByKey(i_pkt->m_pszName, &pktDummy, &idx);
    if(FAILED(hr))
    {
        DBG_ASSERT(false && "Keytype should be in hashtable of keytypes");
        return;
    }
    if(io_abList[idx] == true) return;

    io_abList[idx] = true;

    METABASE_KEYTYPE_NODE* pktnode = i_pkt->m_pKtListInverseCCL;
    while(pktnode != NULL)
    {
        ConstructFlatInverseContainerListHelper(pktnode->m_pKt, io_abList);
        pktnode = pktnode->m_pKtNext;
    }
}

bool CDynSchema::IsContainedUnder(METABASE_KEYTYPE* i_pktParent, METABASE_KEYTYPE* i_pktChild)
/*++

Synopsis: 
    Uses m_abKtContainers described above to determine whether i_pktChild can
    be contained somewhere under i_pktParent.

Arguments: [i_pktParent] - 
           [i_pktChild] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pktParent       != NULL);
    DBG_ASSERT(i_pktChild        != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    METABASE_KEYTYPE* pktDummy;
    ULONG idxParent;
    ULONG idxChild;

    hr = m_hashKeyTypes.Wmi_GetByKey(i_pktParent->m_pszName, &pktDummy, &idxParent);
    if(FAILED(hr))
    {
        return false;
    }
    hr = m_hashKeyTypes.Wmi_GetByKey(i_pktChild->m_pszName, &pktDummy, &idxChild);
    if(FAILED(hr))
    {
        return false;
    }

    return m_abKtContainers[idxChild * m_hashKeyTypes.Wmi_GetNumElements() + idxParent];
}

void CDynSchema::ToConsole()
{
    DBG_ASSERT(m_bInitCalled == true);
    DBG_ASSERT(m_bInitSuccessful == true);

    /*CHashTableElement<WMI_CLASS *>* pElement;
    m_hashClasses.Enum(NULL, &pElement);
    while(pElement != NULL)
    {
        wprintf(L"%s\n", pElement->m_data->pszClassName);
        // wprintf(L"\tShipped: %d\n", pElement->m_iShipped);
        wprintf(L"\tKT: %s\n", pElement->m_data->pkt->m_pszName);
        wprintf(L"\tKN: %s\n", pElement->m_data->pszKeyName);
        wprintf(L"\tMK: %s\n", pElement->m_data->pszMetabaseKey);
        METABASE_PROPERTY** ppmbp = pElement->m_data->ppmbp;
        for(ULONG q = 0; ppmbp != NULL && ppmbp[q] != NULL; q++)
        {
            wprintf(L"\tProp: %s\n", ppmbp[q]->pszPropName);
        }
        pElement = pElement->m_pNext;
    }


    ULONG i;

    m_hashKeyTypes.ToConsole();

    WMI_CLASS *pWmiClass;
    for(i = 0; i < m_poolClasses.GetUsed(); i++)
    {
        pWmiClass = m_poolClasses.Lookup(i);
        wprintf( L"%s KT: %d\n", pWmiClass->pszClassName, pWmiClass->pkt );
        for(ULONG j = 0; ; j++)
        {
            if(pWmiClass->ppmbp[j] == NULL)
            {
                break;
            }
            wprintf(L"\t%s\tId: %d\tUT: %d\tDT: %d\tMSK: %d\tAttr: %d\tRO: %d\n", 
                pWmiClass->ppmbp[j]->pszPropName,
                pWmiClass->ppmbp[j]->dwMDIdentifier,
                pWmiClass->ppmbp[j]->dwMDUserType,
                pWmiClass->ppmbp[j]->dwMDDataType,
                pWmiClass->ppmbp[j]->dwMDMask,
                pWmiClass->ppmbp[j]->dwMDAttributes,
                pWmiClass->ppmbp[j]->fReadOnly);
        }
    }
    WMI_ASSOCIATION *pWmiAssoc;
    for(i = 0; i < m_poolAssociations.GetUsed(); i++)
    {
        pWmiAssoc = m_poolAssociations.Lookup(i);
        wprintf(L"%s\n", pWmiAssoc->pszAssociationName);
        wprintf(L"\t%s\n\t%s\n",
            pWmiAssoc->pcLeft->pszClassName,
            pWmiAssoc->pcRight->pszClassName);
    }

    for(unsigned int q = 0; q < m_poolProps.GetUsed(); q++)
    {
        METABASE_PROPERTY* qt = m_poolProps.Lookup(q);
        wprintf(L"%s\n", qt->pszPropName);
    }*/
}

HRESULT CDynSchema::RulePopulateFromDynamic(
    CSchemaExtensions* i_pCatalog,
    BOOL               i_bUserDefined)
{
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pCatalog        != NULL);

    HRESULT hr                = WBEM_S_NO_ERROR;
    ULONG i                   = 0;
    CTableMeta* pTableMeta    = NULL;
    WMI_CLASS*  pElementClass = NULL;
    WMI_CLASS*  pSettingClass = NULL;
    DWORD       adwIgnoredProps[g_cElemPropIgnoreList];

    DWORD       dwUserDefined = 0;

    while(pTableMeta = i_pCatalog->EnumTables(&i))
    {
        dwUserDefined =
            (fTABLEMETA_USERDEFINED & *pTableMeta->TableMeta.pSchemaGeneratorFlags);
        if( (i_bUserDefined && !dwUserDefined) || (!i_bUserDefined && dwUserDefined) )
        {
            continue;
        }

        memset(adwIgnoredProps, 0, g_cElemPropIgnoreList*sizeof(DWORD));
        pElementClass = NULL;
        pSettingClass = NULL;

        hr = RuleKeyType(pTableMeta);
        if(FAILED(hr))
        {
            return hr;
        }

        DBG_ASSERT(pTableMeta->TableMeta.pInternalName);
        hr = RuleWmiClass(
            pTableMeta, 
            &pElementClass, 
            &pSettingClass, 
            adwIgnoredProps,
            i_bUserDefined);
        if(FAILED(hr))
        {
             return hr;
        }
        DBG_ASSERT(pElementClass != NULL);
        DBG_ASSERT(pSettingClass != NULL);

        if ( (NULL == pElementClass) || (NULL == pSettingClass) )
        {
            return E_FAIL;
        }

        hr = RuleGenericAssociations(
            pElementClass, 
            pSettingClass, 
            &WMI_ASSOCIATION_TYPE_DATA::s_ElementSetting,
            pElementClass->dwExtended);
        if(FAILED(hr))
        {
            return hr;
        }

        hr = RuleSpecialAssociations(
            adwIgnoredProps,
            pElementClass);
        if(FAILED(hr))
        {
            return hr;
        }

        RuleWmiClassServices(pElementClass, pSettingClass);

        hr = RuleWmiClassDescription(pTableMeta, pElementClass, pSettingClass);
        if(FAILED(hr))
        {
            return hr;
        }
    }

    i = 0;
    while(pTableMeta = i_pCatalog->EnumTables(&i))
    {
        dwUserDefined =
            (fTABLEMETA_USERDEFINED & *pTableMeta->TableMeta.pSchemaGeneratorFlags);

        if(!i_bUserDefined && dwUserDefined)
        {
            continue;
        }

        hr = RuleGroupPartAssociations(pTableMeta);
        if(FAILED(hr))
        {
            return hr;
        }
    }

    return hr;
}

HRESULT CDynSchema::RunRules(
    CSchemaExtensions* i_pCatalog, 
    bool               i_bUseExtensions)
/*++

Synopsis: 
    Does all the work

Arguments: [i_pCatalog] - This function calls Initialize.
                       Don't call Init outside this function.
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pCatalog        != NULL);

    HRESULT hr                = S_OK;
    ULONG i                   = 0;

    //
    // TODO: Don't think I need this
    //
    if(m_bRulesRun)
    {
        return hr;
    }

    hr = RulePopulateFromStatic();
    if(FAILED(hr))
    {
        return hr;
    }

    hr = Rule2PopulateFromStatic();
    if(FAILED(hr))
    {
        return hr;
    }

    hr = i_pCatalog->Initialize(i_bUseExtensions);
    if(FAILED(hr))
    {
        return hr;
    }

    hr = RulePopulateFromDynamic(
        i_pCatalog, 
        false);     // shipped schema
    if(FAILED(hr))
    {
        return hr;
    }
    hr = RulePopulateFromDynamic(
        i_pCatalog, 
        true);      // user-defined schema
    if(FAILED(hr))
    {
        return hr;
    }

    hr = ConstructFlatInverseContainerList();

    if(SUCCEEDED(hr))
    {
        m_bRulesRun = true;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\utils.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    General purpose utilities

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#ifndef _utils_h_
#define _utils_h_


#define MAX_BUF_SIZE         1024
#define MAX_KEY_NAME_SIZE      32
#define MAX_KEY_TYPE_SIZE      32

#include "WbemServices.h"
#include "schema.h"
#include <wbemprov.h>
#include <windows.h>
#include <comutil.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <dbgutil.h>
#include <atlbase.h>

class CUtils
{
public:
    //
    // Wrappers for commonly used WMI operations
    //
    static HRESULT CreateEmptyMethodInstance(
        CWbemServices*     i_pNamespace,
        IWbemContext*      i_pCtx,
        LPCWSTR            i_wszClassName,
        LPCWSTR            i_wszMethodName,
        IWbemClassObject** o_ppMethodInstance);

    static HRESULT GetQualifiers(
        IWbemClassObject* i_pClass,
        LPCWSTR*          i_awszQualNames,
        VARIANT*          io_aQualValues,
        ULONG             i_NrQuals);

    static HRESULT GetPropertyQualifiers(
        IWbemClassObject* i_pClass,
        LPCWSTR i_wszPropName,
        DWORD*  io_pdwQuals);

    static HRESULT SetQualifiers(
        IWbemClassObject* i_pClass,
        LPCWSTR*          i_awszQualNames,
        VARIANT*          i_avtQualValues,
        ULONG             i_iNrQuals,
        ULONG             i_iFlags);
    
    static HRESULT SetMethodQualifiers(
        IWbemClassObject* i_pClass,
        LPCWSTR           i_wszMethName,
        LPCWSTR*          i_awszQualNames,
        VARIANT*          i_avtQualValues,
        ULONG             i_iNrQuals);

    static HRESULT SetPropertyQualifiers(
        IWbemClassObject* i_pClass,
        LPCWSTR i_wszPropName,
        LPCWSTR* i_awszQualNames,
        VARIANT* i_avtQualValues,
        ULONG i_iNrQuals);

    static HRESULT CreateEmptyInstance(
        LPWSTR i_wszClass,
        CWbemServices* i_pNamespace,
        IWbemClassObject** o_ppInstance);

    //
    // Retrieval from schema
    //
    static bool GetClass(
        LPCWSTR i_wszClassName,
        WMI_CLASS** o_ppClass);

    static bool GetAssociation(
        LPCWSTR i_wszAssocName, 
        WMI_ASSOCIATION** o_ppAssoc);

    static bool GetMethod(
        LPCWSTR         i_wszMethod,
        WMI_METHOD**    i_apMethodList,
        WMI_METHOD**    o_ppMethod);

    //
    // Data conversion/comparison
    //
    static bool CompareKeyType(
        LPCWSTR           i_wszKeyFromMb,
        METABASE_KEYTYPE* i_pktKeyCompare);

    static bool CompareMultiSz(
        WCHAR*       i_msz1,
        WCHAR*       i_msz2);

    static HRESULT CreateByteArrayFromSafeArray(
        _variant_t&  i_vt,
        LPBYTE*      o_paBytes,
        DWORD*       io_pdw);

    static HRESULT LoadSafeArrayFromByteArray(
        LPBYTE       i_aBytes,
        DWORD        i_iBytes,
        _variant_t&  io_vt);

    static bool CompareByteArray(
        LPBYTE       i_aBytes1,
        ULONG        i_iBytes1,
        LPBYTE       i_aBytes2,
        ULONG        i_iBytes2
        );

    static BSTR ExtractBstrFromVt(
        const VARIANT* i_pvt,
        LPCWSTR        i_wszVtName=NULL);

    static LONG ExtractLongFromVt(
        const VARIANT* i_pvt,
        LPCWSTR        i_wszVtName=NULL);

    //
    // Other
    //
    static KeyRef* GetKey(
        ParsedObjectPath* i_pParsedObjectPath, 
        WCHAR* i_wsz);

    static void GetMetabasePath(
        IWbemClassObject* i_pObj,
        ParsedObjectPath* i_pParsedObjectPath,    
        WMI_CLASS*        i_pClass,
        _bstr_t&          io_bstrPath);

    static HRESULT GetParentMetabasePath(
        LPCWSTR i_wszChildPath,
        LPWSTR  io_wszParentPath);

    static HRESULT ConstructObjectPath(
        LPCWSTR          i_wszMbPath,
        const WMI_CLASS* i_pClass,
        BSTR*            o_pbstrPath);

    static void FileTimeToWchar(
        FILETIME* i_pFileTime, 
        LPWSTR io_wszDateTime);

    //
    // For exception handling and/or errors
    //
    static HRESULT ParserErrToHR(DWORD i_dwErr)
    {
        switch(i_dwErr)
        {
        case CObjectPathParser::NoError:
            break;
        case CObjectPathParser::OutOfMemory:
            return WBEM_E_OUT_OF_MEMORY;
        default:
            return WBEM_E_INVALID_OBJECT;
        }

        return WBEM_S_NO_ERROR;
    }

    static void HRToText(
        HRESULT i_hr,
        BSTR*   o_pbstrText);

    static void MessageCodeToText(
        DWORD    i_dwMC,
        va_list* i_pArgs,
        BSTR*    o_pbstrText);

    static void Throw_Exception(HRESULT, METABASE_PROPERTY*);
};



class CIIsProvException
{
public:
    CIIsProvException() :
      m_hr(0),
      m_bErrorSet(false)
    {
    }

    ~CIIsProvException()
    {
    }

    void SetHR(HRESULT i_hr, LPCWSTR i_wszParams=NULL)
    /*++

    Synopsis: 

    Arguments: [i_hr] -             The HR
               [i_wszParams=NULL] - The param field of __ExtendedStatus
           
    --*/
    {
        DBG_ASSERT(m_bErrorSet == false);
        m_hr               = i_hr;
        m_sbstrParams      = i_wszParams;

        m_bErrorSet        = true;

        ConstructStringFromHR(i_hr);
    }

    void SetMC(HRESULT i_hr, DWORD i_dwMC, LPCWSTR i_wszParams, ...)
    /*++

    Synopsis: 

    Arguments: [i_hr] -         The HR
               [i_dwMC] -       The MC code
               [i_wszParams] -  The param field of __ExtendedStatus
               [...] -          The args for the MC error string
           
    --*/
    {
        DBG_ASSERT(m_bErrorSet == false);
        m_hr               = i_hr;
        m_sbstrParams      = i_wszParams;

        va_list (marker);
        va_start(marker, i_wszParams);

        m_bErrorSet        = true;

        ConstructStringFromMC(i_dwMC, &marker);
    }

    //
    // For getting errors (Get text representation, hr, and culprit param)
    // These are fields of __Extended Status
    //

    HRESULT GetHR() const
    {
        DBG_ASSERT(m_bErrorSet == true);
        return m_hr;
    }

    BSTR GetParams() const
    {
        DBG_ASSERT(m_bErrorSet == true);
        return m_sbstrParams;
    }

    BSTR GetErrorText() const
    {
        DBG_ASSERT(m_bErrorSet == true);
        return m_sbstrError;
    }

private:
    void ConstructStringFromHR(
        HRESULT i_hr)
    {
        DBG_ASSERT(m_bErrorSet == true);

        //
        // If this fails, m_sbstrError will be NULL.  This is okay.
        //
        CUtils::HRToText(i_hr, &m_sbstrError);
    }

    void ConstructStringFromMC(
        DWORD    i_dwMC,
        va_list* i_pArgs)
    {
        DBG_ASSERT(m_bErrorSet == true);
        
        //
        // If this fails, m_sbstrError will be NULL.  This is okay.
        //
        CUtils::MessageCodeToText(i_dwMC, i_pArgs, &m_sbstrError);
    }

    //
    // These are fields of __ExtendedStatus
    //
    HRESULT  m_hr;
    CComBSTR m_sbstrParams;
    CComBSTR m_sbstrError;

    //
    // Used just for assert
    //
    bool     m_bErrorSet;
};


#define THROW_ON_FALSE(b)               \
    if (!b)                             \
        throw((HRESULT)WBEM_E_FAILED);

// if client cancelled, stop and return successfully
#define THROW_ON_ERROR(hr)              \
    if (FAILED(hr))                     \
    {                                   \
        DBGPRINTF((DBG_CONTEXT, "FAILED: hr = %x\n", hr)); \
        throw(hr == WBEM_E_CALL_CANCELLED ? WBEM_NO_ERROR : (HRESULT)hr); \
    }                                                                     \

#define THROW_E_ON_ERROR(hr, pmbp)          \
    if (FAILED(hr))                         \
    {                                       \
        CUtils::Throw_Exception(hr, pmbp);  \
    }

#define EXIT_ON_ERROR(hr)                   \
    if(FAILED(hr))                          \
    {                                       \
        goto exit;                          \
    }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\smartpointer.h ===
//  Copyright (C) 1999 Microsoft Corporation.  All rights reserved.

//This pointer class wraps a pointer so that delete happens automatically when the TSmartPointer goes out of scope
//If this is not the behavior you want then don't use this wrapper class


#ifndef __SMARTPOINTER_H__
#define __SMARTPOINTER_H__

#ifndef ASSERT
    #define ASSERT(x)
#endif

//Destructor is NOT virtual bacause I don't see why anyone would ever treat a TSmartPointerArray as a TSmartPointer

#pragma warning(disable : 4284)//It's OK to use this SmartPointer class with native types; but the -> operator doesn't make sense.  Compiler warns of this.

template <class T> class TSmartPointer
{
public:
    TSmartPointer()                     : m_p(0) {}
    TSmartPointer(T* p)                 : m_p(p) {}
    ~TSmartPointer()                    { Delete();}

    operator T*() const                 { return m_p; }
    T& operator*() const                { ASSERT(0!=m_p); return *m_p; }

    T** operator&()                     { ASSERT(0==m_p); return &m_p; }
    T* operator->() const               { ASSERT(0!=m_p); return m_p; }
    T* operator=(T* p)                  { return (m_p = p); }
    bool operator!() const              { return (0 == m_p); }
    bool operator==(const T* p) const   { return m_p == p; }

    void Delete()                       { delete m_p; m_p=0; }

    T* m_p;
private:
    TSmartPointer(const TSmartPointer<T>& p)    {}//This is private bacause it doesn't make sense to automatically clean up a copy of the pointer
};


template <class T> class TSmartPointerArray : public TSmartPointer<T>
{
public:
    TSmartPointerArray(T *p)            : TSmartPointer<T>(p) {}
    TSmartPointerArray()                : TSmartPointer<T>() {}
    ~TSmartPointerArray()               { Delete();}

    T* operator++()                     { ASSERT(0!=m_p); return ++m_p; }
    T* operator+=(int n)                { ASSERT(0!=m_p); return (m_p+=n); }
    T* operator-=(int n)                { ASSERT(0!=m_p); return (m_p-=n); }
    T* operator--()                     { ASSERT(0!=m_p); return --m_p; }
//    T& operator[](int n) const          { ASSERT(0!=m_p); return m_p[n]; }
    bool operator<(const T* p) const    { return m_p < p; }
    bool operator>(const T* p) const    { return m_p > p; }
    bool operator<=(const T* p) const   { return m_p <= p; }
    bool operator>=(const T* p) const   { return m_p >= p; }
    T* operator=(T p[])                 { return (m_p = p); }

    void Delete()                       { delete [] m_p; m_p=0; }
private:
    TSmartPointerArray(const TSmartPointerArray<T>& p)    {}//This is private bacause it doesn't make sense to automatically clean up a copy of the pointer
};


#endif //__SMARTPOINTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\webservicemethod.cpp ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    ServiceMethod.cpp

Abstract:

    Implements the CServiceMethod class.

    All the methods in this class return HRESULTs and do not throw exceptions.

Author:

    Mohit Srivastava            25-March-01

Revision History:

--*/

#include "WebServiceMethod.h"
#include "MultiSzHelper.h"
#include "Utils.h"
#include "SmartPointer.h"

#include <dbgutil.h>
#include <iiscnfg.h>
#include <atlbase.h>
#include <iwamreg.h>

CServiceMethod::CServiceMethod(
    eSC_SUPPORTED_SERVICES i_eServiceId)
{
    m_bInit         = false;
    m_pSiteCreator  = NULL;
    m_eServiceId    = i_eServiceId;

    DBG_ASSERT(m_eServiceId == SC_W3SVC || m_eServiceId == SC_MSFTPSVC);
}

CServiceMethod::~CServiceMethod()
{
    if(m_pSiteCreator)
    {
        delete m_pSiteCreator;
        m_pSiteCreator = NULL;
    }
}


HRESULT CServiceMethod::Init()
/*++

Synopsis: 
    Should be called immediately after constructor.

Return Value: 

--*/
{
    DBG_ASSERT(m_bInit == false);

    m_pSiteCreator = new CSiteCreator();
    if(m_pSiteCreator == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_bInit = true;

    return WBEM_S_NO_ERROR;
}


HRESULT CServiceMethod::CreateNewSite(
    LPCWSTR        i_wszServerComment,
    PDWORD         o_pdwSiteId,
    PDWORD         i_pdwRequestedSiteId)    // default value NULL
/*++

Synopsis: 
    This is the CreateNewSite called when someone does a Put on a Server w/o
    specifying a SiteId.

Arguments: [o_pdwSiteId] - 
           [i_pdwRequestedSiteId] - 
           
Return Value: 
    HRESULT

--*/
{
    DBG_ASSERT(m_bInit);
    DBG_ASSERT(o_pdwSiteId != NULL);

    HRESULT hr                   = S_OK;

    //
    // Call API
    //
    hr = m_pSiteCreator->CreateNewSite(
        m_eServiceId,
        (i_wszServerComment == NULL) ? L"" : i_wszServerComment,
        o_pdwSiteId,
        i_pdwRequestedSiteId);

    return hr;
}

HRESULT CServiceMethod::CreateNewSite(
    CWbemServices*     i_pNamespace,
    LPCWSTR            i_wszMbPath,
    IWbemContext*      i_pCtx,
    WMI_CLASS*         i_pClass,
    WMI_METHOD*        i_pMethod,
    IWbemClassObject*  i_pInParams,
    IWbemClassObject** o_ppRetObj)
/*++

Synopsis: 
    This is the CreateNewSite called by the WMI Method of the same name.

Arguments: [i_pNamespace] -
           [i_wszMbPath] -  needed for creating WMI return object
           [i_pCtx] -       needed for creating WMI return object
           [i_pClass] -     needed for creating WMI return object
           [i_pMethod] -    needed for creating WMI return object
           [i_pInParams] - 
           [o_ppRetObj] - 
           
Return Value: 
    HRESULT

--*/
{
    DBG_ASSERT(m_bInit);
    DBG_ASSERT(i_pNamespace    != NULL);
    DBG_ASSERT(i_wszMbPath     != NULL);
    DBG_ASSERT(i_pCtx          != NULL);
    DBG_ASSERT(i_pClass        != NULL);
    DBG_ASSERT(i_pMethod       != NULL);
    DBG_ASSERT(i_pInParams     != NULL);
    DBG_ASSERT(o_ppRetObj      != NULL);
    DBG_ASSERT(*o_ppRetObj     == NULL);

    HRESULT     hr = WBEM_S_NO_ERROR;
    CComVariant vtServerId, vtServerComment, vtServerBindings, vtPath;

    //
    // get in params
    //
    hr = InternalGetInParams(
        i_pInParams, 
        vtServerId, 
        vtServerComment, 
        vtServerBindings, 
        vtPath);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Set pdwRequestedSite based on whether the user specified a site
    //
    DWORD  dwRequestedSiteId  = 0;
    PDWORD pdwRequestedSiteId = NULL;
    if(vtServerId.vt == VT_I4)
    {
        pdwRequestedSiteId = &dwRequestedSiteId;
        dwRequestedSiteId  = vtServerId.lVal;
    }

    //
    // Create the new site
    //
    CComPtr<IIISApplicationAdmin> spAppAdmin;
    if(m_eServiceId == SC_W3SVC)
    {
        hr = CoCreateInstance(
            CLSID_WamAdmin,
            NULL,
            CLSCTX_ALL,
            IID_IIISApplicationAdmin,
            (void**)&spAppAdmin);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "[%s] CoCreateInstance failed, hr=0x%x\n", __FUNCTION__, hr));
            return hr;
        }
    }

    DWORD dwSiteId = 0;
    hr = InternalCreateNewSite(
        *i_pNamespace,
        vtServerComment,
        vtServerBindings,
        vtPath,
        spAppAdmin,
        &dwSiteId,
        pdwRequestedSiteId);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "[%s] InternalCreateNewSite failed, hr=0x%x\n", __FUNCTION__, hr));
        return hr;
    }

    //
    // convert dwSiteId to a metabase path
    //
    WCHAR wszServerId[11] = {0};
    _itow(dwSiteId, wszServerId, 10);

    SIZE_T        cchMbPath               = wcslen(i_wszMbPath);
    SIZE_T        cchServerId             = wcslen(wszServerId);

    SIZE_T       cchKeyPath               = cchMbPath + 1 + cchServerId;
    TSmartPointerArray<WCHAR> swszKeyPath = new WCHAR[cchKeyPath+1];
    if(swszKeyPath == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    LPWSTR pEnd  = NULL;
    memcpy(pEnd  = swszKeyPath, i_wszMbPath,  sizeof(WCHAR) * cchMbPath);
    memcpy(pEnd += cchMbPath,   L"/",         sizeof(WCHAR) * 1);
    memcpy(pEnd += 1,           wszServerId,  sizeof(WCHAR) * (cchServerId+1));

    //
    // From sbstrKeyPath, get sbstrRetVal, a full obj path.
    // This is our return value.
    //
    WMI_CLASS* pServer = (m_eServiceId == SC_MSFTPSVC) ? 
        &WMI_CLASS_DATA::s_FtpServer : &WMI_CLASS_DATA::s_WebServer;

    CComBSTR  sbstrRetVal;
    hr = CUtils::ConstructObjectPath(
        swszKeyPath,
        pServer,
        &sbstrRetVal);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Create WMI return object
    //
    CComPtr<IWbemClassObject> spOutParams;
    hr = CUtils::CreateEmptyMethodInstance(
        i_pNamespace,
        i_pCtx,
        i_pClass->pszClassName,
        i_pMethod->pszMethodName,
        &spOutParams);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Put treats vtRetVal as RO.
    // Deliberately not using smart variant.
    //
    VARIANT  vtRetVal;
    vtRetVal.vt      = VT_BSTR;
    vtRetVal.bstrVal = sbstrRetVal;
    hr = spOutParams->Put(L"ReturnValue", 0, &vtRetVal, 0);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Set out parameters if everything succeeded
    //
    *o_ppRetObj = spOutParams.Detach();

    return hr;
}

//
// private
//

HRESULT CServiceMethod::InternalGetInParams(
    IWbemClassObject*   i_pInParams,
    VARIANT&            io_refServerId,
    VARIANT&            io_refServerComment,
    VARIANT&            io_refServerBindings,
    VARIANT&            io_refPath)
/*++

Synopsis: 
    Given in parameters from the WMI method call, return the values of the
    parameters in variants.

Arguments: [i_pInParams] - 
           [io_refServerId] - 
           [io_refServerComment] - 
           [io_refServerBindings] - 
           [io_refPath] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pInParams);

    HRESULT hr = WBEM_S_NO_ERROR;

    LPWSTR awszParamNames[] = { 
        WMI_METHOD_PARAM_DATA::s_ServerId.pszParamName,
        WMI_METHOD_PARAM_DATA::s_ServerComment.pszParamName,
        WMI_METHOD_PARAM_DATA::s_ServerBindings.pszParamName,
        WMI_METHOD_PARAM_DATA::s_PathOfRootVirtualDir.pszParamName,
        NULL
    };
    VARIANT* apvtParamValues[] = {
        &io_refServerId, &io_refServerComment, &io_refServerBindings, &io_refPath, NULL
    };

    //
    // get in params
    //
    for(ULONG i = 0; awszParamNames[i] != NULL; i++)
    {
        hr = i_pInParams->Get(awszParamNames[i], 0, apvtParamValues[i], NULL, NULL);
        if(FAILED(hr))
        {
            return hr;
        }
    }

    return hr;
}

HRESULT CServiceMethod::InternalCreateNewSite(
    CWbemServices&        i_refNamespace,
    const VARIANT&        i_refServerComment,
    const VARIANT&        i_refServerBindings,
    const VARIANT&        i_refPathOfRootVirtualDir,
    IIISApplicationAdmin* i_pIApplAdmin,
    PDWORD                o_pdwSiteId,
    PDWORD                i_pdwRequestedSiteId)   // default value NULL
/*++

Synopsis: 
    Private method that calls the API

Arguments: [i_refNamespace] - 
           [i_refServerComment] - 
           [i_refServerBindings] - 
           [i_refPathOfRootVirtualDir] - 
           [o_pdwSiteId] - 
           [i_pdwRequestedSiteId] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInit);
    DBG_ASSERT(o_pdwSiteId != NULL);

    HRESULT                       hr                      = S_OK;
    LPWSTR                        mszServerBindings       = NULL;
    DWORD                         dwTemp                  = 0;

    LPWSTR                        wszServerComment        = NULL;
    LPWSTR                        wszPathOfRootVirtualDir = NULL;

    if(i_refServerBindings.vt == (VT_ARRAY | VT_UNKNOWN))
    {
        CMultiSz MultiSz(&METABASE_PROPERTY_DATA::s_ServerBindings, &i_refNamespace);
        hr = MultiSz.ToMetabaseForm(
            &i_refServerBindings,
            &mszServerBindings,
            &dwTemp);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "[%s] MultiSz.ToMetabaseForm failed, hr=0x%x\n", __FUNCTION__, hr));
            goto exit;
        }
    }

    try
    {
        wszServerComment        = CUtils::ExtractBstrFromVt(&i_refServerComment);
        wszPathOfRootVirtualDir = CUtils::ExtractBstrFromVt(&i_refPathOfRootVirtualDir);
    }
    catch(HRESULT ehr)
    {
        hr = ehr;
        goto exit;
    }
    catch(...)
    {
        DBG_ASSERT(false && "Should not be throwing unknown exception");
        hr = WBEM_E_FAILED;
        goto exit;
    }

    hr = m_pSiteCreator->CreateNewSite2(
        m_eServiceId,
        (wszServerComment == NULL) ? L"" : wszServerComment,
        mszServerBindings,
        wszPathOfRootVirtualDir,
        i_pIApplAdmin,
        o_pdwSiteId,
        i_pdwRequestedSiteId);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "[%s] CreateNewSite2 failed, hr=0x%x\n", __FUNCTION__, hr));
        goto exit;
    }

exit:
    delete [] mszServerBindings;
    mszServerBindings = NULL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\sources.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sources.

Abstract:

    Internet Information Services provider

Author:

    Zeyong Xu    Oct 1999

Revision History:

!ENDIF

!include $(PROJECT_ROOT)\iis\place.inc

DLLDEF=..\iiswmi.def
TARGETPATH=obj
TARGETTYPE=DYNLINK

NTTARGETFILE0=$(O)\iiswmimsg.h                  \
              $(O)\msg00001.bin                 \
              $(O)\iiswmimsg.rc

NTTARGETFILES=..\iiswmi.mof \
              ..\iiswmi.mfl


TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib      	   \
    $(SDK_LIB_PATH)\user32.lib             \
    $(SDK_LIB_PATH)\oleaut32.lib           \
    $(SDK_LIB_PATH)\ole32.lib              \
    $(SDK_LIB_PATH)\uuid.lib               \
    $(SDK_LIB_PATH)\advapi32.lib           \
    $(SDK_LIB_PATH)\crypt32.lib            \
    $(SDK_LIB_PATH)\wbemuuid.lib           \
    $(SDK_LIB_PATH)\adsiid.lib             \
    $(SDK_LIB_PATH)\activeds.lib           \
    ..\wmiutils\$(O)\wmiutils.lib          \
    $(PROJECT_ROOT)\iis\admin\secconlib\$(O)\secconlib.lib  \
    ..\..\sitecreator\$(O)\sitecreator.lib \
    $(IISBASEDIR)\lib\$(O)\iisutil.lib     \
    $(IISBASEDIR)\config\src\core\catinproc_iiscfg\$(O)\iiscfg.lib \
    $(IISBASEDIR)\config\src\core\entrypoint\$(O)\cat.lib

INCLUDES=..; \
         ..\wmiutils; \
         ..\..\sitecreator; \
         $(IISBASEDIR)\iisrearc\core\inc; \
         $(IISBASEDIR)\svcs\infocomm\metadata\inc; \
         $(IISBASEDIR)\inc; \
         $(IISBASEDIR)\inc\$(O); \
         $(IISBASEDIR)\admin\adsi\adsiis\$(O); \
         $(IISBASEDIR)\config\src\inc; \
         $(IISBASEDIR)\admin\secconlib;\
         $(IISBASEDIR)\config\src\inc\$(O);

USE_VCCOM=1
USE_NATIVE_EH=1
USE_MSVCRT=1
USE_ATL=1
ATL_VER=30
USE_STL=1
C_DEFINES = -DUNICODE -D_WIN32_DCOM -D_WIN32_WINNT=0x0500

SOURCES= \
maindll.cpp             \
iisprov.cpp             \
instancehelper.cpp      \
queryhelper.cpp         \
AssocBase.cpp           \
AssocSameLevel.cpp      \
AssocACLACE.cpp         \
AssocComponent.cpp      \
classfac.cpp            \
certmap.cpp             \
adminacl.cpp            \
ipsecurity.cpp          \
iisprov.rc              \
globdata.cpp            \
utils.cpp               \
enum.cpp                \
metabase.cpp            \
appladmin.cpp           \
hashtable.cpp           \
schemaextensions.cpp    \
schemadynamic.cpp       \
safecs.cpp              \
pusher.cpp              \
webservicemethod.cpp    \
multiszdata.cpp         \
multiszhelper.cpp       \

MISCFILES = ..\iiswmi.mof \
            ..\iiswmi.mfl

DLLENTRY=_DllMainCRTStartup

TARGETNAME=iiswmi
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\webservicemethod.h ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    ServiceMethod.h

Abstract:

    Defines the CServiceMethod class.

    All the methods in this class return HRESULTs and do not throw exceptions.

Author:

    Mohit Srivastava            25-March-01

Revision History:

--*/

#ifndef _ServiceMethod_h_
#define _ServiceMethod_h_

#include "sitecreator.h"
#include "wbemservices.h"
#include "schema.h"

class CServiceMethod
{
public:
    CServiceMethod(
        eSC_SUPPORTED_SERVICES i_eServiceId);

    ~CServiceMethod();

    HRESULT CreateNewSite(
        LPCWSTR        i_wszServerComment,
        PDWORD         o_pdwSiteId,
        PDWORD         i_pdwRequestedSiteId = NULL);

    HRESULT CreateNewSite(
        CWbemServices*     i_pNamespace,
        LPCWSTR            i_wszMbPath,      // needed for creating WMI return object
        IWbemContext*      i_pCtx,           // needed for creating WMI return object
        WMI_CLASS*         i_pClass,         // needed for creating WMI return object
        WMI_METHOD*        i_pMethod,        // needed for creating WMI return object
        IWbemClassObject*  i_pInParams,
        IWbemClassObject** o_ppRetObj);

    HRESULT Init();

private:
    HRESULT InternalGetInParams(
        IWbemClassObject*   i_pInParams,
        VARIANT&            io_refServerId,
        VARIANT&            io_refServerComment,
        VARIANT&            io_refServerBindings,
        VARIANT&            io_refPath);

    HRESULT InternalCreateNewSite(
        CWbemServices&        i_refNamespace, // for formatted multisz: ServerBinding
        const VARIANT&        i_refServerComment,
        const VARIANT&        i_refServerBindings,
        const VARIANT&        i_refPathOfRootVirtualDir,
        IIISApplicationAdmin* i_pIApplAdmin,
        PDWORD                o_pdwSiteId,
        PDWORD                i_pdwRequestedSiteId = NULL);

    bool                     m_bInit;
    CSiteCreator*            m_pSiteCreator;
    eSC_SUPPORTED_SERVICES   m_eServiceId;
};

#endif // _ServiceMethod_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\mofgen\mofgen.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mofgen.h

Abstract:

    This include file contains the definition for the CMofGen class

Author:

    Mohit Srivastava            28-Nov-00

Revision History:

--*/

#ifndef _mofgen_h_
#define _mofgen_h_

extern LPCWSTR g_wszIIsProvider; // defined in iisprov.h

#include <wbemcli.h>

struct CimTypeStringMapping
{
    CIMTYPE cimtype;
    LPCWSTR wszString;
    LPCWSTR wszFormatString;
};

static CimTypeStringMapping CimTypeStringMappingData[] =
{
    { CIM_SINT8,        L"sint8"    ,    L"%d"     },
    { CIM_UINT8,        L"uint8"    ,    L"%d"     },
    { CIM_SINT16,       L"sint16"   ,    L"%hd"    },
    { CIM_UINT16,       L"uint16"   ,    L"%hu"    },
    { CIM_SINT32,       L"sint32"   ,    L"%d"     },
    { CIM_UINT32,       L"uint32"   ,    L"%u"     },
    { CIM_SINT64,       L"sint64"   ,    L"%I64d"  },
    { CIM_UINT64,       L"uint64"   ,    L"%I64u"  },
    { CIM_REAL32,       L"real32"   ,    L"%f"     },
    { CIM_REAL64,       L"real64"   ,    L"%f"     },
    { CIM_BOOLEAN,      L"boolean"  ,    NULL      },
    { CIM_STRING,       L"string"   ,    L"\"%s\"" },
    { CIM_DATETIME,     L"datetime" ,    NULL      },
    { CIM_REFERENCE,    L"reference",    NULL      },
    { CIM_CHAR16,       L"char16"   ,    NULL      },
    { CIM_OBJECT,       L"object"   ,    NULL      },
    { 0,                NULL        ,    NULL      }
};

class CMofGenUtils
{
public:
    static CimTypeStringMapping* LookupCimType(
        CIMTYPE cimtype)
    {
        for(ULONG i = 0; CimTypeStringMappingData[i].wszString != NULL; i++)
        {
            if(cimtype == CimTypeStringMappingData[i].cimtype)
            {
                return &CimTypeStringMappingData[i];
            }
        }

        return NULL;
    }
};

class CMofGen
{
public:
    CMofGen() : m_pFile(NULL),
        m_wszHeaderFileName(NULL),
        m_wszFooterFileName(NULL),
        m_wszOutFileName(NULL),
        m_wszTemp(NULL),
        m_cchTemp(0)
    {
    }
    virtual ~CMofGen()
    {
        if(m_pFile != NULL)
        {
            fclose(m_pFile);
        }
        delete [] m_wszTemp;
    }
    bool ParseCmdLine (int argc, wchar_t **argv);
    void PrintUsage (wchar_t **argv);

    HRESULT Push();
    LPWSTR GetOutFileName()
    {
        return m_wszOutFileName;
    }

private:
    //
    // File handle to output file
    //
    FILE* m_pFile;

    LPWSTR m_wszHeaderFileName;
    LPWSTR m_wszFooterFileName;
    LPWSTR m_wszOutFileName;

    LPWSTR m_wszTemp;
    ULONG  m_cchTemp;

    HRESULT GenerateEscapedString(LPCWSTR i_wsz);

    HRESULT PushProperties(
        WMI_CLASS* i_pElement);

    HRESULT PushMethods(
        WMI_CLASS* i_pElement);

    HRESULT PushAssociationComponent(
        LPWSTR i_wszComp, 
        LPWSTR i_wszClass);

    HRESULT PushFormattedMultiSz();

    HRESULT PushFile(
        LPWSTR i_wszFile);

    template <class T>
    HRESULT PushClasses(CHashTable<T>* i_phashTable,
                        bool bAssoc)
    {
        DBG_ASSERT(i_phashTable != NULL);
        DBG_ASSERT(m_pFile != NULL);

        HRESULT hr = S_OK;

        //
        // Vars needed for iteration
        //
        CHashTable<T>::Record*   pRec = NULL;

        LPWSTR wszParentClass = NULL;
        LPWSTR wszDescription = NULL;

        int iError = 0;

        //
        // Walk thru classes
        //
        ULONG iShipped;
        CHashTable<T>::iterator iter;
	    CHashTable<T>::iterator iterEnd = i_phashTable->end();
	    for (iter = i_phashTable->begin();  iter != iterEnd;  ++iter)
        {
            pRec = iter.Record();
            iShipped = bAssoc ? 
                ((WMI_ASSOCIATION*)(pRec->m_data))->dwExtended :
                ((WMI_CLASS*)(pRec->m_data))->dwExtended;
            if(iShipped == SHIPPED_TO_MOF)
            {
                if(!bAssoc)
                {
                    wszParentClass = ((WMI_CLASS*)(pRec->m_data))->pszParentClass;
                    wszDescription = ((WMI_CLASS*)(pRec->m_data))->pszDescription;
                }
                else
                {
                    wszParentClass = ((WMI_ASSOCIATION*)(pRec->m_data))->pszParentClass;
                    // wszDescription = ((WMI_ASSOCIATION*)(pRec->m_data))->pszDescription;
                }

                iError = fwprintf(m_pFile, L"[dynamic : ToInstance,provider(\"%s\"),Locale(1033)", g_wszIIsProvider);
                if(iError < 0)
                {
                    hr = E_FAIL;
                    goto exit;
                }
                if(wszDescription != NULL)
                {
                    iError = fwprintf(m_pFile, L",Description(\"%s\")", wszDescription);
                    if(iError < 0)
                    {
                        hr = E_FAIL;
                        goto exit;
                    }
                }
                iError = fwprintf(m_pFile, L"]\n");
                if(iError < 0)
                {
                    hr = E_FAIL;
                    goto exit;
                }
                iError = fwprintf(m_pFile, L"class %s : %s\n", pRec->m_wszKey, wszParentClass);
                if(iError < 0)
                {
                    hr = E_FAIL;
                    goto exit;
                }
                iError = fwprintf(m_pFile, L"{\n");
                if(iError < 0)
                {
                    hr = E_FAIL;
                    goto exit;
                }

                if(!bAssoc)
                {
                    bool bPutNameProperty = true;
                    for(ULONG j = 0; g_awszParentClassWithNamePK[j] != NULL; j++)
                    {
                        //
                        // Deliberate ==
                        //
                        if(g_awszParentClassWithNamePK[j] == ((WMI_CLASS *)(pRec->m_data))->pszParentClass)
                        {
                            bPutNameProperty = false;
                        }
                    }
                    if( bPutNameProperty )
                    {
                        iError = fwprintf(m_pFile, L"\t[Key] string Name;\n");
                        if(iError < 0)
                        {
                            hr = E_FAIL;
                            goto exit;
                        }
                    }
                    hr = PushProperties((WMI_CLASS *)(pRec->m_data));
                    if(FAILED(hr))
                    {
                        goto exit;
                    }
                    hr = PushMethods((WMI_CLASS *)(pRec->m_data));
                    if(FAILED(hr))
                    {
                        goto exit;
                    }
                }
                else
                {
                    hr = PushAssociationComponent(
                        ((WMI_ASSOCIATION *)(pRec->m_data))->pType->pszLeft,
                        ((WMI_ASSOCIATION *)(pRec->m_data))->pcLeft->pszClassName);
                    if(FAILED(hr))
                    {
                        goto exit;
                    }
                    hr = PushAssociationComponent(
                        ((WMI_ASSOCIATION *)(pRec->m_data))->pType->pszRight,
                        ((WMI_ASSOCIATION *)(pRec->m_data))->pcRight->pszClassName);
                    if(FAILED(hr))
                    {
                        goto exit;
                    }
                }

                iError = fwprintf(m_pFile, L"};\n\n");
                if(iError < 0)
                {
                    hr = E_FAIL;
                    goto exit;
                }
            }
        }

    exit:
        return hr;
    }
};

#endif // _mofgen_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\utils.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    General purpose utilities

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#include "iisprov.h"
#include "iiswmimsg.h"

extern CDynSchema* g_pDynSch;
extern HMODULE     g_hModule;

BSTR CUtils::ExtractBstrFromVt(
    const VARIANT* i_pvt,
    LPCWSTR        i_wszVtName) // default(NULL)
/*++

Synopsis: 
    This is different from VARAINT::ChangeType in that it handles conversion
    from VT_NULL also.

Arguments: [i_pvt] - 
           
Return Value: 
    BSTR: If non-null, points to i_pvt->bstrVal

--*/
{
    DBG_ASSERT(i_pvt != NULL);

    switch(i_pvt->vt)
    {
    case VT_BSTR:
        return i_pvt->bstrVal;
    case VT_NULL:
        return NULL;
    default:
        CIIsProvException e;
        e.SetHR(DISP_E_TYPEMISMATCH, i_wszVtName);
        throw e;
    }

    return NULL;
}

LONG CUtils::ExtractLongFromVt(
    const VARIANT* i_pvt,
    LPCWSTR        i_wszVtName) //default(NULL)
{
    DBG_ASSERT(i_pvt);

    try
    {
        _variant_t svt;
        svt = *i_pvt;

        return (long)svt;
    }
    catch(_com_error ce)
    {
        CIIsProvException e;
        e.SetHR(ce.Error(), i_wszVtName);
        throw e;
    }
}

bool CUtils::CompareKeyType(
    LPCWSTR           i_wszKeyFromMb,
    METABASE_KEYTYPE* i_pktKeyCompare)
{
    DBG_ASSERT(i_wszKeyFromMb);
    DBG_ASSERT(i_pktKeyCompare);

    if(!i_pktKeyCompare->m_pszName)
    {
        return false;
    }

    if(_wcsicmp(i_wszKeyFromMb, i_pktKeyCompare->m_pszName) == 0)
    {
        return true;
    }

    //
    // If i_wszKeyFromMb is not in our hashtable and i_wszKeyCompare is
    // IIsObject, treat as a match.
    //
    METABASE_KEYTYPE* pKt = NULL;
    HRESULT hr = g_pDynSch->GetHashKeyTypes()->Wmi_GetByKey(i_wszKeyFromMb, &pKt);
    if( FAILED(hr) && i_pktKeyCompare == &METABASE_KEYTYPE_DATA::s_IIsObject )
    {
        return true;
    }

    return false;
}

bool CUtils::CompareMultiSz(
    WCHAR*       i_msz1,
    WCHAR*       i_msz2
    )
{
    if(i_msz1 == NULL && i_msz2 == NULL)
        return true;
    else if(i_msz1 == NULL || i_msz2 == NULL)
        return false;

    // compare the two multisz buffers.
    for ( ; (*i_msz1 && *i_msz2); )
    {
        if (_wcsicmp(i_msz1, i_msz2) != NULL)
            return false;
        i_msz1 += wcslen(i_msz1) + 1;
        i_msz2 += wcslen(i_msz2) + 1;
    }

    if (!*i_msz1 && !*i_msz2)
    {
        return true;
    }

    return false;
}

HRESULT CUtils::LoadSafeArrayFromByteArray(
    LPBYTE       i_aBytes,
    DWORD        i_iBytes,
    _variant_t&     io_vt
    )
{
    DBG_ASSERT(i_aBytes != NULL);

    HRESULT hr = S_OK;
    SAFEARRAY* pSafeArray = NULL;

    SAFEARRAYBOUND safeArrayBounds[1];
    safeArrayBounds[0].lLbound = 0;
    safeArrayBounds[0].cElements = i_iBytes;
    pSafeArray = SafeArrayCreate(VT_UI1, 1, safeArrayBounds);
    if(pSafeArray == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "[%s] Failure, hr=0x%x\n", __FUNCTION__, hr));
        goto exit;
    }
    for(ULONG idx = 0; idx < i_iBytes; idx++)
    {
        hr = SafeArrayPutElement(pSafeArray, (LONG *)&idx, &i_aBytes[idx]);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "[%s] Failure, hr=0x%x\n", __FUNCTION__, hr));
            goto exit;
        }
    }

    //
    // If everything succeeded, set out parameters.
    //
    io_vt.vt = VT_UI1 | VT_ARRAY;
    io_vt.parray = pSafeArray;

exit:
    if(FAILED(hr))
    {
        if(pSafeArray != NULL)
        {
            SafeArrayDestroy(pSafeArray);
        }
    }
    return hr;
}

//
// CreateByteArrayFromSafeArray
//
HRESULT CUtils::CreateByteArrayFromSafeArray(
    _variant_t&  i_vt,
    LPBYTE*      o_paBytes,
    DWORD*       io_pdw
    )
{
    DBG_ASSERT(i_vt.vt == (VT_ARRAY | VT_UI1));
    DBG_ASSERT(o_paBytes != NULL);
    DBG_ASSERT(io_pdw != NULL);

    if(i_vt.parray == NULL)
    {
        *o_paBytes = NULL;
        *io_pdw    = 0;
    }

    HRESULT hr     = S_OK;
    LONG    iLo    = 0;
    LONG    iUp    = 0;
    LPBYTE  aBytes = NULL;

    hr = SafeArrayGetLBound(i_vt.parray,1,&iLo);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "[%s] Failure, hr=0x%x\n", __FUNCTION__, hr));
        goto exit;
    }
    hr = SafeArrayGetUBound(i_vt.parray,1,&iUp);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "[%s] Failure, hr=0x%x\n", __FUNCTION__, hr));
        goto exit;
    }

    aBytes = new BYTE[iUp-iLo+1];
    if(aBytes == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "[%s] Failure, hr=0x%x\n", __FUNCTION__, hr));
        goto exit;
    }

    for(LONG i = iLo; i <= iUp; i++)
    {
        hr = SafeArrayGetElement(i_vt.parray, &i, &aBytes[i-iLo]);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "[%s] Failure, hr=0x%x\n", __FUNCTION__, hr));
            goto exit;
        }
    }

    //
    // If everything succeeded, set out parameters.
    //
    *o_paBytes = aBytes;
    *io_pdw    = iUp-iLo+1;

exit:
    if(FAILED(hr))
    {
        delete [] aBytes;
    }
    return hr;
}

bool CUtils::CompareByteArray(
    LPBYTE       i_aBytes1,
    ULONG        i_iBytes1,
    LPBYTE       i_aBytes2,
    ULONG        i_iBytes2
    )
{
    if(i_aBytes1 == NULL && i_aBytes2 == NULL)
    {
        return true;
    }
    if(i_aBytes1 == NULL || i_aBytes2 == NULL)
    {
        return false;
    }
    if(i_iBytes1 != i_iBytes2)
    {
        return false;
    }

    for(ULONG i = 0; i < i_iBytes1; i++)
    {
        if(i_aBytes1[i] != i_aBytes2[i])
        {
            return false;
        }
    }

    return true;
}

KeyRef* CUtils::GetKey(
    ParsedObjectPath*    i_pParsedObjectPath, 
    WCHAR*               i_wsz
    )
/*++

Synopsis: 
    Return the KeyRef pointer from the ParsedObjectPath for the given string.

Arguments: [i_pParsedObjectPath] - 
           [i_wsz] - 
           
Return Value: 

--*/
{
    KeyRef* pkr;
    DWORD   numkeys = i_pParsedObjectPath->m_dwNumKeys;
    DWORD   c;

    if(numkeys == 1)
    {
        pkr = *(i_pParsedObjectPath->m_paKeys);
        if(pkr->m_pName == NULL)
        {
            return pkr;
        }
    }

    for ( c=0; numkeys; numkeys--,c++ ) 
    {
        pkr = *(i_pParsedObjectPath->m_paKeys + c);
        if (!_wcsicmp(pkr->m_pName,i_wsz))
            return pkr;
    }

    CIIsProvException e;
    e.SetMC(WBEM_E_INVALID_OBJECT, IISWMI_NO_PRIMARY_KEY, i_wsz);
    throw e;
}

bool CUtils::GetAssociation(
    LPCWSTR              i_wszAssocName,
    WMI_ASSOCIATION**    o_ppAssoc
    )
/*++

Synopsis: 
    Association i_wszAssocName is returned in o_ppAssoc if found. 

Arguments: [i_wszAssocName] - 
           [o_ppAssoc] - 
           
Return Value: 
    true  if found
    false otherwise

--*/
{
    DBG_ASSERT(o_ppAssoc != NULL);

    HRESULT hr;
    hr = g_pDynSch->GetHashAssociations()->Wmi_GetByKey(
        (LPWSTR)i_wszAssocName,
        o_ppAssoc);
    if(SUCCEEDED(hr))
    {
        return true;
    }
    else
    {
        return false;
    }    
}

bool CUtils::GetClass(
    LPCWSTR        i_wszClassName,
    WMI_CLASS**    o_ppClass
    )
/*++

Synopsis: 
    Class i_wszClassName is returned in o_ppClass if found.

Arguments: [i_wszClassName] - 
           [o_ppClass] - 
           
Return Value: 
    true if found
    false otherwise

--*/
{
    DBG_ASSERT(o_ppClass != NULL);

    HRESULT hr;

    hr = g_pDynSch->GetHashClasses()->Wmi_GetByKey(
        (LPWSTR)i_wszClassName,
        o_ppClass);

    if(SUCCEEDED(hr))
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool CUtils::GetMethod(
    LPCWSTR         i_wszMethod,
    WMI_METHOD**    i_apMethodList,
    WMI_METHOD**    o_ppMethod
    )
/*++

Synopsis: 
    The Method descriptor for i_wszMethod is returned via o_ppMethod if found

Arguments: [i_wszMethod] - 
           [i_apMethodList] - 
           [o_ppMethod] - 
           
Return Value: 
    true  if found.
    false otherwise.

--*/
{
    DBG_ASSERT(i_wszMethod    != NULL);
    DBG_ASSERT(o_ppMethod     != NULL);

    WMI_METHOD**    ppmethod;

    if(i_apMethodList == NULL)
    {
        return false;
    }

    for (ppmethod = i_apMethodList; *ppmethod != NULL;ppmethod++)
    {
        if (_wcsicmp(i_wszMethod,(*ppmethod)->pszMethodName) ==0) 
        {
            *o_ppMethod = *ppmethod;        
            return true;
        }
    }

    return false;
}

HRESULT CUtils::ConstructObjectPath(
    LPCWSTR          i_wszMbPath,
    const WMI_CLASS* i_pClass,
    BSTR*            o_pbstrPath)
{
    DBG_ASSERT(i_wszMbPath  != NULL);
    DBG_ASSERT(i_pClass     != NULL);
    DBG_ASSERT(o_pbstrPath  != NULL);
    DBG_ASSERT(*o_pbstrPath == NULL);

    CComBSTR sbstrPath;

    ULONG   cchPrefix = wcslen(i_pClass->pszMetabaseKey);
    DBG_ASSERT(cchPrefix <= wcslen(i_wszMbPath));

    LPCWSTR wszSuffix = &i_wszMbPath[cchPrefix];

    if(wszSuffix[0] == L'/')
    {
        wszSuffix++;
    }

    sbstrPath =  i_pClass->pszClassName;
    if(sbstrPath.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    sbstrPath += L"='";
    if(sbstrPath.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    sbstrPath += wszSuffix;
    if(sbstrPath.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    sbstrPath += L"'";
    if(sbstrPath.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    *o_pbstrPath = sbstrPath.Detach();

    return S_OK;
}


void CUtils::GetMetabasePath(
    IWbemClassObject* io_pObj,
    ParsedObjectPath* i_pParsedObjectPath,
    WMI_CLASS*        i_pClass,
    _bstr_t&          io_bstrPath)
/*++

Synopsis: 
    Populates io_bstrPath and sets the key field in IWbemClassObject

Arguments: [io_pObj] - 
           [i_pParsedObjectPath] - 
           [i_pClass] - 
           [io_bstrPath] - 
           
--*/
{
    KeyRef* pkr;
    LPWSTR  wszWmiKey     = i_pClass->pszKeyName;

    DBG_ASSERT(i_pParsedObjectPath      != NULL);
    DBG_ASSERT(i_pClass                 != NULL);
    DBG_ASSERT(wszWmiKey                != NULL);
    DBG_ASSERT(i_pClass->pszMetabaseKey != NULL);

    pkr = GetKey(i_pParsedObjectPath, wszWmiKey);
    DBG_ASSERT(pkr != NULL);

    if (io_pObj)
    {
        _bstr_t bstr;
        if(pkr->m_pName == NULL)
        {
            bstr = wszWmiKey;
        }
        else
        {
            bstr = pkr->m_pName;
        }
        HRESULT hr = io_pObj->Put(bstr, 0, &pkr->m_vValue, 0);
        THROW_ON_ERROR(hr);
    }

    io_bstrPath = i_pClass->pszMetabaseKey;

    switch ((pkr)->m_vValue.vt)
    {
    case VT_I4:
        {
            WCHAR wszBuf[32] = {0};
            io_bstrPath += L"/";
            io_bstrPath += _itow(pkr->m_vValue.lVal, wszBuf, 10);
            break;
        }
    case VT_BSTR:
        {
            io_bstrPath += L"/";
            io_bstrPath += pkr->m_vValue.bstrVal;
            break;
        }
    }

    return;
}

HRESULT CUtils::GetParentMetabasePath(
    LPCWSTR i_wszChildPath,
    LPWSTR  io_wszParentPath)
/*++

Synopsis: 
    Eg. /LM/w3svc/1 => /LM/w3svc/
        /           => E_FAIL

Arguments: [i_wszChildPath] - 
           [io_wszParentPath] - Should be allocated by caller to at least same
                                size as i_wszChildPath.
           
Return Value: 
    E_FAIL
    S_OK

--*/
{
    DBG_ASSERT(i_wszChildPath != NULL);
    DBG_ASSERT(io_wszParentPath != NULL);

    ULONG cchChildPath = wcslen(i_wszChildPath);
    BOOL  bParentFound = false;

    //
    // This should trim all the ending L'/'
    //
    while(cchChildPath > 0 && i_wszChildPath[cchChildPath-1] == L'/')
    {
        cchChildPath--;
    }

    if(cchChildPath <= 1)
    {
        //
        // does not have a parent
        //
        return E_FAIL;
    }

    for(LONG i = cchChildPath-1; i >= 0; i--)
    {
        if(i_wszChildPath[i] == L'/')
        {
            bParentFound = true;
            break;
        }
    }

    if(!bParentFound)
    {
        return E_FAIL;
    }

    memcpy(io_wszParentPath, i_wszChildPath, (i+1)*sizeof(WCHAR));
    io_wszParentPath[i+1] = L'\0';

    return S_OK;
}

void CUtils::Throw_Exception(
    HRESULT               a_hr,
    METABASE_PROPERTY*    a_pmbp
    )
{
    CIIsProvException t_e;

    t_e.SetHR(a_hr, a_pmbp->pszPropName);

    throw(t_e);
}

//
// io_wszDateTime should be allocated outside with 30 elements
//
void CUtils::FileTimeToWchar(FILETIME *i_pFileTime, LPWSTR io_wszDateTime)
{
    DBG_ASSERT(i_pFileTime    != NULL);
    DBG_ASSERT(io_wszDateTime != NULL);

    SYSTEMTIME  systime;
    if(FileTimeToSystemTime(i_pFileTime, &systime) == 0)
    {
        THROW_ON_ERROR(HRESULT_FROM_WIN32(GetLastError()));
    }
    swprintf(
        io_wszDateTime,
        L"%04d%02d%02d%02d%02d%02d.%06d+000",
        systime.wYear,
        systime.wMonth,
        systime.wDay,
        systime.wHour,
        systime.wMinute,
        systime.wSecond,
        systime.wMilliseconds
        );
}

//
// Below this line, added by Mohit
//

HRESULT CUtils::CreateEmptyMethodInstance(
    CWbemServices*     i_pNamespace,
    IWbemContext*      i_pCtx,
    LPCWSTR            i_wszClassName,
    LPCWSTR            i_wszMethodName,
    IWbemClassObject** o_ppMethodInstance)
/*++

Synopsis: 
    Generally used when executing a WMI method that has out parameters.

Arguments: 
           
--*/
{
    DBG_ASSERT(i_pNamespace    != NULL);
    DBG_ASSERT(i_pCtx          != NULL);
    DBG_ASSERT(i_wszClassName  != NULL);
    DBG_ASSERT(i_wszMethodName != NULL);
    DBG_ASSERT(o_ppMethodInstance   != NULL);

    CComPtr<IWbemClassObject> spClass;
    CComPtr<IWbemClassObject> spMethodClass;
    CComPtr<IWbemClassObject> spMethodInstance;
    HRESULT hr = S_OK;

    CComBSTR bstrClassName = i_wszClassName;
    if(bstrClassName.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "[%s] Failure, hr=0x%x\n", __FUNCTION__, hr));
        goto exit;
    }
    hr = i_pNamespace->GetObject(bstrClassName, 0, i_pCtx, &spClass, NULL);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "[%s] Failure, hr=0x%x\n", __FUNCTION__, hr));
        goto exit;
    }

    hr = spClass->GetMethod(i_wszMethodName, 0, NULL, &spMethodClass);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "[%s] Failure, hr=0x%x\n", __FUNCTION__, hr));
        goto exit;
    }

    hr = spMethodClass->SpawnInstance(0, &spMethodInstance);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "[%s] Failure, hr=0x%x\n", __FUNCTION__, hr));
        goto exit;
    }

    //
    // If everything succeeded, set out parameters
    //
    *o_ppMethodInstance = spMethodInstance.Detach();

exit:
    return hr;
}

HRESULT CUtils::GetQualifiers(
    IWbemClassObject* i_pClass,
    LPCWSTR*          i_awszQualNames,
    VARIANT*          io_aQualValues,
    ULONG             i_NrQuals
    )
/*++

Synopsis: 
    Gets Qualifiers.

Arguments: [i_pClass] - 
           [i_awszQualNames] - An array of size i_NrQuals with names of quals.
           [io_aQualValues]  - An array of size i_NrQuals with empty variants.
                               Will be populated on success.
           [i_NrQuals] - 
           
--*/
{
    DBG_ASSERT(i_pClass        != NULL);
    DBG_ASSERT(i_awszQualNames != NULL);
    DBG_ASSERT(io_aQualValues  != NULL);

    HRESULT hr = S_OK;
    ULONG   i = 0;

    CComPtr<IWbemQualifierSet> spQualSet = NULL;

    hr = i_pClass->GetQualifierSet(&spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }

    // Looking for qualifiers
    for(i = 0; i < i_NrQuals; i++)
    {
        DBG_ASSERT(i_awszQualNames[i] != NULL);
        hr = spQualSet->Get(i_awszQualNames[i], 0, &io_aQualValues[i], NULL);
        if(FAILED(hr) && hr != WBEM_E_NOT_FOUND)
        {
            break;
        }
        hr = WBEM_S_NO_ERROR;
    }
    if(FAILED(hr))
    {
        for(i = 0; i < i_NrQuals; i++)
        {
            VariantClear(&io_aQualValues[i]);
        }
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CUtils::GetPropertyQualifiers(
    IWbemClassObject* i_pClass,
    LPCWSTR i_wszPropName,
    DWORD*  io_pdwQuals)
/*++

Synopsis:  Unlike SetPropertyQualifiers, this method is specific to this 
           provider.

Arguments: 
           
--*/
{
    DBG_ASSERT(i_pClass != NULL);
    DBG_ASSERT(i_wszPropName != NULL);
    DBG_ASSERT(io_pdwQuals != NULL);

    HRESULT hr = S_OK;

    CComPtr<IWbemQualifierSet> spQualSet = NULL;
    BSTR               bstrQualName = NULL;
    VARIANT            varQualValue;
    VariantInit(&varQualValue);

    DWORD              dwQuals = 0;

    bool               bSeenForcePropertyOverwrite = false;
    bool               bSeenIsDefault              = false;
    bool               bSeenIsInherit              = false;

    hr = i_pClass->GetPropertyQualifierSet(i_wszPropName, &spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }

    // Looking for qualifiers
    spQualSet->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY);
    while(!bSeenForcePropertyOverwrite || !bSeenIsDefault || !bSeenIsInherit)
    {
        hr = spQualSet->Next(0, &bstrQualName, &varQualValue, NULL);
        if(hr == WBEM_S_NO_MORE_DATA || FAILED(hr)) 
        {
            // No more qualifiers.
            // We don't need to worry about cleanup - nothing was allocated.
            break;
        }

        if(!bSeenForcePropertyOverwrite && _wcsicmp(bstrQualName, g_wszForcePropertyOverwrite) == 0) 
        {
            bSeenForcePropertyOverwrite = true;
            if(varQualValue.vt == VT_BOOL && varQualValue.boolVal) 
            {
                dwQuals |= g_fForcePropertyOverwrite;
            }
        }
        else if(!bSeenIsDefault && _wcsicmp(bstrQualName, g_wszIsDefault) == 0)
        {
            bSeenIsDefault = true;
            if(varQualValue.vt == VT_BOOL && varQualValue.boolVal)
            {
                dwQuals |= g_fIsDefault;
            }
        }
        else if(!bSeenIsInherit && _wcsicmp(bstrQualName, g_wszIsInherit) == 0)
        {
            bSeenIsInherit = true;
            if(varQualValue.vt == VT_BOOL && varQualValue.boolVal)
            {
                dwQuals |= g_fIsInherit;
            }
        }
        SysFreeString(bstrQualName);        
        VariantClear(&varQualValue);
    }
    spQualSet->EndEnumeration();

    if(FAILED(hr))
    {
        goto exit;
    }

    *io_pdwQuals = dwQuals;

exit:
    if(hr == WBEM_S_NO_MORE_DATA)
    {
        hr = WBEM_S_NO_ERROR;
    }
    return hr;
}
    
HRESULT CUtils::SetQualifiers(
    IWbemClassObject* i_pClass,
    LPCWSTR*          i_awszQualNames,
    VARIANT*          i_avtQualValues,
    ULONG             i_iNrQuals,
    ULONG             i_iFlags)
{
    DBG_ASSERT(i_pClass        != NULL);
    DBG_ASSERT(i_awszQualNames != NULL);
    DBG_ASSERT(i_avtQualValues != NULL);

    HRESULT hr = S_OK;
    CComPtr<IWbemQualifierSet> spQualSet = NULL;

    hr = i_pClass->GetQualifierSet(&spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }

    for(ULONG i = 0; i < i_iNrQuals; i++)
    {
        DBG_ASSERT(i_awszQualNames[i] != NULL);
        hr = spQualSet->Put(i_awszQualNames[i], &i_avtQualValues[i], i_iFlags);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CUtils::SetMethodQualifiers(
    IWbemClassObject* i_pClass,
    LPCWSTR           i_wszMethName,
    LPCWSTR*          i_awszQualNames,
    VARIANT*          i_avtQualValues,
    ULONG             i_iNrQuals)
{
    DBG_ASSERT(i_pClass        != NULL);
    DBG_ASSERT(i_wszMethName   != NULL);
    DBG_ASSERT(i_awszQualNames != NULL);
    DBG_ASSERT(i_avtQualValues != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    CComPtr<IWbemQualifierSet> spQualSet;

    hr = i_pClass->GetMethodQualifierSet(i_wszMethName, &spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }

    for(ULONG i = 0; i < i_iNrQuals; i++)
    {
        DBG_ASSERT(i_awszQualNames[i] != NULL);
        hr = spQualSet->Put(i_awszQualNames[i], &i_avtQualValues[i], 
            WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CUtils::SetPropertyQualifiers(
    IWbemClassObject* i_pClass,
    LPCWSTR i_wszPropName,
    LPCWSTR* i_awszQualNames,
    VARIANT* i_avtQualValues,
    ULONG i_iNrQuals)
/*++

Synopsis: 

Arguments: [i_pClass] - 
           [i_wszPropName] - 
           [i_awszQualNames] - 
           [i_avtQualValues] - 
           [i_iNrQuals] -
           
--*/
{
    DBG_ASSERT(i_pClass != NULL);
    DBG_ASSERT(i_wszPropName != NULL);
    DBG_ASSERT(i_awszQualNames != NULL);
    DBG_ASSERT(i_avtQualValues != NULL);

    HRESULT hr = S_OK;
    CComPtr<IWbemQualifierSet> spQualSet = NULL;

    hr = i_pClass->GetPropertyQualifierSet(i_wszPropName, &spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }

    for(ULONG i = 0; i < i_iNrQuals; i++)
    {
        DBG_ASSERT(i_awszQualNames[i] != NULL);
        hr = spQualSet->Put(i_awszQualNames[i], &i_avtQualValues[i], 
            WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CUtils::CreateEmptyInstance(
    LPWSTR i_wszClass,
    CWbemServices* i_pNamespace,
    IWbemClassObject** o_ppInstance)
/*++

Synopsis: 
    Creates an IWbemClassObject populated with default values.

Arguments: [i_wszClass] - 
           [i_pNamespace] - 
           [o_ppInstance] - Must Release() if this function succeeds.
           
--*/
{
    DBG_ASSERT(i_wszClass != NULL);
    DBG_ASSERT(i_pNamespace != NULL);
    DBG_ASSERT(o_ppInstance != NULL);

    HRESULT hr = S_OK;
    CComPtr<IWbemClassObject> spClass;
    CComPtr<IWbemClassObject> spInstance;

    hr = i_pNamespace->GetObject(
        i_wszClass, 
        0, 
        NULL, 
        &spClass, 
        NULL);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = spClass->SpawnInstance(0, &spInstance);
    
    if(FAILED(hr))
    {
        goto exit;
    }

    *o_ppInstance = spInstance;
    (*o_ppInstance)->AddRef();

exit:
    return hr;
}

void CUtils::MessageCodeToText(
    DWORD    i_dwMC,
    va_list* i_pArgs,
    BSTR*    o_pbstrText)
/*++

Synopsis: 

Arguments: [i_dwMC] - 
           [i_pArgs] -     Can be NULL
           [o_pbstrText] - Needs to be freed by caller
           
--*/
{
    DBG_ASSERT(o_pbstrText != NULL);
    *o_pbstrText = NULL;

    LPVOID lpMsgBuf = NULL;
    DWORD dwRet = FormatMessageW( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        g_hModule,
        i_dwMC,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPWSTR) &lpMsgBuf,
        0,
        i_pArgs);
    if(dwRet == 0)
    {
        DBG_ASSERT(lpMsgBuf == NULL);
    }

    CComBSTR sbstrOut;
    if(lpMsgBuf != NULL)
    {
        //
        // If out of memory, sbstrOut will be NULL.  This is okay.
        //
        sbstrOut = (LPWSTR)lpMsgBuf;

        //
        // Free the buffer.
        //
        LocalFree( lpMsgBuf );
    }

    //
    // Set out parameter
    //
    *o_pbstrText = sbstrOut.Detach();
}

void CUtils::HRToText(
    HRESULT i_hr,
    BSTR*   o_pbstrText)
{
    DBG_ASSERT(o_pbstrText != NULL);

    CComPtr<IWbemStatusCodeText> spStatus;

    *o_pbstrText = NULL;
    i_hr         = HRESULT_FROM_WIN32(i_hr);

    if(HRESULT_FACILITY(i_hr) == FACILITY_INTERNET)
    {
        MessageCodeToText(i_hr, NULL, o_pbstrText);
        return;
    }

    HRESULT hr = CoCreateInstance(
        CLSID_WbemStatusCodeText, 
        0, 
        CLSCTX_INPROC_SERVER,
        IID_IWbemStatusCodeText, 
        (LPVOID *) &spStatus);
    
    CComBSTR sbstrError    = NULL;
    CComBSTR sbstrFacility = NULL;
    if(SUCCEEDED(hr))
    {
        spStatus->GetErrorCodeText(i_hr, 0, 0, &sbstrError);       // ignore hr
        spStatus->GetFacilityCodeText(i_hr, 0, 0, &sbstrFacility); // ignore hr
    }

    CComBSTR sbstrFullError = NULL;
    if(sbstrError != NULL && sbstrFacility != NULL)
    {
        sbstrFullError =  sbstrFacility;
        sbstrFullError += L": ";
        sbstrFullError += sbstrError;   // sbstrFullError may be NULL in low mem -- okay
    }
    else if(sbstrError != NULL)
    {
        sbstrFullError =  sbstrError;   // sbstrFullError may be NULL in low mem -- okay
    }
    else if(sbstrFacility != NULL)
    {
        sbstrFullError = sbstrFacility; // sbstrFullError may be NULL in low mem -- okay
    }

    *o_pbstrText = sbstrFullError.Detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\mofgen\mofgen.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mofgen.cpp

Abstract:

    This file contains the implementation of the CMofGen class

Author:

    Mohit Srivastava            28-Nov-00

Revision History:

--*/

#include "iisprov.h"
#include "mofgen.h"
#include "MultiSzData.h"

#include <initguid.h>
// {041FFF3F-EB8F-4d51-9736-A26E91E3A3CA}
DEFINE_GUID(IisWmiMofgenGuid, 
0x41fff3f, 0xeb8f, 0x4d51, 0x97, 0x36, 0xa2, 0x6e, 0x91, 0xe3, 0xa3, 0xca);

//
// Debugging Stuff
//
#include "pudebug.h"
DECLARE_DEBUG_PRINTS_OBJECT()

extern CDynSchema* g_pDynSch; // Initialized to NULL in schemadynamic.cpp

void ConstructFlatContainerList(METABASE_KEYTYPE*, bool*);

bool CMofGen::ParseCmdLine (int argc, wchar_t **argv)
{
    for (int i=1; i<argc; ++i)
    {
        static wchar_t * wszOUT = L"/out:";
        static wchar_t * wszHEADER = L"/header:";
        static wchar_t * wszFOOTER = L"/footer:";
        
        if (wcsncmp (argv[i], wszOUT, wcslen(wszOUT)) == 0)
        {
            if (m_wszOutFileName != 0)
            {
                // duplicate parameter
                return false;
            }
            m_wszOutFileName = new WCHAR [wcslen (argv[i]) - wcslen (wszOUT) + 1];
            if (m_wszOutFileName == 0)
            {
                return false;
            }
            wcscpy (m_wszOutFileName, argv[i] + wcslen(wszOUT));
        }
        else if (wcsncmp (argv[i], wszHEADER, wcslen (wszHEADER)) == 0)
        {
            if (m_wszHeaderFileName != 0)
            {
                // duplicate parameter
                return false;
            }
            m_wszHeaderFileName = new WCHAR [wcslen (argv[i]) - wcslen (wszHEADER) + 1];
            if (m_wszHeaderFileName == 0)
            {
                return false;
            }
            wcscpy (m_wszHeaderFileName, argv[i] + wcslen(wszHEADER));
        }
        else if (wcsncmp (argv[i], wszFOOTER, wcslen (wszFOOTER)) == 0)
        {
            if (m_wszFooterFileName != 0)
            {
                // duplicate parameter
                return false;
            }
            m_wszFooterFileName = new WCHAR [wcslen (argv[i]) - wcslen (wszFOOTER) + 1];
            if (m_wszFooterFileName == 0)
            {
                return false;
            }
            wcscpy (m_wszFooterFileName, argv[i] + wcslen(wszFOOTER));
        }
        else
        {
            wprintf (L"Unknown parameter: %s\n", argv[i]);
            return false;
        }
    }

    // verify that we have the required parameters

    if (m_wszOutFileName == 0)
    {
        printf ("You need to specify an output file name\n");
        return false;
    }

    if (m_wszHeaderFileName == 0)
    {
        printf ("You need to specify a header file name\n");
        return false;
    }

    if (m_wszFooterFileName == 0)
    {
        printf ("You need to specify a footer file name\n");
        return false;
    }

    return true;
}


void CMofGen::PrintUsage (wchar_t **argv)
{
    DBG_ASSERT(argv != NULL);
    wprintf (L"Usage:\n%s /out:<filename> /header:<filename> /footer:<filename>\n", argv[0]);
}


HRESULT CMofGen::PushMethods(WMI_CLASS* i_pElement)
{
    DBG_ASSERT(i_pElement != NULL);
    DBG_ASSERT(m_pFile != NULL);

    WMI_METHOD* pMethCurrent;

    LPCWSTR wszRetType = NULL;
    LPWSTR  wszDescription = NULL;
    LPWSTR  wszParamType = NULL;
    LPWSTR  wszParamTypeSuffix = NULL;
    LPWSTR  wszParamInOut = NULL;

    int iError = 0;

    if(i_pElement->ppMethod == NULL)
    {
        return S_OK;
    }

    for(ULONG i = 0; i_pElement->ppMethod[i] != NULL; i++)
    {
        pMethCurrent = i_pElement->ppMethod[i];

        if(pMethCurrent->typeRetVal == NULL)
        {
            wszRetType = L"void";
        }
        else
        {
            CimTypeStringMapping* pCimType = 
                CMofGenUtils::LookupCimType(pMethCurrent->typeRetVal);
            DBG_ASSERT(pCimType != NULL);
            if (!pCimType) {
                return E_FAIL;
            }

            wszRetType = pCimType->wszString;
        }
        wszDescription = pMethCurrent->pszDescription;

        iError = fwprintf(m_pFile, L"\t[Implemented,bypass_getobject");
        if(iError < 0)
        {
            return E_FAIL;
        }
        if(wszDescription)
        {
            iError = fwprintf(m_pFile, L",Description(\"%s\")", wszDescription);
        }
        iError = fwprintf(m_pFile, L"] %s %s(", wszRetType, pMethCurrent->pszMethodName);
        if(iError < 0)
        {
            return E_FAIL;
        }

        ULONG j = 0;
        if(pMethCurrent->ppParams != NULL)
        {
            for(j = 0; pMethCurrent->ppParams[j] != NULL; j++)
            {
                wszParamType = L"";
                wszParamTypeSuffix = L"";
                wszParamInOut = L"";
                if(j != 0)
                {
                    iError = fwprintf(m_pFile, L", ");
                    if(iError < 0)
                    {
                        return E_FAIL;
                    }
                }
                switch(pMethCurrent->ppParams[j]->type)
                {
                case CIM_STRING:
                    wszParamType = L"string";
                    break;
                case CIM_SINT32:
                    wszParamType = L"sint32";
                    break;
                case VT_ARRAY | CIM_STRING:
                    wszParamType = L"string";
                    wszParamTypeSuffix = L"[]";
                    break;
                case VT_ARRAY | VT_UNKNOWN:
                    wszParamType = L"ServerBinding";
                    wszParamTypeSuffix = L"[]";
                    break;
                case CIM_BOOLEAN:
                    wszParamType = L"boolean";
                    break;
                case CIM_DATETIME:
                    wszParamType = L"datetime";
                    break;
                default:
                    wprintf(L"Warning: Type of Param: %s in Method: %s unknown.  Not outputting type.\n", 
                        pMethCurrent->ppParams[j]->pszParamName,
                        pMethCurrent->pszMethodName);
                    break;
                }
                switch(pMethCurrent->ppParams[j]->iInOut)
                {
                case PARAM_IN:
                    wszParamInOut = L"[IN]";
                    break;
                case PARAM_OUT:
                    wszParamInOut = L"[OUT]";
                    break;
                case PARAM_INOUT:
                    wszParamInOut = L"[IN,OUT]";
                    break;
                default:
                    wprintf(L"Warning: Unsure if Param: %s in Method: %s is IN or OUT param.  Not outputting IN/OUT qualifier\n",
                        pMethCurrent->ppParams[j]->pszParamName,
                        pMethCurrent->pszMethodName);
                    break;
                }

                // CreateNewSite has an optional param
                if (!wcscmp(pMethCurrent->pszMethodName, L"CreateNewSite") &&
                    !wcscmp(pMethCurrent->ppParams[j]->pszParamName, L"ServerId")) {
                    wszParamInOut = L"[IN,OPTIONAL]";
                }

                iError = fwprintf(m_pFile, L"%s %s %s%s", 
                    wszParamInOut, wszParamType, pMethCurrent->ppParams[j]->pszParamName, wszParamTypeSuffix);
                if(iError < 0)
                {
                    return E_FAIL;
                }
            }
        }

        iError = fwprintf(m_pFile, L");\n");
        if(iError < 0)
        {
            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT CMofGen::GenerateEscapedString(LPCWSTR i_wsz)
{
    DBG_ASSERT(i_wsz != NULL);

    ULONG cchOld = 0;
    ULONG cchNew = 0;
    LPWSTR wsz;

    for(ULONG i = 0; i_wsz[i] != L'\0'; i++)
    {
        if(i_wsz[i] == L'\\' || i_wsz[i] == L'\"')
        {
            cchNew += 2;
        }
        else
        {
            cchNew++;
        }
        cchOld++;
    }

    if(cchNew > m_cchTemp || m_wszTemp == NULL)
    {
        delete [] m_wszTemp;
        m_wszTemp = new WCHAR[1+cchNew*2];
        if(m_wszTemp == NULL)
        {
            m_cchTemp = 0;
            return E_OUTOFMEMORY;
        }
        m_cchTemp = cchNew*2;
    }

    ULONG j = 0;
    for(ULONG i = 0; i < cchOld; i++)
    {
        if(i_wsz[i] == L'\\' || i_wsz[i] == L'\"')
        {
            m_wszTemp[j] = L'\\';
            m_wszTemp[j+1] = i_wsz[i];
            j+=2;
        }
        else
        {
            m_wszTemp[j] = i_wsz[i];
            j++;
        }
    }
    DBG_ASSERT(m_wszTemp != NULL);
    m_wszTemp[j] = L'\0';

    return S_OK;
}

HRESULT CMofGen::PushProperties(WMI_CLASS* i_pElement)
{
    DBG_ASSERT(i_pElement != NULL);
    DBG_ASSERT(m_pFile != NULL);

    HRESULT hr = S_OK;
    METABASE_PROPERTY* pPropCurrent;
    
    LPWSTR wszType = NULL;
    LPWSTR wszTypeSuffix = NULL;
    LPWSTR wszQual = NULL;
    LPWSTR wszDefault = NULL;
    LPWSTR wszQuote = L"";

    int iError = 0;

    if(i_pElement->ppmbp == NULL)
    {
        return hr;
    }

    for(ULONG i = 0; i_pElement->ppmbp[i] != NULL; i++)
    {   
        wszQual = wszTypeSuffix = wszType = wszQuote = L"";
        wszDefault = NULL;
        WCHAR wszBuf[20];

        pPropCurrent= i_pElement->ppmbp[i];
        switch(pPropCurrent->dwMDDataType)
        {
        case DWORD_METADATA:
            if(pPropCurrent->dwMDMask != 0)
            {
                wszType = L"boolean";
                if(pPropCurrent->pDefaultValue)
                {
                    if(*((int *)(pPropCurrent->pDefaultValue)) == 0)
                    {
                        //wcscpy(wszBuf, L"false");
                        //wszDefault = wszBuf;
                    }
                    else
                    {
                        //wcscpy(wszBuf, L"true");
                        //wszDefault = wszBuf;
                    }
                }
            }
            else
            {
                wszType = L"sint32";
                if(pPropCurrent->pDefaultValue)
                {
                    //swprintf(wszBuf, L"%d", *((int *)(pPropCurrent->pDefaultValue)));
                    //wszDefault = wszBuf;
                }
            }
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            wszType = L"string";
            wszQuote = L"\"";
            /*if(pPropCurrent->pDefaultValue != NULL)
            {
                //
                // Sets m_wszTemp
                //
                hr = GenerateEscapedString((LPWSTR)pPropCurrent->pDefaultValue);
                if(FAILED(hr))
                {
                    goto exit;
                }
                wszDefault = m_wszTemp;;
            }*/
            break;
        case MULTISZ_METADATA:
            {
                wszType = L"string";
                TFormattedMultiSz* pFormattedMultiSz = 
                    TFormattedMultiSzData::Find(pPropCurrent->dwMDIdentifier);
                if(pFormattedMultiSz)
                {
                    wszType = pFormattedMultiSz->wszWmiClassName;
                }
                wszTypeSuffix = L"[]";
                break;
            }
        case BINARY_METADATA:
            wszType = L"uint8";
            wszTypeSuffix = L"[]";
            break;
        default:
            wprintf(L"Warning: Cannot determine type of Prop: %s in Class: %s.  Ignoring property.\n", pPropCurrent->pszPropName, i_pElement->pszClassName);
            continue;
        }
        
        //
        // qualifier for read-only
        //
        if(pPropCurrent->fReadOnly)
        {
            wszQual = L"[read, write(FALSE)]";
        }
        else
        {
            wszQual = L"[read, write]";
        }

        if(wszDefault)
        {
            iError = fwprintf(m_pFile, L"\t%s %s %s%s = %s%s%s;\n", 
                wszQual, wszType, pPropCurrent->pszPropName, wszTypeSuffix, 
                wszQuote, wszDefault, wszQuote);
        }
        else
        {
            iError = fwprintf(m_pFile, L"\t%s %s %s%s;\n", 
                wszQual, wszType, pPropCurrent->pszPropName, wszTypeSuffix);
        }
        if(iError < 0)
        {
            hr = E_FAIL;
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CMofGen::PushAssociationComponent(LPWSTR i_wszComp, 
                                          LPWSTR i_wszClass)
{
    DBG_ASSERT(i_wszComp != NULL);
    DBG_ASSERT(i_wszClass != NULL);
    DBG_ASSERT(m_pFile != NULL);

    HRESULT hr = S_OK;

    int iError = fwprintf(m_pFile, L"\t[key] %s ref %s = NULL;\n", i_wszClass, i_wszComp);
    if(iError < 0)
    {
        return E_FAIL;
    }

    return hr;
}

HRESULT CMofGen::PushFormattedMultiSz()
{
    DBG_ASSERT(m_pFile != NULL);

    HRESULT             hr                     = S_OK;
    int                 iError                 = 0;
    TFormattedMultiSz** apFormattedMultiSz     = TFormattedMultiSzData::apFormattedMultiSz;

    if(apFormattedMultiSz == NULL)
    {
        goto exit;
    }

    for(ULONG i = 0; apFormattedMultiSz[i] != NULL; i++)
    {
        iError = fwprintf(m_pFile, L"[provider(\"%s\"),Locale(1033)", g_wszIIsProvider);
        if(iError < 0)
        {
            hr = E_FAIL;
            goto exit;
        }
        iError = fwprintf(m_pFile, L"]\n");
        if(iError < 0)
        {
            hr = E_FAIL;
            goto exit;
        }
        iError = fwprintf(m_pFile, L"class %s : IIsStructuredDataClass\n", apFormattedMultiSz[i]->wszWmiClassName);
        if(iError < 0)
        {
            hr = E_FAIL;
            goto exit;
        }
        iError = fwprintf(m_pFile, L"{\n");
        if(iError < 0)
        {
            hr = E_FAIL;
            goto exit;
        }

        LPCWSTR* awszFields = apFormattedMultiSz[i]->awszFields;
        if(awszFields != NULL)
        {
            for(ULONG j = 0; awszFields[j] != NULL; j++)
            {
                iError = fwprintf(m_pFile, L"\t[key, read, write] string %s;\n", awszFields[j]);
                if(iError < 0)
                {
                    hr = E_FAIL;
                    goto exit;
                }
            }
        }

        iError = fwprintf(m_pFile, L"};\n\n");
        if(iError < 0)
        {
            hr = E_FAIL;
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CMofGen::PushFile (LPWSTR i_wszFile)
{
    DBG_ASSERT(i_wszFile != NULL);
    DBG_ASSERT(m_pFile != NULL);

    FILE *pFile = _wfopen (i_wszFile, L"r");
    if (pFile == NULL)
    {
        wprintf(L"Could not open %s for reading\n", i_wszFile);
        return RETURNCODETOHRESULT(ERROR_OPEN_FAILED);
    }

    WCHAR wszBuffer[512];

    while (fgetws (wszBuffer, 512, pFile) != 0)
    {
        fputws (wszBuffer, m_pFile);
    }

    fclose (pFile);

    return S_OK;
}

HRESULT CMofGen::Push()
{
    HRESULT hr = S_OK;

    if(m_pFile == NULL)
    {
        m_pFile = _wfopen(m_wszOutFileName, L"w+");
        if(m_pFile == NULL)
        {
            wprintf(L"Could not open %s for writing\n", m_wszOutFileName);
            hr = RETURNCODETOHRESULT(ERROR_OPEN_FAILED);
            goto exit;
        }
    }

    hr = PushFile(m_wszHeaderFileName);
    if(FAILED(hr))
    {
        goto exit;
    }
    if(fwprintf(m_pFile, L"\n\n") < 0)
    {
        hr = E_FAIL;
        goto exit;
    }
    hr = PushFormattedMultiSz();
    if(FAILED(hr))
    {
        goto exit;
    }
    hr = PushClasses(g_pDynSch->GetHashClasses(), false);
    if(FAILED(hr))
    {
        goto exit;
    }
    hr = PushClasses(g_pDynSch->GetHashAssociations(), true);
    if(FAILED(hr))
    {
        goto exit;
    }
    hr = PushFile(m_wszFooterFileName);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    return hr;
}

int __cdecl wmain(int argc, wchar_t* argv[])
{
#ifndef _NO_TRACING_
    // CREATE_DEBUG_PRINT_OBJECT("Mofgen.exe", IisWmiMofgenGuid);
    CREATE_DEBUG_PRINT_OBJECT("Mofgen.exe");
#else
    CREATE_DEBUG_PRINT_OBJECT("Mofgen.exe");
#endif

    HRESULT hr = S_OK;
    CMofGen mofgen;
    CSchemaExtensions catalog;
    
    g_pDynSch = new CDynSchema();
    if(g_pDynSch == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = g_pDynSch->Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = g_pDynSch->RunRules(&catalog, false);
    if(FAILED(hr))
    {
        goto exit;
    }
    if(!mofgen.ParseCmdLine(argc, argv))
    {
        mofgen.PrintUsage(argv);
        hr = E_INVALIDARG;
        goto exit;
    }
    hr = mofgen.Push();
    if(FAILED(hr))
    {
        goto exit;
    }
    
exit:
    delete g_pDynSch;
    g_pDynSch = NULL;
    DELETE_DEBUG_PRINT_OBJECT();
    if(FAILED(hr))
    {
        printf("MofGen failed, code: 0x%x\n", hr);
        return 1;
    }
    else
    {
        wprintf(L"MofGen successful!  %s created.\n", mofgen.GetOutFileName());
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\provider\makefile.inc ===
#
# Supplemental rules for generating message file.
#


$(O)\iiswmimsg.h $(O)\iiswmimsg.rc $(O)\msg00001.bin: iiswmimsg.mc $(IISBASEDIR)\svcs\infocomm\metadata\interfac\mdmsg.mc
    copy iiswmimsg.mc+$(IISBASEDIR)\svcs\infocomm\metadata\interfac\mdmsg.mc $(O)\tmp.mc
    mc -v -h .\$(O) -r .\$(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\iiswmimsg.h
    copy $(O)\tmp.rc $(O)\iiswmimsg.rc
    del $(O)\tmp.*

..\iiswmi.mof ..\iiswmi.mfl : ..\iiswmimaster.mof
	$(BASEDIR)\tools\$(PROCESSOR_ARCHITECTURE)\mofcomp.exe -Amendment:MS_409 -MOF:..\iiswmi.mof -MFL:..\iiswmi.mfl ..\iiswmimaster.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\genlex.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    m_pTokenBuf = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                    if (m_pTokenBuf == 0)
                        return 0; // out of memory
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\providerbase.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    ProviderBase.cpp

Abstract:

    Implementation of:
        CProviderBase

Author:

    ???

Revision History:

    Mohit Srivastava            10-Nov-2000

--*/

#include "ProviderBase.h"
#include <dbgutil.h>

extern long        g_cObj;

//
// CProviderBase (Implements IWbemServices, IWbemProviderInit, IWbemShutdown)
//

CProviderBase::CProviderBase(
    const BSTR ObjectPath,
    const BSTR User, 
    const BSTR Password, 
    IWbemContext * pCtx)
    :m_cRef(0), m_pNamespace(NULL)
{
}

CProviderBase::~CProviderBase()
{
    if(m_pNamespace)
        delete m_pNamespace;
}

STDMETHODIMP_(ULONG) 
CProviderBase::AddRef(void)
{
    InterlockedIncrement(&g_cObj);

    return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) 
CProviderBase::Release(void)
{
    InterlockedDecrement(&g_cObj);

    long lNewCount = InterlockedDecrement((long *)&m_cRef);

    if (0L == lNewCount)
        delete this;
    
    return (lNewCount > 0) ? lNewCount : 0;
}

STDMETHODIMP 
CProviderBase::QueryInterface(
    REFIID riid, 
    PPVOID ppv)
{
    *ppv=NULL;

    //
    // Since we have dual inheritance, it is necessary to cast the return type
    //

    if(riid == IID_IWbemShutdown)
    {
        *ppv = (IWbemShutdown*)this;
    }

    if(riid == IID_IWbemServices)
    {
       *ppv = (IWbemServices*)this;
    }

    if(IID_IUnknown == riid || riid == IID_IWbemProviderInit)
    {
       *ppv = (IWbemProviderInit*)this;
    }

    if (NULL != *ppv)
    {
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
  
}

HRESULT
CProviderBase::Shutdown(
    LONG uReason,
    ULONG uMaxMilliseconds,
    IWbemContext *pCtx)
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT
CProviderBase::Initialize(
    LPWSTR                 wszUser, 
    LONG                   lFlags,
    LPWSTR                 wszNamespace, 
    LPWSTR                 wszLocale,
    IWbemServices*         pNamespace, 
    IWbemContext*          pCtx,
    IWbemProviderInitSink* pInitSink)
/*++

Synopsis: 
    According to stevm from WMI, calls to Initialize are guaranteed to be
    synchronized - so long as all providers are in the same namespace.

Arguments: [wszUser] - 
           [lFlags] - 
           [wszNamespace] - 
           [wszLocale] - 
           [pNamespace] - 
           [pCtx] - 
           [pInitSink] - 
           
Return Value: 

--*/
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pInitSink->SetStatus(WBEM_E_FAILED, 0);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoInitialize(
        wszUser,
        lFlags,
        wszNamespace,
        wszLocale,
        pNamespace,
        pCtx,
        pInitSink);
}



HRESULT
CProviderBase::CreateInstanceEnumAsync(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoCreateInstanceEnumAsync(
        Class,
        lFlags,
        pCtx,
        pResponseHandler);
}

HRESULT
CProviderBase::DeleteInstanceAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoDeleteInstanceAsync(
        ObjectPath,
        lFlags,
        pCtx,
        pResponseHandler);
}


HRESULT
CProviderBase::ExecMethodAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR MethodName, 
    /* [in] */ long lFlags, 
    /* [in] */ IWbemContext* pCtx,
    /* [in] */ IWbemClassObject* pInParams,
    /* [in] */ IWbemObjectSink* pResponseHandler)
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoExecMethodAsync(
        strObjectPath,
        MethodName,
        lFlags,
        pCtx,
        pInParams,
        pResponseHandler);
    
}


HRESULT
CProviderBase::ExecQueryAsync(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoExecQueryAsync(
        QueryLanguage,
        Query,
        lFlags,
        pCtx,
        pResponseHandler);
    
}


HRESULT
CProviderBase::GetObjectAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoGetObjectAsync(
        ObjectPath,
        lFlags,
        pCtx,
        pResponseHandler);
    
}


HRESULT
CProviderBase::PutInstanceAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoPutInstanceAsync(
        pInst,
        lFlags,
        pCtx,
        pResponseHandler);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\sqllex.h ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    sqllex.h

Abstract:

    SQL Level 1 DFA Table & Tokens

History:

--*/

#ifndef _SQLLEX_H_
#define _SQLLEX_H_

#define SQL_1_TOK_EOF           0
#define SQL_1_TOK_ERROR         1
#define SQL_1_TOK_IDENT         100
#define SQL_1_TOK_QSTRING       101
#define SQL_1_TOK_INT           102
#define SQL_1_TOK_REAL          103
#define SQL_1_TOK_CHAR          104
#define SQL_1_TOK_BOOL          105

#define SQL_1_TOK_LE            106
#define SQL_1_TOK_LT            107
#define SQL_1_TOK_GE            108
#define SQL_1_TOK_GT            109
#define SQL_1_TOK_EQ            110
#define SQL_1_TOK_NE            111

#define SQL_1_TOK_DOT           112
#define SQL_1_TOK_OPEN_PAREN    113
#define SQL_1_TOK_CLOSE_PAREN   114
#define SQL_1_TOK_ASTERISK      115
#define SQL_1_TOK_COMMA         116

#define SQL_1_TOK_SELECT        120
#define SQL_1_TOK_WHERE         121
#define SQL_1_TOK_FROM          122
#define SQL_1_TOK_LIKE          123
#define SQL_1_TOK_OR            124
#define SQL_1_TOK_AND           125
#define SQL_1_TOK_NOT           126
#define SQL_1_TOK_IS            127
#define SQL_1_TOK_NULL          128

extern LexEl Sql_1_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\objpath.cpp ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

  OBJPATH.CPP

Abstract:

  Object path parser.

History:

--*/

#include <ole2.h>
#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

inline LPWSTR Macro_CloneLPWSTR(LPCWSTR x)
{
    if (x)
    {
        LPWSTR szTemp = new wchar_t[wcslen(x) + 1];

        if (szTemp)
            wcscpy(szTemp, x);

        return szTemp;
    }
    else
        return NULL;
}

ParsedObjectPath::ParsedObjectPath()
{
    m_pServer = 0;                  // NULL if no server
    m_dwNumNamespaces = 0;          // 0 if no namespaces

    m_dwAllocNamespaces = 2;
    m_paNamespaces = new LPWSTR[m_dwAllocNamespaces];

    if(m_paNamespaces)
		for (unsigned i = 0; i < m_dwAllocNamespaces; i++)
			m_paNamespaces[i] = 0;

    m_pClass = 0;                   // Class name
    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_bSingletonObj = FALSE;
    m_dwAllocKeys = 2;
    m_paKeys = new KeyRef *[m_dwAllocKeys];
}

ParsedObjectPath::~ParsedObjectPath()
{
    if (m_pServer)
        delete m_pServer;

    if (m_paNamespaces)
    {
        for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
            delete m_paNamespaces[dwIx];
        delete m_paNamespaces;
    }

    if (m_pClass)
        delete m_pClass;

    if (m_paKeys)
    {
        for (DWORD dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
            delete m_paKeys[dwIx];
        delete m_paKeys;
    }
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    if (m_pClass)
        delete [] m_pClass;

    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        m_pClass = Macro_CloneLPWSTR(wszClassName);
    }

    return TRUE;
}

BOOL ParsedObjectPath::IsClass()
{
    if(!IsObject())
        return FALSE;

    return (m_dwNumKeys == 0 && !m_bSingletonObj);
}

BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

BOOL ParsedObjectPath::IsObject()
{
    if(m_pClass == NULL)
        return FALSE;

    if(m_pServer)
    {
        return (m_dwNumNamespaces > 0);
    }
    else
    {
        return (m_dwNumNamespaces == 0);
    }
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    if(m_dwNumNamespaces == m_dwAllocNamespaces)
    {
        DWORD dwNewAllocNamespaces = m_dwAllocNamespaces * 2;
        LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];
        if(paNewNamespaces == NULL) return FALSE;
        memcpy(paNewNamespaces, m_paNamespaces,
            sizeof(LPWSTR) * m_dwAllocNamespaces);
        delete [] m_paNamespaces;
        m_paNamespaces = paNewNamespaces;
        m_dwAllocNamespaces = dwNewAllocNamespaces;
    }
    m_paNamespaces[m_dwNumNamespaces++] = Macro_CloneLPWSTR(wszNamespace);
    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue )
{
    BOOL bStatus = TRUE ;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    for ( ULONG dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
    {
        if ( ( m_paKeys [ dwIndex ]->m_pName ) && wszKeyName )
        {
            if ( _wcsicmp ( m_paKeys [ dwIndex ]->m_pName , wszKeyName )
                                                                        == 0 )
            {
                bFound = TRUE ;
                break ;
            }
        }
        else
        {
            if ( ( ( m_paKeys [ dwIndex ]->m_pName ) == 0 ) )
            {
                bUnNamed = TRUE ;
                if ( ( wszKeyName == 0 ) )
                {
                    bFound = TRUE ;
                    break ;
                }
            }
        }
    }

    if ( ! wszKeyName )
    {
        /* Remove all existing keys */

        for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                                                            dwDeleteIndex ++ )
        {
            delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
            m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
            VariantClear ( &  ( m_paKeys [ dwDeleteIndex ]->m_vValue ) ) ;
        }

        VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) , ( VARIANT * ) pvValue );

        m_dwNumKeys = 1 ;
    }
    else
    {
        if ( bFound )
        {
            /*
             *    If key already exists then just replace the value
             */

            if ( wszKeyName )
            {
                m_paKeys [ dwIndex ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                if (!(m_paKeys[dwIndex]->m_pName))
                {
                    return FALSE;
                    
                }
                wcscpy ( m_paKeys [ dwIndex ]->m_pName , wszKeyName ) ;
            }

            VariantClear ( & ( m_paKeys [ dwIndex ]->m_vValue ) ) ;
            VariantCopy ( & ( m_paKeys [ dwIndex ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) ;
        }
        else
        {
            if ( bUnNamed )
            {
                /* Add an un named key */

                for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                        dwDeleteIndex ++ )
                {
                    delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
                    m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
                    VariantClear (& ( m_paKeys [ dwDeleteIndex ]->m_vValue ) );
                }

                m_paKeys [ 0 ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                if (!(m_paKeys[0]->m_pName))
                {
                    return FALSE;
                }
                wcscpy ( m_paKeys [ 0 ]->m_pName , wszKeyName ) ;

                VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) ;

                m_dwNumKeys = 1 ;
            }
            else
            {
                /* Add a Named Key */

                AddKeyRef(wszKeyName, pvValue);
            }
        }
    }

    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
            dwDeleteIndex ++ )
    {
        delete m_paKeys [ dwDeleteIndex ] ;
        m_paKeys [ dwDeleteIndex ] = NULL ;
    }

    delete [] m_paKeys ;
    m_paKeys = NULL ;

    m_dwNumKeys = 0;                // 0 if no keys (just a class name)

    m_paKeys = new KeyRef *[2];
    if (m_paKeys)
        m_dwAllocKeys = 2;
}

BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        if (!paNewKeys)
            return FALSE;

        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

	if(m_paKeys == NULL)
		return FALSE;
    m_paKeys[m_dwNumKeys] = new KeyRef(wszKeyName, pvValue);
    if (!m_paKeys[m_dwNumKeys])
        return FALSE;

    m_dwNumKeys++;
    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        if(paNewKeys == NULL)return FALSE;
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }
    m_paKeys[m_dwNumKeys] = pAcquireRef;
    m_dwNumKeys++;
    return TRUE;
}

KeyRef::KeyRef()
{
    m_pName = 0;
    VariantInit(&m_vValue);
}

KeyRef::KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    m_pName = Macro_CloneLPWSTR(wszKeyName);
    VariantInit(&m_vValue);
    VariantCopy(&m_vValue, (VARIANT*)pvValue);
}

KeyRef::~KeyRef()
{
    if (m_pName)
    {
        delete m_pName;
    }
    VariantClear(&m_vValue);
}




int WINAPI CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    if(pInput->m_pClass == NULL)
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Allocate enough space
    // =====================

    int nSpace = wcslen(pInput->m_pClass);
    nSpace += 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];
        if(pKey->m_pName)
            nSpace += wcslen(pKey->m_pName);
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(    V_VT(&pKey->m_vValue) == VT_I4
                ||  V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            nSpace += 30;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I2
                ||  V_VT(&pKey->m_vValue) == VT_UI2 )

        {
            nSpace += 15;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I1
                ||  V_VT(&pKey->m_vValue) == VT_UI1 )

        {
            nSpace += 8;
        }
    }
    if(pInput->m_bSingletonObj)
        nSpace +=2;

    WCHAR wszTemp[30];
    LPWSTR wszPath = new WCHAR[nSpace];

    if (!wszPath)
        return OutOfMemory;

    wcscpy(wszPath, pInput->m_pClass);


    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];

        // We dont want to put a '.' if there isnt a key name,
        // for example, Myclass="value"
        if(dwIx == 0)
        {
            if((pKey->m_pName && (0 < wcslen(pKey->m_pName))) || pInput->m_dwNumKeys > 1)
                wcscat(wszPath, L".");
        }
        else
        {
            wcscat(wszPath, L",");
        }
        if(pKey->m_pName)
            wcscat(wszPath, pKey->m_pName);
        wcscat(wszPath, L"=");

        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            wcscat(wszPath, L"\"");
            WCHAR* pwc = V_BSTR(&pKey->m_vValue);
            WCHAR str[2];
            str[1] = 0;
            while(*pwc)
            {
                if(*pwc == '\\' || *pwc == '"')
                {
                    wcscat(wszPath, L"\\");
                }
                str[0] = *pwc;
                wcscat(wszPath, str);
                pwc++;
            }

            wcscat(wszPath, L"\"");
        }
        else if( V_VT(&pKey->m_vValue) == VT_I4 )
        {
            swprintf(wszTemp, L"%d", V_I4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            swprintf(wszTemp, L"%u", V_UI4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I2 )
        {
            swprintf(wszTemp, L"%hd", V_I2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI2 )
        {
            swprintf(wszTemp, L"%hu", V_UI2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I1 )
        {
            swprintf(wszTemp, L"%d", V_I1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI1 )
        {
            swprintf(wszTemp, L"%u", V_UI1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
    }

    // Take care of the singleton case.  This is a path of the form
    // MyClass=@  and represents a single instance of a class with no
    // keys.

    if(pInput->m_bSingletonObj && pInput->m_dwNumKeys == 0)
        wcscat(wszPath, L"=@");


    *pwszPath = wszPath;

    return NoError;
}


LPWSTR WINAPI CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}





void CObjectPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CObjectPathParser::Empty()
{
    delete m_pLexer;
    delete m_pInitialIdent;
    delete m_pTmpKeyRef;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CObjectPathParser::~CObjectPathParser()
{
    Empty();
}

int CObjectPathParser::Parse(
    LPCWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    if (pOutput == 0 || pRawPath == 0 || wcslen(pRawPath) == 0)
        return CObjectPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================

    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0]))
        return InvalidParameter;

     // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    // Set default return to NULL initially until we have some output.
    // ===============================================================
    *pOutput = 0;

    m_pOutput = new ParsedObjectPath;
    if (!m_pOutput)
        return OutOfMemory;

    // Parse the server name (if there is one) manually
    // ================================================

    if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
         (pRawPath[0] == '/' && pRawPath[1] == '/'))
    {
        const WCHAR* pwcStart = pRawPath + 2;

        // Find the next backslash --- it's the end of the server name
        // ===========================================================

        const WCHAR* pwcEnd = pwcStart;
        while (*pwcEnd != L'\0' && *pwcEnd != L'\\' && *pwcEnd != L'/')
        {
            pwcEnd++;
        }

        if (*pwcEnd == L'\0')
        {
            // If we have already exhausted the object path string,
            // a lone server name was all there was.
            // ====================================================

            if (m_eFlags != e_ParserAcceptAll)
            {
                delete m_pOutput;
                return SyntaxError;
            }
            else    // A lone server name is legal.
            {
                m_pOutput->m_pServer = new WCHAR[wcslen(pwcStart)+1];

                if (!m_pOutput->m_pServer)
                {
                    delete m_pOutput;
                    return OutOfMemory;
                }

                wcscpy(m_pOutput->m_pServer, pwcStart);

                *pOutput = m_pOutput;
                m_pOutput = 0;

                return NoError;
            }
        }

        if (pwcEnd == pwcStart)
        {
            // No name at all.
            // ===============
            delete m_pOutput;
            return SyntaxError;
        }

        m_pOutput->m_pServer = new WCHAR[pwcEnd-pwcStart+1];
        if (!m_pOutput->m_pServer)
        {
            delete m_pOutput;
            return OutOfMemory;
        }

        wcsncpy(m_pOutput->m_pServer, pwcStart, pwcEnd-pwcStart);
        m_pOutput->m_pServer[pwcEnd-pwcStart] = 0;

        pRawPath = pwcEnd;
    }

    // Point the lexer at the source.
    // ==============================

    CTextLexSource src(pRawPath);
    m_pLexer = new CGenLexer(OPath_LexTable, &src);
    if (!m_pLexer)
    {
        delete m_pOutput;
        return OutOfMemory;
    }

    // Go.
    // ===

    int nRes = begin_parse();
    if (nRes)
    {
        delete m_pOutput;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EOF)
    {
        delete m_pOutput;
        return SyntaxError;
    }

    if (m_pOutput->m_dwNumNamespaces > 0 && m_pOutput->m_pServer == NULL)
    {
        if (m_eFlags != e_ParserAcceptRelativeNamespace && m_eFlags != e_ParserAcceptAll)
        {
            delete m_pOutput;
            return SyntaxError;
        }
        else
        {
            // Local namespace --- set server to "."
            // =====================================
            m_pOutput->m_pServer = new WCHAR[2];
            if (!m_pOutput->m_pServer)
            {
                delete m_pOutput;
                return OutOfMemory;
            }

            wcscpy(m_pOutput->m_pServer, L".");
        }
    }

    // Sort the key refs lexically. If there is only
    // one key, there is nothing to sort anyway.
    // =============================================

    if (m_pOutput->m_dwNumKeys > 1)
    {
        BOOL bChanges = TRUE;
        while (bChanges)
        {
            bChanges = FALSE;
            for (DWORD dwIx = 0; dwIx < m_pOutput->m_dwNumKeys - 1; dwIx++)
            {
                if (_wcsicmp(m_pOutput->m_paKeys[dwIx]->m_pName,
                    m_pOutput->m_paKeys[dwIx+1]->m_pName) > 0)
                {
                    KeyRef *pTmp = m_pOutput->m_paKeys[dwIx];
                    m_pOutput->m_paKeys[dwIx] = m_pOutput->m_paKeys[dwIx + 1];
                    m_pOutput->m_paKeys[dwIx + 1] = pTmp;
                    bChanges = TRUE;
                }
            }
        }
    }


    // Add in key refs.
    // ================
    *pOutput = m_pOutput;
    m_pOutput = 0;
    return NoError;
}

BOOL CObjectPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}


void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    delete pOutput;
}

void CObjectPathParser::Free( LPWSTR wszUnparsedPath )
{
    delete wszUnparsedPath;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <objref>;
//
int CObjectPathParser::begin_parse()
{
    if (!NextToken())
        return SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pInitialIdent = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
        if (!NextToken())
            return SyntaxError;

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================

        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // If here, we had a bad starter token.
    // ====================================

    return SyntaxError;
}

//
//  <ns_or_server> ::= BACKSLASH <dot_or_ident> BACKSLASH <ns_list> <optional_objref>;
//  <ns_or_server> ::= <ns_list> <optional_objref>;
//
//  <dot_or_ident> is embedded.
//
int CObjectPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================

        return SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        int nRes = ns_list();
        if (nRes)
            return nRes;
        return optional_objref();
    }
    else
        if (m_nCurrentToken == OPATH_TOK_EOF)
            return NoError;

    return SyntaxError;
}

//
//  <optional_objref> ::= COLON <objref>;
//  <optional_objref> ::= <>;
//
int CObjectPathParser::optional_objref()
{
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return NoError;

    if (m_nCurrentToken != OPATH_TOK_COLON)
        return SyntaxError;
    if (!NextToken())
        return SyntaxError;
    return objref();
}


//
//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list> COLON <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//
int CObjectPathParser::ns_or_class()
{
    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        return objref();
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        int nRes = ns_list();
        if (nRes)
            return nRes;
        if (m_nCurrentToken == OPATH_TOK_EOF)    // ns only
            return NoError;

        if (m_nCurrentToken != OPATH_TOK_COLON)
            return SyntaxError;
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // Else
    // ====
    ident_becomes_class();
    return objref_rest();
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CObjectPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
        return SyntaxError;

    return objref_rest();
}

//
// <ns_list> ::= IDENT <ns_list_rest>;
//
int CObjectPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pOutput->AddNamespace(m_pLexer->GetTokenText());

        if (!NextToken())
            return SyntaxError;
        return ns_list_rest();
    }

    return SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
int CObjectPathParser::ident_becomes_ns()
{
    m_pOutput->AddNamespace(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CObjectPathParser::ident_becomes_class()
{
    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pInitialIdent);
    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS *;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CObjectPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.


        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            if(NextToken() && m_nCurrentToken != OPATH_TOK_EOF)
                return SyntaxError;
            m_pOutput->m_bSingletonObj = TRUE;
            return NoError;

        }

        m_pTmpKeyRef = new KeyRef;
        if (!m_pTmpKeyRef)
            return OutOfMemory;

        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        m_pOutput->AddKeyRef(m_pTmpKeyRef);
        m_pTmpKeyRef = 0;
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= <>;
//
int CObjectPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
    return NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CObjectPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_BSTR;
        V_BSTR(&m_pTmpKeyRef->m_vValue) = SysAllocString(m_pLexer->GetTokenText());
    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        V_I4(&m_pTmpKeyRef->m_vValue) = atol(buf);
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        long l;
        sscanf(buf, "%x", &l);
        V_I4(&m_pTmpKeyRef->m_vValue) = l;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 1;
          }
       else if (_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 0;
       }
       else
            return SyntaxError;
    }
    else return SyntaxError;

    if (!NextToken())
        return SyntaxError;

    return NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CObjectPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CObjectPathParser::keyref()
{
    m_pTmpKeyRef = new KeyRef;

    if (!m_pTmpKeyRef)
        return OutOfMemory;

    int nRes = propname();

    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    m_pOutput->AddKeyRef(m_pTmpKeyRef);
    m_pTmpKeyRef = 0;

    return NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CObjectPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
// <propname>  ::= IDENT;
//
int CObjectPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pTmpKeyRef->m_pName = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    return NoError;
}

//***************************************************************************
//
//  ParsedObjectPath::GetKeyString
//
//  Returns the db-engine compatible key string for the object.
//  The format will likely change after the Alpha PDK Release.
//
//  Return value:
//  NULL on error or for pure classes.  Otherwise returns a pointer to
//  a newly allocated string which must be deallocated with operator
//  delete.
//
//***************************************************************************
LPWSTR ParsedObjectPath::GetKeyString()
{
    if (m_dwNumKeys == 0 && !m_bSingletonObj)
    {
        if (m_pClass == 0 || wcslen(m_pClass) == 0)
            return 0;

        LPWSTR pTmp = new wchar_t[wcslen(m_pClass) + 1];
        
        if (pTmp)
            wcscpy(pTmp, m_pClass);

        return pTmp;
    }

    // Allocate enough space
    // =====================

    int nSpace = 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = m_paKeys[dwIx];
        nSpace += 2; // for the |
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(m_bSingletonObj)
        nSpace +=20;


    LPWSTR pRetVal = new wchar_t[nSpace];
    wchar_t Tmp[32];
    long nVal;

    if (!pRetVal)
        return NULL;

    *pRetVal = 0;
    BOOL bFirst = TRUE;

    // The key are already sorted lexically.
    // =====================================

    WCHAR wszSeparator[2];
    wszSeparator[0] = 0xFFFF;
    wszSeparator[1] = 0;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (!bFirst)
            wcscat(pRetVal, wszSeparator);
        bFirst = FALSE;

        KeyRef *pKeyRef = m_paKeys[i];
        VARIANT *pv = &pKeyRef->m_vValue;

        int nType = V_VT(pv);
        switch (nType)
        {
            case VT_LPWSTR:
            case VT_BSTR:
                wcscat(pRetVal, V_BSTR(pv));
                break;

            case VT_I4:
                nVal = V_I4(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_I2:
                nVal = V_I2(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_UI1:
                nVal = V_UI1(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_BOOL:
                nVal = V_BOOL(pv);
                swprintf(Tmp, L"%d", (nVal?1:0));
                wcscat(pRetVal, Tmp);
                break;

            default:
                wcscat(pRetVal, L"NULL");
        }
    }

    if (wcslen(pRetVal) == 0)
    {
        if(m_bSingletonObj)
        {
            wcscpy(pRetVal, L"@");
        }
    }
    return pRetVal;     // This may not be NULL
}

LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if (m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];

    if (!wszOut)
        return NULL;

    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_dwNumNamespaces < 2)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    if(wszOut == NULL)return NULL;
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

BOOL ParsedObjectPath::IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace)
{
    if(!IsLocal(wszMachine))
        return FALSE;

    if(m_dwNumNamespaces == 0)
        return TRUE;

    LPWSTR wszCopy = new wchar_t[wcslen(wszNamespace) + 1];
    if(wszCopy == NULL)return FALSE;
    wcscpy(wszCopy, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    BOOL bFailed = FALSE;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        unsigned int nLen = wcslen(m_paNamespaces[i]);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == m_dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != m_dwNumNamespaces - 1 && wszLeft[nLen] != L'\\')
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(_wcsicmp(wszLeft, m_paNamespaces[i]))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;
}

BOOL ParsedObjectPath::IsLocal(LPCWSTR wszMachine)
{
    return (m_pServer == NULL || !_wcsicmp(m_pServer, L".") ||
        !_wcsicmp(m_pServer, wszMachine));
}


////////////////////////////////////////////////////////
//
// Test object path parser by parsing all objects
// in the input file (one object path per line).
// 
////////////////////////////////////////////////////////

#ifdef TEST
void xmain(int argc, char **argv)
{
    printf("Object Path Test\n");
    if (argc < 2 || strchr(argv[1], '?') != NULL)
    {
        printf("Usage: objpath input-file\n");
        return;
    }

    int nLine = 1;
    char buf[2048];
    FILE *f = fopen(argv[1], "rt");
    if (f == NULL)
    {
        printf("Usage: objpath input-file\nError: cannot open file %s!\n", argv[1]);
        return;
    }

    while (fgets(buf, 2048, f) != NULL)
    {
        // Get rid of newline and trailing spaces.
        // =======================================

        char* ptr = strchr(buf, '\n');
        if (ptr != NULL)
        {
            *ptr = ' ';
            while (ptr >= buf && *ptr == ' ')
            {
                *ptr = '\0'; 
                ptr--;
            }
        }

        // Get rid of leading spaces.
        // ==========================

        ptr = buf;
        while (*ptr == ' ')
        {
            ptr++;
        }

        // Convert to wide char and parse.  Ignore blank lines.
        // ====================================================

        if (*ptr != '\0')
        {
            wchar_t buf2[2048];
            MultiByteToWideChar(CP_ACP, 0, ptr, -1, buf2, 2048);

            printf("----Object path----\n");
            printf("%S\n", buf2);

            ParsedObjectPath* pOutput = 0;
            CObjectPathParser p(e_ParserAcceptAll);
            int nStatus = p.Parse(buf2,  &pOutput);

            if (nStatus != 0)
            {
                printf("ERROR: return code is %d\n", nStatus);
                continue;
            }
            printf("No errors.\n");

            printf("------Output------\n");

            LPWSTR pKey = pOutput->GetKeyString();
            printf("Key String = <%S>\n", pKey);
            delete pKey;

            printf("Server = %S\n", pOutput->m_pServer);
            printf("Namespace Part = %S\n", pOutput->GetNamespacePart());
            printf("Parent Part    = %S\n", pOutput->GetParentNamespacePart());

            for (DWORD dwIx = 0; dwIx < pOutput->m_dwNumNamespaces; dwIx++)
            {
                printf("Namespace = <%S>\n", pOutput->m_paNamespaces[dwIx]);
            }

            printf("Class = <%S>\n", pOutput->m_pClass);

            // If here, the key ref is complete.
            // =================================

            for (dwIx = 0; dwIx < pOutput->m_dwNumKeys; dwIx++)
            {
                KeyRef *pTmp = pOutput->m_paKeys[dwIx];
                printf("*** KeyRef contents:\n");
                printf("    Name = %S   Value=", pTmp->m_pName);
                switch (V_VT(&pTmp->m_vValue))
                {
                    case VT_I4: printf("%d", V_I4(&pTmp->m_vValue)); break;
                    case VT_R8: printf("%f", V_R8(&pTmp->m_vValue)); break;
                    case VT_BSTR: printf("<%S>", V_BSTR(&pTmp->m_vValue)); break;
                    default:
                        printf("BAD KEY REF\n");
                }
                printf("\n");
            }

            p.Free(pOutput);
        }
    }
}

void main(int argc, char **argv)
{
        xmain(argc, argv);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\opathlex.cpp ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

  OPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\sqllex.cpp ===
/*++



// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    sqllex.cpp

Abstract:

    SQL Level 1 DFA Table

History:


--*/

#include <ole2.h>
#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <sqllex.h>             

#define ST_STRING   23
#define ST_IDENT    28
#define ST_GE       34
#define ST_LE       36
#define ST_NE       39
#define ST_NUMERIC  41
#define ST_REAL     44
#define ST_STRING2  50
#define ST_STRING_ESC 55
#define ST_STRING2_ESC 56

// DFA State Table for SQL Level 1 lexical symbols.
// ================================================

LexEl Sql_1_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,  SQL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  SQL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, 0,  SQL_1_TOK_DOT,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  SQL_1_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  SQL_1_TOK_EQ,          GLEX_ACCEPT,

/* 9 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 10 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 11 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 12 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 13 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 14 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 15 */ L'-',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 16 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 17 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 18 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 19 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 20 */ 0,      GLEX_EMPTY, 0,  SQL_1_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 21 */ L',',   GLEX_EMPTY, 0,  SQL_1_TOK_COMMA, GLEX_ACCEPT,

    // Unknown characters

/* 22 */ GLEX_ANY, GLEX_EMPTY, 0,        SQL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 23 */   L'\n', GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 24 */   L'\r', GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 25 */   L'"',  GLEX_EMPTY, 0,  SQL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 26 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 27 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 28 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 29 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 30 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 31 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  0x80,   0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  GLEX_ANY, GLEX_EMPTY,  0,       SQL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 34 */  L'=',   GLEX_EMPTY,  0,  SQL_1_TOK_GE,  GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY,  0,       SQL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 36 */  L'=',   GLEX_EMPTY,      0,  SQL_1_TOK_LE,  GLEX_ACCEPT,
/* 37 */  L'>',   GLEX_EMPTY,      0,  SQL_1_TOK_NE,  GLEX_ACCEPT,
/* 38 */  GLEX_ANY, GLEX_EMPTY,    0,  SQL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 39 */  L'=',   GLEX_EMPTY,      0,  SQL_1_TOK_NE,     GLEX_ACCEPT,
/* 40 */  GLEX_ANY,  GLEX_EMPTY,   0,  SQL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 41 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 42 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 43 */  GLEX_ANY, GLEX_EMPTY, 0,          SQL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 44 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 45 */  L'E',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 46 */  L'e',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 47 */  L'+',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 48 */  L'-',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 49 */  GLEX_ANY,       GLEX_EMPTY,   0,     SQL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 50 */   L'\n',  GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 51 */   L'\r',  GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 52 */   L'\'',  GLEX_EMPTY, 0,  SQL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 53 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 54 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 55 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

// ST_STRING2_ESC
/* 56 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\sql_1ext.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    sql_1ext.h

Abstract:

    Extends the SQL_LEVEL_1_RPN_EXPRESSION

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _sql_1ext_h_
#define _sql_1ext_h_

#include <sql_1.h>

struct SQL_LEVEL_1_RPN_EXPRESSION_EXT
{
    SQL_LEVEL_1_RPN_EXPRESSION_EXT()
    {
        m_bContainsOrOrNot = false;
        m_pSqlExpr = NULL;
    }

    ~SQL_LEVEL_1_RPN_EXPRESSION_EXT()
    {
        if (m_pSqlExpr)
        {
            delete m_pSqlExpr;
        }
    }

    void SetContainsOrOrNot()
    {
        if (!m_pSqlExpr)
        {
            return;
        }

        SQL_LEVEL_1_TOKEN* pToken     = m_pSqlExpr->pArrayOfTokens;

        m_bContainsOrOrNot = false;
        for(int i = 0; i < m_pSqlExpr->nNumTokens; i++, pToken++)
        {
            if( pToken->nTokenType == SQL_LEVEL_1_TOKEN::TOKEN_OR ||
                pToken->nTokenType == SQL_LEVEL_1_TOKEN::TOKEN_NOT )
            {
                m_bContainsOrOrNot = true;
                break;
            }
        }
    }

    bool GetContainsOrOrNot() const { return m_bContainsOrOrNot; }

    const SQL_LEVEL_1_TOKEN* GetFilter(LPCWSTR    i_wszProp) const
    {
        if (!m_pSqlExpr)
        {
            return NULL;
        }

        SQL_LEVEL_1_TOKEN* pToken = m_pSqlExpr->pArrayOfTokens;

        for(int i = 0; i < m_pSqlExpr->nNumTokens; i++, pToken++)
        {
             if( pToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION && 
                 _wcsicmp(pToken->pPropertyName, i_wszProp) == 0 )
             {
                 return pToken;
             }
        }
        return NULL;
    }

    bool FindRequestedProperty(LPCWSTR i_wszProp) const
    {
        if (!m_pSqlExpr)
        {
            return false;
        }

        //
        // This means someone did a select *
        //
        if(m_pSqlExpr->nNumberOfProperties == 0)
        {
            return true;
        }

        for(int i = 0; i < m_pSqlExpr->nNumberOfProperties; i++)
        {
            if(_wcsicmp(m_pSqlExpr->pbsRequestedPropertyNames[i], i_wszProp) == 0)
            {
                return true;
            }
        }

        return false;
    }

    SQL_LEVEL_1_RPN_EXPRESSION* m_pSqlExpr;

private:
    bool m_bContainsOrOrNot;
};

#endif // _sql_1ext_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\sql_1.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SQL_1.CPP

Abstract:

  Level 1 Syntax SQL Parser

  Implements the syntax described in SQL_1.BNF.  This translates the input
  into an RPN stream of tokens.

History:

  21-Jun-96       Created.

--*/

#include <ole2.h>
#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <sqllex.h>
#include <sql_1.h>

class CX_Exception {};

class CX_MemoryException : CX_Exception {};

//#define trace(x) printf x
#define trace(x)

static DWORD TranslateIntrinsic(LPWSTR pFuncName)
{
    if (_wcsicmp(pFuncName, L"UPPER") == 0)
        return SQL_LEVEL_1_TOKEN::IFUNC_UPPER;
    if (_wcsicmp(pFuncName, L"LOWER") == 0)
        return SQL_LEVEL_1_TOKEN::IFUNC_LOWER;
    return SQL_LEVEL_1_TOKEN::IFUNC_NONE;
}

SQL1_Parser::SQL1_Parser(CGenLexSource *pSrc)
{
    Init(pSrc);
}

SQL1_Parser::~SQL1_Parser()
{
    Cleanup();
}

void SQL1_Parser::Init(CGenLexSource *pSrc)
{
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    m_pExpression = 0;
    m_pLexer = 0;

    // Semantic transfer variables.
    // ============================
    m_nRelOp = 0;
    VariantInit(&m_vTypedConst);
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_pIdent = 0;
    m_pPropComp = 0;
    m_bConstIsStrNumeric = FALSE;

    if (pSrc)
    {
        m_pLexer = new CGenLexer(Sql_1_LexTable, pSrc);
        m_pExpression = new SQL_LEVEL_1_RPN_EXPRESSION;
    }
}

void SQL1_Parser::Cleanup()
{
    VariantClear(&m_vTypedConst);
    delete m_pIdent;
    delete m_pPropComp;
    delete m_pLexer;
    delete m_pExpression;
}

void SQL1_Parser::SetSource(CGenLexSource *pSrc)
{
    Cleanup();
    Init(pSrc);
}

int SQL1_Parser::GetQueryClass(
    LPWSTR pDestBuf,
    int nBufLen
    )
{
    if ((!m_pLexer) || (!pDestBuf))
    {
        return FAILED;
    }

    // Scan until 'FROM' and then get the class name.
    // ==============================================

    for (;;)
    {
        m_nCurrentToken = m_pLexer->NextToken();

        if (m_nCurrentToken == SQL_1_TOK_EOF)
        {
            m_pLexer->Reset();
            return FAILED;
        }

        if (_wcsicmp(m_pLexer->GetTokenText(), L"from") == 0)
        {
            m_nCurrentToken = m_pLexer->NextToken();
            if (m_nCurrentToken != SQL_1_TOK_IDENT)
            {
                m_pLexer->Reset();
                return FAILED;
            }

            // If here, we have the class name.
            // ================================
            if (wcslen(m_pLexer->GetTokenText()) >= (size_t)nBufLen)
            {
                m_pLexer->Reset();
                return BUFFER_TOO_SMALL;
            }

            wcscpy(pDestBuf, m_pLexer->GetTokenText());
            break;
        }
    }

    // Reset the scanner.
    // ==================
    m_pLexer->Reset();

    return SUCCESS;
}

int SQL1_Parser::Parse(SQL_LEVEL_1_RPN_EXPRESSION **pOutput)
{
    if ((!m_pLexer) || (!pOutput))
    {
        return FAILED;
    }

    *pOutput = 0;

    int nRes = parse();
    if (nRes)
        return nRes;

    *pOutput = m_pExpression;
    m_pExpression = 0;

    return SUCCESS;
}

LPSTR ToAnsi(LPWSTR Src)
{
    static char buf[256];
    WideCharToMultiByte(CP_ACP, NULL, Src, -1, buf, 256, NULL, NULL);
    return buf;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

BOOL SQL1_Parser::Next()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == SQL_1_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == SQL_1_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check.
    // ==============

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        if (_wcsicmp(m_pTokenText, L"select") == 0)
            m_nCurrentToken = SQL_1_TOK_SELECT;
        else if (_wcsicmp(m_pTokenText, L"from") == 0)
            m_nCurrentToken = SQL_1_TOK_FROM;
        else if (_wcsicmp(m_pTokenText, L"where") == 0)
            m_nCurrentToken = SQL_1_TOK_WHERE;
        else if (_wcsicmp(m_pTokenText, L"like") == 0)
            m_nCurrentToken = SQL_1_TOK_LIKE;
        else if (_wcsicmp(m_pTokenText, L"or") == 0)
            m_nCurrentToken = SQL_1_TOK_OR;
        else if (_wcsicmp(m_pTokenText, L"and") == 0)
            m_nCurrentToken = SQL_1_TOK_AND;
        else if (_wcsicmp(m_pTokenText, L"not") == 0)
            m_nCurrentToken = SQL_1_TOK_NOT;
        else if (_wcsicmp(m_pTokenText, L"IS") == 0)
            m_nCurrentToken = SQL_1_TOK_IS;
        else if (_wcsicmp(m_pTokenText, L"NULL") == 0)
            m_nCurrentToken = SQL_1_TOK_NULL;
        else if (_wcsicmp(m_pTokenText, L"TRUE") == 0)
        {
            m_nCurrentToken = SQL_1_TOK_BOOL;
            m_pTokenText = L"65535";
        }
        else if (_wcsicmp(m_pTokenText, L"FALSE") == 0)
        {
            m_nCurrentToken = SQL_1_TOK_BOOL;
            m_pTokenText = L"0";
        }
    }

    return TRUE;
}

//***************************************************************************
//
// <parse> ::= SELECT <prop_list> FROM <classname> WHERE <expr>;
//
//***************************************************************************
// ok

int SQL1_Parser::parse()
{
    int nRes;

    // SELECT
    // ======
    if (!Next())
        return LEXICAL_ERROR;
    if (m_nCurrentToken != SQL_1_TOK_SELECT)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // <prop_list>
    // ===========
    if (nRes = prop_list())
        return nRes;

    // FROM
    // ====
    if (m_nCurrentToken != SQL_1_TOK_FROM)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // <classname>
    // ===========
    if (nRes = class_name())
        return nRes;

    // WHERE clause.
    // =============
    return opt_where();
}

//***************************************************************************
//
//  <opt_where> ::= WHERE <expr>;
//  <opt_where> ::= <>;
//
//***************************************************************************
int SQL1_Parser::opt_where()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_EOF)
    {
        trace(("No WHERE clause\n"));
        return SUCCESS;
    }

    if (m_nCurrentToken != SQL_1_TOK_WHERE)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    // <expr>
    // ======
    if (nRes = expr())
        return nRes;

    // Verify that the current token is SQL_1_TOK_EOF.
    // ===============================================
    if (m_nCurrentToken != SQL_1_TOK_EOF)
        return SYNTAX_ERROR;

    return SUCCESS;
}



//***************************************************************************
//
//  <prop_list> ::= <property_name> <prop_list_2>;
//
//***************************************************************************

int SQL1_Parser::prop_list()
{
    int nRes;

    if (m_nCurrentToken != SQL_1_TOK_ASTERISK &&
        m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (nRes = property_name())
        return nRes;

    if (!Next())
        return LEXICAL_ERROR;

    return prop_list_2();
}

//***************************************************************************
//
//  <prop_list_2> ::= COMMA <prop_list>;
//  <prop_list_2> ::= <>;
//
//***************************************************************************

int SQL1_Parser::prop_list_2()
{
    if (m_nCurrentToken == SQL_1_TOK_COMMA)
    {
        if (!Next())
            return LEXICAL_ERROR;
        return prop_list();
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <property_name> ::= PROPERTY_NAME_STRING;
//  <property_name> ::= ASTERISK;
//
//***************************************************************************

int SQL1_Parser::property_name()
{
    try
    {
        if (m_nCurrentToken == SQL_1_TOK_ASTERISK)
        {
            trace(("Asterisk\n"));

            // We need to clean up the expression so far.
            for (int i = 0; i < m_pExpression->nNumberOfProperties; i++)
                SysFreeString(m_pExpression->pbsRequestedPropertyNames[i]);

            m_pExpression->nNumberOfProperties = 0;
                // This signals 'all properties' to the evaluator
            return SUCCESS;
        }

        // Else a property name.
        // =====================

        trace(("Property name %S\n", m_pTokenText));

        m_pExpression->AddProperty(m_pTokenText);
    }
    catch (...)
    {
        return FAILED;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <classname> ::= CLASS_NAME_STRING;
//
//***************************************************************************

int SQL1_Parser::class_name()
{
    if (m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    trace(("Class name is %S\n", m_pTokenText));
    m_pExpression->bsClassName = SysAllocString(m_pTokenText);

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr> ::= <term> <expr2>;
//
//***************************************************************************

int SQL1_Parser::expr()
{
    int nRes;

    if (nRes = term())
        return nRes;

    if (nRes = expr2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr2> ::= OR <term> <expr2>;
//  <expr2> ::= <>;
//
//  Entry: Assumes token OR already current.
//  Exit:  Advances a token
//
//***************************************************************************

int SQL1_Parser::expr2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == SQL_1_TOK_OR)
        {
            trace(("Token OR\n"));

            if (!Next())
                return LEXICAL_ERROR;

            if (nRes = term())
                return nRes;

            SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
            pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
            m_pExpression->AddToken(pNewTok);
        }
        else break;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <term> ::= <simple_expr> <term2>;
//
//***************************************************************************

int SQL1_Parser::term()
{
    int nRes;
    if (nRes = simple_expr())
        return nRes;

    if (nRes = term2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <term2> ::= AND <simple_expr> <term2>;
//  <term2> ::= <>;
//
//***************************************************************************

int SQL1_Parser::term2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == SQL_1_TOK_AND)
        {
            trace(("Token AND\n"));

            if (!Next())
                return LEXICAL_ERROR;

            if (nRes = simple_expr())
                return nRes;

            // Add the AND token.
            // ==================
            SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
            pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
            m_pExpression->AddToken(pNewTok);
        }
        else break;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <simple_expr> ::= NOT <expr>;
//  <simple_expr> ::= OPEN_PAREN <expr> CLOSE_PAREN;
//  <simple_expr> ::= IDENTIFIER <leading_ident_expr> <finalize>;
//  <simple_expr> ::= VARIANT <rel_operator> <trailing_prop_expr> <finalize>;
//
//***************************************************************************
// ok
int SQL1_Parser::simple_expr()
{
    int nRes;

    // NOT <expr>
    // ==========
    if (m_nCurrentToken == SQL_1_TOK_NOT)
    {
        trace(("Operator NOT\n"));
        if (!Next())
            return LEXICAL_ERROR;
        if (nRes = simple_expr())
            return nRes;

        SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
        pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
        m_pExpression->AddToken(pNewTok);

        return SUCCESS;
    }

    // OPEN_PAREN <expr> CLOSE_PAREN
    // =============================
    else if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        trace(("Open Paren: Entering subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;
        if (expr())
            return SYNTAX_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        trace(("Close paren: Exiting subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // IDENTIFIER <leading_ident_expr> <finalize>
    // ==========================================
    else if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        trace(("    Identifier <%S>\n", m_pTokenText));

        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        if (!m_pIdent)
        {
            return FAILED;
        }
        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;

        if (nRes = leading_ident_expr())
            return SYNTAX_ERROR;

        return finalize();
    }

    // <typed_constant> <rel_operator> <trailing_prop_expr> <finalize>
    // ======================================================
    else if (m_nCurrentToken == SQL_1_TOK_INT ||
             m_nCurrentToken == SQL_1_TOK_REAL ||
             m_nCurrentToken == SQL_1_TOK_QSTRING
            )
    {
        if (nRes = typed_constant())
            return nRes;

        if (nRes = rel_operator())
            return nRes;

        if (nRes = trailing_prop_expr())
            return nRes;

        return finalize();
    }

    return SYNTAX_ERROR;
}


//***************************************************************************
//
//  <trailing_prop_expr> ::=  IDENTIFIER <trailing_prop_expr2>;
//
//***************************************************************************
// ok
int SQL1_Parser::trailing_prop_expr()
{
    if (m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (!m_pIdent)
    {
        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        if (!m_pIdent)
        {
            return FAILED;
        }
        wcscpy(m_pIdent, m_pTokenText);
    }
    else
    {
        m_pPropComp = new wchar_t[wcslen(m_pTokenText) + 1];
        if (!m_pPropComp)
        {
            return FAILED;
        }
        wcscpy(m_pPropComp, m_pTokenText);
    }

    if (!Next())
        return LEXICAL_ERROR;

    return trailing_prop_expr2();
}

//***************************************************************************
//
//  <trailing_prop_expr2> ::= OPEN_PAREN IDENTIFIER CLOSE_PAREN;
//  <trailing_prop_expr2> ::= <>;
//
//***************************************************************************
// ok

int SQL1_Parser::trailing_prop_expr2()
{
    if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;

        // If we got to this point, the string pointed to by m_pIdent
        // was an intrinsic function and not a property name, and we
        // are about to get the property name, so we have to translate
        // the function name to its correct code before overwriting it.
        // ============================================================
        trace(("Translating intrinsic function %S\n", m_pIdent));
        m_dwPropFunction = TranslateIntrinsic(m_pIdent);
        delete m_pIdent;

        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        if (!m_pIdent)
        {
            return FAILED;
        }
        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;

        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;
    }

    trace(("Property name is %S\n", m_pIdent));
    return SUCCESS;
}


//***************************************************************************
//
//  <leading_ident_expr> ::= OPEN_PAREN <unknown_func_expr>;
//  <leading_ident_expr> ::= <comp_operator> <trailing_const_expr>;
//  <leading_ident_expr> ::= <equiv_operator> <trailing_or_null>;
//  <leading_ident_expr> ::= <is_operator> NULL;
//
//***************************************************************************
// ok
int SQL1_Parser::leading_ident_expr()
{
    int nRes;
    if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;
        return unknown_func_expr();
    }
    if (SUCCESS ==  comp_operator() || SUCCESS == equiv_operator())
        return trailing_or_null();
    nRes = is_operator();
    if(nRes != SUCCESS)
        return nRes;
    if (m_nCurrentToken != SQL_1_TOK_NULL)
        return LEXICAL_ERROR;
    if (Next())
    {
        V_VT(&m_vTypedConst) = VT_NULL;
        return SUCCESS;
    }
    else
        return LEXICAL_ERROR;
}


//***************************************************************************
//
//  <unknown_func_expr> ::= IDENTIFIER CLOSE_PAREN
//                          <rel_operator> <trailing_const_expr>;
//
//  <unknown_func_expr> ::= <typed_constant> CLOSE_PAREN
//                          <rel_operator> <trailing_prop_expr>;
//
//***************************************************************************
// ok
int SQL1_Parser::unknown_func_expr()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        m_dwPropFunction = TranslateIntrinsic(m_pIdent);
        delete m_pIdent;
        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        if (!m_pIdent)
        {
            return FAILED;
        }
        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;
        if (nRes = rel_operator())
            return nRes;
        return trailing_const_expr();
    }

    // Else the other production.
    // ==========================

    if (nRes = typed_constant())
        return nRes;

    // If here, we know that the leading ident was
    // an intrinsic function.
    // ===========================================

    m_dwConstFunction = TranslateIntrinsic(m_pIdent);
    delete m_pIdent;
    m_pIdent = 0;

    if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;
    if (nRes = rel_operator())
        return nRes;

    return trailing_prop_expr();
}

//***************************************************************************
//
//  <trailing_or_null> ::= NULL;
//  <trailing_or_null> ::= <trailing_const_expr>;
//  <trailing_or_null> ::= <trailing_prop_expr>;
//
//***************************************************************************

int SQL1_Parser::trailing_or_null()
{
    int nRes;
    if (m_nCurrentToken == SQL_1_TOK_NULL)
    {
        if (!Next())
            return LEXICAL_ERROR;
        else
        {
            V_VT(&m_vTypedConst) = VT_NULL;
            return SUCCESS;
        }
    }
    else if (!(nRes = trailing_const_expr()))
        return nRes;
    return trailing_prop_expr();
}

//***************************************************************************
//
//  <trailing_const_expr> ::= IDENTIFIER OPEN_PAREN
//                            <typed_constant> CLOSE_PAREN;
//  <trailing_const_expr> ::= <typed_constant>;
//
//***************************************************************************
// ok
int SQL1_Parser::trailing_const_expr()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        trace(("Function applied to typed const = %S\n", m_pTokenText));

        m_dwConstFunction = TranslateIntrinsic(m_pTokenText);
        if (!m_dwConstFunction)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_OPEN_PAREN)
            return SYNTAX_ERROR;
    if (!Next())
            return LEXICAL_ERROR;

        if (nRes = typed_constant())
            return nRes;

        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    return typed_constant();
}

//***************************************************************************
//
//  <finalize> ::= <>;
//
//  This composes the SQL_LEVEL_1_TOKEN for a simple relational expression,
//  complete with any associated intrinsic functions.  All of the other
//  parse functions help isolate the terms of the expression, but only
//  this function builds the token.
//
//  To build the token, the following member variables are used:
//      m_pPropName
//      m_vTypedConst
//      m_dwPropFunction
//      m_dwConstFunction
//      m_nRelOp;
//
//  After the token is built, these are cleared/deallocated as appropriate.
//  No tokens are consumed and the input is not advanced.
//
//***************************************************************************
int SQL1_Parser::finalize()
{
    // At this point, we have all the info needed for a token.
    // =======================================================

    SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
    if (!pNewTok)
        return FAILED;

    pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::OP_EXPRESSION;
    pNewTok->pPropertyName = SysAllocString(m_pIdent);
    if (m_pPropComp)
        pNewTok->pPropName2 = SysAllocString(m_pPropComp);
    pNewTok->nOperator = m_nRelOp;
    VariantInit(&pNewTok->vConstValue);
    VariantCopy(&pNewTok->vConstValue, &m_vTypedConst);
    pNewTok->dwPropertyFunction = m_dwPropFunction;
    pNewTok->dwConstFunction = m_dwConstFunction;
    pNewTok->bConstIsStrNumeric = m_bConstIsStrNumeric;

    m_pExpression->AddToken(pNewTok);

    // Cleanup.
    // ========
    VariantClear(&m_vTypedConst);
    delete m_pIdent;
    m_pIdent = 0;
    m_nRelOp = 0;
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_bConstIsStrNumeric = FALSE;

    return SUCCESS;
}

//***************************************************************************
//
//  <typed_constant> ::= VARIANT;
//
//  Ouput: m_vTypedConst is set to the value of the constant. The only
//         supported types are VT_I4, VT_R8 and VT_BSTR.
//
//***************************************************************************

int SQL1_Parser::typed_constant()
{
    trace(("    Typed constant <%S> ", m_pTokenText));
    VariantClear(&m_vTypedConst);
    m_bConstIsStrNumeric = FALSE;

    if (m_nCurrentToken == SQL_1_TOK_INT)
    {
        trace((" Integer\n"));
        DWORD x = wcslen(m_pTokenText);

        if (*m_pTokenText == L'-')
        {
            //negative

            if ((x < 11) ||
                ((x == 11) && (wcscmp(m_pTokenText, L"-2147483648") <= 0)))
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = _wtol(m_pTokenText);
            }
            else
            {
                trace((" Actually Integer String\n"));
                V_VT(&m_vTypedConst) = VT_BSTR;
                V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
                m_bConstIsStrNumeric = TRUE;
            }
        }
        else
        {
            //positive

            if ((x < 10) ||
                ((x == 10) && (wcscmp(m_pTokenText, L"2147483647") <= 0)))
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = _wtol(m_pTokenText);
            }
            else
            {
                trace((" Actually Integer String\n"));
                V_VT(&m_vTypedConst) = VT_BSTR;
                V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
                m_bConstIsStrNumeric = TRUE;
            }
        }

    }
    else if (m_nCurrentToken == SQL_1_TOK_QSTRING)
    {
        trace((" String\n"));
        V_VT(&m_vTypedConst) = VT_BSTR;
        V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
    }
    else if (m_nCurrentToken == SQL_1_TOK_REAL)
    {
        trace((" Real\n"));
        V_VT(&m_vTypedConst) = VT_R8;
        V_R8(&m_vTypedConst) = 0.0;

        if (m_pTokenText)
        {
            VARIANT varFrom;
            varFrom.vt = VT_BSTR;
            varFrom.bstrVal = SysAllocString(m_pTokenText);

            if(varFrom.bstrVal != NULL)
            {
                VariantClear(&m_vTypedConst);
                VariantInit(&m_vTypedConst);
                SCODE sc = VariantChangeTypeEx(&m_vTypedConst, &varFrom, 0, 0x409, VT_R8);
                VariantClear(&varFrom);

                if(sc != S_OK)
                {
                    VariantClear(&m_vTypedConst);
                    VariantInit(&m_vTypedConst);
                    return LEXICAL_ERROR;
                }
            }
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_BOOL)
    {
        trace((" Bool\n"));
        V_VT(&m_vTypedConst) = VT_BOOL;
        if (m_pTokenText && _wcsicmp(m_pTokenText, L"65535") == 0)
        {
            V_BOOL(&m_vTypedConst) = VARIANT_TRUE;
        }
        else
            V_BOOL(&m_vTypedConst) = VARIANT_FALSE;
    }
    // Else, not a typed constant.
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <rel_operator> ::= <equiv_operator>;
//  <rel_operator> ::= <comp_operator>;
//
//***************************************************************************

int SQL1_Parser::rel_operator()
{
    if(SUCCESS == equiv_operator())
        return SUCCESS;
    else if (SUCCESS == comp_operator())
        return SUCCESS;
    else return LEXICAL_ERROR;
}

//***************************************************************************
//
//  <equiv_operator> ::= EQUIV_OPERATOR; // =, !=
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::equiv_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == SQL_1_TOK_EQ)
    {
        trace(("    REL OP =\n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUAL;
    }
    else if (m_nCurrentToken == SQL_1_TOK_NE)
    {
        trace(("    REL OP <> (!=) \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
    }
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <is_operator> ::= IS_OPERATOR; // is, isnot
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::is_operator()
{
    m_nRelOp = 0;
    if (m_nCurrentToken != SQL_1_TOK_IS)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == SQL_1_TOK_NOT)
    {
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        if (!Next())
            return LEXICAL_ERROR;

        trace(("    REL OP IS NOT \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        return SUCCESS;
    }
    else
    {
        trace(("    REL OP IS \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUAL;
        return SUCCESS;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <comp_operator> ::= COMP_OPERATOR; // <=, >=, <, >, like
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::comp_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == SQL_1_TOK_LE)
    {
        trace(("    REL OP <=\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
        }
        else
        {
            trace(("    REL OP changed to >=\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_LT)
    {
        trace(("    REL OP <\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LESSTHAN;
        }
        else
        {
            trace(("    REL OP changed to >\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_GREATERTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_GE)
    {
        trace(("    REL OP >=\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
        }
        else
        {
            trace(("    REL OP changed to <=\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_GT)
    {
        trace(("    REL OP >\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_GREATERTHAN;
        }
        else
        {
            trace(("    REL OP changed to <\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LESSTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_LIKE)
    {
        trace(("    REL OP 'like' \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LIKE;
    }
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  Expression and token structure methods.
//
//***************************************************************************

SQL_LEVEL_1_RPN_EXPRESSION::SQL_LEVEL_1_RPN_EXPRESSION()
{
    nNumTokens = 0;
    pArrayOfTokens = 0;
    bsClassName = 0;
    nNumberOfProperties = 0;
    pbsRequestedPropertyNames = 0;
    nCurSize = 32;
    nCurPropSize = 32;
    pArrayOfTokens = new SQL_LEVEL_1_TOKEN[nCurSize];
    pbsRequestedPropertyNames = new BSTR[nCurPropSize];

}

SQL_LEVEL_1_RPN_EXPRESSION::~SQL_LEVEL_1_RPN_EXPRESSION()
{
    delete [] pArrayOfTokens;
    if (bsClassName)
        SysFreeString(bsClassName);
    for (int i = 0; i < nNumberOfProperties; i++)
        SysFreeString(pbsRequestedPropertyNames[i]);
    delete pbsRequestedPropertyNames;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddToken(SQL_LEVEL_1_TOKEN *pTok)
{
    AddToken(*pTok);
    delete pTok;
    pTok = NULL;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddToken(SQL_LEVEL_1_TOKEN &pTok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 32;
        SQL_LEVEL_1_TOKEN *pTemp = new SQL_LEVEL_1_TOKEN[nCurSize];
        if (pTemp)
        {
            for (int i = 0; i < nNumTokens; i++)
                pTemp[i] = pArrayOfTokens[i];
            delete [] pArrayOfTokens;
            pArrayOfTokens = pTemp;
        }
    }

    if (pArrayOfTokens)
    {
        pArrayOfTokens[nNumTokens++] = pTok;
    }
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddProperty (LPWSTR pProp)
{
    if (nCurPropSize == nNumberOfProperties)
    {
        nCurPropSize += 32;
        BSTR *pTemp = new BSTR[nCurPropSize];
        if (!pTemp)
            throw CX_MemoryException();

        if (pbsRequestedPropertyNames)
            memcpy(pTemp, pbsRequestedPropertyNames,
                sizeof(BSTR) * nNumberOfProperties);
        else
        {
            delete [] pTemp;
            throw CX_MemoryException();
        }

        delete pbsRequestedPropertyNames;
        pbsRequestedPropertyNames = pTemp;
    }

    pbsRequestedPropertyNames[nNumberOfProperties++] = SysAllocString(pProp);
}

void SQL_LEVEL_1_RPN_EXPRESSION::Dump(const char *pszTextFile)
{
    FILE *f = fopen(pszTextFile, "wt");
    if (!f)
        return;

    fprintf(f, "----RPN Expression----\n");
    fprintf(f, "Class name = %S\n", bsClassName);
    fprintf(f, "Properties selected: ");

    if (!nNumberOfProperties)
    {
        fprintf(f, "* = all properties selected\n");
    }
    else for (int i = 0; i < nNumberOfProperties; i++)
    {
        fprintf(f, "%S ", pbsRequestedPropertyNames[i]);
    }
    fprintf(f, "\n------------------\n");
    fprintf(f, "Tokens:\n");

    for (int i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i].Dump(f);

    fprintf(f, "---end of expression---\n");
    fclose(f);
}

SQL_LEVEL_1_TOKEN::SQL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    pPropertyName = 0;
    pPropName2 = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bConstIsStrNumeric = FALSE;
}

SQL_LEVEL_1_TOKEN::SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN &Src)
{
    nTokenType = 0;
    pPropertyName = 0;
    pPropName2 = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bConstIsStrNumeric = FALSE;

    *this = Src;
}

SQL_LEVEL_1_TOKEN& SQL_LEVEL_1_TOKEN::operator =(SQL_LEVEL_1_TOKEN &Src)
{
    //first clear any old values...
    if (pPropertyName)
        SysFreeString(pPropertyName);
    if (pPropName2)
        SysFreeString(pPropName2);

    VariantClear(&vConstValue);

    nTokenType = Src.nTokenType;
    pPropertyName = SysAllocString(Src.pPropertyName);
    if (Src.pPropName2)
        pPropName2 = SysAllocString(Src.pPropName2);
    nOperator = Src.nOperator;
    VariantCopy(&vConstValue, &Src.vConstValue);
    dwPropertyFunction = Src.dwPropertyFunction;
    dwConstFunction = Src.dwConstFunction;
    bConstIsStrNumeric = Src.bConstIsStrNumeric;
    return *this;
}

SQL_LEVEL_1_TOKEN::~SQL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    if (pPropertyName)
        SysFreeString(pPropertyName);
    if (pPropName2)
        SysFreeString(pPropName2);

    nOperator = 0;
    VariantClear(&vConstValue);
}

void SQL_LEVEL_1_TOKEN::Dump(FILE *f)
{
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            fprintf(f, "OP_EXPRESSION ");
            break;
        case TOKEN_AND:
            fprintf(f, "TOKEN_AND ");
            break;
        case TOKEN_OR:
            fprintf(f, "TOKEN_OR ");
            break;
        case TOKEN_NOT:
            fprintf(f, "TOKEN_NOT ");
            break;
        default:
            fprintf(f, "Error: no token type specified\n");
    }

    if (nTokenType == OP_EXPRESSION)
    {
        char *pOp = "<no op>";
        switch (nOperator)
        {
            case OP_EQUAL: pOp = "OP_EQUAL"; break;
            case OP_NOT_EQUAL: pOp = "OP_NOT_EQUAL"; break;
            case OP_EQUALorGREATERTHAN: pOp = "OP_EQUALorGREATERTHAN"; break;
            case OP_EQUALorLESSTHAN: pOp = "OP_EQUALorLESSTHAN"; break;
            case OP_LESSTHAN: pOp = "OP_LESSTHAN"; break;
            case OP_GREATERTHAN: pOp = "OP_GREATERTHAN"; break;
            case OP_LIKE: pOp = "OP_LIKE"; break;
        }

        fprintf(f, "    Property = %S\n", pPropertyName);
        fprintf(f, "    Operator = %s\n", pOp);
        fprintf(f, "    Value =    ");
        if (pPropName2)
            fprintf(f, "   <Property:%S\n", pPropName2);
        else
        {
            switch (V_VT(&vConstValue))
            {
                case VT_I4:
                    fprintf(f, "VT_I4 = %d\n", V_I4(&vConstValue));
                    break;
                case VT_BSTR:
                    fprintf(f, "VT_BSTR = %S\n", V_BSTR(&vConstValue));
                    break;
                case VT_R8:
                    fprintf(f, "VT_R8 = %f\n", V_R8(&vConstValue));
                    break;
                case VT_BOOL:
                    fprintf(f, "VT_BOOL = %d (%s)\n",
                        V_BOOL(&vConstValue),
                        V_BOOL(&vConstValue) == VARIANT_TRUE ? "VARIANT_TRUE" : "VARIANT_FALSE"
                        );
                    break;
                default:
                    fprintf(f, "<unknown>\n");
            }
        }

        switch (dwPropertyFunction)
        {
            case IFUNC_NONE:
                break;
            case IFUNC_LOWER:
                fprintf(f, "Intrinsic function LOWER() applied to property\n");
                break;
            case IFUNC_UPPER:
                fprintf(f, "Intrinsic function UPPER() applied to property\n");
                break;
        }
        switch (dwConstFunction)
        {
            case IFUNC_NONE:
                break;
            case IFUNC_LOWER:
                fprintf(f, "Intrinsic function LOWER() applied to const value\n");
                break;
            case IFUNC_UPPER:
                fprintf(f, "Intrinsic function UPPER() applied to const value\n");
                break;
        }

    }

    fprintf(f, " <end of token>\n");
}

/////////////////////////////////////////////////////////////////////////////
//
// Algorithm for evaluating the expression, assuming that it has been
// tokenized and translated to Reverse Polish.
//
// Starting point:  (a) An array of SQL tokens.
//                  (b) An empty boolean token stack.
//
// 1.  Read Next Token
//
// 2.  If a SIMPLE EXPRESSION, evaluate it to TRUE or FALSE, and
//     place this boolean result on the stack.  Go to 1.
//
// 3.  If an OR operator, then pop a boolean token into A,
//     pop another boolean token into B. If either A or B are TRUE,
//     stack TRUE.  Else stack FALSE.
//     Go to 1.
//
// 4.  If an AND operator, then pop a boolean token into A,
//     and pop another into B.  If both are TRUE, stack TRUE.
//     Else stack FALSE.
//     Go to 1.
//
// 5.  If a NOT operator, reverse the value of the top-of-stack boolean.
//     Go to 1.
//
// At end-of-input, the result is at top-of-stack.
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\providerbase.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    ProviderBase.h

Abstract:

    Definition of:
        CProviderBase

Author:

    ???

Revision History:

    Mohit Srivastava            10-Nov-2000

--*/

#ifndef __providerbase_h__
#define __providerbase_h__

#if _MSC_VER > 1000
#pragma once
#endif 

#include "WbemServices.h"

typedef LPVOID * PPVOID;

//
// CProviderBase
// Purpose: provide a general solution for impersonate client for 
// Wbem providers.
// USAGE:
// Inherit from this class, and implement abstact virtual functions.
// child class should implement function prefixed with "Do".
//
class CProviderBase : public IWbemServices, public IWbemProviderInit, public IWbemShutdown 
{
protected:
    ULONG           m_cRef;                 // Object reference count
    CWbemServices*  m_pNamespace;
 
public:
    CProviderBase(
        const BSTR    = NULL, 
        const BSTR    = NULL, 
        const BSTR    = NULL, 
        IWbemContext* = NULL);

    virtual ~CProviderBase();

    //
    // Non-delegating object IUnknown
    //
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    //IWbemProviderInit
    //
    HRESULT STDMETHODCALLTYPE Initialize(
         /* [in] */ LPWSTR wszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR wszNamespace,
         /* [in] */ LPWSTR wszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink
         );

    //
    //IWbemShutdown
    //
    HRESULT STDMETHODCALLTYPE Shutdown( 
         /* [in] */ LONG uReason,
         /* [in] */ ULONG uMaxMilliseconds,
         /* [in] */ IWbemContext *pCtx
         );

    //
    //IWbemServices  
    //
    HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE ExecMethod( 
        const BSTR, 
        const BSTR, 
        long, 
        IWbemContext*,
        IWbemClassObject*,
        IWbemClassObject**, 
        IWbemCallResult**) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecMethodAsync(
        const BSTR,
        const BSTR, 
        long, 
        IWbemContext*,
        IWbemClassObject*,
        IWbemObjectSink*);

protected:
    virtual HRESULT STDMETHODCALLTYPE DoInitialize(
         /* [in] */ LPWSTR wszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR wszNamespace,
         /* [in] */ LPWSTR wszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
        /* [in] */ const BSTR,                      // Class,
        /* [in] */ long,                            // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,        // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *      // pResponseHandler
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
        /* [in] */ const BSTR ,                     // ObjectPath,
        /* [in] */ long,                            // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,        // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *      // pResponseHandler
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        /* [in] */ const BSTR,
        /* [in] */ const BSTR, 
        /* [in] */ long, 
        /* [in] */ IWbemContext*,
        /* [in] */ IWbemClassObject*,
        /* [in] */ IWbemObjectSink*
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
        /* [in] */ const BSTR,                      // QueryLanguage,
        /* [in] */ const BSTR,                      // Query,
        /* [in] */ long,                            // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,        // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *      // pResponseHandler
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *,    // pInst,
        /* [in] */ long ,   // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,        // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *      // pResponseHandler
        ) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\wbemobjectsink.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    WbemObjectSink.cpp

Abstract:

    Implementation of:
        CWbemObjectSink

Author:

    ???

Revision History:

    Mohit Srivastava            10-Nov-2000

--*/

#include "WbemObjectSink.h"
#include <dbgutil.h>

CWbemObjectSink::CWbemObjectSink(
    IWbemObjectSink* pHandler,
    DWORD            dwSize)
    :m_pSink(NULL), m_ppInst(NULL), m_dwIndex(0)
{
    m_pSink = pHandler;
    if(m_pSink != NULL)
    {
        m_pSink->AddRef();
    }
    m_dwThreshHold = dwSize;

    m_ppInst       = new IWbemClassObject*[dwSize];

    if ( m_ppInst )
    {
        memset(m_ppInst, 0, sizeof(IWbemClassObject*) * dwSize);
    }
}

CWbemObjectSink::~CWbemObjectSink()
{
    if(m_ppInst != NULL)
    {
        if(m_dwIndex >0)
        {
            m_pSink->Indicate(
                m_dwIndex,
                m_ppInst);
        }

        for(DWORD i =0; i<m_dwIndex; i++)
        {
            if(m_ppInst[i] != NULL)
            {
                (m_ppInst[i])->Release();
            }
        }
        delete [] m_ppInst;
    }

    if(m_pSink != NULL)
    {
        m_pSink->Release();
    }
}

void 
CWbemObjectSink::Indicate(IWbemClassObject* pInst)
{
    if(pInst == NULL)
    {
        throw (HRESULT)WBEM_E_INVALID_PARAMETER;
    }

    m_ppInst[m_dwIndex++] = pInst;
    DBG_ASSERT(m_dwIndex <= m_dwThreshHold);
    pInst->AddRef();
    if(m_dwIndex == m_dwThreshHold)
    {
        SCODE  sc = m_pSink->Indicate(
            m_dwIndex,
            m_ppInst);
        
        //
        // reset state
        //
        for(DWORD i=0; i< m_dwThreshHold; i++)
        {
            if(m_ppInst[i] != NULL)
            {
                (m_ppInst[i])->Release();
            }
            m_ppInst[i] = NULL;
        }
        m_dwIndex = 0;

        if(sc != S_OK)
        {
            throw (HRESULT)sc;
        }
    }
    return;
}

void
CWbemObjectSink::SetStatus(
    LONG              lFlags,
    HRESULT           hr,
    const BSTR        bstrParam,
    IWbemClassObject* pObjParam)
{
    m_pSink->SetStatus(
        lFlags,
        hr,
        bstrParam,
        pObjParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\wbemobjectsink.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    WbemObjectSink.h

Abstract:

    Definition of:
        CWbemObjectSink

    Wraps IWbemObjectSink.  Batches the Indicate call.

Author:

    ???

Revision History:

    Mohit Srivastava            10-Nov-2000

--*/

#ifndef __wbemobjectsink_h__
#define __wbemobjectsink_h__

#if _MSC_VER > 1000
#pragma once
#endif 

#include <windows.h>
#include <wbemprov.h>

typedef LPVOID * PPVOID;

class CWbemObjectSink
{   
protected:
    IWbemObjectSink*   m_pSink;
    IWbemClassObject** m_ppInst;
    DWORD              m_dwThreshHold; // Number of "Indicates" to cache
    DWORD              m_dwIndex;

public:
    CWbemObjectSink(
        IWbemObjectSink*,
        DWORD = 1);

    virtual ~CWbemObjectSink();

    void Indicate(IWbemClassObject*);

    void SetStatus(
        LONG,
        HRESULT,
        const BSTR, 
        IWbemClassObject*);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\wbemservices.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    WbemServices.cpp

Abstract:

    Implementation of:
        CWbemServices

Author:

    ???

Revision History:

    Mohit Srivastava            10-Nov-2000

--*/

#include "WbemServices.h"
#include <wbemprov.h>
#include <dbgutil.h>

CWbemServices::CWbemServices(
    IWbemServices* pNamespace)
    :m_pWbemServices(NULL)
{
    m_pWbemServices = pNamespace;
    if(m_pWbemServices != NULL)
    {
        m_pWbemServices->AddRef();
    }
}

CWbemServices::~CWbemServices()
{
    if(m_pWbemServices != NULL)
    {
        m_pWbemServices->Release();
        m_pWbemServices = NULL;
    }
}

HRESULT
CWbemServices::CreateClassEnum(
    /* [in] */ const BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
    ) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppEnum)
    {
        *ppEnum = NULL;
    }
    SCODE sc = m_pWbemServices->CreateClassEnum(
        Superclass,
        lFlags,
        pCtx,
        ppEnum);
    
    HRESULT cichr = CoImpersonateClient();
    if (FAILED(cichr))
    {
        return cichr;
    }
    
    return sc;
}

HRESULT
CWbemServices::CreateInstanceEnum(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppEnum)
    {
        *ppEnum = NULL;
    }
    HRESULT hr = m_pWbemServices->CreateInstanceEnum(
        Class,
        lFlags,
        pCtx,
        ppEnum);

    HRESULT cichr = CoImpersonateClient();
    if (FAILED(cichr))
    {
        return cichr;
    }
        
    return hr;
}

HRESULT
CWbemServices::DeleteClass(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppCallResult)
    {
        *ppCallResult = NULL;
    }
    HRESULT hr = m_pWbemServices->DeleteClass(
        Class,
        lFlags,
        pCtx,
        ppCallResult);

    HRESULT cichr = CoImpersonateClient();    
    if (FAILED(cichr))
    {
        return cichr;
    }

    return hr;
}

HRESULT
CWbemServices::DeleteInstance(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppCallResult)
    {
        *ppCallResult = NULL;
    }
    HRESULT hr = m_pWbemServices->DeleteInstance(
        ObjectPath,
        lFlags,
        pCtx,
        ppCallResult);

    HRESULT cichr = CoImpersonateClient();    
    if (FAILED(cichr))
    {
        return cichr;
    }

    return hr;
}



HRESULT
CWbemServices::ExecMethod(
    const BSTR strObjectPath, 
    const BSTR MethodName, 
    long lFlags, 
    IWbemContext* pCtx,
    IWbemClassObject* pInParams,
    IWbemClassObject** ppOurParams, 
    IWbemCallResult** ppCallResult) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppOurParams)
    {
        *ppOurParams = NULL;
    }
    if(ppCallResult)
    {
        *ppCallResult = NULL;
    }
    HRESULT hr = m_pWbemServices->ExecMethod(
        strObjectPath, 
        MethodName, 
        lFlags, 
        pCtx,
        pInParams,
        ppOurParams, 
        ppCallResult) ;
    
    HRESULT cichr = CoImpersonateClient();    
    if (FAILED(cichr))
    {
        return cichr;
    }

    return hr;    
}

HRESULT
CWbemServices::ExecNotificationQuery(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppEnum)
    {
        *ppEnum = NULL;
    }
    HRESULT hr = m_pWbemServices->ExecNotificationQuery(
        QueryLanguage,
        Query,
        lFlags,
        pCtx,
        ppEnum);

    HRESULT cichr = CoImpersonateClient();    
    if (FAILED(cichr))
    {
        return cichr;
    }

    return hr;
}

HRESULT
CWbemServices::ExecQuery(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppEnum)
    {
        *ppEnum = NULL;
    }
    HRESULT hr = m_pWbemServices->ExecQuery(
        QueryLanguage,
        Query,
        lFlags,
        pCtx,
        ppEnum);

    HRESULT cichr = CoImpersonateClient();    
    if (FAILED(cichr))
    {
        return cichr;
    }

    return hr;
}

HRESULT
CWbemServices::GetObject(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppObject)
    {
        *ppObject = NULL;
    }
    if(ppCallResult)
    {
        *ppCallResult = NULL;
    }
    HRESULT hr = m_pWbemServices->GetObject(
        ObjectPath,
        lFlags,
        pCtx,
        ppObject,
        ppCallResult);
    
    HRESULT cichr = CoImpersonateClient();    
    if (FAILED(cichr))
    {
        return cichr;
    }
    
    return hr;
}
 
HRESULT
CWbemServices::PutClass(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppCallResult)
    {
        *ppCallResult = NULL;
    }
    HRESULT hr = m_pWbemServices->PutClass(
        pObject,
        lFlags,
        pCtx,
        ppCallResult);
    
    HRESULT cichr = CoImpersonateClient();    
    if (FAILED(cichr))
    {
        return cichr;
    }
    
    return hr;
}

HRESULT
CWbemServices::PutInstance(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{    
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppCallResult)
    {
        *ppCallResult = NULL;
    }
    HRESULT hr = m_pWbemServices->PutInstance(
        pInst,
        lFlags,
        pCtx,
        ppCallResult);
    
    HRESULT cichr = CoImpersonateClient();    
    if (FAILED(cichr))
    {
        return cichr;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\browseinfo\makefile.inc ===
# We want to do this so that our rule for createing the bsc file
# will win over the makefile.def rule.  We do much funkier things
NO_BROWSER_FILE=1

!ifdef IIS_BROWSER_INFO 
!  if "$(NOLINK)" == ""

# this is a wild nmake hack to always run a command
# I picked this up from makefile.def where the do a 
# build -O to make _objects.mac.
!if [-perl gensbrlists.pl .. $O]
!endif

!include $O\sbrlist.inc

$O\iis.bsc: $(SBRLIST) 
    -bscmake -nologo -o $@ @<<
$(SBRLIST: =
)
<<NOKEEP

!  else

$O\iis.bsc: 

!  endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\wbemservices.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    WbemServices.h

Abstract:

    Definition of:
        CWbemServices

    Wraps IWbemServices.  Sets out params to NULL and calls
    CoImpersonateClient.

Author:

    ???

Revision History:

    Mohit Srivastava            10-Nov-2000

--*/

#ifndef __wbemservices_h__
#define __wbemservices_h__

#if _MSC_VER > 1000
#pragma once
#endif 

#include <wbemprov.h>

class CWbemServices
{
protected:
    IWbemServices* m_pWbemServices;

public:
    CWbemServices(IWbemServices*);
    virtual ~CWbemServices();

    operator IWbemServices*() const
    {
        return m_pWbemServices;
    }

    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;

    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecMethod( 
        const BSTR, 
        const BSTR, 
        long, 
        IWbemContext*,
        IWbemClassObject*,
        IWbemClassObject**, 
        IWbemCallResult**) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catinproc_iiscfg\catinproc.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name:
    CatInproc.cpp

$Header: $

Abstract:

--**************************************************************************/
#include "precomp.hxx"

// CATALOG DLL exported functions: Search on HOWTO in this file and sources to integrate new interceptors:

// Debugging stuff
DECLARE_DEBUG_PRINTS_OBJECT();

//This heap really needs to be located on a page boundary for perf and workingset reasons.  The only way in VC5 and VC6 to guarentee this
//is to locate it into its own data segment.  In VC7 we might be able to use '__declspec(align(4096))' tp accomplish the same thing.
#pragma data_seg( "TSHEAP" )
ULONG g_aFixedTableHeap[ CB_FIXED_TABLE_HEAP/sizeof(ULONG)]={kFixedTableHeapSignature0, kFixedTableHeapSignature1, kFixedTableHeapKey, kFixedTableHeapVersion, CB_FIXED_TABLE_HEAP};
#pragma data_seg()

// Global variables:
HMODULE					g_hModule = 0;					// Module handle
TSmartPointer<CSimpleTableDispenser> g_pSimpleTableDispenser; // Table dispenser singleton
CSafeAutoCriticalSection g_csSADispenser;					// Critical section for initializing table dispenser

extern LPWSTR g_wszDefaultProduct;//located in svcerr.cpp

// Get* functions:
// HOWTO: Add your Get* function for your simple object here:

HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct);
HRESULT GetMetabaseXMLTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMetabaseDifferencingInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetFixedTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv);
HRESULT GetFixedPackedInterceptor (REFIID riid, LPVOID* o_ppv);
HRESULT GetErrorTableInterceptor (REFIID riid, LPVOID* o_ppv);

// ============================================================================
HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct)
{
// The dispenser is a singleton: Only create one object of this kind:
	if(g_pSimpleTableDispenser == 0)
	{
		HRESULT hr = S_OK;

		CSafeLock dispenserLock (&g_csSADispenser);
		DWORD dwRes = dispenserLock.Lock ();
	    if(ERROR_SUCCESS != dwRes)
		{
			return HRESULT_FROM_WIN32(dwRes);
		}

		if(g_pSimpleTableDispenser == 0)
		{
		// Create table dispenser:
			g_pSimpleTableDispenser = new CSimpleTableDispenser(i_wszProduct);
			if(g_pSimpleTableDispenser == 0)
			{
				return E_OUTOFMEMORY;
			}

		// Addref table dispenser so it never releases:
			g_pSimpleTableDispenser->AddRef();
			if(S_OK == hr)
			{
			// Initialize table dispenser:
				hr = g_pSimpleTableDispenser->Init(); // NOTE: Must never throw exceptions here!
			}
		}
		if(S_OK != hr) return hr;
	}
	return g_pSimpleTableDispenser->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetMetabaseXMLTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	TMetabase_XMLtable*	p = NULL;

	p = new TMetabase_XMLtable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetMetabaseDifferencingInterceptor(REFIID riid, LPVOID* o_ppv)
{
	TMetabaseDifferencing*	p = NULL;

	p = new TMetabaseDifferencing;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetFixedTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CSDTFxd*	p = NULL;

	p = new CSDTFxd;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetMemoryTableInterceptor(REFIID riid, LPVOID* o_ppv)
{
	CMemoryTable*	p = NULL;

	p = new CMemoryTable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}

// ============================================================================
HRESULT GetFixedPackedInterceptor (REFIID riid, LPVOID* o_ppv)
{
	TFixedPackedSchemaInterceptor*	p = NULL;

	p = new TFixedPackedSchemaInterceptor;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
HRESULT GetErrorTableInterceptor (REFIID riid, LPVOID* o_ppv)
{
	ErrorTable*	p = NULL;

	p = new ErrorTable;
	if(NULL == p) return E_OUTOFMEMORY;

	return p->QueryInterface (riid, o_ppv);
}
// ============================================================================
STDAPI DllGetSimpleObject (LPCWSTR /*i_wszObjectName*/, REFIID riid, LPVOID* o_ppv)
{
    return ReallyGetSimpleTableDispenser(riid, o_ppv, g_wszDefaultProduct);
}

// ============================================================================
// DllGetSimpleObject: Get table dispenser, interceptors, plugins, and other simple objects:
// HOWTO: Match your object name here and call your Get* function:
STDAPI DllGetSimpleObjectByID (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv)
{
	HRESULT hr;

    // Parameter validation:
	if (!o_ppv || *o_ppv != NULL) return E_INVALIDARG;

    // Get simple object:
	switch(i_ObjectID)
	{
		case eSERVERWIRINGMETA_Core_FixedInterceptor:
			hr = GetFixedTableInterceptor(riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_Core_MemoryInterceptor:
			hr = GetMemoryTableInterceptor(riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_Core_FixedPackedInterceptor:
			hr = GetFixedPackedInterceptor(riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_Core_DetailedErrorInterceptor:
			hr = GetErrorTableInterceptor(riid, o_ppv);
		break;

		case eSERVERWIRINGMETA_TableDispenser:
            //Old Cat.libs use this - new Cat.libs should be calling DllGetSimpleObjectByIDEx below for the TableDispenser
		    hr = ReallyGetSimpleTableDispenser(riid, o_ppv, 0);
		break;

		case eSERVERWIRINGMETA_Core_MetabaseInterceptor:
			hr = GetMetabaseXMLTableInterceptor(riid, o_ppv);
		break;

		// only IIS uses metabasedifferencinginterceptor
		case eSERVERWIRINGMETA_Core_MetabaseDifferencingInterceptor:
			hr = GetMetabaseDifferencingInterceptor(riid, o_ppv);
		break;

		default:
			return CLASS_E_CLASSNOTAVAILABLE;
	}
	return hr;
}


STDAPI DllGetSimpleObjectByIDEx (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct)
{
    // Parameter validation:
	if (!o_ppv || *o_ppv != NULL) return E_INVALIDARG;

    // Get simple object:
	if(eSERVERWIRINGMETA_TableDispenser == i_ObjectID)
		return ReallyGetSimpleTableDispenser(riid, o_ppv,i_wszProduct);
    else
        return DllGetSimpleObjectByID(i_ObjectID, riid, o_ppv);
}


// ============================================================================
// DllMain: Global initialization:
extern "C" BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		CREATE_DEBUG_PRINT_OBJECT("iiscfg");
        LOAD_DEBUG_FLAGS_FROM_REG_STR( "System\\CurrentControlSet\\Services\\iisadmin\\Parameters", 0 );

		g_hModule = hModule;
		g_wszDefaultProduct = WSZ_PRODUCT_IIS;

		DisableThreadLibraryCalls(hModule);

		return TRUE;

	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		DELETE_DEBUG_PRINT_OBJECT();
	}

	return TRUE;    // OK
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tableschema_holder.cpp ===
#include "precomp.hxx"

#include "..\..\stores\FixedSchemaInterceptor\TableSchema.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catinproc_iiscfg\resource.h ===
#define IDS_MSG_APPID					353
#define IDS_MSG_APPNAME					354
#define IDS_MSG_FAILFAST				355
#define IDS_MSG_HRESULT					356
#define IDS_MSG_INTERNALS				357
#define IDS_MSG_LOGSTRING				358
#define IDS_MSG_LOGHRESULT				359
#define IDS_MSG_LOGWINERROR				360
#define IDS_MSG_NOAPPINFO				361
#define IDS_MSG_EXCEPTION				362
#define IDS_MSG_ADDRESS					363
#define IDS_MSG_CALLSTACK				364
#define IDS_MSG_ASSERT					365
#define IDS_MSG_PROGID					366
#define IDS_MSG_METHOD					367
#define IDS_MSG_MODULENAME				368
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tcomcatdataxmlfile.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

LPCWSTR TComCatDataXmlFile::m_szComCatDataSchema=L"ComCatData_v6";



//We do everything we need with XmlFile in the ctor so we don't keep it around
TComCatDataXmlFile::TComCatDataXmlFile() : m_pFixup(0), m_pOut(0)
{
}

void TComCatDataXmlFile::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;

    ASSERT(IsSchemaEqualTo(m_szComCatDataSchema));

    CComPtr<IXMLDOMElement>     pElement_Root;
    XIF(m_pXMLDoc->get_documentElement(&pElement_Root));

    CComPtr<IXMLDOMNodeList>    pNodeList_TableID;
    XIF(pElement_Root->get_childNodes(&pNodeList_TableID));

    long cTables;
    XIF(pNodeList_TableID->get_length(&cTables));

    while(cTables--)
    {
        CComPtr<IXMLDOMNode>    pNode_Table;
        XIF(pNodeList_TableID->nextNode(&pNode_Table));

        CComBSTR bstrTableName;
        XIF(pNode_Table->get_baseName(&bstrTableName));

        if(0 == bstrTableName.m_str)
            continue;//ignore comment elements

        unsigned long iTableMeta = m_pFixup->FindTableBy_TableName(bstrTableName.m_str);//Find the table by its internal name
        if(static_cast<long>(iTableMeta) < 1)
            continue;//we're obviously not at a TableNode

        TTableMeta TableMeta(*m_pFixup, iTableMeta);
        m_pFixup->TableMetaFromIndex(iTableMeta)->iFixedTable = m_pFixup->GetCountULONG();//This is where we're going to start putting the fixed table.
        AddTableToPool(pNode_Table, TableMeta);//Add the table to the pool
        //Now that the table is added we need to know how many rows there were.
        unsigned long culongTable = m_pFixup->GetCountULONG() - TableMeta.Get_iFixedTable();//The number of ulongs in the table
        unsigned long ciRows = culongTable / *TableMeta.Get_CountOfColumns();//The number of rows the the ulong count divided by the count of columns
        m_pFixup->TableMetaFromIndex(iTableMeta)->ciRows = ciRows;//store that back into the table.
    }

    FillInTheHashTables();
}


//
//
//  Private member functions
//
//
void TComCatDataXmlFile::AddRowToPool(IXMLDOMNode *pNode_Row, TTableMeta & TableMeta)
{
    CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_Row_AttributeMap;
    XIF(pNode_Row->get_attributes(&pNodeMap_Row_AttributeMap));
    ASSERT(0 != pNodeMap_Row_AttributeMap.p);//The schema should prevent this.

    TColumnMeta ColumnMeta(*m_pFixup, TableMeta.Get_iColumnMeta());

    unsigned cColumns = *TableMeta.Get_CountOfColumns();
    for(;cColumns;--cColumns, ColumnMeta.Next())
    {
        CComBSTR bstrColumnPublicName = ColumnMeta.Get_PublicName();
        if(0 == (*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTPERSISTABLE))
        {
            switch(*ColumnMeta.Get_Type())
            {
            case DBTYPE_GUID:
                {
                    GUID guid;
                    if(!GetNodeValue(pNodeMap_Row_AttributeMap, bstrColumnPublicName, guid, ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue())))
                    {
                        const GUID * pDefaultValue = reinterpret_cast<const GUID *>(ColumnMeta.Get_DefaultValue());
                        if(pDefaultValue)
                            m_pFixup->AddULongToList(m_pFixup->AddGuidToList(*pDefaultValue));
                        else
                            m_pFixup->AddULongToList(0);
                    }
                    else
                        m_pFixup->AddULongToList(m_pFixup->AddGuidToList(guid));//AddGuidToList returns the index to the guid, so add it to the ULong pool
                }
                break;
            case DBTYPE_WSTR:
                {
                    CComVariant var;
                    if(!GetNodeValue(pNodeMap_Row_AttributeMap, bstrColumnPublicName, var, ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue())))
                    {
                        LPCWSTR pDefaultValue = reinterpret_cast<LPCWSTR>(ColumnMeta.Get_DefaultValue());
                        if(pDefaultValue)
                            m_pFixup->AddULongToList(m_pFixup->AddWCharToList(pDefaultValue, *ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_FIXEDLENGTH ? *ColumnMeta.Get_Size() : -1));
                        else
                            m_pFixup->AddULongToList(0);
                    }
                    else
                    {
                        //verify that the string isn't too long
                        unsigned long size = (unsigned long)-1;
                        if(*ColumnMeta.Get_Size() != -1)
                        {
                            if(*ColumnMeta.Get_Size() < (wcslen(var.bstrVal)+1)*sizeof(WCHAR))
                            {
                                m_errorOutput->printf(L"Error - String (%s) is too large according to the Meta for Column (%s).\n", var.bstrVal, ColumnMeta.Get_InternalName());
                                THROW(ERROR - STRING TOO LARGE);
                            }
                            if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_FIXEDLENGTH)
                                size = *ColumnMeta.Get_Size();//if fixed length then pass the size to AddWCharToList so it will reserve the whole size
                        }
                        m_pFixup->AddULongToList(m_pFixup->AddWCharToList(var.bstrVal, size));//AddWCharToList returns the index to the wchar *, so add it to the ULong pool
                    }
                }
                break;
            case DBTYPE_UI4:
                {
                    ULONG ulong = 0;
                    if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_ENUM)
                    {
                        CComVariant var;
                        if(GetNodeValue(pNodeMap_Row_AttributeMap, bstrColumnPublicName, var, ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue())))
                        {
                            TTagMeta TagMeta(*m_pFixup, ColumnMeta.Get_iTagMeta());
                            for(unsigned long iTag=0; iTag<ColumnMeta.Get_ciTagMeta(); ++iTag, TagMeta.Next())
                            {
                                if(0 == lstrcmpi(var.bstrVal, TagMeta.Get_PublicName()))
                                {
                                    ulong = *TagMeta.Get_Value();
                                    break;
                                }
                            }
                            if(iTag == ColumnMeta.Get_ciTagMeta())
                            {
                                m_errorOutput->printf(L"Error - Tag %s not found", var.bstrVal);
                                THROW(ERROR - TAG NOT FOUND);
                            }
                            ulong = m_pFixup->AddUI4ToList(ulong);
                        }
                        //else ulong == 0 means NULL
                    }
                    else if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_FLAG)
                    {
                        CComVariant var;
                        if(GetNodeValue(pNodeMap_Row_AttributeMap, bstrColumnPublicName, var, ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue())))
                        {
                            LPWSTR token = wcstok(var.bstrVal, L" ,|");
                            TTagMeta TagMeta(*m_pFixup, ColumnMeta.Get_iTagMeta());
                            unsigned long iTag=0;
                            while(token && iTag<ColumnMeta.Get_ciTagMeta())
                            {
                                if(0 == lstrcmpi(token, TagMeta.Get_PublicName()))
                                {
                                    ulong |= *TagMeta.Get_Value();
                                    TagMeta.Reset();//Reset the TagMeta pointer to the first TagMeta for the column
                                    iTag = 0;
                                    token = wcstok(0, L" ,|");
                                    continue;
                                }
                                ++iTag;
                                TagMeta.Next();
                            }
                            if(iTag == ColumnMeta.Get_ciTagMeta())
                            {
                                m_errorOutput->printf(L"Error - Tag %s not found", token);
                                THROW(ERROR - TAG NOT FOUND);
                            }
                            ulong = m_pFixup->AddUI4ToList(ulong);
                        }
                        // else ulong == 0 means NULL
                    }
                    else if(GetNodeValue(pNodeMap_Row_AttributeMap, bstrColumnPublicName, ulong, ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue())))
                        ulong = m_pFixup->AddUI4ToList(ulong);//convert to aUI4 index
                    if(0 == ulong)//is our ULONG NULL
                    {
                        const ULONG * pUlong = reinterpret_cast<const ULONG *>(ColumnMeta.Get_DefaultValue());
                        ulong = pUlong ? m_pFixup->AddUI4ToList(*pUlong) : 0;
                    }
                    m_pFixup->AddULongToList(ulong);
                }
                break;
            case DBTYPE_BYTES:
                {
                    CComVariant var;
                    if(GetNodeValue(pNodeMap_Row_AttributeMap, bstrColumnPublicName, var, ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue())))
                    {
                        unsigned char *pBytes=0;
                        unsigned long length = (ULONG) wcslen(var.bstrVal)/2;

                        if(*ColumnMeta.Get_Size() < length)
                        {
                            m_errorOutput->printf(L"Error - Byte array (%s) too long.  Maximum size should be %d bytes.\n", var.bstrVal, *ColumnMeta.Get_Size());
                            THROW(ERROR - BYTE ARRAY TOO LARGE);
                        }
                        if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_FIXEDLENGTH)
                        {
                            length = *ColumnMeta.Get_Size();
                        }
                        try
                        {
                            pBytes = new unsigned char[length];
                            ConvertWideCharsToBytes(var.bstrVal, pBytes, length);//This puts the length in the first ULONG
                            m_pFixup->AddULongToList(m_pFixup->AddBytesToList(pBytes, length));//use the index to the bytes
                            delete [] pBytes;
                        }
                        catch(TException &e)
                        {
                            delete [] pBytes;
                            throw e;
                        }
                    }
                    else
                    {
                        const unsigned char *pDefaultValue = ColumnMeta.Get_DefaultValue();
                        if(pDefaultValue)
                        {
                            const ULONG * pSizeofDefaultValue = reinterpret_cast<const ULONG *>(pDefaultValue - sizeof(ULONG));
                            m_pFixup->AddULongToList(m_pFixup->AddBytesToList(pDefaultValue, *pSizeofDefaultValue));
                        }
                        else
                            m_pFixup->AddULongToList(0);
                    }
                }
                break;
            default:
                ASSERT(false && "Unknown Data Type in XML file");
                THROW(ERROR - UNKNOWN DATA TYPE);
            }
        }
        else
        {
            m_pFixup->AddULongToList(0);//We need to add even NON_PERSISTABLE values so the row/column arithmetic works out
        }
    }
}


void TComCatDataXmlFile::AddTableToPool(IXMLDOMNode *pNode_Table, TTableMeta & TableMeta)
{
    CComPtr<IXMLDOMNodeList> pNodeList_Row;
    XIF(pNode_Table->get_childNodes(&pNodeList_Row));

    long cRows;
    XIF(pNodeList_Row->get_length(&cRows));

    while(cRows--)
    {
        CComPtr<IXMLDOMNode>    pNode_Row;
        XIF(pNodeList_Row->nextNode(&pNode_Row));

        CComBSTR RowName;
        XIF(pNode_Row->get_baseName(&RowName));//This returns NULL string for comments

        if(0==RowName.m_str || 0!=wcscmp(RowName.m_str, TableMeta.Get_PublicRowName()))
            continue;//ignore all but the Table's Rows (usually only comments can exist and still be valid)

        AddRowToPool(pNode_Row, TableMeta);
    }
}

extern unsigned int kPrime[];

unsigned long TComCatDataXmlFile::DetermineBestModulo(ULONG cRows, ULONG aHashes[])
{
    unsigned long BestModulo = 0;
    unsigned int LeastDups   = (unsigned int)-1;

    static HashedIndex  pHashTable[kLargestPrime * 2];

    for(unsigned int iPrimeNumber=0; kPrime[iPrimeNumber] != 0 && kPrime[iPrimeNumber]<(cRows * 20) && LeastDups!=0; ++iPrimeNumber)
    {
        if(kPrime[iPrimeNumber]<cRows)//we don't have a chance of coming up with few duplicates if the prime number is LESS than the number of rows in the table.
            continue;                //So skip all the small primes.

        m_infoOutput->printf(L".");

        unsigned int Dups           = 0;
        unsigned int DeepestLink    = 0;

        //We're going to use the HashPool to store this temporary data so we can figure out the dup count and the deepest depth
        memset(pHashTable, -1, sizeof(pHashTable));
        for(unsigned long iRow=0; iRow<cRows && Dups<LeastDups && DeepestLink<5;++iRow)
        {
            ULONG HashedIndex = aHashes[iRow] % kPrime[iPrimeNumber];

            if(0 == pHashTable[HashedIndex].iNext)//if this is the second time we've seen this hash, then bump the Dups
                ++Dups;

            ++(pHashTable[HashedIndex].iNext);//For now Next holds the number of occurances of this hash

            if(pHashTable[HashedIndex].iNext > DeepestLink)
                DeepestLink = pHashTable[HashedIndex].iNext;
        }
        if(DeepestLink<5 && Dups<LeastDups)
        {
            LeastDups                 = Dups;
            BestModulo  = kPrime[iPrimeNumber];
        }
    }

    if(0 == BestModulo)
        THROW(No hashing scheme seems reasonable.);

    return BestModulo;
}


void TComCatDataXmlFile::FillInTheHashTables()
{
    //Walk the TableMeta looking for tables with an iFixedTable greater than zero.  If iFixedTable is less than zero then
    //the table is a Meta table.  If iFixedTable is greater than zero then it's a fixed table in the ULONG pool.
    TTableMeta TableMeta(*m_pFixup);
    for(unsigned long iTableMeta=0; iTableMeta<TableMeta.GetCount(); ++iTableMeta, TableMeta.Next())
    {
        //If this table is not stored in the fixed table then there's nothing to build the hash on.
        if(0 >= static_cast<long>(TableMeta.Get_iFixedTable()))
            continue;

        FillInTheFixedHashTable(TableMeta);
    }
}


void TComCatDataXmlFile::FillInTheFixedHashTable(TTableMeta &i_TableMeta)
{
    m_infoOutput->printf(L"Building %s hash table", i_TableMeta.Get_InternalName());

    //Get a pointer to the table
    const ULONG *pTable = m_pFixup->ULongFromIndex(i_TableMeta.Get_iFixedTable());//The table is a Fixed table stored in the ULONG pool

    TSmartPointerArray<unsigned long> pRowHash = new unsigned long [i_TableMeta.Get_ciRows()];
    if(0 == pRowHash.m_p)
        THROW(out of memory);

    //Get the ColumnMeta so we can interpret pTable correctly.
    TColumnMeta ColumnMeta(*m_pFixup, i_TableMeta.Get_iColumnMeta());
    for(unsigned long iRow=0; iRow < i_TableMeta.Get_ciRows(); ++iRow, pTable += *i_TableMeta.Get_CountOfColumns(), ColumnMeta.Reset())
    {
        unsigned long RowHash=0;//This hash is the combination of all PKs that uniquely identifies the row

        //I could make this process faster by building an array of PK indexes; but I think code clarity wins out here.
        for(unsigned long iColumnMeta=0; iColumnMeta < *i_TableMeta.Get_CountOfColumns(); ++iColumnMeta, ColumnMeta.Next())
        {
            if(0 == (*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_PRIMARYKEY))
                continue;//Only build the hash for primarykey values

            if(0 == pTable[iColumnMeta])
            {
                m_errorOutput->printf(L"Error - Table %s, Column %s is a PrimaryKey and is set to NULL.\n", i_TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName());
                THROW(Fixed table contains NULL value in PrimaryKey);
            }

            switch(*ColumnMeta.Get_Type())
            {
            case DBTYPE_GUID:
                RowHash = Hash(*m_pFixup->GuidFromIndex(pTable[iColumnMeta]), RowHash);break;
            case DBTYPE_WSTR:
                RowHash = Hash(m_pFixup->StringFromIndex(pTable[iColumnMeta]), RowHash);break;
            case DBTYPE_UI4:
                RowHash = Hash(m_pFixup->UI4FromIndex(pTable[iColumnMeta]), RowHash);break;
            case DBTYPE_BYTES:
                RowHash = Hash(m_pFixup->ByteFromIndex(pTable[iColumnMeta]), m_pFixup->BufferLengthFromIndex(pTable[iColumnMeta]), RowHash);break;
            default:
                THROW(unsupported type);
            }
        }
        pRowHash[iRow] = RowHash;
    }

    //OK Now we have the 32 bit hash values.  Now we need to see which prime number acts as the best modulo.
    unsigned long Modulo = DetermineBestModulo(i_TableMeta.Get_ciRows(), pRowHash);

    //Now actually fill in the hash table
    unsigned long iHashTable = FillInTheHashTable(i_TableMeta.Get_ciRows(), pRowHash, Modulo);

    i_TableMeta.Get_pMetaTable()->iHashTableHeader = iHashTable;
    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_pFixup->HashedIndexFromIndex(iHashTable));//The heap is of type HashedIndex, so cast
    unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;

    m_infoOutput->printf(L"\n%s hash table has %d nonunique entries.\n", i_TableMeta.Get_InternalName(), cNonUniqueEntries);

}


unsigned long TComCatDataXmlFile::FillInTheHashTable(unsigned long cRows, ULONG aHashes[], ULONG Modulo)
{
    HashedIndex header;//This is actually the HashTableHeader
    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(&header);
    pHeader->Modulo = Modulo;
    pHeader->Size   = Modulo;//This Size is not only the number of HashedIndex entries but where we put the overflow from duplicate Hashes.

    //We'll fixup the Size member when we're done.
    ULONG iHashTableHeader = m_pFixup->AddHashedIndexToList(&header)/sizeof(HashedIndex);
    ULONG iHashTable = iHashTableHeader+1;

    HashedIndex     hashedindextemp;
    for(ULONG i=0;i<Modulo;++i)//-1 fill the hash table
        m_pFixup->AddHashedIndexToList(&hashedindextemp);

    for(unsigned long iRow=0; iRow<cRows; ++iRow)
    {
        ASSERT(-1 != aHashes[iRow]);//These fixed table should have a hash for each row.  If a hash turns out to be -1, we have a problem, since we've reserved -1 to indicate an empty slot.
        //This builds the hases for the TableName
        ULONG HashedIndex = aHashes[iRow] % pHeader->Modulo;
        if(-1 == m_pFixup->HashedIndexFromIndex(iHashTable + HashedIndex)->iOffset)
            m_pFixup->HashedIndexFromIndex(iHashTable + HashedIndex)->iOffset = iRow;//iNext is already -1 so no need to set it
        else
        {   //Otherwise we have to walk the linked list to find the last one so we can append this one to the end
            unsigned int LastInLink = HashedIndex;
            while(-1 != m_pFixup->HashedIndexFromIndex(iHashTable + LastInLink)->iNext)
                LastInLink = m_pFixup->HashedIndexFromIndex(iHashTable + LastInLink)->iNext;

            m_pFixup->HashedIndexFromIndex(iHashTable + LastInLink)->iNext = pHeader->Size;//Size is the end of the hash table, so append it to the end and bump the Size.

            //Reuse the temp variable
            hashedindextemp.iNext   = (ULONG)-1;//we only added enough for the hash table without the overflow slots.  So these dups need to be added to the heap with -1 set for iNext.
            hashedindextemp.iOffset = iRow;
            m_pFixup->AddHashedIndexToList(&hashedindextemp);

            ++pHeader->Size;
        }
    }

    //Now fix the Header Size         //The type is HashedIndex, so HashedIndex.iOffset maps to HashedHeader.Size
    m_pFixup->HashedIndexFromIndex(iHashTableHeader)->iOffset = pHeader->Size;

    return iHashTableHeader;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\main.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

// Debugging stuff
DECLARE_DEBUG_PRINTS_OBJECT();

class CDebugInit
{
public:
    CDebugInit(LPCSTR szProd)
    {
        CREATE_DEBUG_PRINT_OBJECT(szProd);
    }
    ~CDebugInit()
    {
        DELETE_DEBUG_PRINT_OBJECT();
    }
};

wchar_t g_szProgramVersion[255];

static wchar_t *szProgramHelp[]={
L"Catalog Utility - Version from %s built on %s %s",
L"\r\n%s\r\n\r\n",
L"This program has two purposes surrounding XML and the Catalog:                 \r\n",
L"        1)  Validating XML File - This is useful for any XML file whether      \r\n",
L"            related to Catalog or not.                                         \r\n",
L"        2)  Compiling - This refers to the Compiling of Catalog Meta and Wiring\r\n",
L"            into the following files: An Unmanaged C++ Header, The Catalog XML \r\n",
L"            Schema (xms) file and The Catalog Dynamic Link Library.            \r\n",
L"                                                                               \r\n",
L"CatUtil [/?] [Validate] [/Compile] [/meta=[CatMeta.xml]] [/wire=[CatWire.xml]] \r\n",
L"        [/header=[CatMeta.h]] [/schema=[Catalog.xms]] [/dll=[Catalog.dll]]     \r\n",
L"        [/mbmeta=[MBMeta.xml]] [xmlfilename]                                   \r\n",
L"                                                                               \r\n",
L"? - Brings up this help screen.                                                \r\n",
L"                                                                               \r\n",
L"validate - Will indicate whether the given file is 'Valid' according to its DTD\r\n",
L"        or XML Schema.  This requires an 'xmlfilename'.                        \r\n",
L"                                                                               \r\n",
L"xmlfilename - If specified with no other options, the XML file will be checked \r\n",
L"        for 'Well-Formity'.                                                    \r\n",
L"                                                                               \r\n",
L"product - Associates the dll with the given product name.  The Product Name    \r\n",
L"        must be supplied.  This association MUST be done before the Catalog may\r\n",
L"        be used with the given product.                                        \r\n",
L"                                                                               \r\n",
L"compile - Compile of Catalog Meta and Wiring as described above, using deaults \r\n",
L"        where no values are supplied.  To do a partial compile (ie only        \r\n",
L"        generate the Unmanaged C++ Header) do NOT specify the 'Compile' option \r\n",
L"        and only specify the 'meta' and 'header' options.  'Compile' is the    \r\n",
L"        same as '/meta /wire /header /schema /dll' where any of those flags    \r\n",
L"        explicitly specified may override the defaults.                        \r\n",
L"                                                                               \r\n",
L"mbmeta - Specifies the Metabase Meta XML file.  The default is MBMeta.xml.     \r\n",
L"             This is an input only file and will not be modified               \r\n",
L"meta   - Specifies the Catalog Meta XML file.  The default is CatMeta.xml.     \r\n",
L"             This is an input only file and will not be modified               \r\n",
L"wire   - Specifies the Catalog Wiring XML file.  The default is CatWire.xml.   \r\n",
L"             This is an input only file and will not be modified               \r\n",
L"header - Specifies the Unmanaged C++ Header file.  The default is CatMeta.h.   \r\n",
L"             This is an input/output file and will be updated only if changed. \r\n",
L"schema - Specifies the Catalog XML Schema file.  The default is Catalog.xms.   \r\n",
L"             This is an output file and will overwrite a previous version.     \r\n",
L"dll    - Specifies the Catalog DLL file.  The default is Catalog.dll.          \r\n",
L"             This is an input/output file and will update the previous version.\r\n",
L"             Either the 'compile' or 'product' option must be specified along  \r\n",
L"             with the 'dll' option.                                            \r\n",
L"config - Specifies the Machine Config Directory.                               \r\n",
L"             The 'product' option must be specified along with the 'config'    \r\n",
L"             option.                                                           \r\n",
L"verbose - This generates detailed output about the compilation                 \r\n",
L"                                                                               \r\n",
L"\r\n", 0};


enum
{
    iHelp,
    iValidate,
    iCompile,
    iMeta,
    iWire,
    iHeader,
    iSchema,
    iDll,
    iProduct,
    iConfig,
    iMBMeta,
    iVerbose,
    cCommandLineSwitches
};
wchar_t * CommandLineSwitch[cCommandLineSwitches]  ={L"?"  , L"validate", L"compile", L"meta", L"wire", L"header", L"schema", L"dll" , L"product" , L"config", L"mbmeta", L"verbose"};
int       kCommandLineSwitch[cCommandLineSwitches] ={0x8000, 0x01       , 0x7e      , 0x02   , 0x66   , 0x0a     , 0x12     , 0x00   , 0x80       , 0x00     , 0x100    , 0x0200};
//Each of the above bits dictates an action.  Which is NOT necessarily a 1 to 1 relation to the command line switch.

const int MinNumCharsInSwitch = 3;//From the command line the user only needs to use the first 3 charaters of the switch
enum
{
    eParseForWellFormedOnly = 0x0000,
    eHelp                   = 0x8000,
    eValidateXMLFile        = 0x0001,
    eValidateMeta           = 0x0002,
    eValidateWiring         = 0x0004,
    eHeaderFromMeta         = 0x0008,
    eSchemaFromMeta         = 0x0010,
    eMetaFixup              = 0x0020,
    eFixedTableFixup        = 0x0040,
    eProduct		        = 0x0080,
    eGenerateMBMetaBin      = 0x0100,
    eVerbose                = 0x0200
};

LPCWSTR wszDefaultOption[cCommandLineSwitches] =
{
    0//no file associated with help
    ,0//no default file associated with validate (the last parameter is considered the XML file; no default)
    ,0//no file associated with compile
    ,L"CatMeta.xml"
    ,L"CatWire.xml"
    ,L"CatMeta.h"
    ,L"Catalog.xms"
    ,L"Catalog.dll"
    ,0
    ,0
    ,L"MBSchema.xml"
    ,0
};

void GetOption(LPCWSTR wszCommandLineSwitch, LPCWSTR &wszOption, LPCWSTR wszDefaultOption)
{
    while(*wszCommandLineSwitch != L'=' && *wszCommandLineSwitch != 0x00)//advance to the '='
        ++wszCommandLineSwitch;
    if(*wszCommandLineSwitch != L'=')//if no '=' then use the dafault
        wszOption = wszDefaultOption;
    else
        wszOption = ++wszCommandLineSwitch;//now point past the '='
}


HRESULT ParseCommandLine(int argc, wchar_t *argv[ ], DWORD &dwCommandLineSwitches, LPCWSTR wszOption[cCommandLineSwitches])
{
    if(argc < 2)//we must have been passed at least the filename
        return E_INVALIDARG;
    if(argc > (cCommandLineSwitches + 2))//we must not be passed more than ALL of the switches
        return E_INVALIDARG;

    dwCommandLineSwitches = 0x00;
    for(int q=0; q<cCommandLineSwitches; q++)
        wszOption[q] = wszDefaultOption[q];//start with all of the default filenames

    for(int n=1;n<argc;n++)
        if(*argv[n] == '/' || *argv[n] == '-')//only acknowledge those command lines that begin with a '/' or a '-'
        {
            for(int i=0; i<cCommandLineSwitches; i++)
                if(0 == wcsncmp(&argv[n][1], CommandLineSwitch[i], MinNumCharsInSwitch))//Compare the first MinNumCharsInSwitch characters
                {
                    dwCommandLineSwitches |= kCommandLineSwitch[i];
                    switch(i)
                    {
                    case iValidate: //This option does not have a '=filename' option but if one is given we will accept it
                    case iMeta:
                    case iWire:
                    case iHeader:
                    case iSchema:
                    case iDll:
                    case iConfig:
                    case iMBMeta:
                        GetOption(argv[n], wszOption[i], wszDefaultOption[i]);
                        break;
                    case iProduct:
                        GetOption(argv[n], wszOption[i], wszDefaultOption[i]);
                        if(0 == wszOption[i])//if a Product is not specified then bail
                            return E_FAIL;
                        break;
                    case iHelp:     //This option does not have a '=filename' option
                    case iCompile:  //We should already be setup for defaults
                    case iVerbose:
                    default:
                        break;
                    }
                    break;
                }
            if(i == cCommandLineSwitches)
                return E_FAIL;//an unknown switch was specified so bail
        }
        else//assume any parameter without a leading '/' or '-' is the XML file name
            wszOption[iValidate] = argv[n];

    //We should have covered this case
    if(eParseForWellFormedOnly == dwCommandLineSwitches && 0 == wszOption[iValidate])
        return E_FAIL;

    return S_OK;
}

HINSTANCE g_hModule=0;

extern "C" int __cdecl wmain( int argc, wchar_t *argv[ ], wchar_t *[ ] )
{
    CDebugInit dbgInit("Catutil");

    TCom            com;
    TScreenOutput   Screen;
    TNullOutput     NullOutput;
    DWORD           dwCommandLineSwitches = 0;
    try
    {
        TOutput *   pOutput = &NullOutput;
        g_hModule = GetModuleHandle(0);

        int i=0;
        Screen.printf(szProgramHelp[i++], W(__TIMESTAMP__), W(__DATE__), W(__TIME__));
        Screen.printf(szProgramHelp[i++], L"");

        wsprintf(g_szProgramVersion, szProgramHelp[0], W(__TIMESTAMP__), W(__DATE__), W(__TIME__));

        LPCWSTR wszFilename[cCommandLineSwitches] = {0};//Most of the switches can have an '=filename' following, but /regsiter has an '=Product',
#if 0
        LPCWSTR &wszProduct = wszFilename[iProduct];//This isn't really a filename like the rest.
#endif


        if(FAILED(ParseCommandLine(argc, argv, dwCommandLineSwitches, wszFilename)) || dwCommandLineSwitches & eHelp)
        {
            //If fialed to parse OR /? was specified then display help and exit
            while(szProgramHelp[i])
                Screen.printf(szProgramHelp[i++]);
            return 0;
        }

        //Now that we have all of the filenames and other options, we need to expand any environment variables passed in
        WCHAR   Filename[cCommandLineSwitches][MAX_PATH];
        for(i=0;i<cCommandLineSwitches; ++i)
        {
            if(wszFilename[i])//if it's NULL then leave it NULL
            {
                ExpandEnvironmentStrings(wszFilename[i], Filename[i], MAX_PATH);
                wszFilename[i] = Filename[i];
            }
        }
        if(eVerbose & dwCommandLineSwitches)
            pOutput = &Screen;

        if(eParseForWellFormedOnly == dwCommandLineSwitches || eValidateXMLFile & dwCommandLineSwitches)
        {
            TXmlFile xml;
            xml.Parse(wszFilename[iValidate], static_cast<bool>(dwCommandLineSwitches & eValidateXMLFile));
        }

        if(dwCommandLineSwitches & eGenerateMBMetaBin)
        {
            XIF(E_NOTIMPL);
            // IVANPASH There is no way that this code can actually be executed
            // during the IIS build, because the iiscfg.dll to be build must be
            // already registered on the build machine.
#if 0
            DWORD dwStartingTickCount = GetTickCount();
            TCatalogDLL catalogDll(wszFilename[iDll]);
            const FixedTableHeap *pShippedSchemaHeap = catalogDll.LocateTableSchemaHeap(*pOutput);

            CComPtr<ISimpleTableDispenser2> pISTDispenser;
            XIF(GetSimpleTableDispenser(L"IIS", 0, &pISTDispenser));

            TMetabaseMetaXmlFile mbmeta(pShippedSchemaHeap, wszFilename[iMBMeta], pISTDispenser, *pOutput);

            TMetaInferrence().Compile(mbmeta, *pOutput);

            THashedPKIndexes hashedPKIndexes;
            hashedPKIndexes.Compile(mbmeta, *pOutput);

            THashedUniqueIndexes hashedUniqueIndexes;
            hashedUniqueIndexes.Compile(mbmeta, *pOutput);

            TLateSchemaValidate lateschemavalidate;
            lateschemavalidate.Compile(mbmeta, *pOutput);

            TWriteSchemaBin(L"MBSchema.bin").Compile(mbmeta, *pOutput);

            DWORD dwEndingTickCount = GetTickCount();
            pOutput->printf(L"HeapColumnMeta       %8d bytes\n", mbmeta.GetCountColumnMeta()          * sizeof(ColumnMeta)        );
            pOutput->printf(L"HeapDatabaseMeta     %8d bytes\n", mbmeta.GetCountDatabaseMeta()        * sizeof(DatabaseMeta)      );
            pOutput->printf(L"HeapHashedIndex      %8d bytes\n", mbmeta.GetCountHashedIndex()         * sizeof(HashedIndex)       );
            pOutput->printf(L"HeapIndexMeta        %8d bytes\n", mbmeta.GetCountIndexMeta()           * sizeof(IndexMeta)         );
            pOutput->printf(L"HeapQueryMeta        %8d bytes\n", mbmeta.GetCountQueryMeta()           * sizeof(QueryMeta)         );
            pOutput->printf(L"HeapRelationMeta     %8d bytes\n", mbmeta.GetCountRelationMeta()        * sizeof(RelationMeta)      );
            pOutput->printf(L"HeapServerWiringMeta %8d bytes\n", mbmeta.GetCountServerWiringMeta()    * sizeof(ServerWiringMeta)  );
            pOutput->printf(L"HeapTableMeta        %8d bytes\n", mbmeta.GetCountTableMeta()           * sizeof(TableMeta)         );
            pOutput->printf(L"HeapTagMeta          %8d bytes\n", mbmeta.GetCountTagMeta()             * sizeof(TagMeta)           );
            pOutput->printf(L"HeapULONG            %8d bytes\n", mbmeta.GetCountULONG()               * sizeof(ULONG)             );
            pOutput->printf(L"HeapPooled           %8d bytes\n", mbmeta.GetCountOfBytesPooledData()                               );
            pOutput->printf(L"Total time to build the %s file: %d milliseconds\n", wszFilename[iMBMeta], dwEndingTickCount - dwStartingTickCount);
#endif
        }

        if(dwCommandLineSwitches & (eValidateMeta | eValidateWiring | eHeaderFromMeta | eSchemaFromMeta | eMetaFixup | eFixedTableFixup) && !(dwCommandLineSwitches & eProduct))
        {
            TXmlFile xml[0x20];//We don't support more than 0x20 meta files
            int      iXmlFile=0;

            WCHAR    MetaFiles[MAX_PATH * 0x20];
            wcscpy(MetaFiles, wszFilename[iMeta]);
            LPWSTR token = wcstok( MetaFiles, L",");
            while( token != NULL )
            {
                xml[iXmlFile].Parse(token, true);//Parse and validate

                if(!xml[iXmlFile].IsSchemaEqualTo(TComCatMetaXmlFile::m_szComCatMetaSchema))
                {
                    Screen.printf(L"Error! %s is not a valid %s.  This is required for any type of Compilation.", token, TComCatMetaXmlFile::m_szComCatMetaSchema);
                    THROW(ERROR - META XML FILE NOT VALID);
                }
                ++iXmlFile;
                token = wcstok( NULL, L",");
            }

            pOutput->printf(L"Compatible %s file detected\n", TComCatMetaXmlFile::m_szComCatMetaSchema);

            TComCatMetaXmlFile ComCatMeta(xml, iXmlFile, *pOutput);
            TMetaInferrence().Compile(ComCatMeta, *pOutput);

            THashedPKIndexes hashedPKIndexes;
            hashedPKIndexes.Compile(ComCatMeta, *pOutput);

            THashedUniqueIndexes hashedUniqueIndexes;
            hashedUniqueIndexes.Compile(ComCatMeta, *pOutput);

            TPopulateTableSchema populatedTableSchemaHeap;
            populatedTableSchemaHeap.Compile(ComCatMeta, *pOutput);

            TLateSchemaValidate lateschemavalidate;
            lateschemavalidate.Compile(ComCatMeta, *pOutput);

            //Schema generation should come before anything else since other options may be dependant on it
            if(dwCommandLineSwitches & eSchemaFromMeta)
                TSchemaGeneration(wszFilename[iSchema], ComCatMeta, *pOutput);//the construction of this object creates the schema files

            if((dwCommandLineSwitches & eFixedTableFixup) && !(dwCommandLineSwitches & eProduct))
            {
                if(-1 == GetFileAttributes(wszFilename[iWire]))//if GetFileAttributes fails then the file does not exist
                {
                    Screen.printf(L"Information:  File %s does not exist.  Nothing to do.", wszFilename[iWire]);
                }
                else
                {
                    TComCatDataXmlFile ComCatData;//Update the PEFixup structure with these tables
                    ComCatData.Parse(wszFilename[iWire], true);
                    if(!ComCatData.IsSchemaEqualTo(TComCatDataXmlFile::m_szComCatDataSchema))
                        Screen.printf(L"Warning! %s specified, but %s is not a %s file.  Nothing to do.", CommandLineSwitch[iMeta], wszFilename[iWire], TComCatDataXmlFile::m_szComCatDataSchema);
                    else
                    {
                        ComCatData.Compile(ComCatMeta, *pOutput);
                    }
                }
            }
            if(dwCommandLineSwitches & eHeaderFromMeta)
                TTableInfoGeneration(wszFilename[iHeader], ComCatMeta, *pOutput);//the construction of this object creates the TableInfo file
            if(dwCommandLineSwitches & eMetaFixup)
            {
                TFixupDLL fixupDll(wszFilename[iDll]);//The construction of this object causes the DLL to be fixed up
                fixupDll.Compile(ComCatMeta, *pOutput);
            }

            {
                ULONG cBytes = ComCatMeta.GetCountDatabaseMeta() * sizeof(DatabaseMeta);
                cBytes +=      ComCatMeta.GetCountTableMeta()    * sizeof(TableMeta);
                cBytes +=      ComCatMeta.GetCountColumnMeta()    * sizeof(ColumnMeta);
                cBytes +=      ComCatMeta.GetCountTagMeta()    * sizeof(TagMeta);
                cBytes +=      ComCatMeta.GetCountIndexMeta()    * sizeof(IndexMeta);
                cBytes +=      ComCatMeta.GetCountULONG()    * sizeof(ULONG);
                cBytes +=      ComCatMeta.GetCountQueryMeta()    * sizeof(QueryMeta);
                cBytes +=      ComCatMeta.GetCountRelationMeta()    * sizeof(RelationMeta);

                pOutput->printf(L"Number of bytes used to store meta information = %d\n (INCLUDING wiring, NOT including Hash tables and UI4 Pool)\n", cBytes);
            }

        }

        if(dwCommandLineSwitches & eProduct)//do this last since something could have gone wrong in the Compile
        {
            XIF(E_NOTIMPL);
            // IVANPASH There is no way that this code can actually be executed
            // during the IIS build, because it would regsiter iiscfg.dll on be build machine.
#if 0
            TRegisterProductName(wszProduct, wszFilename[iDll], *pOutput);

			if((NULL != wszFilename[iConfig]) && (0 != *(wszFilename[iConfig])))
			{
	            TRegisterMachineConfigDirectory(wszProduct, wszFilename[iConfig], *pOutput);
			}
#endif
        }
    }
    catch(TException &e)
    {
        e.Dump(Screen);
        if(dwCommandLineSwitches & eMetaFixup)
            Screen.printf(L"CatUtil(0) : error : Fixup PE FAILED!\n");//This extra output message is so BUILD will report the error.
        return 1;
    }
    Screen.printf(L"CatUtil finished sucessfully.\n");//This is mostly for the case where 'verbose' is not supplied.
                                                      //It would be nice to know that everything worked.
    return 0;
}

LPDEBUG_PRINTS
PuCreateDebugPrintsObject(
    IN const char       *,
    IN DWORD            )
{
   return ( NULL );
}

LPDEBUG_PRINTS
PuDeleteDebugPrintsObject(
    IN OUT LPDEBUG_PRINTS   )
{
    return ( NULL );
}

INT
__cdecl
PuDbgAssertFailed(
    IN OUT LPDEBUG_PRINTS   ,
    IN const char           *,
    IN int                  ,
    IN const char           *,
    IN const char           *,
    IN const char           *)
{
    return 0;
}

VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS    ,
   IN const char            *,
   IN int                   ,
   IN const char            *,
   IN const char            *,
   ...)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tcomcatdataxmlfile.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TComCatDataXmlFile : public TXmlFile, public ICompilationPlugin
{
public:
    TComCatDataXmlFile();

    virtual void Compile(TPEFixup &fixup, TOutput &out);

    void                Parse(LPCWSTR szComCatDataFile, bool bValidate=true){ASSERT(bValidate);TXmlFile::Parse(szComCatDataFile, bValidate);}

    static LPCWSTR      m_szComCatDataSchema;
private:
    TPEFixup  * m_pFixup;
    TOutput   * m_pOut;

    void                AddRowToPool(IXMLDOMNode *pNode_Row, TTableMeta & TableMeta);
    void                AddTableToPool(IXMLDOMNode *pNode_Table, TTableMeta & TableMeta);
    unsigned long       DetermineBestModulo(ULONG cRows, ULONG aHashes[]);
    void                FillInTheHashTables();
    void                FillInTheFixedHashTable(TTableMeta &i_TableMeta);
    unsigned long       FillInTheHashTable(unsigned long cRows, ULONG aHashes[], ULONG Modulo);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tlateschemavalidate.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TLateSchemaValidate : public ICompilationPlugin
{
public:
    TLateSchemaValidate(){}
    virtual void Compile(TPEFixup &fixup, TOutput &out);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tfixupdll.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TCatalogDLL
{
public:
    TCatalogDLL(LPCWSTR szFilename) : m_CatalogsFixedTableHeapSize(0), m_iOffsetOfFixedTableHeap(0), m_pMappedFile(0), m_szFilename(szFilename){}
    ~TCatalogDLL(){delete m_pMappedFile;}

    const FixedTableHeap * LocateTableSchemaHeap(TOutput &out);

protected:
    ULONG                       m_CatalogsFixedTableHeapSize;
    ULONG                       m_iOffsetOfFixedTableHeap;
    TMetaFileMapping          * m_pMappedFile;
    LPCWSTR                     m_szFilename;
};

class TFixupDLL : public TFixedTableHeapBuilder
{
public:
    TFixupDLL(LPCWSTR szFilename);
    ~TFixupDLL();

    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    ULONG                       m_iOffsetOfFixedTableHeap;
    TMetaFileMapping          * m_pMappedFile;
    LPCWSTR                     m_szFilename;
    ULONG                       m_CatalogsFixedTableHeapSize;

    void                        DisplayStatistics() const;
    void                        LocateSignatures();
    void                        SetupToModifyPE();
    void                        UpdateTheDLL();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tpopulatetableschema.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

//The TableSchemaHeap is layed out as follows, the fixed length data comes first
/*
    ULONG           TableSchemaHeapSignature0
    ULONG           TableSchemaHeapSignature1
    ULONG           CountOfTables                       This is interesting only when no query is supplied and we want to walk through every table (this won't be efficient)
    ULONG           TableSchemaRowIndex                 This is the byte offset just beyond the last TableSchema entry.
    ULONG           EndOfHeap                           This is the byte offset just beyond the heap.  All indexes should be less than this
    ULONG           iSimpleColumnMetaHeap               This is described below
    ULONG           Reserved2
    ULONG           Reserved3
    HashTableHeader TableNameHashHeader                 This is the hash table that map a TableID to its aTableSchema byte offset (from the beginning of TableSchemaHeap)
    HashedIndex     aHashedIndex[507]                   The HashTableHeader contains the modulo (503 is the largest prime number less than the hash table size) for the hash table; but the table can never grow beyond this pre-allocated space.
                                                        This size was chosen so that the entire hash table would fit into the same page in memory.
---------------------------<Page Boundary>---------------------------
    unsigned char   aTableSchema[]                      This is where each Table's TableSchema goes.  FirstTableID (4096) == &aTableSchema[0] - &TableSchemaHeap, LastTableID == &aTableSchema[CountOfTables-1] - &TableSchemaHeap
    ULONG           aTableSchemaRowIndex[CountOfTables] This is used to walk ALL of the tables.  Presumably, someone will get all the CollectionMeta and iterate through all of them

---------------------------<SimpleColumnMetaHeap>---------------------
    ULONG           iCollectionMeta                     ULONG index from the beginning of the TableSchemaHeap
    ULONG           cCollectionMeta                     count of SimpleColumnMetas there are for CollectionMeta
    ULONG           iPropertyMeta
    ULONG           cPropertyMeta
    ULONG           iServerWiringMeta
    ULONG           cServerWiringMeta
    ULONG           iTagMeta
    ULONG           cTagMeta
    SimpleColumnMeta aSimpleColumnMeta[cCollectionMeta]
    SimpleColumnMeta aSimpleColumnMeta[cPropertyMeta]
    SimpleColumnMeta aSimpleColumnMeta[cServerWiringMeta]
    SimpleColumnMeta aSimpleColumnMeta[cTagMeta]

One optimization we could do is to make sure that every table's schema (whose size is <=4096) fits into one page.  In other words, minimize TableSchema crossing a page boundary
*/


//This class takes the meta from the old format (TableMeta, ColumnMeta etc.) and puts it into the new format (TableSchema
//which includes CollectionMeta, PropertyMeta etc.)
TPopulateTableSchema::TPopulateTableSchema() : THeap<ULONG>(0x400), m_pFixup(0), m_pOut(0)
{
    memset(m_scmCollectionMeta,   0x00, sizeof(SimpleColumnMeta) * kciTableMetaPublicColumns);
    memset(m_scmPropertyMeta,     0x00, sizeof(SimpleColumnMeta) * kciColumnMetaPublicColumns);
    memset(m_scmServerWiringMeta, 0x00, sizeof(SimpleColumnMeta) * kciServerWiringMetaPublicColumns);
    memset(m_scmTagMeta,          0x00, sizeof(SimpleColumnMeta) * kciTagMetaPublicColumns);
}

void TPopulateTableSchema::Compile(TPEFixup &i_fixup, TOutput &i_out)
{
    m_pFixup    = &i_fixup;
    m_pOut      = &i_out;

    static ULONG aHistogramOfTableSchemaSizesBy16thOfAPage[64];
    static ULONG aHistogramOfTableSchemaMinusHeapSizesBy16thOfAPage[64];
    memset(aHistogramOfTableSchemaSizesBy16thOfAPage, 0x00, sizeof(aHistogramOfTableSchemaSizesBy16thOfAPage));
    memset(aHistogramOfTableSchemaMinusHeapSizesBy16thOfAPage, 0x00, sizeof(aHistogramOfTableSchemaSizesBy16thOfAPage));

    AddItemToHeap(kTableSchemaSignature0);
    AddItemToHeap(kTableSchemaSignature1);

    ULONG CountOfTables = 0;
    ULONG iCountOfTables = AddItemToHeap(CountOfTables);

    (VOID)iCountOfTables;

    TSmartPointerArray<ULONG> aTableSchemaRowIndex = new ULONG[i_fixup.GetCountTableMeta()];//This lookup table gets placed at the end of the heap
    if(0 == aTableSchemaRowIndex.m_p)
    {
        THROW(ERROR - OUTOFMEMORY);
    }

    ULONG TableSchemaRowIndex=0;//We'll fill this in at the end.
    ULONG iTableSchemaRowIndex = AddItemToHeap(TableSchemaRowIndex);//but allocate the space for it here

    ULONG EndOfHeap = 0;//We'll fill this in at the end.
    ULONG iEndOfHeap = AddItemToHeap(EndOfHeap);//but allocate the space for it here

    ULONG iSimpleColumnMetaHeap = 0;
    ULONG iiSimpleColumnMetaHeap = AddItemToHeap(iSimpleColumnMetaHeap);

    ULONG Reserved2 = 0;
    ULONG iReserved2 = AddItemToHeap(Reserved2);

    (VOID)iReserved2;

    ULONG Reserved3 = 0;
    ULONG iReserved3 = AddItemToHeap(Reserved3);

    (VOID)iReserved3;

    ULONG modulo;
    DetermineHashTableModulo(modulo);
    AddItemToHeap(modulo);//TableNameHashHeader.Modulo
    AddItemToHeap(modulo);//Initial size of the hash table is the same

    TableSchema::HashedIndex aHashedIndex[TableSchema::kMaxHashTableSize];
    AddItemToHeap(reinterpret_cast<const unsigned char *>(aHashedIndex), sizeof(TableSchema::HashedIndex)*TableSchema::kMaxHashTableSize);//The HashTable is uninitialized at this point
    //we'll fill it in as we go through the tables

    //At last count there were 101 columns in CollectionMeta, 4 PropertyMeta, 1 ServerWiringMeta.  So we're going to need at least
    //this much space (assuming the average table has 4 or more columns).
    THeap<ULONG> TableSchemaHeapTemp(i_fixup.GetCountTableMeta() * 101*sizeof(ULONG));//We'll build up this heap, then slam the whole thing into the real TableSchemaHeap (this).

    TTableMeta TableMeta_ColumnMeta         (i_fixup, i_fixup.FindTableBy_TableName(L"COLUMNMETA"));
    TTableMeta TableMeta_ServerWiringMeta   (i_fixup, i_fixup.FindTableBy_TableName(L"SERVERWIRINGMETA"));
    TTableMeta TableMeta_TableMeta          (i_fixup, i_fixup.FindTableBy_TableName(L"TABLEMETA"));
    TTableMeta TableMeta_TagMeta            (i_fixup, i_fixup.FindTableBy_TableName(L"TAGMETA"));

    TTableMeta TableMeta(i_fixup);
    for(unsigned long iTable=0; iTable < i_fixup.GetCountTableMeta(); iTable++, TableMeta.Next())
    {
        if(*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_NOTABLESCHEMAHEAPENTRY)
            continue;

        ++CountOfTables;

        TPooledHeap PooledHeap;//This is where strings, bytes and guids get pooled

        TableSchema::CollectionMeta collectionmeta;

        //Inferrence rule 2.u.
        TableMeta.Get_pMetaTable()->nTableID = TableIDFromTableName(TableMeta.Get_InternalName());
        if(0 == (TableMeta.Get_pMetaTable()->nTableID & 0xFFFFF800))
        {
            i_out.printf(L"ERROR - Table (%s) cannot be added to the FixedPackedSchema because its TableID is (0x%08x).  Just alter the table name by a character, that should fix the problem.\n"
                        ,TableMeta.Get_InternalName(), TableMeta.Get_pMetaTable()->nTableID);
            THROW(ERROR - TABLEID HAS UPPER 21 BITS AS ZERO);
        }

        FillInThePublicColumns(reinterpret_cast<ULONG *>(&collectionmeta), TableMeta_TableMeta, reinterpret_cast<ULONG *>(TableMeta.Get_pMetaTable()), PooledHeap, m_scmCollectionMeta);
/*
        collectionmeta.Database             = PooledHeap.AddItemToHeap(TableMeta.Get_Database());               //0
        collectionmeta.InternalName         = PooledHeap.AddItemToHeap(TableMeta.Get_InternalName());           //1
        collectionmeta.PublicName           = PooledHeap.AddItemToHeap(TableMeta.Get_PublicName());             //2
        collectionmeta.PublicRowName        = PooledHeap.AddItemToHeap(TableMeta.Get_PublicRowName());          //3
        collectionmeta.BaseVersion          = *TableMeta.Get_BaseVersion();                                     //4
        collectionmeta.ExtendedVersion      = *TableMeta.Get_ExtendedVersion();                                 //5
        collectionmeta.NameColumn           = *TableMeta.Get_NameColumn();                                      //6
        collectionmeta.NavColumn            = *TableMeta.Get_NavColumn();                                       //7
        collectionmeta.MetaFlags            = *TableMeta.Get_MetaFlags();                                       //8
        collectionmeta.SchemaGeneratorFlags = *TableMeta.Get_SchemaGeneratorFlags();                            //9
        collectionmeta.ConfigItemName       = PooledHeap.AddItemToHeap(TableMeta.Get_ConfigItemName());         //10
        collectionmeta.ConfigCollectionName = PooledHeap.AddItemToHeap(TableMeta.Get_ConfigCollectionName());   //11
        collectionmeta.PublicRowNameColumn  = *TableMeta.Get_PublicRowNameColumn();                             //12
        collectionmeta.CountOfProperties    = *TableMeta.Get_CountOfColumns();                                  //13
*/

        collectionmeta.CountOfTags          = 0;//The rest of the CollectionMeta must be calculated later
        collectionmeta.nTableID             = TableMeta.Get_nTableID();
        collectionmeta.iFixedTableRows      = TableMeta.Get_iFixedTable();//This is an index into a heap that the FixedPackInterceptor knows nothing about
        collectionmeta.cFixedTableRows      = TableMeta.Get_ciRows();
        collectionmeta.iIndexMeta           = TableMeta.Get_iIndexMeta();//This is an index into a heap that the FixedPackInterceptor knows nothing about
        collectionmeta.cIndexMeta           = TableMeta.Get_cIndexMeta();
        collectionmeta.iHashTableHeader     = TableMeta.Get_iHashTableHeader();//This is an index into a heap that the FixedPackInterceptor knows nothing about
        collectionmeta.iTagMeta             = sizeof(TableSchema::CollectionMeta) + (collectionmeta.CountOfProperties * sizeof(TableSchema::PropertyMeta));//If there are tags they'll start at this offset (this does NOT imply that there ARE tag, use CountOfTags to determine that)
        collectionmeta.iServerWiring        = 0;//We can't determine this without first figuring out the Tags
        collectionmeta.cServerWiring        = TableMeta.Get_cServerWiring();;
        collectionmeta.iHeap                = 0;//We can't determine this without first figuring out the ServerWiring
        collectionmeta.cbHeap               = 0;

        ULONG TableOffset = AddItemToHeap(reinterpret_cast<const unsigned char *>(&collectionmeta), sizeof(collectionmeta));
        aTableSchemaRowIndex[CountOfTables-1] = TableOffset;//This lookup table gets placed at the end of the heap
        m_pOut->printf(L"Table:%40s    Offset: 0x%08x (%d)\n", reinterpret_cast<LPCWSTR>(PooledHeap.GetHeapPointer()+collectionmeta.InternalName), TableOffset, TableOffset);

        {//These pointers are only valid until the next AddItemToHeap since it may realloc and thus relocate the heap.  So we'll scope them here
            TableSchema::HashedIndex         *pFirstHashedIndex = reinterpret_cast<TableSchema::HashedIndex *>(m_pHeap + 8*sizeof(ULONG) + sizeof(TableSchema::HashTableHeader));
            TableSchema::HashedIndex         *pHashedIndex = const_cast<TableSchema::HashedIndex *>(pFirstHashedIndex + collectionmeta.nTableID%modulo);
            TableSchema::HashTableHeader     *pHashTableHeader = reinterpret_cast<TableSchema::HashTableHeader *>(pFirstHashedIndex - 1);
            ASSERT(pHashTableHeader->Size != ~0);
            ASSERT(pHashTableHeader->Size >= pHashTableHeader->Modulo);
            if(0x0000c664 == TableOffset)//I can't remember why this restriction exists; but Marcel assures me that the catalog doesn't work when this condition is met.
                THROW(ERROR - TABLEOFFSET MAY NOT BE C664 - REARRANGE THE TABLEMETA);
            if(pHashedIndex->iOffset != -1)//If we already seen this hash
            {
                while(pHashedIndex->iNext != -1)//follow the chain of duplicate hashes
                {
                    //We need to make sure that tables with the same TableID%modulo don't actually match TableIDs.
                    //We DON'T need to do a string compare, however, since like strings should equal like TableIDs.
                    TableSchema::TTableSchema OtherTable;
                    OtherTable.Init(m_pHeap + pHashedIndex->iOffset);
                    if(OtherTable.GetCollectionMeta()->nTableID == collectionmeta.nTableID)
                    {
                        m_pOut->printf(L"Error!  TableID collision between tables %s & %s.  You have either used a duplicate table name (remember table names are case-insensitive) OR it is also remotely possible that two tables with unlike table name CAN result in the same TableID (this is VERY rare).",
                            OtherTable.GetPointerFromIndex(OtherTable.GetCollectionMeta()->InternalName), TableMeta.Get_InternalName());
                        THROW(TableID collision);
                    }

                    pHashedIndex = pFirstHashedIndex + pHashedIndex->iNext;
                }
                pHashedIndex->iNext = pHashTableHeader->Size;
                pHashedIndex = pFirstHashedIndex + pHashTableHeader->Size;
                ++pHashTableHeader->Size;
            }
            //iNext should already be initialized to -1
            ASSERT(pHashedIndex->iNext == -1);
            ASSERT(pHashedIndex->iOffset == -1);

            pHashedIndex->iOffset = TableOffset;
        }
        TSmartPointerArray<TableSchema::PropertyMeta> aPropertyMeta = new TableSchema::PropertyMeta [collectionmeta.CountOfProperties];
        if(0 == aPropertyMeta.m_p)
            THROW(OUT OF MEMORY);

        TColumnMeta ColumnMeta(i_fixup, TableMeta.Get_iColumnMeta());

        ULONG iTagMeta = collectionmeta.iTagMeta;
        for(unsigned long iProperty=0; iProperty < collectionmeta.CountOfProperties; ++iProperty, ColumnMeta.Next())
        {
            FillInThePublicColumns(reinterpret_cast<ULONG *>(&aPropertyMeta[iProperty]), TableMeta_ColumnMeta, reinterpret_cast<ULONG *>(ColumnMeta.Get_pMetaTable()), PooledHeap, m_scmPropertyMeta);
/*
            aPropertyMeta[iProperty].Table                = collectionmeta.InternalName;
            aPropertyMeta[iProperty].Index                = *ColumnMeta.Get_Index();
            aPropertyMeta[iProperty].InternalName         = PooledHeap.AddItemToHeap(ColumnMeta.Get_InternalName());
            aPropertyMeta[iProperty].PublicName           = PooledHeap.AddItemToHeap(ColumnMeta.Get_PublicName());
            aPropertyMeta[iProperty].Type                 = *ColumnMeta.Get_Type();
            aPropertyMeta[iProperty].Size                 = *ColumnMeta.Get_Size();
            aPropertyMeta[iProperty].MetaFlags            = *ColumnMeta.Get_MetaFlags();
            aPropertyMeta[iProperty].DefaultValue         = PooledHeap.AddItemToHeap(ColumnMeta.Get_DefaultValue(), ColumnMeta.Get_DefaultValue() ? *(reinterpret_cast<const ULONG *>(ColumnMeta.Get_DefaultValue())-1) : 0);
            aPropertyMeta[iProperty].FlagMask             = *ColumnMeta.Get_FlagMask();
            aPropertyMeta[iProperty].StartingNumber       = *ColumnMeta.Get_StartingNumber();
            aPropertyMeta[iProperty].EndingNumber         = *ColumnMeta.Get_EndingNumber();
            aPropertyMeta[iProperty].CharacterSet         = PooledHeap.AddItemToHeap(ColumnMeta.Get_CharacterSet());
            aPropertyMeta[iProperty].SchemaGeneratorFlags = *ColumnMeta.Get_SchemaGeneratorFlags();
*/
            aPropertyMeta[iProperty].CountOfTags          = ColumnMeta.Get_ciTagMeta();
            aPropertyMeta[iProperty].iTagMeta             = aPropertyMeta[iProperty].CountOfTags ? iTagMeta : 0;
            aPropertyMeta[iProperty].iIndexName           = PooledHeap.AddItemToHeap(ColumnMeta.Get_iIndexName());

            //If there are other tags they'll start at iTagMeta
            iTagMeta += sizeof(TableSchema::TagMeta)*aPropertyMeta[iProperty].CountOfTags;

            //Total up the Tag count for the whole table
            collectionmeta.CountOfTags += aPropertyMeta[iProperty].CountOfTags;
        }
        if(collectionmeta.CountOfProperties)//Memory table has no Properties
            AddItemToHeap(reinterpret_cast<const unsigned char *>(aPropertyMeta.m_p), collectionmeta.CountOfProperties * sizeof(TableSchema::PropertyMeta));

        {//OK now we ca fixup the collectionmeta.CountOfTags already added to the heap.
            //Also, we know where the ServerWiring starts
            //Again pCollection is only valid 'til we call AddItemToHeap, so scope it here.
            TableSchema::CollectionMeta *pCollection = reinterpret_cast<TableSchema::CollectionMeta *>(m_pHeap + TableOffset);
            pCollection->CountOfTags    = collectionmeta.CountOfTags;
            pCollection->iServerWiring  = collectionmeta.iTagMeta + sizeof(TableSchema::TagMeta)*collectionmeta.CountOfTags;
            pCollection->iHeap          = pCollection->iServerWiring + sizeof(TableSchema::ServerWiringMeta)*collectionmeta.cServerWiring;
            //Now the only thing that needs to be filled in the collectionmeta is the cbHeap, which we won't know until we add the ServerWiring
        }

        if(collectionmeta.CountOfTags)
        {
            TSmartPointerArray<TableSchema::TagMeta> aTagMeta = new TableSchema::TagMeta [collectionmeta.CountOfTags];
            if(0 == aTagMeta.m_p)
                THROW(OUT OF MEMORY);

            ColumnMeta.Reset();
            for(iProperty=0; iProperty < collectionmeta.CountOfProperties; ++iProperty, ColumnMeta.Next())
            {
                if(0 != ColumnMeta.Get_ciTagMeta())
                    break;
            }

            TTagMeta    TagMeta(i_fixup, ColumnMeta.Get_iTagMeta());//Walk all the tags for the table (NOT just the column)
            for(ULONG iTag=0; iTag<collectionmeta.CountOfTags; ++iTag, TagMeta.Next())
            {
                FillInThePublicColumns(reinterpret_cast<ULONG *>(&aTagMeta[iTag]), TableMeta_TagMeta, reinterpret_cast<ULONG *>(TagMeta.Get_pMetaTable()), PooledHeap, m_scmTagMeta);
/*
                aTagMeta[iTag].Table            = PooledHeap.AddItemToHeap(TagMeta.Get_Table());
                aTagMeta[iTag].ColumnIndex      = *TagMeta.Get_ColumnIndex();
                aTagMeta[iTag].InternalName     = PooledHeap.AddItemToHeap(TagMeta.Get_InternalName());
                aTagMeta[iTag].PublicName       = PooledHeap.AddItemToHeap(TagMeta.Get_PublicName());
                aTagMeta[iTag].Value            = *TagMeta.Get_Value();
*/
            }
            AddItemToHeap(reinterpret_cast<const unsigned char *>(aTagMeta.m_p), collectionmeta.CountOfTags * sizeof(TableSchema::TagMeta));
        }

        //ServerWiring
        collectionmeta.cServerWiring = TableMeta.Get_cServerWiring();
        if(0!=wcscmp(L"MEMORY_SHAPEABLE", TableMeta.Get_InternalName()))//memory table has no ServerWiring
        {
            ASSERT(collectionmeta.cServerWiring>0);//There must be at least one ServerWiringMeta
        }

        TSmartPointerArray<TableSchema::ServerWiringMeta> aServerWiring = new TableSchema::ServerWiringMeta [TableMeta.Get_cServerWiring()];
        if(0 == aServerWiring.m_p)
            THROW(OUT OF MEMORY);

        ServerWiringMeta *pServerWiring = i_fixup.ServerWiringMetaFromIndex(TableMeta.Get_iServerWiring());
        for(ULONG iServerWiring=0; iServerWiring<TableMeta.Get_cServerWiring(); ++iServerWiring, ++pServerWiring)
        {
            FillInThePublicColumns(reinterpret_cast<ULONG *>(&aServerWiring[iServerWiring]), TableMeta_ServerWiringMeta, reinterpret_cast<ULONG *>(pServerWiring), PooledHeap, m_scmServerWiringMeta);
/*
            aServerWiring[iServerWiring].Table          = PooledHeap.AddItemToHeap(i_fixup.StringFromIndex(pServerWiring->Table));
            aServerWiring[iServerWiring].Order          = i_fixup.UI4FromIndex(pServerWiring->Order);
            aServerWiring[iServerWiring].ReadPlugin     = i_fixup.UI4FromIndex(pServerWiring->ReadPlugin);
            aServerWiring[iServerWiring].WritePlugin    = i_fixup.UI4FromIndex(pServerWiring->WritePlugin);
            aServerWiring[iServerWiring].Interceptor    = i_fixup.UI4FromIndex(pServerWiring->Interceptor);
            aServerWiring[iServerWiring].DLLName        = PooledHeap.AddItemToHeap(i_fixup.StringFromIndex(pServerWiring->DLLName));
            aServerWiring[iServerWiring].Flags          = i_fixup.UI4FromIndex(pServerWiring->Flags);
            aServerWiring[iServerWiring].Locator        = PooledHeap.AddItemToHeap(i_fixup.StringFromIndex(pServerWiring->Locator));
*/
        }
        AddItemToHeap(reinterpret_cast<const unsigned char *>(aServerWiring.m_p), TableMeta.Get_cServerWiring() * sizeof(TableSchema::ServerWiringMeta));
        ULONG iPooledHeap = AddItemToHeap(PooledHeap);//Now add the PooledHeap (which contains all the Strings, Byte arrays and Guids)

        {//Only now do we know how big the table's PooledHeap is
            TableSchema::CollectionMeta *pCollection = reinterpret_cast<TableSchema::CollectionMeta *>(m_pHeap + TableOffset);
            pCollection->cbHeap = PooledHeap.GetSizeOfHeap();
        }

        ULONG TableSize = GetEndOfHeap() - TableOffset;
        ULONG TableSizeMinusPooledHeap = TableSize - (GetEndOfHeap()-iPooledHeap);
        ++aHistogramOfTableSchemaSizesBy16thOfAPage[(TableSize/0x100)%64];
        ++aHistogramOfTableSchemaMinusHeapSizesBy16thOfAPage[(TableSizeMinusPooledHeap/0x100)%64];
    }
    //TableSchemaRowIndex helps us verify that indexes are in the correct range.
    //This is also where the TableSchemaRowIndex array belongs.  It is used to iterate through the tables aka. CollectionMeta
    TableSchemaRowIndex = AddItemToHeap(reinterpret_cast<const unsigned char *>(aTableSchemaRowIndex.m_p), CountOfTables * sizeof(ULONG));
    *reinterpret_cast<ULONG *>(const_cast<unsigned char *>(GetHeapPointer()+iTableSchemaRowIndex)) = TableSchemaRowIndex;

    iSimpleColumnMetaHeap = AddSimpleColumnMetaHeap();
    *reinterpret_cast<ULONG *>(const_cast<unsigned char *>(GetHeapPointer()+iiSimpleColumnMetaHeap)) = iSimpleColumnMetaHeap;

    //This is always the last thing we do is take stock of the Heap's size
    EndOfHeap = GetEndOfHeap();
    *reinterpret_cast<ULONG *>(const_cast<unsigned char *>(GetHeapPointer()+iEndOfHeap)) = EndOfHeap;

    m_pOut->printf(L"\nHistogram of TableSchema sizes\n");
    ULONG iSize;
    for(iSize=0;iSize<64;++iSize)
    {
        m_pOut->printf(L"%6d - %6d (bytes)    %3d\n", iSize*0x100, (iSize+1)*0x100, aHistogramOfTableSchemaSizesBy16thOfAPage[iSize]);
    }
    m_pOut->printf(L"\n\nHistogram of TableSchema sizes (not including the PooledHeap)\n");
    for(iSize=0;iSize<64;++iSize)
    {
        m_pOut->printf(L"%6d - %6d (bytes)    %3d\n", iSize*0x100, (iSize+1)*0x100, aHistogramOfTableSchemaMinusHeapSizesBy16thOfAPage[iSize]);
    }

    ULONG iULong = i_fixup.AddULongToList(GetTypedPointer(), GetCountOfTypedItems());

    (VOID)iULong;

    ASSERT(0 == iULong && "FixedPackedSchema needs to be at the beginning of the ULONG pool so that it's page aligned");
}

//Private methods
ULONG TPopulateTableSchema::AddSimpleColumnMetaHeap()
{
    /*SimpleColumnMetaHeap
    ULONG           iCollectionMeta
    ULONG           cCollectionMeta
    ULONG           iPropertyMeta
    ULONG           cPropertyMeta
    ULONG           iServerWiringMeta
    ULONG           cServerWiringMeta
    ULONG           iTagMeta
    ULONG           cTagMeta
    SimpleColumnMeta aSimpleColumnMeta[cCollectionMeta]
    SimpleColumnMeta aSimpleColumnMeta[cPropertyMeta]
    SimpleColumnMeta aSimpleColumnMeta[cServerWiringMeta]
    SimpleColumnMeta aSimpleColumnMeta[cTagMeta]
    */

    //SimpleColumnMeta is 3 ULONGs
    TTableMeta TableMeta_ColumnMeta         (*m_pFixup, m_pFixup->FindTableBy_TableName(L"COLUMNMETA"));
    TTableMeta TableMeta_ServerWiringMeta   (*m_pFixup, m_pFixup->FindTableBy_TableName(L"SERVERWIRINGMETA"));
    TTableMeta TableMeta_TableMeta          (*m_pFixup, m_pFixup->FindTableBy_TableName(L"TABLEMETA"));
    TTableMeta TableMeta_TagMeta            (*m_pFixup, m_pFixup->FindTableBy_TableName(L"TAGMETA"));

    ULONG i = 8L;
    ULONG iSimpleColumnMetaHeap = AddItemToHeap(i);
    AddItemToHeap(*TableMeta_TableMeta.Get_CountOfColumns());
    i += *TableMeta_TableMeta.Get_CountOfColumns() * (sizeof(SimpleColumnMeta)/sizeof(ULONG));

    AddItemToHeap(i);
    AddItemToHeap(*TableMeta_ColumnMeta.Get_CountOfColumns());
    i += *TableMeta_ColumnMeta.Get_CountOfColumns() * (sizeof(SimpleColumnMeta)/sizeof(ULONG));

    AddItemToHeap(i);
    AddItemToHeap(*TableMeta_ServerWiringMeta.Get_CountOfColumns());
    i += *TableMeta_ServerWiringMeta.Get_CountOfColumns() * (sizeof(SimpleColumnMeta)/sizeof(ULONG));

    AddItemToHeap(i);
    AddItemToHeap(*TableMeta_TagMeta.Get_CountOfColumns());

    AddItemToHeap(reinterpret_cast<const unsigned char *>(m_scmCollectionMeta), (*TableMeta_TableMeta.Get_CountOfColumns()) * sizeof(SimpleColumnMeta));
    AddItemToHeap(reinterpret_cast<const unsigned char *>(m_scmPropertyMeta), (*TableMeta_ColumnMeta.Get_CountOfColumns()) * sizeof(SimpleColumnMeta));
    AddItemToHeap(reinterpret_cast<const unsigned char *>(m_scmServerWiringMeta), (*TableMeta_ServerWiringMeta.Get_CountOfColumns()) * sizeof(SimpleColumnMeta));
    AddItemToHeap(reinterpret_cast<const unsigned char *>(m_scmTagMeta), (*TableMeta_TagMeta.Get_CountOfColumns()) * sizeof(SimpleColumnMeta));

    return iSimpleColumnMetaHeap;
}

//This doesn't actually fill in the hash table, it just determines whether the tables will fit into the hashtable and what the modulo is.
void TPopulateTableSchema::DetermineHashTableModulo(ULONG &modulo) const
{
    TableSchema::HashedIndex         hashedindex;
    TableSchema::HashedIndex         aHashedIndex[TableSchema::kMaxHashTableSize];

    TableSchema::HashTableHeader    &hashtableheader = *reinterpret_cast<TableSchema::HashTableHeader *>(&hashedindex);

    //Walk the tables and fillin the HashTable trying each of the prime numbers as a modulo
    const ULONG kPrime[]={503,499,491,487,479,467,463,461,457,449,443,439,433,431,421,419,409,401,397,389,383,379,373,367,359,353,349,347,337,331,317,313,311,307,0};

    ULONG CountOfTables = m_pFixup->GetCountTableMeta();

    ULONG iPrime=0;
    for(; kPrime[iPrime]; ++iPrime)
    {
        if(kPrime[iPrime] > TableSchema::kMaxHashTableSize)
            continue;//a valid modulo MUST be less than or equal to the size of the hash table

        hashtableheader.Modulo  = kPrime[iPrime];
        hashtableheader.Size    = hashtableheader.Modulo;//The initial size is the same as the prime number, the overflow go into the slots at the end (up to kMaxHashTableSize since that's the static FIXED size of the buffer)

        memset(aHashedIndex, -1, sizeof(TableSchema::HashedIndex) * TableSchema::kMaxHashTableSize);//Must initialize to -1

        TTableMeta TableMeta(*m_pFixup);
        unsigned long iTable=0;
        for(; iTable<CountOfTables && hashtableheader.Size<=TableSchema::kMaxHashTableSize; iTable++, TableMeta.Next())
        {
            if(*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_NOTABLESCHEMAHEAPENTRY)
                continue;

            TableSchema::HashedIndex *pHashedIndex = aHashedIndex + (TableMeta.Get_nTableID()%hashtableheader.Modulo);
            if(-1 != pHashedIndex->iOffset)
                ++hashtableheader.Size;

            ++pHashedIndex->iOffset;//Increment so we can track not only how many dups there are but how deep the links go (for now I don't care, as long as the hash table fits)
        }
        if(iTable==CountOfTables && hashtableheader.Size<=TableSchema::kMaxHashTableSize)
        {
            modulo = hashtableheader.Modulo;//Set this back to the Modulo so when we build the HashTable we know where to start filling in the overflow buckets
            m_pOut->printf(L"TableSchemaHeap modulo is %d\n", modulo);
            return;//if we made it through the list, we're good to go.
        }
    }
    m_pOut->printf(L"Cannot generate TableID hash table.  There must be alot of tables or something, 'cause this shouldn't happen.");
    THROW(Unable to generate TableID hash table);
}

void TPopulateTableSchema::FillInThePublicColumns(ULONG * o_dest, TTableMeta &i_tablemeta, ULONG * i_source, TPooledHeap &pooledHeap, SimpleColumnMeta *o_pSimpleColumnMeta)
{
    TColumnMeta columnmeta(*m_pFixup, i_tablemeta.Get_iColumnMeta());
    for(ULONG i=0;i<*i_tablemeta.Get_CountOfColumns();++i, columnmeta.Next())
    {
        if(0 == o_pSimpleColumnMeta[i].dbType)
        {
            o_pSimpleColumnMeta[i].dbType = *columnmeta.Get_Type();
            o_pSimpleColumnMeta[i].cbSize = *columnmeta.Get_Size();
            o_pSimpleColumnMeta[i].fMeta  = *columnmeta.Get_MetaFlags();
        }

        switch(*columnmeta.Get_Type())
        {
        case DBTYPE_UI4:
            if(0 == i_source[i])
            {
                m_pOut->printf(L"Error - Table(%s), Column(%d) - NULL not supported for meta UI4 columns\n", i_tablemeta.Get_InternalName(), i);
                THROW(ERROR - NULL UI4 VALUE IN META TABLE);
            }
            else
            {
                o_dest[i] = m_pFixup->UI4FromIndex(i_source[i]);
            }
            break;
        case DBTYPE_BYTES:
        case DBTYPE_WSTR:
            if(0 == i_source[i])
                o_dest[i] = 0;
            else            //Add the item to the local pool
                o_dest[i] = pooledHeap.AddItemToHeap(m_pFixup->ByteFromIndex(i_source[i]), m_pFixup->BufferLengthFromIndex(i_source[i]));
            break;
        case DBTYPE_DBTIMESTAMP:
        default:
            m_pOut->printf(L"Error - Unsupported Type (%d)\n", *columnmeta.Get_Type());
            THROW(ERROR - UNSUPPORTED TYPE);
            break;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tlateschemavalidate.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

void TLateSchemaValidate::Compile(TPEFixup &fixup, TOutput &out)
{
    //Currently we only have one LateSchemaValidation to to:

    //We walk the hash table entries for the TableMeta, looking for tables with the same name (case insensitive)
    //We need to be run AFTER the PK hash tables are built.
    TTableMeta tablemeta(fixup);

    ULONG iTableMeta=0;
    for(; iTableMeta< tablemeta.GetCount() && 0!=_wcsicmp(tablemeta.Get_InternalName(), L"TABLEMETA"); ++iTableMeta, tablemeta.Next());
    
    //We couldn't have gotten this far without TABLEMETA existing; but what the heck let's check anyway
    if(iTableMeta == tablemeta.GetCount())
    {
        THROW(ERROR - NO TABLEMETA FOR TABLEMETA FOUND);
    }

    HashTableHeader * pHashTableHeader      = reinterpret_cast<HashTableHeader *>(fixup.HashedIndexFromIndex(tablemeta.Get_iHashTableHeader()));
    HashedIndex     * pHashedIndexZeroth    = reinterpret_cast<HashedIndex *>(pHashTableHeader+1);

    HashedIndex     * pHashedIndex          = pHashedIndexZeroth;
    for(ULONG iHashTable=0; iHashTable<pHashTableHeader->Modulo; ++iHashTable, ++pHashedIndex)
    {
        if(-1 != pHashedIndex->iNext)//if there are more than one TableMeta at this hash entry
        {
            ASSERT(-1 != pHashedIndex->iOffset);//it does not make sense to have more than one row with the same hash; but have the row index be -1.

            HashedIndex *pHashIndexTemp0 = pHashedIndex;
            while(pHashIndexTemp0->iNext != -1)//follow the chain
            {
                HashedIndex *pHashIndexTemp1 = pHashIndexTemp0;
                while(pHashIndexTemp1->iNext != -1)//follow the chain
                {
                    pHashIndexTemp1 = pHashedIndexZeroth + pHashIndexTemp1->iNext;
                    ASSERT(-1 != pHashIndexTemp1->iOffset);//it does not make sense to have a hash entry for row -1.

                    if(0 == _wcsicmp(fixup.StringFromIndex(fixup.TableMetaFromIndex(pHashIndexTemp0->iOffset)->InternalName),
                                     fixup.StringFromIndex(fixup.TableMetaFromIndex(pHashIndexTemp1->iOffset)->InternalName)))
                    {
                        out.printf(L"TableName collision between (Database:%s Table:%s) and (Database:%s Table:%s)\r\n",
                            fixup.StringFromIndex(fixup.TableMetaFromIndex(pHashIndexTemp0->iOffset)->Database),
                            fixup.StringFromIndex(fixup.TableMetaFromIndex(pHashIndexTemp0->iOffset)->InternalName),
                            fixup.StringFromIndex(fixup.TableMetaFromIndex(pHashIndexTemp1->iOffset)->Database),
                            fixup.StringFromIndex(fixup.TableMetaFromIndex(pHashIndexTemp1->iOffset)->InternalName));
                        THROW(ERROR - TWO TABLE HAVE THE SAME CASE INSENSITIVE NAME);
                    }
                }

                pHashIndexTemp0 = pHashedIndexZeroth + pHashIndexTemp0->iNext;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tcomcatmetaxmlfile.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
/*
Modifying Meta for the ColumnMeta table

List of File Requiring Change
    CATMETA.XMS
    CATMETA_CORE.XML
    "Inferrence Rule for Catalog Meta Tables.doc"
    METATABLESTRUCTS.H
    TMETAINFERRENCE.CPP
Steps
    1.	Add the new columns to ColumnMetaPublic in MetaTableStructs.h.
    2.	Add the new attributes to CatMeta.XMS
    3.	Add the new columns to CatMeta_Core.XML
    4.	Add the new "m_bstr_" variables to the TComCatMetaXmlFile object (in TComCatMetaXmlFile.h)
    5.	Initialize the new "m_bstr_" variables in the TComCatMetaXmlFile constructor (TComCatMetaXmlFile.cpp)
    6.	Modify TComCatMetaXmlFile.cpp::FillInThePEColumnMeta (TComCatMetaXmlFile.cpp) to read in the new columns.
        a.	Update the 'if(InheritsColumnMeta)'.  Note that UI4 value explicitly specified overrides the property the column inherited from.  And flag values are Ored with the inherited flags.
        b.	Update the 'else' clause.
    7.	Modify TComCatMetaXmlFile.cpp::AddColumnByReference (TComCatMetaXmlFile.cpp).
    8.	Update "Inferrence Rule for Catalog Meta Tables.doc".  Remember, UI4 values in Meta tables may NOT be NULL.
    9.	Modify TMetaInferrence::InferColumnMeta (TMetaInferrence.cpp)
   10.  Change FixedTableHeap.h version number (kFixedTableHeapVersion)
*/

#include "precomp.hxx"

LPCWSTR TComCatMetaXmlFile::m_szComCatMetaSchema    =L"ComCatMeta_v7";
GlobalRowCounts g_coreCounts; // global count of the rows in the meta tables that come from catmeta_core.xml

extern int numelementsOLEDataTypeToXMLDataType;

//We do everything we need with XmlFile in the ctor so we don't keep it around
TComCatMetaXmlFile::TComCatMetaXmlFile(TXmlFile *pXmlFile, int cXmlFile, TOutput &out) : TFixupHeaps()
                ,m_bstr_Attributes          (kszAttributes          )
                ,m_bstr_BaseVersion         (kszBaseVersion         )
                ,m_bstr_cbSize              (kszcbSize              )
                ,m_bstr_CellName            (kszCellName            )
                ,m_bstr_CharacterSet        (kszCharacterSet        )
                ,m_bstr_ChildElementName    (kszChildElementName    )
                ,m_bstr_ColumnInternalName  (kszColumnInternalName  )
                ,m_bstr_ColumnMeta          (kszColumnMeta          )
                ,m_bstr_ColumnMetaFlags     (kszColumnMetaFlags     )
                ,m_bstr_ConfigItemName      (kszConfigItemName      )
                ,m_bstr_ConfigCollectionName(kszConfigCollectionName)
                ,m_bstr_ContainerClassList  (kszContainerClassList  )
                ,m_bstr_DatabaseInternalName(kszDatabaseInternalName)
                ,m_bstr_DatabaseMeta        (kszDatabaseMeta        )
                ,m_bstr_dbType              (kszdbType              )
                ,m_bstr_DefaultValue        (kszDefaultValue        )
				,m_bstr_Description			(kszDescription			)
                ,m_bstr_EnumMeta            (kszEnumMeta            )
                ,m_bstr_ExtendedVersion     (kszExtendedVersion     )
                ,m_bstr_FlagMeta            (kszFlagMeta            )
                ,m_bstr_ForeignTable        (kszForeignTable        )
                ,m_bstr_ForeignColumns      (kszForeignColumns      )
                ,m_bstr_ID                  (kszID                  )
                ,m_bstr_IndexMeta           (kszIndexMeta           )
                ,m_bstr_InheritsColumnMeta  (kszInheritsColumnMeta  )
                ,m_bstr_Interceptor         (kszInterceptor         )
				,m_bstr_InterceptorDLLName  (kszInterceptorDLLName  )
                ,m_bstr_InternalName        (kszInternalName        )
                ,m_bstr_Locator             (kszLocator             )
                ,m_bstr_MaximumValue        (kszMaximumValue        )
                ,m_bstr_Merger              (kszMerger              )
                ,m_bstr_MergerDLLName       (kszMergerDLLName       )
                ,m_bstr_MetaFlags           (kszMetaFlags           )
                ,m_bstr_MinimumValue        (kszMinimumValue        )
                ,m_bstr_NameValueMeta       (kszNameValueMeta       )
                ,m_bstr_Operator            (kszOperator            )
                ,m_bstr_PrimaryTable        (kszPrimaryTable        )
                ,m_bstr_PrimaryColumns      (kszPrimaryColumns      )
                ,m_bstr_PublicName          (kszPublicName          )
				,m_bstr_PublicColumnName    (kszPublicColumnName    )
                ,m_bstr_PublicRowName       (kszPublicRowName       )
                ,m_bstr_QueryMeta           (kszQueryMeta           )
                ,m_bstr_ReadPlugin          (kszReadPlugin          )
				,m_bstr_ReadPluginDLLName   (kszReadPluginDLLName   )
                ,m_bstr_RelationMeta        (kszRelationMeta        )
                ,m_bstr_SchemaGenFlags      (kszSchemaGenFlags      )
                ,m_bstr_ServerWiring        (kszServerWiring        )
                ,m_bstr_TableMeta           (kszTableMeta           )
                ,m_bstr_TableMetaFlags      (kszTableMetaFlags      )
                ,m_bstr_UserType            (kszUserType            )
                ,m_bstr_Value               (kszValue               )
                ,m_bstr_WritePlugin         (kszWritePlugin         )
				,m_bstr_WritePluginDLLName  (kszWritePluginDLLName  )
                ,m_out(out)
                ,m_pxmlFile(pXmlFile)
                ,m_pXMLDocMetaMeta(0)
                ,m_pXMLDoc(0)
{
    m_pXMLDocMetaMeta = pXmlFile->GetXMLDOMDocument();
    {//confirm that this is the MetaMeta xml file
        CComPtr<IXMLDOMNodeList>    pNodeList_DatabaseMeta;
        XIF(m_pXMLDocMetaMeta->getElementsByTagName(m_bstr_DatabaseMeta, &pNodeList_DatabaseMeta));

        if(0 == pNodeList_DatabaseMeta.p)
        {
            m_out.printf(L"No Database Meta found.  Unable to proceed.\n");
            THROW(No Database Meta found.);
        }
        long cDatabaseMeta;
        XIF(pNodeList_DatabaseMeta->get_length(&cDatabaseMeta));
        if(0 == cDatabaseMeta)
        {
            m_out.printf(L"No DatabaseMeta found.  Unable to proceed.\n");
            THROW(ERROR - NO DATABASEMETA FOUND);
        }
        long i;
        for(i=0;i<cDatabaseMeta;++i)
        {
            CComPtr<IXMLDOMNode> pNode_DatabaseMeta;
            XIF(pNodeList_DatabaseMeta->nextNode(&pNode_DatabaseMeta));

            CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement = pNode_DatabaseMeta;ASSERT(0 != pElement.p);//Get the IXMLDOMElement interface pointer

            CComVariant             var_Name;
            XIF(pElement->getAttribute(m_bstr_InternalName, &var_Name));

            if(0 == lstrcmpi(var_Name.bstrVal, L"META"))
                break;
        }
        if(i==cDatabaseMeta)
        {
            m_out.printf(L"The first Meta file listed does not contain the MetaMeta.\n");
            THROW(ERROR - METAMETA NOT FOUND);
        }
    }
    for(int iXmlFile=0;iXmlFile<cXmlFile; ++iXmlFile)
    {
        ULONG iStartingTable = GetCountTableMeta();

        (VOID)iStartingTable;

        m_pxmlFile = pXmlFile + iXmlFile;
        m_pXMLDoc = m_pxmlFile->GetXMLDOMDocument();
        FillInThePEDatabaseMeta();
        FillInThePERelationMeta();

        // save the count of rows in the tables after catmeta_core.xml has been compiled
        if(iXmlFile==0)
        {
            g_coreCounts.cCoreTables    = GetCountTableMeta();
            g_coreCounts.cCoreDatabases = GetCountDatabaseMeta();
            g_coreCounts.cCoreColumns   = GetCountColumnMeta();
            g_coreCounts.cCoreTags      = GetCountTagMeta();
            g_coreCounts.cCoreIndexes   = GetCountIndexMeta();
            g_coreCounts.cCoreRelations = GetCountRelationMeta();
            g_coreCounts.cCoreQueries   = GetCountQueryMeta();

            m_out.printf(L"core tables: %d\n", g_coreCounts.cCoreTables);
            m_out.printf(L"core databases: %d\n", g_coreCounts.cCoreDatabases);
            m_out.printf(L"core columns: %d\n", g_coreCounts.cCoreColumns);
            m_out.printf(L"core tags: %d\n", g_coreCounts.cCoreTags);
            m_out.printf(L"core indexes: %d\n", g_coreCounts.cCoreIndexes);
            m_out.printf(L"core relations: %d\n", g_coreCounts.cCoreRelations);
            m_out.printf(L"core queries: %d\n", g_coreCounts.cCoreQueries);
        }
    }

    m_pXMLDoc = 0;//We don't addref on this one since we use it locally within the ctor only.
    m_out.printf(L"%s conforms to all enforceable conventions.\n", m_szComCatMetaSchema);
}


//
//Private functions
//
unsigned long TComCatMetaXmlFile::AddArrayOfColumnsToBytePool(unsigned long Table, LPWSTR wszColumnNames)
{
    ASSERT(0 == Table%4);
    ULONG iColumnMeta_0th = FindColumnBy_Table_And_Index(Table, AddUI4ToList(0));

    unsigned long aColumnsAsBytes[255];
    unsigned long iColumns=0;

    wchar_t *       pszColumn;
    pszColumn = wcstok(wszColumnNames, L" ");
    while(pszColumn != 0)
    {
        ULONG iColumnMeta = iColumnMeta_0th;

        unsigned char index;
        for(index=0; iColumnMeta<GetCountColumnMeta() && ColumnMetaFromIndex(iColumnMeta)->Table == Table; ++index, ++iColumnMeta)
        {
            if(ColumnMetaFromIndex(iColumnMeta)->InternalName == AddWCharToList(pszColumn))
            {
                aColumnsAsBytes[iColumns++] = index;
                if(iColumns >= 255)
                {
                    m_out.printf(L"Error - Too many columns specified.\n");
                    THROW(ERROR - TOO MANY COLUMNS);
                }
                break;
            }
        }
        if(iColumnMeta==GetCountColumnMeta() || ColumnMetaFromIndex(iColumnMeta)->Table!=Table)
        {
            m_out.printf(L"Error in RelationMeta - Column (%s) not found in Table (%s).\n", pszColumn, StringFromIndex(Table));
            THROW(ERROR - BAD COLUMN IN RELATIONMETA);
        }
        pszColumn = wcstok(0, L" ");//Next token (next Flag RefID)
    }
    return AddBytesToList(reinterpret_cast<unsigned char *>(aColumnsAsBytes), (iColumns)*sizeof(ULONG));
}



void TComCatMetaXmlFile::AddColumnByReference(ULONG iTableName_Destination, ULONG iColumnIndex_Destination, ULONG iColumnMeta_Source, ColumnMeta &o_columnmeta)
{
    ColumnMeta * pColumnMeta = ColumnMetaFromIndex(iColumnMeta_Source);

    if(UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_DIRECTIVE)
    {
        m_out.printf(L"Error in inheritance - Referenced Column (%s) is a Directive colum, this is not yet supported.\n", StringFromIndex(pColumnMeta->InternalName));
        THROW(ERROR - BAD INHERITANCE);
    }

    //If the column is a Flag of Enum we need to add TagMeta
    if(UI4FromIndex(pColumnMeta->MetaFlags) & (fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM))
    {
        ULONG iTagMeta = FindTagBy_Table_And_Index(pColumnMeta->Table, pColumnMeta->Index);
        ASSERT(-1 != iTagMeta);
        if(-1 == iTagMeta)
        {
            THROW(ERROR - TAGMETA NOT FOUND);
        }

        /*struct TagMetaPublic
        {
            ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
            ULONG PRIMARYKEY FOREIGNKEY ColumnIndex;            //UI4       This is the iOrder member of the ColumnMeta
            ULONG PRIMARYKEY            InternalName;           //String
            ULONG                       PublicName;             //String
            ULONG                       Value;
        };*/
        for( ;iTagMeta<GetCountTagMeta()
            && TagMetaFromIndex(iTagMeta)->Table==pColumnMeta->Table
            && TagMetaFromIndex(iTagMeta)->ColumnIndex==pColumnMeta->Index;++iTagMeta)
        {
            TagMeta *pTagMeta = TagMetaFromIndex(iTagMeta);

            TagMeta tagmeta;

            tagmeta.Table           = iTableName_Destination    ;
            tagmeta.ColumnIndex     = iColumnIndex_Destination  ;
            tagmeta.InternalName    = pTagMeta->InternalName    ;
            tagmeta.PublicName      = pTagMeta->PublicName      ;
            tagmeta.Value           = pTagMeta->Value           ;
            tagmeta.ID              = pTagMeta->ID              ;

            m_HeapTagMeta.AddItemToHeap(tagmeta);
        }
    }

    o_columnmeta.Table                  = iTableName_Destination                ;//Index into Pool
    o_columnmeta.Index                  = iColumnIndex_Destination              ;//Column Index
    o_columnmeta.InternalName           = pColumnMeta->InternalName             ;//Index into Pool
    o_columnmeta.PublicName             = pColumnMeta->PublicName               ;//Index into Pool
    o_columnmeta.Type                   = pColumnMeta->Type                     ;//These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
    o_columnmeta.Size                   = pColumnMeta->Size                     ;//
    o_columnmeta.MetaFlags              = pColumnMeta->MetaFlags                ;//ColumnMetaFlags defined in CatMeta.xml
    o_columnmeta.DefaultValue           = pColumnMeta->DefaultValue             ;//Only valid for UI4s
    o_columnmeta.FlagMask               = pColumnMeta->FlagMask                 ;//Only valid for flags
    o_columnmeta.StartingNumber         = pColumnMeta->StartingNumber           ;//Only valid for UI4s
    o_columnmeta.EndingNumber           = pColumnMeta->EndingNumber             ;//Only valid for UI4s
    o_columnmeta.CharacterSet           = pColumnMeta->CharacterSet             ;//Index into Pool - Only valid for WSTRs
    o_columnmeta.SchemaGeneratorFlags   = AddUI4ToList(fCOLUMNMETA_PROPERTYISINHERITED | (pColumnMeta->SchemaGeneratorFlags ? UI4FromIndex(pColumnMeta->SchemaGeneratorFlags) : 0));//ColumnMetaFlags defined in CatMeta.xml
    o_columnmeta.ID                     = pColumnMeta->ID                       ;
    o_columnmeta.UserType               = pColumnMeta->UserType                 ;
    o_columnmeta.Attributes             = pColumnMeta->Attributes               ;
	o_columnmeta.Description			= pColumnMeta->Description				;
	o_columnmeta.PublicColumnName		= pColumnMeta->PublicColumnName         ;
    o_columnmeta.ciTagMeta              = 0                                     ;//Count of Tags - Only valid for UI4s
    o_columnmeta.iTagMeta               = 0                                     ;//Index into TagMeta - Only valid for UI4s
    o_columnmeta.iIndexName             = 0                                     ;//IndexName of a single column index (for this column)
}

/*struct ColumnMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            Index;                  //UI4       Column Index
    ULONG                       InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Type;                   //UI4       These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
    ULONG                       Size;                   //UI4
    ULONG                       MetaFlags;              //UI4       ColumnMetaFlags defined in CatMeta.xml
    ULONG                       DefaultValue;           //Bytes
    ULONG                       FlagMask;               //UI4       Only valid for flags
    ULONG                       StartingNumber;         //UI4       Only valid for UI4s
    ULONG                       EndingNumber;           //UI4       Only valid for UI4s
    ULONG                       CharacterSet;           //String    Only valid for Strings
    ULONG                       SchemaGeneratorFlags;   //UI4       ColumnMetaFlags defined in CatMeta.xml
    ULONG                       ID;                     //UI4       Metabase ID
    ULONG                       UserType;               //UI4       One of the Metabase UserTypes
    ULONG                       Attributes;             //UI4       Metabase Attribute flags
	ULONG						Description;			//String	Description
	ULONG                       PublicColumnName;       //String    Public Column name (XML Tag)
    ULONG                       ciTagMeta;              //Count of Tags - Only valid for UI4s
    ULONG                       iTagMeta;               //Index into TagMeta - Only valid for UI4s
    ULONG                       iIndexName;             //IndexName of a single column index (for this column)
};*/
void TComCatMetaXmlFile::FillInThePEColumnMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table, unsigned long ParentTable)
{
    ASSERT(0 == Table%4);
    ASSERT(0 == ParentTable%4);

    ULONG   Index               = 0;

    if(ParentTable)//If there is a parent table, the column meta derives from it
    {
        unsigned long iColumnMeta = FindColumnBy_Table_And_Index(ParentTable, AddUI4ToList(0));
        if(-1 == iColumnMeta)
        {
            m_out.printf(L"Error in inheritance chain of Table(%s) - Parent Table must be defined BEFORE inheriting tables.\n", StringFromIndex(Table));
            THROW(ERROR - BAD INHERITANCE);
        }

        ColumnMeta columnmeta;
        for(Index = 0; iColumnMeta<GetCountColumnMeta() && ColumnMetaFromIndex(iColumnMeta)->Table == ParentTable; ++Index, ++iColumnMeta)
        {
            memset(&columnmeta, 0x00, sizeof(columnmeta));

            AddColumnByReference(Table, AddUI4ToList(Index), iColumnMeta, columnmeta);
            m_HeapColumnMeta.AddItemToHeap(columnmeta);
        }

    }


    //Get All ColumnMeta elements under the TableMeta node
    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_TableMeta = pNode_TableMeta;ASSERT(0 != pElement_TableMeta.p);
    CComPtr<IXMLDOMNodeList>    pNodeList_ColumnMeta;
    XIF(pElement_TableMeta->getElementsByTagName(m_bstr_ColumnMeta, &pNodeList_ColumnMeta));

    if(0 == pNodeList_ColumnMeta.p)
        return;

    long cColumnMeta;
    XIF(pNodeList_ColumnMeta->get_length(&cColumnMeta));

    ULONG iColumnMeta_First=(ULONG)-1;
    ULONG cInheritanceWarnings=0;
    wstring wstrIgnoredColumns;

    //Walk the list to the next sibling that is a ColumnMeta element
    while(cColumnMeta--)
    {
        ColumnMeta columnmeta;
        memset(&columnmeta, 0x00, sizeof(columnmeta));

        CComPtr<IXMLDOMNode> pNode_ColumnMeta;
        XIF(pNodeList_ColumnMeta->nextNode(&pNode_ColumnMeta));
        ASSERT(0 != pNode_ColumnMeta.p);

        //Get the attribute map for this element
        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_ColumnMeta_AttributeMap;
        XIF(pNode_ColumnMeta->get_attributes(&pNodeMap_ColumnMeta_AttributeMap));
        ASSERT(0 != pNodeMap_ColumnMeta_AttributeMap.p);//The schema should prevent this.

        //Is this Property inherited?
        CComVariant var_string;
        if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_InheritsColumnMeta, var_string, false))
        {
            //The inheritance string is of the form  TableName:ColumnName
            wchar_t * pTableName = wcstok(var_string.bstrVal, L":");
            wchar_t * pColumnName = wcstok(0, L":");
            if(0==pTableName || 0==pColumnName)
            {
                CComVariant var_string;
                m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_InheritsColumnMeta, var_string);
                m_out.printf(L"Error in inheritance - Table (%s), Property number (%d) attempted to inherit from (%s).  the inheritance must be of the form (TableName:CollumnName)\n", StringFromIndex(Table), Index, var_string.bstrVal);
                THROW(ERROR IN PROERTY INHERITANCE);
            }
            ULONG iColumnInternalName;
            ULONG iColumnMeta = FindColumnBy_Table_And_InternalName(AddWCharToList(pTableName), iColumnInternalName=AddWCharToList(pColumnName));

            if(-1 == iColumnMeta)
            {
                CComVariant var_string;
                m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_InheritsColumnMeta, var_string);
                ++cInheritanceWarnings;
                WCHAR wszTemp[50];
                wsprintf(wszTemp,L"%-38s ", var_string.bstrVal);
                wstrIgnoredColumns += wszTemp;
                wstrIgnoredColumns += (0 == (cInheritanceWarnings & 0x01)) ? L"\n" : L" ";
                //@@@m_out.printf(L"INHERITANCE WARNING! Table (%s) attempted to inherit from (%s) which does not exist.  Property ignored\n", StringFromIndex(Table), var_string.bstrVal);
                continue;//continue without bumping the Index.
            }
            //Now we tolerate duplicate inherited columns and ignore them
            //so we need to search this table's ColumnMeta for column name we're getting ready to add.
            if(-1 != iColumnMeta_First)
            {
                TColumnMeta columnmetaThis(*this, iColumnMeta_First);
                ULONG j=iColumnMeta_First;
                for(;j<columnmetaThis.GetCount();++j, columnmetaThis.Next())
                {
                    if(columnmetaThis.Get_pMetaTable()->InternalName == iColumnInternalName)
                        break;
                }
                if(j<columnmetaThis.GetCount())
                {
                    ++cInheritanceWarnings;
                    WCHAR wszTemp[50];
                    wsprintf(wszTemp,L"%-38s", StringFromIndex(iColumnInternalName));
                    wstrIgnoredColumns += wszTemp;
                    wstrIgnoredColumns += (0 == (cInheritanceWarnings & 0x01)) ? L"\n" : L" ";
                    //@@@m_out.printf(L"INHERITANCE WARNING! Table (%s) attempted to inherit from (%s) a second time.  Property ignored\n", StringFromIndex(Table), StringFromIndex(iColumnInternalName));
                    continue;//continue without bumping Index
                }
            }

            AddColumnByReference(Table, AddUI4ToList(Index), iColumnMeta, columnmeta);
            //Now fall through to fill in the rest


            //Table         - Already filled in
            //Index         - Already filled in
            //InternalName  - Already filled in (can't override the InternalName)
            //PublicName
                    ULONG PublicName = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_PublicName);
                    if(0 != PublicName)
                        columnmeta.PublicName = PublicName;
            //Type          - Already filled in (can't override the Type)
            //Size          - Already filled in (can't override the Size)
            //MetaFlags
                    ULONG MetaFlags;//We don't want to clobber any MetaFlags that have already been set.
                    GetFlags(pNodeMap_ColumnMeta_AttributeMap, m_bstr_ColumnMetaFlags, 0, MetaFlags);
                    //Inheritted properties can only OR in new flags; they can't reset flags to zero.
                    columnmeta.MetaFlags = AddUI4ToList(MetaFlags | UI4FromIndex(columnmeta.MetaFlags));

            //DefaultValue needs to be filled in after MetaFlags, Type and Size and TagMeta
            //FlagMask      - Already filled in
            //StartingNumber
                    ULONG StartingNumber;
                    if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_MinimumValue, StartingNumber, false))
                        columnmeta.StartingNumber = AddUI4ToList(StartingNumber);
            //EndingNumber
                    ULONG EndingNumber;
                    if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_MaximumValue, EndingNumber, false))
                        columnmeta.EndingNumber = AddUI4ToList(EndingNumber);
            //CharacterSet
                    ULONG CharacterSet;
                    if(0 != (CharacterSet = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_CharacterSet)))
                        columnmeta.CharacterSet = CharacterSet;
            //SchemaGeneratorFlags
                    ULONG SchemaGeneratorFlags;
                    GetFlags(pNodeMap_ColumnMeta_AttributeMap, m_bstr_SchemaGenFlags, 0, SchemaGeneratorFlags);
                    //Inheritted properties can only OR in new flags; they can't reset flags to zero.
                    columnmeta.SchemaGeneratorFlags = AddUI4ToList(SchemaGeneratorFlags | UI4FromIndex(columnmeta.SchemaGeneratorFlags));
            //ID
                    ULONG ID;
                    if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_ID, ID, false))
                        columnmeta.ID = AddUI4ToList(ID);//Convert to index into aUI4 pool
            //UserType
                    ULONG UserType;
                    if(GetEnum(pNodeMap_ColumnMeta_AttributeMap, m_bstr_UserType, UserType, false))
                        columnmeta.UserType = AddUI4ToList(UserType);
            //Attributes
                    ULONG Attributes;
                    GetFlags(pNodeMap_ColumnMeta_AttributeMap, m_bstr_Attributes, 0, Attributes);
                    columnmeta.Attributes = AddUI4ToList(Attributes | UI4FromIndex(columnmeta.Attributes));
			//Description
                    ULONG Description;
                    if(0 != (Description = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_Description)))
                        columnmeta.Description = Description;
        	//PublicColumnName
                    ULONG PublicColumnName;
                    if(0 != (PublicColumnName = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_PublicColumnName)))
                        columnmeta.PublicColumnName = PublicColumnName;

            //ciTagMeta         inferred later
            //iTagMeta          inferred later
            //iIndexName        inferred later

            //DefaultValue
                    ULONG DefaultValue = GetDefaultValue(pNodeMap_ColumnMeta_AttributeMap, columnmeta, false /*don't default a flag value to zero if DefaultValue is not specified*/);
                    if(0 != DefaultValue)
                        columnmeta.DefaultValue = DefaultValue;
                    if(-1 == iColumnMeta_First)
                        iColumnMeta_First = m_HeapColumnMeta.AddItemToHeap(columnmeta)/sizeof(ColumnMeta);
                    else
                        m_HeapColumnMeta.AddItemToHeap(columnmeta);
        }
        else //If the column is inherited and has TagMeta, AddColumnByReference has already filled in the tagmeta
        {
            //We need to know whether there are Flag or Enum child elements
            CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_ColumnMeta = pNode_ColumnMeta;ASSERT(0 != pElement_ColumnMeta.p);
            CComPtr<IXMLDOMNodeList>    pNodeList_FlagMeta;
            XIF(pElement_ColumnMeta->getElementsByTagName(m_bstr_FlagMeta, &pNodeList_FlagMeta));

            long cFlagMeta=0;
            if(pNodeList_FlagMeta.p)
            {
                XIF(pNodeList_FlagMeta->get_length(&cFlagMeta));
            }

            long cEnumMeta=0;
            CComPtr<IXMLDOMNodeList>    pNodeList_EnumMeta;
            if(cFlagMeta == 0)
            {
                XIF(pElement_ColumnMeta->getElementsByTagName(m_bstr_EnumMeta, &pNodeList_EnumMeta));
                if(pNodeList_EnumMeta.p)
                {
                    XIF(pNodeList_EnumMeta->get_length(&cEnumMeta));
                }
            }
            //No if cFlagMeta>0 then we set the MetaFlag, fCOLUMNMETA_FLAG.  If cEnumMeta>0 we set the MetaFlag fCOLUMNMETA_ENUM.
            //Table
                    columnmeta.Table = Table;
            //Index
                    columnmeta.Index = AddUI4ToList(Index);
            //InternalName
                    columnmeta.InternalName = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_InternalName, true);
            //PublicName
                    columnmeta.PublicName = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_PublicName);
            //Type
                    //Get the Type attribute - the Type MUST exist in the OLEDataTypeToXMLDataType array
                    int iOLEDataTypeIndex;
                    Get_OLEDataTypeToXMLDataType_Index(pNodeMap_ColumnMeta_AttributeMap, m_bstr_dbType, iOLEDataTypeIndex);//Get the index into the OLEDataType array
                    columnmeta.Type = AddUI4ToList(OLEDataTypeToXMLDataType[iOLEDataTypeIndex].dbType);
            //Size
                    if(!m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_cbSize, columnmeta.Size, false))
                        columnmeta.Size = OLEDataTypeToXMLDataType[iOLEDataTypeIndex].cbSize;
                    else
                    {
                        if(static_cast<unsigned long>(-1) != OLEDataTypeToXMLDataType[iOLEDataTypeIndex].cbSize &&
                                          columnmeta.Size != OLEDataTypeToXMLDataType[iOLEDataTypeIndex].cbSize)
                        {
                            m_out.printf(L"WARNING!! Bad Size attribute.  A size was specified (%d); but was expecting (%d).  Using expected value of (%d) as the size.\n", columnmeta.Size, OLEDataTypeToXMLDataType[iOLEDataTypeIndex].cbSize, OLEDataTypeToXMLDataType[iOLEDataTypeIndex].cbSize);
                            columnmeta.Size = OLEDataTypeToXMLDataType[iOLEDataTypeIndex].cbSize;
                        }
                    }
                    if(0 == columnmeta.Size)
                    {
                        m_out.printf(L"Error in Size attribute.  A size of 0 was specified.  This size does not make sense.\n");
                        THROW(ERROR - BAD SIZE);
                    }
                    columnmeta.Size = AddUI4ToList(columnmeta.Size);
            //MetaFlags
                    GetFlags(pNodeMap_ColumnMeta_AttributeMap, m_bstr_ColumnMetaFlags, 0, columnmeta.MetaFlags);
                    if(columnmeta.MetaFlags & ( fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM |
                                                fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE))
                    {
                        m_out.printf(L"Warning - Table (%s), Column (%s) - Some MetaFlag should be inferred (resetting these flags).  The following flags should NOT be specified by the user.  These flags are inferred:fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE\n", StringFromIndex(columnmeta.Table), StringFromIndex(columnmeta.InternalName));
                        columnmeta.MetaFlags &= ~(fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM |
                                                    fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE);
                    }
                    columnmeta.MetaFlags |= OLEDataTypeToXMLDataType[iOLEDataTypeIndex].fCOLUMNMETA;

                    //There is one case where fCOLUMNMETA_FIXEDLENGTH cannot be determined by the type alone
                    if(columnmeta.Type == DBTYPE_BYTES && columnmeta.Size != -1)//Size == -1 implies NOT FIXEDLENGTH
                        columnmeta.MetaFlags |= fCOLUMNMETA_FIXEDLENGTH;
                    if(cFlagMeta>0)
                        columnmeta.MetaFlags |= fCOLUMNMETA_FLAG;
                    else if(cEnumMeta>0)
                        columnmeta.MetaFlags |= fCOLUMNMETA_ENUM;

                    columnmeta.MetaFlags = AddUI4ToList(columnmeta.MetaFlags);
            //DefaultValue needs to be filled in after MetaFlags, Type and Size and TagMeta
            //FlagMask          inferred later
            //StartingNumber
                    if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_MinimumValue, columnmeta.StartingNumber, false))
                        columnmeta.StartingNumber = AddUI4ToList(columnmeta.StartingNumber);
            //EndingNumber
                    if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_MaximumValue, columnmeta.EndingNumber, false))
                        columnmeta.EndingNumber = AddUI4ToList(columnmeta.EndingNumber);
            //CharacterSet
                    columnmeta.CharacterSet = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_CharacterSet);
            //SchemaGeneratorFlags
                    GetFlags(pNodeMap_ColumnMeta_AttributeMap, m_bstr_SchemaGenFlags, 0, columnmeta.SchemaGeneratorFlags);
                    if(columnmeta.SchemaGeneratorFlags & (fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED))
                    {
                        m_out.printf(L"Warning - Table (%s), Column (%s) - Some MetaFlagsEx should be inferred (resetting these flags).  The following flags should NOT be specified by the user.  These flags are inferred:fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED\n", StringFromIndex(columnmeta.Table), StringFromIndex(columnmeta.InternalName));
                        columnmeta.SchemaGeneratorFlags &= ~(fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED);
                    }
                    columnmeta.SchemaGeneratorFlags = AddUI4ToList(columnmeta.SchemaGeneratorFlags | OLEDataTypeToXMLDataType[iOLEDataTypeIndex].fCOLUMNSCHEMAGENERATOR);//Some types have inferred SchemaGeneratorFlags
            //ID
                    if(m_pxmlFile->GetNodeValue(pNodeMap_ColumnMeta_AttributeMap, m_bstr_ID, columnmeta.ID, false))
                        columnmeta.ID = AddUI4ToList(columnmeta.ID);//Convert to index into aUI4 pool
            //UserType
                    if(GetEnum(pNodeMap_ColumnMeta_AttributeMap, m_bstr_UserType, columnmeta.UserType, false))
                        columnmeta.UserType = AddUI4ToList(columnmeta.UserType);
            //Attributes
                    GetFlags(pNodeMap_ColumnMeta_AttributeMap, m_bstr_Attributes, 0, columnmeta.Attributes);
                    columnmeta.Attributes = AddUI4ToList(columnmeta.Attributes);
			//Description
                    columnmeta.Description = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_Description);
			//PublicColumnName
                    columnmeta.PublicColumnName = GetString_AndAddToWCharList(pNodeMap_ColumnMeta_AttributeMap, m_bstr_PublicColumnName);

            //ciTagMeta         inferred later
            //iTagMeta          inferred later
            //iIndexName        inferred later

                    if(cFlagMeta>0)
                    {   //Walk the children and build up a TagMeta table and get the FlagMask
                        FillInThePEFlagTagMeta(pNodeList_FlagMeta, Table, columnmeta.Index);
                    }
                    else if(cEnumMeta>0)
                    {   //Walk the children and build up a TagMeta table
                        FillInThePEEnumTagMeta(pNodeList_EnumMeta, Table, columnmeta.Index);
                    }
                    columnmeta.DefaultValue = GetDefaultValue(pNodeMap_ColumnMeta_AttributeMap, columnmeta);
                    if(-1 == iColumnMeta_First)
                        iColumnMeta_First = m_HeapColumnMeta.AddItemToHeap(columnmeta)/sizeof(ColumnMeta);
                    else
                        m_HeapColumnMeta.AddItemToHeap(columnmeta);
        }

        //Bump the Index
        Index++;
    }
    if(0 != cInheritanceWarnings)
    {
        m_out.printf(L"Warning! Table %s contained %d INHERITANCE WARNINGs on columns:\n%s\n", StringFromIndex(Table), cInheritanceWarnings, wstrIgnoredColumns.c_str());;
    }


    if(0 == Index)
    {
        m_out.printf(L"Warning! Table %s contains no %s elements.\n", StringFromIndex(Table), m_bstr_ColumnMeta);
    }
}

/*struct DatabaseMeta
{
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       BaseVersion;            //UI4
    ULONG                       ExtendedVersion;        //UI4
    ULONG                       CountOfTables;          //UI4       Count of tables in database
	ULONG						Description;			//String
	ULONG                       iSchemaBlob;            //Index into Bytes
    ULONG                       cbSchemaBlob;           //Count of Bytes of the SchemaBlob
    ULONG                       iNameHeapBlob;          //Index into Bytes
    ULONG                       cbNameHeapBlob;         //Count of Bytes of the SchemaBlob
    ULONG                       iTableMeta;             //Index into TableMeta
    ULONG                       iGuidDid;               //Index to aGuid where the guid is the Database InternalName cast as a GUID and padded with 0x00s.
};*/
void TComCatMetaXmlFile::FillInThePEDatabaseMeta()
{
    //Get All DatabaseMeta elements
    CComPtr<IXMLDOMNodeList>    pNodeList_DatabaseMeta;
    XIF(m_pXMLDoc->getElementsByTagName(m_bstr_DatabaseMeta, &pNodeList_DatabaseMeta));

    if(0 == pNodeList_DatabaseMeta.p)
    {
        m_out.printf(L"No Database Meta found.  Unable to proceed.\n");
        THROW(No Database Meta found.);
    }

    //Walk the list to the next Database
    while(true)
    {
        DatabaseMeta databasemeta;
        memset(&databasemeta, 0x00, sizeof(databasemeta));//Start with a NULL row

        //Get the next DatabaseMeta node
        CComPtr<IXMLDOMNode> pNode_DatabaseMeta;
        XIF(pNodeList_DatabaseMeta->nextNode(&pNode_DatabaseMeta));
        if(0 == pNode_DatabaseMeta.p)
            break;

        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap;
        XIF(pNode_DatabaseMeta->get_attributes(&pNodeMap));ASSERT(0 != pNodeMap.p);//The schema should prevent this.

//InternalName
        databasemeta.InternalName   = GetString_AndAddToWCharList(pNodeMap, m_bstr_InternalName, true);
//PublicName
        databasemeta.PublicName     = GetString_AndAddToWCharList(pNodeMap, m_bstr_PublicName);
//BaseVersion
        m_pxmlFile->GetNodeValue(pNodeMap, m_bstr_BaseVersion, databasemeta.BaseVersion, false);
        databasemeta.BaseVersion = AddUI4ToList(databasemeta.BaseVersion);//Convert to index into aUI4 pool
//ExtendedVersion
        m_pxmlFile->GetNodeValue(pNodeMap, m_bstr_ExtendedVersion, databasemeta.ExtendedVersion, false);
        databasemeta.ExtendedVersion = AddUI4ToList(databasemeta.ExtendedVersion);//Convert to index into aUI4 pool
//Description
		databasemeta.Description    = GetString_AndAddToWCharList(pNodeMap, m_bstr_Description, false);
//CountOfTables     inferred later
//iSchemaBlob       inferred later
//cbSchemaBlob      inferred later
//iNameHeapBlob     inferred later
//cbNameHeapBlob    inferred later
//iTableMeta        inferred later
//iGuidDid          inferred later


        //Default ServerWiringMeta for this Database
        CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_DatabaseMeta = pNode_DatabaseMeta;ASSERT(0 != pElement_DatabaseMeta.p);
        CComPtr<IXMLDOMNodeList> pNodeList_ServerWiring;

		// get all serverwiring elements that are defined at Database level. Use select
		// nodes to get the direct children and ignore all the grand-children.
        XIF(pElement_DatabaseMeta->selectNodes(m_bstr_ServerWiring, &pNodeList_ServerWiring));

        long cServerWiring=0;
        if(pNodeList_ServerWiring.p)
        {
            XIF(pNodeList_ServerWiring->get_length(&cServerWiring));//This gets all the descendants, but we only care about the first one.
        }

        if(0 == cServerWiring)
        {
            m_out.printf(L"Error in Database (%s) - At least one ServerWiring element must exist beneath each Database", StringFromIndex(databasemeta.InternalName));
            THROW(ERROR - No ServerWiring Found);
        }

		ServerWiringMeta *pDefaultServerWiring = new ServerWiringMeta[cServerWiring];
		if (pDefaultServerWiring == 0)
		{
			THROW(E_OUTOFMEMORY);
		}

		for (long iServerWiring=0; iServerWiring < cServerWiring; ++iServerWiring)
		{
			CComPtr<IXMLDOMNode> pNode_ServerWiring;
			XIF(pNodeList_ServerWiring->nextNode(&pNode_ServerWiring));

			FillInTheServerWiring(pNode_ServerWiring, 0, 0, pDefaultServerWiring[iServerWiring]);
		}

        FillInThePETableMeta(pNode_DatabaseMeta, databasemeta.InternalName, pDefaultServerWiring, cServerWiring);//WalkTheTableMeta returns the index to the first table. The count is
        m_HeapDatabaseMeta.AddItemToHeap(databasemeta);
    }
}

/*struct TagMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;              //Index into Pool
    ULONG PRIMARYKEY FOREIGNKEY ColumnIndex;        //This is the iOrder member of the ColumnMeta
    ULONG PRIMARYKEY            InternalName;       //Index into Pool
    ULONG                       PublicName;         //Index into Pool
    ULONG                       Value;
};*/
void TComCatMetaXmlFile::FillInThePEEnumTagMeta(IXMLDOMNodeList *pNodeList_TagMeta, unsigned long Table, unsigned long ColumnIndex)
{
    ASSERT(0 == Table%4);
    ASSERT(0 == ColumnIndex%4);

    long    cEnum;
    XIF(pNodeList_TagMeta->get_length(&cEnum));

    unsigned long NextValue = 0;
    while(cEnum--)
    {
        TagMeta tagmeta;
        memset(&tagmeta, 0x00, sizeof(tagmeta));

        CComPtr<IXMLDOMNode>    pNode_Enum;
        XIF(pNodeList_TagMeta->nextNode(&pNode_Enum));ASSERT(0 != pNode_Enum.p);

        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_Enum;
        XIF(pNode_Enum->get_attributes(&pNodeMap_Enum));ASSERT(0 != pNodeMap_Enum.p);//The schema should prevent this.

//Table
        tagmeta.Table = Table;
//ColumnIndex
        tagmeta.ColumnIndex = ColumnIndex;
//InternalName
        tagmeta.InternalName = GetString_AndAddToWCharList(pNodeMap_Enum, m_bstr_InternalName, true);
//PublicName
        tagmeta.PublicName = GetString_AndAddToWCharList(pNodeMap_Enum, m_bstr_PublicName);
//Value
        tagmeta.Value = NextValue;
        m_pxmlFile->GetNodeValue(pNodeMap_Enum, m_bstr_Value, tagmeta.Value, false);
        NextValue = tagmeta.Value+1;
        tagmeta.Value = AddUI4ToList(tagmeta.Value);
//ID
        m_pxmlFile->GetNodeValue(pNodeMap_Enum, m_bstr_ID, tagmeta.ID, false);
        tagmeta.ID = AddUI4ToList(tagmeta.ID);//Convert to index into aUI4 pool

        m_HeapTagMeta.AddItemToHeap(tagmeta);
    }
}

/*struct TagMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;              //Index into Pool
    ULONG PRIMARYKEY FOREIGNKEY ColumnIndex;        //This is the iOrder member of the ColumnMeta
    ULONG PRIMARYKEY            InternalName;       //Index into Pool
    ULONG                       PublicName;         //Index into Pool
    ULONG                       Value;
};*/
void TComCatMetaXmlFile::FillInThePEFlagTagMeta(IXMLDOMNodeList *pNodeList_TagMeta, unsigned long Table, unsigned long ColumnIndex)
{
    ASSERT(0 == Table%4);
    ASSERT(0 == ColumnIndex%4);

    long    cFlag;
    XIF(pNodeList_TagMeta->get_length(&cFlag));

    unsigned long NextValue = 1;
    while(cFlag--)
    {
        TagMeta tagmeta;
        memset(&tagmeta, 0x00, sizeof(tagmeta));

        CComPtr<IXMLDOMNode>    pNode_Flag;
        XIF(pNodeList_TagMeta->nextNode(&pNode_Flag));ASSERT(0 != pNode_Flag.p);

        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_Flag;
        XIF(pNode_Flag->get_attributes(&pNodeMap_Flag));ASSERT(0 != pNodeMap_Flag.p);//The schema should prevent this.

//Table
        tagmeta.Table = Table;
//ColumnIndex
        tagmeta.ColumnIndex = ColumnIndex;
//InternalName
        tagmeta.InternalName = GetString_AndAddToWCharList(pNodeMap_Flag, m_bstr_InternalName, true);
//PublicName
        tagmeta.PublicName = GetString_AndAddToWCharList(pNodeMap_Flag, m_bstr_PublicName);
//Value
        tagmeta.Value = NextValue;
        m_pxmlFile->GetNodeValue(pNodeMap_Flag, m_bstr_Value, tagmeta.Value, false);
        if(0 != (tagmeta.Value & (tagmeta.Value-1)))//This yields zero for all powers of two
            m_out.printf(L"WARNING! - Flag Value (0x%08x) is not a power of two.  Table (%s), Flag (%s)\n", tagmeta.Value, StringFromIndex(Table), StringFromIndex(tagmeta.InternalName));

        NextValue = tagmeta.Value<<1;
        if(0 == tagmeta.Value)//A flag value of zero is OK but it messes up our inferrence, so after a flag of value 0, the next flag is 1
            NextValue = 1;

        tagmeta.Value = AddUI4ToList(tagmeta.Value);
//ID
        m_pxmlFile->GetNodeValue(pNodeMap_Flag, m_bstr_ID, tagmeta.ID, false);
        tagmeta.ID = AddUI4ToList(tagmeta.ID);//Convert to index into aUI4 pool

        m_HeapTagMeta.AddItemToHeap(tagmeta);
    }
}

/*struct IndexMeta
{
    ULONG PRIMARYKEY    Table;                          //String
    ULONG PRIMARYKEY    InternalName;                   //String
    ULONG               PublicName;                     //String
    ULONG PRIMARYKEY    ColumnIndex;                    //UI4       This is the iOrder member of the ColumnMeta
    ULONG               ColumnInternalName;             //String
    ULONG               MetaFlags;                      //UI4       Index Flag
};*/
void TComCatMetaXmlFile::FillInThePEIndexMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table)
{
    ASSERT(0 == Table%4);

    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_TableMeta = pNode_TableMeta;ASSERT(0 != pElement_TableMeta.p);
    CComPtr<IXMLDOMNodeList>    pNodeList_IndexMeta;
    XIF(pElement_TableMeta->getElementsByTagName(m_bstr_IndexMeta, &pNodeList_IndexMeta));

    long cIndexMeta=0;
    if(pNodeList_IndexMeta.p)
    {
        XIF(pNodeList_IndexMeta->get_length(&cIndexMeta));
    }

    //Walk the IndexMeta for this table
    while(cIndexMeta--)
    {
        IndexMeta indexmeta;
        memset(&indexmeta, 0x00, sizeof(indexmeta));

        CComPtr<IXMLDOMNode>    pNode_IndexMeta;
        XIF(pNodeList_IndexMeta->nextNode(&pNode_IndexMeta));

        //Get the attribute map for this element
        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_IndexMetaAttributeMap;
        XIF(pNode_IndexMeta->get_attributes(&pNodeMap_IndexMetaAttributeMap));ASSERT(0 != pNodeMap_IndexMetaAttributeMap.p);//The schema should prevent this.

//Table
        indexmeta.Table = Table;
//InternalName
        indexmeta.InternalName = GetString_AndAddToWCharList(pNodeMap_IndexMetaAttributeMap, m_bstr_InternalName, true);
//PublicName
        indexmeta.PublicName = GetString_AndAddToWCharList(pNodeMap_IndexMetaAttributeMap, m_bstr_PublicName);
//ColumnIndex           Filled in below
//ColumnInternalName    Filled in below
//MetaFlags
        GetFlags(pNodeMap_IndexMetaAttributeMap, m_bstr_MetaFlags, 0, indexmeta.MetaFlags);
        indexmeta.MetaFlags = AddUI4ToList(indexmeta.MetaFlags);

        CComVariant     varColumnInternalNames;
        m_pxmlFile->GetNodeValue(pNodeMap_IndexMetaAttributeMap, m_bstr_ColumnInternalName, varColumnInternalNames);

        wchar_t * pszColumnInternalName = wcstok(varColumnInternalNames.bstrVal, L" ");
        while(pszColumnInternalName != 0)
        {
//ColumnInternalName
            indexmeta.ColumnInternalName = AddWCharToList(pszColumnInternalName);
            ULONG iColumnMeta = FindColumnBy_Table_And_InternalName(Table, indexmeta.ColumnInternalName);
            if(-1 == iColumnMeta)
            {
                m_out.printf(L"IndexMeta Error - ColumnInternalName (%s) not found in table.\n", StringFromIndex(Table));
                THROW(ERROR IN INDEXMETA - INVALID INTERNALCOLNAME);
            }

//ColumnIndex
            indexmeta.ColumnIndex = ColumnMetaFromIndex(iColumnMeta)->Index;
            m_HeapIndexMeta.AddItemToHeap(indexmeta);

            pszColumnInternalName = wcstok(0, L" ");//Next token (next Flag RefID)
        }
    }
}

/*struct QueryMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Index;                  //UI4
    ULONG                       CellName;               //String
    ULONG                       Operator;               //UI4
    ULONG                       MetaFlags;              //UI4
};*/
void TComCatMetaXmlFile::FillInThePEQueryMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table)
{
    ASSERT(0 == Table%4);

    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_TableMeta = pNode_TableMeta;ASSERT(0 != pElement_TableMeta.p);
    CComPtr<IXMLDOMNodeList>    pNodeList_QueryMeta;
    XIF(pElement_TableMeta->getElementsByTagName(m_bstr_QueryMeta, &pNodeList_QueryMeta));

    long cQueryMeta=0;
    if(pNodeList_QueryMeta)
    {
        XIF(pNodeList_QueryMeta->get_length(&cQueryMeta));
    }

    ULONG PrevInternalName=(ULONG)-1;
    ULONG Index=0;
    while(cQueryMeta--)
    {
        QueryMeta querymeta;
        memset(&querymeta, 0x00, sizeof(querymeta));

        CComPtr<IXMLDOMNode>    pNode_QueryMeta;
        XIF(pNodeList_QueryMeta->nextNode(&pNode_QueryMeta));

        //Get the attribute map for this element
        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_QueryMetaAttributeMap;
        XIF(pNode_QueryMeta->get_attributes(&pNodeMap_QueryMetaAttributeMap));ASSERT(0 != pNodeMap_QueryMetaAttributeMap.p);//The schema should prevent this.

//Table
        querymeta.Table = Table;
//InternalName
        querymeta.InternalName = GetString_AndAddToWCharList(pNodeMap_QueryMetaAttributeMap, m_bstr_InternalName, true);
//PublicName
        querymeta.PublicName = GetString_AndAddToWCharList(pNodeMap_QueryMetaAttributeMap, m_bstr_PublicName);
//Index     Filled in below
//CellName
        querymeta.CellName = GetString_AndAddToWCharList(pNodeMap_QueryMetaAttributeMap, m_bstr_CellName, false);
//Operator
        GetEnum(pNodeMap_QueryMetaAttributeMap, m_bstr_Operator, querymeta.Operator, false);
        querymeta.Operator = AddUI4ToList(querymeta.Operator);//convert to index into the pool
//MetaFlags
        GetFlags(pNodeMap_QueryMetaAttributeMap, m_bstr_MetaFlags, 0, querymeta.MetaFlags);
        querymeta.MetaFlags = AddUI4ToList(querymeta.MetaFlags);//convert to index into pool

//Index
        Index = (querymeta.CellName == PrevInternalName) ? Index+1 : 0;
        querymeta.Index = AddUI4ToList(Index);

        m_HeapQueryMeta.AddItemToHeap(querymeta);

        PrevInternalName = querymeta.InternalName;//Remember the InternalName so we can bump the index
    }
}

/*struct RelationMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY PrimaryTable;           //String
    ULONG                       PrimaryColumns;         //Bytes
    ULONG PRIMARYKEY FOREIGNKEY ForeignTable;           //String
    ULONG                       ForeignColumns;         //Bytes
    ULONG                       MetaFlags;
};*/
void TComCatMetaXmlFile::FillInThePERelationMeta()
{
    //Get All RelationMeta elements
    CComPtr<IXMLDOMNodeList>    pNodeList_RelationMeta;
    XIF(m_pXMLDoc->getElementsByTagName(m_bstr_RelationMeta, &pNodeList_RelationMeta));

    long cRelations=0;
    if(pNodeList_RelationMeta.p)
    {
        XIF(pNodeList_RelationMeta->get_length(&cRelations));
    }
    if(0 == cRelations)
        return;

    m_out.printf(L"Filling in RelationMeta\n");
    //Walk the list to the next RelationMeta
    while(cRelations--)
    {
        RelationMeta relationmeta;

        //Get the next DatabaseMeta node
        CComPtr<IXMLDOMNode> pNode_RelationMeta;
        XIF(pNodeList_RelationMeta->nextNode(&pNode_RelationMeta));
        ASSERT(0 != pNode_RelationMeta.p);

        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_RelationMetaAttributeMap;
        XIF(pNode_RelationMeta->get_attributes(&pNodeMap_RelationMetaAttributeMap));ASSERT(0 != pNodeMap_RelationMetaAttributeMap.p);//The schema should prevent this.

//PrimaryTable
        relationmeta.PrimaryTable = GetString_AndAddToWCharList(pNodeMap_RelationMetaAttributeMap, m_bstr_PrimaryTable, true);
//PrimaryColumns
        CComVariant     varPrimaryColumns;
        m_pxmlFile->GetNodeValue(pNodeMap_RelationMetaAttributeMap, m_bstr_PrimaryColumns, varPrimaryColumns, true);
        relationmeta.PrimaryColumns = AddArrayOfColumnsToBytePool(relationmeta.PrimaryTable, varPrimaryColumns.bstrVal);
//ForeignTable
        relationmeta.ForeignTable = GetString_AndAddToWCharList(pNodeMap_RelationMetaAttributeMap, m_bstr_ForeignTable, true);
//ForeignColumns
        CComVariant     varForeignColumns;
        m_pxmlFile->GetNodeValue(pNodeMap_RelationMetaAttributeMap, m_bstr_ForeignColumns, varForeignColumns, true);
        relationmeta.ForeignColumns = AddArrayOfColumnsToBytePool(relationmeta.ForeignTable, varForeignColumns.bstrVal);
//MetaFlags
        GetFlags(pNodeMap_RelationMetaAttributeMap, m_bstr_MetaFlags, 0, relationmeta.MetaFlags);
        relationmeta.MetaFlags = AddUI4ToList(relationmeta.MetaFlags);

        m_HeapRelationMeta.AddItemToHeap(relationmeta);
    }
}

void TComCatMetaXmlFile::FillInThePEServerWiringMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table, ServerWiringMeta *pDefaultServerWiring, ULONG cNrDefaultServerWiring)
{
    //Get the list of ServerWiringMeta children
    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_TableMeta = pNode_TableMeta;ASSERT(0 != pElement_TableMeta.p);
    CComPtr<IXMLDOMNodeList> pNodeList_ServerWiring;
    XIF(pElement_TableMeta->getElementsByTagName(m_bstr_ServerWiring, &pNodeList_ServerWiring));

    ULONG   cServerWiring=0;
    if(pNodeList_ServerWiring.p)
    {
        XIF(pNodeList_ServerWiring->get_length(reinterpret_cast<long *>(&cServerWiring)));
    }

    if(0 == cServerWiring)//If none specified then use the DefaultServerWiring
    {
		for (ULONG iServerWiring=0; iServerWiring<cNrDefaultServerWiring; ++iServerWiring)
		{
			ServerWiringMeta serverwiring;
			memcpy(&serverwiring, pDefaultServerWiring + iServerWiring, sizeof(serverwiring));
			serverwiring.Table = Table;
			m_HeapServerWiringMeta.AddItemToHeap(serverwiring);
		}
    }
    else//otherwise walk the list of ServerWiring and add them to the heap
    {
        for(ULONG iServerWiring=0; iServerWiring<cServerWiring; ++iServerWiring)
        {
            CComPtr<IXMLDOMNode> pNode_ServerWiring;
            XIF(pNodeList_ServerWiring->nextNode(&pNode_ServerWiring));

            ServerWiringMeta serverwiring;
            FillInTheServerWiring(pNode_ServerWiring, Table, iServerWiring, serverwiring);
            m_HeapServerWiringMeta.AddItemToHeap(reinterpret_cast<const unsigned char *>(&serverwiring), sizeof(serverwiring));
        }
    }
}

/*struct TableMeta
{
    ULONG FOREIGNKEY            Database;               //String
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       PublicRowName;          //String
    ULONG                       BaseVersion;            //UI4
    ULONG                       ExtendedVersion;        //UI4
    ULONG                       NameColumn;             //UI4       iOrder of the NameColumn
    ULONG                       NavColumn;              //UI4       iOrder of the NavColumn
    ULONG                       CountOfColumns;         //UI4       Count of Columns
    ULONG                       MetaFlags;              //UI4       TableMetaFlags are defined in CatInpro.meta
    ULONG                       SchemaGeneratorFlags;   //UI4       SchemaGenFlags are defined in CatInpro.meta
    ULONG                       ConfigItemName;         //String
    ULONG                       ConfigCollectionName;   //String
	ULONG						Description				//String
    ULONG                       PublicRowNameColumn;    //UI4       If PublicRowName is NULL, this specifies the column whose enum values represent possible PublicRowNames
    ULONG                       ciRows;                 //Count of Rows in the Fixed Table (which if the fixed table is meta, this is also the number of columns in the table that the meta describes).
    ULONG                       iColumnMeta;            //Index into ColumnMeta
    ULONG                       iFixedTable;            //Index into g_aFixedTable
    ULONG                       cPrivateColumns;        //This is the munber of private columns (private + ciColumns = totalColumns), this is needed for fixed table pointer arithmetic
    ULONG                       cIndexMeta;             //The number of IndexMeta entries in this table
    ULONG                       iIndexMeta;             //Index into IndexMeta
    ULONG                       iHashTableHeader;       //If the table is a fixed table, then it will have a hash table.
    ULONG                       nTableID;               //This is a 24 bit Hash of the Table name.
    ULONG                       iServerWiring;          //Index into the ServerWiringHeap (this is a temporary hack for CatUtil)
    ULONG                       cServerWiring;          //Count of ServerWiring (this is a temporary hack for CatUtil)
};
*/
void TComCatMetaXmlFile::FillInThePETableMeta(IXMLDOMNode *pNode_DatabaseMeta,
											  unsigned long Database,
											  ServerWiringMeta *pDefaultServerWiring,
											  ULONG cNrDefaultServerWiring)
{
    //Get All TableMeta elements under the Database node
    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_DatabaseMeta = pNode_DatabaseMeta;ASSERT(0 != pElement_DatabaseMeta.p);
    CComPtr<IXMLDOMNodeList> pNodeList_TableMeta;
    XIF(pElement_DatabaseMeta->getElementsByTagName(m_bstr_TableMeta, &pNodeList_TableMeta));

    if(0 == pNodeList_TableMeta.p)
        return;

    long cTableMeta;
    XIF(pNodeList_TableMeta->get_length(&cTableMeta));

    //Walk the list to the next sibling that is a ColumnMeta element
    while(cTableMeta--)
    {
        TableMeta tablemeta;
        memset(&tablemeta, 0x00, sizeof(tablemeta));

        CComPtr<IXMLDOMNode> pNode_TableMeta;
        XIF(pNodeList_TableMeta->nextNode(&pNode_TableMeta));
        ASSERT(0 != pNode_TableMeta.p);

        //Get the attribute map for this element
        CComPtr<IXMLDOMNamedNodeMap>    pNodeMap_TableMetaAttributeMap;
        XIF(pNode_TableMeta->get_attributes(&pNodeMap_TableMetaAttributeMap));ASSERT(0 != pNodeMap_TableMetaAttributeMap.p);//The schema should prevent this.

//Database
        tablemeta.Database = Database;
//InternalName
        tablemeta.InternalName = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_InternalName, true);
//PublicName
        tablemeta.PublicName = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_PublicName);
//PublicRowName
        tablemeta.PublicRowName = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_PublicRowName);
//BaseVersion
        m_pxmlFile->GetNodeValue(pNodeMap_TableMetaAttributeMap, m_bstr_BaseVersion, tablemeta.BaseVersion, false);
        tablemeta.BaseVersion = AddUI4ToList(tablemeta.BaseVersion);//convert to index to UI4 pool
//ExtendedVersion
        m_pxmlFile->GetNodeValue(pNodeMap_TableMetaAttributeMap, m_bstr_ExtendedVersion, tablemeta.ExtendedVersion, false);
        tablemeta.ExtendedVersion = AddUI4ToList(tablemeta.ExtendedVersion);//convert to index to UI4 pool
//NameColumn    inferred later
//NavColumn     inferred later
//CountOfColumn inferred later
//MetaFlags
        GetFlags(pNodeMap_TableMetaAttributeMap, m_bstr_TableMetaFlags, 0, tablemeta.MetaFlags);
        tablemeta.MetaFlags = AddUI4ToList(tablemeta.MetaFlags);
//SchemaGeneratorFlags
        GetFlags(pNodeMap_TableMetaAttributeMap, m_bstr_SchemaGenFlags, 0, tablemeta.SchemaGeneratorFlags);
        if(tablemeta.SchemaGeneratorFlags & (fTABLEMETA_ISCONTAINED | fTABLEMETA_EXTENDED | fTABLEMETA_USERDEFINED))
        {
            m_out.printf(L"Warning - Table (%s) - Some TableMeta::MetaFlagsEx should be inferred (resetting these flags).  The following flags should NOT be specified by the user.  These flags are inferred:fTABLEMETA_ISCONTAINED | fTABLEMETA_EXTENDED | fTABLEMETA_USERDEFINED\n", StringFromIndex(tablemeta.InternalName));
            tablemeta.SchemaGeneratorFlags &= ~(fTABLEMETA_ISCONTAINED | fTABLEMETA_EXTENDED | fTABLEMETA_USERDEFINED);
        }
        tablemeta.SchemaGeneratorFlags = AddUI4ToList(tablemeta.SchemaGeneratorFlags);
//ConfigItemName
        tablemeta.ConfigItemName = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_ConfigItemName);
//ConfigCollectionName
        tablemeta.ConfigCollectionName = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_ConfigCollectionName);
//PublicRowNameColumn inferred later
//ContainerClassList
        tablemeta.ContainerClassList = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_ContainerClassList);
//Description
		tablemeta.Description = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_Description);
//ChildElementName
		tablemeta.ChildElementName = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_ChildElementName);

        //This allows us to specify the ColumnMeta for one table and inherit all the properties without specifying them in another.
        ULONG ParentTableMeta = GetString_AndAddToWCharList(pNodeMap_TableMetaAttributeMap, m_bstr_InheritsColumnMeta);

        FillInThePEColumnMeta(pNode_TableMeta, tablemeta.InternalName, ParentTableMeta);
        FillInThePEIndexMeta(pNode_TableMeta, tablemeta.InternalName);
        FillInThePEQueryMeta(pNode_TableMeta, tablemeta.InternalName);
        FillInThePEServerWiringMeta(pNode_TableMeta, tablemeta.InternalName, pDefaultServerWiring, cNrDefaultServerWiring);

        m_HeapTableMeta.AddItemToHeap(tablemeta);
    }
}

/*struct ServerWiringMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            Order;                  //UI4
    ULONG                       ReadPlugin;             //UI4
	ULONG						ReadPluginDLLName;      //String
    ULONG                       WritePlugin;            //UI4
	ULONG						WritePluginDLLName;		//String
    ULONG                       Interceptor;            //UI4
    ULONG                       InterceptorDLLName;     //String
    ULONG                       Flags;                  //UI4       Last, NoNext, First, Next
    ULONG                       Locator;                //String
    ULONG                       Reserved;               //UI4       for Protocol.  Protocol may be needed for managed property support
    ULONG                       Merger;                 //UI4
    ULONG                       MergerDLLName;          //String
};*/
void TComCatMetaXmlFile::FillInTheServerWiring(IXMLDOMNode *pNode_ServerWiring, ULONG Table, ULONG Order, TableSchema::ServerWiringMeta &serverwiring)
{
    memset(&serverwiring, 0x00, sizeof(serverwiring));

    CComPtr<IXMLDOMNamedNodeMap> pNodeMap_ServerWiring;
    XIF(pNode_ServerWiring->get_attributes(&pNodeMap_ServerWiring));ASSERT(0 != pNodeMap_ServerWiring.p);//The schema should prevent this.

//Table
    serverwiring.Table = Table;
//Order
    serverwiring.Order = AddUI4ToList(Order);
//ReadPlugin
    GetEnum(pNodeMap_ServerWiring, m_bstr_ReadPlugin,  serverwiring.ReadPlugin);//This will set the ReadPlugin to zero if it's not specified
    serverwiring.ReadPlugin = AddUI4ToList(serverwiring.ReadPlugin);
//ReadPluginDLLName
    serverwiring.ReadPluginDLLName = GetString_AndAddToWCharList(pNodeMap_ServerWiring, m_bstr_ReadPluginDLLName);
//WritePlugin
    GetEnum(pNodeMap_ServerWiring, m_bstr_WritePlugin, serverwiring.WritePlugin);//This will set the WritePlugin to zero if it's not specified
    serverwiring.WritePlugin = AddUI4ToList(serverwiring.WritePlugin);
//WritePluginDLLName
    serverwiring.WritePluginDLLName = GetString_AndAddToWCharList(pNodeMap_ServerWiring, m_bstr_WritePluginDLLName);
//Interceptor
    GetEnum(pNodeMap_ServerWiring, m_bstr_Interceptor, serverwiring.Interceptor);//This will set the Interceptor to zero if it's not specified
    serverwiring.Interceptor = AddUI4ToList(serverwiring.Interceptor);
//InterceptorDLLName
    serverwiring.InterceptorDLLName = GetString_AndAddToWCharList(pNodeMap_ServerWiring, m_bstr_InterceptorDLLName);
//Flags
    GetFlags(pNodeMap_ServerWiring, m_bstr_MetaFlags, 0, serverwiring.Flags);
    serverwiring.Flags = AddUI4ToList(serverwiring.Flags);
//Locator
    serverwiring.Locator = GetString_AndAddToWCharList(pNodeMap_ServerWiring, m_bstr_Locator);
//Reserved
//Merger
    GetEnum(pNodeMap_ServerWiring, m_bstr_Merger, serverwiring.Merger);//This will set the WritePlugin to zero if it's not specified
    serverwiring.Merger= AddUI4ToList(serverwiring.Merger);
//Interceptor
    serverwiring.MergerDLLName = GetString_AndAddToWCharList(pNodeMap_ServerWiring, m_bstr_MergerDLLName);
}


void TComCatMetaXmlFile::Get_OLEDataTypeToXMLDataType_Index(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, int &i) const
{
    CComVariant     var_dbType;
    m_pxmlFile->GetNodeValue(pMap, bstr, var_dbType);

    for(i=0;i<numelementsOLEDataTypeToXMLDataType;i++)//Walk the list to find the
        if(0 == _wcsicmp(OLEDataTypeToXMLDataType[i].String, var_dbType.bstrVal))
            return;

    m_out.printf(L"Error - Unknown Datatype: %s\n", var_dbType.bstrVal);
    THROW(ERROR - UNKNOWN DATATYPE);
}


unsigned long TComCatMetaXmlFile::GetDefaultValue(IXMLDOMNamedNodeMap *pMap, ColumnMeta &columnMeta, bool bDefaultFlagToZero)
{
    CComVariant     varDafaultValue;
    if(!m_pxmlFile->GetNodeValue(pMap, m_bstr_DefaultValue, varDafaultValue, false))
    {
        if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FLAG && bDefaultFlagToZero)
        {
            unsigned long x = 0;
            return AddBytesToList(reinterpret_cast<unsigned char *>(&x), sizeof(ULONG));//infer a default value of 0 for flags.
        }
        return 0;
    }

    switch(UI4FromIndex(columnMeta.Type))
    {
    case DBTYPE_GUID:
        {
            GUID guid;
            if(FAILED(UuidFromString(varDafaultValue.bstrVal, &guid)))
            {
                m_out.printf(L"Error in DefaultValue:  Value (%s) was expected to be type UUID.\n", varDafaultValue.bstrVal);
                THROW(ERROR IN DEFAULT VALUE);
            }
            return AddBytesToList(reinterpret_cast<unsigned char *>(&guid), sizeof(GUID));
        }
    case DBTYPE_WSTR:
        if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_MULTISTRING)
        {
            ULONG ulStrLen = lstrlen(varDafaultValue.bstrVal);
            if((ulStrLen+2)*sizeof(WCHAR) > UI4FromIndex(columnMeta.Size))
            {
                m_out.printf(L"Error in DefaultValue: DefaultValue (%s) is too big.  Maximum size is %d.\n",varDafaultValue.bstrVal, UI4FromIndex(columnMeta.Size));
                THROW(ERROR DEFAULT VALUE TOO BIG);
            }
            if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH)
            {
                m_out.printf(L"Error in DefaultValue - 'Defaulting a FIXEDLENGTH - MULTISTRING is not yet supported");
                THROW(ERROR NOT SUPPORTED);
            }
            if(0==ulStrLen)
            {
                WCHAR  wszDoubleNULL[2];
                wszDoubleNULL[0] = 0x00;
                wszDoubleNULL[1] = 0x00;
                return AddBytesToList(reinterpret_cast<unsigned char *>(wszDoubleNULL), 2 * sizeof(WCHAR));
            }

            LPWSTR pMultiString = new WCHAR [ulStrLen+2];
            if(0 == pMultiString)
            {
                THROW(ERROR - OUT OF MEMORY);
            }
            pMultiString[0] = 0x00;

            LPWSTR token = wcstok(varDafaultValue.bstrVal, L"|\r\n");
            ULONG cchMultiString = 0;
            while(token)
            {
                LPWSTR wszTemp = token;
                while(*wszTemp==L' ' || *wszTemp==L'\t' || *wszTemp==L'\r')//ignore leading spaces and tabs
                {
                    wszTemp++;
                }
                if(0 == *wszTemp)//and if only tabs and spaces exist then bail
                    break;

				ULONG iLen = (ULONG) wcslen (wszTemp);
				while (iLen > 0 && (wszTemp[iLen-1]==L' ' || wszTemp[iLen-1]==L'\t' || wszTemp[iLen-1]==L'\r'))//ignore trailing spaces and tabs
					iLen--;

                wcsncpy(pMultiString + cchMultiString, wszTemp, iLen);
				pMultiString[cchMultiString + iLen] = L'\0';
                cchMultiString += (iLen + 1);

                token = wcstok(0, L"|\r\n");//ignore spaces and tabs
            }
            pMultiString[cchMultiString++] = 0x00;//put the second NULL
            unsigned long lRtn = AddBytesToList(reinterpret_cast<unsigned char *>(pMultiString), cchMultiString * sizeof(WCHAR));
            delete [] pMultiString;
            return lRtn;//return the index past the size
        }
        if((UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) && (lstrlen(varDafaultValue.bstrVal)+1)*sizeof(WCHAR) > UI4FromIndex(columnMeta.Size))
        {
            m_out.printf(L"Error in DefaultValue: DefaultValue (%s) is too big.  Maximum size is %d.\n",varDafaultValue.bstrVal, UI4FromIndex(columnMeta.Size));
            THROW(ERROR DEFAULT VALUE TOO BIG);
        }
        if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH)
        {
            ULONG cbSize = (ULONG)((-1==UI4FromIndex(columnMeta.Size) ? sizeof(WCHAR)*(wcslen(varDafaultValue.bstrVal)+1) : UI4FromIndex(columnMeta.Size)));
            WCHAR * wszTemp = new WCHAR [cbSize/sizeof(WCHAR)];
            if(0 == wszTemp)
                THROW(ERROR - OUT OF MEMORY);
            memset(wszTemp, 0x00, cbSize);
            wcscpy(wszTemp, varDafaultValue.bstrVal);
            return AddBytesToList(reinterpret_cast<unsigned char *>(wszTemp), cbSize);
        }
        return AddBytesToList(reinterpret_cast<unsigned char *>(varDafaultValue.bstrVal), sizeof(WCHAR)*(wcslen(varDafaultValue.bstrVal)+1));
    case DBTYPE_UI4:
        ULONG ui4;
        if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_BOOL)
        {
            static WCHAR * kwszBoolStrings[] = {L"false", L"true", L"0", L"1", L"no", L"yes", L"off", L"on", 0};

            if(varDafaultValue.bstrVal[0]>=L'0' && varDafaultValue.bstrVal[0]<=L'9')
            {   //Accept a numeric value for bool
                ui4 = _wtol(varDafaultValue.bstrVal);
                if(ui4 > 1)//print a warning if the numeric is not 0 or 1.
                    m_out.printf(L"Warning!  Table (%s), Numeric DefaultValue (%u) specified - expecting bool.\r\n", StringFromIndex(columnMeta.InternalName), ui4);
            }
            else
            {
                unsigned long iBoolString;
                for(iBoolString=0; kwszBoolStrings[iBoolString] &&
                    (0 != _wcsicmp(kwszBoolStrings[iBoolString], varDafaultValue.bstrVal)); ++iBoolString);

                if(0 == kwszBoolStrings[iBoolString])
                {
                    m_out.printf(L"Error in DefaultValue: Bool (%s) is not a valid value for column %s.\n    The following are the only legal Bool values (case insensitive):\n    false, true, 0, 1, no, yes, off, on.\n", varDafaultValue.bstrVal, StringFromIndex(columnMeta.InternalName));
                    THROW(ERROR - INVALID BOOL FOR DEFAULT VALUE);
                }

                ui4 = (iBoolString & 0x01);
            }
        }
        else if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_ENUM)//if enum, just scan the TagMeta for the matching InternalName, and return the value of the Tag
        {
            ui4 = 0;
            bool bFound=false;
            ULONG iTagMeta;
            for(iTagMeta = GetCountTagMeta()-1; iTagMeta != -1 && (TagMetaFromIndex(iTagMeta)->Table == columnMeta.Table);--iTagMeta)
            {
                if((TagMetaFromIndex(iTagMeta)->ColumnIndex == columnMeta.Index) &&
                    0 == lstrcmpi(varDafaultValue.bstrVal, StringFromIndex(TagMetaFromIndex(iTagMeta)->InternalName)))
                {
                    ui4 = UI4FromIndex(TagMetaFromIndex(iTagMeta)->Value);
                    bFound=true;
                    break;
                }
            }
            if(!bFound)
            {
                m_out.printf(L"Error in DefaultValue: Enum (%s) is not a valid Tag for column %s.\n", varDafaultValue.bstrVal, StringFromIndex(columnMeta.InternalName));
                THROW(ERROR - INVALID ENUM FOR DEFAULT VALUE);
            }
        }
        else if(UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FLAG)//if flag, walk the list of flags, find the matching Tag and OR in its value.
        {
            ui4 = 0;
            LPWSTR token = wcstok(varDafaultValue.bstrVal, L" ,|");

            //We allow defaults to specify a numeric instead of strings
            if(token && *token>=L'0' && *token<=L'9')
            {
                ui4 = _wtol(token);
                m_out.printf(L"Warning!  Table (%s), Numeric DefaultValue (%u) specified - expecting flags.\r\n", StringFromIndex(columnMeta.InternalName), ui4);
            }
            else
            {
                while(token)
                {
                    bool bFound=false;
                    ULONG iTagMeta;
                    for(iTagMeta = GetCountTagMeta()-1; iTagMeta != -1 && (TagMetaFromIndex(iTagMeta)->Table == columnMeta.Table);--iTagMeta)
                    {
                        if(TagMetaFromIndex(iTagMeta)->ColumnIndex == columnMeta.Index &&
                            0 == lstrcmpi(token, StringFromIndex(TagMetaFromIndex(iTagMeta)->InternalName)))
                        {
                            bFound=true;
                            break;
                        }
                    }
                    if(!bFound)
                    {
                        m_out.printf(L"Error in DefaultValue: Flag (%s) is not a valid Tag for column %s.\n", token, StringFromIndex(columnMeta.InternalName));
                        THROW(ERROR - INVALID FLAG FOR DEFAULT VALUE);
                    }
                    ui4 |= UI4FromIndex(TagMetaFromIndex(iTagMeta)->Value);
                    token = wcstok(0, L" ,|");
                }
            }
        }
        else if(*varDafaultValue.bstrVal == L'-' || (*varDafaultValue.bstrVal >= L'0' && *varDafaultValue.bstrVal <= L'9'))
        {
            ui4 = _wtol(varDafaultValue.bstrVal);
        }
        else
        {
            m_out.printf(L"Error in DefaultValue:  Only UI4s of type Enum or Flag may specify non numeric values for DefaultValue.  %s is illegal.\n", varDafaultValue.bstrVal);
            THROW(ERROR - ILLEGAL DEFAULT VALUE);
        }
        return AddBytesToList(reinterpret_cast<unsigned char *>(&ui4), sizeof(ULONG));
    case DBTYPE_BYTES:
        {
            unsigned long   cbString = lstrlen(varDafaultValue.bstrVal)/2;
            unsigned long   cbArray = (UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) ? UI4FromIndex(columnMeta.Size) : cbString;
            if(cbString != cbArray)
            {
                m_out.printf(L"WARNING!  DefaultValue (%s) does not match Size (%d).  Filling remainder of byte array with zeroes.\n", varDafaultValue.bstrVal, UI4FromIndex(columnMeta.Size));
            }

            unsigned char * byArray = new unsigned char [cbArray];
            if((UI4FromIndex(columnMeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) && cbArray > UI4FromIndex(columnMeta.Size))
            {
                m_out.printf(L"Error in DefaultValue: DefaultValue (%s) is too big.  Maximum size is %d.\n",varDafaultValue.bstrVal, UI4FromIndex(columnMeta.Size));
                THROW(ERROR DEFAULT VALUE TOO BIG);
            }

            if(0 == byArray)
            {
                m_out.printf(L"Error - Out of memory.\n");
                THROW(OUT OF MEMORY);
            }
            if(cbArray > cbString)
                memset(byArray, 0x00, cbArray);
            //Convert the string into a byte array
            m_pxmlFile->ConvertWideCharsToBytes(varDafaultValue.bstrVal, byArray, cbString);
            unsigned long lRtn = AddBytesToList(byArray, cbArray);//AddBytesToList just slams the bytes into the pool (prepending the length) and returns the index to bytes
            delete [] byArray;
            return lRtn;//return the index past the size
        }
    default:
        ASSERT(false && L"Bad Type");
    }
    return S_OK;

}


bool TComCatMetaXmlFile::GetEnum(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, unsigned long &Enum, bool bMustExists) const
{
    Enum = 0;

    CComVariant     var;
    if(!m_pxmlFile->GetNodeValue(pMap, bstr, var, bMustExists))//get the string of the enum
        return false;

    CComPtr<IXMLDOMNodeList>    pNodeList;
    XIF(m_pXMLDocMetaMeta->getElementsByTagName(m_bstr_EnumMeta, &pNodeList));//get all of the EnumMeta elements

    long cEnums=0;
    if(pNodeList.p)
    {
        XIF(pNodeList->get_length(&cEnums));
    }

    for(long i=0; i<cEnums; ++i)
    {
        CComPtr<IXMLDOMNode>    pNodeEnum;
        XIF(pNodeList->nextNode(&pNodeEnum));

        CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement = pNodeEnum;ASSERT(0 != pElement.p);//Get the IXMLDOMElement interface pointer

        CComVariant             var_Name;
        XIF(pElement->getAttribute(m_bstr_InternalName, &var_Name));

        if(0 == lstrcmpi(var_Name.bstrVal, var.bstrVal))//if we found a matching enum
        {
            CComVariant             var_Value;
            XIF(pElement->getAttribute(m_bstr_Value, &var_Value));
            Enum = wcstol(var_Value.bstrVal, 0, 10);
            return true;
        }
    }

    if(i == cEnums)
    {
        m_out.printf(L"Error - Unknown enum (%s) specified.\n", var.bstrVal);
        THROW(ERROR - UNKNOWN FLAG);
    }

    return false;
}


void TComCatMetaXmlFile::GetFlags(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, LPCWSTR /*Flag Type Not Used*/, unsigned long &lFlags) const
{
    lFlags = 0;//start off with lFlags at zero

    CComVariant     var;
    if(!m_pxmlFile->GetNodeValue(pMap, bstr, var, false))
        return;

    CComPtr<IXMLDOMNodeList>    pNodeList;
    XIF(m_pXMLDocMetaMeta->getElementsByTagName(m_bstr_FlagMeta, &pNodeList));

    long cFlags=0;
    if(pNodeList.p)
    {
        XIF(pNodeList->get_length(&cFlags));
    }

    wchar_t *       pszFlag;
    pszFlag = wcstok(var.bstrVal, L" |,");
    while(pszFlag != 0)
    {
        XIF(pNodeList->reset());

        for(long i=0; i<cFlags; ++i)
        {
            CComPtr<IXMLDOMNode>    pNodeFlag;
            XIF(pNodeList->nextNode(&pNodeFlag));

            CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement = pNodeFlag;ASSERT(0 != pElement.p);//Get the IXMLDOMElement interface pointer

            CComVariant             var_Name;
            XIF(pElement->getAttribute(m_bstr_InternalName, &var_Name));

            if(0 == lstrcmpi(var_Name.bstrVal, pszFlag))//if we found a matching flag
            {
                CComVariant             var_Value;
                XIF(pElement->getAttribute(m_bstr_Value, &var_Value));
                lFlags |= wcstol(var_Value.bstrVal, 0, 10);
                break;
            }
        }

        if(i == cFlags)
        {
            m_out.printf(L"Error - Unknown flag (%s) specified.\n", pszFlag);
            THROW(ERROR - UNKNOWN FLAG);
        }
        pszFlag = wcstok(0, L" ,|");//Next token (next Flag RefID)
    }
}


unsigned long TComCatMetaXmlFile::GetString_AndAddToWCharList(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, bool bMustExist)
{
    CComVariant var_string;
    if(!m_pxmlFile->GetNodeValue(pMap, bstr, var_string, bMustExist))//if it must exist and doesn't an exception will be thrown
        return 0;                                        //if it doesn't have to exist AND the attribute doesn't exist then return 0 (which indicates 0 length string)
    return AddWCharToList(var_string.bstrVal);           //if it does exist then add it to the list of WChars
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tfixupdll.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

const FixedTableHeap * TCatalogDLL::LocateTableSchemaHeap(TOutput &out)
{
    if(0 == m_iOffsetOfFixedTableHeap)//If we haven't already gotten the pointer, then load the DLL and find it
    {
        if(0 == m_pMappedFile)
        {
            m_pMappedFile = new TMetaFileMapping(m_szFilename);
            if(0 == m_pMappedFile)
                THROW(MEMORY ALLOCATION FAILED);
        }
        m_iOffsetOfFixedTableHeap = 0;
        for(ULONG i=0;i<(m_pMappedFile->Size()-(32*sizeof(ULONG)));++i)
        {
            if(*reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i)  ==kFixedTableHeapSignature0 &&
               *reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+sizeof(ULONG))==kFixedTableHeapSignature1)
            {
                if(0 != m_iOffsetOfFixedTableHeap)
                {
                    out.printf(L"Multiple TableSchema signatures found.  Cannot continue.\n");
                    THROW(ERROR - MULTIPLE FIXEDTABLEHEAP SIGNATURES);
                }
                if(*reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+(2*sizeof(ULONG)))  !=kFixedTableHeapKey)
                {
                    out.printf(L"Error - Invalid FixedTableHeapKey.  This happens when the meta compilation code is out of sync with the Catalog.dll.  Get an update CatUtil.exe or rebuild Catalog.dll.\n");
                    THROW(ERROR - INVALID FIXEDTABLEHEAPKEY);
                }
                if(*reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+(3*sizeof(ULONG)))  !=kFixedTableHeapVersion)
                {
                    out.printf(L"Error - Invalid FixedTableHeapVersion.  This happens when the meta compilation code is out of sync with the Catalog.dll.  Get an update CatUtil.exe or rebuild Catalog.dll.\n");
                    THROW(ERROR - INVALID FIXEDTABLEHEAPVERSION);
                }
                m_CatalogsFixedTableHeapSize = *reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+(4*sizeof(ULONG)));
                m_iOffsetOfFixedTableHeap = i;
            }

        }
        if(0==m_iOffsetOfFixedTableHeap)
        {
            out.printf(L"Error - FixedTableHeap Signatures NOT found.  This happens when the meta compilation code is out of sync with the Catalog.dll.  Get an update CatUtil.exe or rebuild Catalog.dll.\n");
            THROW(ERROR - SIGNATURES NOT FOUND);
        }
    }
    //After we've found it return a pointer to it
    return reinterpret_cast<const FixedTableHeap *>(m_pMappedFile->Mapping() + m_iOffsetOfFixedTableHeap);
}


TFixupDLL::TFixupDLL(LPCWSTR szFilename) :
                 m_iOffsetOfFixedTableHeap(0)
                ,m_szFilename(szFilename)
{
}

TFixupDLL::~TFixupDLL()
{
    delete m_pMappedFile;
}

void TFixupDLL::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;

    if(-1 == GetFileAttributes(m_szFilename))//if GetFileAttributes fails then the file does not exist
    {
        m_pOut->printf(L"File not found (%s).\n", m_szFilename);
        THROW(ERROR - FILE NOT FOUND);
    }

    SetupToModifyPE();
    LocateSignatures();
    BuildMetaTableHeap();
    UpdateTheDLL();
}


void TFixupDLL::DisplayStatistics() const
{
}


void TFixupDLL::LocateSignatures()
{   //FixedTableHeap
    m_iOffsetOfFixedTableHeap = 0;
    for(ULONG i=0;i<(m_pMappedFile->Size()-(32*sizeof(ULONG)));++i)
    {
        if(*reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i)  ==kFixedTableHeapSignature0 &&
           *reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+sizeof(ULONG))==kFixedTableHeapSignature1)
        {
            if(0 != m_iOffsetOfFixedTableHeap)
            {
                m_pOut->printf(L"Multiple TableSchema signatures found.  Cannot continue.\n");
                THROW(ERROR - MULTIPLE FIXEDTABLEHEAP SIGNATURES);
            }
            if(*reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+(2*sizeof(ULONG)))  !=kFixedTableHeapKey)
            {
                m_pOut->printf(L"Error - Invalid FixedTableHeapKey.  This happens when the meta compilation code is out of sync with the Catalog.dll.  Get an update CatUtil.exe or rebuild Catalog.dll.\n");
                THROW(ERROR - INVALID FIXEDTABLEHEAPKEY);
            }
            if(*reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+(3*sizeof(ULONG)))  !=kFixedTableHeapVersion)
            {
                m_pOut->printf(L"Error - Invalid FixedTableHeapVersion.  This happens when the meta compilation code is out of sync with the Catalog.dll.  Get an update CatUtil.exe or rebuild Catalog.dll.\n");
                THROW(ERROR - INVALID FIXEDTABLEHEAPVERSION);
            }
            m_CatalogsFixedTableHeapSize = *reinterpret_cast<ULONG *>(m_pMappedFile->Mapping()+i+(4*sizeof(ULONG)));
            m_iOffsetOfFixedTableHeap = i;
        }

    }
    if(0==m_iOffsetOfFixedTableHeap)
    {
        m_pOut->printf(L"Error - FixedTableHeap Signatures NOT found.  This happens when the meta compilation code is out of sync with the Catalog.dll.  Get an update CatUtil.exe or rebuild Catalog.dll.\n");
        THROW(ERROR - SIGNATURES NOT FOUND);
    }
}


void TFixupDLL::SetupToModifyPE()
{
    wstring strNewDLL = m_szFilename;
    strNewDLL += L".new";
    if(0 == CopyFile(m_szFilename, strNewDLL.c_str(), FALSE))
    {
        m_pOut->printf(L"Error while making a copy of %s.\n",m_szFilename);
        THROW(ERROR - COPY FILE FAILED);
    }

    m_pMappedFile = new TMetaFileMapping(strNewDLL.c_str());
    if(0 == m_pMappedFile)
        THROW(MEMORY ALLOCATION FAILED);
}


void TFixupDLL::UpdateTheDLL()
{
    if(m_FixedTableHeap.GetEndOfHeap() > m_CatalogsFixedTableHeapSize)
    {
        m_pOut->printf(L"The DLL's FixedTableHeap isn't big enough.  FixedTableHeap needs to be %d bytes.  Current size is only %d bytes.  Update $\\src\\core\\catinproc\\sources with:/D\"CB_FIXED_TABLEHEAP=%d\"\n", m_FixedTableHeap.GetEndOfHeap(), m_CatalogsFixedTableHeapSize, m_FixedTableHeap.GetEndOfHeap());
        THROW(ERROR - FIXEDTABLEHEAP HEAP NOT BIG ENOUGH);
    }
    else
    {
        m_pOut->printf(L"FixedTableHeap will have %d bytes of unused space.  Heap size (%d bytes), Used heap space (%d bytes).\n", m_CatalogsFixedTableHeapSize-m_FixedTableHeap.GetEndOfHeap(), m_CatalogsFixedTableHeapSize, m_FixedTableHeap.GetEndOfHeap());

        m_pOut->printf(L"\nFixed Table Heap Summary\n_____________________________\n");
        ULONG i=0;
        m_pOut->printf(L"Fixed Table Heap Header                                  %10d bytes   \n",  4096);
        m_pOut->printf(L"HeapSignature0      = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"HeapSignature1      = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"HeapKey             = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"HeapVersion         = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cbHeap              = 0x%08X  - (%10d)                      \n",  m_CatalogsFixedTableHeapSize        ,m_CatalogsFixedTableHeapSize        );++i;
        m_pOut->printf(L"EndOfHeap           = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"iColumnMeta         = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cColumnMeta         = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(ColumnMeta));++i;
        m_pOut->printf(L"iDatabaseMeta       = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cDatabaseMeta       = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(DatabaseMeta));++i;
        m_pOut->printf(L"iHashTableHeap      = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cbHashTableHeap     = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"iIndexMeta          = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cIndexMeta          = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(IndexMeta));++i;
        m_pOut->printf(L"iPooledHeap         = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cbPooledHeap        = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"iQueryMeta          = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cQueryMeta          = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(QueryMeta));++i;
        m_pOut->printf(L"iRelationMeta       = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cRelationMeta       = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(RelationMeta));++i;
        m_pOut->printf(L"iServerWiringMeta   = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cServerWiringMeta   = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(ServerWiringMeta));++i;
        m_pOut->printf(L"iTableMeta          = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cTableMeta          = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(TableMeta));++i;
        m_pOut->printf(L"iTagMeta            = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cTagMeta            = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(TagMeta));++i;
        m_pOut->printf(L"iULONG              = 0x%08X  - (%10d)                      \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i));++i;
        m_pOut->printf(L"cULONG              = 0x%08X  - (%10d)         %10d bytes   \n",  *m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i),*m_FixedTableHeap.GetTypedPointer(i) * sizeof(ULONG));++i;
        m_pOut->printf(L"End Fixed Table Heap Summary\n_____________________________\n");
    }

    //Leave the first 5 DWORDs of the DLL's heap in tact.
    memcpy(m_pMappedFile->Mapping()+m_iOffsetOfFixedTableHeap+(5*sizeof(ULONG)),  m_FixedTableHeap.GetHeapPointer()+(5*sizeof(ULONG)), m_FixedTableHeap.GetEndOfHeap()-(5*sizeof(ULONG)));

    m_pOut->printf(L"PE update succeeded.\n");
    DisplayStatistics();
    delete m_pMappedFile;
    m_pMappedFile = 0;

    wstring strOldDLL = m_szFilename;
    strOldDLL += L".old";
    wstring strNewDLL = m_szFilename;
    strNewDLL += L".new";

    //Make a backup copy of the file
    if(0 == CopyFile(m_szFilename, strOldDLL.c_str(), FALSE))
    {
        m_pOut->printf(L"Error while making a backup copy of %s.\n",m_szFilename);
        THROW(ERROR - COPY FILE FAILED);
    }
    //Copy the new file over top of the original
    if(0 == CopyFile(strNewDLL.c_str(), m_szFilename, FALSE))
    {
        m_pOut->printf(L"Error renaming %s to %s...restoring previous version.\n", strNewDLL.c_str(), m_szFilename);
        if(0 == CopyFile(strOldDLL.c_str(), m_szFilename, FALSE))
        {
            m_pOut->printf(L"Error while restoring previous version (%s) to %s.\n", strOldDLL.c_str(), m_szFilename);
            THROW(ERROR - UNABLE TO RESTORE PREVIOUS VERSION OF DLL);
        }
        THROW(ERROR - UNABLE TO COPY NEW DLL OVER EXISTING ONE);
    }
    m_pOut->printf(L"Backup copy of %s renamed as %s.\n", m_szFilename, strOldDLL.c_str());

    //Now delete the working copy
    if(0 == DeleteFile(strNewDLL.c_str()))
        m_pOut->printf(L"Warning - Failed to delete working copy DLL (%s).\n",strNewDLL.c_str());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tpopulatetableschema.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

//The TableSchemaHeap is layed out as follows, the fixed length data comes first
/*
    ULONG           TableSchemaHeapSignature0
    ULONG           TableSchemaHeapSignature1
    ULONG           CountOfTables                       This is interesting only when no query is supplied and we want to walk through every table (this won't be efficient)
    ULONG           EndOfaTableSchema                   This is the byte offset just beyond the last TableSchema entry.
    HashTableHeader TableNameHashHeader                 This is the hash table that map a TableID to its aTableSchema byte offset (from the beginning of TableSchemaHeap)
    HashedIndex     aHashedIndex[kMaxHashTableSize]     The HashTableHeader contains the modulo (503 is the largest prime less than kMaxHashTableSize) for the hash table; but the table can never grow beyond this pre-allocated space.
                                                        This size was chosen so that the entire hash table would fit into the same page in memory.
---------------------------<Page Boundary>---------------------------
    unsigned char   aTableSchema[]                      This is where each Table's TableSchema goes.  FirstTableID (4096) == &aTableSchema[0] - &TableSchemaHeap, LastTableID == &aTableSchema[CountOfTables-1] - &TableSchemaHeap

One optimization we could do is to make sure that every table's schema (whose size is <=4096) fits into one page.  In other words, minimize TableSchema crossing a page boundary
*/


//This class takes the meta from the old format (TableMeta, ColumnMeta etc.) and puts it into the new format (TableSchema
//which includes CollectionMeta, PropertyMeta etc.)
class TPopulateTableSchema : public ICompilationPlugin, public THeap<ULONG>
{
public:                                                                                                               //cbHeap is the starting size, it will grow if necessary
    TPopulateTableSchema();
    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    TOutput     *   m_pOut;
    TPEFixup    *   m_pFixup;
    SimpleColumnMeta m_scmCollectionMeta[kciTableMetaPublicColumns];
    SimpleColumnMeta m_scmPropertyMeta[kciColumnMetaPublicColumns];
    SimpleColumnMeta m_scmServerWiringMeta[kciServerWiringMetaPublicColumns];
    SimpleColumnMeta m_scmTagMeta[kciTagMetaPublicColumns];

    //This doesn't actually fill in the hash table, it just determines whether the tables will fit into the hashtable and what the modulo is.
    ULONG AddSimpleColumnMetaHeap();
    void DetermineHashTableModulo(ULONG &modulo) const;
    void FillInThePublicColumns(ULONG * o_dest, TTableMeta &i_tablemeta, ULONG * i_source, TPooledHeap &io_pooledHeap, SimpleColumnMeta *o_aSimpleColumnMeta);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tcomcatmetaxmlfile.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TComCatMetaXmlFile : public TFixupHeaps
{
public:
    TComCatMetaXmlFile(TXmlFile *pXmlFile, int cXmlFile, TOutput &out);//We do everything we need with XmlFile in the ctor so we don't keep it around
    ~TComCatMetaXmlFile(){}
    static LPCWSTR              m_szComCatMetaSchema;

private:
    //ComCatMeta Elements and Attributes
    const CComBSTR              m_bstr_Attributes;
    const CComBSTR              m_bstr_BaseVersion;
    const CComBSTR              m_bstr_cbSize;
    const CComBSTR              m_bstr_CellName;
    const CComBSTR              m_bstr_CharacterSet;
    const CComBSTR              m_bstr_ChildElementName;
    const CComBSTR              m_bstr_ColumnInternalName;
    const CComBSTR              m_bstr_ColumnMeta;
    const CComBSTR              m_bstr_ColumnMetaFlags;
    const CComBSTR              m_bstr_ConfigItemName;
    const CComBSTR              m_bstr_ConfigCollectionName;
    const CComBSTR              m_bstr_ContainerClassList;
    const CComBSTR              m_bstr_DatabaseInternalName;
    const CComBSTR              m_bstr_DatabaseMeta;
    const CComBSTR              m_bstr_dbType;
    const CComBSTR              m_bstr_DefaultValue;
	const CComBSTR				m_bstr_Description;
    const CComBSTR              m_bstr_EnumMeta;
    const CComBSTR              m_bstr_ExtendedVersion;
    const CComBSTR              m_bstr_FlagMeta;
    const CComBSTR              m_bstr_ForeignTable;
    const CComBSTR              m_bstr_ForeignColumns;
    const CComBSTR              m_bstr_ID;
    const CComBSTR              m_bstr_IndexMeta;
    const CComBSTR              m_bstr_InheritsColumnMeta;
    const CComBSTR              m_bstr_Interceptor;
	const CComBSTR              m_bstr_InterceptorDLLName;
    const CComBSTR              m_bstr_InternalName;
    const CComBSTR              m_bstr_Locator;
    const CComBSTR              m_bstr_MaximumValue;
    const CComBSTR              m_bstr_Merger;
    const CComBSTR              m_bstr_MergerDLLName;
    const CComBSTR              m_bstr_MetaFlags;
    const CComBSTR              m_bstr_MinimumValue;
    const CComBSTR              m_bstr_NameValueMeta;
    const CComBSTR              m_bstr_Operator;
    const CComBSTR              m_bstr_PrimaryTable;
    const CComBSTR              m_bstr_PrimaryColumns;
    const CComBSTR              m_bstr_PublicName;
    const CComBSTR              m_bstr_PublicRowName;
	const CComBSTR				m_bstr_PublicColumnName;
    const CComBSTR              m_bstr_QueryMeta;
    const CComBSTR              m_bstr_ReadPlugin;
	const CComBSTR				m_bstr_ReadPluginDLLName;
    const CComBSTR              m_bstr_RelationMeta;
    const CComBSTR              m_bstr_SchemaGenFlags;
    const CComBSTR              m_bstr_ServerWiring;
    const CComBSTR              m_bstr_TableMeta;
    const CComBSTR              m_bstr_TableMetaFlags;
    const CComBSTR              m_bstr_UserType;
    const CComBSTR              m_bstr_Value;
    const CComBSTR              m_bstr_WritePlugin;
	const CComBSTR				m_bstr_WritePluginDLLName;


    TOutput &                   m_out;
    IXMLDOMDocument *           m_pXMLDoc;//This is only valid during construction
    IXMLDOMDocument *           m_pXMLDocMetaMeta;
    TXmlFile                  * m_pxmlFile;

    static LPCWSTR              m_szNameLegalCharacters;

    unsigned long   AddArrayOfColumnsToBytePool(unsigned long iTableMeta, LPWSTR wszColumnNames);
    void            AddColumnByReference(ULONG iTableName_Destination, ULONG iColumnIndex_Destination, ULONG iColumnMeta_Source, ColumnMeta &o_columnmeta);
    void            FillInThePEColumnMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table, unsigned long ParentTable);
    void            FillInThePEDatabaseMeta();
    void            FillInThePEEnumTagMeta(IXMLDOMNodeList *pNodeList_TagMeta, unsigned long Table, unsigned long ColumnIndex);
    void            FillInThePEFlagTagMeta(IXMLDOMNodeList *pNodeList_TagMeta, unsigned long Table, unsigned long ColumnIndex);
    void            FillInThePEIndexMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table);
    void            FillInThePEQueryMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table);
    void            FillInThePERelationMeta();
    void            FillInThePETableMeta(IXMLDOMNode *pNode_DatabaseMeta, unsigned long Database, ServerWiringMeta *pDefaultServerWiring, ULONG cNrDefaultServerWiring);
    void            FillInTheServerWiring(IXMLDOMNode *pNode_ServerWiring, ULONG Table, ULONG Order, TableSchema::ServerWiringMeta &serverwiring);
    void            FillInThePEServerWiringMeta(IXMLDOMNode *pNode_TableMeta, unsigned long Table, ServerWiringMeta *pDefaultServerWiring, ULONG cNrDefaultServerWiring);
    void            Get_OLEDataTypeToXMLDataType_Index(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, int &i) const;
    unsigned long   GetDefaultValue(IXMLDOMNamedNodeMap *pMap, ColumnMeta &columnMeta, bool bDefaultFlagToZero=true);
    bool            GetEnum(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, unsigned long &Enum, bool bMustExists=false) const;
    void            GetFlags(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, LPCWSTR szFlagType, unsigned long &lFlags) const;
    unsigned long   GetString_AndAddToWCharList(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, bool bMustExist=false);
};

struct GlobalRowCounts 
{
    ULONG cCoreTables;
    ULONG cCoreDatabases;
    ULONG cCoreColumns;
    ULONG cCoreTags;
    ULONG cCoreIndexes;
    ULONG cCoreRelations;
    ULONG cCoreQueries;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\txmlfile.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

TXmlFile::TXmlFile() : m_bValidated(false), m_bAlternateErrorReporting(false), m_szXMLFileName(NULL)
{
    m_errorOutput = &m_outScreen;
    m_infoOutput = &m_outScreen;
}

TXmlFile::~TXmlFile()
{
}

void TXmlFile::SetAlternateErrorReporting()
{
    m_errorOutput = &m_outException;
    m_infoOutput = &m_outScreen;
    m_bAlternateErrorReporting = true;
}

TCHAR * TXmlFile::GetLatestError()
{
    if(m_bAlternateErrorReporting)
        return ((TExceptionOutput *)m_errorOutput)->GetString();
    else
        return NULL;
}

bool TXmlFile::GetNodeValue(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, CComVariant &var, bool bMustExist) const
{
    ASSERT(0 != pMap);

    CComPtr<IXMLDOMNode>    pNode;
    XIF(pMap->getNamedItem(bstr, &pNode));
    if(0 == pNode.p)
        if(bMustExist)
        {
            m_errorOutput->printf(L"Attribute %s does not exist.\n", bstr);
            THROW(ERROR - ATTRIBUTE DOES NOT EXIST);
        }
        else //If the attribute doesn't have to exist then just return false
        {
            var.Clear();
            return false;
        }

    XIF(pNode->get_nodeValue(&var));
    ASSERT(var.vt == VT_BSTR);
    return true;
}


//There are three possibilities for guids: uuid, guidID (guid with '_' instead of '{' & '}') of guid as idref
bool TXmlFile::GetNodeValue(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, GUID &guid, bool bMustExist) const
{
    CComVariant var_Guid;
    if(!GetNodeValue(pMap, bstr, var_Guid, bMustExist))
    {
        memset(&guid, 0x00, sizeof(guid));
        return false;
    }
    if(var_Guid.bstrVal[0] == L'_' && var_Guid.bstrVal[37] == L'_')//if the first character is an '_' then it must be a GuidID
        GuidFromGuidID(var_Guid.bstrVal, guid);
    else if(var_Guid.bstrVal[8]  == L'-' &&
            var_Guid.bstrVal[13] == L'-' &&
            var_Guid.bstrVal[18] == L'-' &&
            var_Guid.bstrVal[23] == L'-')//if these are '-' then it's a guid
    {
        if(FAILED(UuidFromString(var_Guid.bstrVal, &guid)))//validate that it is in fact a GUID
        {
            m_errorOutput->printf(L"Logical Error:\n\tguid (%s) is not a valid GUID.\n", var_Guid.bstrVal);
            THROW(Logical Error);
        }

        SIZE_T nStringLength = wcslen(var_Guid.bstrVal);
        while(nStringLength--)//Then make sure it is all upper case
        {
            if(var_Guid.bstrVal[nStringLength] >= L'a' && var_Guid.bstrVal[nStringLength] <= L'z')
            {
                m_errorOutput->printf(L"Logical Error:\n\tguid %s contains a lower case\n\tcharacter '%c',GUIDs MUST be all caps by convention.\nNOTE: guidgen sometimes produces lowercase characters.\n", var_Guid.bstrVal, static_cast<char>(var_Guid.bstrVal[nStringLength]));
                THROW(Logical Error);
            }
        }
    }
    else //otherwise it's guid as idref
    {
        //Get the node with the matching ID
        CComPtr<IXMLDOMNode>    pNodeGuid;
        XIF((m_pXMLDoc.p)->nodeFromID(var_Guid.bstrVal, &pNodeGuid));
        if(0 == pNodeGuid.p)
        {
            m_errorOutput->printf(L"Logical Error:\n\tguid (%s) is not a valid idref.\n", var_Guid.bstrVal);
            THROW(Logical Error);
        }

        CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement = pNodeGuid;
        ASSERT(0 != pElement.p);//Get the IXMLDOMElement interface pointer

        CComBSTR                bstr_guid     = L"guid";
        CComVariant             var_Guid_;
        XIF(pElement->getAttribute(bstr_guid, &var_Guid_));

        if(FAILED(UuidFromString(var_Guid_.bstrVal, &guid)))//validate that it is in fact a GUID
        {
            m_errorOutput->printf(L"Logical Error:\n\tguid (%s) is not a valid GUID.\n", var_Guid_.bstrVal);
            THROW(Logical Error);
        }
    }
    return true;
}


bool TXmlFile::GetNodeValue(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, unsigned long &ul, bool bMustExist) const
{
    CComVariant var_ul;
    if(!GetNodeValue(pMap, bstr, var_ul, bMustExist))
        return false;

    ul = _wtol(var_ul.bstrVal);
    return true;
}


void TXmlFile::GuidFromGuidID(LPCWSTR wszGuidID, GUID &guid) const
{
    WCHAR wszGuid[39];

    SIZE_T nStringLength = wcslen(wszGuidID);
    if(nStringLength != 38)//Check the string length first
    {
        m_errorOutput->printf(L"Logical Error:\n\tGuidID %s is not a valid.\n\tThe guidid must be of the form\n\t_BDC31734-08A1-11D3-BABE-00C04F68DDC0_\n", wszGuidID);
        THROW(Logical Error in Data Table);
    }

    wcscpy(wszGuid, wszGuidID);
    wszGuid[0] = L'{';
    wszGuid[37] = L'}';//replace the '_'s (presumably) with '{' & '}'
    if(FAILED(CLSIDFromString(wszGuid, &guid)))//Now see if it's a real GUID
    {
        m_errorOutput->printf(L"Logical Error:\n\tGuidID %s is not a valid.\n\tThe guidid must be of the form\n\t_BDC31734-08A1-11D3-BABE-00C04F68DDC0_\n", wszGuidID);
        THROW(Logical Error in Data Table);
    }

    while(nStringLength--)//now verify that it is all upper case
    {
        if(wszGuidID[nStringLength] >= L'a' && wszGuidID[nStringLength] <= L'z')
        {
            m_errorOutput->printf(L"Logical Error:\n\t%s contains a lower case\n\tcharacter '%c',guidids MUST be all caps by convention.\n\tNOTE: guidgen sometimes produces lowercase characters.\n", wszGuidID, static_cast<char>(wszGuidID[nStringLength]));
            THROW(Logical Error in Data Table);
        }
    }
}


bool TXmlFile::IsSchemaEqualTo(LPCWSTR szSchema) const
{
    if(!m_bValidated)//It does not make sense to check the schema if the XML file wasn't validated
        return false;//so we always return unless the xml was validated against a schema.

    wstring wstrSchema;
    GetSchema(wstrSchema);

    return (wstrSchema == szSchema);
}


bool TXmlFile::NextSibling(CComPtr<IXMLDOMNode> &pNode) const
{
    IXMLDOMNode *pnextSibling = 0;
    if(SUCCEEDED(pNode->get_nextSibling(&pnextSibling)) && pnextSibling)
    {
        pNode.Release();
        pNode = pnextSibling;
        pnextSibling->Release();//This is necessary because get_nextSibling add ref'd and the 'pNode = pnextSibling' add ref'd again
                                //Also we can't call pNode.Release because CComPtr will NULL p out after the release
    }
    else
        pNode.Release();
    return (0!=pnextSibling);
}


//XML parse and XML validation (validation must be done before IsSchemaEqualTo can be called.
void TXmlFile::Parse(LPCWSTR szFilename, bool bValidate)
{
    if(-1 == GetFileAttributes(szFilename))//if GetFileAttributes fails then the file does not exist
    {
        m_errorOutput->printf(L"File not found (%s).\n", szFilename);
        THROW(ERROR - FILE NOT FOUND);
    }
	CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, _IID_IXMLDOMDocument, (void**)&m_pXMLDoc);


	XIF(m_pXMLDoc->put_validateOnParse(bValidate ? VARIANT_TRUE : VARIANT_FALSE));//Tell parser whether to validate according to an XML schema or DTD
    XIF(m_pXMLDoc->put_async(VARIANT_FALSE));
    XIF(m_pXMLDoc->put_resolveExternals(VARIANT_TRUE));

    VARIANT_BOOL bSuccess;
	CComVariant  xml(szFilename);
    XIF(m_pXMLDoc->load(xml,&bSuccess));

    if(bSuccess == VARIANT_FALSE)
	{
		CComPtr<IXMLDOMParseError> pXMLParseError;
		XIF(m_pXMLDoc->get_parseError(&pXMLParseError));

        long lErrorCode;
		XIF(pXMLParseError->get_errorCode(&lErrorCode));

        long lFilePosition;
		XIF(pXMLParseError->get_filepos(&lFilePosition));

        long lLineNumber;
		XIF(pXMLParseError->get_line(&lLineNumber));

		long lLinePosition;
		XIF(pXMLParseError->get_linepos(&lLinePosition));

		CComBSTR bstrReasonString;
        XIF(pXMLParseError->get_reason(&bstrReasonString));

		CComBSTR bstrSourceString;
        XIF(pXMLParseError->get_srcText(&bstrSourceString));

        CComBSTR bstrURLString;
		XIF(pXMLParseError->get_url(&bstrURLString));

		m_errorOutput->printf(
                        L"\n-----ERROR PARSING: Details Follow-----\nError Code     0x%08x\nFile Position    %8d\nLine Number      %8d\nLine Position    %8d\n Reason:    %s\nSource:    %s\nURL:       %s\n-----ERROR PARSING: End Details-------\n\n"
                       , lErrorCode, lFilePosition, lLineNumber, lLinePosition
                       , bstrReasonString, bstrSourceString.m_str ? bstrSourceString : "{EMPTY}", bstrURLString);

		THROW(ERROR PARSING XML FILE);
	}

    if(!bValidate)
    {
        m_infoOutput->printf(L"XML is well formed\n");
        return;
    }
    else
        m_infoOutput->printf(L"XML well formed & valid according to all schema\n");

    m_bValidated = bValidate;
}


//
//Private member functions
//

typedef HRESULT( __stdcall *DLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID FAR*);

void TXmlFile::CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID * ppv) const
{
    HRESULT                 hr = S_OK;
    HINSTANCE               hInstMSXML = NULL;
    DLLGETCLASSOBJECT       DllGetClassObject = NULL;
	CComPtr<IClassFactory>  spClassFactory;

	ASSERT( NULL != ppv );
	*ppv = NULL;

    // create a instance of the object we want
	hr = ::CoCreateInstance( rclsid, pUnkOuter, dwClsContext, riid, ppv );

    // During setup msxml3 is not yet registered
	if ( hr != REGDB_E_CLASSNOTREG )
	{
	    XIF( hr );
	    return;
	}
	else
	{
	    // This assumes MSXML3.DLL for the object, leave the instance dangling
        hInstMSXML = LoadLibraryW( L"msxml3.dll" );
        if ( hInstMSXML == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            XIF( hr );
    	    return;
        }

        DllGetClassObject = (DLLGETCLASSOBJECT)GetProcAddress( hInstMSXML, "DllGetClassObject" );
        if ( DllGetClassObject == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            XIF( hr );
    	    return;
        }

        // get the class factory object
	    XIF( DllGetClassObject( rclsid, IID_IClassFactory, (LPVOID*)&spClassFactory ) );

        // create a instance of the object we want
	    XIF( spClassFactory->CreateInstance( NULL, riid, ppv ) );
	}
}


void TXmlFile::GetSchema(wstring &wstrSchema) const
{
    //This is kind of a long road to get to the XML Schema name but here goes...
    CComPtr<IXMLDOMElement>     pRootNodeOfXMLDocument;
    XIF((m_pXMLDoc.p)->get_documentElement(&pRootNodeOfXMLDocument)); //Get the XML Root Node

    CComPtr<IXMLDOMNode>        pDefinitionNode;
    XIF(pRootNodeOfXMLDocument->get_definition(&pDefinitionNode));//From that get the Definition node
    if(0 == pDefinitionNode.p)//This is legal, it just means there's no schema
    {
        wstrSchema = L"";
        return;
    }

    CComPtr<IXMLDOMDocument>    pSchemaDocument;
    XIF(pDefinitionNode->get_ownerDocument(&pSchemaDocument));//From that we get the DOMDocument of the schema

    CComPtr<IXMLDOMElement>     pSchemaRootElement;
    XIF(pSchemaDocument->get_documentElement(&pSchemaRootElement));//Get the schema's root element

    CComBSTR                    bstrAttributeName(L"name");
    CComVariant                 XMLSchemaName;
    XIF(pSchemaRootElement->getAttribute(bstrAttributeName, &XMLSchemaName));//get the Name attribute
    ASSERT(XMLSchemaName.vt == VT_BSTR);

    wstrSchema = XMLSchemaName.bstrVal;

    if(wstrSchema == L"")
        m_infoOutput->printf(L"No schema detected\n");
    else
        m_infoOutput->printf(L"XML Schema %s detected\n", wstrSchema.c_str());
}


static LPCWSTR kwszHexLegalCharacters = L"abcdefABCDEF0123456789";

static unsigned char kWcharToNibble[128] = //0xff is an illegal value, the illegal values should be weeded out by the parser
{ //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
/*00*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*10*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*20*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*30*/  0x0,    0x1,    0x2,    0x3,    0x4,    0x5,    0x6,    0x7,    0x8,    0x9,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*40*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*50*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*60*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*70*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
};

//This converts the string to bytes (an L'A' gets translated to 0x0a NOT 'A')
void TXmlFile::ConvertWideCharsToBytes(LPCWSTR wsz, unsigned char *pBytes, unsigned long length) const
{
    LPCWSTR wszIllegalCharacter = _wcsspnp(wsz, kwszHexLegalCharacters);
    if(wszIllegalCharacter)
    {
        m_errorOutput->printf(L"Error - Illegal character (%c) in Byte string.\n", static_cast<unsigned char>(*wszIllegalCharacter));
        THROW(ERROR - BAD HEX CHARACTER);
    }

    memset(pBytes, 0x00, length);
    for(;length && *wsz; --length, ++pBytes)//while length is non zero and wsz is not at the terminating NULL
    {
        *pBytes =  kWcharToNibble[(*wsz++)&0x007f]<<4;//The first character is the high nibble
        *pBytes |= kWcharToNibble[(*wsz++)&0x007f];   //The second is the low nibble
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tschemageneration.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TSchemaGeneration
{
public:
    TSchemaGeneration(LPCWSTR wszSchemaFilename, TPEFixup &fixup, TOutput &out);
private:
    LPCWSTR         m_wszSchemaFilename;
    TPEFixup      & m_Fixup;
    TOutput       & m_out;
    const LPCWSTR   m_szComCatDataVersion;

    void ProcessMetaXML() const;
    void ProcessMetaTable(TTableMeta &TableMeta, wstring &wstrBeginning) const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\ttableinfogeneration.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

TTableInfoGeneration::TTableInfoGeneration(LPCWSTR szFilename, TPEFixup &fixup, TOutput &out) :
                m_Fixup(fixup),
                m_out(out),
                m_szFilename(szFilename),
                m_szTableInfoDefine(L"TABLEINFO")
{
    wstring wstrTemp = m_szFilename;
    wstrTemp += L".temp";
    TableInfoHeaderFromMeta(wstrTemp);

    bool bUpToDate = false;
    if(-1 != GetFileAttributes(m_szFilename))//if we can't GetFileAttributes then there must not be a table)info file already.
    {
        TMetaFileMapping OldTableInfo(m_szFilename);//false means the file doesn't have to exist.
        TMetaFileMapping NewTableInfo(wstrTemp.c_str());
        LPCSTR szOldTableInfo = strstr(reinterpret_cast<const char *>(OldTableInfo.Mapping()), "Copyright");//Before copyright is the date and time the file was
        LPCSTR szNewTableInfo = strstr(reinterpret_cast<const char *>(NewTableInfo.Mapping()), "Copyright");//generated.  We don't care about that, so compare after the word 'copyright'
        bUpToDate = (OldTableInfo.Size() == NewTableInfo.Size() &&//sizes are the same
                    szOldTableInfo &&                            //and 'Copyright' was
                    szNewTableInfo &&
                    0 == memcmp(szOldTableInfo, szNewTableInfo, OldTableInfo.Size()-(szOldTableInfo-reinterpret_cast<const char *>(OldTableInfo.Mapping()))));
    }

    if(bUpToDate)
        m_out.printf(L"%s is up to date.\n", m_szFilename);
    else
    {
        if(0 == CopyFile(wstrTemp.c_str(), m_szFilename, FALSE))//copy the temp file over top of the header file that might already exist
            THROW(ERROR - COPY FILE FAILED);
        m_out.printf(L"%s Generated.\n", m_szFilename);
    }

    if(0 == DeleteFile(wstrTemp.c_str()))
        m_out.printf(L"Warning - Failed to delete temporary file (%s).\n",wstrTemp.c_str());
}


//
// Private Member Functions
//
void TTableInfoGeneration::GetColumnEnumFromColumnNameAndTagName(LPCWSTR wszTableName, LPCWSTR wszColumnName, LPCWSTR wszTagName, LPWSTR wszEnumName) const
{
    UNREFERENCED_PARAMETER(wszColumnName);
    wsprintf(wszEnumName, L"e%s_%s", wszTableName, wszTagName);
}


void TTableInfoGeneration::GetColumnFlagFromColumnNameAndTagName(LPCWSTR wszTableName, LPCWSTR wszColumnName, LPCWSTR wszTagName, LPWSTR wszEnumName) const
{
    UNREFERENCED_PARAMETER(wszColumnName);
    wsprintf(wszEnumName, L"f%s_%s", wszTableName, wszTagName);
}


void TTableInfoGeneration::GetEnumFromColumnName(LPCWSTR wszTableName, LPCWSTR wszColumnName, LPWSTR wszEnumName) const
{
    wsprintf(wszEnumName, L"i%s_%s", wszTableName, wszColumnName);
}

void TTableInfoGeneration::GetStructElementFromColumnName(ULONG i_Type, LPCWSTR i_wszColumnName, LPWSTR o_szStructElement) const
{
    static WCHAR * wszType[0x10]  ={L"unsigned char *", 0, L"WCHAR *", L"ULONG *", 0, L"UINT64 *", 0, L"void *", L"GUID *", 0, 0, 0, 0, 0, 0, 0};
//@@@The follwing line is useful if we want to add hungarian type information
//    static WCHAR * wszPrefix[0x10]={L"by"             , 0, L"wsz"    , L"ul"     , 0, 0, 0, 0, L"guid"  , 0, 0, 0, 0, 0, 0, 0};
    ASSERT(0 != wszType[i_Type&0x0F]);//we should only get these types for now.
    wsprintf(o_szStructElement, L"%16s     p%s", wszType[i_Type&0x0F], i_wszColumnName);
}

void TTableInfoGeneration::TableInfoHeaderFromMeta(wstring &header_filename) const
{
    //Write preamble
    wstring     wstrPreamble;
    WriteTableInfoHeaderPreamble(wstrPreamble, header_filename);

    //TableEnums
    wstring     wstrTableEnums;
    WriteTableInfoHeaderEnums(wstrTableEnums);

    //TableID_Preprocessor & TableID_DEFINE_GUIDs
    wstring     wstrTableID_Preprocessor;
    wstring     wstrTableID_DEFINE_GUIDs;
    //This writes the DatabaseIDs first then the TableIDs
    WriteTableInfoHeaderTableIDs(wstrTableID_Preprocessor, wstrTableID_DEFINE_GUIDs);

    //Write postamble
    wstring     wstrPostamble;
    WriteTableInfoHeaderPostamble(wstrPostamble);

    wstrPreamble += wstrTableID_Preprocessor;
    wstrPreamble += wstrTableID_DEFINE_GUIDs;
    wstrPreamble += wstrTableEnums;
    wstrPreamble += wstrPostamble;

    TFile(header_filename.c_str(), m_out).Write(wstrPreamble, (ULONG) wstrPreamble.length());
}


void TTableInfoGeneration::WriteTableInfoHeaderDatabaseIDs(wstring &wstrPreprocessor, wstring &wstrDatabaseIDs) const
{
    UNREFERENCED_PARAMETER(wstrPreprocessor);
/*
    static wchar_t *wszTableID_Preprocessor[]={
    L"#	define DEFINE_GUID_FOR_%s  \n",
    };
    static wchar_t *wszDEFINE_GUIDs[]={
    L"\n",
    L"#ifdef DEFINE_GUID_FOR_%s  \n",
    L"DEFINE_GUID(%40s,    0x%08x, 0x%04x, 0x%04x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x); // {%s}\n",
    L"#endif  \n",
    L"\n", 0
    };
*/
    static wchar_t *wszDatabaseName[]={
    L"//------------------------------DatabaseName---------------------------   \n",
    L"#define wszDATABASE_%-30s          L\"%s\"\n",
    L"\n", 0
    };
    WCHAR szTemp[256];

    TDatabaseMeta DatabaseMeta(m_Fixup);

    wstrDatabaseIDs += wszDatabaseName[0];

    for(unsigned int iDatabaseMeta=0; iDatabaseMeta < DatabaseMeta.GetCount(); iDatabaseMeta++, DatabaseMeta.Next())
    {
        wsprintf(szTemp, wszDatabaseName[1], DatabaseMeta.Get_InternalName(), DatabaseMeta.Get_InternalName());
        wstrDatabaseIDs += szTemp;
        /*
        GUID &guid= *DatabaseMeta.Get_iGuidDid();
        WCHAR didInternalNameALLCAPS[255];
        wcscpy(didInternalNameALLCAPS, DatabaseMeta.Get_iInternalName());
        //Convert to uppercase and prepend DEFINE_GUID_FOR_
        _wcsupr(didInternalNameALLCAPS);

        WCHAR *szDidGuidTemp;
        WCHAR szDidGuid[40];
        StringFromCLSID(guid, &szDidGuidTemp);
        wcscpy(szDidGuid, szDidGuidTemp);//This will keep us from having to do a try-catch
        CoTaskMemFree(szDidGuidTemp);

        //Write #define DEFINE_GUID_FOR_### to the list of all DEFINE_TID_GUIDS
        wsprintf(szTemp, wszTableID_Preprocessor[0], didInternalNameALLCAPS);
        wstrPreprocessor += szTemp;

        //Write the DEFINE_GUID entry (this includes the $ifdef DEFINE_GUID_FOR_###)
        wstrDatabaseIDs += wszDEFINE_GUIDs[0];
        wsprintf(szTemp, wszDEFINE_GUIDs[1], didInternalNameALLCAPS);
        wstrDatabaseIDs += szTemp;
        didInternalNameALLCAPS[0] = L'd';
        didInternalNameALLCAPS[1] = L'i';
        didInternalNameALLCAPS[2] = L'd';
        wsprintf(szTemp, wszDEFINE_GUIDs[2], didInternalNameALLCAPS, guid.Data1, guid.Data2, guid.Data3,
                    guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7], szDidGuid);
        wstrDatabaseIDs += szTemp;
        wstrDatabaseIDs += wszDEFINE_GUIDs[3];
        */
    }
    wstrDatabaseIDs += wszDatabaseName[2];
}


void TTableInfoGeneration::WriteTableInfoHeaderEnums(wstring &wstr) const
{
    static wchar_t *wszTableName[]={
    L"\n\n\n\n//-------------------------------TableName-----------------------------   \n",
    L"#define wszTABLE_%-30s          L\"%s\"\n",
    L"#define TABLEID_%-30s           (0x%08xL)\n",
    L"\n", 0
    };

    static wchar_t *wszTableVersion[]={
    L"\n\n\n\n//-------------------------------Table Versions-------------------------\n",
    L"#define BaseVersion_%-30s       (%dL)\n",
    L"#define ExtendedVersion_%-30s   (%dL)\n",
    L"\n", 0
    };

    static wchar_t *wszEnums[]={
    L"//-----------------Column Index Enums--------------   \n",
    L"enum e%s {\n",
    L"    %s,  \n",
    L"    c%s_NumberOfColumns\n",
    L"};\n",
    L"\n", 0
    };

    static wchar_t *wszStruct[]={
    L"//-----------------Columns as Struct---------------   \n",
    L"struct t%sRow {\n",
    L"%s;\n",
    L"};\n",
    L"\n", 0
    };

    static wchar_t *wszColumnTags[]={
    L"enum e%s_%s {\n",
    L"    %-30s\t=\t%8d,\t//(0x%08x)\n",         //This one for enums
    L"    %-30s\t=\t0x%08x,\t//(%d decimal)\n", //This one for flags
    L"    %-30s\t=\t%8d\t//(0x%08x)\n",         //This one for last enum
    L"    f%s_%s_Mask\t= 0x%08x\n",               //This one for flag mask
    L"};\n",
    L"\n", 0
    };

    static wchar_t *wszDefineIndexName[]={
    L"//----------------IndexMeta------------------------   \n",
    L"#define %s_%s L\"%s\"\n",
    L"\n", 0
    };

    wstr = L"";

    TTableMeta TableMeta(m_Fixup);

    //While pNode_MetaTableID is not 0
    WCHAR szTemp[1024];
    WCHAR szEnum[1024];
    WCHAR szStruct[1024];
    for(unsigned int iTableMeta=0; iTableMeta< TableMeta.GetCount(); iTableMeta++, TableMeta.Next())
    {
        wstr += wszTableName[0];//-------------------------------TableName-----------------------------
        wsprintf(szTemp, wszTableName[1], TableMeta.Get_InternalName(), TableMeta.Get_InternalName());
        wstr += szTemp;         //#define tidTableName L"tidTableName"
        wsprintf(szTemp, wszTableName[2], TableMeta.Get_InternalName(), TableMeta.Get_nTableID());
        wstr += szTemp;         //#define TABLEID_TableName (0xabcdef00L)
        wstr += wszTableName[3];

        wstr += wszTableVersion[0];//-------------------------------Table Versions-------------------------
        wsprintf(szTemp, wszTableVersion[1], TableMeta.Get_InternalName(), *TableMeta.Get_BaseVersion());
        wstr += szTemp;         //#define BaseVersion_%-30s       (%dL)\n",
        wsprintf(szTemp, wszTableVersion[2], TableMeta.Get_InternalName(), *TableMeta.Get_ExtendedVersion());
        wstr += szTemp;         //#define ExtendedVersion_%-30s   (%dL)\n",
        wstr += wszTableVersion[3];

        if(!TableMeta.IsTableMetaOfColumnMetaTable())
            continue;

        if(TableMeta.Get_cIndexMeta())//If there are any IndexMeta entries
        {
            //Make a little section for the IndexMeta names
            wstr += wszDefineIndexName[0];

            TIndexMeta IndexMeta(m_Fixup, TableMeta.Get_iIndexMeta());
            LPCWSTR szPrev_IndexMeta_InternalName=0;
            for(unsigned int cIndexMeta=0; cIndexMeta<TableMeta.Get_cIndexMeta(); ++cIndexMeta, IndexMeta.Next())
            {   //put a #define in for every IndexMeta name in the IndexMeta for this table
                if(szPrev_IndexMeta_InternalName != IndexMeta.Get_InternalName())//Only define the name once per index name
                {                                                                 //We don't have to do a string compare since all identical strings share the same index into Pool
                    wsprintf(szTemp, wszDefineIndexName[1], TableMeta.Get_InternalName(), IndexMeta.Get_InternalName(), IndexMeta.Get_InternalName());
                    wstr += szTemp;
                    szPrev_IndexMeta_InternalName = IndexMeta.Get_InternalName();
                }
            }
            wstr += wszDefineIndexName[2];
        }

        //Create an enum
        wstr += wszEnums[0];
        wsprintf(szTemp, wszEnums[1], TableMeta.Get_InternalName());//enum enumTableName
        wstr += szTemp;

        TColumnMeta     ColumnMeta(m_Fixup, TableMeta.Get_iColumnMeta());
        unsigned int    cTags=0;
        unsigned int    iColumnMeta;
        for(iColumnMeta=0; iColumnMeta< *TableMeta.Get_CountOfColumns(); iColumnMeta++, ColumnMeta.Next())
        {
            //Write the ColumnName as the next enum value
            GetEnumFromColumnName(TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName(), szEnum);
            wsprintf(szTemp, wszEnums[2], szEnum);//iTableName_ColumnInternalName
            wstr += szTemp;

            if(*ColumnMeta.Get_MetaFlags() & (fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM))
                ++cTags;
        }
        //End the enum
        wsprintf(szTemp, wszEnums[3], TableMeta.Get_InternalName());//nTableName_NumberOfColumns
        wstr += szTemp;
        wstr += wszEnums[4];//end the enum
        wstr += wszEnums[5];//add a newline


        //Create the struct
        wstr += wszStruct[0];
        wsprintf(szTemp, wszStruct[1], TableMeta.Get_InternalName());//struct tTableName
        wstr += szTemp;

        ColumnMeta.Reset();
        for(iColumnMeta=0; iColumnMeta< *TableMeta.Get_CountOfColumns(); iColumnMeta++, ColumnMeta.Next())
        {
            //Write the ColumnName as the next element of the struct
            GetStructElementFromColumnName(*ColumnMeta.Get_Type(), ColumnMeta.Get_InternalName(), szStruct);
            wsprintf(szTemp, wszStruct[2], szStruct);//ColumnInternalName
            wstr += szTemp;
        }
        //End the struct
        wstr += wszStruct[3];
        wstr += wszStruct[4];//add a newline


        ColumnMeta.Reset();
        //After we've finished the column struct, check to see if there are any ColumnEnums or Flags
        bool bBoolean = false;//We only declare one enum for booleans per table
        for(iColumnMeta=0; cTags && iColumnMeta< *TableMeta.Get_CountOfColumns(); iColumnMeta++, ColumnMeta.Next())
        {
            if(*ColumnMeta.Get_MetaFlags() & (fCOLUMNMETA_ENUM | fCOLUMNMETA_FLAG))
            {
                if(*ColumnMeta.Get_SchemaGeneratorFlags() & fCOLUMNMETA_PROPERTYISINHERITED)
                    continue;//If the property is inherited, then don't generate enum, the user can use the enum from the parent table.
                if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_BOOL)
                    if(bBoolean)//If we've already seen a boolean for this table then skip it and move on.
                        continue;
                    else
                        bBoolean = true;//if this is the first bool we've seen then declare the enum.

                ASSERT(0 != ColumnMeta.Get_ciTagMeta());

                bool bFlag = (0 != (*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_FLAG));

                TTagMeta TagMeta(m_Fixup, ColumnMeta.Get_iTagMeta());

                wsprintf(szTemp, wszColumnTags[0], TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName());//enum Tablename_ColumnName
                wstr += szTemp;

                for(unsigned int cTagMeta=0; cTagMeta < ColumnMeta.Get_ciTagMeta()-1; ++cTagMeta, TagMeta.Next())
                {
                    ASSERT(*TagMeta.Get_ColumnIndex() == iColumnMeta);
                    if(bFlag)
                    {
                        GetColumnFlagFromColumnNameAndTagName(TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName(), TagMeta.Get_InternalName(), szEnum);
                        wsprintf(szTemp, wszColumnTags[2], szEnum, *TagMeta.Get_Value(), *TagMeta.Get_Value());//iTableName_colInternalName_TagNameInternal = 0x0000000f,    //(15 decimal)
                    }
                    else
                    {
                        GetColumnEnumFromColumnNameAndTagName(TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName(), TagMeta.Get_InternalName(), szEnum);
                        wsprintf(szTemp, wszColumnTags[1], szEnum, *TagMeta.Get_Value(), *TagMeta.Get_Value());//iTableName_colInternalName_TagNameInternal = 15,  //(0x0000000f)
                    }
                    wstr += szTemp;
                }
                if(bFlag)
                {
                    GetColumnFlagFromColumnNameAndTagName(TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName(), TagMeta.Get_InternalName(), szEnum);
                    wsprintf(szTemp, wszColumnTags[2], szEnum, *TagMeta.Get_Value(), *TagMeta.Get_Value());//iTableName_colInternalName_TagNameInternal = 0x0000000f,    //(15 decimal)
                }
                else
                {    //The last enum doesn't have a comma
                    GetColumnEnumFromColumnNameAndTagName(TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName(), TagMeta.Get_InternalName(), szEnum);
                    wsprintf(szTemp, wszColumnTags[3], szEnum, *TagMeta.Get_Value(), *TagMeta.Get_Value());//iTableName_colInternalName_TagNameInternal = 15,  //(0x0000000f)
                }
                wstr += szTemp;
                if(bFlag)
                {   //The last flag is followed by the flag mask
                    wsprintf(szTemp, wszColumnTags[4], TableMeta.Get_InternalName(), ColumnMeta.Get_InternalName(), *ColumnMeta.Get_FlagMask());
                    wstr += szTemp;
                }
                wstr += wszColumnTags[5];//end the enum
                wstr += wszColumnTags[6];//add a newline

            }
        }
    }
}


void TTableInfoGeneration::WriteTableInfoHeaderTableIDs(wstring &wstrPreprocessor, wstring &wstrTableIDs) const
{
/*
    static wchar_t *wszTableID_Preprocessor[]={
    L"\n",
    L"\n",
    L"//--------------------------------------------------------------------\n",
    L"// Database and table ids:                                            \n",
    L"//--------------------------------------------------------------------\n",
    L"\n",
    L"\n",
    L"// NOTE: Turn on conditional inclusion for your did or tid here, then.\n",
    L"#ifndef %s_SELECT  \n",
    L"    #define DEFINE_GUID_FOR_%s  \n",
    L"#endif\n",
    L"\n", 0
    };
    static wchar_t *wszTableID_DEFINE_GUIDs[]={
    L"\n",
    L"#ifdef DEFINE_GUID_FOR_%s  \n",
    L"DEFINE_GUID(%40s,    0x%08x, 0x%04x, 0x%04x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x); // %s\n",
    L"#endif  \n",
    L"\n", 0
    };
*/
    wstrPreprocessor    = L"";
    wstrTableIDs        = L"";
/*
    for(int iPreprocessor=0;iPreprocessor<8;iPreprocessor++)//The preprocessor first several lines don't require modification
        wstrPreprocessor += wszTableID_Preprocessor[iPreprocessor];

    WCHAR szTemp[1024];
    wsprintf(szTemp, wszTableID_Preprocessor[iPreprocessor++], m_szTableInfoDefine);
    wstrPreprocessor += szTemp;
*/
    WriteTableInfoHeaderDatabaseIDs(wstrPreprocessor, wstrTableIDs);
/*
    TTableMeta TableMeta(1,m_Fixup);
    for(unsigned int iTableMeta=1; iTableMeta < *m_Fixup.pciTableMetas; iTableMeta++, TableMeta.Next())
    {
        WCHAR tidInternalNameALLCAPS[255];
        wcscpy(tidInternalNameALLCAPS, TableMeta.Get_iInternalName());
        //Convert to uppercase and prepend DEFINE_GUID_FOR_
        _wcsupr(tidInternalNameALLCAPS);

        //Write #define DEFINE_GUID_FOR_### to the list of all DEFINE_TID_GUIDS
        wsprintf(szTemp, wszTableID_Preprocessor[iPreprocessor], tidInternalNameALLCAPS);
        wstrPreprocessor += szTemp;

        //Write the DEFINE_GUID entry (this includes the $ifdef DEFINE_GUID_FOR_###)
        wstrTableIDs += wszTableID_DEFINE_GUIDs[0];
        wsprintf(szTemp, wszTableID_DEFINE_GUIDs[1], tidInternalNameALLCAPS);
        wstrTableIDs += szTemp;
        tidInternalNameALLCAPS[0] = L't';
        tidInternalNameALLCAPS[1] = L'i';
        tidInternalNameALLCAPS[2] = L'd';

        GUID &guid= *TableMeta.Get_iGuidTid();
        WCHAR *szTidGuidTemp;
        WCHAR szTidGuid[40];
        StringFromCLSID(guid, &szTidGuidTemp);
        wcscpy(szTidGuid, szTidGuidTemp);//This will keep us from having to do a try-catch
        CoTaskMemFree(szTidGuidTemp);

        wsprintf(szTemp, wszTableID_DEFINE_GUIDs[2], tidInternalNameALLCAPS, guid.Data1, guid.Data2, guid.Data3,
                    guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7], szTidGuid);
        wstrTableIDs += szTemp;
        wstrTableIDs += wszTableID_DEFINE_GUIDs[3];
    }

    wstrPreprocessor += wszTableID_Preprocessor[++iPreprocessor];//end the #ifndef
*/
}


void TTableInfoGeneration::WriteTableInfoHeaderPostamble(wstring &wstr) const
{
    static wchar_t *wszPostamble[]={
    L"\n",
    L"#endif //__%s_H__ \n",
    L"\n"
    };

    wstr = wszPostamble[0];

    WCHAR szTemp[1024];
    wsprintf(szTemp, wszPostamble[1], m_szTableInfoDefine);//#endif __wszDefineName_H__
    wstr += szTemp;

    wstr += wszPostamble[2];
}


void TTableInfoGeneration::WriteTableInfoHeaderPreamble(wstring &wstr, wstring &wstrFileName) const
{
    static wchar_t *wszPreamble[]={
    L"//  %s - Table Names and Helper enums and flags.  \n",
    L"//  Generated %02d/%02d/%04d %02d:%02d:%02d by %s \n",
    L"//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved. \n",
    L"\n",
    L"#ifndef __%s_H__  \n",
    L"#define __%s_H__  \n",
    L"\n",
    L"#ifndef _OBJBASE_H_\n",
    L"    #include <objbase.h>\n",
    L"#endif\n",
    L"#ifdef REGSYSDEFNS_DEFINE\n",
    L"    #include <initguid.h>\n",
    L"#endif\n",
    L"\n",
    L"// -----------------------------------------                             \n",
    L"// PRODUCT constants:                                                    \n",
    L"// -----------------------------------------                             \n",
    L"#define WSZ_PRODUCT_IIS			            L\"IIS\"                   \n",
    L"\n",
    L"//The Meta flags exist in two places.  When a new flag is added it needs \n",
    L"//into the following:                                                    \n",
    L"//XMLUtility.h                                                           \n",
    L"//CatMeta.xml                                                            \n",
    L"\n",
    L"//These macros are needed for the metabase\n",
    L"#define SynIDFromMetaFlagsEx(MetaFlagsEx) ((MetaFlagsEx>>2)&0x0F)\n",
    L"#define kInferredColumnMetaFlags   (fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE)\n",
    L"#define kInferredColumnMetaFlagsEx (fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED)\n",
    L"\n",
    L"\n", 0
    };

    WCHAR szTemp[1024];
    int i=0;

    wstr = L"";

    WCHAR szFileName[MAX_PATH];
    _wsplitpath(wstrFileName.c_str(), 0, 0, szFileName, 0);
    wsprintf(szTemp, wszPreamble[i++], szFileName);//Comment includes the filename
    wstr += szTemp;

    SYSTEMTIME time;
    GetLocalTime(&time);
    wsprintf(szTemp, wszPreamble[i++], time.wMonth, time.wDay, time.wYear, time.wHour, time.wMinute, time.wSecond, g_szProgramVersion); //Date Generated line
    wstr += szTemp;

    wstr += wszPreamble[i++];
    wstr += wszPreamble[i++];
    wsprintf(szTemp, wszPreamble[i++], m_szTableInfoDefine);//#ifndef __wszDefineName_H__
    wstr += szTemp;
    wsprintf(szTemp, wszPreamble[i++], m_szTableInfoDefine);//#define __wszDefineName_H__
    wstr += szTemp;

    while(wszPreamble[i])//The rest of the preamble is const strings
        wstr += wszPreamble[i++];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\txmlfile.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TXmlFile
{
public:
    TXmlFile();
    ~TXmlFile();

    void                ConvertWideCharsToBytes(LPCWSTR wsz, unsigned char *pBytes, unsigned long length) const;
    bool                GetNodeValue(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, CComVariant &var, bool bMustExist=true) const;
    bool                GetNodeValue(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, GUID &guid, bool bMustExist=true) const;
    bool                GetNodeValue(IXMLDOMNamedNodeMap *pMap, const CComBSTR &bstr, unsigned long &ul, bool bMustExist=true) const;
    IXMLDOMDocument *   GetXMLDOMDocument() const {return m_pXMLDoc.p;}
    void                GuidFromGuidID(LPCWSTR wszGuidID, GUID &guid) const;
    bool                IsSchemaEqualTo(LPCWSTR szSchema) const;
    bool                NextSibling(CComPtr<IXMLDOMNode> &pNode) const;
    void                Parse(LPCWSTR szFilename, bool bValidate=true);//XML parse and XML validation (validation must be done before IsSchemaEqualTo can be called.
    void                SetAlternateErrorReporting();
    TCHAR *             GetLatestError();

protected:
    CComPtr<IXMLDOMDocument>    m_pXMLDoc;
    TOutput *                   m_errorOutput;
    TOutput *                   m_infoOutput;
    const LPCWSTR               m_szXMLFileName;

private:
    bool                        m_bValidated;
    TScreenOutput               m_outScreen;
    TExceptionOutput            m_outException;
    bool                        m_bAlternateErrorReporting;

    void                CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID * ppv) const;
    void                GetSchema(wstring &wstrSchema) const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\ttableinfogeneration.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TTableInfoGeneration
{
public:
    TTableInfoGeneration(LPCWSTR szFilename, TPEFixup &fixup, TOutput &out);
private:
    TPEFixup      & m_Fixup;
    TOutput       & m_out;
    LPCWSTR         m_szFilename;
    LPCWSTR         m_szTableInfoDefine;

    void GetColumnEnumFromColumnNameAndTagName(LPCWSTR wszTableName, LPCWSTR wszColumnName, LPCWSTR wszTagName, LPWSTR wszEnumName) const;
    void GetColumnFlagFromColumnNameAndTagName(LPCWSTR wszTableName, LPCWSTR wszColumnName, LPCWSTR wszTagName, LPWSTR wszEnumName) const;
    void GetEnumFromColumnName(LPCWSTR wszTableName, LPCWSTR wszColumnName, LPWSTR wszEnumName) const;
    void GetStructElementFromColumnName(ULONG i_Type, LPCWSTR i_wszColumnName, LPWSTR o_szStructElement) const;
    void TableInfoHeaderFromMeta(wstring &header_filename) const;
    void WriteTableInfoHeaderDatabaseIDs(wstring &wstrPreprocessor, wstring &wstrDatabaseIDs) const;
    void WriteTableInfoHeaderEnums(wstring &wstr) const;
    void WriteTableInfoHeaderTableIDs(wstring &wstrPreprocessor, wstring &wstrTableIDs) const;
    void WriteTableInfoHeaderPostamble(wstring &wstr) const;
    void WriteTableInfoHeaderPreamble(wstring &wstr, wstring &wstrFileName) const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\catutil\tschemageneration.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

TSchemaGeneration::TSchemaGeneration(LPCWSTR wszSchemaFilename, TPEFixup &fixup, TOutput &out) :
                m_Fixup(fixup),
                m_out(out),
                m_szComCatDataVersion(L"ComCatData_v6"),
                m_wszSchemaFilename(wszSchemaFilename)
{
    ProcessMetaXML();
}


void TSchemaGeneration::ProcessMetaXML() const
{
    //<?xml version ="1.0"?>
    //<Schema name = "ComCatData_v5"
    //  xmlns="urn:schemas-microsoft-com:xml-data"
    //  xmlns:dt="urn:schemas-microsoft-com:datatypes"
    //  >
    //
    //  <ElementType name = "configuration" content = "eltOnly" order = "many" model="closed">
    //      <element minOccurs = "0"  maxOccurs = "1"  type = "WIRING"/>
    //      <element minOccurs = "0"  maxOccurs = "1"  type = "BASICCLIENTWIRING"/>
    //  </ElementType>
    //</Schema>

    static wchar_t *wszSchemaBeginning[]={
    L"<?xml version =\"1.0\"?>\n",
    L"<Schema name = \"%s\"\n",
    L"  xmlns=\"urn:schemas-microsoft-com:xml-data\"\n",
    L"  xmlns:dt=\"urn:schemas-microsoft-com:datatypes\">\n\n",
    L"  <ElementType name = \"webconfig\" content = \"eltOnly\" order = \"many\" model=\"open\"/>\n",
    0
    };
    static wchar_t *wszSchemaMiddle[]={
    L"  \n\n",
    L"  <ElementType name = \"configuration\" content = \"eltOnly\" order = \"many\" model=\"open\">\n",
    L"      <element minOccurs = \"0\"  maxOccurs = \"1\"  type = \"%s\"/>\n",
    L"      <element minOccurs = \"0\"  maxOccurs = \"*\"  type = \"%s\"/>\n",
    0
    };
    static wchar_t *wszSchemaEnding[]={
    L"      <element minOccurs = \"0\"  maxOccurs = \"1\"  type = \"webconfig\"/>\n",
    L"  </ElementType>\n",
    L"</Schema>\n",
    0
    };

    //<ColumnMetaTable>
    //    <TableMeta      tidGuidID="_BCD79B13-0DDA-11D2-8A9A-00A0C96B9BB4_"  didInternalName="didCOMCLASSIC"     tidInternalName="tidCOMCLASSIC_PROGIDS"/>
    //    <ColumnMeta     colInternalName="ProgID"                            dbType="WSTR"   cbSize="-1"     ColumnMetaFlags="fCOLUMNMETA_PRIMARYKEY"/>
    //    <ColumnMeta     colInternalName="CLSID"                             dbType="GUID"/>
    //</ColumnMetaTable>

    bool                        bAnyTablesXMLable = false;
    wstring                     wstrBeginning;
    wstring                     wstrMiddle;
    wstring                     wstrEnding;
    wchar_t                     wszTemp[1024];

    int i=0;
    wstrBeginning = wszSchemaBeginning[i++];  //<?xml version =\"1.0\"?>
    wsprintf(wszTemp, wszSchemaBeginning[i++], m_szComCatDataVersion);
    wstrBeginning += wszTemp;               //<Schema name = "ComCatData_v5"
    while(wszSchemaBeginning[i])
        wstrBeginning += wszSchemaBeginning[i++];

    wstrMiddle     = wszSchemaMiddle[0];
    wstrMiddle    += wszSchemaMiddle[1];

    wstrEnding    = L"";
    for(i=0; wszSchemaEnding[i]; i++)
        wstrEnding    += wszSchemaEnding[i];

    TTableMeta TableMeta(m_Fixup);
    for(unsigned long iTable=0; iTable < TableMeta.GetCount(); iTable++, TableMeta.Next())
    {
        if(0 == (*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_EMITXMLSCHEMA))
            continue;//No schema gen for this table

        bAnyTablesXMLable = true;

        if(!TableMeta.IsTableMetaOfColumnMetaTable())
            continue;//There is TableMeta for fixed tables that are NOT ColumnMeta AND there is TableMeta that has no columns (for GUID gen only)

        if(0 == (*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_ISCONTAINED))
        {
            ASSERT(0 != TableMeta.Get_PublicName());
            if(*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_NOTSCOPEDBYTABLENAME)
                                       //      <element minOccurs = \"0\"  maxOccurs = \"*\"  type = \"PublicRowName\"/>\n",
                wsprintf(wszTemp, wszSchemaMiddle[3], TableMeta.Get_PublicRowName());//if not encapsulated by the TableName then make maxOccurs="*" and use PublicRowName
            else                       //      <element minOccurs = \"0\"  maxOccurs = \"1\"  type = \"tidCOMCLASSIC_PROGIDS\"/>\n",
                wsprintf(wszTemp, wszSchemaMiddle[2], TableMeta.Get_PublicName());
            wstrMiddle    += wszTemp;
        }

        //Now create a tid*.Schema file for this table
        ProcessMetaTable(TableMeta, wstrBeginning);
    }

    //Only need to create a ComCatData.Schema if one or more tables were flagged as emitXMLSchema
    if(bAnyTablesXMLable)
    {
        wstrBeginning += wstrMiddle;//Cat the Beginning Middle and Ending
        wstrBeginning += wstrEnding;

        TFile(m_wszSchemaFilename, m_out).Write(wstrBeginning, (ULONG) wstrBeginning.length());
        m_out.printf(L"%s Generated.\n", m_wszSchemaFilename);

        m_out.printf(L"Parsing & Validating %s.\n", m_wszSchemaFilename);

        TXmlFile xml;
        xml.Parse(m_wszSchemaFilename, true);
    }
}


void TSchemaGeneration::ProcessMetaTable(TTableMeta &TableMeta, wstring &wstrBeginning) const
{
    ASSERT(TableMeta.IsTableMetaOfColumnMetaTable());//This shouldn't be called unless there are rows in the ColumnMeta table

    //  <ElementType name = "PublicTableName" content = "eltOnly" order = "seq" model="closed">
    //      <element type = "PublicRowName" minOccurs = "0" maxOccurs = "*"/>
    //  </ElementType>
    //  <ElementType name = "PublicRowName" content = "empty" model="closed">
    //      <AttributeType name = "iBTW_TID" dt:type="uuid" required = "yes"/>
    //      <attribute type = "iBTW_TID"/>
    //      <AttributeType name = "iBTW_DTDISPENSER" dt:type="uuid" required = "no"/>
    //      <attribute type = "iBTW_DTDISPENSER"/>
    //      <AttributeType name = "iBTW_DTLOCATOR" dt:type="string" required = "no"/>
    //      <attribute type = "iBTW_DTLOCATOR"/>
    //      <AttributeType name = "iBTW_LTDISPENSER" dt:type="idref" required = "no"/>
    //      <attribute type = "iBTW_LTDISPENSER"/>
    //      <AttributeType name = "iBTW_FLAGS" dt:type="ui4" required = "yes"/>
    //      <attribute type = "iBTW_FLAGS"/>
    //      <AttributeType name = "iBTW_CATSRVIID" dt:type="idref" required = "no"/>
    //      <attribute type = "iBTW_CATSRVIID"/>
    //  </ElementType>

    static wchar_t *wszSchemaBeginning[]={
    L"  <ElementType name = \"%s\" content = \"eltOnly\" order = \"seq\" model=\"closed\">\n",
    L"      <element type = \"%s\" minOccurs = \"0\" maxOccurs = \"*\"/>\n",
    L"  </ElementType>\n",
    L"  <ElementType name = \"%s\" content = \"%s\" order = \"many\" model=\"closed\">\n",
    L"  <ElementType name = \"%s\" content = \"empty\" order = \"seq\" model=\"open\"/>\n",
    L"      <element type = \"%s\" minOccurs = \"0\" maxOccurs = \"1\"/>\n",
    0
    };

    static wchar_t *wszSchemaMiddle[]={
    L"      <AttributeType name = \"%s\" dt:type=\"%s\" required = \"%s\"/><attribute type = \"%s\"/>\n",
	L"      <AttributeType name = \"%s\" dt:type=\"enumeration\" dt:values=\"%s\" required = \"%s\"/><attribute type = \"%s\"/>\n",
	L"      <AttributeType name = \"%s\" dt:type=\"enumeration\" dt:values=\"0 1 False True false true FALSE TRUE No Yes no yes NO YES\" required = \"no\" default=\"0\"/><attribute type = \"%s\"/>\n"
    };

    static wchar_t *wszSchemaEnding[]={
    L"      <element minOccurs = \"0\"  maxOccurs = \"*\"  type = \"%s\"/>\n",
    L"      <element minOccurs = \"0\"  maxOccurs = \"1\"  type = \"%s\"/>\n",
    L"  </ElementType>\n",
    0
    };

    wstring                         wstrMiddle;
    wstring                         wstrEnding;
    wstring                         wstrSparseElement;
    wchar_t                         wszTemp[1024];

    int i=0;

    if(0 == (*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_NOTSCOPEDBYTABLENAME))
    {   //We only have the TableName element if the fTABLEMETA_NOTSCOPEDBYTABLENAME bit is NOT set.
        if(-1 != *TableMeta.Get_PublicRowNameColumn())
        {
            wsprintf(wszTemp, wszSchemaBeginning[4], TableMeta.Get_PublicName());
            wstrBeginning += wszTemp;                              //<ElementType name = \"%s\" content = \"empty\" order = \"seq\" model=\"open\"/>
            return;//This is all we want to do if the table uses and enum as the PublicRowName, since we won't be able to validate it with XML schema.
        }
        wsprintf(wszTemp, wszSchemaBeginning[i++], TableMeta.Get_PublicName());
        wstrBeginning += wszTemp;                              //<ElementType name = "PublicTableName" content = "eltOnly" order = "seq" model="closed">
        ASSERT(0 != TableMeta.Get_PublicRowName());
        wsprintf(wszTemp, wszSchemaBeginning[i++], TableMeta.Get_PublicRowName());
        wstrBeginning += wszTemp;                              //    <element type = "PublicRowName" minOccurs = "0" maxOccurs = "*"/>
#if 0
        if(*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_NAMEVALUEPAIRTABLE)
        {//If this is a name value pair table, it may have a corresponding Sparse table.  If so, we need to declare the GROUP elements here
            TTableMeta TableMetaSparse(m_Fixup);                             //It's OK to compare pointers here since the strings are pooled (like strings have like pointers).
            ULONG iTableMetaSparse;
            for(iTableMetaSparse=0;iTableMetaSparse<TableMetaSparse.GetCount();++iTableMetaSparse,TableMetaSparse.Next())
                if(0 == wcscmp(TableMetaSparse.Get_Database(), L"NAMEVALUE") && TableMetaSparse.Get_PublicName()==TableMeta.Get_PublicName())
                    break;
            if(iTableMetaSparse != TableMetaSparse.GetCount())
            {
                TColumnMeta ColumnMetaSparse(m_Fixup, TableMetaSparse.Get_iColumnMeta() + *TableMetaSparse.Get_PublicRowNameColumn());

                TTagMeta    TagMetaGroupColumn(ColumnMetaSparse.Get_iTagMeta(), m_Fixup);
                for(ULONG iTabMetaGroupColumn=0; iTabMetaGroupColumn<ColumnMetaSparse.Get_ciTagMeta(); ++iTabMetaGroupColumn, TagMetaGroupColumn.Next())
                {
                    wsprintf(wszTemp, wszSchemaBeginning[i], TagMetaGroupColumn.Get_PublicName());//maxOccurs is 1 since the Group is the ONLY primarykey
                    wstrBeginning += wszTemp;                              //    <element type = "EnumPublicRowName" minOccurs = "0" maxOccurs = "1"/>


                    //Now define the element as it's used in the Sparse table
                    wsprintf(wszTemp, wszSchemaBeginning[4], TagMetaGroupColumn.Get_PublicName(), L"empty");//No tables may be contained beneath a Sparse table.
                    wstrSparseElement += wszTemp;

                    //OK, now we need to find out which of the columns may exist within this element.  This is defined by the NameValueMeta.
                    //Those well-known names whose GROUP column equals this enum
                    {
                        //First, figure out which column index represents the NAME column
                        TColumnMeta ColumnMeta(m_Fixup, TableMeta.Get_iColumnMeta());
                        ULONG iGroupColumn = -1;
                        ULONG iNameColumn = -1;
                        ULONG iTypeColumn = -1;
                        for(ULONG iColumn=0; (iNameColumn == -1) && (iGroupColumn == -1) && iColumn<*TableMeta.Get_CountOfColumns(); ++iColumn, ColumnMeta.Next())
                        {
                            if(fCOLUMNMETA_USEASGROUPOFNVPAIR & ColumnMeta.Get_SchemaGeneratorFlags())
                                iGroupColumn = iColumn;
                            if(fCOLUMNMETA_USEASNAMEOFNVPAIR & ColumnMeta.Get_SchemaGeneratorFlags())
                                iNameColumn = iColumn;
                            if(fCOLUMNMETA_USEASTYPEOFNVPAIR & ColumnMeta.Get_SchemaGeneratorFlags())
                                iTypeColumn = iColumn;
                        }

                        TTableMeta TableMeta_WellKnownName(iTableMetaSparse-1, m_Fixup);
                        for(ULONG iRow=0; iRow<TableMeta_WellKnownName.Get_ciRows(); ++iRow)
                        {
                            if(m_Fixup.UI4FromIndex(m_Fixup.aULong[iRow + iGroupColumn]) == *TagMetaGroupColumn.Get_Value())
                            {//If the group column == the value of the current tag, then this well-known name need an attribute declared for it.

                                wsprintf(wszTemp, wszSchemaBeginning[5], TagMetaGroupColumn.Get_PublicName());//maxOccurs is 1 since the Group is the ONLY primarykey

                                for(int iOLEDataType=0;OLEDataTypeToXMLDataType[iOLEDataType].MappedString != 0;iOLEDataType++)
                                {   //map the well-known's type to the XML type
                                    if(OLEDataTypeToXMLDataType[iOLEDataType].dbType == m_Fixup.UI4FromIndex(m_Fixup.aULong[iRow + iTypeColumn]))
                                        break;
                                }
                                ASSERT(OLEDataTypeToXMLDataType[iOLEDataType].MappedString != 0);//we should never make it through the list

                                //<AttributeType name = \"ProgID\" dt:type=\"string\" required = \"no\"/><attribute type = \"ProgID\"/>
                                wsprintf(wszTemp, wszSchemaMiddle[0], TagMetaGroupColumn.Get_PublicName(), OLEDataTypeToXMLDataType[iOLEDataType].MappedString, L"no", TagMetaGroupColumn.Get_PublicName());
                                wstrSparseElement += wszTemp;
                            }
                        }
                    }
                }

                ++i;
            }
        }
#endif
        wstrBeginning += wszSchemaBeginning[i++];                     //</ElementType>
    }
    else
    {
        if(-1 != *TableMeta.Get_PublicRowNameColumn())//EnumPublicRowName that aren't scoped by their table name are ignored and the parent table MUST change the namespace to NULL to turn off validation
            return;
    }

    bool bHasContainment = false;
    //Before we put the end tag, we need to see if there are any tables that are contained under this element.
    //We search the relation meta for foreign keys that point to this table's primary key first, then check that table's MetaFlags for ISCONTAINED
    TRelationMeta RelationMeta(m_Fixup);
    unsigned long iRelationMeta=0;
    for(; iRelationMeta<RelationMeta.GetCount(); ++iRelationMeta, RelationMeta.Next())
    {
        if(RelationMeta.Get_PrimaryTable() == TableMeta.Get_InternalName() && (fRELATIONMETA_USECONTAINMENT & *RelationMeta.Get_MetaFlags()))//No need for string compares, the pointer compare will suffice
        {//If this is our table then we obviously have another table that points to us via foreign key containment.
            TTableMeta ForeignTableMeta(m_Fixup);
            unsigned long iTable=0;
            for(; iTable < ForeignTableMeta.GetCount(); iTable++, ForeignTableMeta.Next())
            {
                if(RelationMeta.Get_ForeignTable() == ForeignTableMeta.Get_InternalName())
                    break;//No need for string compares, the pointer compare will suffice
            }
            ASSERT(iTable < ForeignTableMeta.GetCount());//We should never make it through the list
            ASSERT(0 != (*ForeignTableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_ISCONTAINED));

	        if(-1 == *ForeignTableMeta.Get_PublicRowNameColumn())//EnumPublicRowName can't be validated so don't do anything for them
			{
				bHasContainment = true;

				if(*ForeignTableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_NOTSCOPEDBYTABLENAME)
				{
					if(ForeignTableMeta.Get_PublicRowName())//If EnumPublicRowName then this will be NULL, but the encapsulating element must be namespaced as NULL anyway so it won't be validated
					{
						wsprintf(wszTemp, wszSchemaEnding[0], ForeignTableMeta.Get_PublicRowName());//<element minOccurs = \"0\"  maxOccurs = \"*\"  type = \"PublicRowName\"/>\n",
						wstrEnding += wszTemp;
					}
				}
				else
				{
					wsprintf(wszTemp, wszSchemaEnding[1], ForeignTableMeta.Get_PublicName());//<element minOccurs = \"0\"  maxOccurs = \"1\"  type = \"PublicName\"/>\n",
					wstrEnding += wszTemp;
				}
			}
        }
    }
    //If this table is contained then some of the attributes will be omitted from this table, since they are implied from the PrimaryTable they point to.
    if(*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_ISCONTAINED)
    {
        RelationMeta.Reset();
        for(iRelationMeta=0; iRelationMeta<RelationMeta.GetCount(); ++iRelationMeta, RelationMeta.Next())
        {
            if((fRELATIONMETA_USECONTAINMENT & *RelationMeta.Get_MetaFlags()) && (RelationMeta.Get_ForeignTable() == TableMeta.Get_InternalName()))
                break;
        }
        ASSERT(iRelationMeta<RelationMeta.GetCount() && "Chewbacca!  We didn't find the RelationMeta with this table as the foreign table");
    }//So we stopped on the relationship of interest:  if this table ISCONTAINED then we need the RelationMeta to find out which Attributes DON'T exist at this element


    wstrEnding    += wszSchemaEnding[2];                   //</ElementType>
    wsprintf(wszTemp, wszSchemaBeginning[3], TableMeta.Get_PublicRowName(), bHasContainment ? L"eltOnly" : L"empty");
    wstrBeginning += wszTemp;                              //<ElementType name = "PublicRowName" content = "empty" model="closed">

    wstrMiddle    = L"";

    bool    bColumnMetaFound = false;

    TColumnMeta ColumnMeta(m_Fixup, TableMeta.Get_iColumnMeta());
    for(unsigned long iColumn=0; iColumn < *TableMeta.Get_CountOfColumns(); iColumn++, ColumnMeta.Next())
    {
        //AddAttributeDeclaration(TableMeta, ColumnMeta, RelationMeta, wstrMiddle);

        //If one of the column meta flags indicated is NOTPERSISTABLE then we can bail on this one.
        if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTPERSISTABLE)
            continue;
        if((*TableMeta.Get_SchemaGeneratorFlags() & fTABLEMETA_ISCONTAINED) && (*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_FOREIGNKEY))
        {
            bool bColumnFound = false;
            const ULONG * pForeignColumns = reinterpret_cast<const ULONG *>(RelationMeta.Get_ForeignColumns());
            for(unsigned int i1=0; i1<pForeignColumns[-1]/4 && !bColumnFound; ++i1)//I happen to know that the byte pool store the length (in bytes) as a ULONG preceeding the bytes.
            {
                bColumnFound = (pForeignColumns[i1] == iColumn);
            }
            if(bColumnFound)//If this column is one of the foreign key inferred from containment then move on to the next column
                continue;
        }
        bColumnMetaFound = true;

        for(int iOLEDataType=0;OLEDataTypeToXMLDataType[iOLEDataType].MappedString != 0;iOLEDataType++)
        {
            if(OLEDataTypeToXMLDataType[iOLEDataType].dbType == *ColumnMeta.Get_Type())
                break;
        }
        ASSERT(OLEDataTypeToXMLDataType[iOLEDataType].MappedString != 0);//we should never make it through the list

        //<AttributeType name = \"ProgID\" dt:type=\"string\" required = \"no\"/><attribute type = \"ProgID\"/>
        if(*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_ENUM)
        {
            wstring wstrEnumValues;
            unsigned int cTags=ColumnMeta.Get_ciTagMeta();

            TTagMeta TagMeta(m_Fixup, ColumnMeta.Get_iTagMeta());

            while(cTags--)//This builds a string of the enums separated by a space
            {
                wstrEnumValues += TagMeta.Get_PublicName();
                wstrEnumValues += L" ";
                TagMeta.Next();
            }

            wsprintf(wszTemp, wszSchemaMiddle[1], ColumnMeta.Get_PublicName(), wstrEnumValues.c_str(), ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue()) ? L"yes" : L"no", ColumnMeta.Get_PublicName());
            wstrMiddle += wszTemp;
        }
        else if(*ColumnMeta.Get_MetaFlags() & (fCOLUMNMETA_FLAG | fCOLUMNMETA_BOOL))
        {
            wsprintf(wszTemp, wszSchemaMiddle[0], ColumnMeta.Get_PublicName(), L"string", ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue()) ? L"yes" : L"no", ColumnMeta.Get_PublicName());
            wstrMiddle += wszTemp;
        }
        else
        {
            wsprintf(wszTemp, wszSchemaMiddle[0], ColumnMeta.Get_PublicName(), OLEDataTypeToXMLDataType[iOLEDataType].MappedString, OLEDataTypeToXMLDataType[iOLEDataType].bImplicitlyRequired || ((*ColumnMeta.Get_MetaFlags() & fCOLUMNMETA_NOTNULLABLE) && 0==ColumnMeta.Get_DefaultValue()) ? L"yes" : L"no", ColumnMeta.Get_PublicName());
            wstrMiddle += wszTemp;
        }

    }
    if(!bColumnMetaFound)
    {
        if(bHasContainment)
            m_out.printf(L"Warning! Emit XML Schema was specified but no column meta found for '%s'.\r\n",
                        TableMeta.Get_PublicName());
        else
        {
            m_out.printf(L"Emit XML Schema was specified but no column meta found for '%s'.  At least one persistable column must exist in uncontained tables.\r\n",
                        TableMeta.Get_PublicName());
            THROW(Emit XML Schema was set but no ColumnMeta found.);
        }
    }

    wstrBeginning += wstrMiddle;
    wstrBeginning += wstrEnding;
    wstrBeginning += wstrSparseElement;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\dispenser\cshell.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name:
    cshell.cpp

$Header: $

--**************************************************************************/

#include "precomp.hxx"

#define cmaxCOLUMNMETACOLUMNS	15
#define cmaxCOLUMNMETAROWS		100

// ==================================================================
CSTShell::CSTShell ()
	: m_cRef (0)
	, m_bInitialized (0)
	, m_fLOS (0)
	, m_pWrite (NULL)
	, m_pController (NULL)
	, m_pInterceptorPlugin (NULL)
	, m_pReadPlugin (NULL)
	, m_pWritePlugin (NULL)
{
}

// ==================================================================
CSTShell::~CSTShell ()
{
	if (m_pInterceptorPlugin)
		m_pInterceptorPlugin->Release();

	if (m_pWritePlugin)
		m_pWritePlugin->Release();

	if (m_pReadPlugin)
		m_pReadPlugin->Release();

	if (m_pWrite)
		m_pWrite->Release();

	if (m_pController)
		m_pController->Release();
}

// ------------------------------------
// ISimpleTableInterceptor
// ------------------------------------

// ==================================================================
STDMETHODIMP CSTShell::Initialize
(
	LPCWSTR					i_wszDatabase,
	LPCWSTR 				i_wszTable,
	ULONG   				i_TableID,
	LPVOID					i_QueryData,
	LPVOID					i_QueryMeta,
	DWORD					i_eQueryFormat,
	DWORD					i_fLOS,
	IAdvancedTableDispenser* i_pISTDisp,
	LPCWSTR					i_wszLocator,
	LPVOID					i_pv,
	IInterceptorPlugin*		i_pInterceptorPlugin,
	ISimplePlugin*			i_pReadPlugin,
	ISimplePlugin*			i_pWritePlugin,
	LPVOID*					o_ppv
)
{
	HRESULT					hr;
	HRESULT					hrInterceptor = S_OK;

	// At least one plugin needs to be specified
	if(!(i_pInterceptorPlugin || i_pReadPlugin || i_pWritePlugin)) return E_INVALIDARG;

	m_spDispenser = i_pISTDisp;
	// Get the pointer to the undelying cache
	if(i_pInterceptorPlugin)
	{
		hr = i_pInterceptorPlugin->Intercept(i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta,
				i_eQueryFormat, i_fLOS, i_pISTDisp, i_wszLocator, i_pv, (LPVOID *)&m_pWrite);
		if( (FAILED(hr)) && (E_ST_OMITLOGIC != hr))
			return hr;
		else
			hrInterceptor = hr;
	}
	else
	{	// i.e No interceptor plugin, this means we have to wire ourselfs on top of
		// the provided table
		if (NULL == i_pv) return E_INVALIDARG;
		m_pWrite = (ISimpleTableWrite2 *)i_pv;
	}

	hr = m_pWrite->QueryInterface(IID_ISimpleTableController, (LPVOID *)&m_pController);
	if(FAILED(hr)) return hr;
	ASSERT( hr == S_OK );
	// TODO what to do if we have an underlying table that doesn't implement all the interfaces?

	// Save the plugins for later use
	m_pInterceptorPlugin = i_pInterceptorPlugin;
	if(m_pInterceptorPlugin) m_pInterceptorPlugin->AddRef(); // the dispenser just passes the plugins in, we need to do an addref

	m_pReadPlugin = i_pReadPlugin;
	if(m_pReadPlugin) m_pReadPlugin->AddRef();

	m_pWritePlugin = i_pWritePlugin;
	if(m_pWritePlugin) m_pWritePlugin->AddRef();

	// Save did and tid and LOS
	m_wszDatabase = i_wszDatabase;
	m_wszTable    = i_wszTable;

    //ToDo:  We might be given a TableID instead of Database and TableName, if so we should get them from TFixedPackedSchemaInterceptor
	m_fLOS        = i_fLOS;

	// Returned a pointer to us since we are a table
	InterlockedIncrement((LONG *)&m_bInitialized);
	*o_ppv = (ISimpleTableWrite2 *)this;
	AddRef();

	return hrInterceptor;
}


// ------------------------------------
// ISimpleTableRead2
// ------------------------------------

// ==================================================================
STDMETHODIMP CSTShell::GetRowIndexByIdentity (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
	return m_pWrite->GetRowIndexByIdentity (i_acbSizes, i_apvValues, o_piRow);
}
STDMETHODIMP CSTShell::GetRowIndexBySearch(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
	return m_pWrite->GetRowIndexBySearch(i_iStartingRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues, o_piRow);
}
STDMETHODIMP CSTShell::GetColumnValues (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
	return m_pWrite->GetColumnValues (i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
}
STDMETHODIMP CSTShell::GetTableMeta (ULONG* o_pcVersion, DWORD* o_pfTable, ULONG* o_pcRows, ULONG* o_pcColumns )
{
	return m_pWrite->GetTableMeta (o_pcVersion, o_pfTable, o_pcRows, o_pcColumns);
}
STDMETHODIMP CSTShell::GetColumnMetas (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas )
{
	return m_pWrite->GetColumnMetas (i_cColumns, i_aiColumns, o_aColumnMetas);
}

// ------------------------------------
// ISimpleTableWrite2
// ------------------------------------

// ==================================================================
STDMETHODIMP CSTShell::AddRowForDelete (ULONG i_iReadRow)
{
	return m_pWrite->AddRowForDelete (i_iReadRow);
}
STDMETHODIMP CSTShell::AddRowForInsert (ULONG* o_piWriteRow)
{
	return m_pWrite->AddRowForInsert (o_piWriteRow);
}
STDMETHODIMP CSTShell::AddRowForUpdate (ULONG i_iReadRow, ULONG* o_piWriteRow)
{
	return m_pWrite->AddRowForUpdate (i_iReadRow, o_piWriteRow);
}
STDMETHODIMP CSTShell::SetWriteColumnValues (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues)
{
	return m_pWrite->SetWriteColumnValues (i_iRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues);
}
STDMETHODIMP CSTShell::GetWriteColumnValues (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
	return m_pWrite->GetWriteColumnValues (i_iRow, i_cColumns, i_aiColumns, o_afStatus, o_acbSizes, o_apvValues);
}

STDMETHODIMP CSTShell::GetWriteRowIndexBySearch(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
	return m_pWrite->GetWriteRowIndexBySearch(i_iStartingRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues, o_piRow);
}

STDMETHODIMP CSTShell::GetErrorTable(DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable)
{
    return m_pWrite->GetErrorTable(i_fServiceRequests, o_ppvSimpleTable);
}

// ==================================================================
STDMETHODIMP CSTShell::UpdateStore ()
{
	HRESULT hr;
	DWORD eAction;
	ULONG iRow;
	BOOL  fHasDetailedError = FALSE;

	ASSERT(m_bInitialized);

	if(m_pWritePlugin)
	{
		for(iRow = 0; ; iRow++)
		{
			// Get the ro action
			hr = m_pController->GetWriteRowAction(iRow, &eAction);
			if(hr == E_ST_NOMOREROWS)
			{
				hr = S_OK;
				break;
			}

			switch(eAction)
			{
			// call the appropriate plugin function
			case eST_ROW_INSERT:
				hr = m_pWritePlugin->OnInsert(m_spDispenser, m_wszDatabase, m_wszTable, m_fLOS, iRow, m_pWrite);
			break;
			case eST_ROW_UPDATE:
				hr = m_pWritePlugin->OnUpdate(m_spDispenser, m_wszDatabase, m_wszTable, m_fLOS, iRow, m_pWrite);
			break;
			case eST_ROW_DELETE:
				hr = m_pWritePlugin->OnDelete(m_spDispenser, m_wszDatabase, m_wszTable, m_fLOS, iRow, m_pWrite);
			break;
			default:
				ASSERT (eAction == eST_ROW_IGNORE);
			}

			if (FAILED (hr))
			{	// Add detailed error
				STErr ste;

				ste.iColumn = (ULONG)iST_ERROR_ALLCOLUMNS;
				ste.iRow = iRow;
				ste.hr = hr;

                DBGPRINTF(( DBG_CONTEXT,
				            "Detailed error: hr = 0x%x", hr ));

				m_pController->AddDetailedError (&ste);
				fHasDetailedError = TRUE;
			}
		}
		if (fHasDetailedError)
		{
            DBGPRINTF(( DBG_CONTEXT,
			            "Detailed errors found during validation using WritePlugin" ));
			return E_ST_DETAILEDERRS;
		}
	}



	if(m_pInterceptorPlugin)
	{
		hr = m_pInterceptorPlugin->OnUpdateStore (m_pWrite);
	}
	else
	{
		hr = m_pWrite->UpdateStore ();
	}

	if (SUCCEEDED(hr) && fHasDetailedError)
	{
		hr = E_ST_DETAILEDERRS ;
	}

	return hr;
}

// ------------------------------------
// ISimpleTableAdvanced:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSTShell::PopulateCache()
{
	HRESULT hr;
	ULONG iRow;
	BOOL fHasDetailedError = FALSE;

	ASSERT(m_bInitialized);

	if (m_pInterceptorPlugin)
	{
		hr = m_pInterceptorPlugin->OnPopulateCache (m_pWrite);
		if(FAILED(hr)) return hr;
	}
	else
	{
		hr = m_pController->PopulateCache();
		if(FAILED(hr)) return hr;
	}

	if (m_pReadPlugin)
	{
		ULONG cRows;

		hr = m_pWrite->GetTableMeta(NULL, NULL, &cRows, NULL);
		if(FAILED(hr)) return hr;

		hr = m_pController->PrePopulateCache(fST_POPCONTROL_RETAINREAD);
		if(FAILED(hr)) return hr;

		// Iterate the rows in the read cache
		for(iRow = 0; iRow < cRows; iRow++)
		{
			hr = m_pReadPlugin->OnInsert(m_spDispenser, m_wszDatabase, m_wszTable, m_fLOS, iRow, m_pWrite);
			if (FAILED (hr))
			{	// Add detailed error
				STErr ste;

				ste.iColumn = (ULONG)iST_ERROR_ALLCOLUMNS;
				ste.iRow = iRow;
				ste.hr = hr;

				m_pController->AddDetailedError (&ste);
				fHasDetailedError = TRUE;
			}
		}

		hr = m_pController->PostPopulateCache();
	}

	if (SUCCEEDED(hr) && fHasDetailedError)
	{
		hr = E_ST_DETAILEDERRS;
	}

	return hr;
}

// ==================================================================
STDMETHODIMP CSTShell::GetWriteRowIndexByIdentity (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
	return m_pWrite->GetWriteRowIndexByIdentity (i_acbSizes, i_apvValues, o_piRow);
}
STDMETHODIMP CSTShell::GetDetailedErrorCount	(ULONG* o_pcErrs)
{
	return m_pController->GetDetailedErrorCount	(o_pcErrs);
}
STDMETHODIMP CSTShell::GetDetailedError (ULONG i_iErr, STErr* o_pSTErr)
{
	return m_pController->GetDetailedError (i_iErr, o_pSTErr);
}
STDMETHODIMP CSTShell::ResetCaches ()
{
	return m_pController->ResetCaches ();
}

STDMETHODIMP CSTShell::GetColumnValuesEx (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
	return m_pController->GetColumnValuesEx (i_iRow, i_cColumns, i_aiColumns, o_afStatus, o_acbSizes, o_apvValues);
}


// ------------------------------------
// ISimpleTableController:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSTShell::ShapeCache (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes)
{
	return m_pController->ShapeCache (i_fTable, i_cColumns, i_acolmetas, i_apvDefaults, i_acbSizes);
}
STDMETHODIMP CSTShell::PrePopulateCache (DWORD i_fControl)
{
	return m_pController->PrePopulateCache (i_fControl);
}
STDMETHODIMP CSTShell::PostPopulateCache	()
{
	return m_pController->PostPopulateCache();
}
STDMETHODIMP CSTShell::DiscardPendingWrites ()
{
	return m_pController->DiscardPendingWrites ();
}
STDMETHODIMP CSTShell::GetWriteRowAction	(ULONG i_iRow, DWORD* o_peAction)
{
	return m_pController->GetWriteRowAction	(i_iRow, o_peAction);
}
STDMETHODIMP CSTShell::SetWriteRowAction	(ULONG i_iRow, DWORD i_eAction)
{
	return m_pController->SetWriteRowAction	(i_iRow, i_eAction);
}
STDMETHODIMP CSTShell::ChangeWriteColumnStatus (ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus)
{
	return m_pController->ChangeWriteColumnStatus (i_iRow, i_iColumn, i_fStatus);
}
STDMETHODIMP CSTShell::AddDetailedError (STErr* o_pSTErr)
{
	return m_pController->AddDetailedError (o_pSTErr);
}
STDMETHODIMP CSTShell::GetMarshallingInterface (IID * o_piid, LPVOID * o_ppItf)
{
	return m_pController->GetMarshallingInterface (o_piid, o_ppItf);
}

// ==================================================================
// helper function that gets an instance of this object
HRESULT CreateShell(IShellInitialize ** o_pSI)
{
	CSTShell*			p1 = NULL;

	p1 = new CSTShell;
	if(NULL == p1) return E_OUTOFMEMORY;
	return p1->QueryInterface (IID_IShellInitialize, (LPVOID*) o_pSI);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\dispenser\cshell.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    cshell.h

$Header: $

--**************************************************************************/

#pragma once

class CSTShell:
	public ISimpleTableWrite2,
	public ISimpleTableController,
	public IShellInitialize
{
public:
	// IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release) 		();

	// ISimpleTableShellInitializer
	STDMETHOD (Initialize) (LPCWSTR	i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	i_eQueryFormat,
						DWORD i_fTable, IAdvancedTableDispenser* i_pISTDisp, LPCWSTR i_wszLocator, LPVOID i_pv, IInterceptorPlugin * i_pInterceptorPlugin,
						ISimplePlugin * i_pReadPlugin, ISimplePlugin * i_pWritePlugin, LPVOID * o_ppv);

	// ISimpleTableRead2
	STDMETHOD (GetRowIndexByIdentity) (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
	STDMETHOD (GetColumnValues) (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues);
	STDMETHOD (GetTableMeta) (ULONG* o_pcVersion, DWORD* o_pfTable, ULONG* o_pcRows, ULONG* o_pcColumns );
	STDMETHOD (GetColumnMetas)	(ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas );

	// ISimpleTableWrite2 
	STDMETHOD (AddRowForDelete) (ULONG i_iReadRow);
	STDMETHOD (AddRowForInsert) (ULONG* o_piWriteRow);
	STDMETHOD (AddRowForUpdate) (ULONG i_iReadRow, ULONG* o_piWriteRow);
	STDMETHOD (SetWriteColumnValues) (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues);
	STDMETHOD (GetWriteColumnValues) (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, 
										DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues);
	STDMETHOD (GetWriteRowIndexByIdentity) (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
	STDMETHOD (GetWriteRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetErrorTable)(DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable);

	STDMETHOD (UpdateStore) ();
	
	// ISimpleTableAdvanced:
	STDMETHOD (PopulateCache) ();
	STDMETHOD (GetDetailedErrorCount) (ULONG* o_pcErrs);
	STDMETHOD (GetDetailedError) (ULONG i_iErr, STErr* o_pSTErr);
	STDMETHOD (ResetCaches) ();
    STDMETHOD (GetColumnValuesEx) (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues);

	// ISimpleTableController:
	STDMETHOD (ShapeCache) (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes);
	STDMETHOD (PrePopulateCache) (DWORD i_fControl);
	STDMETHOD (PostPopulateCache)	();
	STDMETHOD (DiscardPendingWrites) ();
	STDMETHOD (GetWriteRowAction)	(ULONG i_iRow, DWORD* o_peAction);
	STDMETHOD (SetWriteRowAction)	(ULONG i_iRow, DWORD i_eAction);
	STDMETHOD (ChangeWriteColumnStatus) (ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus);
	STDMETHOD (AddDetailedError) (STErr* o_pSTErr);
	STDMETHOD (GetMarshallingInterface) (IID * o_piid, LPVOID * o_ppItf);

public:
	CSTShell ();
	~CSTShell ();

private:
	ULONG   m_cRef;
	DWORD   m_bInitialized;
	LPCWSTR m_wszDatabase;
	LPCWSTR m_wszTable;
	DWORD	m_fLOS;

	CComPtr<ISimpleTableDispenser2> m_spDispenser;
	ISimpleTableWrite2 *m_pWrite;
	ISimpleTableController *m_pController;
	IInterceptorPlugin *m_pInterceptorPlugin;
	ISimplePlugin *m_pReadPlugin;
	ISimplePlugin *m_pWritePlugin;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\dispenser\cstdispqi.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name:
    cstdispqi.cpp

$Header: $

Abstract:

--**************************************************************************/

#include "precomp.hxx"

// -----------------------------------------
// CSimpleTableDispenser: IUnknown
// -----------------------------------------
// =======================================================================
STDMETHODIMP CSimpleTableDispenser::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv)
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_IUnknown)
	{
		*ppv = (ISimpleTableDispenser2*) this;
	}
	if (riid == IID_IAdvancedTableDispenser)
	{
		*ppv = (IAdvancedTableDispenser*) this;
	}
	else if (riid == IID_ISimpleTableDispenser2)
	{
		*ppv = (ISimpleTableDispenser2*) this;
	}
	else if (riid == IID_ISimpleTableFileAdvise)
	{
		*ppv = (ISimpleTableFileAdvise*) this;
	}
	else if (riid == IID_IMetabaseSchemaCompiler)
	{
//@@@Put this in when the dispenser does the right thing        if(0 == wcsicmp(m_wszProductID, WSZ_PRODUCT_IIS))//This interface is only supported on the IIS catalog
			*ppv = (IMetabaseSchemaCompiler*) this;
	}
	else if (riid == IID_ICatalogErrorLogger)
	{
			*ppv = (ICatalogErrorLogger*) this;
	}

	if (NULL != *ppv)
	{
		((ISimpleTableDispenser2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

// =======================================================================
STDMETHODIMP_(ULONG) CSimpleTableDispenser::AddRef()
{
	// this is a singleton
	return 1;
}

// =======================================================================
STDMETHODIMP_(ULONG) CSimpleTableDispenser::Release()
{
	// this is a singleton
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\dispenser\cstdisp.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#pragma once

// Pointer to DllGetSimpleObject kind of functions
typedef HRESULT( __stdcall *PFNDllGetSimpleObjectByID)( ULONG, REFIID, LPVOID);

/*
// WT -wiring type constants
// these specify wether the object should be wired on read or write scenarios
// Are used in combination with OT constants
#define eST_WT_WRITEONLY		0x00000000 //default
#define eST_WT_READWRITE		0x00000001

// Interceptor types
#define eST_INTERCEPTOR_FIRST	0x00000001
#define eST_INTERCEPTOR_NEXT	0x00000002
*/

// Dumb map between dll names and pointers to their dllgetsimpleobject
// It does not grow, and it does not do hashing
// Add is not thread safe, GetProcAddress is.
// Should be good enough though

// Helper structure for passing in the primary key for the server wiring table
typedef struct tagPKHelper
{
	ULONG  *pTableID;
	ULONG  *porder;
} PKHelper;


// The simple table dispenser class
class CSimpleTableDispenser :
    public IAdvancedTableDispenser,
    public IMetabaseSchemaCompiler,
	public ICatalogErrorLogger,
	public ISimpleTableFileAdvise
{
private:
    CSimpleTableDispenser(const CSimpleTableDispenser&);

//IUnknown
public:
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

// ISimpleTableDispenser2 (IAdvancedTableDispenser derives from ISimpleTableDispenser2)
public:
	STDMETHOD (GetTable)	(
							/*[in]*/ LPCWSTR			i_wszDatabase,
							/*[in]*/ LPCWSTR			i_wszTable,
							/*[in]*/ LPVOID				i_QueryData,
							/*[in]*/ LPVOID				i_QueryMeta,
							/*[in]*/  DWORD				i_eQueryFormat,
							/*[in]*/ DWORD				i_fServiceRequests,
							/*[out]*/ LPVOID*			o_ppIST
							);


//IAdvancedTableDispenser
public:
    STDMETHOD (GetMemoryTable)  (
							/*[in]*/	LPCWSTR					i_wszDatabase,
                            /*[in]*/    LPCWSTR                 i_wszTable,
							/*[in]*/	ULONG					i_TableID,
                            /*[in]*/    LPVOID                  i_QueryData,
                            /*[in]*/    LPVOID                  i_QueryMeta,
                            /*[in]*/    DWORD                   i_eQueryFormat,
                            /*[in]*/    DWORD                   i_fServiceRequests,
                            /*[out]*/   ISimpleTableWrite2**    o_ppISTWrite
                            );
    STDMETHOD (GetProductID)   (
                            /*[out]*/       LPWSTR				o_wszProductID,
                            /*[in, out]*/   DWORD * 			io_pcchProductID
                            );
    STDMETHOD (GetCatalogErrorLogger)   (
                            /*[out]*/ ICatalogErrorLogger2 **	o_ppErrorLogger
                            );
    STDMETHOD (SetCatalogErrorLogger)   (
                            /*[in]*/  ICatalogErrorLogger2 *	i_pErrorLogger
                            );

//IMetabaseSchemaCompiler
public:
    STDMETHOD (Compile)     (
                            /*[in]*/ LPCWSTR                 i_wszExtensionsXmlFile,
                            /*[in]*/ LPCWSTR                 i_wszResultingOutputXmlFile
                            );
    STDMETHOD (GetBinFileName)(
                            /*[out]*/ LPWSTR                  o_wszBinFileName,
                            /*[out]*/ ULONG *                 io_pcchSizeBinFileName
                            );
    STDMETHOD (SetBinPath)  (
                            /*[in]*/ LPCWSTR                 i_wszBinPath
                            );
    STDMETHOD (ReleaseBinFileName)(
							/*[in]*/ LPCWSTR                 i_wszBinFileName
							);

//ICatalogErrorLogger
    STDMETHOD (LogError)    (
                            /*[in]*/ HRESULT                 i_hrErrorCode,
                            /*[in]*/ ULONG                   i_ulCategory,
                            /*[in]*/ ULONG                   i_ulEvent,
                            /*[in]*/ LPCWSTR                 i_szSource,
                            /*[in]*/ ULONG                   i_ulLineNumber
                            );

// ISimpleTableFileAdvise
public:
	STDMETHOD(SimpleTableFileAdvise)(ISimpleTableFileChange	*i_pISTFile, LPCWSTR i_wszDirectory, LPCWSTR i_wszFile, DWORD i_fFlags, DWORD *o_pdwCookie);
	STDMETHOD(SimpleTableFileUnadvise)(DWORD i_dwCookie);

// Class methods
public:
    CSimpleTableDispenser();
    CSimpleTableDispenser(LPCWSTR wszProductID);
    ~CSimpleTableDispenser();
	HRESULT Init();
	static HRESULT GetFilePath(LPWSTR *o_pwszFilePath);

private:
	HRESULT CreateSimpleObjectByID(ULONG i_ObjectID, LPWSTR i_wszDllName, REFIID riid, LPVOID* o_ppv);
	HRESULT CreateTableObjectByID(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat,
				  DWORD	i_fServiceRequests, LPVOID i_pUnderTable, tSERVERWIRINGMETARow * pSWColumns, LPVOID * o_ppIST);
	HRESULT GetMetaTable(ULONG TableID, LPVOID QueryData, LPVOID QueryMeta, DWORD eQueryFormat, LPVOID *ppIST);
    HRESULT GetXMLTable ( LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	 i_eQueryFormat, DWORD	i_fServiceRequests, LPVOID*	o_ppIST);
    HRESULT HardCodedIntercept(eSERVERWIRINGMETA_Interceptor interceptor, LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	 i_eQueryFormat,
				  DWORD	i_fServiceRequests, LPVOID*	o_ppIST) const;
	HRESULT InitFileChangeMgr();
    HRESULT InternalGetTable( LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	 i_eQueryFormat,
				  DWORD	i_fServiceRequests, LPVOID*	o_ppIST);
	HRESULT IsTableConsumedByID(ULONG TableID);

	CComPtr<ISimpleTableRead2>	m_spClientWiring;
	CComPtr<ISimpleTableRead2>	m_spServerWiring;

	CSTFileChangeManager *m_pFileChangeMgr;

    WCHAR               m_wszProductID[32];//TO DO: We need to document that ProductID must be no longer than 31 characters
    TMBSchemaCompilation m_MBSchemaCompilation;
    CComPtr<ICatalogErrorLogger2> m_spErrorLogger;

	// we are trying to keep the workingset to a minimum.
	// When possible, don't add member variables to the dispenser

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\dispenser\cshellqi.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.

#include "precomp.hxx"

// -----------------------------------------
// CSTShell: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP CSTShell::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv)
		return E_INVALIDARG;
	*ppv = NULL;

	if (!m_bInitialized) // ie: Component is posing as class factory / dispenser:
	{
		if (riid == IID_IShellInitialize)
		{
			*ppv = (IShellInitialize*) this;
		}
		else if (riid == IID_ISimpleTableInterceptor)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
		else if (riid == IID_IUnknown)
		{
			*ppv = (IShellInitialize*) this;
		}
	}
	else // ie: Component is currently posing as data table:
	{
		if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableRead2)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableWrite2)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableController)
		{
			*ppv = (ISimpleTableController*) this;
		}
		else if (riid == IID_ISimpleTableAdvanced)
		{
			*ppv = (ISimpleTableAdvanced*) this;
		}
	}
	if (NULL != *ppv)
	{
		((ISimpleTableWrite2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}
STDMETHODIMP_(ULONG) CSTShell::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);

}
STDMETHODIMP_(ULONG) CSTShell::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\dispenser\cstdisp.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name:
    cstdisp.cpp

$Header: $

Abstract:

--**************************************************************************/

#include "precomp.hxx"

// TO DO tracing
// TO DO ISSUE :the dispenser for sdtfxd should be singleton
// TO DO E_ST_OMITDISPENSER is not used corectly
// TO DO Revisit where the notification support gets hooked

// extern functions
STDAPI DllGetSimpleObjectByID (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv);
extern HRESULT CreateShell(IShellInitialize ** o_pSI);

// the lock used by catalog.dll
extern CSafeAutoCriticalSection g_csSADispenser;

#define WIRING_INTERCEPTOR	eSERVERWIRINGMETA_Core_FixedPackedInterceptor
#define META_INTERCEPTOR	eSERVERWIRINGMETA_Core_FixedPackedInterceptor
#define MEMORY_INTERCEPTOR	eSERVERWIRINGMETA_Core_MemoryInterceptor
#define XML_INTERCEPTOR	    eSERVERWIRINGMETA_Core_XMLInterceptor

//Hashing is done on a case insensitive basis, so this ToLower function uses a lookup table to convert a wide char to its lowercase version without
//the need for an 'if' condition.
inline WCHAR ToUpper(WCHAR i_wchar)
{
    //The lower 127 ascii are mapped to their lowercase ascii value.  Note only 0x41('A') - 0x5a('Z') are changed.  And these are mapped to 0x60('a') - 0x7a('z')
    static unsigned char kToUpper[128] =
    { //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
    /*00*/  0x00,   0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,   0x09,   0x0a,   0x0b,   0x0c,   0x0d,   0x0e,   0x0f,
    /*10*/  0x10,   0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,   0x19,   0x1a,   0x1b,   0x1c,   0x1d,   0x1e,   0x1f,
    /*20*/  0x20,   0x21,   0x22,   0x23,   0x24,   0x25,   0x26,   0x27,   0x28,   0x29,   0x2a,   0x2b,   0x2c,   0x2d,   0x2e,   0x2f,
    /*30*/  0x30,   0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,   0x39,   0x3a,   0x3b,   0x3c,   0x3d,   0x3e,   0x3f,
    /*40*/  0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,   0x4a,   0x4b,   0x4c,   0x4d,   0x4e,   0x4f,
    /*50*/  0x50,   0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,   0x5a,   0x5b,   0x5c,   0x5d,   0x5e,   0x5f,
    /*60*/  0x60,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,   0x4a,   0x4b,   0x4c,   0x4d,   0x4e,   0x4f,
    /*70*/  0x50,   0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,   0x5a,   0x7b,   0x7c,   0x7d,   0x7e,   0x7f,
    };

    return (kToUpper[i_wchar & 0x007f] | (i_wchar & ~0x007f));
}

void ToUpper(LPWSTR o_wsz)
{
    if(0 == o_wsz)
        return;

    while(*o_wsz)
    {
        *o_wsz = ToUpper(*o_wsz);
        ++o_wsz;
    }
}


extern LPWSTR g_wszDefaultProduct;//located in svcerr.cpp

//////////////////////////////////////////////////
// Constructor & destructor
//////////////////////////////////////////////////
CSimpleTableDispenser::CSimpleTableDispenser():
m_pFileChangeMgr(NULL)
{
    wcscpy(m_wszProductID, g_wszDefaultProduct);
}

CSimpleTableDispenser::CSimpleTableDispenser(LPCWSTR wszProductID):
m_pFileChangeMgr(NULL)
{
    if(wszProductID && wcslen(wszProductID)<32)
    {
        wcscpy(m_wszProductID, wszProductID);
        ToUpper(m_wszProductID);
    }
    else
        wcscpy(m_wszProductID, g_wszDefaultProduct);
}

CSimpleTableDispenser::~CSimpleTableDispenser()
{
	delete m_pFileChangeMgr;
	m_pFileChangeMgr = 0;
}

// Dispenser initialization function, called once per process
// It is protected by a lock in the one place it's called
HRESULT CSimpleTableDispenser::Init()
{
	HRESULT hr;
	CComPtr <ISimpleTableInterceptor> pISTInterceptor;
	CComPtr <ISimpleTableAdvanced> pISTAdvanced;

	// Get the server wiring table
	hr = DllGetSimpleObjectByID(WIRING_INTERCEPTOR, IID_ISimpleTableInterceptor, (LPVOID *)(&pISTInterceptor));
	if (FAILED (hr)) return hr;

	hr = pISTInterceptor->Intercept (NULL, NULL, TABLEID_SERVERWIRING_META, NULL, 0, eST_QUERYFORMAT_CELLS, 0, (IAdvancedTableDispenser*) this, NULL, NULL, (LPVOID *)&m_spServerWiring);
	if (FAILED (hr)) return hr;

	hr = m_spServerWiring->QueryInterface(IID_ISimpleTableAdvanced, (LPVOID *)&pISTAdvanced);
	if (FAILED (hr)) return hr;

	hr = pISTAdvanced->PopulateCache();
	if (FAILED (hr)) return hr;

	return hr;
}

// Initialization functions
// All of them take locks inside
HRESULT CSimpleTableDispenser::InitFileChangeMgr()
{
	CSafeLock dispenserLock (&g_csSADispenser);
	DWORD dwRes = dispenserLock.Lock ();
	if(ERROR_SUCCESS != dwRes)
	{
	   return HRESULT_FROM_WIN32(dwRes);
	}

	if(!m_pFileChangeMgr)
	{
		m_pFileChangeMgr = new CSTFileChangeManager;
		if(!m_pFileChangeMgr)
			return E_OUTOFMEMORY;
	}

	return S_OK;
}

//////////////////////////////////////////////////
// Implementation of ISimpleTableDispenser2
//////////////////////////////////////////////////
 HRESULT CSimpleTableDispenser::GetTable ( LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	 i_eQueryFormat,
				  DWORD	i_fServiceRequests, LPVOID*	o_ppIST)
{
	ULONG TableID;

	// Validate table and database - rest of the validation is done further down
	if (NULL == i_wszDatabase ) return E_INVALIDARG;
	if (NULL == i_wszTable ) return E_INVALIDARG;

	if (o_ppIST == 0)
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "Bad out parameter" ));
		return E_INVALIDARG;
	}

	*o_ppIST = 0;

	if (i_eQueryFormat != 0 && i_eQueryFormat != eST_QUERYFORMAT_CELLS && i_eQueryFormat != eST_QUERYFORMAT_SQL)
		return E_ST_QUERYNOTSUPPORTED;

    if(0 == _wcsicmp(i_wszDatabase, wszDATABASE_META))
    {
        if(i_fServiceRequests & fST_LOS_EXTENDEDSCHEMA)
        {
			// we do not support extended schemas anymore
			return E_ST_LOSNOTSUPPORTED;

			//Extended schema always comes from the MetaMerge interceptor (which in turn gets the meta from the Fixed interceptor)
            //return HardCodedIntercept(eSERVERWIRINGMETA_Core_MetaMergeInterceptor, i_wszDatabase, i_wszTable, 0, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, o_ppIST);
        }
        else if((0 == i_QueryMeta || 0 == *reinterpret_cast<ULONG *>(i_QueryMeta)))
        {   //The FixedPackedSchema interceptor handles TableMeta without a query; but ALL other META tables without a query need to be directed to the FixedInterceptor
            if(0==_wcsicmp(i_wszTable, wszTABLE_SERVERWIRINGMETA) || 0==_wcsicmp(i_wszTable, wszTABLE_SERVERWIRING_META))
                return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedPackedInterceptor, wszDATABASE_META, i_wszTable, 0, NULL, 0, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
            else
                return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedInterceptor, wszDATABASE_META, i_wszTable, 0, NULL, 0, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
        }
        else if(0 != i_QueryData && (iST_CELL_SPECIAL & reinterpret_cast<STQueryCell *>(i_QueryData)->iCell))
        {   //If the Meta table uses an IndexHint it must come from the FixedInterceptor
            return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedInterceptor, wszDATABASE_META, i_wszTable, 0, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
        }
        else if(0 != i_QueryData && 0 == _wcsicmp(i_wszTable, wszTABLE_TABLEMETA) && iTABLEMETA_Database == reinterpret_cast<STQueryCell *>(i_QueryData)->iCell)
        {
            return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedInterceptor, wszDATABASE_META, i_wszTable, 0, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
        }
        //We need to special case a few tables for perf reasons.  If we don't hard code these tables, we will incur extra page faults.
        //This is because TFixedPackedSchemaInterceptor::GetTableID & InternalGetTable hit the table's schema page to verify the table name
        //and look up the ServerWiring.  By hard coding this information for these tables (which are the core table) we don't hit those pages.
        //This saves up to 4 page faults (2 for ColumnMeta and one each for TableMeta and TagMeta).
        {
            //Remap these META tables to the FixedPackedInterceptor, the other META tables will be handled as usual
            if(0 ==      _wcsicmp(i_wszTable, wszTABLE_COLUMNMETA))
                return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedPackedInterceptor, wszDATABASE_PACKEDSCHEMA, wszTABLE_PROPERTY_META, TABLEID_PROPERTY_META, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
            else if(0 == _wcsicmp(i_wszTable, wszTABLE_TABLEMETA))
                return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedPackedInterceptor, wszDATABASE_PACKEDSCHEMA, wszTABLE_COLLECTION_META, TABLEID_COLLECTION_META, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
            else if(0 == _wcsicmp(i_wszTable, wszTABLE_TAGMETA))
                return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedPackedInterceptor, wszDATABASE_PACKEDSCHEMA, wszTABLE_TAG_META, TABLEID_TAG_META, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
            else
                return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedInterceptor, wszDATABASE_META, i_wszTable, 0, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);
        }
    }
    else if(0 == _wcsicmp(i_wszDatabase, wszDATABASE_PACKEDSCHEMA))//All PACKEDSCHEMA tables come from the FixedPackedInterceptor
        return HardCodedIntercept(eSERVERWIRINGMETA_Core_FixedPackedInterceptor, i_wszDatabase, i_wszTable, 0, i_QueryData, i_QueryMeta, eST_QUERYFORMAT_CELLS, i_fServiceRequests, o_ppIST);

    //For now we only support tables defined in the FixedPackedSchema.  In the future we'll have to content with tables whose schema
    //is expressed in some other form.  At that time we'll need to handle an error returned from GetTableID and do something different
    //for those tables.
    HRESULT hr = TFixedPackedSchemaInterceptor::GetTableID(i_wszDatabase, i_wszTable, TableID);
    if(SUCCEEDED(hr))
    {
        // This table is described in the meta from this dll
		// We can just call the faster method
        return InternalGetTable(i_wszDatabase, i_wszTable, TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, o_ppIST);
    }
#ifdef EXTENDED_SCHEMA_SUPPORT
	// we do not support extended schemas anymore.
    else
    {   // just get an XML table - this is for schema extensibility - we only support reading from XML files and no logic
        return GetXMLTable(i_wszDatabase, i_wszTable, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, o_ppIST);
    }
#endif

	return hr;
}


HRESULT CSimpleTableDispenser::GetXMLTable ( LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	 i_eQueryFormat,
				  DWORD	i_fServiceRequests, LPVOID*	o_ppIST)
{
	HRESULT hr;
	tSERVERWIRINGMETARow SWColumns;
    ULONG zero=0;
    ULONG one = 1;
    ULONG metaflags = fSERVERWIRINGMETA_First;
	ULONG interceptor = XML_INTERCEPTOR;
	ISimpleTableAdvanced * pISTAdvanced = NULL;

    if((0==i_wszDatabase || 0==i_wszTable) )
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "GetXMLTable needs Database/TableName" ));
		return E_INVALIDARG;
	}

	// Validate out pointer
	if (NULL == o_ppIST)
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "Bad out parameter" ));
		return E_INVALIDARG;
	}
    *o_ppIST = 0;//Our cleanup relies on this being NULL

	// Validate query format
	if(i_eQueryFormat != eST_QUERYFORMAT_CELLS)
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "Query format not supported" ));
		return E_ST_QUERYNOTSUPPORTED;
	}

	// Check the query data and meta
	if((NULL != i_QueryData) && (NULL == i_QueryMeta))
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "Invalid query" ));
		return E_INVALIDARG;
	}
/*
	// Scan the query for iST_CELL_COMPUTER or iST_CELL_CLUSTER
	if(i_QueryData)
	{
		STQueryCell * aqCell = (STQueryCell *)i_QueryData;

		for(ULONG iqCell = 0; iqCell<*(ULONG*)i_QueryMeta; iqCell++)
		{
			if ((aqCell[iqCell].iCell == iST_CELL_COMPUTER) ||
				(aqCell[iqCell].iCell == iST_CELL_CLUSTER))
			{
				i_fServiceRequests |= fST_LOS_CONFIGWORK;
				break;
			}
		}
	}
*/
	// We don't support client tables for now
	if(i_fServiceRequests & fST_LOS_CONFIGWORK) return E_ST_LOSNOTSUPPORTED;

    // prepare the structure we pass in CreateTableObjectByID
	SWColumns.pTable				= NULL;//This is the PK so it shouldn't be NULL but I don't know if it matters in this mocked up ServerWiring row (stephenr)
	SWColumns.pOrder				= &one;
	SWColumns.pReadPlugin			= &zero;
	SWColumns.pWritePlugin			= &zero;
	SWColumns.pInterceptor			= &interceptor;
	SWColumns.pReadPluginDLLName    = NULL; // doesn't really matter
	SWColumns.pWritePluginDLLName	= NULL;
	SWColumns.pInterceptorDLLName	= NULL;
	SWColumns.pMergerDLLName		= NULL;
	SWColumns.pMetaFlags			= &metaflags;
	SWColumns.pLocator				= NULL;
	SWColumns.pMerger				= &zero;

    //fill in SWColumns
	hr = CreateTableObjectByID(i_wszDatabase, i_wszTable, 0, i_QueryData, i_QueryMeta, i_eQueryFormat,
		i_fServiceRequests, NULL,  &SWColumns, o_ppIST);
    if(FAILED(hr))
    {
        DBGPRINTF(( DBG_CONTEXT,
		            "%x error in the interceptor", hr ));
        ASSERT(0 == *o_ppIST);
    	return hr;
    }

	// Get the advanced interface
	hr = (*(ISimpleTableWrite2 **)o_ppIST)->QueryInterface(IID_ISimpleTableAdvanced, (LPVOID *)&pISTAdvanced);
	if (FAILED (hr)) goto Cleanup;

	// Populate the table
	hr = pISTAdvanced->PopulateCache();

Cleanup:
    if(pISTAdvanced)
	    pISTAdvanced->Release();
    if(FAILED(hr) && *o_ppIST)
    {
		(*(ISimpleTableWrite2 **)o_ppIST)->Release();
		*o_ppIST = 0;
    }

	return hr;
}



HRESULT CSimpleTableDispenser::InternalGetTable ( LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD	 i_eQueryFormat,
				  DWORD	i_fServiceRequests, LPVOID*	o_ppIST)
{
	HRESULT hr;
	ULONG iRow;	// row index in the wiring table
	PKHelper pk; // primary key for the wiring table
	ULONG iOrder; // the order of the interceptors in the wiring table
	tSERVERWIRINGMETARow SWColumns;
	ISimpleTableWrite2 * pUnderTable = NULL;
	ISimpleTableAdvanced * pISTAdvanced = NULL;
	DWORD fNoNext = 0;
    ULONG zero=0;

    if((0==i_wszDatabase || 0==i_wszTable) && 0==i_TableID)
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "GetTable either needs Database/TableName OR TableID." ));
		return E_INVALIDARG;
	}

	// Validate out pointer
    *o_ppIST = 0;//Our cleanup relies on this being NULL

	// Validate query format
	if(i_eQueryFormat != eST_QUERYFORMAT_CELLS)
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "Query format not supported" ));
		return E_ST_QUERYNOTSUPPORTED;
	}

	// Check the query data and meta
	if((NULL != i_QueryData) && (NULL == i_QueryMeta))
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "Invalid query" ));
		return E_INVALIDARG;
	}

	// Scan the query for iST_CELL_COMPUTER or iST_CELL_CLUSTER
	if(i_QueryData)
	{
		STQueryCell * aqCell = (STQueryCell *)i_QueryData;

		for(ULONG iqCell = 0; iqCell<*(ULONG*)i_QueryMeta; iqCell++)
		{
			if ((aqCell[iqCell].iCell == iST_CELL_COMPUTER) ||
				(aqCell[iqCell].iCell == iST_CELL_CLUSTER))
			{
				i_fServiceRequests |= fST_LOS_CONFIGWORK;
				break;
			}
		}
	}

	// We don't support client tables for now
	if(i_fServiceRequests & fST_LOS_CONFIGWORK) return E_ST_LOSNOTSUPPORTED;


	pk.pTableID = &i_TableID;
	pk.porder = &zero;
	hr = m_spServerWiring->GetRowIndexByIdentity(NULL, (LPVOID *)&pk, &iRow);
	if(FAILED (hr))
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "No wiring was found for tid = %d", i_TableID ));
		return hr;
	}

	// Try the interceptors from the FIRST group,
	// one by one, until we find a good one
	for(iOrder = iRow;;)
	{
		hr = m_spServerWiring->GetColumnValues(iOrder, cSERVERWIRING_META_NumberOfColumns, NULL, NULL, (LPVOID *)&SWColumns);
		iOrder++;
		if (E_ST_NOMOREROWS == hr)
			break; // we tried all the interceptors specified in the wiring
		if (FAILED(hr))
		{	//error in getting the wiring
			goto Cleanup;
		}

		hr = CreateTableObjectByID(i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat,
			i_fServiceRequests, NULL,  &SWColumns, o_ppIST);
		if (hr == S_OK)
			break; // we found a good first interceptor
		else if(hr == E_ST_OMITDISPENSER)
			continue; // try the next one
		else if(hr == E_ST_OMITLOGIC)
		{
			hr = S_OK;
			fNoNext = 1;
			break;
		}
		else
		{	// not S_OK, not E_ST_OMITDISPENSER, not E_ST_OMITLOGIC - error out
            DBGPRINTF(( DBG_CONTEXT,
			            "%x error in the interceptor", hr ));
			goto Cleanup;
		}
	}


	if (!fNoNext)
	{
		if(!(i_fServiceRequests & fST_LOS_NOLOGIC))
		{
			// Create and use each interceptor from the NEXT group
			do
			{
				hr = m_spServerWiring->GetColumnValues(iOrder, cSERVERWIRING_META_NumberOfColumns, NULL, NULL, (LPVOID *)&SWColumns);
				iOrder ++;
				if(S_OK == hr)
				{
					if (*SWColumns.pMetaFlags & fSERVERWIRINGMETA_First) continue; // skip the first interceptors
					pUnderTable = *(ISimpleTableWrite2**)o_ppIST ;

					hr = CreateTableObjectByID(i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat,
						i_fServiceRequests, (LPVOID)pUnderTable, &SWColumns, o_ppIST);
					if (FAILED (hr))
                    {
                        ASSERT(0 == *o_ppIST);
                        goto Cleanup;
                    }
				}
			}
			while(hr == S_OK);
			if (hr == E_ST_NOMOREROWS) hr = S_OK; // we finished the interceptors
			if (FAILED (hr)) goto Cleanup;
		}

		// Get the advanced interface
		hr = (*(ISimpleTableWrite2 **)o_ppIST)->QueryInterface(IID_ISimpleTableAdvanced, (LPVOID *)&pISTAdvanced);
		if (FAILED (hr)) goto Cleanup;

		// Populate the table
		hr = pISTAdvanced->PopulateCache();
		if(FAILED (hr)) goto Cleanup;
	}

Cleanup:

    if(pISTAdvanced)
	    pISTAdvanced->Release();
    if(FAILED(hr))
    {
        if(*o_ppIST)
    		(*(ISimpleTableWrite2 **)o_ppIST)->Release();
		*o_ppIST = 0;
    }

	return hr;
}

//////////////////////////////////////////////////
// Implementation of IAdvancedTableDispenser
//////////////////////////////////////////////////
HRESULT CSimpleTableDispenser::GetMemoryTable ( LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData,
                                                LPVOID i_QueryMeta, DWORD i_eQueryFormat, DWORD i_fServiceRequests,
                                                ISimpleTableWrite2** o_ppISTWrite)
{
    HRESULT hr;
    STQueryCell           qcellMeta;                  // Query cell for grabbing meta table.
    CComPtr<ISimpleTableRead2> pColumnMeta;
    CComPtr<ISimpleTableRead2> pTableMeta;
    ULONG one = 1;

    if(((0 == i_wszDatabase) || (0 == i_wszTable)) && (0 == i_TableID)) return E_INVALIDARG;

    if(0 == o_ppISTWrite )return E_INVALIDARG;

	ASSERT((0 == *o_ppISTWrite) && "Possible memory leak");

    CComPtr<ISimpleTableInterceptor>    pISTInterceptor;
    hr = DllGetSimpleObjectByID(MEMORY_INTERCEPTOR, IID_ISimpleTableInterceptor, (LPVOID *)(&pISTInterceptor));
    if (FAILED (hr)) return hr;

	if(i_TableID == 0)
	{	// get the table id based on the table and database name
        hr = TFixedPackedSchemaInterceptor::GetTableID(i_wszDatabase, i_wszTable, i_TableID);
        if(FAILED(hr) && (i_fServiceRequests & fST_LOS_EXTENDEDSCHEMA))
        {
            // Read the meta information from the extended schema
            i_TableID = 0;

            qcellMeta.pData     = (LPVOID)i_wszTable;
            qcellMeta.eOperator = eST_OP_EQUAL;
            qcellMeta.iCell     = iTABLEMETA_InternalName;
            qcellMeta.dbType    = DBTYPE_WSTR;
            qcellMeta.cbSize    = (ULONG)::wcslen(i_wszTable);

            // Read Table meta
            hr = HardCodedIntercept (eSERVERWIRINGMETA_Core_MetaMergeInterceptor, wszDATABASE_META, wszTABLE_TABLEMETA, 0,
                    reinterpret_cast<LPVOID>(&qcellMeta), reinterpret_cast<LPVOID>(&one), eST_QUERYFORMAT_CELLS, i_fServiceRequests & fST_LOS_EXTENDEDSCHEMA,
                    reinterpret_cast<LPVOID *>(&pTableMeta));
            if (FAILED (hr)) return hr;

            qcellMeta.iCell     = iCOLUMNMETA_Table;
            // Read Column meta
            hr = HardCodedIntercept (eSERVERWIRINGMETA_Core_MetaMergeInterceptor, wszDATABASE_META, wszTABLE_COLUMNMETA, 0,
                    reinterpret_cast<LPVOID>(&qcellMeta), reinterpret_cast<LPVOID>(&one), eST_QUERYFORMAT_CELLS, i_fServiceRequests & fST_LOS_EXTENDEDSCHEMA,
                    reinterpret_cast<LPVOID *>(&pColumnMeta));
            if (FAILED (hr)) return hr;
        }
	}

    if (i_TableID != 0)
    {
        // the meta for this table is hardcoded in out dll
        qcellMeta.pData     = (LPVOID)&i_TableID;
        qcellMeta.eOperator = eST_OP_EQUAL;
        qcellMeta.iCell     = iST_CELL_TABLEID;
        qcellMeta.dbType    = DBTYPE_UI4;
        qcellMeta.cbSize    = 0;

        hr = GetMetaTable (TABLEID_COLLECTION_META, reinterpret_cast<LPVOID>(&qcellMeta), reinterpret_cast<LPVOID>(&one), eST_QUERYFORMAT_CELLS, reinterpret_cast<LPVOID *>(&pTableMeta));
        if (FAILED (hr)) return hr;

        hr = GetMetaTable (TABLEID_PROPERTY_META, reinterpret_cast<LPVOID>(&qcellMeta), reinterpret_cast<LPVOID>(&one), eST_QUERYFORMAT_CELLS, reinterpret_cast<LPVOID *>(&pColumnMeta));
        if (FAILED (hr)) return hr;
    }

    ASSERT(pColumnMeta.p);
    ASSERT(pTableMeta.p);

    // Determine column count and allocate necessary meta structures:
    ULONG aiColumns = iTABLEMETA_CountOfColumns;
    ULONG *pcColumns;
    hr = pTableMeta->GetColumnValues(0, 1, &aiColumns, 0, reinterpret_cast<LPVOID *>(&pcColumns));
    if (FAILED (hr)) return hr;

    // Allocate the arrays ShapeCache uses
    TSmartPointerArray<SimpleColumnMeta> acolmetas = new SimpleColumnMeta[*pcColumns];
    if(NULL == acolmetas.m_p)return E_OUTOFMEMORY;
	TSmartPointerArray<LPVOID> acoldefaults = new LPVOID[*pcColumns];
    if(NULL == acoldefaults.m_p)return E_OUTOFMEMORY;
	TSmartPointerArray<ULONG> acoldefsizes = new ULONG[*pcColumns];
    if(NULL == acoldefsizes.m_p)return E_OUTOFMEMORY;

    for (unsigned int iColumn = 0; iColumn < *pcColumns; iColumn++)
        acolmetas[iColumn].cbSize = 0;

    // Examine meta and setup self
    LPVOID  pvValues[iCOLUMNMETA_DefaultValue+1];//This is the last column in the ColumnMeta that we care about right now.
    ULONG	aulSizes[iCOLUMNMETA_DefaultValue+1];

    for (iColumn = 0;; iColumn++)
    {
        if(E_ST_NOMOREROWS == (hr = pColumnMeta->GetColumnValues(iColumn, iCOLUMNMETA_DefaultValue+1, 0, aulSizes, pvValues)))// Next row:
        {
            ASSERT(*pcColumns == iColumn);
            if(*pcColumns != iColumn)return E_UNEXPECTED; // Assert expected column count.
            break;
        }
        else
        {
            if(FAILED(hr))
            {
                ASSERT(false && "GetColumnValues FAILED with something other than E_ST_NOMOREROWS");
                return hr;
            }
        }

        //Don't care about the iOrder column but we'll get it anyway since it's easier to do.
        acolmetas[iColumn].dbType = *(reinterpret_cast<ULONG *>(pvValues[iCOLUMNMETA_Type]));
        acolmetas[iColumn].cbSize = *(reinterpret_cast<ULONG *>(pvValues[iCOLUMNMETA_Size]));
        acolmetas[iColumn].fMeta  = *(reinterpret_cast<ULONG *>(pvValues[iCOLUMNMETA_MetaFlags]));
		acoldefaults[iColumn] = pvValues[iCOLUMNMETA_DefaultValue];
		acoldefsizes[iColumn] = aulSizes[iCOLUMNMETA_DefaultValue];
    }

    hr = pISTInterceptor->Intercept (i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, (IAdvancedTableDispenser*) this, NULL, NULL, (void**) o_ppISTWrite);
    if (FAILED (hr)) return hr;

    CComQIPtr<ISimpleTableController, &IID_ISimpleTableController>   pISTController = *o_ppISTWrite;ASSERT(0 != pISTController.p);
    if(0 == pISTController.p)return E_UNEXPECTED;

    // Now that the cache is setup, initialize it.
    hr =  pISTController->ShapeCache(i_fServiceRequests, *pcColumns, acolmetas, acoldefaults, acoldefsizes);
    if (FAILED (hr)) return hr;

    //Put the cache into the correct state
    return hr =  pISTController->PopulateCache();
}


HRESULT CSimpleTableDispenser::GetProductID(LPWSTR o_wszProductID, DWORD * io_pcchProductID)
{
    if(0 == io_pcchProductID)
        return E_POINTER;

    DWORD dwSizeNeeded = (DWORD) wcslen(m_wszProductID)+1;

    if(0 == o_wszProductID)//If the user passed in NULL for wszProductID, the we return the size
    {
        *io_pcchProductID = dwSizeNeeded;
        return S_OK;
    }

    if(*io_pcchProductID < dwSizeNeeded)
        return E_ST_SIZENEEDED;

    wcscpy(o_wszProductID, m_wszProductID);
    *io_pcchProductID = dwSizeNeeded;
    return S_OK;
}

//=================================================================================
// Function: GetCatalogErrorLogger
//
// Synopsis: A logger is assocoate with the dispenser,  anybody wanting to log an
//              event should log through this interface.
//
// Arguments: [o_ppErrorLogger] -
//
// Return Value:
//=================================================================================
HRESULT CSimpleTableDispenser::GetCatalogErrorLogger
(
    ICatalogErrorLogger2 **	o_ppErrorLogger
)
{
    if(0 == o_ppErrorLogger)
        return E_INVALIDARG;
    if(0 != *o_ppErrorLogger)
        return E_INVALIDARG;

	CSafeLock dispenserLock(&g_csSADispenser);//guard the spErrorLogger
    HRESULT hr;
    if(0 == m_spErrorLogger.p)
    {
        if(0 == wcscmp(m_wszProductID, WSZ_PRODUCT_IIS))
        {
            TextFileLogger *pLogger = new TextFileLogger(WSZ_PRODUCT_IIS);
            if(0 == pLogger)
                return E_OUTOFMEMORY;

            CComPtr<ICatalogErrorLogger2> spErrorLogger;
            if(FAILED(hr=pLogger->QueryInterface (IID_ICatalogErrorLogger2, reinterpret_cast<void **>(&spErrorLogger))))
                return hr;

            EventLogger *pNTEventLogger = new EventLogger(spErrorLogger);
            if(0 == pNTEventLogger)
                return E_OUTOFMEMORY;
            if(FAILED(hr=pNTEventLogger->QueryInterface (IID_ICatalogErrorLogger2, reinterpret_cast<void **>(&m_spErrorLogger))))
                return hr;
        }
        else //NULL logger
        {
            NULL_Logger *pLogger = new NULL_Logger();
            if(0 == pLogger)
                return E_OUTOFMEMORY;

            if(FAILED(hr=pLogger->QueryInterface (IID_ICatalogErrorLogger2, reinterpret_cast<void **>(&m_spErrorLogger))))
                return hr;

        }
    }

    m_spErrorLogger.CopyTo(o_ppErrorLogger);

    return S_OK;
}

//=================================================================================
// Function: SetCatalogErrorLogger
//
// Synopsis: A logger is assocoate with the dispenser,  anybody wanting to
//              implement their own logger can associate it with a dispenser by
//              setting it here.
//
// Arguments: [i_pErrorLogger] -
//
// Return Value:
//=================================================================================
HRESULT CSimpleTableDispenser::SetCatalogErrorLogger
(
    ICatalogErrorLogger2 *	i_pErrorLogger
)
{
    if(0 == i_pErrorLogger)
        return E_INVALIDARG;

    CSafeLock dispenserLock(&g_csSADispenser);//guard the spErrorLogger

    // old catalog error logger will automatically be released (if non-null) due
    // to behavior of atl CComPtr assignment operator
    m_spErrorLogger = i_pErrorLogger;
    return S_OK;
}


extern const FixedTableHeap * g_pFixedTableHeap;
//////////////////////////////////////////////////
// Implementation of IMetabaseSchemaCompiler
//////////////////////////////////////////////////
HRESULT
CSimpleTableDispenser::Compile
(
    LPCWSTR                 i_wszExtensionsXmlFile,
    LPCWSTR                 i_wszResultingOutputXmlFile
)
{
    return m_MBSchemaCompilation.Compile(this, i_wszExtensionsXmlFile, i_wszResultingOutputXmlFile, g_pFixedTableHeap);
}

HRESULT
CSimpleTableDispenser::GetBinFileName
(
    LPWSTR                  o_wszBinFileName,
    ULONG *                 io_pcchSizeBinFileName
)
{
    return m_MBSchemaCompilation.GetBinFileName(o_wszBinFileName, io_pcchSizeBinFileName);
}

HRESULT
CSimpleTableDispenser::SetBinPath
(
    LPCWSTR                 i_wszBinPath
)
{
    return m_MBSchemaCompilation.SetBinPath(i_wszBinPath);
}

HRESULT
CSimpleTableDispenser::ReleaseBinFileName
(
    LPCWSTR                 i_wszBinFileName
)
{
    return m_MBSchemaCompilation.ReleaseBinFileName(i_wszBinFileName);
}

HRESULT
CSimpleTableDispenser::LogError
(
    HRESULT                 i_hrErrorCode,
    ULONG                   i_ulCategory,
    ULONG                   i_ulEvent,
    LPCWSTR                 i_szSource,
    ULONG                   i_ulLineNumber
)
{
    CErrorInterceptor( i_hrErrorCode, i_ulCategory, i_ulEvent).WriteToLog(i_szSource, i_ulLineNumber);
    return S_OK;
}

////////////////////////////////////////////
// Private member functions
////////////////////////////////////////////
HRESULT CSimpleTableDispenser::CreateTableObjectByID(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat,
				  DWORD	i_fServiceRequests, LPVOID i_pUnderTable, tSERVERWIRINGMETARow * i_pSWColumns, LPVOID * o_ppIST)
{
	HRESULT hr;
	CComPtr <IShellInitialize> spShell;
	CComPtr <IInterceptorPlugin> spIPlugin;
	CComPtr <ISimplePlugin> spReadPlugin;
	CComPtr <ISimplePlugin> spWritePlugin;
	CComPtr <ISimpleTableInterceptor> spInterceptor;


	// A little validation
	ASSERT(i_pSWColumns);
    ASSERT(*i_pSWColumns->pMetaFlags);//MetaFlags should always be First or Next at least.

	*o_ppIST = 0;

	// Deal with the interceptor
	if(*i_pSWColumns->pInterceptor)
	{
		if (!(i_fServiceRequests & fST_LOS_READWRITE) &&
			!(*i_pSWColumns->pMetaFlags & fSERVERWIRINGMETA_First) &&
			!(*i_pSWColumns->pMetaFlags & fSERVERWIRINGMETA_WireOnReadWrite))
		{	// We don't need the logic in this case:
			// we are not in a read-write request,
			// we are not creating a first interceptor
			// the wiring doesn't force us to wire the interceptor on readonly requests

			*o_ppIST = i_pUnderTable;
			return S_OK;
		}

		// Create it
		hr = CreateSimpleObjectByID(*i_pSWColumns->pInterceptor, i_pSWColumns->pInterceptorDLLName, IID_ISimpleTableInterceptor, (LPVOID *)&spInterceptor);
		if (FAILED(hr))
		{
            DBGPRINTF(( DBG_CONTEXT,
			            "Creation of the interceptor failed" ));
			return hr;
		}

		// Figure out wether it's a full interceptor or a interceptor plugin
		hr = spInterceptor->QueryInterface(IID_IInterceptorPlugin, (LPVOID *)&spIPlugin);
		if (FAILED(hr))
		{
			LPVOID table=0;//Catalog spec says this should be 0 initialized

			// Ok, it's full - we need to call GetTable and return
			if(*i_pSWColumns->pReadPlugin || *i_pSWColumns->pWritePlugin)
			{
                DBGPRINTF(( DBG_CONTEXT,
				            "Error: Can't have simple plugins with a fully-fledged interceptor" ));
				return E_ST_INVALIDWIRING;
			}

			hr = spInterceptor->Intercept(i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests,
				(IAdvancedTableDispenser*) this, i_pSWColumns->pLocator, i_pUnderTable, &table);

			if ((hr != S_OK) && (hr != E_ST_OMITLOGIC))
			{
				if (hr != E_ST_OMITDISPENSER)
				{
                    DBGPRINTF(( DBG_CONTEXT,
					            "Intercept method failed on interceptor number %d", *i_pSWColumns->pInterceptor ));
				}
				return hr;
			}
			// Try to get the ISimpleTableWrite
			if (FAILED(((ISimpleTableRead2 *)table)->QueryInterface(IID_ISimpleTableWrite2, o_ppIST)))
			{
				*o_ppIST = table;
			}
			else
			{
				((ISimpleTableRead2 *)table)->Release();
			}
			return hr;

		}
	}

	// The following code doesn't get executed in the "core execution path"
	// We exit the function via the return above

	// Create the read plugin
	if ((!(i_fServiceRequests & fST_LOS_NOLOGIC)) && *i_pSWColumns->pReadPlugin)
	{
		hr = CreateSimpleObjectByID(*i_pSWColumns->pReadPlugin, i_pSWColumns->pReadPluginDLLName, IID_ISimplePlugin, (LPVOID *)&spReadPlugin);
		if (FAILED(hr))
		{
            DBGPRINTF(( DBG_CONTEXT,
			            "Error: Creation of the read plugin failed" ));
			return hr;
		}
	}

	// Create the write plugin
	if ((!(i_fServiceRequests & fST_LOS_NOLOGIC)) && *i_pSWColumns->pWritePlugin)
	{
		if(i_fServiceRequests & fST_LOS_READWRITE)
		{
			hr = CreateSimpleObjectByID(*i_pSWColumns->pWritePlugin, i_pSWColumns->pWritePluginDLLName, IID_ISimplePlugin, (LPVOID *)&spWritePlugin);
			if (FAILED(hr))
			{
                DBGPRINTF(( DBG_CONTEXT,
				            "Error: Creation of the write plugin failed" ));
				return hr;
			}
		}
		// else: for readonly requests we don't need the write plugin,
		// even if the wiring specifies wire logic on readonly
	}

// Create an instance of the shell
	hr = CreateShell(&spShell);
	if(FAILED (hr))
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "Error: Creation of the shell failed" ));
		return hr;
	}

	//TODO add a parameter to initialize in the shell
// Initialize the shell with the plugins we've already created
	hr = spShell->Initialize(i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests,
		(IAdvancedTableDispenser*) this, i_pSWColumns->pLocator, i_pUnderTable,
		spIPlugin, spReadPlugin, spWritePlugin, o_ppIST);
	if(FAILED (hr) && (E_ST_OMITDISPENSER != hr) && (E_ST_OMITLOGIC != hr))
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "Error: Initialization of the shell failed" ));
	}

	return hr;
}


HRESULT CSimpleTableDispenser::CreateSimpleObjectByID(ULONG i_ObjectID, LPWSTR i_wszDllName, REFIID riid, LPVOID* o_ppv)
{
    UNREFERENCED_PARAMETER(i_wszDllName);
	// We're in this dll, we don't need to load it
	return DllGetSimpleObjectByID(i_ObjectID, riid, o_ppv);
}

HRESULT CSimpleTableDispenser::GetMetaTable(ULONG TableID, LPVOID QueryData, LPVOID QueryMeta, DWORD eQueryFormat, LPVOID *ppIST)
{
	HRESULT hr;
	CComPtr <ISimpleTableInterceptor> pISTInterceptor;
	CComPtr <ISimpleTableAdvanced> pISTAdvanced;

	// Get the server wiring table
	hr = DllGetSimpleObjectByID(META_INTERCEPTOR, IID_ISimpleTableInterceptor, (LPVOID *)(&pISTInterceptor));
	if (FAILED (hr)) return hr;

	hr = pISTInterceptor->Intercept (NULL, NULL, TableID, QueryData, QueryMeta, eQueryFormat, 0, (IAdvancedTableDispenser*) this, NULL, NULL, (LPVOID *)ppIST);
	if (FAILED (hr)) return hr;

	hr = m_spServerWiring->QueryInterface(IID_ISimpleTableAdvanced, (LPVOID *)&pISTAdvanced);
	if (FAILED (hr)) return hr;

	hr = pISTAdvanced->PopulateCache();
	if (FAILED (hr)) return hr;

	pISTAdvanced.Release();
	pISTInterceptor.Release();

	return hr;
}

//This is used when the dispenser knows the interceptor without looking it up in the ServerWiring
HRESULT CSimpleTableDispenser::HardCodedIntercept(eSERVERWIRINGMETA_Interceptor interceptor,
                                                  LPCWSTR   i_wszDatabase,
                                                  LPCWSTR   i_wszTable,
                                                  ULONG     i_TableID,
                                                  LPVOID    i_QueryData,
                                                  LPVOID    i_QueryMeta,
                                                  DWORD     i_eQueryFormat,
				                                  DWORD     i_fServiceRequests,
                                                  LPVOID *  o_ppIST) const
{
    HRESULT hr;
    CComPtr <ISimpleTableInterceptor>   pISTInterceptor;

    // Get the server wiring table
    hr = DllGetSimpleObjectByID(interceptor, IID_ISimpleTableInterceptor, (LPVOID *)(&pISTInterceptor));
    if (FAILED (hr)) return hr;

    return pISTInterceptor->Intercept (i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, (IAdvancedTableDispenser*) this, NULL, NULL, o_ppIST);
}

// =======================================================================
//		ISimpleTableFileAdvise implementations.
// =======================================================================
STDMETHODIMP CSimpleTableDispenser::SimpleTableFileAdvise(
	ISimpleTableFileChange *i_pISTFile,
	LPCWSTR		i_wszDirectory,
	LPCWSTR		i_wszFile,
	DWORD		i_fFlags,
	DWORD		*o_pdwCookie)
{
	HRESULT hr;
	if(!m_pFileChangeMgr)
	{
		hr = InitFileChangeMgr();
		if(FAILED(hr)) return hr;
	}

	return m_pFileChangeMgr->InternalListen(i_pISTFile, i_wszDirectory, i_wszFile, i_fFlags, o_pdwCookie);
}

// =======================================================================
STDMETHODIMP CSimpleTableDispenser::SimpleTableFileUnadvise(DWORD i_dwCookie)
{
	HRESULT hr;
	if(!m_pFileChangeMgr)
	{
		hr = InitFileChangeMgr();
		if(FAILED(hr)) return hr;
	}

	return m_pFileChangeMgr->InternalUnlisten(i_dwCookie);
}


// =======================================================================
HRESULT CSimpleTableDispenser::GetFilePath(LPWSTR *o_pwszFilePath)
{
    UNREFERENCED_PARAMETER(o_pwszFilePath);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\entrypoint\createdispenser.cpp ===
#include "precomp.hxx"

#include <initguid.h>
#include "catalog_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\fastcache\sdtfst.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.

// TODO: Implement hashing in MoveToRowByIdentity.
// TODO: Implement a faster CopyWriteRowFromReadRow.
// TODO: In SetRow fail to insert an existing row.  Probably ignorable; better perf; spec decision.
// TODO: For marshalling: need to correct endian-ness.
// TODO: SetRow and SetWriteColumn both are inner loops.  Most SetRow work can be done in SetWriteColumn to optimize.

// 64-BIT Assumptions:
// No variable data will be larger than _MAX_ULONG bytes.
// The caches cannot have more than _MAX_ULONG rows.

#include "precomp.hxx"

#define oDOESNOTEXIST				(~0L)	// Offset does not exist.
#define cbminDATAGROWTH				1024	// Minimum count of bytes to grow the cache at a time.
#define cbmaxDATAGROWTH			67108864	// Maximum count of bytes to grow the cache at a time.
#define cmaxERRGROWTH				2500	// Maximum count of errors to grow the error cache at a time.
#define cmaxCOLUMNS					50		// Maximum number of columns that can be declared: Change CopyWriteRowFromRead if this changes.

										// Cache flags:
#define fCACHE_METAINITIALIZED	0x00000001	// The cache meta is initialized.
#define fCACHE_LOADING			0x00000002	// The cache is loading clean.
#define fCACHE_READY			0x00000004	// The cache is ready for external use.
#define fCACHE_INVALID			0x00000008	// The cache is invalid.
#define fCACHE_CONTINUING		0x00000010	// The cache is continuing from a prior loading.
#define fCACHE_ROWCOPYING		0x00000020	// The cache is copying a read row into a write row.
//								0x00070000	// Reserved for cache marshalling flags from catalog.idl.

										// Cursor designations and flags:
#define eCURSOR_READ				0		// Designates the read cursor.
#define eCURSOR_WRITE				1		// Designates the write cursor.
#define fCURSOR_READ_BEFOREFIRST	0x01	// The read cursor is right before the first row.
#define fCURSOR_READ_ATLAST			0x02	// The read cursor is at the last row.
#define fCURSOR_WRITE_BEFOREFIRST	0x10	// The write cursor is right before the first row.
#define fCURSOR_WRITE_ATLAST		0x20	// The write cursor is at the last row.
#define fCURSOR_ADDING				0x80	// The cursor had added a row to the write cache but has not set it.

										// Internal column status (low nibble reserved!):
#define fCOLUMNSTATUS_READINDEX		0x10	// The column value is a reference index to the read vardata.
#define fCOLUMNSTATUS_WRITEINDEX	0x20	// The column value is a reference index to the write vardata.


// =======================================================================
CMemoryTable::CMemoryTable ()
	: m_fTable (0)
	, m_cColumns (0)
	, m_cUnknownSizes (0)
	, m_cStatusParts (0)
	, m_cValueParts (0)
	, m_acolmetas (NULL)
	, m_acoloffsets (NULL)
	, m_acolDefaults (NULL)
	, m_alDefSizes (NULL)
	, m_cbMinCache (cbminDATAGROWTH)

	, m_fCache (0)
	, m_cRefs (1)

	, m_cReadRows (0)
	, m_cbReadVarData (0)
	, m_pvReadVarData (NULL)

	, m_pvReadCache (NULL)
	, m_cbReadCache (0)
	, m_cbmaxReadCache (0)

	, m_cWriteRows (0)
	, m_cbWriteVarData (0)
	, m_pvWriteVarData (NULL)

	, m_pvWriteCache (NULL)
	, m_cbWriteCache (0)
	, m_cbmaxWriteCache (0)

	, m_cErrs (0)
	, m_cmaxErrs (0)
	, m_pvErrs (NULL)

	, m_cRef (0)
	, m_fIsDataTable (0)
{
}

// =======================================================================
CMemoryTable::~CMemoryTable()
{
	CleanupCaches();
	if (m_acolmetas != NULL)
	{
		delete[] m_acolmetas;
		m_acolmetas = NULL;
	}
	if (m_acoloffsets != NULL)
	{
		delete[] m_acoloffsets;
		m_acoloffsets = NULL;
	}
	if (m_acolDefaults != NULL)
	{
		delete[] m_acolDefaults;
		m_acolDefaults = NULL;
	}
	if (m_alDefSizes != NULL)
	{
		delete[] m_alDefSizes;
		m_alDefSizes = NULL;
	}
}

// ------------------------------------
// ISimpleTableInterceptor:
// ------------------------------------

// ==================================================================
STDMETHODIMP CMemoryTable::Intercept
(
	LPCWSTR					i_wszDatabase,
	LPCWSTR 				i_wszTable,
	ULONG					i_TableID,
	LPVOID					i_QueryData,
	LPVOID					i_QueryMeta,
	DWORD					i_eQueryFormat,
	DWORD					i_fTable,
	IAdvancedTableDispenser *i_pISTDisp,
	LPCWSTR					i_wszLocator,
	LPVOID					i_pv,
	LPVOID*					o_ppv
)
{
    STQueryCell*		pQueryCell = (STQueryCell*) i_QueryData;

    UNREFERENCED_PARAMETER(i_wszDatabase);
    UNREFERENCED_PARAMETER(i_TableID);
    UNREFERENCED_PARAMETER(i_wszTable);
    UNREFERENCED_PARAMETER(i_pISTDisp);

// ie: Assert component is posing as class factory / dispenser.
	ASSERT (!m_fIsDataTable);
	if (m_fIsDataTable)
		return E_UNEXPECTED;
	ASSERT (NULL != o_ppv);
	if (NULL == o_ppv)
		return E_INVALIDARG;
	if(i_wszLocator)
		return E_INVALIDARG;
	*o_ppv = NULL;

// Determine minimum cache size:
	if (eST_QUERYFORMAT_CELLS != i_eQueryFormat) return E_ST_QUERYNOTSUPPORTED;
	if (i_QueryMeta == NULL && i_QueryData != NULL) return E_ST_INVALIDQUERY;
	if (i_QueryMeta != NULL)
	{
		if (*((ULONG*) i_QueryMeta) == 0 && i_QueryData != NULL) return E_ST_INVALIDQUERY;
		if (*((ULONG*) i_QueryMeta) > 1) return E_ST_QUERYNOTSUPPORTED;
		if (*((ULONG*) i_QueryMeta) == 1)
		{
			if (NULL == i_QueryData) return E_ST_INVALIDQUERY;
			if (pQueryCell->iCell != iST_CELL_cbminCACHE) return E_ST_QUERYNOTSUPPORTED;
			if (pQueryCell->eOperator != eST_OP_EQUAL) return E_ST_INVALIDQUERY;
			if (pQueryCell->dbType != DBTYPE_UI4) return E_ST_INVALIDQUERY;
			if (pQueryCell->cbSize != sizeof (ULONG)) return E_ST_INVALIDQUERY;
			m_cbMinCache = *((ULONG*) pQueryCell->pData);
		}
	}

/// As a shapeless cache none of these parameters are supported:
	ASSERT (NULL == i_pv);
	if (NULL != i_pv)
		return E_INVALIDARG;

// Remember what little is necessary:
	m_fTable = i_fTable;

// Leave the cache shapeless

// Supply ISimpleTable* and transition state from class factory / dispenser to data table:
	*o_ppv = (ISimpleTableWrite2*) this;
	((ISimpleTableWrite2*) this)->AddRef ();
	InterlockedIncrement ((LONG*) &m_fIsDataTable);

	return S_OK;
}

// -----------------------------------------
// CSimpleTableDataTableCursor: ISimpleTableRead2
// -----------------------------------------

// =======================================================================
HRESULT CMemoryTable::GetRowIndexByIdentity	(ULONG* i_acb, LPVOID* i_apv, ULONG* o_piRow)
{
	// ie: Assert cache is ready.
	ASSERT(fCACHE_READY & m_fCache);
	if (!(fCACHE_READY & m_fCache))
		return E_ST_INVALIDCALL;

	return (MoveToEitherRowByIdentity (eCURSOR_READ, i_acb, i_apv, o_piRow));
}

HRESULT CMemoryTable::GetRowIndexBySearch(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
	// ie: Assert cache is ready.
	ASSERT(fCACHE_READY & m_fCache);
	if (!(fCACHE_READY & m_fCache))
		return E_ST_INVALIDCALL;

	return GetEitherRowIndexBySearch (eCURSOR_READ, i_iStartingRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues, o_piRow);
}

// =======================================================================
HRESULT CMemoryTable::GetColumnValues (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes , LPVOID* o_apvValues)
{
	// ie: Assert cache is ready.
	ASSERT(fCACHE_READY & m_fCache);
	if (!(fCACHE_READY & m_fCache))
		return E_ST_INVALIDCALL;

	return (GetEitherColumnValues (i_iRow, eCURSOR_READ, i_cColumns, i_aiColumns, NULL, o_acbSizes , o_apvValues));
}

// =======================================================================
HRESULT CMemoryTable::GetTableMeta(ULONG * o_pcVersion, DWORD * o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns)
{
	// Todo:  In the old GetTableMeta, we didn't support pfTable or the Query stuff, for the new GetTableMeta if
	//		  we want to support pcVersion or pfTable, we need to implement it.
	ASSERT (NULL == o_pcVersion);
	if (NULL != o_pcVersion)
		return E_INVALIDARG;
	ASSERT (NULL == o_pfTable);
	if (NULL != o_pfTable)
		return E_INVALIDARG;

	 // ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache);
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return E_ST_INVALIDCALL;

	// The Following line is commented out because logic tables that validate during Populate Cache
	// will not work if this check is present.
	//areturn_on_fail (!(fCACHE_LOADING & m_fCache), E_ST_INVALIDCALL); // ie: Assert cache is not loading.

	if(o_pcRows)
		*o_pcRows = m_cReadRows;
	if(o_pcColumns)
		*o_pcColumns = m_cColumns;

	// TODO: Need to support Version
	if (o_pcVersion)
		*o_pcVersion = 0;

	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::GetColumnMetas(ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas )
{
	 // ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache);
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return E_ST_INVALIDCALL;

	// Make sure caller passed in a valid buffer.
	if (NULL == o_aColumnMetas)
	{
		return E_INVALIDARG;
	}

	// ie: Note column out of range.
	if (i_cColumns > m_cColumns)
		return E_ST_NOMORECOLUMNS;

	ULONG iColumn;
	ULONG iTarget;

	for ( ULONG i = 0; i < i_cColumns; i ++ )
	{
		if(NULL != i_aiColumns)
			iColumn = i_aiColumns[i];
		else
			iColumn = i;

		iTarget = (i_cColumns == 1) ? 0 : iColumn;

		if ( iColumn >= m_cColumns )
			return 	E_ST_NOMORECOLUMNS;

		memcpy( &(o_aColumnMetas[iTarget]), &(m_acolmetas[iColumn]), sizeof( SimpleColumnMeta ) );

		// Mask the internal flags:
		o_aColumnMetas[iTarget].fMeta &= fCOLUMNMETA_MetaFlags_Mask;
	}

	return(S_OK);
}

// -----------------------------------------
// CSimpleTableDataTableCursor: ISimpleTableWrite2
// -----------------------------------------

// =======================================================================
HRESULT CMemoryTable::AddRowForDelete (ULONG i_iReadRow)
{
	ULONG	iWriteRow;
	HRESULT hr;
	// Make sure that there is a read row before adding the write row.
	// else UpdateStore will AV if there is a write row with invalid data.
	LPVOID	pvRow		= NULL;

	// ie: Assert cache writeable and ready.
	ASSERT ((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache)))
		return E_NOTIMPL;

	// Make sure that there is a read row before adding the write row.
	// else UpdateStore will AV if there is a write row with invalid data.
	hr = GetRowFromIndex(eCURSOR_READ, i_iReadRow, &pvRow);
	if (FAILED (hr)) { return hr; }

	hr = AddWriteRow(eST_ROW_DELETE, &iWriteRow);
	if (FAILED (hr)) { return hr; }
	hr = CopyWriteRowFromReadRow(i_iReadRow, iWriteRow);
	if (FAILED (hr)) { return hr; }
	return hr;
}

// =======================================================================
HRESULT CMemoryTable::AddRowForInsert (ULONG* o_piWriteRow)
{
	LPVOID	pvRow = NULL;
	HRESULT hr = S_OK;

	// Assert that there is a valid return pointer.
	ASSERT(o_piWriteRow);

	 // ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;

	hr = AddWriteRow(eST_ROW_INSERT, o_piWriteRow);
	if (FAILED (hr)) { return hr; }

	if (FAILED(hr = GetRowFromIndex(eCURSOR_WRITE, *o_piWriteRow, &pvRow)))
		return hr;
	ASSERT(pvRow != NULL);

	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::AddRowForUpdate (ULONG i_iReadRow, ULONG* o_piWriteRow)
{
	HRESULT hr = S_OK;
	// Make sure that there is a read row before adding the write row.
	// else UpdateStore will AV if there is a write row with invalid data.
	LPVOID	pvRow		= NULL;

	// Assert that there is a valid return pointer.
	ASSERT(o_piWriteRow);

	// ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;


	if (!(fCACHE_LOADING & m_fCache)) // ie: Update from read to write cache: Add and copy into the new write row:

	{
		// Make sure that there is a read row before adding the write row.
		// else UpdateStore will AV if there is a write row with invalid data.
		hr = GetRowFromIndex(eCURSOR_READ, i_iReadRow, &pvRow);
		if (FAILED (hr)) { return hr; }

		hr = AddWriteRow(eST_ROW_UPDATE, o_piWriteRow);
		if (FAILED (hr)) { return hr; }
		hr = CopyWriteRowFromReadRow(i_iReadRow, *o_piWriteRow);
		if (FAILED (hr)) { return hr; }
	}

	return hr;
}

// =======================================================================
HRESULT CMemoryTable::SetWriteColumnValues(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues)
{
	DWORD			fColumn;
	ULONG			cb = 0;
	ULONG			cbMaxSize;
	LPVOID*			ppvValue;
	ULONG*			pulSize;
	BYTE*			pbStatus;
	ULONG			iColumn;
	ULONG			iSource;
	ULONG			icb = 0;
	LPVOID			pv;
	LPVOID			pvWriteRow = NULL;
	HRESULT			hr = S_OK;

	 // ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;

    if (i_apvValues==NULL)	return E_INVALIDARG;

	if (i_cColumns == 0)
		return E_INVALIDARG;

	if (i_cColumns > m_cColumns)
		return E_ST_NOMORECOLUMNS;

	if (FAILED(hr = GetRowFromIndex(eCURSOR_WRITE, i_iRow, &pvWriteRow)))
		return hr;

	ASSERT(pvWriteRow);
	for(ULONG ipv=0; ipv<i_cColumns; ipv++)
	{
		if(NULL != i_aiColumns)
			iColumn	= i_aiColumns[ipv];
		else
			iColumn	= ipv;

		iSource = (i_cColumns == 1) ? 0 : iColumn;

		ASSERT(iSource < m_cColumns);
		if (iSource >= m_cColumns)
			return E_INVALIDARG;

		if(NULL != i_acbSizes)
		{
			icb = i_acbSizes[iSource];
		}
		else
		{
			//reset number of bytes in case size is not given. This prevents
			//problems of reusing the size of the previous parameter.
			icb = 0;
		}


		pv	= i_apvValues[iSource];

	// Parameter validation: column ordinal:
		// ie: Note column out of range (do not assert).
		if (iColumn >= m_cColumns)
			return E_ST_NOMORECOLUMNS;

	// Remember the column flags:
		fColumn = m_acolmetas[iColumn].fMeta;

	// Can't update a primary key column. Unless:
	// The cache is being created, or a row is being copied from read to write cache or the row is an insert.
		if (fColumn & fCOLUMNMETA_PRIMARYKEY && fCACHE_READY & m_fCache && !(m_fCache & fCACHE_ROWCOPYING) && *(pdwDataActionPart (pvWriteRow)) != eST_ROW_INSERT)
		{
			return E_ST_PKNOTCHANGABLE;
		}

		if ((fColumn & fCOLUMNMETA_NOTNULLABLE) && (pv == 0) && !(fColumn & fCOLUMNMETA_NOTPERSISTABLE))
		{
			return E_ST_VALUENEEDED;
		}

	// Parameter validation: specified size:
		if (0 != icb) // ie: Size specified:
		{
			// TODO: Verify that the size is valid
			// areturn_on_fail (NULL != pv && ((fCOLUMNMETA_UNKNOWNSIZE & fColumn) || (DBTYPE_BYTES == m_acolmetas[iColumn].dbType && icb == m_acolmetas[iColumn].cbSize)), E_ST_VALUEINVALID); // ie: Assert column size must be passed and value is non-null.
		}
		else // ie: Size not specified:
		{
			if (!(!(fCOLUMNMETA_UNKNOWNSIZE & fColumn) || NULL == pv))
				return E_ST_SIZENEEDED;
		}

	// Parameter validation: by type:
		if (DBTYPE_WSTR == m_acolmetas[iColumn].dbType && NULL != pv) // ie: Column is a string and specified value is non-null:
		{
			cbMaxSize = m_acolmetas[iColumn].cbSize;
			if (~0 != cbMaxSize) // ie: Column has a maximum length:
			{
				if (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
				{
					// multi-string
					cb = (ULONG)GetMultiStringLength (LPCWSTR(pv)) * sizeof (WCHAR);
				}
				else
				{
					// normal string
					cb = (ULONG)(wcslen (LPCWSTR (pv)) + 1) * sizeof (WCHAR);
				}
				// ie: Assert specified string is within maximum length.
				if (cb > cbMaxSize)
					return E_ST_SIZEEXCEEDED;
			}
		}
		else
		{
			cb = m_acolmetas[iColumn].cbSize;
		}

	// Parameter validation: by flags: (Cannot check non-nullable columns here; done in LoadRow/SetRow instead).

	// Prepare to set the column:
		ppvValue	= ppvDataValuePart (pvWriteRow, iColumn);
		pulSize		= pulDataSizePart (pvWriteRow, iColumn);//This can return NULL
		pbStatus	= pbDataStatusPart (pvWriteRow, iColumn);

	// Set the column size:
		if (fCOLUMNMETA_VARIABLESIZE & fColumn) // ie: Column value is variable size (and therefore a pointer):
		{
			if (pv != NULL)
			{
				if (fCOLUMNMETA_UNKNOWNSIZE & fColumn) // ie: Column-size only knowable by passing it:
				{
                    ASSERT(pulSize);//PREFIX complains that *pulSize is dereferencing NULL; but it can't be NULL when we have a column of UNKNOWNSIZE
					*pulSize = icb; //in this case the size must explicitly be set.  pulSize will be NULL when the size is -1.

				}
				else // Has to be a string, because "BYTES" with FIXEDSIZE are not VARIABLESIZE.
				{
					ASSERT (DBTYPE_WSTR == m_acolmetas[iColumn].dbType);
					if (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
					{
						// multi-string
						icb = (ULONG) GetMultiStringLength (LPCWSTR(pv)) * sizeof (WCHAR);
					}
					else
					{
						// normal string
						icb = (ULONG)(wcslen (LPCWSTR (pv)) + 1) * sizeof (WCHAR);
					}
				}

			// Set the column value:
				hr = AddVarDataToWriteCache (icb, pv, (ULONG **)&ppvValue);
				if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }

				// Recalculate the pointers if the cache has been resized.
				if (hr == S_FALSE)
				{
					GetRowFromIndex(eCURSOR_WRITE, i_iRow, &pvWriteRow);
					pulSize		= pulDataSizePart (pvWriteRow, iColumn);
					pbStatus	= pbDataStatusPart (pvWriteRow, iColumn);
				}
				(*pbStatus) &= ~fCOLUMNSTATUS_READINDEX;
				(*pbStatus) |= (fCACHE_LOADING & m_fCache ? fCOLUMNSTATUS_READINDEX : fCOLUMNSTATUS_WRITEINDEX);
			}
		}
		else // ie: Column data size is fixed:
		{
			if (NULL != pv) // ie: Caller has data to copy:
			{
				memcpy (ppvValue, pv, cb);
			}
		}

	// Set the column status:
		if (NULL == pv) // ie: Value is null and not pass-by-value:
		{
			(*pbStatus) &= ~fST_COLUMNSTATUS_NONNULL;
		}
		else // ie: Value is non-null or pass-by-value:
		{
			(*pbStatus) |= fST_COLUMNSTATUS_NONNULL;
		}

	// if setwritecolumn has been called, probably something has changed
		(*pbStatus) |= fST_COLUMNSTATUS_CHANGED;
	}

	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::GetWriteColumnValues (ULONG i_iRow, ULONG i_cColumns, ULONG *i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes , LPVOID* o_apvValues)
{
	 // ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;

	return (GetEitherColumnValues (i_iRow, eCURSOR_WRITE, i_cColumns, i_aiColumns, o_afStatus, o_acbSizes , o_apvValues));
}

// =======================================================================
HRESULT CMemoryTable::GetWriteRowIndexByIdentity	(ULONG* i_acb, LPVOID* i_apv, ULONG* o_piRow)
{
	 // ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;

	return (MoveToEitherRowByIdentity (eCURSOR_WRITE, i_acb, i_apv, o_piRow));
}

// =======================================================================
HRESULT CMemoryTable::GetWriteRowIndexBySearch(ULONG i_iStartingRow, ULONG i_cColumns,
											   ULONG* i_aiColumns, ULONG* i_acbSizes,
											   LPVOID* i_apvValues, ULONG* o_piRow)
{
 // ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;

	return GetEitherRowIndexBySearch (eCURSOR_WRITE, i_iStartingRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues, o_piRow);
}

HRESULT CMemoryTable::GetErrorTable(DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable)
{
    UNREFERENCED_PARAMETER(i_fServiceRequests);
    UNREFERENCED_PARAMETER(o_ppvSimpleTable);

    return E_NOTIMPL;
}

// ==================================================================
STDMETHODIMP CMemoryTable::UpdateStore()
{
    HRESULT hr = S_OK;

	if (!(m_fTable & fST_LOS_READWRITE)) return E_NOTIMPL;
	hr = InternalPreUpdateStore ();
    if (!SUCCEEDED(hr))
        return hr;
	DiscardPendingWrites ();
	return hr;
}

// -----------------------------------------
// CSimpleTableDataTableCursor: ISimpleTableController:
// -----------------------------------------

// =======================================================================
HRESULT CMemoryTable::ShapeCache (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes)
{
	// ie: Assert meta not already initialized.
	ASSERT (!(fCACHE_METAINITIALIZED & m_fCache));
	if (fCACHE_METAINITIALIZED & m_fCache)
		return E_ST_INVALIDCALL;
	// ie: Assert at least one column specified.
	ASSERT (0 < i_cColumns);
	if (0 == i_cColumns)
		return E_INVALIDARG;

	// ie: Assert pointer validity.
	ASSERT (NULL != i_acolmetas);
	if (NULL == i_acolmetas)
		return E_INVALIDARG;

	ASSERT(i_cColumns < cmaxCOLUMNS);

// Setup the meta (note that if meta setup fails the cache remains uninitialized):
	return SetupMeta (i_fTable, i_cColumns, i_acolmetas, i_apvDefaults, i_acbSizes);
}

// =======================================================================
HRESULT CMemoryTable::PrePopulateCache (DWORD i_fControl)
{
	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache);
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return E_ST_INVALIDCALL;
	// ie: Assert supported control flags.
	ASSERT (0 == (~fCOLUMNMETA_MetaFlags_Mask & i_fControl));
	if (0 != (~fCOLUMNMETA_MetaFlags_Mask & i_fControl))
		return E_INVALIDARG;

	if (!(fST_POPCONTROL_RETAINREAD & i_fControl))
	{
		// ie: Assert retain errors was not specified.
		ASSERT (!(fST_POPCONTROL_RETAINERRS & i_fControl));
		if (fST_POPCONTROL_RETAINERRS & i_fControl)
			return E_INVALIDARG;
	}

	if (fST_POPCONTROL_RETAINREAD & i_fControl) // ie: Retaining the existing read cache:
	{
	// Continue cache loading:
		ContinueReadCacheLoading ();

	// Cleanup error cache unless otherwise requested:
		if (!(fST_POPCONTROL_RETAINERRS & i_fControl))
		{
			CleanupErrorCache ();
		}
	}
	else // ie: Replacing the existing read cache:
	{
	// Begin cache loading:
		BeginReadCacheLoading ();
	}

	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::PostPopulateCache ()
{
	HRESULT				hr;

	// ie: Assert cache is loading.
	ASSERT (fCACHE_LOADING & m_fCache);
	if (!(fCACHE_LOADING & m_fCache))
		return E_ST_INVALIDCALL;

// Remove any deleted rows, shrink cache, and end loading:
	if (m_cWriteRows)
		RemoveDeletedRows();
	hr = ShrinkWriteCache ();
	if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }
	EndReadCacheLoading ();

	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::DiscardPendingWrites ()
{
	// ie: Assert cache writeable and ready.
	ASSERT ((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache)))
		return E_NOTIMPL;

	CleanupWriteCache();
	CleanupErrorCache();
	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::GetWriteRowAction (ULONG i_iRow, DWORD* o_peAction)
{
	LPVOID	pvWriteRow;
	DWORD*	pdwAction;
	HRESULT	hr;

	// ie: Assert cache writeable and ready.
	ASSERT ((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache)))
		return E_NOTIMPL;

	ASSERT(NULL != o_peAction);

	if (FAILED(hr = GetRowFromIndex(eCURSOR_WRITE, i_iRow, &pvWriteRow)))
		return hr;
	ASSERT (NULL != pvWriteRow);

// Get the action part of the current write row:
	pdwAction = pdwDataActionPart (pvWriteRow);
	ASSERT (NULL != pdwAction);
	*o_peAction = *pdwAction;

	return hr;
}

// =======================================================================
HRESULT CMemoryTable::SetWriteRowAction (ULONG i_iRow, DWORD i_eAction)
{
	DWORD*	pdwAction;
	LPVOID	pvWriteRow;
	HRESULT	hr;

	 // ie: Assert cache writable or loading.
	ASSERT((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) || (fCACHE_LOADING & m_fCache)))
		return E_NOTIMPL;

	ASSERT (eST_ROW_IGNORE == i_eAction || eST_ROW_INSERT == i_eAction || eST_ROW_UPDATE == i_eAction || eST_ROW_DELETE == i_eAction);
	if (!(eST_ROW_IGNORE == i_eAction || eST_ROW_INSERT == i_eAction || eST_ROW_UPDATE == i_eAction || eST_ROW_DELETE == i_eAction))
		return E_INVALIDARG;

	if (FAILED(hr = GetRowFromIndex(eCURSOR_WRITE, i_iRow, &pvWriteRow)))
		return hr;

// Set the action part of the current write row:
	pdwAction = pdwDataActionPart (pvWriteRow);
	ASSERT (NULL != pdwAction);
	*pdwAction = i_eAction;
	return hr;
}

// =======================================================================
HRESULT CMemoryTable::ChangeWriteColumnStatus (ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus)
{
	BYTE*			pbStatus;
	BYTE			bStatusChange;
	LPVOID			pvWriteRow;
	HRESULT			hr;

	// ie: Assert cache writeable and ready.
	ASSERT ((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache)))
		return E_NOTIMPL;

// Parameter validation: column ordinal:
	// ie: Note column out of range (do not assert).
	if (i_iColumn >= m_cColumns)
		return E_ST_NOMORECOLUMNS;

	if (FAILED(hr = GetRowFromIndex(eCURSOR_WRITE, i_iRow, &pvWriteRow)))
		return hr;
	ASSERT (NULL != pvWriteRow);

	bStatusChange = (BYTE) i_fStatus;
	pbStatus = pbDataStatusPart (pvWriteRow, i_iColumn);
	switch (bStatusChange)
	{
		case 0:
			(*pbStatus) &= ~fST_COLUMNSTATUS_CHANGED;
		break;
		case fST_COLUMNSTATUS_CHANGED:
			(*pbStatus) |= fST_COLUMNSTATUS_CHANGED;
		break;

		default:
		ASSERT ( ( bStatusChange == 0 ) || ( bStatusChange == fST_COLUMNSTATUS_CHANGED ) );
		return E_INVALIDARG;
	}
	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::AddDetailedError (STErr* i_pSTErr)
{
	STErr*	pSTErr;
	ULONG	cErrs;
	HRESULT	hr;

	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache);
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return E_ST_INVALIDCALL;

	// ie: Assert non-null detailed error.
	ASSERT (NULL != i_pSTErr);
	if (NULL == i_pSTErr)
		return E_INVALIDARG;

// Verify indices:
	cErrs	= m_cErrs;
	pSTErr	= pSTErrPart (cErrs - 1);

// Add error:
	hr = AddErrorToErrorCache (i_pSTErr);
	return hr;
}

// ==================================================================
STDMETHODIMP CMemoryTable::GetMarshallingInterface (IID * o_piid, LPVOID * o_ppItf)
{
	// parameter validation
	ASSERT(NULL != o_piid);
	if (NULL == o_piid)
		return E_INVALIDARG;
	ASSERT(NULL != o_ppItf);
	if (NULL == o_ppItf)
		return E_INVALIDARG;

//	if(fST_LOS_MARSHALLABLE & m_fTable)
//	{ // ie: we are a marshallable table
		*o_piid = IID_ISimpleTableMarshall;
		*o_ppItf = (ISimpleTableMarshall *)this;
		((ISimpleTableMarshall *) *o_ppItf)->AddRef();
		return S_OK;
/*	}
	else
	{// ie: we are NOT a marshallable table
		return E_NOTIMPL;
	} */
}

// -----------------------------------------
// CSimpleTableDataTableCursor: ISimpleTableAdvanced:
// -----------------------------------------

// ==================================================================
STDMETHODIMP CMemoryTable::PopulateCache ()
{
	PrePopulateCache (0);
	PostPopulateCache ();
    return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::GetDetailedErrorCount (ULONG* o_pcErrs)
{
	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache);
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return E_ST_INVALIDCALL;

	// ie: Assert non-null error count destination.
	ASSERT (NULL != o_pcErrs);
	if (NULL == o_pcErrs)
		return E_INVALIDARG;

	*o_pcErrs = m_cErrs;
	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::GetDetailedError (ULONG i_iErr, STErr* o_pSTErr)
{
	STErr*	pSTErr;

	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache);
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return E_ST_INVALIDCALL;

	// ie: Assert non-null error pointer pointer and null error pointer.
	ASSERT (NULL != o_pSTErr);
	if (NULL == o_pSTErr)
		return E_INVALIDARG;
	// ie: Note detailed error is out of range (do not assert).
	if (!(0 < m_cErrs && i_iErr < m_cErrs))
		return E_ST_NOMOREERRORS;

	pSTErr				= pSTErrPart (i_iErr);
	o_pSTErr->iRow		= pSTErr->iRow;
	o_pSTErr->hr		= pSTErr->hr;
	o_pSTErr->iColumn	= pSTErr->iColumn;

	return S_OK;
}

// ==================================================================
STDMETHODIMP CMemoryTable::ResetCaches ()
{
// Flag cache as not ready and clean the caches:
	m_fCache &= ~fCACHE_READY;
	ResetReadCache ();
	ResetWriteCache ();
	ResetErrorCache ();
	return S_OK;
}

STDMETHODIMP CMemoryTable::GetColumnValuesEx (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
	ASSERT(fCACHE_READY & m_fCache);
	if (!(fCACHE_READY & m_fCache))
		return E_ST_INVALIDCALL;

	return (GetEitherColumnValues (i_iRow, eCURSOR_READ, i_cColumns, i_aiColumns, o_afStatus, o_acbSizes , o_apvValues));
}


// -----------------------------------------
// CSimpleTableDataTableCursor: ISimpleTableMarshall:
// -----------------------------------------

// =======================================================================
HRESULT CMemoryTable::SupplyMarshallable
(
	DWORD i_fCaches,
	char **	o_ppv1,	ULONG *	o_pcb1,
	char **	o_ppv2, ULONG *	o_pcb2,
	char **	o_ppv3, ULONG *	o_pcb3,
	char **	o_ppv4, ULONG *	o_pcb4,
	char **	o_ppv5,	ULONG *	o_pcb5
)
{
	HRESULT		hr = S_OK;
//	areturn_on_fail ((m_fTable & fST_LOS_MARSHALLABLE), E_NOTIMPL);// ie: Assert table marshallable.

    UNREFERENCED_PARAMETER(o_ppv4);
    UNREFERENCED_PARAMETER(o_pcb4);
	UNREFERENCED_PARAMETER(o_ppv5);
	UNREFERENCED_PARAMETER(o_pcb5);

	// ie: Assert cache is ready.
	ASSERT(fCACHE_READY & m_fCache);
	if (!(fCACHE_READY & m_fCache))
		return E_ST_INVALIDCALL;

	// ie: Assert supported caches.
	ASSERT (0 == (~maskfST_MCACHE & i_fCaches));
	if (0 != (~maskfST_MCACHE & i_fCaches))
		return E_INVALIDARG;

// Supply the requested cache buffers and note they were marshalled:
	if(fST_MCACHE_READ & i_fCaches) // ie: Read cache:
	{
		*o_ppv1					= (char *)m_pvReadCache;
		*o_pcb1					= m_cbReadCache;
		*o_ppv2					= NULL;
		*o_pcb2					= m_cbReadVarData;
		m_fCache	|= (fST_MCACHE_READ);
	}
	if(fST_MCACHE_WRITE & i_fCaches || fST_MCACHE_WRITE_COPY & i_fCaches) // ie: Write cache:
	{
		hr = ShrinkWriteCache ();
		if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }
		*o_ppv1					= (char *)m_pvWriteCache;
		*o_pcb1					= m_cbWriteCache;
		*o_ppv2					= NULL;
		*o_pcb2					= m_cbWriteVarData;
		if(fST_MCACHE_WRITE & i_fCaches)
		{
			m_fCache	|= (fST_MCACHE_WRITE);
		}
	}
	if(fST_MCACHE_ERRS & i_fCaches) // ie: Error cache:
	{
		*o_ppv3					= (char *)m_pvErrs;
		*o_pcb3					= m_cErrs * sizeof (STErr);
		m_fCache	|= fST_MCACHE_ERRS;
	}

	return S_OK;
}

// =======================================================================
HRESULT CMemoryTable::ConsumeMarshallable
(
	DWORD i_fCaches,
	char * i_pv1, ULONG i_cb1,
	char * i_pv2, ULONG i_cb2,
	char * i_pv3, ULONG i_cb3,
	char * i_pv4, ULONG i_cb4,
	char * i_pv5, ULONG i_cb5
)
{
    UNREFERENCED_PARAMETER(i_pv2);
    UNREFERENCED_PARAMETER(i_pv4);
    UNREFERENCED_PARAMETER(i_cb4);
    UNREFERENCED_PARAMETER(i_pv5);
    UNREFERENCED_PARAMETER(i_cb5);

//	areturn_on_fail ((m_fTable & fST_LOS_MARSHALLABLE), E_NOTIMPL);// ie: Assert table marshallable.
	// ie: Assert cache is not loading.
	ASSERT (!(fCACHE_LOADING & m_fCache));
	if (fCACHE_LOADING & m_fCache)
		return E_ST_INVALIDCALL;
	// ie: Assert cache metainitialized.
	ASSERT ((fCACHE_METAINITIALIZED & m_fCache));
	if (!((fCACHE_METAINITIALIZED & m_fCache)))
		return E_ST_INVALIDCALL;

	// ie: Assert supported caches.
	ASSERT (0 == (~maskfST_MCACHE & i_fCaches));
	if (0 != (~maskfST_MCACHE & i_fCaches))
		return E_INVALIDARG;

// Consume the requested cache buffers and note they were marshalled (cleanup current buffers and compute new maximums):
	if(fST_MCACHE_READ & i_fCaches) // ie: Read cache:
	{
		CleanupReadCache();
		m_pvReadCache		= i_pv1;
		m_cbReadCache		= i_cb1;
		m_cbReadVarData		= i_cb2;
		m_cbmaxReadCache	= m_cbReadCache;
		m_cReadRows			= (m_cbReadCache - m_cbReadVarData) / cbDataTotalParts();
		m_pvReadVarData		= (BYTE *)m_pvReadCache + (m_cbReadCache - m_cbReadVarData);
		m_fCache			|= fST_MCACHE_READ;
	}
	if(fST_MCACHE_WRITE & i_fCaches || fST_MCACHE_WRITE_COPY & i_fCaches) // ie: Write cache:
	{
		if (!(fST_MCACHE_WRITE_MERGE & i_fCaches))
		{
			CleanupWriteCache();
			m_pvWriteCache		= i_pv1;
			m_cbWriteCache		= i_cb1;
			m_cbWriteVarData	= i_cb2;
			m_cbmaxWriteCache	= m_cbWriteCache;
			m_cWriteRows		= (m_cbWriteCache - m_cbWriteVarData) / cbDataTotalParts();
			m_pvWriteVarData	= (BYTE *)m_pvWriteCache + (m_cbWriteCache - m_cbWriteVarData);
			if(fST_MCACHE_WRITE & i_fCaches)
			{
				m_fCache			|= fST_MCACHE_WRITE;
			}
		}
		else
		{
			// Merge the memory buffers.
			m_pvWriteCache = CoTaskMemRealloc (m_pvWriteCache, m_cbWriteCache + i_cb1);
			if(NULL == m_pvWriteCache) return E_OUTOFMEMORY;
			m_pvWriteVarData = (BYTE *)m_pvWriteCache + (m_cbWriteCache - m_cbWriteVarData);
			memmove((BYTE*)m_pvWriteVarData + i_cb1, m_pvWriteVarData, m_cbWriteVarData);
			memcpy(m_pvWriteVarData, i_pv1, i_cb1);
			// Fix the pointers and sizes.
			m_cbWriteCache		+= i_cb1;
			m_cbWriteVarData	+= i_cb2;
			m_cbmaxWriteCache	= m_cbWriteCache;
			m_cWriteRows		= (m_cbWriteCache - m_cbWriteVarData) / cbDataTotalParts();
			m_pvWriteVarData	= (BYTE *)m_pvWriteCache + (m_cbWriteCache - m_cbWriteVarData);

			// Fix the variable data indices.
			PostMerge(m_cWriteRows - ((i_cb1 - i_cb2) / cbDataTotalParts()),	// Old number of rows.
						(i_cb1 - i_cb2) / cbDataTotalParts(),					// Additional number of rows.
						m_cbWriteVarData - i_cb2);								// Old m_cbWriteVarData.
		}

	}
	if(fST_MCACHE_ERRS & i_fCaches) // ie: Error cache:
	{
		CleanupErrorCache();
		m_pvErrs			= i_pv3;
		m_cErrs				= i_cb3 / sizeof (STErr);
		m_cmaxErrs			= m_cErrs;
		m_fCache			|= fST_MCACHE_ERRS;
	}

// Mark the cache ready:
	m_fCache |= fCACHE_READY;

	return S_OK;
}


//=================================================================================
// Update the variable data indices of i_cMergeRows many rows, starting from row
// i_iStartRow. All indices will be incremented by i_iDelta.
//=================================================================================
void CMemoryTable::PostMerge (ULONG i_iStartRow, ULONG i_cMergeRows, ULONG i_iDelta)
{
	DWORD		fColumn;
	LPVOID*		ppvValue;
	BYTE		bStatus;
	LPVOID		pvRow;
	ULONG		cbRow;
	ULONG		iColumn;

	cbRow = cbDataTotalParts ();
	pvRow = (BYTE*)m_pvWriteCache + (i_iStartRow * cbRow);

	while (i_cMergeRows-- > 0)
	{
		for(iColumn = 0; iColumn < m_cColumns; iColumn++)
		{
			fColumn		= m_acolmetas[iColumn].fMeta;
			bStatus		= *(pbDataStatusPart (pvRow, iColumn));
			ppvValue	= ppvDataValuePart (pvRow, iColumn);

			if (fCOLUMNMETA_VARIABLESIZE & fColumn) // ie: Column data size varies:
			{
				if (fST_COLUMNSTATUS_NONNULL & bStatus) // ie: Index exists:
				{
					*(ULONG*)ppvValue += i_iDelta;
				}
			}
		}
		pvRow = (BYTE *)pvRow + cbRow;
	}
}

//=================================================================================
inline HRESULT CMemoryTable::SetupMeta (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbDefSizes)
{
	ULONG				iColumn;
	DWORD				fHasPrimaryKey;
	SimpleColumnMeta*	pcolmeta;
	ColumnDataOffsets*	pcoloffsets;
	ULONG				cbStatusParts;
	ULONG				cbValueParts;

	// ie: Assert cache is totally uninitialized.
	ASSERT (0 == m_fCache);
	if (0 != m_fCache)
		return E_ST_INVALIDCALL;
	// ie: Assert maximum columns (supported by ColumnDataOffsets).
	ASSERT (i_cColumns < 32768);
	if (!(i_cColumns < 32768))
		return E_INVALIDARG;

// Initialize the table flags, column count, column meta, column offsets:
	m_fTable					= i_fTable;
	m_cColumns					= i_cColumns;

	ASSERT (NULL == m_acolmetas);
	m_acolmetas = (SimpleColumnMeta*) new SimpleColumnMeta[m_cColumns];
	if(NULL == m_acolmetas) return E_OUTOFMEMORY;
	memcpy (m_acolmetas, i_acolmetas, m_cColumns * sizeof (SimpleColumnMeta));
	ASSERT (NULL == m_acoloffsets);
	m_acoloffsets = (ColumnDataOffsets*) new ColumnDataOffsets[m_cColumns];
	if(NULL == m_acoloffsets) return E_OUTOFMEMORY;
	if (i_apvDefaults)
	{
		ASSERT (NULL == m_acolDefaults);
		m_acolDefaults = (LPVOID*) new LPVOID[m_cColumns];
		if(NULL == m_acolDefaults) return E_OUTOFMEMORY;
		memcpy (m_acolDefaults, i_apvDefaults, m_cColumns * sizeof (LPVOID));
		ASSERT (NULL == m_alDefSizes);
		m_alDefSizes = (ULONG*) new ULONG[m_cColumns];
		if(NULL == m_alDefSizes) return E_OUTOFMEMORY;
		memcpy (m_alDefSizes, i_acbDefSizes, m_cColumns * sizeof (ULONG));
	}

// Setup extended meta information:
	for
	(
	// Initialization:
		iColumn = 0,
		pcolmeta = m_acolmetas,
		pcoloffsets = m_acoloffsets,
		m_cUnknownSizes = 0,
		cbValueParts = 0,
		fHasPrimaryKey = FALSE;
	// Termination:
		iColumn < m_cColumns;
	// Iteration:
		iColumn++,
		pcolmeta = &(m_acolmetas[iColumn]),
		pcoloffsets = &(m_acoloffsets[iColumn])
	)
	{

	// Assert size specified is valid:
		switch (pcolmeta->dbType)
		{
		// Check the size is not zero for not sized-by-type columns
			case DBTYPE_BYTES:
			case DBTYPE_WSTR:
				ASSERT (0 != pcolmeta->cbSize);
				if (0 == pcolmeta->cbSize)
					return E_ST_INVALIDMETA;
			break;
		// Check size of sized-by-type columns
			case DBTYPE_DBTIMESTAMP:
				ASSERT (pcolmeta->cbSize == sizeof (DBTIMESTAMP));
				if (pcolmeta->cbSize != sizeof (DBTIMESTAMP))
					return E_ST_INVALIDMETA;
			break;
			case DBTYPE_GUID:
				ASSERT (pcolmeta->cbSize == sizeof (GUID));
				if (pcolmeta->cbSize != sizeof (GUID))
					return E_ST_INVALIDMETA;
			break;
			case DBTYPE_UI4:
				ASSERT (pcolmeta->cbSize == sizeof (ULONG));
				if (pcolmeta->cbSize != sizeof (ULONG))
					return E_ST_INVALIDMETA;
			break;

			default:
				ASSERT ( ( pcolmeta->dbType == DBTYPE_BYTES) ||
				         ( pcolmeta->dbType == DBTYPE_WSTR) ||
				         ( pcolmeta->dbType == DBTYPE_DBTIMESTAMP) ||
				         ( pcolmeta->dbType == DBTYPE_GUID) ||
				         ( pcolmeta->dbType == DBTYPE_UI4) );
			break;
		}
		// ie: Assert flags specified are supported.
		ASSERT (0 == (~fCOLUMNMETA_MetaFlags_Mask & pcolmeta->fMeta));
		if (0 != (~fCOLUMNMETA_MetaFlags_Mask & pcolmeta->fMeta))
			return E_ST_INVALIDMETA;

	// Determine fixed-length by-type columns:
		if (DBTYPE_UI4 == pcolmeta->dbType || DBTYPE_GUID == pcolmeta->dbType || DBTYPE_DBTIMESTAMP == pcolmeta->dbType)
		{
			// ie: Assert fixed-length flag is specified.
			ASSERT (fCOLUMNMETA_FIXEDLENGTH & pcolmeta->fMeta);
			if (!(fCOLUMNMETA_FIXEDLENGTH & pcolmeta->fMeta))
				return E_ST_INVALIDMETA;
		}
	// Determine whether a primary key was specified: flag pass-by-ref primary key columns as non-nullable:
		if (fCOLUMNMETA_PRIMARYKEY & pcolmeta->fMeta)
		{
			fHasPrimaryKey = TRUE;
			// ie: Assert Not NULLable flag is specified.
			ASSERT (fCOLUMNMETA_NOTNULLABLE & pcolmeta->fMeta);
			if (!(fCOLUMNMETA_NOTNULLABLE & pcolmeta->fMeta))
				return E_ST_INVALIDMETA;
		}

	// Determine columns whose size can only be known by passing it explicitly:
		if(pcolmeta->fMeta & fCOLUMNMETA_UNKNOWNSIZE)
			m_cUnknownSizes++;

	// Pre-compute column data offsets (must be done before accumulating data buffer byte count):
		pcoloffsets->obStatus	= (WORD) iColumn;
		pcoloffsets->oulSize	= (WORD) (fCOLUMNMETA_UNKNOWNSIZE & pcolmeta->fMeta ? m_cUnknownSizes-1 : ~0);
		pcoloffsets->opvValue	= cbValueParts / sizeof (LPVOID);

	// Accumulate data buffer byte count of value:
		if (fCOLUMNMETA_VARIABLESIZE & pcolmeta->fMeta) // ie: Variable size data: buffer holds pointer to data:
		{
			cbValueParts += sizeof (LPVOID);
		}
		else // ie: Fixed size data: buffer holds data:
		{
			cbValueParts += cbWithPadding (pcolmeta->cbSize, sizeof (LPVOID)); // ie: Pad for alignment by void*.
		}
	}
	// ie: Assert a primary key was specified.
	ASSERT (fHasPrimaryKey);
	if (!(fHasPrimaryKey))
		return E_ST_INVALIDMETA;

// Determine the count of status and value parts in 32-bit units:
	cbStatusParts = cbWithPadding (iColumn, sizeof (DWORD_PTR)); // ie: Pad for alignment by dword.
	// ie: Assert 32/64-bit boundary alignment of status parts.
	ASSERT (0 == cbStatusParts % sizeof (DWORD_PTR));
	if (0 != cbStatusParts % sizeof (DWORD_PTR))
		return E_UNEXPECTED;
	m_cStatusParts = cbStatusParts / sizeof (DWORD_PTR);
	// ie: Assert 32/64-bit boundary alignment of value parts.
	ASSERT (0 == cbValueParts % sizeof (LPVOID));
	if (0 != cbValueParts % sizeof (LPVOID))
		return E_UNEXPECTED;
	m_cValueParts = cbValueParts / sizeof (LPVOID);
	m_cUnknownSizes = (cbWithPadding (m_cUnknownSizes * sizeof (ULONG), sizeof (ULONG_PTR))) / sizeof (ULONG); // ie: Align size parts on 32/64-bit boundary as necessary.

// Adjust column data offsets (buffer contents ordered by statuses, then lengths, then values):
	for (iColumn = 0, pcoloffsets = m_acoloffsets; iColumn < m_cColumns; iColumn++, pcoloffsets = &(m_acoloffsets[iColumn]))
	{
		pcoloffsets->obStatus += 0;
#pragma warning( push, 3 )
		pcoloffsets->oulSize  += ( ((WORD) ~0) == pcoloffsets->oulSize ? 0 : (WORD) m_cStatusParts);
#pragma warning( pop )
		pcoloffsets->opvValue += (WORD) (m_cStatusParts + m_cUnknownSizes);
	}

// Flag the cache as meta initialized:
	m_fCache = fCACHE_METAINITIALIZED;
	return S_OK;
}

// -----------------------------------------
// Cache management:
// -----------------------------------------

//=================================================================================
void CMemoryTable::CleanupCaches ()
{
// Flag cache as not ready and clean the caches:
	m_fCache &= ~fCACHE_READY;
	CleanupReadCache ();
	CleanupWriteCache ();
	CleanupErrorCache ();
	return;
}

//=================================================================================
// How does the cache grow?
// The first allocation is of size m_cbMinCache.
//		(unless the caller has requested for more than m_cbMinCache)
// Then we double the size of the fast cache.
//		(unless the caller requested for more memory than the current size
//		in which case we make the size double of the request)
// We never grow the size of the fast cache by more than cbmaxDATAGROWTH.
//		(unless the caller has asked for more than cbmaxDATAGROWTH)
//=================================================================================
HRESULT CMemoryTable::ResizeCache (DWORD i_fCache, ULONG i_cbRequest)
{
	LPVOID* ppv;
	LPVOID  pvTmp;
	LPVOID  pvNew = NULL;
	LPVOID* ppvVarData = NULL;
	ULONG	cbOldSize = 0;
	ULONG   cbVarData = 0;
	ULONG   cbmaxVarDataNow = 0;
	ULONG   cbNewSize = 0;

	switch (i_fCache)
	{
		case fST_MCACHE_WRITE:
			if (i_cbRequest > cbmaxDATAGROWTH)
			{
				cbNewSize = m_cbmaxWriteCache + i_cbRequest;
			}
			else if ((m_cbmaxWriteCache == 0) && (i_cbRequest < m_cbMinCache))
			{
				cbNewSize = m_cbMinCache;
			}
			else
			{
				cbmaxVarDataNow = (m_cbmaxWriteCache < i_cbRequest ? i_cbRequest * 2 : m_cbmaxWriteCache * 2);
				cbNewSize = (cbmaxDATAGROWTH < (cbmaxVarDataNow - m_cbmaxWriteCache) ? m_cbmaxWriteCache + cbmaxDATAGROWTH : cbmaxVarDataNow);
			}

			ppv = &m_pvWriteCache;
			ppvVarData = &m_pvWriteVarData;
			cbVarData = m_cbWriteVarData;
			cbOldSize = m_cbmaxWriteCache;

		break;
		case fST_MCACHE_ERRS:
			ppv = &m_pvErrs;
			cbOldSize = m_cErrs * sizeof (STErr);
			cbNewSize = i_cbRequest;
		break;
		default:
			ASSERT ( ( i_fCache == fST_MCACHE_WRITE) || ( i_fCache == fST_MCACHE_ERRS)); // ie: Unknown cache: module programming mistake.
		return E_UNEXPECTED;
	}

	if((m_fTable & fST_LOSI_CLIENTSIDE) || !(m_fCache & i_fCache)) // ie: Not marshalled or on the client: automatic reallocation works:
	{
		pvNew = CoTaskMemRealloc (*ppv, cbNewSize);
		if(NULL == pvNew) return E_OUTOFMEMORY;
		*ppv = pvNew;
	}
	else // ie: Marshalled and on the server: manual transfer required:
	{
		ASSERT (cbOldSize <= cbNewSize); // Resize will exclude valid data: module programming mistake.
		m_fCache &= ~i_fCache;
		pvTmp = *ppv;
		// ie: Just forget the marshalled cache. i.e. pass NULL as your first param.
		pvNew = CoTaskMemRealloc (NULL, cbNewSize);
		if(NULL == pvNew) return E_OUTOFMEMORY;
		*ppv = pvNew;
		memcpy (*ppv, pvTmp, cbOldSize);
	}

// For write cache only.
	if (i_fCache & fST_MCACHE_WRITE)
	{
		// Slide the variable data cache to the end of the memory blob.
		*ppvVarData = ((BYTE*)*ppv) + (cbNewSize - cbVarData);
		memmove(*ppvVarData,
				((BYTE*)*ppvVarData) - (cbNewSize - cbOldSize),
				cbVarData);
		m_cbmaxWriteCache = cbNewSize;
	}
	return S_OK;
}

//=================================================================================
void CMemoryTable::CleanupReadCache ()
{
// Free the read cache (always on the client or only on the server if not marshalled):
	if((m_fTable & fST_LOSI_CLIENTSIDE) || !(m_fCache & fST_MCACHE_READ))
	{
		if (NULL != m_pvReadCache) { delete m_pvReadCache; m_pvReadCache = NULL; }
		m_fCache &= ~fST_MCACHE_READ;
	}

// Clear the read cache:
	m_cReadRows			= 0;
	m_cbReadVarData		= 0;
	m_pvReadCache		= NULL;
	m_pvReadVarData		= NULL;
	m_cbReadCache		= 0;
	m_cbmaxReadCache	= 0;

	return;
}

//=================================================================================
// Without freeing the memory of the cache, reset the count of rows to 0. If a client
// is reusing a cache over and over, calling PopulateCache in between (to free the
// contents) won't have the perf hit of allocations and free.
//=================================================================================
void CMemoryTable::ResetReadCache ()
{

// Reset the read cache:
	m_cReadRows			= 0;
	m_cbReadVarData		= 0;
	m_cbReadCache		= 0;

    // The variable data section points to the end of the cache, since we don't have
    // any variable data.
	m_pvReadVarData		= (BYTE*)m_pvReadCache + m_cbmaxReadCache;

	return;
}

//=================================================================================
void CMemoryTable::CleanupWriteCache ()
{
// Free the write cache (always on the client or only on the server if not marshalled):
	if((m_fTable & fST_LOSI_CLIENTSIDE) || !(m_fCache & fST_MCACHE_WRITE))
	{
		if (NULL != m_pvWriteCache) { delete m_pvWriteCache; m_pvWriteCache = NULL; }
		m_fCache &= ~fST_MCACHE_WRITE;
	}

// Clear the write cache:
	m_cWriteRows		= 0;
	m_cbWriteVarData	= 0;
	m_pvWriteCache		= NULL;
	m_pvWriteVarData	= NULL;
	m_cbWriteCache		= 0;
	m_cbmaxWriteCache	= 0;

	return;
}

//=================================================================================
// Without freeing the memory of the cache, reset the count of rows to 0. If a client
// is reusing a cache over and over, calling PopulateCache in between (to free the
// contents) won't have the perf hit of allocations and free.
//=================================================================================
void CMemoryTable::ResetWriteCache ()
{

// Reset the Write cache:
	m_cWriteRows		= 0;
	m_cbWriteVarData	= 0;
	m_cbWriteCache		= 0;

    // The variable data section points to the end of the cache, since we don't have
    // any variable data.
	m_pvWriteVarData	= (BYTE*)m_pvWriteCache + m_cbmaxWriteCache;

	return;
}

//=================================================================================
void CMemoryTable::CleanupErrorCache ()
{
// Free the error cache (always on the client or only on the server if not used in marshalling):
	if((m_fTable & fST_LOSI_CLIENTSIDE) || !(m_fCache & fST_MCACHE_ERRS))
	{
		if (NULL != m_pvErrs) { delete m_pvErrs; m_pvErrs = NULL; }
		m_fCache &= ~fST_MCACHE_ERRS;
	}

// Clear the error cache:
	m_cErrs				= 0;
	m_cmaxErrs			= 0;
	m_pvErrs			= NULL;

	return;
}

//=================================================================================
// Without freeing the memory of the cache, reset the count of rows to 0. If a client
// is reusing a cache over and over, calling PopulateCache in between (to free the
// contents) won't have the perf hit of allocations and free.
//=================================================================================
void CMemoryTable::ResetErrorCache ()
{

// Reset the error cache:
	m_cErrs				= 0;

	return;
}

//=================================================================================
HRESULT CMemoryTable::ShrinkWriteCache ()
{
	LPVOID		pvNewWriteVarData, pvTmp;
	HRESULT		hr = S_OK;

// Shrink the cache as necessary:
	if (m_cbWriteCache < m_cbmaxWriteCache)
	{
		pvNewWriteVarData = (BYTE*)m_pvWriteCache + (m_cWriteRows * cbDataTotalParts());
		memmove(pvNewWriteVarData, m_pvWriteVarData, m_cbWriteVarData);
		m_cbmaxWriteCache = m_cbWriteCache;

		if((m_fTable & fST_LOSI_CLIENTSIDE) || !(m_fCache & fST_MCACHE_WRITE)) // ie: Not marshalled or on the client: automatic reallocation works:
		{
			m_pvWriteCache = CoTaskMemRealloc (m_pvWriteCache, m_cbWriteCache);
			if(NULL == m_pvWriteCache) return E_OUTOFMEMORY;
		}
		else // ie: Marshalled and on the server: manual transfer required:
		{
			m_fCache &= ~fST_MCACHE_WRITE;
			pvTmp = m_pvWriteCache;
			m_pvWriteCache = NULL; // ie: Just forget the marshalled cache.
			m_pvWriteCache = CoTaskMemRealloc (m_pvWriteCache, m_cbWriteCache);
			if(NULL == m_pvWriteCache) return E_OUTOFMEMORY;
			memcpy (m_pvWriteCache, pvTmp, m_cbWriteCache);
		}
		m_pvWriteVarData = (BYTE*)m_pvWriteCache + (m_cWriteRows * cbDataTotalParts());
	}
	return hr;
}

//=================================================================================
// Function: CMemoryTable::RemoveDeletedRows
//
// Synopsis: Removes rows marked as 'DELETED' from the write cache. The function keeps
//           rows in the correct order, and uses a state machine to copy the non-deleted
//           rows quickly.
//			 We have three states:
//				INITIALIZE  We are at the beginning of array, and have not found any
//							deleted elements yet. We don't have to copy these elements
//							and have a separate state to show this.
//				DELETE		We found an element that needs to be deleted
//				COPY		We found an element that needs to be copied after we found
//							an element that gets deleted
//
//			When we find an element that needs to be deleted, we skip over the neighbours
//          that need to be deleted as well. As soon as we find an element that needs to
//          be copied we go into COPY mode and find all neighbours of that element that
//          needs to be copied as well. This means that we will moving blocks of 'valid
//          data' at a time, instead of copying single block.
//=================================================================================
void CMemoryTable::RemoveDeletedRows ()
{
	ASSERT(m_cWriteRows > 0);

	enum MODE
	{
		MODE_INITIALIZE = 1,
		MODE_DELETE		= 2,
		MODE_COPY		= 3
	};

	ULONG cbRow				= cbDataTotalParts ();
	ULONG iInsertionPoint	= 0;					// where should we copy valid rows to
	ULONG iCopyStart		= 0;					// where should we start copying from
	ULONG cNrElemsToCopy	= 0;					// number of elements to copy
	ULONG cNrNonDeletes		= 0;					// number of non-deleted elements
	ULONG iMode				= MODE_INITIALIZE;		// state/mode

	for (ULONG idx=0; idx < m_cWriteRows; ++idx)
	{
		DWORD *pdwDeletedAction = pdwDataActionPart ((BYTE *)m_pvWriteCache + (idx *cbRow));
		if (*pdwDeletedAction == eST_ROW_DELETE)
		{
			switch (iMode)
			{
			case MODE_INITIALIZE:
				// we found the first element that is marked as deleted.
				iInsertionPoint = idx;
				iMode = MODE_DELETE;
				break;

			case MODE_COPY:
				// we found an element that needs to be deleted after a block of valid
				// elements. Copy the block of valid elements to the insertpoint
				ASSERT (cNrElemsToCopy > 0);
				ASSERT (iInsertionPoint < iCopyStart);
				memmove ((BYTE *)m_pvWriteCache + (iInsertionPoint * cbRow),
						 (BYTE *)m_pvWriteCache + (iCopyStart * cbRow),
						 cNrElemsToCopy * cbRow);
				iInsertionPoint += cNrElemsToCopy;
				cNrElemsToCopy = 0;
				iMode = MODE_DELETE;
				break;

			default:
				// do nothing
				break;
			}
		}
		else
		{
			++cNrNonDeletes;
			switch (iMode)
			{
			case MODE_DELETE:
				// we found an element after a block of deleted elements. Go into copy
				// mode to count the number of elements that needs to be copied. Also keep
				// track of where the valid element block started with iCopyStart
				iMode = MODE_COPY;
				iCopyStart = idx;
				cNrElemsToCopy = 1;
				break;
			case MODE_COPY:
				++cNrElemsToCopy;
				break;
			default:
				break;
			}
		}
	}

	// When the cache has some valid elements at the end of the cache, we need to copy
	// these elements as well. This needs to happen after we have walked through all the
	// elements.
	if (cNrElemsToCopy != 0)
	{
		ASSERT (iInsertionPoint < iCopyStart);
		memmove ((BYTE *)m_pvWriteCache + (iInsertionPoint * cbRow),
				 (BYTE *)m_pvWriteCache + (iCopyStart * cbRow),
				 cNrElemsToCopy * cbRow);
	}

	m_cbWriteCache -= ((m_cWriteRows - cNrNonDeletes) * cbDataTotalParts());
	m_cWriteRows = cNrNonDeletes;
}

//=================================================================================
HRESULT CMemoryTable::AddRowToWriteCache (ULONG* o_piRow, LPVOID* o_ppvRow)
{
	HRESULT		hr = S_OK;

	if (m_cbWriteCache + cbDataTotalParts() > m_cbmaxWriteCache)
	{
		hr = ResizeCache (fST_MCACHE_WRITE, cbDataTotalParts());
		if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }
	}

// Supply the index of and pointer to the added row:
	*o_piRow = m_cWriteRows;
	*o_ppvRow = ( ((LPVOID*) m_pvWriteCache) + ( cDataTotalParts() * m_cWriteRows ) );

// Increment the count of rows filled and clear the current row:
	m_cWriteRows++;
	memset (*o_ppvRow, 0, cbDataTotalParts());
	m_cbWriteCache += cbDataTotalParts();

	return hr;
}

//=================================================================================
HRESULT CMemoryTable::AddVarDataToWriteCache (ULONG i_cb, LPVOID i_pv, ULONG** o_pib)
{
	ULONG		cbPadded;
	ULONG		cbColumnOffset;
	HRESULT		hr = S_OK;

// Grow vardata cache as necessary:
	cbPadded = cbWithPadding (i_cb, sizeof (DWORD_PTR));
	if (m_cbWriteCache + cbPadded > m_cbmaxWriteCache)
	{
		cbColumnOffset = (ULONG)((BYTE*)*o_pib - (BYTE*)m_pvWriteCache);
		hr = ResizeCache (fST_MCACHE_WRITE, cbPadded);
		if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }
		// Let the caller know about the resize.
		hr = S_FALSE;
		*o_pib = (ULONG*)((BYTE*)m_pvWriteCache + cbColumnOffset);
	}

// Copy the data, supply its index, and increment the count of bytes filled:
	m_pvWriteVarData = ((BYTE*) m_pvWriteVarData) - cbPadded;
	memcpy (m_pvWriteVarData, i_pv, i_cb);
	m_cbWriteVarData += cbPadded;
	**o_pib = m_cbWriteVarData;
	m_cbWriteCache += cbPadded;

	return hr;
}

//=================================================================================
HRESULT CMemoryTable::AddErrorToErrorCache (STErr* i_pSTErr)
{
	ULONG		cmaxErrsNow;
	HRESULT		hr = S_OK;

	if (m_cErrs == m_cmaxErrs)
	{
		cmaxErrsNow = (m_cmaxErrs * 2) + 1;
		ULONG cMaxErrsNewSize = (cmaxERRGROWTH < (cmaxErrsNow - m_cmaxErrs) ? m_cmaxErrs + cmaxERRGROWTH : cmaxErrsNow);
		hr = ResizeCache (fST_MCACHE_ERRS, cMaxErrsNewSize * sizeof (STErr));
		if (FAILED (hr))
		{
			ASSERT (hr == S_OK);
			return hr;
		}
		m_cmaxErrs = cMaxErrsNewSize;

	}

// Copy error into cache and increment error count:
	memcpy ( (LPVOID) (((STErr*) m_pvErrs) + m_cErrs), i_pSTErr, sizeof (STErr));
	m_cErrs++;

	return hr;
}

//=================================================================================
void CMemoryTable::BeginReadCacheLoading ()
{
	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache);
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return;
	// ie: Assert cache is not already loading.
	ASSERT (!(fCACHE_LOADING & m_fCache));
	if (fCACHE_LOADING & m_fCache)
		return;

// Flag the cache as loading:
	m_fCache |= fCACHE_LOADING;

// Clean the previous caches:
	CleanupCaches ();
	return;
}

//=================================================================================
void CMemoryTable::ContinueReadCacheLoading ()
{
	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache);
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return;
	// ie: Assert cache is not already loading.
	ASSERT (!(fCACHE_LOADING & m_fCache));
	if (fCACHE_LOADING & m_fCache)
		return;

// Flag the cache as loading (and no longer ready):
	m_fCache &= ~fCACHE_READY;
	m_fCache |= (fCACHE_LOADING | fCACHE_CONTINUING);

// Clean only the write cache:
	CleanupWriteCache ();

// Write cache now impersonates the read cache:
	m_cWriteRows		= m_cReadRows;
	m_cbWriteVarData	= m_cbReadVarData;
	m_pvWriteCache		= m_pvReadCache;
	m_pvWriteVarData	= m_pvReadVarData;
	m_cbWriteCache		= m_cbReadCache;
	m_cbmaxWriteCache	= m_cbmaxReadCache;

	return;
}

//=================================================================================
void CMemoryTable::EndReadCacheLoading ()
{
	// ie: Assert meta initialized.
	ASSERT (fCACHE_METAINITIALIZED & m_fCache);
	if (!(fCACHE_METAINITIALIZED & m_fCache))
		return;
	// ie: Assert cache is loading.
	ASSERT (fCACHE_LOADING & m_fCache);
	if (!(fCACHE_LOADING & m_fCache))
		return;
	// ie: Assert cache was clean or we are continuing.
	ASSERT (!(fCACHE_READY & m_fCache) || (fCACHE_CONTINUING & m_fCache));
	if (!(!(fCACHE_READY & m_fCache) || (fCACHE_CONTINUING & m_fCache)))
		return;

// Assert cache loading succeeded:
	if (fCACHE_INVALID & m_fCache) // ie: Cache loading failed: flag cache as un-useable:
	{
		m_fCache &= ~fCACHE_LOADING;
		m_fCache &= ~fCACHE_READY;
		ASSERT ( !( fCACHE_INVALID & m_fCache ) );
		return;
	}

// Transform the "populated" write cache into the "populated" read cache:
	m_cReadRows			= m_cWriteRows;
	m_cbReadVarData		= m_cbWriteVarData;
	m_pvReadCache		= m_pvWriteCache;
	m_pvReadVarData		= m_pvWriteVarData;
	m_cbReadCache		= m_cbWriteCache;
	m_cbmaxReadCache	= m_cbmaxWriteCache;

// Clear the write cache for consumer use:
	m_cWriteRows		= 0;
	m_cbWriteVarData	= 0;
	m_pvWriteCache		= NULL;
	m_pvWriteVarData	= NULL;
	m_cbWriteCache		= 0;
	m_cbmaxWriteCache	= 0;

// Flag the cache as ready to use:
	m_fCache &= ~(fCACHE_LOADING | fCACHE_CONTINUING);
	m_fCache |= fCACHE_READY;

	return;
}


// -----------------------------------------
// Offset and pointer calculation helpers:
// -----------------------------------------

// =======================================================================
inline ULONG CMemoryTable::cbWithPadding (ULONG i_cb, ULONG i_cbPadTo) { return ( (i_cb + (i_cbPadTo - 1)) & (-((LONG)i_cbPadTo)) ); }

// =======================================================================
inline ULONG CMemoryTable::cbDataTotalParts	() { return (cDataTotalParts () * sizeof (LPVOID)); }

// =======================================================================
inline ULONG CMemoryTable::cDataStatusParts	() { return (m_cStatusParts); }
inline ULONG CMemoryTable::cDataSizeParts		() { return (m_cUnknownSizes); }
inline ULONG CMemoryTable::cDataValueParts		() { return (m_cValueParts); }
inline ULONG CMemoryTable::cDataTotalParts() { return (cDataStatusParts () + cDataSizeParts () + cDataValueParts () + 1); }

// =======================================================================
inline ULONG CMemoryTable::obDataStatusPart	(ULONG i_iColumn) { return (m_acoloffsets[i_iColumn].obStatus); }
inline ULONG CMemoryTable::obDataSizePart		(ULONG i_iColumn) { return (oulDataSizePart (i_iColumn) * sizeof (ULONG_PTR)); }
inline ULONG CMemoryTable::obDataValuePart		(ULONG i_iColumn) { return (opvDataValuePart (i_iColumn) * sizeof (LPVOID)); }

// =======================================================================
inline ULONG CMemoryTable::oulDataSizePart		(ULONG i_iColumn) { return (((WORD) ~0) == m_acoloffsets[i_iColumn].oulSize ? oDOESNOTEXIST : m_acoloffsets[i_iColumn].oulSize); }
inline ULONG CMemoryTable::opvDataValuePart	(ULONG i_iColumn) { return (m_acoloffsets[i_iColumn].opvValue); }
inline ULONG CMemoryTable::odwDataActionPart	() { return (cDataTotalParts () - 1); } // Action bit is the last 4-byte of the row.

// =======================================================================
inline BYTE*	CMemoryTable::pbDataStatusPart	(LPVOID i_pv, ULONG i_iColumn) { return ( ((BYTE*) i_pv) + obDataStatusPart(i_iColumn) ); }
inline ULONG*	CMemoryTable::pulDataSizePart	(LPVOID i_pv, ULONG i_iColumn)
{
	WORD oulSize = m_acoloffsets[i_iColumn].oulSize;
	return (ULONG *)((((WORD) ~0) == oulSize ? NULL : ((BYTE *)i_pv) + sizeof(ULONG_PTR)*oulSize));
}
inline LPVOID*	CMemoryTable::ppvDataValuePart	(LPVOID i_pv, ULONG i_iColumn) { return ( ((LPVOID*) i_pv) + opvDataValuePart(i_iColumn) ); }
inline DWORD*	CMemoryTable::pdwDataActionPart	(LPVOID i_pv) { return (DWORD *)( ((BYTE *)i_pv) + sizeof(DWORD_PTR)*odwDataActionPart ()  ); }

// =======================================================================
inline LPVOID	CMemoryTable::pvVarDataFromIndex (BYTE i_statusIndex, LPVOID i_pv, ULONG i_iColumn)
{
	return ( ((BYTE*) (fCOLUMNSTATUS_READINDEX & i_statusIndex ? ((BYTE*)m_pvReadCache) + m_cbmaxReadCache : ((BYTE*)m_pvWriteCache) + m_cbmaxWriteCache)) - (*((ULONG*) ppvDataValuePart (i_pv, i_iColumn))) );
}

// =======================================================================
inline LPVOID	CMemoryTable::pvDefaultFromIndex (ULONG i_iColumn) { return (m_acolDefaults ?  m_acolDefaults[i_iColumn] :  NULL); }
inline ULONG	CMemoryTable::lDefaultSize (ULONG i_iColumn) { return (m_alDefSizes ?  m_alDefSizes[i_iColumn] :  0); }

// =======================================================================
inline STErr*	CMemoryTable::pSTErrPart (ULONG i_iErr) { return ( (((STErr*) m_pvErrs) + i_iErr) ); }

// -----------------------------------------
// Derived class helpers:
// -----------------------------------------

// =======================================================================
// Type-aware matching
BOOL CMemoryTable::InternalMatchValues(DWORD eOperator, DWORD dbType, DWORD fMeta, ULONG size1, ULONG size2, void *pv1, void *pv2)
{
	switch(eOperator)
	{
	case eST_OP_EQUAL:
		if(!(pv1 && pv2)) // ie at least one is null or zero
		{
			return (!pv1 && !pv2);
		}
		else // both pv1 and pv2 are not null
		{
			switch (dbType)
			{
			case DBTYPE_DBTIMESTAMP:
				return !::memcmp(pv1, pv2, sizeof (DBTIMESTAMP));
			break;
			case DBTYPE_GUID:
				return !::memcmp(pv1, pv2, sizeof (GUID));
			break;
			case DBTYPE_WSTR:
				if (fMeta & fCOLUMNMETA_MULTISTRING)
				{
					return MultiStringCompare ((LPCWSTR) pv1, (LPCWSTR) pv2, fMeta & fCOLUMNMETA_CASEINSENSITIVE);
				}
				else
				{
					if (fMeta & fCOLUMNMETA_CASEINSENSITIVE)
					{
						if (fMeta & fCOLUMNMETA_LOCALIZABLE)
						{
							return (CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, (LPCWSTR)pv1, -1, (LPCWSTR)pv2, -1));
						}
						return !::_wcsicmp((LPCWSTR)pv1, (LPCWSTR)pv2);
					}
					else
						return !::wcscmp((LPCWSTR)pv1, (LPCWSTR)pv2);
				}
			break;
			case DBTYPE_BYTES:
				return (size1 == size2) && !::memcmp(pv1, pv2, size1);
			break;
			case DBTYPE_UI4:
				return *(DWORD*)pv1==*(DWORD*)pv2;
			break;
			default:
				ASSERT( ( dbType == DBTYPE_DBTIMESTAMP ) ||
				        ( dbType == DBTYPE_GUID ) ||
				        ( dbType == DBTYPE_WSTR ) ||
				        ( dbType == DBTYPE_BYTES ) ||
				        ( dbType == DBTYPE_UI4 ) );
				return FALSE;
			break;
			}
		}//else
	break;
	case eST_OP_NOTEQUAL:
		if(!(pv1 && pv2)) // ie at least one is null or zero
		{
			return (pv1 || pv2);  // at least one should not be NULL/zero to succeed
		}
		else // both pv1 and pv2 are not null
		{
			switch (dbType)
			{
			case DBTYPE_DBTIMESTAMP:
				return ::memcmp(pv1, pv2, sizeof (DBTIMESTAMP));
			break;
			case DBTYPE_GUID:
				return ::memcmp(pv1, pv2, sizeof (GUID));
			break;
			case DBTYPE_WSTR:
				if (fMeta & fCOLUMNMETA_MULTISTRING)
				{
					return !MultiStringCompare ((LPCWSTR) pv1, (LPCWSTR) pv2, fMeta & fCOLUMNMETA_CASEINSENSITIVE);
				}
				else
				{
					if (fMeta & fCOLUMNMETA_CASEINSENSITIVE)
					{
						if (fMeta & fCOLUMNMETA_LOCALIZABLE)
						{
							return (CSTR_EQUAL != CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, (LPCWSTR)pv1, -1, (LPCWSTR)pv2, -1));
						}
						return ::_wcsicmp((LPCWSTR)pv1, (LPCWSTR)pv2);
					}
					else
						return ::wcscmp((LPCWSTR)pv1, (LPCWSTR)pv2);
				}
			break;
			case DBTYPE_BYTES:
				return (size1 != size2) || ::memcmp(pv1, pv2, size1);
			break;
			case DBTYPE_UI4:
				return *(DWORD*)pv1 != *(DWORD*)pv2;
			break;
			default:
				ASSERT( ( dbType == DBTYPE_DBTIMESTAMP ) ||
				        ( dbType == DBTYPE_GUID ) ||
				        ( dbType == DBTYPE_WSTR ) ||
				        ( dbType == DBTYPE_BYTES ) ||
				        ( dbType == DBTYPE_UI4 ) );
				return FALSE;
			break;
			}
		}//else
	break;
	default: // we don't support other operators (yet)
		ASSERT( ( eOperator==eST_OP_NOTEQUAL ) || ( eOperator == eST_OP_EQUAL ) );
		return FALSE;
	break;
	}
}


// -----------------------------------------
// read/write helpers:
// -----------------------------------------

// =======================================================================
HRESULT CMemoryTable::GetRowFromIndex(DWORD i_eReadOrWrite, ULONG i_iRow, VOID** o_ppvRow)
{
	HRESULT		hr = S_OK;
	ULONG		cRows;								// Count of rows present.
	ULONG		cRowTotalParts;						// Count of parts of a row.
	LPVOID*		ppvFirstRow;						// Pointer to the first row.

// Setup for either:
	switch (i_eReadOrWrite)
	{
		case eCURSOR_READ:
			cRows			= m_cReadRows;
			ppvFirstRow		= (LPVOID*) m_pvReadCache;
		break;

		case eCURSOR_WRITE:
			cRows			= m_cWriteRows;
			ppvFirstRow		= (LPVOID*) m_pvWriteCache;
		break;
		default:
			cRows 			= 0;
			ppvFirstRow		= 0;
	}

	cRowTotalParts	= cDataTotalParts ();
// Check if the row index is within limits:
	if (i_iRow >= cRows)
	{
		return E_ST_NOMOREROWS;
	}

// Index and point to the row and note we are on a row:
	*o_ppvRow = ppvFirstRow + (i_iRow * cRowTotalParts);
	return hr;
}

// =======================================================================
HRESULT CMemoryTable::MoveToEitherRowByIdentity(DWORD i_eReadOrWrite, ULONG* i_acb, LPVOID* i_apv, ULONG* o_piRow)
{
	HRESULT	hr = S_OK;
	ULONG	iKeyColumn;
	LPVOID	pv;
	ULONG	cbColSize, i;
	ULONG	iRow;
	BOOL	fColMatched;

// TODO: Do not bother checking if we are already on the row!

	// parameter validation; we need i_acb not null only for dbbytes
// TODO: Verify i_acb non-null if pk has bytes types.
	if (!i_apv)
		return E_INVALIDARG;

	if (o_piRow == 0)
		return E_INVALIDARG;

	// initialize output parameter
	*o_piRow = ~0ul;


	iRow = 0;
	// keep looking at rows until we find a match or we are out of rows
	while (E_ST_NOMOREROWS != hr)
	{
		fColMatched = TRUE;
		iKeyColumn = 0;
		i=0;
		while ((i<m_cColumns) && fColMatched)
		{
			if(m_acolmetas[i].fMeta & fCOLUMNMETA_PRIMARYKEY) // only look at key columns
			{
				//NULL PK is invalid.
				if (NULL == i_apv[iKeyColumn])
				{
                    return E_INVALIDARG;
				}

				hr = GetEitherColumnValues(iRow, i_eReadOrWrite, 1, &i, NULL, &cbColSize, &pv);
				if (FAILED (hr)) { return hr; }

				switch(m_acolmetas[i].dbType)
				{
				case DBTYPE_BYTES:
					ASSERT(i_acb);
					if (!i_acb)
						return E_INVALIDARG;
					fColMatched = InternalMatchValues(eST_OP_EQUAL, m_acolmetas[i].dbType, m_acolmetas[i].fMeta, cbColSize, i_acb[iKeyColumn], pv, i_apv[iKeyColumn]);
				break;
				default:
					fColMatched = InternalMatchValues(eST_OP_EQUAL, m_acolmetas[i].dbType, m_acolmetas[i].fMeta, 0, 0, pv, i_apv[iKeyColumn]);
				break;
				}

				// advance the index in the "in" structures
				iKeyColumn++;
			}
			if(fColMatched) i++;
		}
		if( i == m_cColumns)
		{
			*o_piRow = iRow;
			break; // we've found a match
		}
		iRow++;
	}
	return hr;
}

HRESULT CMemoryTable::GetEitherRowIndexBySearch(DWORD i_eReadOrWrite,
												ULONG i_iStartingRow, ULONG i_cColumns,
											    ULONG* i_aiColumns, ULONG* i_acbSizes,
											    LPVOID* i_apvValues, ULONG* o_piRow)
{
	HRESULT	hr = S_OK;

	LPVOID	pv;
	ULONG	cbColSize;
	ULONG	iRow;
	BOOL	fColMatched;

	if (i_cColumns > m_cColumns)
		return E_ST_NOMORECOLUMNS;

	if (i_aiColumns == 0 && i_cColumns != m_cColumns)
		return E_INVALIDARG;

	if (o_piRow == 0)
		return E_INVALIDARG;

	if (i_apvValues == 0)
		return E_INVALIDARG;

	// initialize output parameter.
	*o_piRow = ~0ul;

	iRow = i_iStartingRow;
	// keep looking at rows until we find a match or we are out of rows
	while (E_ST_NOMOREROWS != hr)
	{
		fColMatched = TRUE;
		ULONG iColToGet;
		// get the value for each column that we are interested in, and compare it
		// to the value for that column that is passed in. When all values match, the
		// whole row matches.
		for (ULONG idx=0; idx<i_cColumns; ++idx)
		{
			if (i_aiColumns == 0)
			{
				iColToGet = idx;
			}
			else
			{
				iColToGet = i_aiColumns[idx];
				if (iColToGet >= m_cColumns)
				{
					return E_ST_NOMORECOLUMNS;
				}
			}

			// get single row
			hr = GetEitherColumnValues(iRow, i_eReadOrWrite, 1, &iColToGet, NULL, &cbColSize, &pv);
			if (FAILED (hr))
			{
				return hr;
			}

			switch(m_acolmetas[iColToGet].dbType)
			{
			case DBTYPE_BYTES:
				ASSERT(i_acbSizes);
				if (!i_acbSizes)
					return E_INVALIDARG;
				fColMatched = InternalMatchValues(eST_OP_EQUAL, m_acolmetas[iColToGet].dbType, m_acolmetas[iColToGet].fMeta, cbColSize, i_acbSizes[iColToGet], pv, i_apvValues[iColToGet]);
			break;
			default:
				fColMatched = InternalMatchValues(eST_OP_EQUAL, m_acolmetas[iColToGet].dbType, m_acolmetas[iColToGet].fMeta, 0, 0, pv, i_apvValues[iColToGet]);
			break;
			}

			if (!fColMatched)
			{
				break;
			}
		}

		if (fColMatched)
		{
			*o_piRow = iRow;
			break; // break out the while loop, because we found a match
		}

		iRow++;
	}
	return hr;
}
// =======================================================================
HRESULT CMemoryTable::GetEitherColumnValues (ULONG i_iRow, DWORD i_eReadOrWrite, ULONG i_cColumns, ULONG *i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes , LPVOID* o_apvValues)
{
	DWORD			fColumn;
	BYTE			fIndex;
	LPVOID*			ppvValue;
	LPVOID			pvValue = NULL;
	BYTE			bStatus;
	LPVOID			pvRow = NULL;
	ULONG			iColumn;
	ULONG			ipv;
	ULONG			iTarget;
	HRESULT			hr			= S_OK;

// Parameter validation:
	// ie: Assert caller's buffer is valid.
	if (NULL == o_apvValues)
		return E_INVALIDARG;
	// ie: Assert count is valid.
	if (i_cColumns == 0)
		return E_INVALIDARG;

	if (i_cColumns > m_cColumns)
		return E_ST_NOMORECOLUMNS;

	if (i_eReadOrWrite == eCURSOR_READ)
	{
		fIndex = fCOLUMNSTATUS_READINDEX;
	}
	else
	{
		fIndex = fCOLUMNSTATUS_WRITEINDEX;
	}


	if (FAILED(hr = GetRowFromIndex(i_eReadOrWrite, i_iRow, &pvRow)))
		return hr;
	ASSERT(pvRow != NULL);

	for(ipv=0; ipv<i_cColumns; ipv++)
	{
		if(NULL != i_aiColumns)
			iColumn = i_aiColumns[ipv];
		else
			iColumn = ipv;

		// If caller needs one column only, he doesn't need to pass a buffer for all the columns.
		iTarget = (i_cColumns == 1) ? 0 : iColumn;

		// ie: Note column out of range (do not assert).
		if (iColumn >= m_cColumns)
		{
			hr = E_ST_NOMORECOLUMNS;
			goto Cleanup;
		}

	// Remember the column flags, status, and value reference:
		fColumn		= m_acolmetas[iColumn].fMeta;
		bStatus		= *(pbDataStatusPart (pvRow, iColumn));
		ppvValue	= ppvDataValuePart (pvRow, iColumn);

	// Get the column value:
		if (fCOLUMNMETA_VARIABLESIZE & fColumn) // ie: Column data size varies: pointer copy:
		{
			if (fST_COLUMNSTATUS_NONNULL & bStatus) // ie: Data exists:
			{
				pvValue = pvVarDataFromIndex (fIndex, pvRow, iColumn);
			}
			else // ie: No data:
			{
				// Apply defaults if the user hasn't explicitly asked not to.
				if ( (fColumn & fCOLUMNMETA_PRIMARYKEY) || !(m_fTable & fST_LOS_NODEFAULTS))
				{
					pvValue = pvDefaultFromIndex(iColumn);
				}
				else
				{
					pvValue = NULL;
				}

				if (pvValue != NULL)
				{
					bStatus |= fST_COLUMNSTATUS_DEFAULTED|fST_COLUMNSTATUS_NONNULL;
				}
			}
			o_apvValues[iTarget] = pvValue;
		}
		else // ie: Column data size fixed: value copy:
		{
			if (fST_COLUMNSTATUS_NONNULL & bStatus) // ie: Data to copy:
			{
				o_apvValues[iTarget] = ppvValue;
			}
			else // ie: No data to copy:
			{
				// Apply defaults if the user hasn't explicitly asked not to.
				if ( (fColumn & fCOLUMNMETA_PRIMARYKEY) || !(m_fTable & fST_LOS_NODEFAULTS))
				{
					o_apvValues[iTarget] = pvDefaultFromIndex(iColumn);
				}
				else
				{
					o_apvValues[iTarget] = NULL;
				}

				if (o_apvValues[iTarget] != NULL)
				{
					bStatus |= fST_COLUMNSTATUS_DEFAULTED|fST_COLUMNSTATUS_NONNULL;
				}
			}
		}

	// Get the row status (optional)
		if (o_afStatus)
		{
			o_afStatus[iTarget] = (bStatus & maskfST_COLUMNSTATUS);
		}

	// Get the column size (optional):
		if (o_acbSizes)
		{
			if (fCOLUMNMETA_VARIABLESIZE & fColumn) // ie: Column data size varies:
			{
				if (fCOLUMNMETA_UNKNOWNSIZE & fColumn) // ie: Column data size must be passed:
				{
					if (!(bStatus & fST_COLUMNSTATUS_DEFAULTED))
					{
						o_acbSizes[iTarget] = *(pulDataSizePart (pvRow, iColumn));
					}
					else
					{
						o_acbSizes[iTarget] = lDefaultSize(iColumn);
					}
				}
				else // ie: Column data size must be determined:
				{
					ASSERT (DBTYPE_WSTR == m_acolmetas[iColumn].dbType);
					ULONG cLength = 0;
					if (pvValue != 0)
					{
						if (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
						{
							cLength = (ULONG) GetMultiStringLength ((LPCWSTR) pvValue);
						}
						else
						{
							cLength = (ULONG) wcslen ((LPCWSTR) pvValue) + 1;
						}
					}
					o_acbSizes[iTarget] = (ULONG)(fST_COLUMNSTATUS_NONNULL & bStatus ? cLength * sizeof (WCHAR) : 0);
				}
			}
			else // ie: Column data size is fixed:
			{
                #define FixedAndNullable(fColumnMetaFlags) (fCOLUMNMETA_FIXEDLENGTH == ((fCOLUMNMETA_NOTNULLABLE | fCOLUMNMETA_FIXEDLENGTH) & fColumnMetaFlags))
				o_acbSizes[iTarget] = (FixedAndNullable(fColumn) && !(fST_COLUMNSTATUS_NONNULL & bStatus) ? 0 : m_acolmetas[iColumn].cbSize);
			}
		}

	} // For all columns requested

Cleanup:

	if(FAILED(hr))
	{
// Initialize out parameters
		for(ipv=0; ipv<i_cColumns; ipv++)
		{
			o_apvValues[ipv]		= NULL;
			if(NULL != o_acbSizes)
			{
				o_acbSizes[ipv]	= 0;
			}
		}
	}

	return hr;
}

// =======================================================================
HRESULT CMemoryTable::AddWriteRow(DWORD fAction, ULONG* o_piWriteRow)
{
	HRESULT hr = S_OK;
	LPVOID	pvWriteRow;	// todo: Not used, can be deleted.

// Add a row to the write cache and obtain its index and pointer:
	hr = AddRowToWriteCache (o_piWriteRow, &pvWriteRow);
	if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }

// Set the row action appropriately:
	if (fCACHE_READY & m_fCache) // ie: Adding the write cache: Set the row action:
	{
		hr = SetWriteRowAction (*o_piWriteRow, fAction);
	}// else: ie: Adding to the read cache: Row action not present.

	return hr;
}

// =======================================================================
HRESULT CMemoryTable::CopyWriteRowFromReadRow(ULONG i_iReadRow, ULONG i_iWriteRow)
{
	HRESULT	hr;
	ULONG	i;
	ULONG	cColumns = m_cColumns;

	ULONG	acb[cmaxCOLUMNS];
	LPVOID	apv[cmaxCOLUMNS];

	ULONG	*pcb		= acb;
	LPVOID	*ppv		= apv;
	BOOL	bDynAlloc	= FALSE;
	LPVOID	pvWriteRow	= NULL;

	if(cColumns > cmaxCOLUMNS)
	{
		ASSERT (NULL == pcb);
		pcb = new ULONG[cColumns];
		if(NULL == pcb) return E_OUTOFMEMORY;
		ASSERT (NULL == ppv);
		ppv = new LPVOID[cColumns];
		if(NULL == ppv) return E_OUTOFMEMORY;
		bDynAlloc = TRUE;
	}

	hr = GetColumnValues(i_iReadRow, cColumns, NULL, pcb, ppv);
	if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }

	m_fCache |= fCACHE_ROWCOPYING;
	hr = SetWriteColumnValues(i_iWriteRow, cColumns, NULL, pcb, ppv);
	m_fCache &= ~fCACHE_ROWCOPYING;
	if (FAILED (hr)) {	ASSERT (hr == S_OK); return hr; }

	if (FAILED(hr = GetRowFromIndex(eCURSOR_WRITE, i_iWriteRow, &pvWriteRow)))
		return hr;
	ASSERT(pvWriteRow != NULL);

	for(i=0; i<cColumns; i++)
	{
		BYTE	*pbStatus;

		pbStatus =  pbDataStatusPart (pvWriteRow, i);
		(*pbStatus) &= ~fST_COLUMNSTATUS_CHANGED;
	}

	if(bDynAlloc)
	{
		if (NULL != pcb) { delete[] pcb; pcb = NULL; }
		if (NULL != ppv) { delete[] ppv; ppv = NULL; }
	}

	return S_OK;
}



// -----------------------------------------
// CSimpleTableDataTableCursor: ISimpleDataTableDispenser2:
// -----------------------------------------

// =======================================================================
HRESULT CMemoryTable::InternalPreUpdateStore ()
{
	LPVOID		pvWriteRow = NULL;
	BYTE		bStatus;
	ULONG		iColumn = 0;
	ULONG		i = 0;
	HRESULT		hr = S_OK;

	// ie: Assert cache writeable and ready.
	ASSERT ((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache));
	if (!((m_fTable & fST_LOS_READWRITE) && (fCACHE_READY & m_fCache)))
		return E_NOTIMPL;

	// TODO: Validate that all NOTNULLABLE columns are set.
	while (SUCCEEDED(hr = GetRowFromIndex(eCURSOR_WRITE, i++, &pvWriteRow)))
	{
		// Insure all non-nullable columns were set:
		for (iColumn = 0; iColumn < m_cColumns; iColumn++)
		{
			if (fCOLUMNMETA_NOTNULLABLE & (m_acolmetas[iColumn].fMeta)) // ie: Column marked not nullable:
			{
				bStatus = *(pbDataStatusPart (pvWriteRow, iColumn));
				if (!(fST_COLUMNSTATUS_NONNULL & bStatus))
					return E_ST_VALUENEEDED;		// ie: Verify column is not null.
			}
		}
	}

	if (hr == E_ST_NOMOREROWS)
		hr = S_OK;

	return hr;
}

SIZE_T
CMemoryTable::GetMultiStringLength (LPCWSTR i_wszMS) const
{
	SIZE_T iTotalLen = 0;
	ASSERT (i_wszMS != 0);

	if ((*i_wszMS == L'\0') && (*(i_wszMS+1) == L'\0'))
	{
		iTotalLen = 2;
	}
	else
	{
		for (LPCWSTR pCurString = i_wszMS;
			 *pCurString != L'\0';
			 pCurString = i_wszMS + iTotalLen)
		{
			iTotalLen += wcslen (pCurString) + 1;
		}

		iTotalLen++; // for last L\'0'
	}

	return iTotalLen;
}

BOOL
CMemoryTable::MultiStringCompare (LPCWSTR i_wszLHS,
								  LPCWSTR i_wszRHS,
								  BOOL fCaseInsensitive)
{
	ASSERT (i_wszLHS != 0);
	ASSERT (i_wszRHS != 0);

	LPCWSTR pLHS;
	LPCWSTR pRHS;

	for (pLHS = i_wszLHS, pRHS = i_wszRHS;
	     *pLHS != L'\0' && *pRHS != L'\0';
		 pLHS += wcslen (pLHS) + 1, pRHS += wcslen (pRHS) + 1)
	 {
		 BOOL fResult;
		 if (fCaseInsensitive)
		 {
			 fResult = _wcsicmp (pLHS, pRHS);
		 }
		 else
		 {
			 fResult = wcscmp (pLHS, pRHS);
		 }

		 if (fResult != 0)
		 {
			 return FALSE;
		 }
	 }

	 // we compared all the string, so they must be equal

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\filechng\filechng.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
// =======================================================================
#include "precomp.hxx"

DWORD WINAPI CListener::ListenerThreadStart(LPVOID	lpParam)
{
	CListener	*pListener = (CListener*)lpParam;
	HRESULT		hr = S_OK;

	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr))
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "[CSTFileChangeManager::ListenerThreadStart] Call to CoInitializeEx failed with hr = %08x\n", hr ));
		goto Cleanup;
	}

	ASSERT(pListener);
	hr = pListener->Listen();
	if (FAILED(hr))
	{
        DBGPRINTF(( DBG_CONTEXT,
		            "[CSTFileChangeManager::ListenerThreadStart] Call to CSTFileChangeManager::Listen failed with hr = %08x\n", hr ));
	}

	// When Listen() is done, the file notify manager should have removed
	// this object from his list.

Cleanup:

	delete pListener;

	CoUninitialize();
	return hr;
}

// =======================================================================
// ISimpleTableListen
// =======================================================================
HRESULT CSTFileChangeManager::InternalListen(
	ISimpleTableFileChange	*i_pISTFile,
	LPCWSTR		i_wszDirectory,
	LPCWSTR		i_wszFile,
	DWORD		i_fFlags,
	DWORD		*o_pdwCookie)
{
	CListener	*pListener = NULL;
	DWORD		dwThreadID;
	DWORD		dwHighCookie = 0;
	HANDLE		hThread = NULL;
	HRESULT		hr = S_OK;
	ULONG		iListener = 0;

	// Argument validation.
	if (!i_pISTFile || !i_wszDirectory || !o_pdwCookie)
	{
		return E_INVALIDARG;
	}

	// @TODO: do we need more validation. Does directory exist? Are flags valid?

	// Init out param.
	*o_pdwCookie = 0;

	// Search for a listener to handle the request.
	if (m_aListenerMap.Count() > 0)
	{
		for (iListener = m_aListenerMap.Count(); iListener > 0; iListener--)
		{
		    hr = m_aListenerMap[iListener-1].pListener->IsFull();
		    if ( FAILED(hr) )
		    {
		        return hr;
		    }

			if ( hr == S_FALSE )
			{
				pListener = m_aListenerMap[iListener-1].pListener;
				dwHighCookie = m_aListenerMap[iListener-1].dwListenerID;
				break;
			}
		}
	}

	// If no listener is found:
	if (pListener == NULL)
	{
		// Create a new listener object.
		pListener = new CListener;
		if (pListener == NULL)
		{
			return E_OUTOFMEMORY;
		}

		hr = pListener->Init();
		if (FAILED(hr)) goto Cleanup;

		// Start a thread for this consumer.
		hThread = CreateThread(NULL, 0, CListener::ListenerThreadStart, (LPVOID)pListener, 0, &dwThreadID);
		if (hThread == NULL)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Cleanup;
		}

		// Add listener to listener list.
		hr = AddListener(pListener, &dwHighCookie);
		if (FAILED(hr)) goto Cleanup;
	}

	// Initialize it with user provided data.
	hr = pListener->AddConsumer(i_pISTFile, i_wszDirectory, i_wszFile, i_fFlags, o_pdwCookie);
	if (FAILED(hr)) goto Cleanup;

	*o_pdwCookie = *o_pdwCookie | (dwHighCookie << 16);
Cleanup:
	if (FAILED(hr))
	{
		if (pListener)
		{
			delete pListener;
		}
		InternalUnlisten(*o_pdwCookie);
	}
	// @TODO: Do I need to keep the handle around?
	if (hThread != NULL)
	{
		CloseHandle(hThread);
	}

	return hr;
}

// =======================================================================
HRESULT CSTFileChangeManager::InternalUnlisten(
	DWORD		i_dwCookie)
{
	ULONG		iListener;
	HRESULT		hr = S_OK;

	// Find the consumer in the consumer list.
	for (iListener = 0; iListener < m_aListenerMap.Count(); iListener++)
	{
		if (m_aListenerMap[iListener].dwListenerID == ((i_dwCookie & HIGH_COOKIE)>>16))
			break;
	}
	// If not found, the cookie was not valid.
	if (iListener == m_aListenerMap.Count())
		return E_INVALIDARG;

	// Signal the done event.
	ASSERT(m_aListenerMap[iListener].pListener != NULL);
	hr = m_aListenerMap[iListener].pListener->RemoveConsumer(i_dwCookie);

	// If the listener doesn't have anything to listen do delete it.
	if (hr == S_FALSE)
	{
		m_aListenerMap.DeleteAt(iListener);
	}
	return S_OK;
}

// =======================================================================
HRESULT CSTFileChangeManager::AddListener(
	CListener	*i_pListener,
	DWORD		*o_pdwCookie)
{
	ListenerInfo *pListener = NULL;
	HRESULT		hr = S_OK;

	ASSERT(i_pListener && o_pdwCookie);

	// Add a new consumer.
	hr = m_aListenerMap.SetSize(m_aListenerMap.Count()+1);
	if (FAILED (hr))
	{
		return hr;
	}

	pListener = &m_aListenerMap[m_aListenerMap.Count()-1];
	pListener->pListener = i_pListener;
	pListener->dwListenerID = GetNextCookie();
	*o_pdwCookie = pListener->dwListenerID;
	return S_OK;
}

// =======================================================================
//	CListener
// =======================================================================

// If Init() fails the caller should delete the listener object.
// Not called by multiple threads.
// =======================================================================
HRESULT CListener::Init()
{
    HRESULT             hr = S_OK;
    DWORD               dwError = ERROR_SUCCESS;
	CSafeLock           cLock(m_csArrayLock);
	ULONG		        i = 0;

	if ( !m_csArrayLock.IsInitialized() )
	{
	    hr = E_FAIL;
	    goto Cleanup;
	}

	// Synchronize access to the consumer and handle array.
	dwError = cLock.Lock();
	if ( dwError != ERROR_SUCCESS )
	{
	    hr = HRESULT_FROM_WIN32( dwError );
	    goto Cleanup;
	}

	// Alocate room for two handles.
	hr = m_aHandles.SetSize(m_aHandles.Count() + m_eOverheadHandleCount);
	if (FAILED (hr))
	{
		goto Cleanup;
	}

	// Create the Done and ConsumerUpdate events.
	for (i = 0; i < m_eOverheadHandleCount; i++)
	{
		m_aHandles[i] = CreateEvent(NULL,	// Use default security settings.
									FALSE,	// Auto-reset.
									FALSE,	// Initially nonsignaled.
									NULL);  // With no name.
		if (m_aHandles[i] == NULL)
		{
			dwError = GetLastError();
			hr = HRESULT_FROM_WIN32( dwError );
			goto Cleanup;
		}
	}

Cleanup:
	return hr;
}

// Can this listener serve another consumer. The maximum number of consumers
// a listener can serve is CONSUMER_LIMIT, which has to be less than
// MAXIMUM_WAIT_OBJECTS -  (the limit on WaitForMultiple objects)
// Not called by multiple threads.
// =======================================================================
HRESULT CListener::IsFull()
{
	HRESULT		            hr = S_OK;
    DWORD                   dwError = ERROR_SUCCESS;
	CSafeLock               cLock(m_csArrayLock);

	// Synchronize access to the consumer and handle array.
	dwError = cLock.Lock();
	if ( dwError != ERROR_SUCCESS )
	{
	    hr = HRESULT_FROM_WIN32( dwError );
	    goto Cleanup;
	}

	if ( (m_dwNextCookie > USHRT_MAX) || m_aConsumers.Count() == m_eConsumerLimit )
	{
	    hr = S_OK;
	}
	else
	{
	    hr = S_FALSE;
	}

Cleanup:
    return hr;
}

// Not called by multiple threads.
// =======================================================================
HRESULT CListener::AddConsumer(
	ISimpleTableFileChange  *i_pISTFile,
	LPCWSTR		            i_wszDirectory,
	LPCWSTR		            i_wszFile,
	DWORD		            i_fFlags,
	DWORD                   *o_pdwCookie)
{
	HRESULT		            hr = S_OK;
    DWORD                   dwError = ERROR_SUCCESS;
	CSafeLock               cLock(m_csArrayLock);
	BOOL                    bAppendBackslash = FALSE;
	FileConsumerInfo        *pConsumerInfo = NULL;

	ASSERT(i_pISTFile && i_wszDirectory && o_pdwCookie);

	// Synchronize access to the consumer and handle array.
	dwError = cLock.Lock();
	if ( dwError != ERROR_SUCCESS )
	{
	    hr = HRESULT_FROM_WIN32( dwError );
	    goto Cleanup;
	}

	// Allocate room for a new consumer.
	hr = m_aConsumers.SetSize(m_aConsumers.Count()+1);
	if (FAILED (hr))
	{
		goto Cleanup;
	}

	pConsumerInfo = &m_aConsumers[m_aConsumers.Count()-1];
	ZeroMemory(pConsumerInfo, sizeof(FileConsumerInfo));

	// Init the consumer.
	hr = i_pISTFile->QueryInterface(IID_ISimpleTableFileChange, (LPVOID*)&pConsumerInfo->pISTNotify);
	if(FAILED(hr))
    {
        goto Cleanup;
    }

	// Directory name must contain a backslash at the end.
	if (i_wszDirectory[wcslen(i_wszDirectory)-1] != L'\\')
		bAppendBackslash = TRUE;
	pConsumerInfo->wszDirectory = new WCHAR[wcslen(i_wszDirectory) + (bAppendBackslash ? 2 : 1)];
	if (pConsumerInfo->wszDirectory == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

	wcscpy(pConsumerInfo->wszDirectory, i_wszDirectory);
	if (bAppendBackslash)
	{
		wcscat(pConsumerInfo->wszDirectory, L"\\");
	}

	if (i_wszFile != NULL)
	{
		pConsumerInfo->wszFile = new WCHAR[wcslen(i_wszFile) + 1];
		if (pConsumerInfo->wszFile == NULL)
	    {
	        hr = E_OUTOFMEMORY;
	        goto Cleanup;
	    }
		wcscpy(pConsumerInfo->wszFile, i_wszFile);
	}

	// Create the file cache.
	pConsumerInfo->paFileCache = new CCfgArray<FileInfo>;
	if (pConsumerInfo->paFileCache == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

	pConsumerInfo->fFlags = i_fFlags | fFCI_ADDCONSUMER;

	// Notify the listener thread to pick up this new consumer.
	if (SetEvent(m_aHandles[m_eConsumerChangeHandle]) == FALSE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Cleanup;
	}

	// Set the lower 2-bytes of the cookie.
	*o_pdwCookie = GetNextCookie();

Cleanup:
	if (FAILED(hr))
	{
	    if ( pConsumerInfo != NULL )
	    {
    		ASSERT(pConsumerInfo && (pConsumerInfo == &m_aConsumers[m_aConsumers.Count()-1]));
    		UninitConsumer(pConsumerInfo);
    		m_aConsumers.DeleteAt(m_aConsumers.Count()-1);
	    }
	}

	return hr;
}

// Not called by multiple threads.
// =======================================================================
HRESULT CListener::RemoveConsumer(
	DWORD		        i_dwCookie)
{
	HRESULT		        hr = S_OK;
    DWORD               dwError = ERROR_SUCCESS;
	CSafeLock           cLock(m_csArrayLock);
	FileConsumerInfo    *pConsumerInfo = NULL;
	ULONG		        iConsumer;

	// Synchronize access to the consumer and handle array.
	dwError = cLock.Lock();
	if ( dwError != ERROR_SUCCESS )
	{
	    hr = HRESULT_FROM_WIN32( dwError );
	    goto Cleanup;
	}

	// Find the consumer in the consumer list.
	for (iConsumer = 0; iConsumer < m_aConsumers.Count(); iConsumer++)
	{
		if (m_aConsumers[iConsumer ].dwCookie == (i_dwCookie & LOW_COOKIE))
			break;
	}
	// If not found, the cookie was not valid.
	if (iConsumer == m_aConsumers.Count())
	{
		hr = E_INVALIDARG;
	    goto Cleanup;
	}

	pConsumerInfo = &m_aConsumers[iConsumer];

	pConsumerInfo->fFlags |= fFCI_REMOVECONSUMER;

	// Notify the listener thread to pick up this new consumer.
	if (SetEvent(m_aHandles[m_eConsumerChangeHandle]) == FALSE)
	{
		dwError = GetLastError();
		hr = HRESULT_FROM_WIN32( dwError );
	    goto Cleanup;
	}

Cleanup:
	return hr;
}

// =======================================================================
void CListener::UninitConsumer(
	FileConsumerInfo *i_pConsumerInfo)
{
	if (i_pConsumerInfo->wszDirectory)
	{
		delete [] i_pConsumerInfo->wszDirectory;
	}

	if (i_pConsumerInfo->wszFile)
	{
		delete [] i_pConsumerInfo->wszFile;
	}

	if (i_pConsumerInfo->pISTNotify)
	{
		i_pConsumerInfo->pISTNotify->Release();
	}

	if (i_pConsumerInfo->paFileCache)
	{
		delete i_pConsumerInfo->paFileCache;
	}
}

// =======================================================================
HRESULT CListener::Listen()
{
	HRESULT		        hr = S_OK;
    DWORD               dwError = ERROR_SUCCESS;
	DWORD		        dwWait;
	BOOL		        fDone = FALSE;
	ULONG		        iChangedDirectory = 0;
	ULONG		        iConsumer = 0;

	while (!fDone)
	{
		// Sleep until a file change happens or the consumer is done.
		dwWait = WaitForMultipleObjects(m_aHandles.Count(), &m_aHandles[0], FALSE, 0xFFFFFFFF);
		// @TODO: think about timeout.
		// If consumer is done, leave.
		if (dwWait == WAIT_OBJECT_0 + m_eDoneHandle)
		{
			fDone = TRUE;
		}
		// A consumer has been added or removed.
		else if (dwWait == WAIT_OBJECT_0 + m_eConsumerChangeHandle)
		{
			// Synchronize access to the consumer and handle array.
        	CSafeLock           cLock(m_csArrayLock);

        	dwError = cLock.Lock();
        	if ( dwError != ERROR_SUCCESS )
        	{
        	    hr = HRESULT_FROM_WIN32( dwError );
				return hr;
        	}

			// Iterate through consumers to find the added/removed ones.
			for (iConsumer = 0; iConsumer < m_aConsumers.Count(); iConsumer++)
			{
				// If consumer has been added:
				if (m_aConsumers[iConsumer].fFlags & fFCI_ADDCONSUMER)
				{
					// Allocate room for a new handle.
					hr = m_aHandles.SetSize(m_aHandles.Count()+1);
					if (FAILED (hr))
					{
						return hr;
					}

					// Init file change notification.
					m_aHandles[m_aHandles.Count()-1] = FindFirstChangeNotificationW(m_aConsumers[iConsumer].wszDirectory,
								m_aConsumers[iConsumer].fFlags & fST_FILECHANGE_RECURSIVE,
								FILE_NOTIFY_CHANGE_FILE_NAME|FILE_NOTIFY_CHANGE_LAST_WRITE);
					if (m_aHandles[m_aHandles.Count()-1] == INVALID_HANDLE_VALUE)
					{
						hr = HRESULT_FROM_WIN32(GetLastError());
						goto Cleanup;
					}

					// Add files to the file cache.
					hr = UpdateFileCache(m_aConsumers[iConsumer].wszDirectory, iConsumer, TRUE);
					if (FAILED(hr))	{ goto Cleanup;	}

					// Clear the internal flags.
					m_aConsumers[iConsumer].fFlags &= ~fFCI_INTERNALMASK;
				}
				// If consumer has been removed:
				else if (m_aConsumers[iConsumer].fFlags & fFCI_REMOVECONSUMER)
				{
					// Remove the files from the file cache.
					hr = UpdateFileCache(m_aConsumers[iConsumer].wszDirectory, iConsumer, TRUE);
					if (FAILED(hr))	{ goto Cleanup;	}

					// Delete the handle and consumer info.
					ASSERT(m_aHandles[iConsumer] != INVALID_HANDLE_VALUE);
					FindCloseChangeNotification(m_aHandles[iConsumer]);
					m_aHandles.DeleteAt(iConsumer);
					UninitConsumer(&m_aConsumers[iConsumer]);
					m_aConsumers.DeleteAt(iConsumer);

					// Readjust the loop variable.
					iConsumer--;
				}

			}
		}
		else if (dwWait > WAIT_OBJECT_0 + m_eConsumerChangeHandle && dwWait < WAIT_OBJECT_0 + m_eOverheadHandleCount + m_aHandles.Count())
		{
			// Synchronize access to the consumer and handle array.
        	CSafeLock           cLock(m_csArrayLock);

        	dwError = cLock.Lock();
        	if ( dwError != ERROR_SUCCESS )
        	{
        	    hr = HRESULT_FROM_WIN32( dwError );
				return hr;
        	}

			ASSERT(dwWait < WAIT_OBJECT_0 + MAXIMUM_WAIT_OBJECTS);

			iChangedDirectory = dwWait - m_eOverheadHandleCount;

			// Update the file cache and inform the consumer.
			hr = UpdateFileCache(m_aConsumers[iChangedDirectory].wszDirectory, iChangedDirectory, FALSE);
			if (FAILED(hr))	{ goto Cleanup;	}

			hr = FireEvents(*m_aConsumers[iChangedDirectory].paFileCache, m_aConsumers[iChangedDirectory].pISTNotify);
			if (FAILED(hr)) { goto Cleanup; }

			// Wait for next change.
			if (FindNextChangeNotification(m_aHandles[dwWait]) == FALSE)
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
				goto Cleanup;
			}
		}
		else
		{
			ASSERT(dwWait == WAIT_FAILED);
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Cleanup;
		}
	}
	// The consumer is done.
Cleanup:

	return hr;
}

// This method is called
// 1 - when a consumer wants to listen to a new directory
// 2 - when a change occured in one of the listened directories.
// =======================================================================
HRESULT CListener::UpdateFileCache(
	LPCWSTR		i_wszDirectory,
	ULONG		i_iConsumer,
	BOOL		i_bCreate)
{
	WIN32_FIND_DATA FindFileData;
	HANDLE		hFind = 0;
	BOOL		bNext = TRUE;
	HRESULT		hr = S_OK;

    TSmartPointerArray<WCHAR>   saFileSearch;
    ULONG                       strlenDirectory;
    saFileSearch = new WCHAR [strlenDirectory = (ULONG)wcslen(i_wszDirectory) + 4];//plus 4 for "*.*\0"
    if(0 == saFileSearch.m_p)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

	wcscpy(saFileSearch, i_wszDirectory);
	wcscat(saFileSearch, L"*.*");

	hFind = FindFirstFile(saFileSearch, &FindFileData);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Cleanup;
	}

	do
	{
		if ((m_aConsumers[i_iConsumer].fFlags & fST_FILECHANGE_RECURSIVE) && (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			&& wcscmp(FindFileData.cFileName, L".") && wcscmp(FindFileData.cFileName, L".."))
		{
            TSmartPointerArray<WCHAR> saNextDir = new WCHAR [strlenDirectory + wcslen(FindFileData.cFileName) + 2];//plus 2 for the "\\\0"
            if(0 == saNextDir.m_p)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

			wcscpy(saNextDir, i_wszDirectory);
			wcscat(saNextDir, FindFileData.cFileName);
			wcscat(saNextDir, L"\\");
			hr = UpdateFileCache(saNextDir, i_iConsumer, i_bCreate);
		}
		// Deal only with files of interest to us.
		// @TODO: The filenames need to be provided via Advise.
		else if (!lstrcmpi(FindFileData.cFileName, m_aConsumers[i_iConsumer].wszFile))
		{
			if (i_bCreate)
			{
				hr = AddFile(*m_aConsumers[i_iConsumer].paFileCache, i_wszDirectory, &FindFileData, i_bCreate);
			}
			else
			{
				hr = UpdateFile(*m_aConsumers[i_iConsumer].paFileCache, i_wszDirectory, &FindFileData);
			}
		}
		if (FAILED(hr)) { goto Cleanup; }

	} while ((bNext = FindNextFile(hFind, &FindFileData)) == TRUE);

	if ((hr = HRESULT_FROM_WIN32(GetLastError())) != HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
		goto Cleanup;
	else
		hr = S_OK;

Cleanup:
	if (hFind != INVALID_HANDLE_VALUE)
		FindClose(hFind);
	return hr;
}

// =======================================================================
HRESULT CListener::AddFile(
	CCfgArray<FileInfo>& i_aFileCache,
	LPCWSTR		i_wszDirectory,
	WIN32_FIND_DATA *i_pFindFileData,
	BOOL		i_bCreate)
{
	FileInfo	*pFileInfo;

	ASSERT(i_pFindFileData && i_wszDirectory);

	// Add a new consumer.
	HRESULT hr = i_aFileCache.SetSize(i_aFileCache.Count()+1);
	if (FAILED (hr))
	{
		return hr;
	}

	pFileInfo = &i_aFileCache[i_aFileCache.Count()-1];

	pFileInfo->wszFileName = new WCHAR[wcslen(i_wszDirectory) + wcslen(i_pFindFileData->cFileName)+1];
	if (pFileInfo->wszFileName == NULL)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy(pFileInfo->wszFileName, i_wszDirectory);
	wcscat(pFileInfo->wszFileName, i_pFindFileData->cFileName);

	pFileInfo->ftLastModified = i_pFindFileData->ftLastWriteTime;
	pFileInfo->fStatus = i_bCreate ? 0 : fST_FILESTATUS_ADD;
	return S_OK;
}

// =======================================================================
HRESULT CListener::UpdateFile(
	CCfgArray<FileInfo>& i_aFileCache,
	LPCWSTR		i_wszDirectory,
	WIN32_FIND_DATA *i_pFindFileData)
{
	WCHAR		awchFullPath[_MAX_PATH];

    if ( ( i_wszDirectory == NULL ) ||
         ( ( wcslen( i_wszDirectory ) + wcslen( i_pFindFileData->cFileName ) ) >= _MAX_PATH ) )
    {
        return E_INVALIDARG;
    }

	wcsncpy( awchFullPath, i_wszDirectory, _MAX_PATH - 1 );
	awchFullPath[_MAX_PATH-1] = L'\0';
	wcsncat( awchFullPath, i_pFindFileData->cFileName, _MAX_PATH - wcslen( awchFullPath ) - 1 );
	awchFullPath[_MAX_PATH-1] = L'\0';

	for (ULONG i = 0; i < i_aFileCache.Count(); i++)
	{
		if (!lstrcmpi(i_aFileCache[i].wszFileName, awchFullPath))
		{
			// Initially, I was just comparing the LastWriteTime which worked fine for file edits. However
			// when the file was overwritten by a file copy, I'd get the write time changed twice and I'd call
			// OnFileModify twice. To prevent this I check both AccessTime and WriteTime.
			if (CompareFileTime(&i_aFileCache[i].ftLastModified, &i_pFindFileData->ftLastAccessTime) &&
				CompareFileTime(&i_aFileCache[i].ftLastModified, &i_pFindFileData->ftLastWriteTime))
			{
				i_aFileCache[i].ftLastModified = i_pFindFileData->ftLastWriteTime;
				i_aFileCache[i].fStatus = fST_FILESTATUS_UPDATE;
			}
			else
			{
				i_aFileCache[i].fStatus = fST_FILESTATUS_NOCHANGE;
			}
			return S_OK;
		}
	}

	// If the file wasn't already in the cache add it.
	return AddFile(i_aFileCache, i_wszDirectory, i_pFindFileData, FALSE);
}

// =======================================================================
HRESULT CListener::FireEvents(
	CCfgArray<FileInfo>& i_aFileCache,
	ISimpleTableFileChange* pISTNotify)
{
	HRESULT		hr = S_OK;

	for (ULONG i = 0; i < i_aFileCache.Count(); i++)
	{
		if (i_aFileCache[i].fStatus == fST_FILESTATUS_NOCHANGE)
		{
		}
		else if (i_aFileCache[i].fStatus == fST_FILESTATUS_ADD)
		{
			hr = pISTNotify->OnFileCreate(i_aFileCache[i].wszFileName);
		}
		else if (i_aFileCache[i].fStatus == fST_FILESTATUS_UPDATE)
		{
			hr = pISTNotify->OnFileModify(i_aFileCache[i].wszFileName);
		}
		else
		{
			hr = pISTNotify->OnFileDelete(i_aFileCache[i].wszFileName);

			// Get rid of this entry.
			delete [] i_aFileCache[i].wszFileName;
			i_aFileCache.DeleteAt(i);
			i--;
			continue;
		}
		i_aFileCache[i].fStatus = 0;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\fastcache\sdtfst_com.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

// -----------------------------------------
// CSLTShapeless: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP CMemoryTable::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv)
		return E_INVALIDARG;
	*ppv = NULL;

	if (!m_fIsDataTable) // ie: Component is posing as class factory / dispenser:
	{
		if (riid == IID_ISimpleTableInterceptor)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
		else if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
	}
	else // ie: Component is currently posing as data table:
	{
		if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableRead2)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableWrite2)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableController)
		{
			*ppv = (ISimpleTableController*) this;
		}
		else if (riid == IID_ISimpleTableAdvanced)
		{
			*ppv = (ISimpleTableAdvanced*) this;
		}
		else if (riid == IID_ISimpleTableMarshall && (fST_LOS_MARSHALLABLE & m_fTable))
		{
			*ppv = (ISimpleTableMarshall*) this;
		}

	}
	if (NULL != *ppv)
	{
		((ISimpleTableWrite2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

// =======================================================================
STDMETHODIMP_(ULONG) CMemoryTable::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);

}

// =======================================================================
STDMETHODIMP_(ULONG) CMemoryTable::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\filechng\filechng.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#pragma once

#include <limits.h>

#define fST_FILESTATUS_NOCHANGE 0x00000001
#define fST_FILESTATUS_ADD		0x00000002
#define fST_FILESTATUS_UPDATE	0x00000003

#define HIGH_COOKIE	0xFFFF0000
#define LOW_COOKIE	0x0000FFFF

// Internal values for FileConsumerInfo::fFlags
#define fFCI_ADDCONSUMER		0x00010000
#define fFCI_REMOVECONSUMER		0x00020000
#define fFCI_INTERNALMASK		0xFFFF0000

// File information that is cached.
struct FileInfo
{
	LPWSTR		wszFileName;
	FILETIME	ftLastModified;
	DWORD		fStatus;
};

struct FileConsumerInfo
{
	LPWSTR		wszDirectory;
	LPWSTR		wszFile;
	DWORD		fFlags;
	ISimpleTableFileChange *pISTNotify;
	DWORD		dwCookie;
	CCfgArray<FileInfo> *paFileCache;
};

class CListener
{
	// Overhead handles.
	enum
	{
		m_eDoneHandle,
		m_eConsumerChangeHandle,
		m_eOverheadHandleCount
	};

	// consts
	enum
	{
		m_eConsumerLimit = MAXIMUM_WAIT_OBJECTS - m_eOverheadHandleCount
	};

public:
	CListener() : m_dwNextCookie(0), m_fInit(FALSE)
	{
	}

	~CListener()
	{
	}

	HRESULT Init();
	HRESULT Uninit();
    HRESULT IsFull();
	HRESULT Listen();
	HRESULT AddConsumer(ISimpleTableFileChange *i_pISTFile, LPCWSTR	i_wszDirectory, LPCWSTR i_wszFile, DWORD i_fFlags, DWORD *o_pdwCookie);
	HRESULT RemoveConsumer(DWORD i_dwCookie);
	static DWORD WINAPI ListenerThreadStart(LPVOID lpParam);

private:
	void UninitConsumer(FileConsumerInfo *i_pConsumerInfo);
	HRESULT UpdateFileCache(LPCWSTR i_wszDirectory,	ULONG i_iConsumer, BOOL i_bCreate);
	HRESULT AddFile(CCfgArray<FileInfo>& i_aFileCache, LPCWSTR i_wszDirectory, WIN32_FIND_DATA *i_pFindFileData, BOOL i_bCreate);
	HRESULT UpdateFile(CCfgArray<FileInfo>& i_aFileCache, LPCWSTR i_wszDirectory, WIN32_FIND_DATA *i_pFindFileData);
	HRESULT FireEvents(CCfgArray<FileInfo>& i_aFileCache, ISimpleTableFileChange* pISTNotify);

	DWORD GetNextCookie()
	{
		ASSERT(m_dwNextCookie < USHRT_MAX);
		return ++m_dwNextCookie;
	}

	DWORD					m_fInit;
	DWORD					m_dwNextCookie;

	// The following members can be manipulated by multiple threads.
	CSafeAutoCriticalSection    m_csArrayLock;
	CCfgArray<HANDLE>			m_aHandles;
	CCfgArray<FileConsumerInfo>	m_aConsumers;
};


struct ListenerInfo
{
	DWORD					dwListenerID;
	CListener				*pListener;
};

class CSTFileChangeManager
{
public:
	CSTFileChangeManager() : m_dwNextCookie(0)
	{}

	~CSTFileChangeManager()
	{}

	HRESULT Init()
	{
		return E_NOTIMPL;
	}

// ISimpleTableListen
public:
	HRESULT InternalListen(ISimpleTableFileChange *i_pISTFile, LPCWSTR i_wszDirectory, LPCWSTR i_wszFile, DWORD i_fFlags, DWORD	*o_pdwCookie);
	HRESULT InternalUnlisten(DWORD i_dwCookie);

private:
	HRESULT AddListener(CListener *i_pListener, DWORD *o_pdwCookie);
	DWORD GetNextCookie()
	{
		ASSERT(m_dwNextCookie < USHRT_MAX);
		return ++m_dwNextCookie;
	}

	DWORD				m_dwNextCookie;
	CCfgArray<ListenerInfo>	m_aListenerMap;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\icompilationplugin.h ===
//  Copyright (C) 2000 Microsoft Corporation.  All rights reserved.
//  Filename:       ICompilationPlugin.h
//  Author:         Stephenr
//  Date Created:   6/22/00
//  Description:    We need aa extensible way to allow disparate pieces of code to
//                  update and cook the meta into new forms.  Those pieces of code
//                  that wish to do this must derive from this interface.
//

#pragma once

class ICompilationPlugin
{
public:
    ICompilationPlugin(){}
    virtual ~ICompilationPlugin(){}
    
    virtual void Compile(TPEFixup &fixup, TOutput &out) = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\output.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

//  TOutput - Abstract base class that provides a printf function
//            Derived classes could send the printf data anywhere.
class TOutput
{
public:
    TOutput(){}
    virtual void _cdecl printf(LPCTSTR szFormat, ...) const = 0;
};

// TNullOutput - TOutput implementation that sends the output nowhere

class TNullOutput: public TOutput
{
public:
    TNullOutput(){}
    virtual void _cdecl printf(LPCTSTR szFormat, ...) const
    {
        UNREFERENCED_PARAMETER(szFormat);

        // do nothing
    }
};



// TScreenOutput - TOutput implementation that sends the output
//                 to the screen.
class TScreenOutput : public TOutput
{
public:
    TScreenOutput(){}
    virtual void _cdecl printf(LPCTSTR szFormat, ...) const
    {
	    va_list args;
	    va_start(args, szFormat);

	    _vtprintf(szFormat, args);

	    va_end(args);
    }
};


// TDebugOutput - TOutput implementation that sends the output
//                 to the debug monitor.
#if 0
class TDebugOutput : public TOutput
{
public:
    TDebugOutput(){}
    virtual void _cdecl printf(LPCTSTR szFormat, ...) const
    {
	    va_list args;
	    va_start(args, szFormat);

	    TCHAR szBuffer[512];
	    _vstprintf(szBuffer, szFormat, args);

	    OutputDebugString(szBuffer);
	    va_end(args);
    }
};
#endif

// TExceptionOutput - TOutput implementation that keeps the output internally for use by an exception handler
class TExceptionOutput : public TOutput
{
public:
    TExceptionOutput()
    {
        m_szBuffer[0] = NULL;
    }
    virtual void _cdecl printf(LPCTSTR szFormat, ...) const
    {
	    va_list args;
	    va_start(args, szFormat);

        _vstprintf(const_cast<TCHAR *>(m_szBuffer), szFormat, args);

        va_end(args);
    }
    TCHAR * GetString (void)
    {
        return m_szBuffer;
    }
private:
	TCHAR m_szBuffer[512];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tcom.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TCom
{
public:
    TCom(){CoInitialize(NULL);}
    ~TCom(){CoUninitialize();}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\mbschemacompilation.cpp ===
// Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
// Filename:        MBSchemaCompilation.cpp
// Author:          Stephenr
// Date Created:    10/16/2000
// Description:     This function takes an MBSchema.Xml (or MBExtensionsSchema.Xml) and merges the Metabase Schema with
//                  the shipped schema and generates a MBSchema.bin file.  From that new bin file, a merged MBSchema.Xml
//                  is generated.
//

#include "precomp.hxx"

#define LOG_ERROR0(x)                     {LOG_ERROR(Interceptor, (0, 0, E_ST_COMPILEFAILED,           ID_CAT_CONFIG_SCHEMA_COMPILE, x,                 L"",  L"",  L"",  L"" ))   ;}
#define LOG_ERROR_WIN32(win32err, call)   {LOG_ERROR(Interceptor, (0, 0, HRESULT_FROM_WIN32(win32err), ID_CAT_CONFIG_SCHEMA_COMPILE, IDS_COMCAT_WIN32, call,  L"",  L"",  L"" ))   ;}


//////////////////////////////////////
//                                  //
//        Public Methods            //
//                                  //
//////////////////////////////////////
#define kwszBinFileNameCore           (L"MBSchema.bin.\0\0")             //L"MBSchema.bin."  just requires a version to be added
#define kwszBinFileNameSearchString   (L"MBSchema.bin.????????h\0")      //L"MBSchema.bin.????????h" this is used in FindFirstFile
#define kwszFormatString              (L"MBSchema.bin.%08xh\0")
#define kwszFormatStringFull          (L"%sMBSchema.bin.%08xh")



TMBSchemaCompilation::TMBSchemaCompilation() :
             m_cchFullyQualifiedBinFileName (0)
            ,m_lBinFileVersion              (-1)
{
}


TMBSchemaCompilation::~TMBSchemaCompilation()
{
}


//This is the heart of the class - its whole purpose in life is to take an Extensions XML file (which contains Metabase Schema, usually just
//the user-defined properties, thus the name Extensions XML) and the DLL and produce a FixedTableHeap which contains a merge of the meta
//in both.  A Bin file is generated (we name it, the user supplies the path).  And an composite XML Schema file is generated (file name
//is supplied by the user).
//After the user calls Compile, they will need to GetBinFileName - I didn't want to add more params and make this function do double duty.
HRESULT
TMBSchemaCompilation::Compile
(
    ISimpleTableDispenser2 *    i_pISTDispenser,
    LPCWSTR                     i_wszExtensionsXmlFile,
    LPCWSTR                     i_wszSchemaXmlFile,
    const FixedTableHeap *      i_pFixedTableHeap
)
{
    HRESULT hr;

    ASSERT(0 != i_pISTDispenser);
    //ASSERT(0 != i_wszExtensionsXmlFile);This is allowed to be NULL
    ASSERT(0 != i_wszSchemaXmlFile);
    ASSERT(0 != i_pFixedTableHeap);
    ASSERT(i_pFixedTableHeap->IsValid());
    if( 0 == i_pISTDispenser        ||
        0 == i_wszSchemaXmlFile     ||
        0 == i_pFixedTableHeap      ||
        !i_pFixedTableHeap->IsValid())
        return E_INVALIDARG;

    ASSERT(0 != m_saBinPath.m_p && "The Schema BinPath must be set before calling Compile");
    if(0 == m_saBinPath.m_p)
        return E_ST_INVALIDSTATE;

    #ifdef _DEBUG
    TNullOutput  out;
//    TDebugOutput out;
    #else
    TNullOutput  out;
    #endif

    try
    {
        DWORD dwStartingTickCount = GetTickCount();

        TMetabaseMetaXmlFile mbmeta(i_pFixedTableHeap, i_wszExtensionsXmlFile, i_pISTDispenser, out);

        out.printf(L"TMetaInferrence().Compile(mbmeta, out);\r\n");
        TMetaInferrence().Compile(mbmeta, out);

        out.printf(L"THashedPKIndexes().Compile(mbmeta, out);\r\n");
        THashedPKIndexes hashedPKIndexes;
        hashedPKIndexes.Compile(mbmeta, out);

        out.printf(L"THashedUniqueIndexes().Compile(mbmeta, out);\r\n");
        THashedUniqueIndexes hashedUniqueIndexes;
        hashedUniqueIndexes.Compile(mbmeta, out);

        SIZE_T cchXmlFile = wcslen(i_wszSchemaXmlFile);

        //Allocate enough space to hold the temp filenames
        TSmartPointerArray<WCHAR> saBinFileNew  = new WCHAR[m_cchFullyQualifiedBinFileName];
        TSmartPointerArray<WCHAR> saBinFileTmp  = new WCHAR[m_cchFullyQualifiedBinFileName];
        TSmartPointerArray<WCHAR> saXmlFileTmp  = new WCHAR[cchXmlFile + 5];//enough room to tack on ".tmp\0"

        if(0 == saBinFileNew.m_p || 0 == saBinFileTmp.m_p || 0 == saXmlFileTmp.m_p)
            return E_OUTOFMEMORY;//if any of the allocs fail then return error

        //Now build the New Bin filename
        LONG lNewBinVersion=0;
        InterlockedExchange(&lNewBinVersion, m_lBinFileVersion+1);//if no bin file exists, m_lBinFileVersion is -1
        wsprintf(saBinFileNew, kwszFormatStringFull, m_saBinPath.m_p, lNewBinVersion);

        //build the temp bin filename
        wcscpy(saBinFileTmp, m_saBinPath);
        wcscat(saBinFileTmp, kwszBinFileNameCore);
        wcscat(saBinFileTmp, L"tmp");

        //Xml tmp file is the filename passed in with ".tmp" tacked onto the end
        memcpy(saXmlFileTmp.m_p,   i_wszSchemaXmlFile, cchXmlFile * sizeof(WCHAR));
        memcpy(saXmlFileTmp.m_p  + cchXmlFile, L".tmp\0", 5 * sizeof(WCHAR));


        TWriteSchemaBin(saBinFileTmp).Compile(mbmeta, out);
        TMBSchemaGeneration(saXmlFileTmp).Compile(mbmeta, out);

        MoveFileEx(saBinFileTmp, saBinFileNew, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED);
        if(0 == MoveFileEx(saXmlFileTmp, i_wszSchemaXmlFile, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED))
        {
            hr = GetLastError();

            static const WCHAR wszMoveFileEx[] = L"MoveFileEx to ";
            static const ULONG cchMoveFileEx   = (ULONG)sizeof(wszMoveFileEx)/sizeof(WCHAR) - 1;
            TSmartPointerArray<WCHAR> saCall   = new WCHAR[cchMoveFileEx + cchXmlFile + 1];
            if(0 != saCall.m_p)
            {
                wcscpy(saCall, wszMoveFileEx);
                wcscat(saCall, i_wszSchemaXmlFile);
                LOG_ERROR_WIN32(hr, saCall);
            }
            else
            {
                LOG_ERROR_WIN32(hr, L"MoveFileEx");
            }

            hr = HRESULT_FROM_WIN32(hr);
            DBGERROR((DBG_CONTEXT, "Could not move to %ws, hr=0x%x\n", i_wszSchemaXmlFile, hr));
            return hr;
        }

        if(FAILED(hr = SetBinFileVersion(lNewBinVersion)))//now lock the new file into memory and start using it
            return hr;//inside SetBinFileName we will delete the file if it fails to load correctly

        out.printf(L"\r\n%s file generated\n", saBinFileNew);
        out.printf(L"\r\n%s file generated\n", i_wszSchemaXmlFile);

        DWORD dwEndingTickCount = GetTickCount();
        out.printf(L"HeapColumnMeta       %8d bytes\n", mbmeta.GetCountColumnMeta()          * sizeof(ColumnMeta)        );
        out.printf(L"HeapDatabaseMeta     %8d bytes\n", mbmeta.GetCountDatabaseMeta()        * sizeof(DatabaseMeta)      );
        out.printf(L"HeapHashedIndex      %8d bytes\n", mbmeta.GetCountHashedIndex()         * sizeof(HashedIndex)       );
        out.printf(L"HeapIndexMeta        %8d bytes\n", mbmeta.GetCountIndexMeta()           * sizeof(IndexMeta)         );
        out.printf(L"HeapQueryMeta        %8d bytes\n", mbmeta.GetCountQueryMeta()           * sizeof(QueryMeta)         );
        out.printf(L"HeapRelationMeta     %8d bytes\n", mbmeta.GetCountRelationMeta()        * sizeof(RelationMeta)      );
        out.printf(L"HeapServerWiringMeta %8d bytes\n", mbmeta.GetCountServerWiringMeta()    * sizeof(ServerWiringMeta)  );
        out.printf(L"HeapTableMeta        %8d bytes\n", mbmeta.GetCountTableMeta()           * sizeof(TableMeta)         );
        out.printf(L"HeapTagMeta          %8d bytes\n", mbmeta.GetCountTagMeta()             * sizeof(TagMeta)           );
        out.printf(L"HeapULONG            %8d bytes\n", mbmeta.GetCountULONG()               * sizeof(ULONG)             );
        out.printf(L"HeapPooled           %8d bytes\n", mbmeta.GetCountOfBytesPooledData()                               );
        out.printf(L"Total time to build the %s file: %d milliseconds\n", i_wszSchemaXmlFile, dwEndingTickCount - dwStartingTickCount);
    }
    catch(TException &e)
    {
        if(0 != e.m_msgID)//if there is a message ID associated with this error, the report it (most errors are reported at the layers below)
        {
            LOG_ERROR0(e.m_msgID);
        }
        e.Dump(out);
        return E_ST_COMPILEFAILED;
    }
    return S_OK;
}

extern HINSTANCE g_hModule;

//This function returns the BinFileName to be used for getting all of the IST meta tables used by the Metabase.
//This file name changes as new versions get compiled; but this abstraction guarentees that the filename returned
//exists AND is lock into memory and thus cannot be deleted by some other process or thread.  It isn't released
//until another file has been compiled and locked into memory, OR when the process shuts down.
HRESULT
TMBSchemaCompilation::GetBinFileName
(
    LPWSTR      o_wszBinFileName,           //Buffer to receive the BinFileName
    ULONG *     io_pcchSizeBinFileName      //This is a SIZE param so it always INCLUDE the NULL - unlike wcslen
)
{
    //It's OK for o_wszBinFileName to be NULL - this is how the user finds out the size of the buffer needed.
    ASSERT(io_pcchSizeBinFileName != 0);

    //Before the user can get the BinFileName they must first have set the path
    if(0 == m_saBinPath.m_p)
    {
        WCHAR wszPath[1024];
        GetModuleFileName(g_hModule, wszPath, 1024);
        LPWSTR pBackSlash = wcsrchr(wszPath, L'\\');
        if(pBackSlash)
            *pBackSlash = 0x00;
        SetBinPath(wszPath);
    }

    if(0 != o_wszBinFileName && *io_pcchSizeBinFileName < (ULONG) m_cchFullyQualifiedBinFileName)
        return E_ST_SIZEEXCEEDED;

    LONG lBinFileVersion;
    InterlockedExchange(&lBinFileVersion, m_lBinFileVersion);
    if(0 != o_wszBinFileName)//return a copy of the filename g_wszMBSchemaBinFileName
    {
        if ( lBinFileVersion >= 0 )
        {
            wsprintf(o_wszBinFileName, kwszFormatStringFull, m_saBinPath.m_p, lBinFileVersion);
            HRESULT hr;
            if(FAILED(hr = m_aBinFile[lBinFileVersion % 0x3F].LoadBinFile(o_wszBinFileName, lBinFileVersion)))
                return hr;
        }
        else
        {
            o_wszBinFileName[0] = 0x00;
        }
    }

    //return the wcslen+1 of g_wszMBSchemaBinFileName in *io_pcchSchemaBinFileName
    *io_pcchSizeBinFileName = (ULONG) m_cchFullyQualifiedBinFileName;//return the buffer size required
    if(0 == o_wszBinFileName)
        return S_OK;

    return (0x00 == o_wszBinFileName[0] ? S_FALSE : S_OK);
}


HRESULT
TMBSchemaCompilation::ReleaseBinFileName
(
    LPCWSTR         i_wszBinFileName
)
{
    HRESULT hr=S_OK;

    ASSERT(i_wszBinFileName);
    if(i_wszBinFileName[0] == 0x00)
        return S_OK;

    LONG lVersion;
    if(FAILED(hr = BinFileToBinVersion(lVersion, i_wszBinFileName)))
        return hr;

    if ( lVersion < 0 )
    {
        return E_FAIL;
    }

    ASSERT(m_aBinFile[lVersion % 0x3F].m_lBinFileVersion == lVersion && L"This is a bug, we should never have more than 64 versions of the bin file loaded at once");
    m_aBinFile[lVersion % 0x3F].UnloadBinFile();
    return S_OK;
}


//This is broken out into a separate method because on start up, we'll be called to GetBinFileName without first an MBSchemaCompilation
HRESULT
TMBSchemaCompilation::SetBinPath
(
    LPCWSTR     i_wszBinPath
)
{
    ASSERT(i_wszBinPath);
    if(0 == i_wszBinPath)
        return E_INVALIDARG;

    DWORD BinPathAttributes = GetFileAttributes(i_wszBinPath);
    if(-1 == BinPathAttributes)
        return HRESULT_FROM_WIN32(GetLastError());

    if(0 == (FILE_ATTRIBUTE_DIRECTORY & BinPathAttributes))
        return HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);

    if(0 != m_saBinPath.m_p)
        return S_FALSE;//this is so the caller can distinguish between S_OK and S_HEY_YOU_ALREADY_SET_THE_PATH

    //we need to know this all over the place so keep track of it
    m_cchFullyQualifiedBinFileName = wcslen(i_wszBinPath);

    m_saBinPath = new WCHAR [m_cchFullyQualifiedBinFileName+2];//one for the terminating NULL the second in case we need to add a trailing backslash

    if(0 == m_saBinPath.m_p)
        return E_OUTOFMEMORY;

    wcscpy(m_saBinPath, i_wszBinPath);

    if(m_saBinPath[m_cchFullyQualifiedBinFileName - 1] != L'\\')//if the path doesn't end in a backslash then add one
    {
        m_saBinPath[m_cchFullyQualifiedBinFileName]     = L'\\';
        m_saBinPath[m_cchFullyQualifiedBinFileName+1]   = 0x00;
        m_cchFullyQualifiedBinFileName++;
    }

    //up to this point m_cchFullyQualifiedBinFileName has been the strlen of the path, now add in the size of the filename too
    m_cchFullyQualifiedBinFileName += wcslen(kwszBinFileNameSearchString)+1;//one for the NULL

    //Everytime the user sets the path, we need to scan the directory of the new path for the latest Bin file
    WalkTheFileSystemToFindTheLatestBinFileName();

    return S_OK;
}




//////////////////////////////////////
//                                  //
//        Private Methods           //
//                                  //
//////////////////////////////////////

static int g_aValidHexChars[256] = {
//  x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//0x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//1x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//2x
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,//3x
    0,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,//4x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//5x
    0,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,//6x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//7x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//8x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//9x
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//ax
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//bx
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//cx
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//dx
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,//ex
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 //fx
};



//This just takes the numeric extension and converts from hex string to a ULONG (file is assumed to be in the form L"*.*.xxxxxxxx", where L"xxxxxxxx" is a hex number)
HRESULT
TMBSchemaCompilation::BinFileToBinVersion
(
    LONG   &o_lBinVersion,
    LPCWSTR i_wszBinFileName
) const
{
    SIZE_T cchBinFileName = wcslen(i_wszBinFileName);
    if(cchBinFileName == 0)
        return E_ST_INVALIDBINFILE;
    if(cchBinFileName >= m_cchFullyQualifiedBinFileName)
        return E_ST_INVALIDBINFILE;//we must have a filename of the form MBSchema.bin.old or something

    //if the file is something like MBSchema.bin.tmp the following code will catch that
    for(SIZE_T i=cchBinFileName-9;i<cchBinFileName-1;++i)
    {
        if(0 == g_aValidHexChars[i_wszBinFileName[i]])
            return E_ST_INVALIDBINFILE;
    }

    //convert the number at the end of the string to a ULONG
    o_lBinVersion = wcstol(i_wszBinFileName + cchBinFileName - 9, 0, 16);
    return S_OK;
}

HRESULT
TMBSchemaCompilation::DeleteBinFileVersion
(
    LONG i_lBinFileVersion
)
{
    if ( i_lBinFileVersion < 0 )
    {
        return E_INVALIDARG;
    }

    TSmartPointerArray<WCHAR> saBinFileName = new WCHAR [m_cchFullyQualifiedBinFileName];
    if(0 == saBinFileName.m_p)
        return E_OUTOFMEMORY;

    wsprintf(saBinFileName, kwszFormatStringFull, m_saBinPath.m_p, i_lBinFileVersion);
    m_aBinFile[i_lBinFileVersion % 0x3F].UnloadBinFile();
    DeleteFile(saBinFileName);

    return S_OK;
}

//This checks the validity of the FixedTableHeap mapped into memory
bool
TMBSchemaCompilation::IsValidBin
(
    TFileMapping &mapping
) const
{
    return (mapping.Size()>4096 && reinterpret_cast<const class FixedTableHeap *>(mapping.Mapping())->IsValid()) ? true : false;
}


HRESULT
TMBSchemaCompilation::RenameBinFileVersion
(
    LONG    i_lSourceVersion,
    LONG    i_lDestinationVersion
)
{
    if ( ( i_lSourceVersion < 0 ) || ( i_lDestinationVersion < 0 ) )
    {
        return E_INVALIDARG;
    }

    TSmartPointerArray<WCHAR> saSourceBinFileName = new WCHAR [m_cchFullyQualifiedBinFileName];
    if(0 == saSourceBinFileName.m_p)
        return E_OUTOFMEMORY;

    wsprintf(saSourceBinFileName, kwszFormatStringFull, m_saBinPath.m_p, i_lSourceVersion);


    TSmartPointerArray<WCHAR> saDestinationBinFileName = new WCHAR [m_cchFullyQualifiedBinFileName];
    if(0 == saDestinationBinFileName.m_p)
        return E_OUTOFMEMORY;

    wsprintf(saDestinationBinFileName, kwszFormatStringFull, m_saBinPath.m_p, i_lDestinationVersion);

    if(0 == MoveFileEx(saSourceBinFileName, saDestinationBinFileName, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED))
        return E_FAIL;
    return S_OK;
}


//This sets the BinFileName in a thread safe fashion
HRESULT
TMBSchemaCompilation::SetBinFileVersion
(
    LONG    i_lBinFileVersion
)
{
    HRESULT hr = S_OK;

    if ( i_lBinFileVersion < 0 )
    {
        return E_INVALIDARG;
    }

    TSmartPointerArray<WCHAR> saBinFileName = new WCHAR [m_cchFullyQualifiedBinFileName];
    if(0 == saBinFileName.m_p)
        return E_OUTOFMEMORY;

    wsprintf(saBinFileName, kwszFormatStringFull, m_saBinPath.m_p, i_lBinFileVersion);

    //This will either load the file OR if already loaded, it will bump the ref count
    if(FAILED(hr = m_aBinFile[i_lBinFileVersion % 0x3F].LoadBinFile(saBinFileName, i_lBinFileVersion)))
    {   //if that fails then delete the file and FAIL
        DeleteFile(saBinFileName);
        return hr;
    }

    //verify that the file is in fact a valid SchemaBin file
    if(false == IsValidBin(m_aBinFile[i_lBinFileVersion % 0x3F]))
    {   //if that fails then delete the file and FAIL
        DeleteBinFileVersion(i_lBinFileVersion);
        return E_ST_INVALIDBINFILE;
    }

    LONG lPrevBinFileVersion = m_lBinFileVersion;
    InterlockedExchange(&m_lBinFileVersion, i_lBinFileVersion);
    if ( lPrevBinFileVersion >= 0 )
    {
        DeleteBinFileVersion(lPrevBinFileVersion);
        if ( lPrevBinFileVersion > 0 )
        {
            DeleteBinFileVersion(lPrevBinFileVersion-1);
        }
    }

    return hr;
}


HRESULT
TMBSchemaCompilation::WalkTheFileSystemToFindTheLatestBinFileName()
{
    //Before the user can get the BinFileName they must first have set the path
    ASSERT(0 != m_saBinPath.m_p);

    HANDLE  hFindFile = INVALID_HANDLE_VALUE;

    //we need to scan the directory for
    //files of the form MBSchema.bin.????????.  The file whose ? translates to
    //the largest number represents our MBSchema.bin.  Note: It would take 136 years
    //without a restart for this to roll over - assuming a compile every second.  This
    //is a safe assumption since the compilation process itself currently takes
    //about 2 seconds (on a 900 MHz machine).

    //Build the search string L"d:\Bin-Path\MBSchema.bin.????????h"
    TSmartPointerArray<WCHAR> saSearchString = new WCHAR [m_cchFullyQualifiedBinFileName];
    if(0 == saSearchString.m_p)
        return E_OUTOFMEMORY;
    wcscpy(saSearchString, m_saBinPath);
    wcscat(saSearchString, kwszBinFileNameSearchString);

    WIN32_FIND_DATA FindFileData;
    hFindFile = FindFirstFile(saSearchString, &FindFileData);
    if(INVALID_HANDLE_VALUE == hFindFile)
    {   //it's perfectly valid to find NO matching files - in this case we return L"" with a size of 0
        FindClose(hFindFile);
        return S_OK;
    }

    LONG lMostCurrentBinVersion = -1;
    BinFileToBinVersion(lMostCurrentBinVersion, FindFileData.cFileName);

    //Now try to find the first matching file which ALSO has a valid version number.
    while(-1 == lMostCurrentBinVersion)
    {
        if(!FindNextFile(hFindFile, &FindFileData))//if we walk the list finding bogus matches then bail
        {
            FindClose(hFindFile);
            return S_OK;
        }
        BinFileToBinVersion(lMostCurrentBinVersion, FindFileData.cFileName);
    }

    BOOL bAllDeletesSucceeded;//if any DeleteFile fails then we DON'T rename the most current BinFile to MBSChema.bin.00000000
    bAllDeletesSucceeded=true;

    //Now try to find the MOST CUREENT bin file
    while(FindNextFile(hFindFile, &FindFileData))
    {
        LONG lBinVersion;
        if(FAILED(BinFileToBinVersion(lBinVersion, FindFileData.cFileName)))
            continue;
        if(lBinVersion > lMostCurrentBinVersion)
        {
            //delete the PrevBinVersion and make lBinVersion the previous one
            if(0 == DeleteBinFileVersion(lMostCurrentBinVersion))
                bAllDeletesSucceeded= false;

            //and make this one the most current bin file
            lMostCurrentBinVersion = lBinVersion;
        }
        else
        {
            if(0 == DeleteFile(FindFileData.cFileName))
                bAllDeletesSucceeded = false;
        }
    }
    FindClose(hFindFile);

    //At this point we have attempted to delete all but the MostCurrentBinFile
    if(bAllDeletesSucceeded)
    {//if all deletes succeeded, we can rename the most wszMostCurrentBinFileName to L"MBSchema.bin.00000000"
        if(lMostCurrentBinVersion!=0)
        {
            if(SUCCEEDED(RenameBinFileVersion(lMostCurrentBinVersion, 0/*destination version 0*/)))
                lMostCurrentBinVersion = 0;
        }
    }

    return SetBinFileVersion(lMostCurrentBinVersion);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tfixedtableheapbuilder.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TFixedTableHeapBuilder : public ICompilationPlugin
{
public:
    TFixedTableHeapBuilder();
    ~TFixedTableHeapBuilder();

    virtual void Compile(TPEFixup &fixup, TOutput &out);

    THeap<ULONG>                m_FixedTableHeap;
protected:
    TPEFixup                  * m_pFixup;
    TOutput                   * m_pOut;

    void                        BuildMetaTableHeap();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tcolumnmeta.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

/*
struct ColumnMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            Index;                  //UI4       Column Index
    ULONG                       InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Type;                   //UI4       These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
    ULONG                       Size;                   //UI4
    ULONG                       MetaFlags;              //UI4       ColumnMetaFlags defined in CatMeta.xml
    ULONG                       DefaultValue;           //Bytes
    ULONG                       FlagMask;               //UI4       Only valid for flags
    ULONG                       StartingNumber;         //UI4       Only valid for UI4s
    ULONG                       EndingNumber;           //UI4       Only valid for UI4s
    ULONG                       CharacterSet;           //String    Only valid for Strings
    ULONG                       SchemaGeneratorFlags;   //UI4       ColumnMetaFlags defined in CatMeta.xml
    ULONG                       ID;                     //UI4       Metabase ID
    ULONG                       UserType;               //UI4       One of the Metabase UserTypes
    ULONG                       Attributes;             //UI4       Metabase Attribute flags
    ULONG                       ciTagMeta;              //Count of Tags - Only valid for UI4s
    ULONG                       iTagMeta;               //Index into TagMeta - Only valid for UI4s
    ULONG                       iIndexName;             //IndexName of a single column index (for this column)
	ULONG						Description;			//String	Description
	ULONG                       PublicColumnName;       //String    PublicColumnName
};
*/

class TColumnMeta : public TMetaTable<ColumnMeta>
{
public:
    TColumnMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<ColumnMeta>(fixup,i){}
    const WCHAR * Get_Table               () const {return m_Fixup.StringFromIndex( Get_MetaTable().Table                );}
    const ULONG * Get_Index               () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().Index                );}
    const WCHAR * Get_InternalName        () const {return m_Fixup.StringFromIndex( Get_MetaTable().InternalName         );}
    const WCHAR * Get_PublicName          () const {return m_Fixup.StringFromIndex( Get_MetaTable().PublicName           );}
    const WCHAR * Get_PublicColumnName    () const {return m_Fixup.StringFromIndex( Get_MetaTable().PublicColumnName           );}
    const ULONG * Get_Type                () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().Type                 );}
    const ULONG * Get_Size                () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().Size                 );}
    const ULONG * Get_MetaFlags           () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().MetaFlags            );}
    const BYTE  * Get_DefaultValue        () const {return m_Fixup.ByteFromIndex(   Get_MetaTable().DefaultValue         );}
    const ULONG * Get_FlagMask            () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().FlagMask             );}
    const ULONG * Get_StartingNumber      () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().StartingNumber       );}
    const ULONG * Get_EndingNumber        () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().EndingNumber         );}
    const WCHAR * Get_CharacterSet        () const {return m_Fixup.StringFromIndex( Get_MetaTable().CharacterSet         );}
    const ULONG * Get_SchemaGeneratorFlags() const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().SchemaGeneratorFlags );}
    const ULONG * Get_ID                  () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().ID                   );}
    const ULONG * Get_UserType            () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().UserType             );}
    const ULONG * Get_Attributes          () const {return m_Fixup.UI4pFromIndex(   Get_MetaTable().Attributes           );}
          ULONG   Get_ciTagMeta           () const {return Get_MetaTable().ciTagMeta;}
          ULONG   Get_iTagMeta            () const {return Get_MetaTable().iTagMeta;}
    const WCHAR * Get_iIndexName          () const {return m_Fixup.StringFromIndex( Get_MetaTable().iIndexName           );}
	const WCHAR * Get_Description         () const {return m_Fixup.StringFromIndex( Get_MetaTable().Description          );}

    //Warning!! Users should not rely on this pointer once a Column is added, since the add could cause a relocation of the data.
    virtual ColumnMeta *Get_pMetaTable  ()       {return m_Fixup.ColumnMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount      () const {return m_Fixup.GetCountColumnMeta();};
    const ColumnMeta & Get_MetaTable () const {return *m_Fixup.ColumnMetaFromIndex(m_iCurrent);}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tfixedtableheapbuilder.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"


TFixedTableHeapBuilder::TFixedTableHeapBuilder() :
                 m_pFixup(0)
                ,m_pOut(0)
{
}

TFixedTableHeapBuilder::~TFixedTableHeapBuilder()
{
}

void TFixedTableHeapBuilder::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;

    BuildMetaTableHeap();
}

//The FixedTableHeap is layed out as follows, the fixed length data comes first
//All indexes listed below are byte offsets from the beginning of the FixedTableHeap.  All indexes within the structs are indexes within
//other structs.  For example, DatabaseMeta has a provate column that gives an index to the first table belonging to the database.  That
//index is a TableMeta struct array index (&aTableMeta[index]); it is NOT a byte offset.
/*
0   ULONG           kFixedTableHeapSignature0
1   ULONG           kFixedTableHeapSignature1
2   ULONG           kFixedTableHeapKey
3   ULONG           kFixedTableHeapVersion
4   ULONG           kcbHeap
5   ULONG           EndOfHeap                                       This is the byte offset just beyond the heap.  All indexes should be less than this (this is basically just the size of the heap)

6   ULONG           iColumnMeta                                     This is the byte offset to the aColumnMeta
7   ULONG           cColumnMeta

8   ULONG           iDatabaseMeta
9   ULONG           cDatabaseMeta

A   ULONG           iHashTableHeap
B   ULONG           cbHashTableHeap                                 Size of the HashTableHeap in count of bytes

C   ULONG           iIndexMeta
D   ULONG           cIndexMeta

E   ULONG           iPooledHeap                                     All data is stored in a pooled heap (including UI4s)
F   ULONG           cbPooledHeap                                    Size of the Pooled Heap in count of bytes

10  ULONG           iQueryMeta
11  ULONG           cQueryMeta

12  ULONG           iRelationMeta
13  ULONG           cRelationMeta

14  ULONG           iServerWiringMeta
15  ULONG           cServerWiringMeta

16  ULONG           iTableMeta
17  ULONG           cTableMeta

18  ULONG           iTagMeta
19  ULONG           cTagMeta

1A  ULONG           iULONG                                          Pool For Non Meta Tables
1B  ULONG           cULONG
                              //0x400 ULONGs in a page
    ULONG           aReserved[0x400 - 0x1C]                         This dummy array puts the ULONG pool on a page boundary, this is important for FixedPackedSchema which is located at the beginning of the ULONG pool
------------------------------------Page Boundary------------------------------------
    ULONG               aULONG              [cULONG             ]   FixedPackedSchema pool is always located first in the ULONG pool.
    ColumnMeta          aColumnMeta         [cColumnMeta        ]
    DatabaseMeta        aDatabaseMeta       [cDatabaseMeta      ]
    HashedIndex         HashTableHeap       [cbHashTableHeap    ]
    IndexMeta           aIndexMeta          [cIndexMeta         ]
    unsigned char       PooledDataHeap      [cbPooledDataHeap   ]
    QueryMeta           aQueryMeta          [cQueryMeta         ]
    RelationMeta        aRelationMeta       [cRelationMeta      ]
    ServerWiringMeta    aServerWiringMeta   [cServerWiringMeta  ]
    TableMeta           aTableMeta          [cTableMeta         ]
    TagMeta             aTagMeta            [cTagMeta           ]
*/
void TFixedTableHeapBuilder::BuildMetaTableHeap()
{
    //The heap signatures need to be 0 so multiple signatures don't appear in Catalog.dll
    m_FixedTableHeap.GrowHeap(1024);//pre allocate enough space for the header info, the rest are allocated in pretty big chunks

    m_FixedTableHeap.AddItemToHeap(0);                                     //kFixedTableHeapSignature0
    m_FixedTableHeap.AddItemToHeap(0);                                     //kFixedTableHeapSignature1
    m_FixedTableHeap.AddItemToHeap(kFixedTableHeapKey);                    //kFixedTableHeapKey
    m_FixedTableHeap.AddItemToHeap(kFixedTableHeapVersion);                //kFixedTableHeapVersion    
    m_FixedTableHeap.AddItemToHeap(0);                                     //kcbHeap
    //The above 5 ULONG DON'T get written into the DLL.  They are used to find the position of the heap within the file; but should NOT be overritten.
                                                                 
    //Reserve space for EndOfHeap index                                                                    
    ULONG iiEndOfHeap = m_FixedTableHeap.AddItemToHeap(0L);                //EndOfHeap                 

    //Reserve space for iColumnMeta index                                                                  
    ULONG iiColumnMeta = m_FixedTableHeap.AddItemToHeap(0L);               //iColumnMeta               
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountColumnMeta());        //cColumnMeta               
 
    //Reserve space for iDatabasemeta index
    ULONG iiDatabaseMeta = m_FixedTableHeap.AddItemToHeap(0L);             //iDatabaseMeta             
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountDatabaseMeta());      //cDatabaseMeta             
 
    //Reserve space for iDatabasemeta index
    ULONG iiHashTableHeap = m_FixedTableHeap.AddItemToHeap(0L);            //iHashTableHeap                
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountHashedIndex()*sizeof(HashedIndex));//cbHashTableHeap               
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiIndexMeta = m_FixedTableHeap.AddItemToHeap(0L);                //iIndexMeta                    
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountIndexMeta());         //cIndexMeta                    
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiPooledDataHeap = m_FixedTableHeap.AddItemToHeap(0L);           //iPooledDataHeap
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountOfBytesPooledData()); //cbPooledDataHeap                  
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiQueryMeta = m_FixedTableHeap.AddItemToHeap(0L);                //iQueryMeta                    
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountQueryMeta());         //cQueryMeta                    
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiRelationMeta = m_FixedTableHeap.AddItemToHeap(0L);             //iRelationMeta                 
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountRelationMeta());      //cRelationMeta                 
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiServerWiringMeta = m_FixedTableHeap.AddItemToHeap(0L);         //iServerWiringMeta             
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountServerWiringMeta());  //cServerWiringMeta             
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiTableMeta = m_FixedTableHeap.AddItemToHeap(0L);                //iTableMeta                    
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountTableMeta());         //cTableMeta                    
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiTagMeta = m_FixedTableHeap.AddItemToHeap(0L);                  //iTagMeta                      
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountTagMeta());           //cTagMeta                      
                                                                                    
    //Reserve space for iDatabasemeta index                                         
    ULONG iiULONG = m_FixedTableHeap.AddItemToHeap(0L);                    //iULONG                        
    m_FixedTableHeap.AddItemToHeap(m_pFixup->GetCountULONG());             //cULONG                        

    ULONG ulTemp[0x400];
#ifdef _DEBUG
    for(ULONG i=0;i<0x400;++i)ulTemp[i] = 0x6db6db6d;
#endif
    m_FixedTableHeap.AddItemToHeap(ulTemp, 0x400-0x1C);

    //ULONG pool must come first so that the FixedPackedSchema is page alligned
    ULONG iULONG            = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->ULongFromIndex(0)           ), m_pFixup->GetCountULONG()           * sizeof(ULONG));

    ULONG iColumnMeta       = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->ColumnMetaFromIndex(0)      ), m_pFixup->GetCountColumnMeta()      * sizeof(ColumnMeta));
    ULONG iDatabaseMeta     = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->DatabaseMetaFromIndex(0)    ), m_pFixup->GetCountDatabaseMeta()    * sizeof(DatabaseMeta));
    ULONG iHashedIndex      = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->HashedIndexFromIndex(0)     ), m_pFixup->GetCountHashedIndex()     * sizeof(HashedIndex));
    ULONG iIndexMeta        = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->IndexMetaFromIndex(0)       ), m_pFixup->GetCountIndexMeta()       * sizeof(IndexMeta));
    ULONG iPooledDataHeap   = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->PooledDataPointer()         ), m_pFixup->GetCountOfBytesPooledData());
    ULONG iQueryMeta        = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->QueryMetaFromIndex(0)       ), m_pFixup->GetCountQueryMeta()       * sizeof(QueryMeta));
    ULONG iRelationMeta     = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->RelationMetaFromIndex(0)    ), m_pFixup->GetCountRelationMeta()    * sizeof(RelationMeta));
    ULONG iServerWiringMeta = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->ServerWiringMetaFromIndex(0)), m_pFixup->GetCountServerWiringMeta()* sizeof(ServerWiringMeta));
    ULONG iTableMeta        = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->TableMetaFromIndex(0)       ), m_pFixup->GetCountTableMeta()       * sizeof(TableMeta));
    ULONG iTagMeta          = m_FixedTableHeap.AddItemToHeap(reinterpret_cast<unsigned char *>(m_pFixup->TagMetaFromIndex(0)         ), m_pFixup->GetCountTagMeta()         * sizeof(TagMeta));

    *m_FixedTableHeap.GetTypedPointer(iiColumnMeta      /sizeof(ULONG)) = iColumnMeta      ;
    *m_FixedTableHeap.GetTypedPointer(iiDatabaseMeta    /sizeof(ULONG)) = iDatabaseMeta    ;
    *m_FixedTableHeap.GetTypedPointer(iiHashTableHeap   /sizeof(ULONG)) = iHashedIndex     ;
    *m_FixedTableHeap.GetTypedPointer(iiIndexMeta       /sizeof(ULONG)) = iIndexMeta       ;
    *m_FixedTableHeap.GetTypedPointer(iiPooledDataHeap  /sizeof(ULONG)) = iPooledDataHeap  ;
    *m_FixedTableHeap.GetTypedPointer(iiQueryMeta       /sizeof(ULONG)) = iQueryMeta       ;
    *m_FixedTableHeap.GetTypedPointer(iiRelationMeta    /sizeof(ULONG)) = iRelationMeta    ;
    *m_FixedTableHeap.GetTypedPointer(iiServerWiringMeta/sizeof(ULONG)) = iServerWiringMeta;
    *m_FixedTableHeap.GetTypedPointer(iiTableMeta       /sizeof(ULONG)) = iTableMeta       ;
    *m_FixedTableHeap.GetTypedPointer(iiTagMeta         /sizeof(ULONG)) = iTagMeta         ;
    *m_FixedTableHeap.GetTypedPointer(iiULONG           /sizeof(ULONG)) = iULONG           ;

    *m_FixedTableHeap.GetTypedPointer(iiEndOfHeap       /sizeof(ULONG)) = m_FixedTableHeap.GetEndOfHeap();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\texception.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

struct TException
{
    TException(HRESULT hr, LPCTSTR szFile, LPCTSTR szLineOfCode, UINT nLineNumber, UINT msgID=0) : m_hr(hr), m_szFile(szFile), m_szLineOfCode(szLineOfCode), m_nLineNumber(nLineNumber), m_msgID(msgID){}
    void Dump(TOutput &out){out.printf(TEXT("TException raised:\n\tHRESULT:    \t0x%08x\n\tFile:      \t%s\n\tLine Number:\t%d\n\tCode:      \t%s\n"), m_hr, m_szFile, m_nLineNumber, m_szLineOfCode);}

    HRESULT m_hr;
    LPCTSTR m_szFile;
    LPCTSTR m_szLineOfCode;
    UINT    m_nLineNumber;
    UINT    m_msgID;
};

inline void ThrowExceptionIfFailed(HRESULT hr, LPCTSTR szFile, LPCTSTR szLineOfCode, UINT nLineNumber, UINT msgID=0)
{
    if(FAILED(hr))
    {
//        DebugBreak();
        throw TException(hr, szFile, szLineOfCode, nLineNumber, msgID);
    }
}

inline void ThrowException(LPCTSTR szFile, LPCTSTR szLineOfCode, UINT nLineNumber, UINT msgID=0)
{
//    DebugBreak();
    throw TException(E_FAIL, szFile, szLineOfCode, nLineNumber, msgID);
}

#define XIF(q)                  ThrowExceptionIfFailed(q, TEXT(__FILE__), TEXT(#q), __LINE__)
#define XIF_MCSTRING(id, q)     ThrowExceptionIfFailed(q, TEXT(__FILE__), TEXT(#q), __LINE__, id)
#define THROW(q)                ThrowException(TEXT(__FILE__), TEXT(#q), __LINE__)
#define THROW_MCSTRING(id,q)    ThrowException(TEXT(__FILE__), TEXT(#q), __LINE__, id)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tfile.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TFile
{
public:
    TFile(LPCWSTR wszFileName, TOutput &out, bool bBinary=false, LPSECURITY_ATTRIBUTES psa=0);
    virtual ~TFile();

    void Write(LPCSTR szBuffer, unsigned int nNumChars) const;
    void Write(const unsigned char *pch, unsigned int nNumChars) const;
    void Write(unsigned char ch) const;
    void Write(unsigned long ul) const;
    void Write(LPCWSTR wszBuffer, unsigned int nNumWCHARs);
private:
    HANDLE m_hFile;
    char * m_pBuffer;
    unsigned int m_cbSizeOfBuffer;

};


class TMetaFileMapping
{
public:
    TMetaFileMapping(LPCWSTR filename);
    ~TMetaFileMapping();
    unsigned long Size() const {return m_Size;}
    unsigned char * Mapping() const {return m_pMapping;}

private:
    HANDLE          m_hFile;
    HANDLE          m_hMapping;
    unsigned char * m_pMapping;
    unsigned long   m_Size;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tfixupheaps.h ===
// Copyright (C) 2000 Microsoft Corporation.  All rights reserved.
// Filename:        TFixupHeaps.h
// Author:          Stephenr
// Date Created:    9/19/00
// Description:     This class abstracts the basic heap storage of the meta tables.
//                  We can have different consumers of meta XML that need to build heap.
//                  The consumers need to present a TPeFixup interface to allow
//                  CompilationPlugins to act on this meta.  The easiest way to store
//                  this meta is in heaps.  That's what this object does.
//

#pragma once

class TFixupHeaps : public TPEFixup
{
public:
    TFixupHeaps(){}
    virtual ~TFixupHeaps(){}

    //Begin TPEFixup - This is the interface by which other code accesses the fixed data before it's written into the DLL (or where ever we choose to put it).
    virtual unsigned long       AddBytesToList(const unsigned char * pBytes, size_t cbBytes){return m_HeapPooled.AddItemToHeap(pBytes, (ULONG)cbBytes);}
    virtual unsigned long       AddGuidToList(const GUID &guid)                             {return m_HeapPooled.AddItemToHeap(guid);}
    virtual unsigned long       AddUI4ToList(ULONG ui4)                                     {return m_HeapPooled.AddItemToHeap(ui4);}
    virtual unsigned long       AddULongToList(ULONG ulong)                                 {return m_HeapULONG.AddItemToHeap(ulong);}
    virtual unsigned long       AddWCharToList(LPCWSTR wsz, unsigned long cwchar=(unsigned long)-1)        {return m_HeapPooled.AddItemToHeap(wsz, cwchar);}
    virtual unsigned long       FindStringInPool(LPCWSTR wsz, unsigned long cwchar=(unsigned long)-1) const
    {
        UNREFERENCED_PARAMETER(cwchar);
        return m_HeapPooled.FindMatchingHeapEntry(wsz);
    }

    virtual unsigned long       AddColumnMetaToList         (ColumnMeta       *p, ULONG count=1)       {return m_HeapColumnMeta.AddItemToHeap(p, count);            }
    virtual unsigned long       AddDatabaseMetaToList       (DatabaseMeta     *p, ULONG count=1)       {return m_HeapDatabaseMeta.AddItemToHeap(p, count);          }
    virtual unsigned long       AddHashedIndexToList        (HashedIndex      *p, ULONG count=1)       {return m_HeapHashedIndex.AddItemToHeap(p, count);           }
    virtual unsigned long       AddIndexMetaToList          (IndexMeta        *p, ULONG count=1)       {return m_HeapIndexMeta.AddItemToHeap(p, count);             }
    virtual unsigned long       AddQueryMetaToList          (QueryMeta        *p, ULONG count=1)       {return m_HeapQueryMeta.AddItemToHeap(p, count);             }
    virtual unsigned long       AddRelationMetaToList       (RelationMeta     *p, ULONG count=1)       {return m_HeapRelationMeta.AddItemToHeap(p, count);          }
    virtual unsigned long       AddServerWiringMetaToList   (ServerWiringMeta *p, ULONG count=1)       {return m_HeapServerWiringMeta.AddItemToHeap(p, count);      }
    virtual unsigned long       AddTableMetaToList          (TableMeta        *p, ULONG count=1)       {return m_HeapTableMeta.AddItemToHeap(p, count);             }
    virtual unsigned long       AddTagMetaToList            (TagMeta          *p, ULONG count=1)       {return m_HeapTagMeta.AddItemToHeap(p, count);               }
    virtual unsigned long       AddULongToList              (ULONG            *p, ULONG count)         {return m_HeapULONG.AddItemToHeap(p, count);                 }

    virtual const BYTE       *  ByteFromIndex               (ULONG i) const {return m_HeapPooled.BytePointerFromIndex(i);             }
    virtual const GUID       *  GuidFromIndex               (ULONG i) const {return m_HeapPooled.GuidPointerFromIndex(i);             }
    virtual const WCHAR      *  StringFromIndex             (ULONG i) const {return m_HeapPooled.StringPointerFromIndex(i);           }
    virtual       ULONG         UI4FromIndex                (ULONG i) const {return *m_HeapPooled.UlongPointerFromIndex(i);           }
    virtual const ULONG      *  UI4pFromIndex               (ULONG i) const {return m_HeapPooled.UlongPointerFromIndex(i);            }

    virtual unsigned long       BufferLengthFromIndex       (ULONG i) const {return m_HeapPooled.GetSizeOfItem(i);                    }

    virtual ColumnMeta       *  ColumnMetaFromIndex         (ULONG i=0)     {return m_HeapColumnMeta.GetTypedPointer(i);            }
    virtual DatabaseMeta     *  DatabaseMetaFromIndex       (ULONG i=0)     {return m_HeapDatabaseMeta.GetTypedPointer(i);          }
    virtual HashedIndex      *  HashedIndexFromIndex        (ULONG i=0)     {return m_HeapHashedIndex.GetTypedPointer(i);           }
    virtual IndexMeta        *  IndexMetaFromIndex          (ULONG i=0)     {return m_HeapIndexMeta.GetTypedPointer(i);             }
    virtual QueryMeta        *  QueryMetaFromIndex          (ULONG i=0)     {return m_HeapQueryMeta.GetTypedPointer(i);             }
    virtual RelationMeta     *  RelationMetaFromIndex       (ULONG i=0)     {return m_HeapRelationMeta.GetTypedPointer(i);          }
    virtual ServerWiringMeta *  ServerWiringMetaFromIndex   (ULONG i=0)     {return m_HeapServerWiringMeta.GetTypedPointer(i);      }
    virtual TableMeta        *  TableMetaFromIndex          (ULONG i=0)     {return m_HeapTableMeta.GetTypedPointer(i);             }
    virtual TagMeta          *  TagMetaFromIndex            (ULONG i=0)     {return m_HeapTagMeta.GetTypedPointer(i);               }
    virtual ULONG            *  ULongFromIndex              (ULONG i=0)     {return m_HeapULONG.GetTypedPointer(i);                 }
    virtual unsigned char    *  PooledDataPointer           ()              {return reinterpret_cast<unsigned char *>(m_HeapPooled.GetTypedPointer(0));}

    virtual unsigned long       GetCountColumnMeta          ()        const {return m_HeapColumnMeta.GetCountOfTypedItems();        }
    virtual unsigned long       GetCountDatabaseMeta        ()        const {return m_HeapDatabaseMeta.GetCountOfTypedItems();      }
    virtual unsigned long       GetCountHashedIndex         ()        const {return m_HeapHashedIndex.GetCountOfTypedItems();       }
    virtual unsigned long       GetCountIndexMeta           ()        const {return m_HeapIndexMeta.GetCountOfTypedItems();         }
    virtual unsigned long       GetCountQueryMeta           ()        const {return m_HeapQueryMeta.GetCountOfTypedItems();         }
    virtual unsigned long       GetCountRelationMeta        ()        const {return m_HeapRelationMeta.GetCountOfTypedItems();      }
    virtual unsigned long       GetCountServerWiringMeta    ()        const {return m_HeapServerWiringMeta.GetCountOfTypedItems();  }
    virtual unsigned long       GetCountTableMeta           ()        const {return m_HeapTableMeta.GetCountOfTypedItems();         }
    virtual unsigned long       GetCountTagMeta             ()        const {return m_HeapTagMeta.GetCountOfTypedItems();           }
    virtual unsigned long       GetCountULONG               ()        const {return m_HeapULONG.GetCountOfTypedItems();             }
    virtual unsigned long       GetCountOfBytesPooledData   ()        const {return m_HeapPooled.GetEndOfHeap();                    }

    virtual unsigned long       FindTableBy_TableName(ULONG Table, bool bCaseSensitive=false)
    {
        ASSERT(0 == Table%4);
        unsigned long iTableMeta;
        if(bCaseSensitive)
        {
            for(iTableMeta=GetCountTableMeta()-1;iTableMeta!=(-1);--iTableMeta)
            {
                if(TableMetaFromIndex(iTableMeta)->InternalName == Table)
                    return iTableMeta;
            }
        }
        else
        {
            for(iTableMeta=GetCountTableMeta()-1;iTableMeta!=((unsigned long)-1);--iTableMeta)
            {
                if(0==_wcsicmp(StringFromIndex(TableMetaFromIndex(iTableMeta)->InternalName), StringFromIndex(Table)))
                    return iTableMeta;
            }
        }
        return (unsigned long)-1;
    }
    virtual unsigned long       FindTableBy_TableName(LPCWSTR wszTable)
    {
        ULONG Table = FindStringInPool(wszTable);
        return (Table == (unsigned long)-1) ? (unsigned long)-1 : FindTableBy_TableName(Table);
    }
    virtual unsigned long       FindColumnBy_Table_And_Index(unsigned long Table, unsigned long Index, bool bCaseSensitive=false)
    {
        ASSERT(0 == Table%4);
        ASSERT(Index>0 && 0 == Index%4);
        bool bTableMatches=false;
        //Start at the end because presumably the caller cares about the ColumnMeta for the columns just added
        if(bCaseSensitive)
        {
            for(ULONG iColumnMeta=GetCountColumnMeta()-1; iColumnMeta!=(-1);--iColumnMeta)
            {
                if( ColumnMetaFromIndex(iColumnMeta)->Table == Table)
                {
                    bTableMatches = true;
                    if(ColumnMetaFromIndex(iColumnMeta)->Index == Index)
                        return iColumnMeta;
                }
                else if(bTableMatches)
                    return (unsigned long)-1;
            }
        }
        else
        {
            for(ULONG iColumnMeta=GetCountColumnMeta()-1; iColumnMeta!=(-1);--iColumnMeta)
            {
                if(0==_wcsicmp(StringFromIndex(ColumnMetaFromIndex(iColumnMeta)->Table), StringFromIndex(Table)))
                {
                    bTableMatches = true;
                    if(ColumnMetaFromIndex(iColumnMeta)->Index == Index)
                        return iColumnMeta;
                }
                else if(bTableMatches)
                    return (unsigned long)-1;
            }
        }
        return (unsigned long)-1;
    }
    virtual unsigned long       FindColumnBy_Table_And_InternalName(unsigned long Table, unsigned long  InternalName, bool bCaseSensitive=false)
    {
        ASSERT(0 == Table%4);
        ASSERT(0 == InternalName%4);
        bool bTableMatches=false;
        //Start at the end because presumably the caller cares about the ColumnMeta for the columns just added
        if(bCaseSensitive)
        {
            for(ULONG iColumnMeta=GetCountColumnMeta()-1; iColumnMeta!=(-1);--iColumnMeta)
            {
                if( ColumnMetaFromIndex(iColumnMeta)->Table==Table)
                {
                    bTableMatches = true;
                    if(ColumnMetaFromIndex(iColumnMeta)->InternalName==InternalName)
                        return iColumnMeta;
                }
                else if(bTableMatches)//if we previously found the table and now we don't match the table, then we never will, so bail.
                {
                    return (unsigned long)-1;
                }
            }
        }
        else
        {
            for(ULONG iColumnMeta=GetCountColumnMeta()-1; iColumnMeta!=(-1);--iColumnMeta)
            {
                if(ColumnMetaFromIndex(iColumnMeta)->Table==Table || 0==_wcsicmp(StringFromIndex(ColumnMetaFromIndex(iColumnMeta)->Table), StringFromIndex(Table)))
                {
                    bTableMatches = true;
                    if(ColumnMetaFromIndex(iColumnMeta)->InternalName==InternalName || 0==_wcsicmp(StringFromIndex(ColumnMetaFromIndex(iColumnMeta)->InternalName), StringFromIndex(InternalName)))
                        return iColumnMeta;
                }
                else if(bTableMatches)//if we previously found the table and now we don't match the table, then we never will, so bail.
                {
                    return (unsigned long)-1;
                }
            }
        }
        return (unsigned long)-1;
    }
    virtual unsigned long       FindTagBy_Table_And_Index(ULONG iTableName, ULONG iColumnIndex, bool bCaseSensitive=false)
    {
        ASSERT(0 == iTableName%4);
        ASSERT(iColumnIndex>0 && 0 == iColumnIndex%4);
        bool bTableMatches=false;
        if(bCaseSensitive)
        {
            for(ULONG iTagMeta=0; iTagMeta<GetCountTagMeta();++iTagMeta)
            {
                if( TagMetaFromIndex(iTagMeta)->Table       == iTableName)
                {
                    bTableMatches = true;
                    if(TagMetaFromIndex(iTagMeta)->ColumnIndex == iColumnIndex)
                        return iTagMeta;
                }
                else if(bTableMatches)
                {
                    return (unsigned long)-1;
                }
            }
        }
        else
        {
            for(ULONG iTagMeta=0; iTagMeta<GetCountTagMeta();++iTagMeta)
            {
                if(0==_wcsicmp(StringFromIndex(TagMetaFromIndex(iTagMeta)->Table), StringFromIndex(iTableName)))
                {
                    bTableMatches = true;
                    if(TagMetaFromIndex(iTagMeta)->ColumnIndex == iColumnIndex)
                        return iTagMeta;
                }
                else if(bTableMatches)
                {
                    return (unsigned long)-1;
                }
            }
        }
        return (unsigned long)-1;
    }
    //End TPEFixup

protected:
    //We need a buch of Heaps.  We're going to use THeap.
    THeap<ColumnMeta      >     m_HeapColumnMeta      ;
    THeap<DatabaseMeta    >     m_HeapDatabaseMeta    ;
    THeap<HashedIndex     >     m_HeapHashedIndex     ;
    THeap<IndexMeta       >     m_HeapIndexMeta       ;
    THeap<QueryMeta       >     m_HeapQueryMeta       ;
    THeap<RelationMeta    >     m_HeapRelationMeta    ;
    THeap<ServerWiringMeta>     m_HeapServerWiringMeta;
    THeap<TableMeta       >     m_HeapTableMeta       ;
    THeap<TagMeta         >     m_HeapTagMeta         ;
    THeap<ULONG           >     m_HeapULONG           ;

    TPooledHeap                 m_HeapPooled          ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tfile.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

TFile::TFile(LPCWSTR wszFileName, TOutput &out, bool bBinary, LPSECURITY_ATTRIBUTES psa) : m_cbSizeOfBuffer(0), m_pBuffer(0)
{
    UNREFERENCED_PARAMETER(bBinary);

    if(-1 != GetFileAttributes(wszFileName))//if GetFileAttributes fails then the file does not exist
    {   //if it does NOT fail then lets delete the file before we open it.  The only reason I'm doing all of this is because
        //_wfopen failed once and weren't able to repro the problem on another machine.  So this is a bit over coded
        if(0 == DeleteFile(wszFileName))
        {   //if delete file fails then report this warning, but continue any way.
            out.printf(L"Warning! Unable to delete file %s.  Last error returned 0x%08x.\n\tCheck to see that the file is not Read-Only\n", wszFileName, GetLastError());
        }
    }

	if(INVALID_HANDLE_VALUE == (m_hFile = CreateFile(wszFileName, GENERIC_WRITE, 0, psa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)))
    {
        out.printf(L"Error - Failed to create file %s.\n", wszFileName);
        THROW(CreateFile Failed.);
    }
}


TFile::~TFile()
{
    if(m_hFile)
        CloseHandle(m_hFile);

    delete [] m_pBuffer;
}


void TFile::Write(LPCSTR szBuffer, unsigned int nNumChars) const
{
    DWORD dwBytesWritten;
	if(!WriteFile(m_hFile, reinterpret_cast<const void *>(szBuffer), DWORD(nNumChars), &dwBytesWritten, NULL))
	{
        THROW(L"Write File Failed.");
	}
}


void TFile::Write(const unsigned char *pch, unsigned int nNumChars) const
{
    Write(reinterpret_cast<const char *>(pch), nNumChars);
}


void TFile::Write(unsigned char ch) const
{
    Write(reinterpret_cast<const char *>(&ch), sizeof(unsigned char));
}


void TFile::Write(unsigned long ul) const
{
    Write(reinterpret_cast<const char *>(&ul), sizeof(unsigned long));
}


void TFile::Write(LPCWSTR wszBuffer, unsigned int nNumWCHARs)
{
    if(nNumWCHARs > m_cbSizeOfBuffer)
    {
        delete [] m_pBuffer;
        m_pBuffer = new char [nNumWCHARs];//We want to write the file as chars not UNICODE
        if(0 == m_pBuffer)
            THROW(ERROR - FAILED TO ALLOCATE MEMORY);
        m_cbSizeOfBuffer = nNumWCHARs;
    }
    WideCharToMultiByte(CP_UTF8, 0, wszBuffer, nNumWCHARs, m_pBuffer, nNumWCHARs, 0, 0);

    DWORD dwBytesWritten;
	if(!WriteFile(m_hFile, reinterpret_cast<const void *>(m_pBuffer), DWORD(nNumWCHARs), &dwBytesWritten, NULL))
	{
        THROW(ERROR - WRITE FILE FAILED);
	}
}


TMetaFileMapping::TMetaFileMapping(LPCWSTR filename)
{
    m_hFile = CreateFile(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL);
    m_hMapping = CreateFileMapping(m_hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
    m_pMapping = reinterpret_cast<unsigned char *>(MapViewOfFile(m_hMapping, FILE_MAP_WRITE, 0, 0, 0));
    if(0 == m_pMapping)//We only check the last step of the process since the last two steps should fail gracefully if passed NULL.
        THROW(ERROR MAPPING VIEW OF FILE);
    m_Size = GetFileSize(m_hFile, 0);
}


TMetaFileMapping::~TMetaFileMapping()
{
    if(m_pMapping)
    {
        if(0 == FlushViewOfFile(m_pMapping,0))
            THROW(ERROR - UNABLE TO FLUSH TO DISK);
        UnmapViewOfFile(m_pMapping);
        m_pMapping = 0;
    }

    if(m_hMapping)
        CloseHandle(m_hMapping);
    m_hMapping = 0;

    if(m_hFile)
        CloseHandle(m_hFile);
    m_hFile = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tdatabasemeta.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

/*
struct DatabaseMeta
{
    ULONG PRIMARYKEY            InternalName            //String
    ULONG                       PublicName              //String
    ULONG                       BaseVersion             //UI4
    ULONG                       ExtendedVersion         //UI4
    ULONG                       CountOfTables           //UI4       Count of tables in database
    ULONG                       iSchemaBlob             //Index into Pool
    ULONG                       cbSchemaBlob            //Count of Bytes of the SchemaBlob
    ULONG                       iNameHeapBlob           //Index into Pool
    ULONG                       cbNameHeapBlob          //Count of Bytes of the SchemaBlob
    ULONG                       iTableMeta              //Index into TableMeta
    ULONG                       iGuidDid                //Index to Pool, where the guid is the Database InternalName cast as a GUID and padded with 0x00s.
	ULONG						Description				//String
};
*/

class TDatabaseMeta : public TMetaTable<DatabaseMeta>
{
public:
    TDatabaseMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<DatabaseMeta>(fixup,i){}
    const WCHAR * Get_InternalName    () const {return m_Fixup.StringFromIndex(   Get_MetaTable().InternalName   );}
    const WCHAR * Get_PublicName      () const {return m_Fixup.StringFromIndex(   Get_MetaTable().PublicName     );}
    const ULONG * Get_BaseVersion     () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().BaseVersion    );}
    const ULONG * Get_ExtendedVersion () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().ExtendedVersion);}
    const ULONG * Get_CountOfTables   () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().CountOfTables  );}
    const BYTE  * Get_iSchemaBlob     () const {return m_Fixup.ByteFromIndex(     Get_MetaTable().iSchemaBlob    );}
    const ULONG   Get_cbSchemaBlob    () const {return                            Get_MetaTable().cbSchemaBlob    ;}
    const BYTE  * Get_iNameHeapBlob   () const {return m_Fixup.ByteFromIndex(     Get_MetaTable().iNameHeapBlob  );}
          ULONG   Get_cbNameHeapBlob  () const {return                            Get_MetaTable().cbNameHeapBlob  ;}
          ULONG   Get_iTableMeta      () const {return                            Get_MetaTable().iTableMeta      ;}
    const GUID  * Get_iGuidDid        () const {return m_Fixup.GuidFromIndex(     Get_MetaTable().iGuidDid       );}
	const WCHAR * Get_Desciption      () const {return m_Fixup.StringFromIndex(   Get_MetaTable().Description    );}
   
    virtual DatabaseMeta * Get_pMetaTable   ()       {return m_Fixup.DatabaseMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount          () const {return m_Fixup.GetCountDatabaseMeta();};
    const DatabaseMeta & Get_MetaTable () const {return *m_Fixup.DatabaseMetaFromIndex(m_iCurrent);}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\thashedpkindexes.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class THashedPKIndexes : public ICompilationPlugin
{
public:
    THashedPKIndexes();
    ~THashedPKIndexes();

    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    typedef ULONG HashArray[kLargestPrime*2];

    THeap<HashedIndex>  m_HashedIndexHeap;
    TPEFixup *          m_pFixup;
    TOutput  *          m_pOut;

    unsigned long   DetermineBestModulo(ULONG cRows, ULONG cPrimaryKeys, HashArray aHashes[]);
    unsigned long   DetermineModuloRating(ULONG cRows, ULONG AccumulativeLinkage, ULONG Modulo) const;
    unsigned long   FillInTheHashTable(unsigned long cRows, unsigned long cPrimaryKeys, HashArray Hashes[], ULONG Modulo);
    void            FillInTheHashTableForColumnMeta  ();
    void            FillInTheHashTableForDatabase    ();
    void            FillInTheHashTableForIndexMeta   ();
    void            FillInTheHashTableForQueryMeta   ();
    void            FillInTheHashTableForRelationMeta();
    void            FillInTheHashTableForTableMeta   ();
    void            FillInTheHashTableForTagMeta     ();
    void            FillInTheHashTables();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\thasheduniqueindexes.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class THashedUniqueIndexes : public ICompilationPlugin
{
public:
    THashedUniqueIndexes();
    ~THashedUniqueIndexes();

    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    TPEFixup *          m_pFixup;
    TOutput  *          m_pOut;

    unsigned long   DetermineBestModulo(ULONG cRows, ULONG aHashes[]);
    unsigned long   DetermineModuloRating(ULONG cRows, ULONG AccumulativeLinkage, ULONG Modulo) const;
    unsigned long   FillInTheHashTable(unsigned long cRows, ULONG aHashes[], ULONG Modulo);
    void            FillInTheHashTableViaIndexMeta(TTableMeta &i_TableMeta);
    void            FillInTheHashTableViaIndexMeta(TTableMeta &i_tableMeta, TIndexMeta &i_indexMeta, ULONG cIndexMeta);
    void            GetMetaTable(ULONG iTableName, TMetaTableBase ** o_ppMetaTable) const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\thasheduniqueindexes.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

class TServerWiringMeta : public TMetaTable<ServerWiringMeta>
{
public:
    TServerWiringMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<ServerWiringMeta>(fixup,i){}

    virtual ServerWiringMeta *Get_pMetaTable ()       {return m_Fixup.ServerWiringMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount  () const {return m_Fixup.GetCountServerWiringMeta();};
    const ServerWiringMeta & Get_MetaTable () const {return *m_Fixup.ServerWiringMetaFromIndex(m_iCurrent);}
};


THashedUniqueIndexes::THashedUniqueIndexes() :
                m_pFixup(0)
                ,m_pOut(0)
{
}


THashedUniqueIndexes::~THashedUniqueIndexes()
{
}


void THashedUniqueIndexes::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;

    TTableMeta tableMeta(fixup);
    for(ULONG iTableMeta=0; iTableMeta<tableMeta.GetCount();++iTableMeta, tableMeta.Next())
    {
        FillInTheHashTableViaIndexMeta(tableMeta);
    }
}


extern unsigned int kPrime[];


unsigned long THashedUniqueIndexes::DetermineBestModulo(ULONG cRows, ULONG aHashes[])
{
    unsigned long BestModulo = 0;
    unsigned int LeastDups = (unsigned int)-1;

    static HashedIndex  pHashTable[kLargestPrime * 2];

    //Let's first see if the index is a reasonable one for large tables
    if(cRows > kLargestPrime/2)
        return kLargestPrime;

    ULONG cPrimesTried=0;
    ULONG AccumulativeLinkage=0;
    ULONG BestModuloRating=0;
    for(unsigned int iPrimeNumber=0; kPrime[iPrimeNumber] != 0 && kPrime[iPrimeNumber]<(cRows * 20) && BestModuloRating<60; ++iPrimeNumber)
    {
        if(kPrime[iPrimeNumber]<cRows)//we don't have a chance of coming up with few duplicates if the prime number is LESS than the number of rows in the table.
            continue;                //So skip all the small primes.

        m_pOut->printf(L".");

        unsigned int Dups           = 0;
        unsigned int DeepestLink    = 0;

        AccumulativeLinkage=0;

        //We're going to use the HashPool to store this temporary data so we can figure out the dup count and the deepest depth
        memset(pHashTable, -1, sizeof(pHashTable));
        for(unsigned long iRow=0; iRow<cRows && Dups<LeastDups;++iRow)
        {
            ULONG HashedIndex = aHashes[iRow] % kPrime[iPrimeNumber];

            if(0 == pHashTable[HashedIndex].iNext)//if this is the second time we've seen this hash, then bump the Dups
                ++Dups;

            ++(pHashTable[HashedIndex].iNext);//For now Next holds the number of occurances of this hash
            AccumulativeLinkage += (pHashTable[HashedIndex].iNext+1);

            if(pHashTable[HashedIndex].iNext > DeepestLink)
                DeepestLink = pHashTable[HashedIndex].iNext;
        }
        ++cPrimesTried;
        ULONG ModuloRating = DetermineModuloRating(cRows, AccumulativeLinkage, kPrime[iPrimeNumber]);
        if(ModuloRating > BestModuloRating)
        {
            BestModulo          = kPrime[iPrimeNumber];
            BestModuloRating    = ModuloRating;
        }
        //m_pOut->printf(L"\nRating %4d\tModulo %4d\tcRows %4d\tAccLinkage %4d", ModuloRating, kPrime[iPrimeNumber], cRows, AccumulativeLinkage);
    }
    //m_pOut->printf(L"cPrimesTried %4d\tBestModulo %4d\n", cPrimesTried, BestModulo);

    if(0 == BestModulo)
        THROW(No hashing scheme seems reasonable.);

    return BestModulo;
}

//returns a number between 0 and 100 where 100 is a perfect Modulo
unsigned long THashedUniqueIndexes::DetermineModuloRating(ULONG cRows, ULONG AccumulativeLinkage, ULONG Modulo) const
{
    if(0 == cRows)
        return 100;

    unsigned long ModuloRating = (cRows*100) / AccumulativeLinkage;//This doesn't take into account the Modulo value
    if(ModuloRating > 100)
        return 100;

    //Now we need to add in the bonus that makes the rating go up as we approach  Modulo of kLargestPrime.
    //This wiill raise the Rating by as much as 50% of the way toward 100.  In other word a rating of 60 with a Modulo of kLargestPrime would result in
    //a final rating of 80.
    ModuloRating += (((100 - ModuloRating) * Modulo) / (2*kLargestPrime));

    return ModuloRating;
}

unsigned long THashedUniqueIndexes::FillInTheHashTable(unsigned long cRows, ULONG aHashes[], ULONG Modulo)
{
    HashedIndex header;//This is actually the HashTableHeader
    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(&header);
    pHeader->Modulo = Modulo;
    pHeader->Size   = Modulo;//This Size is not only the number of HashedIndex entries but where we put the overflow from duplicate Hashes.

    //We'll fixup the Size member when we're done.
    ULONG iHashTableHeader = m_pFixup->AddHashedIndexToList(&header)/sizeof(HashedIndex);
    ULONG iHashTable = iHashTableHeader+1;

    HashedIndex     hashedindextemp;
    for(ULONG i=0;i<Modulo;++i)//-1 fill the hash table
        m_pFixup->AddHashedIndexToList(&hashedindextemp);

    for(unsigned long iRow=0; iRow<cRows; ++iRow)
    {
        ASSERT(-1 != aHashes[iRow]);//These fixed table should have a hash for each row.  If a hash turns out to be -1, we have a problem, since we've reserved -1 to indicate an empty slot.
        //This builds the hases for the TableName
        ULONG HashedIndex = aHashes[iRow] % pHeader->Modulo;
        if(-1 == m_pFixup->HashedIndexFromIndex(iHashTable + HashedIndex)->iOffset)
            m_pFixup->HashedIndexFromIndex(iHashTable + HashedIndex)->iOffset = iRow;//iNext is already -1 so no need to set it
        else
        {   //Otherwise we have to walk the linked list to find the last one so we can append this one to the end
            unsigned int LastInLink = HashedIndex;
            while(-1 != m_pFixup->HashedIndexFromIndex(iHashTable + LastInLink)->iNext)
                LastInLink = m_pFixup->HashedIndexFromIndex(iHashTable + LastInLink)->iNext;

            m_pFixup->HashedIndexFromIndex(iHashTable + LastInLink)->iNext = pHeader->Size;//Size is the end of the hash table, so append it to the end and bump the Size.

            //Reuse the temp variable
            hashedindextemp.iNext   = (ULONG)-1;//we only added enough for the hash table without the overflow slots.  So these dups need to be added to the heap with -1 set for iNext.
            hashedindextemp.iOffset = iRow;
            m_pFixup->AddHashedIndexToList(&hashedindextemp);

            ++pHeader->Size;
        }
    }

    //Now fix the Header Size         //The type is HashedIndex, so HashedIndex.iOffset maps to HashedHeader.Size
    m_pFixup->HashedIndexFromIndex(iHashTableHeader)->iOffset = pHeader->Size;

    return iHashTableHeader;
}


void THashedUniqueIndexes::FillInTheHashTableViaIndexMeta(TTableMeta &i_tableMeta)
{
    if(0 == i_tableMeta.Get_cIndexMeta())
        return;//If there's no IndexMeta for this table, just return

    ULONG   iIndexMeta=i_tableMeta.Get_iIndexMeta();

    while(iIndexMeta != (i_tableMeta.Get_iIndexMeta() + i_tableMeta.Get_cIndexMeta()))
    {
        TIndexMeta indexMeta(*m_pFixup, iIndexMeta);
        LPCWSTR wszIndexName=indexMeta.Get_InternalName();
        ULONG   i;
        //Walk the indexMeta to find out how many match the Index name
        for(i=iIndexMeta;i<(i_tableMeta.Get_iIndexMeta() + i_tableMeta.Get_cIndexMeta()) && wszIndexName==indexMeta.Get_InternalName();++i, indexMeta.Next());

        //Reset the list to point to the first index (that matches the Index name)
        indexMeta.Reset();
        FillInTheHashTableViaIndexMeta(i_tableMeta, indexMeta, i-iIndexMeta);

        iIndexMeta = i;
    }
}

void THashedUniqueIndexes::FillInTheHashTableViaIndexMeta(TTableMeta &i_tableMeta, TIndexMeta &i_indexMeta, ULONG cIndexMeta)
{
    ASSERT(cIndexMeta != 0);


    //We only build hash table for UNIQUE indexes
//    if(0 == (fINDEXMETA_UNIQUE & *indexMeta.Get_MetaFlags()))
//        return;

    TSmartPointer<TMetaTableBase> pMetaTable;
    GetMetaTable(i_indexMeta.Get_pMetaTable()->Table, &pMetaTable);

    //Only care about the meta tables right now.  In the future we might handle the other fixed tables.  GetMetaTable returns NULL for non Meta tables.
    if(0 == pMetaTable.m_p)
        return;

    m_pOut->printf(L"Building indexed (%s) hash table for table: %s", i_indexMeta.Get_InternalName(), i_tableMeta.Get_InternalName());

    TSmartPointerArray<unsigned long> pRowHash = new unsigned long [pMetaTable->GetCount()];
    if(0 == pRowHash.m_p)
        THROW(OUT OF MEMORY);

    //Get the ColumnMeta so we can interpret pTable correctly.
    for(unsigned long iRow=0; iRow < pMetaTable->GetCount(); ++iRow, pMetaTable->Next())
    {
        ULONG *pData = pMetaTable->Get_pulMetaTable();
        unsigned long RowHash=0;//This hash is the combination of all PKs that uniquely identifies the row
        i_indexMeta.Reset();
        for(ULONG iIndexMeta=0;iIndexMeta < cIndexMeta; i_indexMeta.Next(), ++iIndexMeta)
        {
            ULONG iColumn = *i_indexMeta.Get_ColumnIndex();
            TColumnMeta ColumnMeta(*m_pFixup, i_tableMeta.Get_iColumnMeta() + iColumn);

            if(0 == pData[iColumn])
            {
                m_pOut->printf(L"\nError - Table (%s), Column number %d (%s) is an Index but is set to NULL.\n", i_tableMeta.Get_InternalName(), iColumn, ColumnMeta.Get_InternalName());
                THROW(Fixed table contains NULL value in Unique Index);
            }

            switch(*ColumnMeta.Get_Type())
            {
            case DBTYPE_GUID:
                RowHash = Hash(*m_pFixup->GuidFromIndex(pData[iColumn]), RowHash);break;
            case DBTYPE_WSTR:
                RowHash = Hash(m_pFixup->StringFromIndex(pData[iColumn]), RowHash);break;
            case DBTYPE_UI4:
                RowHash = Hash(m_pFixup->UI4FromIndex(pData[iColumn]), RowHash);break;
            case DBTYPE_BYTES:
                RowHash = Hash(m_pFixup->ByteFromIndex(pData[iColumn]), m_pFixup->BufferLengthFromIndex(pData[iColumn]), RowHash);break;
            default:
                THROW(unsupported type);
            }
        }
        pRowHash[iRow] = RowHash;
    }
    i_indexMeta.Reset();

    //OK Now we have the 32 bit hash values.  Now we need to see which prime number acts as the best modulo.
    unsigned long Modulo = DetermineBestModulo(pMetaTable->GetCount(), pRowHash);

    //Now actually fill in the hash table
    unsigned long iHashTable = FillInTheHashTable(pMetaTable->GetCount(), pRowHash, Modulo);

    i_indexMeta.Get_pMetaTable()->iHashTable = iHashTable;
    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_pFixup->HashedIndexFromIndex(iHashTable));//The heap is of type HashedIndex, so cast
    unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;

    m_pOut->printf(L"\n%s hash table has %d nonunique entries.\n", i_tableMeta.Get_InternalName(), cNonUniqueEntries);

}


void THashedUniqueIndexes::GetMetaTable(ULONG iTableName, TMetaTableBase ** o_ppMetaTable) const
{
    ASSERT(0!=o_ppMetaTable);
    *o_ppMetaTable = 0;
    if(iTableName      == m_pFixup->FindStringInPool(L"COLUMNMETA"))
    {
        *o_ppMetaTable = new TColumnMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"DATABASEMETA"))
    {
        *o_ppMetaTable = new TDatabaseMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"INDEXMETA"))
    {
        *o_ppMetaTable = new TIndexMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"QUERYMETA"))
    {
        *o_ppMetaTable = new TQueryMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"RELATIONMETA"))
    {
        *o_ppMetaTable = new TRelationMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"SERVERWIRINGMETA"))
    {
        *o_ppMetaTable = new TServerWiringMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"TABLEMETA"))
    {
        *o_ppMetaTable = new TTableMeta(*m_pFixup);
    }
    else if(iTableName == m_pFixup->FindStringInPool(L"TAGMETA"))
    {
        *o_ppMetaTable = new TTagMeta(*m_pFixup);
    }
    else return;

    if(0 == *o_ppMetaTable)
        THROW(OUT OF MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\thashedpkindexes.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"


THashedPKIndexes::THashedPKIndexes() :
                 m_pFixup(0)
                ,m_pOut(0)
{
}

THashedPKIndexes::~THashedPKIndexes()
{
}

void THashedPKIndexes::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;

    m_HashedIndexHeap.GrowHeap(400000);//make plenty of room to reduce reallocs

    //We special case the Meta tables since we know for a fact that they are ordered in such a way that they can be queried by
    //any number of PrimaryKeys (ie. TagMeta can be queried by Table, Table/ColumnIndex, or Table/ColumnIndex/InternalName).  This
    //is because of the way the Meta tables are sorted and the containment enforced in CatMeta.XML.
    FillInTheHashTableForColumnMeta  ();
    FillInTheHashTableForDatabase    ();
    FillInTheHashTableForIndexMeta   ();
    FillInTheHashTableForQueryMeta   ();
//@@@    FillInTheHashTableForRelationMeta();
    FillInTheHashTableForTableMeta   ();
    FillInTheHashTableForTagMeta     ();

    m_pFixup->AddHashedIndexToList(m_HashedIndexHeap.GetTypedPointer(), m_HashedIndexHeap.GetCountOfTypedItems());
}

//We start with two because there are going to be tables with only one row.  To prevent an 'if' statement
//ALL FIXED tables will have a hash table associated with them, even those with one row.  So by starting
//with 2 as the first prime, the hash table will be of size 2, for those tables with only one row.
unsigned int kPrime[] = {
      2,     3,      5,      7,     11,     13,     17,     19,     23,     29,
     31,    37,     41,     43,     47,     53,     59,     61,     67,     71,
     73,    79,     83,     89,     97,    101,    103,    107,    109,    113,
    127,   131,    137,    139,    149,    151,    157,    163,    167,    173,
    179,   181,    191,    193,    197,    199,    211,    223,    227,    229,
    233,   239,    241,    251,    257,    263,    269,    271,    277,    281,
    283,   293,    307,    311,    313,    317,    331,    337,    347,    349,
    353,   359,    367,    373,    379,    383,    389,    397,    401,    409,
    419,   421,    431,    433,    439,    443,    449,    457,    461,    463,
    467,   479,    487,    491,    499,    503,    509,    521,    523,    541,
    547,   557,    563,    569,    571,    577,    587,    593,    599,    601,
    607,   613,    617,    619,    631,    641,    643,    647,    653,    659,
    661,   673,    677,    683,    691,    701,    709,    719,    727,    733,
    739,   743,    751,    757,    761,    769,    773,    787,    797,    809,
    811,   821,    823,    827,    829,    839,    853,    857,    859,    863,
    877,   881,    883,    887,    907,    911,    919,    929,    937,    941,
    947,   953,    967,    971,    977,    983,    991,    997,   1009,   1013,
   1019,  1021,   1031,   1033,   1039,   1049,   1051,   1061,   1063,   1069,
   1087,  1091,   1093,   1097,   1103,   1109,   1117,   1123,   1129,   1151,
   1153,  1163,   1171,   1181,   1187,   1193,   1201,   1213,   1217,   1223,
   1229,  1231,   1237,   1249,   1259,   1277,   1279,   1283,   1289,   1291,
   1297,  1301,   1303,   1307,   1319,   1321,   1327,   1361,   1367,   1373,
   1381,  1399,   1409,   1423,   1427,   1429,   1433,   1439,   1447,   1451,
   1453,  1459,   1471,   1481,   1483,   1487,   1489,   1493,   1499,   1511,
   1523,  1531,   1543,   1549,   1553,   1559,   1567,   1571,   1579,   1583,
   1597,  1601,   1607,   1609,   1613,   1619,   1621,   1627,   1637,   1657,
   1663,  1667,   1669,   1693,   1697,   1699,   1709,   1721,   1723,   1733,
   1741,  1747,   1753,   1759,   1777,   1783,   1787,   1789,   1801,   1811,
   1823,  1831,   1847,   1861,   1867,   1871,   1873,   1877,   1879,   1889,
   1901,  1907,   1913,   1931,   1933,   1949,   1951,   1973,   1979,   1987,
   1993,  1997,   1999,   2003,   2011,   2017,   2027,   2029,   2039,   2053,
   2063,  2069,   2081,   2083,   2087,   2089,   2099,   2111,   2113,   2129,
   2131,  2137,   2141,   2143,   2153,   2161,   2179,   2203,   2207,   2213,
   2221,  2237,   2239,   2243,   2251,   2267,   2269,   2273,   2281,   2287,
   2293,  2297,   2309,   2311,   2333,   2339,   2341,   2347,   2351,   2357,
   2371,  2377,   2381,   2383,   2389,   2393,   2399,   2411,   2417,   2423,
   2437,  2441,   2447,   2459,   2467,   2473,   2477,   2503,   2521,   2531,
   2539,  2543,   2549,   2551,   2557,   2579,   2591,   2593,   2609,   2617,
   2621,  2633,   2647,   2657,   2659,   2663,   2671,   2677,   2683,   2687,
   2689,  2693,   2699,   2707,   2711,   2713,   2719,   2729,   2731,   2741,
   2749,  2753,   2767,   2777,   2789,   2791,   2797,   2801,   2803,   2819,
   2833,  2837,   2843,   2851,   2857,   2861,   2879,   2887,   2897,   2903,
   2909,  2917,   2927,   2939,   2953,   2957,   2963,   2969,   2971,   2999,
   3001,  3011,   3019,   3023,   3037,   3041,   3049,   3061,   3067,   3079,
   3083,  3089,   3109,   3119,   3121,   3137,   3163,   3167,   3169,   3181,
   3187,  3191,   3203,   3209,   3217,   3221,   3229,   3251,   3253,   3257,
   3259,  3271,   3299,   3301,   3307,   3313,   3319,   3323,   3329,   3331,
   3343,  3347,   3359,   3361,   3371,   3373,   3389,   3391,   3407,   3413,
   3433,  3449,   3457,   3461,   3463,   3467,   3469,   3491,   3499,   3511,
   3517,  3527,   3529,   3533,   3539,   3541,   3547,   3557,   3559,   3571,
   3581,  3583,   3593,   3607,   3613,   3617,   3623,   3631,   3637,   3643,
   3659,  3671,   3673,   3677,   3691,   3697,   3701,   3709,   3719,   3727,
   3733,  3739,   3761,   3767,   3769,   3779,   3793,   3797,   3803,   3821,
   3823,  3833,   3847,   3851,   3853,   3863,   3877,   3881,   3889,   3907,
   3911,  3917,   3919,   3923,   3929,   3931,   3943,   3947,   3967,   3989,
   4001,  4003,   4007,   4013,   4019,   4021,   4027,   4049,   4051,   4057,
   4073,  4079,   4091,   4093,   4099,   4111,   4127,   4129,   4133,   4139,
   4153,  4157,   4159,   4177,   4201,   4211,   4217,   4219,   4229,   4231,
   4241,  4243,   4253,   4259,   4261,   4271,   4273,   4283,   4289,   4297,
   4327,  4337,   4339,   4349,   4357,   4363,   4373,   4391,   4397,   4409,
   4421,  4423,   4441,   4447,   4451,   4457,   4463,   4481,   4483,   4493,
   4507,  4513,   4517,   4519,   4523,   4547,   4549,   4561,   4567,   4583,
   4591,  4597,   4603,   4621,   4637,   4639,   4643,   4649,   4651,   4657,
   4663,  4673,   4679,   4691,   4703,   4721,   4723,   4729,   4733,   4751,
   4759,  4783,   4787,   4789,   4793,   4799,   4801,   4813,   4817,   4831,
   4861,  4871,   4877,   4889,   4903,   4909,   4919,   4931,   4993,   4937,
   4943,  4951,   4957,   4967,   4969,   4973,   4987,   4993,   4999,   5003,
   5009,  5011,   5021,   5023,   5039,   5051,   5059,   5077,   5081,   5087,
   5099,  5101,   5107,   5113,   5119,   5147,   5153,   5167,   5171,   5179,
   5189,  5197,   5209,   5227,   5231,   5233,   5237,   5261,   5273,   5279,
   10007, 20011,  0 };//These last two prime are to cover an extreme corner case


unsigned long THashedPKIndexes::DetermineBestModulo(ULONG cRows, ULONG cPrimaryKeys, HashArray Hashes[])
{
    if(0 == cRows)//Some kinds of meta may have no rows (like IndexMeta).
        return 1;

    unsigned long BestModulo = 0;

    static HashedIndex  pHashTable[kLargestPrime * 2];

    if(cRows > kLargestPrime/2)
        return kLargestPrime;

    ULONG BestModuloRating=0;

    //We're going to use a formula to determine which Modulo is best
    ULONG AccumulativeLinkage=0;
    for(unsigned int iPrimeNumber=0; kPrime[iPrimeNumber] != 0 && kPrime[iPrimeNumber]<(cRows * 20) && BestModuloRating<60; ++iPrimeNumber)
    {
        if(kPrime[iPrimeNumber]<cRows)//we don't have a chance of coming up with few duplicates if the prime number is LESS than the number of rows in the table.
            continue;                //So skip all the small primes.

        m_pOut->printf(L".");

        unsigned int Dups           = 0;
        unsigned int DeepestLink    = 0;

        //We're going to use the HashPool to store this temporary data so we can figure out the dup count and the deepest depth
        memset(pHashTable, -1, sizeof(pHashTable));
        AccumulativeLinkage = 0;
        for(unsigned long iPrimaryKey=0; iPrimaryKey<cPrimaryKeys; ++iPrimaryKey)
        {
            for(unsigned long iRow=0; iRow<cRows/* && Dups<LeastDups && DeepestLink<LeastDeepestLink*/;++iRow)
            {
                if(-1 == Hashes[iPrimaryKey][iRow])//Ignore those with a -1 for the hash.  We're all but guarenteed that all hashes are non -1
                    continue;

                ULONG HashedIndex = Hashes[iPrimaryKey][iRow] % kPrime[iPrimeNumber];

                if(0 == pHashTable[HashedIndex].iNext)//if this is the first duplicate for this hash, then bump the Dups
                    ++Dups;

                ++(pHashTable[HashedIndex].iNext);//For now Next holds the number of occurances of this hash
                AccumulativeLinkage += (pHashTable[HashedIndex].iNext + 1);

                if(pHashTable[HashedIndex].iNext > DeepestLink)
                    DeepestLink = pHashTable[HashedIndex].iNext;
            }
        }
        ULONG ModuloRating = DetermineModuloRating(cRows, AccumulativeLinkage, kPrime[iPrimeNumber]);
        if(ModuloRating > BestModuloRating)
        {
            BestModulo          = kPrime[iPrimeNumber];
            BestModuloRating    = ModuloRating;
        }
        //m_pOut->printf(L"\nRating %4d\tModulo %4d\tcRows %4d\tAccLinkage %4d", ModuloRating, kPrime[iPrimeNumber], cRows, AccumulativeLinkage);
    }

    if(0 == BestModulo)
        THROW(No hashing scheme seems reasonable.);

    return BestModulo;
}

//returns a number between 0 and 100 where 100 is a perfect Modulo
unsigned long THashedPKIndexes::DetermineModuloRating(ULONG cRows, ULONG AccumulativeLinkage, ULONG Modulo) const
{
    if(0 == cRows)
        return 100;

    unsigned long ModuloRating = (cRows*100) / AccumulativeLinkage;//This doesn't take into account the Modulo value
    if(ModuloRating > 100)
        return 100;

    //Now we need to add in the bonus that makes the rating go up as we approach  Modulo of kLargestPrime.
    //This wiill raise the Rating by as much as 50% of the way toward 100.  In other word a rating of 60 with a Modulo of kLargestPrime would result in
    //a final rating of 80.
    ModuloRating += (((100 - ModuloRating) * Modulo) / kLargestPrime);

    return ModuloRating;
}

unsigned long THashedPKIndexes::FillInTheHashTable(unsigned long cRows, unsigned long cPrimaryKeys, HashArray Hashes[], ULONG Modulo)
{
    HashedIndex header;//This is actually the HashTableHeader
    HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(&header);
    pHeader->Modulo = Modulo;
    pHeader->Size   = Modulo;//This Size is not only the number of HashedIndex entries but where we put the overflow from duplicate Hashes.

    //We'll fixup the Size member when we're done.
    ULONG iHashTableHeader = m_HashedIndexHeap.AddItemToHeap(header)/sizeof(HashedIndex);
    ULONG iHashTable = iHashTableHeader+1;

    HashedIndex     hashedindextemp;
    for(ULONG i=0;i<Modulo;++i)
        m_HashedIndexHeap.AddItemToHeap(hashedindextemp);

    for(unsigned long iPrimaryKey=0; iPrimaryKey<cPrimaryKeys; ++iPrimaryKey)
    {
        for(unsigned long iRow=0; iRow<cRows; ++iRow)
        {
            if(-1 != Hashes[iPrimaryKey][iRow])
            {   //This builds the hases for the TableName
                ULONG HashedIndex = Hashes[iPrimaryKey][iRow] % pHeader->Modulo;
                if(-1 == m_HashedIndexHeap.GetTypedPointer(iHashTable + HashedIndex)->iOffset)
                    m_HashedIndexHeap.GetTypedPointer(iHashTable + HashedIndex)->iOffset = iRow;//iNext is already -1 so no need to set it
                else
                {   //Otherwise we have to walk the linked list to find the last one so we can append this one to the end
                    unsigned int LastInLink = HashedIndex;
                    while(-1 != m_HashedIndexHeap.GetTypedPointer(iHashTable + LastInLink)->iNext)
                        LastInLink = m_HashedIndexHeap.GetTypedPointer(iHashTable + LastInLink)->iNext;

                    m_HashedIndexHeap.GetTypedPointer(iHashTable + LastInLink)->iNext = pHeader->Size;//Size is the end of the hash table, so append it to the end and bump the Size.

                    //Reuse the temp variable
                    hashedindextemp.iNext   = (ULONG)-1;//we only added enough for the hash table without the overflow slots.  So these dups need to be added to the heap with -1 set for iNext.
                    hashedindextemp.iOffset = iRow;
                    m_HashedIndexHeap.AddItemToHeap(hashedindextemp);

                    ++pHeader->Size;
                }
            }
        }
    }
    //Now fix the Header Size         //The type is HashedIndex, so HashedIndex.iOffset maps to HashedHeader.Size
    m_HashedIndexHeap.GetTypedPointer(iHashTableHeader)->iOffset = pHeader->Size;

    return iHashTableHeader;
}

void THashedPKIndexes::FillInTheHashTableForColumnMeta()
{
    m_pOut->printf(L"Building ColumnMeta hash table");
    unsigned int iRow;//indexes are reused

    //ColumnMeta has two primarykeys so build hashes for all of the first PK, then build the hashes for both PKs
    const int cPrimaryKeys = 2;
    HashArray *pHashes = NULL;

    pHashes = new HashArray[cPrimaryKeys];

    if ( pHashes == NULL )
    {
        m_pOut->printf(L"Error! Out of memory in THashedPKIndexes::FillInTheHashTableForColumnMeta");
        THROW(OUT OF MEMORY);
    }

    try
    {
        TColumnMeta ColumnMeta(*m_pFixup);
        ULONG cRows = ColumnMeta.GetCount();
        if(cRows>(kLargestPrime*2))
        {
            m_pOut->printf(L"Error! Too Many Rows - ColumnMeta has %d rows, Hash table generation relies on fixed tables being less than %d rows\n",cRows, kLargestPrime*2);
            THROW_MCSTRING(IDS_SCHEMA_COMPILATION_SCHEMA_OVERFLOW, TOO MANY ROWS - HASH TABLE GENERATION ASSUMES FIXED TABLES ARE RELATIVELY SMALL);
        }

        LPCWSTR pPrevTableName=0;
        pHashes[0][0] = (ULONG)-1;
        for(iRow=0; iRow<cRows; ++iRow, ColumnMeta.Next())
        {
            if(ColumnMeta.Get_Table() == pPrevTableName)
                pHashes[0][iRow] = (ULONG)-1;
            else
                pHashes[0][iRow] = Hash(pPrevTableName=ColumnMeta.Get_Table(), 0);
        }

        ColumnMeta.Reset();
        pHashes[1][0] = (ULONG)-1;
        for(iRow=0; iRow<cRows; ++iRow, ColumnMeta.Next())
        {
            if(0 == ColumnMeta.Get_Index())
                pHashes[1][iRow] = (ULONG)-1;
            else
                pHashes[1][iRow] = Hash(*ColumnMeta.Get_Index(), Hash(ColumnMeta.Get_Table(), 0));
        }
        //At this point we have a list of the 32 bit hash values

        //Now we need to figure out which prime number will be the best modulo.  So we modulo every 32 bit hash value
        //by the prime number to see how many duplicates result.  We repeat this process for every 'reasonable' prime number
        //and determine which one leaves up with the least duplicates.

        unsigned long Modulo = DetermineBestModulo(cRows, cPrimaryKeys, pHashes);

        //OK, now that the setup is done we can build the hash.  We reuse the pHashes list since it just stores the 32 bit hash values.
        //We just need to modulo the value to store it into the hash.
        unsigned long iHashTable = FillInTheHashTable(cRows, cPrimaryKeys, pHashes, Modulo);

        ULONG iMetaTable = m_pFixup->FindTableBy_TableName(L"COLUMNMETA");
        m_pFixup->TableMetaFromIndex(iMetaTable)->iHashTableHeader = iHashTable;

        HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_HashedIndexHeap.GetTypedPointer(iHashTable));//The heap is of type HashedIndex, so cast
        unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;
        m_pOut->printf(L"\nColumnMeta hash table has %d nonunique entries.\n", cNonUniqueEntries);
    }
    catch ( TException& err )
    {
        if ( pHashes != NULL )
        {
            delete [] pHashes;
            pHashes = NULL;
        }

        throw ( err );
    }

    if ( pHashes != NULL )
    {
        delete [] pHashes;
        pHashes = NULL;
    }
}

void THashedPKIndexes::FillInTheHashTableForDatabase()
{
    m_pOut->printf(L"Building DatabaseMeta hash table");
    unsigned int iRow;//indexes are reused

    //DatabaseMeta has one primarykey so build hashes for the PK values
    const int cPrimaryKeys = 1;
    HashArray *pHashes = NULL;

    pHashes = new HashArray[cPrimaryKeys];

    if ( pHashes == NULL )
    {
        m_pOut->printf(L"Error! Out of memory in THashedPKIndexes::FillInTheHashTableForDatabase");
        THROW(OUT OF MEMORY);
    }

    try
    {
        TDatabaseMeta DatabaseMeta(*m_pFixup);
        ULONG cRows = DatabaseMeta.GetCount();
        if(cRows>(kLargestPrime*2))
        {
            m_pOut->printf(L"Error! Too Many Rows - DatabaseMeta has %d rows, Hash table generation relies on fixed tables being less than %d rows\n",cRows, kLargestPrime*2);
            THROW(TOO MANY ROWS - HASH TABLE GENERATION ASSUMES FIXED TABLES ARE RELATIVELY SMALL);
        }

        pHashes[0][0] = (ULONG)-1;
        for(iRow=0; iRow<cRows; ++iRow, DatabaseMeta.Next())
            pHashes[0][iRow] = Hash(DatabaseMeta.Get_InternalName(), 0);

        //At this point we have a list of the 32 bit hash values

        //Now we need to figure out which prime number will be the best modulo.  So we modulo every 32 bit hash value
        //by the prime number to see how many duplicates result.  We repeat this process for every 'reasonable' prime number
        //and determine which one leaves up with the least duplicates.

        unsigned long Modulo = DetermineBestModulo(cRows, cPrimaryKeys, pHashes);

        //OK, now that the setup is done we can build the hash.  We reuse the pHashes list since it just stores the 32 bit hash values.
        //We just need to modulo the value to store it into the hash.
        unsigned long iHashTable = FillInTheHashTable(cRows, cPrimaryKeys, pHashes, Modulo);

        ULONG iMetaTable = m_pFixup->FindTableBy_TableName(L"DATABASEMETA");
        m_pFixup->TableMetaFromIndex(iMetaTable)->iHashTableHeader = iHashTable;

        HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_HashedIndexHeap.GetTypedPointer(iHashTable));//The heap is of type HashedIndex, so cast
        unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;
        m_pOut->printf(L"\nDatabaseMeta hash table has %d nonunique entries.\n", cNonUniqueEntries);
    }
    catch ( TException& err )
    {
        if ( pHashes != NULL )
        {
            delete [] pHashes;
            pHashes = NULL;
        }

        throw ( err );
    }

    if ( pHashes != NULL )
    {
        delete [] pHashes;
        pHashes = NULL;
    }
}

void THashedPKIndexes::FillInTheHashTableForIndexMeta()
{
    m_pOut->printf(L"Building IndexMeta hash table");
    unsigned int iRow;//indexes are reused

    //IndexMeta has three primarykeys so build hashes for all of the first PK, then build the hashes for two PKs, then all three
    const int cPrimaryKeys = 3;
    HashArray *pHashes = NULL;

    pHashes = new HashArray[cPrimaryKeys];

    if ( pHashes == NULL )
    {
        m_pOut->printf(L"Error! Out of memory in THashedPKIndexes::FillInTheHashTableForIndexMeta");
        THROW(OUT OF MEMORY);
    }

    try
    {
        TIndexMeta IndexMeta(*m_pFixup);
        ULONG cRows = IndexMeta.GetCount();
        if(cRows>(kLargestPrime*2))
        {
            m_pOut->printf(L"Error! Too Many Rows - IndexMeta has %d rows, Hash table generation relies on fixed tables being less than %d rows\n",cRows, kLargestPrime*2);
            THROW(TOO MANY ROWS - HASH TABLE GENERATION ASSUMES FIXED TABLES ARE RELATIVELY SMALL);
        }

        LPCWSTR pPrevTableName=0;
        pHashes[0][0] = (ULONG)-1;
        for(iRow=0; iRow<cRows; ++iRow, IndexMeta.Next())
        {
            if(IndexMeta.Get_Table() == pPrevTableName)
                pHashes[0][iRow] = (ULONG)-1;
            else
                pHashes[0][iRow] = Hash(pPrevTableName=IndexMeta.Get_Table(), 0);
        }

        IndexMeta.Reset();
        pPrevTableName=0;
        LPCWSTR pPrevInteralName=0;
        pHashes[1][0] = (ULONG)-1;
        for(iRow=0; iRow<cRows; ++iRow, IndexMeta.Next())
        {
            if(IndexMeta.Get_Table() == pPrevTableName && IndexMeta.Get_InternalName() == pPrevInteralName)
                pHashes[1][iRow] = (ULONG)-1;
            else
                pHashes[1][iRow] = Hash(pPrevInteralName=IndexMeta.Get_InternalName(), Hash(pPrevTableName=IndexMeta.Get_Table(), 0));
        }

        IndexMeta.Reset();
        for(iRow=0; iRow<cRows; ++iRow, IndexMeta.Next())
            pHashes[2][iRow] = Hash(*IndexMeta.Get_ColumnIndex(), Hash(IndexMeta.Get_InternalName(), Hash(IndexMeta.Get_Table(), 0)));

        //At this point we have a list of the 32 bit hash values

        //Now we need to figure out which prime number will be the best modulo.  So we modulo every 32 bit hash value
        //by the prime number to see how many duplicates result.  We repeat this process for every 'reasonable' prime number
        //and determine which one leaves up with the least duplicates.

        unsigned long Modulo = DetermineBestModulo(cRows, cPrimaryKeys, pHashes);

        //OK, now that the setup is done we can build the hash.  We reuse the pHashes list since it just stores the 32 bit hash values.
        //We just need to modulo the value to store it into the hash.
        unsigned long iHashTable = FillInTheHashTable(cRows, cPrimaryKeys, pHashes, Modulo);

        ULONG iMetaTable = m_pFixup->FindTableBy_TableName(L"INDEXMETA");
        m_pFixup->TableMetaFromIndex(iMetaTable)->iHashTableHeader = iHashTable;

        HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_HashedIndexHeap.GetTypedPointer(iHashTable));//The heap is of type HashedIndex, so cast
        unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;
        m_pOut->printf(L"\nIndexMeta hash table has %d nonunique entries.\n", cNonUniqueEntries);
    }
    catch ( TException& err )
    {
        if ( pHashes != NULL )
        {
            delete [] pHashes;
            pHashes = NULL;
        }

        throw ( err );
    }

    if ( pHashes != NULL )
    {
        delete [] pHashes;
        pHashes = NULL;
    }
}

void THashedPKIndexes::FillInTheHashTableForQueryMeta()
{
    m_pOut->printf(L"Building QueryMeta hash table");
    unsigned int iRow;//indexes are reused

    //QueryMeta has two primarykeys so build hashes for all of the first PK, then build the hashes for two PKs
    const int cPrimaryKeys = 2;
    HashArray *pHashes = NULL;

    pHashes = new HashArray[cPrimaryKeys];

    if ( pHashes == NULL )
    {
        m_pOut->printf(L"Error! Out of memory in THashedPKIndexes::FillInTheHashTableForQueryMeta");
        THROW(OUT OF MEMORY);
    }

    try
    {
        TQueryMeta QueryMeta(*m_pFixup);
        ULONG cRows = QueryMeta.GetCount();
        if(cRows>(kLargestPrime*2))
        {
            m_pOut->printf(L"Error! Too Many Rows - QueryMeta has %d rows, Hash table generation relies on fixed tables being less than %d rows\n",cRows, kLargestPrime*2);
            THROW(TOO MANY ROWS - HASH TABLE GENERATION ASSUMES FIXED TABLES ARE RELATIVELY SMALL);
        }

        LPCWSTR pPrevTableName=0;
        pHashes[0][0] = (ULONG)-1;
        for(iRow=0; iRow<cRows; ++iRow, QueryMeta.Next())
        {
            if(QueryMeta.Get_Table() == pPrevTableName)
                pHashes[0][iRow] = (ULONG)-1;
            else
                pHashes[0][iRow] = Hash(pPrevTableName=QueryMeta.Get_Table(), 0);
        }

        QueryMeta.Reset();
        pHashes[1][0] = (ULONG)-1;
        for(iRow=0; iRow<cRows; ++iRow, QueryMeta.Next())
                pHashes[1][iRow] = Hash(QueryMeta.Get_InternalName(), Hash(QueryMeta.Get_Table(), 0));

        //At this point we have a list of the 32 bit hash values

        //Now we need to figure out which prime number will be the best modulo.  So we modulo every 32 bit hash value
        //by the prime number to see how many duplicates result.  We repeat this process for every 'reasonable' prime number
        //and determine which one leaves up with the least duplicates.

        unsigned long Modulo = DetermineBestModulo(cRows, cPrimaryKeys, pHashes);

        //OK, now that the setup is done we can build the hash.  We reuse the pHashes list since it just stores the 32 bit hash values.
        //We just need to modulo the value to store it into the hash.
        unsigned long iHashTable = FillInTheHashTable(cRows, cPrimaryKeys, pHashes, Modulo);

        ULONG iMetaTable = m_pFixup->FindTableBy_TableName(L"QUERYMETA");
        m_pFixup->TableMetaFromIndex(iMetaTable)->iHashTableHeader = iHashTable;

        HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_HashedIndexHeap.GetTypedPointer(iHashTable));//The heap is of type HashedIndex, so cast
        unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;
        m_pOut->printf(L"\nQueryMeta hash table has %d nonunique entries.\n", cNonUniqueEntries);
    }
    catch ( TException& err )
    {
        if ( pHashes != NULL )
        {
            delete [] pHashes;
            pHashes = NULL;
        }

        throw ( err );
    }

    if ( pHashes != NULL )
    {
        delete [] pHashes;
        pHashes = NULL;
    }
}

void THashedPKIndexes::FillInTheHashTableForRelationMeta()
{
    //@@@ We can't do the relation meta until we sort them.  At that point we need to sort the rows by PrimaryTable and have a separate table sorted
    //@@@ by ForeignTable
}

void THashedPKIndexes::FillInTheHashTableForTableMeta()
{
    m_pOut->printf(L"Building TableMeta hash table");
    unsigned int iRow;//indexes are reused

    //TableMeta has one primarykey so build hashes for the PK values
    const int cPrimaryKeys = 1;
    HashArray *pHashes = NULL;

    pHashes = new HashArray[cPrimaryKeys];

    if ( pHashes == NULL )
    {
        m_pOut->printf(L"Error! Out of memory in THashedPKIndexes::FillInTheHashTableForTableMeta");
        THROW(OUT OF MEMORY);
    }

    try
    {
        TTableMeta TableMeta(*m_pFixup);
        ULONG cRows = TableMeta.GetCount();
        if(cRows>(kLargestPrime*2))
        {
            m_pOut->printf(L"Error! Too Many Rows - TableMeta has %d rows, Hash table generation relies on fixed tables being less than %d rows\n",cRows, kLargestPrime*2);
            THROW(TOO MANY ROWS - HASH TABLE GENERATION ASSUMES FIXED TABLES ARE RELATIVELY SMALL);
        }

        pHashes[0][0] = (ULONG)-1;
        for(iRow=0; iRow<cRows; ++iRow, TableMeta.Next())
            pHashes[0][iRow] = Hash(TableMeta.Get_InternalName(), 0);

        //At this point we have a list of the 32 bit hash values

        //Now we need to figure out which prime number will be the best modulo.  So we modulo every 32 bit hash value
        //by the prime number to see how many duplicates result.  We repeat this process for every 'reasonable' prime number
        //and determine which one leaves up with the least duplicates.

        unsigned long Modulo = DetermineBestModulo(cRows, cPrimaryKeys, pHashes);

        //OK, now that the setup is done we can build the hash.  We reuse the pHashes list since it just stores the 32 bit hash values.
        //We just need to modulo the value to store it into the hash.
        unsigned long iHashTable = FillInTheHashTable(cRows, cPrimaryKeys, pHashes, Modulo);

        ULONG iMetaTable = m_pFixup->FindTableBy_TableName(L"TABLEMETA");
        m_pFixup->TableMetaFromIndex(iMetaTable)->iHashTableHeader = iHashTable;

        HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_HashedIndexHeap.GetTypedPointer(iHashTable));//The heap is of type HashedIndex, so cast
        unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;
        m_pOut->printf(L"\nTableMeta hash table has %d nonunique entries.\n", cNonUniqueEntries);
    }
    catch ( TException& err )
    {
        if ( pHashes != NULL )
        {
            delete [] pHashes;
            pHashes = NULL;
        }

        throw ( err );
    }

    if ( pHashes != NULL )
    {
        delete [] pHashes;
        pHashes = NULL;
    }
}

void THashedPKIndexes::FillInTheHashTableForTagMeta()
{
    m_pOut->printf(L"Building TagMeta hash table");
    unsigned int iRow;//indexes are reused

    //TagMeta has three primarykeys so build hashes for all of the first PK, then build the hashes for two PKs, then all three
    const int cPrimaryKeys = 3;
    HashArray *pHashes = NULL;

    pHashes = new HashArray[cPrimaryKeys];

    if ( pHashes == NULL )
    {
        m_pOut->printf(L"Error! Out of memory in THashedPKIndexes::FillInTheHashTableForTableMeta");
        THROW(OUT OF MEMORY);
    }

    try
    {
        TTagMeta TagMeta(*m_pFixup);
        ULONG cRows = TagMeta.GetCount();
        if(cRows>(kLargestPrime*2))
        {
            m_pOut->printf(L"Error! Too Many Rows - TagMeta has %d rows, Hash table generation relies on fixed tables being less than %d rows\n",cRows, kLargestPrime*2);
            THROW(TOO MANY ROWS - HASH TABLE GENERATION ASSUMES FIXED TABLES ARE RELATIVELY SMALL);
        }

        LPCWSTR pPrevTableName=0;
        pHashes[0][0] = (ULONG)-1;
        for(iRow=0; iRow<cRows; ++iRow, TagMeta.Next())
        {
            if(TagMeta.Get_Table() == pPrevTableName)
                pHashes[0][iRow] = (ULONG)-1;
            else
                pHashes[0][iRow] = Hash(pPrevTableName=TagMeta.Get_Table(), 0);
        }

        TagMeta.Reset();
        pPrevTableName=0;
        ULONG iPrevColumnIndex=(ULONG)-1;
        pHashes[1][0] = (ULONG)-1;
        for(iRow=0; iRow<cRows; ++iRow, TagMeta.Next())
        {
            if(TagMeta.Get_Table() == pPrevTableName && *TagMeta.Get_ColumnIndex() == iPrevColumnIndex)
                pHashes[1][iRow] = (ULONG)-1;
            else
                pHashes[1][iRow] = Hash(iPrevColumnIndex=*TagMeta.Get_ColumnIndex(), Hash(pPrevTableName=TagMeta.Get_Table(), 0));
        }

        TagMeta.Reset();
        pHashes[2][0] = (ULONG)-1;
        for(iRow=0; iRow<cRows; ++iRow, TagMeta.Next())
            pHashes[2][iRow] = Hash(TagMeta.Get_InternalName(), Hash(*TagMeta.Get_ColumnIndex(), Hash(TagMeta.Get_Table(), 0)));

        //At this point we have a list of the 32 bit hash values

        //Now we need to figure out which prime number will be the best modulo.  So we modulo every 32 bit hash value
        //by the prime number to see how many duplicates result.  We repeat this process for every 'reasonable' prime number
        //and determine which one leaves up with the least duplicates.

        unsigned long Modulo = DetermineBestModulo(cRows, cPrimaryKeys, pHashes);

        //OK, now that the setup is done we can build the hash.  We reuse the pHashes list since it just stores the 32 bit hash values.
        //We just need to modulo the value to store it into the hash.
        unsigned long iHashTable = FillInTheHashTable(cRows, cPrimaryKeys, pHashes, Modulo);

        ULONG iMetaTable = m_pFixup->FindTableBy_TableName(L"TAGMETA");
        m_pFixup->TableMetaFromIndex(iMetaTable)->iHashTableHeader = iHashTable;

        HashTableHeader *pHeader = reinterpret_cast<HashTableHeader *>(m_HashedIndexHeap.GetTypedPointer(iHashTable));//The heap is of type HashedIndex, so cast
        unsigned int cNonUniqueEntries = pHeader->Size - pHeader->Modulo;
        m_pOut->printf(L"\nTagMeta hash table has %d nonunique entries.\n", cNonUniqueEntries);
    }
    catch ( TException& err )
    {
        if ( pHashes != NULL )
        {
            delete [] pHashes;
            pHashes = NULL;
        }

        throw ( err );
    }

    if ( pHashes != NULL )
    {
        delete [] pHashes;
        pHashes = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tmbschemageneration.cpp ===
// Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
// Filename:        TMBSchemaGeneration.cpp
// Author:          Stephenr
// Date Created:    10/9/2000
// Description:     This compilation plugin takes the metabase's meta and generates MBSchema.xml.
//
#include "precomp.hxx"

TMBSchemaGeneration::TMBSchemaGeneration(LPCWSTR i_wszSchemaXmlFile) :
                m_wszSchemaXmlFile(i_wszSchemaXmlFile)
{
}

void TMBSchemaGeneration::Compile(TPEFixup &fixup, TOutput &out)
{
    UNREFERENCED_PARAMETER(out);

    TDatabaseMeta databasemeta(fixup);
    ULONG iMetabaseDatabaseMeta=0;
    for( ;iMetabaseDatabaseMeta<databasemeta.GetCount(); ++iMetabaseDatabaseMeta, databasemeta.Next())
    {
        if(0 == _wcsicmp(databasemeta.Get_InternalName(), wszDATABASE_METABASE))
            break;
    }
    if(databasemeta.GetCount() == iMetabaseDatabaseMeta)
    {
        THROW(METABASE DATABASE NOT FOUND);
    }

    {//CWriter doesn't close the file until the dtor, so scope it here
        //I don't have to keep track of these pointers, they are owned by the object that returns them.
        CWriter writer;
        XIF(writer.Initialize(m_wszSchemaXmlFile, NULL, NULL));
	    XIF(writer.BeginWrite(eWriter_Schema));//This writes the UTF8 header bytes

        TSmartPointer<CCatalogSchemaWriter> spCSchemaWriter;
	    XIF(writer.GetCatalogSchemaWriter(&spCSchemaWriter));

        TTableMeta tablemeta(fixup, databasemeta.Get_iTableMeta()+1);//skip the MetabaseBaseClass

        LPCWSTR pszMETABASE = tablemeta.Get_Database();
        
        (VOID)pszMETABASE;

        for(ULONG iTableMeta=databasemeta.Get_iTableMeta()+1; iTableMeta<(tablemeta.GetCount()-2); ++iTableMeta, tablemeta.Next())
        {
            ASSERT(tablemeta.Get_Database()==pszMETABASE);
            if(0 == wcscmp(tablemeta.Get_InternalName(), wszTABLE_IIsInheritedProperties))
                continue;
            if(0 == wcscmp(tablemeta.Get_InternalName(), wszTABLE_MBProperty))
                break;
            /*
            struct tTABLEMETARow {
                     WCHAR *     pDatabase;
                     WCHAR *     pInternalName;
                     WCHAR *     pPublicName;
                     WCHAR *     pPublicRowName;
                     ULONG *     pBaseVersion;
                     ULONG *     pExtendedVersion;
                     ULONG *     pNameColumn;
                     ULONG *     pNavColumn;
                     ULONG *     pCountOfColumns;
                     ULONG *     pMetaFlags;
                     ULONG *     pSchemaGeneratorFlags;
                     WCHAR *     pConfigItemName;
                     WCHAR *     pConfigCollectionName;
                     ULONG *     pPublicRowNameColumn;
                     WCHAR *     pContainerClassList;
					 WCHAR *	 pDescription;
            };*/
		    tTABLEMETARow tmRow;
            tmRow.pDatabase                 = const_cast<LPWSTR> (tablemeta.Get_Database            ());
            tmRow.pInternalName             = const_cast<LPWSTR> (tablemeta.Get_InternalName        ());
            tmRow.pPublicName               = const_cast<LPWSTR> (tablemeta.Get_PublicName          ());
            tmRow.pPublicRowName            = const_cast<LPWSTR> (tablemeta.Get_PublicRowName       ());
            tmRow.pBaseVersion              = const_cast<ULONG *>(tablemeta.Get_BaseVersion         ());
            tmRow.pExtendedVersion          = const_cast<ULONG *>(tablemeta.Get_ExtendedVersion     ());
            tmRow.pNameColumn               = const_cast<ULONG *>(tablemeta.Get_NameColumn          ());
            tmRow.pNavColumn                = const_cast<ULONG *>(tablemeta.Get_NavColumn           ());
            tmRow.pCountOfColumns           = const_cast<ULONG *>(tablemeta.Get_CountOfColumns      ());
            tmRow.pMetaFlags                = const_cast<ULONG *>(tablemeta.Get_MetaFlags           ());
            tmRow.pSchemaGeneratorFlags     = const_cast<ULONG *>(tablemeta.Get_SchemaGeneratorFlags());
            tmRow.pConfigItemName           = const_cast<LPWSTR> (tablemeta.Get_ConfigItemName      ());
            tmRow.pConfigCollectionName     = const_cast<LPWSTR> (tablemeta.Get_ConfigCollectionName());
            tmRow.pPublicRowNameColumn      = const_cast<ULONG *>(tablemeta.Get_PublicRowNameColumn ());
            tmRow.pContainerClassList       = const_cast<LPWSTR> (tablemeta.Get_ContainerClassList  ());
			tmRow.pDescription				= const_cast<LPWSTR> (tablemeta.Get_Description         ());

            CCatalogCollectionWriter * pCollectionWriter;
		    XIF(spCSchemaWriter->GetCollectionWriter(&tmRow, &pCollectionWriter));

            TColumnMeta columnmeta(fixup, tablemeta.Get_iColumnMeta());
            for(ULONG iColumnMeta=0; iColumnMeta<*tablemeta.Get_CountOfColumns(); ++iColumnMeta, columnmeta.Next())
            {
                /*
                struct tCOLUMNMETARow {
                         WCHAR *     pTable;
                         ULONG *     pIndex;
                         WCHAR *     pInternalName;
                         WCHAR *     pPublicName;
                         ULONG *     pType;
                         ULONG *     pSize;
                         ULONG *     pMetaFlags;
                 unsigned char *     pDefaultValue;
                         ULONG *     pFlagMask;
                         ULONG *     pStartingNumber;
                         ULONG *     pEndingNumber;
                         WCHAR *     pCharacterSet;
                         ULONG *     pSchemaGeneratorFlags;
                         ULONG *     pID;
                         ULONG *     pUserType;
                         ULONG *     pAttributes;
						 WCHAR *	 pDescription
                };*/
                tCOLUMNMETARow cmRow;
                cmRow.pTable                   = const_cast<LPWSTR> (columnmeta.Get_Table               ());
                cmRow.pIndex                   = const_cast<ULONG *>(columnmeta.Get_Index               ());
                cmRow.pInternalName            = const_cast<LPWSTR> (columnmeta.Get_InternalName        ());

                if(0 == wcscmp(L"Location", cmRow.pInternalName))//Locatioin is derived from the MetabaseBaseClass
                    continue;

                cmRow.pPublicName              = const_cast<LPWSTR> (columnmeta.Get_PublicName          ());
                cmRow.pType                    = const_cast<ULONG *>(columnmeta.Get_Type                ());
                cmRow.pSize                    = const_cast<ULONG *>(columnmeta.Get_Size                ());
                cmRow.pMetaFlags               = const_cast<ULONG *>(columnmeta.Get_MetaFlags           ());
                cmRow.pDefaultValue            = const_cast<unsigned char *>(columnmeta.Get_DefaultValue());
                cmRow.pFlagMask                = const_cast<ULONG *>(columnmeta.Get_FlagMask            ());
                cmRow.pStartingNumber          = const_cast<ULONG *>(columnmeta.Get_StartingNumber      ());
                cmRow.pEndingNumber            = const_cast<ULONG *>(columnmeta.Get_EndingNumber        ());
                cmRow.pCharacterSet            = const_cast<LPWSTR> (columnmeta.Get_CharacterSet        ());
                cmRow.pSchemaGeneratorFlags    = const_cast<ULONG *>(columnmeta.Get_SchemaGeneratorFlags());
                cmRow.pID                      = const_cast<ULONG *>(columnmeta.Get_ID                  ());
                cmRow.pUserType                = const_cast<ULONG *>(columnmeta.Get_UserType            ());
                cmRow.pAttributes              = const_cast<ULONG *>(columnmeta.Get_Attributes          ());
				cmRow.pDescription             = const_cast<LPWSTR> (columnmeta.Get_Description         ());
				cmRow.pPublicColumnName        = const_cast<LPWSTR> (columnmeta.Get_PublicColumnName    ());

                ULONG aColumnMetaSizes[cCOLUMNMETA_NumberOfColumns];
                memset(aColumnMetaSizes, 0x00, sizeof(ULONG) * cCOLUMNMETA_NumberOfColumns);
                if(cmRow.pDefaultValue)//If there is a default value, then we need to supply the size of the DefaultValue byte array.
                    aColumnMetaSizes[iCOLUMNMETA_DefaultValue] = fixup.BufferLengthFromIndex(columnmeta.Get_MetaTable().DefaultValue);

                CCatalogPropertyWriter * pPropertyWriter;
			    XIF(pCollectionWriter->GetPropertyWriter(&cmRow,
                                                         aColumnMetaSizes,
                                                         &pPropertyWriter));


                if(columnmeta.Get_ciTagMeta() > 0)
                {
                    TTagMeta tagmeta(fixup, columnmeta.Get_iTagMeta());
                    for(ULONG iTagMeta=0; iTagMeta<columnmeta.Get_ciTagMeta(); ++iTagMeta, tagmeta.Next())
                    {
                        /*
                        struct tTAGMETARow {
                                 WCHAR *     pTable;
                                 ULONG *     pColumnIndex;
                                 WCHAR *     pInternalName;
                                 WCHAR *     pPublicName;
                                 ULONG *     pValue;
                                 ULONG *     pID;
                        };*/
                        tTAGMETARow tagmetRow;
                        tagmetRow.pTable              = const_cast<LPWSTR> (tagmeta.Get_Table       ());
                        tagmetRow.pColumnIndex        = const_cast<ULONG *>(tagmeta.Get_ColumnIndex ());
                        tagmetRow.pInternalName       = const_cast<LPWSTR> (tagmeta.Get_InternalName());
                        tagmetRow.pPublicName         = const_cast<LPWSTR> (tagmeta.Get_PublicName  ());
                        tagmetRow.pValue              = const_cast<ULONG *>(tagmeta.Get_Value       ());
                        tagmetRow.pID                 = const_cast<ULONG *>(tagmeta.Get_ID          ());

    				    XIF(pPropertyWriter->AddFlagToProperty(&tagmetRow));
                    }//for(ULONG iTagMeta
                }//if(columnmeta.Get_ciTagMeta() > 0)
            }//for(ULONG iColumnMeta
        }//for(ULONG iTableMeta

	    XIF(spCSchemaWriter->WriteSchema());
	    XIF(writer.EndWrite(eWriter_Schema));
    }//dtor of CWrite closes the handle...now we can make a copy of it
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tmbschemageneration.h ===
// Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
// Filename:        TMBSchemaGeneration.h
// Author:          Stephenr
// Date Created:    10/9/2000
// Description:     This compilation plugin takes the metabase's meta and generates MBSchema.xml.
//

#pragma once

class TMBSchemaGeneration : public ICompilationPlugin
{
public:
    TMBSchemaGeneration(LPCWSTR i_wszSchemaXmlFile);

    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    LPCWSTR     m_wszSchemaXmlFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tindexmeta.h ===
#pragma once

/*
struct IndexMeta
{
    ULONG PRIMARYKEY    Table;                          //String
    ULONG PRIMARYKEY    InternalName;                   //String
    ULONG               PublicName;                     //String
    ULONG PRIMARYKEY    ColumnIndex;                    //UI4       This is the iOrder member of the ColumnMeta
    ULONG               ColumnInternalName;             //String
    ULONG               MetaFlags;                      //UI4       Index Flag
};
*/

class TIndexMeta : public TMetaTable<IndexMeta>
{
public:
    TIndexMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<IndexMeta>(fixup,i){}
    const WCHAR *Get_Table               ()  const {return m_Fixup.StringFromIndex(Get_MetaTable().Table);}
    const WCHAR *Get_InternalName        ()  const {return m_Fixup.StringFromIndex(Get_MetaTable().InternalName);}
    const WCHAR *Get_PublicName          ()  const {return m_Fixup.StringFromIndex(Get_MetaTable().PublicName);}
    const ULONG *Get_ColumnIndex         ()  const {return m_Fixup.UI4pFromIndex(  Get_MetaTable().ColumnIndex);}
    const WCHAR *Get_ColumnInternalName  ()  const {return m_Fixup.StringFromIndex(Get_MetaTable().ColumnInternalName);}
    const ULONG *Get_MetaFlags           ()  const {return m_Fixup.UI4pFromIndex(  Get_MetaTable().MetaFlags);}
    const ULONG  Get_iHashTable          ()  const {return Get_MetaTable().iHashTable;}

    virtual IndexMeta * Get_pMetaTable  ()       {return m_Fixup.IndexMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount      () const {return m_Fixup.GetCountIndexMeta();};
    const IndexMeta & Get_MetaTable () const {return *m_Fixup.IndexMetaFromIndex(m_iCurrent);}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\theap.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

//This is a heap that holds UI4s and bytes, it does NOT directly hold strings or GUIDs.  TPooledHeap takes care of pooling like strings and guids.
class TBaseHeap
{
public:
    TBaseHeap(ULONG cbInitialSize) :
         m_cbSizeOfHeap(0)
        ,m_iEndOfHeap(0)
        ,m_pHeap(0)
    {
        if(cbInitialSize>0)
            GrowHeap(cbInitialSize);
     }

    virtual ~TBaseHeap()
    {
        if(0 != m_pHeap)
        {
            ASSERT(m_cbSizeOfHeap>0);
            free(m_pHeap);
            m_pHeap = 0;
        }
    }

    virtual void    GrowHeap(ULONG cbAmountToGrow)
    {
        unsigned char * pTemp;

        pTemp = reinterpret_cast<unsigned char *>(realloc(m_pHeap, m_cbSizeOfHeap += (ULONG)RoundUpToNearestULONGBoundary(cbAmountToGrow)));

        if ( 0 == pTemp )
        {
            free( m_pHeap );
            m_pHeap = 0;
            THROW(OUT OF MEMORY);
        }
        else
        {
            m_pHeap = pTemp;
        }
    }

    ULONG                   GetEndOfHeap() const {return m_iEndOfHeap;}
    ULONG                   GetSizeOfHeap()     const {return m_cbSizeOfHeap;}
    const unsigned char *   GetHeapPointer()    const {return m_pHeap;}

protected:
    size_t          RoundUpToNearestULONGBoundary(size_t cb) const {return ((cb + 3) & -4);}
    unsigned char * m_pHeap;//Making this protected saves a bunch of const_casts

    ULONG           m_cbSizeOfHeap;
    ULONG           m_iEndOfHeap;//This is where new items get added.  Since items always reside on a ULONG boundary, this should always be divisible by 4 (sizeof(ULONG))

};

template <class T> class THeap : public TBaseHeap
{
public:
    THeap(const TBaseHeap &heap) : TBaseHeap(0){AddItemToHeap(heap);}
    THeap(ULONG cbInitialSize=0x10) : TBaseHeap(cbInitialSize){}

    operator T *()                        const {return reinterpret_cast<T *>(m_pHeap);}

    T *                     GetTypedPointer(ULONG i=0)     {ASSERT(0==i || i<GetCountOfTypedItems()); return (reinterpret_cast<T *>(m_pHeap))+i;}
    ULONG                   GetCountOfTypedItems()   const {return m_iEndOfHeap / sizeof(T);}

    ULONG   AddItemToHeap(const unsigned char *aBytes, unsigned long cb)
    {
        if(0 == aBytes || 0 == cb)
            return m_iEndOfHeap;
        ASSERT(m_cbSizeOfHeap >= m_iEndOfHeap);//they're both unsigned so if the ever fails we're in trouble.

        ULONG cbPaddedSize = (ULONG) RoundUpToNearestULONGBoundary(cb);

        //Check to see if it will fit into the heap
        if((m_cbSizeOfHeap - m_iEndOfHeap) < cbPaddedSize)
            GrowHeap(cb);//GrowHeap rounds up to nearest ULONG boundary for us

        //Get a pointer to the place where we're adding this data (which is located at the end of the heap).
        unsigned char * pData = m_pHeap + m_iEndOfHeap;
        if(cb != cbPaddedSize)//if the cb is not on ULONG boundary, we need to pad with zeros (the last ULONG is sufficient)
            *(reinterpret_cast<ULONG *>(pData + cbPaddedSize) - 1) = 0;
        memcpy(pData, aBytes, cb);
        m_iEndOfHeap += cbPaddedSize;

        return (ULONG)(pData - m_pHeap);//return the byte offset of the data from the beginning of the heap
    }

    ULONG   AddItemToHeap(const TBaseHeap &heap)
    {
        return AddItemToHeap(heap.GetHeapPointer(), heap.GetSizeOfHeap());
    }

    ULONG   AddItemToHeap(const T& t)
    {
        return AddItemToHeap(reinterpret_cast<const unsigned char *>(&t), sizeof(T));
    }
    ULONG   AddItemToHeap(const T *t, ULONG count)
    {
        return AddItemToHeap(reinterpret_cast<const unsigned char *>(t), sizeof(T)*count);
    }
};

//So heaps can be declared without the template syntax we create this specialized template.
//template <> class THeap<ULONG>
//{
//};


//This is a heap that holds strings, byte arrays, guids and any other non-UI4 types.  Items are added to the heap but not removed.
//Like items are pooled together. The second identical string added to the heap, will not result in the second string being
//appended to the end of the heap.  Instead it will return the index the the matching string previously added to the heap.  This
//applies to GUIDs and byte arrays as well.  One other thing, the 0th element is reserved to represent NULL.
class TPooledHeap : public THeap<ULONG>
{
public:
    ULONG   AddItemToHeap(const unsigned char *aBytes, unsigned long cb)
    {
        if(0 == aBytes || 0 == cb)//Are we adding NULL
            return 0;//The 0th index is reserved to represent NULL

        ULONG iHeapItem = FindMatchingHeapEntry(aBytes, cb);
        if(iHeapItem)//if a matching byte array was found, then return the index to the match
            return iHeapItem;

        THeap<ULONG>::AddItemToHeap(cb);//cbSize
        return THeap<ULONG>::AddItemToHeap(aBytes, cb);//return the byte offset of the data from the beginning of the heap
    }
    ULONG   AddItemToHeapWithoutPooling(const unsigned char *aBytes, unsigned long cb)
    {
        if(0 == aBytes || 0 == cb)//Are we adding NULL
            return 0;//The 0th index is reserved to represent NULL

        THeap<ULONG>::AddItemToHeap(cb);//cbSize
        return THeap<ULONG>::AddItemToHeap(aBytes, cb);//return the byte offset of the data from the beginning of the heap
    }

    ULONG   AddItemToHeap(const GUID * pguid)
    {
        return AddItemToHeap(reinterpret_cast<const unsigned char *>(pguid), sizeof(GUID));
    }

    ULONG   AddItemToHeap(const GUID &guid)
    {
        return AddItemToHeap(reinterpret_cast<const unsigned char *>(&guid), sizeof(GUID));
    }

    ULONG   AddItemToHeap(const TBaseHeap &heap)
    {
        //Another Heap is just stored as an array of bytes
        return AddItemToHeap(heap.GetHeapPointer(), heap.GetSizeOfHeap());
    }

    ULONG   AddItemToHeap(ULONG ul)
    {
        return AddItemToHeap(reinterpret_cast<const unsigned char *>(&ul), sizeof(ULONG));
    }

    ULONG   AddItemToHeap(LPCWSTR wsz, unsigned long cwchar=-1)
    {
        if(0==wsz || 0==cwchar)
            return 0;//The 0th index is reserved to represent NULL

        if(cwchar == -1)
            cwchar = (unsigned long)wcslen(wsz)+1;//add one for the terminating NULL
        return AddItemToHeap(reinterpret_cast<const unsigned char *>(wsz), cwchar*2);//convert cwchar to cbchar
    }

    ULONG FindMatchingHeapEntry(const WCHAR *wsz) const
    {
        if(0 == wsz)
            return 0;//0 is reserved to represent NULL
        return FindMatchingHeapEntry(reinterpret_cast<const unsigned char *>(wsz), (ULONG)(sizeof(WCHAR)*(wcslen(wsz)+1)));
    }

    ULONG FindMatchingHeapEntry(const unsigned char *aBytes, unsigned long cb) const
    {
        if(0 == aBytes || 0 == cb)
            return 0;//0 is reserved to represent NULL

        for(const HeapEntry *pHE = reinterpret_cast<const HeapEntry *>(GetHeapPointer()+m_iFirstPooledIndex); IsValidHeapEntry(pHE); pHE = pHE->Next())
        {
            if(pHE->cbSize == cb && 0 == memcmp(pHE->Value, aBytes, cb))
                return (ULONG)(reinterpret_cast<const unsigned char *>(pHE) - GetHeapPointer()) + sizeof(ULONG);//return the bytes offset (from m_pHeap) of the Value (not the HeapEntry)
        }
        //If we make it through the HeapEntries without finding a match then return 0 to indicate 'No Match'
        return 0;
    }
    void SetFirstPooledIndex(ULONG iFirstPooledIndex){m_iFirstPooledIndex = (iFirstPooledIndex>0x1000000) ? 0x1000000 : iFirstPooledIndex;}

    const unsigned char * BytePointerFromIndex(ULONG i)   const {ASSERT(i<GetEndOfHeap()); return ((0 == i || GetEndOfHeap() < i) ? 0 : reinterpret_cast<const unsigned char *>(GetHeapPointer() + i));}
    const GUID          * GuidPointerFromIndex(ULONG i)   const {return reinterpret_cast<const GUID *>(BytePointerFromIndex(i));}
    const WCHAR         * StringPointerFromIndex(ULONG i) const {return reinterpret_cast<const WCHAR *>(BytePointerFromIndex(i));}
    const ULONG         * UlongPointerFromIndex(ULONG i)  const {return reinterpret_cast<const ULONG *>(BytePointerFromIndex(i));}

    ULONG                 GetSizeOfItem(ULONG i)          const {return (0==i) ? 0 : UlongPointerFromIndex(i)[-1];}

    TPooledHeap(ULONG cbInitialSize=0x10) : THeap<ULONG>(cbInitialSize), m_iFirstPooledIndex(0)
    {
        THeap<ULONG>::AddItemToHeap(static_cast<ULONG>(0));
    }//This represents NULL
private:
    struct HeapEntry
    {
        ULONG cbSize;//Size in count of bytes.  Size is the Size of the Value array (NOT including the Size itself).  This is the ACTUAL size of the data (NOT rounded to the nearest ULONG)
        unsigned char Value[1];                                                                                   //cbSize is the actual size so we need to round up to locate the next HeapEntry
        const HeapEntry * Next() const {return reinterpret_cast<const HeapEntry *>(reinterpret_cast<const unsigned char *>(this) + ((cbSize + 3) & -4) + sizeof(ULONG));}//Add sizeof(ULONG) for the cbSize ULONG
    };
    ULONG m_iFirstPooledIndex;

    bool    IsValidHeapEntry(const HeapEntry *pHE) const {return (reinterpret_cast<const unsigned char *>(pHE) >= GetHeapPointer() && reinterpret_cast<const unsigned char *>(pHE) < (GetHeapPointer()+GetEndOfHeap()));}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tmetabasemetaxmlfile.cpp ===
// Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
// Filename:        TMetabaseMetaXmlFile.cpp
// Author:          Stephenr
// Date Created:    9/19/00
// Description:     This class builds the meta heaps from the MetabaseMeta.XML file and the shipped meta located in the Fixed Tables.
//                  The shipped meta is un alterable.  So if discrepencies appear between the MetabaseMeta.XML file and the shipped
//                  schema, the meta reverts back to what was 'shipped'.
//

#include "precomp.hxx"

#define THROW_ERROR0(x)                           {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, L"",  L"",  L"",  L"" ))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}
#define THROW_ERROR1(x, str1)                     {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, L"",  L"",  L"" ))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}
#define THROW_ERROR2(x, str1, str2)               {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, L"",  L"" ))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}
#define THROW_ERROR3(x, str1, str2, str3)         {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, str3, L"" ))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}
#define THROW_ERROR4(x, str1, str2, str3, str4)   {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, str3, str4))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}

#define LOG_ERROR1(x, str1)                       {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, L"",  L"",  L"" ))   ;}
#define LOG_ERROR2(x, str1, str2)                 {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, L"",  L"" ))   ;}
#define LOG_ERROR3(x, str1, str2, str3)           {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, str3, L"" ))   ;}
#define LOG_ERROR4(x, str1, str2, str3, str4)     {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, str3, str4))   ;}

#define LOG_WARNING1(x, str1)                     {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEWARNING, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, L"",  L"",  L"",  eSERVERWIRINGMETA_NoInterceptor, 0, eDETAILEDERRORS_Populate, (ULONG)-1, (ULONG)-1, m_wszXmlFile, eDETAILEDERRORS_WARNING));}
#define LOG_WARNING2(x, str1, str2)               {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEWARNING, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, L"",  L"",  eSERVERWIRINGMETA_NoInterceptor, 0, eDETAILEDERRORS_Populate, (ULONG)-1, (ULONG)-1, m_wszXmlFile, eDETAILEDERRORS_WARNING));}
#define LOG_WARNING3(x, str1, str2, str3)         {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEWARNING, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, str3, L"",  eSERVERWIRINGMETA_NoInterceptor, 0, eDETAILEDERRORS_Populate, (ULONG)-1, (ULONG)-1, m_wszXmlFile, eDETAILEDERRORS_WARNING));}
#define LOG_WARNING4(x, str1, str2, str3, str4)   {LOG_ERROR(Interceptor, (0, m_spISTAdvancedDispenser, E_ST_COMPILEWARNING, ID_CAT_CONFIG_SCHEMA_COMPILE, x, str1, str2, str3, str4, eSERVERWIRINGMETA_NoInterceptor, 0, eDETAILEDERRORS_Populate, (ULONG)-1, (ULONG)-1, m_wszXmlFile, eDETAILEDERRORS_WARNING));}

#define     IIS_SYNTAX_ID_DWORD         1
//  DWORD                                              EXTENDEDTYPE0   (| EXTENDEDTYPE0")
#define     IIS_SYNTAX_ID_STRING        2
//  STRING                               EXTENDEDTYPE1                 (| EXTENDEDTYPE1")
#define     IIS_SYNTAX_ID_EXPANDSZ      3
//  EXPANDSZ                             EXTENDEDTYPE1 EXTENDEDTYPE0   (| EXTENDEDTYPE0 | EXTENDEDTYPE1")
#define     IIS_SYNTAX_ID_MULTISZ       4
//  MULTISZ                EXTENDEDTYPE2                               (| EXTENDEDTYPE2")
#define     IIS_SYNTAX_ID_BINARY        5
//  BINARY                 EXTENDEDTYPE2               EXTENDEDTYPE0   (| EXTENDEDTYPE0 | EXTENDEDTYPE2")
#define     IIS_SYNTAX_ID_BOOL          6
//  DWORD                  EXTENDEDTYPE2 EXTENDEDTYPE1                 (| EXTENDEDTYPE1 | EXTENDEDTYPE2")
#define     IIS_SYNTAX_ID_BOOL_BITMASK  7
//  DWORD                  EXTENDEDTYPE2 EXTENDEDTYPE1 EXTENDEDTYPE0   (| EXTENDEDTYPE0 | EXTENDEDTYPE1 | EXTENDEDTYPE2")
#define     IIS_SYNTAX_ID_MIMEMAP       8
//  MULTISZ  EXTENDEDTYPE3                                             (| EXTENDEDTYPE3")
#define     IIS_SYNTAX_ID_IPSECLIST     9
//  MULTISZ  EXTENDEDTYPE3                             EXTENDEDTYPE0   (| EXTENDEDTYPE0 | EXTENDEDTYPE3")
#define     IIS_SYNTAX_ID_NTACL        10
//  BINARY   EXTENDEDTYPE3               EXTENDEDTYPE1                 (| EXTENDEDTYPE1 | EXTENDEDTYPE3")
#define     IIS_SYNTAX_ID_HTTPERRORS   11
//  MULTISZ  EXTENDEDTYPE3               EXTENDEDTYPE1 EXTENDEDTYPE0   (| EXTENDEDTYPE0 | EXTENDEDTYPE1 | EXTENDEDTYPE3")
#define     IIS_SYNTAX_ID_HTTPHEADERS  12
//  MULTISZ  EXTENDEDTYPE3 EXTENDEDTYPE2                               (| EXTENDEDTYPE2 | EXTENDEDTYPE3")

TOLEDataTypeToXMLDataType OLEDataTypeToXMLDataType[]=
{
//String,               MappedString,       bImplicitlyRequired,    dbType,             cbSize,                 fCOLUMNMETA,                                                                fCOLUMNSCHEMAGENERATOR
L"STRING",              L"string",          false,                  DBTYPE_WSTR,        (ULONG)-1,              0,                                                                          (IIS_SYNTAX_ID_STRING<<2),
L"Bool",                L"ui4",             false,                  DBTYPE_UI4,         sizeof(ULONG),          fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_BOOL | fCOLUMNMETA_CASEINSENSITIVE,   (IIS_SYNTAX_ID_BOOL<<2),
L"MULTISZ",             L"string",          false,                  DBTYPE_WSTR,        (ULONG)-1,              fCOLUMNMETA_MULTISTRING,                                                    (IIS_SYNTAX_ID_MULTISZ<<2),
L"BINARY",              L"bin.hex",         false,                  DBTYPE_BYTES,       (ULONG)-1,              0,                                                                          (IIS_SYNTAX_ID_BINARY<<2),
L"EXPANDSZ",            L"string",          false,                  DBTYPE_WSTR,        (ULONG)-1,              fCOLUMNMETA_EXPANDSTRING,                                                   (IIS_SYNTAX_ID_EXPANDSZ<<2),
L"IPSECLIST",           L"bin.hex",         false,                  DBTYPE_BYTES,       (ULONG)-1,              fCOLUMNMETA_MULTISTRING,                                                    (IIS_SYNTAX_ID_IPSECLIST<<2),
L"MIMEMAP",             L"string",          false,                  DBTYPE_WSTR,        (ULONG)-1,              fCOLUMNMETA_MULTISTRING,                                                    (IIS_SYNTAX_ID_MIMEMAP<<2),
L"NTACL",               L"bin.hex",         false,                  DBTYPE_BYTES,       (ULONG)-1,              0,                                                                          (IIS_SYNTAX_ID_NTACL<<2),
L"BOOL_BITMASK",        L"ui4",             false,                  DBTYPE_UI4,         sizeof(ULONG),          0,                                                                          (IIS_SYNTAX_ID_BOOL_BITMASK<<2),
L"HTTPERRORS",          L"string",          false,                  DBTYPE_WSTR,        (ULONG)-1,              fCOLUMNMETA_MULTISTRING,                                                    (IIS_SYNTAX_ID_HTTPERRORS<<2),
L"HTTPHEADERS",         L"string",          false,                  DBTYPE_WSTR,        (ULONG)-1,              fCOLUMNMETA_MULTISTRING,                                                    (IIS_SYNTAX_ID_HTTPHEADERS<<2),
L"GUID",                L"uuid",            false,                  DBTYPE_GUID,        sizeof(GUID),           fCOLUMNMETA_FIXEDLENGTH,                                                    0,
L"WSTR",                L"string",          false,                  DBTYPE_WSTR,        (ULONG)-1,              0,                                                                          (IIS_SYNTAX_ID_STRING<<2),
L"UI4",                 L"ui4",             false,                  DBTYPE_UI4,         sizeof(ULONG),          fCOLUMNMETA_FIXEDLENGTH,                                                    (IIS_SYNTAX_ID_DWORD<<2),
L"BYTES",               L"bin.hex",         false,                  DBTYPE_BYTES,       (ULONG)-1,              0,                                                                          (IIS_SYNTAX_ID_BINARY<<2),
L"Boolean",             L"ui4",             false,                  DBTYPE_UI4,         sizeof(ULONG),          fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_BOOL | fCOLUMNMETA_CASEINSENSITIVE,   (IIS_SYNTAX_ID_BOOL<<2),
L"Enum",                L"ui4",             false,                  DBTYPE_UI4,         sizeof(ULONG),          fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_ENUM,                                 (IIS_SYNTAX_ID_DWORD<<2),
L"Flag",                L"ui4",             false,                  DBTYPE_UI4,         sizeof(ULONG),          fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_FLAG,                                 (IIS_SYNTAX_ID_DWORD<<2),
L"String",              L"string",          false,                  DBTYPE_WSTR,        (ULONG)-1,              0,                                                                          (IIS_SYNTAX_ID_STRING<<2),
L"int32",               L"ui4",             false,                  DBTYPE_UI4,         sizeof(ULONG),          fCOLUMNMETA_FIXEDLENGTH,                                                    (IIS_SYNTAX_ID_DWORD<<2),
L"Byte[]",              L"bin.hex",         false,                  DBTYPE_BYTES,       (ULONG)-1,              0,                                                                          (IIS_SYNTAX_ID_BINARY<<2),
L"DWORD",               L"ui4",             false,                  DBTYPE_UI4,         sizeof(ULONG),          fCOLUMNMETA_FIXEDLENGTH,                                                    (IIS_SYNTAX_ID_DWORD<<2),
L"XMLBLOB",             L"string",          false,                  DBTYPE_WSTR,        (ULONG)-1,              0,                                                                          (IIS_SYNTAX_ID_STRING<<2) | fCOLUMNMETA_XMLBLOB,
L"StrictBool",          L"ui4",             false,                  DBTYPE_UI4,         sizeof(ULONG),          fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_BOOL,                                 (IIS_SYNTAX_ID_BOOL<<2),
L"DBTIMESTAMP",         L"notsupported",    false,                  DBTYPE_DBTIMESTAMP, sizeof(DBTIMESTAMP),    fCOLUMNMETA_FIXEDLENGTH,											        0,
0,                      0,                  false,                  0,                  0,                      0,                                                                          0
};
/*  These aren't supported at this time
L"I4",             L"i4",           true,
L"I2",             L"i2",           true,
L"R4",             L"r4",           true,
L"R8",             L"r8",           true,
L"CY",             L"int",          true,
L"DATE",           L"date",         true,
L"BSTR",           L"string",       true,
L"ERROR",          L"ui4",          true,
L"BOOL",           L"boolean",      true,
L"DECIMAL",        L"float",        true,
L"UI1",            L"ui1",          true,
L"ARRAY",          L"bin.hex",      true,
L"I1",             L"i1",           true,
L"UI2",            L"ui2",          true,
L"I8",             L"i8",           true,
L"UI8",            L"ui8",          true,
L"STR",            L"string",       false,
L"NUMERIC",        L"int",          true,
L"DBDATE",         L"date",         true,
L"DBTIME",         L"time",         true,
L"DBTIMESTAMP",    L"dateTime",     true
};
*/
int numelementsOLEDataTypeToXMLDataType = (sizeof(OLEDataTypeToXMLDataType) / sizeof(OLEDataTypeToXMLDataType[0]))-1;

//We do everything we need with XmlFile in the ctor so we don't keep it around
TMetabaseMetaXmlFile::TMetabaseMetaXmlFile(const FixedTableHeap *pShippedSchemaHeap, LPCWSTR wszXmlFile, ISimpleTableDispenser2 *pISTDispenser, TOutput &out) :
     m_Attributes               (kszAttributes)
    ,m_BaseVersion              (kszBaseVersion)
    ,m_CharacterSet             (kszCharacterSet)
    ,m_Collection               (kszTableMeta)
    ,m_ContainerClassList       (kszContainerClassList)
    ,m_DatabaseMeta             (kszDatabaseMeta)
    ,m_DefaultValue             (kszDefaultValue)
	,m_Description				(kszDescription)
    ,m_EndingNumber             (kszMaximumValue)
    ,m_Enum                     (kszEnumMeta)
    ,m_ExtendedVersion          (kszExtendedVersion)
    ,m_Flag                     (kszFlagMeta)
    ,m_ID                       (kszID)
    ,m_IIsConfigObject          (wszTABLE_IIsConfigObject)
    ,m_InheritsPropertiesFrom   (kszInheritsColumnMeta)
    ,m_InternalName             (kszInternalName)
    ,m_Meta                     (wszDATABASE_META)
    ,m_Metabase                 (wszDATABASE_METABASE)
    ,m_MetabaseBaseClass        (wszTABLE_MetabaseBaseClass)
    ,m_MetaFlags                (kszColumnMetaFlags)
    ,m_NameColumn               (kszNameColumn)
    ,m_NavColumn                (kszNavColumn)
    ,m_Property                 (kszColumnMeta)
    ,m_PublicName               (kszPublicName)
	,m_PublicColumnName			(kszPublicColumnName)
    ,m_PublicRowName            (kszPublicRowName)
    ,m_SchemaGeneratorFlags     (kszSchemaGenFlags)
    ,m_Size                     (kszcbSize)
    ,m_StartingNumber           (kszMinimumValue)
    ,m_Type                     (kszdbType)
    ,m_UserType                 (kszUserType)
    ,m_Value                    (kszValue)

    //m_aiUI4 initialized in PresizeHeaps
    ,m_iColumnMeta_Location         (0)
    ,m_iCurrentColumnIndex          (0)
    ,m_iCurrentDatabaseName         (0)
    ,m_iCurrentTableName            (0)
    ,m_iCurrentTableMeta            (0)
    ,m_ipoolPrevUserDefinedID       (0)
    ,m_iTableName_IIsConfigObject   (0)
    ,m_iLastShippedCollection       (0)
    ,m_iLastShippedProperty         (0)
    ,m_iLastShippedTag              (0)
    ,m_LargestID                    (kLargestReservedID)
    ,m_NextColumnIndex              (0)
    ,m_out                          (out)
    ,m_pShippedSchemaHeap           (pShippedSchemaHeap)
    ,m_State                        (eLookingForTheMetabaseDatabase)
    ,m_spISTAdvancedDispenser       (pISTDispenser)
    ,m_wszXmlFile                   (wszXmlFile)
{
    ASSERT(0 != pShippedSchemaHeap);
    ASSERT(0 != pISTDispenser);

    m_out.printf(L"\r\n\r\n----------------------Metabase Compilation Starting----------------------\r\n\r\n");

    PresizeHeaps();//This minimizes reallocs

    const DatabaseMeta *pDatabaseMeta_METABASE=0;
    BuildDatabaseMeta(pDatabaseMeta_METABASE);//This scans the shipped databases and adds the "Meta" & "Metabase" databases to the DatabaseHeap

    //Put the Meta tables into the heap
    const TableMeta *pTableMeta = m_pShippedSchemaHeap->Get_aTableMeta(0);
    for(ULONG iTableMeta=0; iTableMeta<m_pShippedSchemaHeap->Get_cTableMeta(); ++iTableMeta, ++pTableMeta)
        if(m_Meta.IsEqual(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pTableMeta->Database))))
            AddShippedTableMetaToHeap(pTableMeta, true);
        else
            break;

    //From the FixedTableHeap, Locate the first TableMeta for the metabase (DatabaseMeta::iTableMeta)
    const TableMeta * pTableMetaCurrent = m_pShippedSchemaHeap->Get_aTableMeta(pDatabaseMeta_METABASE->iTableMeta);
    ASSERT(0 != pTableMetaCurrent);
    //Verify that the first table is the 'MetabaseBaseClass' table.
    if(0 != _wcsicmp(wszTABLE_MetabaseBaseClass, reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pTableMetaCurrent->InternalName))))
    {
        LOG_ERROR(Interceptor, (reinterpret_cast<ISimpleTableWrite2 **>(0), m_spISTAdvancedDispenser, E_ST_COMPILEFAILED, ID_CAT_CONFIG_SCHEMA_COMPILE,
            IDS_COMCAT_CLASS_NOT_FOUND_IN_META, wszTABLE_MetabaseBaseClass, L"", L"", L""));
        THROW_ERROR1(IDS_COMCAT_CLASS_NOT_FOUND_IN_META, wszTABLE_MetabaseBaseClass);
    }

    //Add MetabaseBaseClass to the TableMeta heap
    //Add its column(s) to the ColumnMeta heap
    AddShippedTableMetaToHeap(pTableMetaCurrent);//This in turn calls AddColumnMetaToHeap for each column
    m_iColumnMeta_Location = m_iLastShippedProperty;

    //Verify that the next table is the 'IIsConfigObject' table.
    ++pTableMetaCurrent;
    if(0 != _wcsicmp(wszTABLE_IIsConfigObject, reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pTableMetaCurrent->InternalName))))
    {
        THROW_ERROR1(IDS_COMCAT_CLASS_NOT_FOUND_IN_META, wszTABLE_IIsConfigObject);
    }
    m_iTableName_IIsConfigObject = AddWCharToList(wszTABLE_IIsConfigObject);
    //Add it to the TableMeta heap
    //Add its column(s) to the ColumnMeta heap
    AddShippedTableMetaToHeap(pTableMetaCurrent);//This in turn calls AddColumnMetaToHeap for each column, which calls AddTagMetaToHeap for each tag.

    ULONG iIISConfigObjectTable = m_iLastShippedCollection;

    //Now we're ready to merge the contents of the XML file with the shipped schema
    //so we need to do some setup

    //Get TagMeta table
    if(FAILED(pISTDispenser->GetTable( wszDATABASE_META, wszTABLE_TAGMETA, 0, 0, eST_QUERYFORMAT_CELLS, fST_LOS_NONE, reinterpret_cast<LPVOID *>(&m_spISTTagMeta))))
    {
        THROW_ERROR1(IDS_COMCAT_ERROR_GETTTING_SHIPPED_SCHEMA, wszTABLE_TAGMETA);
    }

    //Get ColumnMeta table Indexed 'ByName'
    STQueryCell             acellsMeta[2];
    acellsMeta[0].pData        = COLUMNMETA_ByName;
    acellsMeta[0].eOperator    = eST_OP_EQUAL;
    acellsMeta[0].iCell        = iST_CELL_INDEXHINT;
    acellsMeta[0].dbType       = DBTYPE_WSTR;
    acellsMeta[0].cbSize       = 0;

    ULONG one=1;
    if(FAILED(pISTDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, acellsMeta, &one, eST_QUERYFORMAT_CELLS, fST_LOS_NONE, reinterpret_cast<void **>(&m_spISTColumnMeta))))
    {
        THROW_ERROR1(IDS_COMCAT_ERROR_GETTTING_SHIPPED_SCHEMA, wszTABLE_COLUMNMETA);
    }

    //Get ColumnMeta table Indexed 'ByID'
    acellsMeta[0].pData        = COLUMNMETA_ByID;
    if(FAILED(pISTDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, acellsMeta, &one, eST_QUERYFORMAT_CELLS, fST_LOS_NONE, reinterpret_cast<void **>(&m_spISTColumnMetaByID))))
    {
        THROW_ERROR1(IDS_COMCAT_ERROR_GETTTING_SHIPPED_SCHEMA, wszTABLE_COLUMNMETA);
    }


    //Get TableMeta table - Database 'Metabase'
    acellsMeta[0].pData        = wszDATABASE_METABASE;
    acellsMeta[0].eOperator    = eST_OP_EQUAL;
    acellsMeta[0].iCell        = iTABLEMETA_Database;
    acellsMeta[0].dbType       = DBTYPE_WSTR;
    acellsMeta[0].cbSize       = 0;

    if(FAILED(pISTDispenser->GetTable (wszDATABASE_META, wszTABLE_TABLEMETA, acellsMeta, &one, eST_QUERYFORMAT_CELLS, fST_LOS_NONE, reinterpret_cast<void **>(&m_spISTTableMeta))))
    {
        THROW_ERROR1(IDS_COMCAT_ERROR_GETTTING_SHIPPED_SCHEMA, wszTABLE_TABLEMETA);
    }

    //Allocate aBool[Database::CountOfTables] to indicate which of the Tables we listed in the XML file
    ULONG cTableMetaRows;
    VERIFY(SUCCEEDED(m_spISTTableMeta->GetTableMeta( 0, 0, &cTableMetaRows, 0)));
    ASSERT(cTableMetaRows > 50);//I know there are more that 50 classes, let's just verify that.
    if(0 == (m_aBoolShippedTables = new bool [cTableMetaRows]))
    {
        THROW_ERROR0(IDS_SCHEMA_COMPILATION_OUTOFMEMORY);
    }

    //Initialize each element to false
    for(ULONG iRow=0;iRow < cTableMetaRows; ++iRow)
        m_aBoolShippedTables[iRow] = false;

    //Parse the XML file
    if(0 != wszXmlFile)//we tolerate NULL here.  In that case we're just generating a Bin file with the shipped schema
    {
        TXmlParsedFile_NoCache xmlParsedFile;
        if(FAILED(xmlParsedFile.Parse(*this, wszXmlFile)))
        {
            //@@@ Parse using DOM to report the error
            THROW(ERROR PARSING XML FILE);
        }
    }

    //The ExtendedVersion contains the LargestID withing the IIsConfigObject table
    TableMetaFromIndex(iIISConfigObjectTable)->ExtendedVersion = AddUI4ToList(m_LargestID);

    //At this point we have all of the Collections defined within the XML
    //Now we need to make sure that none of the shipped collections we delete
    //Walk the m_aBoolShippedTables looking for any 'false' values (starting at row 2 - row 0 is MetabaseBaseClass, row 1 is IIsConfigObject)
    for(iRow=2; iRow<cTableMetaRows-2; ++iRow)//The last two tables are MBProperty and MBPropertyDiff.  We always add these from the shipped schema PLUS! extra group tags (see below)
    {
        if(!m_aBoolShippedTables[iRow])
        {
            ULONG   iTableMetaInternalName = iTABLEMETA_InternalName;
            LPWSTR wszTableName;
            VERIFY(SUCCEEDED(m_spISTTableMeta->GetColumnValues(iRow, 1, &iTableMetaInternalName, 0, reinterpret_cast<LPVOID *>(&wszTableName))));
            ULONG iRowTableMeta = m_pShippedSchemaHeap->FindTableMetaRow(wszTableName);
            ASSERT(iRowTableMeta != -1);
            //Add it from the ShippedSchemaHeap to the TableMeta heap
            AddShippedTableMetaToHeap(m_pShippedSchemaHeap->Get_aTableMeta(iRowTableMeta));//This adds all shipped columns and tags too
        }
    }

    {//MBProperty
        ULONG   iTableMetaInternalName = iTABLEMETA_InternalName;
        LPWSTR  wszTableName;
        VERIFY(SUCCEEDED(m_spISTTableMeta->GetColumnValues(iRow++, 1, &iTableMetaInternalName, 0, reinterpret_cast<LPVOID *>(&wszTableName))));
        ASSERT(0 == _wcsicmp(wszTableName, wszTABLE_MBProperty));
        ULONG iRowTableMeta = m_pShippedSchemaHeap->FindTableMetaRow(wszTableName);
        ASSERT(iRowTableMeta != -1);
        //Add it from the ShippedSchemaHeap to the TableMeta heap
        AddShippedTableMetaToHeap(m_pShippedSchemaHeap->Get_aTableMeta(iRowTableMeta));//This adds all shipped columns and tags too

        //We have strategically chosen the last column in this table to be the Group column.  This is because we need to add the Tag enums
        //for those User defined collections.
        ULONG iMBProperyTableName       = TagMetaFromIndex(GetCountTagMeta()-1)->Table;
        ULONG iMBProperyGroupColumnIndex= TagMetaFromIndex(GetCountTagMeta()-1)->ColumnIndex;

        ASSERT(0 == wcscmp(StringFromIndex(iMBProperyTableName), wszTABLE_MBProperty));

        //Walk the Tables (after IISConfigObject and not including MBProperty)
        for(ULONG iTableMeta=iIISConfigObjectTable; iTableMeta<GetCountTableMeta()-2; ++iTableMeta)//minus 2 because we don't care about the last table MBProperty
        {
            //Is this table one of the shipped collections?
            ULONG   iRow;
            LPVOID  apvValues[1];
            apvValues[0] = reinterpret_cast<LPVOID>(const_cast<LPWSTR>(StringFromIndex(TableMetaFromIndex(iTableMeta)->InternalName)));

            //Look for the Table in the shipped schema
            if(FAILED(m_spISTTableMeta->GetRowIndexByIdentity(0, apvValues, &iRow)))
            {
                TagMeta tagmeta;
                tagmeta.Table           = iMBProperyTableName;
                tagmeta.ColumnIndex     = iMBProperyGroupColumnIndex;
                tagmeta.InternalName    = TableMetaFromIndex(iTableMeta)->InternalName;
                tagmeta.PublicName      = TableMetaFromIndex(iTableMeta)->PublicName;
                tagmeta.Value           = AddUI4ToList(UI4FromIndex(TagMetaFromIndex(GetCountTagMeta()-1)->Value)+1);//increment the previous enum
                tagmeta.ID              = AddUI4ToList(0);

                AddTagMetaToList(&tagmeta);
            }
        }
    }
    {//MBPropertyDiff
        ULONG   iTableMetaInternalName = iTABLEMETA_InternalName;
        LPWSTR  wszTableName;
        VERIFY(SUCCEEDED(m_spISTTableMeta->GetColumnValues(iRow++, 1, &iTableMetaInternalName, 0, reinterpret_cast<LPVOID *>(&wszTableName))));
        ASSERT(0 == _wcsicmp(wszTableName, wszTABLE_MBPropertyDiff));
        ULONG iRowTableMeta = m_pShippedSchemaHeap->FindTableMetaRow(wszTableName);
        ASSERT(iRowTableMeta != -1);
        //Add it from the ShippedSchemaHeap to the TableMeta heap
        AddShippedTableMetaToHeap(m_pShippedSchemaHeap->Get_aTableMeta(iRowTableMeta));//This adds all shipped columns and tags too

        //We have strategically chosen the last column in this table to be the Group column.  This is because we need to add the Tag enums
        //for those User defined collections.
        ULONG iMBProperyTableName       = TagMetaFromIndex(GetCountTagMeta()-1)->Table;
        ULONG iMBProperyGroupColumnIndex= TagMetaFromIndex(GetCountTagMeta()-1)->ColumnIndex;

        ASSERT(0 == wcscmp(StringFromIndex(iMBProperyTableName), wszTABLE_MBPropertyDiff));

        //Walk the Tables (after IISConfigObject and not including MBProperty)
        for(ULONG iTableMeta=iIISConfigObjectTable; iTableMeta<GetCountTableMeta()-3; ++iTableMeta)//minus 2 because we don't care about the last two tables MBProperty & MBPropertyDiff
        {
            //Is this table one of the shipped collections?
            ULONG   iRow;
            LPVOID  apvValues[1];
            apvValues[0] = reinterpret_cast<LPVOID>(const_cast<LPWSTR>(StringFromIndex(TableMetaFromIndex(iTableMeta)->InternalName)));

            //Look for the Table in the shipped schema
            if(FAILED(m_spISTTableMeta->GetRowIndexByIdentity(0, apvValues, &iRow)))
            {
                TagMeta tagmeta;
                tagmeta.Table           = iMBProperyTableName;
                tagmeta.ColumnIndex     = iMBProperyGroupColumnIndex;
                tagmeta.InternalName    = TableMetaFromIndex(iTableMeta)->InternalName;
                tagmeta.PublicName      = TableMetaFromIndex(iTableMeta)->PublicName;
                tagmeta.Value           = AddUI4ToList(UI4FromIndex(TagMetaFromIndex(GetCountTagMeta()-1)->Value)+1);//increment the previous enum
                tagmeta.ID              = AddUI4ToList(0);

                AddTagMetaToList(&tagmeta);
            }
        }
    }
//    out.printf(L"Size of m_HeapColumnMeta       %d bytes\n", m_HeapColumnMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapDatabaseMeta     %d bytes\n", m_HeapDatabaseMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapHashedIndex      %d bytes\n", m_HeapHashedIndex.GetEndOfHeap());
//    out.printf(L"Size of m_HeapIndexMeta        %d bytes\n", m_HeapIndexMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapQueryMeta        %d bytes\n", m_HeapQueryMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapRelationMeta     %d bytes\n", m_HeapRelationMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapServerWiringMeta %d bytes\n", m_HeapServerWiringMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapTableMeta        %d bytes\n", m_HeapTableMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapTagMeta          %d bytes\n", m_HeapTagMeta.GetEndOfHeap());
//    out.printf(L"Size of m_HeapULONG            %d bytes\n", m_HeapULONG.GetEndOfHeap());
//    out.printf(L"Size of m_HeapPooled           %d bytes\n", m_HeapPooled.GetEndOfHeap());
}



//TXmlParsedFileNodeFactory members
HRESULT TMetabaseMetaXmlFile::CreateNode(const TElement &Element)
{
    if(XML_ELEMENT != Element.m_ElementType)//Ignore non Element nodes
        return S_OK;
    if(Element.m_NodeFlags & fEndTag)//Ignore EndTags
        return S_OK;

    HRESULT hr = S_OK;

    switch(m_State)
    {
    case eLookingForTheMetabaseDatabase:
        //From the XML file, walk the elements looking for the Metabase Database
        if(eDatabaseMetaLevel != Element.m_LevelOfElement)
            break;
        if(!m_DatabaseMeta.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))//If it's not a Property element, then ignore it - may be a comment, could be querymeta or indexmeta, neither of which we care about
            break;

        if(GetAttribute(Element, m_InternalName).Value().IsEqual(m_Metabase))//If the InternalName is 'Metabase'
        {
            m_State = eLookingForTheIIsConfigObjectTable;
        }
        break;
    case eLookingForTheIIsConfigObjectTable:
        //From there walk the elements looking for the IIsConfigObject Collection element (ignoring everything before it)
        if(eDatabaseMetaLevel == Element.m_LevelOfElement)
        {
            m_out.printf(L"Error - Found Level 1 element when expecting IIsConfigObjectTable\r\n");
            return E_SDTXML_LOGICAL_ERROR_IN_XML;//returning E_SDTXML_LOGICAL_ERROR_IN_XML will cause us to just use the shipped schema
        }

        if(eCollectionLevel != Element.m_LevelOfElement)
            break;
        if(!m_Collection.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))
            break;

        if(!GetAttribute(Element, m_InternalName).Value().IsEqual(m_MetabaseBaseClass))//If the InternalName is 'IIsConfigObject'
        {
            m_State = eLookingForGlobalProperties;
            hr = CreateNode(Element);
        }
        break;
    case eLookingForGlobalProperties:
        switch(Element.m_LevelOfElement)
        {
        case eDatabaseMetaLevel://1
            m_out.printf(L"Error - Found Level 1 element when expecting GlobalProperties\r\n");
            return E_SDTXML_LOGICAL_ERROR_IN_XML;//returning E_SDTXML_LOGICAL_ERROR_IN_XML will cause us to just use the shipped schema
        case eCollectionLevel://2
            {
                if(!m_Collection.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))//If it's not a Collection element, then ignore it - may be a comment
                    break;

                if(GetAttribute(Element, m_InternalName).Value().IsEqual(m_IIsConfigObject))//If the InternalName is 'IIsConfigObject'
                    break;//Then this table has already been added, continue looking for global properties.


                //when we get here, we're done with global properties; and we're ready for the classes (with their inherited properties).
                m_State = eLookingForCollectionOrInheritedProperties;
                //This recursive call prevents us from having duplicate code here AND at 'case eLookingForCollectionOrInheritedProperties:'
                //This sould only happen once (at the first level 2 element following IIsConfigObject)
                hr = CreateNode(Element);
            }
            break;
        case eProperytLevel://3
            {
                if(!m_Property.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))//If it's not a Property element, then ignore it - may be a comment, could be querymeta or indexmeta, neither of which we care about
                    break;

                ULONG iColumnInternalName = AddStringToHeap(GetAttribute(Element, m_InternalName).Value());

                if(ShouldAddColumnMetaToHeap(Element, iColumnInternalName))
                {   //If we failed to get the Row by Search then it's not in the shipped schema
                    AddColumnMetaToHeap(Element, iColumnInternalName);
                }
                else
                {
                    m_iCurrentColumnIndex = 0;//This indicate that we should ignore TagMeta children
                }
            }
            break;
        case eTagLevel://4
            {
                bool bFlag;

                bFlag = m_Flag.IsEqual(Element.m_ElementName, Element.m_ElementNameLength);
                if(!bFlag && !m_Enum.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))
                    break;
                if(0 == m_iCurrentColumnIndex)
                    break;//We got a TagMeta without a ColumnMeta
                //If this is the first flag we've seen for this column we need to OR in the fCOLUMNMETA_FLAG MetaFlag on the last column in the list
                //so just do it everytime we see a tag
                ColumnMeta *pColumnMeta = ColumnMetaFromIndex(GetCountColumnMeta()-1);
                pColumnMeta->MetaFlags = AddUI4ToList(UI4FromIndex(pColumnMeta->MetaFlags) | (bFlag ? fCOLUMNMETA_FLAG : fCOLUMNMETA_ENUM));

                AddTagMetaToHeap(Element);
            }
            break;
        default:
            break;
        }
        break;
    case eLookingForCollectionOrInheritedProperties:
        switch(Element.m_LevelOfElement)
        {
        case eDatabaseMetaLevel://1
            return E_SDTXML_DONE;
        case eCollectionLevel://2
            {
                if(!m_Collection.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))//If it's not a Collection element, then ignore it - may be a comment
                    break;

                //We need a NULL terminate string for the TableInternalName so add it to the list
                m_iCurrentTableName = AddStringToHeap(GetAttribute(Element, m_InternalName).Value());

                //Look up the collection in the Fixed interceptor
                ULONG   iRow;
                LPVOID  apvValues[1];
                apvValues[0] = reinterpret_cast<LPVOID>(const_cast<LPWSTR>(StringFromIndex(m_iCurrentTableName)));

                //Look for the Table in the shipped schema
                if(FAILED(m_spISTTableMeta->GetRowIndexByIdentity(0, apvValues, &iRow)))
                {//if the table is NOT one of the shipped collections then add it
                    AddTableMetaToHeap(Element);
                    //We now look for the properties
                }
                else
                {
                    //Keep track of which shipped tables we've seen (this way we can add back in any shipped collections that are removed from the XML file).
                    m_aBoolShippedTables[iRow] = true;
                    ULONG iRowTableMeta = m_pShippedSchemaHeap->FindTableMetaRow(StringFromIndex(m_iCurrentTableName));
                    ASSERT(iRowTableMeta != -1);
                    //Add it from the ShippedSchemaHeap to the TableMeta heap
                    AddShippedTableMetaToHeap(m_pShippedSchemaHeap->Get_aTableMeta(iRowTableMeta), false, &GetAttribute(Element, m_ContainerClassList).Value());//This adds all shipped columns and tags too
                    //@@@ ToDo:  Do we support user modifications to tha TableMeta (like adding classes to the ContainerClassList)?  If so we do that here.
                    //Now we need to look for User-defined properties (and tags) for this collection
                }
            }
            break;
        case eProperytLevel://3
            {
                if(!m_Property.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))//If it's not a Property element, then ignore it - may be a comment, could be querymeta or indexmeta, neither of which we care about
                    break;

                AddColumnMetaViaReferenceToHeap(Element);
            }
            break;
        case eTagLevel:
            {
                m_out.printf(L"Tag found under inherited property.  Tags are being ignored\r\n");
            }
            break;
        default:
            break;
        }
        break;
    default:
        ASSERT(false);
    }
    return hr;
}

//private member functions
void TMetabaseMetaXmlFile::AddColumnMetaByReference(ULONG iColumnMeta_Source)
{
    ColumnMeta * pColumnMeta = ColumnMetaFromIndex(iColumnMeta_Source);

    m_iCurrentColumnIndex = AddUI4ToList(m_NextColumnIndex);//Don't increment m_NextColumnIndex until this column is actually added

    if(UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_DIRECTIVE)
    {
        THROW_ERROR1(IDS_COMCAT_ERROR_IN_DIRECTIVE_INHERITANCE, StringFromIndex(pColumnMeta->InternalName));
    }

    //If the column is a Flag of Enum we need to add TagMeta
    if(UI4FromIndex(pColumnMeta->MetaFlags) & (fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM))
    {
        ULONG iTagMeta = FindTagBy_Table_And_Index(pColumnMeta->Table, pColumnMeta->Index);
        ASSERT(-1 != iTagMeta);
        if(-1 == iTagMeta)
        {
            THROW_ERROR2(IDS_COMCAT_INHERITED_FLAG_OR_ENUM_HAS_NO_TAGS_DEFINED, StringFromIndex(pColumnMeta->Table), StringFromIndex(pColumnMeta->InternalName));
        }

        for( ;iTagMeta<GetCountTagMeta() && TagMetaFromIndex(iTagMeta)->Table==pColumnMeta->Table && TagMetaFromIndex(iTagMeta)->ColumnIndex==pColumnMeta->Index ;++iTagMeta)
        {
            TagMeta *pTagMeta = TagMetaFromIndex(iTagMeta);

            TagMeta tagmeta;
            tagmeta.Table           = m_iCurrentTableName       ;
            tagmeta.ColumnIndex     = m_iCurrentColumnIndex     ;
            tagmeta.InternalName    = pTagMeta->InternalName    ;
            tagmeta.PublicName      = pTagMeta->PublicName      ;
            tagmeta.Value           = pTagMeta->Value           ;
            tagmeta.ID              = pTagMeta->ID              ;

            AddTagMetaToList(&tagmeta);
        }
    }

    ColumnMeta columnmeta;
    memset(&columnmeta, 0x00, sizeof(ColumnMeta));
    columnmeta.Table                = m_iCurrentTableName                   ;//Index into Pool
    columnmeta.Index                = m_iCurrentColumnIndex                 ;//Column Index
    columnmeta.InternalName         = pColumnMeta->InternalName             ;//Index into Pool
    columnmeta.PublicName           = pColumnMeta->PublicName               ;//Index into Pool
    columnmeta.Type                 = pColumnMeta->Type                     ;//These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
    columnmeta.Size                 = pColumnMeta->Size                     ;//
    columnmeta.MetaFlags            = pColumnMeta->MetaFlags                ;//ColumnMetaFlags defined in CatMeta.xml
    columnmeta.DefaultValue         = pColumnMeta->DefaultValue             ;//Only valid for UI4s
    columnmeta.FlagMask             = pColumnMeta->FlagMask                 ;//Only valid for flags
    columnmeta.StartingNumber       = pColumnMeta->StartingNumber           ;//Only valid for UI4s
    columnmeta.EndingNumber         = pColumnMeta->EndingNumber             ;//Only valid for UI4s
    columnmeta.CharacterSet         = pColumnMeta->CharacterSet             ;//Index into Pool - Only valid for WSTRs

    //Columns added here may be shipped properties; but we OR in the USERDEFINED flag to indicate that this property is NOT part of the shipped schema for THIS table.
    columnmeta.SchemaGeneratorFlags = AddUI4ToList(fCOLUMNMETA_USERDEFINED | fCOLUMNMETA_PROPERTYISINHERITED | (pColumnMeta->SchemaGeneratorFlags ? UI4FromIndex(pColumnMeta->SchemaGeneratorFlags) : 0));//ColumnMetaFlags defined in CatMeta.xml
    columnmeta.ID                   = pColumnMeta->ID                       ;
    columnmeta.UserType             = pColumnMeta->UserType                 ;
    columnmeta.Attributes           = pColumnMeta->Attributes               ;
	columnmeta.Description			= pColumnMeta->Description				;
	columnmeta.PublicColumnName     = pColumnMeta->PublicColumnName         ;
    //columnmeta.ciTagMeta            = 0                                     ;//Count of Tags - Only valid for UI4s
    //columnmeta.iTagMeta             = 0                                     ;//Index into TagMeta - Only valid for UI4s
    //columnmeta.iIndexName           = 0                                     ;//IndexName of a single column index (for this column)

    AddColumnMetaToList(&columnmeta);
    ++m_NextColumnIndex;
}


void TMetabaseMetaXmlFile::AddColumnMetaToHeap(const TElement &i_Element, ULONG i_iColumnInternalName)
{
    //<Property InternalName ="KeyType" ID="1002" Type="STRING" MetaFlags="PRIMARYKEY" UserType="IIS_MD_UT_SERVER" Attributes="INHERIT"/>
    ColumnMeta columnmeta;
    memset(&columnmeta, 0x00, sizeof(ColumnMeta));
    columnmeta.Table                = m_iCurrentTableName;
    columnmeta.Index                = AddUI4ToList(m_NextColumnIndex);//Don't increment m_NextColumnIndex until this column is actually added
    columnmeta.InternalName         = i_iColumnInternalName;

    if(~0x00 != FindUserDefinedPropertyBy_Table_And_InternalName(m_iCurrentTableName, i_iColumnInternalName))
        return;//No need to proceed, this property is already in the global property list

    m_iCurrentColumnIndex           = columnmeta.Index;
    columnmeta.PublicName           = AddStringToHeap(GetAttribute(i_Element, m_PublicName).Value());

    //Several things are inferred from the Type: Size, MetaFlags, SchemaGeneratorFlags
    const TOLEDataTypeToXMLDataType * pOLEDataType = Get_OLEDataTypeToXMLDataType(GetAttribute(i_Element, m_Type).Value());

    columnmeta.Type                 = AddUI4ToList(pOLEDataType->dbType);
    const TAttr & attrSize          = GetAttribute(i_Element, m_Size);
    if(attrSize.IsNULL())
        columnmeta.Size             = AddUI4ToList(pOLEDataType->cbSize);
    else
    {
        WCHAR * dummy;
        columnmeta.Size             = AddUI4ToList(wcstol(attrSize.Value().GetString(), &dummy, 10));
    }

    ULONG MetaFlags = StringToFlagValue(GetAttribute(i_Element, m_MetaFlags).Value(), wszTABLE_COLUMNMETA, iCOLUMNMETA_MetaFlags);
    if(MetaFlags & (fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE))
    {
        m_out.printf(L"Error! - Invalid MetaFlag supplied.  Ignoring property (%s).  Some MetaFlags must be inferred (fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE)\r\n", StringFromIndex(i_iColumnInternalName));
        MetaFlags &= ~(fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE);
    }
    columnmeta.MetaFlags            = AddUI4ToList(MetaFlags | pOLEDataType->fCOLUMNMETA);

    ULONG MetaFlagsEx = StringToFlagValue(GetAttribute(i_Element, m_SchemaGeneratorFlags).Value(), wszTABLE_COLUMNMETA, iCOLUMNMETA_SchemaGeneratorFlags);
    if(MetaFlagsEx & (fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED))
    {
        m_out.printf(L"Error! - Invalid MetaFlagsEx supplied.  Ignoring property (%s).  Some MetaFlagsEx must be inferred (fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED)\r\n", StringFromIndex(i_iColumnInternalName));
        MetaFlags &= ~(fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED);
    }
    columnmeta.SchemaGeneratorFlags = AddUI4ToList(MetaFlagsEx | pOLEDataType->fCOLUMNSCHEMAGENERATOR | fCOLUMNMETA_USERDEFINED);//Mark this property as a UserDefined property
    columnmeta.DefaultValue         = 0;//This gets filled in last since the rest of ColumnMeta is needed
    columnmeta.FlagMask             = 0;//Inferred from TagMeta
    columnmeta.StartingNumber       = AddUI4ToList(GetAttribute(i_Element, m_StartingNumber).Value().ToUI4());

    const TAttr & attrEndingNumber  = GetAttribute(i_Element, m_EndingNumber);
    if(attrEndingNumber.IsNULL())
        columnmeta.EndingNumber     = AddUI4ToList(static_cast<ULONG>(~0x00));
    else
        columnmeta.EndingNumber     = AddUI4ToList(attrEndingNumber.Value().ToUI4());

    columnmeta.CharacterSet         = AddStringToHeap(GetAttribute(i_Element, m_CharacterSet).Value());
    columnmeta.ID                   = AddUI4ToList(GetAttribute(i_Element, m_ID).Value().ToUI4());
    columnmeta.UserType             = AddUI4ToList(StringToEnumValue(GetAttribute(i_Element, m_UserType).Value(), wszTABLE_COLUMNMETA, iCOLUMNMETA_UserType, true));
    columnmeta.Attributes           = AddUI4ToList(StringToFlagValue(GetAttribute(i_Element, m_Attributes).Value(), wszTABLE_COLUMNMETA, iCOLUMNMETA_Attributes));
	columnmeta.Description			= AddStringToHeap(GetAttribute(i_Element, m_Description).Value());
	columnmeta.PublicColumnName     = AddStringToHeap(GetAttribute(i_Element, m_PublicColumnName).Value());
    columnmeta.ciTagMeta            = 0;//Inferred later
    columnmeta.iTagMeta             = 0;//Inferred later
    columnmeta.iIndexName           = 0;//Not used in the Metabase

    if(UI4FromIndex(columnmeta.ID) > m_LargestID)
        m_LargestID = UI4FromIndex(columnmeta.ID);

    columnmeta.DefaultValue         = GetDefaultValue(i_Element, columnmeta);

    AddColumnMetaToList(&columnmeta);
    ++m_NextColumnIndex;
}


ULONG TMetabaseMetaXmlFile::GetDefaultValue(const TElement &i_Element, ColumnMeta & columnmeta)
{
    const TSizedString & strDefaultValue = GetAttribute(i_Element, m_DefaultValue).Value();
    if(strDefaultValue.IsNULL())
        return 0;//NULL

    ULONG SynID = SynIDFromMetaFlagsEx(UI4FromIndex(columnmeta.SchemaGeneratorFlags));

    switch(SynID)
    {
    case IIS_SYNTAX_ID_DWORD       : // 1 DWORD
    case IIS_SYNTAX_ID_BOOL        : // 6 DWORD
    case IIS_SYNTAX_ID_BOOL_BITMASK: // 7 DWORD
        {
            return AddUI4ToList(strDefaultValue.ToUI4());
        }
        break;

    case IIS_SYNTAX_ID_STRING      : // 2 STRING
    case IIS_SYNTAX_ID_EXPANDSZ    : // 3 EXPANDSZ
        {
            return AddStringToHeap(strDefaultValue);
        }
        break;

    case IIS_SYNTAX_ID_MULTISZ     : // 4 MULTISZ
    case IIS_SYNTAX_ID_MIMEMAP     : // 8 MULTISZ
    case IIS_SYNTAX_ID_IPSECLIST   : // 9 MULTISZ
    case IIS_SYNTAX_ID_HTTPERRORS  : //11 MULTISZ
    case IIS_SYNTAX_ID_HTTPHEADERS : //12 MULTISZ
        {
            ULONG ulStrLen = (ULONG) strDefaultValue.GetStringLength();
            if((ulStrLen+2)*sizeof(WCHAR) > UI4FromIndex(columnmeta.Size))
            {
                WCHAR wszSize[12];
                wsprintf(wszSize, L"%d", UI4FromIndex(columnmeta.Size));
                LOG_ERROR(Interceptor, (0,
                                        m_spISTAdvancedDispenser,
                                        E_ST_COMPILEFAILED,
                                        ID_CAT_CONFIG_SCHEMA_COMPILE,
                                        IDS_SCHEMA_COMPILATION_DEFAULT_VALUE_TOO_LARGE,
                                        wszSize,
                                        StringFromIndex(columnmeta.InternalName),
                                        static_cast<ULONG>(0),
                                        StringFromIndex(columnmeta.Table)));
                THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);
            }
            if(UI4FromIndex(columnmeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH)
            {
                LOG_ERROR(Interceptor, (0,
                                        m_spISTAdvancedDispenser,
                                        E_ST_COMPILEFAILED,
                                        ID_CAT_CONFIG_SCHEMA_COMPILE,
                                        IDS_SCHEMA_COMPILATION_DEFAULT_VALUE_FIXEDLENGTH_MULTISTRING_NOT_ALLOWED,
                                        StringFromIndex(columnmeta.InternalName),
                                        static_cast<ULONG>(0),
                                        StringFromIndex(columnmeta.Table)));
                THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);
            }
            if(0==ulStrLen)
            {
                WCHAR  wszDoubleNULL[2];
                wszDoubleNULL[0] = 0x00;
                wszDoubleNULL[1] = 0x00;
                return AddBytesToList(reinterpret_cast<unsigned char *>(wszDoubleNULL), 2 * sizeof(WCHAR));
            }

            TSmartPointerArray<WCHAR> saString = new WCHAR [ulStrLen+1];
            TSmartPointerArray<WCHAR> saMultiString = new WCHAR [ulStrLen+2];
            if(0 == saString.m_p || 0 == saMultiString.m_p)
            {
                THROW_ERROR0(IDS_SCHEMA_COMPILATION_OUTOFMEMORY);
            }
            memcpy(saString.m_p, strDefaultValue.GetString(), strDefaultValue.GetStringLength() *sizeof(WCHAR));//make a copy of the string so we can strtok it
            saString[strDefaultValue.GetStringLength()] = 0x00;//NULL terminate it too
            saMultiString[0] = 0x00;

            LPWSTR token = wcstok(saString, L"|\r\n");
            ULONG cchMultiString = 0;
            while(token)
            {
                LPWSTR wszTemp = token;
                while(*wszTemp==L' ' || *wszTemp==L'\t')//ignore leading spaces and tabs
                    wszTemp++;

                if(0 == *wszTemp)//and if only tabs and spaces exist then bail
                    break;
                wcscpy(saMultiString + cchMultiString, wszTemp);
                cchMultiString += (ULONG) (wcslen(wszTemp) + 1);

                token = wcstok(0, L"|\r\n");
            }
            saMultiString[cchMultiString++] = 0x00;//put the second NULL
            return AddBytesToList(reinterpret_cast<unsigned char *>(saMultiString.m_p), cchMultiString * sizeof(WCHAR));
        }
        break;

    case IIS_SYNTAX_ID_BINARY      : // 5 BINARY
    case IIS_SYNTAX_ID_NTACL       : //10 BINARY
        {
            unsigned long                       cbArray = (ULONG)strDefaultValue.GetStringLength();
            if(cbArray & 0x01)
            {
                TSmartPointerArray<WCHAR> saString = new WCHAR [strDefaultValue.GetStringLength()+1];
                if(0 == saString.m_p)
                {
                    THROW_ERROR0(IDS_SCHEMA_COMPILATION_OUTOFMEMORY);
                }
                memcpy(saString.m_p, strDefaultValue.GetString(), strDefaultValue.GetStringLength() *sizeof(WCHAR));//make a copy of the string so we can strtok it
                saString[strDefaultValue.GetStringLength()] = 0x00;//NULL terminate it too
                THROW_ERROR1(IDS_COMCAT_XML_BINARY_STRING_CONTAINS_ODD_NUMBER_OF_CHARACTERS, saString);
            }
            cbArray /= 2;//There are two characters per hex byte.

            if((UI4FromIndex(columnmeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) && cbArray > UI4FromIndex(columnmeta.Size))
            {
                WCHAR wszSize[12];
                wsprintf(wszSize, L"%d", UI4FromIndex(columnmeta.Size));
                THROW_ERROR2(IDS_SCHEMA_COMPILATION_DEFAULT_VALUE_TOO_LARGE, wszSize, StringFromIndex(columnmeta.InternalName));
            }

            TSmartPointerArray<unsigned char>   sabyArray;
            sabyArray = new unsigned char [(UI4FromIndex(columnmeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) ? UI4FromIndex(columnmeta.Size) : cbArray];
            if(0 == sabyArray.m_p)
            {
                THROW_ERROR0(IDS_SCHEMA_COMPILATION_OUTOFMEMORY);
            }
            memset(sabyArray.m_p, 0x00, (UI4FromIndex(columnmeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) ? UI4FromIndex(columnmeta.Size) : cbArray);

            //Convert the string into a byte array
            ConvertWideCharsToBytes(strDefaultValue.GetString(), sabyArray.m_p, cbArray);
            return AddBytesToList(sabyArray.m_p, (UI4FromIndex(columnmeta.MetaFlags) & fCOLUMNMETA_FIXEDLENGTH) ? UI4FromIndex(columnmeta.Size) : cbArray);//AddBytesToList just slams the bytes into the pool (prepending the length) and returns the index to bytes
        }
        break;
    default:
        ASSERT(false && L"Unknown Synid");
    }
    return 0;
}

static LPCWSTR kwszHexLegalCharacters = L"abcdefABCDEF0123456789";

static unsigned char kWcharToNibble[128] = //0xff is an illegal value, the illegal values should be weeded out by the parser
{ //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
/*00*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*10*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*20*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*30*/  0x0,    0x1,    0x2,    0x3,    0x4,    0x5,    0x6,    0x7,    0x8,    0x9,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*40*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*50*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*60*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*70*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
};

//This converts the string to bytes (an L'A' gets translated to 0x0a NOT 'A')
void TMetabaseMetaXmlFile::ConvertWideCharsToBytes(LPCWSTR string, unsigned char *pBytes, unsigned long length)
{
    for(;length; --length, ++pBytes)//while length is non zero
    {
        if(kWcharToNibble[(*string)&0x007f] & 0xf0)
        {
            TSmartPointerArray<WCHAR> saByteString = new WCHAR [(length * 2) + 1];
			if (saByteString == 0)
			{
				THROW_ERROR0(IDS_SCHEMA_COMPILATION_OUTOFMEMORY);
			}
            memcpy(saByteString, string, length * 2);
            saByteString[length * 2] = 0x00;//NULL terminate it
            THROW_ERROR1(IDS_COMCAT_XML_BINARY_STRING_CONTAINS_A_NON_HEX_CHARACTER, saByteString);
        }
        *pBytes =  kWcharToNibble[(*string++)&0x007f]<<4;//The first character is the high nibble

        if(kWcharToNibble[(*string)&0x007f] & 0xf0)
        {
            TSmartPointerArray<WCHAR> saByteString = new WCHAR [(length * 2) + 1];
			if (saByteString == 0)
			{
				THROW_ERROR0(IDS_SCHEMA_COMPILATION_OUTOFMEMORY);
			}

            memcpy(saByteString, string, length * 2);
            saByteString[length * 2] = 0x00;//NULL terminate it
            THROW_ERROR1(IDS_COMCAT_XML_BINARY_STRING_CONTAINS_A_NON_HEX_CHARACTER, saByteString);
        }
        *pBytes |= kWcharToNibble[(*string++)&0x007f];   //The second is the low nibble
    }
}

void TMetabaseMetaXmlFile::AddColumnMetaViaReferenceToHeap(const TElement &i_Element)
{
    //<Property       InheritsPropertiesFrom ="IIsConfigObject:MaxConnections"/>
    const TAttr & attrInheritsPropertiesFrom = GetAttribute(i_Element, m_InheritsPropertiesFrom);
    if(attrInheritsPropertiesFrom.IsNULL())
    {
        WCHAR wszOffendingXml[0x100];
        wcsncpy(wszOffendingXml, i_Element.m_NumberOfAttributes>0 ? i_Element.m_aAttribute[0].m_Name : L"", 0xFF);//copy up to 0xFF characters
        wszOffendingXml[0xFF]=0x00;

        LOG_ERROR2(IDS_SCHEMA_COMPILATION_ATTRIBUTE_NOT_FOUND, kszInheritsColumnMeta, wszOffendingXml);
    }

    ColumnMeta columnmeta;
    memset(&columnmeta, 0x00, sizeof(ColumnMeta));

    //wcstok needs a NULL terminated string
    WCHAR szTemp[272];//IIsConfigObject:PropertyNameUpTo255Characters so wcslen(L"IIsConfigObject:") + 255 + 1 (for the NULL) = 272
    if(attrInheritsPropertiesFrom.Value().GetStringLength() > 271)
    {
        wcsncpy(szTemp, attrInheritsPropertiesFrom.Value().GetString(), 268);
        szTemp[268]=L'.';
        szTemp[269]=L'.';
        szTemp[270]=L'.';
        szTemp[271]=0x00;

        THROW_ERROR3(IDS_SCHEMA_COMPILATION_ATTRIBUTE_CONTAINS_TOO_MANY_CHARACTERS, kszInheritsColumnMeta, szTemp, L"271");
    }
    memcpy(szTemp, attrInheritsPropertiesFrom.Value().GetString(), attrInheritsPropertiesFrom.Value().GetStringLength() * sizeof(WCHAR));
    szTemp[attrInheritsPropertiesFrom.Value().GetStringLength()] = 0x00;//NULL terminate it

    //The inheritance string is of the form  TableName:ColumnName
    WCHAR * pTableName = wcstok(szTemp, L":");
    WCHAR * pColumnName = wcstok(0, L":");
    if(0==pTableName || 0==pColumnName)
    {
        memcpy(szTemp, attrInheritsPropertiesFrom.Value().GetString(), attrInheritsPropertiesFrom.Value().GetStringLength() * sizeof(WCHAR));
        szTemp[attrInheritsPropertiesFrom.Value().GetStringLength()] = 0x00;

        THROW_ERROR1(IDS_SCHEMA_COMPILATION_INHERITSPROPERTIESFROM_ERROR, szTemp);
    }
    else
    {
        if(*pTableName!=L'i' && *pTableName!=L'I')
        {
            THROW_ERROR2(IDS_SCHEMA_COMPILATION_INHERITSPROPERTIESFROM_BOGUS_TABLE, pTableName, wszTABLE_IIsConfigObject);
        }
    }

    //See if the property is already part of this collection, if it is just ignore it.
    ULONG iColumnInternalName=AddWCharToList(pColumnName, attrInheritsPropertiesFrom.Value().GetStringLength() + 1 - (ULONG)(pColumnName-pTableName));
    ULONG iColumnAlreadyAdded;
    bool  bColumnAlreadyPartOfTheTable = (-1 != (iColumnAlreadyAdded = FindColumnBy_Table_And_InternalName(m_iCurrentTableName, iColumnInternalName, true)));
    if(!bColumnAlreadyPartOfTheTable)
    {
        //All inheritance MUST be from IIsConfigObject
        ULONG iColumnMeta = FindColumnBy_Table_And_InternalName(m_iTableName_IIsConfigObject, iColumnInternalName, true);

        if(-1 == iColumnMeta)
            return;//ignore properties we don't understand.  We would log an error but there are currently lots of these because of the way the MetaMigrate works

        //Now we tolerate duplicate inherited columns and ignore them
        //so we need to search this table's ColumnMeta for column name we're getting ready to add.
        ULONG i=GetCountColumnMeta()-1;
        for(; i>0 && ColumnMetaFromIndex(i)->Table==m_iCurrentTableName; --i)
        {
            if(ColumnMetaFromIndex(i)->InternalName == iColumnInternalName)
                return;//This ColumnInternalName already belongs to this table's ColumnMeta so ignore it
        }

        iColumnAlreadyAdded = m_NextColumnIndex;

        AddColumnMetaByReference(iColumnMeta);
    }

    //Check for overriding ColumnMeta - some ColumnMeta is inherited but overridden by the inheriting class
    CheckForOverrridingColumnMeta(i_Element, iColumnAlreadyAdded);

    //if this column is NOT already part of the table AND the table is a shipped table, then the shipped table has just been EXTENDED.
    if(!bColumnAlreadyPartOfTheTable && m_iCurrentTableMeta <= m_iLastShippedCollection)
    {//If this is a Shipped collection, then we need to mark the MetaFlagsEx (AKA SchemaGeneratorFlags) as EXTENDED (meaning the collection is a shipped collection; but it has been EXTENDED somehow).
        TableMetaFromIndex(m_iCurrentTableMeta)->SchemaGeneratorFlags = AddUI4ToList(UI4FromIndex(TableMetaFromIndex(m_iCurrentTableMeta)->SchemaGeneratorFlags) | fTABLEMETA_EXTENDED);
    }
}

ULONG TMetabaseMetaXmlFile::AddMergedContainerClassListToList(const TSizedString *i_pContainerClassList, LPCWSTR i_wszContainerClassListShipped, ULONG i_cchContainerClassListShipped, bool &o_bExtended)
{
    o_bExtended = false;

    //if the XML is NULL or L"" then use the shipped list
    if(0 == i_pContainerClassList || i_pContainerClassList->IsNULL() || 0 == i_pContainerClassList->GetStringLength())
        return AddWCharToList(i_wszContainerClassListShipped, i_cchContainerClassListShipped);

    //if the shipped schema is NULL or L"" then use the XML list
    if(0==i_cchContainerClassListShipped || 0==i_wszContainerClassListShipped)
    {
        o_bExtended = true;
        return AddStringToHeap(*i_pContainerClassList);
    }

    //this is cch of the string        this is cch of the buffer
    if(i_pContainerClassList->GetStringLength()==(i_cchContainerClassListShipped-1) && 0==memcmp(i_pContainerClassList->GetString(), i_wszContainerClassListShipped, i_pContainerClassList->GetStringLength() * sizeof(WCHAR)))
        return AddWCharToList(i_wszContainerClassListShipped, i_cchContainerClassListShipped);

    //@@@TODO  The line below disabled support for modifying ContainerClassList
    //return AddWCharToList(i_wszContainerClassListShipped, i_cchContainerClassListShipped);

    //this is the maximum size buffer needed.
    TSmartPointerArray<WCHAR> saMergedContainerClassList = new WCHAR[i_pContainerClassList->GetStringLength() + i_cchContainerClassListShipped + 2];//the plus one is for the extra comma between the strings, plus one more for the trailing comma that gets removed at the end
    TSmartPointerArray<WCHAR> saXmlContainerClassList    = new WCHAR[i_pContainerClassList->GetStringLength() + 2];//Add 2 to make searching easier

    if(0 == saMergedContainerClassList.m_p || 0 == saXmlContainerClassList.m_p)
    {
        THROW_ERROR0(IDS_SCHEMA_COMPILATION_OUTOFMEMORY);
    }

    //wcstr needs two NULL terminated strings
    memcpy(saXmlContainerClassList.m_p, i_pContainerClassList->GetString(), i_pContainerClassList->GetStringLength()*sizeof(WCHAR));
    saXmlContainerClassList.m_p[i_pContainerClassList->GetStringLength()] = 0x00;//null terminate it
    saXmlContainerClassList.m_p[i_pContainerClassList->GetStringLength()+1] = 0x00;//This second NULL makes the searching below easier

    //@@@TODO: This is NOT the most efficient way of doing this; but it is the most straight forward.  We may need to optimize it.

    //if the XML string is different than the shipped list, then merge the two
    memcpy(saMergedContainerClassList.m_p, i_wszContainerClassListShipped, i_cchContainerClassListShipped * sizeof(WCHAR));//this cch includes the NULL
    ULONG   cchStringLenMergedList = i_cchContainerClassListShipped-1;

    saMergedContainerClassList[cchStringLenMergedList++] = L',';//add a comma to the end for easier searching
    saMergedContainerClassList[cchStringLenMergedList]   = 0x00;//NULL Terminate it

    LPWSTR  token = wcstok(saXmlContainerClassList, L",");
    while(token)
    {
        //OK, now to keep from finding property "Foo" in the MergedList "Foo2,Foo3," we need to look for the trailing comma (note the trailing comma - it's there for a reason)
        //we need to make the tokenized string "Foo\0Bar,Zee" into "Foo,\0ar,Zee"
        ULONG wchToken = (ULONG)wcslen(token);
        WCHAR wchAfterTheComma = 0x00;

        wchAfterTheComma  = token[wchToken+1];
        token[wchToken+1] = 0x00;
        token[wchToken]   = L',';

        if(0 == wcsstr(saMergedContainerClassList, token))
        {//if this class was not found in the merged list, then add it
            o_bExtended = true;
            wcscpy(saMergedContainerClassList + cchStringLenMergedList, token);
            cchStringLenMergedList += wchToken+1;
        }
        //now put the toekn back to the way it was
        token[wchToken+1] = wchAfterTheComma;
        token[wchToken]   = 0x00;

        token = wcstok(0, L",");
    }
    ASSERT(saMergedContainerClassList[cchStringLenMergedList-1] == L',');
    saMergedContainerClassList[--cchStringLenMergedList] = 0x00;//remove the last comma


    return AddWCharToList(saMergedContainerClassList, cchStringLenMergedList+1/*This parameter is the size including the NULL*/);
}

void TMetabaseMetaXmlFile::AddServerWiringMetaToHeap(ULONG iTableName, bool i_bFixedInterceptor)
{
    ServerWiringMeta serverwiringmeta;
    serverwiringmeta.Table          = iTableName;
    serverwiringmeta.Order          = AddUI4ToList(0);
    serverwiringmeta.ReadPlugin     = 0;//defaulted later
    serverwiringmeta.WritePlugin    = 0;//defaulted later
    serverwiringmeta.Merger         = 0;//defaulted later

    //All tables come from the XML interceptor except MBPropertyDiff, which comes from the differencing interceptor
    if(i_bFixedInterceptor)//the only other databases use the FixedInterceptor
        serverwiringmeta.Interceptor    = AddUI4ToList(eSERVERWIRINGMETA_Core_FixedInterceptor);
    else
    {
        if(0 == _wcsicmp(wszTABLE_MBPropertyDiff, StringFromIndex(iTableName)))
            serverwiringmeta.Interceptor    = AddUI4ToList(eSERVERWIRINGMETA_Core_MetabaseDifferencingInterceptor);
        else if(0 == _wcsicmp(wszTABLE_MBProperty, StringFromIndex(iTableName)))
            serverwiringmeta.Interceptor    = AddUI4ToList(eSERVERWIRINGMETA_Core_MetabaseInterceptor);
        else
            serverwiringmeta.Interceptor    = AddUI4ToList(eSERVERWIRINGMETA_Core_XMLInterceptor);
    }

    serverwiringmeta.ReadPluginDLLName	= 0;//inferred later
    serverwiringmeta.WritePluginDLLName	= 0;//inferred later
    serverwiringmeta.InterceptorDLLName	= 0;//inferred later
    serverwiringmeta.MergerDLLName		= 0;//inferred later
    serverwiringmeta.Flags				= 0;//inferred later
    serverwiringmeta.Locator			= 0;//inferred later
    serverwiringmeta.Reserved			= 0;//inferred later

    AddServerWiringMetaToList(&serverwiringmeta);
}

void TMetabaseMetaXmlFile::AddShippedColumnMetaToHeap(ULONG i_iTableName, const ColumnMeta *i_pColumnMeta)
{
    ColumnMeta columnmeta;
    memset(&columnmeta, 0x00, sizeof(ColumnMeta));

    m_iCurrentColumnIndex           = AddUI4ToList( m_NextColumnIndex);//Don't increment m_NextColumnIndex until this column is actually added

    columnmeta.Table                = i_iTableName;
    columnmeta.Index                = m_iCurrentColumnIndex;
    columnmeta.InternalName         = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->InternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pColumnMeta->InternalName)/sizeof(WCHAR));

    if(i_pColumnMeta->PublicName == i_pColumnMeta->InternalName)
        columnmeta.PublicName       = columnmeta.InternalName;
    else
        columnmeta.PublicName       = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->PublicName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pColumnMeta->PublicName)/sizeof(WCHAR));

    columnmeta.Type                 = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->Type)));
    columnmeta.Size                 = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->Size)));
    columnmeta.MetaFlags            = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->MetaFlags)));
    columnmeta.DefaultValue         = AddBytesToList(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->DefaultValue), m_pShippedSchemaHeap->Get_PooledDataSize(i_pColumnMeta->DefaultValue));
    columnmeta.FlagMask             = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->FlagMask)));
    columnmeta.StartingNumber       = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->StartingNumber)));
    columnmeta.EndingNumber         = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->EndingNumber)));
    columnmeta.CharacterSet         = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->CharacterSet)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pColumnMeta->CharacterSet)/sizeof(WCHAR));
    columnmeta.SchemaGeneratorFlags = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->SchemaGeneratorFlags)));
    columnmeta.ID                   = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->ID)));
    columnmeta.UserType             = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->UserType)));
    columnmeta.Attributes           = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->Attributes)));
    columnmeta.Description			= AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->Description)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pColumnMeta->Description)/sizeof(WCHAR));
    columnmeta.PublicColumnName		= AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pColumnMeta->PublicColumnName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pColumnMeta->PublicColumnName)/sizeof(WCHAR));
	columnmeta.ciTagMeta            = 0;//Inferred later
    columnmeta.iTagMeta             = 0;//Inferred later
    columnmeta.iIndexName           = 0;//Not used

    const TagMeta * pTagMeta = m_pShippedSchemaHeap->Get_aTagMeta(i_pColumnMeta->iTagMeta);
    for(ULONG i=0;i<i_pColumnMeta->ciTagMeta;++i, ++pTagMeta)
        AddShippedTagMetaToHeap(i_iTableName, columnmeta.Index, pTagMeta);

    m_iLastShippedProperty = AddColumnMetaToList(&columnmeta) / sizeof(ColumnMeta);//Keep track of the last shipped property, this can make some lookups faster
    ++m_NextColumnIndex;
    m_iCurrentColumnIndex = 0;//This set to zero means that no more Tags are allowed to be added to this column
}


void TMetabaseMetaXmlFile::AddShippedIndexMetaToHeap(ULONG i_iTableName, const IndexMeta *i_pIndexMeta)
{
    IndexMeta indexmeta;
    indexmeta.Table                 = i_iTableName;
    indexmeta.InternalName          = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pIndexMeta->InternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pIndexMeta->InternalName)/sizeof(WCHAR));

    if(i_pIndexMeta->PublicName == i_pIndexMeta->InternalName)
        indexmeta.PublicName        = indexmeta.InternalName;
    else
        indexmeta.PublicName        = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pIndexMeta->PublicName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pIndexMeta->PublicName)/sizeof(WCHAR));

    indexmeta.ColumnIndex           = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pIndexMeta->ColumnIndex)));
    indexmeta.ColumnInternalName    = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pIndexMeta->ColumnInternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pIndexMeta->ColumnInternalName)/sizeof(WCHAR));
    indexmeta.MetaFlags             = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pIndexMeta->MetaFlags)));

    AddIndexMetaToList(&indexmeta);
}


void TMetabaseMetaXmlFile::AddShippedTableMetaToHeap(const TableMeta *i_pTableMeta, bool i_bFixedInterceptor, const TSizedString *i_pContainerClassList)
{
    TableMeta tablemeta;
    memset(&tablemeta, 0x00, sizeof(TableMeta));

    m_iCurrentDatabaseName          = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->Database)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->Database)/sizeof(WCHAR));
    tablemeta.Database              = m_iCurrentDatabaseName;
    tablemeta.InternalName          = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->InternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->InternalName)/sizeof(WCHAR));

    if(i_pTableMeta->PublicName == i_pTableMeta->InternalName)
        tablemeta.PublicName        = tablemeta.InternalName;
    else
        tablemeta.PublicName        = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->PublicName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->PublicName)/sizeof(WCHAR));

    tablemeta.PublicRowName         = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->PublicRowName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->PublicRowName)/sizeof(WCHAR));
    tablemeta.BaseVersion           = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->BaseVersion)));
    tablemeta.ExtendedVersion       = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->ExtendedVersion)));
    tablemeta.NameColumn            = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->NameColumn)));
    tablemeta.NavColumn             = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->NavColumn)));
    tablemeta.CountOfColumns        = 0;//This will be inferred later
    tablemeta.MetaFlags             = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->MetaFlags)));
    //tablemeta.SchemaGeneratorFlags is done after ContainerClassList
    tablemeta.ConfigItemName        = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->ConfigItemName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->ConfigItemName)/sizeof(WCHAR));
    tablemeta.ConfigCollectionName  = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->ConfigCollectionName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->ConfigCollectionName)/sizeof(WCHAR));
    tablemeta.PublicRowNameColumn   = 0;

    //Users can modify this column.  They can add classes but not removed any.
    bool bExtended;
    tablemeta.ContainerClassList    = AddMergedContainerClassListToList(i_pContainerClassList, reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->ContainerClassList)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->ContainerClassList)/sizeof(WCHAR), bExtended);
    tablemeta.SchemaGeneratorFlags  = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->SchemaGeneratorFlags)) | (bExtended ? fTABLEMETA_EXTENDED : 0));

    tablemeta.Description           = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->Description)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->Description)/sizeof(WCHAR));
    tablemeta.ChildElementName      = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->ChildElementName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTableMeta->ChildElementName)/sizeof(WCHAR));

    tablemeta.ciRows                = 0;//N/A
    tablemeta.iColumnMeta           = 0;//Inferred later
    tablemeta.iFixedTable           = 0;//N/A
    tablemeta.cPrivateColumns       = 0;//N/A
    tablemeta.cIndexMeta            = 0;//N/A
    tablemeta.iIndexMeta            = 0;//N/A
    tablemeta.iHashTableHeader      = 0;//N/A
    tablemeta.nTableID              = 0;//N/A
    tablemeta.iServerWiring         = 0;//N/A
    tablemeta.cServerWiring         = 0;//N/A

    m_iCurrentTableMeta             = AddTableMetaToList(&tablemeta) / sizeof(TableMeta);//Keep track of the last shipped collection, this can make some lookups faster
    m_iLastShippedCollection        = m_iCurrentTableMeta;
    m_NextColumnIndex               = 0;//We're starting a new table so the ColumnIndex start at zero
    m_iCurrentTableName             = tablemeta.InternalName;

    AddServerWiringMetaToHeap(tablemeta.InternalName, i_bFixedInterceptor);

    const ColumnMeta * pColumnMeta = m_pShippedSchemaHeap->Get_aColumnMeta(i_pTableMeta->iColumnMeta);
    for(;m_NextColumnIndex<*reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTableMeta->CountOfColumns));++pColumnMeta)
        AddShippedColumnMetaToHeap(tablemeta.InternalName, pColumnMeta);//This function increments the m_NextColumnIndex counter

    if(i_bFixedInterceptor && -1!=i_pTableMeta->iIndexMeta)
    {
        const IndexMeta * pIndexMeta = m_pShippedSchemaHeap->Get_aIndexMeta(i_pTableMeta->iIndexMeta);
        for(ULONG iIndexMeta=0; iIndexMeta<i_pTableMeta->cIndexMeta; ++iIndexMeta, ++pIndexMeta)
            AddShippedIndexMetaToHeap(tablemeta.InternalName, pIndexMeta);
    }
    //The last shipped Collection to be added is IISConfigObject.  We rely on m_NextColumnIndex to be correct so we can continue to increment it
    //when adding user defined properties.
}


void TMetabaseMetaXmlFile::AddShippedTagMetaToHeap(ULONG i_iTableName, ULONG i_iColumnIndex, const TagMeta *i_pTagMeta)
{
    TagMeta tagmeta;

    tagmeta.Table                   = i_iTableName;
    tagmeta.ColumnIndex             = i_iColumnIndex;
    tagmeta.InternalName            = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTagMeta->InternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTagMeta->InternalName)/sizeof(WCHAR));

    if(i_pTagMeta->PublicName == i_pTagMeta->InternalName)
        tagmeta.PublicName          = tagmeta.InternalName;
    else
        tagmeta.PublicName          = AddWCharToList(reinterpret_cast<LPCWSTR>(      m_pShippedSchemaHeap->Get_PooledData(i_pTagMeta->PublicName)), m_pShippedSchemaHeap->Get_PooledDataSize(i_pTagMeta->PublicName)/sizeof(WCHAR));

    tagmeta.Value                   = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTagMeta->Value)));
    tagmeta.ID                      = AddUI4ToList( *reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(i_pTagMeta->ID)));

    m_iLastShippedTag = AddTagMetaToList(&tagmeta) / sizeof(TagMeta);//Keep track of the last shipped tag, this can make some lookups faster
}


ULONG TMetabaseMetaXmlFile::AddStringToHeap(const TSizedString &i_str)
{
    if(i_str.IsNULL())
        return 0;//NULL

    TSmartPointerArray<WCHAR>   saTemp;
    WCHAR                       szTemp[1024];//We need to make a copy of the string because it needs to be NULL terminated
    WCHAR *                     pTemp = szTemp;

    if(i_str.GetStringLength() >= 1024)//only allocate heap space if the stack variable isn't big enough
    {
        saTemp = new WCHAR [i_str.GetStringLength() + 1];
        if(0 == saTemp.m_p)
        {
            THROW_ERROR0(IDS_SCHEMA_COMPILATION_OUTOFMEMORY);
        }
		pTemp  = saTemp.m_p;
    }

    memcpy(pTemp, i_str.GetString(), i_str.GetStringLength() * sizeof(WCHAR));
    pTemp[i_str.GetStringLength()]=0x00;//NULL terminate the temp string
    return AddWCharToList(pTemp, i_str.GetStringLength()+1);
}

void TMetabaseMetaXmlFile::AddTableMetaToHeap(const TElement &i_Element)
{
    TableMeta tablemeta;
    memset(&tablemeta, 0x00, sizeof(TableMeta));

    tablemeta.Database              = m_iCurrentDatabaseName;
    tablemeta.InternalName          = m_iCurrentTableName;
    tablemeta.PublicName            = AddStringToHeap(GetAttribute(i_Element, m_PublicName).Value());
    tablemeta.PublicRowName         = AddStringToHeap(GetAttribute(i_Element, m_PublicRowName).Value());
    tablemeta.BaseVersion           = AddUI4ToList(GetAttribute(i_Element, m_BaseVersion).Value().ToUI4());
    tablemeta.ExtendedVersion       = AddUI4ToList(GetAttribute(i_Element, m_ExtendedVersion).Value().ToUI4());
    tablemeta.NameColumn            = AddStringToHeap(GetAttribute(i_Element, m_NameColumn).Value());
    tablemeta.NavColumn             = AddStringToHeap(GetAttribute(i_Element, m_NavColumn).Value());
    tablemeta.CountOfColumns        = 0;//This will be inferred later

    const TAttr & attrMetaFlags = GetAttribute(i_Element, m_MetaFlags);
    if(!attrMetaFlags.IsNULL())
        tablemeta.MetaFlags             = AddUI4ToList(StringToFlagValue(attrMetaFlags.Value(), wszTABLE_TABLEMETA, iTABLEMETA_MetaFlags));
    else
        tablemeta.MetaFlags             = AddUI4ToList(0);

    const TAttr & attrSchemaGeneratorFlags = GetAttribute(i_Element, m_SchemaGeneratorFlags);
    if(attrSchemaGeneratorFlags.IsNULL())
        tablemeta.SchemaGeneratorFlags  = AddUI4ToList(fCOLUMNMETA_USERDEFINED);//Make sure this table is marked as an extended table
    else
    {
        ULONG SchemaGeneratorFlags = StringToFlagValue(attrSchemaGeneratorFlags.Value(), wszTABLE_TABLEMETA, iTABLEMETA_SchemaGeneratorFlags);
        if(SchemaGeneratorFlags & (fTABLEMETA_ISCONTAINED | fTABLEMETA_EXTENDED | fTABLEMETA_USERDEFINED))
        {
            m_out.printf(L"Warning - Table (%s) - Some TableMeta::MetaFlagsEx should be inferred (resetting these flags).  The following flags should NOT be specified by the user.  These flags are inferred:fTABLEMETA_ISCONTAINED | fTABLEMETA_EXTENDED | fTABLEMETA_USERDEFINED\n", StringFromIndex(tablemeta.InternalName));
            SchemaGeneratorFlags &= ~(fTABLEMETA_ISCONTAINED | fTABLEMETA_EXTENDED | fTABLEMETA_USERDEFINED);
        }
        tablemeta.SchemaGeneratorFlags  = AddUI4ToList(SchemaGeneratorFlags | fCOLUMNMETA_USERDEFINED);
    }

    //tablemeta.ConfigItemName        = 0;
    //tablemeta.ConfigCollectionName  = 0;
    //tablemeta.PublicRowNameColumn   = 0;
    tablemeta.ContainerClassList    = AddStringToHeap(GetAttribute(i_Element, m_ContainerClassList).Value());
    tablemeta.Description			= AddStringToHeap(GetAttribute(i_Element, m_Description).Value());
    //tablemeta.ChildElementName      = 0;//N/A  Not used by the Metabase
    //tablemeta.ciRows                = 0;//N/A
    //tablemeta.iColumnMeta           = 0;//Inferred later
    //tablemeta.iFixedTable           = 0;//N/A
    //tablemeta.cPrivateColumns       = 0;//N/A
    //tablemeta.cIndexMeta            = 0;//N/A
    //tablemeta.iIndexMeta            = 0;//N/A
    //tablemeta.iHashTableHeader      = 0;//N/A
    //tablemeta.nTableID              = 0;//N/A
    //tablemeta.iServerWiring         = 0;//N/A
    //tablemeta.cServerWiring         = 0;//N/A

    m_iCurrentTableMeta = AddTableMetaToList(&tablemeta);
    AddServerWiringMetaToHeap(tablemeta.InternalName);

    m_NextColumnIndex           = 0;//We're starting a new table so the ColumnIndex start at zero
    m_iCurrentColumnIndex       = 0;//This prevents us from receiving TagMeta without first getting a Column

    AddColumnMetaByReference(m_iColumnMeta_Location);
}

void TMetabaseMetaXmlFile::AddTagMetaToHeap(const TElement &i_Element)
{
    TagMeta tagmeta;
    tagmeta.Table               = m_iCurrentTableName;
    tagmeta.ColumnIndex         = m_iCurrentColumnIndex;
    tagmeta.InternalName        = AddStringToHeap(GetAttribute(i_Element, m_InternalName).Value());
    tagmeta.PublicName          = AddStringToHeap(GetAttribute(i_Element, m_PublicName).Value());
    tagmeta.Value               = AddUI4ToList(GetAttribute(i_Element, m_Value).Value().ToUI4());
    tagmeta.ID                  = AddUI4ToList(GetAttribute(i_Element, m_ID).Value().ToUI4());

    if(UI4FromIndex(tagmeta.ID) > m_LargestID)
        m_LargestID = UI4FromIndex(tagmeta.ID);

    AddTagMetaToList(&tagmeta);
}


unsigned long TMetabaseMetaXmlFile::AddUI4ToList(ULONG ui4)
{
    //At kcStaticUI4HeapEntries==429 this optimization gets a 69% hit ratio
    if(ui4<kcStaticUI4HeapEntries)//The first kcStaticUI4HeapEntries are initialized in the beginning so we don't have to scan the heap
        return m_aiUI4[ui4];

    return m_HeapPooled.AddItemToHeapWithoutPooling(reinterpret_cast<const unsigned char *>(&ui4), sizeof(ULONG));
}


unsigned long TMetabaseMetaXmlFile::AddWCharToList(LPCWSTR wsz, unsigned long cwchar)
{
    if(0 == wsz)
        return 0;
    return (m_HeapPooled.AddItemToHeap(wsz, cwchar));
}


//Scans the shipped databases and adds the "Meta" & "Metabase" databases to the DatabaseHeap
void TMetabaseMetaXmlFile::BuildDatabaseMeta(const DatabaseMeta * &o_pDatabaseMeta_METABASE)
{
    //From the FixedTableHeap, find the DatabaseMeta for 'Metabase'
    const DatabaseMeta *pDatabaseMeta = m_pShippedSchemaHeap->Get_aDatabaseMeta(0);
    const DatabaseMeta *pDatabaseMeta_METABASE=0;
    for(ULONG iDatabaseMeta=0;iDatabaseMeta<m_pShippedSchemaHeap->Get_cDatabaseMeta();++iDatabaseMeta,++pDatabaseMeta)// assume Metabase database is last - so walk backward from the end
    {
        if(m_Meta.IsEqual(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->InternalName))))
        {
            //Add this row to the DatabaseMeta heap.
            DatabaseMeta databasemeta;
            memset(&databasemeta, 0x00, sizeof(databasemeta));
            databasemeta.InternalName   = AddWCharToList(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->InternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(pDatabaseMeta->InternalName)/sizeof(WCHAR));

            if(pDatabaseMeta->PublicName == pDatabaseMeta->InternalName)
                databasemeta.PublicName = databasemeta.InternalName;
            else
                databasemeta.PublicName = AddWCharToList(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->PublicName)), m_pShippedSchemaHeap->Get_PooledDataSize(pDatabaseMeta->PublicName)/sizeof(WCHAR));

            databasemeta.BaseVersion    = AddUI4ToList(*reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->BaseVersion)));
            databasemeta.ExtendedVersion= AddUI4ToList(*reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->ExtendedVersion)));
            //databasemeta.CountOfTables  = 0;//We'll leave this to be inferred later (since the CountOfTables of the shipped schema may not be the same as what we're compiling)
			databasemeta.Description    = AddWCharToList(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->Description)), m_pShippedSchemaHeap->Get_PooledDataSize(pDatabaseMeta->Description)/sizeof(WCHAR));
            //databasemeta.iSchemaBlob    = 0;//Not used
            //databasemeta.cbSchemaBlob   = 0;//Not used
            //databasemeta.iNameHeapBlob  = 0;//Not used
            //databasemeta.cbNameHeapBlob = 0;//Not used
            //databasemeta.iTableMeta     = 0;//This will be inferred later (it should turn out to be 0 since this is the only database in the bin file).
            //databasemeta.iGuidDid       = 0;//Not used

            AddDatabaseMetaToList(&databasemeta);
        }
        else if(m_Metabase.IsEqual(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->InternalName))))
        {
            pDatabaseMeta_METABASE = pDatabaseMeta;

            //Add this row to the DatabaseMeta heap.
            DatabaseMeta databasemeta;
            memset(&databasemeta, 0x00, sizeof(databasemeta));
            databasemeta.InternalName   = AddWCharToList(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->InternalName)), m_pShippedSchemaHeap->Get_PooledDataSize(pDatabaseMeta->InternalName)/sizeof(WCHAR));

            if(pDatabaseMeta->PublicName == pDatabaseMeta->InternalName)
                databasemeta.PublicName = databasemeta.InternalName;
            else
                databasemeta.PublicName = AddWCharToList(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->PublicName)), m_pShippedSchemaHeap->Get_PooledDataSize(pDatabaseMeta->PublicName)/sizeof(WCHAR));

            databasemeta.BaseVersion    = AddUI4ToList(*reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->BaseVersion)));
            databasemeta.ExtendedVersion= AddUI4ToList(*reinterpret_cast<const ULONG *>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->ExtendedVersion)));
            //databasemeta.CountOfTables  = 0;//We'll leave this to be inferred later (since the CountOfTables of the shipped schema may not be the same as what we're compiling)
			databasemeta.Description	= AddWCharToList(reinterpret_cast<LPCWSTR>(m_pShippedSchemaHeap->Get_PooledData(pDatabaseMeta->Description)), m_pShippedSchemaHeap->Get_PooledDataSize(pDatabaseMeta->Description)/sizeof(WCHAR));
            //databasemeta.iSchemaBlob    = 0;//Not used
            //databasemeta.cbSchemaBlob   = 0;//Not used
            //databasemeta.iNameHeapBlob  = 0;//Not used
            //databasemeta.cbNameHeapBlob = 0;//Not used
            //databasemeta.iTableMeta     = 0;//This will be inferred later (it should turn out to be 0 since this is the only database in the bin file).
            //databasemeta.iGuidDid       = 0;//Not used

            AddDatabaseMetaToList(&databasemeta);
            break;//We're assuming that the Metabase database comes after the Meta database.
        }
    }
    if(0 == pDatabaseMeta_METABASE)
    {
        THROW_ERROR1(IDS_SCHEMA_COMPILATION_NO_METABASE_DATABASE, wszTABLE_MetabaseBaseClass);
    }
    o_pDatabaseMeta_METABASE = pDatabaseMeta_METABASE;
}


void TMetabaseMetaXmlFile::CheckForOverrridingColumnMeta(const TElement &i_Element, ULONG i_iColumnMetaToOverride)
{
    //Now check for overriding PropertyMeta (the only one we plan to support is MetaFlagsEx)
    const TSizedString & schemageneratorflagsValue = GetAttribute(i_Element, m_SchemaGeneratorFlags).Value();
    if(0==schemageneratorflagsValue.GetString())
        return;

    ColumnMeta * pColumnMeta = ColumnMetaFromIndex(i_iColumnMetaToOverride);

    ULONG ulMetaFlagsEx = UI4FromIndex(pColumnMeta->SchemaGeneratorFlags) | StringToFlagValue(schemageneratorflagsValue, wszTABLE_COLUMNMETA, iCOLUMNMETA_SchemaGeneratorFlags);

    if(UI4FromIndex(pColumnMeta->SchemaGeneratorFlags) != ulMetaFlagsEx)
        ulMetaFlagsEx |= fCOLUMNMETA_EXTENDED;//if MetaFlagsEx is different from the ColumnMeta defined in IISConfigObject, the indicate so by setting the EXTENDED flag
    pColumnMeta->SchemaGeneratorFlags = AddUI4ToList(ulMetaFlagsEx);
}

//Returns the index to the ColumnMeta or ~0x00 if the property was not found
ULONG TMetabaseMetaXmlFile::FindUserDefinedPropertyBy_Table_And_InternalName(unsigned long Table, unsigned long  InternalName)
{
    ASSERT(0 == Table%4);
    ASSERT(0 == InternalName%4);

    for(ULONG iColumnMeta=m_iLastShippedProperty+1; iColumnMeta<GetCountColumnMeta();--iColumnMeta)
    {
        if( 0==_wcsicmp(StringFromIndex(ColumnMetaFromIndex(iColumnMeta)->Table), StringFromIndex(Table)) &&
            0==_wcsicmp(StringFromIndex(ColumnMetaFromIndex(iColumnMeta)->InternalName), StringFromIndex(InternalName)))
            break;
    }
    return (iColumnMeta<GetCountColumnMeta() ? iColumnMeta : ~0x00); //return ~0 if the property was not found
}


const TOLEDataTypeToXMLDataType * TMetabaseMetaXmlFile::Get_OLEDataTypeToXMLDataType(const TSizedString &i_str)
{
    const TOLEDataTypeToXMLDataType * pOLEDataType = OLEDataTypeToXMLDataType;

    for(;0 != pOLEDataType->String; ++pOLEDataType)//Walk the list to find the
        if(i_str.IsEqualCaseInsensitive(pOLEDataType->String))
            return pOLEDataType;

    WCHAR szType[1024];
    memcpy(szType, i_str.GetString(), min(i_str.GetStringLength(), 1023));
    szType[min(i_str.GetStringLength(), 1023)] = 0x00;
    THROW_ERROR1(IDS_SCHEMA_COMPILATION_UNKNOWN_DATA_TYPE, szType);

    return 0;
}


const TMetabaseMetaXmlFile::TAttr & TMetabaseMetaXmlFile::GetAttribute(const TElement &i_Element, const TSizedString &i_AttrName)
{
    static TAttr attrNULL;
    ULONG iAttr=0;
    for(;iAttr<i_Element.m_NumberOfAttributes;++iAttr)
    {
        if(i_AttrName.IsEqual(i_Element.m_aAttribute[iAttr].m_Name, i_Element.m_aAttribute[iAttr].m_NameLength))
            return *reinterpret_cast<const TAttr *>(&i_Element.m_aAttribute[iAttr]);
    }
    return attrNULL;
}


void TMetabaseMetaXmlFile::PresizeHeaps()
{
    //presize heaps

    //These numbers come from the Debug Output that's generated at the end of the copilation
    //We leave a little extra room to handle user defined properties.  So only if the user defines
    //lots of properties do we ever have to do a realloc.

    m_HeapColumnMeta.GrowHeap(160000);
    m_HeapDatabaseMeta.GrowHeap(88);
    m_HeapHashedIndex.GrowHeap(450000);
    m_HeapIndexMeta.GrowHeap(392);
    //m_HeapQueryMeta.GrowHeap(0);
    //m_HeapRelationMeta.GrowHeap(0);
    m_HeapServerWiringMeta.GrowHeap(3000);
    m_HeapTableMeta.GrowHeap(8000);
    m_HeapTagMeta.GrowHeap(100000);
    //m_HeapULONG.GrowHeap(0);
    m_HeapPooledUserDefinedID.GrowHeap(300);

    m_HeapPooled.GrowHeap(55000);

    m_HeapPooled.SetFirstPooledIndex((ULONG)-1);

    for(ULONG UI4Value=0;UI4Value!=kcStaticUI4HeapEntries;++UI4Value)//For values between 0 and 255 we'll index to them directly so we done linearly search for the matching entry
        m_aiUI4[UI4Value] = m_HeapPooled.AddItemToHeap(UI4Value);

    m_HeapPooled.SetFirstPooledIndex(m_HeapPooled.GetEndOfHeap());
}


bool TMetabaseMetaXmlFile::ShouldAddColumnMetaToHeap(const TElement &Element, ULONG iColumnInternalName)
{
    //If the property a shipped property?  If so ignore it.  If the proerty is in error, log warning and ignore it.

    tCOLUMNMETARow columnmetaRow = {0};
    columnmetaRow.pTable        = wszTABLE_IIsConfigObject;
    columnmetaRow.pInternalName = const_cast<LPWSTR>(StringFromIndex(iColumnInternalName));

    ULONG aiColumns[2];
    aiColumns[0] = iCOLUMNMETA_Table;
    aiColumns[1] = iCOLUMNMETA_InternalName;

    ULONG iColumnMetaRow;
    if(SUCCEEDED(m_spISTColumnMeta->GetRowIndexBySearch(  0, 2, aiColumns, 0, reinterpret_cast<LPVOID *>(&columnmetaRow), &iColumnMetaRow)))
        return false;

    //If the property was not found ByName, the search ByID
    ULONG        ulID   = GetAttribute(Element, m_ID).Value().ToUI4();
    columnmetaRow.pID   = &ulID;
    aiColumns[1]        = iCOLUMNMETA_ID;

    if(SUCCEEDED(m_spISTColumnMetaByID->GetRowIndexBySearch(  0, 2, aiColumns, 0, reinterpret_cast<LPVOID *>(&columnmetaRow), &iColumnMetaRow)))
    {   //We already searched for this property ByName and didn't find it in the shipped schema, now we ARE finding it by ID.  That a conflict.
        LPWSTR wszShippedProperty = L"";
        ULONG  iColumnInternalNameTemp = iCOLUMNMETA_InternalName;
        VERIFY(SUCCEEDED(m_spISTColumnMetaByID->GetColumnValues(iColumnMetaRow, 1, &iColumnInternalNameTemp, 0, reinterpret_cast<LPVOID *>(&wszShippedProperty))));

        WCHAR wszOffendingXml[0x100];
        wcsncpy(wszOffendingXml, Element.m_NumberOfAttributes>0 ? Element.m_aAttribute[0].m_Name : L"", 0xFF);//copy up to 0xFF characters
        wszOffendingXml[0xFF]=0x00;

        WCHAR wszID[12];
        wsprintf(wszID, L"%d", ulID);

        LOG_WARNING4(IDS_SCHEMA_COMPILATION_USERDEFINED_PROPERTY_HAS_COLLIDING_ID, columnmetaRow.pInternalName, wszID, wszShippedProperty, wszOffendingXml);
        return false;
    }

    //At this point we know we have a User-Defined property
    //check to see if we've seen this ID before
    ULONG ipoolCurrentID = m_HeapPooledUserDefinedID.AddItemToHeap(ulID);
    if(ipoolCurrentID <= m_ipoolPrevUserDefinedID)//if this ID wasn't added to the end of the list, then we have a warning
    {
        WCHAR wszOffendingXml[0x100];
        wcsncpy(wszOffendingXml, Element.m_NumberOfAttributes>0 ? Element.m_aAttribute[0].m_Name : L"", 0xFF);//copy up to 0xFF characters
        wszOffendingXml[0xFF]=0x00;

        WCHAR wszID[12];
        wsprintf(wszID, L"%d", ulID);

        LOG_WARNING3(IDS_SCHEMA_COMPILATION_USERDEFINED_PROPERTY_HAS_COLLIDING_ID_,columnmetaRow.pInternalName, wszID, wszOffendingXml);
        return false;//ignore this property
    }
    m_ipoolPrevUserDefinedID = ipoolCurrentID;//remember the latest ID added,

    return true;
}


ULONG TMetabaseMetaXmlFile::StringToEnumValue(const TSizedString &i_strValue, LPCWSTR i_wszTable, ULONG i_iColumn, bool bAllowNumeric)
{
    if(i_strValue.IsNULL())
        return 0;

    if(bAllowNumeric && i_strValue.GetString()[0] >= L'0' && i_strValue.GetString()[0] <= L'9')
    {
        WCHAR * dummy;
        return wcstol(i_strValue.GetString(), &dummy, 10);
    }

    //We need a NULL terminated string so we can call wcstok
    TSmartPointerArray<WCHAR>   saTemp;
    WCHAR                       szTemp[1024];//We need to make a copy of the string because it needs to be NULL terminated
    WCHAR *                     pTemp = szTemp;

    if(i_strValue.GetStringLength() >= 1024)//only allocate heap space if the stack variable isn't big enough
    {
        saTemp = new WCHAR [i_strValue.GetStringLength() + 1];
        if(0 == saTemp.m_p)
        {
            THROW_ERROR0(IDS_SCHEMA_COMPILATION_OUTOFMEMORY);
        }
		pTemp  = saTemp.m_p;
    }

    memcpy(pTemp, i_strValue.GetString(), i_strValue.GetStringLength() * sizeof(WCHAR));
    pTemp[i_strValue.GetStringLength()] = 0x00;//NULL terminate it

    ULONG   iRow;
    LPVOID  apvValues[3];
    apvValues[0] = reinterpret_cast<LPVOID>(const_cast<LPWSTR>(i_wszTable));
    apvValues[1] = reinterpret_cast<LPVOID>(&i_iColumn);
    apvValues[2] = reinterpret_cast<LPVOID>(pTemp);
    if(FAILED(m_spISTTagMeta->GetRowIndexByIdentity(0, apvValues, &iRow)))
    {//The XML contains a bogus flag
        THROW_ERROR2(IDS_SCHEMA_COMPILATION_ILLEGAL_ENUM_VALUE, pTemp, i_wszTable);
    }

    ULONG * plEnum;
    ULONG   iValueColumn = iTAGMETA_Value;
    VERIFY(SUCCEEDED(m_spISTTagMeta->GetColumnValues(iRow, 1, &iValueColumn, 0, reinterpret_cast<LPVOID *>(&plEnum))));
    return *plEnum;
}


ULONG TMetabaseMetaXmlFile::StringToFlagValue(const TSizedString &i_strValue, LPCWSTR i_wszTable, ULONG i_iColumn)
{
    if(i_strValue.IsNULL())
        return 0;

    //We need a NULL terminated string so we can call wcstok
    TSmartPointerArray<WCHAR>   saTemp;
    WCHAR                       szTemp[1024];//We need to make a copy of the string because it needs to be NULL terminated
    WCHAR *                     pTemp = szTemp;

    if(i_strValue.GetStringLength() >= 1024)//only allocate heap space if the stack variable isn't big enough
    {
        saTemp = new WCHAR [i_strValue.GetStringLength() + 1];
        if(0 == saTemp.m_p)
        {
            THROW_ERROR0(IDS_SCHEMA_COMPILATION_OUTOFMEMORY);
        }
		pTemp  = saTemp.m_p;
    }

    memcpy(pTemp, i_strValue.GetString(), i_strValue.GetStringLength() * sizeof(WCHAR));
    pTemp[i_strValue.GetStringLength()] = 0x00;//NULL terminate it

    ULONG   lFlags = 0;
    WCHAR * pFlag = wcstok(pTemp, L" |,");

    ULONG   iRow;
    LPVOID  apvValues[3];
    apvValues[0] = reinterpret_cast<LPVOID>(const_cast<LPWSTR>(i_wszTable));
    apvValues[1] = reinterpret_cast<LPVOID>(&i_iColumn);

    ULONG iValueColumn = iTAGMETA_Value;
    ULONG *pFlagValue;
    while(pFlag != 0)
    {
        apvValues[2] = reinterpret_cast<LPVOID>(pFlag);
        if(FAILED(m_spISTTagMeta->GetRowIndexByIdentity(0, apvValues, &iRow)))
        {//The XML contains a bogus flag
            LOG_ERROR2(IDS_SCHEMA_COMPILATION_ILLEGAL_FLAG_VALUE, pFlag, i_wszTable);
        }
        else
        {
            VERIFY(SUCCEEDED(m_spISTTagMeta->GetColumnValues(iRow, 1, &iValueColumn, 0, reinterpret_cast<LPVOID *>(&pFlagValue))));
            lFlags |= *pFlagValue;
        }
        pFlag = wcstok(0, L" ,|");
    }
    return lFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tmetainferrence.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TMetaInferrence : public ICompilationPlugin
{
public:
    TMetaInferrence() : m_pFixup(0), m_pOut(0), m_iZero(0){}
    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    static LPCWSTR m_szNameLegalCharacters;
    static LPCWSTR m_szPublicTagLegalCharacters;

    TPEFixup * m_pFixup;
    TOutput  * m_pOut;
    ULONG      m_iZero;

    void ValidateStringAsLegalVariableName(LPCWSTR wszString) const;

    void InferTableMeta_NameColumn_NavColumn(TableMeta *pTableMeta);
    unsigned long InferPublicRowName(unsigned long PublicName);
    void ValidateStringAsLegalVariableName(LPCWSTR wszString, LPCWSTR wszLegalChars=0, bool bAllowNumericFirstCharacter=false);

    void InferDatabaseMeta();
    void InferColumnMeta();
    void InferIndexMeta();
    void InferQueryMeta();
    void InferRelationMeta();//RelationMeta need to come before TableMeta since Inferrence of NameColumn, NvaColumn rely on fCOLUMNMETA_FOREIGNKEY.
    void InferServerWiringMeta();
    void InferTableMeta();
    void InferTagMeta();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tmetabasemetaxmlfile.h ===
// Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
// Filename:        TMetabaseMetaXmlFile.h
// Author:          Stephenr
// Date Created:    9/22/00
// Description:     This class builds the meta heaps from the MetabaseMeta.XML file and the shipped meta located in the Fixed Tables.
//                  The shipped meta is un alterable.  So if discrepencies appear between the MetabaseMeta.XML file and the shipped
//                  schema, the meta reverts back to what was 'shipped'.
//

#pragma once

class TMetabaseMetaXmlFile :
    public  TFixupHeaps,
    public  TMSXMLBase,
    public  TXmlParsedFileNodeFactory
{
public:
    TMetabaseMetaXmlFile(const FixedTableHeap *pShippedSchemaHeap, LPCWSTR wszXmlFile, ISimpleTableDispenser2 *pISTDispenser, TOutput &out);

//TXmlParsedFileNodeFactory
    virtual HRESULT  CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid,  LPVOID * ppv) const {return TMSXMLBase::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);}
    virtual HRESULT  CreateNode      (const TElement &Element);

private:
    //
    //Private types
    //

    //This private class is designed to deal with strings returned from NodeFactory.
    //These strings are NOT NULL terminated.  We need a way of passing them around easily
    //and as one entity.  Also we need to do alot of comparing.
    struct TSizedString
    {
        TSizedString() : m_str(0), m_cch(0){}
        TSizedString(const WCHAR *wsz) : m_str(wsz)
        {
            ASSERT(0 != wsz);
            m_cch = (DWORD) wcslen(wsz);
        }
        void operator =(const WCHAR *wsz)
        {
            ASSERT(0 != wsz);
            m_str = wsz;
            m_cch = (DWORD) wcslen(wsz);
        }
        bool IsEqualCaseInsensitive(const WCHAR *wsz) const
        {
            ASSERT(0 != wsz);

            const WCHAR *pstr = m_str;
            ULONG i;
            for(i=0;i<m_cch;++i, ++pstr, ++wsz)
            {
                if(ToLower(*wsz) != ToLower(*pstr))
                    return false;
            }
            return (0 == *wsz);//if the next character in the wsz is the terminating NULL then we have a match.
        }
        bool IsEqual(const WCHAR *wsz, ULONG cch) const
        {
            return (m_cch==cch && 0==memcmp(wsz, m_str, m_cch*sizeof(WCHAR)));
        }
        bool IsEqual(const WCHAR *wsz) const
        {
            ASSERT(0 != wsz);
            ULONG cch = (ULONG) wcslen(wsz);
            return (m_cch==cch && 0==memcmp(wsz, m_str, m_cch*sizeof(WCHAR)));
        }
        bool IsEqual(const TSizedString &str) const
        {
            return (m_cch==str.m_cch && 0==memcmp(str.m_str, m_str, m_cch*sizeof(WCHAR)));
        }
        bool IsEqual(const TElement &element) const
        {
            return (m_cch==element.m_ElementNameLength && 0==memcmp(element.m_ElementName, m_str, m_cch*sizeof(WCHAR)));
        }
        ULONG ToUI4() const
        {
            if(0 == m_str)
                return 0;
            return _wtol(m_str);//m_str is always of the form 123"  
        }
        bool IsNULL() const
        {
            return (0 == m_str);
        }
        //The members are public so I didn't have to declare a bunch of casting operators
        //or accessor functions.  It is useful to say if(0!=mystring.m_str)memcpy(pFoo, mystring.m_str, mystring.m_cch*sizeof(WCHAR));
        LPCWSTR GetString() const
        {
            return m_str;
        }
        DWORD GetStringLength() const
        {
            return m_cch;
        }
    private:
        DWORD   m_cch;
        LPCWSTR m_str;
    };

    struct TAttr : public TAttribute
    {
        TAttr(){}
        const TSizedString & Name()  const {return *reinterpret_cast<const TSizedString *>(this);}
        const TSizedString & Value() const {return *(reinterpret_cast<const TSizedString *>(this)+1);}
        bool  IsNULL() const {return Name().IsNULL();}
    };


    //
    //Private consts
    //
    enum eParsingState
    {
        eLookingForTheMetabaseDatabase,
        eLookingForTheIIsConfigObjectTable,
        eLookingForGlobalProperties,
        eLookingForCollectionOrInheritedProperties
    };
    enum eParsedLevel
    {
        eConfigurationLevel,
        eDatabaseMetaLevel,
        eCollectionLevel,
        eProperytLevel,
        eTagLevel
    };
    enum
    {
        kcStaticUI4HeapEntries  = 429,
        kPrimeModulo            = 4831,
        kLargestReservedID      = IIS_MD_ADSI_METAID_BEGIN
    };

    const TSizedString    m_Attributes;
    const TSizedString    m_BaseVersion;
    const TSizedString    m_CharacterSet;
    const TSizedString    m_Collection;
    const TSizedString    m_ContainerClassList;
    const TSizedString    m_DatabaseMeta;
    const TSizedString    m_DefaultValue;
	const TSizedString	m_Description;
    const TSizedString    m_EndingNumber;
    const TSizedString    m_Enum;
    const TSizedString    m_ExtendedVersion;
    const TSizedString    m_Flag;
    const TSizedString    m_ID;
    const TSizedString    m_IIsConfigObject;
    const TSizedString    m_InheritsPropertiesFrom;
    const TSizedString    m_InternalName;
    const TSizedString    m_Meta;
    const TSizedString    m_Metabase;
    const TSizedString    m_MetabaseBaseClass;
    const TSizedString    m_MetaFlags;
    const TSizedString    m_NameColumn;
    const TSizedString    m_NavColumn;
    const TSizedString    m_Property;
    const TSizedString    m_PublicName;
	const TSizedString    m_PublicColumnName;
    const TSizedString    m_PublicRowName;
    const TSizedString    m_SchemaGeneratorFlags;
    const TSizedString    m_Size;
    const TSizedString    m_StartingNumber;
    const TSizedString    m_Type;
    const TSizedString    m_UserType;
    const TSizedString    m_Value;


    //
    //Private non const variables
    //
    TSmartPointerArray <bool>   m_aBoolShippedTables;
    ULONG                       m_aiUI4[kcStaticUI4HeapEntries];
    ULONG                       m_iColumnMeta_Location;
    ULONG                       m_iCurrentColumnIndex;
    ULONG                       m_iCurrentDatabaseName;
    ULONG                       m_iCurrentTableName;
    ULONG                       m_iCurrentTableMeta;
    ULONG                       m_iTableName_IIsConfigObject;
    ULONG                       m_iLastShippedCollection;
    ULONG                       m_iLastShippedProperty;
    ULONG                       m_iLastShippedTag;
    ULONG                       m_LargestID;
    ULONG                       m_NextColumnIndex;
    TOutput &                   m_out;
    const FixedTableHeap *      m_pShippedSchemaHeap;
    eParsingState               m_State;

    CComQIPtr<IAdvancedTableDispenser, &IID_IAdvancedTableDispenser> m_spISTAdvancedDispenser;
    CComPtr<ISimpleTableRead2>      m_spISTTagMeta;
    CComPtr<ISimpleTableRead2>      m_spISTColumnMeta;
    CComPtr<ISimpleTableRead2>      m_spISTColumnMetaByID;
    CComPtr<ISimpleTableRead2>      m_spISTTableMeta;

    TPooledHeap                 m_HeapPooledUserDefinedID;
    ULONG                       m_ipoolPrevUserDefinedID;
    LPCWSTR                     m_wszXmlFile;

    //
    //Private methods
    //
    void            AddColumnMetaByReference(ULONG iColumnMeta_Source);
    void            AddColumnMetaToHeap(const TElement &i_Element, ULONG i_iColumnInternalName);
    void            AddColumnMetaViaReferenceToHeap(const TElement &i_Element);
    ULONG           AddMergedContainerClassListToList(const TSizedString *i_pContainerClassList, LPCWSTR i_wszContainerClassListShipped, ULONG i_cchContainerClassListShipped, bool &o_bExtended);
    void            AddServerWiringMetaToHeap(ULONG iTableName, bool i_bFixedInterceptor=false);
    void            AddShippedColumnMetaToHeap(ULONG i_iTableName, const ColumnMeta *i_pColumnMeta);
    void            AddShippedIndexMetaToHeap(ULONG i_iTableName, const IndexMeta *i_pIndexMeta);
    void            AddShippedTableMetaToHeap(const TableMeta *i_pTableMeta, bool i_bFixedInterceptor=false, const TSizedString *i_pContainerClassList=0);
    void            AddShippedTagMetaToHeap(ULONG i_iTableName, ULONG i_iColumnIndex, const TagMeta *i_pTagMeta);
    ULONG           AddStringToHeap(const TSizedString &i_str);
    void            AddTableMetaToHeap(const TElement &i_Element);
    void            AddTagMetaToHeap(const TElement &i_Element);
    unsigned long   AddUI4ToList(ULONG ui4);
    unsigned long   AddWCharToList(LPCWSTR wsz, unsigned long cwchar=-1);
    void            BuildDatabaseMeta(const DatabaseMeta * &o_pDatabaseMeta_METABASE);
    void            CheckForOverrridingColumnMeta(const TElement &i_Element, ULONG i_iColumnMetaToOverride);
    void            ConvertWideCharsToBytes(LPCWSTR string, unsigned char *pBytes, unsigned long length);
    ULONG           FindUserDefinedPropertyBy_Table_And_InternalName(unsigned long Table, unsigned long  InternalName);
    const TOLEDataTypeToXMLDataType * Get_OLEDataTypeToXMLDataType(const TSizedString &i_str);
    const TAttr &   GetAttribute(const TElement &i_Element, const TSizedString &i_AttrName);
    ULONG           GetDefaultValue(const TElement &i_Element, ColumnMeta & columnmeta);
    void            PresizeHeaps();
    bool            ShouldAddColumnMetaToHeap(const TElement &Element, ULONG iColumnInternalName);
    ULONG           StringToEnumValue(const TSizedString &i_strValue, LPCWSTR i_wszTable, ULONG i_iColumn, bool bAllowNumeric=false);
    ULONG           StringToFlagValue(const TSizedString &i_strValue, LPCWSTR i_wszTable, ULONG i_iColumn);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tmetainferrence.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

LPCWSTR TMetaInferrence::m_szNameLegalCharacters =L"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
LPCWSTR TMetaInferrence::m_szPublicTagLegalCharacters  =L"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789[]";

void TMetaInferrence::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup    = &fixup;
    m_pOut      = &out;

    m_iZero = m_pFixup->AddUI4ToList(0);//we need this all over the place so add it here then use the index where needed

    //Ordering here is important since TableMeta sets some flags according to how the ColumnMeta flags are set; but some ColumnMeta flags are inferred.
    InferTagMeta();
    InferColumnMeta();
    InferQueryMeta();
    InferIndexMeta();
    InferRelationMeta();
    InferServerWiringMeta();
    InferTableMeta();
    InferDatabaseMeta();
}

void TMetaInferrence::InferColumnMeta()
{
    //CompositeOfMetaFlags is used if at least one PK is declared per table, and to verify that no more than one NameColumn
    //and no more than one NavColumn are declared per table.
    ULONG CompositeOfMetaFlags=(fCOLUMNMETA_PRIMARYKEY | fCOLUMNMETA_NAMECOLUMN | fCOLUMNMETA_NAVCOLUMN);
    ULONG CompositeOfSchemaGeneratorFlags=(fCOLUMNMETA_USEASPUBLICROWNAME);
    ULONG PreviousTable=0;


    for(unsigned long iColumnMeta=0; iColumnMeta<m_pFixup->GetCountColumnMeta(); ++iColumnMeta)
    {
        ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta);

        //Inference Rule 3.a.i.
            //The TableMeta.InternalName of the parent XML element determines Table to which the column belongs.
        //This should have already happened, ASSERT that it has.
        ASSERT(0 != pColumnMeta->Table);


        //Inference Rule 3.b.i.
            //The first ColumnMeta element encountered under each table is set to Index 0.  Each successive ColumnMeta element has an Index value one greater than the previous ColumnMeta.Index.
        //This should have already happened, ASSERT that it has.
        ASSERT(0 != pColumnMeta->Index);


        //Inference Rule 3.c.i.
            //ColumnMeta.InternalName is a primary key so it must not be NULL.
        if(0 == pColumnMeta->InternalName)
        {
            m_pOut->printf(L"Validation Error in ColumnMeta for Table (%s). ColumnMeta.InternalName is a primarykey, so it must not be NULL.", m_pFixup->StringFromIndex(pColumnMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }


        //Inference Rule 3.c.ii.
            //ColumnMeta.InternalName should be validated to be a legal C++ variable name.
        ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pColumnMeta->InternalName));


        //Inference Rule 3.d.i.
            //ColumnMeta PublicName is set to be the same as the ColumnMeta.InternalName if one is not supplied.
        if(0 == pColumnMeta->PublicName)
        {
            pColumnMeta->PublicName = pColumnMeta->InternalName;
        }
        else
        {
            //Inference Rule 3.d.ii.
                //ColumnMeta.PublicName should be validated to be a legal C++ variable name.
            ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pColumnMeta->PublicName));
        }


        //Inference Rule 3.e.i.
            //Type is specified as a string and is mapped according to its TagMeta.
        //This should have already happened, ASSERT that it has.
        ASSERT(0 != pColumnMeta->Type);


        //Inference Rule 3.f.i.
            //Size is defaulted to -1 if the ColumnMeta.Type is DBTYPE_STRING or DBTYPE_BYTES (or equivalent) and no Size is supplied.
        ASSERT(0 != pColumnMeta->Size);//There is a mapping that is handled at XML read time that deals with this

        //Inference Rule 3.g.i.1 - Also See Below
            //fCOLUMNMETA_PRIMARYKEY  must be set on at least one column per table.
        if(PreviousTable != pColumnMeta->Table)
        {
            if(0 == (CompositeOfMetaFlags & fCOLUMNMETA_PRIMARYKEY))
            {
                m_pOut->printf(L"Error - Table (%s) has no primarykey.  fCOLUMNMETA_PRIMARYKEY must be set on at least one column per table", m_pFixup->StringFromIndex(PreviousTable));
                THROW(ERROR - VALIDATION ERROR);
            }
            CompositeOfMetaFlags = 0;//We scanning a new table so start with no flags set
            CompositeOfSchemaGeneratorFlags = 0;
        }

        //Inference Rule 3.g.ii.1  - This is handled in RelationMeta inferrence
            //fCOLUMNMETA_FOREIGNKEY  is set when the table is listed as a RelationMeta.ForeignTable and the column is listed as one of the RelationMeta.ForeignColumns.


        //Inference Rule 3.g.iii.1
            //Only one NameColumn may be specified per table.
        ULONG MetaFlags = m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags);
        if((MetaFlags & fCOLUMNMETA_NAMECOLUMN) && (CompositeOfMetaFlags & fCOLUMNMETA_NAMECOLUMN))
        {
            m_pOut->printf(L"Error - Table (%s) has more than one NameColumn", m_pFixup->StringFromIndex(pColumnMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 3.g.iv.1
            //Only one NavColumn may be specified per table.
        if((MetaFlags & fCOLUMNMETA_NAVCOLUMN) && (CompositeOfMetaFlags & fCOLUMNMETA_NAVCOLUMN))
        {
            m_pOut->printf(L"Error - Table (%s) has more than one NavColumn", m_pFixup->StringFromIndex(pColumnMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 3.g.vi.1
            //fCOLUMNMETA_ FLAG must only be set if the ColumnMeta.Type is DBTYPE_UI4 or DWORD_METADATA.
        if((MetaFlags & fCOLUMNMETA_FLAG) && m_pFixup->UI4FromIndex(pColumnMeta->Type)!=static_cast<ULONG>(DBTYPE_UI4) && m_pFixup->UI4FromIndex(pColumnMeta->Type)!=static_cast<ULONG>(DWORD_METADATA))
        {
            m_pOut->printf(L"Error - Table (%s) Column (%s) - fCOLUMNMETA_FLAG must only be set on UI4 columns", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 3.g.vii.1
            //fCOLUMNMETA_ ENUM must only be set if the ColumnMeta.Type is DBTYPE_UI4 or DWORD_METADATA.
        if((MetaFlags & fCOLUMNMETA_ENUM) && m_pFixup->UI4FromIndex(pColumnMeta->Type)!=static_cast<ULONG>(DBTYPE_UI4) && m_pFixup->UI4FromIndex(pColumnMeta->Type)!=static_cast<ULONG>(DWORD_METADATA))
        {
            m_pOut->printf(L"Error - Table (%s) Column (%s) - fCOLUMNMETA_ENUM must only be set on UI4 columns", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 3.g.xx.1
            //fCOLUMNMETA_NOTNULLABLE is set if fCOLUMNMETA_PRIMARYKEY is set.
        if(MetaFlags & fCOLUMNMETA_PRIMARYKEY)
            MetaFlags |= fCOLUMNMETA_NOTNULLABLE;

        //Inference Rule 3.g.xxviii.1
            //fCOLUMNMETA_UNKNOWNSIZE bit is set when ColumnMeta.Type is BYTES and ColumnMeta.Size is -1.
        if(m_pFixup->UI4FromIndex(pColumnMeta->Size)==-1 && (m_pFixup->UI4FromIndex(pColumnMeta->Type)==DBTYPE_BYTES || m_pFixup->UI4FromIndex(pColumnMeta->Type)==BINARY_METADATA))
            MetaFlags |= fCOLUMNMETA_UNKNOWNSIZE;


        //Inference Rule 3.g.xxi.1
            //fCOLUMNMETA_FIXEDLENGTH is set if Size it not -1
        if(-1 != m_pFixup->UI4FromIndex(pColumnMeta->Size))
            MetaFlags |= fCOLUMNMETA_FIXEDLENGTH;


        //Inference Rule 3.j.i.1
            //ColumnMeta.StartingNumber is defaulted to 0 if none is supplied.
        if(0 == pColumnMeta->StartingNumber)
            pColumnMeta->StartingNumber = m_iZero;


        //Inference Rule 3.k.i.1
            //ColumnMeta.EndingNumber is defaulted to 0xFFFFFFFF if none is supplied.
        if(0 == pColumnMeta->EndingNumber)
            pColumnMeta->EndingNumber = m_pFixup->AddUI4ToList((ULONG)-1);


        //Inference Rule 3.g.xxii.1
            //fCOLUMNMETA_HASNUMERICRANGE is set if the Type is UI4 and, StartingNumber is not 0 or EndingNumber is not 0xFFFFFFFF.
        if( ((m_pFixup->UI4FromIndex(pColumnMeta->Type) == DBTYPE_UI4 || m_pFixup->UI4FromIndex(pColumnMeta->Type) == DWORD_METADATA)) &&
            ((m_pFixup->UI4FromIndex(pColumnMeta->StartingNumber)!=0   || m_pFixup->UI4FromIndex(pColumnMeta->EndingNumber)!=-1)))
            MetaFlags |= fCOLUMNMETA_HASNUMERICRANGE;


        //Inference Rule 3.g.xxix.1
            //fCOLUMNMETA_VARIABLESIZE bit is set when fCOLUMNMETA_FIXEDLENGTH is not set.
        if(0 == (fCOLUMNMETA_FIXEDLENGTH & MetaFlags))
            MetaFlags |= fCOLUMNMETA_VARIABLESIZE;



        //Inference Rule 3.i.i - See Below
            //FlagMask is the ORing of all of the TagMeta when fCOLUMNMETA_FLAG is set.  Otherwise it is defaulted to 0.
        //Inference Rule 3.j.i.1 - See Above
            //ColumnMeta.StartingNumber is defaulted to 0 if none is supplied.
        //Inference Rule 3.k.i.1 - See Above
            //ColumnMeta.EndingNumber is defaulted to 0xFFFFFFFF if none is supplied.



        //Inference Rule 3.m.i.1
            //fCOLUMNMETA_USEASPUBLICROWNAME should only be set on column whose MetaFlags fCOLUMNMETA_ENUM bit is set.
        ASSERT(0 != pColumnMeta->SchemaGeneratorFlags);
        if((m_pFixup->UI4FromIndex(pColumnMeta->SchemaGeneratorFlags)&fCOLUMNMETA_USEASPUBLICROWNAME) &&
            0==(m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags)&fCOLUMNMETA_ENUM))
        {
            m_pOut->printf(L"Error - Table (%s) - USEASPUBLICROWNAME was set on a non ENUM Column (%s)", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }

        ULONG SchemaGeneratorFlags = m_pFixup->UI4FromIndex(pColumnMeta->SchemaGeneratorFlags);
        //Inference Rule 3.m.i.2
            //Only one column can be marked as fCOLUMNMETA_USEASPUBLICROWNAME
        if((SchemaGeneratorFlags & fCOLUMNMETA_USEASPUBLICROWNAME) && (CompositeOfSchemaGeneratorFlags & fCOLUMNMETA_USEASPUBLICROWNAME))
        {
            m_pOut->printf(L"Error - Table (%s) has more than one PublicRowNameColumn", m_pFixup->StringFromIndex(pColumnMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 3.m.xi.2
            //XMLBLOB columns may not also be marked as PRIMARYKEY or NOTPERSISTABLE
        if((SchemaGeneratorFlags & fCOLUMNMETA_XMLBLOB) && (MetaFlags & fCOLUMNMETA_PRIMARYKEY))
        {
            m_pOut->printf(L"Error - Table (%s) has XMLBLOB column (%s) marked as the PrimaryKey", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }



        //Inference Rule 3.n.i
            //ciTagMeta is the count of TagMeta whose Table equals ColumnMeta.Table.
        //Inference Rule 3.o.i
            //iTagMeta is an index to the first TagMeta whose Table equals ColumnMeta.Table and whose ColumnIndex equals ColumnMeta.Index.  Or zero if no tags exist for this column.
        pColumnMeta->iTagMeta   = 0;
        pColumnMeta->ciTagMeta  = 0;
        pColumnMeta->FlagMask   = m_iZero;
        if(MetaFlags & (fCOLUMNMETA_ENUM | fCOLUMNMETA_FLAG))
        {
            //Inference Rule 3.o.i
                //iTagMeta is an index to the first TagMeta whose Table equals ColumnMeta.Table and whose ColumnIndex equals ColumnMeta.Index.  Or zero if no tags exist for this column.
            for(pColumnMeta->iTagMeta = 0;pColumnMeta->iTagMeta<m_pFixup->GetCountTagMeta();++pColumnMeta->iTagMeta)
            {
                if( m_pFixup->TagMetaFromIndex(pColumnMeta->iTagMeta)->Table == pColumnMeta->Table &&
                    m_pFixup->TagMetaFromIndex(pColumnMeta->iTagMeta)->ColumnIndex == pColumnMeta->Index)
                    break;
            }
            if(pColumnMeta->iTagMeta==m_pFixup->GetCountTagMeta())
            {
                m_pOut->printf(L"Error - Table (%s) - No TagMeta found for Column (%s)", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
                THROW(ERROR - VALIDATION ERROR);
            }

            //Inference Rule 3.n.i
                //ciTagMeta is the count of TagMeta whose Table equals ColumnMeta.Table and whose ColumnIndex equals ColumnMeta.Index.
            ULONG iTagMeta = pColumnMeta->iTagMeta;
            ULONG FlagMask = 0;
            for(;iTagMeta<m_pFixup->GetCountTagMeta()
                && m_pFixup->TagMetaFromIndex(iTagMeta)->Table == pColumnMeta->Table
                && m_pFixup->TagMetaFromIndex(iTagMeta)->ColumnIndex == pColumnMeta->Index;++iTagMeta, ++pColumnMeta->ciTagMeta)
                FlagMask |= m_pFixup->UI4FromIndex(m_pFixup->TagMetaFromIndex(iTagMeta)->Value);

            //Inference Rule 3.i.i - See Above for defaulting to 0
                //FlagMask is the ORing of all of the TagMeta when fCOLUMNMETA_FLAG is set.  Otherwise it is defaulted to 0.
            if(MetaFlags & fCOLUMNMETA_FLAG)
                pColumnMeta->FlagMask = m_pFixup->AddUI4ToList(FlagMask);
        }


        pColumnMeta->MetaFlags = m_pFixup->AddUI4ToList(MetaFlags);

        CompositeOfMetaFlags |= MetaFlags;
        CompositeOfSchemaGeneratorFlags |= SchemaGeneratorFlags;
        PreviousTable = pColumnMeta->Table;

        //Inference Rule 3.q
        if(0 == pColumnMeta->ID)
            pColumnMeta->ID = m_iZero;
        //Inference Rule 3.r
        if(0 == pColumnMeta->UserType)
            pColumnMeta->UserType = m_iZero;
        //Inference Rule 3.s
        ASSERT(0 != pColumnMeta->Attributes);//Attributes is a flag and should already be defaulted to zero

		//Inference Rule 3.t.i.
		// PublicColumnName is same as PublicName if not specified
		if(0 == pColumnMeta->PublicColumnName)
		{
			pColumnMeta->PublicColumnName = pColumnMeta->PublicName;
		}
		else
		{
			//Inference Rule 3.t.ii.
			//ColumnMeta.PublicColumnName should be validated to be a legal C++ variable name.
			ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pColumnMeta->PublicColumnName));
		}
    }

    //Inference Rule 3.g.i.1.
        //fCOLUMNMETA_PRIMARYKEY  must be set on at least one column per table.
    //The last table in the ColumnMeta list will exit the for loop before we get to check this.  So check it now.
    if(0 == (CompositeOfMetaFlags & fCOLUMNMETA_PRIMARYKEY))
    {
        m_pOut->printf(L"Error - Table (%s) has no primarykey.  fCOLUMNMETA_PRIMARYKEY must be set on at least one column per table", m_pFixup->StringFromIndex(m_pFixup->ColumnMetaFromIndex(PreviousTable)->Table));
        THROW(ERROR - VALIDATION ERROR);
    }

}


void TMetaInferrence::InferDatabaseMeta()
{
    for(unsigned long i=0; i<m_pFixup->GetCountDatabaseMeta(); ++i)
    {
        DatabaseMeta *pDatabaseMeta = m_pFixup->DatabaseMetaFromIndex(i);

        //Inference Rule 1.a.i.
            //DatabaseMeta.InternalName is a primarykey, so it must not be NULL.
        if(0 == pDatabaseMeta->InternalName)
        {
            m_pOut->printf(L"Validation Error in DatabaseMeta Row %d. DatabaseMeta.InternalName is a primarykey, so it must not be NULL.", i);
            THROW(ERROR - VALIDATION ERROR);
        }

        //Infereence Rule 1.a.ii.
            //DatabaseMeta.InternalName should be validated to be a legal C++ variable name.
        ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pDatabaseMeta->InternalName));


        //Infereence Rule 1.a.iii.
            //DatabaseMeta.InternalName should be no more than 16 characters (including the terminating NULL).
        if(wcslen(m_pFixup->StringFromIndex(pDatabaseMeta->InternalName))>15)
        {
            m_pOut->printf(L"Error - DatabaseMeta.InternalName (%s) is too long.  Must be 15 characters or less.", m_pFixup->StringFromIndex(pDatabaseMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 1.b.i.
            //DatabaseMeta.PublicName should be inferred from DatabaseMeta.InternalName if not supplied.
        if(0 == pDatabaseMeta->PublicName)
        {
            pDatabaseMeta->PublicName = pDatabaseMeta->InternalName;
        }
        else
        {
            //Inference Rule 1.b.ii.
                //DatabaseMeta.PublicName should be validated to be a legal C++ variable name.
            ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pDatabaseMeta->PublicName));
        }


        //Inference Rule 1.c.i.
            //DatabaseMeta.BaseVersion should be defaulted to zero if not specified.
        if(0 == pDatabaseMeta->BaseVersion)
            pDatabaseMeta->BaseVersion = m_iZero;


        //Inference Rule 1.d.i.
            //DatabaseMeta.ExtendedVersion should be defaulted to zero if not specified.
        if(0 == pDatabaseMeta->ExtendedVersion)
            pDatabaseMeta->ExtendedVersion = m_iZero;


        //Inference Rule 1.j.i.
            //DatabaseMeta.iTableMeta is an index to the first table whose Database matches the DatabaseMeta.InternalName.
        ASSERT(0 == pDatabaseMeta->iTableMeta);
        pDatabaseMeta->iTableMeta = 0;
        for(pDatabaseMeta->iTableMeta = 0;pDatabaseMeta->iTableMeta<m_pFixup->GetCountTableMeta();++pDatabaseMeta->iTableMeta)
        {
            if(m_pFixup->TableMetaFromIndex(pDatabaseMeta->iTableMeta)->Database == pDatabaseMeta->InternalName)
                break;//exit on the first occurance of a table within this database
        }

        //Inference Rule 1.j.ii.
            //DatabaseMeta.iTableMeta must have a legal value (between 0 and total number of TableMeta).
        if(pDatabaseMeta->iTableMeta == m_pFixup->GetCountTableMeta())
        {
            m_pOut->printf(L"Error - No tables belong to Database (%s)", m_pFixup->StringFromIndex(pDatabaseMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 1.e.i.
            //DatabaseMeta.CountOfTables should be inferred from the number of TableMeta whose Database column is equal to DatabaseMeta.InternalName.
        ASSERT(0 == pDatabaseMeta->CountOfTables);//This should not be filled in yet.  In Retail build, if it is, we'll overwrite it.
        pDatabaseMeta->CountOfTables = 0;
        for(unsigned long iTableMeta=pDatabaseMeta->iTableMeta;iTableMeta<m_pFixup->GetCountTableMeta();++iTableMeta)
        {
            if(m_pFixup->TableMetaFromIndex(iTableMeta)->Database == pDatabaseMeta->InternalName)
                ++pDatabaseMeta->CountOfTables;
            else if(pDatabaseMeta->CountOfTables != 0)//If we already saw the first Table in this database, then we're done (since all tables within a database
                break;                              //are contiguously located).
        }
        pDatabaseMeta->CountOfTables = m_pFixup->AddUI4ToList(pDatabaseMeta->CountOfTables);

        //f.    iSchemaBlob     Compilation Plugin
        //g.    cbSchemaBlob    Compilation Plugin
        //h.    iNameHeapBlob   Compilation Plugin
        //i.    cbNameHeapBlob  Compilation Plugin

        //Inference Rule 1.j.i. - See above - This rule is executed before 1.e.i.
            //DatabaseMeta.iTableMeta is an index to the first table whose Database matches the DatabaseMeta.InternalName.

        //Inference Rule 1.j.ii. - See above - This rule is executed before 1.e.i.
            //DatabaseMeta.iTableMeta must have a legal value (between 0 and total number of TableMeta).

        //k     iGuidDid        Compilation Plugin
    }
}

void TMetaInferrence::InferIndexMeta()
{
    for(unsigned long iIndexMeta=0; iIndexMeta<m_pFixup->GetCountIndexMeta(); ++iIndexMeta)
    {
        IndexMeta *pIndexMeta = m_pFixup->IndexMetaFromIndex(iIndexMeta);

        //Inference Rule 5.a.i.
            //IndexMeta.Table is a primary key so it must not be NULL.
        //This should have already happened, ASSERT that it has.
        ASSERT(0 != pIndexMeta->Table);


        //Inference Rule 5.b.i.
            //IndexMeta.InternalName is a primary key so it must not be NULL.
        ASSERT(0 != pIndexMeta->InternalName);


        //Inference Rule 5.b.ii.
            //IndexMeta.InternalName should be validated to be a legal C++ variable name.
        ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pIndexMeta->InternalName));


        //Inference Rule 5.c.i.
            //IndexMeta.PublicName is inferred from the IndexMeta.InternalName if one is not supplied.
        if(0 == pIndexMeta->PublicName)
        {
            pIndexMeta->PublicName = pIndexMeta->InternalName;
        }
        else
        {
            //Inference Rule 5.c.ii.
                //IndexMeta.PublicName should be validated to be a legal C++ variable name.
            ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pIndexMeta->PublicName));
        }


        //Inference Rule 5.d.i.-See Below
            //ColumnIndex is the ColumnMeta.Index whose Table matches IndexMeta.Table and whose InternalName matches IndexMeta.ColumnInternalName.
        //Inference Rule 5.e.i.
            //There must exist a ColumnMeta whose Table matches IndexMeta.Table and whose InternalName matches IndexMeta.ColumnInternalName.
        ULONG iColumnMeta;
        for(iColumnMeta=0;iColumnMeta<m_pFixup->GetCountColumnMeta();++iColumnMeta)
        {
            ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta);
            if( pColumnMeta->InternalName == pIndexMeta->ColumnInternalName &&
                pColumnMeta->Table == pIndexMeta->Table)
                break;
        }
        if(m_pFixup->GetCountColumnMeta() == iColumnMeta)
        {
            m_pOut->printf(L"Error in IndexMeta - Table (%s), No ColumnMeta.InternalName matches IndexMeta ColumnInternalName (%s)", m_pFixup->StringFromIndex(pIndexMeta->Table), m_pFixup->StringFromIndex(pIndexMeta->ColumnInternalName));
            THROW(ERROR - VALIDATION ERROR);
        }


        //Inference Rule 5.d.i.-See Below
            //ColumnIndex is the ColumnMeta.Index whose Table matches IndexMeta.Table and whose InternalName matches IndexMeta.ColumnInternalName.
        pIndexMeta->ColumnIndex = m_pFixup->ColumnMetaFromIndex(iColumnMeta)->Index;

        //Inference Rule 5.f.
            //MetaFlags is defaulted to zero of not supplied.
        if(0 == pIndexMeta->MetaFlags)
            pIndexMeta->MetaFlags = m_iZero;
    }
}

void TMetaInferrence::InferQueryMeta()
{
    for(unsigned long iQueryMeta=0; iQueryMeta<m_pFixup->GetCountQueryMeta(); ++iQueryMeta)
    {
        QueryMeta *pQueryMeta = m_pFixup->QueryMetaFromIndex(iQueryMeta);

        //Inference Rule 6.a.i.
            //QueryMeta.Table is a primary key so it must not be NULL.
        //This should have already happened, ASSERT that it has.
        ASSERT(0 != pQueryMeta->Table);

        //Inference Rule 6.b.i.
            //QueryMeta.InternalName is a primary key so it must not be NULL.
        //This should have already happened, ASSERT that it has.
        ASSERT(0 != pQueryMeta->InternalName);


        //Inference Rule 6.b.ii.
            //QueryMeta.InternalName should be validated to be a legal C++ variable name.
        ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pQueryMeta->InternalName));


        //Inference Rule 6.c.i.
            //QueryMeta.PublicName is inferred from the QueryMeta.InternalName if one is not supplied.
        if(0 == pQueryMeta->PublicName)
        {
            pQueryMeta->PublicName = pQueryMeta->InternalName;
        }
        else
        {
            //Inference Rule 6.c.ii.
                //QueryMeta.PublicName should be validated to be a legal C++ variable name.
            ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pQueryMeta->PublicName));
        }

        //Inference Rule 6.e.i.
            //CellName is defaulted to L"" is not supplied.
        if(0 == pQueryMeta->CellName)
        {
            pQueryMeta->CellName = m_pFixup->AddWCharToList(L"");
        }

        //Inference Rule 6.e.ii.
            //If CellName is provided and CellName is not CellName equals L"__FILE", it must match a ColumnMeta whose InternalName and a ColumnMeta.Table must match the QueryMeta.Table.
        if(pQueryMeta->CellName != m_pFixup->FindStringInPool(L"") && pQueryMeta->CellName != m_pFixup->FindStringInPool(L"__FILE"))
        {
            ULONG iColumnMeta;
            for(iColumnMeta=0;iColumnMeta<m_pFixup->GetCountColumnMeta();++iColumnMeta)
            {
                ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta);
                if( pColumnMeta->Table == pQueryMeta->Table &&
                    pColumnMeta->InternalName == pQueryMeta->CellName)
                    break;
            }
            if(m_pFixup->GetCountColumnMeta() == iColumnMeta)
            {
                m_pOut->printf(L"Error in QueryMeta - Table (%s), No ColumnMeta.InternalName matches QueryMeta CellName (%s)", m_pFixup->StringFromIndex(pQueryMeta->Table), m_pFixup->StringFromIndex(pQueryMeta->CellName));
                THROW(ERROR - VALIDATION ERROR);
            }
        }


        //Inference Rule 6.f.i.
            //Operator is set to 'EQUAL" (zero) if not supplied.
        if(0 == pQueryMeta->Operator)
            pQueryMeta->Operator = m_iZero;


        //Inference Rule 6.g.
            //MetaFlags is set to zero is not supplied.
        if(0 == pQueryMeta->MetaFlags)
            pQueryMeta->MetaFlags = m_iZero;
    }
}


//@@@ What happens if the PrimaryTable and ForeignTable are the same?
void TMetaInferrence::InferRelationMeta()
{
    for(unsigned long iRelationMeta=0; iRelationMeta<m_pFixup->GetCountRelationMeta(); ++iRelationMeta)
    {
        RelationMeta *pRelationMeta = m_pFixup->RelationMetaFromIndex(iRelationMeta);

        //Inference Rule 7.a.i.
            //PrimaryTable must not be NULL and must match a TableMeta.InternalName.
        if(0 == pRelationMeta->PrimaryTable)
        {
            m_pOut->printf(L"Error in RelationMeta Row (%s) - PrimaryTable must exist.", iRelationMeta);
            THROW(ERROR - VALIDATION ERROR);
        }
        ULONG iPrimaryTable = m_pFixup->FindTableBy_TableName(pRelationMeta->PrimaryTable);
        if(-1 == iPrimaryTable)
        {
            m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s) not found in TableMeta", m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable));
            THROW(ERROR - VALIDATION ERROR);
        }


        //Inference Rule 7.b.i.
            //There must be as many PrimaryColumns as there are primary keys in the primary table.
        if(0 == pRelationMeta->PrimaryColumns)
        {
            m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s) has no PrimaryColumns entry", m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable));
            THROW(ERROR - VALIDATION ERROR);
        }
        ULONG cPrimaryKeysInPrimaryTable=0;
        ULONG iColumnMeta = m_pFixup->FindColumnBy_Table_And_Index(m_pFixup->TableMetaFromIndex(iPrimaryTable)->InternalName, m_iZero);
        ULONG iColumnMeta_PrimaryTable = iColumnMeta;//This is used below 7.d.i
        for(;m_pFixup->ColumnMetaFromIndex(iColumnMeta)->Table == m_pFixup->TableMetaFromIndex(iPrimaryTable)->InternalName;++iColumnMeta)
        {
            ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta);
            if(fCOLUMNMETA_PRIMARYKEY & m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags))
                ++cPrimaryKeysInPrimaryTable;
        }
        if(cPrimaryKeysInPrimaryTable != m_pFixup->BufferLengthFromIndex(pRelationMeta->PrimaryColumns)/sizeof(ULONG))
        {
            m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s) has (%d) PrimaryColumns but (%d) were supplied", m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), cPrimaryKeysInPrimaryTable, m_pFixup->BufferLengthFromIndex(pRelationMeta->PrimaryColumns)/sizeof(ULONG));
            THROW(ERROR - VALIDATION ERROR);
        }


        //Inference Rule 7.c.i.
            //ForeignTable must not be NULL and must match a TableMeta.InternalName.
        if(0 == pRelationMeta->ForeignTable)
        {
            m_pOut->printf(L"Error in RelationMeta Row (%s) - ForeignTable must exist.", iRelationMeta);
            THROW(ERROR - VALIDATION ERROR);
        }
        ULONG iForeignTable = m_pFixup->FindTableBy_TableName(pRelationMeta->ForeignTable);
        if(-1 == iForeignTable)
        {
            m_pOut->printf(L"Error in RelationMeta - ForeignTable (%s) not found in TableMeta", m_pFixup->StringFromIndex(pRelationMeta->ForeignTable));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 7.d.i.
            //There must be as many ForeignColumns as there are primary keys in the primary table.
        if(0 == pRelationMeta->ForeignColumns)
        {
            m_pOut->printf(L"Error in RelationMeta - ForeignTable (%s) has no ForeignColumns entry", m_pFixup->StringFromIndex(pRelationMeta->ForeignTable));
            THROW(ERROR - VALIDATION ERROR);
        }
        if(cPrimaryKeysInPrimaryTable != m_pFixup->BufferLengthFromIndex(pRelationMeta->ForeignColumns)/sizeof(ULONG))
        {
            m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s) has (%d) PrimaryColumns but (%d) ForeignColumns were supplied", m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), cPrimaryKeysInPrimaryTable, m_pFixup->BufferLengthFromIndex(pRelationMeta->ForeignColumns)/sizeof(ULONG));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 7.e.
            //MetaFlags 	DefaultValue (0)
        if(0 == pRelationMeta->MetaFlags)
            pRelationMeta->MetaFlags = m_iZero;

        //Inference Rule 7.e.i.1.
            //fRELATIONMETA_USECONTAINMENT There can be only one containment relationship per ForeignTable.
        //@@@ TODO

        //Inference Rule 7.e.ii.1.
            //fRELATIONMETA_CONTAINASSIBLING Tables marked with this flag should infer the USECONTAINMENT flag.
        if((m_pFixup->UI4FromIndex(pRelationMeta->MetaFlags) & (fRELATIONMETA_CONTAINASSIBLING | fRELATIONMETA_USECONTAINMENT))
                    == fRELATIONMETA_CONTAINASSIBLING)//if CONTAINASSIBLING is set but USECONTAINMENT is NOT, then infer USECONTAINMENT
        {
            pRelationMeta->MetaFlags = m_pFixup->AddUI4ToList(m_pFixup->UI4FromIndex(pRelationMeta->MetaFlags) |
                            fRELATIONMETA_USECONTAINMENT);
        }

        ULONG iColumnMeta_ForeignTable = m_pFixup->FindColumnBy_Table_And_Index(m_pFixup->TableMetaFromIndex(iForeignTable)->InternalName, m_iZero);
        for(ULONG iPK=0;iPK<cPrimaryKeysInPrimaryTable;++iPK)
        {
            ULONG iForeignKey = reinterpret_cast<const ULONG *>(m_pFixup->ByteFromIndex(pRelationMeta->ForeignColumns))[iPK];
            ULONG iPrimaryKey = reinterpret_cast<const ULONG *>(m_pFixup->ByteFromIndex(pRelationMeta->PrimaryColumns))[iPK];

            ColumnMeta *pColumnMeta_ForeignKey = m_pFixup->ColumnMetaFromIndex(iColumnMeta_ForeignTable + iForeignKey);
            ColumnMeta *pColumnMeta_PrimaryKey = m_pFixup->ColumnMetaFromIndex(iColumnMeta_PrimaryTable + iPrimaryKey);

            //Inference Rule 7.d.ii.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.Type.
            if(pColumnMeta_ForeignKey->Type != pColumnMeta_PrimaryKey->Type)
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.Type mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }


            //Inference Rule 7.d.iii.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.Size.
            if(pColumnMeta_ForeignKey->Size != pColumnMeta_PrimaryKey->Size)
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.Size mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }


            //Inference Rule 7.d.iv.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.FlagMask.
            if(pColumnMeta_ForeignKey->FlagMask != pColumnMeta_PrimaryKey->FlagMask)
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.FlagMask mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }


            //Inference Rule 7.d.v.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.StartingNumber.
            if(pColumnMeta_ForeignKey->StartingNumber != pColumnMeta_PrimaryKey->StartingNumber)
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.StartingNumber mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }


            //Inference Rule 7.d.vi.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.EndingNumber.
            if(pColumnMeta_ForeignKey->EndingNumber != pColumnMeta_PrimaryKey->EndingNumber)
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.EndingNumber mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }


            //Inference Rule 7.d.vii.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.CharacterSet.
            if(pColumnMeta_ForeignKey->CharacterSet != pColumnMeta_PrimaryKey->CharacterSet)
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.CharacterSet mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }


            //Inference Rule 7.d.viii.
                //Each ForeignColumn must map to a PriomaryColumn of the same ColumnMeta.MetaFlags set (fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_HASNUMERICRANGE |fCOLUMNMETA_LEGALCHARSET | fCOLUMNMETA_ILLEGALCHARSET | fCOLUMNMETA_NOTPERSISTABLE | fCOLUMNMETA_MULTISTRING | fCOLUMNMETA_EXPANDSTRING | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE)
            ULONG FlagsThatMustMatch = (fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_FIXEDLENGTH | fCOLUMNMETA_HASNUMERICRANGE |fCOLUMNMETA_LEGALCHARSET | fCOLUMNMETA_ILLEGALCHARSET | fCOLUMNMETA_NOTPERSISTABLE | fCOLUMNMETA_MULTISTRING | fCOLUMNMETA_EXPANDSTRING | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE);
            if( (m_pFixup->UI4FromIndex(pColumnMeta_ForeignKey->MetaFlags)&FlagsThatMustMatch) !=
                (m_pFixup->UI4FromIndex(pColumnMeta_PrimaryKey->MetaFlags)&FlagsThatMustMatch))
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.MetaFlags mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }

            //Inference Rule 7.d.ix
                //If a containment relation, each ForeignColumn must map to a PrimaryColumn of the same ColumnMeta.MetaFags set (fCOLUMNMETA_NOTNULLABLE)
            FlagsThatMustMatch = (fCOLUMNMETA_NOTNULLABLE);
            if( (m_pFixup->UI4FromIndex(pRelationMeta->MetaFlags) & fRELATIONMETA_USECONTAINMENT) &&
                ((m_pFixup->UI4FromIndex(pColumnMeta_ForeignKey->MetaFlags)&FlagsThatMustMatch) !=
                 (m_pFixup->UI4FromIndex(pColumnMeta_PrimaryKey->MetaFlags)&FlagsThatMustMatch)) )
            {
                m_pOut->printf(L"Error in RelationMeta - PrimaryTable (%s), ForeignTable (%s) - ColumnMeta.MetaFlags mismatch between ForeignColumn / PrimaryColumn %dth PrimaryKey",
                                m_pFixup->StringFromIndex(pRelationMeta->PrimaryTable), m_pFixup->StringFromIndex(pRelationMeta->ForeignTable), iPK);
                THROW(ERROR - VALIDATION ERROR);
            }

            //Inference Rule 3.g.ii.1  - This is handled in RelationMeta inferrence
                //fCOLUMNMETA_FOREIGNKEY  is set when the table is listed as a RelationMeta.ForeignTable and the column is listed as one of the RelationMeta.ForeignColumns.
            pColumnMeta_ForeignKey->MetaFlags = m_pFixup->AddUI4ToList(m_pFixup->UI4FromIndex(pColumnMeta_ForeignKey->MetaFlags) | fCOLUMNMETA_FOREIGNKEY);
        }
    }
}


void TMetaInferrence::InferTableMeta()
{
    for(unsigned long i=0; i<m_pFixup->GetCountTableMeta(); ++i)
    {
        TableMeta *pTableMeta = m_pFixup->TableMetaFromIndex(i);

        //Inference Rule 2.a.i.
            //TableMeta XML elements exist as children of the Database under which they belong.  So Database is inferred from the parent DatabaseMeta.InternalName.
        ASSERT(0 != pTableMeta->Database);//This rule must have already been executed.  If not, it is a programming error.


        //Inference Rule 2.b.i.
            //TableMeta.InternalName is a primary key so it must not be NULL.
        if(0 == pTableMeta->InternalName)
        {
            m_pOut->printf(L"Validation Error in TableMeta Row %d. TableMeta.InternalName is a primarykey, so it must not be NULL.", i);
            THROW(ERROR - VALIDATION ERROR);
        }


        //Inference Rule 2.b.ii.
            //TableMeta.InternalName should be validated to be a legal C++ variable name.
        ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pTableMeta->InternalName));


        //Inference Rule 2.c.i.
            //TableMeta.PublicName is inferred from TableMeta.InternalName if not supplied.
        if(0 == pTableMeta->PublicName)
        {
            pTableMeta->PublicName = pTableMeta->InternalName;
        }
        else
        {
            //Inference Rule 2.c.ii.
                //TableMeta.PublicName should be validated to be a legal C++ variable name.
            ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pTableMeta->PublicName));
        }


        //Inference Rule 2.d.i.
            //PublicRowName is inferred from the PublicName if one is not supplied.  If the PublicName ends in 's', the PublicRowName is inferred as the PublicName without the 's'.  Otherwise the PublicRowName is 'A' followed by the PublicName.
        if(0 == pTableMeta->PublicRowName)
        {   //We no longer infer the public row name, is MUST be explicitly specified
            //pTableMeta->PublicRowName = InferPublicRowName(pTableMeta->PublicName);
        }


        //Inference Rule 2.e.i.
            //TableMeta.BaseVersion is defaulted to zero if none is supplied.
        if(0 == pTableMeta->BaseVersion)
            pTableMeta->BaseVersion = m_iZero;


        //Inference Rule 2.f.i.
            //TableMeta.ExtendedVersion is defaulted to zero if none is supplied.
        if(0 == pTableMeta->ExtendedVersion)
            pTableMeta->ExtendedVersion = m_iZero;


        //Inference Rule 2.p.i.
            //TableMeta.iColumnMeta is an index to the first ColumnMeta row whose Table matches the TableMeta.InternalName
        ASSERT(0 == pTableMeta->iColumnMeta);
        pTableMeta->iColumnMeta = 0;
        for(pTableMeta->iColumnMeta = 0;pTableMeta->iColumnMeta<m_pFixup->GetCountColumnMeta();++pTableMeta->iColumnMeta)
        {
            if(m_pFixup->ColumnMetaFromIndex(pTableMeta->iColumnMeta)->Table == pTableMeta->InternalName)
                break;//exit on the first occurance of a column within this table
        }

        //Inference Rule 2.i.i.
            //TableMeta.CountOfColumns is the count of ColumnMeta whose Table equals the TableMeta.InternalName
        ASSERT(0 == pTableMeta->CountOfColumns);
        while((pTableMeta->iColumnMeta + pTableMeta->CountOfColumns) < m_pFixup->GetCountColumnMeta() &&
            m_pFixup->ColumnMetaFromIndex(pTableMeta->iColumnMeta + pTableMeta->CountOfColumns)->Table == pTableMeta->InternalName)++pTableMeta->CountOfColumns;
        pTableMeta->CountOfColumns = m_pFixup->AddUI4ToList(pTableMeta->CountOfColumns);


        //Inference Rule 2.g.i.
            //TableMeta.NameColumn can be inferred from a column whose ColumnMeta.MetaFlags fCOLUMNMETA_NAMECOLUMN bit is set.  If no columns have this bit set,
            //it is the first primary key whole type is WSTR.  If no primary keys are of type WSTR, it is the first column of type WSTR.  If no columns
            //are of type WSTR, the NameColumn is set to be the TableMeta.NavColumn value.  Thus the NavColumn inferrence rule must be executed before
            //the NameColumn inferrence rule.
        //Inference Rule 2.h.i.
            //TableMeta.NavColumn can be inferred from a column whose ColumnMeta.MetaFlags fCOLUMNMETA_NAVCOLUMN bit is set.  If no columns have this bit set,
            //it is set to be the first primary key that is not also a foreign key.  If no column is a primary key that is not also a foreign key, the NavColumn
            //is set as the first primary key whose type is WSTR.  If none of the above conditions are met, the NavColumn is set as the first primary key.
        InferTableMeta_NameColumn_NavColumn(pTableMeta);

        ASSERT(0 != pTableMeta->MetaFlags);
        ULONG MetaFlags = m_pFixup->UI4FromIndex(pTableMeta->MetaFlags);

        ULONG fORingOfAllColumnMeta_MetaFlags = 0;
        ULONG fORingOfAllColumnMeta_SchemaGeneratorFlags = 0;
        bool  bPrimaryKey_MerkedAs_InsertUnique = false;
        for(ULONG iColumnMeta=0; iColumnMeta<m_pFixup->UI4FromIndex(pTableMeta->CountOfColumns); ++iColumnMeta)
        {
            ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta + pTableMeta->iColumnMeta);
            ASSERT(m_pFixup->UI4FromIndex(pColumnMeta->Index) == iColumnMeta);

            if((m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags)&(fCOLUMNMETA_PRIMARYKEY | fCOLUMNMETA_INSERTUNIQUE)) == (fCOLUMNMETA_PRIMARYKEY | fCOLUMNMETA_INSERTUNIQUE))
                bPrimaryKey_MerkedAs_InsertUnique = true;

            fORingOfAllColumnMeta_MetaFlags |= m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags);
            fORingOfAllColumnMeta_SchemaGeneratorFlags |= m_pFixup->UI4FromIndex(pColumnMeta->SchemaGeneratorFlags);

            //Inference Rule 2.n.i.
                //PublicRowNameColumn is inferred from the ColumnMeta whose SchemaGeneratorFlags has the fCOLUMNMETA_USEASPUBLICROWNAME bit set.
            if(m_pFixup->UI4FromIndex(pColumnMeta->SchemaGeneratorFlags)&fCOLUMNMETA_USEASPUBLICROWNAME)
            {
                ASSERT(0 == pTableMeta->PublicRowNameColumn);//Can have more than one of these.  This is handled by Inference Rule 3.m.i.2
                pTableMeta->PublicRowNameColumn = m_pFixup->AddUI4ToList(iColumnMeta);
            }
        }

        if(fORingOfAllColumnMeta_SchemaGeneratorFlags & fCOLUMNMETA_VALUEINCHILDELEMENT)
        {
            //Inference Rule 2.aa.ii
                //This property is NOT NULL if at least one column has the VALUEINCHILDELEMENT set in SchemaGeneratorFlags.
            if(0 == pTableMeta->ChildElementName)
            {
                m_pOut->printf(L"Error - Table (%s) has at least one column marked as VALUEINCHILDELEMENT but no ChildElementName is set in the TableMeta", m_pFixup->StringFromIndex(pTableMeta->InternalName));
                THROW(ERROR - VALIDATION ERROR);
            }
        }
        else
        {
            //Inference Rule 2.aa.i
                //This property is NULL if no column has the VALUEINCHILDELEMENT set in SchemaGeneratorFlags.
            if(0 != pTableMeta->ChildElementName)
            {
                m_pOut->printf(L"Error - Table (%s) has no column marked as VALUEINCHILDELEMENT but a ChildElementName is set in the TableMeta", m_pFixup->StringFromIndex(pTableMeta->InternalName));
                THROW(ERROR - VALIDATION ERROR);
            }
        }

        //Inference Rule 2.j.xviii.1
            //If any column is marked as fCOLUMNMETA_PRIMARYKEY and fCOLUMNMETA_INSERTUNIQUE, the fTABLEMETA_OVERWRITEALLROWS must
            //be specified.  It is not inferred - it should be explicitly specified..
        if(bPrimaryKey_MerkedAs_InsertUnique && 0==(MetaFlags & fTABLEMETA_OVERWRITEALLROWS))
        {
            m_pOut->printf(L"Error - Table (%s) has a PRIMARYKEY column that is also marked as INSERTUNIQUE.  This requires the table to be marked as OVERWRITEALLROWS", m_pFixup->StringFromIndex(pTableMeta->InternalName));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 2.j.v.1.
            //fTABLEMETA_HASUNKNOWNSIZES indicates whether any of the table's ColumnMeta.MetaFlags fCOLUMNMETA_UNKNOWNSIZE bit is set.  This depends in Inferrence Rule 3.g.xxviii.1.
        if(fORingOfAllColumnMeta_MetaFlags & fCOLUMNMETA_UNKNOWNSIZE)
            MetaFlags |= fTABLEMETA_HASUNKNOWNSIZES;


        //Inference Rule 2.j.x.1.
            //If any of the table's ColumnMeta.Metaflags specify fCOLUMNMETA_DIRECTIVE then fTABLEMETA_HASDIRECTIVES is set.
        if(fORingOfAllColumnMeta_MetaFlags & fCOLUMNMETA_DIRECTIVE)
            MetaFlags |= fTABLEMETA_HASDIRECTIVES;
        pTableMeta->MetaFlags = m_pFixup->AddUI4ToList(MetaFlags);


        ULONG SchemaGeneratorFlags = m_pFixup->UI4FromIndex(pTableMeta->SchemaGeneratorFlags);
        //Inference Rule 2.k.iii.1.
            //fTABLEMETA_ISCONTAINED is set if there is a RelationMeta.ForeignTable that matches TableMeta.InternalName and RelationMeta.Metaflags' fRELATIONMETA_USECONTAINMENT bit is set.
        for(ULONG iRelationMeta=0; iRelationMeta<m_pFixup->GetCountRelationMeta(); ++iRelationMeta)
        {
            RelationMeta *pRelationMeta = m_pFixup->RelationMetaFromIndex(iRelationMeta);
            if(m_pFixup->UI4FromIndex(pRelationMeta->MetaFlags)&fRELATIONMETA_USECONTAINMENT &&
                pRelationMeta->ForeignTable == pTableMeta->InternalName)
            {
                SchemaGeneratorFlags |= fTABLEMETA_ISCONTAINED;
                break;
            }
        }
        pTableMeta->SchemaGeneratorFlags = m_pFixup->AddUI4ToList(SchemaGeneratorFlags);


        //Inference Rule 2.n.i.-See Above
            //PublicRowNameColumn is inferred from the ColumnMeta whose SchemaGeneratorFlags has the fCOLUMNMETA_USEASPUBLICROWNAME bit set.

        //Inference Rule 2.n.ii.
            //If no column has the fCOLUMNMETA_USEASPUBLICROWNAME bit set, TableMeta. PublicRowNameColumn column is defaulted to -1.
        if(0 == pTableMeta->PublicRowNameColumn)
        {
            pTableMeta->PublicRowNameColumn = m_pFixup->AddUI4ToList((ULONG)-1);
        }


        //Inference Rule 2.p.i. - See Above
            //TableMeta.iColumnMeta is an index to the first ColumnMeta row whose Table matches the TableMeta.InternalName


        pTableMeta->iIndexMeta = 0;
        //Inference Rule 2.s.i.
            //iIndexMeta is an index to the first IndexMeta whose Table matches the TableMeta.InternalName.
        for( ; pTableMeta->iIndexMeta<m_pFixup->GetCountIndexMeta();++pTableMeta->iIndexMeta)
        {
            if(m_pFixup->IndexMetaFromIndex(pTableMeta->iIndexMeta)->Table == pTableMeta->InternalName)
                break;
        }
        if(pTableMeta->iIndexMeta==m_pFixup->GetCountIndexMeta())
            pTableMeta->iIndexMeta = (ULONG)-1;//No IndexMeta for this table

        //Inference Rule 2.r.i.
            //cIndexMeta is the count of IndexMeta whose Table matches the TableMeta.InternalName.
        pTableMeta->cIndexMeta = 0;
        for( ; (pTableMeta->iIndexMeta + pTableMeta->cIndexMeta)<m_pFixup->GetCountIndexMeta();++pTableMeta->cIndexMeta)
        {
            if(m_pFixup->IndexMetaFromIndex(pTableMeta->iIndexMeta + pTableMeta->cIndexMeta)->Table != pTableMeta->InternalName)
                break;
        }

        //Inference Rule 2.v.i.
            //iServerWiring is an index to the first ServerWiringMeta row whose Table matches the TableMeta.InternalName.
        pTableMeta->iServerWiring=0;
        for( ;pTableMeta->iServerWiring<m_pFixup->GetCountServerWiringMeta();++pTableMeta->iServerWiring)
        {
            if(m_pFixup->ServerWiringMetaFromIndex(pTableMeta->iServerWiring)->Table == pTableMeta->InternalName)
                break;
        }
        ASSERT(pTableMeta->iServerWiring<m_pFixup->GetCountServerWiringMeta());
        //Inference Rule 2.w.i.
            //cServerWiring is the count of ServerWiringMeta rows whole Table matches the TableMeta.InternalName.
        pTableMeta->cServerWiring=0;
        for( ; (pTableMeta->iServerWiring + pTableMeta->cServerWiring)<m_pFixup->GetCountServerWiringMeta();++pTableMeta->cServerWiring)
        {
            if(m_pFixup->ServerWiringMetaFromIndex(pTableMeta->iServerWiring + pTableMeta->cServerWiring)->Table != pTableMeta->InternalName)
                break;
        }

        if(MetaFlags & fTABLEMETA_HASDIRECTIVES)
        {
            for(ULONG iColumnMeta=0; iColumnMeta<m_pFixup->UI4FromIndex(pTableMeta->CountOfColumns); ++iColumnMeta)
            {   //we're only validating PKs that are NOT FKs
                ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta + pTableMeta->iColumnMeta);

                if(fCOLUMNMETA_PRIMARYKEY == (m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags)
                                                & (fCOLUMNMETA_PRIMARYKEY | fCOLUMNMETA_FOREIGNKEY)))
                {
                    if(m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_DIRECTIVE)
                    {   //A directive column may NOT have a DefaultValue
                        if(0 != pColumnMeta->DefaultValue)
                        {
                            m_pOut->printf(L"Directive Table (%s), has Directive Column (%s) with a DefaultValue.\r\n"
                                            ,m_pFixup->StringFromIndex(pTableMeta->InternalName)
                                            ,m_pFixup->StringFromIndex(pColumnMeta->InternalName));
                            m_pOut->printf(L"In a Directive Table, all PrimaryKeys that are not ForeignKeys must have a default"
                                          L"value (with one exception - the Directive column itself must NOT have a Default Value)\r\n");
                            THROW(ERROR IN DIRECTIVE COLUMN - DEFAULT VALUE SUPPLIED FOR DIRECTIVE COLUMN);
                        }
                    }
                    else
                    {   //Not DIRECTIVE PK Column must have a DefaultValue
                        if(0 == pColumnMeta->DefaultValue)
                        {
                            m_pOut->printf(L"Directive Table (%s), has PrimaryKey Column (%s) but no DefaultValue was supplied\r\n"
                                            ,m_pFixup->StringFromIndex(pTableMeta->InternalName)
                                            ,m_pFixup->StringFromIndex(pColumnMeta->InternalName));
                            m_pOut->printf(L"In a Directive Table, all PrimaryKeys that are not ForeignKeys must have a default"
                                          L"value (with one exception - the Directive column itself must NOT have a Default Value)\r\n");
                            THROW(ERROR IN DIRECTIVE COLUMN - NOT DEFAULT VALUE);
                        }
                    }
                }
            }
        }
#if 0
        //Inference Rule 2.x.i.
            //cPrivateColumns is hard coded based on the meta tables.  Only Meta tables have a private column count.
        if(pTableMeta->InternalName         == m_pFixup->FindStringInPool(L"COLUMNMETA"))
            pTableMeta->cPrivateColumns = kciColumnMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"DATABASEMETA"))
            pTableMeta->cPrivateColumns = kciDatabaseMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"INDEXMETA"))
            pTableMeta->cPrivateColumns = kciIndexMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"QUERYMETA"))
            pTableMeta->cPrivateColumns = kciQueryMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"RELATIONMETA"))
            pTableMeta->cPrivateColumns = kciRelationMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"SERVERWIRINGMETA"))
            pTableMeta->cPrivateColumns = kciServerWiringMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"TABLEMETA"))
            pTableMeta->cPrivateColumns = kciTableMetaPrivateColumns;
        else if(pTableMeta->InternalName    == m_pFixup->FindStringInPool(L"TAGMETA"))
            pTableMeta->cPrivateColumns = kciTagMetaPrivateColumns;
#endif
    }
}

void TMetaInferrence::InferTagMeta()
{
    for(ULONG iTagMeta=0; iTagMeta<m_pFixup->GetCountTagMeta(); ++iTagMeta)
    {
        TagMeta *pTagMeta = m_pFixup->TagMetaFromIndex(iTagMeta);

        //Inference Rule 4.c.i.
            //TagMeta.InternalName must exist.
        if(0 == pTagMeta->InternalName)
        {
            m_pOut->printf(L"Error - TagMeta.InternalName is missing on Table (%s), ColumnIndex (%d).", pTagMeta->Table ? m_pFixup->StringFromIndex(pTagMeta->Table) : L"<unknown>", pTagMeta->ColumnIndex ? m_pFixup->UI4FromIndex(pTagMeta->ColumnIndex) : -1);
            THROW(ERROR - VALIDATION ERROR);
        }

        //We'd like to scan the TableMeta; but PublicRowNameColumn has not yet been inferred.
        //So we'll have to scan for the ColumnMeta instead and look at the MetaFlagsEx (SchemaGeneratorFlags)
        ULONG iColumnMeta = m_pFixup->FindColumnBy_Table_And_Index(pTagMeta->Table, pTagMeta->ColumnIndex);
        ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta);

        //If this is not the enum used as PublicRow name then Numerics are OK as a first char
        bool bAllowNumeric = !(m_pFixup->UI4FromIndex(pColumnMeta->SchemaGeneratorFlags) & fCOLUMNMETA_USEASPUBLICROWNAME);

        //Inference Rule 4.c.ii.
            //TagMeta.InternalName should be validated to be a legal C++ variable name.
        ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pTagMeta->InternalName), m_szNameLegalCharacters, bAllowNumeric);

        //Inference Rule 4.d.i.
            //TagMeta.PublicName is set to the TagMeta.InternalName if none is supplied.
        if(0 == pTagMeta->PublicName)
        {
            pTagMeta->PublicName = pTagMeta->InternalName;
            //if the InternalName is a legal C++ variable name and this enum is the EnumPublicRowName column
            //then we're good to go.
        }
        else
        {
            //Inference Rule 4.d.ii.
                //TagMeta.PublicName should be validated to be a legal C++ variable name.
            ValidateStringAsLegalVariableName(m_pFixup->StringFromIndex(pTagMeta->PublicName),
                    bAllowNumeric ? m_szPublicTagLegalCharacters : m_szNameLegalCharacters, bAllowNumeric);
        }



        ASSERT(0 != pTagMeta->Value);
    }
}


//Inference Rule 2.g.i.
//Inference Rule 2.h.i.
void TMetaInferrence::InferTableMeta_NameColumn_NavColumn(TableMeta *pTableMeta)
{
    unsigned long iInferredNavColumn = (unsigned long)-1;//undefined
    unsigned long iFirstWCharPrimaryKeyThatsAlsoAForeignKey = (unsigned long)-1;//undefined
    unsigned long iFirstWCharPrimaryKey = (unsigned long)-1;//undefined
    unsigned long iFirstWCharColumn = (unsigned long)-1;//undefined
    unsigned long iNavColumn  = (unsigned long)-1;//undefined
    unsigned long iNameColumn = (unsigned long)-1;//undefined

    for(unsigned long iColumnMeta=0; iColumnMeta<m_pFixup->UI4FromIndex(pTableMeta->CountOfColumns); ++iColumnMeta)
    {
        ColumnMeta *pColumnMeta = m_pFixup->ColumnMetaFromIndex(iColumnMeta + pTableMeta->iColumnMeta);
        if(m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_NAMECOLUMN)//If the user specified the NameColumn flag then use it
        {
            //Inference Rule 3.g.iii.1
                //Only one NameColumn may be specified per table.
            if(-1 != iNameColumn)
            {
                m_pOut->printf(L"Error - Multiple NameColumns specified (Table %s, Column %s).\n\tOnly one Column should have the fCOLUMNMETA_NAMECOLUMN set.\n", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
                THROW(ERROR - MULTIPLE NAME COLUMNS SPECIFIED);
            }
            iNameColumn = iColumnMeta;
        }
        if(m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_NAVCOLUMN)
        {
            //Inference Rule 3.g.iv.1
                //Only one NavColumn may be specified per table.
            if(-1 != iNavColumn)
            {
                m_pOut->printf(L"Error - Multiple NavColumns specified (Table %s, Column %s).\n\tOnly one Column should have the fCOLUMNMETA_NAVCOLUMN set.\n", m_pFixup->StringFromIndex(pColumnMeta->Table), m_pFixup->StringFromIndex(pColumnMeta->InternalName));
                THROW(ERROR - MULTIPLE NAV COLUMNS SPECIFIED);
            }
            iNavColumn = iColumnMeta;
        }
        //If we haven't already reached the first PRIMARYKEY that is not a FOREIGNKEY, then use this to infer the Name and Nav Columns
        if(-1 == iInferredNavColumn && m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY && 0==(m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_FOREIGNKEY))
            iInferredNavColumn  = iColumnMeta;
        if(-1 == iFirstWCharColumn && m_pFixup->UI4FromIndex(pColumnMeta->Type) == DBTYPE_WSTR)
            iFirstWCharColumn = iColumnMeta;
        if(-1 == iFirstWCharPrimaryKey && m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY && 0==(m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_FOREIGNKEY) && m_pFixup->UI4FromIndex(pColumnMeta->Type) == DBTYPE_WSTR)
            iFirstWCharPrimaryKey = iColumnMeta;
        if(-1 == iFirstWCharPrimaryKeyThatsAlsoAForeignKey && m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY && m_pFixup->UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_FOREIGNKEY && m_pFixup->UI4FromIndex(pColumnMeta->Type) == DBTYPE_WSTR)
            iFirstWCharPrimaryKeyThatsAlsoAForeignKey = iColumnMeta;
    }
    if(-1 == iInferredNavColumn)//ALL Table should have at least one primary key that is NOT a foreign key
    {
        m_pOut->printf(L"Warning - Table (%s) contains no PRIMARYKEY that is not also a FOREIGNKEY.\n", m_pFixup->StringFromIndex(pTableMeta->InternalName));
        iInferredNavColumn = (-1 == iFirstWCharPrimaryKeyThatsAlsoAForeignKey) ? 0 : iFirstWCharPrimaryKeyThatsAlsoAForeignKey;
    }
    if(-1 == iNavColumn)
        iNavColumn = iInferredNavColumn;
    if(-1 == iNameColumn)
    {
        if(-1 != iFirstWCharPrimaryKey)
            iNameColumn = iFirstWCharPrimaryKey;
        else if(-1 != iFirstWCharColumn)
            iNameColumn = iFirstWCharColumn;
        else
            iNameColumn = iNavColumn;
    }
    pTableMeta->NameColumn = m_pFixup->AddUI4ToList(iNameColumn);
    pTableMeta->NavColumn  = m_pFixup->AddUI4ToList(iNavColumn);
}


unsigned long TMetaInferrence::InferPublicRowName(unsigned long PublicName)
{
    LPCWSTR wszPublicName = m_pFixup->StringFromIndex(PublicName);
    SIZE_T  cwchPublicName = wcslen(wszPublicName);

    TSmartPointerArray<WCHAR> wszPublicRowName = new WCHAR [wcslen(wszPublicName)+2];
    if(0 == wszPublicRowName.m_p)
    {
        THROW(ERROR - OUT OF MEMORY);
    }

    //Very language specific, if PublicTableName ends in 's' or 'S' then Infer PublicRowName as PublicTableName without the 's'
    if(wszPublicName[cwchPublicName-1] == L's' || wszPublicName[cwchPublicName-1] == L'S')
    {
        wcscpy(wszPublicRowName, m_pFixup->StringFromIndex(PublicName));
        wszPublicRowName[cwchPublicName-1] = 0x00;
    }
    else //If PublicTableName does NOT end in 's' or 'S' then put 'A' in front of the PublicTableName
    {
        wcscpy(wszPublicRowName, L"A");
        wcscat(wszPublicRowName, m_pFixup->StringFromIndex(PublicName));
    }
    return m_pFixup->AddWCharToList(wszPublicRowName);
}

void TMetaInferrence::InferServerWiringMeta()
{
	ULONG lastTable = ULONG(-1); // -1 is not used for any table nr

    for(unsigned long iServerWiringMeta=0; iServerWiringMeta<m_pFixup->GetCountServerWiringMeta(); ++iServerWiringMeta)
    {
        ServerWiringMeta *pServerWiringMeta = m_pFixup->ServerWiringMetaFromIndex(iServerWiringMeta);

        //Inference Rule 8.a.i.
            //Table is a primarykey so it cannot be NULL
        if(0 == pServerWiringMeta->Table)
        {
            m_pOut->printf(L"Error in ServerWiringMeta row (%d) - NULL specified for Table.", iServerWiringMeta);
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 8.b.i.
            //Order is a primarykey so it cannot be NULL
        ASSERT(0 != pServerWiringMeta->Order);//This should have already been inferred

        //Inference Rule 8.c.i.
            //ReadPlugin is defatuled to RPNone (0) if none is specified.
        if(0 == pServerWiringMeta->ReadPlugin)
            pServerWiringMeta->ReadPlugin = m_iZero;

        //Inference Rule 8.d.i.
            //WritePlugin is defaulted to WPNone (0) if none is specified.
        if(0 == pServerWiringMeta->WritePlugin)
            pServerWiringMeta->WritePlugin = m_iZero;

        //Inference Rule 8.e.i.
            //Interceptor is defaulted to NoInterceptor (0) if none is specified.
        if(0 == pServerWiringMeta->Interceptor)
            pServerWiringMeta->Interceptor = m_iZero;

		//Inference Rule 8.j.i
		if(0 == pServerWiringMeta->Merger)
            pServerWiringMeta->Merger= m_iZero;

		// Inference Rule 8.j.ii
		//Check that when a merger is defined, it is only defined in the first serverwiring
		//element for that table
		if (pServerWiringMeta->Table != lastTable)
		{
			lastTable    = pServerWiringMeta->Table;
		}
		else
		{
			// same table, so check that merger is not specified
			if (m_iZero != pServerWiringMeta->Merger)
			{
				m_pOut->printf(L"Error in ServerWiringMeta for Table (%s) - Merge Interceptor must be defined as first interceptor, and there can be only one merge interceptor.", m_pFixup->StringFromIndex(pServerWiringMeta->Table));
				THROW(ERROR - VALIDATION ERROR);
			}
		}

        //Inference Rule 8.e.ii.
            //At least one of the following must be non zero: ReadPlugin, WritePlugin, Interceptor.
        if( m_iZero == pServerWiringMeta->ReadPlugin  &&
            m_iZero == pServerWiringMeta->WritePlugin &&
            m_iZero == pServerWiringMeta->Interceptor)
        {
            m_pOut->printf(L"Error in ServerWiringMeta for Table (%s) - ReadPlugin, WritePlugin, Interceptor are all specified as NONE.  At least one of these must be specified.", m_pFixup->StringFromIndex(pServerWiringMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }

		// You cannot defined read plugins and write plugins when you have defined a merger
		if ((pServerWiringMeta->Merger != m_iZero) &&
			((pServerWiringMeta->ReadPlugin != m_iZero) || (pServerWiringMeta->WritePlugin != m_iZero)))
		{
			m_pOut->printf(L"Error in ServerWiringMeta for Table (%s) - You cannot define ReadPlugin or WritePlugin when a Merger is defined.", m_pFixup->StringFromIndex(pServerWiringMeta->Table));
			THROW(ERROR - VALIDATION ERROR);
		}

        //Inference Rule 8.f.i./8.k.i/8.l.i/8.m.i
        //If InterceptorDLLName of L"catalog.dll" is specified, it is replaced with the default value of 0.

        if(0 != pServerWiringMeta->ReadPluginDLLName &&  0 == _wcsicmp( m_pFixup->StringFromIndex(pServerWiringMeta->ReadPluginDLLName), L"catalog.dll"))
            THROW(ERROR - CATALOG.DLL SHOULD NEVER BE EXPLLICITLY SPECIFIED);

		if(0 != pServerWiringMeta->WritePluginDLLName &&  0 == _wcsicmp( m_pFixup->StringFromIndex(pServerWiringMeta->WritePluginDLLName), L"catalog.dll"))
            THROW(ERROR - CATALOG.DLL SHOULD NEVER BE EXPLLICITLY SPECIFIED);

		if(0 != pServerWiringMeta->InterceptorDLLName &&  0 == _wcsicmp( m_pFixup->StringFromIndex(pServerWiringMeta->InterceptorDLLName), L"catalog.dll"))
            THROW(ERROR - CATALOG.DLL SHOULD NEVER BE EXPLLICITLY SPECIFIED);

		if(0 != pServerWiringMeta->MergerDLLName &&  0 == _wcsicmp( m_pFixup->StringFromIndex(pServerWiringMeta->MergerDLLName), L"catalog.dll"))
            THROW(ERROR - CATALOG.DLL SHOULD NEVER BE EXPLLICITLY SPECIFIED);

        //Inference Rule 8.g.i.
            //Flags is defaulted to (First | NoNext | Last | WireOnReadWrite) or 0x2D if none is supplied.
        if(0 == pServerWiringMeta->Flags || 0 == m_pFixup->UI4FromIndex(pServerWiringMeta->Flags))
            pServerWiringMeta->Flags = m_pFixup->AddUI4ToList(0x2D);

        //Inference Rule 8.g.ii.
            //Flags can specify WireOnReadWrite or WireOnWriteOnly but not both.(fSERVERWIRINGMETA_WireOnReadWrite | fSERVERWIRINGMETA_WireOnWriteOnly) == 0x30
        if((m_pFixup->UI4FromIndex(pServerWiringMeta->Flags) & 0x30) == 0x30)
        {
            m_pOut->printf(L"Error in ServerWiringMeta for Table (%s) - WireOnReadWrite OR WireOnWriteOnly may be specified but not both.", m_pFixup->StringFromIndex(pServerWiringMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 8.g.iii.
            //Flags can specify First or Next but not both.(fSERVERWIRINGMETA_First | fSERVERWIRINGMETA_Next)==0x03
        if((m_pFixup->UI4FromIndex(pServerWiringMeta->Flags) & 0x03) == 0x03)
        {
            m_pOut->printf(L"Error in ServerWiringMeta for Table (%s) - First OR Next may be specified but not both.", m_pFixup->StringFromIndex(pServerWiringMeta->Table));
            THROW(ERROR - VALIDATION ERROR);
        }

        //Inference Rule 8.g.i.
            //Reserved should be set to 0.
        if(0 == pServerWiringMeta->Reserved)
            pServerWiringMeta->Reserved = m_pFixup->AddUI4ToList(0L);
    }
}


void TMetaInferrence::ValidateStringAsLegalVariableName(LPCWSTR wszString, LPCWSTR wszLegalCharacters, bool bAllowNumericFirstCharacter)
{
    if(0 == wszLegalCharacters)
        wszLegalCharacters = m_szNameLegalCharacters;

    SIZE_T nStringLength = wcslen(wszString);
	// the string must start with a letter (WMI naming convention)
    if(!bAllowNumericFirstCharacter)
    {
        if((*wszString < L'a' || *wszString > L'z') && (*wszString < L'A' || *wszString > L'Z'))
        {
            m_pOut->printf(L"Error - Bogus String (%s).  This String must be a legal C++ variable name (begins with an alpha and contains only alpha (or '_') and numerics.\n", wszString);
            THROW(ERROR - BOGUS NAME);
        }
    }

	// WMI names cannot end with underscore.
	if (wszString[nStringLength - 1] == L'_')
	{
		m_pOut->printf(L"Error - Bogus String (%s).  This String must be a legal WMI name (cannot end with underscore).\n", wszString);
        THROW(ERROR - BOGUS NAME);
	}

    LPCWSTR wszIllegalCharacter = _wcsspnp(wszString, wszLegalCharacters);
    if(NULL != wszIllegalCharacter)
    {
        m_pOut->printf(L"Error - Bogus String (%s).  This string should not contain the character '%c'.\n", wszString, static_cast<char>(*wszIllegalCharacter));
        THROW(ERROR - BAD NAME);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tpefixup.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

//TPEFixup class is the interface that all Schema compilation modules use to get at the meta and fixed tables.  TColumnMeta, TDatabaseMeta etc classes
//can be used to make this access easier (pasing in a TPEFixup class reference).
class TPEFixup
{
public:
    TPEFixup(){}

    virtual unsigned long       AddBytesToList(const unsigned char * pBytes, size_t cbBytes) =0;
    virtual unsigned long       AddGuidToList(const GUID &guid)                              =0;
    virtual unsigned long       AddUI4ToList(ULONG ui4)                                      =0;
    virtual unsigned long       AddULongToList(ULONG ulong)                                  =0;
    virtual unsigned long       AddWCharToList(LPCWSTR wsz, unsigned long cwchar=-1)         =0;
    virtual unsigned long       FindStringInPool(LPCWSTR wsz, unsigned long cwchar=-1) const =0;

    virtual unsigned long       AddColumnMetaToList         (ColumnMeta       *p, ULONG count=1) =0;
    virtual unsigned long       AddDatabaseMetaToList       (DatabaseMeta     *p, ULONG count=1) =0;
    virtual unsigned long       AddHashedIndexToList        (HashedIndex      *p, ULONG count=1) =0;
    virtual unsigned long       AddIndexMetaToList          (IndexMeta        *p, ULONG count=1) =0;
    virtual unsigned long       AddQueryMetaToList          (QueryMeta        *p, ULONG count=1) =0;
    virtual unsigned long       AddRelationMetaToList       (RelationMeta     *p, ULONG count=1) =0;
    virtual unsigned long       AddServerWiringMetaToList   (ServerWiringMeta *p, ULONG count=1) =0;
    virtual unsigned long       AddTableMetaToList          (TableMeta        *p, ULONG count=1) =0;
    virtual unsigned long       AddTagMetaToList            (TagMeta          *p, ULONG count=1) =0;
    virtual unsigned long       AddULongToList              (ULONG            *p, ULONG count)   =0;
                                                                                                 
    virtual const BYTE       *  ByteFromIndex               (ULONG i) const =0;
    virtual const GUID       *  GuidFromIndex               (ULONG i) const =0;
    virtual const WCHAR      *  StringFromIndex             (ULONG i) const =0;
    virtual       ULONG         UI4FromIndex                (ULONG i) const =0;
    virtual const ULONG      *  UI4pFromIndex               (ULONG i) const =0;
                                                                           
    virtual unsigned long       BufferLengthFromIndex       (ULONG i) const =0;
                                                                           
    virtual ColumnMeta       *  ColumnMetaFromIndex         (ULONG i=0)     =0;
    virtual DatabaseMeta     *  DatabaseMetaFromIndex       (ULONG i=0)     =0;
    virtual HashedIndex      *  HashedIndexFromIndex        (ULONG i=0)     =0;
    virtual IndexMeta        *  IndexMetaFromIndex          (ULONG i=0)     =0;
    virtual QueryMeta        *  QueryMetaFromIndex          (ULONG i=0)     =0;
    virtual RelationMeta     *  RelationMetaFromIndex       (ULONG i=0)     =0;
    virtual ServerWiringMeta *  ServerWiringMetaFromIndex   (ULONG i=0)     =0;
    virtual TableMeta        *  TableMetaFromIndex          (ULONG i=0)     =0;
    virtual TagMeta          *  TagMetaFromIndex            (ULONG i=0)     =0;
    virtual ULONG            *  ULongFromIndex              (ULONG i=0)     =0;
    virtual unsigned char    *  PooledDataPointer           ()              =0;

    virtual unsigned long       GetCountColumnMeta          ()        const =0;
    virtual unsigned long       GetCountDatabaseMeta        ()        const =0;
    virtual unsigned long       GetCountHashedIndex         ()        const =0;
    virtual unsigned long       GetCountIndexMeta           ()        const =0;
    virtual unsigned long       GetCountQueryMeta           ()        const =0;
    virtual unsigned long       GetCountRelationMeta        ()        const =0;
    virtual unsigned long       GetCountServerWiringMeta    ()        const =0;
    virtual unsigned long       GetCountTableMeta           ()        const =0;
    virtual unsigned long       GetCountTagMeta             ()        const =0;
    virtual unsigned long       GetCountULONG               ()        const =0;
    virtual unsigned long       GetCountOfBytesPooledData   ()        const =0;

    virtual unsigned long       FindTableBy_TableName(ULONG Table, bool bCaseSensitive=false)           =0;
    virtual unsigned long       FindTableBy_TableName(LPCWSTR wszTable)                                 =0;
    virtual unsigned long       FindColumnBy_Table_And_Index(unsigned long Table, unsigned long Index, bool bCaseSensitive=false)               =0;
    virtual unsigned long       FindColumnBy_Table_And_InternalName(unsigned long Table, unsigned long  InternalName, bool bCaseSensitive=false)=0;
    virtual unsigned long       FindTagBy_Table_And_Index(ULONG iTableName, ULONG iColumnIndex, bool bCaseSensitive=false)                      =0;
};

class TMetaTableBase
{
public:
    TMetaTableBase() {}
    virtual ~TMetaTableBase(){}

    virtual bool    Next()      = 0;
    virtual void    First()     = 0;
    virtual bool    Previous()  = 0;
    virtual void    Reset()     = 0;

    virtual ULONG * Get_pulMetaTable() = 0;
    virtual unsigned long GetCount() const =0;
};

template <class T> class TMetaTable : public TMetaTableBase
{
public:
    TMetaTable(TPEFixup &fixup, ULONG i=0) :
          m_Fixup(fixup),
          m_iCurrent(i),
          m_iFirst(i)
    {
    }
    virtual ~TMetaTable(){}

    virtual bool    Next(){++m_iCurrent;return (m_iCurrent < static_cast<long>(GetCount()));}
    virtual void    First(){m_iCurrent = 0;}
    virtual bool    Previous(){--m_iCurrent; return (m_iCurrent >= 0);}
    virtual void    Reset(){m_iCurrent = m_iFirst;}

    virtual ULONG * Get_pulMetaTable() {return reinterpret_cast<ULONG *>(Get_pMetaTable());}
    virtual T * Get_pMetaTable() = 0;
    virtual unsigned long GetCount() const =0;

protected:
    TPEFixup &  m_Fixup;
    long        m_iCurrent;
    long        m_iFirst;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\tquerymeta.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

/*
struct QueryMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Index;                  //UI4
    ULONG                       CellName;               //String
    ULONG                       Operator;               //UI4
    ULONG                       MetaFlags;              //UI4
};
*/

class TQueryMeta : public TMetaTable<QueryMeta>
{
public:
    TQueryMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<QueryMeta>(fixup,i){}
    const WCHAR *Get_Table           () const {return m_Fixup.StringFromIndex(   Get_MetaTable().Table);}
    const WCHAR *Get_InternalName    () const {return m_Fixup.StringFromIndex(   Get_MetaTable().InternalName);}
    const WCHAR *Get_PublicName      () const {return m_Fixup.StringFromIndex(   Get_MetaTable().PublicName);}
    const ULONG * Get_Index           () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().Index);}
    const WCHAR *Get_CellName        () const {return m_Fixup.StringFromIndex(   Get_MetaTable().CellName);}
    const ULONG * Get_Operator        () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().Operator);}
    const ULONG * Get_MetaFlags       () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().MetaFlags);}

    virtual QueryMeta * Get_pMetaTable  ()       {return m_Fixup.QueryMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount      () const {return m_Fixup.GetCountQueryMeta();};
    const QueryMeta & Get_MetaTable () const {return *m_Fixup.QueryMetaFromIndex(m_iCurrent);}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\trelationmeta.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

/*
struct RelationMeta
{
    ULONG PRIMARYKEY FOREIGNKEY PrimaryTable;           //String
    ULONG                       PrimaryColumns;         //Bytes
    ULONG PRIMARYKEY FOREIGNKEY ForeignTable;           //String
    ULONG                       ForeignColumns;         //Bytes
    ULONG                       MetaFlags;
};
*/

class TRelationMeta : public TMetaTable<RelationMeta>
{
public:
    TRelationMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<RelationMeta>(fixup,i){}
    const WCHAR *Get_PrimaryTable    () const {return m_Fixup.StringFromIndex(Get_MetaTable().PrimaryTable);}
    const BYTE  * Get_PrimaryColumns  () const {return m_Fixup.ByteFromIndex( Get_MetaTable().PrimaryColumns);}
    const WCHAR *Get_ForeignTable    () const {return m_Fixup.StringFromIndex(Get_MetaTable().ForeignTable);}
    const BYTE  * Get_ForeignColumns  () const {return m_Fixup.ByteFromIndex( Get_MetaTable().ForeignColumns);}
    const ULONG * Get_MetaFlags       () const {return m_Fixup.UI4pFromIndex( Get_MetaTable().MetaFlags);}

    virtual RelationMeta * Get_pMetaTable   ()       {return m_Fixup.RelationMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount          () const {return m_Fixup.GetCountRelationMeta();};
    const RelationMeta & Get_MetaTable () const {return *m_Fixup.RelationMetaFromIndex(m_iCurrent);}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\twriteschemabin.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TWriteSchemaBin : public TFixedTableHeapBuilder
{
public:
    TWriteSchemaBin(LPCWSTR wszSchemaBinFileName);
    ~TWriteSchemaBin();
    virtual void Compile(TPEFixup &fixup, TOutput &out);
private:
    PACL    m_paclDiscretionary;
    PSID    m_psdStorage;
    PSID    m_psidAdmin;
    PSID    m_psidSystem;
    LPCWSTR m_szFilename;

    void SetSecurityDescriptor();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\ttablemeta.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

/*
struct TableMeta
{
    ULONG FOREIGNKEY            Database;               //String
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       PublicRowName;          //String
    ULONG                       BaseVersion;            //UI4
    ULONG                       ExtendedVersion;        //UI4
    ULONG                       NameColumn;             //UI4       iOrder of the NameColumn
    ULONG                       NavColumn;              //UI4       iOrder of the NavColumn
    union
    {
    ULONG                       CountOfColumns;         //UI4       Count of Columns
    ULONG                       CountOfProperties;      //UI4       Count of Columns
    };
    ULONG                       MetaFlags;              //UI4       TableMetaFlags are defined in CatInpro.meta
    ULONG                       SchemaGeneratorFlags;   //UI4       SchemaGenFlags are defined in CatInpro.meta
    ULONG                       ConfigItemName;         //String
    ULONG                       ConfigCollectionName;   //String
    ULONG                       PublicRowNameColumn;    //UI4       If PublicRowName is NULL, this specifies the column whose enum values represent possible PublicRowNames
    ULONG                       ContainerClassList;     //String    This is a comma delimited list of classes
    ULONG                       Description;            //String
    ULONG                       ChildElementName;       //String    This should be NULL unless one or more columns has the VALUEINCHILDELEMENT flag set on it.
    ULONG PRIVATE               ciRows;                 //Count of Rows in the Fixed Table (which if the fixed table is meta, this is also the number of columns in the table that the meta describes).
    ULONG PRIVATE_INDEX         iColumnMeta;            //Index into ColumnMeta
    ULONG PRIVATE_INDEX         iFixedTable;            //Index into g_aFixedTable
    ULONG PRIVATE               cPrivateColumns;        //This is the munber of private columns (private + ciColumns = totalColumns), this is needed for fixed table pointer arithmetic
    ULONG PRIVATE               cIndexMeta;             //The number of IndexMeta entries in this table
    ULONG PRIVATE_INDEX         iIndexMeta;             //Index into IndexMeta
    ULONG PRIVATE_INDEX         iHashTableHeader;       //If the table is a fixed table, then it will have a hash table.
    ULONG PRIVATE               nTableID;               //This is a 24 bit Hash of the Table name.
    ULONG PRIVATE_INDEX         iServerWiring;          //Index into the ServerWiringHeap (this is a temporary hack for CatUtil)
    ULONG PRIVATE               cServerWiring;          //Count of ServerWiring (this is a temporary hack for CatUtil)
};
*/

class TTableMeta : public TMetaTable<TableMeta>
{
public:
    TTableMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<TableMeta>(fixup,i){}
    bool    IsTableMetaOfColumnMetaTable() const {return (Get_MetaTable().InternalName && m_Fixup.UI4FromIndex(Get_MetaTable().CountOfColumns)>0);}

    const WCHAR * Get_Database            () const {return m_Fixup.StringFromIndex(   Get_MetaTable().Database              );}
    const WCHAR * Get_InternalName        () const {return m_Fixup.StringFromIndex(   Get_MetaTable().InternalName          );}
    const WCHAR * Get_PublicName          () const {return m_Fixup.StringFromIndex(   Get_MetaTable().PublicName            );}
    const WCHAR * Get_PublicRowName       () const {return m_Fixup.StringFromIndex(   Get_MetaTable().PublicRowName         );}
    const ULONG * Get_BaseVersion         () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().BaseVersion           );}
    const ULONG * Get_ExtendedVersion     () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().ExtendedVersion       );}
    const ULONG * Get_NameColumn          () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().NameColumn            );}
    const ULONG * Get_NavColumn           () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().NavColumn             );}
    const ULONG * Get_CountOfColumns      () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().CountOfColumns        );}
    const ULONG * Get_MetaFlags           () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().MetaFlags             );}
    const ULONG * Get_SchemaGeneratorFlags() const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().SchemaGeneratorFlags  );}
    const WCHAR * Get_ConfigItemName      () const {return m_Fixup.StringFromIndex(   Get_MetaTable().ConfigItemName        );}
    const WCHAR * Get_ConfigCollectionName() const {return m_Fixup.StringFromIndex(   Get_MetaTable().ConfigCollectionName  );}
    const ULONG * Get_PublicRowNameColumn () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().PublicRowNameColumn   );}
    const WCHAR * Get_ContainerClassList  () const {return m_Fixup.StringFromIndex(   Get_MetaTable().ContainerClassList    );}
    const WCHAR * Get_Description         () const {return m_Fixup.StringFromIndex(   Get_MetaTable().Description           );}
    const WCHAR * Get_ChildElementName    () const {return m_Fixup.StringFromIndex(   Get_MetaTable().ChildElementName      );}
          ULONG   Get_ciRows              () const {return Get_MetaTable().ciRows;}
          ULONG   Get_iColumnMeta         () const {return Get_MetaTable().iColumnMeta;}
          ULONG   Get_iFixedTable         () const {return Get_MetaTable().iFixedTable;}
          ULONG   Get_cPrivateColumns     () const {return Get_MetaTable().cPrivateColumns;}
          ULONG   Get_cIndexMeta          () const {return Get_MetaTable().cIndexMeta;}
          ULONG   Get_iIndexMeta          () const {return Get_MetaTable().iIndexMeta;}
          ULONG   Get_iHashTableHeader    () const {return Get_MetaTable().iHashTableHeader;}
          ULONG   Get_nTableID            () const {return Get_MetaTable().nTableID;}
          ULONG   Get_iServerWiring       () const {return Get_MetaTable().iServerWiring;}
          ULONG   Get_cServerWiring       () const {return Get_MetaTable().cServerWiring;}
       
    //Warning!! Users should not rely on this pointer once a Table is added, since the add could cause a relocation of the data.
    virtual TableMeta *Get_pMetaTable   ()       {return m_Fixup.TableMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount      () const {return m_Fixup.GetCountTableMeta();};
    const TableMeta & Get_MetaTable () const {return *m_Fixup.TableMetaFromIndex(m_iCurrent);}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\ttagmeta.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

/*
typedef struct
{
    ULONG PRIMARYKEY    Table               //Index into Pool
    ULONG PRIMARYKEY    ColumnIndex         //This is the iOrder member of the ColumnMeta
    ULONG PRIMARYKEY    InternalName        //Index into Pool
    ULONG               PublicName          //Index into Pool
    ULONG               Value 
    ULONG               ID                  //Index into Pool
}TagMeta;
*/

class TTagMeta : public TMetaTable<TagMeta>
{
public:
    TTagMeta(TPEFixup &fixup, ULONG i=0) : TMetaTable<TagMeta>(fixup,i){}
    const WCHAR * Get_Table               () const {return m_Fixup.StringFromIndex(   Get_MetaTable().Table         );}
    const ULONG * Get_ColumnIndex         () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().ColumnIndex   );}
    const WCHAR * Get_InternalName        () const {return m_Fixup.StringFromIndex(   Get_MetaTable().InternalName  );}
    const WCHAR * Get_PublicName          () const {return m_Fixup.StringFromIndex(   Get_MetaTable().PublicName    );}
    const ULONG * Get_Value               () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().Value         );}
    const ULONG * Get_ID                  () const {return m_Fixup.UI4pFromIndex(     Get_MetaTable().ID            );}

    virtual TagMeta *Get_pMetaTable ()       {return m_Fixup.TagMetaFromIndex(m_iCurrent);}
    virtual unsigned long GetCount  () const {return m_Fixup.GetCountTagMeta();};
    const TagMeta & Get_MetaTable () const {return *m_Fixup.TagMetaFromIndex(m_iCurrent);}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\twriteschemabin.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

#define THROW_ERROR0(x)                     {LOG_ERROR(Interceptor, (0, 0, E_ST_COMPILEFAILED,           ID_CAT_CONFIG_SCHEMA_COMPILE, x,                 L"",  L"",  L"",  L"" ))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}
#define THROW_ERROR_WIN32(win32err, call)   {LOG_ERROR(Interceptor, (0, 0, HRESULT_FROM_WIN32(win32err), ID_CAT_CONFIG_SCHEMA_COMPILE, IDS_COMCAT_WIN32, call,  L"",  L"",  L"" ))   ;THROW(SCHEMA COMPILATION ERROR - CHECK THE EVENT LOG FOR DETAILS);}


TWriteSchemaBin::TWriteSchemaBin(LPCWSTR szFilename) :
                m_paclDiscretionary(0)
                ,m_psdStorage(0)
                ,m_psidAdmin(0)
                ,m_psidSystem(0)
                ,m_szFilename(szFilename)
{
}

TWriteSchemaBin::~TWriteSchemaBin()
{
	if( m_paclDiscretionary != NULL )
		LocalFree( m_paclDiscretionary );

	if( m_psidAdmin != NULL )
		FreeSid( m_psidAdmin );

	if( m_psidSystem != NULL )
		FreeSid( m_psidSystem );

	if( m_psdStorage != NULL )
		LocalFree( m_psdStorage );
}

void TWriteSchemaBin::Compile(TPEFixup &fixup, TOutput &out)
{
    m_pFixup = &fixup;
    m_pOut   = &out;

    BuildMetaTableHeap();

    SECURITY_ATTRIBUTES saStorage;
    PSECURITY_ATTRIBUTES psaStorage = NULL;

	SetSecurityDescriptor();

    saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
    saStorage.lpSecurityDescriptor = m_psdStorage;
    saStorage.bInheritHandle = FALSE;
    psaStorage = &saStorage;

    TFile schemabin(m_szFilename, out, true, psaStorage);

    //Write the header
    //We don't want the signature bytes to appear twice in the DLL so we'll write them to the file one byte at a time.
    //#define      kFixedTableHeapSignature0   (0x207be016)
    schemabin.Write(static_cast<unsigned char>(0x16));
    schemabin.Write(static_cast<unsigned char>(0xe0));
    schemabin.Write(static_cast<unsigned char>(0x7b));
    schemabin.Write(static_cast<unsigned char>(0x20));

    //#define      kFixedTableHeapSignature1   (0xe0182086)
    schemabin.Write(static_cast<unsigned char>(0x86));
    schemabin.Write(static_cast<unsigned char>(0x20));
    schemabin.Write(static_cast<unsigned char>(0x18));
    schemabin.Write(static_cast<unsigned char>(0xe0));

    schemabin.Write(kFixedTableHeapKey);
    schemabin.Write(kFixedTableHeapVersion);
    schemabin.Write(m_FixedTableHeap.GetEndOfHeap());

    //Write the FixedTableHeap (minus the header).  The header is not
    schemabin.Write(m_FixedTableHeap.GetHeapPointer() + 5*sizeof(ULONG), m_FixedTableHeap.GetEndOfHeap() - 5*sizeof(ULONG));
}

void TWriteSchemaBin::SetSecurityDescriptor()
{
    DWORD                    dwDaclSize;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;

    m_psdStorage = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

    if(m_psdStorage == NULL)
    {
        THROW_ERROR0(IDS_SCHEMA_COMPILATION_OUTOFMEMORY);
    }

    //
    // Initialize the security descriptor.
    //
    if( !InitializeSecurityDescriptor(m_psdStorage, SECURITY_DESCRIPTOR_REVISION))
    {
        THROW_ERROR_WIN32(GetLastError(), L"InitializeSecurityDescriptor");
    }

    //
    // Create the SIDs for the local system and admin group.
    //
    if( !AllocateAndInitializeSid(&ntAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &m_psidSystem))
    {
        THROW_ERROR_WIN32(GetLastError(), L"AllocateAndInitializeSid");
    }

    if( !AllocateAndInitializeSid(&ntAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &m_psidAdmin))
    {
        THROW_ERROR_WIN32(GetLastError(), L"AllocateAndInitializeSid");
    }

    //
    // Create the DACL containing an access-allowed ACE
    // for the local system and admin SIDs.
    //
    dwDaclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(m_psidAdmin) + sizeof(ACCESS_ALLOWED_ACE)
                   + GetLengthSid(m_psidSystem) - sizeof(DWORD);

    m_paclDiscretionary = (PACL)LocalAlloc(LPTR, dwDaclSize );

    if( m_paclDiscretionary == NULL )
    {
        THROW_ERROR0(IDS_SCHEMA_COMPILATION_OUTOFMEMORY);
    }

    if( !InitializeAcl(m_paclDiscretionary, dwDaclSize, ACL_REVISION))
    {
        THROW_ERROR_WIN32(GetLastError(), L"InitializeAcl");
    }

    if( !AddAccessAllowedAce(m_paclDiscretionary, ACL_REVISION, FILE_ALL_ACCESS, m_psidSystem))
    {
        THROW_ERROR_WIN32(GetLastError(), L"AddAccessAllowedAce");
    }

    if( !AddAccessAllowedAce(m_paclDiscretionary, ACL_REVISION, FILE_ALL_ACCESS, m_psidAdmin))
    {
        THROW_ERROR_WIN32(GetLastError(), L"AddAccessAllowedAce");
    }

    //
    // Set the DACL into the security descriptor.
    //
    if( !SetSecurityDescriptorDacl(m_psdStorage, TRUE, m_paclDiscretionary, FALSE))
    {
        THROW_ERROR_WIN32(GetLastError(), L"SetSecurityDescriptorDacl");
    }

}//TWriteSchemaBin::SetSecurityDescriptor
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\wstring.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

// wstring class is a minimal version of std::wstring.  sdt::wstring requires the entire stl.
// Be warned! this class throws exceptions so wrap non-const calls in try-catch
class wstring
{
public:
    wstring() : pstr(0), cbbuffer(0), cbpstr(0){}
    wstring(wstring &str) : pstr(0){assign(str.c_str());}
    wstring(const wchar_t *psz) : pstr(0){assign(psz);}
    ~wstring(){if(pstr)CoTaskMemFree(pstr);}

    const wchar_t * c_str() const {return pstr;}
    operator const wchar_t*() const {return pstr;}

    wstring & operator =(const wstring &str){return assign(str.c_str());}
    wstring & operator +=(const wstring &str){return append(str.c_str());}
    wstring & operator =(const wchar_t *psz){return assign(psz);}
    wstring & operator +=(const wchar_t *psz){return append(psz);}
    bool      operator ==(const wstring &str) const {return isequal(str.c_str());}
    bool      operator ==(const wchar_t *psz) const {return isequal(psz);}
    bool      operator !=(const wstring &str) const {return !isequal(str.c_str());}
    bool      operator !=(const wchar_t *psz) const {return !isequal(psz);}

    size_t length()const {return (0==pstr) ? 0 : wcslen(pstr);}
    void   truncate(size_t i){if(i<length())pstr[i]=0x00;}
private:
    wchar_t *pstr;
    SIZE_T   cbbuffer;
    SIZE_T   cbpstr;

    wstring & append(const wchar_t *psz)
    {
        if(!pstr)
            assign(psz);
        else if(psz)
        {
            SIZE_T cbpsz = (wcslen(psz)+1)*sizeof(wchar_t);
            if((cbpstr+cbpsz-sizeof(wchar_t)) > cbbuffer)
            {
                cbbuffer = (cbpstr+cbpsz-sizeof(wchar_t)) * 2;
                pstr = reinterpret_cast<wchar_t *>(CoTaskMemRealloc(pstr, cbbuffer));
                if(0==pstr)
                    THROW(ERROR - OUTOFMEMORY);
            }
            memcpy(reinterpret_cast<char *>(pstr) + (cbpstr-sizeof(wchar_t)), psz, cbpsz);
            cbpstr += (cbpsz-sizeof(wchar_t));
        }
        return *this;
    }
    wstring & assign(const wchar_t *psz)
    {
        if(psz)
        {
            cbpstr = (wcslen(psz) + 1)*sizeof(wchar_t);
            cbbuffer = cbpstr * 2;//presume that strings will be appended
            pstr = reinterpret_cast<wchar_t *>(CoTaskMemRealloc(pstr, cbbuffer));
            if(0==pstr)
                THROW(ERROR - OUTOFMEMORY);
            memcpy(pstr, psz, cbpstr);
        }
        return *this;
    }
    bool      isequal(const wchar_t *psz) const {return (0==wcscmp(pstr, psz));}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\catalogpropertywriter.h ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    MBPropertyWriter.h

Abstract:

    Header of the class that writes proterty information in the schema file.
    (after schema compilation). 

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#pragma once

class CCatalogCollectionWriter;

class CCatalogPropertyWriter
{
	public:
		
		CCatalogPropertyWriter();
		~CCatalogPropertyWriter();

		void Initialize(tCOLUMNMETARow*		i_pProperty,
                        ULONG*              i_aPropertySize,
			            tTABLEMETARow*		i_pCollection,
			            CWriter*			i_pcWriter);

		HRESULT AddFlagToProperty(tTAGMETARow*		    i_pFlag);

		HRESULT WriteProperty();

	private:
	
		HRESULT WritePropertyLong();
		HRESULT WritePropertyShort();
		HRESULT BeginWritePropertyLong();
		HRESULT EndWritePropertyLong();
		HRESULT WriteFlag(ULONG		i_Flag);
		HRESULT ReAllocate();
		DWORD   MetabaseTypeFromColumnMetaType();

		CWriter*		m_pCWriter;
		tCOLUMNMETARow	m_Property;
        ULONG           m_PropertySize[cCOLUMNMETA_NumberOfColumns];
        tTABLEMETARow*	m_pCollection;


		tTAGMETARow*				m_aFlag;
		ULONG						m_cFlag;
		ULONG						m_iFlag;

}; // CCatalogPropertyWriter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\catalogcollectionwriter.h ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    CatalogCollectionWriter.h

Abstract:

    Header of the class that writes class (or collection) information
    in the schema file (after schema compilation). 

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#pragma once

class CCatalogCollectionWriter
{
    public:
        
        CCatalogCollectionWriter();
        ~CCatalogCollectionWriter();

        void Initialize(tTABLEMETARow*  i_pCollection,
                        CWriter*        i_pcWriter);

        HRESULT GetPropertyWriter(tCOLUMNMETARow*           i_pProperty,
                                  ULONG*                    i_aPropertySize,
                                  CCatalogPropertyWriter**  o_pProperty);
        HRESULT WriteCollection();

    private:

        HRESULT ReAllocate();
        HRESULT BeginWriteCollection();
        HRESULT EndWriteCollection();

        CWriter*                    m_pCWriter;
        tTABLEMETARow               m_Collection;
        CCatalogPropertyWriter**    m_apProperty;
        ULONG                       m_cProperty;
        ULONG                       m_iProperty;

}; // CCatalogCollectionWriter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\core\schemagen\xmlutility.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

#ifndef _CLSID_DOMDocument
#define _CLSID_DOMDocument TMSXMLBase::GetCLSID_DOMDocument()
#define _IID_IXMLDOMDocument IID_IXMLDOMDocument
#define _IID_IXMLDOMElement IID_IXMLDOMElement
#endif

extern wchar_t g_szProgramVersion[];

struct TOLEDataTypeToXMLDataType
{
    LPCWSTR String;
    LPCWSTR MappedString;
    bool    bImplicitlyRequired;//if true, we assume NOTNULLABLE thus the attribute is required
    DWORD   dbType;
    ULONG   cbSize;
    ULONG   fCOLUMNMETA;
    ULONG   fCOLUMNSCHEMAGENERATOR;
};
extern TOLEDataTypeToXMLDataType OLEDataTypeToXMLDataType[];

//In addition to DBTYPE_UI4, DBTYPE_BYTES, DBTYPE_WSTR, and DBTYPE_DBTIMESTAMP, we also support the following
//defines for specifying data types.  These come from the metabase; and like the DBTYPEs, their values cannot be changed.
#define DWORD_METADATA                          (     0x01)
#define STRING_METADATA                         (     0x02)
#define BINARY_METADATA                         (     0x03)
#define EXPANDSZ_METADATA                       (     0x04)
#define MULTISZ_METADATA                        (     0x05)



const unsigned int  kLargestPrime = 5279;//20011;

//These are the strings read from CatMeta XML files.  Any chagnes to the PublicNames of the meta tables requires a change here.
//Example: SchemaGeneratorFlags was renamed to MetaFlagsEx.  The constant is still kszSchemaGenFlags, but its value is L"MetaFlagsEx".
#define kszAttributes           (L"Attributes")
#define kszBaseVersion          (L"BaseVersion")
#define kszcbSize               (L"Size")
#define kszCellName             (L"CellName")
#define kszCharacterSet         (L"CharacterSet")
#define kszChildElementName     (L"ChildElementName")
#define kszColumnInternalName   (L"ColumnInternalName")
#define kszColumnMeta           (L"Property")
#define kszColumnMetaFlags      (L"MetaFlags")
#define kszConfigItemName       (L"ItemClass")
#define kszConfigCollectionName (L"ItemCollection")
#define kszContainerClassList   (L"ContainerClassList")
#define kszDatabaseInternalName (L"InternalName")
#define kszDatabaseMeta         (L"DatabaseMeta")
#define kszDescription          (L"Description")
#define kszdbType               (L"Type")
#define kszDefaultValue         (L"DefaultValue")
#define kszEnumMeta             (L"Enum")
#define kszExtendedVersion      (L"ExtendedVersion")
#define kszFlagMeta             (L"Flag")
#define kszForeignTable         (L"ForeignTable")
#define kszForeignColumns       (L"ForeignColumns")
#define kszID                   (L"ID")
#define kszIndexMeta            (L"IndexMeta")
#define kszInheritsColumnMeta   (L"InheritsPropertiesFrom")
#define kszInterceptor          (L"Interceptor")
#define kszInterceptorDLLName   (L"InterceptorDLLName")
#define kszInternalName         (L"InternalName")
#define kszLocator              (L"Locator")
#define kszMaximumValue         (L"EndingNumber")
#define kszMerger               (L"Merger")
#define kszMergerDLLName        (L"MergerDLLName")
#define kszMetaFlags            (L"MetaFlags")
#define kszMinimumValue         (L"StartingNumber")
#define kszNameColumn           (L"NameColumn")
#define kszNameValueMeta        (L"NameValue")
#define kszNavColumn            (L"NavColumn")
#define kszOperator             (L"Operator")
#define kszPrimaryTable         (L"PrimaryTable")
#define kszPrimaryColumns       (L"PrimaryColumns")
#define kszPublicName           (L"PublicName")
#define kszPublicColumnName     (L"PublicColumnName")
#define kszPublicRowName        (L"PublicRowName")
#define kszQueryMeta            (L"QueryMeta")
#define kszReadPlugin           (L"ReadPlugin")
#define kszReadPluginDLLName    (L"ReadPluginDLLName")
#define kszRelationMeta         (L"RelationMeta")
#define kszSchemaGenFlags       (L"MetaFlagsEx")
#define kszServerWiring         (L"ServerWiring")
#define kszTableMeta            (L"Collection")
#define kszTableMetaFlags       (L"MetaFlags")
#define kszUserType             (L"UserType")
#define kszValue                (L"Value")
#define kszWritePlugin          (L"WritePlugin")
#define kszWritePluginDLLName   (L"WritePluginDLLName")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\catalogschemawriter.h ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    CatalogSchemaWriter.h

Abstract:

    Header of the class that writes schema information in the schema file. 
    (after schema compilation). 
    
Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#pragma once

class CCatalogSchemaWriter
{
    public:
        
        CCatalogSchemaWriter(CWriter*   i_pcWriter);
        ~CCatalogSchemaWriter();

        HRESULT GetCollectionWriter(tTABLEMETARow*              i_pCollection,
                                    CCatalogCollectionWriter**  o_pCollectionWriter);

        HRESULT WriteSchema();

    private:

        HRESULT ReAllocate();
        HRESULT BeginWriteSchema();
        HRESULT EndWriteSchema();

        CCatalogCollectionWriter**  m_apCollection;
        ULONG                       m_cCollection;
        ULONG                       m_iCollection;
        CWriter*                    m_pCWriter;

}; // CCatalogSchemaWriter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\catmacros.h ===
#pragma once

//-------------------------------------------------------------------------
//
// LOG_ERROR(type,args)	Constructs an error object and writes it to the log.
//						The "type" tells which derived error object you want
//						to construct and "args" become the parameters to the
//						constructor for that class. The type is only the
//						trailing portion of the class name (e.g. Simple, HR, Win32).
//						Extra parens are required around the constructor
//						parameters.
//
//-------------------------------------------------------------------------

// Examples:
// LOG_ERROR(Simple, (ID_CAT_MTSTOCOM, IDS_I_MTSTOCOM_LAUNCH_STARTED));
// LOG_ERROR(HR,(hr, ID_CAT_CAT, ID_COMCAT_REGDBSVR_INITFAILED));
// LOG_ERROR(Win32, (GetLastError(), ID_CAT_ASP, ID_COMSVCS_IDENTIFY_CALLER	, L"CopySid"));

#define	LOG_ERROR(t,a)		    {CError ## t _e_ a; _e_.WriteToLog(W(__FILE__), __LINE__);}
#define LOG_ERROR_LOS(los,t,a)  {CError ## t _e_ a; _e_.WriteToLog(W(__FILE__), __LINE__, los);}


//-------------------------------------------------------------------------
// helper classes and functions
//-------------------------------------------------------------------------
class CSemExclusive;

//
// CError - universal error-handling class for COM+ Services
//

#define MSGBUFSIZE 4096

class CError {

private:    // protected member data

    WORD        m_wCat;                 // event log message category
    DWORD       m_dwMsgId;              // event log message id

    HRESULT     m_hr;                   // error code to report

    PVOID       m_pvData;               // extended data to log
    size_t      m_cbData;               // size of extended data

    // If related to a customer method call, log information pertinent to
    // the call.
    GUID        m_clsid;
    GUID        m_iid;
    long        m_lMethId;
    long        m_lDispId;

public:

    CError (
        HRESULT     hr,
        WORD        wCat,
        DWORD       dwMsgId,
        LPWSTR      szMsg,
        PVOID       pvData,
        unsigned    cbData,
        REFGUID     rclsid,
        REFGUID     riid,
        long        lMethId,
        long        lDispId
    );

    void SetMethod(REFGUID rclsid, REFGUID riid, long lMethId, long lDispId)
    {
        m_clsid = rclsid;
        m_iid = riid;
        m_lMethId = lMethId;
        m_lDispId = lDispId;
    }

    void SetExtData(PVOID pvData, size_t cbData)
    {
        m_pvData = pvData;
        m_cbData = cbData;
    }

    void SetHRESULT(HRESULT hr)
    {
        m_hr = hr;
    }

    void SetError(WORD wCat, DWORD dwMsgId)
    {
        m_wCat = wCat;
        m_dwMsgId = dwMsgId;
    }

    void SetMessage(LPWSTR msg, ...);

    void WriteToLog(LPWSTR szFile, unsigned uLine);
};

/////////////////////////////////////////////////////
//
// CErrorInterceptor
//
// This object is like the other CError objects.  It
// takes some parameters and either builds a DetailedErrors
// table or it writes an entry into the event log (and
// into the CatalogEventLog XML file).
//
class CErrorInterceptor
{
public://This first ctor is so we can replace CErrorWin32
    CErrorInterceptor(  HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1=0,
                        LPCWSTR                         szString2=0,
                        LPCWSTR                         szString3=0,
                        LPCWSTR                         szString4=0,
                        eDETAILEDERRORS_Type            eType=eDETAILEDERRORS_SUCCESS,
                        unsigned char *                 pData=0,
                        ULONG                           cbData=0,
                        BOOL                            bNotUsed=false);
    CErrorInterceptor(  ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        ULONG                           ulInterceptor=0,
                        LPCWSTR                         szTable=0,
                        eDETAILEDERRORS_OperationType   OperationType=eDETAILEDERRORS_Unspecified,
                        ULONG                           ulRow=-1,
                        ULONG                           ulColumn=-1,
                        LPCWSTR                         szConfigurationSource=0,
                        eDETAILEDERRORS_Type            eType=eDETAILEDERRORS_SUCCESS,
                        unsigned char *                 pData=0,
                        ULONG                           cbData=0,
                        ULONG                           MajorVersion=-1,
                        ULONG                           MinorVersion=-1);
    CErrorInterceptor(  ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        ULONG                           ulInterceptor=0,
                        LPCWSTR                         szTable=0,
                        eDETAILEDERRORS_OperationType   OperationType=eDETAILEDERRORS_Unspecified,
                        ULONG                           ulRow=-1,
                        ULONG                           ulColumn=-1,
                        LPCWSTR                         szConfigurationSource=0,
                        eDETAILEDERRORS_Type            eType=eDETAILEDERRORS_SUCCESS,
                        unsigned char *                 pData=0,
                        ULONG                           cbData=0,
                        ULONG                           MajorVersion=-1,
                        ULONG                           MinorVersion=-1);
    CErrorInterceptor(  ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        LPCWSTR                         szString3,
                        ULONG                           ulInterceptor=0,
                        LPCWSTR                         szTable=0,
                        eDETAILEDERRORS_OperationType   OperationType=eDETAILEDERRORS_Unspecified,
                        ULONG                           ulRow=-1,
                        ULONG                           ulColumn=-1,
                        LPCWSTR                         szConfigurationSource=0,
                        eDETAILEDERRORS_Type            eType=eDETAILEDERRORS_SUCCESS,
                        unsigned char *                 pData=0,
                        ULONG                           cbData=0,
                        ULONG                           MajorVersion=-1,
                        ULONG                           MinorVersion=-1);
    CErrorInterceptor(  ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        LPCWSTR                         szString3,
                        LPCWSTR                         szString4,
                        ULONG                           ulInterceptor=0,
                        LPCWSTR                         szTable=0,
                        eDETAILEDERRORS_OperationType   OperationType=eDETAILEDERRORS_Unspecified,
                        ULONG                           ulRow=-1,
                        ULONG                           ulColumn=-1,
                        LPCWSTR                         szConfigurationSource=0,
                        eDETAILEDERRORS_Type            eType=eDETAILEDERRORS_SUCCESS,
                        unsigned char *                 pData=0,
                        ULONG                           cbData=0,
                        ULONG                           MajorVersion=-1,
                        ULONG                           MinorVersion=-1);
    ~CErrorInterceptor()
    {
        delete m_pStorage;
    }
    HRESULT WriteToLog(LPCWSTR szSource, ULONG Line, ULONG los=fST_LOS_DETAILED_ERROR_TABLE);

    enum
    {
         cchCategoryString   =64
        ,cchComputerName     =256
        ,cchDate             =256
        ,cchDescription      =4096
        ,cchInterceptorSource=256
        ,cchSource           =64
        ,cchSourceFileName   =256
        ,cchMessageString    =1024 //Per documentation on FormatMessage.
        ,cchString1          =1024 //No single insertion string may exceed 1023 characters in length.
        ,cchString2          =1024
        ,cchString3          =1024
        ,cchString4          =1024
        ,cchString5          =1024
        ,cchTime             =256
        ,cchUserName         =256
    };
private:
    static ULONG cError;


    class ErrorInterceptorStorage
    {
    public:     //these are the only two that need to be explicitly
        ErrorInterceptorStorage() : m_pISTControllerError(0), m_pIErrorInfo(0)
        {
            memset(&m_errRow, 0x00, sizeof(m_errRow));
        }
        ~ErrorInterceptorStorage()
        {
            if(m_pISTControllerError)
                m_pISTControllerError->Release();
            if(m_pIErrorInfo)
                m_pIErrorInfo->Release();
        }

        ULONG                       m_Category;
        ULONG                       m_Column;
        ULONG                       m_ErrorCode;
        ULONG                       m_ErrorID;
        tDETAILEDERRORSRow          m_errRow;
        ULONG                       m_Event;
        ULONG                       m_Interceptor;
        ULONG                       m_MajorVersion;
        ULONG                       m_MinorVersion;
        ULONG                       m_OperationType;
        IAdvancedTableDispenser *   m_pDispenser;//This one is passed in by the user and does NOT need to be released
        IErrorInfo *                m_pIErrorInfo;//This interface DOES need to be released
        ISimpleTableWrite2 *        m_pISTWriteError;//This one is exactly what we return to the user, so we don't have a ref to this
        ISimpleTableController *    m_pISTControllerError;//This interface DOES need to be released
        ULONG                       m_Row;
        WCHAR                       m_szCategoryString[cchCategoryString];
        WCHAR                       m_szComputerName[cchComputerName];
        WCHAR                       m_szDate[cchDate];
        WCHAR                       m_szDescription[cchDescription];
        WCHAR                       m_szInterceptorSource[cchInterceptorSource];
        WCHAR                       m_szMessageString[cchMessageString];
        WCHAR                       m_szSource[cchSource];
        WCHAR                       m_szSourceFileName[cchSourceFileName];
        WCHAR                       m_szString1[cchString1];
        WCHAR                       m_szString2[cchString2];
        WCHAR                       m_szString3[cchString3];
        WCHAR                       m_szString4[cchString4];
        WCHAR                       m_szString5[cchString5];
        WCHAR                       m_szTime[cchTime];
        WCHAR                       m_szUserName[cchUserName];
        ULONG                       m_Type;
    };

    HRESULT                     m_hr;
    ErrorInterceptorStorage *   m_pStorage;

    void Init(  ISimpleTableWrite2 **           ppErrInterceptor,
                IAdvancedTableDispenser *       pDisp,
                HRESULT                         hrErrorCode,
                ULONG                           ulCategory,
                ULONG                           ulEvent,
                LPCWSTR                         szString1=0,
                LPCWSTR                         szString2=0,
                LPCWSTR                         szString3=0,
                LPCWSTR                         szString4=0,
                ULONG                           ulInterceptor=0,
                LPCWSTR                         szTable=0,
                eDETAILEDERRORS_OperationType   OperationType=eDETAILEDERRORS_Unspecified,
                ULONG                           ulRow=-1,
                ULONG                           ulColumn=-1,
                LPCWSTR                         szConfigurationSource=0,
                eDETAILEDERRORS_Type            eType=eDETAILEDERRORS_SUCCESS,
                unsigned char *                 pData=0,
                ULONG                           cbData=0,
                ULONG                           MajorVersion=-1,
                ULONG                           MinorVersion=-1);
    void SetCategory(ULONG ulCategory);
    void SetColumn(ULONG ulColumn);
    void SetComputer();
    void SetConfigurationSource(LPWSTR wszConfigurationSource);
    void SetDate(SYSTEMTIME &systime);
    void SetData();
    void SetDescription();//Must be called after SetString5 since FormatString will rely on String1-5.
    void SetErrorCode(HRESULT hr);
    void SetErrorID(SYSTEMTIME &systime);
    void SetEvent(ULONG ulEvent);
    void SetInterceptor(ULONG ulInterceptor);
    void SetInterceptorSource(LPCWSTR file, ULONG line);
    void SetMajorVersion(ULONG ulMajorVersion);
    void SetMessageString();//Must be called before SetDescription
    void SetMinorVersion(ULONG ulMinorVersion);
    void SetOperationType(eDETAILEDERRORS_OperationType OperationType);
    void SetRow(ULONG ulRow);
    void SetSource(IAdvancedTableDispenser *pDisp);
    void SetSourceFileName();//comes from g_hModule
    void SetString1(LPWSTR wsz);
    void SetString2(LPWSTR wsz);
    void SetString3(LPWSTR wsz);
    void SetString4(LPWSTR wsz);
    void SetString5();//This string is formed from the column values and must be called after all the dependant columns have been set
    void SetTable(LPWSTR wszTable);
    void SetTime(SYSTEMTIME &systime);
    void SetType(HRESULT hrErrorCode, eDETAILEDERRORS_Type eType);
    void SetUser();
};


inline void FillInInsertionString5(LPWSTR wszString5Buffer, ULONG cchString5Buffer, tDETAILEDERRORSRow & errRow)
{
    if(errRow.pString5)
        return;//nothing to do, it's already Not NULL

    if(0 == wszString5Buffer)
        return;
    if(0 == cchString5Buffer)
        return;

    //Generate pString5 from columns.  pString5 contains all the columns after pString4
    //    iDETAILEDERRORS_ErrorCode,
    //    iDETAILEDERRORS_Interceptor,
    //    iDETAILEDERRORS_InterceptorSource,
    //    iDETAILEDERRORS_OperationType,
    //    iDETAILEDERRORS_Table,
    //    iDETAILEDERRORS_ConfigurationSource,
    //    iDETAILEDERRORS_Row,
    //    iDETAILEDERRORS_Column,

    //cDETAILEDERRORS_NumberOfColumns

    //We could make this process meta driven; but this object WILL need to be modified
    //if the meta for the DetailedErrors table changes, so why bother.
    static LPCWSTR pwszOperationType[3]={L"Unspecified", L"Populate", L"UpdateStore"};

    WCHAR *pString=wszString5Buffer;

    pString[0] = 0x00;//start with 0 length string
    long size;
    if(errRow.pErrorCode)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: 0x%08X", L"ErrorCode",           *errRow.pErrorCode);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pInterceptor)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %d",   L"Interceptor",         *errRow.pInterceptor);
        pString += (size<0 ? size*-1 : size);
    }

#ifdef _DEBUG
    //We're not going to put the Source file and line number since it might confuse some user.
    if(errRow.pInterceptorSource)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %s",   L"InterceptorSource",   errRow.pInterceptorSource);
        pString += (size<0 ? size*-1 : size);
    }
#endif

    if(errRow.pOperationType && *errRow.pOperationType<3)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %s",   L"OperationType",       pwszOperationType[*errRow.pOperationType]);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pTable)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %s",   L"Table",               errRow.pTable);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pConfigurationSource)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %s",   L"ConfigurationSource", errRow.pConfigurationSource);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pRow)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %d",   L"Row",                 *errRow.pRow);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pColumn)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %d",   L"Column",              *errRow.pColumn);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pMajorVersion)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %d",   L"MajorVersion",        *errRow.pMajorVersion);
        pString += (size<0 ? size*-1 : size);
    }

    if(errRow.pMinorVersion)
    {
        size = _snwprintf(pString, cchString5Buffer-(pString-wszString5Buffer), L"\r\n%-20s: %d",   L"MinorVersion",        *errRow.pMinorVersion);
        pString += (size<0 ? size*-1 : size);
    }

    wszString5Buffer[cchString5Buffer-1] = 0x00;//make sure it's NULL terminated
    errRow.pString5 = wszString5Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\catmeta.h ===
//  catmeta.h - Table Names and Helper enums and flags.  
//  Generated 10/17/2002 15:36:10 by Catalog Utility - Version from Mon Jul  8 17:10:48 2002 built on Oct 17 2002 14:50:24 
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved. 

#ifndef __TABLEINFO_H__  
#define __TABLEINFO_H__  

#ifndef _OBJBASE_H_
    #include <objbase.h>
#endif
#ifdef REGSYSDEFNS_DEFINE
    #include <initguid.h>
#endif

// -----------------------------------------                             
// PRODUCT constants:                                                    
// -----------------------------------------                             
#define WSZ_PRODUCT_IIS			            L"IIS"                   

//The Meta flags exist in two places.  When a new flag is added it needs 
//into the following:                                                    
//XMLUtility.h                                                           
//CatMeta.xml                                                            

//These macros are needed for the metabase
#define SynIDFromMetaFlagsEx(MetaFlagsEx) ((MetaFlagsEx>>2)&0x0F)
#define kInferredColumnMetaFlags   (fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE)
#define kInferredColumnMetaFlagsEx (fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED)


//------------------------------DatabaseName---------------------------   
#define wszDATABASE_META                                    L"META"
#define wszDATABASE_ERRORS                                  L"ERRORS"
#define wszDATABASE_PACKEDSCHEMA                            L"PACKEDSCHEMA"
#define wszDATABASE_CONFIGSYS                               L"CONFIGSYS"
#define wszDATABASE_MEMORY                                  L"MEMORY"
#define wszDATABASE_FIXED                                   L"FIXED"
#define wszDATABASE_MOFGENERATOR                            L"MOFGENERATOR"
#define wszDATABASE_METABASE                                L"METABASE"





//-------------------------------TableName-----------------------------   
#define wszTABLE_COLUMNMETA                              L"COLUMNMETA"
#define TABLEID_COLUMNMETA                               (0xfe16a100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_COLUMNMETA                           (0L)
#define ExtendedVersion_COLUMNMETA                       (0L)

//----------------IndexMeta------------------------   
#define COLUMNMETA_ByName L"ByName"
#define COLUMNMETA_ByID L"ByID"

//-----------------Column Index Enums--------------   
enum eCOLUMNMETA {
    iCOLUMNMETA_Table,  
    iCOLUMNMETA_Index,  
    iCOLUMNMETA_InternalName,  
    iCOLUMNMETA_PublicName,  
    iCOLUMNMETA_Type,  
    iCOLUMNMETA_Size,  
    iCOLUMNMETA_MetaFlags,  
    iCOLUMNMETA_DefaultValue,  
    iCOLUMNMETA_FlagMask,  
    iCOLUMNMETA_StartingNumber,  
    iCOLUMNMETA_EndingNumber,  
    iCOLUMNMETA_CharacterSet,  
    iCOLUMNMETA_SchemaGeneratorFlags,  
    iCOLUMNMETA_ID,  
    iCOLUMNMETA_UserType,  
    iCOLUMNMETA_Attributes,  
    iCOLUMNMETA_Description,  
    iCOLUMNMETA_PublicColumnName,  
    cCOLUMNMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tCOLUMNMETARow {
         WCHAR *     pTable;
         ULONG *     pIndex;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pType;
         ULONG *     pSize;
         ULONG *     pMetaFlags;
 unsigned char *     pDefaultValue;
         ULONG *     pFlagMask;
         ULONG *     pStartingNumber;
         ULONG *     pEndingNumber;
         WCHAR *     pCharacterSet;
         ULONG *     pSchemaGeneratorFlags;
         ULONG *     pID;
         ULONG *     pUserType;
         ULONG *     pAttributes;
         WCHAR *     pDescription;
         WCHAR *     pPublicColumnName;
};

enum eCOLUMNMETA_Type {
    eCOLUMNMETA_Boolean           	=	      19,	//(0x00000013)
    eCOLUMNMETA_Bool              	=	      19,	//(0x00000013)
    eCOLUMNMETA_StrictBool        	=	      19,	//(0x00000013)
    eCOLUMNMETA_Enum              	=	      19,	//(0x00000013)
    eCOLUMNMETA_Flag              	=	      19,	//(0x00000013)
    eCOLUMNMETA_int32             	=	      19,	//(0x00000013)
    eCOLUMNMETA_ByteBracketBracket	=	     128,	//(0x00000080)
    eCOLUMNMETA_String            	=	     130,	//(0x00000082)
    eCOLUMNMETA_UI4               	=	      19,	//(0x00000013)
    eCOLUMNMETA_GUID              	=	      72,	//(0x00000048)
    eCOLUMNMETA_BYTES             	=	     128,	//(0x00000080)
    eCOLUMNMETA_WSTR              	=	     130,	//(0x00000082)
    eCOLUMNMETA_DBTIMESTAMP       	=	     135,	//(0x00000087)
    eCOLUMNMETA_DWORD_METADATA    	=	      19,	//(0x00000013)
    eCOLUMNMETA_STRING_METADATA   	=	     130,	//(0x00000082)
    eCOLUMNMETA_BINARY_METADATA   	=	     128,	//(0x00000080)
    eCOLUMNMETA_EXPANDSZ_METADATA 	=	     130,	//(0x00000082)
    eCOLUMNMETA_MULTISZ_METADATA  	=	     130,	//(0x00000082)
    eCOLUMNMETA_BOOL_BITMASK      	=	      19,	//(0x00000013)
    eCOLUMNMETA_MIMEMAP           	=	     130,	//(0x00000082)
    eCOLUMNMETA_IPSECLIST         	=	     128,	//(0x00000080)
    eCOLUMNMETA_NTACL             	=	     128,	//(0x00000080)
    eCOLUMNMETA_HTTPERRORS        	=	     130,	//(0x00000082)
    eCOLUMNMETA_HTTPHEADERS       	=	     130,	//(0x00000082)
    eCOLUMNMETA_XMLBLOB           	=	     130	//(0x00000082)
};

enum eCOLUMNMETA_MetaFlags {
    fCOLUMNMETA_PRIMARYKEY        	=	0x00000001,	//(1 decimal)
    fCOLUMNMETA_FOREIGNKEY        	=	0x00000002,	//(2 decimal)
    fCOLUMNMETA_NAMECOLUMN        	=	0x00000004,	//(4 decimal)
    fCOLUMNMETA_NAVCOLUMN         	=	0x00000008,	//(8 decimal)
    fCOLUMNMETA_DIRECTIVE         	=	0x00000010,	//(16 decimal)
    fCOLUMNMETA_BOOL              	=	0x00000020,	//(32 decimal)
    fCOLUMNMETA_FLAG              	=	0x00000040,	//(64 decimal)
    fCOLUMNMETA_ENUM              	=	0x00000080,	//(128 decimal)
    fCOLUMNMETA_WRITENEVER        	=	0x00000100,	//(256 decimal)
    fCOLUMNMETA_WRITEONCHANGE     	=	0x00000200,	//(512 decimal)
    fCOLUMNMETA_WRITEONINSERT     	=	0x00000400,	//(1024 decimal)
    fCOLUMNMETA_NOTPUBLIC         	=	0x00000800,	//(2048 decimal)
    fCOLUMNMETA_NOTDOCD           	=	0x00001000,	//(4096 decimal)
    fCOLUMNMETA_PUBLICREADONLY    	=	0x00002000,	//(8192 decimal)
    fCOLUMNMETA_PUBLICWRITEONLY   	=	0x00004000,	//(16384 decimal)
    fCOLUMNMETA_LOCALIZABLE       	=	0x00008000,	//(32768 decimal)
    fCOLUMNMETA_INSERTGENERATE    	=	0x00010000,	//(65536 decimal)
    fCOLUMNMETA_INSERTUNIQUE      	=	0x00020000,	//(131072 decimal)
    fCOLUMNMETA_INSERTPARENT      	=	0x00040000,	//(262144 decimal)
    fCOLUMNMETA_NOTNULLABLE       	=	0x00080000,	//(524288 decimal)
    fCOLUMNMETA_FIXEDLENGTH       	=	0x00100000,	//(1048576 decimal)
    fCOLUMNMETA_HASNUMERICRANGE   	=	0x00200000,	//(2097152 decimal)
    fCOLUMNMETA_LEGALCHARSET      	=	0x00400000,	//(4194304 decimal)
    fCOLUMNMETA_ILLEGALCHARSET    	=	0x00800000,	//(8388608 decimal)
    fCOLUMNMETA_NOTPERSISTABLE    	=	0x01000000,	//(16777216 decimal)
    fCOLUMNMETA_MULTISTRING       	=	0x02000000,	//(33554432 decimal)
    fCOLUMNMETA_EXPANDSTRING      	=	0x04000000,	//(67108864 decimal)
    fCOLUMNMETA_UNKNOWNSIZE       	=	0x08000000,	//(134217728 decimal)
    fCOLUMNMETA_VARIABLESIZE      	=	0x10000000,	//(268435456 decimal)
    fCOLUMNMETA_CASEINSENSITIVE   	=	0x20000000,	//(536870912 decimal)
    fCOLUMNMETA_TOLOWERCASE       	=	0x40000000,	//(1073741824 decimal)
    fCOLUMNMETA_MetaFlags_Mask	= 0x7fffffff
};

enum eCOLUMNMETA_SchemaGeneratorFlags {
    fCOLUMNMETA_CACHE_PROPERTY_MODIFIED	=	0x00000001,	//(1 decimal)
    fCOLUMNMETA_CACHE_PROPERTY_CLEARED	=	0x00000002,	//(2 decimal)
    fCOLUMNMETA_EXTENDEDTYPE0     	=	0x00000004,	//(4 decimal)
    fCOLUMNMETA_EXTENDEDTYPE1     	=	0x00000008,	//(8 decimal)
    fCOLUMNMETA_EXTENDEDTYPE2     	=	0x00000010,	//(16 decimal)
    fCOLUMNMETA_EXTENDEDTYPE3     	=	0x00000020,	//(32 decimal)
    fCOLUMNMETA_PROPERTYISINHERITED	=	0x00000040,	//(64 decimal)
    fCOLUMNMETA_USEASPUBLICROWNAME	=	0x00000080,	//(128 decimal)
    fCOLUMNMETA_EXTENDED          	=	0x00000100,	//(256 decimal)
    fCOLUMNMETA_MANDATORY         	=	0x00000200,	//(512 decimal)
    fCOLUMNMETA_USERDEFINED       	=	0x00000400,	//(1024 decimal)
    fCOLUMNMETA_WAS_NOTIFICATION  	=	0x00000800,	//(2048 decimal)
    fCOLUMNMETA_XMLBLOB           	=	0x00001000,	//(4096 decimal)
    fCOLUMNMETA_HIDDEN            	=	0x00010000,	//(65536 decimal)
    fCOLUMNMETA_WAS_NOTIFICATION_ON_NO_CHANGE_IN_VALUE	=	0x00002000,	//(8192 decimal)
    fCOLUMNMETA_VALUEINCHILDELEMENT	=	0x00004000,	//(16384 decimal)
    fCOLUMNMETA_SchemaGeneratorFlags_Mask	= 0x00017fff
};

enum eCOLUMNMETA_UserType {
    eCOLUMNMETA_UNKNOWN_UserType  	=	       0,	//(0x00000000)
    eCOLUMNMETA_IIS_MD_UT_SERVER  	=	       1,	//(0x00000001)
    eCOLUMNMETA_IIS_MD_UT_FILE    	=	       2,	//(0x00000002)
    eCOLUMNMETA_IIS_MD_UT_WAM     	=	     100,	//(0x00000064)
    eCOLUMNMETA_ASP_MD_UT_APP     	=	     101	//(0x00000065)
};

enum eCOLUMNMETA_Attributes {
    fCOLUMNMETA_NO_ATTRIBUTES     	=	0x00000000,	//(0 decimal)
    fCOLUMNMETA_INHERIT           	=	0x00000001,	//(1 decimal)
    fCOLUMNMETA_PARTIAL_PATH      	=	0x00000002,	//(2 decimal)
    fCOLUMNMETA_SECURE            	=	0x00000004,	//(4 decimal)
    fCOLUMNMETA_REFERENCE         	=	0x00000008,	//(8 decimal)
    fCOLUMNMETA_VOLATILE          	=	0x00000010,	//(16 decimal)
    fCOLUMNMETA_ISINHERITED       	=	0x00000020,	//(32 decimal)
    fCOLUMNMETA_INSERT_PATH       	=	0x00000040,	//(64 decimal)
    fCOLUMNMETA_LOCAL_MACHINE_ONLY	=	0x00000080,	//(128 decimal)
    fCOLUMNMETA_Attributes_Mask	= 0x000000ff
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_DATABASEMETA                            L"DATABASEMETA"
#define TABLEID_DATABASEMETA                             (0xb125a100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_DATABASEMETA                         (0L)
#define ExtendedVersion_DATABASEMETA                     (0L)

//-----------------Column Index Enums--------------   
enum eDATABASEMETA {
    iDATABASEMETA_InternalName,  
    iDATABASEMETA_PublicName,  
    iDATABASEMETA_BaseVersion,  
    iDATABASEMETA_ExtendedVersion,  
    iDATABASEMETA_CountOfTables,  
    iDATABASEMETA_Description,  
    cDATABASEMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tDATABASEMETARow {
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pBaseVersion;
         ULONG *     pExtendedVersion;
         ULONG *     pCountOfTables;
         WCHAR *     pDescription;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_INDEXMETA                               L"INDEXMETA"
#define TABLEID_INDEXMETA                                (0x7530a100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_INDEXMETA                            (0L)
#define ExtendedVersion_INDEXMETA                        (0L)

//-----------------Column Index Enums--------------   
enum eINDEXMETA {
    iINDEXMETA_Table,  
    iINDEXMETA_InternalName,  
    iINDEXMETA_PublicName,  
    iINDEXMETA_ColumnIndex,  
    iINDEXMETA_ColumnInternalName,  
    iINDEXMETA_MetaFlags,  
    cINDEXMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tINDEXMETARow {
         WCHAR *     pTable;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pColumnIndex;
         WCHAR *     pColumnInternalName;
         ULONG *     pMetaFlags;
};

enum eINDEXMETA_MetaFlags {
    fINDEXMETA_UNIQUE             	=	0x00000001,	//(1 decimal)
    fINDEXMETA_SORTED             	=	0x00000002,	//(2 decimal)
    fINDEXMETA_MetaFlags_Mask	= 0x00000003
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_TABLEMETA                               L"TABLEMETA"
#define TABLEID_TABLEMETA                                (0x6ba9a100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_TABLEMETA                            (0L)
#define ExtendedVersion_TABLEMETA                        (0L)

//-----------------Column Index Enums--------------   
enum eTABLEMETA {
    iTABLEMETA_Database,  
    iTABLEMETA_InternalName,  
    iTABLEMETA_PublicName,  
    iTABLEMETA_PublicRowName,  
    iTABLEMETA_BaseVersion,  
    iTABLEMETA_ExtendedVersion,  
    iTABLEMETA_NameColumn,  
    iTABLEMETA_NavColumn,  
    iTABLEMETA_CountOfColumns,  
    iTABLEMETA_MetaFlags,  
    iTABLEMETA_SchemaGeneratorFlags,  
    iTABLEMETA_ConfigItemName,  
    iTABLEMETA_ConfigCollectionName,  
    iTABLEMETA_PublicRowNameColumn,  
    iTABLEMETA_ContainerClassList,  
    iTABLEMETA_Description,  
    iTABLEMETA_ChildElementName,  
    cTABLEMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tTABLEMETARow {
         WCHAR *     pDatabase;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         WCHAR *     pPublicRowName;
         ULONG *     pBaseVersion;
         ULONG *     pExtendedVersion;
         ULONG *     pNameColumn;
         ULONG *     pNavColumn;
         ULONG *     pCountOfColumns;
         ULONG *     pMetaFlags;
         ULONG *     pSchemaGeneratorFlags;
         WCHAR *     pConfigItemName;
         WCHAR *     pConfigCollectionName;
         ULONG *     pPublicRowNameColumn;
         WCHAR *     pContainerClassList;
         WCHAR *     pDescription;
         WCHAR *     pChildElementName;
};

enum eTABLEMETA_MetaFlags {
    fTABLEMETA_INTERNAL           	=	0x00000001,	//(1 decimal)
    fTABLEMETA_NOLISTENING        	=	0x00000002,	//(2 decimal)
    fTABLEMETA_RELATIONINTEGRITY  	=	0x00000004,	//(4 decimal)
    fTABLEMETA_ROWINTEGRITY       	=	0x00000008,	//(8 decimal)
    fTABLEMETA_HASUNKNOWNSIZES    	=	0x00000010,	//(16 decimal)
    fTABLEMETA_NOPUBLICINSERT     	=	0x00000020,	//(32 decimal)
    fTABLEMETA_NOPUBLICUPDATE     	=	0x00000040,	//(64 decimal)
    fTABLEMETA_NOPUBLICDELETE     	=	0x00000080,	//(128 decimal)
    fTABLEMETA_REQUIRESQUERY      	=	0x00000100,	//(256 decimal)
    fTABLEMETA_HASDIRECTIVES      	=	0x00000200,	//(512 decimal)
    fTABLEMETA_STOREDELTAS        	=	0x00000400,	//(1024 decimal)
    fTABLEMETA_AUTOGENITEMCLASS   	=	0x00000800,	//(2048 decimal)
    fTABLEMETA_AUTOGENCOLLECTIONCLASS	=	0x00001000,	//(4096 decimal)
    fTABLEMETA_OVERRIDEITEMCLASS  	=	0x00002000,	//(8192 decimal)
    fTABLEMETA_OVERRIDECOLLECTIONCLASS	=	0x00004000,	//(16384 decimal)
    fTABLEMETA_NAMEVALUEPAIRTABLE 	=	0x00008000,	//(32768 decimal)
    fTABLEMETA_HIDDEN             	=	0x00010000,	//(65536 decimal)
    fTABLEMETA_OVERWRITEALLROWS   	=	0x00020000,	//(131072 decimal)
    fTABLEMETA_MetaFlags_Mask	= 0x0003ffff
};

enum eTABLEMETA_SchemaGeneratorFlags {
    fTABLEMETA_EMITXMLSCHEMA      	=	0x00000001,	//(1 decimal)
    fTABLEMETA_EMITCLBBLOB        	=	0x00000002,	//(2 decimal)
    fTABLEMETA_ISCONTAINED        	=	0x00000004,	//(4 decimal)
    fTABLEMETA_NOTSCOPEDBYTABLENAME	=	0x00000008,	//(8 decimal)
    fTABLEMETA_GENERATECONFIGOBJECTS	=	0x00000010,	//(16 decimal)
    fTABLEMETA_NOTABLESCHEMAHEAPENTRY	=	0x00000020,	//(32 decimal)
    fTABLEMETA_CONTAINERCLASS     	=	0x00000040,	//(64 decimal)
    fTABLEMETA_EXTENDED           	=	0x00000100,	//(256 decimal)
    fTABLEMETA_USERDEFINED        	=	0x00000400,	//(1024 decimal)
    fTABLEMETA_SchemaGeneratorFlags_Mask	= 0x0000057f
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_TAGMETA                                 L"TAGMETA"
#define TABLEID_TAGMETA                                  (0x06bfa100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_TAGMETA                              (0L)
#define ExtendedVersion_TAGMETA                          (0L)

//----------------IndexMeta------------------------   
#define TAGMETA_ByTableAndTagNameOnly L"ByTableAndTagNameOnly"
#define TAGMETA_ByTableAndColumnIndexOnly L"ByTableAndColumnIndexOnly"
#define TAGMETA_ByTableAndColumnIndexAndNameOnly L"ByTableAndColumnIndexAndNameOnly"
#define TAGMETA_ByTableAndColumnIndexAndValueOnly L"ByTableAndColumnIndexAndValueOnly"
#define TAGMETA_ByTableAndTagIDOnly L"ByTableAndTagIDOnly"

//-----------------Column Index Enums--------------   
enum eTAGMETA {
    iTAGMETA_Table,  
    iTAGMETA_ColumnIndex,  
    iTAGMETA_InternalName,  
    iTAGMETA_PublicName,  
    iTAGMETA_Value,  
    iTAGMETA_ID,  
    cTAGMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tTAGMETARow {
         WCHAR *     pTable;
         ULONG *     pColumnIndex;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pValue;
         ULONG *     pID;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_RELATIONMETA                            L"RELATIONMETA"
#define TABLEID_RELATIONMETA                             (0x16dea100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_RELATIONMETA                         (0L)
#define ExtendedVersion_RELATIONMETA                     (0L)

//-----------------Column Index Enums--------------   
enum eRELATIONMETA {
    iRELATIONMETA_PrimaryTable,  
    iRELATIONMETA_PrimaryColumns,  
    iRELATIONMETA_ForeignTable,  
    iRELATIONMETA_ForeignColumns,  
    iRELATIONMETA_MetaFlags,  
    cRELATIONMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tRELATIONMETARow {
         WCHAR *     pPrimaryTable;
 unsigned char *     pPrimaryColumns;
         WCHAR *     pForeignTable;
 unsigned char *     pForeignColumns;
         ULONG *     pMetaFlags;
};

enum eRELATIONMETA_MetaFlags {
    fRELATIONMETA_CASCADEDELETE   	=	0x00000001,	//(1 decimal)
    fRELATIONMETA_PRIMARYREQUIRED 	=	0x00000002,	//(2 decimal)
    fRELATIONMETA_USECONTAINMENT  	=	0x00000004,	//(4 decimal)
    fRELATIONMETA_CONTAINASSIBLING	=	0x00000008,	//(8 decimal)
    fRELATIONMETA_HIDDEN          	=	0x00010000,	//(65536 decimal)
    fRELATIONMETA_MetaFlags_Mask	= 0x0001000f
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_QUERYMETA                               L"QUERYMETA"
#define TABLEID_QUERYMETA                                (0x6bbda100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_QUERYMETA                            (0L)
#define ExtendedVersion_QUERYMETA                        (0L)

//-----------------Column Index Enums--------------   
enum eQUERYMETA {
    iQUERYMETA_Table,  
    iQUERYMETA_InternalName,  
    iQUERYMETA_PublicName,  
    iQUERYMETA_Index,  
    iQUERYMETA_CellName,  
    iQUERYMETA_Operator,  
    iQUERYMETA_MetaFlags,  
    cQUERYMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tQUERYMETARow {
         WCHAR *     pTable;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pIndex;
         WCHAR *     pCellName;
         ULONG *     pOperator;
         ULONG *     pMetaFlags;
};

enum eQUERYMETA_Operator {
    eQUERYMETA_EQUAL              	=	       0,	//(0x00000000)
    eQUERYMETA_NOTEQUAL           	=	       1	//(0x00000001)
};

enum eQUERYMETA_MetaFlags {
    fQUERYMETA_ALL                	=	0x00000001,	//(1 decimal)
    fQUERYMETA_ANY                	=	0x00000002,	//(2 decimal)
    fQUERYMETA_MetaFlags_Mask	= 0x00000003
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_SERVERWIRINGMETA                        L"SERVERWIRINGMETA"
#define TABLEID_SERVERWIRINGMETA                         (0xd653ba00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_SERVERWIRINGMETA                     (0L)
#define ExtendedVersion_SERVERWIRINGMETA                 (0L)

//-----------------Column Index Enums--------------   
enum eSERVERWIRINGMETA {
    iSERVERWIRINGMETA_Table,  
    iSERVERWIRINGMETA_Order,  
    iSERVERWIRINGMETA_ReadPlugin,  
    iSERVERWIRINGMETA_ReadPluginDLLName,  
    iSERVERWIRINGMETA_WritePlugin,  
    iSERVERWIRINGMETA_WritePluginDLLName,  
    iSERVERWIRINGMETA_Interceptor,  
    iSERVERWIRINGMETA_InterceptorDLLName,  
    iSERVERWIRINGMETA_MetaFlags,  
    iSERVERWIRINGMETA_Locator,  
    iSERVERWIRINGMETA_Reserved,  
    iSERVERWIRINGMETA_Merger,  
    iSERVERWIRINGMETA_MergerDLLName,  
    cSERVERWIRINGMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tSERVERWIRINGMETARow {
         WCHAR *     pTable;
         ULONG *     pOrder;
         ULONG *     pReadPlugin;
         WCHAR *     pReadPluginDLLName;
         ULONG *     pWritePlugin;
         WCHAR *     pWritePluginDLLName;
         ULONG *     pInterceptor;
         WCHAR *     pInterceptorDLLName;
         ULONG *     pMetaFlags;
         WCHAR *     pLocator;
         ULONG *     pReserved;
         ULONG *     pMerger;
         WCHAR *     pMergerDLLName;
};

enum eSERVERWIRINGMETA_ReadPlugin {
    eSERVERWIRINGMETA_RPNone      	=	       0,	//(0x00000000)
    eSERVERWIRINGMETA_RPDucttape_CFGValidationPlugin	=	    1001,	//(0x000003e9)
    eSERVERWIRINGMETA_RPTracer    	=	    1002,	//(0x000003ea)
    eSERVERWIRINGMETA_AddRemoveClearReadPlugin	=	    1003,	//(0x000003eb)
    eSERVERWIRINGMETA_AppCenter_ASAITablePlugin	=	    1004	//(0x000003ec)
};

enum eSERVERWIRINGMETA_WritePlugin {
    eSERVERWIRINGMETA_WPNone      	=	       0,	//(0x00000000)
    eSERVERWIRINGMETA_WPTracer    	=	    2001,	//(0x000007d1)
    eSERVERWIRINGMETA_AddRemoveClearWritePlugin	=	    2002	//(0x000007d2)
};

enum eSERVERWIRINGMETA_Interceptor {
    eSERVERWIRINGMETA_NoInterceptor	=	       0,	//(0x00000000)
    eSERVERWIRINGMETA_TableDispenser	=	       1,	//(0x00000001)
    eSERVERWIRINGMETA_Core_FixedInterceptor	=	       2,	//(0x00000002)
    eSERVERWIRINGMETA_Core_ComplibInterceptor	=	       3,	//(0x00000003)
    eSERVERWIRINGMETA_Core_XMLInterceptor	=	       4,	//(0x00000004)
    eSERVERWIRINGMETA_Core_EventInterceptor	=	       5,	//(0x00000005)
    eSERVERWIRINGMETA_Core_MemoryInterceptor	=	       6,	//(0x00000006)
    eSERVERWIRINGMETA_Core_MergeDirectivesInterceptor	=	       7,	//(0x00000007)
    eSERVERWIRINGMETA_Core_AssemblyInterceptor	=	       8,	//(0x00000008)
    eSERVERWIRINGMETA_Core_AssemblyInterceptor2	=	       9,	//(0x00000009)
    eSERVERWIRINGMETA_Core_FixedPackedInterceptor	=	      10,	//(0x0000000a)
    eSERVERWIRINGMETA_Ducttape_FileNameInterceptor	=	      11,	//(0x0000000b)
    eSERVERWIRINGMETA_WebServer_ValidationInterceptor	=	      12,	//(0x0000000c)
    eSERVERWIRINGMETA_Ducttape_WriteInterceptor	=	      13,	//(0x0000000d)
    eSERVERWIRINGMETA_Core_MetabaseInterceptor	=	      14,	//(0x0000000e)
    eSERVERWIRINGMETA_Core_MetabaseDifferencingInterceptor	=	      15,	//(0x0000000f)
    eSERVERWIRINGMETA_Core_MetaMergeInterceptor	=	      16,	//(0x00000010)
    eSERVERWIRINGMETA_Core_DetailedErrorInterceptor	=	      17,	//(0x00000011)
    eSERVERWIRINGMETA_Core_MergeInterceptor	=	      18,	//(0x00000012)
    eSERVERWIRINGMETA_AppCenter_ASAIInterceptor	=	      19,	//(0x00000013)
    eSERVERWIRINGMETA_AppCenter_ListToRowsPlugin	=	      20	//(0x00000014)
};

enum eSERVERWIRINGMETA_MetaFlags {
    fSERVERWIRINGMETA_First       	=	0x00000001,	//(1 decimal)
    fSERVERWIRINGMETA_Next        	=	0x00000002,	//(2 decimal)
    fSERVERWIRINGMETA_Last        	=	0x00000004,	//(4 decimal)
    fSERVERWIRINGMETA_NoNext      	=	0x00000008,	//(8 decimal)
    fSERVERWIRINGMETA_WireOnWriteOnly	=	0x00000010,	//(16 decimal)
    fSERVERWIRINGMETA_WireOnReadWrite	=	0x00000020,	//(32 decimal)
    fSERVERWIRINGMETA_ReadOnly    	=	0x00000040,	//(64 decimal)
    fSERVERWIRINGMETA_MetaFlags_Mask	= 0x0000007f
};

enum eSERVERWIRINGMETA_Merger {
    eSERVERWIRINGMETA_ListAppend  	=	    3001,	//(0x00000bb9)
    eSERVERWIRINGMETA_PropertyOverride	=	    3002,	//(0x00000bba)
    eSERVERWIRINGMETA_ListMerge   	=	    3003	//(0x00000bbb)
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_DETAILEDERRORS                          L"DETAILEDERRORS"
#define TABLEID_DETAILEDERRORS                           (0xb17dca00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_DETAILEDERRORS                       (0L)
#define ExtendedVersion_DETAILEDERRORS                   (0L)

//-----------------Column Index Enums--------------   
enum eDETAILEDERRORS {
    iDETAILEDERRORS_ErrorID,  
    iDETAILEDERRORS_Description,  
    iDETAILEDERRORS_Date,  
    iDETAILEDERRORS_Time,  
    iDETAILEDERRORS_SourceModuleName,  
    iDETAILEDERRORS_MessageString,  
    iDETAILEDERRORS_CategoryString,  
    iDETAILEDERRORS_Source,  
    iDETAILEDERRORS_Type,  
    iDETAILEDERRORS_Category,  
    iDETAILEDERRORS_User,  
    iDETAILEDERRORS_Computer,  
    iDETAILEDERRORS_Data,  
    iDETAILEDERRORS_Event,  
    iDETAILEDERRORS_String1,  
    iDETAILEDERRORS_String2,  
    iDETAILEDERRORS_String3,  
    iDETAILEDERRORS_String4,  
    iDETAILEDERRORS_String5,  
    iDETAILEDERRORS_ErrorCode,  
    iDETAILEDERRORS_Interceptor,  
    iDETAILEDERRORS_InterceptorSource,  
    iDETAILEDERRORS_OperationType,  
    iDETAILEDERRORS_Table,  
    iDETAILEDERRORS_ConfigurationSource,  
    iDETAILEDERRORS_Row,  
    iDETAILEDERRORS_Column,  
    iDETAILEDERRORS_MajorVersion,  
    iDETAILEDERRORS_MinorVersion,  
    cDETAILEDERRORS_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tDETAILEDERRORSRow {
         ULONG *     pErrorID;
         WCHAR *     pDescription;
         WCHAR *     pDate;
         WCHAR *     pTime;
         WCHAR *     pSourceModuleName;
         WCHAR *     pMessageString;
         WCHAR *     pCategoryString;
         WCHAR *     pSource;
         ULONG *     pType;
         ULONG *     pCategory;
         WCHAR *     pUser;
         WCHAR *     pComputer;
 unsigned char *     pData;
         ULONG *     pEvent;
         WCHAR *     pString1;
         WCHAR *     pString2;
         WCHAR *     pString3;
         WCHAR *     pString4;
         WCHAR *     pString5;
         ULONG *     pErrorCode;
         ULONG *     pInterceptor;
         WCHAR *     pInterceptorSource;
         ULONG *     pOperationType;
         WCHAR *     pTable;
         WCHAR *     pConfigurationSource;
         ULONG *     pRow;
         ULONG *     pColumn;
         ULONG *     pMajorVersion;
         ULONG *     pMinorVersion;
};

enum eDETAILEDERRORS_Type {
    eDETAILEDERRORS_SUCCESS       	=	       0,	//(0x00000000)
    eDETAILEDERRORS_ERROR         	=	       1,	//(0x00000001)
    eDETAILEDERRORS_WARNING       	=	       2,	//(0x00000002)
    eDETAILEDERRORS_INFORMATION   	=	       4,	//(0x00000004)
    eDETAILEDERRORS_AUDIT_SUCCESS 	=	       8,	//(0x00000008)
    eDETAILEDERRORS_AUDIT_FAILURE 	=	      16	//(0x00000010)
};

enum eDETAILEDERRORS_OperationType {
    eDETAILEDERRORS_Unspecified   	=	       0,	//(0x00000000)
    eDETAILEDERRORS_Populate      	=	       1,	//(0x00000001)
    eDETAILEDERRORS_UpdateStore   	=	       2	//(0x00000002)
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_COLLECTION_META                         L"COLLECTION_META"
#define TABLEID_COLLECTION_META                          (0xcb4ba600L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_COLLECTION_META                      (0L)
#define ExtendedVersion_COLLECTION_META                  (0L)

//-----------------Column Index Enums--------------   
enum eCOLLECTION_META {
    iCOLLECTION_META_Database,  
    iCOLLECTION_META_InternalName,  
    iCOLLECTION_META_PublicName,  
    iCOLLECTION_META_PublicRowName,  
    iCOLLECTION_META_BaseVersion,  
    iCOLLECTION_META_ExtendedVersion,  
    iCOLLECTION_META_NameColumn,  
    iCOLLECTION_META_NavColumn,  
    iCOLLECTION_META_CountOfColumns,  
    iCOLLECTION_META_MetaFlags,  
    iCOLLECTION_META_SchemaGeneratorFlags,  
    iCOLLECTION_META_ConfigItemName,  
    iCOLLECTION_META_ConfigCollectionName,  
    iCOLLECTION_META_PublicRowNameColumn,  
    iCOLLECTION_META_ContainerClassList,  
    iCOLLECTION_META_Description,  
    iCOLLECTION_META_ChildElementName,  
    cCOLLECTION_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tCOLLECTION_METARow {
         WCHAR *     pDatabase;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         WCHAR *     pPublicRowName;
         ULONG *     pBaseVersion;
         ULONG *     pExtendedVersion;
         ULONG *     pNameColumn;
         ULONG *     pNavColumn;
         ULONG *     pCountOfColumns;
         ULONG *     pMetaFlags;
         ULONG *     pSchemaGeneratorFlags;
         WCHAR *     pConfigItemName;
         WCHAR *     pConfigCollectionName;
         ULONG *     pPublicRowNameColumn;
         WCHAR *     pContainerClassList;
         WCHAR *     pDescription;
         WCHAR *     pChildElementName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_PROPERTY_META                           L"PROPERTY_META"
#define TABLEID_PROPERTY_META                            (0xfae7a100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_PROPERTY_META                        (0L)
#define ExtendedVersion_PROPERTY_META                    (0L)

//-----------------Column Index Enums--------------   
enum ePROPERTY_META {
    iPROPERTY_META_Table,  
    iPROPERTY_META_Index,  
    iPROPERTY_META_InternalName,  
    iPROPERTY_META_PublicName,  
    iPROPERTY_META_Type,  
    iPROPERTY_META_Size,  
    iPROPERTY_META_MetaFlags,  
    iPROPERTY_META_DefaultValue,  
    iPROPERTY_META_FlagMask,  
    iPROPERTY_META_StartingNumber,  
    iPROPERTY_META_EndingNumber,  
    iPROPERTY_META_CharacterSet,  
    iPROPERTY_META_SchemaGeneratorFlags,  
    iPROPERTY_META_ID,  
    iPROPERTY_META_UserType,  
    iPROPERTY_META_Attributes,  
    iPROPERTY_META_Description,  
    iPROPERTY_META_PublicColumnName,  
    cPROPERTY_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tPROPERTY_METARow {
         WCHAR *     pTable;
         ULONG *     pIndex;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pType;
         ULONG *     pSize;
         ULONG *     pMetaFlags;
 unsigned char *     pDefaultValue;
         ULONG *     pFlagMask;
         ULONG *     pStartingNumber;
         ULONG *     pEndingNumber;
         WCHAR *     pCharacterSet;
         ULONG *     pSchemaGeneratorFlags;
         ULONG *     pID;
         ULONG *     pUserType;
         ULONG *     pAttributes;
         WCHAR *     pDescription;
         WCHAR *     pPublicColumnName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_SERVERWIRING_META                       L"SERVERWIRING_META"
#define TABLEID_SERVERWIRING_META                        (0x58ffcd00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_SERVERWIRING_META                    (0L)
#define ExtendedVersion_SERVERWIRING_META                (0L)

//-----------------Column Index Enums--------------   
enum eSERVERWIRING_META {
    iSERVERWIRING_META_Table,  
    iSERVERWIRING_META_Order,  
    iSERVERWIRING_META_ReadPlugin,  
    iSERVERWIRING_META_ReadPluginDLLName,  
    iSERVERWIRING_META_WritePlugin,  
    iSERVERWIRING_META_WritePluginDLLName,  
    iSERVERWIRING_META_Interceptor,  
    iSERVERWIRING_META_InterceptorDLLName,  
    iSERVERWIRING_META_MetaFlags,  
    iSERVERWIRING_META_Locator,  
    iSERVERWIRING_META_Reserved,  
    iSERVERWIRING_META_Merger,  
    iSERVERWIRING_META_MergerDLLName,  
    cSERVERWIRING_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tSERVERWIRING_METARow {
         WCHAR *     pTable;
         ULONG *     pOrder;
         ULONG *     pReadPlugin;
         WCHAR *     pReadPluginDLLName;
         ULONG *     pWritePlugin;
         WCHAR *     pWritePluginDLLName;
         ULONG *     pInterceptor;
         WCHAR *     pInterceptorDLLName;
         ULONG *     pMetaFlags;
         WCHAR *     pLocator;
         ULONG *     pReserved;
         ULONG *     pMerger;
         WCHAR *     pMergerDLLName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_TAG_META                                L"TAG_META"
#define TABLEID_TAG_META                                 (0x1acfa100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_TAG_META                             (0L)
#define ExtendedVersion_TAG_META                         (0L)

//-----------------Column Index Enums--------------   
enum eTAG_META {
    iTAG_META_Table,  
    iTAG_META_ColumnIndex,  
    iTAG_META_InternalName,  
    iTAG_META_PublicName,  
    iTAG_META_Value,  
    iTAG_META_ID,  
    cTAG_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tTAG_METARow {
         WCHAR *     pTable;
         ULONG *     pColumnIndex;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pValue;
         ULONG *     pID;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_ManagedWiring                           L"ManagedWiring"
#define TABLEID_ManagedWiring                            (0x64aecf00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_ManagedWiring                        (0L)
#define ExtendedVersion_ManagedWiring                    (0L)

//-----------------Column Index Enums--------------   
enum eManagedWiring {
    iManagedWiring_ConfigType,  
    iManagedWiring_Protocol,  
    iManagedWiring_Order,  
    iManagedWiring_InterceptorClass,  
    iManagedWiring_InterceptorType,  
    iManagedWiring_InterceptorFlags,  
    cManagedWiring_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tManagedWiringRow {
         WCHAR *     pConfigType;
         WCHAR *     pProtocol;
         ULONG *     pOrder;
         WCHAR *     pInterceptorClass;
         ULONG *     pInterceptorType;
         ULONG *     pInterceptorFlags;
};

enum eManagedWiring_InterceptorType {
    eManagedWiring_Reader         	=	       1,	//(0x00000001)
    eManagedWiring_Writer         	=	       2,	//(0x00000002)
    eManagedWiring_Transformer    	=	       3,	//(0x00000003)
    eManagedWiring_Merger         	=	       4,	//(0x00000004)
    eManagedWiring_Validator      	=	       5	//(0x00000005)
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_SchemaFiles                             L"SchemaFiles"
#define TABLEID_SchemaFiles                              (0xc96f6700L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_SchemaFiles                          (0L)
#define ExtendedVersion_SchemaFiles                      (0L)

//-----------------Column Index Enums--------------   
enum eSchemaFiles {
    iSchemaFiles_Name,  
    iSchemaFiles_Path,  
    cSchemaFiles_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tSchemaFilesRow {
         WCHAR *     pName;
         WCHAR *     pPath;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_MEMORY_SHAPEABLE                        L"MEMORY_SHAPEABLE"
#define TABLEID_MEMORY_SHAPEABLE                         (0x6a2aa900L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_MEMORY_SHAPEABLE                     (0L)
#define ExtendedVersion_MEMORY_SHAPEABLE                 (0L)





//-------------------------------TableName-----------------------------   
#define wszTABLE_TRANSFORMER_META                        L"TRANSFORMER_META"
#define TABLEID_TRANSFORMER_META                         (0x1a1bba00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_TRANSFORMER_META                     (0L)
#define ExtendedVersion_TRANSFORMER_META                 (0L)

//-----------------Column Index Enums--------------   
enum eTRANSFORMER_META {
    iTRANSFORMER_META_TF_Protocol,  
    iTRANSFORMER_META_TF_Type,  
    iTRANSFORMER_META_DllName,  
    cTRANSFORMER_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tTRANSFORMER_METARow {
         WCHAR *     pTF_Protocol;
         ULONG *     pTF_Type;
         WCHAR *     pDllName;
};

enum eTRANSFORMER_META_TF_Type {
    eTRANSFORMER_META_FileTransformer	=	    4000,	//(0x00000fa0)
    eTRANSFORMER_META_WebHierarchyTransformer	=	    4001,	//(0x00000fa1)
    eTRANSFORMER_META_AppDomainTransformer	=	    4002,	//(0x00000fa2)
    eTRANSFORMER_META_LocalMachineTransformer	=	    4003,	//(0x00000fa3)
    eTRANSFORMER_META_ConfigTransformer	=	    4004,	//(0x00000fa4)
    eTRANSFORMER_META_ShellTransformer	=	    4005	//(0x00000fa5)
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_ASSOC_META                              L"ASSOC_META"
#define TABLEID_ASSOC_META                               (0xec7fa100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_ASSOC_META                           (0L)
#define ExtendedVersion_ASSOC_META                       (0L)

//-----------------Column Index Enums--------------   
enum eASSOC_META {
    iASSOC_META_Type,  
    iASSOC_META_TableName,  
    cASSOC_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tASSOC_METARow {
         WCHAR *     pType;
         WCHAR *     pTableName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_MetabaseBaseClass                       L"MetabaseBaseClass"
#define TABLEID_MetabaseBaseClass                        (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_MetabaseBaseClass                    (0L)
#define ExtendedVersion_MetabaseBaseClass                (0L)

//-----------------Column Index Enums--------------   
enum eMetabaseBaseClass {
    iMetabaseBaseClass_Location,  
    cMetabaseBaseClass_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tMetabaseBaseClassRow {
         WCHAR *     pLocation;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsConfigObject                         L"IIsConfigObject"
#define TABLEID_IIsConfigObject                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsConfigObject                      (0L)
#define ExtendedVersion_IIsConfigObject                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsConfigObject {
    iIIsConfigObject_KeyType,  
    iIIsConfigObject_AdminACL,  
    iIIsConfigObject_AdminACLBin,  
    iIIsConfigObject_AdminEmail,  
    iIIsConfigObject_AdminName,  
    iIIsConfigObject_AdminServer,  
    iIIsConfigObject_AllowAnonymous,  
    iIIsConfigObject_AllowClientPosts,  
    iIIsConfigObject_AllowControlMsgs,  
    iIIsConfigObject_AllowFeedPosts,  
    iIIsConfigObject_AllowKeepAlive,  
    iIIsConfigObject_AllowPathInfoForScriptMappings,  
    iIIsConfigObject_AlwaysUseSsl,  
    iIIsConfigObject_AnonymousOnly,  
    iIIsConfigObject_AnonymousPasswordSync,  
    iIIsConfigObject_AnonymousUserName,  
    iIIsConfigObject_AnonymousUserPass,  
    iIIsConfigObject_AppAllowClientDebug,  
    iIIsConfigObject_AppAllowDebugging,  
    iIIsConfigObject_AppFriendlyName,  
    iIIsConfigObject_AppIsolated,  
    iIIsConfigObject_AppOopRecoverLimit,  
    iIIsConfigObject_AppPackageID,  
    iIIsConfigObject_AppPackageName,  
    iIIsConfigObject_AppPoolId,  
    iIIsConfigObject_AppPoolIdentityType,  
    iIIsConfigObject_AppPoolCommand,  
    iIIsConfigObject_AppPoolState,  
    iIIsConfigObject_AppPoolAutoStart,  
    iIIsConfigObject_AppRoot,  
    iIIsConfigObject_AppWamClsid,  
    iIIsConfigObject_ArticleTableFile,  
    iIIsConfigObject_AspAllowOutOfProcComponents,  
    iIIsConfigObject_AspAllowSessionState,  
    iIIsConfigObject_AspBufferingOn,  
    iIIsConfigObject_AspCodepage,  
    iIIsConfigObject_AspDiskTemplateCacheDirectory,  
    iIIsConfigObject_AspEnableApplicationRestart,  
    iIIsConfigObject_AspEnableAspHtmlFallback,  
    iIIsConfigObject_AspEnableChunkedEncoding,  
    iIIsConfigObject_AspEnableParentPaths,  
    iIIsConfigObject_AspEnableTypelibCache,  
    iIIsConfigObject_AspErrorsToNTLog,  
    iIIsConfigObject_AspExceptionCatchEnable,  
    iIIsConfigObject_AspKeepSessionIDSecure,  
    iIIsConfigObject_AspLCID,  
    iIIsConfigObject_AspLogErrorRequests,  
    iIIsConfigObject_AspMaxDiskTemplateCacheFiles,  
    iIIsConfigObject_AspPartitionID,  
    iIIsConfigObject_AspSxsName,  
    iIIsConfigObject_AspProcessorThreadMax,  
    iIIsConfigObject_AspQueueConnectionTestTime,  
    iIIsConfigObject_AspQueueTimeout,  
    iIIsConfigObject_AspRequestQueueMax,  
    iIIsConfigObject_AspScriptEngineCacheMax,  
    iIIsConfigObject_AspScriptErrorMessage,  
    iIIsConfigObject_AspScriptErrorSentToBrowser,  
    iIIsConfigObject_AspScriptFileCacheSize,  
    iIIsConfigObject_AspScriptLanguage,  
    iIIsConfigObject_AspScriptTimeout,  
    iIIsConfigObject_AspSessionMax,  
    iIIsConfigObject_AspSessionTimeout,  
    iIIsConfigObject_AspTrackThreadingModel,  
    iIIsConfigObject_AspExecuteInMTA,  
    iIIsConfigObject_AspRunOnEndAnonymously,  
    iIIsConfigObject_AuthTurnList,  
    iIIsConfigObject_IIs5IsolationModeEnabled,  
    iIIsConfigObject_BadMailDirectory,  
    iIIsConfigObject_CacheControlCustom,  
    iIIsConfigObject_CacheControlMaxAge,  
    iIIsConfigObject_CacheControlNoCache,  
    iIIsConfigObject_CacheISAPI,  
    iIIsConfigObject_CertCheckMode,  
    iIIsConfigObject_CGITimeout,  
    iIIsConfigObject_ChangeNumber,  
    iIIsConfigObject_ClientPostHardLimit,  
    iIIsConfigObject_ClientPostSoftLimit,  
    iIIsConfigObject_ClusterEnabled,  
    iIIsConfigObject_CollectionComment,  
    iIIsConfigObject_ConnectionTimeout,  
    iIIsConfigObject_ContentIndexed,  
    iIIsConfigObject_CPUAction,  
    iIIsConfigObject_CPULimit,  
    iIIsConfigObject_CPUResetInterval,  
    iIIsConfigObject_CreateCGIWithNewConsole,  
    iIIsConfigObject_CreateProcessAsUser,  
    iIIsConfigObject_CSideEtrnDomains,  
    iIIsConfigObject_CustomErrorDescriptions,  
    iIIsConfigObject_DefaultDoc,  
    iIIsConfigObject_DefaultDocFooter,  
    iIIsConfigObject_DefaultDomain,  
    iIIsConfigObject_DefaultLogonDomain,  
    iIIsConfigObject_DefaultModeratorDomain,  
    iIIsConfigObject_DirectoryLevelsToScan,  
    iIIsConfigObject_DisableNewNews,  
    iIIsConfigObject_DisableSocketPooling,  
    iIIsConfigObject_DisallowOverlappingRotation,  
    iIIsConfigObject_DisallowRotationOnConfigChange,  
    iIIsConfigObject_DomainRouting,  
    iIIsConfigObject_DoMasquerade,  
    iIIsConfigObject_DontLog,  
    iIIsConfigObject_DownlevelAdminInstance,  
    iIIsConfigObject_DropDirectory,  
    iIIsConfigObject_HistoryMajorVersionNumber,  
    iIIsConfigObject_XMLSchemaTimeStamp,  
    iIIsConfigObject_BINSchemaTimeStamp,  
    iIIsConfigObject_EnableHistory,  
    iIIsConfigObject_EnableDocFooter,  
    iIIsConfigObject_EnableEditWhileRunning,  
    iIIsConfigObject_EnableReverseDns,  
    iIIsConfigObject_EnableReverseDnsLookup,  
    iIIsConfigObject_EtrnDays,  
    iIIsConfigObject_ExitMessage,  
    iIIsConfigObject_FeedPostHardLimit,  
    iIIsConfigObject_FeedPostSoftLimit,  
    iIIsConfigObject_FeedReportPeriod,  
    iIIsConfigObject_FilterDescription,  
    iIIsConfigObject_FilterEnableCache,  
    iIIsConfigObject_FilterEnabled,  
    iIIsConfigObject_FilterLoadOrder,  
    iIIsConfigObject_FilterPath,  
    iIIsConfigObject_FilterState,  
    iIIsConfigObject_FrontPageWeb,  
    iIIsConfigObject_FtpDirBrowseShowLongDate,  
    iIIsConfigObject_FullyQualifiedDomainName,  
    iIIsConfigObject_BannerMessage,  
    iIIsConfigObject_UserIsolationMode,  
    iIIsConfigObject_FtpLogInUtf8,  
    iIIsConfigObject_GreetingMessage,  
    iIIsConfigObject_GroupHelpFile,  
    iIIsConfigObject_GroupListFile,  
    iIIsConfigObject_GroupVarListFile,  
    iIIsConfigObject_HeaderWaitTimeout,  
    iIIsConfigObject_HcCacheControlHeader,  
    iIIsConfigObject_HcCompressionBufferSize,  
    iIIsConfigObject_HcCompressionDirectory,  
    iIIsConfigObject_HcCompressionDll,  
    iIIsConfigObject_HcCreateFlags,  
    iIIsConfigObject_HcDoDiskSpaceLimiting,  
    iIIsConfigObject_HcDoDynamicCompression,  
    iIIsConfigObject_HcDoOnDemandCompression,  
    iIIsConfigObject_HcDoStaticCompression,  
    iIIsConfigObject_HcDynamicCompressionLevel,  
    iIIsConfigObject_HcExpiresHeader,  
    iIIsConfigObject_HcFileExtensions,  
    iIIsConfigObject_HcFilesDeletedPerDiskFree,  
    iIIsConfigObject_HcIoBufferSize,  
    iIIsConfigObject_HcMaxDiskSpaceUsage,  
    iIIsConfigObject_HcMaxQueueLength,  
    iIIsConfigObject_HcMinFileSizeForComp,  
    iIIsConfigObject_HcNoCompressionForHttp10,  
    iIIsConfigObject_HcNoCompressionForProxies,  
    iIIsConfigObject_HcNoCompressionForRange,  
    iIIsConfigObject_HcOnDemandCompLevel,  
    iIIsConfigObject_HcPriority,  
    iIIsConfigObject_HcScriptFileExtensions,  
    iIIsConfigObject_HcSendCacheHeaders,  
    iIIsConfigObject_HistoryTableFile,  
    iIIsConfigObject_HonorClientMsgIds,  
    iIIsConfigObject_HopCount,  
    iIIsConfigObject_HttpCustomHeaders,  
    iIIsConfigObject_HttpErrors,  
    iIIsConfigObject_HttpExpires,  
    iIIsConfigObject_HttpPics,  
    iIIsConfigObject_HttpRedirect,  
    iIIsConfigObject_IdleTimeout,  
    iIIsConfigObject_ImapClearTextProvider,  
    iIIsConfigObject_ImapDefaultDomain,  
    iIIsConfigObject_ImapDsAccount,  
    iIIsConfigObject_ImapDsBindType,  
    iIIsConfigObject_ImapDsDataDirectory,  
    iIIsConfigObject_ImapDsDefaultMailRoot,  
    iIIsConfigObject_ImapDsHost,  
    iIIsConfigObject_ImapDsNamingContext,  
    iIIsConfigObject_ImapDsPassword,  
    iIIsConfigObject_ImapDsSchemaType,  
    iIIsConfigObject_ImapExpireDelay,  
    iIIsConfigObject_ImapExpireMail,  
    iIIsConfigObject_ImapExpireStart,  
    iIIsConfigObject_ImapMailExpirationTime,  
    iIIsConfigObject_ImapRoutingDll,  
    iIIsConfigObject_ImapRoutingSources,  
    iIIsConfigObject_ImapRoutingTableType,  
    iIIsConfigObject_ImapServiceVersion,  
    iIIsConfigObject_InProcessIsapiApps,  
    iIIsConfigObject_IPSecurity,  
    iIIsConfigObject_LimitRemoteConnections,  
    iIIsConfigObject_ListFile,  
    iIIsConfigObject_LocalRetryAttempts,  
    iIIsConfigObject_LocalRetryInterval,  
    iIIsConfigObject_LogAnonymous,  
    iIIsConfigObject_LogCustomPropertyDataType,  
    iIIsConfigObject_LogCustomPropertyHeader,  
    iIIsConfigObject_LogCustomPropertyID,  
    iIIsConfigObject_LogCustomPropertyMask,  
    iIIsConfigObject_LogCustomPropertyName,  
    iIIsConfigObject_LogCustomPropertyServicesString,  
    iIIsConfigObject_LogCustomPropertyNodeID,  
    iIIsConfigObject_LogFileDirectory,  
    iIIsConfigObject_LogFileLocaltimeRollover,  
    iIIsConfigObject_LogFilePeriod,  
    iIIsConfigObject_LogFileTruncateSize,  
    iIIsConfigObject_LogInUTF8,  
    iIIsConfigObject_LogModuleId,  
    iIIsConfigObject_LogModuleList,  
    iIIsConfigObject_LogModuleUiId,  
    iIIsConfigObject_LogNonAnonymous,  
    iIIsConfigObject_LogOdbcDataSource,  
    iIIsConfigObject_LogOdbcPassword,  
    iIIsConfigObject_LogOdbcTableName,  
    iIIsConfigObject_LogOdbcUserName,  
    iIIsConfigObject_LogonMethod,  
    iIIsConfigObject_LogPluginClsid,  
    iIIsConfigObject_LogType,  
    iIIsConfigObject_MasqueradeDomain,  
    iIIsConfigObject_MaxErrorFiles,  
    iIIsConfigObject_MaxHistoryFiles,  
    iIIsConfigObject_MaxBandwidth,  
    iIIsConfigObject_MaxBandwidthBlocked,  
    iIIsConfigObject_MaxBatchedMessages,  
    iIIsConfigObject_MaxClientsMessage,  
    iIIsConfigObject_MaxConnections,  
    iIIsConfigObject_MaxEndpointConnections,  
    iIIsConfigObject_MaxGlobalBandwidth,  
    iIIsConfigObject_MaxMessageSize,  
    iIIsConfigObject_MaxOutConnections,  
    iIIsConfigObject_MaxOutConnectionsPerDomain,  
    iIIsConfigObject_MaxProcesses,  
    iIIsConfigObject_MaxRecipients,  
    iIIsConfigObject_MaxSearchResults,  
    iIIsConfigObject_MaxSessionSize,  
    iIIsConfigObject_MaxSmtpLogonErrors,  
    iIIsConfigObject_MD_0,  
    iIIsConfigObject_MD_1001,  
    iIIsConfigObject_PostmasterName,  
    iIIsConfigObject_PostmasterEmail,  
    iIIsConfigObject_LocalDomains,  
    iIIsConfigObject_ShutdownLatency,  
    iIIsConfigObject_MD_APP_LAST_OUTPROC_PID,  
    iIIsConfigObject_AuthChangeURL,  
    iIIsConfigObject_AuthExpiredUnsecureURL,  
    iIIsConfigObject_AuthExpiredURL,  
    iIIsConfigObject_AuthNotifyPwdExpURL,  
    iIIsConfigObject_AuthNotifyPwdExpUnsecureURL,  
    iIIsConfigObject_MD_ETAG_CHANGENUMBER,  
    iIIsConfigObject_MD_IISADMIN_EXTENSIONS,  
    iIIsConfigObject_MD_ISM_ACCESS_CHECK,  
    iIIsConfigObject_MD_METADATA_ID_REGISTRATION,  
    iIIsConfigObject_MD_SERVER_CAPABILITIES,  
    iIIsConfigObject_ServerCommand,  
    iIIsConfigObject_MD_SERVER_PLATFORM,  
    iIIsConfigObject_MajorIIsVersionNumber,  
    iIIsConfigObject_MinorIIsVersionNumber,  
    iIIsConfigObject_MimeMap,  
    iIIsConfigObject_MinFileBytesPerSec,  
    iIIsConfigObject_ModeratorFile,  
    iIIsConfigObject_MSDOSDirOutput,  
    iIIsConfigObject_NntpCommandLogMask,  
    iIIsConfigObject_NewsDropDirectory,  
    iIIsConfigObject_NewsFailedPickupDirectory,  
    iIIsConfigObject_NewsPickupDirectory,  
    iIIsConfigObject_NntpServiceVersion,  
    iIIsConfigObject_NntpUucpName,  
    iIIsConfigObject_NTAuthenticationProviders,  
    iIIsConfigObject_OrphanActionExe,  
    iIIsConfigObject_OrphanActionParams,  
    iIIsConfigObject_OrphanWorkerProcess,  
    iIIsConfigObject_PasswordCacheTTL,  
    iIIsConfigObject_PasswordExpirePrenotifyDays,  
    iIIsConfigObject_Path,  
    iIIsConfigObject_PeriodicRestartRequests,  
    iIIsConfigObject_PeriodicRestartSchedule,  
    iIIsConfigObject_PeriodicRestartTime,  
    iIIsConfigObject_PeriodicRestartMemory,  
    iIIsConfigObject_PeriodicRestartPrivateMemory,  
    iIIsConfigObject_PickupDirectory,  
    iIIsConfigObject_PingingEnabled,  
    iIIsConfigObject_PingInterval,  
    iIIsConfigObject_PingResponseTime,  
    iIIsConfigObject_PoolIdcTimeout,  
    iIIsConfigObject_Pop3ClearTextProvider,  
    iIIsConfigObject_Pop3DefaultDomain,  
    iIIsConfigObject_Pop3DsAccount,  
    iIIsConfigObject_Pop3DsBindType,  
    iIIsConfigObject_Pop3DsDataDirectory,  
    iIIsConfigObject_Pop3DsDefaultMailRoot,  
    iIIsConfigObject_Pop3DsHost,  
    iIIsConfigObject_Pop3DsNamingContext,  
    iIIsConfigObject_Pop3DsPassword,  
    iIIsConfigObject_Pop3DsSchemaType,  
    iIIsConfigObject_Pop3ExpireDelay,  
    iIIsConfigObject_Pop3ExpireMail,  
    iIIsConfigObject_Pop3ExpireStart,  
    iIIsConfigObject_Pop3MailExpirationTime,  
    iIIsConfigObject_Pop3RoutingDll,  
    iIIsConfigObject_Pop3RoutingSources,  
    iIIsConfigObject_Pop3RoutingTableType,  
    iIIsConfigObject_Pop3ServiceVersion,  
    iIIsConfigObject_PrettyNamesFile,  
    iIIsConfigObject_NntpClearTextProvider,  
    iIIsConfigObject_ProcessNTCRIfLoggedOn,  
    iIIsConfigObject_QueueDirectory,  
    iIIsConfigObject_RapidFailProtection,  
    iIIsConfigObject_RapidFailProtectionInterval,  
    iIIsConfigObject_RapidFailProtectionMaxCrashes,  
    iIIsConfigObject_Realm,  
    iIIsConfigObject_RedirectHeaders,  
    iIIsConfigObject_RelayForAuth,  
    iIIsConfigObject_RelayIpList,  
    iIIsConfigObject_RemoteRetryAttempts,  
    iIIsConfigObject_RemoteRetryInterval,  
    iIIsConfigObject_RemoteSmtpPort,  
    iIIsConfigObject_RemoteSmtpSecurePort,  
    iIIsConfigObject_RemoteTimeout,  
    iIIsConfigObject_RevocationFreshnessTime,  
    iIIsConfigObject_RevocationURLRetrievalTimeout,  
    iIIsConfigObject_RouteAction,  
    iIIsConfigObject_RouteActionString,  
    iIIsConfigObject_RoutePassword,  
    iIIsConfigObject_RouteUserName,  
    iIIsConfigObject_RoutingDll,  
    iIIsConfigObject_RoutingSources,  
    iIIsConfigObject_SaslLogonDomain,  
    iIIsConfigObject_ScriptMaps,  
    iIIsConfigObject_SecureBindings,  
    iIIsConfigObject_SendBadTo,  
    iIIsConfigObject_SendNdrTo,  
    iIIsConfigObject_ServerAutoStart,  
    iIIsConfigObject_ServerBindings,  
    iIIsConfigObject_ServerComment,  
    iIIsConfigObject_ServerListenBacklog,  
    iIIsConfigObject_ServerListenTimeout,  
    iIIsConfigObject_ServerSize,  
    iIIsConfigObject_ServerState,  
    iIIsConfigObject_SessionKey,  
    iIIsConfigObject_ShouldDeliver,  
    iIIsConfigObject_ShutdownTimeLimit,  
    iIIsConfigObject_SmartHost,  
    iIIsConfigObject_SmartHostType,  
    iIIsConfigObject_SMPAffinitized,  
    iIIsConfigObject_SMPProcessorAffinityMask,  
    iIIsConfigObject_SmtpAdvQueueDll,  
    iIIsConfigObject_SmtpAuthTimeout,  
    iIIsConfigObject_SmtpBdatTimeout,  
    iIIsConfigObject_SmtpClearTextProvider,  
    iIIsConfigObject_SmtpCommandLogMask,  
    iIIsConfigObject_SmtpConnectTimeout,  
    iIIsConfigObject_SmtpDataTimeout,  
    iIIsConfigObject_SmtpDsAccount,  
    iIIsConfigObject_SmtpDsBindType,  
    iIIsConfigObject_SmtpDsDataDirectory,  
    iIIsConfigObject_SmtpDsDefaultMailRoot,  
    iIIsConfigObject_SmtpDsDomain,  
    iIIsConfigObject_SmtpDsFlags,  
    iIIsConfigObject_SmtpDsHost,  
    iIIsConfigObject_SmtpDsNamingContext,  
    iIIsConfigObject_SmtpDSNLanguageID,  
    iIIsConfigObject_SmtpDSNOptions,  
    iIIsConfigObject_SmtpDsPassword,  
    iIIsConfigObject_SmtpDsPort,  
    iIIsConfigObject_SmtpDsSchemaType,  
    iIIsConfigObject_SmtpDsUseCat,  
    iIIsConfigObject_SmtpFlushMailFile,  
    iIIsConfigObject_SmtpHeloTimeout,  
    iIIsConfigObject_SmtpInboundCommandSupportOptions,  
    iIIsConfigObject_SmtpLocalDelayExpireMinutes,  
    iIIsConfigObject_SmtpLocalNDRExpireMinutes,  
    iIIsConfigObject_SmtpMailFromTimeout,  
    iIIsConfigObject_SmtpOutboundCommandSupportOptions,  
    iIIsConfigObject_SmtpRcptToTimeout,  
    iIIsConfigObject_SmtpRemoteDelayExpireMinutes,  
    iIIsConfigObject_SmtpRemoteNDRExpireMinutes,  
    iIIsConfigObject_SmtpRemoteProgressiveRetry,  
    iIIsConfigObject_SmtpRemoteRetryThreshold,  
    iIIsConfigObject_SmtpRoutingTableType,  
    iIIsConfigObject_SmtpRsetTimeout,  
    iIIsConfigObject_SmtpSaslTimeout,  
    iIIsConfigObject_SmtpServer,  
    iIIsConfigObject_SmtpServiceVersion,  
    iIIsConfigObject_SmtpTurnTimeout,  
    iIIsConfigObject_SmtpIpRestrictionFlag,  
    iIIsConfigObject_SSIExecDisable,  
    iIIsConfigObject_SSLCertHash,  
    iIIsConfigObject_SSLStoreName,  
    iIIsConfigObject_SslUseDsMapper,  
    iIIsConfigObject_SSLAlwaysNegoClientCert,  
    iIIsConfigObject_StartupTimeLimit,  
    iIIsConfigObject_AppPoolQueueLength,  
    iIIsConfigObject_UNCPassword,  
    iIIsConfigObject_UNCUserName,  
    iIIsConfigObject_DisableStaticFileCache,  
    iIIsConfigObject_UploadReadAheadSize,  
    iIIsConfigObject_UseDigestSSP,  
    iIIsConfigObject_VrDriverClsid,  
    iIIsConfigObject_VrDriverProgid,  
    iIIsConfigObject_FsPropertyPath,  
    iIIsConfigObject_VrUseAccount,  
    iIIsConfigObject_VrDoExpire,  
    iIIsConfigObject_ExMdbGuid,  
    iIIsConfigObject_VrOwnModerator,  
    iIIsConfigObject_ArticleTimeLimit,  
    iIIsConfigObject_HistoryExpiration,  
    iIIsConfigObject_NewsCrawlerTime,  
    iIIsConfigObject_NntpOrganization,  
    iIIsConfigObject_SmtpUseTcpDns,  
    iIIsConfigObject_SmtpDotStuffPickupDirFiles,  
    iIIsConfigObject_SmtpDomainValidationFlags,  
    iIIsConfigObject_SmtpSSLRequireTrustedCA,  
    iIIsConfigObject_SmtpSSLCertHostnameValidation,  
    iIIsConfigObject_MaxMailObjects,  
    iIIsConfigObject_ShouldPickupMail,  
    iIIsConfigObject_MaxDirChangeIOSize,  
    iIIsConfigObject_NameResolutionType,  
    iIIsConfigObject_MaxSmtpErrors,  
    iIIsConfigObject_ShouldPipelineIn,  
    iIIsConfigObject_ShouldPipelineOut,  
    iIIsConfigObject_ConnectResponse,  
    iIIsConfigObject_UpdatedFQDN,  
    iIIsConfigObject_UpdatedDefaultDomain,  
    iIIsConfigObject_EtrnSubdomains,  
    iIIsConfigObject_SmtpMaxRemoteQThreads,  
    iIIsConfigObject_SmtpDisableRelay,  
    iIIsConfigObject_SmtpHeloNoDomain,  
    iIIsConfigObject_SmtpMailNoHelo,  
    iIIsConfigObject_SmtpAqueueWait,  
    iIIsConfigObject_AddNoHeaders,  
    iIIsConfigObject_SmtpEventlogLevel,  
    iIIsConfigObject_FeedServerName,  
    iIIsConfigObject_FeedType,  
    iIIsConfigObject_FeedNewsgroups,  
    iIIsConfigObject_FeedSecurityType,  
    iIIsConfigObject_FeedAuthenticationType,  
    iIIsConfigObject_FeedAccountName,  
    iIIsConfigObject_FeedPassword,  
    iIIsConfigObject_FeedStartTimeHigh,  
    iIIsConfigObject_FeedStartTimeLow,  
    iIIsConfigObject_FeedInterval,  
    iIIsConfigObject_FeedAllowControlMsgs,  
    iIIsConfigObject_FeedCreateAutomatically,  
    iIIsConfigObject_FeedDisabled,  
    iIIsConfigObject_FeedDistribution,  
    iIIsConfigObject_FeedConcurrentSessions,  
    iIIsConfigObject_FeedMaxConnectionAttempts,  
    iIIsConfigObject_FeedUucpName,  
    iIIsConfigObject_FeedTempDirectory,  
    iIIsConfigObject_FeedNextPullHigh,  
    iIIsConfigObject_FeedNextPullLow,  
    iIIsConfigObject_FeedPeerTempDirectory,  
    iIIsConfigObject_FeedPeerGapSize,  
    iIIsConfigObject_FeedOutgoingPort,  
    iIIsConfigObject_FeedFeedpairId,  
    iIIsConfigObject_FeedHandshake,  
    iIIsConfigObject_FeedAdminError,  
    iIIsConfigObject_FeedErrParmMask,  
    iIIsConfigObject_ExpireSpace,  
    iIIsConfigObject_ExpireTime,  
    iIIsConfigObject_ExpireNewsgroups,  
    iIIsConfigObject_ExpirePolicyName,  
    iIIsConfigObject_DoStaticCompression,  
    iIIsConfigObject_DoDynamicCompression,  
    iIIsConfigObject_WAMUserName,  
    iIIsConfigObject_WAMUserPass,  
    iIIsConfigObject_Win32Error,  
    iIIsConfigObject_XoverTableFile,  
    iIIsConfigObject_ADConnectionsUserName,  
    iIIsConfigObject_ADConnectionsPassword,  
    iIIsConfigObject_PassivePortRange,  
    iIIsConfigObject_IsapiRestrictionList,  
    iIIsConfigObject_CgiRestrictionList,  
    iIIsConfigObject_LoadBalancerCapabilities,  
    iIIsConfigObject_AutoShutdownAppPoolExe,  
    iIIsConfigObject_AutoShutdownAppPoolParams,  
    iIIsConfigObject_RestrictionListCustomDesc,  
    iIIsConfigObject_ApplicationDependencies,  
    iIIsConfigObject_WebSvcExtRestrictionList,  
    iIIsConfigObject_CentralBinaryLoggingEnabled,  
    iIIsConfigObject_AzEnable,  
    iIIsConfigObject_AzStoreName,  
    iIIsConfigObject_AzScopeName,  
    iIIsConfigObject_AzImpersonationLevel,  
    iIIsConfigObject_SslCtlIdentifier,  
    iIIsConfigObject_SslCtlStoreName,  
    iIIsConfigObject_AspBufferingLimit,  
    iIIsConfigObject_MaxRequestEntityAllowed,  
    iIIsConfigObject_AspMaxRequestEntityAllowed,  
    iIIsConfigObject_DemandStartThreshold,  
    iIIsConfigObject_PassportRequireADMapping,  
    iIIsConfigObject_AspCalcLineNumber,  
    iIIsConfigObject_AccessFlags,  
    iIIsConfigObject_AccessSSLFlags,  
    iIIsConfigObject_AuthFlags,  
    iIIsConfigObject_AuthPersistence,  
    iIIsConfigObject_DirBrowseFlags,  
    iIIsConfigObject_FilterFlags,  
    iIIsConfigObject_LogExtFileFlags,  
    iIIsConfigObject_PasswordChangeFlags,  
    iIIsConfigObject_ServerConfigFlags,  
    iIIsConfigObject_AspAppServiceFlags,  
    iIIsConfigObject_LogEventOnRecycle,  
    cIIsConfigObject_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsConfigObjectRow {
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
         WCHAR *     pAdminEmail;
         WCHAR *     pAdminName;
         WCHAR *     pAdminServer;
         ULONG *     pAllowAnonymous;
         ULONG *     pAllowClientPosts;
         ULONG *     pAllowControlMsgs;
         ULONG *     pAllowFeedPosts;
         ULONG *     pAllowKeepAlive;
         ULONG *     pAllowPathInfoForScriptMappings;
         ULONG *     pAlwaysUseSsl;
         ULONG *     pAnonymousOnly;
         ULONG *     pAnonymousPasswordSync;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pAppAllowClientDebug;
         ULONG *     pAppAllowDebugging;
         WCHAR *     pAppFriendlyName;
         ULONG *     pAppIsolated;
         ULONG *     pAppOopRecoverLimit;
         WCHAR *     pAppPackageID;
         WCHAR *     pAppPackageName;
         WCHAR *     pAppPoolId;
         ULONG *     pAppPoolIdentityType;
         ULONG *     pAppPoolCommand;
         ULONG *     pAppPoolState;
         ULONG *     pAppPoolAutoStart;
         WCHAR *     pAppRoot;
         WCHAR *     pAppWamClsid;
         WCHAR *     pArticleTableFile;
         ULONG *     pAspAllowOutOfProcComponents;
         ULONG *     pAspAllowSessionState;
         ULONG *     pAspBufferingOn;
         ULONG *     pAspCodepage;
         WCHAR *     pAspDiskTemplateCacheDirectory;
         ULONG *     pAspEnableApplicationRestart;
         ULONG *     pAspEnableAspHtmlFallback;
         ULONG *     pAspEnableChunkedEncoding;
         ULONG *     pAspEnableParentPaths;
         ULONG *     pAspEnableTypelibCache;
         ULONG *     pAspErrorsToNTLog;
         ULONG *     pAspExceptionCatchEnable;
         ULONG *     pAspKeepSessionIDSecure;
         ULONG *     pAspLCID;
         ULONG *     pAspLogErrorRequests;
         ULONG *     pAspMaxDiskTemplateCacheFiles;
         WCHAR *     pAspPartitionID;
         WCHAR *     pAspSxsName;
         ULONG *     pAspProcessorThreadMax;
         ULONG *     pAspQueueConnectionTestTime;
         ULONG *     pAspQueueTimeout;
         ULONG *     pAspRequestQueueMax;
         ULONG *     pAspScriptEngineCacheMax;
         WCHAR *     pAspScriptErrorMessage;
         ULONG *     pAspScriptErrorSentToBrowser;
         ULONG *     pAspScriptFileCacheSize;
         WCHAR *     pAspScriptLanguage;
         ULONG *     pAspScriptTimeout;
         ULONG *     pAspSessionMax;
         ULONG *     pAspSessionTimeout;
         ULONG *     pAspTrackThreadingModel;
         ULONG *     pAspExecuteInMTA;
         ULONG *     pAspRunOnEndAnonymously;
         WCHAR *     pAuthTurnList;
         ULONG *     pIIs5IsolationModeEnabled;
         WCHAR *     pBadMailDirectory;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         ULONG *     pCacheISAPI;
         ULONG *     pCertCheckMode;
         ULONG *     pCGITimeout;
         ULONG *     pChangeNumber;
         ULONG *     pClientPostHardLimit;
         ULONG *     pClientPostSoftLimit;
         ULONG *     pClusterEnabled;
         WCHAR *     pCollectionComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pContentIndexed;
         ULONG *     pCPUAction;
         ULONG *     pCPULimit;
         ULONG *     pCPUResetInterval;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pCreateProcessAsUser;
         WCHAR *     pCSideEtrnDomains;
         WCHAR *     pCustomErrorDescriptions;
         WCHAR *     pDefaultDoc;
         WCHAR *     pDefaultDocFooter;
         WCHAR *     pDefaultDomain;
         WCHAR *     pDefaultLogonDomain;
         WCHAR *     pDefaultModeratorDomain;
         ULONG *     pDirectoryLevelsToScan;
         ULONG *     pDisableNewNews;
         ULONG *     pDisableSocketPooling;
         ULONG *     pDisallowOverlappingRotation;
         ULONG *     pDisallowRotationOnConfigChange;
         WCHAR *     pDomainRouting;
         ULONG *     pDoMasquerade;
         ULONG *     pDontLog;
         ULONG *     pDownlevelAdminInstance;
         WCHAR *     pDropDirectory;
         ULONG *     pHistoryMajorVersionNumber;
 unsigned char *     pXMLSchemaTimeStamp;
 unsigned char *     pBINSchemaTimeStamp;
         ULONG *     pEnableHistory;
         ULONG *     pEnableDocFooter;
         ULONG *     pEnableEditWhileRunning;
         ULONG *     pEnableReverseDns;
         ULONG *     pEnableReverseDnsLookup;
         ULONG *     pEtrnDays;
         WCHAR *     pExitMessage;
         ULONG *     pFeedPostHardLimit;
         ULONG *     pFeedPostSoftLimit;
         ULONG *     pFeedReportPeriod;
         WCHAR *     pFilterDescription;
         ULONG *     pFilterEnableCache;
         ULONG *     pFilterEnabled;
         WCHAR *     pFilterLoadOrder;
         WCHAR *     pFilterPath;
         ULONG *     pFilterState;
         ULONG *     pFrontPageWeb;
         ULONG *     pFtpDirBrowseShowLongDate;
         WCHAR *     pFullyQualifiedDomainName;
         WCHAR *     pBannerMessage;
         ULONG *     pUserIsolationMode;
         ULONG *     pFtpLogInUtf8;
         WCHAR *     pGreetingMessage;
         WCHAR *     pGroupHelpFile;
         WCHAR *     pGroupListFile;
         WCHAR *     pGroupVarListFile;
         ULONG *     pHeaderWaitTimeout;
         WCHAR *     pHcCacheControlHeader;
         ULONG *     pHcCompressionBufferSize;
         WCHAR *     pHcCompressionDirectory;
         WCHAR *     pHcCompressionDll;
         ULONG *     pHcCreateFlags;
         ULONG *     pHcDoDiskSpaceLimiting;
         ULONG *     pHcDoDynamicCompression;
         ULONG *     pHcDoOnDemandCompression;
         ULONG *     pHcDoStaticCompression;
         ULONG *     pHcDynamicCompressionLevel;
         WCHAR *     pHcExpiresHeader;
         WCHAR *     pHcFileExtensions;
         ULONG *     pHcFilesDeletedPerDiskFree;
         ULONG *     pHcIoBufferSize;
         ULONG *     pHcMaxDiskSpaceUsage;
         ULONG *     pHcMaxQueueLength;
         ULONG *     pHcMinFileSizeForComp;
         ULONG *     pHcNoCompressionForHttp10;
         ULONG *     pHcNoCompressionForProxies;
         ULONG *     pHcNoCompressionForRange;
         ULONG *     pHcOnDemandCompLevel;
         ULONG *     pHcPriority;
         WCHAR *     pHcScriptFileExtensions;
         ULONG *     pHcSendCacheHeaders;
         WCHAR *     pHistoryTableFile;
         ULONG *     pHonorClientMsgIds;
         ULONG *     pHopCount;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpRedirect;
         ULONG *     pIdleTimeout;
         WCHAR *     pImapClearTextProvider;
         WCHAR *     pImapDefaultDomain;
         WCHAR *     pImapDsAccount;
         WCHAR *     pImapDsBindType;
         WCHAR *     pImapDsDataDirectory;
         WCHAR *     pImapDsDefaultMailRoot;
         WCHAR *     pImapDsHost;
         WCHAR *     pImapDsNamingContext;
         WCHAR *     pImapDsPassword;
         WCHAR *     pImapDsSchemaType;
         ULONG *     pImapExpireDelay;
         ULONG *     pImapExpireMail;
         ULONG *     pImapExpireStart;
         ULONG *     pImapMailExpirationTime;
         WCHAR *     pImapRoutingDll;
         WCHAR *     pImapRoutingSources;
         WCHAR *     pImapRoutingTableType;
         ULONG *     pImapServiceVersion;
         WCHAR *     pInProcessIsapiApps;
 unsigned char *     pIPSecurity;
         ULONG *     pLimitRemoteConnections;
         WCHAR *     pListFile;
         ULONG *     pLocalRetryAttempts;
         ULONG *     pLocalRetryInterval;
         ULONG *     pLogAnonymous;
         ULONG *     pLogCustomPropertyDataType;
         WCHAR *     pLogCustomPropertyHeader;
         ULONG *     pLogCustomPropertyID;
         ULONG *     pLogCustomPropertyMask;
         WCHAR *     pLogCustomPropertyName;
         WCHAR *     pLogCustomPropertyServicesString;
         ULONG *     pLogCustomPropertyNodeID;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileLocaltimeRollover;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogInUTF8;
         WCHAR *     pLogModuleId;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogModuleUiId;
         ULONG *     pLogNonAnonymous;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcPassword;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         ULONG *     pLogonMethod;
         WCHAR *     pLogPluginClsid;
         ULONG *     pLogType;
         WCHAR *     pMasqueradeDomain;
         ULONG *     pMaxErrorFiles;
         ULONG *     pMaxHistoryFiles;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxBandwidthBlocked;
         ULONG *     pMaxBatchedMessages;
         WCHAR *     pMaxClientsMessage;
         ULONG *     pMaxConnections;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pMaxGlobalBandwidth;
         ULONG *     pMaxMessageSize;
         ULONG *     pMaxOutConnections;
         ULONG *     pMaxOutConnectionsPerDomain;
         ULONG *     pMaxProcesses;
         ULONG *     pMaxRecipients;
         ULONG *     pMaxSearchResults;
         ULONG *     pMaxSessionSize;
         ULONG *     pMaxSmtpLogonErrors;
         WCHAR *     pMD_0;
         ULONG *     pMD_1001;
         WCHAR *     pPostmasterName;
         WCHAR *     pPostmasterEmail;
         WCHAR *     pLocalDomains;
         ULONG *     pShutdownLatency;
         WCHAR *     pMD_APP_LAST_OUTPROC_PID;
         WCHAR *     pAuthChangeURL;
         WCHAR *     pAuthExpiredUnsecureURL;
         WCHAR *     pAuthExpiredURL;
         WCHAR *     pAuthNotifyPwdExpURL;
         WCHAR *     pAuthNotifyPwdExpUnsecureURL;
         ULONG *     pMD_ETAG_CHANGENUMBER;
         WCHAR *     pMD_IISADMIN_EXTENSIONS;
         ULONG *     pMD_ISM_ACCESS_CHECK;
         WCHAR *     pMD_METADATA_ID_REGISTRATION;
         ULONG *     pMD_SERVER_CAPABILITIES;
         ULONG *     pServerCommand;
         ULONG *     pMD_SERVER_PLATFORM;
         ULONG *     pMajorIIsVersionNumber;
         ULONG *     pMinorIIsVersionNumber;
         WCHAR *     pMimeMap;
         ULONG *     pMinFileBytesPerSec;
         WCHAR *     pModeratorFile;
         ULONG *     pMSDOSDirOutput;
         ULONG *     pNntpCommandLogMask;
         WCHAR *     pNewsDropDirectory;
         WCHAR *     pNewsFailedPickupDirectory;
         WCHAR *     pNewsPickupDirectory;
         ULONG *     pNntpServiceVersion;
         WCHAR *     pNntpUucpName;
         WCHAR *     pNTAuthenticationProviders;
         WCHAR *     pOrphanActionExe;
         WCHAR *     pOrphanActionParams;
         ULONG *     pOrphanWorkerProcess;
         ULONG *     pPasswordCacheTTL;
         ULONG *     pPasswordExpirePrenotifyDays;
         WCHAR *     pPath;
         ULONG *     pPeriodicRestartRequests;
         WCHAR *     pPeriodicRestartSchedule;
         ULONG *     pPeriodicRestartTime;
         ULONG *     pPeriodicRestartMemory;
         ULONG *     pPeriodicRestartPrivateMemory;
         WCHAR *     pPickupDirectory;
         ULONG *     pPingingEnabled;
         ULONG *     pPingInterval;
         ULONG *     pPingResponseTime;
         ULONG *     pPoolIdcTimeout;
         WCHAR *     pPop3ClearTextProvider;
         WCHAR *     pPop3DefaultDomain;
         WCHAR *     pPop3DsAccount;
         WCHAR *     pPop3DsBindType;
         WCHAR *     pPop3DsDataDirectory;
         WCHAR *     pPop3DsDefaultMailRoot;
         WCHAR *     pPop3DsHost;
         WCHAR *     pPop3DsNamingContext;
         WCHAR *     pPop3DsPassword;
         WCHAR *     pPop3DsSchemaType;
         ULONG *     pPop3ExpireDelay;
         ULONG *     pPop3ExpireMail;
         ULONG *     pPop3ExpireStart;
         ULONG *     pPop3MailExpirationTime;
         WCHAR *     pPop3RoutingDll;
         WCHAR *     pPop3RoutingSources;
         WCHAR *     pPop3RoutingTableType;
         ULONG *     pPop3ServiceVersion;
         WCHAR *     pPrettyNamesFile;
         WCHAR *     pNntpClearTextProvider;
         ULONG *     pProcessNTCRIfLoggedOn;
         WCHAR *     pQueueDirectory;
         ULONG *     pRapidFailProtection;
         ULONG *     pRapidFailProtectionInterval;
         ULONG *     pRapidFailProtectionMaxCrashes;
         WCHAR *     pRealm;
         WCHAR *     pRedirectHeaders;
         ULONG *     pRelayForAuth;
 unsigned char *     pRelayIpList;
         ULONG *     pRemoteRetryAttempts;
         ULONG *     pRemoteRetryInterval;
         ULONG *     pRemoteSmtpPort;
         ULONG *     pRemoteSmtpSecurePort;
         ULONG *     pRemoteTimeout;
         ULONG *     pRevocationFreshnessTime;
         ULONG *     pRevocationURLRetrievalTimeout;
         ULONG *     pRouteAction;
         WCHAR *     pRouteActionString;
         WCHAR *     pRoutePassword;
         WCHAR *     pRouteUserName;
         WCHAR *     pRoutingDll;
         WCHAR *     pRoutingSources;
         WCHAR *     pSaslLogonDomain;
         WCHAR *     pScriptMaps;
         WCHAR *     pSecureBindings;
         WCHAR *     pSendBadTo;
         WCHAR *     pSendNdrTo;
         ULONG *     pServerAutoStart;
         WCHAR *     pServerBindings;
         WCHAR *     pServerComment;
         ULONG *     pServerListenBacklog;
         ULONG *     pServerListenTimeout;
         ULONG *     pServerSize;
         ULONG *     pServerState;
 unsigned char *     pSessionKey;
         ULONG *     pShouldDeliver;
         ULONG *     pShutdownTimeLimit;
         WCHAR *     pSmartHost;
         ULONG *     pSmartHostType;
         ULONG *     pSMPAffinitized;
         ULONG *     pSMPProcessorAffinityMask;
         WCHAR *     pSmtpAdvQueueDll;
         ULONG *     pSmtpAuthTimeout;
         ULONG *     pSmtpBdatTimeout;
         WCHAR *     pSmtpClearTextProvider;
         ULONG *     pSmtpCommandLogMask;
         ULONG *     pSmtpConnectTimeout;
         ULONG *     pSmtpDataTimeout;
         WCHAR *     pSmtpDsAccount;
         WCHAR *     pSmtpDsBindType;
         WCHAR *     pSmtpDsDataDirectory;
         WCHAR *     pSmtpDsDefaultMailRoot;
         WCHAR *     pSmtpDsDomain;
         ULONG *     pSmtpDsFlags;
         WCHAR *     pSmtpDsHost;
         WCHAR *     pSmtpDsNamingContext;
         ULONG *     pSmtpDSNLanguageID;
         ULONG *     pSmtpDSNOptions;
         WCHAR *     pSmtpDsPassword;
         ULONG *     pSmtpDsPort;
         WCHAR *     pSmtpDsSchemaType;
         ULONG *     pSmtpDsUseCat;
         ULONG *     pSmtpFlushMailFile;
         ULONG *     pSmtpHeloTimeout;
         ULONG *     pSmtpInboundCommandSupportOptions;
         ULONG *     pSmtpLocalDelayExpireMinutes;
         ULONG *     pSmtpLocalNDRExpireMinutes;
         ULONG *     pSmtpMailFromTimeout;
         ULONG *     pSmtpOutboundCommandSupportOptions;
         ULONG *     pSmtpRcptToTimeout;
         ULONG *     pSmtpRemoteDelayExpireMinutes;
         ULONG *     pSmtpRemoteNDRExpireMinutes;
         WCHAR *     pSmtpRemoteProgressiveRetry;
         ULONG *     pSmtpRemoteRetryThreshold;
         WCHAR *     pSmtpRoutingTableType;
         ULONG *     pSmtpRsetTimeout;
         ULONG *     pSmtpSaslTimeout;
         WCHAR *     pSmtpServer;
         ULONG *     pSmtpServiceVersion;
         ULONG *     pSmtpTurnTimeout;
         ULONG *     pSmtpIpRestrictionFlag;
         ULONG *     pSSIExecDisable;
 unsigned char *     pSSLCertHash;
         WCHAR *     pSSLStoreName;
         ULONG *     pSslUseDsMapper;
         ULONG *     pSSLAlwaysNegoClientCert;
         ULONG *     pStartupTimeLimit;
         ULONG *     pAppPoolQueueLength;
         WCHAR *     pUNCPassword;
         WCHAR *     pUNCUserName;
         ULONG *     pDisableStaticFileCache;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pUseDigestSSP;
         WCHAR *     pVrDriverClsid;
         WCHAR *     pVrDriverProgid;
         WCHAR *     pFsPropertyPath;
         ULONG *     pVrUseAccount;
         ULONG *     pVrDoExpire;
         WCHAR *     pExMdbGuid;
         ULONG *     pVrOwnModerator;
         ULONG *     pArticleTimeLimit;
         ULONG *     pHistoryExpiration;
         ULONG *     pNewsCrawlerTime;
         WCHAR *     pNntpOrganization;
         ULONG *     pSmtpUseTcpDns;
         ULONG *     pSmtpDotStuffPickupDirFiles;
         ULONG *     pSmtpDomainValidationFlags;
         ULONG *     pSmtpSSLRequireTrustedCA;
         ULONG *     pSmtpSSLCertHostnameValidation;
         ULONG *     pMaxMailObjects;
         ULONG *     pShouldPickupMail;
         ULONG *     pMaxDirChangeIOSize;
         ULONG *     pNameResolutionType;
         ULONG *     pMaxSmtpErrors;
         ULONG *     pShouldPipelineIn;
         ULONG *     pShouldPipelineOut;
         WCHAR *     pConnectResponse;
         ULONG *     pUpdatedFQDN;
         ULONG *     pUpdatedDefaultDomain;
         ULONG *     pEtrnSubdomains;
         ULONG *     pSmtpMaxRemoteQThreads;
         ULONG *     pSmtpDisableRelay;
         ULONG *     pSmtpHeloNoDomain;
         ULONG *     pSmtpMailNoHelo;
         ULONG *     pSmtpAqueueWait;
         ULONG *     pAddNoHeaders;
         ULONG *     pSmtpEventlogLevel;
         WCHAR *     pFeedServerName;
         ULONG *     pFeedType;
         WCHAR *     pFeedNewsgroups;
         ULONG *     pFeedSecurityType;
         ULONG *     pFeedAuthenticationType;
         WCHAR *     pFeedAccountName;
         WCHAR *     pFeedPassword;
         ULONG *     pFeedStartTimeHigh;
         ULONG *     pFeedStartTimeLow;
         ULONG *     pFeedInterval;
         ULONG *     pFeedAllowControlMsgs;
         ULONG *     pFeedCreateAutomatically;
         ULONG *     pFeedDisabled;
         WCHAR *     pFeedDistribution;
         ULONG *     pFeedConcurrentSessions;
         ULONG *     pFeedMaxConnectionAttempts;
         WCHAR *     pFeedUucpName;
         WCHAR *     pFeedTempDirectory;
         ULONG *     pFeedNextPullHigh;
         ULONG *     pFeedNextPullLow;
         WCHAR *     pFeedPeerTempDirectory;
         ULONG *     pFeedPeerGapSize;
         ULONG *     pFeedOutgoingPort;
         ULONG *     pFeedFeedpairId;
         ULONG *     pFeedHandshake;
         ULONG *     pFeedAdminError;
         ULONG *     pFeedErrParmMask;
         ULONG *     pExpireSpace;
         ULONG *     pExpireTime;
         WCHAR *     pExpireNewsgroups;
         WCHAR *     pExpirePolicyName;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         WCHAR *     pWAMUserName;
         WCHAR *     pWAMUserPass;
         ULONG *     pWin32Error;
         WCHAR *     pXoverTableFile;
         WCHAR *     pADConnectionsUserName;
         WCHAR *     pADConnectionsPassword;
         WCHAR *     pPassivePortRange;
         WCHAR *     pIsapiRestrictionList;
         WCHAR *     pCgiRestrictionList;
         ULONG *     pLoadBalancerCapabilities;
         WCHAR *     pAutoShutdownAppPoolExe;
         WCHAR *     pAutoShutdownAppPoolParams;
         WCHAR *     pRestrictionListCustomDesc;
         WCHAR *     pApplicationDependencies;
         WCHAR *     pWebSvcExtRestrictionList;
         ULONG *     pCentralBinaryLoggingEnabled;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
         ULONG *     pAzImpersonationLevel;
         WCHAR *     pSslCtlIdentifier;
         WCHAR *     pSslCtlStoreName;
         ULONG *     pAspBufferingLimit;
         ULONG *     pMaxRequestEntityAllowed;
         ULONG *     pAspMaxRequestEntityAllowed;
         ULONG *     pDemandStartThreshold;
         ULONG *     pPassportRequireADMapping;
         ULONG *     pAspCalcLineNumber;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pAuthFlags;
         ULONG *     pAuthPersistence;
         ULONG *     pDirBrowseFlags;
         ULONG *     pFilterFlags;
         ULONG *     pLogExtFileFlags;
         ULONG *     pPasswordChangeFlags;
         ULONG *     pServerConfigFlags;
         ULONG *     pAspAppServiceFlags;
         ULONG *     pLogEventOnRecycle;
};

enum eIIsConfigObject_AccessFlags {
    fIIsConfigObject_AccessExecute	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_AccessSource 	=	0x00000010,	//(16 decimal)
    fIIsConfigObject_AccessRead   	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_AccessWrite  	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_AccessScript 	=	0x00000200,	//(512 decimal)
    fIIsConfigObject_AccessNoRemoteExecute	=	0x00002000,	//(8192 decimal)
    fIIsConfigObject_AccessNoRemoteRead	=	0x00001000,	//(4096 decimal)
    fIIsConfigObject_AccessNoRemoteWrite	=	0x00000400,	//(1024 decimal)
    fIIsConfigObject_AccessNoRemoteScript	=	0x00004000,	//(16384 decimal)
    fIIsConfigObject_AccessNoPhysicalDir	=	0x00008000,	//(32768 decimal)
    fIIsConfigObject_AccessFlags_Mask	= 0x0000f617
};

enum eIIsConfigObject_AccessSSLFlags {
    fIIsConfigObject_AccessSSL    	=	0x00000008,	//(8 decimal)
    fIIsConfigObject_AccessSSL128 	=	0x00000100,	//(256 decimal)
    fIIsConfigObject_AccessSSLNegotiateCert	=	0x00000020,	//(32 decimal)
    fIIsConfigObject_AccessSSLRequireCert	=	0x00000040,	//(64 decimal)
    fIIsConfigObject_AccessSSLMapCert	=	0x00000080,	//(128 decimal)
    fIIsConfigObject_AccessSSLFlags_Mask	= 0x000001e8
};

enum eIIsConfigObject_AuthFlags {
    fIIsConfigObject_AuthBasic    	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_AuthAnonymous	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_AuthNTLM     	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_AuthMD5      	=	0x00000010,	//(16 decimal)
    fIIsConfigObject_AuthPassport 	=	0x00000040,	//(64 decimal)
    fIIsConfigObject_AuthFlags_Mask	= 0x00000057
};

enum eIIsConfigObject_AuthPersistence {
    fIIsConfigObject_AuthPersistSingleRequest	=	0x00000040,	//(64 decimal)
    fIIsConfigObject_AuthPersistence_Mask	= 0x00000040
};

enum eIIsConfigObject_DirBrowseFlags {
    fIIsConfigObject_EnableDirBrowsing	=	0x80000000,	//(-2147483648 decimal)
    fIIsConfigObject_DirBrowseShowDate	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_DirBrowseShowTime	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_DirBrowseShowSize	=	0x00000008,	//(8 decimal)
    fIIsConfigObject_DirBrowseShowExtension	=	0x00000010,	//(16 decimal)
    fIIsConfigObject_DirBrowseShowLongDate	=	0x00000020,	//(32 decimal)
    fIIsConfigObject_EnableDefaultDoc	=	0x40000000,	//(1073741824 decimal)
    fIIsConfigObject_DirBrowseFlags_Mask	= 0xc000003e
};

enum eIIsConfigObject_FilterFlags {
    fIIsConfigObject_NotifySecurePort	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_NotifyNonSecurePort	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_NotifyReadRawData	=	0x00008000,	//(32768 decimal)
    fIIsConfigObject_NotifyPreProcHeaders	=	0x00004000,	//(16384 decimal)
    fIIsConfigObject_NotifyAuthentication	=	0x00002000,	//(8192 decimal)
    fIIsConfigObject_NotifyUrlMap 	=	0x00001000,	//(4096 decimal)
    fIIsConfigObject_NotifyAccessDenied	=	0x00000800,	//(2048 decimal)
    fIIsConfigObject_NotifySendResponse	=	0x00000040,	//(64 decimal)
    fIIsConfigObject_NotifySendRawData	=	0x00000400,	//(1024 decimal)
    fIIsConfigObject_NotifyLog    	=	0x00000200,	//(512 decimal)
    fIIsConfigObject_NotifyEndOfRequest	=	0x00000080,	//(128 decimal)
    fIIsConfigObject_NotifyEndOfNetSession	=	0x00000100,	//(256 decimal)
    fIIsConfigObject_NotifyOrderHigh	=	0x00080000,	//(524288 decimal)
    fIIsConfigObject_NotifyOrderMedium	=	0x00040000,	//(262144 decimal)
    fIIsConfigObject_NotifyOrderLow	=	0x00020000,	//(131072 decimal)
    fIIsConfigObject_NotifyAuthComplete	=	0x04000000,	//(67108864 decimal)
    fIIsConfigObject_FilterFlags_Mask	= 0x040effc3
};

enum eIIsConfigObject_LogExtFileFlags {
    fIIsConfigObject_LogExtFileDate	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_LogExtFileHost	=	0x00100000,	//(1048576 decimal)
    fIIsConfigObject_LogExtFileTime	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_LogExtFileClientIp	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_LogExtFileUserName	=	0x00000008,	//(8 decimal)
    fIIsConfigObject_LogExtFileSiteName	=	0x00000010,	//(16 decimal)
    fIIsConfigObject_LogExtFileComputerName	=	0x00000020,	//(32 decimal)
    fIIsConfigObject_LogExtFileServerIp	=	0x00000040,	//(64 decimal)
    fIIsConfigObject_LogExtFileMethod	=	0x00000080,	//(128 decimal)
    fIIsConfigObject_LogExtFileUriStem	=	0x00000100,	//(256 decimal)
    fIIsConfigObject_LogExtFileUriQuery	=	0x00000200,	//(512 decimal)
    fIIsConfigObject_LogExtFileHttpStatus	=	0x00000400,	//(1024 decimal)
    fIIsConfigObject_LogExtFileWin32Status	=	0x00000800,	//(2048 decimal)
    fIIsConfigObject_LogExtFileBytesSent	=	0x00001000,	//(4096 decimal)
    fIIsConfigObject_LogExtFileBytesRecv	=	0x00002000,	//(8192 decimal)
    fIIsConfigObject_LogExtFileTimeTaken	=	0x00004000,	//(16384 decimal)
    fIIsConfigObject_LogExtFileServerPort	=	0x00008000,	//(32768 decimal)
    fIIsConfigObject_LogExtFileUserAgent	=	0x00010000,	//(65536 decimal)
    fIIsConfigObject_LogExtFileCookie	=	0x00020000,	//(131072 decimal)
    fIIsConfigObject_LogExtFileReferer	=	0x00040000,	//(262144 decimal)
    fIIsConfigObject_LogExtFileProtocolVersion	=	0x00080000,	//(524288 decimal)
    fIIsConfigObject_LogExtFileHttpSubStatus	=	0x00200000,	//(2097152 decimal)
    fIIsConfigObject_LogExtFileFlags_Mask	= 0x003fffff
};

enum eIIsConfigObject_PasswordChangeFlags {
    fIIsConfigObject_AuthChangeUnsecure	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_AuthChangeDisable	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_AuthAdvNotifyDisable	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_PasswordChangeFlags_Mask	= 0x00000007
};

enum eIIsConfigObject_ServerConfigFlags {
    fIIsConfigObject_ServerConfigSSL40	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_ServerConfigSSL128	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_ServerConfigSSLAllowEncrypt	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_ServerConfigAutoPWSync	=	0x00000008,	//(8 decimal)
    fIIsConfigObject_ServerConfigFlags_Mask	= 0x0000000f
};

enum eIIsConfigObject_AspAppServiceFlags {
    fIIsConfigObject_AspEnableTracker	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_AspEnableSxs 	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_AspUsePartition	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_AspAppServiceFlags_Mask	= 0x00000007
};

enum eIIsConfigObject_LogEventOnRecycle {
    fIIsConfigObject_AppPoolRecycleTime	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_AppPoolRecycleRequests	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_AppPoolRecycleSchedule	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_AppPoolRecycleMemory	=	0x00000008,	//(8 decimal)
    fIIsConfigObject_AppPoolRecycleIsapiUnhealthy	=	0x00000010,	//(16 decimal)
    fIIsConfigObject_AppPoolRecycleOnDemand	=	0x00000020,	//(32 decimal)
    fIIsConfigObject_AppPoolRecycleConfigChange	=	0x00000040,	//(64 decimal)
    fIIsConfigObject_AppPoolRecyclePrivateMemory	=	0x00000080,	//(128 decimal)
    fIIsConfigObject_LogEventOnRecycle_Mask	= 0x000000ff
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsInheritedProperties                  L"IIsInheritedProperties"
#define TABLEID_IIsInheritedProperties                   (0xf9eae800L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsInheritedProperties               (0L)
#define ExtendedVersion_IIsInheritedProperties           (0L)

//-----------------Column Index Enums--------------   
enum eIIsInheritedProperties {
    iIIsInheritedProperties_KeyType,  
    iIIsInheritedProperties_AdminACL,  
    iIIsInheritedProperties_AdminACLBin,  
    iIIsInheritedProperties_AdminEmail,  
    iIIsInheritedProperties_AdminName,  
    iIIsInheritedProperties_AdminServer,  
    iIIsInheritedProperties_AllowAnonymous,  
    iIIsInheritedProperties_AllowClientPosts,  
    iIIsInheritedProperties_AllowControlMsgs,  
    iIIsInheritedProperties_AllowFeedPosts,  
    iIIsInheritedProperties_AllowKeepAlive,  
    iIIsInheritedProperties_AllowPathInfoForScriptMappings,  
    iIIsInheritedProperties_AlwaysUseSsl,  
    iIIsInheritedProperties_AnonymousOnly,  
    iIIsInheritedProperties_AnonymousPasswordSync,  
    iIIsInheritedProperties_AnonymousUserName,  
    iIIsInheritedProperties_AnonymousUserPass,  
    iIIsInheritedProperties_AppAllowClientDebug,  
    iIIsInheritedProperties_AppAllowDebugging,  
    iIIsInheritedProperties_AppFriendlyName,  
    iIIsInheritedProperties_AppIsolated,  
    iIIsInheritedProperties_AppOopRecoverLimit,  
    iIIsInheritedProperties_AppPackageID,  
    iIIsInheritedProperties_AppPackageName,  
    iIIsInheritedProperties_AppPoolId,  
    iIIsInheritedProperties_AppPoolIdentityType,  
    iIIsInheritedProperties_AppPoolCommand,  
    iIIsInheritedProperties_AppPoolState,  
    iIIsInheritedProperties_AppPoolAutoStart,  
    iIIsInheritedProperties_AppRoot,  
    iIIsInheritedProperties_AppWamClsid,  
    iIIsInheritedProperties_ArticleTableFile,  
    iIIsInheritedProperties_AspAllowOutOfProcComponents,  
    iIIsInheritedProperties_AspAllowSessionState,  
    iIIsInheritedProperties_AspBufferingOn,  
    iIIsInheritedProperties_AspCodepage,  
    iIIsInheritedProperties_AspDiskTemplateCacheDirectory,  
    iIIsInheritedProperties_AspEnableApplicationRestart,  
    iIIsInheritedProperties_AspEnableAspHtmlFallback,  
    iIIsInheritedProperties_AspEnableChunkedEncoding,  
    iIIsInheritedProperties_AspEnableParentPaths,  
    iIIsInheritedProperties_AspEnableTypelibCache,  
    iIIsInheritedProperties_AspErrorsToNTLog,  
    iIIsInheritedProperties_AspExceptionCatchEnable,  
    iIIsInheritedProperties_AspKeepSessionIDSecure,  
    iIIsInheritedProperties_AspLCID,  
    iIIsInheritedProperties_AspLogErrorRequests,  
    iIIsInheritedProperties_AspMaxDiskTemplateCacheFiles,  
    iIIsInheritedProperties_AspPartitionID,  
    iIIsInheritedProperties_AspSxsName,  
    iIIsInheritedProperties_AspProcessorThreadMax,  
    iIIsInheritedProperties_AspQueueConnectionTestTime,  
    iIIsInheritedProperties_AspQueueTimeout,  
    iIIsInheritedProperties_AspRequestQueueMax,  
    iIIsInheritedProperties_AspScriptEngineCacheMax,  
    iIIsInheritedProperties_AspScriptErrorMessage,  
    iIIsInheritedProperties_AspScriptErrorSentToBrowser,  
    iIIsInheritedProperties_AspScriptFileCacheSize,  
    iIIsInheritedProperties_AspScriptLanguage,  
    iIIsInheritedProperties_AspScriptTimeout,  
    iIIsInheritedProperties_AspSessionMax,  
    iIIsInheritedProperties_AspSessionTimeout,  
    iIIsInheritedProperties_AspTrackThreadingModel,  
    iIIsInheritedProperties_AspExecuteInMTA,  
    iIIsInheritedProperties_AspRunOnEndAnonymously,  
    iIIsInheritedProperties_AuthTurnList,  
    iIIsInheritedProperties_IIs5IsolationModeEnabled,  
    iIIsInheritedProperties_BadMailDirectory,  
    iIIsInheritedProperties_CacheControlCustom,  
    iIIsInheritedProperties_CacheControlMaxAge,  
    iIIsInheritedProperties_CacheControlNoCache,  
    iIIsInheritedProperties_CacheISAPI,  
    iIIsInheritedProperties_CertCheckMode,  
    iIIsInheritedProperties_CGITimeout,  
    iIIsInheritedProperties_ChangeNumber,  
    iIIsInheritedProperties_ClientPostHardLimit,  
    iIIsInheritedProperties_ClientPostSoftLimit,  
    iIIsInheritedProperties_ClusterEnabled,  
    iIIsInheritedProperties_CollectionComment,  
    iIIsInheritedProperties_ConnectionTimeout,  
    iIIsInheritedProperties_ContentIndexed,  
    iIIsInheritedProperties_CPUAction,  
    iIIsInheritedProperties_CPULimit,  
    iIIsInheritedProperties_CPUResetInterval,  
    iIIsInheritedProperties_CreateCGIWithNewConsole,  
    iIIsInheritedProperties_CreateProcessAsUser,  
    iIIsInheritedProperties_CSideEtrnDomains,  
    iIIsInheritedProperties_CustomErrorDescriptions,  
    iIIsInheritedProperties_DefaultDoc,  
    iIIsInheritedProperties_DefaultDocFooter,  
    iIIsInheritedProperties_DefaultDomain,  
    iIIsInheritedProperties_DefaultLogonDomain,  
    iIIsInheritedProperties_DefaultModeratorDomain,  
    iIIsInheritedProperties_DirectoryLevelsToScan,  
    iIIsInheritedProperties_DisableNewNews,  
    iIIsInheritedProperties_DisableSocketPooling,  
    iIIsInheritedProperties_DisallowOverlappingRotation,  
    iIIsInheritedProperties_DisallowRotationOnConfigChange,  
    iIIsInheritedProperties_DomainRouting,  
    iIIsInheritedProperties_DoMasquerade,  
    iIIsInheritedProperties_DontLog,  
    iIIsInheritedProperties_DownlevelAdminInstance,  
    iIIsInheritedProperties_DropDirectory,  
    iIIsInheritedProperties_HistoryMajorVersionNumber,  
    iIIsInheritedProperties_XMLSchemaTimeStamp,  
    iIIsInheritedProperties_BINSchemaTimeStamp,  
    iIIsInheritedProperties_EnableHistory,  
    iIIsInheritedProperties_EnableDocFooter,  
    iIIsInheritedProperties_EnableEditWhileRunning,  
    iIIsInheritedProperties_EnableReverseDns,  
    iIIsInheritedProperties_EnableReverseDnsLookup,  
    iIIsInheritedProperties_EtrnDays,  
    iIIsInheritedProperties_ExitMessage,  
    iIIsInheritedProperties_FeedPostHardLimit,  
    iIIsInheritedProperties_FeedPostSoftLimit,  
    iIIsInheritedProperties_FeedReportPeriod,  
    iIIsInheritedProperties_FilterDescription,  
    iIIsInheritedProperties_FilterEnableCache,  
    iIIsInheritedProperties_FilterEnabled,  
    iIIsInheritedProperties_FilterLoadOrder,  
    iIIsInheritedProperties_FilterPath,  
    iIIsInheritedProperties_FilterState,  
    iIIsInheritedProperties_FrontPageWeb,  
    iIIsInheritedProperties_FtpDirBrowseShowLongDate,  
    iIIsInheritedProperties_FullyQualifiedDomainName,  
    iIIsInheritedProperties_BannerMessage,  
    iIIsInheritedProperties_UserIsolationMode,  
    iIIsInheritedProperties_FtpLogInUtf8,  
    iIIsInheritedProperties_GreetingMessage,  
    iIIsInheritedProperties_GroupHelpFile,  
    iIIsInheritedProperties_GroupListFile,  
    iIIsInheritedProperties_GroupVarListFile,  
    iIIsInheritedProperties_HeaderWaitTimeout,  
    iIIsInheritedProperties_HcCacheControlHeader,  
    iIIsInheritedProperties_HcCompressionBufferSize,  
    iIIsInheritedProperties_HcCompressionDirectory,  
    iIIsInheritedProperties_HcCompressionDll,  
    iIIsInheritedProperties_HcCreateFlags,  
    iIIsInheritedProperties_HcDoDiskSpaceLimiting,  
    iIIsInheritedProperties_HcDoDynamicCompression,  
    iIIsInheritedProperties_HcDoOnDemandCompression,  
    iIIsInheritedProperties_HcDoStaticCompression,  
    iIIsInheritedProperties_HcDynamicCompressionLevel,  
    iIIsInheritedProperties_HcExpiresHeader,  
    iIIsInheritedProperties_HcFileExtensions,  
    iIIsInheritedProperties_HcFilesDeletedPerDiskFree,  
    iIIsInheritedProperties_HcIoBufferSize,  
    iIIsInheritedProperties_HcMaxDiskSpaceUsage,  
    iIIsInheritedProperties_HcMaxQueueLength,  
    iIIsInheritedProperties_HcMinFileSizeForComp,  
    iIIsInheritedProperties_HcNoCompressionForHttp10,  
    iIIsInheritedProperties_HcNoCompressionForProxies,  
    iIIsInheritedProperties_HcNoCompressionForRange,  
    iIIsInheritedProperties_HcOnDemandCompLevel,  
    iIIsInheritedProperties_HcPriority,  
    iIIsInheritedProperties_HcScriptFileExtensions,  
    iIIsInheritedProperties_HcSendCacheHeaders,  
    iIIsInheritedProperties_HistoryTableFile,  
    iIIsInheritedProperties_HonorClientMsgIds,  
    iIIsInheritedProperties_HopCount,  
    iIIsInheritedProperties_HttpCustomHeaders,  
    iIIsInheritedProperties_HttpErrors,  
    iIIsInheritedProperties_HttpExpires,  
    iIIsInheritedProperties_HttpPics,  
    iIIsInheritedProperties_HttpRedirect,  
    iIIsInheritedProperties_IdleTimeout,  
    iIIsInheritedProperties_ImapClearTextProvider,  
    iIIsInheritedProperties_ImapDefaultDomain,  
    iIIsInheritedProperties_ImapDsAccount,  
    iIIsInheritedProperties_ImapDsBindType,  
    iIIsInheritedProperties_ImapDsDataDirectory,  
    iIIsInheritedProperties_ImapDsDefaultMailRoot,  
    iIIsInheritedProperties_ImapDsHost,  
    iIIsInheritedProperties_ImapDsNamingContext,  
    iIIsInheritedProperties_ImapDsPassword,  
    iIIsInheritedProperties_ImapDsSchemaType,  
    iIIsInheritedProperties_ImapExpireDelay,  
    iIIsInheritedProperties_ImapExpireMail,  
    iIIsInheritedProperties_ImapExpireStart,  
    iIIsInheritedProperties_ImapMailExpirationTime,  
    iIIsInheritedProperties_ImapRoutingDll,  
    iIIsInheritedProperties_ImapRoutingSources,  
    iIIsInheritedProperties_ImapRoutingTableType,  
    iIIsInheritedProperties_ImapServiceVersion,  
    iIIsInheritedProperties_InProcessIsapiApps,  
    iIIsInheritedProperties_IPSecurity,  
    iIIsInheritedProperties_LimitRemoteConnections,  
    iIIsInheritedProperties_ListFile,  
    iIIsInheritedProperties_LocalRetryAttempts,  
    iIIsInheritedProperties_LocalRetryInterval,  
    iIIsInheritedProperties_LogAnonymous,  
    iIIsInheritedProperties_LogCustomPropertyDataType,  
    iIIsInheritedProperties_LogCustomPropertyHeader,  
    iIIsInheritedProperties_LogCustomPropertyID,  
    iIIsInheritedProperties_LogCustomPropertyMask,  
    iIIsInheritedProperties_LogCustomPropertyName,  
    iIIsInheritedProperties_LogCustomPropertyServicesString,  
    iIIsInheritedProperties_LogCustomPropertyNodeID,  
    iIIsInheritedProperties_LogFileDirectory,  
    iIIsInheritedProperties_LogFileLocaltimeRollover,  
    iIIsInheritedProperties_LogFilePeriod,  
    iIIsInheritedProperties_LogFileTruncateSize,  
    iIIsInheritedProperties_LogInUTF8,  
    iIIsInheritedProperties_LogModuleId,  
    iIIsInheritedProperties_LogModuleList,  
    iIIsInheritedProperties_LogModuleUiId,  
    iIIsInheritedProperties_LogNonAnonymous,  
    iIIsInheritedProperties_LogOdbcDataSource,  
    iIIsInheritedProperties_LogOdbcPassword,  
    iIIsInheritedProperties_LogOdbcTableName,  
    iIIsInheritedProperties_LogOdbcUserName,  
    iIIsInheritedProperties_LogonMethod,  
    iIIsInheritedProperties_LogPluginClsid,  
    iIIsInheritedProperties_LogType,  
    iIIsInheritedProperties_MasqueradeDomain,  
    iIIsInheritedProperties_MaxErrorFiles,  
    iIIsInheritedProperties_MaxHistoryFiles,  
    iIIsInheritedProperties_MaxBandwidth,  
    iIIsInheritedProperties_MaxBandwidthBlocked,  
    iIIsInheritedProperties_MaxBatchedMessages,  
    iIIsInheritedProperties_MaxClientsMessage,  
    iIIsInheritedProperties_MaxConnections,  
    iIIsInheritedProperties_MaxEndpointConnections,  
    iIIsInheritedProperties_MaxGlobalBandwidth,  
    iIIsInheritedProperties_MaxMessageSize,  
    iIIsInheritedProperties_MaxOutConnections,  
    iIIsInheritedProperties_MaxOutConnectionsPerDomain,  
    iIIsInheritedProperties_MaxProcesses,  
    iIIsInheritedProperties_MaxRecipients,  
    iIIsInheritedProperties_MaxSearchResults,  
    iIIsInheritedProperties_MaxSessionSize,  
    iIIsInheritedProperties_MaxSmtpLogonErrors,  
    iIIsInheritedProperties_MD_0,  
    iIIsInheritedProperties_MD_1001,  
    iIIsInheritedProperties_PostmasterName,  
    iIIsInheritedProperties_PostmasterEmail,  
    iIIsInheritedProperties_LocalDomains,  
    iIIsInheritedProperties_ShutdownLatency,  
    iIIsInheritedProperties_MD_APP_LAST_OUTPROC_PID,  
    iIIsInheritedProperties_AuthChangeURL,  
    iIIsInheritedProperties_AuthExpiredUnsecureURL,  
    iIIsInheritedProperties_AuthExpiredURL,  
    iIIsInheritedProperties_AuthNotifyPwdExpURL,  
    iIIsInheritedProperties_AuthNotifyPwdExpUnsecureURL,  
    iIIsInheritedProperties_MD_ETAG_CHANGENUMBER,  
    iIIsInheritedProperties_MD_IISADMIN_EXTENSIONS,  
    iIIsInheritedProperties_MD_ISM_ACCESS_CHECK,  
    iIIsInheritedProperties_MD_METADATA_ID_REGISTRATION,  
    iIIsInheritedProperties_MD_SERVER_CAPABILITIES,  
    iIIsInheritedProperties_ServerCommand,  
    iIIsInheritedProperties_MD_SERVER_PLATFORM,  
    iIIsInheritedProperties_MajorIIsVersionNumber,  
    iIIsInheritedProperties_MinorIIsVersionNumber,  
    iIIsInheritedProperties_MimeMap,  
    iIIsInheritedProperties_MinFileBytesPerSec,  
    iIIsInheritedProperties_ModeratorFile,  
    iIIsInheritedProperties_MSDOSDirOutput,  
    iIIsInheritedProperties_NntpCommandLogMask,  
    iIIsInheritedProperties_NewsDropDirectory,  
    iIIsInheritedProperties_NewsFailedPickupDirectory,  
    iIIsInheritedProperties_NewsPickupDirectory,  
    iIIsInheritedProperties_NntpServiceVersion,  
    iIIsInheritedProperties_NntpUucpName,  
    iIIsInheritedProperties_NTAuthenticationProviders,  
    iIIsInheritedProperties_OrphanActionExe,  
    iIIsInheritedProperties_OrphanActionParams,  
    iIIsInheritedProperties_OrphanWorkerProcess,  
    iIIsInheritedProperties_PasswordCacheTTL,  
    iIIsInheritedProperties_PasswordExpirePrenotifyDays,  
    iIIsInheritedProperties_Path,  
    iIIsInheritedProperties_PeriodicRestartRequests,  
    iIIsInheritedProperties_PeriodicRestartSchedule,  
    iIIsInheritedProperties_PeriodicRestartTime,  
    iIIsInheritedProperties_PeriodicRestartMemory,  
    iIIsInheritedProperties_PeriodicRestartPrivateMemory,  
    iIIsInheritedProperties_PickupDirectory,  
    iIIsInheritedProperties_PingingEnabled,  
    iIIsInheritedProperties_PingInterval,  
    iIIsInheritedProperties_PingResponseTime,  
    iIIsInheritedProperties_PoolIdcTimeout,  
    iIIsInheritedProperties_Pop3ClearTextProvider,  
    iIIsInheritedProperties_Pop3DefaultDomain,  
    iIIsInheritedProperties_Pop3DsAccount,  
    iIIsInheritedProperties_Pop3DsBindType,  
    iIIsInheritedProperties_Pop3DsDataDirectory,  
    iIIsInheritedProperties_Pop3DsDefaultMailRoot,  
    iIIsInheritedProperties_Pop3DsHost,  
    iIIsInheritedProperties_Pop3DsNamingContext,  
    iIIsInheritedProperties_Pop3DsPassword,  
    iIIsInheritedProperties_Pop3DsSchemaType,  
    iIIsInheritedProperties_Pop3ExpireDelay,  
    iIIsInheritedProperties_Pop3ExpireMail,  
    iIIsInheritedProperties_Pop3ExpireStart,  
    iIIsInheritedProperties_Pop3MailExpirationTime,  
    iIIsInheritedProperties_Pop3RoutingDll,  
    iIIsInheritedProperties_Pop3RoutingSources,  
    iIIsInheritedProperties_Pop3RoutingTableType,  
    iIIsInheritedProperties_Pop3ServiceVersion,  
    iIIsInheritedProperties_PrettyNamesFile,  
    iIIsInheritedProperties_NntpClearTextProvider,  
    iIIsInheritedProperties_ProcessNTCRIfLoggedOn,  
    iIIsInheritedProperties_QueueDirectory,  
    iIIsInheritedProperties_RapidFailProtection,  
    iIIsInheritedProperties_RapidFailProtectionInterval,  
    iIIsInheritedProperties_RapidFailProtectionMaxCrashes,  
    iIIsInheritedProperties_Realm,  
    iIIsInheritedProperties_RedirectHeaders,  
    iIIsInheritedProperties_RelayForAuth,  
    iIIsInheritedProperties_RelayIpList,  
    iIIsInheritedProperties_RemoteRetryAttempts,  
    iIIsInheritedProperties_RemoteRetryInterval,  
    iIIsInheritedProperties_RemoteSmtpPort,  
    iIIsInheritedProperties_RemoteSmtpSecurePort,  
    iIIsInheritedProperties_RemoteTimeout,  
    iIIsInheritedProperties_RevocationFreshnessTime,  
    iIIsInheritedProperties_RevocationURLRetrievalTimeout,  
    iIIsInheritedProperties_RouteAction,  
    iIIsInheritedProperties_RouteActionString,  
    iIIsInheritedProperties_RoutePassword,  
    iIIsInheritedProperties_RouteUserName,  
    iIIsInheritedProperties_RoutingDll,  
    iIIsInheritedProperties_RoutingSources,  
    iIIsInheritedProperties_SaslLogonDomain,  
    iIIsInheritedProperties_ScriptMaps,  
    iIIsInheritedProperties_SecureBindings,  
    iIIsInheritedProperties_SendBadTo,  
    iIIsInheritedProperties_SendNdrTo,  
    iIIsInheritedProperties_ServerAutoStart,  
    iIIsInheritedProperties_ServerBindings,  
    iIIsInheritedProperties_ServerComment,  
    iIIsInheritedProperties_ServerListenBacklog,  
    iIIsInheritedProperties_ServerListenTimeout,  
    iIIsInheritedProperties_ServerSize,  
    iIIsInheritedProperties_ServerState,  
    iIIsInheritedProperties_SessionKey,  
    iIIsInheritedProperties_ShouldDeliver,  
    iIIsInheritedProperties_ShutdownTimeLimit,  
    iIIsInheritedProperties_SmartHost,  
    iIIsInheritedProperties_SmartHostType,  
    iIIsInheritedProperties_SMPAffinitized,  
    iIIsInheritedProperties_SMPProcessorAffinityMask,  
    iIIsInheritedProperties_SmtpAdvQueueDll,  
    iIIsInheritedProperties_SmtpAuthTimeout,  
    iIIsInheritedProperties_SmtpBdatTimeout,  
    iIIsInheritedProperties_SmtpClearTextProvider,  
    iIIsInheritedProperties_SmtpCommandLogMask,  
    iIIsInheritedProperties_SmtpConnectTimeout,  
    iIIsInheritedProperties_SmtpDataTimeout,  
    iIIsInheritedProperties_SmtpDsAccount,  
    iIIsInheritedProperties_SmtpDsBindType,  
    iIIsInheritedProperties_SmtpDsDataDirectory,  
    iIIsInheritedProperties_SmtpDsDefaultMailRoot,  
    iIIsInheritedProperties_SmtpDsDomain,  
    iIIsInheritedProperties_SmtpDsFlags,  
    iIIsInheritedProperties_SmtpDsHost,  
    iIIsInheritedProperties_SmtpDsNamingContext,  
    iIIsInheritedProperties_SmtpDSNLanguageID,  
    iIIsInheritedProperties_SmtpDSNOptions,  
    iIIsInheritedProperties_SmtpDsPassword,  
    iIIsInheritedProperties_SmtpDsPort,  
    iIIsInheritedProperties_SmtpDsSchemaType,  
    iIIsInheritedProperties_SmtpDsUseCat,  
    iIIsInheritedProperties_SmtpFlushMailFile,  
    iIIsInheritedProperties_SmtpHeloTimeout,  
    iIIsInheritedProperties_SmtpInboundCommandSupportOptions,  
    iIIsInheritedProperties_SmtpLocalDelayExpireMinutes,  
    iIIsInheritedProperties_SmtpLocalNDRExpireMinutes,  
    iIIsInheritedProperties_SmtpMailFromTimeout,  
    iIIsInheritedProperties_SmtpOutboundCommandSupportOptions,  
    iIIsInheritedProperties_SmtpRcptToTimeout,  
    iIIsInheritedProperties_SmtpRemoteDelayExpireMinutes,  
    iIIsInheritedProperties_SmtpRemoteNDRExpireMinutes,  
    iIIsInheritedProperties_SmtpRemoteProgressiveRetry,  
    iIIsInheritedProperties_SmtpRemoteRetryThreshold,  
    iIIsInheritedProperties_SmtpRoutingTableType,  
    iIIsInheritedProperties_SmtpRsetTimeout,  
    iIIsInheritedProperties_SmtpSaslTimeout,  
    iIIsInheritedProperties_SmtpServer,  
    iIIsInheritedProperties_SmtpServiceVersion,  
    iIIsInheritedProperties_SmtpTurnTimeout,  
    iIIsInheritedProperties_SmtpIpRestrictionFlag,  
    iIIsInheritedProperties_SSIExecDisable,  
    iIIsInheritedProperties_SSLCertHash,  
    iIIsInheritedProperties_SSLStoreName,  
    iIIsInheritedProperties_SslUseDsMapper,  
    iIIsInheritedProperties_SSLAlwaysNegoClientCert,  
    iIIsInheritedProperties_StartupTimeLimit,  
    iIIsInheritedProperties_AppPoolQueueLength,  
    iIIsInheritedProperties_UNCPassword,  
    iIIsInheritedProperties_UNCUserName,  
    iIIsInheritedProperties_DisableStaticFileCache,  
    iIIsInheritedProperties_UploadReadAheadSize,  
    iIIsInheritedProperties_UseDigestSSP,  
    iIIsInheritedProperties_VrDriverClsid,  
    iIIsInheritedProperties_VrDriverProgid,  
    iIIsInheritedProperties_FsPropertyPath,  
    iIIsInheritedProperties_VrUseAccount,  
    iIIsInheritedProperties_VrDoExpire,  
    iIIsInheritedProperties_ExMdbGuid,  
    iIIsInheritedProperties_VrOwnModerator,  
    iIIsInheritedProperties_ArticleTimeLimit,  
    iIIsInheritedProperties_HistoryExpiration,  
    iIIsInheritedProperties_NewsCrawlerTime,  
    iIIsInheritedProperties_NntpOrganization,  
    iIIsInheritedProperties_SmtpUseTcpDns,  
    iIIsInheritedProperties_SmtpDotStuffPickupDirFiles,  
    iIIsInheritedProperties_SmtpDomainValidationFlags,  
    iIIsInheritedProperties_SmtpSSLRequireTrustedCA,  
    iIIsInheritedProperties_SmtpSSLCertHostnameValidation,  
    iIIsInheritedProperties_MaxMailObjects,  
    iIIsInheritedProperties_ShouldPickupMail,  
    iIIsInheritedProperties_MaxDirChangeIOSize,  
    iIIsInheritedProperties_NameResolutionType,  
    iIIsInheritedProperties_MaxSmtpErrors,  
    iIIsInheritedProperties_ShouldPipelineIn,  
    iIIsInheritedProperties_ShouldPipelineOut,  
    iIIsInheritedProperties_ConnectResponse,  
    iIIsInheritedProperties_UpdatedFQDN,  
    iIIsInheritedProperties_UpdatedDefaultDomain,  
    iIIsInheritedProperties_EtrnSubdomains,  
    iIIsInheritedProperties_SmtpMaxRemoteQThreads,  
    iIIsInheritedProperties_SmtpDisableRelay,  
    iIIsInheritedProperties_SmtpHeloNoDomain,  
    iIIsInheritedProperties_SmtpMailNoHelo,  
    iIIsInheritedProperties_SmtpAqueueWait,  
    iIIsInheritedProperties_AddNoHeaders,  
    iIIsInheritedProperties_SmtpEventlogLevel,  
    iIIsInheritedProperties_FeedServerName,  
    iIIsInheritedProperties_FeedType,  
    iIIsInheritedProperties_FeedNewsgroups,  
    iIIsInheritedProperties_FeedSecurityType,  
    iIIsInheritedProperties_FeedAuthenticationType,  
    iIIsInheritedProperties_FeedAccountName,  
    iIIsInheritedProperties_FeedPassword,  
    iIIsInheritedProperties_FeedStartTimeHigh,  
    iIIsInheritedProperties_FeedStartTimeLow,  
    iIIsInheritedProperties_FeedInterval,  
    iIIsInheritedProperties_FeedAllowControlMsgs,  
    iIIsInheritedProperties_FeedCreateAutomatically,  
    iIIsInheritedProperties_FeedDisabled,  
    iIIsInheritedProperties_FeedDistribution,  
    iIIsInheritedProperties_FeedConcurrentSessions,  
    iIIsInheritedProperties_FeedMaxConnectionAttempts,  
    iIIsInheritedProperties_FeedUucpName,  
    iIIsInheritedProperties_FeedTempDirectory,  
    iIIsInheritedProperties_FeedNextPullHigh,  
    iIIsInheritedProperties_FeedNextPullLow,  
    iIIsInheritedProperties_FeedPeerTempDirectory,  
    iIIsInheritedProperties_FeedPeerGapSize,  
    iIIsInheritedProperties_FeedOutgoingPort,  
    iIIsInheritedProperties_FeedFeedpairId,  
    iIIsInheritedProperties_FeedHandshake,  
    iIIsInheritedProperties_FeedAdminError,  
    iIIsInheritedProperties_FeedErrParmMask,  
    iIIsInheritedProperties_ExpireSpace,  
    iIIsInheritedProperties_ExpireTime,  
    iIIsInheritedProperties_ExpireNewsgroups,  
    iIIsInheritedProperties_ExpirePolicyName,  
    iIIsInheritedProperties_DoStaticCompression,  
    iIIsInheritedProperties_DoDynamicCompression,  
    iIIsInheritedProperties_WAMUserName,  
    iIIsInheritedProperties_WAMUserPass,  
    iIIsInheritedProperties_Win32Error,  
    iIIsInheritedProperties_XoverTableFile,  
    iIIsInheritedProperties_ADConnectionsUserName,  
    iIIsInheritedProperties_ADConnectionsPassword,  
    iIIsInheritedProperties_PassivePortRange,  
    iIIsInheritedProperties_IsapiRestrictionList,  
    iIIsInheritedProperties_CgiRestrictionList,  
    iIIsInheritedProperties_LoadBalancerCapabilities,  
    iIIsInheritedProperties_AutoShutdownAppPoolExe,  
    iIIsInheritedProperties_AutoShutdownAppPoolParams,  
    iIIsInheritedProperties_RestrictionListCustomDesc,  
    iIIsInheritedProperties_ApplicationDependencies,  
    iIIsInheritedProperties_WebSvcExtRestrictionList,  
    iIIsInheritedProperties_CentralBinaryLoggingEnabled,  
    iIIsInheritedProperties_AzEnable,  
    iIIsInheritedProperties_AzStoreName,  
    iIIsInheritedProperties_AzScopeName,  
    iIIsInheritedProperties_AzImpersonationLevel,  
    iIIsInheritedProperties_SslCtlIdentifier,  
    iIIsInheritedProperties_SslCtlStoreName,  
    iIIsInheritedProperties_AspBufferingLimit,  
    iIIsInheritedProperties_MaxRequestEntityAllowed,  
    iIIsInheritedProperties_AspMaxRequestEntityAllowed,  
    iIIsInheritedProperties_DemandStartThreshold,  
    iIIsInheritedProperties_PassportRequireADMapping,  
    iIIsInheritedProperties_AspCalcLineNumber,  
    iIIsInheritedProperties_AccessFlags,  
    iIIsInheritedProperties_AccessSSLFlags,  
    iIIsInheritedProperties_AuthFlags,  
    iIIsInheritedProperties_AuthPersistence,  
    iIIsInheritedProperties_DirBrowseFlags,  
    iIIsInheritedProperties_FilterFlags,  
    iIIsInheritedProperties_LogExtFileFlags,  
    iIIsInheritedProperties_PasswordChangeFlags,  
    iIIsInheritedProperties_ServerConfigFlags,  
    iIIsInheritedProperties_AspAppServiceFlags,  
    iIIsInheritedProperties_LogEventOnRecycle,  
    cIIsInheritedProperties_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsInheritedPropertiesRow {
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
         WCHAR *     pAdminEmail;
         WCHAR *     pAdminName;
         WCHAR *     pAdminServer;
         ULONG *     pAllowAnonymous;
         ULONG *     pAllowClientPosts;
         ULONG *     pAllowControlMsgs;
         ULONG *     pAllowFeedPosts;
         ULONG *     pAllowKeepAlive;
         ULONG *     pAllowPathInfoForScriptMappings;
         ULONG *     pAlwaysUseSsl;
         ULONG *     pAnonymousOnly;
         ULONG *     pAnonymousPasswordSync;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pAppAllowClientDebug;
         ULONG *     pAppAllowDebugging;
         WCHAR *     pAppFriendlyName;
         ULONG *     pAppIsolated;
         ULONG *     pAppOopRecoverLimit;
         WCHAR *     pAppPackageID;
         WCHAR *     pAppPackageName;
         WCHAR *     pAppPoolId;
         ULONG *     pAppPoolIdentityType;
         ULONG *     pAppPoolCommand;
         ULONG *     pAppPoolState;
         ULONG *     pAppPoolAutoStart;
         WCHAR *     pAppRoot;
         WCHAR *     pAppWamClsid;
         WCHAR *     pArticleTableFile;
         ULONG *     pAspAllowOutOfProcComponents;
         ULONG *     pAspAllowSessionState;
         ULONG *     pAspBufferingOn;
         ULONG *     pAspCodepage;
         WCHAR *     pAspDiskTemplateCacheDirectory;
         ULONG *     pAspEnableApplicationRestart;
         ULONG *     pAspEnableAspHtmlFallback;
         ULONG *     pAspEnableChunkedEncoding;
         ULONG *     pAspEnableParentPaths;
         ULONG *     pAspEnableTypelibCache;
         ULONG *     pAspErrorsToNTLog;
         ULONG *     pAspExceptionCatchEnable;
         ULONG *     pAspKeepSessionIDSecure;
         ULONG *     pAspLCID;
         ULONG *     pAspLogErrorRequests;
         ULONG *     pAspMaxDiskTemplateCacheFiles;
         WCHAR *     pAspPartitionID;
         WCHAR *     pAspSxsName;
         ULONG *     pAspProcessorThreadMax;
         ULONG *     pAspQueueConnectionTestTime;
         ULONG *     pAspQueueTimeout;
         ULONG *     pAspRequestQueueMax;
         ULONG *     pAspScriptEngineCacheMax;
         WCHAR *     pAspScriptErrorMessage;
         ULONG *     pAspScriptErrorSentToBrowser;
         ULONG *     pAspScriptFileCacheSize;
         WCHAR *     pAspScriptLanguage;
         ULONG *     pAspScriptTimeout;
         ULONG *     pAspSessionMax;
         ULONG *     pAspSessionTimeout;
         ULONG *     pAspTrackThreadingModel;
         ULONG *     pAspExecuteInMTA;
         ULONG *     pAspRunOnEndAnonymously;
         WCHAR *     pAuthTurnList;
         ULONG *     pIIs5IsolationModeEnabled;
         WCHAR *     pBadMailDirectory;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         ULONG *     pCacheISAPI;
         ULONG *     pCertCheckMode;
         ULONG *     pCGITimeout;
         ULONG *     pChangeNumber;
         ULONG *     pClientPostHardLimit;
         ULONG *     pClientPostSoftLimit;
         ULONG *     pClusterEnabled;
         WCHAR *     pCollectionComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pContentIndexed;
         ULONG *     pCPUAction;
         ULONG *     pCPULimit;
         ULONG *     pCPUResetInterval;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pCreateProcessAsUser;
         WCHAR *     pCSideEtrnDomains;
         WCHAR *     pCustomErrorDescriptions;
         WCHAR *     pDefaultDoc;
         WCHAR *     pDefaultDocFooter;
         WCHAR *     pDefaultDomain;
         WCHAR *     pDefaultLogonDomain;
         WCHAR *     pDefaultModeratorDomain;
         ULONG *     pDirectoryLevelsToScan;
         ULONG *     pDisableNewNews;
         ULONG *     pDisableSocketPooling;
         ULONG *     pDisallowOverlappingRotation;
         ULONG *     pDisallowRotationOnConfigChange;
         WCHAR *     pDomainRouting;
         ULONG *     pDoMasquerade;
         ULONG *     pDontLog;
         ULONG *     pDownlevelAdminInstance;
         WCHAR *     pDropDirectory;
         ULONG *     pHistoryMajorVersionNumber;
 unsigned char *     pXMLSchemaTimeStamp;
 unsigned char *     pBINSchemaTimeStamp;
         ULONG *     pEnableHistory;
         ULONG *     pEnableDocFooter;
         ULONG *     pEnableEditWhileRunning;
         ULONG *     pEnableReverseDns;
         ULONG *     pEnableReverseDnsLookup;
         ULONG *     pEtrnDays;
         WCHAR *     pExitMessage;
         ULONG *     pFeedPostHardLimit;
         ULONG *     pFeedPostSoftLimit;
         ULONG *     pFeedReportPeriod;
         WCHAR *     pFilterDescription;
         ULONG *     pFilterEnableCache;
         ULONG *     pFilterEnabled;
         WCHAR *     pFilterLoadOrder;
         WCHAR *     pFilterPath;
         ULONG *     pFilterState;
         ULONG *     pFrontPageWeb;
         ULONG *     pFtpDirBrowseShowLongDate;
         WCHAR *     pFullyQualifiedDomainName;
         WCHAR *     pBannerMessage;
         ULONG *     pUserIsolationMode;
         ULONG *     pFtpLogInUtf8;
         WCHAR *     pGreetingMessage;
         WCHAR *     pGroupHelpFile;
         WCHAR *     pGroupListFile;
         WCHAR *     pGroupVarListFile;
         ULONG *     pHeaderWaitTimeout;
         WCHAR *     pHcCacheControlHeader;
         ULONG *     pHcCompressionBufferSize;
         WCHAR *     pHcCompressionDirectory;
         WCHAR *     pHcCompressionDll;
         ULONG *     pHcCreateFlags;
         ULONG *     pHcDoDiskSpaceLimiting;
         ULONG *     pHcDoDynamicCompression;
         ULONG *     pHcDoOnDemandCompression;
         ULONG *     pHcDoStaticCompression;
         ULONG *     pHcDynamicCompressionLevel;
         WCHAR *     pHcExpiresHeader;
         WCHAR *     pHcFileExtensions;
         ULONG *     pHcFilesDeletedPerDiskFree;
         ULONG *     pHcIoBufferSize;
         ULONG *     pHcMaxDiskSpaceUsage;
         ULONG *     pHcMaxQueueLength;
         ULONG *     pHcMinFileSizeForComp;
         ULONG *     pHcNoCompressionForHttp10;
         ULONG *     pHcNoCompressionForProxies;
         ULONG *     pHcNoCompressionForRange;
         ULONG *     pHcOnDemandCompLevel;
         ULONG *     pHcPriority;
         WCHAR *     pHcScriptFileExtensions;
         ULONG *     pHcSendCacheHeaders;
         WCHAR *     pHistoryTableFile;
         ULONG *     pHonorClientMsgIds;
         ULONG *     pHopCount;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpRedirect;
         ULONG *     pIdleTimeout;
         WCHAR *     pImapClearTextProvider;
         WCHAR *     pImapDefaultDomain;
         WCHAR *     pImapDsAccount;
         WCHAR *     pImapDsBindType;
         WCHAR *     pImapDsDataDirectory;
         WCHAR *     pImapDsDefaultMailRoot;
         WCHAR *     pImapDsHost;
         WCHAR *     pImapDsNamingContext;
         WCHAR *     pImapDsPassword;
         WCHAR *     pImapDsSchemaType;
         ULONG *     pImapExpireDelay;
         ULONG *     pImapExpireMail;
         ULONG *     pImapExpireStart;
         ULONG *     pImapMailExpirationTime;
         WCHAR *     pImapRoutingDll;
         WCHAR *     pImapRoutingSources;
         WCHAR *     pImapRoutingTableType;
         ULONG *     pImapServiceVersion;
         WCHAR *     pInProcessIsapiApps;
 unsigned char *     pIPSecurity;
         ULONG *     pLimitRemoteConnections;
         WCHAR *     pListFile;
         ULONG *     pLocalRetryAttempts;
         ULONG *     pLocalRetryInterval;
         ULONG *     pLogAnonymous;
         ULONG *     pLogCustomPropertyDataType;
         WCHAR *     pLogCustomPropertyHeader;
         ULONG *     pLogCustomPropertyID;
         ULONG *     pLogCustomPropertyMask;
         WCHAR *     pLogCustomPropertyName;
         WCHAR *     pLogCustomPropertyServicesString;
         ULONG *     pLogCustomPropertyNodeID;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileLocaltimeRollover;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogInUTF8;
         WCHAR *     pLogModuleId;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogModuleUiId;
         ULONG *     pLogNonAnonymous;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcPassword;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         ULONG *     pLogonMethod;
         WCHAR *     pLogPluginClsid;
         ULONG *     pLogType;
         WCHAR *     pMasqueradeDomain;
         ULONG *     pMaxErrorFiles;
         ULONG *     pMaxHistoryFiles;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxBandwidthBlocked;
         ULONG *     pMaxBatchedMessages;
         WCHAR *     pMaxClientsMessage;
         ULONG *     pMaxConnections;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pMaxGlobalBandwidth;
         ULONG *     pMaxMessageSize;
         ULONG *     pMaxOutConnections;
         ULONG *     pMaxOutConnectionsPerDomain;
         ULONG *     pMaxProcesses;
         ULONG *     pMaxRecipients;
         ULONG *     pMaxSearchResults;
         ULONG *     pMaxSessionSize;
         ULONG *     pMaxSmtpLogonErrors;
         WCHAR *     pMD_0;
         ULONG *     pMD_1001;
         WCHAR *     pPostmasterName;
         WCHAR *     pPostmasterEmail;
         WCHAR *     pLocalDomains;
         ULONG *     pShutdownLatency;
         WCHAR *     pMD_APP_LAST_OUTPROC_PID;
         WCHAR *     pAuthChangeURL;
         WCHAR *     pAuthExpiredUnsecureURL;
         WCHAR *     pAuthExpiredURL;
         WCHAR *     pAuthNotifyPwdExpURL;
         WCHAR *     pAuthNotifyPwdExpUnsecureURL;
         ULONG *     pMD_ETAG_CHANGENUMBER;
         WCHAR *     pMD_IISADMIN_EXTENSIONS;
         ULONG *     pMD_ISM_ACCESS_CHECK;
         WCHAR *     pMD_METADATA_ID_REGISTRATION;
         ULONG *     pMD_SERVER_CAPABILITIES;
         ULONG *     pServerCommand;
         ULONG *     pMD_SERVER_PLATFORM;
         ULONG *     pMajorIIsVersionNumber;
         ULONG *     pMinorIIsVersionNumber;
         WCHAR *     pMimeMap;
         ULONG *     pMinFileBytesPerSec;
         WCHAR *     pModeratorFile;
         ULONG *     pMSDOSDirOutput;
         ULONG *     pNntpCommandLogMask;
         WCHAR *     pNewsDropDirectory;
         WCHAR *     pNewsFailedPickupDirectory;
         WCHAR *     pNewsPickupDirectory;
         ULONG *     pNntpServiceVersion;
         WCHAR *     pNntpUucpName;
         WCHAR *     pNTAuthenticationProviders;
         WCHAR *     pOrphanActionExe;
         WCHAR *     pOrphanActionParams;
         ULONG *     pOrphanWorkerProcess;
         ULONG *     pPasswordCacheTTL;
         ULONG *     pPasswordExpirePrenotifyDays;
         WCHAR *     pPath;
         ULONG *     pPeriodicRestartRequests;
         WCHAR *     pPeriodicRestartSchedule;
         ULONG *     pPeriodicRestartTime;
         ULONG *     pPeriodicRestartMemory;
         ULONG *     pPeriodicRestartPrivateMemory;
         WCHAR *     pPickupDirectory;
         ULONG *     pPingingEnabled;
         ULONG *     pPingInterval;
         ULONG *     pPingResponseTime;
         ULONG *     pPoolIdcTimeout;
         WCHAR *     pPop3ClearTextProvider;
         WCHAR *     pPop3DefaultDomain;
         WCHAR *     pPop3DsAccount;
         WCHAR *     pPop3DsBindType;
         WCHAR *     pPop3DsDataDirectory;
         WCHAR *     pPop3DsDefaultMailRoot;
         WCHAR *     pPop3DsHost;
         WCHAR *     pPop3DsNamingContext;
         WCHAR *     pPop3DsPassword;
         WCHAR *     pPop3DsSchemaType;
         ULONG *     pPop3ExpireDelay;
         ULONG *     pPop3ExpireMail;
         ULONG *     pPop3ExpireStart;
         ULONG *     pPop3MailExpirationTime;
         WCHAR *     pPop3RoutingDll;
         WCHAR *     pPop3RoutingSources;
         WCHAR *     pPop3RoutingTableType;
         ULONG *     pPop3ServiceVersion;
         WCHAR *     pPrettyNamesFile;
         WCHAR *     pNntpClearTextProvider;
         ULONG *     pProcessNTCRIfLoggedOn;
         WCHAR *     pQueueDirectory;
         ULONG *     pRapidFailProtection;
         ULONG *     pRapidFailProtectionInterval;
         ULONG *     pRapidFailProtectionMaxCrashes;
         WCHAR *     pRealm;
         WCHAR *     pRedirectHeaders;
         ULONG *     pRelayForAuth;
 unsigned char *     pRelayIpList;
         ULONG *     pRemoteRetryAttempts;
         ULONG *     pRemoteRetryInterval;
         ULONG *     pRemoteSmtpPort;
         ULONG *     pRemoteSmtpSecurePort;
         ULONG *     pRemoteTimeout;
         ULONG *     pRevocationFreshnessTime;
         ULONG *     pRevocationURLRetrievalTimeout;
         ULONG *     pRouteAction;
         WCHAR *     pRouteActionString;
         WCHAR *     pRoutePassword;
         WCHAR *     pRouteUserName;
         WCHAR *     pRoutingDll;
         WCHAR *     pRoutingSources;
         WCHAR *     pSaslLogonDomain;
         WCHAR *     pScriptMaps;
         WCHAR *     pSecureBindings;
         WCHAR *     pSendBadTo;
         WCHAR *     pSendNdrTo;
         ULONG *     pServerAutoStart;
         WCHAR *     pServerBindings;
         WCHAR *     pServerComment;
         ULONG *     pServerListenBacklog;
         ULONG *     pServerListenTimeout;
         ULONG *     pServerSize;
         ULONG *     pServerState;
 unsigned char *     pSessionKey;
         ULONG *     pShouldDeliver;
         ULONG *     pShutdownTimeLimit;
         WCHAR *     pSmartHost;
         ULONG *     pSmartHostType;
         ULONG *     pSMPAffinitized;
         ULONG *     pSMPProcessorAffinityMask;
         WCHAR *     pSmtpAdvQueueDll;
         ULONG *     pSmtpAuthTimeout;
         ULONG *     pSmtpBdatTimeout;
         WCHAR *     pSmtpClearTextProvider;
         ULONG *     pSmtpCommandLogMask;
         ULONG *     pSmtpConnectTimeout;
         ULONG *     pSmtpDataTimeout;
         WCHAR *     pSmtpDsAccount;
         WCHAR *     pSmtpDsBindType;
         WCHAR *     pSmtpDsDataDirectory;
         WCHAR *     pSmtpDsDefaultMailRoot;
         WCHAR *     pSmtpDsDomain;
         ULONG *     pSmtpDsFlags;
         WCHAR *     pSmtpDsHost;
         WCHAR *     pSmtpDsNamingContext;
         ULONG *     pSmtpDSNLanguageID;
         ULONG *     pSmtpDSNOptions;
         WCHAR *     pSmtpDsPassword;
         ULONG *     pSmtpDsPort;
         WCHAR *     pSmtpDsSchemaType;
         ULONG *     pSmtpDsUseCat;
         ULONG *     pSmtpFlushMailFile;
         ULONG *     pSmtpHeloTimeout;
         ULONG *     pSmtpInboundCommandSupportOptions;
         ULONG *     pSmtpLocalDelayExpireMinutes;
         ULONG *     pSmtpLocalNDRExpireMinutes;
         ULONG *     pSmtpMailFromTimeout;
         ULONG *     pSmtpOutboundCommandSupportOptions;
         ULONG *     pSmtpRcptToTimeout;
         ULONG *     pSmtpRemoteDelayExpireMinutes;
         ULONG *     pSmtpRemoteNDRExpireMinutes;
         WCHAR *     pSmtpRemoteProgressiveRetry;
         ULONG *     pSmtpRemoteRetryThreshold;
         WCHAR *     pSmtpRoutingTableType;
         ULONG *     pSmtpRsetTimeout;
         ULONG *     pSmtpSaslTimeout;
         WCHAR *     pSmtpServer;
         ULONG *     pSmtpServiceVersion;
         ULONG *     pSmtpTurnTimeout;
         ULONG *     pSmtpIpRestrictionFlag;
         ULONG *     pSSIExecDisable;
 unsigned char *     pSSLCertHash;
         WCHAR *     pSSLStoreName;
         ULONG *     pSslUseDsMapper;
         ULONG *     pSSLAlwaysNegoClientCert;
         ULONG *     pStartupTimeLimit;
         ULONG *     pAppPoolQueueLength;
         WCHAR *     pUNCPassword;
         WCHAR *     pUNCUserName;
         ULONG *     pDisableStaticFileCache;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pUseDigestSSP;
         WCHAR *     pVrDriverClsid;
         WCHAR *     pVrDriverProgid;
         WCHAR *     pFsPropertyPath;
         ULONG *     pVrUseAccount;
         ULONG *     pVrDoExpire;
         WCHAR *     pExMdbGuid;
         ULONG *     pVrOwnModerator;
         ULONG *     pArticleTimeLimit;
         ULONG *     pHistoryExpiration;
         ULONG *     pNewsCrawlerTime;
         WCHAR *     pNntpOrganization;
         ULONG *     pSmtpUseTcpDns;
         ULONG *     pSmtpDotStuffPickupDirFiles;
         ULONG *     pSmtpDomainValidationFlags;
         ULONG *     pSmtpSSLRequireTrustedCA;
         ULONG *     pSmtpSSLCertHostnameValidation;
         ULONG *     pMaxMailObjects;
         ULONG *     pShouldPickupMail;
         ULONG *     pMaxDirChangeIOSize;
         ULONG *     pNameResolutionType;
         ULONG *     pMaxSmtpErrors;
         ULONG *     pShouldPipelineIn;
         ULONG *     pShouldPipelineOut;
         WCHAR *     pConnectResponse;
         ULONG *     pUpdatedFQDN;
         ULONG *     pUpdatedDefaultDomain;
         ULONG *     pEtrnSubdomains;
         ULONG *     pSmtpMaxRemoteQThreads;
         ULONG *     pSmtpDisableRelay;
         ULONG *     pSmtpHeloNoDomain;
         ULONG *     pSmtpMailNoHelo;
         ULONG *     pSmtpAqueueWait;
         ULONG *     pAddNoHeaders;
         ULONG *     pSmtpEventlogLevel;
         WCHAR *     pFeedServerName;
         ULONG *     pFeedType;
         WCHAR *     pFeedNewsgroups;
         ULONG *     pFeedSecurityType;
         ULONG *     pFeedAuthenticationType;
         WCHAR *     pFeedAccountName;
         WCHAR *     pFeedPassword;
         ULONG *     pFeedStartTimeHigh;
         ULONG *     pFeedStartTimeLow;
         ULONG *     pFeedInterval;
         ULONG *     pFeedAllowControlMsgs;
         ULONG *     pFeedCreateAutomatically;
         ULONG *     pFeedDisabled;
         WCHAR *     pFeedDistribution;
         ULONG *     pFeedConcurrentSessions;
         ULONG *     pFeedMaxConnectionAttempts;
         WCHAR *     pFeedUucpName;
         WCHAR *     pFeedTempDirectory;
         ULONG *     pFeedNextPullHigh;
         ULONG *     pFeedNextPullLow;
         WCHAR *     pFeedPeerTempDirectory;
         ULONG *     pFeedPeerGapSize;
         ULONG *     pFeedOutgoingPort;
         ULONG *     pFeedFeedpairId;
         ULONG *     pFeedHandshake;
         ULONG *     pFeedAdminError;
         ULONG *     pFeedErrParmMask;
         ULONG *     pExpireSpace;
         ULONG *     pExpireTime;
         WCHAR *     pExpireNewsgroups;
         WCHAR *     pExpirePolicyName;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         WCHAR *     pWAMUserName;
         WCHAR *     pWAMUserPass;
         ULONG *     pWin32Error;
         WCHAR *     pXoverTableFile;
         WCHAR *     pADConnectionsUserName;
         WCHAR *     pADConnectionsPassword;
         WCHAR *     pPassivePortRange;
         WCHAR *     pIsapiRestrictionList;
         WCHAR *     pCgiRestrictionList;
         ULONG *     pLoadBalancerCapabilities;
         WCHAR *     pAutoShutdownAppPoolExe;
         WCHAR *     pAutoShutdownAppPoolParams;
         WCHAR *     pRestrictionListCustomDesc;
         WCHAR *     pApplicationDependencies;
         WCHAR *     pWebSvcExtRestrictionList;
         ULONG *     pCentralBinaryLoggingEnabled;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
         ULONG *     pAzImpersonationLevel;
         WCHAR *     pSslCtlIdentifier;
         WCHAR *     pSslCtlStoreName;
         ULONG *     pAspBufferingLimit;
         ULONG *     pMaxRequestEntityAllowed;
         ULONG *     pAspMaxRequestEntityAllowed;
         ULONG *     pDemandStartThreshold;
         ULONG *     pPassportRequireADMapping;
         ULONG *     pAspCalcLineNumber;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pAuthFlags;
         ULONG *     pAuthPersistence;
         ULONG *     pDirBrowseFlags;
         ULONG *     pFilterFlags;
         ULONG *     pLogExtFileFlags;
         ULONG *     pPasswordChangeFlags;
         ULONG *     pServerConfigFlags;
         ULONG *     pAspAppServiceFlags;
         ULONG *     pLogEventOnRecycle;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsObject                               L"IIsObject"
#define TABLEID_IIsObject                                (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsObject                            (0L)
#define ExtendedVersion_IIsObject                        (0L)

//-----------------Column Index Enums--------------   
enum eIIsObject {
    iIIsObject_Location,  
    iIIsObject_KeyType,  
    cIIsObject_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsObjectRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsComputer                             L"IIsComputer"
#define TABLEID_IIsComputer                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsComputer                          (0L)
#define ExtendedVersion_IIsComputer                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsComputer {
    iIIsComputer_Location,  
    iIIsComputer_KeyType,  
    iIIsComputer_MaxBandwidth,  
    iIIsComputer_MaxBandwidthBlocked,  
    iIIsComputer_MimeMap,  
    iIIsComputer_MD_1001,  
    iIIsComputer_EnableHistory,  
    iIIsComputer_MaxHistoryFiles,  
    iIIsComputer_EnableEditWhileRunning,  
    iIIsComputer_MaxErrorFiles,  
    iIIsComputer_AdminACL,  
    iIIsComputer_AdminACLBin,  
    cIIsComputer_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsComputerRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxBandwidthBlocked;
         WCHAR *     pMimeMap;
         ULONG *     pMD_1001;
         ULONG *     pEnableHistory;
         ULONG *     pMaxHistoryFiles;
         ULONG *     pEnableEditWhileRunning;
         ULONG *     pMaxErrorFiles;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsWebService                           L"IIsWebService"
#define TABLEID_IIsWebService                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsWebService                        (0L)
#define ExtendedVersion_IIsWebService                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsWebService {
    iIIsWebService_Location,  
    iIIsWebService_KeyType,  
    iIIsWebService_MaxBandwidth,  
    iIIsWebService_MaxConnections,  
    iIIsWebService_MimeMap,  
    iIIsWebService_AnonymousUserName,  
    iIIsWebService_AnonymousUserPass,  
    iIIsWebService_UseDigestSSP,  
    iIIsWebService_ServerListenBacklog,  
    iIIsWebService_ServerComment,  
    iIIsWebService_ServerBindings,  
    iIIsWebService_ConnectionTimeout,  
    iIIsWebService_ServerListenTimeout,  
    iIIsWebService_MaxEndpointConnections,  
    iIIsWebService_ServerAutoStart,  
    iIIsWebService_AllowKeepAlive,  
    iIIsWebService_ServerSize,  
    iIIsWebService_DisableSocketPooling,  
    iIIsWebService_AnonymousPasswordSync,  
    iIIsWebService_DefaultLogonDomain,  
    iIIsWebService_AdminACL,  
    iIIsWebService_AdminACLBin,  
    iIIsWebService_IPSecurity,  
    iIIsWebService_DontLog,  
    iIIsWebService_Realm,  
    iIIsWebService_DefaultDoc,  
    iIIsWebService_HttpExpires,  
    iIIsWebService_HttpPics,  
    iIIsWebService_HttpCustomHeaders,  
    iIIsWebService_HttpErrors,  
    iIIsWebService_EnableDocFooter,  
    iIIsWebService_DefaultDocFooter,  
    iIIsWebService_LogonMethod,  
    iIIsWebService_CacheISAPI,  
    iIIsWebService_CGITimeout,  
    iIIsWebService_DirectoryLevelsToScan,  
    iIIsWebService_ContentIndexed,  
    iIIsWebService_NTAuthenticationProviders,  
    iIIsWebService_CertCheckMode,  
    iIIsWebService_DownlevelAdminInstance,  
    iIIsWebService_AspBufferingOn,  
    iIIsWebService_AspLogErrorRequests,  
    iIIsWebService_AspScriptErrorSentToBrowser,  
    iIIsWebService_AspScriptErrorMessage,  
    iIIsWebService_AspAllowOutOfProcComponents,  
    iIIsWebService_AspScriptFileCacheSize,  
    iIIsWebService_AspDiskTemplateCacheDirectory,  
    iIIsWebService_AspMaxDiskTemplateCacheFiles,  
    iIIsWebService_AspScriptEngineCacheMax,  
    iIIsWebService_AspScriptTimeout,  
    iIIsWebService_AspSessionTimeout,  
    iIIsWebService_AspEnableParentPaths,  
    iIIsWebService_AspAllowSessionState,  
    iIIsWebService_AspScriptLanguage,  
    iIIsWebService_AspExceptionCatchEnable,  
    iIIsWebService_AspCodepage,  
    iIIsWebService_AspLCID,  
    iIIsWebService_AspQueueTimeout,  
    iIIsWebService_AspEnableAspHtmlFallback,  
    iIIsWebService_AspEnableChunkedEncoding,  
    iIIsWebService_AspEnableTypelibCache,  
    iIIsWebService_AspErrorsToNTLog,  
    iIIsWebService_AspProcessorThreadMax,  
    iIIsWebService_AspTrackThreadingModel,  
    iIIsWebService_AspRequestQueueMax,  
    iIIsWebService_AspEnableApplicationRestart,  
    iIIsWebService_AspQueueConnectionTestTime,  
    iIIsWebService_AspSessionMax,  
    iIIsWebService_AppRoot,  
    iIIsWebService_AppFriendlyName,  
    iIIsWebService_AppIsolated,  
    iIIsWebService_AppPackageID,  
    iIIsWebService_AppPackageName,  
    iIIsWebService_AppAllowDebugging,  
    iIIsWebService_AppAllowClientDebug,  
    iIIsWebService_CacheControlMaxAge,  
    iIIsWebService_CacheControlNoCache,  
    iIIsWebService_CacheControlCustom,  
    iIIsWebService_CreateProcessAsUser,  
    iIIsWebService_PoolIdcTimeout,  
    iIIsWebService_RedirectHeaders,  
    iIIsWebService_UploadReadAheadSize,  
    iIIsWebService_PasswordExpirePrenotifyDays,  
    iIIsWebService_PasswordCacheTTL,  
    iIIsWebService_PasswordChangeFlags,  
    iIIsWebService_AppWamClsid,  
    iIIsWebService_DirBrowseFlags,  
    iIIsWebService_AuthFlags,  
    iIIsWebService_AuthPersistence,  
    iIIsWebService_AccessFlags,  
    iIIsWebService_AccessSSLFlags,  
    iIIsWebService_DisableStaticFileCache,  
    iIIsWebService_ScriptMaps,  
    iIIsWebService_SSIExecDisable,  
    iIIsWebService_EnableReverseDns,  
    iIIsWebService_CreateCGIWithNewConsole,  
    iIIsWebService_ProcessNTCRIfLoggedOn,  
    iIIsWebService_AllowPathInfoForScriptMappings,  
    iIIsWebService_InProcessIsapiApps,  
    iIIsWebService_LogType,  
    iIIsWebService_LogFilePeriod,  
    iIIsWebService_LogFileLocaltimeRollover,  
    iIIsWebService_LogPluginClsid,  
    iIIsWebService_LogModuleList,  
    iIIsWebService_LogFileDirectory,  
    iIIsWebService_LogFileTruncateSize,  
    iIIsWebService_LogExtFileFlags,  
    iIIsWebService_LogOdbcDataSource,  
    iIIsWebService_LogOdbcTableName,  
    iIIsWebService_LogOdbcUserName,  
    iIIsWebService_LogOdbcPassword,  
    iIIsWebService_SslUseDsMapper,  
    iIIsWebService_SSLAlwaysNegoClientCert,  
    iIIsWebService_WAMUserName,  
    iIIsWebService_WAMUserPass,  
    iIIsWebService_ShutdownTimeLimit,  
    iIIsWebService_SSLCertHash,  
    iIIsWebService_SSLStoreName,  
    iIIsWebService_AuthChangeURL,  
    iIIsWebService_AuthExpiredURL,  
    iIIsWebService_AuthNotifyPwdExpURL,  
    iIIsWebService_AuthExpiredUnsecureURL,  
    iIIsWebService_AuthNotifyPwdExpUnsecureURL,  
    iIIsWebService_MD_APP_LAST_OUTPROC_PID,  
    iIIsWebService_MD_ETAG_CHANGENUMBER,  
    iIIsWebService_AdminServer,  
    iIIsWebService_AppPoolId,  
    iIIsWebService_DoStaticCompression,  
    iIIsWebService_DoDynamicCompression,  
    iIIsWebService_IIs5IsolationModeEnabled,  
    iIIsWebService_MaxGlobalBandwidth,  
    iIIsWebService_MinFileBytesPerSec,  
    iIIsWebService_HeaderWaitTimeout,  
    iIIsWebService_LogInUTF8,  
    iIIsWebService_RapidFailProtectionInterval,  
    iIIsWebService_RapidFailProtectionMaxCrashes,  
    iIIsWebService_AspPartitionID,  
    iIIsWebService_AspSxsName,  
    iIIsWebService_AspAppServiceFlags,  
    iIIsWebService_AspKeepSessionIDSecure,  
    iIIsWebService_RevocationFreshnessTime,  
    iIIsWebService_RevocationURLRetrievalTimeout,  
    iIIsWebService_AspExecuteInMTA,  
    iIIsWebService_CentralBinaryLoggingEnabled,  
    iIIsWebService_AspRunOnEndAnonymously,  
    iIIsWebService_AspBufferingLimit,  
    iIIsWebService_AzEnable,  
    iIIsWebService_AzStoreName,  
    iIIsWebService_AzScopeName,  
    iIIsWebService_AzImpersonationLevel,  
    iIIsWebService_AspCalcLineNumber,  
    iIIsWebService_ApplicationDependencies,  
    iIIsWebService_WebSvcExtRestrictionList,  
    iIIsWebService_AspMaxRequestEntityAllowed,  
    iIIsWebService_MaxRequestEntityAllowed,  
    iIIsWebService_DemandStartThreshold,  
    iIIsWebService_PassportRequireADMapping,  
    cIIsWebService_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsWebServiceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pMimeMap;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pUseDigestSSP;
         ULONG *     pServerListenBacklog;
         WCHAR *     pServerComment;
         WCHAR *     pServerBindings;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         ULONG *     pAllowKeepAlive;
         ULONG *     pServerSize;
         ULONG *     pDisableSocketPooling;
         ULONG *     pAnonymousPasswordSync;
         WCHAR *     pDefaultLogonDomain;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         WCHAR *     pRealm;
         WCHAR *     pDefaultDoc;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         ULONG *     pEnableDocFooter;
         WCHAR *     pDefaultDocFooter;
         ULONG *     pLogonMethod;
         ULONG *     pCacheISAPI;
         ULONG *     pCGITimeout;
         ULONG *     pDirectoryLevelsToScan;
         ULONG *     pContentIndexed;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pCertCheckMode;
         ULONG *     pDownlevelAdminInstance;
         ULONG *     pAspBufferingOn;
         ULONG *     pAspLogErrorRequests;
         ULONG *     pAspScriptErrorSentToBrowser;
         WCHAR *     pAspScriptErrorMessage;
         ULONG *     pAspAllowOutOfProcComponents;
         ULONG *     pAspScriptFileCacheSize;
         WCHAR *     pAspDiskTemplateCacheDirectory;
         ULONG *     pAspMaxDiskTemplateCacheFiles;
         ULONG *     pAspScriptEngineCacheMax;
         ULONG *     pAspScriptTimeout;
         ULONG *     pAspSessionTimeout;
         ULONG *     pAspEnableParentPaths;
         ULONG *     pAspAllowSessionState;
         WCHAR *     pAspScriptLanguage;
         ULONG *     pAspExceptionCatchEnable;
         ULONG *     pAspCodepage;
         ULONG *     pAspLCID;
         ULONG *     pAspQueueTimeout;
         ULONG *     pAspEnableAspHtmlFallback;
         ULONG *     pAspEnableChunkedEncoding;
         ULONG *     pAspEnableTypelibCache;
         ULONG *     pAspErrorsToNTLog;
         ULONG *     pAspProcessorThreadMax;
         ULONG *     pAspTrackThreadingModel;
         ULONG *     pAspRequestQueueMax;
         ULONG *     pAspEnableApplicationRestart;
         ULONG *     pAspQueueConnectionTestTime;
         ULONG *     pAspSessionMax;
         WCHAR *     pAppRoot;
         WCHAR *     pAppFriendlyName;
         ULONG *     pAppIsolated;
         WCHAR *     pAppPackageID;
         WCHAR *     pAppPackageName;
         ULONG *     pAppAllowDebugging;
         ULONG *     pAppAllowClientDebug;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCreateProcessAsUser;
         ULONG *     pPoolIdcTimeout;
         WCHAR *     pRedirectHeaders;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pPasswordExpirePrenotifyDays;
         ULONG *     pPasswordCacheTTL;
         ULONG *     pPasswordChangeFlags;
         WCHAR *     pAppWamClsid;
         ULONG *     pDirBrowseFlags;
         ULONG *     pAuthFlags;
         ULONG *     pAuthPersistence;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pDisableStaticFileCache;
         WCHAR *     pScriptMaps;
         ULONG *     pSSIExecDisable;
         ULONG *     pEnableReverseDns;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pProcessNTCRIfLoggedOn;
         ULONG *     pAllowPathInfoForScriptMappings;
         WCHAR *     pInProcessIsapiApps;
         ULONG *     pLogType;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileLocaltimeRollover;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pSslUseDsMapper;
         ULONG *     pSSLAlwaysNegoClientCert;
         WCHAR *     pWAMUserName;
         WCHAR *     pWAMUserPass;
         ULONG *     pShutdownTimeLimit;
 unsigned char *     pSSLCertHash;
         WCHAR *     pSSLStoreName;
         WCHAR *     pAuthChangeURL;
         WCHAR *     pAuthExpiredURL;
         WCHAR *     pAuthNotifyPwdExpURL;
         WCHAR *     pAuthExpiredUnsecureURL;
         WCHAR *     pAuthNotifyPwdExpUnsecureURL;
         WCHAR *     pMD_APP_LAST_OUTPROC_PID;
         ULONG *     pMD_ETAG_CHANGENUMBER;
         WCHAR *     pAdminServer;
         WCHAR *     pAppPoolId;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         ULONG *     pIIs5IsolationModeEnabled;
         ULONG *     pMaxGlobalBandwidth;
         ULONG *     pMinFileBytesPerSec;
         ULONG *     pHeaderWaitTimeout;
         ULONG *     pLogInUTF8;
         ULONG *     pRapidFailProtectionInterval;
         ULONG *     pRapidFailProtectionMaxCrashes;
         WCHAR *     pAspPartitionID;
         WCHAR *     pAspSxsName;
         ULONG *     pAspAppServiceFlags;
         ULONG *     pAspKeepSessionIDSecure;
         ULONG *     pRevocationFreshnessTime;
         ULONG *     pRevocationURLRetrievalTimeout;
         ULONG *     pAspExecuteInMTA;
         ULONG *     pCentralBinaryLoggingEnabled;
         ULONG *     pAspRunOnEndAnonymously;
         ULONG *     pAspBufferingLimit;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
         ULONG *     pAzImpersonationLevel;
         ULONG *     pAspCalcLineNumber;
         WCHAR *     pApplicationDependencies;
         WCHAR *     pWebSvcExtRestrictionList;
         ULONG *     pAspMaxRequestEntityAllowed;
         ULONG *     pMaxRequestEntityAllowed;
         ULONG *     pDemandStartThreshold;
         ULONG *     pPassportRequireADMapping;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsFtpService                           L"IIsFtpService"
#define TABLEID_IIsFtpService                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsFtpService                        (0L)
#define ExtendedVersion_IIsFtpService                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsFtpService {
    iIIsFtpService_Location,  
    iIIsFtpService_KeyType,  
    iIIsFtpService_MaxConnections,  
    iIIsFtpService_AnonymousUserName,  
    iIIsFtpService_AnonymousUserPass,  
    iIIsFtpService_ServerListenBacklog,  
    iIIsFtpService_LogAnonymous,  
    iIIsFtpService_LogNonAnonymous,  
    iIIsFtpService_ServerComment,  
    iIIsFtpService_ServerBindings,  
    iIIsFtpService_ConnectionTimeout,  
    iIIsFtpService_ServerListenTimeout,  
    iIIsFtpService_MaxEndpointConnections,  
    iIIsFtpService_ServerAutoStart,  
    iIIsFtpService_ExitMessage,  
    iIIsFtpService_GreetingMessage,  
    iIIsFtpService_MaxClientsMessage,  
    iIIsFtpService_AnonymousOnly,  
    iIIsFtpService_MSDOSDirOutput,  
    iIIsFtpService_ServerSize,  
    iIIsFtpService_DisableSocketPooling,  
    iIIsFtpService_AnonymousPasswordSync,  
    iIIsFtpService_AllowAnonymous,  
    iIIsFtpService_DefaultLogonDomain,  
    iIIsFtpService_AdminACL,  
    iIIsFtpService_AdminACLBin,  
    iIIsFtpService_IPSecurity,  
    iIIsFtpService_DontLog,  
    iIIsFtpService_DirectoryLevelsToScan,  
    iIIsFtpService_Realm,  
    iIIsFtpService_LogType,  
    iIIsFtpService_LogFilePeriod,  
    iIIsFtpService_LogFileLocaltimeRollover,  
    iIIsFtpService_LogPluginClsid,  
    iIIsFtpService_LogModuleList,  
    iIIsFtpService_LogFileDirectory,  
    iIIsFtpService_LogFileTruncateSize,  
    iIIsFtpService_LogExtFileFlags,  
    iIIsFtpService_LogOdbcDataSource,  
    iIIsFtpService_LogOdbcTableName,  
    iIIsFtpService_LogOdbcUserName,  
    iIIsFtpService_LogOdbcPassword,  
    iIIsFtpService_FtpDirBrowseShowLongDate,  
    iIIsFtpService_AccessFlags,  
    iIIsFtpService_DownlevelAdminInstance,  
    iIIsFtpService_BannerMessage,  
    iIIsFtpService_UserIsolationMode,  
    iIIsFtpService_FtpLogInUtf8,  
    iIIsFtpService_ADConnectionsUserName,  
    iIIsFtpService_ADConnectionsPassword,  
    iIIsFtpService_ServerCommand,  
    iIIsFtpService_PassivePortRange,  
    cIIsFtpService_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsFtpServiceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxConnections;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pServerListenBacklog;
         ULONG *     pLogAnonymous;
         ULONG *     pLogNonAnonymous;
         WCHAR *     pServerComment;
         WCHAR *     pServerBindings;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         WCHAR *     pExitMessage;
         WCHAR *     pGreetingMessage;
         WCHAR *     pMaxClientsMessage;
         ULONG *     pAnonymousOnly;
         ULONG *     pMSDOSDirOutput;
         ULONG *     pServerSize;
         ULONG *     pDisableSocketPooling;
         ULONG *     pAnonymousPasswordSync;
         ULONG *     pAllowAnonymous;
         WCHAR *     pDefaultLogonDomain;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pDirectoryLevelsToScan;
         WCHAR *     pRealm;
         ULONG *     pLogType;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileLocaltimeRollover;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pFtpDirBrowseShowLongDate;
         ULONG *     pAccessFlags;
         ULONG *     pDownlevelAdminInstance;
         WCHAR *     pBannerMessage;
         ULONG *     pUserIsolationMode;
         ULONG *     pFtpLogInUtf8;
         WCHAR *     pADConnectionsUserName;
         WCHAR *     pADConnectionsPassword;
         ULONG *     pServerCommand;
         WCHAR *     pPassivePortRange;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsWebServer                            L"IIsWebServer"
#define TABLEID_IIsWebServer                             (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsWebServer                         (0L)
#define ExtendedVersion_IIsWebServer                     (0L)

//-----------------Column Index Enums--------------   
enum eIIsWebServer {
    iIIsWebServer_Location,  
    iIIsWebServer_ContentIndexed,  
    iIIsWebServer_KeyType,  
    iIIsWebServer_ServerState,  
    iIIsWebServer_ServerComment,  
    iIIsWebServer_MaxBandwidth,  
    iIIsWebServer_ServerAutoStart,  
    iIIsWebServer_ServerSize,  
    iIIsWebServer_DisableSocketPooling,  
    iIIsWebServer_ServerListenBacklog,  
    iIIsWebServer_ServerListenTimeout,  
    iIIsWebServer_ServerBindings,  
    iIIsWebServer_SecureBindings,  
    iIIsWebServer_MaxConnections,  
    iIIsWebServer_ConnectionTimeout,  
    iIIsWebServer_AllowKeepAlive,  
    iIIsWebServer_CGITimeout,  
    iIIsWebServer_MaxEndpointConnections,  
    iIIsWebServer_UseDigestSSP,  
    iIIsWebServer_CacheISAPI,  
    iIIsWebServer_MimeMap,  
    iIIsWebServer_AnonymousUserName,  
    iIIsWebServer_AnonymousUserPass,  
    iIIsWebServer_FrontPageWeb,  
    iIIsWebServer_AnonymousPasswordSync,  
    iIIsWebServer_DefaultLogonDomain,  
    iIIsWebServer_AdminACL,  
    iIIsWebServer_AdminACLBin,  
    iIIsWebServer_IPSecurity,  
    iIIsWebServer_DontLog,  
    iIIsWebServer_Realm,  
    iIIsWebServer_DefaultDoc,  
    iIIsWebServer_HttpExpires,  
    iIIsWebServer_HttpPics,  
    iIIsWebServer_HttpCustomHeaders,  
    iIIsWebServer_HttpErrors,  
    iIIsWebServer_EnableDocFooter,  
    iIIsWebServer_DefaultDocFooter,  
    iIIsWebServer_LogonMethod,  
    iIIsWebServer_NTAuthenticationProviders,  
    iIIsWebServer_CertCheckMode,  
    iIIsWebServer_AspBufferingOn,  
    iIIsWebServer_AspLogErrorRequests,  
    iIIsWebServer_AspScriptErrorSentToBrowser,  
    iIIsWebServer_AspScriptErrorMessage,  
    iIIsWebServer_AspAllowOutOfProcComponents,  
    iIIsWebServer_AspScriptFileCacheSize,  
    iIIsWebServer_AspDiskTemplateCacheDirectory,  
    iIIsWebServer_AspMaxDiskTemplateCacheFiles,  
    iIIsWebServer_AspScriptEngineCacheMax,  
    iIIsWebServer_AspScriptTimeout,  
    iIIsWebServer_AspEnableParentPaths,  
    iIIsWebServer_AspAllowSessionState,  
    iIIsWebServer_AspScriptLanguage,  
    iIIsWebServer_AspExceptionCatchEnable,  
    iIIsWebServer_AspCodepage,  
    iIIsWebServer_AspLCID,  
    iIIsWebServer_AspSessionTimeout,  
    iIIsWebServer_AspQueueTimeout,  
    iIIsWebServer_AspEnableAspHtmlFallback,  
    iIIsWebServer_AspEnableChunkedEncoding,  
    iIIsWebServer_AspEnableTypelibCache,  
    iIIsWebServer_AspErrorsToNTLog,  
    iIIsWebServer_AspProcessorThreadMax,  
    iIIsWebServer_AspTrackThreadingModel,  
    iIIsWebServer_AspRequestQueueMax,  
    iIIsWebServer_AspEnableApplicationRestart,  
    iIIsWebServer_AspQueueConnectionTestTime,  
    iIIsWebServer_AspSessionMax,  
    iIIsWebServer_AppRoot,  
    iIIsWebServer_AppFriendlyName,  
    iIIsWebServer_AppIsolated,  
    iIIsWebServer_AppPackageID,  
    iIIsWebServer_AppPackageName,  
    iIIsWebServer_AppOopRecoverLimit,  
    iIIsWebServer_AppAllowDebugging,  
    iIIsWebServer_AppAllowClientDebug,  
    iIIsWebServer_ClusterEnabled,  
    iIIsWebServer_CacheControlMaxAge,  
    iIIsWebServer_CacheControlNoCache,  
    iIIsWebServer_CacheControlCustom,  
    iIIsWebServer_CreateProcessAsUser,  
    iIIsWebServer_PoolIdcTimeout,  
    iIIsWebServer_RedirectHeaders,  
    iIIsWebServer_UploadReadAheadSize,  
    iIIsWebServer_PasswordExpirePrenotifyDays,  
    iIIsWebServer_PasswordCacheTTL,  
    iIIsWebServer_PasswordChangeFlags,  
    iIIsWebServer_MaxBandwidthBlocked,  
    iIIsWebServer_AppWamClsid,  
    iIIsWebServer_DirBrowseFlags,  
    iIIsWebServer_AuthFlags,  
    iIIsWebServer_AuthPersistence,  
    iIIsWebServer_AccessFlags,  
    iIIsWebServer_AccessSSLFlags,  
    iIIsWebServer_DisableStaticFileCache,  
    iIIsWebServer_ScriptMaps,  
    iIIsWebServer_SSIExecDisable,  
    iIIsWebServer_EnableReverseDns,  
    iIIsWebServer_CreateCGIWithNewConsole,  
    iIIsWebServer_LogType,  
    iIIsWebServer_LogPluginClsid,  
    iIIsWebServer_LogFileDirectory,  
    iIIsWebServer_LogFilePeriod,  
    iIIsWebServer_LogFileLocaltimeRollover,  
    iIIsWebServer_LogFileTruncateSize,  
    iIIsWebServer_LogExtFileFlags,  
    iIIsWebServer_LogOdbcDataSource,  
    iIIsWebServer_LogOdbcTableName,  
    iIIsWebServer_LogOdbcUserName,  
    iIIsWebServer_LogOdbcPassword,  
    iIIsWebServer_ShutdownTimeLimit,  
    iIIsWebServer_SSLCertHash,  
    iIIsWebServer_SSLStoreName,  
    iIIsWebServer_SSLAlwaysNegoClientCert,  
    iIIsWebServer_ProcessNTCRIfLoggedOn,  
    iIIsWebServer_AllowPathInfoForScriptMappings,  
    iIIsWebServer_ServerCommand,  
    iIIsWebServer_MD_ISM_ACCESS_CHECK,  
    iIIsWebServer_Win32Error,  
    iIIsWebServer_AppPoolId,  
    iIIsWebServer_DoStaticCompression,  
    iIIsWebServer_DoDynamicCompression,  
    iIIsWebServer_AspPartitionID,  
    iIIsWebServer_AspSxsName,  
    iIIsWebServer_AspAppServiceFlags,  
    iIIsWebServer_AspKeepSessionIDSecure,  
    iIIsWebServer_RevocationFreshnessTime,  
    iIIsWebServer_RevocationURLRetrievalTimeout,  
    iIIsWebServer_AspExecuteInMTA,  
    iIIsWebServer_AspRunOnEndAnonymously,  
    iIIsWebServer_AspBufferingLimit,  
    iIIsWebServer_AzEnable,  
    iIIsWebServer_AzStoreName,  
    iIIsWebServer_AzScopeName,  
    iIIsWebServer_AzImpersonationLevel,  
    iIIsWebServer_AspCalcLineNumber,  
    iIIsWebServer_AspMaxRequestEntityAllowed,  
    iIIsWebServer_MaxRequestEntityAllowed,  
    iIIsWebServer_SslCtlIdentifier,  
    iIIsWebServer_SslCtlStoreName,  
    iIIsWebServer_PassportRequireADMapping,  
    cIIsWebServer_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsWebServerRow {
         WCHAR *     pLocation;
         ULONG *     pContentIndexed;
         WCHAR *     pKeyType;
         ULONG *     pServerState;
         WCHAR *     pServerComment;
         ULONG *     pMaxBandwidth;
         ULONG *     pServerAutoStart;
         ULONG *     pServerSize;
         ULONG *     pDisableSocketPooling;
         ULONG *     pServerListenBacklog;
         ULONG *     pServerListenTimeout;
         WCHAR *     pServerBindings;
         WCHAR *     pSecureBindings;
         ULONG *     pMaxConnections;
         ULONG *     pConnectionTimeout;
         ULONG *     pAllowKeepAlive;
         ULONG *     pCGITimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pUseDigestSSP;
         ULONG *     pCacheISAPI;
         WCHAR *     pMimeMap;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pFrontPageWeb;
         ULONG *     pAnonymousPasswordSync;
         WCHAR *     pDefaultLogonDomain;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         WCHAR *     pRealm;
         WCHAR *     pDefaultDoc;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         ULONG *     pEnableDocFooter;
         WCHAR *     pDefaultDocFooter;
         ULONG *     pLogonMethod;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pCertCheckMode;
         ULONG *     pAspBufferingOn;
         ULONG *     pAspLogErrorRequests;
         ULONG *     pAspScriptErrorSentToBrowser;
         WCHAR *     pAspScriptErrorMessage;
         ULONG *     pAspAllowOutOfProcComponents;
         ULONG *     pAspScriptFileCacheSize;
         WCHAR *     pAspDiskTemplateCacheDirectory;
         ULONG *     pAspMaxDiskTemplateCacheFiles;
         ULONG *     pAspScriptEngineCacheMax;
         ULONG *     pAspScriptTimeout;
         ULONG *     pAspEnableParentPaths;
         ULONG *     pAspAllowSessionState;
         WCHAR *     pAspScriptLanguage;
         ULONG *     pAspExceptionCatchEnable;
         ULONG *     pAspCodepage;
         ULONG *     pAspLCID;
         ULONG *     pAspSessionTimeout;
         ULONG *     pAspQueueTimeout;
         ULONG *     pAspEnableAspHtmlFallback;
         ULONG *     pAspEnableChunkedEncoding;
         ULONG *     pAspEnableTypelibCache;
         ULONG *     pAspErrorsToNTLog;
         ULONG *     pAspProcessorThreadMax;
         ULONG *     pAspTrackThreadingModel;
         ULONG *     pAspRequestQueueMax;
         ULONG *     pAspEnableApplicationRestart;
         ULONG *     pAspQueueConnectionTestTime;
         ULONG *     pAspSessionMax;
         WCHAR *     pAppRoot;
         WCHAR *     pAppFriendlyName;
         ULONG *     pAppIsolated;
         WCHAR *     pAppPackageID;
         WCHAR *     pAppPackageName;
         ULONG *     pAppOopRecoverLimit;
         ULONG *     pAppAllowDebugging;
         ULONG *     pAppAllowClientDebug;
         ULONG *     pClusterEnabled;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCreateProcessAsUser;
         ULONG *     pPoolIdcTimeout;
         WCHAR *     pRedirectHeaders;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pPasswordExpirePrenotifyDays;
         ULONG *     pPasswordCacheTTL;
         ULONG *     pPasswordChangeFlags;
         ULONG *     pMaxBandwidthBlocked;
         WCHAR *     pAppWamClsid;
         ULONG *     pDirBrowseFlags;
         ULONG *     pAuthFlags;
         ULONG *     pAuthPersistence;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pDisableStaticFileCache;
         WCHAR *     pScriptMaps;
         ULONG *     pSSIExecDisable;
         ULONG *     pEnableReverseDns;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pLogType;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileLocaltimeRollover;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pShutdownTimeLimit;
 unsigned char *     pSSLCertHash;
         WCHAR *     pSSLStoreName;
         ULONG *     pSSLAlwaysNegoClientCert;
         ULONG *     pProcessNTCRIfLoggedOn;
         ULONG *     pAllowPathInfoForScriptMappings;
         ULONG *     pServerCommand;
         ULONG *     pMD_ISM_ACCESS_CHECK;
         ULONG *     pWin32Error;
         WCHAR *     pAppPoolId;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         WCHAR *     pAspPartitionID;
         WCHAR *     pAspSxsName;
         ULONG *     pAspAppServiceFlags;
         ULONG *     pAspKeepSessionIDSecure;
         ULONG *     pRevocationFreshnessTime;
         ULONG *     pRevocationURLRetrievalTimeout;
         ULONG *     pAspExecuteInMTA;
         ULONG *     pAspRunOnEndAnonymously;
         ULONG *     pAspBufferingLimit;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
         ULONG *     pAzImpersonationLevel;
         ULONG *     pAspCalcLineNumber;
         ULONG *     pAspMaxRequestEntityAllowed;
         ULONG *     pMaxRequestEntityAllowed;
         WCHAR *     pSslCtlIdentifier;
         WCHAR *     pSslCtlStoreName;
         ULONG *     pPassportRequireADMapping;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsFtpServer                            L"IIsFtpServer"
#define TABLEID_IIsFtpServer                             (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsFtpServer                         (0L)
#define ExtendedVersion_IIsFtpServer                     (0L)

//-----------------Column Index Enums--------------   
enum eIIsFtpServer {
    iIIsFtpServer_Location,  
    iIIsFtpServer_KeyType,  
    iIIsFtpServer_MaxConnections,  
    iIIsFtpServer_ServerState,  
    iIIsFtpServer_AnonymousUserName,  
    iIIsFtpServer_AnonymousUserPass,  
    iIIsFtpServer_ServerListenBacklog,  
    iIIsFtpServer_DisableSocketPooling,  
    iIIsFtpServer_LogAnonymous,  
    iIIsFtpServer_LogNonAnonymous,  
    iIIsFtpServer_ServerComment,  
    iIIsFtpServer_ServerBindings,  
    iIIsFtpServer_ConnectionTimeout,  
    iIIsFtpServer_ServerListenTimeout,  
    iIIsFtpServer_MaxEndpointConnections,  
    iIIsFtpServer_ServerAutoStart,  
    iIIsFtpServer_ExitMessage,  
    iIIsFtpServer_GreetingMessage,  
    iIIsFtpServer_MaxClientsMessage,  
    iIIsFtpServer_AnonymousOnly,  
    iIIsFtpServer_MSDOSDirOutput,  
    iIIsFtpServer_ServerSize,  
    iIIsFtpServer_AnonymousPasswordSync,  
    iIIsFtpServer_AllowAnonymous,  
    iIIsFtpServer_DefaultLogonDomain,  
    iIIsFtpServer_AdminACL,  
    iIIsFtpServer_AdminACLBin,  
    iIIsFtpServer_IPSecurity,  
    iIIsFtpServer_DontLog,  
    iIIsFtpServer_Realm,  
    iIIsFtpServer_ClusterEnabled,  
    iIIsFtpServer_LogType,  
    iIIsFtpServer_LogPluginClsid,  
    iIIsFtpServer_LogFileDirectory,  
    iIIsFtpServer_LogFilePeriod,  
    iIIsFtpServer_LogFileLocaltimeRollover,  
    iIIsFtpServer_LogFileTruncateSize,  
    iIIsFtpServer_LogExtFileFlags,  
    iIIsFtpServer_LogOdbcDataSource,  
    iIIsFtpServer_LogOdbcTableName,  
    iIIsFtpServer_LogOdbcUserName,  
    iIIsFtpServer_LogOdbcPassword,  
    iIIsFtpServer_AccessFlags,  
    iIIsFtpServer_Win32Error,  
    iIIsFtpServer_FtpDirBrowseShowLongDate,  
    iIIsFtpServer_BannerMessage,  
    iIIsFtpServer_UserIsolationMode,  
    iIIsFtpServer_FtpLogInUtf8,  
    iIIsFtpServer_ADConnectionsUserName,  
    iIIsFtpServer_ADConnectionsPassword,  
    iIIsFtpServer_ServerCommand,  
    cIIsFtpServer_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsFtpServerRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxConnections;
         ULONG *     pServerState;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pServerListenBacklog;
         ULONG *     pDisableSocketPooling;
         ULONG *     pLogAnonymous;
         ULONG *     pLogNonAnonymous;
         WCHAR *     pServerComment;
         WCHAR *     pServerBindings;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         WCHAR *     pExitMessage;
         WCHAR *     pGreetingMessage;
         WCHAR *     pMaxClientsMessage;
         ULONG *     pAnonymousOnly;
         ULONG *     pMSDOSDirOutput;
         ULONG *     pServerSize;
         ULONG *     pAnonymousPasswordSync;
         ULONG *     pAllowAnonymous;
         WCHAR *     pDefaultLogonDomain;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         WCHAR *     pRealm;
         ULONG *     pClusterEnabled;
         ULONG *     pLogType;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileLocaltimeRollover;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pAccessFlags;
         ULONG *     pWin32Error;
         ULONG *     pFtpDirBrowseShowLongDate;
         WCHAR *     pBannerMessage;
         ULONG *     pUserIsolationMode;
         ULONG *     pFtpLogInUtf8;
         WCHAR *     pADConnectionsUserName;
         WCHAR *     pADConnectionsPassword;
         ULONG *     pServerCommand;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsWebFile                              L"IIsWebFile"
#define TABLEID_IIsWebFile                               (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsWebFile                           (0L)
#define ExtendedVersion_IIsWebFile                       (0L)

//-----------------Column Index Enums--------------   
enum eIIsWebFile {
    iIIsWebFile_Location,  
    iIIsWebFile_KeyType,  
    iIIsWebFile_AnonymousUserName,  
    iIIsWebFile_AnonymousUserPass,  
    iIIsWebFile_AnonymousPasswordSync,  
    iIIsWebFile_UseDigestSSP,  
    iIIsWebFile_CGITimeout,  
    iIIsWebFile_DefaultLogonDomain,  
    iIIsWebFile_LogonMethod,  
    iIIsWebFile_Realm,  
    iIIsWebFile_MimeMap,  
    iIIsWebFile_IPSecurity,  
    iIIsWebFile_DontLog,  
    iIIsWebFile_HttpExpires,  
    iIIsWebFile_HttpPics,  
    iIIsWebFile_HttpCustomHeaders,  
    iIIsWebFile_HttpErrors,  
    iIIsWebFile_EnableDocFooter,  
    iIIsWebFile_DefaultDocFooter,  
    iIIsWebFile_HttpRedirect,  
    iIIsWebFile_CacheControlMaxAge,  
    iIIsWebFile_CacheControlNoCache,  
    iIIsWebFile_CacheControlCustom,  
    iIIsWebFile_CreateProcessAsUser,  
    iIIsWebFile_PoolIdcTimeout,  
    iIIsWebFile_RedirectHeaders,  
    iIIsWebFile_UploadReadAheadSize,  
    iIIsWebFile_AuthFlags,  
    iIIsWebFile_AuthPersistence,  
    iIIsWebFile_AccessFlags,  
    iIIsWebFile_AccessSSLFlags,  
    iIIsWebFile_DisableStaticFileCache,  
    iIIsWebFile_ScriptMaps,  
    iIIsWebFile_SSIExecDisable,  
    iIIsWebFile_EnableReverseDns,  
    iIIsWebFile_CreateCGIWithNewConsole,  
    iIIsWebFile_DoStaticCompression,  
    iIIsWebFile_DoDynamicCompression,  
    iIIsWebFile_AzEnable,  
    iIIsWebFile_AzStoreName,  
    iIIsWebFile_AzScopeName,  
    iIIsWebFile_AzImpersonationLevel,  
    iIIsWebFile_AdminACL,  
    iIIsWebFile_AdminACLBin,  
    iIIsWebFile_MaxRequestEntityAllowed,  
    iIIsWebFile_PassportRequireADMapping,  
    iIIsWebFile_NTAuthenticationProviders,  
    cIIsWebFile_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsWebFileRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pAnonymousPasswordSync;
         ULONG *     pUseDigestSSP;
         ULONG *     pCGITimeout;
         WCHAR *     pDefaultLogonDomain;
         ULONG *     pLogonMethod;
         WCHAR *     pRealm;
         WCHAR *     pMimeMap;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         ULONG *     pEnableDocFooter;
         WCHAR *     pDefaultDocFooter;
         WCHAR *     pHttpRedirect;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCreateProcessAsUser;
         ULONG *     pPoolIdcTimeout;
         WCHAR *     pRedirectHeaders;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pAuthFlags;
         ULONG *     pAuthPersistence;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pDisableStaticFileCache;
         WCHAR *     pScriptMaps;
         ULONG *     pSSIExecDisable;
         ULONG *     pEnableReverseDns;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
         ULONG *     pAzImpersonationLevel;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
         ULONG *     pMaxRequestEntityAllowed;
         ULONG *     pPassportRequireADMapping;
         WCHAR *     pNTAuthenticationProviders;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsWebDirectory                         L"IIsWebDirectory"
#define TABLEID_IIsWebDirectory                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsWebDirectory                      (0L)
#define ExtendedVersion_IIsWebDirectory                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsWebDirectory {
    iIIsWebDirectory_Location,  
    iIIsWebDirectory_KeyType,  
    iIIsWebDirectory_AnonymousUserName,  
    iIIsWebDirectory_AnonymousUserPass,  
    iIIsWebDirectory_AnonymousPasswordSync,  
    iIIsWebDirectory_UseDigestSSP,  
    iIIsWebDirectory_AppRoot,  
    iIIsWebDirectory_AppFriendlyName,  
    iIIsWebDirectory_AppOopRecoverLimit,  
    iIIsWebDirectory_AppIsolated,  
    iIIsWebDirectory_AppPackageName,  
    iIIsWebDirectory_AppPackageID,  
    iIIsWebDirectory_CacheISAPI,  
    iIIsWebDirectory_AppAllowDebugging,  
    iIIsWebDirectory_AppAllowClientDebug,  
    iIIsWebDirectory_DefaultLogonDomain,  
    iIIsWebDirectory_LogonMethod,  
    iIIsWebDirectory_CGITimeout,  
    iIIsWebDirectory_Realm,  
    iIIsWebDirectory_IPSecurity,  
    iIIsWebDirectory_DontLog,  
    iIIsWebDirectory_HttpExpires,  
    iIIsWebDirectory_HttpPics,  
    iIIsWebDirectory_HttpCustomHeaders,  
    iIIsWebDirectory_HttpErrors,  
    iIIsWebDirectory_EnableDocFooter,  
    iIIsWebDirectory_DefaultDocFooter,  
    iIIsWebDirectory_HttpRedirect,  
    iIIsWebDirectory_DefaultDoc,  
    iIIsWebDirectory_ContentIndexed,  
    iIIsWebDirectory_CacheControlMaxAge,  
    iIIsWebDirectory_CacheControlNoCache,  
    iIIsWebDirectory_CacheControlCustom,  
    iIIsWebDirectory_CreateProcessAsUser,  
    iIIsWebDirectory_PoolIdcTimeout,  
    iIIsWebDirectory_RedirectHeaders,  
    iIIsWebDirectory_UploadReadAheadSize,  
    iIIsWebDirectory_FrontPageWeb,  
    iIIsWebDirectory_AppWamClsid,  
    iIIsWebDirectory_AuthPersistence,  
    iIIsWebDirectory_AccessFlags,  
    iIIsWebDirectory_AccessSSLFlags,  
    iIIsWebDirectory_DisableStaticFileCache,  
    iIIsWebDirectory_ScriptMaps,  
    iIIsWebDirectory_SSIExecDisable,  
    iIIsWebDirectory_EnableReverseDns,  
    iIIsWebDirectory_CreateCGIWithNewConsole,  
    iIIsWebDirectory_AspBufferingOn,  
    iIIsWebDirectory_AspLogErrorRequests,  
    iIIsWebDirectory_AspScriptErrorSentToBrowser,  
    iIIsWebDirectory_AspScriptErrorMessage,  
    iIIsWebDirectory_AspAllowOutOfProcComponents,  
    iIIsWebDirectory_AspScriptFileCacheSize,  
    iIIsWebDirectory_AspDiskTemplateCacheDirectory,  
    iIIsWebDirectory_AspMaxDiskTemplateCacheFiles,  
    iIIsWebDirectory_AspScriptEngineCacheMax,  
    iIIsWebDirectory_AspScriptTimeout,  
    iIIsWebDirectory_AspSessionTimeout,  
    iIIsWebDirectory_AspEnableParentPaths,  
    iIIsWebDirectory_AspAllowSessionState,  
    iIIsWebDirectory_AspScriptLanguage,  
    iIIsWebDirectory_AspExceptionCatchEnable,  
    iIIsWebDirectory_AspCodepage,  
    iIIsWebDirectory_AspLCID,  
    iIIsWebDirectory_MimeMap,  
    iIIsWebDirectory_AspQueueTimeout,  
    iIIsWebDirectory_AspEnableAspHtmlFallback,  
    iIIsWebDirectory_AspEnableChunkedEncoding,  
    iIIsWebDirectory_AspEnableTypelibCache,  
    iIIsWebDirectory_AspErrorsToNTLog,  
    iIIsWebDirectory_AspProcessorThreadMax,  
    iIIsWebDirectory_AspTrackThreadingModel,  
    iIIsWebDirectory_AspRequestQueueMax,  
    iIIsWebDirectory_AspEnableApplicationRestart,  
    iIIsWebDirectory_AspQueueConnectionTestTime,  
    iIIsWebDirectory_AspSessionMax,  
    iIIsWebDirectory_ShutdownTimeLimit,  
    iIIsWebDirectory_DirBrowseFlags,  
    iIIsWebDirectory_AuthFlags,  
    iIIsWebDirectory_AppPoolId,  
    iIIsWebDirectory_DoStaticCompression,  
    iIIsWebDirectory_DoDynamicCompression,  
    iIIsWebDirectory_AspPartitionID,  
    iIIsWebDirectory_AspSxsName,  
    iIIsWebDirectory_AspAppServiceFlags,  
    iIIsWebDirectory_AspKeepSessionIDSecure,  
    iIIsWebDirectory_AspExecuteInMTA,  
    iIIsWebDirectory_AspRunOnEndAnonymously,  
    iIIsWebDirectory_AspBufferingLimit,  
    iIIsWebDirectory_AzEnable,  
    iIIsWebDirectory_AzStoreName,  
    iIIsWebDirectory_AzScopeName,  
    iIIsWebDirectory_AzImpersonationLevel,  
    iIIsWebDirectory_AspCalcLineNumber,  
    iIIsWebDirectory_AdminACL,  
    iIIsWebDirectory_AdminACLBin,  
    iIIsWebDirectory_AspMaxRequestEntityAllowed,  
    iIIsWebDirectory_MaxRequestEntityAllowed,  
    iIIsWebDirectory_PassportRequireADMapping,  
    iIIsWebDirectory_NTAuthenticationProviders,  
    cIIsWebDirectory_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsWebDirectoryRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pAnonymousPasswordSync;
         ULONG *     pUseDigestSSP;
         WCHAR *     pAppRoot;
         WCHAR *     pAppFriendlyName;
         ULONG *     pAppOopRecoverLimit;
         ULONG *     pAppIsolated;
         WCHAR *     pAppPackageName;
         WCHAR *     pAppPackageID;
         ULONG *     pCacheISAPI;
         ULONG *     pAppAllowDebugging;
         ULONG *     pAppAllowClientDebug;
         WCHAR *     pDefaultLogonDomain;
         ULONG *     pLogonMethod;
         ULONG *     pCGITimeout;
         WCHAR *     pRealm;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         ULONG *     pEnableDocFooter;
         WCHAR *     pDefaultDocFooter;
         WCHAR *     pHttpRedirect;
         WCHAR *     pDefaultDoc;
         ULONG *     pContentIndexed;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCreateProcessAsUser;
         ULONG *     pPoolIdcTimeout;
         WCHAR *     pRedirectHeaders;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pFrontPageWeb;
         WCHAR *     pAppWamClsid;
         ULONG *     pAuthPersistence;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pDisableStaticFileCache;
         WCHAR *     pScriptMaps;
         ULONG *     pSSIExecDisable;
         ULONG *     pEnableReverseDns;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pAspBufferingOn;
         ULONG *     pAspLogErrorRequests;
         ULONG *     pAspScriptErrorSentToBrowser;
         WCHAR *     pAspScriptErrorMessage;
         ULONG *     pAspAllowOutOfProcComponents;
         ULONG *     pAspScriptFileCacheSize;
         WCHAR *     pAspDiskTemplateCacheDirectory;
         ULONG *     pAspMaxDiskTemplateCacheFiles;
         ULONG *     pAspScriptEngineCacheMax;
         ULONG *     pAspScriptTimeout;
         ULONG *     pAspSessionTimeout;
         ULONG *     pAspEnableParentPaths;
         ULONG *     pAspAllowSessionState;
         WCHAR *     pAspScriptLanguage;
         ULONG *     pAspExceptionCatchEnable;
         ULONG *     pAspCodepage;
         ULONG *     pAspLCID;
         WCHAR *     pMimeMap;
         ULONG *     pAspQueueTimeout;
         ULONG *     pAspEnableAspHtmlFallback;
         ULONG *     pAspEnableChunkedEncoding;
         ULONG *     pAspEnableTypelibCache;
         ULONG *     pAspErrorsToNTLog;
         ULONG *     pAspProcessorThreadMax;
         ULONG *     pAspTrackThreadingModel;
         ULONG *     pAspRequestQueueMax;
         ULONG *     pAspEnableApplicationRestart;
         ULONG *     pAspQueueConnectionTestTime;
         ULONG *     pAspSessionMax;
         ULONG *     pShutdownTimeLimit;
         ULONG *     pDirBrowseFlags;
         ULONG *     pAuthFlags;
         WCHAR *     pAppPoolId;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         WCHAR *     pAspPartitionID;
         WCHAR *     pAspSxsName;
         ULONG *     pAspAppServiceFlags;
         ULONG *     pAspKeepSessionIDSecure;
         ULONG *     pAspExecuteInMTA;
         ULONG *     pAspRunOnEndAnonymously;
         ULONG *     pAspBufferingLimit;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
         ULONG *     pAzImpersonationLevel;
         ULONG *     pAspCalcLineNumber;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
         ULONG *     pAspMaxRequestEntityAllowed;
         ULONG *     pMaxRequestEntityAllowed;
         ULONG *     pPassportRequireADMapping;
         WCHAR *     pNTAuthenticationProviders;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsWebVirtualDir                        L"IIsWebVirtualDir"
#define TABLEID_IIsWebVirtualDir                         (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsWebVirtualDir                     (0L)
#define ExtendedVersion_IIsWebVirtualDir                 (0L)

//-----------------Column Index Enums--------------   
enum eIIsWebVirtualDir {
    iIIsWebVirtualDir_Location,  
    iIIsWebVirtualDir_KeyType,  
    iIIsWebVirtualDir_AnonymousUserName,  
    iIIsWebVirtualDir_AnonymousUserPass,  
    iIIsWebVirtualDir_AnonymousPasswordSync,  
    iIIsWebVirtualDir_UseDigestSSP,  
    iIIsWebVirtualDir_AppRoot,  
    iIIsWebVirtualDir_AppFriendlyName,  
    iIIsWebVirtualDir_AppOopRecoverLimit,  
    iIIsWebVirtualDir_AppIsolated,  
    iIIsWebVirtualDir_AppPackageName,  
    iIIsWebVirtualDir_AppPackageID,  
    iIIsWebVirtualDir_CacheISAPI,  
    iIIsWebVirtualDir_AppAllowDebugging,  
    iIIsWebVirtualDir_AppAllowClientDebug,  
    iIIsWebVirtualDir_DefaultLogonDomain,  
    iIIsWebVirtualDir_LogonMethod,  
    iIIsWebVirtualDir_CGITimeout,  
    iIIsWebVirtualDir_Realm,  
    iIIsWebVirtualDir_IPSecurity,  
    iIIsWebVirtualDir_DontLog,  
    iIIsWebVirtualDir_HttpExpires,  
    iIIsWebVirtualDir_HttpPics,  
    iIIsWebVirtualDir_HttpCustomHeaders,  
    iIIsWebVirtualDir_HttpErrors,  
    iIIsWebVirtualDir_EnableDocFooter,  
    iIIsWebVirtualDir_DefaultDocFooter,  
    iIIsWebVirtualDir_HttpRedirect,  
    iIIsWebVirtualDir_DefaultDoc,  
    iIIsWebVirtualDir_ContentIndexed,  
    iIIsWebVirtualDir_CacheControlMaxAge,  
    iIIsWebVirtualDir_CacheControlNoCache,  
    iIIsWebVirtualDir_CacheControlCustom,  
    iIIsWebVirtualDir_CreateProcessAsUser,  
    iIIsWebVirtualDir_PoolIdcTimeout,  
    iIIsWebVirtualDir_RedirectHeaders,  
    iIIsWebVirtualDir_UploadReadAheadSize,  
    iIIsWebVirtualDir_FrontPageWeb,  
    iIIsWebVirtualDir_Path,  
    iIIsWebVirtualDir_UNCUserName,  
    iIIsWebVirtualDir_UNCPassword,  
    iIIsWebVirtualDir_DisableStaticFileCache,  
    iIIsWebVirtualDir_AppWamClsid,  
    iIIsWebVirtualDir_AuthPersistence,  
    iIIsWebVirtualDir_AccessFlags,  
    iIIsWebVirtualDir_AccessSSLFlags,  
    iIIsWebVirtualDir_ScriptMaps,  
    iIIsWebVirtualDir_SSIExecDisable,  
    iIIsWebVirtualDir_EnableReverseDns,  
    iIIsWebVirtualDir_CreateCGIWithNewConsole,  
    iIIsWebVirtualDir_AspBufferingOn,  
    iIIsWebVirtualDir_AspLogErrorRequests,  
    iIIsWebVirtualDir_AspScriptErrorSentToBrowser,  
    iIIsWebVirtualDir_AspScriptErrorMessage,  
    iIIsWebVirtualDir_AspAllowOutOfProcComponents,  
    iIIsWebVirtualDir_AspScriptFileCacheSize,  
    iIIsWebVirtualDir_AspDiskTemplateCacheDirectory,  
    iIIsWebVirtualDir_AspMaxDiskTemplateCacheFiles,  
    iIIsWebVirtualDir_AspScriptEngineCacheMax,  
    iIIsWebVirtualDir_AspScriptTimeout,  
    iIIsWebVirtualDir_AspSessionTimeout,  
    iIIsWebVirtualDir_AspEnableParentPaths,  
    iIIsWebVirtualDir_AspAllowSessionState,  
    iIIsWebVirtualDir_AspScriptLanguage,  
    iIIsWebVirtualDir_AspExceptionCatchEnable,  
    iIIsWebVirtualDir_AspCodepage,  
    iIIsWebVirtualDir_AspLCID,  
    iIIsWebVirtualDir_MimeMap,  
    iIIsWebVirtualDir_AspQueueTimeout,  
    iIIsWebVirtualDir_AspEnableAspHtmlFallback,  
    iIIsWebVirtualDir_AspEnableChunkedEncoding,  
    iIIsWebVirtualDir_AspEnableTypelibCache,  
    iIIsWebVirtualDir_AspErrorsToNTLog,  
    iIIsWebVirtualDir_AspProcessorThreadMax,  
    iIIsWebVirtualDir_AspTrackThreadingModel,  
    iIIsWebVirtualDir_AspRequestQueueMax,  
    iIIsWebVirtualDir_AspEnableApplicationRestart,  
    iIIsWebVirtualDir_AspQueueConnectionTestTime,  
    iIIsWebVirtualDir_AspSessionMax,  
    iIIsWebVirtualDir_ShutdownTimeLimit,  
    iIIsWebVirtualDir_DirBrowseFlags,  
    iIIsWebVirtualDir_AuthFlags,  
    iIIsWebVirtualDir_Win32Error,  
    iIIsWebVirtualDir_AppPoolId,  
    iIIsWebVirtualDir_DoStaticCompression,  
    iIIsWebVirtualDir_DoDynamicCompression,  
    iIIsWebVirtualDir_AspPartitionID,  
    iIIsWebVirtualDir_AspSxsName,  
    iIIsWebVirtualDir_AspAppServiceFlags,  
    iIIsWebVirtualDir_AspKeepSessionIDSecure,  
    iIIsWebVirtualDir_AspExecuteInMTA,  
    iIIsWebVirtualDir_AspRunOnEndAnonymously,  
    iIIsWebVirtualDir_AspBufferingLimit,  
    iIIsWebVirtualDir_AzEnable,  
    iIIsWebVirtualDir_AzStoreName,  
    iIIsWebVirtualDir_AzScopeName,  
    iIIsWebVirtualDir_AzImpersonationLevel,  
    iIIsWebVirtualDir_AspCalcLineNumber,  
    iIIsWebVirtualDir_AdminACL,  
    iIIsWebVirtualDir_AdminACLBin,  
    iIIsWebVirtualDir_AspMaxRequestEntityAllowed,  
    iIIsWebVirtualDir_MaxRequestEntityAllowed,  
    iIIsWebVirtualDir_PassportRequireADMapping,  
    iIIsWebVirtualDir_NTAuthenticationProviders,  
    cIIsWebVirtualDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsWebVirtualDirRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pAnonymousPasswordSync;
         ULONG *     pUseDigestSSP;
         WCHAR *     pAppRoot;
         WCHAR *     pAppFriendlyName;
         ULONG *     pAppOopRecoverLimit;
         ULONG *     pAppIsolated;
         WCHAR *     pAppPackageName;
         WCHAR *     pAppPackageID;
         ULONG *     pCacheISAPI;
         ULONG *     pAppAllowDebugging;
         ULONG *     pAppAllowClientDebug;
         WCHAR *     pDefaultLogonDomain;
         ULONG *     pLogonMethod;
         ULONG *     pCGITimeout;
         WCHAR *     pRealm;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         ULONG *     pEnableDocFooter;
         WCHAR *     pDefaultDocFooter;
         WCHAR *     pHttpRedirect;
         WCHAR *     pDefaultDoc;
         ULONG *     pContentIndexed;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCreateProcessAsUser;
         ULONG *     pPoolIdcTimeout;
         WCHAR *     pRedirectHeaders;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pFrontPageWeb;
         WCHAR *     pPath;
         WCHAR *     pUNCUserName;
         WCHAR *     pUNCPassword;
         ULONG *     pDisableStaticFileCache;
         WCHAR *     pAppWamClsid;
         ULONG *     pAuthPersistence;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         WCHAR *     pScriptMaps;
         ULONG *     pSSIExecDisable;
         ULONG *     pEnableReverseDns;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pAspBufferingOn;
         ULONG *     pAspLogErrorRequests;
         ULONG *     pAspScriptErrorSentToBrowser;
         WCHAR *     pAspScriptErrorMessage;
         ULONG *     pAspAllowOutOfProcComponents;
         ULONG *     pAspScriptFileCacheSize;
         WCHAR *     pAspDiskTemplateCacheDirectory;
         ULONG *     pAspMaxDiskTemplateCacheFiles;
         ULONG *     pAspScriptEngineCacheMax;
         ULONG *     pAspScriptTimeout;
         ULONG *     pAspSessionTimeout;
         ULONG *     pAspEnableParentPaths;
         ULONG *     pAspAllowSessionState;
         WCHAR *     pAspScriptLanguage;
         ULONG *     pAspExceptionCatchEnable;
         ULONG *     pAspCodepage;
         ULONG *     pAspLCID;
         WCHAR *     pMimeMap;
         ULONG *     pAspQueueTimeout;
         ULONG *     pAspEnableAspHtmlFallback;
         ULONG *     pAspEnableChunkedEncoding;
         ULONG *     pAspEnableTypelibCache;
         ULONG *     pAspErrorsToNTLog;
         ULONG *     pAspProcessorThreadMax;
         ULONG *     pAspTrackThreadingModel;
         ULONG *     pAspRequestQueueMax;
         ULONG *     pAspEnableApplicationRestart;
         ULONG *     pAspQueueConnectionTestTime;
         ULONG *     pAspSessionMax;
         ULONG *     pShutdownTimeLimit;
         ULONG *     pDirBrowseFlags;
         ULONG *     pAuthFlags;
         ULONG *     pWin32Error;
         WCHAR *     pAppPoolId;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         WCHAR *     pAspPartitionID;
         WCHAR *     pAspSxsName;
         ULONG *     pAspAppServiceFlags;
         ULONG *     pAspKeepSessionIDSecure;
         ULONG *     pAspExecuteInMTA;
         ULONG *     pAspRunOnEndAnonymously;
         ULONG *     pAspBufferingLimit;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
         ULONG *     pAzImpersonationLevel;
         ULONG *     pAspCalcLineNumber;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
         ULONG *     pAspMaxRequestEntityAllowed;
         ULONG *     pMaxRequestEntityAllowed;
         ULONG *     pPassportRequireADMapping;
         WCHAR *     pNTAuthenticationProviders;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsFtpVirtualDir                        L"IIsFtpVirtualDir"
#define TABLEID_IIsFtpVirtualDir                         (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsFtpVirtualDir                     (0L)
#define ExtendedVersion_IIsFtpVirtualDir                 (0L)

//-----------------Column Index Enums--------------   
enum eIIsFtpVirtualDir {
    iIIsFtpVirtualDir_Location,  
    iIIsFtpVirtualDir_KeyType,  
    iIIsFtpVirtualDir_Path,  
    iIIsFtpVirtualDir_UNCUserName,  
    iIIsFtpVirtualDir_UNCPassword,  
    iIIsFtpVirtualDir_AccessFlags,  
    iIIsFtpVirtualDir_DontLog,  
    iIIsFtpVirtualDir_IPSecurity,  
    iIIsFtpVirtualDir_FtpDirBrowseShowLongDate,  
    iIIsFtpVirtualDir_Win32Error,  
    iIIsFtpVirtualDir_AdminACL,  
    iIIsFtpVirtualDir_AdminACLBin,  
    cIIsFtpVirtualDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsFtpVirtualDirRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pPath;
         WCHAR *     pUNCUserName;
         WCHAR *     pUNCPassword;
         ULONG *     pAccessFlags;
         ULONG *     pDontLog;
 unsigned char *     pIPSecurity;
         ULONG *     pFtpDirBrowseShowLongDate;
         ULONG *     pWin32Error;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsFilter                               L"IIsFilter"
#define TABLEID_IIsFilter                                (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsFilter                            (0L)
#define ExtendedVersion_IIsFilter                        (0L)

//-----------------Column Index Enums--------------   
enum eIIsFilter {
    iIIsFilter_Location,  
    iIIsFilter_KeyType,  
    iIIsFilter_FilterPath,  
    iIIsFilter_FilterDescription,  
    iIIsFilter_FilterFlags,  
    iIIsFilter_FilterState,  
    iIIsFilter_FilterEnabled,  
    iIIsFilter_FilterEnableCache,  
    iIIsFilter_Win32Error,  
    iIIsFilter_AdminACL,  
    iIIsFilter_AdminACLBin,  
    cIIsFilter_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsFilterRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pFilterPath;
         WCHAR *     pFilterDescription;
         ULONG *     pFilterFlags;
         ULONG *     pFilterState;
         ULONG *     pFilterEnabled;
         ULONG *     pFilterEnableCache;
         ULONG *     pWin32Error;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsFilters                              L"IIsFilters"
#define TABLEID_IIsFilters                               (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsFilters                           (0L)
#define ExtendedVersion_IIsFilters                       (0L)

//-----------------Column Index Enums--------------   
enum eIIsFilters {
    iIIsFilters_Location,  
    iIIsFilters_KeyType,  
    iIIsFilters_FilterLoadOrder,  
    iIIsFilters_AdminACL,  
    iIIsFilters_AdminACLBin,  
    cIIsFilters_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsFiltersRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pFilterLoadOrder;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsCompressionScheme                    L"IIsCompressionScheme"
#define TABLEID_IIsCompressionScheme                     (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsCompressionScheme                 (0L)
#define ExtendedVersion_IIsCompressionScheme             (0L)

//-----------------Column Index Enums--------------   
enum eIIsCompressionScheme {
    iIIsCompressionScheme_Location,  
    iIIsCompressionScheme_KeyType,  
    iIIsCompressionScheme_HcDoDynamicCompression,  
    iIIsCompressionScheme_HcDoStaticCompression,  
    iIIsCompressionScheme_HcDoOnDemandCompression,  
    iIIsCompressionScheme_HcCompressionDll,  
    iIIsCompressionScheme_HcFileExtensions,  
    iIIsCompressionScheme_HcScriptFileExtensions,  
    iIIsCompressionScheme_HcPriority,  
    iIIsCompressionScheme_HcDynamicCompressionLevel,  
    iIIsCompressionScheme_HcOnDemandCompLevel,  
    iIIsCompressionScheme_HcCreateFlags,  
    iIIsCompressionScheme_AdminACL,  
    iIIsCompressionScheme_AdminACLBin,  
    cIIsCompressionScheme_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsCompressionSchemeRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pHcDoDynamicCompression;
         ULONG *     pHcDoStaticCompression;
         ULONG *     pHcDoOnDemandCompression;
         WCHAR *     pHcCompressionDll;
         WCHAR *     pHcFileExtensions;
         WCHAR *     pHcScriptFileExtensions;
         ULONG *     pHcPriority;
         ULONG *     pHcDynamicCompressionLevel;
         ULONG *     pHcOnDemandCompLevel;
         ULONG *     pHcCreateFlags;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsCompressionSchemes                   L"IIsCompressionSchemes"
#define TABLEID_IIsCompressionSchemes                    (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsCompressionSchemes                (0L)
#define ExtendedVersion_IIsCompressionSchemes            (0L)

//-----------------Column Index Enums--------------   
enum eIIsCompressionSchemes {
    iIIsCompressionSchemes_Location,  
    iIIsCompressionSchemes_KeyType,  
    iIIsCompressionSchemes_HcCompressionDirectory,  
    iIIsCompressionSchemes_HcCacheControlHeader,  
    iIIsCompressionSchemes_HcExpiresHeader,  
    iIIsCompressionSchemes_HcDoDynamicCompression,  
    iIIsCompressionSchemes_HcDoStaticCompression,  
    iIIsCompressionSchemes_HcDoOnDemandCompression,  
    iIIsCompressionSchemes_HcDoDiskSpaceLimiting,  
    iIIsCompressionSchemes_HcNoCompressionForHttp10,  
    iIIsCompressionSchemes_HcNoCompressionForProxies,  
    iIIsCompressionSchemes_HcNoCompressionForRange,  
    iIIsCompressionSchemes_HcSendCacheHeaders,  
    iIIsCompressionSchemes_HcMaxDiskSpaceUsage,  
    iIIsCompressionSchemes_HcIoBufferSize,  
    iIIsCompressionSchemes_HcCompressionBufferSize,  
    iIIsCompressionSchemes_HcMaxQueueLength,  
    iIIsCompressionSchemes_HcFilesDeletedPerDiskFree,  
    iIIsCompressionSchemes_HcMinFileSizeForComp,  
    iIIsCompressionSchemes_AdminACL,  
    iIIsCompressionSchemes_AdminACLBin,  
    cIIsCompressionSchemes_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsCompressionSchemesRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pHcCompressionDirectory;
         WCHAR *     pHcCacheControlHeader;
         WCHAR *     pHcExpiresHeader;
         ULONG *     pHcDoDynamicCompression;
         ULONG *     pHcDoStaticCompression;
         ULONG *     pHcDoOnDemandCompression;
         ULONG *     pHcDoDiskSpaceLimiting;
         ULONG *     pHcNoCompressionForHttp10;
         ULONG *     pHcNoCompressionForProxies;
         ULONG *     pHcNoCompressionForRange;
         ULONG *     pHcSendCacheHeaders;
         ULONG *     pHcMaxDiskSpaceUsage;
         ULONG *     pHcIoBufferSize;
         ULONG *     pHcCompressionBufferSize;
         ULONG *     pHcMaxQueueLength;
         ULONG *     pHcFilesDeletedPerDiskFree;
         ULONG *     pHcMinFileSizeForComp;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsCertMapper                           L"IIsCertMapper"
#define TABLEID_IIsCertMapper                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsCertMapper                        (0L)
#define ExtendedVersion_IIsCertMapper                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsCertMapper {
    iIIsCertMapper_Location,  
    iIIsCertMapper_KeyType,  
    iIIsCertMapper_AdminACL,  
    iIIsCertMapper_AdminACLBin,  
    cIIsCertMapper_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsCertMapperRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsMimeMap                              L"IIsMimeMap"
#define TABLEID_IIsMimeMap                               (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsMimeMap                           (0L)
#define ExtendedVersion_IIsMimeMap                       (0L)

//-----------------Column Index Enums--------------   
enum eIIsMimeMap {
    iIIsMimeMap_Location,  
    iIIsMimeMap_KeyType,  
    iIIsMimeMap_MimeMap,  
    iIIsMimeMap_AdminACL,  
    iIIsMimeMap_AdminACLBin,  
    cIIsMimeMap_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsMimeMapRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pMimeMap;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsLogModules                           L"IIsLogModules"
#define TABLEID_IIsLogModules                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsLogModules                        (0L)
#define ExtendedVersion_IIsLogModules                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsLogModules {
    iIIsLogModules_Location,  
    iIIsLogModules_KeyType,  
    iIIsLogModules_AdminACL,  
    iIIsLogModules_AdminACLBin,  
    cIIsLogModules_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsLogModulesRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsLogModule                            L"IIsLogModule"
#define TABLEID_IIsLogModule                             (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsLogModule                         (0L)
#define ExtendedVersion_IIsLogModule                     (0L)

//-----------------Column Index Enums--------------   
enum eIIsLogModule {
    iIIsLogModule_Location,  
    iIIsLogModule_KeyType,  
    iIIsLogModule_LogModuleId,  
    iIIsLogModule_LogModuleUiId,  
    iIIsLogModule_AdminACL,  
    iIIsLogModule_AdminACLBin,  
    cIIsLogModule_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsLogModuleRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pLogModuleId;
         WCHAR *     pLogModuleUiId;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsCustomLogModule                      L"IIsCustomLogModule"
#define TABLEID_IIsCustomLogModule                       (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsCustomLogModule                   (0L)
#define ExtendedVersion_IIsCustomLogModule               (0L)

//-----------------Column Index Enums--------------   
enum eIIsCustomLogModule {
    iIIsCustomLogModule_Location,  
    iIIsCustomLogModule_KeyType,  
    iIIsCustomLogModule_LogCustomPropertyName,  
    iIIsCustomLogModule_LogCustomPropertyHeader,  
    iIIsCustomLogModule_LogCustomPropertyID,  
    iIIsCustomLogModule_LogCustomPropertyMask,  
    iIIsCustomLogModule_LogCustomPropertyDataType,  
    iIIsCustomLogModule_LogCustomPropertyServicesString,  
    iIIsCustomLogModule_LogCustomPropertyNodeID,  
    iIIsCustomLogModule_AdminACL,  
    iIIsCustomLogModule_AdminACLBin,  
    cIIsCustomLogModule_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsCustomLogModuleRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pLogCustomPropertyName;
         WCHAR *     pLogCustomPropertyHeader;
         ULONG *     pLogCustomPropertyID;
         ULONG *     pLogCustomPropertyMask;
         ULONG *     pLogCustomPropertyDataType;
         WCHAR *     pLogCustomPropertyServicesString;
         ULONG *     pLogCustomPropertyNodeID;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsWebInfo                              L"IIsWebInfo"
#define TABLEID_IIsWebInfo                               (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsWebInfo                           (0L)
#define ExtendedVersion_IIsWebInfo                       (0L)

//-----------------Column Index Enums--------------   
enum eIIsWebInfo {
    iIIsWebInfo_Location,  
    iIIsWebInfo_KeyType,  
    iIIsWebInfo_ServerConfigFlags,  
    iIIsWebInfo_CustomErrorDescriptions,  
    iIIsWebInfo_AdminServer,  
    iIIsWebInfo_LogModuleList,  
    iIIsWebInfo_MajorIIsVersionNumber,  
    iIIsWebInfo_MinorIIsVersionNumber,  
    iIIsWebInfo_MD_SERVER_CAPABILITIES,  
    iIIsWebInfo_AdminACL,  
    iIIsWebInfo_AdminACLBin,  
    iIIsWebInfo_MD_SERVER_PLATFORM,  
    cIIsWebInfo_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsWebInfoRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pServerConfigFlags;
         WCHAR *     pCustomErrorDescriptions;
         WCHAR *     pAdminServer;
         WCHAR *     pLogModuleList;
         ULONG *     pMajorIIsVersionNumber;
         ULONG *     pMinorIIsVersionNumber;
         ULONG *     pMD_SERVER_CAPABILITIES;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
         ULONG *     pMD_SERVER_PLATFORM;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsFtpInfo                              L"IIsFtpInfo"
#define TABLEID_IIsFtpInfo                               (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsFtpInfo                           (0L)
#define ExtendedVersion_IIsFtpInfo                       (0L)

//-----------------Column Index Enums--------------   
enum eIIsFtpInfo {
    iIIsFtpInfo_Location,  
    iIIsFtpInfo_AdminACL,  
    iIIsFtpInfo_AdminACLBin,  
    iIIsFtpInfo_KeyType,  
    iIIsFtpInfo_LogModuleList,  
    iIIsFtpInfo_MD_SERVER_PLATFORM,  
    iIIsFtpInfo_MajorIIsVersionNumber,  
    iIIsFtpInfo_MinorIIsVersionNumber,  
    iIIsFtpInfo_MD_SERVER_CAPABILITIES,  
    cIIsFtpInfo_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsFtpInfoRow {
         WCHAR *     pLocation;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
         WCHAR *     pKeyType;
         WCHAR *     pLogModuleList;
         ULONG *     pMD_SERVER_PLATFORM;
         ULONG *     pMajorIIsVersionNumber;
         ULONG *     pMinorIIsVersionNumber;
         ULONG *     pMD_SERVER_CAPABILITIES;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpService                          L"IIsNntpService"
#define TABLEID_IIsNntpService                           (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpService                       (0L)
#define ExtendedVersion_IIsNntpService                   (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpService {
    iIIsNntpService_Location,  
    iIIsNntpService_KeyType,  
    iIIsNntpService_MaxBandwidth,  
    iIIsNntpService_MaxConnections,  
    iIIsNntpService_AnonymousUserName,  
    iIIsNntpService_AnonymousUserPass,  
    iIIsNntpService_AllowAnonymous,  
    iIIsNntpService_DirectoryLevelsToScan,  
    iIIsNntpService_ServerComment,  
    iIIsNntpService_ConnectionTimeout,  
    iIIsNntpService_ServerListenTimeout,  
    iIIsNntpService_MaxEndpointConnections,  
    iIIsNntpService_ServerAutoStart,  
    iIIsNntpService_AnonymousPasswordSync,  
    iIIsNntpService_AdminACL,  
    iIIsNntpService_AdminACLBin,  
    iIIsNntpService_IPSecurity,  
    iIIsNntpService_DontLog,  
    iIIsNntpService_ContentIndexed,  
    iIIsNntpService_AuthFlags,  
    iIIsNntpService_ServerListenBacklog,  
    iIIsNntpService_HonorClientMsgIds,  
    iIIsNntpService_SmtpServer,  
    iIIsNntpService_AdminEmail,  
    iIIsNntpService_AdminName,  
    iIIsNntpService_AllowClientPosts,  
    iIIsNntpService_AllowFeedPosts,  
    iIIsNntpService_AllowControlMsgs,  
    iIIsNntpService_DefaultModeratorDomain,  
    iIIsNntpService_NntpCommandLogMask,  
    iIIsNntpService_DisableNewNews,  
    iIIsNntpService_ClientPostHardLimit,  
    iIIsNntpService_ClientPostSoftLimit,  
    iIIsNntpService_FeedPostHardLimit,  
    iIIsNntpService_FeedPostSoftLimit,  
    iIIsNntpService_LogType,  
    iIIsNntpService_LogFilePeriod,  
    iIIsNntpService_LogPluginClsid,  
    iIIsNntpService_LogModuleList,  
    iIIsNntpService_LogFileDirectory,  
    iIIsNntpService_LogFileTruncateSize,  
    iIIsNntpService_LogExtFileFlags,  
    iIIsNntpService_LogOdbcDataSource,  
    iIIsNntpService_LogOdbcTableName,  
    iIIsNntpService_LogOdbcUserName,  
    iIIsNntpService_LogOdbcPassword,  
    iIIsNntpService_FeedReportPeriod,  
    iIIsNntpService_MaxSearchResults,  
    iIIsNntpService_NntpServiceVersion,  
    iIIsNntpService_AccessSSLFlags,  
    iIIsNntpService_AccessFlags,  
    iIIsNntpService_ShutdownLatency,  
    iIIsNntpService_ArticleTimeLimit,  
    iIIsNntpService_HistoryExpiration,  
    iIIsNntpService_NewsCrawlerTime,  
    iIIsNntpService_GroupVarListFile,  
    iIIsNntpService_NTAuthenticationProviders,  
    iIIsNntpService_AzEnable,  
    iIIsNntpService_AzStoreName,  
    iIIsNntpService_AzScopeName,  
    cIIsNntpService_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpServiceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pAllowAnonymous;
         ULONG *     pDirectoryLevelsToScan;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         ULONG *     pAnonymousPasswordSync;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pContentIndexed;
         ULONG *     pAuthFlags;
         ULONG *     pServerListenBacklog;
         ULONG *     pHonorClientMsgIds;
         WCHAR *     pSmtpServer;
         WCHAR *     pAdminEmail;
         WCHAR *     pAdminName;
         ULONG *     pAllowClientPosts;
         ULONG *     pAllowFeedPosts;
         ULONG *     pAllowControlMsgs;
         WCHAR *     pDefaultModeratorDomain;
         ULONG *     pNntpCommandLogMask;
         ULONG *     pDisableNewNews;
         ULONG *     pClientPostHardLimit;
         ULONG *     pClientPostSoftLimit;
         ULONG *     pFeedPostHardLimit;
         ULONG *     pFeedPostSoftLimit;
         ULONG *     pLogType;
         ULONG *     pLogFilePeriod;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pFeedReportPeriod;
         ULONG *     pMaxSearchResults;
         ULONG *     pNntpServiceVersion;
         ULONG *     pAccessSSLFlags;
         ULONG *     pAccessFlags;
         ULONG *     pShutdownLatency;
         ULONG *     pArticleTimeLimit;
         ULONG *     pHistoryExpiration;
         ULONG *     pNewsCrawlerTime;
         WCHAR *     pGroupVarListFile;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpServer                           L"IIsNntpServer"
#define TABLEID_IIsNntpServer                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpServer                        (0L)
#define ExtendedVersion_IIsNntpServer                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpServer {
    iIIsNntpServer_Location,  
    iIIsNntpServer_KeyType,  
    iIIsNntpServer_MaxBandwidth,  
    iIIsNntpServer_MaxConnections,  
    iIIsNntpServer_AnonymousUserName,  
    iIIsNntpServer_AnonymousUserPass,  
    iIIsNntpServer_ServerComment,  
    iIIsNntpServer_ConnectionTimeout,  
    iIIsNntpServer_ServerListenTimeout,  
    iIIsNntpServer_MaxEndpointConnections,  
    iIIsNntpServer_ServerAutoStart,  
    iIIsNntpServer_ServerBindings,  
    iIIsNntpServer_SecureBindings,  
    iIIsNntpServer_ClusterEnabled,  
    iIIsNntpServer_AnonymousPasswordSync,  
    iIIsNntpServer_AdminACL,  
    iIIsNntpServer_AdminACLBin,  
    iIIsNntpServer_IPSecurity,  
    iIIsNntpServer_DontLog,  
    iIIsNntpServer_ContentIndexed,  
    iIIsNntpServer_AuthFlags,  
    iIIsNntpServer_ServerListenBacklog,  
    iIIsNntpServer_Win32Error,  
    iIIsNntpServer_ServerState,  
    iIIsNntpServer_HonorClientMsgIds,  
    iIIsNntpServer_SmtpServer,  
    iIIsNntpServer_AdminEmail,  
    iIIsNntpServer_AdminName,  
    iIIsNntpServer_AllowClientPosts,  
    iIIsNntpServer_AllowFeedPosts,  
    iIIsNntpServer_AllowControlMsgs,  
    iIIsNntpServer_DefaultModeratorDomain,  
    iIIsNntpServer_NntpCommandLogMask,  
    iIIsNntpServer_DisableNewNews,  
    iIIsNntpServer_ClientPostHardLimit,  
    iIIsNntpServer_ClientPostSoftLimit,  
    iIIsNntpServer_FeedPostHardLimit,  
    iIIsNntpServer_FeedPostSoftLimit,  
    iIIsNntpServer_NewsPickupDirectory,  
    iIIsNntpServer_NewsFailedPickupDirectory,  
    iIIsNntpServer_NewsDropDirectory,  
    iIIsNntpServer_LogType,  
    iIIsNntpServer_LogPluginClsid,  
    iIIsNntpServer_LogFileDirectory,  
    iIIsNntpServer_LogFilePeriod,  
    iIIsNntpServer_LogFileTruncateSize,  
    iIIsNntpServer_LogExtFileFlags,  
    iIIsNntpServer_LogOdbcDataSource,  
    iIIsNntpServer_LogOdbcTableName,  
    iIIsNntpServer_LogOdbcUserName,  
    iIIsNntpServer_LogOdbcPassword,  
    iIIsNntpServer_FeedReportPeriod,  
    iIIsNntpServer_MaxSearchResults,  
    iIIsNntpServer_NntpUucpName,  
    iIIsNntpServer_NntpServiceVersion,  
    iIIsNntpServer_AccessSSLFlags,  
    iIIsNntpServer_AccessFlags,  
    iIIsNntpServer_GroupHelpFile,  
    iIIsNntpServer_GroupListFile,  
    iIIsNntpServer_ArticleTableFile,  
    iIIsNntpServer_HistoryTableFile,  
    iIIsNntpServer_ListFile,  
    iIIsNntpServer_ModeratorFile,  
    iIIsNntpServer_XoverTableFile,  
    iIIsNntpServer_PrettyNamesFile,  
    iIIsNntpServer_GroupVarListFile,  
    iIIsNntpServer_SSLCertHash,  
    iIIsNntpServer_ArticleTimeLimit,  
    iIIsNntpServer_HistoryExpiration,  
    iIIsNntpServer_NewsCrawlerTime,  
    iIIsNntpServer_ShutdownLatency,  
    iIIsNntpServer_NntpOrganization,  
    iIIsNntpServer_NntpClearTextProvider,  
    iIIsNntpServer_NTAuthenticationProviders,  
    iIIsNntpServer_AzEnable,  
    iIIsNntpServer_AzStoreName,  
    iIIsNntpServer_AzScopeName,  
    cIIsNntpServer_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpServerRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         WCHAR *     pServerBindings;
         WCHAR *     pSecureBindings;
         ULONG *     pClusterEnabled;
         ULONG *     pAnonymousPasswordSync;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pContentIndexed;
         ULONG *     pAuthFlags;
         ULONG *     pServerListenBacklog;
         ULONG *     pWin32Error;
         ULONG *     pServerState;
         ULONG *     pHonorClientMsgIds;
         WCHAR *     pSmtpServer;
         WCHAR *     pAdminEmail;
         WCHAR *     pAdminName;
         ULONG *     pAllowClientPosts;
         ULONG *     pAllowFeedPosts;
         ULONG *     pAllowControlMsgs;
         WCHAR *     pDefaultModeratorDomain;
         ULONG *     pNntpCommandLogMask;
         ULONG *     pDisableNewNews;
         ULONG *     pClientPostHardLimit;
         ULONG *     pClientPostSoftLimit;
         ULONG *     pFeedPostHardLimit;
         ULONG *     pFeedPostSoftLimit;
         WCHAR *     pNewsPickupDirectory;
         WCHAR *     pNewsFailedPickupDirectory;
         WCHAR *     pNewsDropDirectory;
         ULONG *     pLogType;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pFeedReportPeriod;
         ULONG *     pMaxSearchResults;
         WCHAR *     pNntpUucpName;
         ULONG *     pNntpServiceVersion;
         ULONG *     pAccessSSLFlags;
         ULONG *     pAccessFlags;
         WCHAR *     pGroupHelpFile;
         WCHAR *     pGroupListFile;
         WCHAR *     pArticleTableFile;
         WCHAR *     pHistoryTableFile;
         WCHAR *     pListFile;
         WCHAR *     pModeratorFile;
         WCHAR *     pXoverTableFile;
         WCHAR *     pPrettyNamesFile;
         WCHAR *     pGroupVarListFile;
 unsigned char *     pSSLCertHash;
         ULONG *     pArticleTimeLimit;
         ULONG *     pHistoryExpiration;
         ULONG *     pNewsCrawlerTime;
         ULONG *     pShutdownLatency;
         WCHAR *     pNntpOrganization;
         WCHAR *     pNntpClearTextProvider;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpVirtualDir                       L"IIsNntpVirtualDir"
#define TABLEID_IIsNntpVirtualDir                        (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpVirtualDir                    (0L)
#define ExtendedVersion_IIsNntpVirtualDir                (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpVirtualDir {
    iIIsNntpVirtualDir_Location,  
    iIIsNntpVirtualDir_KeyType,  
    iIIsNntpVirtualDir_Path,  
    iIIsNntpVirtualDir_UNCUserName,  
    iIIsNntpVirtualDir_UNCPassword,  
    iIIsNntpVirtualDir_Win32Error,  
    iIIsNntpVirtualDir_ContentIndexed,  
    iIIsNntpVirtualDir_AccessSSLFlags,  
    iIIsNntpVirtualDir_AccessFlags,  
    iIIsNntpVirtualDir_VrDoExpire,  
    iIIsNntpVirtualDir_VrUseAccount,  
    iIIsNntpVirtualDir_VrOwnModerator,  
    iIIsNntpVirtualDir_VrDriverProgid,  
    iIIsNntpVirtualDir_FsPropertyPath,  
    iIIsNntpVirtualDir_ExMdbGuid,  
    iIIsNntpVirtualDir_DontLog,  
    iIIsNntpVirtualDir_VrDriverClsid,  
    iIIsNntpVirtualDir_AdminACL,  
    iIIsNntpVirtualDir_AdminACLBin,  
    cIIsNntpVirtualDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpVirtualDirRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pPath;
         WCHAR *     pUNCUserName;
         WCHAR *     pUNCPassword;
         ULONG *     pWin32Error;
         ULONG *     pContentIndexed;
         ULONG *     pAccessSSLFlags;
         ULONG *     pAccessFlags;
         ULONG *     pVrDoExpire;
         ULONG *     pVrUseAccount;
         ULONG *     pVrOwnModerator;
         WCHAR *     pVrDriverProgid;
         WCHAR *     pFsPropertyPath;
         WCHAR *     pExMdbGuid;
         ULONG *     pDontLog;
         WCHAR *     pVrDriverClsid;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpInfo                             L"IIsNntpInfo"
#define TABLEID_IIsNntpInfo                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpInfo                          (0L)
#define ExtendedVersion_IIsNntpInfo                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpInfo {
    iIIsNntpInfo_Location,  
    iIIsNntpInfo_KeyType,  
    iIIsNntpInfo_LogModuleList,  
    iIIsNntpInfo_MD_SERVER_PLATFORM,  
    iIIsNntpInfo_MajorIIsVersionNumber,  
    iIIsNntpInfo_MinorIIsVersionNumber,  
    iIIsNntpInfo_AdminACL,  
    iIIsNntpInfo_AdminACLBin,  
    iIIsNntpInfo_MD_SERVER_CAPABILITIES,  
    cIIsNntpInfo_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpInfoRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pLogModuleList;
         ULONG *     pMD_SERVER_PLATFORM;
         ULONG *     pMajorIIsVersionNumber;
         ULONG *     pMinorIIsVersionNumber;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
         ULONG *     pMD_SERVER_CAPABILITIES;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpService                          L"IIsSmtpService"
#define TABLEID_IIsSmtpService                           (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpService                       (0L)
#define ExtendedVersion_IIsSmtpService                   (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpService {
    iIIsSmtpService_Location,  
    iIIsSmtpService_KeyType,  
    iIIsSmtpService_MaxBandwidth,  
    iIIsSmtpService_MaxConnections,  
    iIIsSmtpService_ServerComment,  
    iIIsSmtpService_ConnectionTimeout,  
    iIIsSmtpService_ServerListenTimeout,  
    iIIsSmtpService_MaxEndpointConnections,  
    iIIsSmtpService_ServerAutoStart,  
    iIIsSmtpService_AdminACL,  
    iIIsSmtpService_AdminACLBin,  
    iIIsSmtpService_IPSecurity,  
    iIIsSmtpService_DontLog,  
    iIIsSmtpService_AccessFlags,  
    iIIsSmtpService_AccessSSLFlags,  
    iIIsSmtpService_AuthFlags,  
    iIIsSmtpService_LogType,  
    iIIsSmtpService_LogFilePeriod,  
    iIIsSmtpService_LogPluginClsid,  
    iIIsSmtpService_LogModuleList,  
    iIIsSmtpService_LogFileDirectory,  
    iIIsSmtpService_LogFileTruncateSize,  
    iIIsSmtpService_LogExtFileFlags,  
    iIIsSmtpService_LogOdbcDataSource,  
    iIIsSmtpService_LogOdbcTableName,  
    iIIsSmtpService_LogOdbcUserName,  
    iIIsSmtpService_LogOdbcPassword,  
    iIIsSmtpService_SmtpServiceVersion,  
    iIIsSmtpService_EnableReverseDnsLookup,  
    iIIsSmtpService_ShouldDeliver,  
    iIIsSmtpService_AlwaysUseSsl,  
    iIIsSmtpService_LimitRemoteConnections,  
    iIIsSmtpService_SmartHostType,  
    iIIsSmtpService_DoMasquerade,  
    iIIsSmtpService_RemoteSmtpPort,  
    iIIsSmtpService_RemoteSmtpSecurePort,  
    iIIsSmtpService_HopCount,  
    iIIsSmtpService_MaxOutConnections,  
    iIIsSmtpService_MaxOutConnectionsPerDomain,  
    iIIsSmtpService_RemoteTimeout,  
    iIIsSmtpService_MaxMessageSize,  
    iIIsSmtpService_MaxSessionSize,  
    iIIsSmtpService_MaxRecipients,  
    iIIsSmtpService_LocalRetryInterval,  
    iIIsSmtpService_RemoteRetryInterval,  
    iIIsSmtpService_LocalRetryAttempts,  
    iIIsSmtpService_RemoteRetryAttempts,  
    iIIsSmtpService_EtrnDays,  
    iIIsSmtpService_MaxBatchedMessages,  
    iIIsSmtpService_SmartHost,  
    iIIsSmtpService_FullyQualifiedDomainName,  
    iIIsSmtpService_DefaultDomain,  
    iIIsSmtpService_DropDirectory,  
    iIIsSmtpService_BadMailDirectory,  
    iIIsSmtpService_PickupDirectory,  
    iIIsSmtpService_QueueDirectory,  
    iIIsSmtpService_MasqueradeDomain,  
    iIIsSmtpService_SendNdrTo,  
    iIIsSmtpService_SendBadTo,  
    iIIsSmtpService_RoutingDll,  
    iIIsSmtpService_RoutingSources,  
    iIIsSmtpService_DomainRouting,  
    iIIsSmtpService_RouteAction,  
    iIIsSmtpService_RouteUserName,  
    iIIsSmtpService_RoutePassword,  
    iIIsSmtpService_SaslLogonDomain,  
    iIIsSmtpService_SmtpClearTextProvider,  
    iIIsSmtpService_NTAuthenticationProviders,  
    iIIsSmtpService_SmtpRemoteProgressiveRetry,  
    iIIsSmtpService_SmtpLocalDelayExpireMinutes,  
    iIIsSmtpService_SmtpLocalNDRExpireMinutes,  
    iIIsSmtpService_SmtpRemoteDelayExpireMinutes,  
    iIIsSmtpService_SmtpRemoteNDRExpireMinutes,  
    iIIsSmtpService_SmtpRemoteRetryThreshold,  
    iIIsSmtpService_SmtpDSNOptions,  
    iIIsSmtpService_SmtpDSNLanguageID,  
    iIIsSmtpService_SmtpAdvQueueDll,  
    iIIsSmtpService_SmtpInboundCommandSupportOptions,  
    iIIsSmtpService_SmtpOutboundCommandSupportOptions,  
    iIIsSmtpService_SmtpCommandLogMask,  
    iIIsSmtpService_SmtpFlushMailFile,  
    iIIsSmtpService_RelayIpList,  
    iIIsSmtpService_RelayForAuth,  
    iIIsSmtpService_SmtpConnectTimeout,  
    iIIsSmtpService_SmtpMailFromTimeout,  
    iIIsSmtpService_SmtpRcptToTimeout,  
    iIIsSmtpService_SmtpDataTimeout,  
    iIIsSmtpService_SmtpBdatTimeout,  
    iIIsSmtpService_SmtpAuthTimeout,  
    iIIsSmtpService_SmtpSaslTimeout,  
    iIIsSmtpService_SmtpTurnTimeout,  
    iIIsSmtpService_SmtpRsetTimeout,  
    iIIsSmtpService_SmtpHeloTimeout,  
    iIIsSmtpService_LocalDomains,  
    iIIsSmtpService_AnonymousUserPass,  
    iIIsSmtpService_DisableSocketPooling,  
    iIIsSmtpService_SmtpUseTcpDns,  
    iIIsSmtpService_SmtpDotStuffPickupDirFiles,  
    iIIsSmtpService_SmtpDomainValidationFlags,  
    iIIsSmtpService_SmtpSSLRequireTrustedCA,  
    iIIsSmtpService_SmtpSSLCertHostnameValidation,  
    iIIsSmtpService_MaxMailObjects,  
    iIIsSmtpService_ShouldPickupMail,  
    iIIsSmtpService_MaxDirChangeIOSize,  
    iIIsSmtpService_NameResolutionType,  
    iIIsSmtpService_MaxSmtpErrors,  
    iIIsSmtpService_ShouldPipelineIn,  
    iIIsSmtpService_ShouldPipelineOut,  
    iIIsSmtpService_ConnectResponse,  
    iIIsSmtpService_UpdatedFQDN,  
    iIIsSmtpService_UpdatedDefaultDomain,  
    iIIsSmtpService_EtrnSubdomains,  
    iIIsSmtpService_SmtpMaxRemoteQThreads,  
    iIIsSmtpService_SmtpDisableRelay,  
    iIIsSmtpService_SmtpHeloNoDomain,  
    iIIsSmtpService_SmtpMailNoHelo,  
    iIIsSmtpService_SmtpAqueueWait,  
    iIIsSmtpService_AddNoHeaders,  
    iIIsSmtpService_SmtpEventlogLevel,  
    iIIsSmtpService_AllowAnonymous,  
    iIIsSmtpService_AnonymousOnly,  
    iIIsSmtpService_AnonymousPasswordSync,  
    iIIsSmtpService_AnonymousUserName,  
    iIIsSmtpService_Realm,  
    iIIsSmtpService_DefaultLogonDomain,  
    iIIsSmtpService_SmtpIpRestrictionFlag,  
    iIIsSmtpService_AzEnable,  
    iIIsSmtpService_AzStoreName,  
    iIIsSmtpService_AzScopeName,  
    cIIsSmtpService_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpServiceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pAuthFlags;
         ULONG *     pLogType;
         ULONG *     pLogFilePeriod;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pSmtpServiceVersion;
         ULONG *     pEnableReverseDnsLookup;
         ULONG *     pShouldDeliver;
         ULONG *     pAlwaysUseSsl;
         ULONG *     pLimitRemoteConnections;
         ULONG *     pSmartHostType;
         ULONG *     pDoMasquerade;
         ULONG *     pRemoteSmtpPort;
         ULONG *     pRemoteSmtpSecurePort;
         ULONG *     pHopCount;
         ULONG *     pMaxOutConnections;
         ULONG *     pMaxOutConnectionsPerDomain;
         ULONG *     pRemoteTimeout;
         ULONG *     pMaxMessageSize;
         ULONG *     pMaxSessionSize;
         ULONG *     pMaxRecipients;
         ULONG *     pLocalRetryInterval;
         ULONG *     pRemoteRetryInterval;
         ULONG *     pLocalRetryAttempts;
         ULONG *     pRemoteRetryAttempts;
         ULONG *     pEtrnDays;
         ULONG *     pMaxBatchedMessages;
         WCHAR *     pSmartHost;
         WCHAR *     pFullyQualifiedDomainName;
         WCHAR *     pDefaultDomain;
         WCHAR *     pDropDirectory;
         WCHAR *     pBadMailDirectory;
         WCHAR *     pPickupDirectory;
         WCHAR *     pQueueDirectory;
         WCHAR *     pMasqueradeDomain;
         WCHAR *     pSendNdrTo;
         WCHAR *     pSendBadTo;
         WCHAR *     pRoutingDll;
         WCHAR *     pRoutingSources;
         WCHAR *     pDomainRouting;
         ULONG *     pRouteAction;
         WCHAR *     pRouteUserName;
         WCHAR *     pRoutePassword;
         WCHAR *     pSaslLogonDomain;
         WCHAR *     pSmtpClearTextProvider;
         WCHAR *     pNTAuthenticationProviders;
         WCHAR *     pSmtpRemoteProgressiveRetry;
         ULONG *     pSmtpLocalDelayExpireMinutes;
         ULONG *     pSmtpLocalNDRExpireMinutes;
         ULONG *     pSmtpRemoteDelayExpireMinutes;
         ULONG *     pSmtpRemoteNDRExpireMinutes;
         ULONG *     pSmtpRemoteRetryThreshold;
         ULONG *     pSmtpDSNOptions;
         ULONG *     pSmtpDSNLanguageID;
         WCHAR *     pSmtpAdvQueueDll;
         ULONG *     pSmtpInboundCommandSupportOptions;
         ULONG *     pSmtpOutboundCommandSupportOptions;
         ULONG *     pSmtpCommandLogMask;
         ULONG *     pSmtpFlushMailFile;
 unsigned char *     pRelayIpList;
         ULONG *     pRelayForAuth;
         ULONG *     pSmtpConnectTimeout;
         ULONG *     pSmtpMailFromTimeout;
         ULONG *     pSmtpRcptToTimeout;
         ULONG *     pSmtpDataTimeout;
         ULONG *     pSmtpBdatTimeout;
         ULONG *     pSmtpAuthTimeout;
         ULONG *     pSmtpSaslTimeout;
         ULONG *     pSmtpTurnTimeout;
         ULONG *     pSmtpRsetTimeout;
         ULONG *     pSmtpHeloTimeout;
         WCHAR *     pLocalDomains;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pDisableSocketPooling;
         ULONG *     pSmtpUseTcpDns;
         ULONG *     pSmtpDotStuffPickupDirFiles;
         ULONG *     pSmtpDomainValidationFlags;
         ULONG *     pSmtpSSLRequireTrustedCA;
         ULONG *     pSmtpSSLCertHostnameValidation;
         ULONG *     pMaxMailObjects;
         ULONG *     pShouldPickupMail;
         ULONG *     pMaxDirChangeIOSize;
         ULONG *     pNameResolutionType;
         ULONG *     pMaxSmtpErrors;
         ULONG *     pShouldPipelineIn;
         ULONG *     pShouldPipelineOut;
         WCHAR *     pConnectResponse;
         ULONG *     pUpdatedFQDN;
         ULONG *     pUpdatedDefaultDomain;
         ULONG *     pEtrnSubdomains;
         ULONG *     pSmtpMaxRemoteQThreads;
         ULONG *     pSmtpDisableRelay;
         ULONG *     pSmtpHeloNoDomain;
         ULONG *     pSmtpMailNoHelo;
         ULONG *     pSmtpAqueueWait;
         ULONG *     pAddNoHeaders;
         ULONG *     pSmtpEventlogLevel;
         ULONG *     pAllowAnonymous;
         ULONG *     pAnonymousOnly;
         ULONG *     pAnonymousPasswordSync;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pRealm;
         WCHAR *     pDefaultLogonDomain;
         ULONG *     pSmtpIpRestrictionFlag;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpServer                           L"IIsSmtpServer"
#define TABLEID_IIsSmtpServer                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpServer                        (0L)
#define ExtendedVersion_IIsSmtpServer                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpServer {
    iIIsSmtpServer_Location,  
    iIIsSmtpServer_KeyType,  
    iIIsSmtpServer_MaxBandwidth,  
    iIIsSmtpServer_MaxConnections,  
    iIIsSmtpServer_ServerComment,  
    iIIsSmtpServer_ConnectionTimeout,  
    iIIsSmtpServer_ServerListenTimeout,  
    iIIsSmtpServer_MaxEndpointConnections,  
    iIIsSmtpServer_ServerAutoStart,  
    iIIsSmtpServer_ServerBindings,  
    iIIsSmtpServer_SecureBindings,  
    iIIsSmtpServer_ClusterEnabled,  
    iIIsSmtpServer_AdminACL,  
    iIIsSmtpServer_AdminACLBin,  
    iIIsSmtpServer_IPSecurity,  
    iIIsSmtpServer_DontLog,  
    iIIsSmtpServer_AuthFlags,  
    iIIsSmtpServer_AccessFlags,  
    iIIsSmtpServer_AccessSSLFlags,  
    iIIsSmtpServer_ServerListenBacklog,  
    iIIsSmtpServer_Win32Error,  
    iIIsSmtpServer_ServerState,  
    iIIsSmtpServer_LogType,  
    iIIsSmtpServer_LogPluginClsid,  
    iIIsSmtpServer_LogFileDirectory,  
    iIIsSmtpServer_LogFilePeriod,  
    iIIsSmtpServer_LogFileTruncateSize,  
    iIIsSmtpServer_LogExtFileFlags,  
    iIIsSmtpServer_LogOdbcDataSource,  
    iIIsSmtpServer_LogOdbcTableName,  
    iIIsSmtpServer_LogOdbcUserName,  
    iIIsSmtpServer_LogOdbcPassword,  
    iIIsSmtpServer_SmtpServiceVersion,  
    iIIsSmtpServer_EnableReverseDnsLookup,  
    iIIsSmtpServer_ShouldDeliver,  
    iIIsSmtpServer_AlwaysUseSsl,  
    iIIsSmtpServer_LimitRemoteConnections,  
    iIIsSmtpServer_SmartHostType,  
    iIIsSmtpServer_DoMasquerade,  
    iIIsSmtpServer_RemoteSmtpPort,  
    iIIsSmtpServer_RemoteSmtpSecurePort,  
    iIIsSmtpServer_HopCount,  
    iIIsSmtpServer_MaxOutConnections,  
    iIIsSmtpServer_MaxOutConnectionsPerDomain,  
    iIIsSmtpServer_RemoteTimeout,  
    iIIsSmtpServer_MaxMessageSize,  
    iIIsSmtpServer_MaxSessionSize,  
    iIIsSmtpServer_MaxRecipients,  
    iIIsSmtpServer_LocalRetryInterval,  
    iIIsSmtpServer_RemoteRetryInterval,  
    iIIsSmtpServer_LocalRetryAttempts,  
    iIIsSmtpServer_RemoteRetryAttempts,  
    iIIsSmtpServer_EtrnDays,  
    iIIsSmtpServer_MaxBatchedMessages,  
    iIIsSmtpServer_SmartHost,  
    iIIsSmtpServer_FullyQualifiedDomainName,  
    iIIsSmtpServer_DefaultDomain,  
    iIIsSmtpServer_DropDirectory,  
    iIIsSmtpServer_BadMailDirectory,  
    iIIsSmtpServer_PickupDirectory,  
    iIIsSmtpServer_QueueDirectory,  
    iIIsSmtpServer_MasqueradeDomain,  
    iIIsSmtpServer_SendNdrTo,  
    iIIsSmtpServer_SendBadTo,  
    iIIsSmtpServer_RoutingDll,  
    iIIsSmtpServer_RoutingSources,  
    iIIsSmtpServer_DomainRouting,  
    iIIsSmtpServer_RouteAction,  
    iIIsSmtpServer_RouteUserName,  
    iIIsSmtpServer_RoutePassword,  
    iIIsSmtpServer_SaslLogonDomain,  
    iIIsSmtpServer_SmtpClearTextProvider,  
    iIIsSmtpServer_NTAuthenticationProviders,  
    iIIsSmtpServer_SmtpRemoteProgressiveRetry,  
    iIIsSmtpServer_SmtpLocalDelayExpireMinutes,  
    iIIsSmtpServer_SmtpLocalNDRExpireMinutes,  
    iIIsSmtpServer_SmtpRemoteDelayExpireMinutes,  
    iIIsSmtpServer_SmtpRemoteNDRExpireMinutes,  
    iIIsSmtpServer_SmtpRemoteRetryThreshold,  
    iIIsSmtpServer_SmtpDSNOptions,  
    iIIsSmtpServer_SmtpDSNLanguageID,  
    iIIsSmtpServer_SmtpInboundCommandSupportOptions,  
    iIIsSmtpServer_SmtpOutboundCommandSupportOptions,  
    iIIsSmtpServer_RelayIpList,  
    iIIsSmtpServer_RelayForAuth,  
    iIIsSmtpServer_SmtpConnectTimeout,  
    iIIsSmtpServer_SmtpMailFromTimeout,  
    iIIsSmtpServer_SmtpRcptToTimeout,  
    iIIsSmtpServer_SmtpDataTimeout,  
    iIIsSmtpServer_SmtpBdatTimeout,  
    iIIsSmtpServer_SmtpAuthTimeout,  
    iIIsSmtpServer_SmtpSaslTimeout,  
    iIIsSmtpServer_SmtpTurnTimeout,  
    iIIsSmtpServer_SmtpRsetTimeout,  
    iIIsSmtpServer_SmtpHeloTimeout,  
    iIIsSmtpServer_PostmasterName,  
    iIIsSmtpServer_PostmasterEmail,  
    iIIsSmtpServer_LocalDomains,  
    iIIsSmtpServer_SSLCertHash,  
    iIIsSmtpServer_DisableSocketPooling,  
    iIIsSmtpServer_SmtpUseTcpDns,  
    iIIsSmtpServer_SmtpDotStuffPickupDirFiles,  
    iIIsSmtpServer_SmtpDomainValidationFlags,  
    iIIsSmtpServer_SmtpSSLRequireTrustedCA,  
    iIIsSmtpServer_SmtpSSLCertHostnameValidation,  
    iIIsSmtpServer_MaxMailObjects,  
    iIIsSmtpServer_ShouldPickupMail,  
    iIIsSmtpServer_MaxDirChangeIOSize,  
    iIIsSmtpServer_NameResolutionType,  
    iIIsSmtpServer_MaxSmtpErrors,  
    iIIsSmtpServer_ShouldPipelineIn,  
    iIIsSmtpServer_ShouldPipelineOut,  
    iIIsSmtpServer_ConnectResponse,  
    iIIsSmtpServer_UpdatedFQDN,  
    iIIsSmtpServer_UpdatedDefaultDomain,  
    iIIsSmtpServer_EtrnSubdomains,  
    iIIsSmtpServer_SmtpMaxRemoteQThreads,  
    iIIsSmtpServer_SmtpDisableRelay,  
    iIIsSmtpServer_SmtpHeloNoDomain,  
    iIIsSmtpServer_SmtpMailNoHelo,  
    iIIsSmtpServer_SmtpAqueueWait,  
    iIIsSmtpServer_AddNoHeaders,  
    iIIsSmtpServer_SmtpEventlogLevel,  
    iIIsSmtpServer_AllowAnonymous,  
    iIIsSmtpServer_AnonymousOnly,  
    iIIsSmtpServer_AnonymousPasswordSync,  
    iIIsSmtpServer_AnonymousUserName,  
    iIIsSmtpServer_Realm,  
    iIIsSmtpServer_DefaultLogonDomain,  
    iIIsSmtpServer_SmtpIpRestrictionFlag,  
    iIIsSmtpServer_AzEnable,  
    iIIsSmtpServer_AzStoreName,  
    iIIsSmtpServer_AzScopeName,  
    cIIsSmtpServer_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpServerRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         WCHAR *     pServerBindings;
         WCHAR *     pSecureBindings;
         ULONG *     pClusterEnabled;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pAuthFlags;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pServerListenBacklog;
         ULONG *     pWin32Error;
         ULONG *     pServerState;
         ULONG *     pLogType;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pSmtpServiceVersion;
         ULONG *     pEnableReverseDnsLookup;
         ULONG *     pShouldDeliver;
         ULONG *     pAlwaysUseSsl;
         ULONG *     pLimitRemoteConnections;
         ULONG *     pSmartHostType;
         ULONG *     pDoMasquerade;
         ULONG *     pRemoteSmtpPort;
         ULONG *     pRemoteSmtpSecurePort;
         ULONG *     pHopCount;
         ULONG *     pMaxOutConnections;
         ULONG *     pMaxOutConnectionsPerDomain;
         ULONG *     pRemoteTimeout;
         ULONG *     pMaxMessageSize;
         ULONG *     pMaxSessionSize;
         ULONG *     pMaxRecipients;
         ULONG *     pLocalRetryInterval;
         ULONG *     pRemoteRetryInterval;
         ULONG *     pLocalRetryAttempts;
         ULONG *     pRemoteRetryAttempts;
         ULONG *     pEtrnDays;
         ULONG *     pMaxBatchedMessages;
         WCHAR *     pSmartHost;
         WCHAR *     pFullyQualifiedDomainName;
         WCHAR *     pDefaultDomain;
         WCHAR *     pDropDirectory;
         WCHAR *     pBadMailDirectory;
         WCHAR *     pPickupDirectory;
         WCHAR *     pQueueDirectory;
         WCHAR *     pMasqueradeDomain;
         WCHAR *     pSendNdrTo;
         WCHAR *     pSendBadTo;
         WCHAR *     pRoutingDll;
         WCHAR *     pRoutingSources;
         WCHAR *     pDomainRouting;
         ULONG *     pRouteAction;
         WCHAR *     pRouteUserName;
         WCHAR *     pRoutePassword;
         WCHAR *     pSaslLogonDomain;
         WCHAR *     pSmtpClearTextProvider;
         WCHAR *     pNTAuthenticationProviders;
         WCHAR *     pSmtpRemoteProgressiveRetry;
         ULONG *     pSmtpLocalDelayExpireMinutes;
         ULONG *     pSmtpLocalNDRExpireMinutes;
         ULONG *     pSmtpRemoteDelayExpireMinutes;
         ULONG *     pSmtpRemoteNDRExpireMinutes;
         ULONG *     pSmtpRemoteRetryThreshold;
         ULONG *     pSmtpDSNOptions;
         ULONG *     pSmtpDSNLanguageID;
         ULONG *     pSmtpInboundCommandSupportOptions;
         ULONG *     pSmtpOutboundCommandSupportOptions;
 unsigned char *     pRelayIpList;
         ULONG *     pRelayForAuth;
         ULONG *     pSmtpConnectTimeout;
         ULONG *     pSmtpMailFromTimeout;
         ULONG *     pSmtpRcptToTimeout;
         ULONG *     pSmtpDataTimeout;
         ULONG *     pSmtpBdatTimeout;
         ULONG *     pSmtpAuthTimeout;
         ULONG *     pSmtpSaslTimeout;
         ULONG *     pSmtpTurnTimeout;
         ULONG *     pSmtpRsetTimeout;
         ULONG *     pSmtpHeloTimeout;
         WCHAR *     pPostmasterName;
         WCHAR *     pPostmasterEmail;
         WCHAR *     pLocalDomains;
 unsigned char *     pSSLCertHash;
         ULONG *     pDisableSocketPooling;
         ULONG *     pSmtpUseTcpDns;
         ULONG *     pSmtpDotStuffPickupDirFiles;
         ULONG *     pSmtpDomainValidationFlags;
         ULONG *     pSmtpSSLRequireTrustedCA;
         ULONG *     pSmtpSSLCertHostnameValidation;
         ULONG *     pMaxMailObjects;
         ULONG *     pShouldPickupMail;
         ULONG *     pMaxDirChangeIOSize;
         ULONG *     pNameResolutionType;
         ULONG *     pMaxSmtpErrors;
         ULONG *     pShouldPipelineIn;
         ULONG *     pShouldPipelineOut;
         WCHAR *     pConnectResponse;
         ULONG *     pUpdatedFQDN;
         ULONG *     pUpdatedDefaultDomain;
         ULONG *     pEtrnSubdomains;
         ULONG *     pSmtpMaxRemoteQThreads;
         ULONG *     pSmtpDisableRelay;
         ULONG *     pSmtpHeloNoDomain;
         ULONG *     pSmtpMailNoHelo;
         ULONG *     pSmtpAqueueWait;
         ULONG *     pAddNoHeaders;
         ULONG *     pSmtpEventlogLevel;
         ULONG *     pAllowAnonymous;
         ULONG *     pAnonymousOnly;
         ULONG *     pAnonymousPasswordSync;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pRealm;
         WCHAR *     pDefaultLogonDomain;
         ULONG *     pSmtpIpRestrictionFlag;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpVirtualDir                       L"IIsSmtpVirtualDir"
#define TABLEID_IIsSmtpVirtualDir                        (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpVirtualDir                    (0L)
#define ExtendedVersion_IIsSmtpVirtualDir                (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpVirtualDir {
    iIIsSmtpVirtualDir_Location,  
    iIIsSmtpVirtualDir_KeyType,  
    iIIsSmtpVirtualDir_Path,  
    iIIsSmtpVirtualDir_UNCUserName,  
    iIIsSmtpVirtualDir_UNCPassword,  
    iIIsSmtpVirtualDir_Win32Error,  
    iIIsSmtpVirtualDir_DontLog,  
    iIIsSmtpVirtualDir_AccessFlags,  
    iIIsSmtpVirtualDir_AccessSSLFlags,  
    iIIsSmtpVirtualDir_AdminACL,  
    iIIsSmtpVirtualDir_AdminACLBin,  
    cIIsSmtpVirtualDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpVirtualDirRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pPath;
         WCHAR *     pUNCUserName;
         WCHAR *     pUNCPassword;
         ULONG *     pWin32Error;
         ULONG *     pDontLog;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpDomain                           L"IIsSmtpDomain"
#define TABLEID_IIsSmtpDomain                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpDomain                        (0L)
#define ExtendedVersion_IIsSmtpDomain                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpDomain {
    iIIsSmtpDomain_Location,  
    iIIsSmtpDomain_KeyType,  
    iIIsSmtpDomain_RouteAction,  
    iIIsSmtpDomain_RouteActionString,  
    iIIsSmtpDomain_RouteUserName,  
    iIIsSmtpDomain_RoutePassword,  
    iIIsSmtpDomain_RelayIpList,  
    iIIsSmtpDomain_RelayForAuth,  
    iIIsSmtpDomain_AuthTurnList,  
    iIIsSmtpDomain_CSideEtrnDomains,  
    iIIsSmtpDomain_AdminACL,  
    iIIsSmtpDomain_AdminACLBin,  
    cIIsSmtpDomain_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpDomainRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pRouteAction;
         WCHAR *     pRouteActionString;
         WCHAR *     pRouteUserName;
         WCHAR *     pRoutePassword;
 unsigned char *     pRelayIpList;
         ULONG *     pRelayForAuth;
         WCHAR *     pAuthTurnList;
         WCHAR *     pCSideEtrnDomains;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpRoutingSource                    L"IIsSmtpRoutingSource"
#define TABLEID_IIsSmtpRoutingSource                     (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpRoutingSource                 (0L)
#define ExtendedVersion_IIsSmtpRoutingSource             (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpRoutingSource {
    iIIsSmtpRoutingSource_Location,  
    iIIsSmtpRoutingSource_KeyType,  
    iIIsSmtpRoutingSource_SmtpRoutingTableType,  
    iIIsSmtpRoutingSource_SmtpDsDataDirectory,  
    iIIsSmtpRoutingSource_SmtpDsDefaultMailRoot,  
    iIIsSmtpRoutingSource_SmtpDsBindType,  
    iIIsSmtpRoutingSource_SmtpDsSchemaType,  
    iIIsSmtpRoutingSource_SmtpDsHost,  
    iIIsSmtpRoutingSource_SmtpDsNamingContext,  
    iIIsSmtpRoutingSource_SmtpDsAccount,  
    iIIsSmtpRoutingSource_SmtpDsPassword,  
    iIIsSmtpRoutingSource_SmtpDsUseCat,  
    iIIsSmtpRoutingSource_SmtpDsPort,  
    iIIsSmtpRoutingSource_SmtpDsDomain,  
    iIIsSmtpRoutingSource_SmtpDsFlags,  
    iIIsSmtpRoutingSource_AdminACL,  
    iIIsSmtpRoutingSource_AdminACLBin,  
    cIIsSmtpRoutingSource_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpRoutingSourceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pSmtpRoutingTableType;
         WCHAR *     pSmtpDsDataDirectory;
         WCHAR *     pSmtpDsDefaultMailRoot;
         WCHAR *     pSmtpDsBindType;
         WCHAR *     pSmtpDsSchemaType;
         WCHAR *     pSmtpDsHost;
         WCHAR *     pSmtpDsNamingContext;
         WCHAR *     pSmtpDsAccount;
         WCHAR *     pSmtpDsPassword;
         ULONG *     pSmtpDsUseCat;
         ULONG *     pSmtpDsPort;
         WCHAR *     pSmtpDsDomain;
         ULONG *     pSmtpDsFlags;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpInfo                             L"IIsSmtpInfo"
#define TABLEID_IIsSmtpInfo                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpInfo                          (0L)
#define ExtendedVersion_IIsSmtpInfo                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpInfo {
    iIIsSmtpInfo_Location,  
    iIIsSmtpInfo_KeyType,  
    iIIsSmtpInfo_LogModuleList,  
    iIIsSmtpInfo_MajorIIsVersionNumber,  
    iIIsSmtpInfo_MinorIIsVersionNumber,  
    iIIsSmtpInfo_MD_SERVER_PLATFORM,  
    iIIsSmtpInfo_AdminACL,  
    iIIsSmtpInfo_AdminACLBin,  
    iIIsSmtpInfo_MD_SERVER_CAPABILITIES,  
    cIIsSmtpInfo_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpInfoRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pLogModuleList;
         ULONG *     pMajorIIsVersionNumber;
         ULONG *     pMinorIIsVersionNumber;
         ULONG *     pMD_SERVER_PLATFORM;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
         ULONG *     pMD_SERVER_CAPABILITIES;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsPop3Service                          L"IIsPop3Service"
#define TABLEID_IIsPop3Service                           (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsPop3Service                       (0L)
#define ExtendedVersion_IIsPop3Service                   (0L)

//-----------------Column Index Enums--------------   
enum eIIsPop3Service {
    iIIsPop3Service_Location,  
    iIIsPop3Service_KeyType,  
    iIIsPop3Service_MaxBandwidth,  
    iIIsPop3Service_MaxConnections,  
    iIIsPop3Service_ServerComment,  
    iIIsPop3Service_ConnectionTimeout,  
    iIIsPop3Service_ServerListenTimeout,  
    iIIsPop3Service_MaxEndpointConnections,  
    iIIsPop3Service_ServerAutoStart,  
    iIIsPop3Service_AdminACL,  
    iIIsPop3Service_AdminACLBin,  
    iIIsPop3Service_IPSecurity,  
    iIIsPop3Service_DontLog,  
    iIIsPop3Service_AuthFlags,  
    iIIsPop3Service_ServerListenBacklog,  
    iIIsPop3Service_DefaultLogonDomain,  
    iIIsPop3Service_NTAuthenticationProviders,  
    iIIsPop3Service_AccessFlags,  
    iIIsPop3Service_AccessSSLFlags,  
    iIIsPop3Service_LogType,  
    iIIsPop3Service_LogFilePeriod,  
    iIIsPop3Service_LogPluginClsid,  
    iIIsPop3Service_LogModuleList,  
    iIIsPop3Service_LogFileDirectory,  
    iIIsPop3Service_LogFileTruncateSize,  
    iIIsPop3Service_LogExtFileFlags,  
    iIIsPop3Service_LogOdbcDataSource,  
    iIIsPop3Service_LogOdbcTableName,  
    iIIsPop3Service_LogOdbcUserName,  
    iIIsPop3Service_LogOdbcPassword,  
    iIIsPop3Service_Pop3ServiceVersion,  
    iIIsPop3Service_Pop3ExpireMail,  
    iIIsPop3Service_Pop3ExpireDelay,  
    iIIsPop3Service_Pop3ExpireStart,  
    iIIsPop3Service_Pop3MailExpirationTime,  
    iIIsPop3Service_Pop3ClearTextProvider,  
    iIIsPop3Service_Pop3DefaultDomain,  
    iIIsPop3Service_Pop3RoutingDll,  
    iIIsPop3Service_Pop3RoutingSources,  
    iIIsPop3Service_AzEnable,  
    iIIsPop3Service_AzStoreName,  
    iIIsPop3Service_AzScopeName,  
    cIIsPop3Service_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsPop3ServiceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pAuthFlags;
         ULONG *     pServerListenBacklog;
         WCHAR *     pDefaultLogonDomain;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pLogType;
         ULONG *     pLogFilePeriod;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pPop3ServiceVersion;
         ULONG *     pPop3ExpireMail;
         ULONG *     pPop3ExpireDelay;
         ULONG *     pPop3ExpireStart;
         ULONG *     pPop3MailExpirationTime;
         WCHAR *     pPop3ClearTextProvider;
         WCHAR *     pPop3DefaultDomain;
         WCHAR *     pPop3RoutingDll;
         WCHAR *     pPop3RoutingSources;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsPop3Server                           L"IIsPop3Server"
#define TABLEID_IIsPop3Server                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsPop3Server                        (0L)
#define ExtendedVersion_IIsPop3Server                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsPop3Server {
    iIIsPop3Server_Location,  
    iIIsPop3Server_KeyType,  
    iIIsPop3Server_MaxBandwidth,  
    iIIsPop3Server_MaxConnections,  
    iIIsPop3Server_ServerComment,  
    iIIsPop3Server_ConnectionTimeout,  
    iIIsPop3Server_ServerListenTimeout,  
    iIIsPop3Server_MaxEndpointConnections,  
    iIIsPop3Server_ServerAutoStart,  
    iIIsPop3Server_ServerBindings,  
    iIIsPop3Server_SecureBindings,  
    iIIsPop3Server_AdminACL,  
    iIIsPop3Server_AdminACLBin,  
    iIIsPop3Server_IPSecurity,  
    iIIsPop3Server_DontLog,  
    iIIsPop3Server_AuthFlags,  
    iIIsPop3Server_DefaultLogonDomain,  
    iIIsPop3Server_NTAuthenticationProviders,  
    iIIsPop3Server_AccessFlags,  
    iIIsPop3Server_AccessSSLFlags,  
    iIIsPop3Server_ServerListenBacklog,  
    iIIsPop3Server_Win32Error,  
    iIIsPop3Server_ServerState,  
    iIIsPop3Server_LogType,  
    iIIsPop3Server_LogPluginClsid,  
    iIIsPop3Server_LogFileDirectory,  
    iIIsPop3Server_LogFilePeriod,  
    iIIsPop3Server_LogFileTruncateSize,  
    iIIsPop3Server_LogExtFileFlags,  
    iIIsPop3Server_LogOdbcDataSource,  
    iIIsPop3Server_LogOdbcTableName,  
    iIIsPop3Server_LogOdbcUserName,  
    iIIsPop3Server_LogOdbcPassword,  
    iIIsPop3Server_Pop3ServiceVersion,  
    iIIsPop3Server_Pop3ExpireMail,  
    iIIsPop3Server_Pop3ExpireDelay,  
    iIIsPop3Server_Pop3ExpireStart,  
    iIIsPop3Server_Pop3MailExpirationTime,  
    iIIsPop3Server_Pop3ClearTextProvider,  
    iIIsPop3Server_Pop3DefaultDomain,  
    iIIsPop3Server_Pop3RoutingDll,  
    iIIsPop3Server_Pop3RoutingSources,  
    iIIsPop3Server_SSLCertHash,  
    iIIsPop3Server_AzEnable,  
    iIIsPop3Server_AzStoreName,  
    iIIsPop3Server_AzScopeName,  
    cIIsPop3Server_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsPop3ServerRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         WCHAR *     pServerBindings;
         WCHAR *     pSecureBindings;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pAuthFlags;
         WCHAR *     pDefaultLogonDomain;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pServerListenBacklog;
         ULONG *     pWin32Error;
         ULONG *     pServerState;
         ULONG *     pLogType;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pPop3ServiceVersion;
         ULONG *     pPop3ExpireMail;
         ULONG *     pPop3ExpireDelay;
         ULONG *     pPop3ExpireStart;
         ULONG *     pPop3MailExpirationTime;
         WCHAR *     pPop3ClearTextProvider;
         WCHAR *     pPop3DefaultDomain;
         WCHAR *     pPop3RoutingDll;
         WCHAR *     pPop3RoutingSources;
 unsigned char *     pSSLCertHash;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsPop3VirtualDir                       L"IIsPop3VirtualDir"
#define TABLEID_IIsPop3VirtualDir                        (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsPop3VirtualDir                    (0L)
#define ExtendedVersion_IIsPop3VirtualDir                (0L)

//-----------------Column Index Enums--------------   
enum eIIsPop3VirtualDir {
    iIIsPop3VirtualDir_Location,  
    iIIsPop3VirtualDir_KeyType,  
    iIIsPop3VirtualDir_Path,  
    iIIsPop3VirtualDir_UNCUserName,  
    iIIsPop3VirtualDir_UNCPassword,  
    iIIsPop3VirtualDir_Win32Error,  
    iIIsPop3VirtualDir_DontLog,  
    iIIsPop3VirtualDir_AccessFlags,  
    iIIsPop3VirtualDir_AccessSSLFlags,  
    iIIsPop3VirtualDir_Pop3ExpireMail,  
    iIIsPop3VirtualDir_Pop3MailExpirationTime,  
    iIIsPop3VirtualDir_AdminACL,  
    iIIsPop3VirtualDir_AdminACLBin,  
    cIIsPop3VirtualDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsPop3VirtualDirRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pPath;
         WCHAR *     pUNCUserName;
         WCHAR *     pUNCPassword;
         ULONG *     pWin32Error;
         ULONG *     pDontLog;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pPop3ExpireMail;
         ULONG *     pPop3MailExpirationTime;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsPop3RoutingSource                    L"IIsPop3RoutingSource"
#define TABLEID_IIsPop3RoutingSource                     (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsPop3RoutingSource                 (0L)
#define ExtendedVersion_IIsPop3RoutingSource             (0L)

//-----------------Column Index Enums--------------   
enum eIIsPop3RoutingSource {
    iIIsPop3RoutingSource_Location,  
    iIIsPop3RoutingSource_KeyType,  
    iIIsPop3RoutingSource_Pop3RoutingTableType,  
    iIIsPop3RoutingSource_Pop3DsDataDirectory,  
    iIIsPop3RoutingSource_Pop3DsDefaultMailRoot,  
    iIIsPop3RoutingSource_Pop3DsBindType,  
    iIIsPop3RoutingSource_Pop3DsSchemaType,  
    iIIsPop3RoutingSource_Pop3DsHost,  
    iIIsPop3RoutingSource_Pop3DsNamingContext,  
    iIIsPop3RoutingSource_Pop3DsAccount,  
    iIIsPop3RoutingSource_Pop3DsPassword,  
    iIIsPop3RoutingSource_AdminACL,  
    iIIsPop3RoutingSource_AdminACLBin,  
    cIIsPop3RoutingSource_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsPop3RoutingSourceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pPop3RoutingTableType;
         WCHAR *     pPop3DsDataDirectory;
         WCHAR *     pPop3DsDefaultMailRoot;
         WCHAR *     pPop3DsBindType;
         WCHAR *     pPop3DsSchemaType;
         WCHAR *     pPop3DsHost;
         WCHAR *     pPop3DsNamingContext;
         WCHAR *     pPop3DsAccount;
         WCHAR *     pPop3DsPassword;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsPop3Info                             L"IIsPop3Info"
#define TABLEID_IIsPop3Info                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsPop3Info                          (0L)
#define ExtendedVersion_IIsPop3Info                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsPop3Info {
    iIIsPop3Info_Location,  
    iIIsPop3Info_KeyType,  
    iIIsPop3Info_LogModuleList,  
    iIIsPop3Info_AdminACL,  
    iIIsPop3Info_AdminACLBin,  
    cIIsPop3Info_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsPop3InfoRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pLogModuleList;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsImapService                          L"IIsImapService"
#define TABLEID_IIsImapService                           (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsImapService                       (0L)
#define ExtendedVersion_IIsImapService                   (0L)

//-----------------Column Index Enums--------------   
enum eIIsImapService {
    iIIsImapService_Location,  
    iIIsImapService_KeyType,  
    iIIsImapService_MaxBandwidth,  
    iIIsImapService_MaxConnections,  
    iIIsImapService_ServerComment,  
    iIIsImapService_ConnectionTimeout,  
    iIIsImapService_ServerListenTimeout,  
    iIIsImapService_MaxEndpointConnections,  
    iIIsImapService_ServerAutoStart,  
    iIIsImapService_AdminACL,  
    iIIsImapService_AdminACLBin,  
    iIIsImapService_IPSecurity,  
    iIIsImapService_DontLog,  
    iIIsImapService_AuthFlags,  
    iIIsImapService_ServerListenBacklog,  
    iIIsImapService_DefaultLogonDomain,  
    iIIsImapService_NTAuthenticationProviders,  
    iIIsImapService_AccessFlags,  
    iIIsImapService_AccessSSLFlags,  
    iIIsImapService_LogType,  
    iIIsImapService_LogFilePeriod,  
    iIIsImapService_LogPluginClsid,  
    iIIsImapService_LogModuleList,  
    iIIsImapService_LogFileDirectory,  
    iIIsImapService_LogFileTruncateSize,  
    iIIsImapService_LogExtFileFlags,  
    iIIsImapService_LogOdbcDataSource,  
    iIIsImapService_LogOdbcTableName,  
    iIIsImapService_LogOdbcUserName,  
    iIIsImapService_LogOdbcPassword,  
    iIIsImapService_ImapServiceVersion,  
    iIIsImapService_ImapExpireMail,  
    iIIsImapService_ImapExpireDelay,  
    iIIsImapService_ImapExpireStart,  
    iIIsImapService_ImapMailExpirationTime,  
    iIIsImapService_ImapClearTextProvider,  
    iIIsImapService_ImapDefaultDomain,  
    iIIsImapService_ImapRoutingDll,  
    iIIsImapService_ImapRoutingSources,  
    iIIsImapService_AzEnable,  
    iIIsImapService_AzStoreName,  
    iIIsImapService_AzScopeName,  
    cIIsImapService_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsImapServiceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pAuthFlags;
         ULONG *     pServerListenBacklog;
         WCHAR *     pDefaultLogonDomain;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pLogType;
         ULONG *     pLogFilePeriod;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pImapServiceVersion;
         ULONG *     pImapExpireMail;
         ULONG *     pImapExpireDelay;
         ULONG *     pImapExpireStart;
         ULONG *     pImapMailExpirationTime;
         WCHAR *     pImapClearTextProvider;
         WCHAR *     pImapDefaultDomain;
         WCHAR *     pImapRoutingDll;
         WCHAR *     pImapRoutingSources;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsImapServer                           L"IIsImapServer"
#define TABLEID_IIsImapServer                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsImapServer                        (0L)
#define ExtendedVersion_IIsImapServer                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsImapServer {
    iIIsImapServer_Location,  
    iIIsImapServer_KeyType,  
    iIIsImapServer_MaxBandwidth,  
    iIIsImapServer_MaxConnections,  
    iIIsImapServer_ServerComment,  
    iIIsImapServer_ConnectionTimeout,  
    iIIsImapServer_ServerListenTimeout,  
    iIIsImapServer_MaxEndpointConnections,  
    iIIsImapServer_ServerAutoStart,  
    iIIsImapServer_ServerBindings,  
    iIIsImapServer_SecureBindings,  
    iIIsImapServer_AdminACL,  
    iIIsImapServer_AdminACLBin,  
    iIIsImapServer_IPSecurity,  
    iIIsImapServer_DontLog,  
    iIIsImapServer_AuthFlags,  
    iIIsImapServer_DefaultLogonDomain,  
    iIIsImapServer_NTAuthenticationProviders,  
    iIIsImapServer_AccessFlags,  
    iIIsImapServer_AccessSSLFlags,  
    iIIsImapServer_LogType,  
    iIIsImapServer_LogPluginClsid,  
    iIIsImapServer_LogFileDirectory,  
    iIIsImapServer_LogFilePeriod,  
    iIIsImapServer_LogFileTruncateSize,  
    iIIsImapServer_LogExtFileFlags,  
    iIIsImapServer_LogOdbcDataSource,  
    iIIsImapServer_LogOdbcTableName,  
    iIIsImapServer_LogOdbcUserName,  
    iIIsImapServer_LogOdbcPassword,  
    iIIsImapServer_ServerListenBacklog,  
    iIIsImapServer_Win32Error,  
    iIIsImapServer_ServerState,  
    iIIsImapServer_ImapServiceVersion,  
    iIIsImapServer_ImapExpireMail,  
    iIIsImapServer_ImapExpireDelay,  
    iIIsImapServer_ImapExpireStart,  
    iIIsImapServer_ImapMailExpirationTime,  
    iIIsImapServer_ImapClearTextProvider,  
    iIIsImapServer_ImapDefaultDomain,  
    iIIsImapServer_ImapRoutingDll,  
    iIIsImapServer_ImapRoutingSources,  
    iIIsImapServer_SSLCertHash,  
    iIIsImapServer_AzEnable,  
    iIIsImapServer_AzStoreName,  
    iIIsImapServer_AzScopeName,  
    cIIsImapServer_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsImapServerRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         WCHAR *     pServerBindings;
         WCHAR *     pSecureBindings;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pAuthFlags;
         WCHAR *     pDefaultLogonDomain;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pLogType;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pServerListenBacklog;
         ULONG *     pWin32Error;
         ULONG *     pServerState;
         ULONG *     pImapServiceVersion;
         ULONG *     pImapExpireMail;
         ULONG *     pImapExpireDelay;
         ULONG *     pImapExpireStart;
         ULONG *     pImapMailExpirationTime;
         WCHAR *     pImapClearTextProvider;
         WCHAR *     pImapDefaultDomain;
         WCHAR *     pImapRoutingDll;
         WCHAR *     pImapRoutingSources;
 unsigned char *     pSSLCertHash;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsImapVirtualDir                       L"IIsImapVirtualDir"
#define TABLEID_IIsImapVirtualDir                        (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsImapVirtualDir                    (0L)
#define ExtendedVersion_IIsImapVirtualDir                (0L)

//-----------------Column Index Enums--------------   
enum eIIsImapVirtualDir {
    iIIsImapVirtualDir_Location,  
    iIIsImapVirtualDir_KeyType,  
    iIIsImapVirtualDir_Path,  
    iIIsImapVirtualDir_UNCUserName,  
    iIIsImapVirtualDir_UNCPassword,  
    iIIsImapVirtualDir_Win32Error,  
    iIIsImapVirtualDir_DontLog,  
    iIIsImapVirtualDir_AccessFlags,  
    iIIsImapVirtualDir_AccessSSLFlags,  
    iIIsImapVirtualDir_ImapExpireMail,  
    iIIsImapVirtualDir_ImapMailExpirationTime,  
    iIIsImapVirtualDir_AdminACL,  
    iIIsImapVirtualDir_AdminACLBin,  
    cIIsImapVirtualDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsImapVirtualDirRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pPath;
         WCHAR *     pUNCUserName;
         WCHAR *     pUNCPassword;
         ULONG *     pWin32Error;
         ULONG *     pDontLog;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pImapExpireMail;
         ULONG *     pImapMailExpirationTime;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsImapRoutingSource                    L"IIsImapRoutingSource"
#define TABLEID_IIsImapRoutingSource                     (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsImapRoutingSource                 (0L)
#define ExtendedVersion_IIsImapRoutingSource             (0L)

//-----------------Column Index Enums--------------   
enum eIIsImapRoutingSource {
    iIIsImapRoutingSource_Location,  
    iIIsImapRoutingSource_KeyType,  
    iIIsImapRoutingSource_ImapRoutingTableType,  
    iIIsImapRoutingSource_ImapDsDataDirectory,  
    iIIsImapRoutingSource_ImapDsDefaultMailRoot,  
    iIIsImapRoutingSource_ImapDsBindType,  
    iIIsImapRoutingSource_ImapDsSchemaType,  
    iIIsImapRoutingSource_ImapDsHost,  
    iIIsImapRoutingSource_ImapDsNamingContext,  
    iIIsImapRoutingSource_ImapDsAccount,  
    iIIsImapRoutingSource_ImapDsPassword,  
    iIIsImapRoutingSource_AdminACL,  
    iIIsImapRoutingSource_AdminACLBin,  
    cIIsImapRoutingSource_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsImapRoutingSourceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pImapRoutingTableType;
         WCHAR *     pImapDsDataDirectory;
         WCHAR *     pImapDsDefaultMailRoot;
         WCHAR *     pImapDsBindType;
         WCHAR *     pImapDsSchemaType;
         WCHAR *     pImapDsHost;
         WCHAR *     pImapDsNamingContext;
         WCHAR *     pImapDsAccount;
         WCHAR *     pImapDsPassword;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsImapInfo                             L"IIsImapInfo"
#define TABLEID_IIsImapInfo                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsImapInfo                          (0L)
#define ExtendedVersion_IIsImapInfo                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsImapInfo {
    iIIsImapInfo_Location,  
    iIIsImapInfo_KeyType,  
    iIIsImapInfo_LogModuleList,  
    iIIsImapInfo_AdminACL,  
    iIIsImapInfo_AdminACLBin,  
    cIIsImapInfo_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsImapInfoRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pLogModuleList;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpRebuild                          L"IIsNntpRebuild"
#define TABLEID_IIsNntpRebuild                           (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpRebuild                       (0L)
#define ExtendedVersion_IIsNntpRebuild                   (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpRebuild {
    iIIsNntpRebuild_Location,  
    iIIsNntpRebuild_KeyType,  
    iIIsNntpRebuild_AdminACL,  
    iIIsNntpRebuild_AdminACLBin,  
    cIIsNntpRebuild_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpRebuildRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpSessions                         L"IIsNntpSessions"
#define TABLEID_IIsNntpSessions                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpSessions                      (0L)
#define ExtendedVersion_IIsNntpSessions                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpSessions {
    iIIsNntpSessions_Location,  
    iIIsNntpSessions_KeyType,  
    iIIsNntpSessions_AdminACL,  
    iIIsNntpSessions_AdminACLBin,  
    cIIsNntpSessions_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpSessionsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpFeeds                            L"IIsNntpFeeds"
#define TABLEID_IIsNntpFeeds                             (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpFeeds                         (0L)
#define ExtendedVersion_IIsNntpFeeds                     (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpFeeds {
    iIIsNntpFeeds_Location,  
    iIIsNntpFeeds_KeyType,  
    iIIsNntpFeeds_FeedPeerTempDirectory,  
    iIIsNntpFeeds_AdminACL,  
    iIIsNntpFeeds_AdminACLBin,  
    cIIsNntpFeeds_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpFeedsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pFeedPeerTempDirectory;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpFeed                             L"IIsNntpFeed"
#define TABLEID_IIsNntpFeed                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpFeed                          (0L)
#define ExtendedVersion_IIsNntpFeed                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpFeed {
    iIIsNntpFeed_Location,  
    iIIsNntpFeed_KeyType,  
    iIIsNntpFeed_FeedServerName,  
    iIIsNntpFeed_FeedType,  
    iIIsNntpFeed_FeedNewsgroups,  
    iIIsNntpFeed_FeedSecurityType,  
    iIIsNntpFeed_FeedAuthenticationType,  
    iIIsNntpFeed_FeedAccountName,  
    iIIsNntpFeed_FeedPassword,  
    iIIsNntpFeed_FeedStartTimeHigh,  
    iIIsNntpFeed_FeedStartTimeLow,  
    iIIsNntpFeed_FeedInterval,  
    iIIsNntpFeed_FeedAllowControlMsgs,  
    iIIsNntpFeed_FeedCreateAutomatically,  
    iIIsNntpFeed_FeedDisabled,  
    iIIsNntpFeed_FeedDistribution,  
    iIIsNntpFeed_FeedConcurrentSessions,  
    iIIsNntpFeed_FeedMaxConnectionAttempts,  
    iIIsNntpFeed_FeedUucpName,  
    iIIsNntpFeed_FeedTempDirectory,  
    iIIsNntpFeed_FeedNextPullHigh,  
    iIIsNntpFeed_FeedNextPullLow,  
    iIIsNntpFeed_FeedPeerTempDirectory,  
    iIIsNntpFeed_FeedPeerGapSize,  
    iIIsNntpFeed_FeedOutgoingPort,  
    iIIsNntpFeed_FeedFeedpairId,  
    iIIsNntpFeed_FeedHandshake,  
    iIIsNntpFeed_FeedAdminError,  
    iIIsNntpFeed_FeedErrParmMask,  
    iIIsNntpFeed_AdminACL,  
    iIIsNntpFeed_AdminACLBin,  
    cIIsNntpFeed_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpFeedRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pFeedServerName;
         ULONG *     pFeedType;
         WCHAR *     pFeedNewsgroups;
         ULONG *     pFeedSecurityType;
         ULONG *     pFeedAuthenticationType;
         WCHAR *     pFeedAccountName;
         WCHAR *     pFeedPassword;
         ULONG *     pFeedStartTimeHigh;
         ULONG *     pFeedStartTimeLow;
         ULONG *     pFeedInterval;
         ULONG *     pFeedAllowControlMsgs;
         ULONG *     pFeedCreateAutomatically;
         ULONG *     pFeedDisabled;
         WCHAR *     pFeedDistribution;
         ULONG *     pFeedConcurrentSessions;
         ULONG *     pFeedMaxConnectionAttempts;
         WCHAR *     pFeedUucpName;
         WCHAR *     pFeedTempDirectory;
         ULONG *     pFeedNextPullHigh;
         ULONG *     pFeedNextPullLow;
         WCHAR *     pFeedPeerTempDirectory;
         ULONG *     pFeedPeerGapSize;
         ULONG *     pFeedOutgoingPort;
         ULONG *     pFeedFeedpairId;
         ULONG *     pFeedHandshake;
         ULONG *     pFeedAdminError;
         ULONG *     pFeedErrParmMask;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpExpiration                       L"IIsNntpExpiration"
#define TABLEID_IIsNntpExpiration                        (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpExpiration                    (0L)
#define ExtendedVersion_IIsNntpExpiration                (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpExpiration {
    iIIsNntpExpiration_Location,  
    iIIsNntpExpiration_KeyType,  
    iIIsNntpExpiration_AdminACL,  
    iIIsNntpExpiration_AdminACLBin,  
    cIIsNntpExpiration_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpExpirationRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpExpire                           L"IIsNntpExpire"
#define TABLEID_IIsNntpExpire                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpExpire                        (0L)
#define ExtendedVersion_IIsNntpExpire                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpExpire {
    iIIsNntpExpire_Location,  
    iIIsNntpExpire_KeyType,  
    iIIsNntpExpire_ExpireSpace,  
    iIIsNntpExpire_ExpireTime,  
    iIIsNntpExpire_ExpireNewsgroups,  
    iIIsNntpExpire_ExpirePolicyName,  
    iIIsNntpExpire_AdminACL,  
    iIIsNntpExpire_AdminACLBin,  
    cIIsNntpExpire_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpExpireRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pExpireSpace;
         ULONG *     pExpireTime;
         WCHAR *     pExpireNewsgroups;
         WCHAR *     pExpirePolicyName;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpGroups                           L"IIsNntpGroups"
#define TABLEID_IIsNntpGroups                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpGroups                        (0L)
#define ExtendedVersion_IIsNntpGroups                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpGroups {
    iIIsNntpGroups_Location,  
    iIIsNntpGroups_KeyType,  
    iIIsNntpGroups_AdminACL,  
    iIIsNntpGroups_AdminACLBin,  
    cIIsNntpGroups_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpGroupsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpSessions                         L"IIsSmtpSessions"
#define TABLEID_IIsSmtpSessions                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpSessions                      (0L)
#define ExtendedVersion_IIsSmtpSessions                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpSessions {
    iIIsSmtpSessions_Location,  
    iIIsSmtpSessions_KeyType,  
    iIIsSmtpSessions_AdminACL,  
    iIIsSmtpSessions_AdminACLBin,  
    cIIsSmtpSessions_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpSessionsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsPop3Sessions                         L"IIsPop3Sessions"
#define TABLEID_IIsPop3Sessions                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsPop3Sessions                      (0L)
#define ExtendedVersion_IIsPop3Sessions                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsPop3Sessions {
    iIIsPop3Sessions_Location,  
    iIIsPop3Sessions_KeyType,  
    iIIsPop3Sessions_AdminACL,  
    iIIsPop3Sessions_AdminACLBin,  
    cIIsPop3Sessions_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsPop3SessionsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsImapSessions                         L"IIsImapSessions"
#define TABLEID_IIsImapSessions                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsImapSessions                      (0L)
#define ExtendedVersion_IIsImapSessions                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsImapSessions {
    iIIsImapSessions_Location,  
    iIIsImapSessions_KeyType,  
    iIIsImapSessions_AdminACL,  
    iIIsImapSessions_AdminACLBin,  
    cIIsImapSessions_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsImapSessionsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_FTP_TEMPLATE                        L"IIS_FTP_TEMPLATE"
#define TABLEID_IIS_FTP_TEMPLATE                         (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_FTP_TEMPLATE                     (0L)
#define ExtendedVersion_IIS_FTP_TEMPLATE                 (0L)

//-----------------Column Index Enums--------------   
enum eIIS_FTP_TEMPLATE {
    iIIS_FTP_TEMPLATE_Location,  
    iIIS_FTP_TEMPLATE_KeyType,  
    iIIS_FTP_TEMPLATE_IPSecurity,  
    iIIS_FTP_TEMPLATE_AnonymousOnly,  
    iIIS_FTP_TEMPLATE_AllowAnonymous,  
    iIIS_FTP_TEMPLATE_ServerComment,  
    cIIS_FTP_TEMPLATE_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_FTP_TEMPLATERow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pIPSecurity;
         ULONG *     pAnonymousOnly;
         ULONG *     pAllowAnonymous;
         WCHAR *     pServerComment;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_FTP_TEMPLATESETTINGS                L"IIS_FTP_TEMPLATESETTINGS"
#define TABLEID_IIS_FTP_TEMPLATESETTINGS                 (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_FTP_TEMPLATESETTINGS             (0L)
#define ExtendedVersion_IIS_FTP_TEMPLATESETTINGS         (0L)

//-----------------Column Index Enums--------------   
enum eIIS_FTP_TEMPLATESETTINGS {
    iIIS_FTP_TEMPLATESETTINGS_Location,  
    iIIS_FTP_TEMPLATESETTINGS_KeyType,  
    iIIS_FTP_TEMPLATESETTINGS_AccessFlags,  
    cIIS_FTP_TEMPLATESETTINGS_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_FTP_TEMPLATESETTINGSRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pAccessFlags;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_WEB_TEMPLATE                        L"IIS_WEB_TEMPLATE"
#define TABLEID_IIS_WEB_TEMPLATE                         (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_WEB_TEMPLATE                     (0L)
#define ExtendedVersion_IIS_WEB_TEMPLATE                 (0L)

//-----------------Column Index Enums--------------   
enum eIIS_WEB_TEMPLATE {
    iIIS_WEB_TEMPLATE_Location,  
    iIIS_WEB_TEMPLATE_KeyType,  
    iIIS_WEB_TEMPLATE_ServerComment,  
    cIIS_WEB_TEMPLATE_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_WEB_TEMPLATERow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pServerComment;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_WEB_TEMPLATESETTINGS                L"IIS_WEB_TEMPLATESETTINGS"
#define TABLEID_IIS_WEB_TEMPLATESETTINGS                 (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_WEB_TEMPLATESETTINGS             (0L)
#define ExtendedVersion_IIS_WEB_TEMPLATESETTINGS         (0L)

//-----------------Column Index Enums--------------   
enum eIIS_WEB_TEMPLATESETTINGS {
    iIIS_WEB_TEMPLATESETTINGS_Location,  
    iIIS_WEB_TEMPLATESETTINGS_KeyType,  
    iIIS_WEB_TEMPLATESETTINGS_IPSecurity,  
    iIIS_WEB_TEMPLATESETTINGS_AccessFlags,  
    iIIS_WEB_TEMPLATESETTINGS_AuthFlags,  
    iIIS_WEB_TEMPLATESETTINGS_AzEnable,  
    iIIS_WEB_TEMPLATESETTINGS_AzStoreName,  
    iIIS_WEB_TEMPLATESETTINGS_AzScopeName,  
    iIIS_WEB_TEMPLATESETTINGS_AzImpersonationLevel,  
    cIIS_WEB_TEMPLATESETTINGS_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_WEB_TEMPLATESETTINGSRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pIPSecurity;
         ULONG *     pAccessFlags;
         ULONG *     pAuthFlags;
         ULONG *     pAzEnable;
         WCHAR *     pAzStoreName;
         WCHAR *     pAzScopeName;
         ULONG *     pAzImpersonationLevel;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_ADMIN                               L"IIS_ADMIN"
#define TABLEID_IIS_ADMIN                                (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_ADMIN                            (0L)
#define ExtendedVersion_IIS_ADMIN                        (0L)

//-----------------Column Index Enums--------------   
enum eIIS_ADMIN {
    iIIS_ADMIN_Location,  
    iIIS_ADMIN_KeyType,  
    iIIS_ADMIN_MD_IISADMIN_EXTENSIONS,  
    iIIS_ADMIN_MD_METADATA_ID_REGISTRATION,  
    iIIS_ADMIN_AdminACL,  
    iIIS_ADMIN_AdminACLBin,  
    cIIS_ADMIN_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_ADMINRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pMD_IISADMIN_EXTENSIONS;
         WCHAR *     pMD_METADATA_ID_REGISTRATION;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_EVENTMANAGER                        L"IIS_EVENTMANAGER"
#define TABLEID_IIS_EVENTMANAGER                         (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_EVENTMANAGER                     (0L)
#define ExtendedVersion_IIS_EVENTMANAGER                 (0L)

//-----------------Column Index Enums--------------   
enum eIIS_EVENTMANAGER {
    iIIS_EVENTMANAGER_Location,  
    iIIS_EVENTMANAGER_KeyType,  
    iIIS_EVENTMANAGER_MD_0,  
    iIIS_EVENTMANAGER_AdminACL,  
    iIIS_EVENTMANAGER_AdminACLBin,  
    cIIS_EVENTMANAGER_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_EVENTMANAGERRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pMD_0;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_ROOT                                L"IIS_ROOT"
#define TABLEID_IIS_ROOT                                 (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_ROOT                             (0L)
#define ExtendedVersion_IIS_ROOT                         (0L)

//-----------------Column Index Enums--------------   
enum eIIS_ROOT {
    iIIS_ROOT_Location,  
    iIIS_ROOT_KeyType,  
    iIIS_ROOT_AdminACL,  
    cIIS_ROOT_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_ROOTRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_Global                              L"IIS_Global"
#define TABLEID_IIS_Global                               (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_Global                           (0L)
#define ExtendedVersion_IIS_Global                       (0L)

//-----------------Column Index Enums--------------   
enum eIIS_Global {
    iIIS_Global_Location,  
    iIIS_Global_KeyType,  
    iIIS_Global_SessionKey,  
    iIIS_Global_ChangeNumber,  
    iIIS_Global_HistoryMajorVersionNumber,  
    iIIS_Global_XMLSchemaTimeStamp,  
    iIIS_Global_BINSchemaTimeStamp,  
    cIIS_Global_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_GlobalRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pSessionKey;
         ULONG *     pChangeNumber;
         ULONG *     pHistoryMajorVersionNumber;
 unsigned char *     pXMLSchemaTimeStamp;
 unsigned char *     pBINSchemaTimeStamp;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpAlias                            L"IIsSmtpAlias"
#define TABLEID_IIsSmtpAlias                             (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpAlias                         (0L)
#define ExtendedVersion_IIsSmtpAlias                     (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpAlias {
    iIIsSmtpAlias_Location,  
    iIIsSmtpAlias_KeyType,  
    iIIsSmtpAlias_AdminACL,  
    iIIsSmtpAlias_AdminACLBin,  
    cIIsSmtpAlias_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpAliasRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpDL                               L"IIsSmtpDL"
#define TABLEID_IIsSmtpDL                                (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpDL                            (0L)
#define ExtendedVersion_IIsSmtpDL                        (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpDL {
    iIIsSmtpDL_Location,  
    iIIsSmtpDL_KeyType,  
    iIIsSmtpDL_AdminACL,  
    iIIsSmtpDL_AdminACLBin,  
    cIIsSmtpDL_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpDLRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpUser                             L"IIsSmtpUser"
#define TABLEID_IIsSmtpUser                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpUser                          (0L)
#define ExtendedVersion_IIsSmtpUser                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpUser {
    iIIsSmtpUser_Location,  
    iIIsSmtpUser_KeyType,  
    iIIsSmtpUser_AdminACL,  
    iIIsSmtpUser_AdminACLBin,  
    cIIsSmtpUser_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpUserRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsApplicationPool                      L"IIsApplicationPool"
#define TABLEID_IIsApplicationPool                       (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsApplicationPool                   (0L)
#define ExtendedVersion_IIsApplicationPool               (0L)

//-----------------Column Index Enums--------------   
enum eIIsApplicationPool {
    iIIsApplicationPool_Location,  
    iIIsApplicationPool_KeyType,  
    iIIsApplicationPool_PeriodicRestartTime,  
    iIIsApplicationPool_PeriodicRestartRequests,  
    iIIsApplicationPool_MaxProcesses,  
    iIIsApplicationPool_PingingEnabled,  
    iIIsApplicationPool_IdleTimeout,  
    iIIsApplicationPool_RapidFailProtection,  
    iIIsApplicationPool_SMPAffinitized,  
    iIIsApplicationPool_SMPProcessorAffinityMask,  
    iIIsApplicationPool_StartupTimeLimit,  
    iIIsApplicationPool_ShutdownTimeLimit,  
    iIIsApplicationPool_PingInterval,  
    iIIsApplicationPool_PingResponseTime,  
    iIIsApplicationPool_DisallowOverlappingRotation,  
    iIIsApplicationPool_DisallowRotationOnConfigChange,  
    iIIsApplicationPool_OrphanWorkerProcess,  
    iIIsApplicationPool_AppPoolQueueLength,  
    iIIsApplicationPool_CPUAction,  
    iIIsApplicationPool_CPULimit,  
    iIIsApplicationPool_CPUResetInterval,  
    iIIsApplicationPool_AppPoolIdentityType,  
    iIIsApplicationPool_WAMUserName,  
    iIIsApplicationPool_WAMUserPass,  
    iIIsApplicationPool_LogonMethod,  
    iIIsApplicationPool_PeriodicRestartMemory,  
    iIIsApplicationPool_PeriodicRestartPrivateMemory,  
    iIIsApplicationPool_AppPoolCommand,  
    iIIsApplicationPool_AppPoolState,  
    iIIsApplicationPool_AppPoolAutoStart,  
    iIIsApplicationPool_PeriodicRestartSchedule,  
    iIIsApplicationPool_RapidFailProtectionInterval,  
    iIIsApplicationPool_RapidFailProtectionMaxCrashes,  
    iIIsApplicationPool_Win32Error,  
    iIIsApplicationPool_OrphanActionExe,  
    iIIsApplicationPool_OrphanActionParams,  
    iIIsApplicationPool_LoadBalancerCapabilities,  
    iIIsApplicationPool_AutoShutdownAppPoolExe,  
    iIIsApplicationPool_AutoShutdownAppPoolParams,  
    iIIsApplicationPool_LogEventOnRecycle,  
    iIIsApplicationPool_AdminACL,  
    iIIsApplicationPool_AdminACLBin,  
    cIIsApplicationPool_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsApplicationPoolRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pPeriodicRestartTime;
         ULONG *     pPeriodicRestartRequests;
         ULONG *     pMaxProcesses;
         ULONG *     pPingingEnabled;
         ULONG *     pIdleTimeout;
         ULONG *     pRapidFailProtection;
         ULONG *     pSMPAffinitized;
         ULONG *     pSMPProcessorAffinityMask;
         ULONG *     pStartupTimeLimit;
         ULONG *     pShutdownTimeLimit;
         ULONG *     pPingInterval;
         ULONG *     pPingResponseTime;
         ULONG *     pDisallowOverlappingRotation;
         ULONG *     pDisallowRotationOnConfigChange;
         ULONG *     pOrphanWorkerProcess;
         ULONG *     pAppPoolQueueLength;
         ULONG *     pCPUAction;
         ULONG *     pCPULimit;
         ULONG *     pCPUResetInterval;
         ULONG *     pAppPoolIdentityType;
         WCHAR *     pWAMUserName;
         WCHAR *     pWAMUserPass;
         ULONG *     pLogonMethod;
         ULONG *     pPeriodicRestartMemory;
         ULONG *     pPeriodicRestartPrivateMemory;
         ULONG *     pAppPoolCommand;
         ULONG *     pAppPoolState;
         ULONG *     pAppPoolAutoStart;
         WCHAR *     pPeriodicRestartSchedule;
         ULONG *     pRapidFailProtectionInterval;
         ULONG *     pRapidFailProtectionMaxCrashes;
         ULONG *     pWin32Error;
         WCHAR *     pOrphanActionExe;
         WCHAR *     pOrphanActionParams;
         ULONG *     pLoadBalancerCapabilities;
         WCHAR *     pAutoShutdownAppPoolExe;
         WCHAR *     pAutoShutdownAppPoolParams;
         ULONG *     pLogEventOnRecycle;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsApplicationPools                     L"IIsApplicationPools"
#define TABLEID_IIsApplicationPools                      (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsApplicationPools                  (0L)
#define ExtendedVersion_IIsApplicationPools              (0L)

//-----------------Column Index Enums--------------   
enum eIIsApplicationPools {
    iIIsApplicationPools_Location,  
    iIIsApplicationPools_KeyType,  
    iIIsApplicationPools_PeriodicRestartTime,  
    iIIsApplicationPools_PeriodicRestartRequests,  
    iIIsApplicationPools_MaxProcesses,  
    iIIsApplicationPools_PingingEnabled,  
    iIIsApplicationPools_IdleTimeout,  
    iIIsApplicationPools_RapidFailProtection,  
    iIIsApplicationPools_SMPAffinitized,  
    iIIsApplicationPools_SMPProcessorAffinityMask,  
    iIIsApplicationPools_StartupTimeLimit,  
    iIIsApplicationPools_ShutdownTimeLimit,  
    iIIsApplicationPools_PingInterval,  
    iIIsApplicationPools_PingResponseTime,  
    iIIsApplicationPools_DisallowOverlappingRotation,  
    iIIsApplicationPools_DisallowRotationOnConfigChange,  
    iIIsApplicationPools_OrphanWorkerProcess,  
    iIIsApplicationPools_AppPoolQueueLength,  
    iIIsApplicationPools_CPUAction,  
    iIIsApplicationPools_CPULimit,  
    iIIsApplicationPools_CPUResetInterval,  
    iIIsApplicationPools_AppPoolIdentityType,  
    iIIsApplicationPools_WAMUserName,  
    iIIsApplicationPools_WAMUserPass,  
    iIIsApplicationPools_LogonMethod,  
    iIIsApplicationPools_PeriodicRestartMemory,  
    iIIsApplicationPools_PeriodicRestartPrivateMemory,  
    iIIsApplicationPools_AppPoolAutoStart,  
    iIIsApplicationPools_PeriodicRestartSchedule,  
    iIIsApplicationPools_RapidFailProtectionInterval,  
    iIIsApplicationPools_RapidFailProtectionMaxCrashes,  
    iIIsApplicationPools_Win32Error,  
    iIIsApplicationPools_OrphanActionExe,  
    iIIsApplicationPools_OrphanActionParams,  
    iIIsApplicationPools_LoadBalancerCapabilities,  
    iIIsApplicationPools_AutoShutdownAppPoolExe,  
    iIIsApplicationPools_AutoShutdownAppPoolParams,  
    iIIsApplicationPools_LogEventOnRecycle,  
    iIIsApplicationPools_AdminACL,  
    iIIsApplicationPools_AdminACLBin,  
    cIIsApplicationPools_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsApplicationPoolsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pPeriodicRestartTime;
         ULONG *     pPeriodicRestartRequests;
         ULONG *     pMaxProcesses;
         ULONG *     pPingingEnabled;
         ULONG *     pIdleTimeout;
         ULONG *     pRapidFailProtection;
         ULONG *     pSMPAffinitized;
         ULONG *     pSMPProcessorAffinityMask;
         ULONG *     pStartupTimeLimit;
         ULONG *     pShutdownTimeLimit;
         ULONG *     pPingInterval;
         ULONG *     pPingResponseTime;
         ULONG *     pDisallowOverlappingRotation;
         ULONG *     pDisallowRotationOnConfigChange;
         ULONG *     pOrphanWorkerProcess;
         ULONG *     pAppPoolQueueLength;
         ULONG *     pCPUAction;
         ULONG *     pCPULimit;
         ULONG *     pCPUResetInterval;
         ULONG *     pAppPoolIdentityType;
         WCHAR *     pWAMUserName;
         WCHAR *     pWAMUserPass;
         ULONG *     pLogonMethod;
         ULONG *     pPeriodicRestartMemory;
         ULONG *     pPeriodicRestartPrivateMemory;
         ULONG *     pAppPoolAutoStart;
         WCHAR *     pPeriodicRestartSchedule;
         ULONG *     pRapidFailProtectionInterval;
         ULONG *     pRapidFailProtectionMaxCrashes;
         ULONG *     pWin32Error;
         WCHAR *     pOrphanActionExe;
         WCHAR *     pOrphanActionParams;
         ULONG *     pLoadBalancerCapabilities;
         WCHAR *     pAutoShutdownAppPoolExe;
         WCHAR *     pAutoShutdownAppPoolParams;
         ULONG *     pLogEventOnRecycle;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_MBProperty                              L"MBProperty"
#define TABLEID_MBProperty                               (0xcc73c900L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_MBProperty                           (54L)
#define ExtendedVersion_MBProperty                       (0L)

//-----------------Column Index Enums--------------   
enum eMBProperty {
    iMBProperty_Name,  
    iMBProperty_Type,  
    iMBProperty_Attributes,  
    iMBProperty_Value,  
    iMBProperty_Location,  
    iMBProperty_ID,  
    iMBProperty_UserType,  
    iMBProperty_LocationID,  
    iMBProperty_Group,  
    cMBProperty_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tMBPropertyRow {
         WCHAR *     pName;
         ULONG *     pType;
         ULONG *     pAttributes;
 unsigned char *     pValue;
         WCHAR *     pLocation;
         ULONG *     pID;
         ULONG *     pUserType;
         ULONG *     pLocationID;
         ULONG *     pGroup;
};

enum eMBProperty_Type {
    eMBProperty_DWORD             	=	       1,	//(0x00000001)
    eMBProperty_STRING            	=	       2,	//(0x00000002)
    eMBProperty_BINARY            	=	       3,	//(0x00000003)
    eMBProperty_EXPANDSZ          	=	       4,	//(0x00000004)
    eMBProperty_MULTISZ           	=	       5	//(0x00000005)
};

enum eMBProperty_Attributes {
    fMBProperty_NO_ATTRIBUTES     	=	0x00000000,	//(0 decimal)
    fMBProperty_INHERIT           	=	0x00000001,	//(1 decimal)
    fMBProperty_SECURE            	=	0x00000004,	//(4 decimal)
    fMBProperty_REFERENCE         	=	0x00000008,	//(8 decimal)
    fMBProperty_VOLATILE          	=	0x00000010,	//(16 decimal)
    fMBProperty_INSERT_PATH       	=	0x00000040,	//(64 decimal)
    fMBProperty_LOCAL_MACHINE_ONLY	=	0x00000080,	//(128 decimal)
    fMBProperty_Attributes_Mask	= 0x000000dd
};

enum eMBProperty_UserType {
    eMBProperty_UNKNOWN_UserType  	=	       0,	//(0x00000000)
    eMBProperty_IIS_MD_UT_SERVER  	=	       1,	//(0x00000001)
    eMBProperty_IIS_MD_UT_FILE    	=	       2,	//(0x00000002)
    eMBProperty_IIS_MD_UT_WAM     	=	     100,	//(0x00000064)
    eMBProperty_ASP_MD_UT_APP     	=	     101	//(0x00000065)
};

enum eMBProperty_Group {
    eMBProperty_IIsConfigObject   	=	       0,	//(0x00000000)
    eMBProperty_IIsObject         	=	       1,	//(0x00000001)
    eMBProperty_IIsComputer       	=	       2,	//(0x00000002)
    eMBProperty_IIsWebService     	=	       3,	//(0x00000003)
    eMBProperty_IIsFtpService     	=	       4,	//(0x00000004)
    eMBProperty_IIsWebServer      	=	       5,	//(0x00000005)
    eMBProperty_IIsFtpServer      	=	       6,	//(0x00000006)
    eMBProperty_IIsWebFile        	=	       7,	//(0x00000007)
    eMBProperty_IIsWebDirectory   	=	       8,	//(0x00000008)
    eMBProperty_IIsWebVirtualDir  	=	       9,	//(0x00000009)
    eMBProperty_IIsFtpVirtualDir  	=	      10,	//(0x0000000a)
    eMBProperty_IIsFilter         	=	      11,	//(0x0000000b)
    eMBProperty_IIsFilters        	=	      12,	//(0x0000000c)
    eMBProperty_IIsCompressionScheme	=	      13,	//(0x0000000d)
    eMBProperty_IIsCompressionSchemes	=	      14,	//(0x0000000e)
    eMBProperty_IIsCertMapper     	=	      15,	//(0x0000000f)
    eMBProperty_IIsMimeMap        	=	      16,	//(0x00000010)
    eMBProperty_IIsLogModule      	=	      17,	//(0x00000011)
    eMBProperty_IIsLogModules     	=	      18,	//(0x00000012)
    eMBProperty_IIsCustomLogModule	=	      19,	//(0x00000013)
    eMBProperty_IIsWebInfo        	=	      20,	//(0x00000014)
    eMBProperty_IIsFtpInfo        	=	      21,	//(0x00000015)
    eMBProperty_IIsNntpService    	=	      22,	//(0x00000016)
    eMBProperty_IIsNntpServer     	=	      23,	//(0x00000017)
    eMBProperty_IIsNntpVirtualDir 	=	      24,	//(0x00000018)
    eMBProperty_IIsNntpInfo       	=	      25,	//(0x00000019)
    eMBProperty_IIsSmtpService    	=	      26,	//(0x0000001a)
    eMBProperty_IIsSmtpServer     	=	      27,	//(0x0000001b)
    eMBProperty_IIsSmtpVirtualDir 	=	      28,	//(0x0000001c)
    eMBProperty_IIsSmtpDomain     	=	      29,	//(0x0000001d)
    eMBProperty_IIsSmtpRoutingSource	=	      30,	//(0x0000001e)
    eMBProperty_IIsSmtpInfo       	=	      31,	//(0x0000001f)
    eMBProperty_IIsPop3Service    	=	      32,	//(0x00000020)
    eMBProperty_IIsPop3Server     	=	      33,	//(0x00000021)
    eMBProperty_IIsPop3VirtualDir 	=	      34,	//(0x00000022)
    eMBProperty_IIsPop3RoutingSource	=	      35,	//(0x00000023)
    eMBProperty_IIsPop3Info       	=	      36,	//(0x00000024)
    eMBProperty_IIsImapService    	=	      37,	//(0x00000025)
    eMBProperty_IIsImapServer     	=	      38,	//(0x00000026)
    eMBProperty_IIsImapVirtualDir 	=	      39,	//(0x00000027)
    eMBProperty_IIsImapRoutingSource	=	      40,	//(0x00000028)
    eMBProperty_IIsImapInfo       	=	      41,	//(0x00000029)
    eMBProperty_IIsNntpRebuild    	=	      42,	//(0x0000002a)
    eMBProperty_IIsNntpSessions   	=	      43,	//(0x0000002b)
    eMBProperty_IIsNntpFeeds      	=	      44,	//(0x0000002c)
    eMBProperty_IIsNntpFeed       	=	      45,	//(0x0000002d)
    eMBProperty_IIsNntpExpire     	=	      46,	//(0x0000002e)
    eMBProperty_IIsNntpExpiration 	=	      47,	//(0x0000002f)
    eMBProperty_IIsNntpGroups     	=	      48,	//(0x00000030)
    eMBProperty_IIsSmtpSessions   	=	      49,	//(0x00000031)
    eMBProperty_IIsPop3Sessions   	=	      50,	//(0x00000032)
    eMBProperty_IIsImapSessions   	=	      51,	//(0x00000033)
    eMBProperty_IIS_Global        	=	      52,	//(0x00000034)
    eMBProperty_IIS_ROOT          	=	      53,	//(0x00000035)
    eMBProperty_IIS_FTP_TEMPLATE  	=	      54,	//(0x00000036)
    eMBProperty_IIS_FTP_TEMPLATESETTINGS	=	      55,	//(0x00000037)
    eMBProperty_IIS_WEB_TEMPLATE  	=	      56,	//(0x00000038)
    eMBProperty_IIS_WEB_TEMPLATESETTINGS	=	      57,	//(0x00000039)
    eMBProperty_IIS_ADMIN         	=	      58,	//(0x0000003a)
    eMBProperty_IIS_EVENTMANAGER  	=	      59,	//(0x0000003b)
    eMBProperty_IIsSmtpAlias      	=	      60,	//(0x0000003c)
    eMBProperty_IIsSmtpDL         	=	      61,	//(0x0000003d)
    eMBProperty_IIsSmtpUser       	=	      62,	//(0x0000003e)
    eMBProperty_IIsApplicationPool	=	      63,	//(0x0000003f)
    eMBProperty_IIsApplicationPools	=	      64,	//(0x00000040)
    eMBProperty_IIsInheritedProperties	=	      65,	//(0x00000041)
    eMBProperty_Custom            	=	      66	//(0x00000042)
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_MBPropertyDiff                          L"MBPropertyDiff"
#define TABLEID_MBPropertyDiff                           (0x95d76f00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_MBPropertyDiff                       (0L)
#define ExtendedVersion_MBPropertyDiff                   (0L)

//-----------------Column Index Enums--------------   
enum eMBPropertyDiff {
    iMBPropertyDiff_Name,  
    iMBPropertyDiff_Type,  
    iMBPropertyDiff_Attributes,  
    iMBPropertyDiff_Value,  
    iMBPropertyDiff_Location,  
    iMBPropertyDiff_ID,  
    iMBPropertyDiff_UserType,  
    iMBPropertyDiff_LocationID,  
    iMBPropertyDiff_Directive,  
    iMBPropertyDiff_Group,  
    cMBPropertyDiff_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tMBPropertyDiffRow {
         WCHAR *     pName;
         ULONG *     pType;
         ULONG *     pAttributes;
 unsigned char *     pValue;
         WCHAR *     pLocation;
         ULONG *     pID;
         ULONG *     pUserType;
         ULONG *     pLocationID;
         ULONG *     pDirective;
         ULONG *     pGroup;
};

enum eMBPropertyDiff_Directive {
    eMBPropertyDiff_Insert        	=	       1,	//(0x00000001)
    eMBPropertyDiff_Update        	=	       2,	//(0x00000002)
    eMBPropertyDiff_Delete        	=	       3,	//(0x00000003)
    eMBPropertyDiff_DeleteNode    	=	       4	//(0x00000004)
};


#endif //__TABLEINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\coremacros.h ===
#pragma once

//+----------------------------------------------------------------------------
//
//  TRACE  -- send output to the Debugger window
//
//  TRACE() is like printf(), with some exceptions. First, it writes to the
//  debugger window, not to stdout. Second, it disappears when _DEBUG is not
//  set(actually, its arguments turn into a comma expression when _DEBUG is
//  not set, but that usually amounts to the same thing.
//
//	Example
//
//	hr = SomeApi(params, somemoreparams);
//	if(FAILED(hr))
//	{
//		TRACE(L"SomeApi failed with hr = %08x", hr);
//		return hr;
//	}
//
//-----------------------------------------------------------------------------

#include <dbgutil.h>

// helper macro to get the line number and file name
#define __W_HELPER(x) L ## x
#define W(x) __W_HELPER(x)

//+----------------------------------------------------------------------------
//
//  ASSERT  -- displays a dialog box in free builds. It does nothing in
//	debug builds. The dialog box contains the line number, file name, and the stack
//  if symbols are available
//
//	This macro should be used only to check for conditions that should never occur
//
//-----------------------------------------------------------------------------
#undef ASSERT
#ifdef _DEBUG

    #define ASSERT(_bool)   DBG_ASSERT((_bool))
    #define VERIFY(_bool)   DBG_ASSERT((_bool))

#else //_RELASE build

    #define ASSERT(_bool)
    #define VERIFY(_bool)   ((void)(_bool))

#endif

#if defined(__cplusplus)
//-------------------------------------------------------------------------
//
//	Memory allocation functions: they just point to com memory allocator
//	functions for now, but we can change them later
//
//-------------------------------------------------------------------------

inline void* __cdecl operator new[] (size_t cb)
{
	return CoTaskMemAlloc(cb);
}

inline void* __cdecl operator new (size_t cb)
{
	return CoTaskMemAlloc(cb);
}

inline void __cdecl operator delete [] (void* pv)
{
	CoTaskMemFree(pv);
}

inline void __cdecl operator delete (void* pv)
{
	CoTaskMemFree(pv);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\eventlogger.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name:
    EventLogger.h

$Header: $

Abstract: This class implements ICatalogErrorLogger2 interface and
            sends error information to the NT EventLog

Author:
    stephenr 	4/26/2001		Initial Release

Revision History:

--**************************************************************************/

#pragma once

class EventLogger : public ICatalogErrorLogger2
{
public:
    EventLogger(ICatalogErrorLogger2 *pNextLogger=0) : m_cRef(0), m_spNextLogger(pNextLogger){}
    virtual ~EventLogger(){}

//IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv)
    {
        if (NULL == ppv)
            return E_INVALIDARG;
        *ppv = NULL;

        if (riid == IID_ICatalogErrorLogger2)
            *ppv = (ICatalogErrorLogger2*) this;
        else if (riid == IID_IUnknown)
            *ppv = (ICatalogErrorLogger2*) this;

        if (NULL == *ppv)
            return E_NOINTERFACE;

        ((ICatalogErrorLogger2*)this)->AddRef ();
        return S_OK;
    }
	STDMETHOD_(ULONG,AddRef)		()
    {
        return InterlockedIncrement((LONG*) &m_cRef);
    }
	STDMETHOD_(ULONG,Release)		()
    {
        long cref = InterlockedDecrement((LONG*) &m_cRef);
        if (cref == 0)
            delete this;

        return cref;
    }

//ICatalogErrorLogger2
	STDMETHOD(ReportError) (ULONG      i_BaseVersion_DETAILEDERRORS,
                            ULONG      i_ExtendedVersion_DETAILEDERRORS,
                            ULONG      i_cDETAILEDERRORS_NumberOfColumns,
                            ULONG *    i_acbSizes,
                            LPVOID *   i_apvValues);
private:
    ULONG                           m_cRef;
    CComPtr<ICatalogErrorLogger2>   m_spNextLogger;

    void Close();
    void Open();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\fixedtableheap.h ===
//  Copyright (C) 2000 Microsoft Corporation.  All rights reserved.
//  Filename:       FixedTableHeap.h
//  Author:         Stephenr
//  Date Created:   6/20/00
//  Description:    The previous implementation of the fixed tables (which mostly included
//                  meta tables like DatabaseMeta, TableMeta etc.) included static arrays
//                  of types DatabaseMeta, TableMeta.  The problem with this method is,
//                  since it is not a heap, the size of each array had to be statically
//                  declared.  Also, each array needed a unique signature so the PE fixup
//                  could identify the location of each array within the DLL.
//
//                  This new approach needs only one unique signature for the entire heap.
//                  Also, the heap needs to be declared as a static size; but the individual
//                  pieces within the heap, like the DatabaseMeta and TableMeta arrays,
//                  aren't presized.  So there's only one thing to resize if we run out of
//                  heap space.

#pragma once

struct ColumnMetaPrivate
{
    ULONG                       ciTagMeta;              //Count of Tags - Only valid for UI4s
    ULONG                       iTagMeta;               //Index into aTagMeta - Only valid for UI4s
    ULONG                       iIndexName;             //IndexName of a single column index (for this column)
};
const kciColumnMetaPrivateColumns   = sizeof(ColumnMetaPrivate)/sizeof(ULONG);

struct ColumnMeta : public ColumnMetaPublic, public ColumnMetaPrivate{};
const kciColumnMetaColumns          = sizeof(ColumnMeta)/sizeof(ULONG);



struct DatabaseMetaPrivate
{
    ULONG                       iSchemaBlob;            //Index into aBytes
    ULONG                       cbSchemaBlob;           //Count of Bytes of the SchemaBlob
    ULONG                       iNameHeapBlob;          //Index into aBytes
    ULONG                       cbNameHeapBlob;         //Count of Bytes of the SchemaBlob
    ULONG                       iTableMeta;             //Index into aTableMeta
    ULONG                       iGuidDid;               //Index to aGuid where the guid is the Database InternalName cast as a GUID and padded with 0x00s.
};
const kciDatabaseMetaPrivateColumns = sizeof(DatabaseMetaPrivate)/sizeof(ULONG);

struct DatabaseMeta : public DatabaseMetaPublic, public DatabaseMetaPrivate{};
const kciDatabaseMetaColumns        = sizeof(DatabaseMeta)/sizeof(ULONG);



struct IndexMetaPrivate
{
    ULONG                       iHashTable;             //Index into the FixedTableHeap where the Hash table
};
const unsigned long kciIndexMetaPrivateColumns = sizeof(IndexMetaPrivate)/sizeof(ULONG);
struct IndexMeta : public IndexMetaPublic, public IndexMetaPrivate{};
const unsigned long kciIndexMetaColumns = sizeof(IndexMeta)/sizeof(ULONG);



const unsigned long kciQueryMetaPrivateColumns = 0;
typedef QueryMetaPublic QueryMeta;
const unsigned long kciQueryMetaColumns = sizeof(QueryMeta)/sizeof(ULONG);



const unsigned long kciRelationMetaPrivateColumns = 0;
typedef RelationMetaPublic RelationMeta;
const unsigned long kciRelationMetaColumns = sizeof(RelationMeta)/sizeof(ULONG);



const unsigned long kciServerWiringMetaPrivateColumns = 0;
typedef ServerWiringMetaPublic ServerWiringMeta;
const unsigned long kciServerWiringMetaColumns = sizeof(ServerWiringMeta)/sizeof(ULONG);



struct TableMetaPrivate
{
    ULONG                       ciRows;                 //Count of Rows in the Fixed Table (which if the fixed table is meta, this is also the number of columns in the table that the meta describes).
    ULONG                       iColumnMeta;            //Index into aColumnMeta
    ULONG                       iFixedTable;            //Index into g_aFixedTable
    ULONG                       cPrivateColumns;        //This is the munber of private columns (private + ciColumns = totalColumns), this is needed for fixed table pointer arithmetic
    ULONG                       cIndexMeta;             //The number of IndexMeta entries in this table
    ULONG                       iIndexMeta;             //Index into aIndexMeta
    ULONG                       iHashTableHeader;       //If the table is a fixed table, then it will have a hash table.
    ULONG                       nTableID;               //This is a 24 bit Hash of the Table name.
    ULONG                       iServerWiring;          //Index into the ServerWiringHeap (this is a temporary hack for CatUtil)
    ULONG                       cServerWiring;          //Count of ServerWiring (this is a temporary hack for CatUtil)
};
const kciTableMetaPrivateColumns    = sizeof(TableMetaPrivate)/sizeof(ULONG);

struct TableMeta : public TableMetaPublic, public TableMetaPrivate{};
const kciTableMetaColumns           = sizeof(TableMeta)/sizeof(ULONG);



const unsigned long kciTagMetaPrivateColumns = 0;
typedef TagMetaPublic TagMeta;
const unsigned long kciTagMetaColumns = sizeof(TagMeta)/sizeof(ULONG);



//All hash tables begin with a HashTableHeader that indicates the Modulo and the total size of the HashTable (in number of HashIndexes that follow
//the HashTableHeader).  The size should be equal to Modulo if there are NO HashIndex collisions.  If there are NO HashIndex collisions, then all
//of the HashedIndex.iNext members should be 0.  If there are collisions, all iNext values should be greater than or equal to Modulo.
struct HashedIndex
{
public:
    HashedIndex() : iNext((ULONG)-1), iOffset((ULONG)-1){}

    ULONG       iNext;  //If the hash value is not unique then this points to the next HashedIndex with the same hash value
    ULONG       iOffset;//Index offset into some heap (defined by the hash table itself)
};

class HashTableHeader
{
public:
    ULONG       Modulo;
    ULONG       Size;//This is the size in number of HashedIndexes that follow the HashTableHeader

    const HashedIndex * Get_HashedIndex(ULONG iHash) const
    {
        return (reinterpret_cast<const HashedIndex *>(this) + 1 + iHash%Modulo);
    }
    const HashedIndex * Get_NextHashedIndex(const HashedIndex *pHI) const
    {
        ASSERT(pHI->iNext >= Modulo);
        if(-1 == pHI->iNext)
            return 0;
        else
            return (reinterpret_cast<const HashedIndex *>(this) + 1 + pHI->iNext);
    }

private:
    HashTableHeader(){}//We never construct one of these.  We always cast from some pointer.
};


//The FixedTableHeap is layed out as follows, the fixed length data comes first
//All indexes listed below are byte offsets from the beginning of the FixedTableHeap.  All indexes within the structs are indexes within
//other structs.  For example, DatabaseMeta has a provate column that gives an index to the first table belonging to the database.  That
//index is a TableMeta struct array index (&aTableMeta[index]); it is NOT a byte offset.
/*
0   ULONG           kFixedTableHeapSignature0
1   ULONG           kFixedTableHeapSignature1
2   ULONG           kFixedTableHeapKey
3   ULONG           kFixedTableHeapVersion
4   ULONG           kcbHeap
5   ULONG           EndOfHeap                                       This is the byte offset just beyond the heap.  All indexes should be less than this (this is basically just the size of the heap)

6   ULONG           iColumnMeta                                     This is the byte offset to the aColumnMeta
7   ULONG           cColumnMeta

8   ULONG           iDatabaseMeta
9   ULONG           cDatabaseMeta

A   ULONG           iHashTableHeap
B   ULONG           cbHashTableHeap                                 Size of the HashTableHeap in count of bytes

C   ULONG           iIndexMeta
D   ULONG           cIndexMeta

E   ULONG           iPooledHeap                                     All data is stored in a pooled heap (including UI4s)
F   ULONG           cbPooledHeap                                    Size of the Pooled Heap in count of bytes

10  ULONG           iQueryMeta
11  ULONG           cQueryMeta

12  ULONG           iRelationMeta
13  ULONG           cRelationMeta

14  ULONG           iServerWiringMeta
15  ULONG           cServerWiringMeta

16  ULONG           iTableMeta
17  ULONG           cTableMeta

18  ULONG           iTagMeta
19  ULONG           cTagMeta

1A  ULONG           iULONG                                          Pool For Non Meta Tables
1B  ULONG           cULONG

                              //0x400 ULONGs in a page
    ULONG           aReserved[0x400 - 0x1C]                         This dummy array puts the ULONG pool on a page boundary, this is important for FixedPackedSchema which is located at the beginning of the ULONG pool
------------------------------------Page Boundary------------------------------------
    ULONG               aULONG              [cULONG             ]   FixedPackedSchema pool is always located first in the ULONG pool.
    ColumnMeta          aColumnMeta         [cColumnMeta        ]
    DatabaseMeta        aDatabaseMeta       [cDatabaseMeta      ]
    HashedIndex         HashTableHeap       [cbHashTableHeap    ]
    IndexMeta           aIndexMeta          [cIndexMeta         ]
    unsigned char       PooledDataHeap      [cbPooledDataHeap   ]
    QueryMeta           aQueryMeta          [cQueryMeta         ]
    RelationMeta        aRelationMeta       [cRelationMeta      ]
    ServerWiringMeta    aServerWiringMeta   [cServerWiringMeta  ]
    TableMeta           aTableMeta          [cTableMeta         ]
    TagMeta             aTagMeta            [cTagMeta           ]
*/

//WARNING!! If we changes the following two lines to 'const ULONG', the signatures can appear in two places within Catalog.dll.  So leave them as '#define'.
#define      kFixedTableHeapSignature0   (0x207be016)
#define      kFixedTableHeapSignature1   (0xe0182086)
const ULONG  kFixedTableHeapKey        = sizeof(ColumnMeta) ^ (sizeof(DatabaseMeta)<<3) ^ (sizeof(IndexMeta)<<6) ^ (sizeof(QueryMeta)<<9) ^ (sizeof(RelationMeta)<<12)
                                         ^ (sizeof(ServerWiringMeta)<<15) ^ (sizeof(TableMeta)<<18) ^ (sizeof(TagMeta)<<21);
const ULONG  kFixedTableHeapVersion    = 0x00000036;
//248392 bytes is the total size reserved for the heap.  EndOfHeap give the amount of use space
const ULONG  kcbFixedTableHeap         = 1250536;

class FixedTableHeap
{
public:
    ULONG                       Get_HeapSignature0      ()              const {return *reinterpret_cast<const ULONG *>(this);}
    ULONG                       Get_HeapSignature1      ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x01);}
    ULONG                       Get_HeapKey             ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x02);}
    ULONG                       Get_HeapVersion         ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x03);}
    ULONG                       Get_cbHeap              ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x04);}
    ULONG                       Get_EndOfHeap           ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x05);}

    ULONG                       Get_iColumnMeta         ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x06);}
    ULONG                       Get_cColumnMeta         ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x07);}

    ULONG                       Get_iDatabaseMeta       ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x08);}
    ULONG                       Get_cDatabaseMeta       ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x09);}

    ULONG                       Get_iHashTableHeap      ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x0A);}
    ULONG                       Get_cbHashTableHeap     ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x0B);}

    ULONG                       Get_iIndexMeta          ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x0C);}
    ULONG                       Get_cIndexMeta          ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x0D);}

    ULONG                       Get_iPooledHeap         ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x0E);}
    ULONG                       Get_cbPooledHeap        ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x0F);}

    ULONG                       Get_iQueryMeta          ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x10);}
    ULONG                       Get_cQueryMeta          ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x11);}

    ULONG                       Get_iRelationMeta       ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x12);}
    ULONG                       Get_cRelationMeta       ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x13);}

    ULONG                       Get_iServerWiringMeta   ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x14);}
    ULONG                       Get_cServerWiringMeta   ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x15);}

    ULONG                       Get_iTableMeta          ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x16);}
    ULONG                       Get_cTableMeta          ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x17);}

    ULONG                       Get_iTagMeta            ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x18);}
    ULONG                       Get_cTagMeta            ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x19);}

    ULONG                       Get_iULONG              ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x1A);}
    ULONG                       Get_cULONG              ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x1B);}

    const ULONG *               Get_pReserved           (ULONG i=0)     const {ASSERT(i<(0x400 - 0x1C));return (reinterpret_cast<const ULONG *>(this) + 0x1C + i);}

    //The zeroth entry is reserved for NULL
    const unsigned char    *    Get_PooledDataHeap      ()              const {return  reinterpret_cast<const unsigned char *>(this) + Get_iPooledHeap();}
    const unsigned char    *    Get_PooledData          (ULONG iPool)   const {ASSERT(iPool < Get_cbPooledHeap());return 0==iPool ? 0 : (Get_PooledDataHeap()+iPool);}
    ULONG                       Get_PooledDataSize      (ULONG iPool)   const {ASSERT(iPool < Get_cbPooledHeap());return 0==iPool ? 0 : reinterpret_cast<const ULONG *>(Get_PooledDataHeap()+iPool)[-1];}

    const HashedIndex      *    Get_HashTableHeap       ()              const {return  reinterpret_cast<const HashedIndex *>(reinterpret_cast<const unsigned char *>(this) + Get_iHashTableHeap());}
    const HashTableHeader  *    Get_HashHeader          (ULONG iHash)   const {ASSERT(iHash < Get_cbHashTableHeap());return (reinterpret_cast<const HashTableHeader *>(Get_HashTableHeap()+iHash));}
    const HashedIndex      *    Get_HashedIndex         (ULONG iHash)   const {ASSERT(iHash < Get_cbHashTableHeap());return Get_HashTableHeap()+iHash;}

    const ColumnMeta       *    Get_aColumnMeta         (ULONG iRow=0)  const {ASSERT(iRow < Get_cColumnMeta      ());return reinterpret_cast<const ColumnMeta       *>(reinterpret_cast<const unsigned char *>(this) + Get_iColumnMeta      ()) + iRow;}
    const DatabaseMeta     *    Get_aDatabaseMeta       (ULONG iRow=0)  const {ASSERT(iRow < Get_cDatabaseMeta    ());return reinterpret_cast<const DatabaseMeta     *>(reinterpret_cast<const unsigned char *>(this) + Get_iDatabaseMeta    ()) + iRow;}
    const IndexMeta        *    Get_aIndexMeta          (ULONG iRow=0)  const {ASSERT(iRow < Get_cIndexMeta       ());return reinterpret_cast<const IndexMeta        *>(reinterpret_cast<const unsigned char *>(this) + Get_iIndexMeta       ()) + iRow;}
    const QueryMeta        *    Get_aQueryMeta          (ULONG iRow=0)  const {ASSERT(iRow < Get_cQueryMeta       ());return reinterpret_cast<const QueryMeta        *>(reinterpret_cast<const unsigned char *>(this) + Get_iQueryMeta       ()) + iRow;}
    const RelationMeta     *    Get_aRelationMeta       (ULONG iRow=0)  const {ASSERT(iRow < Get_cRelationMeta    ());return reinterpret_cast<const RelationMeta     *>(reinterpret_cast<const unsigned char *>(this) + Get_iRelationMeta    ()) + iRow;}
    const ServerWiringMeta *    Get_aServerWiringMeta   (ULONG iRow=0)  const {ASSERT(iRow < Get_cServerWiringMeta());return reinterpret_cast<const ServerWiringMeta *>(reinterpret_cast<const unsigned char *>(this) + Get_iServerWiringMeta()) + iRow;}
    const TableMeta        *    Get_aTableMeta          (ULONG iRow=0)  const {ASSERT(iRow < Get_cTableMeta       ());return reinterpret_cast<const TableMeta        *>(reinterpret_cast<const unsigned char *>(this) + Get_iTableMeta       ()) + iRow;}
    const TagMeta          *    Get_aTagMeta            (ULONG iRow=0)  const {ASSERT(iRow < Get_cTagMeta         ());return reinterpret_cast<const TagMeta          *>(reinterpret_cast<const unsigned char *>(this) + Get_iTagMeta         ()) + iRow;}
    const ULONG            *    Get_aULONG              (ULONG iRow=0)  const {ASSERT(iRow < Get_cULONG           ());return reinterpret_cast<const ULONG            *>(reinterpret_cast<const unsigned char *>(this) + Get_iULONG           ()) + iRow;}

    ULONG                       FindTableMetaRow         (LPCWSTR InternalName) const //This should be used to get MetaTables only.  Linear search for other tables will be too expensive.
    {
        ULONG iTableMeta;
        for(iTableMeta=0; iTableMeta<Get_cTableMeta(); ++iTableMeta)
        {
            if(0 == _wcsicmp(reinterpret_cast<const WCHAR *>(Get_PooledData(Get_aTableMeta(iTableMeta)->InternalName)), InternalName))
                return iTableMeta;
        }
        return (ULONG)-1;
    }

    //Utility functions
    ULONG                       UI4FromIndex            (ULONG i)       const {return *reinterpret_cast<const ULONG *>(Get_PooledData(i));}
    const WCHAR *               StringFromIndex         (ULONG i)       const {return  reinterpret_cast<const WCHAR *>(Get_PooledData(i));}
    const unsigned char *       BytesFromIndex          (ULONG i)       const {return Get_PooledData(i);}
    const GUID *                GuidFromIndex           (ULONG i)       const {return  reinterpret_cast<const GUID *>(Get_PooledData(i));}

    bool                        IsValid() const
    {
        if(IsBadReadPtr(this, 4096))
            return false;
        if( reinterpret_cast<const unsigned char *>(this)[0] != 0x16 ||
            reinterpret_cast<const unsigned char *>(this)[1] != 0xe0 ||
            reinterpret_cast<const unsigned char *>(this)[2] != 0x7b ||
            reinterpret_cast<const unsigned char *>(this)[3] != 0x20 ||
            reinterpret_cast<const unsigned char *>(this)[4] != 0x86 ||
            reinterpret_cast<const unsigned char *>(this)[5] != 0x20 ||
            reinterpret_cast<const unsigned char *>(this)[6] != 0x18 ||
            reinterpret_cast<const unsigned char *>(this)[7] != 0xe0)
            return false;
        if( Get_HeapKey()       != kFixedTableHeapKey       ||
            Get_HeapVersion()   != kFixedTableHeapVersion   ||
            IsBadReadPtr(this, Get_EndOfHeap())             ||
            IsBadReadPtr(this, Get_cbHeap()))
            return false;
        if( Get_cColumnMeta() <  (  kciColumnMetaPublicColumns      +
                                    kciDatabaseMetaPublicColumns    +
                                    kciIndexMetaPublicColumns       +
                                    kciQueryMetaPublicColumns       +
                                    kciRelationMetaPublicColumns    +
                                    kciServerWiringMetaPublicColumns+
                                    kciTableMetaPublicColumns       +
                                    kciTagMetaPublicColumns))
            return false;
        return true;
    }
private:
    FixedTableHeap(){} //This is private bacause we never instantiate one of these objects.  We only cast to one of these.
};

//@@@TODO This should go away
typedef HRESULT( __stdcall *GETFIXEDTABLEHEAPSIGNATURES)(ULONG *signature0, ULONG *signature1, ULONG *cbFixedTableHeap);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\hash.h ===
#pragma once

//These functions generate a 32 bit hash value given any variable type.  The only pointer types that are supported are 'LPCWSTR' and 'unsigned char *'.
//Everything else should be passed by reference.  If you pass a pointer type (other than the two supported types), the Hash template will hash the
//pointer itself, NOT its contents.  That may be what you want;  if so, go for it.


//Hashing is done on a case insensitive basis, so this ToLower function uses a lookup table to convert a wide char to its lowercase version without
//the need for an 'if' condition.
inline WCHAR ToLower(WCHAR i_wchar)
{
    //The lower 127 ascii are mapped to their lowercase ascii value.  Note only 0x41('A') - 0x5a('Z') are changed.  And these are mapped to 0x60('a') - 0x7a('z')
    static unsigned char kToLower[128] = 
    { //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
    /*00*/  0x00,   0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,   0x09,   0x0a,   0x0b,   0x0c,   0x0d,   0x0e,   0x0f,
    /*10*/  0x10,   0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,   0x19,   0x1a,   0x1b,   0x1c,   0x1d,   0x1e,   0x1f,
    /*20*/  0x20,   0x21,   0x22,   0x23,   0x24,   0x25,   0x26,   0x27,   0x28,   0x29,   0x2a,   0x2b,   0x2c,   0x2d,   0x2e,   0x2f,
    /*30*/  0x30,   0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,   0x39,   0x3a,   0x3b,   0x3c,   0x3d,   0x3e,   0x3f,
    /*40*/  0x40,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,   0x67,   0x68,   0x69,   0x6a,   0x6b,   0x6c,   0x6d,   0x6e,   0x6f,
    /*50*/  0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7a,   0x5b,   0x5c,   0x5d,   0x5e,   0x5f,
    /*60*/  0x60,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,   0x67,   0x68,   0x69,   0x6a,   0x6b,   0x6c,   0x6d,   0x6e,   0x6f,
    /*70*/  0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7a,   0x7b,   0x7c,   0x7d,   0x7e,   0x7f,
    };

    return (kToLower[i_wchar & 0x007f] | (i_wchar & ~0x007f));
}


//Warning! For effeciency users should never rotate by more than 32 bits
inline ULONG RotateLeft(ULONG Value, ULONG cBits)
{
#ifdef _X86_
    _asm
    {
        mov         eax, Value
        mov         ecx, cBits
        rol         eax, cl
    }
#else
    return (Value << cBits) | (Value >> (32-cBits));
#endif
}


inline ULONG HashCaseSensitive(LPCWSTR i_pKey, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    //Case sensitive hash
    while(*i_pKey) i_Hash = RotateLeft(i_Hash,2)^(*i_pKey++);
    return i_Hash;
}


inline ULONG HashCaseSensitive(LPWSTR i_pKey, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    return HashCaseSensitive(reinterpret_cast<LPCWSTR>(i_pKey), i_Hash);
}

inline ULONG Hash(LPCWSTR i_pKey, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    //Case insensitive hash
#ifdef _X86_
    WCHAR wchTemp;
    while(*i_pKey)
    {
        wchTemp = ToLower(*i_pKey++);//result is in eax
        _asm
        {
            movzx       esi,    wchTemp
            mov         eax,    i_Hash
            mov         ecx,    2
            rol         eax,    cl
            xor         eax,    esi
            mov         i_Hash, eax
        }
    }
#else
    while(*i_pKey) i_Hash = RotateLeft(i_Hash,2)^ToLower(*i_pKey++);
#endif
    return i_Hash;
}

inline ULONG Hash(LPWSTR i_pKey, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    //Case insensitive hash
    return Hash(reinterpret_cast<LPCWSTR>(i_pKey), i_Hash);
}


inline ULONG Hash(const unsigned char *i_pKey, unsigned long i_cb, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    while(i_cb--) i_Hash = RotateLeft(i_Hash,2)^(*i_pKey++);
    return i_Hash;
}


inline ULONG Hash(unsigned char *i_pKey, unsigned long i_cb, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    return Hash(static_cast<const unsigned char *>(i_pKey), i_cb, i_Hash);
}


template<class T> ULONG Hash(T i_Key, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    return Hash(reinterpret_cast<const unsigned char *>(&i_Key), sizeof(T), i_Hash);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\cfgarray.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name:
    cfgarray.h

$Header: $

Abstract:

Author:
    marcelv     5/9/2001 12:28:08       Initial Release

Revision History:

--**************************************************************************/

#pragma once

template <class T>
class CCfgArray
{
public:
    CCfgArray () : m_aData(0), m_cElements(0), m_cSize(0) {}
    ~CCfgArray ()
    {
        delete [] m_aData;
        m_aData = 0;
    }

    ULONG Count () const
    {
        return m_cElements;
    }

    ULONG AllocSize () const
    {
        return m_cSize;
    }

	void Reset ()
	{
		delete [] m_aData;
		m_aData		= 0;
		m_cElements = 0;
		m_cSize		= 0;
	}

    HRESULT SetAllocSize (ULONG i_iNewSize)
    {
        ASSERT (i_iNewSize > m_cSize);

        return AllocNewSize (i_NewSize);
    }

    HRESULT Append (const T& i_NewElement)
    {
        return InsertAt (i_NewElement, m_cElements);
    }

    HRESULT Prepend (const T& i_NewElement)
    {
       return InsertAt (i_NewElement, 0);
    }

	HRESULT SetSize (ULONG i_iSize)
	{
		HRESULT hr = S_OK;
		if (i_iSize == 0 && m_cElements == 0)
		{
			return S_OK;
		}

		if (i_iSize > m_cSize)
		{
			hr = AllocNewSize (i_iSize);
			if (FAILED (hr))
			{
				return hr;
			}
		}

		m_cElements = i_iSize;

		return hr;
	}

    HRESULT InsertAt (const T& i_NewElement, ULONG i_idx)
    {
        ASSERT (i_idx >=0 && i_idx <= m_cElements);
        HRESULT hr = S_OK;
        if (m_cElements==m_cSize)
        {
            hr = AllocNewSize (m_cSize==0?1:2*m_cSize);
            if (FAILED (hr))
            {
                return hr;
            }
        }

        // move the data in the array. Note that you cannot use
        // memmove, because when you have an array of objects that are
        // refcounted, you have to call the copy constructor, else you
        // get very weird behavior (program crash, etc).
        for (ULONG jdx = m_cElements; jdx > i_idx; --jdx)
        {
            m_aData[jdx] = m_aData[jdx-1];
        }

        m_aData[i_idx] = i_NewElement;
        m_cElements++;

        return hr;
    }

	void DeleteAt (ULONG i_idx)
	{
		ASSERT (i_idx >= 0 && i_idx < m_cElements);

		for (ULONG idx = i_idx + 1; idx < m_cElements; ++idx)
		{
			m_aData[idx-1] = m_aData[idx];
		}

		m_aData[m_cElements-1] = T();

		m_cElements--;
	}

    T& operator[] (ULONG idx) const
    {
        ASSERT (idx >= 0 && idx < m_cElements);
        return m_aData[idx];
    };

//=================================================================================
// The Iterator class is used to navigate through the elements in the linked list. Call
// List::Begin to get an iterator pointing to the first element in the list, and call
// Next to get the next element in the list. List::End can be used if we are at the end
// of the list
//=================================================================================
	class Iterator
	{
	private:
	    void operator=(const Iterator&);

		friend class CCfgArray<T>;
	public:

		//=================================================================================
		// Function: Next
		//
		// Synopsis: get iterator to next element in the list
		//=================================================================================
		void Next () { m_curIdx++;}

		//=================================================================================
		// Function: Value
		//
		// Synopsis: Returns value of element that iterator points to
		//=================================================================================
		T& Value () const
        {
            return m_aData[m_curIdx];
        }

		bool operator== (const Iterator& rhs) const	{return m_curIdx == rhs.m_curIdx;}
		bool operator!= (const Iterator& rhs) const {return m_curIdx != rhs.m_curIdx;}

	private:
        Iterator (const CCfgArray<T> * i_paData, ULONG iStart) : m_aData(*i_paData), m_curIdx (iStart) {} // only list can create these
		ULONG m_curIdx;
        const CCfgArray<T>& m_aData;
	};

    //=================================================================================
	// Function: Begin
	//
	// Synopsis: Returns an iterator to the beginning of the list
	//=================================================================================
	const Iterator Begin () const
	{
		return Iterator (this, 0);
	}

	//=================================================================================
	// Function: End
	//
	// Synopsis: Returns an iterator one past the end of the list (like STL does)
	//=================================================================================
	const Iterator End () const
	{
		return Iterator (this, m_cElements);
	}

    // returns index of place to insert element in sorted array
    ULONG BinarySearch (const T& i_ElemToSearch) const
    {
        ULONG iLow = 0;
        ULONG iHigh = m_cElements;
        while (iLow < iHigh)
        {
            // (low + high) / 2 might overflow
            ULONG iMid = iLow + (iHigh - iLow) / 2;
            if (m_aData[iMid] > i_ElemToSearch)
            {
                iHigh = iMid;
            }
            else
            {
                iLow = iMid + 1;
            }
        }

        return iLow;
    }


    ULONG BinarySearch(BOOL (*pfnLE)(T*, void*), void* pArg) const
    {
        ULONG itLo = 0;
        ULONG itHi = Count();
        while (itLo < itHi) {
                // (low + high) / 2 might overflow
                unsigned itMid = itLo + (itHi - itLo) / 2;
                if ((*pfnLE)(&m_aData[itMid], pArg))
                        itHi = itMid;
                else
                        itLo = itMid + 1;
        }

        return itLo;
    }

private:
    HRESULT AllocNewSize (ULONG i_NewSize)
    {
        ASSERT (i_NewSize > m_cSize);

        T * aNewData = new T [i_NewSize];
        if (aNewData == 0)
        {
            return E_OUTOFMEMORY;
        }

        // copy the data from the old array in the new array.
        // you have to use the copy constructor (and not memcpy), to avoid
        // all kind of weird errors. When you use memcpy, you are not updating
        // possible refcounts that are part of type T, and thus you get possible
        // crashes
        for (ULONG idx=0; idx < m_cSize; ++idx)
        {
            aNewData[idx] = m_aData[idx];
        }

        delete[] m_aData;
        m_aData = aNewData;
        m_cSize = i_NewSize;

        return S_OK;
    }

    // we don't allow copies
    CCfgArray (const CCfgArray<T>& );
    CCfgArray<T>& operator=(const CCfgArray<T>& );

    T *     m_aData;
    ULONG   m_cSize;
    ULONG   m_cElements;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\locationwriter.h ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    LocationWriter.h

Abstract:

    Header of the class that writes a node (location)
    in the metabase

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#pragma once

class CLocationWriter
{
    public:

        CLocationWriter();
        ~CLocationWriter();

        //
        // Both SaveAllData and ApplyChangesToHistoryFile use this.
        //

        HRESULT WriteLocation(BOOL bSort);

        HRESULT Initialize(CWriter* pCWriter,
                           LPCWSTR   wszLocation);

        //
        // SaveAllData uses these interfaces
        //

        HRESULT InitializeKeyType(DWORD dwKeyTypeIdentifier,
                                  DWORD dwKeyTypeAttributes,
                                  DWORD dwKeyTypeUserType,
                                  DWORD dwKeyTypeDataType,
                                  PBYTE pbKeyTypeData,
                                  DWORD cbKeyTypeData);

        HRESULT InitializeKeyTypeAsInherited();

        HRESULT AddProperty(DWORD   dwIdentifier,
                            DWORD   dwAttributes,
                            DWORD   dwUserType,
                            DWORD   dwDataType,
                            PBYTE   pbData,
                            DWORD   cbData);    // Computes Name and Group (For which keytype needs to be initialized)

        //
        // ApplyChangesToHistoryFile uses these interfaces
        //

        HRESULT AddProperty(BOOL     bMBPropertyTable,
                            LPVOID*  a_pvProperty,
                            ULONG*   a_cbSize); 

    private:

        HRESULT AssignKeyType(LPWSTR wszKeyType);

        HRESULT SaveComment(DWORD  i_dwDataType,
                            LPWSTR i_wszComment);

        HRESULT WriteComment();

        HRESULT GetGroupEnum(LPWSTR             wszGroup,
                             eMBProperty_Group* peGroup,
                             LPWSTR*            pwszGroup);

        HRESULT Sort(ULONG*  aiRowSorted);

        HRESULT WriteBeginLocation(LPCWSTR  wszLocation);

        HRESULT WriteEndLocation();

        HRESULT WriteCustomProperty(LPVOID*  a_pv,
                                    ULONG*   a_cbSize);

        HRESULT WriteEndWellKnownGroup();

        HRESULT WriteWellKnownProperty(LPVOID*   a_pv,
                                       ULONG*    a_cbSize);

        void IncrementGroupCount(DWORD i_dwGroup);

    public:

        LPWSTR                      m_wszLocation;

    private:
    
        LPWSTR                      m_wszKeyType;
        eMBProperty_Group           m_eKeyTypeGroup;
        CWriter*                    m_pCWriter;
        CWriterGlobalHelper*        m_pCWriterGlobalHelper;
        LPWSTR                      m_wszComment;
        ULONG                       m_cCustomProperty;
        ULONG                       m_cWellKnownProperty;

}; // class CLocationWriter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\mbpropertywriter.h ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    MBPropertyWriter.h

Abstract:

    Header of the class that writes proterty information when there are 
    schema extensions. 

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#pragma once

struct PropValue {
    DWORD dwMetaID;
    DWORD dwPropID;
    DWORD dwSynID;
    DWORD dwMaxRange;
    DWORD dwMinRange;
    DWORD dwMetaType;
    DWORD dwFlags;
    DWORD dwMask;
    DWORD dwMetaFlags;
    DWORD dwUserGroup;
    BOOL fMultiValued;
    DWORD dwDefault;
    LPWSTR szDefault;
};

class CMBCollectionWriter;

class CMBPropertyWriter
{
    public:
        
        CMBPropertyWriter();
        ~CMBPropertyWriter();

        void Initialize(DWORD                           i_dwID,
                        BOOL                            i_bMandatory,
                        CMBCollectionWriter*            i_pCollection,
                        CWriter*                        i_pcWriter);

        HRESULT AddNameToProperty(LPCWSTR               i_wszName);
        HRESULT AddTypeToProperty(PropValue*            i_wszType);
        HRESULT AddDefaultToProperty(BYTE*              i_bDefault,
                                     ULONG              i_cbDefault);
        HRESULT AddFlagToProperty(CMBPropertyWriter*    i_pFlag);
        HRESULT WriteProperty();

        HRESULT WriteFlag(ULONG i_iFlag);
        LPCWSTR Name() {return m_wszName;}
        DWORD   ID() {return m_dwID;}
        DWORD   FlagValue() {return m_pType->dwMask;}

    private:

        HRESULT ReAllocate();
        void    CreateUnknownName(LPWSTR    io_wszUnknownName,
                                  DWORD     i_dwID);
        HRESULT GetMetaFlagsExTag(LPWSTR* o_pwszMetaFlagsEx);
        HRESULT WritePropertyLong();
        HRESULT WritePropertyShort();
        HRESULT BeginWritePropertyLong();
        HRESULT EndWritePropertyLong();
        BOOL    IsPropertyFlag(BOOL i_bLog);

        CWriter*                    m_pCWriter;
        LPCWSTR                     m_wszName;
        PropValue*                  m_pType;
        BYTE*                       m_bDefault;
        ULONG                       m_cbDefault;
        DWORD                       m_dwID;
        CMBPropertyWriter**         m_apFlag;
        DWORD                       m_iFlag;
        DWORD                       m_cFlag;
        BOOL                        m_IsProperty;
        BOOL                        m_bMandatory;
        CMBCollectionWriter*        m_pCollection;
        
}; // CMBPropertyWriter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\mbcollectionwriter.h ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    MBCollectionWriter.h

Abstract:

    Header of the class that writes class (or collection) information
    when there are schema extensions. 

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#pragma once

class CMBCollectionWriter
{
    public:
        
        CMBCollectionWriter();
        ~CMBCollectionWriter();

        void Initialize(LPCWSTR     i_wszCollection,
                        BOOL        i_bContainer,
                        LPCWSTR     i_wszContainerClassList,
                        CWriter*    i_pcWriter);

        HRESULT GetMBPropertyWriter(DWORD                  i_dwID,
                                    CMBPropertyWriter**    o_pMBPropertyWriter);

        HRESULT GetMBPropertyWriter(LPCWSTR              i_wszName,
                                    BOOL                 i_bMandatory,
                                    CMBPropertyWriter**  o_pProperty);


        HRESULT CreateIndex();
        HRESULT WriteCollection();

        LPCWSTR Name(){ return m_wszMBClass;}

    private:

        HRESULT ReAllocate();
        HRESULT ReAllocateIndex(DWORD i_dwLargestID);
        HRESULT GetNewMBPropertyWriter(DWORD                i_dwID,
                                       CMBPropertyWriter**  o_pProperty);
        HRESULT BeginWriteCollection();
        HRESULT EndWriteCollection();


        CWriter*                    m_pCWriter;
        LPCWSTR                     m_wszMBClass;
        LPCWSTR                     m_wszContainerClassList;
        BOOL                        m_bContainer;
        CMBPropertyWriter**         m_apProperty;
        ULONG                       m_cProperty;
        ULONG                       m_iProperty;
        CMBPropertyWriter**         m_aIndexToProperty;
        DWORD                       m_dwLargestID;

}; // CMBCollectionWriter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\safecs.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        SafeCS.h
//
// Contents:    CSafeAutoCriticalSection, protects CriticalSection against AV via try,catch
//
//------------------------------------------------------------------------
#pragma once

class CSafeAutoCriticalSection
{
public:


    CSafeAutoCriticalSection();
    ~CSafeAutoCriticalSection();

    DWORD Lock();
    DWORD  Unlock();

    BOOL IsInitialized() { return (STATE_INITIALIZED == m_lState);}

private:

    enum
    {
        STATE_UNINITIALIZED = 0,
        STATE_INITIALIZED   = 1
    };

    CRITICAL_SECTION    m_cs;
    LONG                m_lState;
	DWORD               m_dwError;

};

class CSafeLock 
{
public:
	CSafeLock (CSafeAutoCriticalSection* val);
	CSafeLock (CSafeAutoCriticalSection& val);

	~CSafeLock ();

	DWORD Lock ();
	DWORD Unlock ();
private:

private:
	BOOL m_locked;
	CSafeAutoCriticalSection* m_pSem;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\mbschemawriter.h ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    MBSchemaWriter.h

Abstract:

    Header of the class that writes schema extensions.
    
Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#pragma once

class CMBSchemaWriter
{
    public:
        
        CMBSchemaWriter(CWriter* pcWriter);
        ~CMBSchemaWriter();

        HRESULT GetCollectionWriter(LPCWSTR                 i_wszCollection,
                                    BOOL                    i_bContainer,
                                    LPCWSTR                 i_wszContainerClassList,
                                    CMBCollectionWriter**   o_pMBCollectionWriter);

        HRESULT WriteSchema();

    private:

        HRESULT ReAllocate();

        CMBCollectionWriter**   m_apCollection;
        ULONG                   m_cCollection;
        ULONG                   m_iCollection;
        CWriter*                m_pCWriter;

}; // CMBSchemaWriter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\metatablestructs.h ===
//  Copyright (C) 2000 Microsoft Corporation.  All rights reserved.
//  Filename:       MetaTableStructs.h
//  Author:         Stephenr
//  Date Created:   6/20/00
//  Description:    All fixed tables store their column values as ULONGs.  These ULONGs are either
//                  interpretted as ULONGs or indexes into some pool that contains the actual data.
//                  The columns' type defines the type of data pointed to.  And in the past it has
//                  also determined which pool the data came from (we had a separate pool for each
//                  type of data).  Either way, the fixed table columns are always stored as ULONGs.
//
//                  Currently there are two fixed table formats:  the TableSchema format and the
//                  FixedTable format.  Each solves a slightly different problem.  They each store
//                  extra information on a per column basis.  Also the TableSchema stores UI4s
//                  directly as ULONG.  The FixedTable format stores UI4s as indexes into a pool.
//                  This is necessary so we can represent a UI4 column as NULL.
//
//                  All meta, regardless of the specifics of the fixed storage format, must derive
//                  from the tables below.  This reduces the change points when updating meta for
//                  the meta tables.  Currently there are several places that need to be updated,
//                  when updating meta-meta:
//                      MetaTableStructs.h
//                      CatMeta_Core.xml
//
//                  This assumes the most simple case meta-meta change is being made.  Like a column
//                  being added to ColumnMeta that does not require any inferrance rules.  Obviously
//                  anything beyond this would require changes to the CatUtil code.
#pragma once


//  These signatures are used to verify the position of each of structures within the PE file.  The
//  0th entry of each of these arrays starts with Signature0 followed by Signature1.  This 0th element is
//  not considered as part of the array so the count of elements in the array is always minus this 0th
//  element.  Thus element 1 becomes the 0th element after this signature verification is done.  Since we
//  always use indexes to reference into these structs, it is sometimes useful to reserve an element to
//  indicate NULL.  An index to this reserved element is interpreted as NULL (and NOT as a pointer to
//  a NULL element).  This reserved element is usually element 1 which gets translated as the 0th element.
//  This is particularly useful in the above arrays, where a 0 index into the WChar array indicates NULL
//  and not a pointer to the 0th element.
#define FixedTableHeap0         0x207be016
#define FixedTableHeap1         0xe0182086

//The numbers below can be used as signatures (a histogram of catinpro revealed that none of the WORDs appeared in the bin).
//When we run out of signatures, we can generate some more by writing a program that searches for unique WORDs within Catalog.dll, and combining two of them.
//0x208ee01b    0xe0222093    0x209de027    0xe028209e
//0x209fe042    0xe04c20a5    0x20aae04f    0xe05220ae
//0x20b2e054    0xe05e20d6    0x20dbe05f    0xe07220dd
//0x20dee07a    0xe07b20e6    0x20e7e07c    0xe08f20ed
//0x20f5e096    0xe09720f7    0x20fbe098    0xe09920fd
//0x210de09a    0xe09b2115    0x211be09c    0xe09d2126


#define PRIMARYKEY
#define FOREIGNKEY

struct ColumnMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            Index;                  //UI4       Column Index
    ULONG                       InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Type;                   //UI4       These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
    ULONG                       Size;                   //UI4
    ULONG                       MetaFlags;              //UI4       ColumnMetaFlags defined in CatMeta.xml
    ULONG                       DefaultValue;           //Bytes
    ULONG                       FlagMask;               //UI4       Only valid for flags
    ULONG                       StartingNumber;         //UI4       Only valid for UI4s
    ULONG                       EndingNumber;           //UI4       Only valid for UI4s
    ULONG                       CharacterSet;           //String    Only valid for Strings
    ULONG                       SchemaGeneratorFlags;   //UI4       ColumnMetaFlags defined in CatMeta.xml
    ULONG                       ID;                     //UI4       Metabase ID
    ULONG                       UserType;               //UI4       One of the Metabase UserTypes
    ULONG                       Attributes;             //UI4       Metabase Attribute flags
    ULONG                       Description;            //String
    ULONG                       PublicColumnName;       //String
};
const kciColumnMetaPublicColumns = sizeof(ColumnMetaPublic)/sizeof(ULONG);

struct DatabaseMetaPublic
{
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       BaseVersion;            //UI4
    ULONG                       ExtendedVersion;        //UI4
    ULONG                       CountOfTables;          //UI4       Count of tables in database
    ULONG                       Description;            //String
};
const kciDatabaseMetaPublicColumns = sizeof(DatabaseMetaPublic)/sizeof(ULONG);

struct IndexMetaPublic
{
    ULONG PRIMARYKEY    Table;                          //String
    ULONG PRIMARYKEY    InternalName;                   //String
    ULONG               PublicName;                     //String
    ULONG PRIMARYKEY    ColumnIndex;                    //UI4       This is the iOrder member of the ColumnMeta
    ULONG               ColumnInternalName;             //String
    ULONG               MetaFlags;                      //UI4       Index Flag
};
const kciIndexMetaPublicColumns = sizeof(IndexMetaPublic)/sizeof(ULONG);

struct QueryMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Index;                  //UI4
    ULONG                       CellName;               //String
    ULONG                       Operator;               //UI4
    ULONG                       MetaFlags;              //UI4
};
const kciQueryMetaPublicColumns = sizeof(QueryMetaPublic)/sizeof(ULONG);

struct RelationMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY PrimaryTable;           //String
    ULONG                       PrimaryColumns;         //Bytes
    ULONG PRIMARYKEY FOREIGNKEY ForeignTable;           //String
    ULONG                       ForeignColumns;         //Bytes
    ULONG                       MetaFlags;
};
const kciRelationMetaPublicColumns = sizeof(RelationMetaPublic)/sizeof(ULONG);

struct ServerWiringMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            Order;                  //UI4
    ULONG                       ReadPlugin;             //UI4
    ULONG                       ReadPluginDLLName;      //String
    ULONG                       WritePlugin;            //UI4
    ULONG                       WritePluginDLLName;     //String
    ULONG                       Interceptor;            //UI4
    ULONG                       InterceptorDLLName;     //String
    ULONG                       Flags;                  //UI4       Last, NoNext, First, Next
    ULONG                       Locator;                //String
    ULONG                       Reserved;               //UI4       for Protocol.  Protocol may be needed for managed property support
    ULONG                       Merger;                 //UI4
    ULONG                       MergerDLLName;          //String
};
const kciServerWiringMetaPublicColumns = sizeof(ServerWiringMetaPublic)/sizeof(ULONG);

struct TableMetaPublic
{
    ULONG FOREIGNKEY            Database;               //String
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       PublicRowName;          //String
    ULONG                       BaseVersion;            //UI4
    ULONG                       ExtendedVersion;        //UI4
    ULONG                       NameColumn;             //UI4       iOrder of the NameColumn
    ULONG                       NavColumn;              //UI4       iOrder of the NavColumn
    union
    {
    ULONG                       CountOfColumns;         //UI4       Count of Columns
    ULONG                       CountOfProperties;      //UI4       Count of Columns
    };
    ULONG                       MetaFlags;              //UI4       TableMetaFlags are defined in CatInpro.meta
    ULONG                       SchemaGeneratorFlags;   //UI4       SchemaGenFlags are defined in CatInpro.meta
    ULONG                       ConfigItemName;         //String
    ULONG                       ConfigCollectionName;   //String
    ULONG                       PublicRowNameColumn;    //UI4       If PublicRowName is NULL, this specifies the column whose enum values represent possible PublicRowNames
    ULONG                       ContainerClassList;     //String    This is a comma delimited list of classes
    ULONG                       Description;            //String
    ULONG                       ChildElementName;       //String    This should be NULL unless one or more columns has the VALUEINCHILDELEMENT flag set on it.
};
const kciTableMetaPublicColumns = sizeof(TableMetaPublic)/sizeof(ULONG);

struct TagMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY FOREIGNKEY ColumnIndex;            //UI4       This is the iOrder member of the ColumnMeta
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Value;                  //UI4
    ULONG                       ID;                     //UI4
};
const kciTagMetaPublicColumns = sizeof(TagMetaPublic)/sizeof(ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\mbschemacompilation.h ===
// Copyright (C) 2000 Microsoft Corporation.  All rights reserved.
// Filename:        MBSchemaCompilation,h
// Author:          Stephenr
// Date Created:    10/16/2000
// Description:     This function takes an MBSchema.Xml (or MBExtensionsSchema.Xml) and merges the Metabase Schema with
//                  the shipped schema and generates a MBSchema.bin file.  From that new bin file, a merged MBSchema.Xml
//                  is generated.
//

#pragma once

class TMBSchemaCompilation
{
public:
    TMBSchemaCompilation();
    ~TMBSchemaCompilation();
    
    //After the user calls Compile, they will need to GetBinFileName - I didn't want to add more params and make this function do double duty
    HRESULT Compile                (ISimpleTableDispenser2 *i_pISTDispenser,
                                    LPCWSTR                 i_wszExtensionsXmlFile,
                                    LPCWSTR                 i_wszResultingOutputXmlFile,
                                    const FixedTableHeap *  i_pFixedTableHeap
                                   );
    //This function returns the BinFileName to be used for getting all of the IST meta tables used by the Metabase.
    //This file name changes as new versions get compiled; but this abstraction guarentees that the filename returned
    //exists AND is lock into memory and thus cannot be deleted by some other process or thread.  It isn't released
    //until another file has been compiled and locked into memory, OR when the process shuts down.
    HRESULT GetBinFileName         (LPWSTR                  o_wszBinFileName,
                                    ULONG *                 io_pcchSizeBinFileName//this is a SIZE param so it always INCLUDE the NULL - unlike wcslen
                                   );

    //This is broken out into a separate method because on start up, we'll be called to GetMBSchemaBinFileName without first an MBSchemaCompilation
    HRESULT SetBinPath             (LPCWSTR                 i_wszBinPath
                                   );
    HRESULT ReleaseBinFileName     (LPCWSTR                 i_wszBinFileName
                                   );


private:
    struct TBinFileName : public TFileMapping
    {
        TBinFileName() : m_cRef(0), m_lBinFileVersion(-1){}
        HRESULT LoadBinFile(LPCTSTR filename, LONG lVersion)
        {
            if(m_cRef>0)
            {
                ASSERT(m_lBinFileVersion==lVersion && "Do we really need more than 64 versions of the BinFile hanging around?");
                ++m_cRef;
                return S_OK;
            }

            m_cRef = 1;
            m_lBinFileVersion = lVersion;
            return TFileMapping::Load(filename, false);
        }
        void UnloadBinFile()
        {
            if(0 == m_cRef)
                return;

            --m_cRef;
            if(0 == m_cRef)
            {
                m_lBinFileVersion = -1;
                TFileMapping::Unload();
            }
        }
        ULONG   m_cRef;
        LONG    m_lBinFileVersion;
    };

    TBinFileName                    m_aBinFile[0x40];
    SIZE_T                          m_cchFullyQualifiedBinFileName;
    TSmartPointerArray<WCHAR>       m_saBinPath;                          //The user specifies the path (we supply the file name)
    LONG                            m_lBinFileVersion;                    //Modifying the version is done through InterlockedExchange

    //This just takes the numeric extension and converts from hex string to a ULONG (file is assumed to be in the form L"*.*.xxxxxxxx", where L"xxxxxxxx" is a hex number)
    HRESULT BinFileToBinVersion    (LONG &                  i_lVersion,
                                    LPCWSTR                 i_wszBinFileName
                                   ) const;
    HRESULT DeleteBinFileVersion   (LONG i_lBinFileVersion
                                   );

    //This checks the validity of the FixedTableHeap mapped into memory
    bool    IsValidBin             (TFileMapping &          i_mapping
                                   ) const;
    HRESULT RenameBinFileVersion   (LONG                    i_lSourceVersion,
                                    LONG                    i_lDestinationVersion
                                   );
    HRESULT SetBinFileVersion      (LONG                    i_lBinFileVersion
                                   );
    HRESULT WalkTheFileSystemToFindTheLatestBinFileName();




};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\textfilelogger.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name:
    TextFileLogger.h

$Header: $

Abstract:
    Definition of the TextFileLogger.

Author:
    ???             ???

Revision History:
    mohits          4/19/01

--**************************************************************************/

#pragma once

/********************************************************************++

Class Name:

    TLogData

Class Description:

    Specific to our log file format.  It provides the following
    additional functionality: verify if the log file is full -and-
    version number stuff.

Constraints

--********************************************************************/
struct TLogData : public WIN32_FIND_DATA
{
public:
    TLogData(
        ULONG   i_ulIdxNumPart,
        ULONG   i_ulFullSize) : WIN32_FIND_DATA()
    /*++

    Synopsis:
        Constructor, class is useless until passed to Find*File.

    Arguments: [i_ulIdxNumPart] - The idx of the num part (i.e. where version starts)
               [i_ulFullSize]   - The size of a full log

    --*/
    {
        m_ulVersion  = 0;
        m_ulFullSize = i_ulFullSize;
        nFileSizeLow = 0;

        cFileName[0] = L'\0';
        m_idxNumPart = i_ulIdxNumPart;
    }

    TLogData(
        ULONG   i_ulIdxNumPart,
        ULONG   i_ulFullSize,
        LPCWSTR i_wszFileName,
        ULONG   i_ulFileSize) : WIN32_FIND_DATA()
    /*++

    Synopsis:
        Constructor, lets user start out with a file.

    Arguments: [i_ulIdxNumPart] - The idx of the num part (i.e. where version starts)
               [i_ulFullSize]   - The size of a full log
               [i_wszFileName]  - The file name
               [i_ulFileSize]   - The current size of file on disk

    --*/
    {
        DBG_ASSERT(i_wszFileName);
        DBG_ASSERT(wcslen(i_wszFileName) < MAX_PATH);

        m_ulVersion  = 0;
        m_ulFullSize = i_ulFullSize;
        nFileSizeLow = i_ulFileSize;

        wcsncpy(cFileName, i_wszFileName, MAX_PATH-1);
        cFileName[MAX_PATH-1]=L'\0';
        m_idxNumPart = i_ulIdxNumPart;
    }

    bool ContainsData()
    /*++

    Synopsis:
        Verifies that TLogData actually is referring to a file.
        (i.e. this obj was passed to Find*File)

    Return Value:
        bool

    --*/
    {
        return (cFileName[0] != L'\0');
    }


    bool IsFull()
    /*++

    Synopsis:
        Sees if log is full

    Return Value:
        bool

    --*/
    {
        DBG_ASSERT(*cFileName);
        return (nFileSizeLow >= m_ulFullSize);
    }

    bool SyncVersion()
    /*++

    Synopsis:
        Syncs ulVersion with the version number from the file.
        Needs to be run after filename changes (i.e. thru Find*File)

    Return Value:

    --*/
    {
        DBG_ASSERT(*cFileName);
        return WstrToUl(
            &cFileName[m_idxNumPart],
            L'.',
            &m_ulVersion);
    }

    ULONG GetVersion()
    {
        DBG_ASSERT(*cFileName);
        return m_ulVersion;
    }

    void IncrementVersion()
    {
        DBG_ASSERT(*cFileName);
        m_ulVersion++;
        SetVersion(m_ulVersion);
    }

    void SetVersion(
        ULONG i_ulVersion)
    {
        DBG_ASSERT(*cFileName);
        m_ulVersion = i_ulVersion;
        _snwprintf(&cFileName[m_idxNumPart], 10, L"%010lu", m_ulVersion);
    }

private:
    ULONG m_idxNumPart;   // The array index into cFileName where version starts
    ULONG m_ulVersion;
    ULONG m_ulFullSize;

    bool WstrToUl(
        LPCWSTR  i_wszSrc,
        WCHAR    i_wcTerminator,
        ULONG*   o_pul);
};

/********************************************************************++

Class Name:

    TextFileLogger

Class Description:

    The textfile ogger

Constraints

    Only one of these can be used per PRODUCT at a time.  That is
    because:
    - the log files are named after the PRODUCT
    - the "current file" we are logging to is only stored in process
      memory - it is not in a shared segment or otherwise shared.

--********************************************************************/
class TextFileLogger : public ICatalogErrorLogger2
{
public:
    TextFileLogger(
                    const WCHAR* wszEventSource,
                    HMODULE      hMsgModule,
                    DWORD        dwNumFiles=4);
    TextFileLogger( const WCHAR* wszProductID,
                    ICatalogErrorLogger2 *pNext=0,
                    DWORD        dwNumFiles=4);

    virtual ~TextFileLogger();

//IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

//ICatalogErrorLogger2
	STDMETHOD(ReportError) (ULONG      i_BaseVersion_DETAILEDERRORS,
                            ULONG      i_ExtendedVersion_DETAILEDERRORS,
                            ULONG      i_cDETAILEDERRORS_NumberOfColumns,
                            ULONG *    i_acbSizes,
                            LPVOID *   i_apvValues);

    void Init(
        const WCHAR* wszEventSource,
        HMODULE      hMsgModule=0);

    void Report(
        WORD         wType,
        WORD         wCategory,
        DWORD        dwEventID,
        WORD         wNumStrings,
        size_t       dwDataSize,
        LPCTSTR*     lpStrings,
        LPVOID       lpRawData,
        LPCWSTR      wszCategory=0,      //if NULL the category is looked up in this module using wCategory
        LPCWSTR      wszMessageString=0);//if NULL the message is looked up in this module using dwEventID

private:
    HRESULT Lock() {
        // Serialize access to the file by synchronizing on a process-wide critical section.
        HRESULT hr = _cs.Lock();
        if(hr != ERROR_SUCCESS)
        {
            hr = E_OUTOFMEMORY;
            DBGERROR((DBG_CONTEXT, "Could not lock critical section\n"));
            return hr;
        }
        return hr;
    }
    HRESULT Unlock() {
        HRESULT hr = _cs.Unlock();
        if(hr != ERROR_SUCCESS)
        {
            hr = E_OUTOFMEMORY;
            DBGERROR((DBG_CONTEXT, "Could not unlock critical section\n"));
            return hr;
        }
        return hr;
    }

    // helper routine called by Report (determines correct file, opens it)
    void InitFile();

    // helper routine called by InitFile
    HRESULT DetermineFile();

    // Called by DetermineFile
    HRESULT GetFirstAvailableFile(
        LPWSTR     wszBuf,
        LPWSTR     wszFilePartOfBuf,
        TLogData*  io_pFileData);

    // Called by DetermineFile
    bool ConstructSearchString(
        LPWSTR     o_wszSearchPath,
        LPWSTR*    o_ppFilePartOfSearchPath,
        LPWSTR*    o_ppNumPartOfSearchPath);

    // Called by DetermineFile
    void SetGlobalFile(
        LPCWSTR    i_wszSearchString,
        ULONG      i_ulIdxNumPart,
        ULONG      i_ulVersion);

    HANDLE CreateFile();

private:
    DWORD                _dwMaxSize;    // Total size (in bytes) of _dwNumFiles files
    const DWORD          _dwNumFiles;   // Number of files log is divided into
    const WCHAR*         _eventSource;
    HANDLE               _hFile;
    HMODULE              _hMsgModule;
    static CSafeAutoCriticalSection _cs;

    ULONG           m_cRef;
    WCHAR           m_wszProductID[64];
    CComPtr<ICatalogErrorLogger2> m_spNextLogger;
};

class NULL_Logger : public ICatalogErrorLogger2
{
public:
    NULL_Logger() : m_cRef(0){}
    virtual ~NULL_Logger(){}

//IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv)
    {
        if (NULL == ppv)
            return E_INVALIDARG;
        *ppv = NULL;

        if (riid == IID_ICatalogErrorLogger2)
            *ppv = (ICatalogErrorLogger2*) this;
        else if (riid == IID_IUnknown)
            *ppv = (ICatalogErrorLogger2*) this;

        if (NULL == *ppv)
            return E_NOINTERFACE;

        ((ICatalogErrorLogger2*)this)->AddRef ();
        return S_OK;
    }
	STDMETHOD_(ULONG,AddRef)		()
    {
        return InterlockedIncrement((LONG*) &m_cRef);
    }
	STDMETHOD_(ULONG,Release)		()
    {
        long cref = InterlockedDecrement((LONG*) &m_cRef);
        if (cref == 0)
            delete this;

        return cref;
    }

//ICatalogErrorLogger2
	STDMETHOD(ReportError) (ULONG      i_BaseVersion_DETAILEDERRORS,
                            ULONG      i_ExtendedVersion_DETAILEDERRORS,
                            ULONG      i_cDETAILEDERRORS_NumberOfColumns,
                            ULONG *    i_acbSizes,
                            LPVOID *   i_apvValues)
    {
        UNREFERENCED_PARAMETER(i_BaseVersion_DETAILEDERRORS);
        UNREFERENCED_PARAMETER(i_ExtendedVersion_DETAILEDERRORS);
        UNREFERENCED_PARAMETER(i_cDETAILEDERRORS_NumberOfColumns);
        UNREFERENCED_PARAMETER(i_acbSizes);
        UNREFERENCED_PARAMETER(i_apvValues);

        return S_OK;
    }
private:
    ULONG           m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\sdtfst.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#pragma once


typedef struct							// Column data offsets:
{
	WORD	obStatus;						// Offset in bytes to column data status.
	WORD	oulSize;						// Offset in ulongs to column data size.
	ULONG	opvValue;						// Offset in void*s to column data value.
} ColumnDataOffsets;
										// Forward declarations:

// ------------------------------------------------------------------
// class CMemoryTable:
// ------------------------------------------------------------------
// Base class for implementing simple data tables for various datastores.
// This base class uses the in-memory marshallable Fox rowset as its table cache.
// Data table implementors using this base class must derive from it privately.
//
// Complete or partial method implementations are provided for the interfaces 
// ISimpleTable, ISimpleTableMeta, ISimpleTableRowset, ISimpleDataTableDispenser.
// Methods which operate exclusively on the cache are fully implemented.
// The derived class must implement datastore-dependent methods, but
// helper methods are provided to support the associated cache-specific work.
//
// Method names of these base implementations begin with "Internal".
// These methods should be called as appropriate from the derived class.
// 
class CMemoryTable :
	public ISimpleTableInterceptor,
	public ISimpleTableWrite2,
	public ISimpleTableController,
	public ISimpleTableMarshall	

{
// -----------------------------------------
// samsara
// -----------------------------------------
public:
			CMemoryTable	();
			~CMemoryTable	();

// -----------------------------------------
// IUnknown, IClassFactory, ISimpleLogicTableDispenser:
// -----------------------------------------

//IUnknown
public:
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

//ISimpleLogicTableDispenser
public:
	STDMETHOD(Intercept) (
						LPCWSTR					i_wszDatabase,
						LPCWSTR 				i_wszTable, 
						ULONG					i_TableID,
						LPVOID					i_QueryData,
						LPVOID					i_QueryMeta,
						DWORD					i_eQueryFormat,
						DWORD					i_fTable,
						IAdvancedTableDispenser* i_pISTDisp,
						LPCWSTR					i_wszLocator,
						LPVOID					i_pv,
						LPVOID*					o_ppv
						);

// -----------------------------------------
// ISimpleTable*:
// -----------------------------------------

//ISimpleTableRead2
public:

	STDMETHOD (GetRowIndexByIdentity)	(ULONG * i_cb, LPVOID * i_pv, ULONG* o_piRow);

    STDMETHOD (GetRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);

	STDMETHOD (GetColumnValues)	(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues);

	STDMETHOD (GetTableMeta) (ULONG* o_pcVersion, DWORD* o_pfTable, ULONG *o_pcRows, ULONG* o_pcColumns);

	STDMETHOD (GetColumnMetas)		(ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas);
//ISimpleTableWrite2
public:
	STDMETHOD (AddRowForDelete)			(ULONG i_iReadRow);

	STDMETHOD (AddRowForInsert)	(ULONG* o_piWriteRow);
	STDMETHOD (AddRowForUpdate)	(ULONG i_iReadRow, ULONG* o_piWriteRow);

	STDMETHOD (GetWriteColumnValues)	(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues);
	STDMETHOD (SetWriteColumnValues)	(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* i_apvValues);

	STDMETHOD (GetWriteRowIndexByIdentity)	(ULONG * i_cbSizes, LPVOID * i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetWriteRowIndexBySearch)	(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetErrorTable)               (DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable);

	STDMETHOD (UpdateStore)				();
	
//ISimpleTableController
public:
	STDMETHOD (ShapeCache)				(DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes);
	STDMETHOD (PrePopulateCache)		(DWORD i_fControl);
	STDMETHOD (PostPopulateCache)		();
	STDMETHOD (DiscardPendingWrites)	();

	STDMETHOD (GetWriteRowAction)		(ULONG i_iRow, DWORD* o_peAction);
	STDMETHOD (SetWriteRowAction)		(ULONG i_iRow, DWORD i_eAction);
	STDMETHOD (ChangeWriteColumnStatus)	(ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus);

	STDMETHOD (AddDetailedError)		(STErr* o_pSTErr);

	STDMETHOD (GetMarshallingInterface) (IID * o_piid, LPVOID * o_ppItf);

//ISimpleTableAdvanced
public:
	STDMETHOD (PopulateCache)		();
	STDMETHOD (GetDetailedErrorCount)	(ULONG* o_pcErrs);
	STDMETHOD (GetDetailedError)		(ULONG i_iErr, STErr* o_pSTErr);
	STDMETHOD (ResetCaches)			();
    STDMETHOD (GetColumnValuesEx)   (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues);

//ISimpleTableMarshall
public:
	STDMETHOD (SupplyMarshallable) (DWORD i_fReadNotWrite,
		char **	o_ppv1,	ULONG *	o_pcb1,	char **	o_ppv2, ULONG *	o_pcb2, char **	o_ppv3,
		ULONG *	o_pcb3, char **	o_ppv4, ULONG *	o_pcb4, char **	o_ppv5,	ULONG *	o_pcb5);

	STDMETHOD (ConsumeMarshallable) (DWORD i_fReadNotWrite,
		char * i_pv1, ULONG i_cb1,	char * i_pv2, ULONG i_cb2,	char * i_pv3, 
		ULONG i_cb3, char * i_pv4, ULONG i_cb4,	char * i_pv5, ULONG i_cb5);


private:
	void	BeginAddRow				();
	void	EndAddRow				();

// -----------------------------------------
// read/write helpers:
// -----------------------------------------
	void	RestartEitherRow		(DWORD i_eReadOrWrite);
	HRESULT MoveToEitherRowByIdentity(DWORD i_eReadOrWrite, ULONG* i_acb, LPVOID* i_apv, ULONG* o_piRow);
	HRESULT GetEitherRowIndexBySearch(DWORD i_eReadOrWrite, ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
	HRESULT GetEitherColumnValues	(ULONG i_iRow, DWORD i_eReadOrWrite, ULONG i_cColumns, ULONG *i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes , LPVOID* o_apvValues);
	HRESULT AddWriteRow				(DWORD fAction, ULONG* o_piWriteRow);
	HRESULT CopyWriteRowFromReadRow	(ULONG i_iReadRow, ULONG i_iWriteRow);
	HRESULT GetRowFromIndex			(DWORD i_eReadOrWrite, ULONG i_iRow, VOID** o_ppvRow);

	void PostMerge (ULONG i_iStartRow, ULONG i_cMergeRows, ULONG i_iDelta);
// -----------------------------------------
// Derived class helpers:
// -----------------------------------------
public:
	static BOOL	InternalMatchValues		(DWORD eOperator, DWORD dbType, DWORD fMeta, ULONG size1, ULONG size2, void *pv1, void *pv2);
public:

// -----------------------------------------
// interface ISimpleDataTableDispenser:
// -----------------------------------------
// Method implementations: 1 partial: 1 total.
// GetTable:	All information necessary to create an empty shaped cache is specified
//				once via InternalSimpleInitialize prior to calling any other methods,
//				including ConsumeMarshallable.
//				The derived class specifies the table flags from the dispenser, 
//				count of columns, and an array of column meta, which the base copies.
//

// -----------------------------------------
// interface ISimpleTableRead2
// -----------------------------------------
// Method implementations:  4 complete, 1 partial: 5 total.
//
// Partial implementations of the following methods are provided:
// GetTableMeta:	The table id and query is not known to the base implementation.	
//
// The remaining methods are completely implemented and should be directly delegated.
//
	
// -----------------------------------------
// interface ISimpleTableWrite2
// -----------------------------------------
// Method implementations:  8 complete, 1 notimpl: 9 total.
//
// The following methods must be exclusively implemented by the derived class:
// UpdateStore:			The derived class must call InternalPreUpdateStore immediately
//						preceding their update, then must write all pending updates, 
//						insertions,	and deletions to the datastore and must call 
//						InternalPostUpdateStore when done (which clears the write cache).
//InternalAbortAddRow:	This is not yet implemented and will return E_NOTIMPL for now
// The remaining methods are completely implemented and should be directly delegated.
//
	HRESULT	InternalPreUpdateStore			();
	
// -----------------------------------------
// interface ISimpleTableAdvanced
// -----------------------------------------
// Method implementations:  7 complete: 7 total.
//
// Partial implementations of the following methods are provided:
// PopulateCache:				The derived class must call InternalPrePopulateCache
//								immediately preceding their population and must call
//								InternalPostPopulateCache immediately following.
//								While populating, AddRowForInsert, SetWriteColumn, and
//								ValidateRow all act on the read cache.
// CloneCursor:					The derived class must create a copy of itself first.
//								InternalCloneCursor takes that copy and copies all base members.
//								This results in another cursor to the same cache.
// The following methods must be exclusively implemented by the derived class:
// ChangeQuery.
//
// The remaining methods are completely implemented and should be directly delegated.
//
	HRESULT InternalMoveToWriteRowByIdentity(ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);

// -----------------------------------------
// interface ISimpleTableController
// -----------------------------------------
// Method implementations:	4 complete : 9 total.
//
// The following methods must be exclusively implemented by the derived class:
// GetMarshallingInterface.
//
// The remaining methods are completely implemented and should be directly delegated.
//
// Use InternalSimpleInitialize for ShapeCache (many implementors will opt to E_NOTIMPL this method).
// Use InternalPre/PostPopulateCache for Pre/PostPopulateCache.
// Use InternalPostUpdateStore for DiscardPendingWrites.
//
// -----------------------------------------
// interface ISimpleTableMarshall
// -----------------------------------------
// Method implementations:  2 complete : 2 total.
//
//	InternalSupplyMarshallable: supplies the data for marshalling the cache
//  InternalConsumeMarshallable: initializes the cache with data from marshalling
//
	
// -----------------------------------------
// Methods that used to be seperate on CSimpleDataTableCache
// -----------------------------------------
private:
	HRESULT	SetupMeta					(DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbDefSizes);

// -----------------------------------------
// Cache management:
// -----------------------------------------

	void	CleanupCaches				();
	HRESULT	ResizeCache					(DWORD i_fCache, ULONG i_cbNewSize);
	void	CleanupReadCache			();
	void	CleanupWriteCache			();
	void	CleanupErrorCache			();
	void	ResetReadCache			    ();
	void	ResetWriteCache			    ();
	void	ResetErrorCache			    ();
	HRESULT	ShrinkWriteCache			();
	HRESULT	AddRowToWriteCache			(ULONG* o_piRow, LPVOID* o_ppvRow);
	HRESULT	AddVarDataToWriteCache		(ULONG i_cb, LPVOID i_pv, ULONG** o_pib);
	HRESULT	AddErrorToErrorCache		(STErr* i_pSTErr);
	void	BeginReadCacheLoading		();
	void	ContinueReadCacheLoading	();
	void	EndReadCacheLoading			();
	void	RemoveDeletedRows			();

// -----------------------------------------
// Offset and pointer calculation helpers:
// -----------------------------------------

	ULONG	cbWithPadding				(ULONG i_cb, ULONG i_cbPadTo);

	ULONG	cbDataTotalParts			();

	ULONG	cDataStatusParts			();
	ULONG	cDataSizeParts				();
	ULONG	cDataValueParts				();
	ULONG	cDataTotalParts				();
	
	ULONG	obDataStatusPart			(ULONG i_iColumn);
	ULONG	obDataSizePart				(ULONG i_iColumn);
	ULONG	obDataValuePart				(ULONG i_iColumn);

	ULONG	oulDataSizePart				(ULONG i_iColumn);
	ULONG	opvDataValuePart			(ULONG i_iColumn);
	ULONG	odwDataActionPart			();

	BYTE*	pbDataStatusPart			(LPVOID i_pv, ULONG i_iColumn);
	ULONG*	pulDataSizePart				(LPVOID i_pv, ULONG i_iColumn);
	LPVOID*	ppvDataValuePart			(LPVOID i_pv, ULONG i_iColumn);
	DWORD*	pdwDataActionPart			(LPVOID i_pv);

	LPVOID	pvVarDataFromIndex			(BYTE i_statusIndex, LPVOID i_pv, ULONG i_iColumn);

	LPVOID	pvDefaultFromIndex			(ULONG i_iColumn);
	ULONG	lDefaultSize				(ULONG i_iColumn);

	STErr*	pSTErrPart					(ULONG i_iErr);

private:
	// Helper functions
	SIZE_T GetMultiStringLength (LPCWSTR i_wszMS) const;
	static BOOL  MultiStringCompare (LPCWSTR i_wszLHS, LPCWSTR i_wszRHS, BOOL fCaseInsensitive);
// -----------------------------------------
// Member data:
// -----------------------------------------
private:
										// Meta information:	
	DWORD				m_fTable;			// Table flags.
	ULONG				m_cColumns;			// Count of columns.
	ULONG				m_cUnknownSizes;	// Count of columns with unknown sizes.
	ULONG				m_cStatusParts;		// Count of status parts in 32-bit units.
	ULONG				m_cValueParts;		// Count of value parts in 32-bit units.
	SimpleColumnMeta*	m_acolmetas;		// Simple column meta.
	ColumnDataOffsets*	m_acoloffsets;		// Column offsets.
	LPVOID*				m_acolDefaults;		// Column default values.
	ULONG*				m_alDefSizes;		// Column default sizes.
	ULONG				m_cbMinCache;		// Count of bytes of minimum cache size.

										// Cursor interaction:
	DWORD				m_fCache;			// Cache flags.
	ULONG				m_cRefs;			// Reference count of cursors.

										// Read cache:
	ULONG				m_cReadRows;		// Count of read cache rows filled.
	ULONG				m_cbReadVarData;	// Count of bytes of read cache variable data filled.
	LPVOID				m_pvReadVarData;	// Void pointer to read cache variable data.

	LPVOID				m_pvReadCache;		// Void pointer to the read cache.
	ULONG				m_cbReadCache;		// Count of bytes of read cache data filled.
	ULONG				m_cbmaxReadCache;	// Count of bytes of read cache allocated.
										// Write cache:
	ULONG				m_cWriteRows;		// Count of write cache rows filled.
	ULONG				m_cbWriteVarData;	// Count of bytes of write cache variable data filled.
	LPVOID				m_pvWriteVarData;	// Void pointer to write cache variable data.

	LPVOID				m_pvWriteCache;		// Void pointer to the write cache.
	ULONG				m_cbWriteCache;		// Count of bytes of write cache data filled.
	ULONG				m_cbmaxWriteCache;	// Count of bytes of write cache allocated.

										// Detailed errors:
	ULONG				m_cErrs;			// Count of detailed errors filled.
	ULONG				m_cmaxErrs;			// Count of detailed errors allocated.
	LPVOID				m_pvErrs;			// Void pointer to detailed errors.

	// Formerly lived in sltshp.
	ULONG				m_cRef;						// Interface reference count.
	DWORD				m_fIsDataTable;				// Either component is posing as class factory / dispenser or data table.
	DWORD				m_fTable2;					// Table flags.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\smartpointer.h ===
//  Copyright (C) 1999 Microsoft Corporation.  All rights reserved.
#pragma once

//This pointer class wraps a pointer so that delete happens automatically when the TSmartPointer goes out of scope
//If this is not the behavior you want then don't use this wrapper class

//Destructor is NOT virtual bacause I don't see why anyone would ever treat a TSmartPointerArray as a TSmartPointer

#pragma warning(disable : 4284)//It's OK to use this SmartPointer class with native types; but the -> operator doesn't make sense.  Compiler warns of this.

template <class T> class TSmartPointer
{
public:
    TSmartPointer()                     : m_p(0) {}
    TSmartPointer(T* p)                 : m_p(p) {}
    ~TSmartPointer()                    { Delete();}

    operator T*() const                 { return m_p; }
    T& operator*() const                { ASSERT(0!=m_p); return *m_p; }

    T** operator&()                     { ASSERT(0==m_p); return &m_p; }
    T* operator->() const               { ASSERT(0!=m_p); return m_p; }
    T* operator=(T* p)                  { return (m_p = p); }
    bool operator!() const              { return (0 == m_p); }
    bool operator==(const T* p) const   { return m_p == p; }

    void Delete()                       { delete m_p; m_p=0; }

    T* m_p;
private:
    TSmartPointer(const TSmartPointer<T>& p)    {}//This is private bacause it doesn't make sense to automatically clean up a copy of the pointer
};


template <class T> class TSmartPointerArray : public TSmartPointer<T>
{
public:
    TSmartPointerArray(T *p)            : TSmartPointer<T>(p) {}
    TSmartPointerArray()                : TSmartPointer<T>() {}
    ~TSmartPointerArray()               { Delete();}

    T* operator++()                     { ASSERT(0!=m_p); return ++m_p; }
    T* operator+=(int n)                { ASSERT(0!=m_p); return (m_p+=n); }
    T* operator-=(int n)                { ASSERT(0!=m_p); return (m_p-=n); }
    T* operator--()                     { ASSERT(0!=m_p); return --m_p; }
//    T& operator[](int n) const          { ASSERT(0!=m_p); return m_p[n]; }
    bool operator<(const T* p) const    { return m_p < p; }
    bool operator>(const T* p) const    { return m_p > p; }
    bool operator<=(const T* p) const   { return m_p <= p; }
    bool operator>=(const T* p) const   { return m_p >= p; }
    T* operator=(T p[])                 { return (m_p = p); }

    void Delete()                       { delete [] m_p; m_p=0; }
private:
    TSmartPointerArray(const TSmartPointerArray<T>& p)    {}//This is private bacause it doesn't make sense to automatically clean up a copy of the pointer
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\tableschema.h ===
//  Copyright (C) 2000 Microsoft Corporation.  All rights reserved.
//  Filename:       TableSchema.h
//  Author:         Stephenr
//  Date Created:   1/27/00
//  Description:    Table Schema contains all the information needed to access a table.  This
//                  includes CollectionMeta, PropertyMeta, TagMeta, Wiring etc.  Several meta
//                  tables are NOT needed for the core requirement of describing a table.
//                  These include DatabaseMeta, RelationMeta, QueryMeta, and hash tables.
//
//                  It is important to cram all of this information together to reduce the
//                  working set.  TableSchema attempts to place all of the table schema into
//                  a single page (assuming 4096 bytes).  If possible, two or more tables
//                  should fit into a single page.
//
//                  In addition to the core meta information, the string values for the meta
//                  are stored within the TableSchema.  This combined with the variable number
//                  wiring entries, and ColumnMeta rows make TableSchema a variable sized
//                  structure.
//
//                  The tables' rows are represented by a series of ULONGs.  Each ULONG repre-
//                  sents a column.  The ColumnMeta (or PropertyMeta) identifies the type of
//                  each column.  UI4s are stored directly in the ULONG.  All other types are
//                  stored in the TableSchemaHeap.  The heap is ULONG_PTR alligned (32 bit
//                  alligned on 32 bit platform / 64 bit alligned on a 64 bit platform).
//
//                  The TableSchema structure lends itself to a compact binary file format.
//                  This may become the file format for describing extensible schema.
//
//                  Indexes are byte offset from the beginning of the TableSchema.  These indexes
//                  include: iFixedTableRows, iTagMeta, iServerWiring, iClientWiring, iHeap

#pragma once


//This generates a TableID whose upper 24 bits are unique (this has to be confirmed by some routine at meta compilation time).
inline ULONG TableIDFromTableName(LPCWSTR TableName)
{
    ULONG TableID = ::Hash(TableName);
    return (TableID<<8) ^ ((TableID & 0xFF000000)>>1);//This yield a slightly lower collision rate than just bit shifting alone.
}

namespace TableSchema
{
#define INDEX           //INDEX is a column that is NOT UI4 and thus is an index into a heap (iHeap is the index to the heap from the beginning of the TableSchema)


struct CollectionMetaPrivate
{
    ULONG               CountOfTags;            //UI4
    ULONG               nTableID;               //We may make this public
    ULONG INDEX         iFixedTableRows;        //Index into the Heap (from the beginning of the heap) Fixed Table (We will put the fixed data immediately following the meta.  This way, for small tables, only one page will be faulted in.)
    ULONG               cFixedTableRows;        //Count of Rows in the Fixed Table.
    ULONG INDEX         iIndexMeta;             //Index into aIndexMeta
    ULONG               cIndexMeta;             //The number of IndexMeta entries in this table
    ULONG INDEX         iHashTableHeader;       //If the table is a fixed table, then it will have a hash table for accessing rows by primarykey(s) (ie GetRowByIdentity) Note, accessing the Fixed data may not cause a page fault; but GetRowByIdentity will since it accesses the HashTable.  For now the hash table exists in a separate heap.
    ULONG INDEX         iTagMeta;               //ULONG  offset (NOT byte offset) from the beginning of the TableSchemaHeader
    ULONG INDEX         iServerWiring;          //ULONG  offset (NOT byte offset) from the beginning of the TableSchemaHeader
    ULONG               cServerWiring;          //Count of interceptors in ServerWiring
    ULONG INDEX         iHeap;                  //ULONG  offset (NOT byte offset) from the beginning of the TableSchemaHeader
    ULONG               cbHeap;                 //Count of BYTES in the heap.  This number MUST be divisible by sizeof(int) since everything gets alligned
};
const kciCollectionMetaPrivateColumns = sizeof(CollectionMetaPrivate)/sizeof(ULONG);

struct CollectionMeta : public TableMetaPublic, public CollectionMetaPrivate{};
const kciCollectionMetaColumns = sizeof(CollectionMeta)/sizeof(ULONG);



struct PropertyMetaPrivate
{
    ULONG               CountOfTags;            //Count of Tags - Only valid for UI4s
    ULONG INDEX         iTagMeta;               //Index into aTagMeta - Only valid for UI4s
    ULONG INDEX         iIndexName;             //IndexName of a single column index (for this column)
};
const unsigned long kciPropertyMetaPrivateColumns = sizeof(PropertyMetaPrivate)/sizeof(ULONG);

struct PropertyMeta : public ColumnMetaPublic, public PropertyMetaPrivate{};
const unsigned long kciPropertyMetaColumns = sizeof(PropertyMeta)/sizeof(ULONG);



const unsigned long kciTagMetaPrivateColumns = 0;
typedef TagMetaPublic TagMeta;
const unsigned long kciTagMetaColumns = sizeof(TagMeta)/sizeof(ULONG);



const unsigned long kciServerWiringMetaPrivateColumns = 0;
typedef ServerWiringMetaPublic ServerWiringMeta;
const unsigned long kciServerWiringMetaColumns = sizeof(ServerWiringMeta)/sizeof(ULONG);






//All hash tables begin with a HashTableHeader that indicates the Modulo and the total size of the HashTable (in number of HashIndexes that follow
//the HashTableHeader).  The size should be equal to Modulo if there are NO HashIndex collisions.  If there are NO HashIndex collisions, then all
//of the HashedIndex.iNext members should be 0.  If there are collisions, all iNext values should be greater than or equal to Modulo.
struct HashedIndex
{
public:
    HashedIndex() : iNext((ULONG)-1), iOffset((ULONG)-1){}

    ULONG       iNext;  //If the hash value is not unique then this points to the next HashedIndex with the same hash value
    ULONG       iOffset;//Index offset into some heap (defined by the hash table itself)
};

class HashTableHeader
{
public:
    ULONG       Modulo;
    ULONG       Size;//This is the size in number of HashedIndexes that follow the HashTableHeader

    const HashedIndex * Get_HashedIndex(ULONG iHash) const
    {
        return (reinterpret_cast<const HashedIndex *>(this) + 1 + iHash%Modulo);
    }
    const HashedIndex * Get_NextHashedIndex(const HashedIndex *pHI) const
    {
        ASSERT(pHI->iNext >= Modulo);
        if(-1 == pHI->iNext)
            return 0;
        else
            return (reinterpret_cast<const HashedIndex *>(this) + 1 + pHI->iNext);
    }

private:
    HashTableHeader(){}//We never construct one of these.  We always cast from some pointer.
};

//The TableSchemaHeap is layed out as follows, the fixed length data comes first
/*
    ULONG           TableSchemaHeapSignature0
    ULONG           TableSchemaHeapSignature1
    ULONG           CountOfTables                       This is interesting only when no query is supplied and we want to walk through every table (this won't be efficient)
    ULONG           TableSchemaRowIndex                 This is the byte offset just beyond the last TableSchema entry.
    ULONG           EndOfHeap                           This is the byte offset just beyond the heap.  All indexes should be less than this
    ULONG           iSimpleColumnMetaHeap               This is described below
    ULONG           Reserved2
    ULONG           Reserved3
    HashTableHeader TableNameHashHeader                 This is the hash table that map a TableID to its aTableSchema byte offset (from the beginning of TableSchemaHeap)
    HashedIndex     aHashedIndex[507]                   The HashTableHeader contains the modulo (503 is the largest prime number less than the hash table size) for the hash table; but the table can never grow beyond this pre-allocated space.
                                                        This size was chosen so that the entire hash table would fit into the same page in memory.
---------------------------<Page Boundary>---------------------------
    unsigned char   aTableSchema[]                      This is where each Table's TableSchema goes.  FirstTableID (4096) == &aTableSchema[0] - &TableSchemaHeap, LastTableID == &aTableSchema[CountOfTables-1] - &TableSchemaHeap
    ULONG           aTableSchemaRowIndex[CountOfTables] This is used to walk ALL of the tables.  Presumably, someone will get all the CollectionMeta and iterate through all of them

---------------------------<SimpleColumnMetaHeap>---------------------
    ULONG           iCollectionMeta                     ULONG index from the beginning of the TableSchemaHeap
    ULONG           cCollectionMeta                     count of SimpleColumnMetas there are for CollectionMeta
    ULONG           iPropertyMeta
    ULONG           cPropertyMeta
    ULONG           iServerWiringMeta
    ULONG           cServerWiringMeta
    ULONG           iTagMeta
    ULONG           cTagMeta
    SimpleColumnMeta aSimpleColumnMeta[cCollectionMeta]
    SimpleColumnMeta aSimpleColumnMeta[cPropertyMeta]
    SimpleColumnMeta aSimpleColumnMeta[cServerWiringMeta]
    SimpleColumnMeta aSimpleColumnMeta[cTagMeta]

One optimization we could do is to make sure that every table's schema (whose size is <=4096) fits into one page.  In other words, minimize TableSchema crossing a page boundary
*/
const ULONG kMaxHashTableSize         = 507;
const ULONG TableSchemaHeapSignature0 = 0x2145e0aa;
const ULONG TableSchemaHeapSignature1 = 0xe0a8212b;

class TableSchemaHeap
{
public:
    enum TableEnum //These are the offsets to the indexes
    {
        eCollectionMeta   = 0,
        ePropertyMeta     = 2,
        eServerWiringMeta = 4,
        eTagMeta          = 6
    };

    ULONG                   Get_TableSchemaHeapSignature0()     const {return *reinterpret_cast<const ULONG *>(this);}
    ULONG                   Get_TableSchemaHeapSignature1()     const {return *(reinterpret_cast<const ULONG *>(this) + 1);}
    ULONG                   Get_CountOfTables()                 const {return *(reinterpret_cast<const ULONG *>(this) + 2);}
    ULONG                   Get_TableSchemaRowIndex()           const {return *(reinterpret_cast<const ULONG *>(this) + 3);}
    ULONG                   Get_EndOfaTableSchema()             const {return Get_TableSchemaRowIndex();}
    ULONG                   Get_EndOfHeap()                     const {return *(reinterpret_cast<const ULONG *>(this) + 4);}
    ULONG                   Get_iSimpleColumnMeta()             const {return *(reinterpret_cast<const ULONG *>(this) + 5);}
    ULONG                   Get_Reserved0()                     const {return *(reinterpret_cast<const ULONG *>(this) + 6);}
    ULONG                   Get_Reserved1()                     const {return *(reinterpret_cast<const ULONG *>(this) + 7);}
    const HashTableHeader & Get_TableNameHashHeader()           const {return *reinterpret_cast<const HashTableHeader *>(reinterpret_cast<const ULONG *>(this) + 8);}
    const HashedIndex     * Get_aHashedIndex()                  const {return reinterpret_cast<const HashedIndex *>(reinterpret_cast<const ULONG *>(this) + 8 + sizeof(HashTableHeader));}
    const ULONG           * Get_aTableSchemaRowIndex()          const {return reinterpret_cast<const ULONG *>(reinterpret_cast<const unsigned char *>(this) + Get_TableSchemaRowIndex());}
    const SimpleColumnMeta* Get_aSimpleColumnMeta(TableEnum e)  const
    {
        const ULONG * pSimpleColumnMetaHeap = reinterpret_cast<const ULONG *>(reinterpret_cast<const unsigned char *>(this) + Get_iSimpleColumnMeta());
        ULONG iSimpleColumnMeta = pSimpleColumnMetaHeap[e];
        return reinterpret_cast<const SimpleColumnMeta *>(pSimpleColumnMetaHeap+iSimpleColumnMeta);
    }

    const unsigned char   * Get_TableSchema(LPCWSTR TableName) const;
    const unsigned char   * Get_TableSchema(ULONG TableID) const;
    LPCWSTR                 Get_TableName(ULONG TableID) const;
private:
    TableSchemaHeap(){}//We never construct one of these.  We always cast from some pointer.
};

class TTableSchema
{
public:
    TTableSchema() : m_pCollectionMeta(0), m_pHeap(0), m_pPropertyMeta(0), m_pServerWiring(0), m_pTableDataHeap(0), m_pTagMeta(0){}
    HRESULT Init(const unsigned char *pTableSchema);

    const CollectionMeta      * GetCollectionMeta() const
    {
        ASSERT(0 != m_pCollectionMeta);
        return m_pCollectionMeta;
    }

    const PropertyMeta        * GetPropertyMeta(ULONG iOrder) const
    {
        ASSERT(0 != m_pCollectionMeta);
        ASSERT(iOrder<m_pCollectionMeta->CountOfProperties || 0==m_pCollectionMeta->CountOfProperties);
        return m_pPropertyMeta+iOrder;
    }

    const ServerWiringMeta    * GetServerWiringMeta() const
    {
        ASSERT(0 != m_pCollectionMeta);
        return m_pServerWiring;
    }

    //This GetTagMeta gets the first TagMeta in the table
    //Note: This will return NULL if there are no tags in the table.
    const TagMeta             * GetTagMeta() const
    {
        ASSERT(0 != m_pCollectionMeta);
        return m_pTagMeta;
    }

    //This GetTagMeta gets the first TagMeta for a given Property
    const TagMeta             * GetTagMeta(ULONG iOrder) const
    {
        ASSERT(0 != m_pCollectionMeta);
        if(-1 == iOrder)//This is reserved to mean the same as GetTagMeta for the whole table
            return GetTagMeta();

        ASSERT(iOrder<m_pCollectionMeta->CountOfProperties || 0==m_pCollectionMeta->CountOfProperties);
        return reinterpret_cast<const TagMeta *>(reinterpret_cast<const unsigned char *>(m_pCollectionMeta) + m_pPropertyMeta[iOrder].iTagMeta);
    }

    const unsigned char       * GetPointerFromIndex(ULONG index) const
    {
        ASSERT(0 != m_pCollectionMeta);
        return (0 == index ? 0 : m_pHeap + index);
    }

    const WCHAR               * GetWCharPointerFromIndex(ULONG index) const
    {
        ASSERT(0 != m_pCollectionMeta);
        return (0 == index ? 0 : reinterpret_cast<const WCHAR *>(m_pHeap + index));
    }

    const GUID                * GetGuidPointerFromIndex(ULONG index) const
    {
        ASSERT(0 != m_pCollectionMeta);
        return (0 == index ? 0 : reinterpret_cast<const GUID *>(m_pHeap + index));
    }

    ULONG                       GetPointerSizeFromIndex(ULONG index) const
    {
        return (0==index ? 0 : *(reinterpret_cast<const ULONG *>(GetPointerFromIndex(index)) - 1));
    }
    ULONG                       GetPooledHeapPointerSize(const unsigned char *p) const;

private:
    const CollectionMeta      * m_pCollectionMeta;
    const PropertyMeta        * m_pPropertyMeta;
    const TagMeta             * m_pTagMeta;
    const ServerWiringMeta    * m_pServerWiring;
    const unsigned char       * m_pHeap;
    const ULONG               * m_pTableDataHeap;
};

}//end of namespace

const ULONG  kTableSchemaSignature0 = 0xe0222093;
const ULONG  kTableSchemaSignature1 = 0x208ee01b;
typedef HRESULT( __stdcall *GETTABLESCHEMAHEAPSIGNATURES)(ULONG *signature0, ULONG *signature1, ULONG *cbTableSchemaHeap);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\tmsxmlbase.h ===
#pragma once

#define DEFINE_PRIVATEGUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

#define _CLSID_DOMDocument TMSXMLBase::GetCLSID_DOMDocument()
#define _CLSID_XMLParser   TMSXMLBase::GetCLSID_XMLParser()
#define _IID_IXMLDOMDocument IID_IXMLDOMDocument
#define _IID_IXMLDOMElement IID_IXMLDOMElement

EXTERN_C const GUID FAR IID_IXMLDOMDocument;
EXTERN_C const GUID FAR IID_IXMLDOMElement;

class TMSXMLBase
{
public:
    TMSXMLBase()  {}
    ~TMSXMLBase();
    static CLSID GetCLSID_DOMDocument();
    static CLSID GetCLSID_XMLParser();

protected:
    //protected methods
    virtual HRESULT  CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid,  LPVOID * ppv) const;
    static CLSID m_CLSID_DOMDocument;
    static CLSID m_CLSID_DOMDocument30;
    static CLSID m_CLSID_XMLParser;
    static CLSID m_CLSID_XMLParser30;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\writer.h ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    Writer.h

Abstract:

    Header for the Writer class that is used to wrap the calls to the API 
    WriteFile. 

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#pragma once

//
// Forward declaration 
//
class CLocationWriter;
class CCatalogSchemaWriter;
class CMBSchemaWriter;

enum eWriter
{
    eWriter_Schema,
    eWriter_Metabase,
    eWriter_Abort,
};

#define g_cbMaxBuffer           32768       
#define g_cchMaxBuffer          g_cbMaxBuffer/sizeof(WCHAR)
#define g_cbMaxBufferMultiByte  32768

class CWriter
{

    public:

        CWriter();

        ~CWriter();

        HRESULT Initialize(LPCWSTR               wszFile,
                           CWriterGlobalHelper*  i_pCWriterGlobalHelper,
                           HANDLE                hFile);

        HRESULT WriteToFile(LPVOID  pvData,
                            DWORD   cchData,
                            BOOL    bForceFlush = FALSE);

        HRESULT BeginWrite(eWriter              eType,
                                   PSECURITY_ATTRIBUTES pSecurityAtrributes = NULL);

        HRESULT GetLocationWriter(CLocationWriter** ppLocationWriter,
                                  LPCWSTR           wszLocation);

        HRESULT GetCatalogSchemaWriter(CCatalogSchemaWriter** ppSchemaWriter);

        HRESULT GetMetabaseSchemaWriter(CMBSchemaWriter** ppSchemaWriter);

        HRESULT EndWrite(eWriter eType);

    private:
        HRESULT FlushBufferToDisk();
        HRESULT ConstructFile(PSECURITY_ATTRIBUTES pSecurityAtrributes);
        HRESULT SetSecurityDescriptor();
        void    FreeSecurityRelatedMembers();

    private:
        LPWSTR              m_wszFile;
        BOOL                m_bCreatedFile;
        BOOL                m_bCreatedGlobalHelper;
        ULONG               m_cbBufferUsed;
        BYTE                m_Buffer[g_cbMaxBuffer];
        BYTE                m_BufferMultiByte[g_cbMaxBufferMultiByte];
        PSID                 m_psidSystem;
        PSID                 m_psidAdmin;
        PACL                 m_paclDiscretionary;
        PSECURITY_DESCRIPTOR m_psdStorage;


    public:
        HANDLE                  m_hFile;
        CWriterGlobalHelper*    m_pCWriterGlobalHelper;
        ISimpleTableWrite2*     m_pISTWrite;

}; // Class CWriter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\tfilemapping.h ===
#pragma once

#define E_ERROR_OPENING_FILE    0x80000004

//  TFileMapping
//
//  This class abstracts the mapping process and guarentees cleanup.
class TFileMapping
{
public:
    TFileMapping() : m_hFile(NULL), m_hMapping(NULL), m_pMapping(NULL), m_Size(NULL) {}
    ~TFileMapping(){Unload();}

    HRESULT Load(LPCTSTR filename, bool bReadWrite = false)
    {
        HRESULT         hr = S_OK;

        ASSERT( NULL == m_hFile );

        m_hFile = CreateFile(filename, GENERIC_READ | (bReadWrite ? GENERIC_WRITE : 0), FILE_SHARE_READ | (bReadWrite ?  0 : FILE_SHARE_WRITE), NULL, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL);
        if ( m_hFile == INVALID_HANDLE_VALUE )
        {
            hr = E_ERROR_OPENING_FILE;
            goto exit;
        }

        m_hMapping = CreateFileMappingA(m_hFile, NULL, (bReadWrite ? PAGE_READWRITE : PAGE_READONLY), 0, 0, NULL);
        if ( m_hMapping == NULL )
        {
            hr = E_ERROR_OPENING_FILE;
            goto exit;
        }

        m_pMapping = reinterpret_cast<char *>(MapViewOfFile(m_hMapping, (bReadWrite ? FILE_MAP_WRITE : FILE_MAP_READ), 0, 0, 0));
        m_Size = GetFileSize(m_hFile, 0);

    exit:
        if ( FAILED(hr) )
        {
            Unload();
        }

        return hr;
    }

    HRESULT Unload()
    {
        if (m_pMapping)
        {
            if (0 == FlushViewOfFile(m_pMapping,0))
            {
                ASSERT(false && "ERROR - UNABLE TO FLUSH TO DISK");
            }
            UnmapViewOfFile(m_pMapping);
        }

        if ( m_hMapping != NULL )
        {
            CloseHandle(m_hMapping);
        }
        if ( ( m_hFile != NULL ) && ( m_hFile != INVALID_HANDLE_VALUE ) )
        {
            CloseHandle(m_hFile);
        }

        m_pMapping  = NULL;
        m_hMapping  = NULL;
        m_hFile     = NULL;
        m_Size      = 0;

		return S_OK;
    }

    unsigned long   Size() const {return m_Size;}
    char *          Mapping() const {return m_pMapping;}
    char *          EndOfFile() const {return (m_pMapping + m_Size);}

private:
    HANDLE          m_hFile;
    HANDLE          m_hMapping;
    char *          m_pMapping;
    unsigned long   m_Size;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\txmlparsedfile.h ===
#pragma once

typedef VOID (__stdcall * INTERLOCKEDEXCHANGEADD)(PLONG, LONG);

//These classes are used to cache any XML files that have already been parsed.
struct TAttribute
{
    TAttribute() : m_NameLength(0), m_Name(0), m_ValueLength(0), m_Value(0){}
    DWORD   m_NameLength;
    LPCWSTR m_Name;
    DWORD   m_ValueLength;
    LPCWSTR m_Value;
};

enum XmlNodeFlags
{
    fNone           = 0x00,
    fBeginTag       = 0x01,
    fEndTag         = 0x02,
    fBeginEndTag    = 0x03,
};

struct TElement
{
    TElement() : m_LevelOfElement(0), m_ElementNameLength(0), m_ElementName(0), m_NumberOfAttributes(0), m_ElementType(XML_ELEMENT){}
    DWORD           m_LevelOfElement;
    union
    {
        DWORD           m_ElementNameLength;
        DWORD           m_cchElementValue;
        DWORD           m_cchComment;
        DWORD           m_cchWhiteSpace;
    };
    union
    {
        LPCWSTR         m_ElementName;
        LPCWSTR         m_ElementValue;
        LPCWSTR         m_Comment;
        LPCWSTR         m_WhiteSpace;
    };
    DWORD           m_NodeFlags;//OR of any of the XmlNodeFlags flags
    DWORD           m_NumberOfAttributes;//This can be non zero for XML_ELEMENTs only
    XML_NODE_TYPE   m_ElementType;//only XML_ELEMENT(1), XML_PCDATA(13), XML_COMMENT(16) & XML_WHITESPACE(18) are supported
    TAttribute  m_aAttribute[1];

    TElement * Next() const {return const_cast<TElement *>(reinterpret_cast<const TElement *>(reinterpret_cast<const unsigned char *>(this + 1) + (static_cast<int>(m_NumberOfAttributes)-1) * sizeof(TAttribute)));}
    bool        IsValid() const {return (m_LevelOfElement>0 && m_ElementType>0);}
};


//This class is a callback interface.  It is passed into the TXmlParsedFile::Parse method.
class TXmlParsedFileNodeFactory
{
public:
    virtual HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid,  LPVOID * ppv) const {return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);}
    virtual HRESULT CreateNode(const TElement &Element) = 0;
};


class TXmlParsedFileCache;


/*The data is layed out in the following structure:
[DWORD-Level of Element][DWORD-String Length of Element Name][LPCWSTR-Element Name][DWORD-Number Of Attributes][DWORD-Length of Attribute Name][LPCWSTR-Attribute Name][DWORD-Length of Attribute Value][LPCWSTR-Attribute Value]...[DWORD-Length of Attribute Name][LPCWSTR-Attribute Name][DWORD-Length of Attribute Value][LPCWSTR-Attribute Value]

The strings are NOT NULL terminated
The 'Number Of Attributes' DWORD allows for skipping over elements.
The structures above allow for easier access to the pool of TElements.
*/

class TXmlParsedFile : public _unknown<IXMLNodeFactory>, public TFileMapping
{
public:
    TXmlParsedFile();
    ~TXmlParsedFile();

    //If the file hasn't already been parsed, it calls into the CLSID_XMLParser, otherwise it just calls back TXmlParsedFileNodeFactory for
    //each element under the root (excluding the root element).  By putting the XmlParsedNodeFactory as a parameter we don't have to synchronize
    //call pairs like (SetFactory and Parse).
    virtual HRESULT         Parse(TXmlParsedFileNodeFactory &i_XmlParsedFileNodeFactory, LPCTSTR i_filename, bool bOnlyIfInCache=false);
    virtual HRESULT            Unload();

//This method is only called FROM the cache itself.
    void                    SetCache(TXmlParsedFileCache &cache){m_pCache = &cache;}//If NO cache is set then the object won't be cached.  You can remove it from the cache once added.
    DWORD                   GetLastParseTime() const {return m_dwTickCountOfLastParse;}
    bool                    IsCompletedParse() const {return !!m_ElementPool;}
    unsigned long           PoolSize() const {return m_cbElementPool + m_cbStringPool;}


//IXMLNodeFactory methods
private:
    HRESULT STDMETHODCALLTYPE BeginChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);

    HRESULT STDMETHODCALLTYPE CreateNode( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ PVOID pNodeParent,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

    HRESULT STDMETHODCALLTYPE EndChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ BOOL fEmptyNode,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);
    
    HRESULT STDMETHODCALLTYPE Error( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ HRESULT hrErrorCode,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

	HRESULT STDMETHODCALLTYPE NotifyEvent( 
			/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
			/* [in] */ XML_NODEFACTORY_EVENT iEvt);


//helper functions
private:
    LPCWSTR         AddStringToPool(LPCWSTR i_String, unsigned long i_Length);
    HRESULT         AllocateAndCopyElementList(unsigned long i_Length);
    void            AppendToLastStringInPool(LPCWSTR i_String, unsigned long i_Length);
    HRESULT         Load(LPCTSTR i_filename);
    VOID            MemberInterlockedExchangeAdd(PLONG Addend, LONG Increment);

//member variables
private:
    unsigned long                               m_cbElementPool;
    unsigned long                               m_cbStringPool;
    unsigned long                               m_cElements;                    //Count of elements in this XML file.
    CSafeAutoCriticalSection                    m_SACriticalSectionThis;        //While accessing this object, users should ask for the critical section and lock it.
    unsigned long                               m_CurrentLevelBelowRootElement; //This is used while MSXML parsing to keep track of the level below the root element (0 indicating root element level)
    unsigned long                               m_cWcharsInStringPool;          //This is the offset just beyond the last String in the pool.  This is where the next string would be added.
    TSmartPointerArray<unsigned char>           m_ElementPool;                  //We build the element pool into a growable buffer, then we know how big it needs to be and slam it into here.
    WCHAR                                       m_FileName[MAX_PATH];           //XML file name
    FILETIME                                    m_ftLastWriteTime;              //Remember the last time the file was written so we can deterime whether to reparse
    TElement           *                        m_pElement;                     //Reused.  While MSXML parsing it points into the GrowableBuffer, after calling AllocateAndCopyElementList it points to the allocated space
    TElement           *                        m_pLastBeginTagElement;
    TSmartPointerArray<WCHAR>                   m_StringPool;                   //To make sure we have enough pool space, we allocate the same size as the file.

    //These members are needed to make the TXmlParsedFile cache aware
    DWORD                                       m_dwTickCountOfLastParse;
    TXmlParsedFileCache *                       m_pCache;

//static member variables
private:
    static TSmartPointerArray<unsigned char>    m_aGrowableBuffer;              //This is a shared buffer used while MSXML parsing of the file.
    static CSafeAutoCriticalSection             m_SACriticalSectionStaticBuffers; //This is to guard the shared buffers.  This means only one XML file can be parsing via MSXML at once.
    static unsigned long                        m_SizeOfGrowableBuffer;         //Size of the Growable buffer.
    static int                                  m_OSSupportForInterLockedExchangeAdd;
    static INTERLOCKEDEXCHANGEADD               m_pfnInterLockedExchangeAdd;
    enum
    {
        Undetermined = -1,
        Supported    = 0,
        Unsupported  = 1
    };

};


class TXmlParsedFileCache
{

public:
    enum CacheSize
    {
        CacheSize_mini    = 3,
        CacheSize_small   = 97    ,
        CacheSize_medium  = 331   ,
        CacheSize_large   = 997
    };
    TXmlParsedFileCache() : m_cCacheEntry(CacheSize_mini), m_cbTotalCache(0){}

    void AgeOutCache(DWORD dwKeepAliveTime)
    {
        DWORD dwTimeToAgeOutCacheEntry = GetTickCount() - (dwKeepAliveTime ? dwKeepAliveTime : static_cast<DWORD>(kTimeToAgeOutCacheEntry));
        for(int iCacheEntry=0;iCacheEntry<m_cCacheEntry;++iCacheEntry)
        {
            if(m_aCacheEntry[iCacheEntry].GetLastParseTime() < dwTimeToAgeOutCacheEntry)
                m_aCacheEntry[iCacheEntry].Unload();
        }
    }
    TXmlParsedFile * GetXmlParsedFile(LPCWSTR filename)
    {
        ASSERT(IsInitialized());

        unsigned int iCache = Hash(filename) % m_cCacheEntry;
        m_aCacheEntry[iCache].SetCache(*this);//Each cache entry needs a pointer to the cache itself, if we don't call SetCache the TXmlParsedFile won't be considered part of the cache
        return (m_aCacheEntry + iCache);
    }
    HRESULT Initialize(CacheSize size=CacheSize_small)
    {
        if(IsInitialized())
            return S_OK;
        m_cCacheEntry = size;

        m_aCacheEntry = new TXmlParsedFile[m_cCacheEntry];
        if(!m_aCacheEntry)
            return E_OUTOFMEMORY;
        return S_OK;
    }
    bool IsInitialized() const {return !!m_aCacheEntry;}

    long                                m_cbTotalCache;//This is update by the TXmlParsedFile object when it does an MSXML parse (or an Unload).
private:
    enum
    {
        kTimeToAgeOutCacheEntry = 5*60*1000 //5 minutes
    };
    TSmartPointerArray<TXmlParsedFile>  m_aCacheEntry;
    CacheSize                           m_cCacheEntry;
};


class TXmlParsedFile_NoCache : public _unknown<IXMLNodeFactory>, public TFileMapping
{
public:
    TXmlParsedFile_NoCache();
    ~TXmlParsedFile_NoCache();

    virtual HRESULT         Parse(TXmlParsedFileNodeFactory &i_XmlParsedFileNodeFactory, LPCTSTR i_filename);

//IXMLNodeFactory methods
private:
    HRESULT STDMETHODCALLTYPE BeginChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);

    HRESULT STDMETHODCALLTYPE CreateNode( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ PVOID pNodeParent,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

    HRESULT STDMETHODCALLTYPE EndChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ BOOL fEmptyNode,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);
    
    HRESULT STDMETHODCALLTYPE Error( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ HRESULT hrErrorCode,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

	HRESULT STDMETHODCALLTYPE NotifyEvent( 
			/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
			/* [in] */ XML_NODEFACTORY_EVENT iEvt);

//member variables
private:
    ULONG                                   m_CurrentLevelBelowRootElement;
    TElement                              * m_pElement;
    TXmlParsedFileNodeFactory             * m_pXmlParsedFileNodeFactory;
    TSmartPointerArray<unsigned char>       m_ScratchBuffer;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\writerglobals.h ===
#pragma once

extern LPCWSTR  g_wszBeginFile0;
extern ULONG	g_cchBeginFile0;
extern LPCWSTR	g_wszBeginFile1;
extern ULONG	g_cchBeginFile1;
extern LPCWSTR	g_wszEndFile;					
extern ULONG	g_cchEndFile;					
extern LPCWSTR	g_BeginLocation;
extern ULONG	g_cchBeginLocation;				
extern LPCWSTR	g_Location;						
extern ULONG	g_cchLocation;					
extern LPCWSTR	g_EndLocationBegin;				
extern ULONG	g_cchEndLocationBegin;			
extern LPCWSTR	g_EndLocationEnd;				
extern ULONG	g_cchEndLocationEnd;				
extern LPCWSTR  g_CloseQuoteBraceRtn;			
extern ULONG	g_cchCloseQuoteBraceRtn;			
extern LPCWSTR  g_Rtn;							
extern ULONG	g_cchRtn;						
extern LPCWSTR  g_EqQuote;						
extern ULONG	g_cchEqQuote;					
extern LPCWSTR  g_QuoteRtn;						
extern ULONG	g_cchQuoteRtn;					
extern LPCWSTR  g_TwoTabs;						
extern ULONG	g_cchTwoTabs;					
extern LPCWSTR	g_NameEq;						
extern ULONG	g_cchNameEq;						
extern LPCWSTR	g_IDEq;							
extern ULONG	g_cchIDEq;						
extern LPCWSTR	g_ValueEq;						
extern ULONG	g_cchValueEq;					
extern LPCWSTR	g_TypeEq;						
extern ULONG	g_cchTypeEq;						
extern LPCWSTR	g_UserTypeEq;					
extern ULONG	g_cchUserTypeEq;					
extern LPCWSTR	g_AttributesEq;					
extern ULONG	g_cchAttributesEq;				
extern LPCWSTR	g_BeginGroup;					
extern ULONG	g_cchBeginGroup;					
extern LPCWSTR	g_EndGroup;						
extern ULONG	g_cchEndGroup;					
extern LPCWSTR	g_BeginCustomProperty;			
extern ULONG	g_cchBeginCustomProperty;		
extern LPCWSTR	g_EndCustomProperty;				
extern ULONG	g_cchEndCustomProperty;			
extern LPCWSTR	g_ZeroHex;						
extern ULONG	g_cchZeroHex;
extern LPCWSTR	g_wszIIsConfigObject;
extern LPCWSTR  g_BeginComment;
extern ULONG    g_cchBeginComment;
extern LPCWSTR  g_EndComment;
extern ULONG    g_cchEndComment;

extern WORD    BYTE_ORDER_MASK;
extern DWORD	UTF8_SIGNATURE;

extern LPWSTR  g_wszByID;
extern LPWSTR  g_wszByName;
extern LPWSTR  g_wszByTableAndColumnIndexOnly;
extern LPWSTR  g_wszByTableAndColumnIndexAndNameOnly;
extern LPWSTR  g_wszByTableAndColumnIndexAndValueOnly;
extern LPWSTR  g_wszByTableAndTagNameOnly;
extern LPWSTR  g_wszByTableAndTagIDOnly;
extern LPWSTR  g_wszUnknownName;
extern ULONG   g_cchUnknownName;             
extern LPWSTR  g_UT_Unknown;
extern ULONG   g_cchUT_Unknown;
extern LPWSTR  g_T_Unknown;
extern LPWSTR  g_wszTrue;
extern ULONG   g_cchTrue;
extern LPWSTR  g_wszFalse;
extern ULONG   g_cchFalse;
extern ULONG   g_cchMaxBoolStr;

extern LPCWSTR g_wszHistorySlash;
extern ULONG   g_cchHistorySlash;
extern LPCWSTR g_wszMinorVersionExt;
extern ULONG   g_cchMinorVersionExt;
extern LPCWSTR g_wszDotExtn;
extern ULONG   g_cchDotExtn;
extern WCHAR   g_wchBackSlash;
extern WCHAR   g_wchFwdSlash;
extern WCHAR   g_wchDot;

extern ULONG  g_cchTemp;
extern WCHAR  g_wszTemp[];
extern LPCWSTR g_wszBeginSchema;
extern ULONG   g_cchBeginSchema;
extern LPCWSTR g_wszEndSchema;
extern ULONG   g_cchEndSchema;
extern LPCWSTR g_wszBeginCollection;
extern ULONG   g_cchBeginCollection;
extern LPCWSTR g_wszEndBeginCollectionMB;
extern ULONG   g_cchEndBeginCollectionMB;
extern LPCWSTR g_wszEndBeginCollectionCatalog;
extern ULONG   g_cchEndBeginCollectionCatalog;
extern LPCWSTR g_wszInheritsFrom;
extern ULONG   g_cchInheritsFrom;
extern LPCWSTR g_wszEndCollection;
extern ULONG   g_cchEndCollection;
extern LPCWSTR g_wszBeginPropertyShort; 
extern ULONG   g_cchBeginPropertyShort;
extern LPCWSTR g_wszMetaFlagsExEq;
extern ULONG   g_cchMetaFlagsExEq;
extern LPCWSTR g_wszMetaFlagsEq;
extern ULONG   g_cchMetaFlagsEq;
extern LPCWSTR g_wszEndPropertyShort; 
extern ULONG   g_cchEndPropertyShort; 
extern LPCWSTR g_wszBeginPropertyLong;
extern ULONG   g_cchBeginPropertyLong;
extern LPCWSTR g_wszPropIDEq;
extern ULONG   g_cchPropIDEq;
extern LPCWSTR g_wszPropTypeEq;
extern ULONG   g_cchPropTypeEq;
extern LPCWSTR g_wszPropUserTypeEq;
extern ULONG   g_cchPropUserTypeEq;
extern LPCWSTR g_wszPropAttributeEq;
extern ULONG   g_cchPropAttributeEq;
extern LPWSTR  g_wszPropMetaFlagsEq; 
extern ULONG   g_cchPropMetaFlagsEq; 
extern LPWSTR  g_wszPropMetaFlagsExEq;
extern ULONG   g_cchPropMetaFlagsExEq;
extern LPWSTR  g_wszPropDefaultEq;    
extern ULONG   g_cchPropDefaultEq;    
extern LPWSTR  g_wszPropMinValueEq;   
extern ULONG   g_cchPropMinValueEq;   
extern LPWSTR  g_wszPropMaxValueEq;   
extern ULONG   g_cchPropMaxValueEq;  
extern LPWSTR  g_wszEndPropertyLongNoFlag;
extern ULONG   g_cchEndPropertyLongNoFlag;
extern LPWSTR  g_wszEndPropertyLongBeforeFlag;
extern ULONG   g_cchEndPropertyLongBeforeFlag;
extern LPWSTR  g_wszEndPropertyLongAfterFlag;
extern ULONG   g_cchEndPropertyLongAfterFlag; 
extern LPCWSTR g_wszBeginFlag; 
extern ULONG   g_cchBeginFlag; 
extern LPCWSTR g_wszFlagValueEq;   
extern ULONG   g_cchFlagValueEq;   
extern LPCWSTR g_wszEndFlag;
extern ULONG   g_cchEndFlag;
extern LPCWSTR g_wszEndPropertyShort;

extern LPCWSTR g_wszOr;
extern ULONG   g_cchOr;
extern LPCWSTR g_wszOrManditory;
extern ULONG    g_cchOrManditory;
extern LPCWSTR g_wszFlagIDEq;
extern ULONG   g_cchFlagIDEq;
extern LPCWSTR g_wszContainerClassListEq;
extern ULONG   g_cchContainerClassListEq;

extern LPCWSTR g_wszSlash;
extern ULONG   g_cchSlash;
extern LPCWSTR g_wszLM;
extern ULONG   g_cchLM;
extern LPCWSTR g_wszSchema;
extern ULONG   g_cchSchema;
extern LPCWSTR g_wszSlashSchema;
extern ULONG   g_cchSlashSchema;
extern LPCWSTR g_wszSlashSchema;
extern ULONG   g_cchSlashSchema;
extern LPCWSTR g_wszSlashSchemaSlashProperties;
extern ULONG   g_cchSlashSchemaSlashProperties;
extern LPCWSTR g_wszSlashSchemaSlashPropertiesSlashNames;
extern ULONG   g_cchSlashSchemaSlashPropertiesSlashNames;
extern LPCWSTR g_wszSlashSchemaSlashPropertiesSlashTypes;
extern ULONG   g_cchSlashSchemaSlashPropertiesSlashTypes;
extern LPCWSTR g_wszSlashSchemaSlashPropertiesSlashDefaults;
extern ULONG   g_cchSlashSchemaSlashPropertiesSlashDefaults;
extern LPCWSTR g_wszSlashSchemaSlashClasses;
extern ULONG   g_cchSlashSchemaSlashClasses;
extern LPWSTR  g_wszEmptyMultisz;
extern ULONG   g_cchEmptyMultisz;
extern LPWSTR  g_wszEmptyWsz;
extern ULONG   g_cchEmptyWsz;
extern LPCWSTR g_wszComma;
extern ULONG   g_cchComma;
extern LPCWSTR g_wszMultiszSeperator;
extern ULONG   g_cchMultiszSeperator;


extern LPCWSTR g_aSynIDToWszType[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\plugins\metabasedifferencing\metabasedifferencing.cpp ===
//  Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

ULONG   TMetabaseDifferencing::m_kInsert      = eMBPropertyDiff_Insert;
ULONG   TMetabaseDifferencing::m_kUpdate      = eMBPropertyDiff_Update;
ULONG   TMetabaseDifferencing::m_kDelete      = eMBPropertyDiff_Delete;
ULONG   TMetabaseDifferencing::m_kDeleteNode  = eMBPropertyDiff_DeleteNode;
ULONG   TMetabaseDifferencing::m_kOne         = 1;
ULONG   TMetabaseDifferencing::m_kTwo         = 1;
ULONG   TMetabaseDifferencing::m_kZero        = 0;


// =======================================================================
TMetabaseDifferencing::TMetabaseDifferencing() :
                 m_cRef         (0)
                ,m_IsIntercepted(0)
{
    ASSERT(cMBProperty_NumberOfColumns == (cMBPropertyDiff_NumberOfColumns - 1));
}

TMetabaseDifferencing::~TMetabaseDifferencing()
{
}

// =======================================================================
// IInterceptorPlugin:

HRESULT TMetabaseDifferencing::Intercept (LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat,
                                          DWORD i_fLOS, IAdvancedTableDispenser* i_pISTDisp,LPCWSTR /*i_wszLocator unused*/, LPVOID i_pSimpleTable, LPVOID* o_ppv)
{
// Parameter validation:
    if (_wcsicmp(i_wszDatabase,    wszDATABASE_METABASE)                    )return E_ST_INVALIDTABLE;
    if (_wcsicmp(   i_wszTable,    wszTABLE_MBPropertyDiff)                 )return E_ST_INVALIDTABLE;
    if (TABLEID_MBPropertyDiff != i_TableID                                 )return E_ST_INVALIDTABLE;
    if (                  NULL == i_QueryData                               )return E_INVALIDARG;
    if (                  NULL == i_QueryMeta                               )return E_INVALIDARG;
    if (                     2 >  *reinterpret_cast<ULONG *>(i_QueryMeta)   )return E_INVALIDARG;
    if ( eST_QUERYFORMAT_CELLS != i_eQueryFormat                            )return E_INVALIDARG;
    if (    ~fST_LOS_READWRITE &  i_fLOS                                    )return E_ST_LOSNOTSUPPORTED;
    if (                  NULL == i_pISTDisp                                )return E_INVALIDARG;
    if (                  NULL != i_pSimpleTable                            )return E_INVALIDARG;
    if (                  NULL == o_ppv                                     )return E_INVALIDARG;
    if (                  NULL != *o_ppv                                    )return E_INVALIDARG;

//Check the object state
    if(m_IsIntercepted) return E_ST_INVALIDCALL;

    STQueryCell *   pQueryCell  = (STQueryCell*) i_QueryData;    // Query cell array from caller.
    STQueryCell     aQueryCellOriginalFile[2];//this holds the query with the OriginalFileName and optionally the SchemaFileName
    STQueryCell     aQueryCellUpdatedFile[2]; //this holds the query with the UpdatedFileName and optionally the SchemaFileName

    memset(aQueryCellOriginalFile, 0x00, 2*sizeof(STQueryCell));
    memset(aQueryCellUpdatedFile,  0x00, 2*sizeof(STQueryCell));

    ULONG           cQueryCount = i_QueryMeta ? *reinterpret_cast<ULONG *>(i_QueryMeta) : 0;
    for(ULONG iQueryCell=0; iQueryCell<cQueryCount; ++iQueryCell)//Get the only query cells we care about, and save the information.
    {
        if(pQueryCell[iQueryCell].iCell & iST_CELL_SPECIAL)
        {
            if(pQueryCell[iQueryCell].pData     != 0                  &&
               pQueryCell[iQueryCell].eOperator == eST_OP_EQUAL       &&
               pQueryCell[iQueryCell].iCell     == iST_CELL_FILE      &&
               pQueryCell[iQueryCell].dbType    == DBTYPE_WSTR        )
            {
                //The first iST_CELL_FILE should be the OriginalFile, the second should be the UpdatedFile.
                if(0 == aQueryCellOriginalFile[0].pData)
                    memcpy(&aQueryCellOriginalFile[0], &pQueryCell[iQueryCell], sizeof(STQueryCell));
                else if(0 == aQueryCellUpdatedFile[0].pData)
                    memcpy(&aQueryCellUpdatedFile[0], &pQueryCell[iQueryCell], sizeof(STQueryCell));
                else
                    return E_ST_INVALIDQUERY;//More than two file names?  Hmm, what would I do with that?
            }
            else if(pQueryCell[iQueryCell].pData!= 0                   &&
               pQueryCell[iQueryCell].eOperator == eST_OP_EQUAL        &&
               pQueryCell[iQueryCell].iCell     == iST_CELL_SCHEMAFILE &&
               pQueryCell[iQueryCell].dbType    == DBTYPE_WSTR        /*&&
               pQueryCell[iQueryCell].cbSize    == (wcslen(reinterpret_cast<WCHAR *>(pQueryCell[iQueryCell].pData))+1)*sizeof(WCHAR)*/)
            {
                memcpy(&aQueryCellOriginalFile[1], &pQueryCell[iQueryCell], sizeof(STQueryCell));
                memcpy(&aQueryCellUpdatedFile[1],  &pQueryCell[iQueryCell], sizeof(STQueryCell));
            }
        }
        else//Any query other than iST_CELL_SPECIAL is an INVALIDQUERY
            return E_ST_INVALIDQUERY;
    }
    if(0 == aQueryCellUpdatedFile[0].pData)//The user must supply two URLPaths.
        return E_ST_INVALIDQUERY;

    //Get the IST to the Original Metabase file
    HRESULT hr;
    if(FAILED(hr = i_pISTDisp->GetTable(wszDATABASE_METABASE, wszTABLE_MBProperty, aQueryCellOriginalFile, reinterpret_cast<LPVOID>(0==aQueryCellOriginalFile[1].pData ? &m_kOne : &m_kTwo),
                         eST_QUERYFORMAT_CELLS, fST_LOS_NONE, reinterpret_cast<void **>(&m_ISTOriginal))))return hr;

    //Get the IST to the Update Metabase file
    if(FAILED(hr = i_pISTDisp->GetTable(wszDATABASE_METABASE, wszTABLE_MBProperty, aQueryCellUpdatedFile,  reinterpret_cast<LPVOID>(0==aQueryCellUpdatedFile[1].pData ? &m_kOne : &m_kTwo),
                         eST_QUERYFORMAT_CELLS, fST_LOS_NONE, reinterpret_cast<void **>(&m_ISTUpdated))))return hr;

    //Finally create the fast cache that will hold the difference of these two Metabase files/tables.
    if(FAILED(hr = i_pISTDisp->GetMemoryTable(i_wszDatabase, i_wszTable, i_TableID, 0, 0, i_eQueryFormat, i_fLOS, reinterpret_cast<ISimpleTableWrite2 **>(o_ppv))))
        return hr;

    InterlockedIncrement(&m_IsIntercepted);//We can only be called to Intercept once.

    return S_OK;
}

HRESULT TMetabaseDifferencing::OnPopulateCache(ISimpleTableWrite2* i_pISTW2)
{
// Construct merged view:
    CComQIPtr<ISimpleTableController, &IID_ISimpleTableController> pISTController = i_pISTW2;
    if(0 == pISTController.p)return E_UNEXPECTED;

    HRESULT hr;
	if (FAILED(hr = pISTController->PrePopulateCache (0))) return hr;


    ULONG aOriginalSize[cMBPropertyDiff_NumberOfColumns];
    ULONG aUpdatedSize[cMBPropertyDiff_NumberOfColumns];

    memset(aOriginalSize, 0x00, sizeof(aOriginalSize));
    memset(aUpdatedSize,  0x00, sizeof(aUpdatedSize));

    ULONG iRowOriginal=0;
    ULONG iRowUpdated =0;
    ULONG cRowOriginal=0;
    ULONG cRowUpdated =0;

    if(FAILED(hr = m_ISTOriginal->GetTableMeta(0, 0, &cRowOriginal, 0)))return hr;
    if(FAILED(hr = m_ISTUpdated->GetTableMeta(0, 0, &cRowUpdated,  0)))return hr;

//         WCHAR *     pName;
//         ULONG *     pType;
//         ULONG *     pAttributes;
// unsigned char *     pValue;
//         ULONG *     pGroup;
//         WCHAR *     pLocation;
//         ULONG *     pID;
//         ULONG *     pUserType;
//         ULONG *     pLocationID;
//         ULONG *     pDirective;

    tMBPropertyDiffRow OriginalRow;
    ULONG PrevOriginalLocationID = 0;
    if(cRowOriginal > 0)
    {
        if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
            return hr;
    }
	else
	{
		//initialize it
		memset (&OriginalRow, 0x00, sizeof (tMBPropertyDiffRow));
	}

    tMBPropertyDiffRow UpdatedRow;
    if(cRowUpdated > 0)
    {
        if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTUpdated, iRowUpdated, aUpdatedSize, UpdatedRow)))
            return hr;
    }
	else
	{
		//initialize it
		memset (&UpdatedRow, 0x00, sizeof (tMBPropertyDiffRow));
	}

    while(iRowOriginal < cRowOriginal && iRowUpdated < cRowUpdated)
    {


        int iLocationCompare = _wcsicmp(OriginalRow.pLocation, UpdatedRow.pLocation);

        if(iLocationCompare == 0)
        {
            ULONG LocationIDOriginal = *OriginalRow.pLocationID;
            ULONG LocationIDUpdated  = *UpdatedRow.pLocationID;
            while(*OriginalRow.pLocationID==LocationIDOriginal || *UpdatedRow.pLocationID==LocationIDUpdated)
            {
                //There are three cases we need to handle.  The current Rows we are comparing are:
                //  1> Both Original metabase and Updated metabase are at the same location (always true the first time through the loop)
                //  2> The Updated metabase row now points to a different location.  This means all remaining of the Original metabase rows for the
                //          location should be marked as Deleted.
                //  3> The Original metabase row now points to a different location.  This means all remaining of the Updated metabase rows for the
                //          location should be marked as Inserted.

                if(*OriginalRow.pLocationID==LocationIDOriginal && *UpdatedRow.pLocationID==LocationIDUpdated)
                {
                    //Now go through all of the properties for this location and compare them
                    int iNameCompare = _wcsicmp(OriginalRow.pName, UpdatedRow.pName);

                    if(iNameCompare == 0)
                    {   //Now go through each of the attributes of this property to see if this property has changed
                        if(     *OriginalRow.pType              != *UpdatedRow.pType
                            ||  *OriginalRow.pAttributes        != *UpdatedRow.pAttributes
                            ||  *OriginalRow.pGroup             != *UpdatedRow.pGroup
                            ||  *OriginalRow.pID                != *UpdatedRow.pID
                            ||  *OriginalRow.pUserType          != *UpdatedRow.pUserType
                            ||  aOriginalSize[iMBProperty_Value]!= aUpdatedSize[iMBProperty_Value]
                            ||  memcmp(OriginalRow.pValue ? reinterpret_cast<void *>(OriginalRow.pValue) : reinterpret_cast<void *>(&m_kZero),
                                       UpdatedRow.pValue  ? reinterpret_cast<void *>(UpdatedRow.pValue)  : reinterpret_cast<void *>(&m_kZero), aOriginalSize[iMBProperty_Value]))
                        {//The row needs to be updated
                            if(FAILED(hr = UpdateRow(UpdatedRow, aUpdatedSize, i_pISTW2)))return hr;
                        }

                        ++iRowOriginal;
                        if(iRowOriginal < cRowOriginal)
                        {
                            PrevOriginalLocationID = *OriginalRow.pLocationID;
                            if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
                                return hr;
                        }

                        ++iRowUpdated;
                        if(iRowUpdated < cRowUpdated)
                        {
                            if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTUpdated, iRowUpdated, aUpdatedSize, UpdatedRow)))
                                return hr;
                        }
                        if(iRowUpdated == cRowUpdated || iRowOriginal == cRowOriginal)
                            break;
                    }
                    else if(iNameCompare < 0)
                    {   //The OriginalRow.pName property was removed
                        OriginalRow.pLocationID = UpdatedRow.pLocationID;//This makes the LocationID match the UpdatedRow
                        //This is important so an Insert followed by a Delete  (of the same location) have the same LocationID

                        if(FAILED(hr = DeleteRow(OriginalRow, aOriginalSize, i_pISTW2)))return hr;

                        ++iRowOriginal;
                        if(iRowOriginal == cRowOriginal)//if we reached the end of the Original properties then bail the while loop
                            break;
                        PrevOriginalLocationID = *OriginalRow.pLocationID;
                        if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
                            return hr;
                    }
                    else //if(iNameCompare > 0)
                    {   //The UpdatedRow.pName property was added
                        if(FAILED(hr = InsertRow(UpdatedRow, aUpdatedSize, i_pISTW2)))return hr;

                        ++iRowUpdated;
                        if(iRowUpdated == cRowUpdated)//if we reached the end of the Updated property list then bail the while loop
                            break;
                        if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTUpdated, iRowUpdated, aUpdatedSize, UpdatedRow)))
                            return hr;
                    }
                }
                else if(*UpdatedRow.pLocationID!=LocationIDUpdated)
                {   //While walking through the properties within this location, we reached the end of the Updated location but NOT the original location.
                    //So we need to mark all of the remaining Original properties under this location as 'Deleted'
                    while(*OriginalRow.pLocationID==LocationIDOriginal)
                    {
                        OriginalRow.pLocationID = &LocationIDUpdated;//This makes the LocationID match the UpdatedRow
                        //This is important so an Insert followed by a Delete  (of the same location) have the same LocationID

                        if(FAILED(hr = DeleteRow(OriginalRow, aOriginalSize, i_pISTW2)))return hr;

                        ++iRowOriginal;
                        if(iRowOriginal == cRowOriginal)//if we reached the end of the Original properties then bail the while loop
                            break;
                        PrevOriginalLocationID = *OriginalRow.pLocationID;
                        if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
                            return hr;
                    }
                }
                else
                {
                    ASSERT(*OriginalRow.pLocationID!=LocationIDOriginal);
                    //While walking through the properties within this location, we reached the end of the Original location but NOT the Update location.
                    //So we need to mark all of the remaining Update properties in this locations as Inserted
                    while(*UpdatedRow.pLocationID==LocationIDUpdated)
                    {
                        if(FAILED(hr = InsertRow(UpdatedRow, aUpdatedSize, i_pISTW2)))return hr;

                        ++iRowUpdated;
                        if(iRowUpdated == cRowUpdated)//if we reached the end of the Updated property list then bail the while loop
                            break;
                        if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTUpdated, iRowUpdated, aUpdatedSize, UpdatedRow)))
                            return hr;
                    }
                }
            }
        }
        else if(iLocationCompare < 0)
        {   //The OriginalRow.pLocation was removed
            //Add a row to the cache indicating this location was Deleted (a DeleteNode)
            if(FAILED(hr = DeleteNodeRow(OriginalRow, aOriginalSize, i_pISTW2)))return hr;

            ULONG LocationID = *OriginalRow.pLocationID;
            PrevOriginalLocationID = *OriginalRow.pLocationID;
            while(LocationID == *OriginalRow.pLocationID && ++iRowOriginal<cRowOriginal)
            {
                if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
                    return hr;
            }
        }
        else// if(iLocationCompare > 0)
        {   //The UpdatedRow,pLocation was added
            ULONG LocationID = *UpdatedRow.pLocationID;
            UpdatedRow.pDirective = &m_kInsert;//It's OK to set this outside the loop since GetColumnValues won't overwrite it (since we're doing cMBProperty_NumberOfColumns)

            while(LocationID == *UpdatedRow.pLocationID)
            {//For each property within this location add a row to the cache indicating an Insert
                if(FAILED(hr = InsertRow(UpdatedRow, aUpdatedSize, i_pISTW2)))return hr;

                ++iRowUpdated;
                if(iRowUpdated == cRowUpdated)//if we just inserted the last row then bail the while loop
                    break;
                if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTUpdated, iRowUpdated, aUpdatedSize, UpdatedRow)))
                    return hr;
            }
        }
    }

    //Now unless both iRowOriginal==cRowOriginal && iRowUpdated==cRowUpdated
    //we still have work to do.
    //If iRowOriginal!=cRowOriginal, then we have to Delete the remaining Original rows.
    if(iRowOriginal!=cRowOriginal)
    {
        if(PrevOriginalLocationID == *OriginalRow.pLocationID)
        {
            if(FAILED(hr = DeleteRow(OriginalRow, aOriginalSize, i_pISTW2)))return hr;

            //This first while loop deletes each property within the current LocationID
            while(++iRowOriginal<cRowOriginal && PrevOriginalLocationID==*OriginalRow.pLocationID)
            {
                if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
                    return hr;

                if(PrevOriginalLocationID != *OriginalRow.pLocationID)
                    break;
                if(FAILED(hr = DeleteRow(OriginalRow, aOriginalSize, i_pISTW2)))return hr;
            }
        }
        //This loop adds Deleted Nodes rows
        while(iRowOriginal<cRowOriginal)
        {
            ASSERT(PrevOriginalLocationID != *OriginalRow.pLocationID);//The only way the above or below loops can exit is iRow==cRow OR this condition

            OriginalRow.pID = &m_kZero;
            if(FAILED(hr = DeleteNodeRow(OriginalRow, aOriginalSize, i_pISTW2)))return hr;
            PrevOriginalLocationID = *OriginalRow.pLocationID;

            while(PrevOriginalLocationID == *OriginalRow.pLocationID && ++iRowOriginal<cRowOriginal)
            {
                if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
                    return hr;
            }
        }
    }
    //If iRowUpdated!=cRowUpdated, then we need to Insert the remaining Updated rows.
    else if(iRowUpdated!=cRowUpdated)
    {
        if(FAILED(hr = InsertRow(UpdatedRow, aUpdatedSize, i_pISTW2)))return hr;
        while(++iRowUpdated<cRowUpdated)
        {
            if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTUpdated, iRowUpdated, aUpdatedSize, UpdatedRow)))
                return hr;

            if(FAILED(hr = InsertRow(UpdatedRow, aUpdatedSize, i_pISTW2)))return hr;
        }
    }

	return pISTController->PostPopulateCache ();
}

HRESULT TMetabaseDifferencing::OnUpdateStore(ISimpleTableWrite2* i_pISTShell)
{
    UNREFERENCED_PARAMETER(i_pISTShell);

    return E_NOTIMPL;
}

// =======================================================================
// IUnknown:

STDMETHODIMP TMetabaseDifferencing::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv)
        return E_INVALIDARG;
    *ppv = NULL;

    if (riid == IID_ISimpleTableInterceptor)
    {
        *ppv = (ISimpleTableInterceptor*) this;
    }
    else if (riid == IID_IInterceptorPlugin)
    {
        *ppv = (IInterceptorPlugin*) this;
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = (IInterceptorPlugin*) this;
    }

    if (NULL != *ppv)
    {
        ((IInterceptorPlugin*)this)->AddRef ();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }

}

STDMETHODIMP_(ULONG) TMetabaseDifferencing::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);

}

STDMETHODIMP_(ULONG) TMetabaseDifferencing::Release()
{
    long cref = InterlockedDecrement((LONG*) &m_cRef);
    if (cref == 0)
    {
        delete this;
    }
    return cref;
}

//private members
HRESULT TMetabaseDifferencing::DeleteNodeRow(tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pISTW2)
{
    HRESULT hr;
    ULONG iCacheRow;
    if(FAILED(hr = i_pISTW2->AddRowForInsert(&iCacheRow)))return hr;

    row.pName      = reinterpret_cast<WCHAR *>(&m_kZero);
    row.pType      = &m_kZero;
    row.pAttributes= &m_kZero;
    row.pValue     = reinterpret_cast<unsigned char *>(&m_kZero);
    row.pGroup     = &m_kZero;
    //row.pLocation leave location alone
    row.pID        = &m_kZero;
    row.pUserType  = &m_kZero;
    row.pDirective = &m_kDeleteNode;
    aSize[iMBPropertyDiff_Value] = 1;//No need to copy the entire value since it's not going to be accessed anyway.
    return i_pISTW2->SetWriteColumnValues(iCacheRow, cMBPropertyDiff_NumberOfColumns, 0, aSize, reinterpret_cast<void **>(&row));
}

HRESULT TMetabaseDifferencing::DeleteRow(tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pISTW2)
{
    HRESULT hr;
    ULONG iCacheRow;
    if(FAILED(hr = i_pISTW2->AddRowForInsert(&iCacheRow)))return hr;

    row.pDirective = &m_kDelete;
    aSize[iMBPropertyDiff_Value] = 1;//No need to copy the entire value since it's not going to be accessed anyway.
    return i_pISTW2->SetWriteColumnValues(iCacheRow, cMBPropertyDiff_NumberOfColumns, 0, aSize, reinterpret_cast<void **>(&row));
}

HRESULT TMetabaseDifferencing::InsertRow(tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pISTW2)
{
    HRESULT hr;
    ULONG iCacheRow;
    if(FAILED(hr = i_pISTW2->AddRowForInsert(&iCacheRow)))return hr;

    row.pDirective = &m_kInsert;
    return i_pISTW2->SetWriteColumnValues(iCacheRow, cMBPropertyDiff_NumberOfColumns, 0, aSize, reinterpret_cast<void **>(&row));
}

HRESULT TMetabaseDifferencing::UpdateRow(tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pISTW2)
{
    HRESULT hr;
    ULONG iCacheRow;
    if(FAILED(hr = i_pISTW2->AddRowForInsert(&iCacheRow)))return hr;

    row.pDirective = &m_kUpdate;
    return i_pISTW2->SetWriteColumnValues(iCacheRow, cMBPropertyDiff_NumberOfColumns, 0, aSize, reinterpret_cast<void **>(&row));
}

HRESULT TMetabaseDifferencing::GetColumnValues_AsMBPropertyDiff(ISimpleTableWrite2 *i_pISTWrite, ULONG i_iRow, ULONG o_aSizes[], tMBPropertyDiffRow &o_DiffRow)
{
    HRESULT hr;
    tMBPropertyRow mbpropertyRow;

    if(FAILED(hr = i_pISTWrite->GetColumnValues(i_iRow, cMBProperty_NumberOfColumns, 0, o_aSizes, reinterpret_cast<void **>(&mbpropertyRow))))
        return hr;

    //The MBProperty table has the Same columns as MBPropertyDiff.  MBPropertyDiff has one additional column (Directive)
    //BUT!!! The columns are NOT in the exact same order.  So we need to map the columns correctly.

    o_DiffRow.pName       = mbpropertyRow.pName      ;
    o_DiffRow.pType       = mbpropertyRow.pType      ;
    o_DiffRow.pAttributes = mbpropertyRow.pAttributes;
    o_DiffRow.pValue      = mbpropertyRow.pValue     ;
    o_DiffRow.pLocation   = mbpropertyRow.pLocation  ;
    o_DiffRow.pID         = mbpropertyRow.pID        ;
    o_DiffRow.pUserType   = mbpropertyRow.pUserType  ;
    o_DiffRow.pLocationID = mbpropertyRow.pLocationID;

    o_DiffRow.pGroup      = mbpropertyRow.pGroup     ;
    o_DiffRow.pDirective  = 0                        ;

    ASSERT(o_DiffRow.pName      );
    ASSERT(o_DiffRow.pType      );
    ASSERT(o_DiffRow.pAttributes);
    //ASSERT(o_DiffRow.pValue);There doesn't have to be a Value
    ASSERT(o_DiffRow.pLocation  );
    ASSERT(o_DiffRow.pID        );
    ASSERT(o_DiffRow.pUserType  );
    ASSERT(o_DiffRow.pLocationID);
    ASSERT(o_DiffRow.pGroup     );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\writerglobalhelper.h ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    WriterGlobalHelper.h

Abstract:

    Header of a global helper class that wraps access to config meta
    tables.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#pragma once

enum eESCAPE{
    eNoESCAPE=0,
    eESCAPEgt,
    eESCAPElt,
    eESCAPEquote,
    eESCAPEamp,
    eESCAPEashex,
    eESCAPEillegalxml
};

class CPropertyIDCache
{
public:
    CPropertyIDCache()
    {}

    ~CPropertyIDCache()
    {}

    HRESULT GetRowByID( DWORD   i_iPropertyID,
                        DWORD   *o_iRow);

    HRESULT AddPropertyID(  DWORD   i_iPropertyID,
                            DWORD   i_iRow);
private:

    class Entry
    {
    public:

        DWORD   iPropertyID;
        DWORD   iPropertyRow;

        bool operator>(const Entry e) const    { return iPropertyID > e.iPropertyID; }
    };

    CCfgArray<Entry>     caCache;
};


class CWriterGlobalHelper
{
    private:
        CWriterGlobalHelper(const CWriterGlobalHelper&);
        void operator =(const CWriterGlobalHelper&);

    public:

        CWriterGlobalHelper();
        ~CWriterGlobalHelper();
        HRESULT InitializeGlobals(BOOL i_bFailIfBinFileAbsent);//LPCWSTR    i_wszBinFileForMeta);

    private:

        HRESULT GetInternalTableName(ISimpleTableDispenser2*  i_pISTDisp,
                                     LPCWSTR                  i_wszTableName,
                                     LPWSTR*                  o_wszInternalTableName);

    public:

        HRESULT ToString(PBYTE   pbData,
                         DWORD   cbData,
                         DWORD   dwIdentifier,
                         DWORD   dwDataType,
                         DWORD   dwAttributes,
                         LPWSTR* pwszData);

        HRESULT FlagToString(DWORD      dwValue,
                             LPWSTR*    pwszData,
                             LPWSTR     wszTable,
                             ULONG      iColFlag);

        HRESULT EnumToString(DWORD      dwValue,
                             LPWSTR*    pwszData,
                             LPWSTR     wszTable,
                             ULONG      iColEnum);

        HRESULT EscapeString(LPCWSTR wszString,
                             ULONG   cchString,
                             BOOL*   pbEscaped,
                             LPWSTR* pwszEscapedString,
                             ULONG*  pcchEscaped);

        HRESULT GetUserType(DWORD   i_dwUserType,
                            LPWSTR* o_pwszUserType,
                            ULONG*  o_cchUserType,
                            BOOL*   o_bAllocedUserType);

        HRESULT GetPropertyName(ULONG      i_dwPropertyID,
                                LPWSTR*    o_wszName,
                                BOOL*      o_bAlloced);

    private:

        HRESULT BoolToString(DWORD      dwValue,
                             LPWSTR*    pwszData);


        HRESULT GetStartRowIndex(LPWSTR    wszTable,
                                 ULONG     iColFlag,
                                 ULONG*    piStartRow);

        inline int  StringInsensitiveCompare(LPCWSTR wsz1, LPCWSTR wsz2) const {if(wsz1 == wsz2) return 0; else return _wcsicmp(wsz1, wsz2);}

        eESCAPE GetEscapeType(WCHAR i_wChar);

        HRESULT CreateUnknownName(DWORD    dwID,
                                  LPWSTR*   pwszUnknownName);


    public:

        ISimpleTableRead2*  m_pISTTagMetaByTableAndColumnIndexAndName;
        ISimpleTableRead2*  m_pISTTagMetaByTableAndColumnIndexAndValue;
        ISimpleTableRead2*  m_pISTTagMetaByTableAndColumnIndex;
        ISimpleTableRead2*  m_pISTTagMetaByTableAndID;
        ISimpleTableRead2*  m_pISTTagMetaByTableAndName;
        ISimpleTableRead2*  m_pISTColumnMeta;
        ISimpleTableRead2*  m_pISTColumnMetaByTableAndID;
        ISimpleTableRead2*  m_pISTColumnMetaByTableAndName;
        ISimpleTableRead2*  m_pISTTableMetaForMetabaseTables;
        ULONG               m_cColKeyTypeMetaData;
        LPVOID              m_apvKeyTypeMetaData[cCOLUMNMETA_NumberOfColumns];
        LPWSTR              m_wszTABLE_MBProperty;
        LPWSTR              m_wszTABLE_IIsConfigObject;
        int                 m_iStartRowForAttributes;
        LPWSTR              m_wszBinFileForMeta;
        ULONG               m_cchBinFileForMeta;
        LPWSTR              m_wszIIS_MD_UT_SERVER;
        ULONG               m_cchIIS_MD_UT_SERVER;
        LPWSTR              m_wszIIS_MD_UT_FILE;
        ULONG               m_cchIIS_MD_UT_FILE;
        LPWSTR              m_wszIIS_MD_UT_WAM;
        ULONG               m_cchIIS_MD_UT_WAM;
        LPWSTR              m_wszASP_MD_UT_APP;
        ULONG               m_cchASP_MD_UT_APP;

        CPropertyIDCache    m_PropertyIDs;

}; // CWriterGlobalHelper
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\inc\wstring.h ===
#pragma once

// wstring class is a minimal version of std::wstring.  sdt::wstring requires the entire stl.
// Be warned! this class throws exceptions so wrap non-const calls in try-catch
class wstring
{
public:
    wstring() : pstr(0){}
    wstring(wstring &str) : pstr(0){assign(str.c_str());}
    wstring(const wchar_t *psz) : pstr(0){assign(psz);}
    ~wstring(){if(pstr)CoTaskMemFree(pstr);}

    const wchar_t * c_str() const {return pstr;}
    operator const wchar_t*() 