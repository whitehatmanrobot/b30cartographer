                                                         //
//--------------------------------------------------------------------------//
#include "precomp.h"
#include "resource.h"
#include "help_ids.h"
#include "dlgcall2.h"
#include "mrulist2.h"
#include "dlgacd.h"
#include "dlgCall2.h"
#include "calv.h"
#include "dirutil.h"
#include "callto.h"
#include "conf.h"
#include "confroom.h"
#include "confpolicies.h"


extern void UpdateSecurityCheck(CConfRoom *pConfRoom, HWND hDlg, UINT idCheck);


//--------------------------------------------------------------------------//
//      CDlgAcd::CDlgAcd.                                                                                                               //
//--------------------------------------------------------------------------//
CDlgAcd::CDlgAcd(CConfRoom *pConfRoom):
        m_hwnd( NULL ),
        m_nameCombo( NULL ),
        m_addressTypeCombo( NULL ),
        m_pRai( NULL ),
        m_mruRai( NULL ),
        m_pConfRoom( pConfRoom ),
        m_secure( false )
{
        //      Ensure the common controls are loaded...
        INITCOMMONCONTROLSEX    icc;

        icc.dwSize      = sizeof(icc);
        icc.dwICC       = ICC_WIN95_CLASSES | ICC_COOL_CLASSES | ICC_USEREX_CLASSES;

        InitCommonControlsEx( &icc );

}       //      End of CDlgAcd::CDlgAcd.


//--------------------------------------------------------------------------//
//      CDlgAcd::~CDlgAcd.                                                                                                              //
//--------------------------------------------------------------------------//
CDlgAcd::~CDlgAcd()
{

        ClearRai( &m_mruRai );

}       //      End of CDlgAcd::~CDlgAcd.


//--------------------------------------------------------------------------//
//      CDlgAcd::doModal.                                                                                                               //
//--------------------------------------------------------------------------//
INT_PTR CDlgAcd::doModal
(
        HWND                            parent,
        RichAddressInfo *       rai,
        bool &                          secure
){
        INT_PTR result;

        m_pRai          = rai;
        m_secure        = secure;

        result = DialogBoxParam(        ::GetInstanceHandle(),
                                                                MAKEINTRESOURCE( IDD_ACD ),
                                                                parent,
                                                                DlgProcAcd,
                                                                (LPARAM) this );

        secure = m_secure;

        return( result );

}       //      End of CDlgAcd::doModal.


//--------------------------------------------------------------------------//
//      CDlgAcd::DlgProcAcd.                                                                                                    //
//--------------------------------------------------------------------------//
INT_PTR
CALLBACK
CDlgAcd::DlgProcAcd
(
        HWND    dialog,
        UINT    message,
        WPARAM  wParam,
        LPARAM  lParam
){
        static const DWORD      helpIDMap[] =
        {
                IDC_STATIC_ADDRESS,             IDH_GENERAL_GENERAL,
                IDB_ACD_ADDRESS,                IDH_PLACECALL_TO_TEXT,
                IDL_ACD_ADDRESS,                IDH_PLACECALL_TO_TEXT,
                IDC_ACD_USING_STATIC,   IDH_PLACECALL_USING,
                IDL_ACD_ADDR_TYPE,              IDH_PLACECALL_USING,
                IDC_SECURE_CALL,                IDH_PLACECALL_SECURITY_CHKBX,
                IDC_ACD_DIRECTORY,              IDH_PLACECALL_TO,
                IDOK,                                   IDH_PLACECALL_CALL,
                0,                                              0
        };

        bool    result  = false;

        switch( message )
        {
                case WM_INITDIALOG:
                {
                        ASSERT(NULL != lParam);
                        ::SetWindowLongPtr( dialog, DWLP_USER, lParam );
                        result = ((CDlgAcd *) lParam)->onInitDialog( dialog );
                }
                break;

                case WM_COMMAND:
                {
                        CDlgAcd *       acd     = (CDlgAcd *) ::GetWindowLongPtr( dialog, DWLP_USER );

                        if( acd != NULL )
                        {
                                result = acd->onCommand( LOWORD( wParam ), HIWORD( wParam ) );
                        }
                }
                break;

                case WM_CONTEXTMENU:
                {
                        DoHelpWhatsThis( wParam, helpIDMap );
                }
                break;
                
                case WM_HELP:
                {
                        DoHelp( lParam, helpIDMap );
                }
                break;
        }

        return( (BOOL) result );

}       //      End of CDlgAcd::DlgProcAcd.


//--------------------------------------------------------------------------//
//      CDlgAcd::onInitDialog.                                                                                                  //
//--------------------------------------------------------------------------//
bool
CDlgAcd::onInitDialog
(
        HWND    dialog
){

        m_hwnd = dialog;

        UpdateSecurityCheck(m_pConfRoom, m_hwnd, IDC_SECURE_CALL);

        HICON   directoryIcon   = LoadIcon( ::GetInstanceHandle(), MAKEINTRESOURCE( IDI_DIRECTORY ) );

        if( directoryIcon != NULL )
        {
                ::SendDlgItemMessage( dialog, IDC_ACD_DIRECTORY, BM_SETIMAGE, IMAGE_ICON, (LPARAM) directoryIcon );
        }

        m_nameCombo                     = GetDlgItem( m_hwnd, IDL_ACD_ADDRESS );
        m_addressTypeCombo      = GetDlgItem( m_hwnd, IDL_ACD_ADDR_TYPE );

        ComboBox_LimitText( m_nameCombo, CCHMAXSZ_ADDRESS - 1 );

        fillCallMruList();
        fillAddressTypesList();

        ::SendMessage( m_nameCombo, EM_LIMITTEXT, CCallto::s_iMaxAddressLength, 0 );

        if( hasValidUserInfo( m_pRai ) )
        {
                ::SetWindowText( m_nameCombo, m_pRai->szName );
                ::SendMessage( m_addressTypeCombo, CB_SETCURSEL, m_pRai->rgDwStr[ 0 ].dw, 0 );
        }
        else
        {
                ::SendMessage( m_addressTypeCombo, CB_SETCURSEL, 0, 0 );
        }

        CenterWindow( m_hwnd, ::GetParent( m_hwnd ) );

        if (m_pConfRoom->FIsConferenceActive())
        {
                // Simulate a call started to get all the states right
                OnCallStarted();
        }

        return( true );         //      Default focus...

}       //      End of CDlgAcd::onInitDialog.


//--------------------------------------------------------------------------//
//      CDlgAcd::fillCallMruList.                                                                                               //
//--------------------------------------------------------------------------//
void
CDlgAcd::fillCallMruList(void)
{
        ASSERT(NULL != m_nameCombo);

        COMBOBOXEXITEM  cbi;

        ClearStruct( &cbi );

        cbi.mask        = CBEIF_TEXT;
        cbi.iItem       = -1;   //      Always insert at the end...

        HRESULT result  = S_OK;

        for( int nn = 0; result == S_OK; nn++ )
        {
                RichAddressInfo *       rai;

                if( (result = m_callMruList.GetAddress( nn, &rai )) == S_OK )
                {
                        cbi.pszText             = rai->szName;
                        cbi.cchTextMax  = lstrlen( cbi.pszText );

                        int     index   = (int)::SendMessage( m_nameCombo, CBEM_INSERTITEM, 0, (LPARAM) &cbi );

                        if( index != CB_ERR )
                        {
                                ::SendMessage( m_nameCombo, CB_SETITEMDATA, index, nn );
                        }
                        else
                        {
                                result = S_FALSE;
                        }

                        ClearRai( &rai );
                }
        }

}       //      End of CDlgAcd::fillCallMruList.


//--------------------------------------------------------------------------//
//      CDlgAcd::fillAddressTypesList.                                                                                  //
//--------------------------------------------------------------------------//
void
CDlgAcd::fillAddressTypesList(void)
{
        using namespace ConfPolicies;

        enum CallMode
        {
                CM_GK           = 0x0001,       // GateKeeper
                CM_GW           = 0x0002,       // Gateway
                CM_NoGate       = 0x0004,       // Neither
        } ;

        static const struct
        {
                LPARAM dwCallType;
                UINT idTitle;
                UINT uCallMode;
        } s_mpCtIds[] =
        {
                {       NM_ADDR_UNKNOWN,                IDS_ACD_CT_AUTOMATIC,   CM_GK|CM_GW|CM_NoGate   },
                {       NM_ADDR_MACHINENAME,    IDS_ACD_CT_IP,                  CM_GW|CM_NoGate                 },
                {       NM_ADDR_ULS,                    IDS_ACD_CT_ILS,                 CM_GW|CM_NoGate                 },
                {       NM_ADDR_ALIAS_E164,             IDS_ACD_CT_PHONE,               CM_GK|CM_GW                             },
                {       NM_ADDR_ALIAS_ID,               IDS_ACD_CT_ALIAS,               CM_GK                                   },
        } ;

        HWND    combo   = GetDlgItem( m_hwnd, IDL_ACD_ADDR_TYPE );

        if( combo != NULL )
        {
                UINT uCallType = CM_NoGate;

                if (CallingMode_GateKeeper == GetCallingMode())
                {
                        uCallType = CM_GK;
                }
                else
                {
                        RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
                        if (reConf.GetNumber( REGVAL_USE_H323_GATEWAY ) != 0)
                        {
                                uCallType = CM_GW;
                        }
                }

                for( int nn = 0; nn < ARRAY_ELEMENTS(s_mpCtIds); nn++ )
                {
                        if (0 == (uCallType & s_mpCtIds[nn].uCallMode))
                        {
                                continue;
                        }

                        TCHAR   sz[ CCHMAXSZ_NAME ];

                        if( FLoadString( s_mpCtIds[ nn ].idTitle, sz, CCHMAX( sz ) ) )
                        {
                                int     index   = (int)::SendMessage( combo, CB_INSERTSTRING, -1, (LPARAM) sz );

                                if( index != CB_ERR )
                                {
                                        ::SendMessage( combo, CB_SETITEMDATA, index, s_mpCtIds[ nn ].dwCallType );
                                }
                        }
                }
        }

}       //      End of CDlgAcd::fillAddressTypesList.


//--------------------------------------------------------------------------//
//      CDlgAcd::onCommand.                                                                                                             //
//--------------------------------------------------------------------------//
bool
CDlgAcd::onCommand
(
        int command,
        int     notification
){
        ASSERT(NULL != m_hwnd);

        bool    result = false;

        switch( command )
        {
                case IDC_SECURE_CALL:
                {
                        m_secure = (IsDlgButtonChecked( m_hwnd, IDC_SECURE_CALL ) == BST_CHECKED);
                }
                break;

                case IDL_ACD_ADDRESS:
                {
                        if( notification == CBN_EDITCHANGE )
                        {
                                onEditChange();
                        }
                        else if( notification == CBN_SELCHANGE )
                        {
                                int iSel = (int)::SendMessage( m_nameCombo, CB_GETCURSEL, 0, 0 );

                                if (iSel >= 0)
                                {
                                        onMruSelect( iSel );
                                }
                        }
                }
                break;

                case IDL_ACD_ADDR_TYPE:
                        if (CBN_SELCHANGE == notification)
                        {
                                // Pretend like the user just typed in the edit control
                                onEditChange();
                        }
                        break;

                case IDC_ACD_DIRECTORY:
                {
                        CFindSomeone::findSomeone(m_pConfRoom);
                        ::EndDialog( m_hwnd, IDCANCEL );
                }
                break;

                case IDOK:
                {
                        if( m_mruRai != NULL )
                        {
                                lstrcpy( m_pRai->szName, m_mruRai->szName );
                                m_pRai->cItems                          = m_mruRai->cItems;

                                for( int nn = 0; nn < m_mruRai->cItems; nn++ )
                                {
                                        m_pRai->rgDwStr[ nn ].dw        = m_mruRai->rgDwStr[ nn ].dw;
                                        m_pRai->rgDwStr[ nn ].psz       = PszAlloc( m_mruRai->rgDwStr[ nn ].psz );
                                }
                        }
                        else
                        {
                                int     type    = (int)::SendMessage( m_addressTypeCombo, CB_GETCURSEL, 0, 0 );

                                type = (int)((type == CB_ERR)? NM_ADDR_UNKNOWN: ComboBox_GetItemData(m_addressTypeCombo, type));

                                ::SendMessage( GetDlgItem( m_hwnd, IDL_ACD_ADDRESS), WM_GETTEXT, CCHMAX( m_pRai->szName ), (LPARAM) m_pRai->szName );

                                if( (type == NM_ADDR_UNKNOWN) && bCanCallAsPhoneNumber( m_pRai->szName ) )
                                {
                                        type = NM_ADDR_ALIAS_E164;
                                }

                                m_pRai->cItems                          = 1;
                                m_pRai->rgDwStr[ 0 ].dw         = type;
                                m_pRai->rgDwStr[ 0 ].psz        = PszAlloc( m_pRai->szName );
                        }

                        ::EndDialog( m_hwnd, IDOK );
                        result = true;
                }
                break;

                case IDCANCEL:
                {
                        ::EndDialog( m_hwnd, IDCANCEL );
                        result = true;
                }
                break;
        }

        return( result );

}       //      End of CDlgAcd::onCommand.


//--------------------------------------------------------------------------//
//      CDlgAcd::onEditChange.                                                                                                  //
//--------------------------------------------------------------------------//
void
CDlgAcd::onEditChange(void)
{
        TCHAR   szEdit[ CCHMAXSZ_ADDRESS ];
        int             cch     = get_editText( szEdit, CCHMAX( szEdit ) );

        EnableWindow( GetDlgItem( m_hwnd, IDOK ), (cch > 0) );
        ClearRai( &m_mruRai );

}       //      End of CDlgAcd::onEditChange.


//--------------------------------------------------------------------------//
//      CDlgAcd::onMruSelect.                                                                                                   //
//--------------------------------------------------------------------------//
void
CDlgAcd::onMruSelect
(
        int     selection
){
        int             mruIndex = (int)::SendMessage( m_nameCombo, CB_GETITEMDATA, selection, 0 );
        HRESULT result;

        RichAddressInfo *       rai;

        if( (result = m_callMruList.GetAddress( mruIndex, &rai )) == S_OK )
        {
                ::SetWindowText( m_nameCombo, rai->szName );

                DWORD dwType = rai->rgDwStr[ 0 ].dw;

                // HACKHACK georgep: We know Automatic is at index 0
                for (int typeIndex=ComboBox_GetCount(m_addressTypeCombo)-1; typeIndex>0; --typeIndex)
                {
                        if (static_cast<DWORD>(ComboBox_GetItemData(m_addressTypeCombo, typeIndex))
                                == dwType)
                        {
                                break;
                        }
                }
                ComboBox_SetCurSel(m_addressTypeCombo, typeIndex);

                m_mruRai = rai;
        }

}       //      End of CDlgAcd::onMruSelect.


//--------------------------------------------------------------------------//
//      CDlgAcd::newCall.                                                                                                               //
//--------------------------------------------------------------------------//
void
CDlgAcd::newCall
(
        HWND    parentWindow,
        CConfRoom * pConfRoom
){
        CDlgAcd                 placeCall(pConfRoom);
        RichAddressInfo rai;
        bool                    userAlterable;
        bool                    secure;

        pConfRoom->AddConferenceChangeHandler(&placeCall);

        pConfRoom->get_securitySettings( userAlterable, secure );

        rai.szName[ 0 ] = '\0';
        rai.cItems              = 0;

        if( placeCall.doModal( parentWindow, &rai, secure ) == IDOK )
        {
                NM_ADDR_TYPE            nmType          = static_cast<NM_ADDR_TYPE>(rai.rgDwStr[ 0 ].dw);

                g_pCCallto->Callto(     rai.szName,             //      pointer to the callto url to try to place the call with...
                                                        NULL,                   //      pointer to the display name to use...
                                                        nmType,                 //      callto type to resolve this callto as...
                                                        true,                   //      the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
                                                        &secure,                //      security preference, NULL for none. must be "compatible" with secure param if present...
                                                        true,                   //      whether or not save in mru...
                                                        true,                   //      whether or not to perform user interaction on errors...
                                                        parentWindow,   //      if bUIEnabled is true this is the window to parent error/status windows to...
                                                        NULL );                 //      out pointer to INmCall * to receive INmCall * generated by placing call...

                for( int nn = 0; nn < rai.cItems; nn++ )
                {
                        delete [] rai.rgDwStr[ nn ].psz;
                }
        }

        pConfRoom->RemoveConferenceChangeHandler(&placeCall);

}       //      End of CDlgAcd::newCall.


//--------------------------------------------------------------------------//
//      CDlgAcd::get_editText.                                                                                                  //
//--------------------------------------------------------------------------//
int
CDlgAcd::get_editText
(
        LPTSTR  psz,
        int             cchMax
){
        ASSERT(NULL != m_nameCombo);

        SetEmptySz( psz );
        GetWindowText( m_nameCombo, psz, cchMax );
        
        return( TrimSz( psz ) );

}       //      End of get_editText.


void CDlgAcd::OnCallStarted()
{
        UpdateSecurityCheck(m_pConfRoom, m_hwnd, IDC_SECURE_CALL);

        // BUGBUG georgep: We get notified before the actual conference state
        // changes, so we need to disable manually
    ::EnableWindow( GetDlgItem(m_hwnd, IDC_SECURE_CALL), FALSE );
}

void CDlgAcd::OnCallEnded()
{
        UpdateSecurityCheck(m_pConfRoom, m_hwnd, IDC_SECURE_CALL);
    ::CheckDlgButton( m_hwnd, IDC_SECURE_CALL, m_secure );
}

//--------------------------------------------------------------------------//
//      CEnumMRU::CEnumMRU.                                                                                                             //
//--------------------------------------------------------------------------//
CEnumMRU::CEnumMRU():
        RefCount( NULL )
{
}       //      CEnumMRU::CEnumMRU.


//--------------------------------------------------------------------------//
//      CEnumMRU::AddRef.                                                                                                               //
//--------------------------------------------------------------------------//
ULONG
STDMETHODCALLTYPE
CEnumMRU::AddRef(void)
{

        return( RefCount::AddRef() );

}       //      CEnumMRU::AddRef.


//--------------------------------------------------------------------------//
//      CEnumMRU::Release.                                                                                                              //
//--------------------------------------------------------------------------//
ULONG
STDMETHODCALLTYPE
CEnumMRU::Release(void)
{
        return( RefCount::Release() );

}       //      CEnumMRU::Release.


//--------------------------------------------------------------------------//
//      CEnumMRU::GetAddress.                                                                                                   //
//--------------------------------------------------------------------------//
HRESULT
STDMETHODCALLTYPE
CEnumMRU::GetAddress
(
        long                            index,
        RichAddressInfo **      ppAddr
){
        HRESULT result  = S_FALSE;

        if( GetNumEntries() <= index )
        {
                result = S_FALSE;
        }
        else
        {
                // HACKHACK georgep: Just using the Address as the display name. We
                // should clean this up later so we are not taking up extra memory and
                // registry space
                *ppAddr = CreateRai( GetString( index, ACD_ADDR ), (NM_ADDR_TYPE) GetDWORD( index, ACD_TYPE ), GetString( index, ACD_ADDR ) );
                result  = (*ppAddr == NULL)? E_OUTOFMEMORY: S_OK;
        }

        return( result );

}       //      CEnumMRU::GetAddress.


//--------------------------------------------------------------------------//
//      CEnumMRU::GetRecentAddresses.                                                                                   //
//--------------------------------------------------------------------------//
HRESULT
CEnumMRU::GetRecentAddresses
(
        IEnumRichAddressInfo ** ppEnum
){

        *ppEnum = new CEnumMRU();

        return( (*ppEnum == NULL)? E_OUTOFMEMORY: S_OK );

}       //      End of CEnumMRU::GetRecentAddresses.


//--------------------------------------------------------------------------//
//      CEnumMRU::FreeAddress.                                                                                                  //
//--------------------------------------------------------------------------//
HRESULT
CEnumMRU::FreeAddress
(
        RichAddressInfo **      ppAddr
){

        ClearRai( ppAddr );

        return( S_OK );

}       //      End of CEnumMRU::FreeAddress.


//--------------------------------------------------------------------------//
//      CEnumMRU::CopyAddress.                                                                                                  //
//--------------------------------------------------------------------------//
HRESULT
CEnumMRU::CopyAddress
(
        RichAddressInfo *       pAddrIn,
        RichAddressInfo **      ppAddrOut
){

        *ppAddrOut = DupRai( pAddrIn );

        return( (*ppAddrOut == NULL)? E_OUTOFMEMORY: S_OK );

}       //      End of CEnumMRU::CopyAddress.

CAcdMru::CAcdMru() :
        CMRUList2( _rgMruCall, CENTRYMAX_MRUCALL )
{
}

int CAcdMru::CompareEntry(int iItem, PMRUE pEntry)
{
        ASSERT(NULL != pEntry);

        int iRet = 0;

        LPCTSTR psz1 = GetString(iItem, ACD_ADDR);
        LPCTSTR psz2 = GetString(pEntry, ACD_ADDR);

        ASSERT(NULL != psz1 && NULL != psz2);

        return(lstrcmpi(psz1, psz2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dirutil.h ===
// File: util.h

#ifndef _UTIL_H_
#define _UTIL_H_

#include "SDKInternal.h"
#include "confutil.h"

int  FindSzCombo(HWND hwnd, LPCTSTR pszSrc, LPTSTR pszResult);
VOID AutoCompleteCombo(HWND hwnd, LPCTSTR psz);
VOID AutoCompleteEdit(HWND hwnd, LPCTSTR psz);

int  DisplayMsg(HWND hwndParent, LPCTSTR pszMsg, UINT uType);
int  DisplayMsgId(HWND hwndParent, UINT id);
VOID DisplayMsgErr(HWND hwndParent, UINT id, PVOID pv);
VOID DisplayMsgErr(HWND hwndParent, UINT id);

	// Atl defines a function AtlWaitWithMessageLoop
	// We are not linking with ATL, but when we start,
	// this function can be removed
HRESULT WaitWithMessageLoop( HANDLE hEvent );

VOID AddToolTip(HWND hwndParent, HWND hwndCtrl, UINT_PTR idMsg);
HWND CreateStaticText(HWND hwnd, INT_PTR id);
HWND CreateButton(HWND hwndParent, int ids, INT_PTR id);

BOOL FGetDefaultServer(LPTSTR pszServer, UINT cchMax);
BOOL FCreateIlsName(LPTSTR pszDest, LPCTSTR pszEmail, int cchMax);

// from nmobj.cpp
HRESULT PlaceCall(LPCTSTR pszName, LPCTSTR pszAddress,
	NM_ADDR_TYPE addrType = NM_ADDR_UNKNOWN, DWORD dwFlags = 0,
	LPCTSTR pszConference = NULL, LPCTSTR pszPassword = NULL);


HRESULT ExtractAddress( DWORD dwAddrType, LPTSTR szAddress, LPTSTR szExtractedAddr, int cchMax );
bool IsValidAddress( DWORD dwAddrType, LPTSTR szAddr );

// from dlgcall.h
#define IDI_DLGCALL_NAME     0
#define IDI_DLGCALL_ADDRESS  1
#define IDI_MISC1			 2
#define IDI_DLGCALL_COMMENT  IDI_MISC1
#define IDI_DLGCALL_PHONENUM IDI_MISC1

int     DlgCallAddItem(HWND hwndList, LPCTSTR pszName, LPCTSTR pszAddress,
                       int iImage=0, LPARAM lParam=0, int iItem=0, LPCTSTR pszComment=NULL);
VOID    DlgCallSetHeader(HWND hwndList, int ids);
HRESULT CallToSz(LPCTSTR pcszAddress);

#endif /* _UTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dirutil.cpp ===
// File: util.cpp

#include "precomp.h"
#include "resource.h"

#include <oprahcom.h>
#include <strutil.h>
#include "dirutil.h"

/*  F I N D  S Z  C O M B O  */
/*-------------------------------------------------------------------------
    %%Function: FindSzCombo

    Find the item that matches at least the first part of the string
    from the names in the combo box list.

    Returns the item index or -1 if not found.
-------------------------------------------------------------------------*/
int FindSzCombo(HWND hwnd, LPCTSTR pszSrc, LPTSTR pszResult)
{
	int cch = lstrlen(pszSrc);
	if (0 == cch)
		return -1;

	TCHAR szBuff[CCHMAXSZ];
	lstrcpy(szBuff, pszSrc);
	CharUpperBuff(szBuff, CCHMAX(szBuff));
	
	COMBOBOXEXITEM cbi;
	ClearStruct(&cbi);
	cbi.mask = CBEIF_TEXT;
	cbi.pszText = pszResult;

	for ( ; ; cbi.iItem++)
	{
		cbi.cchTextMax = CCHMAX(szBuff);
		if (0 == SendMessage(hwnd, CBEM_GETITEM, 0, (LPARAM) &cbi))
			return -1;

		TCHAR szTemp[CCHMAXSZ];
		lstrcpy(szTemp, pszResult);
		CharUpperBuff(szTemp, CCHMAX(szTemp));

		if (0 == _StrCmpN(szBuff, szTemp, cch))
			return (int)(cbi.iItem);
	}
}

	// Atl defines a function AtlWaitWithMessageLoop
	// We are not linking with ATL, but when we start,
	// this function can be removed
HRESULT WaitWithMessageLoop(HANDLE hEvent)
{
	DWORD dwRet;
	MSG msg;

	HRESULT hr = S_OK;
	
	while(1)
	{
		dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT);

		if (dwRet == WAIT_OBJECT_0)
			return S_OK;    // The event was signaled

		if (dwRet != WAIT_OBJECT_0 + 1)
			return E_FAIL;          // Something else happened

		// There is one or more window message available. Dispatch them
		while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
				return S_OK; // Event is now signaled.
		}
	}

	return hr;
}


/*  A U T O  C O M P L E T E  C O M B O  */
/*-------------------------------------------------------------------------
    %%Function: AutoCompleteCombo

    Update the current edit text with the suggestion and select it.
-------------------------------------------------------------------------*/
VOID AutoCompleteCombo(HWND hwnd, LPCTSTR psz)
{
	HWND hwndEdit = (HWND) SendMessage(hwnd, CBEM_GETEDITCONTROL, 0, 0);
	if (NULL != hwndEdit)
	{
		AutoCompleteEdit(hwndEdit, psz);
	}
}

VOID AutoCompleteEdit(HWND hwndEdit, LPCTSTR psz)
{
	const int cchLast = 0x7FFF;

	int cch = GetWindowTextLength(hwndEdit);
	Edit_SetSel(hwndEdit, cchLast, cchLast);
	Edit_ReplaceSel(hwndEdit, psz);
	Edit_SetSel(hwndEdit, cch, cchLast);
}



/*  F G E T  D E F A U L T  S E R V E R  */
/*-------------------------------------------------------------------------
    %%Function: FGetDefaultServer

-------------------------------------------------------------------------*/
BOOL FGetDefaultServer(LPTSTR pszServer, UINT cchMax)
{
	RegEntry ulsKey(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
	LPTSTR psz = ulsKey.GetString(REGVAL_SERVERNAME);
	if (FEmptySz(psz))
		return FALSE;

	lstrcpyn(pszServer, psz, cchMax);
	return TRUE;
}


/*  F  C R E A T E  I L S  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: FCreateIlsName

    Combine the server and email names to form an ILS name.
    Return TRUE if the result fit in the buffer.
-------------------------------------------------------------------------*/
BOOL FCreateIlsName(LPTSTR pszDest, LPCTSTR pszEmail, int cchMax)
{
	ASSERT(NULL != pszDest);

	TCHAR szServer[MAX_PATH];
	if (!FGetDefaultServer(szServer, CCHMAX(szServer)))
		return FALSE;

	if (FEmptySz(pszEmail))
	{
		WARNING_OUT(("FCreateIlsName: Null email name?"));
		return FALSE;
	}

	int cch = lstrlen(szServer);
	lstrcpyn(pszDest, szServer, cchMax);
	if (cch >= (cchMax-2))
		return FALSE;

	pszDest += cch;
	*pszDest++ = _T('/');
	cchMax -= (cch+1);
	
	lstrcpyn(pszDest, pszEmail, cchMax);

	return (lstrlen(pszEmail) < cchMax);
}

/*  D I S P L A Y  M S G  */
/*-------------------------------------------------------------------------
    %%Function: DisplayMsg

    Display a message with the standard title.
-------------------------------------------------------------------------*/
int DisplayMsg(HWND hwndParent, LPCTSTR pszMsg, UINT uType)
{
	TCHAR szTitle[MAX_PATH];
	FLoadString(IDS_MSGBOX_TITLE, szTitle, CCHMAX(szTitle));

	return ::MessageBox(hwndParent, pszMsg, szTitle, uType);
}

int DisplayMsgId(HWND hwndParent, UINT id)
{
	TCHAR szMsg[CCHMAXSZ];
	if (!FLoadString(id, szMsg, CCHMAX(szMsg)))
		return IDOK;

	return DisplayMsg(hwndParent, szMsg,
				MB_ICONINFORMATION | MB_SETFOREGROUND | MB_OK);
}

VOID DisplayMsgErr(HWND hwndParent, UINT id, PVOID pv)
{
	TCHAR szFormat[CCHMAXSZ];
	if (!FLoadString(id, szFormat, CCHMAX(szFormat)))
		return;

	TCHAR szMsg[CCHMAXSZ*2];
	wsprintf(szMsg, szFormat, pv);
	ASSERT(lstrlen(szMsg) < CCHMAX(szMsg));

	DisplayMsg(hwndParent, szMsg, MB_OK | MB_SETFOREGROUND | MB_ICONERROR);
}

VOID DisplayMsgErr(HWND hwndParent, UINT id)
{
	TCHAR szFormat[CCHMAXSZ];
	if (FLoadString(id, szFormat, CCHMAX(szFormat)))
	{
		DisplayMsg(hwndParent, szFormat, MB_OK | MB_SETFOREGROUND | MB_ICONERROR);
	}
}




/*  A D D  T O O L  T I P  */
/*-------------------------------------------------------------------------
    %%Function: AddToolTip

    Add a tooltip to a control.
-------------------------------------------------------------------------*/
VOID AddToolTip(HWND hwndParent, HWND hwndCtrl, UINT_PTR idMsg)
{
	if (NULL == hwndCtrl)
		return;

	HWND hwnd = ::CreateWindowEx(0, TOOLTIPS_CLASS, NULL, 0,
			CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
			hwndParent, NULL, ::GetInstanceHandle(), NULL);

	if (NULL == hwnd)
		return;
		
	TOOLINFO ti;
	ti.cbSize = sizeof(TOOLINFO);
	ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
	ti.hwnd = hwndParent;
	ti.hinst = ::GetInstanceHandle();
	ti.uId = (UINT_PTR) hwndCtrl; // Note: subclassing the window!
	ti.lpszText = (LPTSTR) idMsg;

	::SendMessage(hwnd, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
}


/*  C R E A T E  S T A T I C  T E X T  */
/*-------------------------------------------------------------------------
    %%Function: CreateStaticText

-------------------------------------------------------------------------*/
HWND CreateStaticText(HWND hwndParent, INT_PTR id)
{
	HWND hwndCtrl = ::CreateWindowEx(0, g_cszStatic, NULL,
			WS_CHILD | WS_VISIBLE, 0, 0, 0, 0,
			hwndParent, (HMENU) id, ::GetInstanceHandle(), NULL);
	if (NULL == hwndCtrl)
		return NULL;

	// Set the font:
	::SendMessage(hwndCtrl, WM_SETFONT, (WPARAM) GetDefaultFont(), 0);

	TCHAR sz[CCHMAXSZ];
	if (FLoadString(PtrToInt((LPVOID)id), sz, CCHMAX(sz)))
	{
		::SetWindowText(hwndCtrl, sz);
	}
	return hwndCtrl;
}


/*  C R E A T E  B U T T O N  */
/*-------------------------------------------------------------------------
    %%Function: CreateButton

-------------------------------------------------------------------------*/
HWND CreateButton(HWND hwndParent, int ids, INT_PTR id)
{
	TCHAR sz[CCHMAXSZ];
	if (!FLoadString(ids, sz, CCHMAX(sz)))
		return NULL;

	HWND hwndCtrl = CreateWindow(g_cszButton, sz,
			WS_CHILD | WS_VISIBLE |  WS_TABSTOP |
			WS_CLIPCHILDREN | BS_PUSHBUTTON,
			0, 0, 0, 0,
			hwndParent, (HMENU) id,
			::GetInstanceHandle(), NULL);

	if (NULL != hwndCtrl)
	{
		::SendMessage(hwndCtrl, WM_SETFONT, (WPARAM) GetDefaultFont(), 0);
	}
	return hwndCtrl;
}



bool IsValid_e164_Char( TCHAR t )
{
	bool bRet = false;

	switch( t )
	{
		case _T('0'):
		case _T('1'):
		case _T('2'):
		case _T('3'):
		case _T('4'):
		case _T('5'):
		case _T('6'):
		case _T('7'):
		case _T('8'):
		case _T('9'):
		case _T('#'):
		case _T('*'):
		case _T(','):
			bRet = true;

	}

	return bRet;
}


HRESULT ExtractAddress( DWORD dwAddrType, LPTSTR szAddress, LPTSTR szExtractedAddr, int cchMax )
{
	HRESULT hr = S_OK;
	LPTSTR pchRead;
	LPTSTR pchWrite;

	if( szAddress && szExtractedAddr && ( cchMax > 0 ) )
	{
		switch( dwAddrType )
		{
			case NM_ADDR_UNKNOWN:
			case NM_ADDR_IP:
			case NM_ADDR_MACHINENAME:
			case NM_ADDR_ULS:
			case NM_ADDR_ALIAS_ID:
				lstrcpyn( szExtractedAddr, szAddress, cchMax );
				break;

				// THese are phone numbers, yank the non-telephone num keys...
			case NM_ADDR_PSTN:
			case NM_ADDR_H323_GATEWAY:
			case NM_ADDR_ALIAS_E164:
			{
				pchRead = szAddress;
				pchWrite = szExtractedAddr;
				while( *pchRead != NULL )
				{
					if( IsValid_e164_Char( *pchRead ) )
					{
							// REVIEW: Is this rite for unicode??
						*pchWrite = *pchRead;					
						pchWrite = CharNext(pchWrite);
					}						
					pchRead = CharNext( pchRead );
				}
					// This will copy the NULL termination...
				*pchWrite = *pchRead;
			}
				
				break;
			
			default:
				hr = E_FAIL;
				break;

		}
	}
	else
	{
		hr = E_INVALIDARG;
	}

	return hr;
}

bool IsValidAddress( DWORD dwAddrType, LPTSTR szAddr )
{
	bool bRet = false;

	if( szAddr && szAddr[0] )
	{
		bRet = true;
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dlgauth.h ===
// File: dlgauth.h

#ifndef _CDLGAUTH_H_
#define _CDLGAUTH_H_

#include "SDKInternal.h"

class CDlgAuth
{
private:
	HWND   m_hwnd;
	INmCall * m_pCall;
	
public:
	CDlgAuth(INmCall * pCall);
	~CDlgAuth();

	// Properties:
	INT_PTR DoModal(void);
	VOID OnInitDialog(void);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	static BOOL CALLBACK DlgProcAuth(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif /* _CDLGAUTH_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dlgcall.h ===
// File: dlgcall.h

#ifndef _CDLGCALL_H_
#define _CDLGCALL_H_

class CDlgCall : public RefCount
{
private:
	CCall * m_pCall;
	HWND    m_hwnd;

	int     m_nTextWidth;

	VOID CreateCallDlg();

public:
	CDlgCall(CCall * pCall);
	~CDlgCall();

	ULONG   STDMETHODCALLTYPE AddRef(void);
	ULONG   STDMETHODCALLTYPE Release(void);

	HWND GetHwnd(void)  {return m_hwnd;}

	VOID Destroy(void);
	VOID OnStateChange(void);

	VOID OnInitDialog(HWND hdlg);
	VOID OnCancel(void);
	VOID OnDestroy(void);

	static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif /* _CDLGCall_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dlgcall2.h ===
// File: DlgCall.h

#ifndef _CDLGCALL2_H_
#define _CDLGCALL2_H_

#include "richaddr.h"
#include "GenContainers.h"
#include "ConfRoom.h"

class CLDAP;
class CWAB;
class CGAL;
class CSPEEDDIAL;
class CHISTORY;
class CALV;
class CTranslateAccelTable;

class CMRUList;

#define MAX_DIR_COLUMNS	7

//	These are the indexes the columns are actually added to the listview in...
#define	COLUMN_INDEX_ADDRESS	0
#define	COLUMN_INDEX_AUDIO		1
#define	COLUMN_INDEX_VIDEO		2
#define	COLUMN_INDEX_LAST_NAME	3
#define	COLUMN_INDEX_FIRST_NAME	4
#define	COLUMN_INDEX_LOCATION	5
#define	COLUMN_INDEX_COMMENTS	6



class CFindSomeone : public CFrame, public IConferenceChangeHandler
{
public:
	static void findSomeone(CConfRoom *pConfRoom);

	static VOID Destroy();

	virtual void Layout();

	virtual void OnDesiredSizeChanged()
	{
		ScheduleLayout();
	}

	public:		// IConferenceChangeHandler methods
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
		{
			return(CFrame::QueryInterface(riid, ppvObject));
		}
        
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
		{
			return(CFrame::AddRef());
		}
        
        virtual ULONG STDMETHODCALLTYPE Release( void)
		{
			return(CFrame::Release());
		}

		virtual void OnCallStarted();
		virtual void OnCallEnded();

		virtual void OnAudioLevelChange(BOOL fSpeaker, DWORD dwVolume) {}
		virtual void OnAudioMuteChange(BOOL fSpeaker, BOOL fMute) {}

		virtual void OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify) {}

		virtual void OnChangePermissions() {}

		virtual void OnVideoChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel) {}

protected:
	~CFindSomeone();

	virtual LRESULT ProcessMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
		// constants
	enum { DEFAULT_NUM_LISTVIEW_COLUMNS = 2 };

		// Member Vars
	static CFindSomeone *s_pDlgCall;

	CTranslateAccelTable *m_pAccel;	// The accelerator table we need to clean up

	HWND    m_hwndList;          // list view
	HWND    m_ilsListView;       // ils list view
	HWND    m_webView;			 // web view
	HWND    m_hwndOwnerDataList; // list view ( The owner-data one )
	WNDPROC m_WndOwnerDataListOldWndProc;  // For subclassing the above wnd

	HWND    m_hwndFrame;         // group box
	HWND    m_hwndCombo;         // combo box
	HWND    m_hwndComboEdit;     // combo box's edit control
	HWND    m_hwndEdit;          // edit control (for type-ahead)
	BOOL    m_fInEdit;           // TRUE if editing the name/address

	DWORD   m_dwOptions;         // options (NM_CALLDLG_*)
	LPCTSTR m_pszDefault;        // initial text to put in the edit control

	HIMAGELIST m_himlIcon;       // small icon image list
	int     m_cVisible;          // number of visible lines in the listbox
	int     m_dxButton;          // width of the "Advanced..." button
	int     m_dyButton;          // height of the "Advanced..." button
	int     m_dyText;            // height of a line of text
	int     m_dyTextIntro;       // height of intro text at top of dialog
	LPTSTR  m_pszTextIntro;      // Introductory text for top of dialog
	bool    m_bPlacedCall;       // TRUE if we successfuly placed a call
	bool    m_secure;		     // Save the state of the secure button

	int     m_iIlsFirst;         // index of first ILS server
	CMRUList * m_pMruServer;     // list of ILS servers
	RAI      * m_pRai;           // Rich Address Information

	// CALV items
	CLDAP    * m_pUls;
	CWAB     * m_pWab;
	CSPEEDDIAL * m_pSpeedDial;

#if USE_GAL
    CGAL     * m_pGAL;
#endif // USE_GAL
    CHISTORY * m_pHistory;

	CConfRoom * m_pConfRoom;


#ifdef ENABLE_BL
	CBL      * m_pBl;
#endif /* ENABLE_BL */

	CALV     * m_pAlv;        // Current Address List View (NOTE: NULL == m_pUls)
	int        m_iSel;        // current selection in combo box
	TCHAR      m_szAddress[CCHMAXSZ_ADDRESS];
	TCHAR      m_szDirectory[CCHMAXSZ];

	CFindSomeone(CConfRoom *pConfRoom);

	HWND GetHwndList();
	int  GetEditText(LPTSTR psz, int cchMax);
	RAI * GetAddrInfo();
	
	int  AddAlv(CALV * pAlv);
	int  AddAlvSz(CALV * pAlv, LPCTSTR psz, int cbIndex=-1);

	HRESULT doModeless(void);
	HRESULT CreateDlgCall(HWND hwndParent);
	BOOL FMsgSpecial(MSG * pMsg);
	VOID CalcDyText(void);
	VOID InitAlv(void);

	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
	void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);

	LRESULT OnNotifyCombo(LPARAM lParam);
	LRESULT OnNotifyList(LPARAM lParam);
	VOID EndComboEdit(int iWhy);
	VOID UpdateIlsServer(void);
	LRESULT DoCustomDraw(LPNMLVCUSTOMDRAW lplvcd);

	VOID ShowList(int iSel);

	HWND
	createIlsListView(void);

	VOID OnEditChangeDirectory(void);
	int  FindSz(LPCTSTR psz);
	int FindSzBySortedColumn(LPCTSTR psz);
	HRESULT HrGetSelection(void);
	void OnDeleteIlsServer(void);

    static LRESULT CALLBACK OwnerDataListWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

private:
	// Helper Fns
	int _GetCurListViewNumColumns();
	bool _IsDirectoryServicePolicyDisabled();

	BOOL
	InitColumns(void);

	BOOL
	LoadColumnInfo(void);

	void
	StoreColumnInfo(void);

	static
	int
	CALLBACK
	CompareWrapper
	(
		LPARAM	param1,
		LPARAM	param2,
		LPARAM	This
	);

	int
	DirListViewCompareProc
	(
		LPARAM	param1,
		LPARAM	param2
	);

	int
	LParamToPos
	(
		LPARAM lParam
	);

	void
	onAdvanced(void);

	void
	onCall(void);

	LONG	m_alColumns[MAX_DIR_COLUMNS];
	int		m_iSortColumn;
	BOOL	m_fSortAscending;
};

CMRUList * GetMruListServer(void);

#define WM_DISPLAY_MSG    (WM_USER + 200)

#endif /* _CDLGCALL2_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dlgauth.cpp ===
// File: dlgauth.cpp

#include "precomp.h"
#include "resource.h"
#include "ConfUtil.h"
#include "dlgauth.h"

extern GUID g_csguidSecurity;

/*  C  D L G  A U T H  */
/*-------------------------------------------------------------------------
    %%Function: CDlgAuth

-------------------------------------------------------------------------*/
CDlgAuth::CDlgAuth(INmCall * pCall):
	m_hwnd(NULL),
	m_pCall(pCall)
{
}

CDlgAuth::~CDlgAuth(void)
{
}


INT_PTR CDlgAuth::DoModal(void)
{
	return DialogBoxParam(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_SECURE_CALL_INFO),
						::GetMainWindow(), CDlgAuth::DlgProcAuth, (LPARAM) this);
}



/*  D L G  P R O C  A U T H  */
/*-------------------------------------------------------------------------
    %%Function: DlgProcAuth

-------------------------------------------------------------------------*/
BOOL CALLBACK CDlgAuth::DlgProcAuth(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG:
	{
		ASSERT(NULL != lParam);
		::SetWindowLongPtr(hdlg, DWLP_USER, lParam);

		CDlgAuth * pDlg = (CDlgAuth *) lParam;
		pDlg->m_hwnd = hdlg;
		pDlg->OnInitDialog();
		return TRUE; // default focus is ok
	}

	case WM_COMMAND:
	{
		CDlgAuth * pDlg = (CDlgAuth*) GetWindowLongPtr(hdlg, DWLP_USER);
		if (NULL != pDlg)
		{
			pDlg->OnCommand(wParam, lParam);
		}
		break;
	}
	
	default:
		break;
	}

	return FALSE;
}


/*  O N  C O M M A N D  */
/*-------------------------------------------------------------------------
    %%Function: OnCommand

-------------------------------------------------------------------------*/
BOOL CDlgAuth::OnCommand(WPARAM wParam, LPARAM lParam)
{
	ASSERT(NULL != m_hwnd);

	WORD wCmd = LOWORD(wParam);
	
	switch (wCmd)
	{
	case IDOK:
	{
		::EndDialog(m_hwnd, wCmd);
		return TRUE;
	}

	case IDCANCEL:
	{
		::EndDialog(m_hwnd, wCmd);
		return TRUE;
	}

	default:
		break;
	}

	return FALSE;
}



/*  O N  I N I T  D I A L O G  */
/*-------------------------------------------------------------------------
    %%Function: OnInitDialog

-------------------------------------------------------------------------*/
VOID CDlgAuth::OnInitDialog(void)
{
	PBYTE pb = NULL;
	ULONG cb = 0;

	CenterWindow(m_hwnd,HWND_DESKTOP);
	ASSERT(NULL != m_pCall);
	if (NULL != m_pCall && S_OK == m_pCall->GetUserData(g_csguidSecurity,&pb,&cb)) {
		if (cb > 0) {
			// Data was properly validated.
			SetDlgItemText(m_hwnd,IDC_SECURE_CALL_CERT,(LPCTSTR)pb);
			CoTaskMemFree(pb);
		}
		else {
			// Something went wrong.  Print an error message in the dialog box.
			TCHAR szTextBuf[MAX_PATH];
			if (FLoadString(IDS_SECURITY_INVALID_CERT,
					szTextBuf, CCHMAX(szTextBuf)))
			SetDlgItemText(m_hwnd,IDC_SECURE_CALL_CERT,szTextBuf);
		}
	}
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dlgcall.cpp ===
// File: dlgcall.cpp
//
// Outgoing call progress dialog

#include "precomp.h"
#include "resource.h"
#include "call.h"
#include "dlgcall.h"
#include "conf.h"
#include "ConfUtil.h"

static int g_cDlgCall = 0; // number of outgoing call dialogs
static int g_dypOffset = 0;

/*  C  D L G  C A L L  */
/*-------------------------------------------------------------------------
    %%Function: CDlgCall

-------------------------------------------------------------------------*/
CDlgCall::CDlgCall(CCall * pCall):
	RefCount(NULL),
	m_pCall(pCall),
	m_hwnd(NULL)
{
	ASSERT(NULL != m_pCall);
	m_pCall->AddRef();  // Released in destructor

	AddRef(); // Destroyed when call goes to a completed state

	if(!_Module.InitControlMode())
	{
		CreateCallDlg();
		g_cDlgCall++;
	}
}

CDlgCall::~CDlgCall(void)
{
	m_pCall->Release();

	g_cDlgCall--;
	if (0 == g_cDlgCall)
	{
		g_dypOffset = 0; // center new dialogs
	}
}

STDMETHODIMP_(ULONG) CDlgCall::AddRef(void)
{
	return RefCount::AddRef();
}

STDMETHODIMP_(ULONG) CDlgCall::Release(void)
{
	return RefCount::Release();
}



/*  C R E A T E  C A L L  D L G  */
/*-------------------------------------------------------------------------
    %%Function: CreateCallDlg

    Create the outgoing call progress dialog
-------------------------------------------------------------------------*/
VOID CDlgCall::CreateCallDlg()
{
	ASSERT(NULL == m_hwnd);
	ASSERT(NULL != m_pCall);
	LPCTSTR pcszName = m_pCall->GetPszName();
	if (NULL == pcszName)
		return;

	// determine the maximum width of the string
	TCHAR szMsg[MAX_PATH*2];
	FLoadString1(IDS_STATUS_WAITING, szMsg, (PVOID) pcszName);
	m_nTextWidth = DxpSz(szMsg);

	FLoadString1(IDS_STATUS_FINDING, szMsg, (PVOID) pcszName);
	int dxp = DxpSz(szMsg);
	if (m_nTextWidth < dxp)
	{
		m_nTextWidth = dxp;
	}

	m_hwnd = ::CreateDialogParam(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_CALL_PROGRESS),
						::GetMainWindow(), CDlgCall::DlgProc, (LPARAM) this);
	if (NULL == m_hwnd)
		return;
	
	::SetDlgItemText(m_hwnd, IDC_MSG_STATIC, szMsg);

	RECT rc;
	::GetWindowRect(m_hwnd, &rc);

	// Stretch the width to fit the person's name,
	int nWidth = RectWidth(rc) + m_nTextWidth;
	int nHeight = RectHeight(rc);
	MoveWindow(m_hwnd, 0, 0, nWidth, nHeight, FALSE);

	// Center it
	CenterWindow(m_hwnd, HWND_DESKTOP);
	::GetWindowRect(m_hwnd, &rc);

	// Move it down
	OffsetRect(&rc, 0, g_dypOffset);

	// Show, move, make topmost
	HWND hwndInsertAfter = HWND_TOPMOST;
#ifdef DEBUG
	{	// Hack to allow call placement to be debugged
		RegEntry reDebug(DEBUG_KEY, HKEY_LOCAL_MACHINE);
		if (0 == reDebug.GetNumber(REGVAL_DBG_CALLTOP, DEFAULT_DBG_CALLTOP))
		{
			hwndInsertAfter = HWND_NOTOPMOST;
		}
	}
#endif
	::SetWindowPos(m_hwnd, hwndInsertAfter, rc.left, rc.top, nWidth, nHeight,
		SWP_SHOWWINDOW | SWP_DRAWFRAME);

	// Adjust for next time
	g_dypOffset += nHeight;

	// Check for wrap-around
	RECT rcDeskTop;
	GetWindowRect(GetDesktopWindow(), &rcDeskTop);
	if ((rc.bottom + nHeight) > rcDeskTop.bottom)
	{
		g_dypOffset -= rc.top;
	}
}


/*  O N  I N I T  D I A L O G  */
/*-------------------------------------------------------------------------
    %%Function: OnInitDialog

-------------------------------------------------------------------------*/
VOID CDlgCall::OnInitDialog(HWND hdlg)
{
	HWND hwnd;
	RECT rc;

	::SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR) this);

	AddModelessDlg(hdlg);
			
	// Move the Cancel button
	hwnd = ::GetDlgItem(hdlg, IDCANCEL);
	if ((NULL != hwnd) && ::GetWindowRect(hwnd, &rc))
	{
		// Turn rc top and left into client coords:
		::MapWindowPoints(NULL, hdlg, (LPPOINT) &rc, 1);
		::SetWindowPos(hwnd, NULL,
				rc.left + m_nTextWidth, rc.top, 0, 0,
				SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE | SWP_NOREDRAW);
	}

	// Stretch the text field:
	hwnd = ::GetDlgItem(hdlg, IDC_MSG_STATIC);
	if ((NULL != hwnd) && ::GetWindowRect(hwnd, &rc))
	{
		::SetWindowPos(hwnd, NULL,
				0, 0, m_nTextWidth, rc.bottom - rc.top,
				SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);

		// and set the font
		::SendMessage(hwnd, WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	}

	// Start the animation
	hwnd = GetDlgItem(hdlg, IDC_CALL_ANIMATION);
	Animate_Open(hwnd, MAKEINTRESOURCE(IDA_CALL_ANIMATION));
	Animate_Play(hwnd, 0, -1, -1);
}

// Change the state of the call
VOID CDlgCall::OnStateChange(void)
{
	if (NULL == m_hwnd)
		return;

	// Assume the only state change is to "Waiting"
	TCHAR szMsg[MAX_PATH*2];
	FLoadString1(IDS_STATUS_WAITING, szMsg, (PVOID) m_pCall->GetPszName());
	SetWindowText(GetDlgItem(m_hwnd, IDC_MSG_STATIC), szMsg);
}


// Destroy the window
// Can be called by OnCancel or the owner
VOID CDlgCall::Destroy(void)
{
	if (NULL != m_hwnd)
	{
        ASSERT(IsWindow(m_hwnd));
		DestroyWindow(m_hwnd);
		m_hwnd = NULL;
	}
}

// Cancel/Close the dialog
VOID CDlgCall::OnCancel(void)
{
	ASSERT(NULL != m_pCall);
	m_pCall->Cancel(FALSE);

    return;
}

// Handle the destruction of the dialog
VOID CDlgCall::OnDestroy(void)
{
	SetWindowLongPtr(m_hwnd, DWLP_USER, 0L);

	HWND hwnd = GetDlgItem(m_hwnd, IDC_CALL_ANIMATION);
	if (NULL != hwnd)
	{		
		Animate_Stop(hwnd);
		Animate_Close(hwnd);
	}

	::RemoveModelessDlg(m_hwnd);

	Release(); // This normally destroys the object
}


/*  D L G  P R O C  */
/*-------------------------------------------------------------------------
    %%Function: DlgProc

-------------------------------------------------------------------------*/
INT_PTR CALLBACK CDlgCall::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			CDlgCall * ppm = (CDlgCall*) lParam;
			ASSERT(NULL != ppm);
			ppm->AddRef();
			ppm->OnInitDialog(hDlg);
			return TRUE;
		}

		case WM_COMMAND:
		{
			switch (GET_WM_COMMAND_ID(wParam, lParam))
				{
			case IDCANCEL:
			{
				CDlgCall * pDlg = (CDlgCall*) GetWindowLongPtr(hDlg, DWLP_USER);
				if (NULL != pDlg)
				{
					// OnCancel will cause this window to be destoyed
					// AddRef this object so that it does not go away.
					pDlg->AddRef();
					pDlg->OnCancel();
					pDlg->Release();
				}
				break;
			}
			default:
				break;
				}

			return TRUE;
		}

		case WM_DESTROY:
		{
			CDlgCall * pDlg = (CDlgCall*) GetWindowLongPtr(hDlg, DWLP_USER);
			if (NULL != pDlg)
			{
				pDlg->OnDestroy();
				pDlg->Release();
			}
			break;
		}

		default:
			break;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dlgcall2.cpp ===
// File: dlgcall.cpp

#include "precomp.h"
#include "resource.h"
#include "help_ids.h"

#include "dlgcall2.h"

#include "dirutil.h"
#include "mrulist2.h"

#include "ldap.h"
#include "wab.h"
#include "calv.h"
#include "speedial.h"
#include "history.h"
#include "dlgacd.h"
#include "conf.h"
#include "confroom.h"
#include "confutil.h"
#include "confpolicies.h"
#include "cmd.h"

// GUI constants for this dialog
const UINT DX_BORDER = 6;     // Standard spacing for Office dialogs
const UINT DY_BORDER = 6;     // Standard spacing for Office dialogs
const UINT DY_COMBOBOX = 200; // Height of the dropped list

const UINT DX_DLGCALL_MIN = 460;
const UINT DY_DLGCALL_MIN = 400;

const UINT DX_DLGCALL_DEFAULT = 800;
const UINT DY_DLGCALL_DEFAULT = 600;

void GetDefaultRect(const HWND hwndParent, RECT & rcRect, const int iDefaultWidth, const int iDefaultHeight);
int GetPixelsPerChar(const HWND hwnd);

const static struct _ColumnInfo
{
	int	iColumnLabelIds;
	int	iMinColumnChars;

}	ciColumnInfo[ MAX_DIR_COLUMNS ]	=
{
	{	IDS_DIR_COLUMN_EMAIL,		28	},
	{	IDS_DIR_COLUMN_AUDIO,		0	},
	{	IDS_DIR_COLUMN_VIDEO,		0	},
	{	IDS_DIR_COLUMN_LAST_NAME,	16	},
	{	IDS_DIR_COLUMN_FIRST_NAME,	14	},
	{	IDS_DIR_COLUMN_LOCATION,	16	},
	{	IDS_DIR_COLUMN_COMMENTS,	22	}
};


///////////////////////////////////////////////////////////////////////////
// Local Data

static const DWORD	_mpIdHelpDlgCall[] =
{
	IDM_DLGCALL_DELETE_ILS,		IDH_FINDSOMEONE_DELETE_ILS,
	IDM_DLGCALL_NEWWINDOW,		IDH_FINDSOMEONE_BROWSER,
	IDM_DLGCALL_REFRESH,		IDH_FINDSOMEONE_REFRESH,
	ID_TB_HELP,					IDH_FINDSOMEONE_HELP,
	IDS_DLGCALL_EDIT_HDR,		IDH_PLACECALL_NAME,
	IDE_DLGCALL_NAME,			IDH_PLACECALL_NAME,
	IDC_DLGCALL_COMBO,			IDH_PLACECALL_INFOSTORE,
	IDS_SECURITY_CHECKBOX,		IDH_PLACECALL_SECURITY_CHKBX,
	IDL_DLGCALL_LIST,			IDH_PLACECALL_LIST,
	IDL_DLGCALL_LISTOWNERDATA,	IDH_PLACECALL_LIST,
	IDL_DLGCALL_ILS_LISTVIEW,	IDH_PLACECALL_LIST,
	IDOK,						IDH_PLACECALL_CALL,
	0,							0
};


int g_cBusy = 0;             // non-zero if busy connecting to server

#ifdef nmDlgCallNormal
const int NM_CALLDLG_DEFAULT       = nmDlgCallNormal;
const int NM_CALLDLG_NO_ILS_FILTER = nmDlgCallNoFilter;
const int NM_CALLDLG_NO_ILS        = nmDlgCallNoIls;
const int NM_CALLDLG_NO_GAL        = nmDlgCallNoGal;
const int NM_CALLDLG_NO_WAB        = nmDlgCallNoWab;
const int NM_CALLDLG_NO_SPEEDDIAL  = nmDlgCallNoSpeedDial;
const int NM_CALLDLG_NO_HISTORY    = nmDlgCallNoHistory;
#endif /* old NM_CALL_DLG constants */


// Dir list types:
const UINT DLT_ULS =					0;
const UINT DLT_IN_CALL_LOG =			1;
const UINT DLT_OUT_CALL_LOG =			2;
const UINT DLT_WAB =					3;

struct DLTCOLUMNINFO
{
	int		nColumns;			// number of columns
	int		nIconColumns;		// number of icon-only columns
	UINT	uStringID;			// string ID of first column
	LPTSTR	pszRVOrder;			// reg val to store column order
	LPTSTR	pszRVWidths;		// reg val to store column widths
	LPTSTR	pszRVSortAscending;	// reg val to store sort direction
	LPTSTR	pszRVSortColumn;	// reg val to store sort column
};

const DLTCOLUMNINFO g_rgDLColumnInfo[] =
{
	{ 	MAX_DIR_COLUMNS, 2, IDS_DIR_COLUMN_FIRST,			// DLT_ULS
		&REGVAL_DIR_COLUMN_ORDER, &REGVAL_DIR_COLUMN_WIDTHS,
		&REGVAL_DIR_SORT_ASCENDING, &REGVAL_DIR_SORT_COLUMN	},
};

CFindSomeone* CFindSomeone::s_pDlgCall= NULL;

///////////////////////////////////////////////////////////////////////////
int StringCompare( const TCHAR * const psz1, const TCHAR * const psz2 );


void UpdateSecurityCheck(CConfRoom *pConfRoom, HWND hDlg, UINT idCheck)
{
	bool userAlterable, secure;

	pConfRoom->get_securitySettings( userAlterable, secure );

	EnableWindow( GetDlgItem(hDlg, idCheck), userAlterable );
	::CheckDlgButton( hDlg, idCheck, secure? BST_CHECKED: BST_UNCHECKED );
}


/*  C  D L G  C A L L  */
/*-------------------------------------------------------------------------
    %%Function: CFindSomeone

-------------------------------------------------------------------------*/
CFindSomeone::CFindSomeone(CConfRoom *pConfRoom):
	m_pAccel(NULL),
	m_dwOptions(0),
	m_hwndList(NULL),
	m_ilsListView(NULL),
	m_hwndCombo(NULL),
	m_hwndComboEdit(NULL),
	m_hwndEdit(NULL),
	m_webView( NULL ),
	m_WndOwnerDataListOldWndProc(NULL),
	m_fInEdit(FALSE),
	m_iSel(0),
	m_pMruServer(NULL),
	m_pUls(NULL),
	m_pSpeedDial(NULL),
#if USE_GAL
	m_pGAL(NULL),
#endif //#if USE_GAL
	m_pAlv(NULL),
	m_pWab(NULL),
	m_pHistory(NULL),
	m_pszDefault(NULL),
	m_pRai(NULL),
	m_pConfRoom(pConfRoom),
	m_bPlacedCall(false)
{
	SetEmptySz(m_szAddress);
	SetEmptySz(m_szDirectory);

	// BUGBUG georgep: Why are we checking m_dwOptions? It was set to 0 above.

	if ((0 == (m_dwOptions & NM_CALLDLG_NO_WAB)) &&
		(NULL == CWAB::GetInstance()) )
	{
		m_pWab = new CWAB();
	}

	if (0 == (m_dwOptions & NM_CALLDLG_NO_ILS))
	{
		m_pMruServer = GetMruListServer();
		m_pUls = new CLDAP();
	}

	if (0 == (m_dwOptions & NM_CALLDLG_NO_SPEEDDIAL))
	{
		m_pSpeedDial = new CSPEEDDIAL();
	}
	
#if USE_GAL
	if ((0 == (m_dwOptions & NM_CALLDLG_NO_GAL)) &&
		CGAL::FLoadMapiFns() )
	{
		m_pGAL = new CGAL();
	}
#endif // USE_GAL

	if (0 == (m_dwOptions & NM_CALLDLG_NO_HISTORY))
	{
		m_pHistory = new CHISTORY();
	}
	
	// Load the small icon list
	m_himlIcon = ImageList_Create(DXP_ICON_SMALL, DYP_ICON_SMALL, ILC_MASK, 1, 0);
	if (NULL != m_himlIcon)
	{
		HBITMAP hBmp = ::LoadBitmap(::GetInstanceHandle(), MAKEINTRESOURCE(IDB_ICON_IMAGES));
		if (NULL != hBmp)
		{
			ImageList_AddMasked(m_himlIcon, hBmp, TOOLBAR_MASK_COLOR);
			::DeleteObject(hBmp);
		}
	}

	m_pConfRoom->AddConferenceChangeHandler(this);
}

CFindSomeone::~CFindSomeone(void)
{
	// Clear any existing data
	if (NULL != m_pAlv)
	{
		m_pAlv->ClearItems();
	}

	delete m_pMruServer;

	if (NULL != m_pWab)
	{
		m_pWab->Release();
	}
	if (NULL != m_pUls)
	{
		m_pUls->Release();
	}
	if (NULL != m_pSpeedDial)
	{
		m_pSpeedDial->Release();
	}
	if (NULL != m_himlIcon)
	{
		ImageList_Destroy(m_himlIcon);
	}
#if USE_GAL
	if (NULL != m_pGAL)
	{
		m_pGAL->Release();
	}
#endif // USE_GAL
	if (NULL != m_pHistory)
	{
		m_pHistory->Release();
	}

	ClearRai(&m_pRai);

	m_pConfRoom->RemoveConferenceChangeHandler(this);
}


//--------------------------------------------------------------------------//
//	CFindSomeone::findSomeone.												//
//--------------------------------------------------------------------------//
void
CFindSomeone::findSomeone(CConfRoom *pConfRoom)
{
	if (NULL == s_pDlgCall)
	{
		s_pDlgCall = new CFindSomeone(pConfRoom);
		s_pDlgCall->doModeless();
	}

	if (NULL != s_pDlgCall)
	{
		HWND hwnd = s_pDlgCall->GetWindow();

		::ShowWindow( hwnd, SW_RESTORE );
		::SetForegroundWindow( hwnd );
	}

}	//	End of CFindSomeone::findSomeone.


//--------------------------------------------------------------------------//
//	CDlgCall::Destroy.														//
//--------------------------------------------------------------------------//
void
CFindSomeone::Destroy()
{
WARNING_OUT(("Entering CFindSomeone::Destroy( )..."));
	CFindSomeone *	pDlgCall	= s_pDlgCall;
	s_pDlgCall = NULL;

	if( pDlgCall != NULL )
	{
		if( pDlgCall->m_pUls != NULL )
		{
			//	Stop the CLDAP thread from trying to interact with the FindSomeone
			//	windows after we've already destroyed them...
			pDlgCall->m_pUls->CloseServer();
		}

		HWND hwnd = pDlgCall->GetWindow();
		if (NULL != hwnd)
		{
WARNING_OUT(("CFindSomeone::Destroy( ): destroying windows..."));
			DestroyWindow(hwnd);
		}

		pDlgCall->Release();
	}
WARNING_OUT(("Exiting CFindSomeone::Destroy( )..."));

}	//	End of CDlgCall::Destroy.


HWND CFindSomeone::GetHwndList()
{
	return ( m_pAlv && m_pAlv->FOwnerData() ) ?
		m_hwndOwnerDataList : (m_pAlv == (CALV *) m_pUls)? m_ilsListView: m_hwndList;
}

RAI * CFindSomeone::GetAddrInfo()
{
	return DupRai(m_pRai);
}


/*  F  M S G  S P E C I A L  */
/*-------------------------------------------------------------------------
    %%Function: FMsgSpecial

    Return TRUE if this is a special message, not to be passed to IsDialogMessage
-------------------------------------------------------------------------*/
BOOL CFindSomeone::FMsgSpecial(MSG * pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
	case WM_KEYUP:
	case WM_CHAR:
		if (VK_F5 == pMsg->wParam)
			return TRUE;
		if (VK_RETURN == pMsg->wParam)
		{
			if (m_hwndComboEdit == GetFocus())
			{
				return TRUE;
			}
		}
		break;
	default:
		break;
	}

	return FALSE;
}


/*  D O  M O D A L  */
/*-------------------------------------------------------------------------
    %%Function: DoModal

-------------------------------------------------------------------------*/
HRESULT
CFindSomeone::doModeless(void)
{

#if 0
	HACCEL hAccel = LoadAccelerators(::GetInstanceHandle(), MAKEINTRESOURCE(IDA_DLGCALL));
#endif

	HRESULT hr = CreateDlgCall(NULL);
#if 0
	if (SUCCEEDED(hr) && (NULL != m_hwnd))
	{
		while (IsWindow(m_hwnd))
		{
			MSG msg;
			if (!::GetMessage(&msg, NULL, 0, 0))
			{
				// Don't eat the WM_QUIT
				PostQuitMessage(msg.wParam);
				break; // out of loop
			}

			if (FMsgSpecial(&msg) || !IsDialogMessage(m_hwnd, &msg))
			{
				if (FALSE == ::TranslateAccelerator(m_hwnd, hAccel, &msg))
				{
					::TranslateMessage(&msg);
					::DispatchMessage(&msg);
				}
			}
		}
	}
#endif

	return hr;
}


// Determine the standard font size
VOID CFindSomeone::CalcDyText(void)
{
	m_dyText = 14; // default to something reasonable
	HWND hwnd = GetWindow();

	ASSERT(NULL != hwnd);

	HDC hdc = GetDC(hwnd);
	if (NULL == hdc)
		return;

	TEXTMETRIC tm;
	if (GetTextMetrics(hdc, &tm))
	{
		m_dyText = tm.tmHeight;
	}

	// Leave space for 4 n's (two on each side)
	TCHAR sz[MAX_PATH];
	const int cSpaceN = 4;
	for (int ich = 0; ich < cSpaceN; ich++)
	{
		sz[ich] = _T('n');
	}
	if (FLoadString( IDS_DLGCALL_CLOSE, &sz[cSpaceN], CCHMAX(sz)-cSpaceN))
	{
		HFONT hfont = SelectFont(hdc, ::GetDefaultFont());
		RECT rc;
		SetRect(&rc, 0, 0, 0, 0);
		m_dyButton = 2*DY_BORDER + DrawText(hdc, sz, -1, &rc, DT_CALCRECT);
		m_dxButton = rc.right;
		hfont = SelectFont(hdc, hfont);
	}

	ReleaseDC(hwnd, hdc);
}

HWND CreatIconButton(HWND hwndParent, int idTooltip, int idCmd, int idIcon)
{
	HWND hwndButton = CreateButton( hwndParent, idTooltip, idCmd );
	if (NULL != hwndButton)
	{
		AddToolTip(hwndParent, hwndButton, idTooltip);

		SetWindowLong(hwndButton, GWL_STYLE, BS_PUSHBUTTON|BS_ICON|WS_VISIBLE|WS_CHILD|WS_TABSTOP);

		HANDLE hIcon = LoadImage(GetInstanceHandle(), MAKEINTRESOURCE(idIcon),
			IMAGE_ICON, 0, 0, 0);
		SendMessage(hwndButton, BM_SETIMAGE, IMAGE_ICON, reinterpret_cast<LPARAM>(hIcon));
	}

	return(hwndButton);
}
	
/*  C R E A T E  D L G  C A L L  */
/*-------------------------------------------------------------------------
    %%Function: CreateDlgCall

	The order in which these windows is created is very important.
	See the Layout function and pay attention to the tab order

-------------------------------------------------------------------------*/
HRESULT CFindSomeone::CreateDlgCall(HWND hwndParent)
{
	TCHAR sz[CCHMAXSZ];

	HRESULT hr = S_OK;
	
	if (NULL == m_himlIcon)
		return E_FAIL; // no pretty icons, don't bother trying to continue

	if (!FLoadString(IDS_DLGCALL_TITLE, sz, CCHMAX(sz)))
		return E_FAIL;

	// Get the window position
	PVOID pv;
	RECT rcDest; // left, right, width, height
	RegEntry re(DLGCALL_MRU_KEY, HKEY_CURRENT_USER);
	if (sizeof(rcDest) == re.GetBinary(REGVAL_DLGCALL_POSITION, &pv))
	{
		CopyMemory(&rcDest, pv, sizeof(rcDest));
	}
	else
	{
		GetDefaultRect( hwndParent, rcDest, DX_DLGCALL_DEFAULT, DY_DLGCALL_DEFAULT );
		rcDest.right	-= rcDest.left;
		rcDest.bottom	-= rcDest.top;
	}

	if (!CFrame::Create(
		hwndParent,
		sz,
		WS_OVERLAPPEDWINDOW | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME,
		0,
		rcDest.left, rcDest.top, rcDest.right, rcDest.bottom,
		GetInstanceHandle(),
		LoadIcon(GetInstanceHandle(), MAKEINTRESOURCE(IDI_WEBVIEW))
		))
	{
		return E_OUTOFMEMORY;
	}

	HWND hwndThis = GetWindow();

	CalcDyText();

	//////////////////////////////////
	// Static text at the top
	HWND hwnd = CreateStaticText(hwndThis, IDS_DLGCALL_HDR);

	DWORD dwStyle = WS_CHILD | WS_BORDER | WS_VSCROLL | WS_VISIBLE | WS_TABSTOP |
				WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CBS_AUTOHSCROLL;

	// Either a complicated combo edit/listbox or a simple drop list
	if ((NULL != m_pUls) && m_pUls->FAvailable())
	{
		dwStyle |= (0 != (nmDlgCallNoServerEdit & m_dwOptions)) ?
		          CBS_DROPDOWNLIST : CBS_DROPDOWN;
	}
	else
	{
		dwStyle |= CBS_DROPDOWNLIST;
	}

	m_hwndCombo = ::CreateWindowEx(0L, g_cszComboBoxEx, g_cszEmpty, dwStyle,
				0, 0, DX_BORDER, DY_COMBOBOX,
				hwndThis, (HMENU) IDC_DLGCALL_COMBO,
				::GetInstanceHandle(), NULL);
	if (NULL != m_hwndCombo)
	{
		// Set the icons
		::SendMessage(m_hwndCombo, CBEM_SETIMAGELIST, 0, (LPARAM) m_himlIcon);

		// Set the font:
		::SendMessage(m_hwndCombo, WM_SETFONT, (WPARAM) GetDefaultFont(), 0);

		// Limit the text
		::SendMessage(m_hwndCombo, CB_LIMITTEXT, CCHMAXSZ_ADDRESS-1, 0L);

		// Set extended user interface
		::SendMessage(m_hwndCombo, CB_SETEXTENDEDUI, 1, 0L);

		m_hwndComboEdit = (HWND) SendMessage(m_hwndCombo, CBEM_GETEDITCONTROL, 0, 0);
		if (NULL != m_hwndComboEdit)
		{
			// Add a tooltip to the combo box (actually, the edit control)
			AddToolTip(hwndThis, m_hwndComboEdit, IDS_DLGCALL_COMBO_TOOLTIP);
		}
		else
		{
			// Add a tooltip to the combo box
			AddToolTip(hwndThis, m_hwndCombo, IDS_DLGCALL_COMBO_TOOLTIP);
		}
	}

	CreatIconButton(hwndThis, IDS_TT_DELETE_ILS, IDM_DLGCALL_DELETE_ILS, IDI_DELETE);
	CreatIconButton(hwndThis, IDS_TT_NEWWINDOW , IDM_DLGCALL_NEWWINDOW , IDI_NEWHTMLWINDOW);
	CreatIconButton(hwndThis, IDS_TT_REFRESH   , IDM_DLGCALL_REFRESH   , IDI_REFRESH);
	CreatIconButton(hwndThis, IDS_TT_HELP      , ID_TB_HELP            , IDI_HELP);

	//////////////////////////////////
	// GroupBox
	m_hwndFrame  = ::CreateWindowEx( 0, TEXT( "button" ), g_cszEmpty,
				WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | WS_GROUP | BS_GROUPBOX,
				0, 0, 0, 0,
				hwndThis, (HMENU) -1,
				::GetInstanceHandle(), NULL);

	//////////////////////////////////
	// Edit Control
	CreateStaticText(hwndThis, IDS_DLGCALL_EDIT_HDR);

	m_hwndEdit = ::CreateWindowEx(WS_EX_CLIENTEDGE, g_cszEdit, g_cszEmpty,
				WS_CHILD | WS_BORDER | WS_VISIBLE | WS_TABSTOP | WS_CLIPCHILDREN |
				ES_AUTOHSCROLL,
				0, 0, 0, 0,
				hwndThis, (HMENU) IDE_DLGCALL_NAME,
				::GetInstanceHandle(), NULL);
	if (NULL != m_hwndEdit)
	{
		// Set the font:
		::SendMessage(m_hwndEdit, WM_SETFONT, (WPARAM) GetDefaultFont(), 0);

		// Limit the text
		::SendMessage(m_hwndEdit, EM_LIMITTEXT, CCHMAXSZ_ADDRESS-1, 0L);

		// Add a tooltip to the edit control
		AddToolTip(hwndThis, m_hwndEdit, IDS_DLGCALL_EDIT_TOOLTIP);
	}

	////////////////////////////////
	// Main Listbox
	m_hwndList = CreateWindowEx(WS_EX_CLIENTEDGE, g_cszListView, g_cszEmpty,
			WS_CHILD | WS_CLIPCHILDREN | WS_BORDER | WS_TABSTOP | WS_VISIBLE |
			LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS |
			LVS_SORTASCENDING | LVS_NOSORTHEADER,
			0, 0, 0, 0,
			hwndThis, (HMENU) IDL_DLGCALL_LIST,
			::GetInstanceHandle(), NULL);
	if (NULL != m_hwndList)
	{
		ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT);
		ListView_SetImageList(m_hwndList, m_himlIcon, LVSIL_SMALL);

		LV_COLUMN lvc;
		ClearStruct(&lvc);
		lvc.mask = LVCF_TEXT | LVCF_SUBITEM;
		lvc.pszText = sz;

		if (FLoadString(IDS_NAME, sz, CCHMAX(sz)))
		{
			lvc.iSubItem = 0;
			ListView_InsertColumn(m_hwndList, IDI_DLGCALL_NAME, &lvc);
		}

		if (FLoadString(IDS_ADDRESS, sz, CCHMAX(sz)))
		{
			lvc.iSubItem = 1;
			ListView_InsertColumn(m_hwndList, IDI_DLGCALL_ADDRESS, &lvc);
		}
		
		m_cVisible = ListView_GetCountPerPage(m_hwndList);
	}


	////////////////////////////////
	// OwnerData Listbox
	m_hwndOwnerDataList = CreateWindowEx(WS_EX_CLIENTEDGE, g_cszListView, g_cszEmpty,
			WS_CHILD | WS_CLIPCHILDREN | WS_BORDER | WS_TABSTOP | WS_VISIBLE |
			LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS |
			LVS_SORTASCENDING | LVS_NOSORTHEADER | LVS_OWNERDATA,
			0, 0, 0, 0,
			hwndThis, (HMENU) IDL_DLGCALL_LISTOWNERDATA,
			::GetInstanceHandle(), NULL);

	if (NULL != m_hwndOwnerDataList)
	{
		ListView_SetExtendedListViewStyle(m_hwndOwnerDataList, LVS_EX_FULLROWSELECT);
		ListView_SetImageList(m_hwndOwnerDataList, m_himlIcon, LVSIL_SMALL);

		LV_COLUMN lvc;
		ClearStruct(&lvc);
		lvc.mask = LVCF_TEXT | LVCF_SUBITEM;
		lvc.pszText = sz;

		if (FLoadString(IDS_NAME, sz, CCHMAX(sz)))
		{
			lvc.iSubItem = 0;
			ListView_InsertColumn(m_hwndOwnerDataList, IDI_DLGCALL_NAME, &lvc);
		}

		if (FLoadString(IDS_ADDRESS, sz, CCHMAX(sz)))
		{
			lvc.iSubItem = 1;
			ListView_InsertColumn(m_hwndOwnerDataList, IDI_DLGCALL_ADDRESS, &lvc);
		}

		m_WndOwnerDataListOldWndProc = reinterpret_cast< WNDPROC >(GetWindowLongPtr(m_hwndOwnerDataList, GWLP_WNDPROC));
		SetWindowLongPtr(m_hwndOwnerDataList, GWLP_USERDATA, reinterpret_cast< LONG_PTR >( this ));
		SetWindowLongPtr(m_hwndOwnerDataList, GWLP_WNDPROC, reinterpret_cast< LONG_PTR >( OwnerDataListWndProc));
    }




	////////////////////////////////
	// ILS Listbox
	m_ilsListView = CreateWindowEx(	WS_EX_CLIENTEDGE,
									WC_LISTVIEW,		// list view class
									TEXT( "" ),			// no default text
									WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_VSCROLL | WS_TABSTOP |
									LVS_REPORT | LVS_SINGLESEL | LVS_AUTOARRANGE | LVS_SHAREIMAGELISTS | LVS_SHOWSELALWAYS,
									0, 0,
									0, 0,
									hwndThis,
									(HMENU) IDL_DLGCALL_ILS_LISTVIEW,
									::GetInstanceHandle(),
									NULL );

	if( m_ilsListView != NULL )
	{
		InitColumns();

		// Associate the image list with the list view
		ListView_SetImageList( m_ilsListView, m_himlIcon, LVSIL_SMALL);

		// set the style to do drag and drop headers and full row select
		ListView_SetExtendedListViewStyle( m_ilsListView, ListView_GetExtendedListViewStyle( m_ilsListView ) |
															LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES );
	}

	TCHAR szWebDir[1024];
	CDirectoryManager::get_webDirectoryUrl(szWebDir, ARRAY_ELEMENTS(szWebDir));

	m_webView = CreateWindowEx( WS_EX_CLIENTEDGE | WS_EX_CONTROLPARENT,
								TEXT( "AtlAxWin" ),
								szWebDir,
								WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_TABSTOP,
								0, 0,
								0, 0,
								hwndThis,
								(HMENU) IDL_DLGCALL_WEB_VIEW,
								::GetInstanceHandle(),
								NULL );

	//////////////////////////////////
	// Security Control
	FLoadString( IDS_SECURITY_CHECKBOX, sz, CCHMAX( sz ) );

	HWND	securityCheckBox;
	
	securityCheckBox = ::CreateWindow(
		TEXT( "button" ),
		sz,
		WS_CHILD | WS_TABSTOP | WS_VISIBLE | BS_AUTOCHECKBOX | BS_MULTILINE | BS_TOP,
		0, 0, 0, 0,
		hwndThis,
		(HMENU) IDS_SECURITY_CHECKBOX,
		::GetInstanceHandle(),
		NULL );

	if( securityCheckBox != NULL )
	{
		// Set the font:
		::SendMessage(securityCheckBox, WM_SETFONT, (WPARAM) GetDefaultFont(), 0);

		UpdateSecurityCheck(m_pConfRoom, hwndThis, IDS_SECURITY_CHECKBOX);
	}

	CreateButton( hwndThis, IDS_DLGCALL_CALL, IDOK );
	CreateButton( hwndThis, IDS_DLGCALL_CLOSE, IDCANCEL );

	// Finally, initialize the data in each list
	InitAlv();

	Layout();

	if( m_ilsListView != NULL )
	{
		LoadColumnInfo();
	}

	if (m_pConfRoom->FIsConferenceActive())
	{
		// Simulate a call started to get all the states right
		OnCallStarted();
	}

	ShowWindow(hwndThis, SW_SHOWNORMAL);

	::EnableWindow(GetDlgItem(hwndThis, IDOK), FALSE);
	
	if( m_pAlv )
	{
		SetFocus(m_hwndEdit);
		if (!FEmptySz(m_pszDefault))
		{
			SetWindowText(m_hwndEdit, m_pszDefault);
		}
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;
}

bool
get_textRect
(
	const HWND			window,
	RECT &				rect,
	const TCHAR * const	measureText = NULL
);


//--------------------------------------------------------------------------//
//	get_textRect.															//
//--------------------------------------------------------------------------//
bool
get_textRect
(
	const HWND			window,
	RECT &				rect,
	const TCHAR * const	measureText
){
	HDC		dc		= GetDC( window );
	bool	result	= false;

	if( dc != NULL )
	{
		HFONT	font = SelectFont( dc, ::GetDefaultFont() );
		
		if( measureText != NULL )
		{
			DrawText( dc, measureText, -1, &rect, DT_CALCRECT | DT_WORDBREAK );
			result = true;
		}
		else
		{
			int	length;

			if( (length = ::SendMessage( window, WM_GETTEXTLENGTH, 0, 0 )) > 0 )
			{
				TCHAR *	text	= new TCHAR [ length + 1 ];

				if( text != NULL )
				{
					::SendMessage( window, WM_GETTEXT, length + 1, (LPARAM) text );
					DrawText( dc, text, -1, &rect, DT_CALCRECT | DT_WORDBREAK );
					delete [] text;
					result = true;
				}
			}
		}

		SelectFont( dc,  font );
		ReleaseDC( window, dc );
	}

	return( result );

}	//	End of get_textRect.


//--------------------------------------------------------------------------//
//	CFindSomeone::Layout.													//
//--------------------------------------------------------------------------//
void
CFindSomeone::Layout(void)
{
	// BUGBUG georgep: Hard coded for now
	static const int IconButtonWidth = 24;
	static const int IconButtonHeight = 24;

	static const int idIconButtons[] =
	{
		IDM_DLGCALL_DELETE_ILS,
		IDM_DLGCALL_NEWWINDOW,
		IDM_DLGCALL_REFRESH,
		ID_TB_HELP,
	};
	static const int NumIconButtons = ARRAY_ELEMENTS(idIconButtons);

	HWND hwnd = GetWindow();

	HDWP hdwp = BeginDeferWindowPos(15);

	//	Get client area (inside margin/border)...
	RECT rc;
	GetClientRect(hwnd, &rc);
	int	clientWidth		= rc.right - 2*DX_BORDER;
	int	clientHeight	= rc.bottom - (DY_BORDER + DY_BORDER + m_dyButton);

	int maxComboLabelWidth	= (clientWidth - NumIconButtons*(DX_BORDER + IconButtonWidth)) / 2;

	HWND	comboLabel	= GetDlgItem( hwnd, IDS_DLGCALL_HDR );
	RECT	comboRect;
	RECT	comboLabelRect;

	GetWindowRect( m_hwndCombo, &comboRect );

	SetRect( &comboLabelRect, 0, 0, maxComboLabelWidth, 0 );
	get_textRect( comboLabel, comboLabelRect );

	int	comboHeight			= RectHeight( comboRect );
	int	comboLabelWidth		= RectWidth( comboLabelRect );
	int	comboLabelHeight	= RectHeight( comboLabelRect );

	int	maxHeight	= max( comboHeight, comboLabelHeight );

	int comboLabelLeft	= DX_BORDER;
	int	comboLabelTop	= max( DY_BORDER, (DY_BORDER + ((maxHeight - comboLabelHeight) / 2)) );

	hdwp = DeferWindowPos(hdwp,
					comboLabel,
					NULL,
					comboLabelLeft,
					comboLabelTop,
					comboLabelWidth,
					comboLabelHeight,
					SWP_NOACTIVATE | SWP_NOZORDER );

	int	comboLeft		= comboLabelLeft + comboLabelWidth + DX_BORDER;
	int	comboTop		= max( DY_BORDER, (DY_BORDER + ((maxHeight - comboHeight) / 2)) );
	int comboWidth		= clientWidth - (comboLabelLeft + comboLabelWidth
		+ NumIconButtons*(DX_BORDER + IconButtonWidth) );

	hdwp = DeferWindowPos(hdwp,
					m_hwndCombo,
					NULL,
					comboLeft,
					comboTop,
					comboWidth,
					DY_COMBOBOX,
					SWP_NOACTIVATE | SWP_NOZORDER );

	{
		for (int i=0; i<NumIconButtons; ++i)
		{
			hdwp = DeferWindowPos(hdwp,
				GetDlgItem(hwnd, idIconButtons[i]),
				NULL,
				comboLeft + comboWidth + DX_BORDER + i*(IconButtonWidth+DX_BORDER),
				comboTop,
				IconButtonWidth,
				IconButtonHeight,
				SWP_NOACTIVATE | SWP_NOZORDER );
		}
	}

	int	frameTop	= maxHeight + DY_BORDER;

	hdwp = DeferWindowPos(hdwp,
					m_hwndFrame,
					NULL,
					DX_BORDER,
					frameTop,
					clientWidth,
					clientHeight - frameTop,
					SWP_NOACTIVATE | SWP_NOZORDER );

	// Add a little because groups draw inside their bounds
	frameTop += 2 * DY_BORDER;

	RECT	editLabelRect;
	HWND	editLabel		= GetDlgItem( hwnd, IDS_DLGCALL_EDIT_HDR );
	int		editLabelWidth	= (clientWidth - (DX_BORDER * 6)) / 2;

	SetRect( &editLabelRect, 0, 0, editLabelWidth, 0 );
	get_textRect( editLabel, editLabelRect );

	int	editLabelHeight	= RectHeight( editLabelRect );
	int editLabelLeft	= DY_BORDER * 3;
	int editLabelTop	= frameTop + DY_BORDER;

	hdwp = DeferWindowPos(hdwp,
					editLabel,
					NULL,
					editLabelLeft,
					editLabelTop,
					editLabelWidth,
					editLabelHeight,
					SWP_NOACTIVATE | SWP_NOZORDER );

	int editTop	= editLabelTop + editLabelHeight + DY_BORDER;

	// Edit Control
	hdwp = DeferWindowPos(hdwp,
					m_hwndEdit,
					NULL,
					editLabelLeft,
					editTop,
					editLabelWidth,
					comboHeight,
					SWP_NOACTIVATE | SWP_NOZORDER );

	int	buttonTop		= clientHeight - ((DY_BORDER * 3) / 2) - m_dyButton;
	int	listViewLeft	= 3 * DX_BORDER;
	int	listViewTop		= editTop + comboHeight + DY_BORDER;
	int	listViewWidth	= clientWidth - (DX_BORDER * 4);
	int	listViewHeight	= buttonTop - listViewTop - DY_BORDER;
	int	columns			= _GetCurListViewNumColumns();
	int	columnWidth		= listViewWidth / columns;

	// ListBox
	hdwp = DeferWindowPos(hdwp,
					m_hwndList,
					NULL,
					listViewLeft,
					listViewTop,
					listViewWidth,
					listViewHeight,
					SWP_NOACTIVATE | SWP_NOZORDER );

	hdwp = DeferWindowPos(hdwp,
					m_hwndOwnerDataList,
					NULL,
					listViewLeft,
					listViewTop,
					listViewWidth,
					listViewHeight,
					SWP_NOACTIVATE | SWP_NOZORDER );

	hdwp = DeferWindowPos(hdwp,
					m_ilsListView,
					NULL,
					listViewLeft,
					listViewTop,
					listViewWidth,
					listViewHeight,
					SWP_NOACTIVATE | SWP_NOZORDER );

	HWND hWndList = GetHwndList();

	if( hWndList != m_ilsListView )
	{
		for( int i = 0; i < columns; i++ )
		{
			ListView_SetColumnWidth( hWndList, i, columnWidth );
		}
	}

	InvalidateRect( ListView_GetHeader(hWndList), NULL, true );

	m_cVisible = ListView_GetCountPerPage(hWndList);
	
	{
		int		securityWidth	= editLabelWidth - GetSystemMetrics( SM_CXSMICON );
		HWND	security		= GetDlgItem( hwnd, IDS_SECURITY_CHECKBOX );
		RECT	securityRect;

		SetRect( &securityRect, 0, 0, securityWidth, 0 );
		get_textRect( security, securityRect );

		// + 2 for the focus rect
		int	securityHeight	= RectHeight( securityRect ) + 2;
		int checkHeight = GetSystemMetrics(SM_CYMENUCHECK);
		securityHeight = max (securityHeight, checkHeight);

		hdwp = DeferWindowPos(hdwp,
						security,
						NULL,
						listViewLeft,
						buttonTop,
						securityWidth,
						securityHeight,
						SWP_NOACTIVATE | SWP_NOZORDER );
	}

	HWND	callButton =	GetDlgItem( hwnd, IDOK );

	hdwp = DeferWindowPos(hdwp,
					callButton,
					NULL,
					clientWidth - DX_BORDER - m_dxButton,
					buttonTop,
					m_dxButton,
					m_dyButton,
					SWP_NOACTIVATE | SWP_NOZORDER );

	hdwp = DeferWindowPos(hdwp,
					m_webView,
					NULL,
					DX_BORDER,
					frameTop,
					clientWidth,
					clientHeight - frameTop,
					SWP_NOACTIVATE | SWP_NOZORDER );

	// Center the close button at the bottom of the window
	HWND	closeButton =	GetDlgItem( hwnd, IDCANCEL );

	hdwp = DeferWindowPos(hdwp,
					closeButton,
					NULL,
					(clientWidth - m_dxButton) / 2,
					clientHeight + DY_BORDER,
					m_dxButton,
					m_dyButton,
					SWP_NOACTIVATE | SWP_NOZORDER );

	EndDeferWindowPos(hdwp);
}	//	End of CFindSomeone::Layout.

static BOOL IsInClient(HWND hwnd, POINT *ppt)
{
	RECT rc;
	GetClientRect(hwnd, &rc);
	MapWindowPoints(hwnd, HWND_DESKTOP, (POINT *) &rc, 2);
	return(PtInRect(&rc, *ppt));
}

void CFindSomeone::OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
{
	POINT pt = { xPos, yPos };

	if (IsInClient(GetHwndList(), &pt))
	{
		m_pAlv->OnRClick(pt);
		return;
	}

	if (IsInClient(GetWindow(), &pt))
	{
		DoHelpWhatsThis(reinterpret_cast<WPARAM>(hwndContext), _mpIdHelpDlgCall);
		return;
	}

	FORWARD_WM_CONTEXTMENU(hwnd, hwndContext, xPos, yPos, CFrame::ProcessMessage);
}

LRESULT CFindSomeone::ProcessMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		HANDLE_MSG(hwnd, WM_COMMAND    , OnCommand);
		HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);

	case WM_GETMINMAXINFO:
	{
		LPMINMAXINFO lpminmax = (LPMINMAXINFO) lParam;
		lpminmax->ptMinTrackSize.x = DX_DLGCALL_MIN;
		lpminmax->ptMinTrackSize.y = DY_DLGCALL_MIN;
		return 0;
	}

	case WM_DISPLAY_MSG:
	{
		DisplayMsgId(hwnd, (int) wParam);
		return 0;
	}

	case WM_CLOSE:
		Destroy();
		break;

	case WM_CREATE:
	{
		HACCEL hAccel = LoadAccelerators(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDA_DLGCALL));
		if (NULL != hAccel)
		{
			m_pAccel = new CTranslateAccelTable(hwnd, hAccel);
			if (NULL != m_pAccel)
			{
				AddTranslateAccelerator(m_pAccel);
			}
		}

		// Must be done AFTER adding the accelerator table
		AddModelessDlg(hwnd);

		break;
	}

	case WM_DESTROY:
	{
		if (NULL != m_pAccel)
		{
			RemoveTranslateAccelerator(m_pAccel);
			m_pAccel->Release();
			m_pAccel = NULL;
		}

		RemoveModelessDlg(hwnd);

		if (NULL != m_pAlv)
		{
			m_pAlv->ClearItems();
			m_pAlv->ClearHwnd();
		}

		RegEntry re(DLGCALL_MRU_KEY, HKEY_CURRENT_USER);

		// Save the window size/position
		RECT rc;
		if (GetWindowRect(hwnd, &rc))
		{
			rc.right -= rc.left;
			rc.bottom -= rc.top;
			re.SetValue(REGVAL_DLGCALL_POSITION, &rc, sizeof(rc));
		}

		// Save the selected view
		TCHAR szServer[CCHMAXSZ_SERVER];
		if (0 != GetWindowText(m_hwndComboEdit, szServer, CCHMAX(szServer)))
		{
			TRACE_OUT(("Saving last used directory is [%s]", szServer));
			re.SetValue(REGVAL_DLGCALL_DEFDIR, szServer);
		}

		StoreColumnInfo();

		return 0;
	}

	case WM_HELP:
	{
		DoHelp(lParam, _mpIdHelpDlgCall);
		break;
	}

	case WM_NOTIFY:
	{
		switch (wParam)
			{
		case IDL_DLGCALL_LIST:
		case IDL_DLGCALL_LISTOWNERDATA:
		case IDL_DLGCALL_ILS_LISTVIEW:
			return OnNotifyList(lParam);
		case IDC_DLGCALL_COMBO:
			OnNotifyCombo(lParam);
 			break;
 		default:
 			break;
	 		}
		break;
	}

	case WM_SETTINGCHANGE:
	{
		WINDOWPLACEMENT wp;
		wp.length = sizeof(wp);
		if (!GetWindowPlacement(hwnd, &wp))
			break;
		switch (wp.showCmd)
		{
		case SW_NORMAL:
		case SW_RESTORE:
		{
			CalcDyText();
			Layout();
			break;
		}

		default:
			break;
		}
		break;
	}

	case WM_SETCURSOR:
	{
		if (0 == g_cBusy)
			break;

		::SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_APPSTARTING)));
		return TRUE;
	}
	
	case WM_SETFOCUS:
	{
		::SetFocus(m_hwndEdit);
		return 0;
	}

	default:
		break;
	}

	return(CFrame::ProcessMessage(hwnd, uMsg, wParam, lParam));
}


/*  O N  N O T I F Y  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyList

-------------------------------------------------------------------------*/
LRESULT CFindSomeone::OnNotifyList(LPARAM lParam)
{
	LPNMHDR pnmh = (LPNMHDR) lParam;
	HWND hwnd = GetWindow();

	switch (pnmh->code)
		{
	case NM_DBLCLK:
	{
		OnCommand(hwnd, IDOK, NULL, 0);
		break;
	}

	case LVN_KEYDOWN:
	{
		LPNMLVKEYDOWN pkdn = (LPNMLVKEYDOWN) lParam;
		switch (pkdn->wVKey)
			{
		case VK_F5:
			OnCommand(hwnd, IDM_DLGCALL_REFRESH, NULL, 0);
			break;
		case VK_DELETE:
			OnCommand(hwnd, IDM_DLGCALL_DELETE, NULL, 0);
			break;
		default:
			break;
			}
		break;
	}

	case LVN_ITEMCHANGED:
	{
		CConfRoom *pConfRoom = GetConfRoom();
        if (m_fInEdit || NULL == pConfRoom || !pConfRoom->IsNewCallAllowed())
			break;

		int iSel = m_pAlv->GetSelection();
		BOOL fEnable = (-1 != iSel);
		EnableWindow(GetDlgItem(hwnd, IDOK), fEnable);
		break;
	}

	case LVN_GETDISPINFO:
	{
		LV_DISPINFO *lpdi = (LV_DISPINFO *)lParam;
		if (lpdi->item.mask & LVIF_TEXT)
		{
			switch( lpdi->item.iSubItem )
			{
				case 0:
					m_pAlv->OnListGetColumn1Data(lpdi->item.iItem, lpdi->item.cchTextMax, lpdi->item.pszText);
					break;

				case 1:
					m_pAlv->OnListGetColumn2Data(lpdi->item.iItem, lpdi->item.cchTextMax, lpdi->item.pszText);
					break;
				
				case 2:
					m_pAlv->OnListGetColumn3Data(lpdi->item.iItem, lpdi->item.cchTextMax, lpdi->item.pszText);
					break;
			}
		}

        if( lpdi->item.mask & LVIF_IMAGE )
        {
            lpdi->item.iImage = m_pAlv->OnListGetImageForItem( lpdi->item.iItem );
        }

		break;
	}

	case LVN_ODCACHEHINT:
	{
		LPNMLVCACHEHINT lpCacheHint = reinterpret_cast< LPNMLVCACHEHINT > (lParam);
		m_pAlv->OnListCacheHint(lpCacheHint->iFrom, lpCacheHint->iTo);
		break;
	}

	case LVN_ODFINDITEM:
	{
		LPNMLVFINDITEM lpFindItem = reinterpret_cast< LPNMLVFINDITEM > (lParam);
		if (0 == (lpFindItem->lvfi.flags & (LVFI_PARTIAL | LVFI_STRING)))
			break;

		return m_pAlv->OnListFindItem(lpFindItem->lvfi.psz);
	}

	case LVN_COLUMNCLICK:
	{
		if( m_pAlv == m_pUls )
		{
			// The user clicked on one of the column headings - sort by
			// this column.
			TRACE_OUT(("CFindSomeone::OnNotify called (NM_COLUMNCLICK)"));
			NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
			ASSERT(pNm);

			if (pNm->iSubItem == m_iSortColumn)
			{
				m_fSortAscending = !m_fSortAscending;
			}
			else if( pNm->iSubItem != -1 )
			{
				m_fSortAscending = TRUE;
			}

			if( pNm->iSubItem != -1 )
			{
				m_iSortColumn = pNm->iSubItem;
			}
			else
			{
				pNm->iSubItem = m_iSortColumn;
			}

			SendMessage( pNm->hdr.hwndFrom, WM_SETREDRAW, FALSE, 0 );

			ListView_SortItems( pNm->hdr.hwndFrom,
								CompareWrapper,
								(LPARAM) this );

			SendMessage( pNm->hdr.hwndFrom, WM_SETREDRAW, TRUE, 0 );
		}
		break;
	}

	case NM_CUSTOMDRAW:
	{
		return DoCustomDraw((LPNMLVCUSTOMDRAW)lParam);
	}

	default:
		break;
	}
	
	return 0;
}


/*  D O  C U S T O M  D R A W  */
/*-------------------------------------------------------------------------
    %%Function: DoCustomDraw

-------------------------------------------------------------------------*/
LRESULT CFindSomeone::DoCustomDraw(LPNMLVCUSTOMDRAW lplvcd)
{
	switch (lplvcd->nmcd.dwDrawStage)
		{
	case CDDS_PREPAINT:
	{
		return CDRF_NOTIFYITEMDRAW;
	}

	case CDDS_ITEMPREPAINT:
	{
		if (!m_pAlv->IsItemBold(lplvcd->nmcd.dwItemSpec))
			break;

		//get the existing font
		HFONT hFont = (HFONT)SendMessage(m_hwndOwnerDataList, WM_GETFONT, 0, 0);
		if (NULL == hFont)
			break;

		LOGFONT  lf;
		if (0 == GetObject(hFont, sizeof(lf), &lf))
			break;
		lf.lfWeight = FW_BOLD;
		hFont = CreateFontIndirect(&lf);
		if (NULL == hFont)
			break;

		SelectObject(lplvcd->nmcd.hdc, hFont);
		return  CDRF_NEWFONT | CDRF_NOTIFYPOSTPAINT;
	}

	case CDDS_ITEMPOSTPAINT:
	{
		HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
		if (NULL != hFont)
		{
			//clean up stuff here
			hFont = (HFONT)SelectObject(lplvcd->nmcd.hdc, hFont);
			DeleteFont(hFont);
		}
		break;
	}

	default:
		break;
	}

	return CDRF_DODEFAULT;
}


/*  U P D A T E  I L S  S E R V E R  */
/*-------------------------------------------------------------------------
    %%Function: UpdateIlsServer

    Update the current ILS server based on the text in the combo's edit control.
-------------------------------------------------------------------------*/
VOID CFindSomeone::UpdateIlsServer(void)
{
	TCHAR szServer[CCHMAXSZ_SERVER];
	if (0 == GetWindowText(m_hwndComboEdit, szServer, CCHMAX(szServer)))
		return;

	const TCHAR * const	displayName	= CDirectoryManager::get_displayName( szServer );
	const TCHAR * const	dnsName		= CDirectoryManager::get_dnsName( szServer );

	SetWindowText( m_hwndComboEdit, displayName );

	int iSel = ::SendMessage(m_hwndCombo, CB_FINDSTRINGEXACT, (WPARAM) -1, (LPARAM) displayName );
	if ((CB_ERR == iSel) && (NULL != m_pUls) && m_pUls->FAvailable())
	{
        RegEntry    rePol(POLICIES_KEY, HKEY_CURRENT_USER);

        //
		// Assume this is an ILS server - and add it to the list ONLY if
        // not prevented by policy.
        //
        if (!rePol.GetNumber(REGVAL_POL_NO_ADDING_NEW_ULS, DEFAULT_POL_NO_ADDING_NEW_ULS))
        {
    		if (NULL != m_pMruServer)
	    	{
		    	if( m_pMruServer->AddNewEntry( dnsName ) )
			    {
				    iSel = AddAlvSz( m_pUls, displayName, m_iIlsFirst );
    			}
	    	}
        }
	}

	if (CB_ERR == iSel)
		return;

	if (NULL != m_pAlv)
	{
		m_pAlv->ClearItems();
	}

	if (iSel >= m_iIlsFirst)
	{
		if( NULL != m_pUls )
		{
			m_pAlv = m_pUls;

			if( !CDirectoryManager::isWebDirectory( dnsName ) )
			{
				m_pUls->SetServer( dnsName );
					// We have to send this twice so that we don't autocomplete..
				SendMessage(m_hwndCombo, CB_SETCURSEL, (WPARAM) iSel, 0);
				SendMessage(m_hwndCombo, CB_SETCURSEL, (WPARAM) iSel, 0);
			}
		}
	}

	ShowList(iSel);
}


LRESULT CFindSomeone::OnNotifyCombo(LPARAM lParam)
{
	NMCOMBOBOXEX * pNmcbe = (NMCOMBOBOXEX*) lParam;

	switch(pNmcbe->hdr.code)
		{
	case CBEN_ENDEDIT:
	{
		PNMCBEENDEDIT pnmcbee = (PNMCBEENDEDIT) lParam;
		if (_T('\0') != pnmcbee->szText[0])
		{
			EndComboEdit(pnmcbee->iWhy);
		}
		break;
	}

	// NOTE: the IE 3.0 comctl32.dll sends us the wrong notification
	// when running under NT.  We handle it here, but if we are running
	// on NT using the IE 4.0 comctl32.dll, it will be handled above.
	case CBEN_ENDEDITW:
	{
		PNMCBEENDEDITW pnmcbee = (PNMCBEENDEDITW) lParam;
		if (L'\0' != pnmcbee->szText[0])
		{
			EndComboEdit(pnmcbee->iWhy);
		}
		break;
	}


	default:
		break;
		}

	return 0;
}

VOID CFindSomeone::EndComboEdit(int iWhy)
{
	switch (iWhy)
	{
	case CBENF_RETURN:
	{
		if (SendMessage(m_hwndCombo, CB_GETDROPPEDSTATE, 0, 0))
		{
			// remove the dropdown
			SendMessage(m_hwndCombo, CB_SHOWDROPDOWN, 0, 0);
		}

		UpdateIlsServer();
		break;
	}

	case CBENF_KILLFOCUS:
	{
		// remove the dropdown
		SendMessage(m_hwndCombo, CB_SHOWDROPDOWN, 0, 0);
		break;
	}

	case CBENF_DROPDOWN:
	default:
		break;
	}
}

static void DoAxMethod(HWND hwnd, LPWSTR szMethod)
{
	IUnknown *pUnk;
	if (SUCCEEDED(AtlAxGetControl(hwnd, &pUnk)))
	{
		CComPtr<IDispatch> spDispatch = com_cast<IDispatch>(pUnk);
		if (spDispatch)
		{
			DISPID dispid;
			if (SUCCEEDED(spDispatch->GetIDsOfNames(IID_NULL, &szMethod, 1,
							LOCALE_USER_DEFAULT, &dispid)))
			{
				DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

				HRESULT hr = spDispatch->Invoke(
						dispid,
						IID_NULL,
						LOCALE_USER_DEFAULT,
						DISPATCH_METHOD,
						&dispparamsNoArgs, NULL, NULL, NULL);
			}
		}

		pUnk->Release();
	}
}

static void NewHtmlWindow(HWND hwnd)
{
	IUnknown *pUnk;
	if (SUCCEEDED(AtlAxGetControl(hwnd, &pUnk)))
	{
		CComPtr<IWebBrowser> spWeb = com_cast<IWebBrowser>(pUnk);
		if (spWeb)
		{
			BSTR bstrLocation;

			if (SUCCEEDED(spWeb->get_LocationURL(&bstrLocation)))
			{
				LPTSTR  szName;
				if (SUCCEEDED(BSTR_to_LPTSTR (&szName, bstrLocation)))
				{
					LaunchRedirWebPage(szName);
					// Free resources
					//
					delete (szName);
				}
				SysFreeString(bstrLocation);
			}
		}

		pUnk->Release();
	}
}

/*  O N  C O M M A N D  */
/*-------------------------------------------------------------------------
    %%Function: OnCommand

-------------------------------------------------------------------------*/
void CFindSomeone::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	ASSERT(NULL != hwnd);

	switch (id)
	{
	case ID_TB_HELP:
		FORWARD_WM_SYSCOMMAND(hwnd, SC_CONTEXTHELP, 0, 0, SendMessage);
		break;

	case IDM_DLGCALL_ENTER:
		if (IsWindowActive(m_hwndCombo))
		{
			UpdateIlsServer();
		}
		else
		{
			HWND hwndFocus = GetFocus();
			TCHAR szClass[20];

			GetClassName(hwndFocus, szClass, ARRAY_ELEMENTS(szClass));
			if (0 == lstrcmpi(szClass, TEXT("button"))
				&& BS_PUSHBUTTON == (GetWindowStyle(hwndFocus)&(BS_PUSHBUTTON|BS_CHECKBOX|BS_RADIOBUTTON)))
			{
				// Push the button
				OnCommand(hwnd, GetDlgCtrlID(hwndFocus), hwndFocus, BN_CLICKED);
			}
			else if (IsWindowEnabled(GetDlgItem(hwnd, IDOK)))
			{
				// Try to complete the call
				OnCommand(hwnd, IDOK, NULL, 0);
			}
			else
			{
				MessageBeep(MB_ICONHAND);
			}
		}
		break;

	case IDC_DLGCALL_COMBO:
	{
		switch (codeNotify)
			{
		case CBN_EDITCHANGE:
		{
			OnEditChangeDirectory();
			break;
		}
		case CBN_KILLFOCUS:
		{
			int iSel = ::SendMessage(m_hwndCombo, CB_GETCURSEL, 0, 0);
			if (CB_ERR == iSel)
			{
				UpdateIlsServer();
			}
			else if (iSel != m_iSel)
			{
				ShowList(iSel);
			}
			break;
		}
		case CBN_SELENDOK:
		{
			int iSel = ::SendMessage(m_hwndCombo, CB_GETCURSEL, 0, 0);
				// We have to send this so that we don't autocomplete..
			SendMessage(m_hwndCombo, CB_SETCURSEL, (WPARAM) iSel, 0);
			ShowList(iSel);
			break;
		}
		default:
			break;
			} /* switch (HIWORD(wParam)) */
		break;
	}

	case IDM_DLGCALL_CALL:
	case IDOK:
	{
		CConfRoom *pConfRoom = GetConfRoom();
        if (NULL == pConfRoom || !pConfRoom->IsNewCallAllowed())
        {
            WARNING_OUT(("Meeting settings prevent outgoing calls"));
            break;
        }

		if (SUCCEEDED(HrGetSelection()))
		{
			onCall();
		}
		else
		{
			if( !hasValidUserInfo( m_pRai ) )
			{
				DisplayMsgErr( hwnd, IDS_NO_CALL_LOG_INFO );
			}
			else
			{
				TCHAR szName[CCHMAXSZ_NAME];
				GetEditText(szName, CCHMAX(szName));
				DisplayMsgErr(hwnd, IDS_ERR_CALLTO, szName);
			}
		}
		break;
	}

	case IDCANCEL:
	{
		PostMessage( hwnd, WM_CLOSE, 0, 0 );
		break;
	}

	case IDE_DLGCALL_NAME:
	{
		switch (codeNotify)
		{
		case EN_CHANGE:
		{
			TCHAR sz[CCHMAXSZ];
			sz[0] = _T('\0');
			GetWindowText(m_hwndEdit, sz, CCHMAX(sz));

			int iSel = CFindSomeone::FindSzBySortedColumn(sz);

			if (-1 != iSel)
			{
				HWND hwndCurr = GetHwndList();

				// Select the item found
				ListView_SetItemState(hwndCurr, iSel, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

				int iTop = ListView_GetTopIndex(hwndCurr);
				int cDiff = (iSel - iTop);
				if ((cDiff < 0) || (cDiff > m_cVisible))
				{
					// Scroll the item into view
					RECT rc;
					ListView_GetItemRect(hwndCurr, iSel, &rc, LVIR_BOUNDS);
					ListView_Scroll(hwndCurr, 0, cDiff * (rc.bottom - rc.top));
				}
			}

			break;
		}
		default:
			break;
		} /* switch (HIWORD(wParam)) */

		break;
	}

	case IDM_DLGCALL_NEWWINDOW:
		NewHtmlWindow(m_webView);
		break;

	case IDM_DLGCALL_REFRESH:
		if (IsWindowVisible(m_webView))
		{
			DoAxMethod(m_webView, L"Refresh");
			break;
		}

		// Fall through
	case IDM_DLGCALL_PROPERTIES:
	case IDM_DLGCALL_DELETE:
	case IDM_DLGCALL_SPEEDDIAL:
	case IDM_DLGCALL_WAB:
	case IDM_DLGCALL_STOP:
	{
		if (NULL != m_pAlv)
		{
			m_pAlv->OnCommand(GET_WM_COMMAND_MPS(id, hwndCtl, codeNotify));
		}
		break;
	}

	case IDM_DLGCALL_DELETE_ILS:
		OnDeleteIlsServer();
		break;
	default:
		break;
	}
}


int CFindSomeone::GetEditText(LPTSTR psz, int cchMax)
{
	ASSERT(NULL != m_hwndEdit);
	int cch = GetWindowText(m_hwndEdit, psz, cchMax);
	return TrimSz(psz);
}


HRESULT CFindSomeone::HrGetSelection(void)
{
	HRESULT	result	= E_FAIL;

	//	Check if we have a selection
	if( ListView_GetNextItem( GetHwndList(), -1, LVNI_ALL | LVNI_SELECTED ) != -1 )
	{
		m_pRai = m_pAlv->GetAddrInfo();
	
		if( hasValidUserInfo( m_pRai ) )
		{
			result = S_OK;
		}
	}

	return( result );

}	//	End of CFindSomeone::HrGetSelection.


/*  F I N D  S Z  */
/*-------------------------------------------------------------------------
    %%Function: FindSz

    First the item that matches at least the first part of the string
    from the current list.
-------------------------------------------------------------------------*/
int CFindSomeone::FindSz(LPCTSTR psz)
{
	LV_FINDINFO lvfi;
	ClearStruct(&lvfi);
	lvfi.flags = LVFI_PARTIAL;
	lvfi.psz = (LPTSTR) psz;

	return ListView_FindItem(GetHwndList(), -1, &lvfi);
}


//--------------------------------------------------------------------------//
//	CFindSomeone::FindSzBySortedColumn.										//
//--------------------------------------------------------------------------//
int CFindSomeone::FindSzBySortedColumn(LPCTSTR psz)
{
	ASSERT( psz != NULL );

	TCHAR	pszColumnText[ MAX_PATH ];
	HWND	hwndList		= GetHwndList();
	bool	bSorted			= hwndList == m_ilsListView;
	int		iSearchColumn	= bSorted ? m_iSortColumn : 0;
	int		iStart			= 0;
	int		iEnd			= ListView_GetItemCount( hwndList ) - 1;
	int		iMid			= iEnd / 2;
	int		iCompareLength	= lstrlen( psz );
	int		iResult			= -1;
	bool	bAscending		= (m_fSortAscending != FALSE);

	if( iEnd > 0 )
	{
		if( bSorted && ((iSearchColumn == COLUMN_INDEX_AUDIO) || (iSearchColumn == COLUMN_INDEX_VIDEO) ))
		{
			bSorted = false;

			//	The list is sorted by av capabilities.... perform a linear search on the first (unsorted) text column...
			int iColumnOrder[ MAX_DIR_COLUMNS ];

			if( ListView_GetColumnOrderArray( m_ilsListView, g_rgDLColumnInfo[ DLT_ULS ].nColumns, iColumnOrder ) )
			{
				if( (iColumnOrder[ 0 ] == COLUMN_INDEX_AUDIO) || (iColumnOrder[ 0 ] == COLUMN_INDEX_VIDEO) )
				{
					if( (iColumnOrder[ 1 ] == COLUMN_INDEX_AUDIO) || (iColumnOrder[ 1 ] == COLUMN_INDEX_VIDEO) )
					{
						iSearchColumn = 2;
					}
					else
					{
						iSearchColumn = 1;
					}
				}
				else
				{
					iSearchColumn = 0;
				}

				iSearchColumn = iColumnOrder[iSearchColumn];
			}
		}

		if (!bSorted)
		{
			// Do a linear search
			for( int nn = 0; nn <= iEnd; nn++ )
			{
				ListView_GetItemText( hwndList, nn, iSearchColumn, pszColumnText, CCHMAX( pszColumnText ) );

				if( iCompareLength < CCHMAX( pszColumnText ) - 1 )
				{
					pszColumnText[ iCompareLength ] = '\0';		//	Only compare iCompareLength characters...
				}

				if( StringCompare( psz, pszColumnText ) == 0 )
				{
					iResult = nn;
					break;
				}
			}
		}
		else
		{
			while( iStart <= iEnd )
			{
				pszColumnText[ 0 ] = '\0';

				ListView_GetItemText( hwndList, iMid, iSearchColumn, pszColumnText, CCHMAX( pszColumnText ) );

				if( iCompareLength < CCHMAX( pszColumnText ) - 1 )
				{
					pszColumnText[ iCompareLength ] = '\0';		//	Only compare iCompareLength characters...
				}

				int		iCompareResult	= StringCompare( psz, pszColumnText );
				bool	pszIsLess		= (iCompareResult <= 0);

				if( iCompareResult == 0 )
				{
					//	We've found a match but we will keep going because there may be more than one
					//	and we want to find the "first" one...
					iResult = iMid;
				}
				else
				{
					if( !bAscending )
					{
						pszIsLess = !pszIsLess;
					}
				}
					
				if( pszIsLess )
				{
					iEnd = iMid - 1;
				}
				else
				{
					iStart = iMid + 1;
				}

				iMid = iStart + ((iEnd - iStart) / 2);
			}
		}
	}

	return( iResult );

}	//	End of CFindSomeone::FindSzBySortedColumn.


VOID CFindSomeone::OnEditChangeDirectory(void)
{
	if (m_fInEdit)
		return;

	TCHAR szEdit[CCHMAXSZ_ADDRESS];
	TCHAR szBuff[CCHMAXSZ_ADDRESS];

	szEdit[0] = _T('\0');
	int cch = GetWindowText(m_hwndCombo, szEdit, CCHMAX(szEdit));
	CharUpperBuff(szEdit, CCHMAX(szEdit));

	if (0 == cch)
		return;

	// Check if anything changed
	PTCHAR pchSrc = m_szDirectory;
	PTCHAR pchDest = szEdit;
	while ((_T('\0') != *pchSrc) && (*pchSrc == *pchDest))
	{
		// REVIEW: not DBCS safe
		pchSrc++;
		pchDest++;
	}
	if (_T('\0') == *pchDest)
	{
		lstrcpy(m_szDirectory, szEdit);
		return; // quick exit - nothing to do
	}

	if (-1 == FindSzCombo(m_hwndCombo, szEdit, szBuff))
		return;

	m_fInEdit = TRUE;
	AutoCompleteCombo(m_hwndCombo, &szBuff[cch]);
	lstrcpyn(m_szDirectory, szBuff, cch+1);
	CharUpperBuff(m_szDirectory, CCHMAX(m_szDirectory));
	m_fInEdit = FALSE;
}



/*  I N I T  A L V  */
/*-------------------------------------------------------------------------
    %%Function: InitAlv

-------------------------------------------------------------------------*/
VOID CFindSomeone::InitAlv(void)
{
	int iSelDefault = LB_ERR;

	ASSERT( NULL == m_pAlv );



	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
	
	bool bGkEnabled = CALLING_MODE_GATEKEEPER == reConf.GetNumber(REGVAL_CALLING_MODE, CALLING_MODE_DIRECT );

#if USE_GAL
	// Add each of the view items to the list
	if ((NULL != m_pGAL) && m_pGAL->FAvailable())
	{
		AddAlv(m_pGAL);
		if( !m_pAlv )
		{
			m_pAlv = m_pGAL;
		}
	}
#endif // #if USE_GAL
	if((!bGkEnabled) && (NULL != m_pSpeedDial) && m_pSpeedDial->FAvailable())
	{
		AddAlv(m_pSpeedDial);
		if( !m_pAlv )
		{
			m_pAlv = m_pSpeedDial;
		}

	}

	if ( (!bGkEnabled) && ( NULL != m_pHistory) && m_pHistory->FAvailable())
	{
		AddAlv(m_pHistory);
		if( !m_pAlv )
		{
			m_pAlv = m_pHistory;
		}

	}
	if ((NULL != m_pWab) && m_pWab->FAvailable())
	{
		AddAlv(m_pWab);
		if( !m_pAlv )
		{
			m_pAlv = m_pWab;
		}
	}

	m_iIlsFirst = ::SendMessage(m_hwndCombo, CB_GETCOUNT, 0, 0);

	// Add the list of ILS servers
	if (bGkEnabled)
	{
		// If there is a customized Web View, we will show it in GK mode as
		// well as in ILS mode
		if ((NULL != m_pUls) && ConfPolicies::GetWebDirInfo())
		{
			AddAlvSz( m_pUls, CDirectoryManager::get_displayName( CDirectoryManager::get_webDirectoryIls() ));
		}
	}
	else
	{
		if((NULL != m_pUls) && m_pUls->FAvailable() && (NULL != m_pMruServer) && !_IsDirectoryServicePolicyDisabled())
		{
			m_pAlv = m_pUls;

			for( int i = m_pMruServer->GetNumEntries() - 1; i >= 0; i-- )
			{
				AddAlvSz( m_pUls, CDirectoryManager::get_displayName( m_pMruServer->GetNameEntry( i ) ) );
			}
		}
	}

	iSelDefault = CB_ERR;

	if( m_pAlv )
	{
		// We know that there is at lest one directory server in the combobox

		// Get the user's last selection
		RegEntry reMru(DLGCALL_MRU_KEY, HKEY_CURRENT_USER);
		LPTSTR psz = reMru.GetString(REGVAL_DLGCALL_DEFDIR);

		if (!FEmptySz(psz))
		{
			TRACE_OUT(("Last directory was [%s]",psz));
			iSelDefault = ::SendMessage(m_hwndCombo, CB_FINDSTRINGEXACT, (WPARAM) -1, (LPARAM) psz);
		}
		else
		{
			// This may be the first time, and there is no last use one in the registry
			TCHAR szDirectoryName[CCHMAXSZ];

			if( m_pAlv )
			{
				if( m_pAlv != m_pUls )
				{
					m_pAlv->GetName(szDirectoryName, CCHMAX(szDirectoryName));

					iSelDefault = ::SendMessage(m_hwndCombo, CB_FINDSTRINGEXACT, (WPARAM) -1, (LPARAM) szDirectoryName);
				}
				else if( m_pMruServer->GetNumEntries() > 0 )
				{
					iSelDefault = m_iIlsFirst;
				}
			}
		}

		iSelDefault = (CB_ERR != iSelDefault) ? iSelDefault : 0;

		ShowList(iSelDefault);

			// We have to send this twice so that we don't autocomplete..
		SendMessage(m_hwndCombo, CB_SETCURSEL, (WPARAM) iSelDefault, 0);
		SendMessage(m_hwndCombo, CB_SETCURSEL, (WPARAM) iSelDefault, 0);
	}
	else
	{
		// The user has no directory services set up
		DisplayMsgErr( NULL, IDS_NO_DIRECTORY_SERVICES_OR_ADDRESS_BOOKS );
	}
}

bool CFindSomeone::_IsDirectoryServicePolicyDisabled()
{
    RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
    return rePol.GetNumber( REGVAL_POL_NO_DIRECTORY_SERVICES, DEFAULT_POL_NO_DIRECTORY_SERVICES ) ? true : false;
}

int CFindSomeone::AddAlv(CALV * pAlv)
{
	TCHAR sz[CCHMAXSZ];

	pAlv->GetName(sz, CCHMAX(sz));
	return AddAlvSz(pAlv, sz);
}

int CFindSomeone::AddAlvSz(CALV * pAlv, LPCTSTR psz, int cbIndex)
{
	ASSERT(NULL != pAlv);
	ASSERT(NULL != m_hwndCombo);

	COMBOBOXEXITEM cbi;
	ClearStruct(&cbi);

	cbi.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
	cbi.iItem = cbIndex;
	cbi.iImage = pAlv->GetIconId(psz);
	cbi.iSelectedImage = cbi.iImage;
	cbi.pszText = (LPTSTR) psz;
	cbi.cchTextMax = lstrlen(cbi.pszText);

	int iIndex = ::SendMessage(m_hwndCombo, CBEM_INSERTITEM, 0, (LPARAM) &cbi);
	if (CB_ERR != iIndex)
	{
		::SendMessage(m_hwndCombo, CB_SETITEMDATA, iIndex, (LPARAM) pAlv);
	}

	return iIndex;
}



/*  S H O W  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: ShowList

-------------------------------------------------------------------------*/
VOID CFindSomeone::ShowList(int iSel)
{
	HWND hwnd = GetWindow();

	if (CB_ERR == iSel)
		return;
	m_iSel = iSel;

	BOOL bPrevListWasOwnerData = m_pAlv->FOwnerData();
	int nColsPrevListView = _GetCurListViewNumColumns();
	BOOL bPrevChangedNumCols = FALSE;

	// Clear any existing data
	if (NULL != m_pAlv)
	{
		m_pAlv->ClearItems();
		if( nColsPrevListView != _GetCurListViewNumColumns() )
		{	
			bPrevChangedNumCols = TRUE;
		}
	}

	// Get the new selection
	m_pAlv = (CALV *) ::SendMessage(m_hwndCombo, CB_GETITEMDATA, iSel, 0);
	ASSERT(m_pAlv != NULL);
	ASSERT(m_pAlv != (CALV *) -1);
	
	BOOL bCurListIsOwnerData = m_pAlv->FOwnerData();

	bool webDir = false;

    TCHAR szServer[CCHMAXSZ_SERVER];
	szServer[0] = 0;

	if (m_pAlv == m_pUls)
	{
        COMBOBOXEXITEM  cbi;

        ClearStruct(&cbi);
        cbi.mask = CBEIF_TEXT;
        cbi.iItem = iSel;
        cbi.pszText = szServer;
        cbi.cchTextMax = ARRAY_ELEMENTS(szServer);

		::SendMessage(m_hwndCombo, CBEM_GETITEM, iSel, (LPARAM)&cbi);

		TRACE_OUT(("CBEM_GETITEM got %s for text", szServer));

		webDir	= CDirectoryManager::isWebDirectory( szServer );
	}

	// Show or hide all windows between HELP and CANCEL
	HWND start = GetDlgItem(hwnd, ID_TB_HELP);
	HWND end   = GetDlgItem(hwnd, IDCANCEL);

	if (NULL != start)
	{
		UINT uShow = webDir ? SW_HIDE : SW_SHOW;
		for (HWND child=::GetWindow(start, GW_HWNDNEXT);
			child!=NULL && child!=end; child=::GetWindow(child, GW_HWNDNEXT))
		{
			ShowWindow(child, uShow);
		}

		ShowWindow(m_webView, SW_HIDE+SW_SHOW-uShow);
	}
	EnableWindow(GetDlgItem(hwnd, IDM_DLGCALL_NEWWINDOW), webDir);
	EnableWindow( GetDlgItem( hwnd, IDM_DLGCALL_DELETE_ILS ), FALSE );

	if (m_pAlv == m_pUls)
	{
		::ShowWindow( m_hwndOwnerDataList,	SW_HIDE );
		::ShowWindow( m_hwndList,			SW_HIDE );

		if( webDir )
		{
			::SetFocus( m_webView );
		}
		else
		{
	        m_pUls->SetServer( CDirectoryManager::get_dnsName( szServer ) );

			m_pAlv->ShowItems(GetHwndList());

			::SetFocus( m_ilsListView );

			RegEntry    rePol( POLICIES_KEY, HKEY_CURRENT_USER );

		    if (!rePol.GetNumber(REGVAL_POL_NO_ADDING_NEW_ULS, DEFAULT_POL_NO_ADDING_NEW_ULS))
			{
				EnableWindow( GetDlgItem( hwnd, IDM_DLGCALL_DELETE_ILS ), TRUE );
			}
		}
	}
	else
	{
		if( m_ilsListView != NULL )
		{
			::ShowWindow( m_ilsListView, SW_HIDE );
			::ShowWindow( m_webView, SW_HIDE );
			m_pUls->CacheServerData();
		}

		if (m_pAlv->FOwnerData())
		{
			::ShowWindow(m_hwndList, SW_HIDE);
		}
		else
		{
			::ShowWindow(m_hwndOwnerDataList, SW_HIDE);
		}

		m_pAlv->ShowItems(GetHwndList());
		::SetFocus( GetHwndList() );
	}

	if( bPrevChangedNumCols || ( bCurListIsOwnerData != bPrevListWasOwnerData ) || ( nColsPrevListView != _GetCurListViewNumColumns() ) )
	{
		Layout();
	}

}


int CFindSomeone::_GetCurListViewNumColumns()
{

	int nListViewColumns = DEFAULT_NUM_LISTVIEW_COLUMNS;

	HWND hListViewHeader = NULL;
	HWND hWndList = GetHwndList();
	if( hWndList )
	{
		hListViewHeader = ListView_GetHeader( hWndList );
		if( hListViewHeader )
		{
			nListViewColumns = Header_GetItemCount( hListViewHeader );
		}
	}

	return nListViewColumns;
}


/*  D L G  C A L L  S E T  H E A D E R  */
/*-------------------------------------------------------------------------
    %%Function: DlgCallSetHeader

    Set the listbox header text for the "address" / "email" / "status" field.
-------------------------------------------------------------------------*/
VOID DlgCallSetHeader(HWND hwndList, int ids)
{
	HWND hwnd = ListView_GetHeader(hwndList);
	if (NULL == hwnd)
		return;

	TCHAR sz[CCHMAXSZ];
	if (!FLoadString(ids, sz, CCHMAX(sz)))
		return;

	HDITEM hdItem;
	ClearStruct(&hdItem);
	hdItem.mask = HDI_TEXT; // | HDI_IMAGE; hdItem.iImage = II_ASCENDING;
	hdItem.pszText = sz;
	hdItem.cchTextMax = lstrlen(hdItem.pszText);
	Header_SetItem(hwnd, IDI_DLGCALL_ADDRESS, &hdItem);
}


/*  D L G  C A L L  A D D  I T E M  */
/*-------------------------------------------------------------------------
    %%Function: DlgCallAddItem

    Add the name and address to the list, returning the position.
-------------------------------------------------------------------------*/
int DlgCallAddItem(HWND hwndList, LPCTSTR pszName, LPCTSTR pszAddress, int iImage, LPARAM lParam, int iItem, LPCTSTR pszComment)
{
	LV_ITEM lvItem;
	ClearStruct(&lvItem);
	lvItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
	lvItem.iItem = iItem;
	lvItem.lParam = lParam;
	lvItem.iImage = iImage;
	lvItem.pszText = (LPTSTR) pszName;
	lvItem.cchTextMax = lstrlen(lvItem.pszText);
	int iPos = ListView_InsertItem(hwndList, &lvItem);
	if (-1 != iPos)
	{
		ListView_SetItemText(hwndList, iPos, IDI_DLGCALL_ADDRESS, (LPTSTR) pszAddress);

		if( pszComment )
		{
			ListView_SetItemText(hwndList, iPos, IDI_DLGCALL_COMMENT, (LPTSTR) pszComment);
		}
	}

	return iPos;
}




/*  C A L L  T O  S Z  */
/*-------------------------------------------------------------------------
    %%Function: CallToSz

    Call an address using "CallTo:"
-------------------------------------------------------------------------*/
HRESULT CallToSz(LPCTSTR pcszAddress)
{
#ifdef DEBUG
	RegEntry re(DEBUG_KEY, HKEY_LOCAL_MACHINE);
	if (0 != re.GetNumber(REGVAL_DBG_FAKE_CALLTO, DEFAULT_DBG_FAKE_CALLTO))
	{
		MessageBox(NULL, pcszAddress, "Called", MB_OK);
		return S_OK;
	}
#endif /* DEBUG */

	if (FEmptySz(pcszAddress))
		return E_INVALIDARG;

	TCHAR sz[MAX_PATH];
	lstrcpy(sz, g_cszCallTo);
	int cch = lstrlen(sz);
	if (CCHMAX(sz) <= (cch + lstrlen(pcszAddress)))
		return E_INVALIDARG; // the address won't fit
	lstrcpy(&sz[cch], pcszAddress);

	HINSTANCE hInst = ShellExecute(NULL, NULL, sz, NULL, NULL, SW_SHOWNORMAL);

	return ((INT_PTR)hInst > 32) ? S_OK : E_FAIL;
}


//--------------------------------------------------------------------------//
//	GetMruListServer.														//
//--------------------------------------------------------------------------//
CMRUList *
GetMruListServer(void)
{
	CMRUList *	pMruList	= new CMRUList;

	if( pMruList != NULL )
	{
		pMruList->Load( DIR_MRU_KEY );

		if( CDirectoryManager::isWebDirectoryEnabled() )
		{
			//	Make sure the web directory is in the list...
			pMruList->AppendEntry( CDirectoryManager::get_webDirectoryIls() );
		}

		const TCHAR * const	defaultServer	= CDirectoryManager::get_defaultServer();

		if( lstrlen( defaultServer ) > 0 )
		{
			//	Make sure the default server name is in the list and at the top...
			pMruList->AddNewEntry( defaultServer );
		}
	}

	return( pMruList );

}	//	End of GetMruListServer.


// The only purpose for this function is to avoid scrollbar tracking of the data
/* static */
LRESULT CALLBACK CFindSomeone::OwnerDataListWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	CFindSomeone* pThis = reinterpret_cast< CFindSomeone* >( GetWindowLongPtr( hwnd, GWLP_USERDATA ) );
	WNDPROC lpPrevWndFunc = pThis->m_WndOwnerDataListOldWndProc;

	bool bUserDroppedScrollSlider = false;

	if (WM_VSCROLL == uMsg)
	{
		switch (LOWORD(wParam))
		{
		case SB_THUMBTRACK:
			// don't track
			return FALSE;

		case SB_THUMBPOSITION:
			bUserDroppedScrollSlider = true;
			// fake a final SB_THUMBTRACK notification
			CallWindowProc(lpPrevWndFunc, hwnd, uMsg, MAKEWPARAM(SB_THUMBTRACK, HIWORD(wParam)), lParam);
			break;

		default:
			break;
		}
	}

	LRESULT lRet = CallWindowProc(lpPrevWndFunc, hwnd, uMsg, wParam, lParam);

	if( bUserDroppedScrollSlider )
	{
		ListView_SetItemState(hwnd, GetScrollPos( hwnd, SB_VERT ), LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
	}

	return lRet;
}


//--------------------------------------------------------------------------//
//--------------------------------------------------------------------------//
//	copied from 2.11 dirlist.cpp.											//
//--------------------------------------------------------------------------//
//--------------------------------------------------------------------------//
//--------------------------------------------------------------------------//
//	CFindSomeone::InitColumns.												//
//--------------------------------------------------------------------------//
BOOL CFindSomeone::InitColumns(void)
{
	BOOL bRet = FALSE;
	
	if (NULL != m_ilsListView)
	{
		// Remove all columns:
		// NOTE: we could optimize by removing only extras and changing the rest
		while( ListView_DeleteColumn( m_ilsListView, 0 ) ){};

		// Now initialize the columns we will need
		// Initialize the LV_COLUMN structure
		// the mask specifies that the .fmt, .ex, width, and .subitem members
		// of the structure are valid,
		LV_COLUMN lvC;			// List View Column structure
		TCHAR szText[256];		// place to store some text

		lvC.pszText	= szText;
		lvC.fmt		= LVCFMT_LEFT;  // left align the column

		// Add the columns.
	    for (int index = 0; index < g_rgDLColumnInfo[DLT_ULS].nColumns; index++)
		{
			HD_ITEM	hdi;

			switch( index )
			{
				case COLUMN_INDEX_AUDIO:
					hdi.iImage	= II_AUDIO_COLUMN_HEADER;
					lvC.mask	= LVCF_SUBITEM;
					break;
				case COLUMN_INDEX_VIDEO:
					hdi.iImage	= II_VIDEO_COLUMN_HEADER;
					lvC.mask	= LVCF_SUBITEM;
					break;
				default:
					hdi.iImage	= -1;
					lvC.mask	= LVCF_TEXT | LVCF_FMT | LVCF_SUBITEM;

					LoadString( ::GetInstanceHandle(),
								ciColumnInfo[ index ].iColumnLabelIds,
								szText,
								CCHMAX(szText));
					break;
			}

			lvC.iSubItem = index;

			if( ListView_InsertColumn( m_ilsListView, index, &lvC ) == -1 )
			{
				WARNING_OUT(("Could not insert column %d in list view", index));
			}
			else if( hdi.iImage != -1 )
			{
				hdi.mask	= HDI_IMAGE | HDI_FORMAT;
				hdi.fmt		= HDF_IMAGE;
				
				Header_SetItem( ListView_GetHeader( m_ilsListView ), index, &hdi );
			}
		}

		Header_SetImageList( ListView_GetHeader( m_ilsListView ), m_himlIcon );
		bRet = TRUE;
	}
	// ISSUE: do we want to persist this data?
	m_fSortAscending	= TRUE;
	m_iSortColumn		= COLUMN_INDEX_LAST_NAME;

	return bRet;
}


//--------------------------------------------------------------------------//
//	CFindSomeone::LoadColumnInfo.											//
//--------------------------------------------------------------------------//
BOOL
CFindSomeone::LoadColumnInfo(void)
{
	RegEntry re(UI_KEY, HKEY_CURRENT_USER);

    // load column info from registry:
	LPLONG plColumns = NULL;
	DWORD dwLength = re.GetBinary(	g_rgDLColumnInfo[DLT_ULS].pszRVWidths,
									(LPVOID*) &plColumns);

	if (dwLength == (sizeof(LONG) * g_rgDLColumnInfo[DLT_ULS].nColumns))
	{
		// get width of each column
		for (int i = 0; i < g_rgDLColumnInfo[DLT_ULS].nColumns; i++)
		{
			m_alColumns[i] = plColumns[i];
			ListView_SetColumnWidth(m_ilsListView, i, m_alColumns[i]);
		}
	}
	else
	{
		int iMinColumnPixels[ MAX_DIR_COLUMNS ];

		int	iPixelsPerChar	= GetPixelsPerChar( m_ilsListView );
		int	ii;

		//	Loop through all the columns setting their minimum widths...
		for( ii = 0; ii < g_rgDLColumnInfo[ DLT_ULS ].nColumns; ii++ )
		{
			if( (ii == COLUMN_INDEX_AUDIO) || (ii == COLUMN_INDEX_VIDEO) )
			{
				//	We use a 16x16 icon, plus add 7 pixels for padding.
				//	There's also padding built into the icons to make them look more centered....
				//	The column header icons are aligned left and the column icons are aligned right...
				iMinColumnPixels[ ii ] = 23;
			}
			else
			{
				iMinColumnPixels[ ii ] = ciColumnInfo[ ii ].iMinColumnChars * iPixelsPerChar;
			}
		}

		//	Loop through all but the last column setting each columns to it's minimum width...
		for( ii = 0; ii < g_rgDLColumnInfo[ DLT_ULS ].nColumns - 1; ii++ )
		{
			ListView_SetColumnWidth( m_ilsListView, ii, iMinColumnPixels[ ii ] );
			m_alColumns[ ii ] = ListView_GetColumnWidth( m_ilsListView, ii );
		}

		//	The last column gets the rest...
		int	iLastColoumnIndex = g_rgDLColumnInfo[ DLT_ULS ].nColumns - 1;

		ListView_SetColumnWidth( m_ilsListView, iLastColoumnIndex, LVSCW_AUTOSIZE_USEHEADER );
		m_alColumns[ iLastColoumnIndex ] = ListView_GetColumnWidth( m_ilsListView, iLastColoumnIndex );

		if( m_alColumns[ iLastColoumnIndex ] < iMinColumnPixels[ iLastColoumnIndex ] )
		{
			ListView_SetColumnWidth( m_ilsListView, iLastColoumnIndex, iMinColumnPixels[ iLastColoumnIndex ] );
			m_alColumns[ iLastColoumnIndex ] = ListView_GetColumnWidth( m_ilsListView, iLastColoumnIndex );
		}
	}

	// set column order
	LPLONG plColumnOrder = NULL;
	dwLength = re.GetBinary(	g_rgDLColumnInfo[DLT_ULS].pszRVOrder,
								(LPVOID*) &plColumnOrder);
	if (dwLength == (sizeof(LONG) * g_rgDLColumnInfo[DLT_ULS].nColumns))
	{
		ListView_SetColumnOrderArray(	m_ilsListView,
										g_rgDLColumnInfo[DLT_ULS].nColumns,
										plColumnOrder);

		// load the sort column and direction
		m_iSortColumn = re.GetNumber(g_rgDLColumnInfo[DLT_ULS].pszRVSortColumn, COLUMN_INDEX_LAST_NAME );
		ASSERT(m_iSortColumn < g_rgDLColumnInfo[DLT_ULS].nColumns);
		m_fSortAscending = re.GetNumber(g_rgDLColumnInfo[DLT_ULS].pszRVSortAscending, TRUE);
	}
	else
	{
		const static int	iDefaultColumnOrder[] = { COLUMN_INDEX_AUDIO, COLUMN_INDEX_VIDEO, COLUMN_INDEX_LAST_NAME, COLUMN_INDEX_FIRST_NAME, COLUMN_INDEX_ADDRESS, COLUMN_INDEX_LOCATION, COLUMN_INDEX_COMMENTS };

		ListView_SetColumnOrderArray( m_ilsListView, ARRAY_ELEMENTS( iDefaultColumnOrder ), iDefaultColumnOrder );
	}

	return TRUE;
}


//--------------------------------------------------------------------------//
//	CFindSomeone::CompareWrapper.											//
//--------------------------------------------------------------------------//
int
CALLBACK
CFindSomeone::CompareWrapper
(
	LPARAM	param1,
	LPARAM	param2,
	LPARAM	This
){

	return( ((CFindSomeone *) This)->DirListViewCompareProc( param1, param2 ) );

}	//	End of CFindSomeone::CompareWrapper.


//--------------------------------------------------------------------------//
//	CFindSomeone::DirListViewCompareProc.									//
//--------------------------------------------------------------------------//
int
CFindSomeone::DirListViewCompareProc
(
	LPARAM	param1,
	LPARAM	param2
){
	LV_ITEM	lvi;
	int		result;

	if( (m_iSortColumn == COLUMN_INDEX_AUDIO) || (m_iSortColumn == COLUMN_INDEX_VIDEO) )
	{
		lvi.mask		= LVIF_IMAGE;
		lvi.iItem		= LParamToPos( param1 );
		lvi.iSubItem	= m_iSortColumn;

		ListView_GetItem( m_ilsListView, &lvi );

		int	iImage1	= lvi.iImage;

		lvi.iItem = LParamToPos( param2 );

		ListView_GetItem( m_ilsListView, &lvi );

		result = lvi.iImage - iImage1;
	}
	else
	{
		// BUGBUG: need better constant for max size
		TCHAR	szText1[ MAX_PATH ];
		TCHAR	szText2[ MAX_PATH ];

		lvi.mask		= LVIF_TEXT;
		lvi.iItem		= LParamToPos( param1 );
		lvi.iSubItem	= m_iSortColumn;
		lvi.pszText		= szText1;
		lvi.cchTextMax	= CCHMAX( szText1 );

		ListView_GetItem( m_ilsListView, &lvi );

		lvi.iItem	= LParamToPos( param2 );
		lvi.pszText	= szText2;

		ListView_GetItem( m_ilsListView, &lvi );

		result = StringCompare( szText1, szText2 );
	}

	if( !m_fSortAscending )
	{
		result = -result;
	}

	return( result );
}


//--------------------------------------------------------------------------//
//	CFindSomeone::LParamToPos.												//
//--------------------------------------------------------------------------//
int CFindSomeone::LParamToPos(LPARAM lParam)
{
	LV_FINDINFO lvF;

	lvF.flags	= LVFI_PARAM;
	lvF.lParam	= lParam;

	return( ListView_FindItem( m_ilsListView, -1, &lvF ) );		//	Note: retuns -1 on failure...

}


//--------------------------------------------------------------------------//
//	CFindSomeone::StoreColumnInfo.											//
//--------------------------------------------------------------------------//
void
CFindSomeone::StoreColumnInfo(void)
{
	if( IsWindow( m_ilsListView ) )
	{
		RegEntry	re( UI_KEY, HKEY_CURRENT_USER );
		DWORD		dwStyle	= ::GetWindowLong( m_ilsListView, GWL_STYLE );

		if( (dwStyle & LVS_TYPEMASK) == LVS_REPORT )
		{
			// get width of each column
			for( int i = 0; i < g_rgDLColumnInfo[ DLT_ULS ].nColumns; i++ )
			{
				m_alColumns[ i ] = ListView_GetColumnWidth( m_ilsListView, i );
			}
		}

		// save this back to registry
		re.SetValue( g_rgDLColumnInfo[ DLT_ULS ].pszRVWidths,
					(LPVOID) m_alColumns,
					sizeof( LONG ) * g_rgDLColumnInfo[ DLT_ULS ].nColumns );

		int anColumnOrder[MAX_DIR_COLUMNS];

		if( ListView_GetColumnOrderArray( m_ilsListView,
										g_rgDLColumnInfo[ DLT_ULS ].nColumns,
										anColumnOrder ) )
		{
			// save the column order to registry
			re.SetValue( g_rgDLColumnInfo[ DLT_ULS ].pszRVOrder,
						(LPVOID) anColumnOrder,
						sizeof( LONG ) * g_rgDLColumnInfo[ DLT_ULS ].nColumns );
		}

		// save the sort column and direction
		re.SetValue(g_rgDLColumnInfo[ DLT_ULS ].pszRVSortColumn, m_iSortColumn);
		re.SetValue(g_rgDLColumnInfo[ DLT_ULS ].pszRVSortAscending, m_fSortAscending);
	}

}	//	End of CFindSomeone::StoreColumnInfo.


//--------------------------------------------------------------------------//
//	CFindSomeone::onCall.													//
//--------------------------------------------------------------------------//
void
CFindSomeone::onCall(void)
{
	if( m_pRai != NULL )
	{
		const bool			secure	= (IsDlgButtonChecked( GetWindow(), IDS_SECURITY_CHECKBOX ) == BST_CHECKED);
		const NM_ADDR_TYPE	nmType	= static_cast<NM_ADDR_TYPE>(m_pRai->rgDwStr[ 0 ].dw);

		g_pCCallto->Callto(	m_pRai->rgDwStr[ 0 ].psz,	//	pointer to the callto url to try to place the call with...
							m_pRai->szName,				//	pointer to the display name to use...
							nmType,						//	callto type to resolve this callto as...
							true,						//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
							&secure,					//	security preference, NULL for none. must be "compatible" with secure param if present...
							false,						//	whether or not save in mru...
							true,						//	whether or not to perform user interaction on errors...
							GetWindow(),				//	if bUIEnabled is true this is the window to parent error/status windows to...
							NULL );						//	out pointer to INmCall * to receive INmCall * generated by placing call...
	}

}	//	End of CFindSomeone::onCall.


//--------------------------------------------------------------------------//
//	CFindSomeone::OnDeleteIlsServer.										//
//--------------------------------------------------------------------------//
void CFindSomeone::OnDeleteIlsServer(void)
{

	if( m_pMruServer != NULL )
	{
		int	iSelectionIndex	= ::SendMessage( m_hwndCombo, CB_GETCURSEL, 0, 0 );

		if( iSelectionIndex != CB_ERR )
		{
			int	iLength	= ::SendMessage( m_hwndCombo, CB_GETLBTEXTLEN, iSelectionIndex, 0 );

			TCHAR * pszIls	= new TCHAR [ iLength + 1 ];

			if( pszIls != NULL )
			{
				if( ::SendMessage( m_hwndCombo, CB_GETLBTEXT, iSelectionIndex, (LPARAM) pszIls ) != CB_ERR )
				{
					HWND	hwndDialog	= s_pDlgCall->GetWindow();
					USES_RES2T
					TCHAR res1[RES_CH_MAX];
					TCHAR res2[RES_CH_MAX];
					RES2T( IDS_MSGBOX_TITLE );
					
					COPY_RES2T(res2)

					//	First make sure this directory server isn't their default server....
					if( lstrcmpi( pszIls, CDirectoryManager::get_defaultServer() ) == 0 )
					{
						RES2T( IDS_DLGCALL_CANT_DELETE_DEFAULT_ILS );
						COPY_RES2T(res1);
						
						::MessageBox( hwndDialog, res1, res2, MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION );
					}
					else
					{
						//	Next make them confirm they want to do this...
						if( ::MessageBox( hwndDialog, RES2T( IDS_DLGCALL_CONFIRM_DELETE_ILS ), res2, MB_SETFOREGROUND | MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 ) == IDYES )
						{
							if( m_pMruServer->DeleteEntry( pszIls ) )
							{
								m_pMruServer->Save();

								int	iCount	= ::SendMessage( m_hwndCombo, CB_DELETESTRING, iSelectionIndex, 0 );

								if( iCount <= iSelectionIndex )
								{
									iSelectionIndex--;
								}

								::SendMessage( m_hwndCombo, CB_SETCURSEL, iSelectionIndex, 0 );
								ShowList( iSelectionIndex );
    						}
						}
					}
				}
						
				delete [] pszIls;
			}
		}
	}

}	//	End of CFindSomeone::OnDeleteIlsServer.


void CFindSomeone::OnCallStarted()
{
	HWND hwnd = GetWindow();

    m_secure = ::IsDlgButtonChecked( hwnd, IDS_SECURITY_CHECKBOX ) != 0;
	UpdateSecurityCheck(m_pConfRoom, hwnd, IDS_SECURITY_CHECKBOX);

	// BUGBUG georgep: We get notified before the actual conference state
	// changes, so we need to disable manually
    ::EnableWindow( GetDlgItem(hwnd, IDS_SECURITY_CHECKBOX), FALSE );
}

void CFindSomeone::OnCallEnded()
{
	HWND hwnd = GetWindow();

	UpdateSecurityCheck(m_pConfRoom, hwnd, IDS_SECURITY_CHECKBOX);
    ::CheckDlgButton( hwnd, IDS_SECURITY_CHECKBOX, m_secure );
}

//--------------------------------------------------------------------------//
//	StringCompare.															//
//--------------------------------------------------------------------------//
int StringCompare( const TCHAR * const psz1, const TCHAR * const psz2 )
{
	ASSERT( psz1 != NULL );
	ASSERT( psz2 != NULL );

	int	iResult	= CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE | SORT_STRINGSORT, psz1, -1, psz2, -1 );

	ASSERT( iResult != 0);

	if( iResult == CSTR_LESS_THAN )
	{
		iResult = -1;
	}
	else if( iResult == CSTR_GREATER_THAN )
	{
		iResult = 1;
	}
	else
	{
		iResult = 0;
	}

	return( iResult );

}	//	End of StringCompare.


//--------------------------------------------------------------------------//
//	GetDefaultRect.															//
//--------------------------------------------------------------------------//
void GetDefaultRect(const HWND hwndParent, RECT & rcRect, const int iDefaultWidth, const int iDefaultHeight)
{
	RECT	rcWorkArea;
	bool	bResizeAndCenter = true;

	if( !SystemParametersInfo( SPI_GETWORKAREA, 0, &rcWorkArea, 0 ) )
	{
		SetRect( &rcWorkArea, 0, 0, GetSystemMetrics( SM_CXSCREEN ) - 1, GetSystemMetrics( SM_CYSCREEN ) - 1 );
	}

	if( IsWindow( hwndParent ) )
	{
		GetWindowRect( hwndParent, &rcRect );

		rcRect.left	+= DX_BORDER;
		rcRect.top	+= DY_BORDER + GetSystemMetrics( SM_CYCAPTION );

		rcRect.right	= rcRect.left + iDefaultWidth;
		rcRect.bottom	= rcRect.top + iDefaultHeight;

		if( (rcRect.left >= rcWorkArea.left) && (rcRect.top >= rcWorkArea.top) &&
			(rcRect.right <= rcWorkArea.right) && (rcRect.bottom <= rcWorkArea.bottom) )
		{
			bResizeAndCenter = false;
		}
	}

	if( bResizeAndCenter )
	{
		int	iWidth	= rcWorkArea.right - rcWorkArea.left;

		if( iWidth > iDefaultWidth )
		{
			iWidth -= iDefaultWidth;
			iWidth /= 2;

			rcWorkArea.left += iWidth;
			rcWorkArea.right = rcWorkArea.left + iDefaultWidth;
		}
		else
		{
			iWidth = (rcWorkArea.right - rcWorkArea.left) / 10;

			rcWorkArea.left		+= iWidth;
			rcWorkArea.right	-= iWidth;
		}

		int	iHeight	= rcWorkArea.bottom - rcWorkArea.top;

		if( iHeight > iDefaultHeight )
		{
			iHeight -= iDefaultHeight;
			iHeight /= 2;

			rcWorkArea.top += iHeight;
			rcWorkArea.bottom = rcWorkArea.top + iDefaultHeight;
		}
		else
		{
			iHeight = (rcWorkArea.bottom - rcWorkArea.top) / 10;

			rcWorkArea.top		+= iHeight;
			rcWorkArea.bottom	-= iHeight;
		}

		rcRect = rcWorkArea;
	}

}	//	End of GetDefaultRect.


//--------------------------------------------------------------------------//
//	GetPixelsPerChar.														//
//--------------------------------------------------------------------------//
int GetPixelsPerChar(const HWND hwnd)
{
	int	iPixels	= 10;

	if( IsWindow( hwnd ) )
	{
		HDC	hDC;

		if( (hDC = GetDC( hwnd )) != NULL )
		{
			HFONT	hFont;

			if( (hFont = (HFONT) SendMessage( hwnd, WM_GETFONT, 0, 0 )) != NULL )
			{
				hFont = (HFONT) SelectObject( hDC, hFont );

				TEXTMETRIC	tmMetrics;

				GetTextMetrics( hDC, &tmMetrics );

				iPixels = tmMetrics.tmAveCharWidth;

				SelectObject( hDC, hFont );
			}

			ReleaseDC( hwnd, hDC );
		}
	}

	return( iPixels );

}	//	End of GetPixelsPerChar.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dlghost.h ===
// File: dlghost.h

#ifndef _CDLGHOST_H_
#define _CDLGHOST_H_

class CDlgHost
{
private:
	HWND   m_hwnd;
	LPTSTR m_pszName;
	LPTSTR m_pszPassword;
	BOOL   m_fSecure;
    DWORD  m_attendeePermissions;
    UINT   m_maxParticipants;

public:
	CDlgHost();
	~CDlgHost();

	// Properties:
	LPCTSTR PszName()     const {return m_pszName;}
	LPCTSTR PszPassword() const {return m_pszPassword;}
	BOOL IsSecure() const {return m_fSecure;}
    DWORD   AttendeePermissions() const {return m_attendeePermissions;}
    UINT    MaxParticipants() const {return m_maxParticipants;}
	
	INT_PTR DoModal(HWND hwnd);
	VOID OnInitDialog(void);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	static INT_PTR CALLBACK DlgProcHost(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};



class CDlgHostSettings
{
private:
    HWND    m_hwnd;
    BOOL    m_fHost;
    LPTSTR  m_pszName;
    DWORD   m_caps;
    NM30_MTG_PERMISSIONS   m_permissions;

public:
    CDlgHostSettings(BOOL fHost, LPTSTR szName, DWORD caps, NM30_MTG_PERMISSIONS permissions);
    ~CDlgHostSettings(void);

    static void KillHostSettings();

    INT_PTR DoModal(HWND hwnd);
    void    OnInitDialog(void);

    static INT_PTR CALLBACK DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif /* _CDLGHOST_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dlghost.cpp ===
// File: dlghost.cpp

#include "precomp.h"

#include "resource.h"
#include "dlghost.h"
#include "ConfPolicies.h"
#include <help_ids.h>


// Dialog ID to Help ID mapping
static const DWORD rgHelpIdsHostMeeting[] = {
IDE_HOST_GENERAL,       IDH_HOST_GENERAL,
IDE_HOST_SETTINGS,      IDH_HOST_SETTINGS,
IDE_HOST_NAME,          IDH_HOST_NAME,
IDE_HOST_PASSWORD,      IDH_HOST_PASSWORD,
IDE_HOST_SECURE,        IDH_HOST_SECURE,
IDE_HOST_YOUACCEPT,     IDH_HOST_ACCEPT_PEOPLE,
IDE_HOST_YOUINVITE,     IDH_HOST_INVITE_PEOPLE,
IDE_HOST_TOOLS,         IDH_HOST_TOOLS,
IDE_HOST_TOOLS2,        IDH_HOST_TOOLS,
IDE_HOST_YOUSHARE,      IDH_HOST_SHARE,
IDE_HOST_YOUWB,         IDH_HOST_WHITEBD,
IDE_HOST_YOUCHAT,       IDH_HOST_CHAT,
IDE_HOST_YOUFT,         IDH_HOST_XFER,
IDE_HOST_YOUAUDIO,      IDH_HOST_AUDIO,
IDE_HOST_YOUVIDEO,      IDH_HOST_VIDEO,
0, 0 // terminator
};

static HWND  s_hwndSettings = NULL;


/*  C  D L G  H O S T  */
/*-------------------------------------------------------------------------
    %%Function: CDlgHost

-------------------------------------------------------------------------*/
CDlgHost::CDlgHost(void):
	m_hwnd(NULL),
	m_pszName(NULL),
	m_pszPassword(NULL),
    m_attendeePermissions(NM_PERMIT_ALL),
    m_maxParticipants(-1)
{
}

CDlgHost::~CDlgHost(void)
{
	delete m_pszName;
	delete m_pszPassword;
}


INT_PTR CDlgHost::DoModal(HWND hwnd)
{
	return DialogBoxParam(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_HOST),
						hwnd, CDlgHost::DlgProcHost, (LPARAM) this);
}



/*  D L G  P R O C  H O S T  */
/*-------------------------------------------------------------------------
    %%Function: DlgProcHost

-------------------------------------------------------------------------*/
INT_PTR CALLBACK CDlgHost::DlgProcHost(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG:
	{
		ASSERT(NULL != lParam);
		::SetWindowLongPtr(hdlg, DWLP_USER, lParam);

		CDlgHost * pDlg = (CDlgHost*) lParam;
		pDlg->m_hwnd = hdlg;
		pDlg->OnInitDialog();
		return TRUE; // default focus is ok
	}

	case WM_COMMAND:
	{
		CDlgHost * pDlg = (CDlgHost*) GetWindowLongPtr(hdlg, DWLP_USER);
		if (NULL != pDlg)
		{
			pDlg->OnCommand(wParam, lParam);
		}
		break;
	}

    case WM_CONTEXTMENU:
        DoHelpWhatsThis(wParam, rgHelpIdsHostMeeting);
        break;

    case WM_HELP:
        DoHelp(lParam, rgHelpIdsHostMeeting);
        break;
	
	default:
		break;
	}

	return FALSE;
}


/*  O N  C O M M A N D  */
/*-------------------------------------------------------------------------
    %%Function: OnCommand

-------------------------------------------------------------------------*/
BOOL CDlgHost::OnCommand(WPARAM wParam, LPARAM lParam)
{
    TCHAR   szName[MAX_PATH];
    TCHAR   szPassword[MAX_PATH];

    UINT wCmd = GET_WM_COMMAND_ID(wParam, lParam);
	
	switch (wCmd)
	{
	case IDOK:
	{
		TCHAR sz[MAX_PATH];
		if (0 != GetDlgItemText(m_hwnd, IDE_HOST_NAME, sz, CCHMAX(sz)))
		{
			m_pszName = PszAlloc(sz);
		}

		if (0 != GetDlgItemText(m_hwnd, IDE_HOST_PASSWORD, sz, CCHMAX(sz)))
		{
			m_pszPassword = PszAlloc(sz);
		}

        m_fSecure = ::IsDlgButtonChecked(m_hwnd, IDE_HOST_SECURE);

        //
        // Permissions
        //
        if (::IsDlgButtonChecked(m_hwnd, IDE_HOST_YOUACCEPT))
        {
            m_attendeePermissions &= ~NM_PERMIT_INCOMINGCALLS;
        }
        if (::IsDlgButtonChecked(m_hwnd, IDE_HOST_YOUINVITE))
        {
            m_attendeePermissions &= ~NM_PERMIT_OUTGOINGCALLS;
        }

        if (::IsDlgButtonChecked(m_hwnd, IDE_HOST_YOUSHARE))
        {
            m_attendeePermissions &= ~NM_PERMIT_SHARE;
        }
        if (::IsDlgButtonChecked(m_hwnd, IDE_HOST_YOUWB))
        {
            m_attendeePermissions &= ~(NM_PERMIT_STARTOLDWB | NM_PERMIT_STARTWB);
        }
        if (::IsDlgButtonChecked(m_hwnd, IDE_HOST_YOUCHAT))
        {
            m_attendeePermissions &= ~NM_PERMIT_STARTCHAT;
        }
        if (::IsDlgButtonChecked(m_hwnd, IDE_HOST_YOUFT))
        {
            m_attendeePermissions &= ~NM_PERMIT_SENDFILES;
        }
		// fall thru to IDCANCEL
	}

	case IDCANCEL:
	{
		::EndDialog(m_hwnd, wCmd);
		return TRUE;
	}

    case IDE_HOST_NAME:
    case IDE_HOST_PASSWORD:
    {
        switch (GET_WM_COMMAND_CMD(wParam, lParam))
        {
            case EN_CHANGE:
            {
                BOOL    fOkName;
                BOOL    fOkPassword;

                //
                // Look at the name
                //
                GetDlgItemText(m_hwnd, IDE_HOST_NAME, szName, CCHMAX(szName));

                if (!szName[0])
                {
                    fOkName = FALSE;
                }
                else if (!FAnsiSz(szName))
                {
                    fOkName = FALSE;
                    if (GET_WM_COMMAND_ID(wParam, lParam) == IDE_HOST_NAME)
                    {
                        // User typed bogus char in name field
                        MessageBeep(0);
                    }
                }
                else
                {
                    fOkName = TRUE;
                }

                //
                // Look at the password, it CAN be empty
                //
                GetDlgItemText(m_hwnd, IDE_HOST_PASSWORD, szPassword, CCHMAX(szPassword));

                if (!szPassword[0])
                {
                    fOkPassword = TRUE;
                }
                else if (FAnsiSz(szPassword))
                {
                    fOkPassword = TRUE;
                }
                else
                {
                    fOkPassword = FALSE;
                    if (GET_WM_COMMAND_ID(wParam, lParam) == IDE_HOST_PASSWORD)
                    {
                        // User typed bogus char in password field
                        MessageBeep(0);
                    }
                }

                EnableWindow(GetDlgItem(m_hwnd, IDOK), fOkName && fOkPassword);

                break;
            }
        }
        break;
    }

	default:
		break;
	}

	return FALSE;
}



/*  O N  I N I T  D I A L O G  */
/*-------------------------------------------------------------------------
    %%Function: OnInitDialog

-------------------------------------------------------------------------*/
VOID CDlgHost::OnInitDialog(void)
{
	TCHAR sz[MAX_PATH];
    BOOL  fSecureAlterable;
    BOOL  fSecureOn;

    switch (ConfPolicies::GetSecurityLevel())
    {
        case DISABLED_POL_SECURITY:
            fSecureOn = FALSE;
            fSecureAlterable = FALSE;
            break;

        case REQUIRED_POL_SECURITY:
            fSecureOn = TRUE;
            fSecureAlterable = FALSE;
            break;

        default:
            fSecureOn = ConfPolicies::OutgoingSecurityPreferred();
            fSecureAlterable = TRUE;
            break;
    }

    ::CheckDlgButton(m_hwnd, IDE_HOST_SECURE, fSecureOn);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDE_HOST_SECURE), fSecureAlterable);

	if (FLoadString(IDS_DEFAULT_CONF_NAME, sz, CCHMAX(sz)))
	{
		SetDlgItemText(m_hwnd, IDE_HOST_NAME, sz);
	}

	Edit_LimitText(GetDlgItem(m_hwnd, IDE_HOST_NAME), CCHMAXSZ_NAME - 1);
	Edit_LimitText(GetDlgItem(m_hwnd, IDE_HOST_PASSWORD), CCHMAXSZ_NAME - 1);

}



//
// C  D L G  H O S T  S E T T I N G S
//
// This is a simple description of what restrictions there are in this
// meeting.  Users see this when
//      (a) They join a restricted meeting
//      (b) They or the host chooses the Meeting Properties menu item under Call
//
CDlgHostSettings::CDlgHostSettings
(
    BOOL        fHost,
    LPTSTR      szName,
    DWORD       caps,
    NM30_MTG_PERMISSIONS permissions
)
{
    m_hwnd          = NULL;
    m_fHost         = fHost;
    m_pszName       = szName;
    m_caps          = caps;
    m_permissions   = permissions;
}


CDlgHostSettings::~CDlgHostSettings(void)
{
}


void CDlgHostSettings::KillHostSettings(void)
{
    if (s_hwndSettings)
    {
        // Kill current one.
        WARNING_OUT(("Killing previous meeting settings dialog"));
        SendMessage(s_hwndSettings, WM_COMMAND, IDCANCEL, 0);
        ASSERT(!s_hwndSettings);
    }
}


INT_PTR CDlgHostSettings::DoModal(HWND hwnd)
{
    CDlgHostSettings::KillHostSettings();

    return DialogBoxParam(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_HOST_SETTINGS),
        hwnd, CDlgHostSettings::DlgProc, (LPARAM)this);
}


//
// CDlgHostSettings::DlgProc()
//
INT_PTR CALLBACK CDlgHostSettings::DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ASSERT(lParam != NULL);
            SetWindowLongPtr(hdlg, DWLP_USER, lParam);

            CDlgHostSettings * pDlg = (CDlgHostSettings *) lParam;

            ASSERT(!s_hwndSettings);
            s_hwndSettings = hdlg;
            pDlg->m_hwnd = hdlg;
            pDlg->OnInitDialog();
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    if (s_hwndSettings == hdlg)
                    {
                        s_hwndSettings = NULL;
                    }
                    ::EndDialog(hdlg, GET_WM_COMMAND_ID(wParam, lParam));
                    return TRUE;
            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            DoHelpWhatsThis(wParam, rgHelpIdsHostMeeting);
            break;
        }

        case WM_HELP:
        {
            DoHelp(lParam, rgHelpIdsHostMeeting);
            break;
        }

        default:
            break;
    }

    return FALSE;
}


//
// CDlgHostSettings::OnInitDialog()
//
void CDlgHostSettings::OnInitDialog(void)
{
    TCHAR   szText[256];
    TCHAR   szRestrict[128];
    TCHAR   szResult[384];
    USES_RES2T
	
    ::SetDlgItemText(m_hwnd, IDE_HOST_NAME, m_pszName);

    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_SECURE), ((m_caps & NMCH_SECURE) != 0));

    //
    // Meeting settings
    //
    if (!m_fHost)
	{
		SetDlgItemText(m_hwnd, IDE_HOST_YOUACCEPT, RES2T(IDS_NONHOST_YOUACCEPT));
	}
    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_YOUACCEPT),
        !(m_permissions & NM_PERMIT_INCOMINGCALLS));

    if (!m_fHost)
	{
		SetDlgItemText(m_hwnd, IDE_HOST_YOUINVITE, RES2T(IDS_NONHOST_YOUINVITE));
	}
    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_YOUINVITE),
        !(m_permissions & NM_PERMIT_OUTGOINGCALLS));

    //
    // Meeting tools
    //
	if (!m_fHost)
	{
		SetDlgItemText(m_hwnd, IDE_HOST_TOOLS, RES2T(IDS_NONHOST_TOOLS));
	}

    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_YOUSHARE),
        !(m_permissions & NM_PERMIT_SHARE));
    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_YOUWB),
        !(m_permissions & (NM_PERMIT_STARTWB | NM_PERMIT_STARTOLDWB)));
    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_YOUCHAT),
        !(m_permissions & NM_PERMIT_STARTCHAT));
    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_YOUFT),
        !(m_permissions & NM_PERMIT_SENDFILES));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dshowdlg.h ===
/****************************************************************************
*
*    FILE:     DShowDlg.h
*
*    CREATED:  Chris Pirich (ChrisPi) 5-6-96
*
****************************************************************************/

#ifndef _DSHOWDLG_H_
#define _DSHOWDLG_H_

static const int DS_MAX_MESSAGE_LENGTH = 1024; // characters
static const int DS_MAX_TEXT_WIDTH = 320; // pixels

// NOTE: must not conflict with MB_* flags in winuser.h
#define DSD_ALWAYSONTOP				0x01000000L

class CDontShowDlg
{
protected:
	HWND		m_hwnd;
	UINT		m_uFlags;

	LPTSTR		m_pszRegVal;
	UINT_PTR	m_uMsgId;
	RegEntry	m_reDontShow;

	int			m_nWidth;
	int			m_nHeight;
	int			m_nTextWidth;
	int			m_nTextHeight;

	BOOL		OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

	// Handlers:
	BOOL		OnOk();

public:
	
	// Methods:
				CDontShowDlg(	UINT uMsgId,
								LPCTSTR pcszRegVal,
								UINT uFlags=0);
				~CDontShowDlg()	{ delete m_pszRegVal;	};
	INT_PTR	DoModal(HWND hwnd);

	static INT_PTR CALLBACK DontShowDlgProc(	HWND hDlg,
											UINT uMsg,
											WPARAM wParam,
											LPARAM lParam);
};

BOOL FEnableDontShow(LPCTSTR pszKey);

#endif // _DSHOWDLG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dshowdlg.cpp ===
#include "precomp.h"
#include "resource.h"

/****************************************************************************
*
*    FILE:     DShowDlg.cpp
*
*    CREATED:  Chris Pirich (ChrisPi) 5-6-96
*
*    CONTENTS: CDontShowDlg object
*
****************************************************************************/

#include "DShowDlg.h"
#include "conf.h"
#include "ConfUtil.h"

/****************************************************************************
*
*    CLASS:    CDontShowDlg
*
*    MEMBER:   CDontShowDlg()
*
*    PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CDontShowDlg::CDontShowDlg(	UINT uMsgId,
							LPCTSTR pcszRegVal,
							UINT uFlags):
	m_uMsgId		(uMsgId),
	m_hwnd			(NULL),
	m_reDontShow	(UI_KEY, HKEY_CURRENT_USER),
	m_uFlags		(uFlags),
	m_nWidth		(0),
	m_nHeight		(0),
	m_nTextWidth	(0),
	m_nTextHeight	(0)
{
	DebugEntry(CDontShowDlg::CDontShowDlg);

	ASSERT(pcszRegVal);
	
	m_pszRegVal = PszAlloc(pcszRegVal);

	DebugExitVOID(CDontShowDlg::CDontShowDlg);
}

/****************************************************************************
*
*    CLASS:    CDontShowDlg
*
*    MEMBER:   DoModal()
*
*    PURPOSE:  Brings up the modal dialog box
*
****************************************************************************/

INT_PTR CDontShowDlg::DoModal(HWND hwnd)
{
	DebugEntry(CDontShowDlg::DoModal);

	INT_PTR nRet = IDCANCEL;

	if (_Module.InitControlMode())
	{
		nRet = IDOK;
	}
	else if (NULL != m_pszRegVal)
	{
	// If the "dont show me" check box has been checked before and stored in
	// the registry, then return IDOK, so the calling code doesn't have to
	// differentiate the two cases.

		nRet = (TRUE == m_reDontShow.GetNumber(m_pszRegVal, FALSE)) ?
				IDOK : IDCANCEL;
	}
	
	if (IDOK != nRet)
	{
		HWND hwndDesktop = ::GetDesktopWindow();
		if (NULL != hwndDesktop)
		{
			HDC hdc = ::GetDC(hwndDesktop);
			if (NULL != hdc)
			{
				HFONT hFontOld = (HFONT) SelectObject(hdc, g_hfontDlg);
				TCHAR szString[DS_MAX_MESSAGE_LENGTH];
				LPTSTR pszString = NULL;
				if (0 != HIWORD(m_uMsgId))
				{
					// use m_uMsgId as a string pointer
					// NOTE: object must be used on the stack since the pointer is
					// not copied
					pszString = (LPTSTR) m_uMsgId;
				}
				else if (::LoadString(	::GetInstanceHandle(), (UINT)m_uMsgId,
										szString, ARRAY_ELEMENTS(szString)))
				{
					pszString = szString;
				}
				if (NULL != pszString)
				{
					m_nTextWidth = DS_MAX_TEXT_WIDTH;

					RECT rct = {0, 0, m_nTextWidth, 0xFFFF};
					m_nTextHeight = ::DrawText(	hdc,
												pszString,
												-1,
												&rct,
												DT_LEFT | DT_CALCRECT | DT_WORDBREAK);
				}
				::SelectObject(hdc, hFontOld);
				::ReleaseDC(hwndDesktop, hdc);
			}
		}

		// If the box wasn't checked before, then bring up the dialog:
		nRet = DialogBoxParam(	::GetInstanceHandle(),
								MAKEINTRESOURCE(IDD_DONT_SHOW_ME),
								hwnd,
								CDontShowDlg::DontShowDlgProc,
								(LPARAM) this);
	}

	DebugExitINT_PTR(CDontShowDlg::DoModal, nRet);

	return nRet;
}

/****************************************************************************
*
*    CLASS:    CDontShowDlg
*
*    MEMBER:   DontShowDlgProc()
*
*    PURPOSE:  Dialog Proc - handles all messages
*
****************************************************************************/

INT_PTR CALLBACK CDontShowDlg::DontShowDlgProc(HWND hDlg,
											UINT uMsg,
											WPARAM wParam,
											LPARAM lParam)
{
	BOOL bMsgHandled = FALSE;

	// uMsg may be any value.
	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hDlg, WND));

	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			if (NULL != lParam)
			{
				CDontShowDlg* pdsd = (CDontShowDlg*) lParam;
				pdsd->m_hwnd = hDlg;
				::SetWindowLongPtr(hDlg, DWLP_USER, lParam);

				int nInitialTextWidth = 0;
				int nInitialTextHeight = 0;

				TCHAR szMsgBuf[DS_MAX_MESSAGE_LENGTH];
				if (0 != HIWORD(pdsd->m_uMsgId))
				{
					// use m_uMsgId as a string pointer
					// NOTE: object must be used on the stack since the pointer is
					// not copied
					ASSERT(IS_VALID_READ_PTR((LPTSTR) pdsd->m_uMsgId, TCHAR));
					lstrcpyn(szMsgBuf, (LPTSTR) pdsd->m_uMsgId, CCHMAX(szMsgBuf));
				}
				else
				{
					::LoadString(	::GetInstanceHandle(),
									(INT)pdsd->m_uMsgId,
									szMsgBuf,
									(INT)ARRAY_ELEMENTS(szMsgBuf));
				}

				// Set the text
				::SetDlgItemText(	hDlg,
									IDC_TEXT_STATIC,
									szMsgBuf);

				RECT rctDlg;
				::GetWindowRect(hDlg, &rctDlg);
				int nOrigWidth = rctDlg.right - rctDlg.left;
				int nOrigHeight = rctDlg.bottom - rctDlg.top;
				HWND hwndText = ::GetDlgItem(hDlg, IDC_TEXT_STATIC);
				if (NULL != hwndText)
				{
					RECT rctText;
					if (::GetWindowRect(hwndText, &rctText))
					{
						nInitialTextWidth = rctText.right - rctText.left;
						nInitialTextHeight = rctText.bottom - rctText.top;
						// Resize the text control
						::SetWindowPos(	hwndText,
										NULL, 0, 0,
										pdsd->m_nTextWidth,
										pdsd->m_nTextHeight,
										SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);
					}

					// Set the font (for DBCS systems)
					::SendMessage(hwndText, WM_SETFONT, (WPARAM) g_hfontDlg, 0);
				}

				pdsd->m_nWidth = (nOrigWidth - nInitialTextWidth)
									+ pdsd->m_nTextWidth;
				pdsd->m_nHeight = (nOrigHeight - nInitialTextHeight)
									+ pdsd->m_nTextHeight;

				RECT rctCtrl;
				// Move the ok button (IDOK)
				HWND hwndOK = ::GetDlgItem(hDlg, IDOK);
				if ((NULL != hwndOK) && ::GetWindowRect(hwndOK, &rctCtrl))
				{
					// Turn rctCtrl's top and left into client coords:
					::MapWindowPoints(NULL, hDlg, (LPPOINT) &rctCtrl, 2);
					if (pdsd->m_uFlags & MB_OKCANCEL)
					{
						::SetWindowPos(	hwndOK,
										NULL,
										rctCtrl.left + ((pdsd->m_nWidth - nOrigWidth) / 2),
										rctCtrl.top + (pdsd->m_nHeight - nOrigHeight),
										0, 0,
										SWP_NOACTIVATE | SWP_NOZORDER
											| SWP_NOSIZE | SWP_NOREDRAW);
					}
					else
					{
						// center the OK button
						::SetWindowPos(	hwndOK,
										NULL,
										(pdsd->m_nWidth / 2) -
											((rctCtrl.right - rctCtrl.left) / 2),
										rctCtrl.top + (pdsd->m_nHeight - nOrigHeight),
										0, 0,
										SWP_NOACTIVATE | SWP_NOZORDER
											| SWP_NOSIZE | SWP_NOREDRAW);
					}
				}
				// Move the cancel button (IDCANCEL)
				HWND hwndCancel = ::GetDlgItem(hDlg, IDCANCEL);
				if ((NULL != hwndCancel) && ::GetWindowRect(hwndCancel, &rctCtrl))
				{
					if (pdsd->m_uFlags & MB_OKCANCEL)
					{
						// Turn rctCtrl's top and left into client coords:
						::MapWindowPoints(NULL, hDlg, (LPPOINT) &rctCtrl, 1);
						::SetWindowPos(	hwndCancel,
										NULL,
										rctCtrl.left + ((pdsd->m_nWidth - nOrigWidth) / 2),
										rctCtrl.top + (pdsd->m_nHeight - nOrigHeight),
										0, 0,
										SWP_NOACTIVATE | SWP_NOZORDER
											| SWP_NOSIZE | SWP_NOREDRAW);
					}
					else
					{
						::ShowWindow(hwndCancel, SW_HIDE);
					}
				}
				// Move the check box (IDC_DONT_SHOW_ME_CHECK)
				HWND hwndCheck = ::GetDlgItem(hDlg, IDC_DONT_SHOW_ME_CHECK);
				if ((NULL != hwndCheck) && ::GetWindowRect(hwndCheck, &rctCtrl))
				{
					// Turn rctCtrl's top and left into client coords:
					::MapWindowPoints(NULL, hDlg, (LPPOINT) &rctCtrl, 1);
					::SetWindowPos(	hwndCheck,
									NULL,
									rctCtrl.left,
									rctCtrl.top + (pdsd->m_nHeight - nOrigHeight),
									0, 0,
									SWP_NOACTIVATE | SWP_NOZORDER
										| SWP_NOSIZE | SWP_NOREDRAW);
				}
				
				// Show, resize, and activate
				::SetWindowPos(	hDlg,
								0,
								0,
								0,
								pdsd->m_nWidth,
								pdsd->m_nHeight,
								SWP_SHOWWINDOW | SWP_NOZORDER |
									SWP_NOMOVE | SWP_DRAWFRAME);

				// Put the appropriate icon on the dialog:
				HWND hwndIcon = ::GetDlgItem(hDlg, IDC_ICON_STATIC);
				::SendMessage(	hwndIcon,
								STM_SETICON,
								(WPARAM) ::LoadIcon(NULL, IDI_INFORMATION),
								0);

				if (pdsd->m_uFlags & DSD_ALWAYSONTOP)
				{
					::SetWindowPos(	hDlg,
									HWND_TOPMOST,
									0, 0, 0, 0,
									SWP_NOMOVE | SWP_NOSIZE);
				}
				if (pdsd->m_uFlags & MB_SETFOREGROUND)
				{
					::SetForegroundWindow(hDlg);
				}
			}

			bMsgHandled = 1;
			break;
		}

		default:
		{
			CDontShowDlg* ppd = (CDontShowDlg*) GetWindowLongPtr(	hDlg,
																DWLP_USER);

			if (NULL != ppd)
			{
				bMsgHandled = ppd->OnMessage(uMsg, wParam, lParam);
			}
		}
	}

	return bMsgHandled;
}

/****************************************************************************
*
*    CLASS:    CDontShowDlg
*
*    MEMBER:   OnMessage()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CDontShowDlg::OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL bRet = FALSE;
		
	ASSERT(m_hwnd);
	
	switch (uMsg)
	{
		case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
				case IDOK:
				{
					bRet = OnOk();
					break;
				}

				case IDCANCEL:
				{
					::EndDialog(m_hwnd, LOWORD(wParam));
					bRet = TRUE;
					break;
				}

			}
			break;
		}
			
		default:
			break;
	}

	return bRet;
}

/****************************************************************************
*
*    CLASS:    CDontShowDlg
*
*    MEMBER:   OnOk()
*
*    PURPOSE:  processes the WM_COMMAND,IDOK message
*
****************************************************************************/

BOOL CDontShowDlg::OnOk()
{
	DebugEntry(CDontShowDlg::OnOk);

	BOOL bRet = TRUE;

	if ((BST_CHECKED == ::IsDlgButtonChecked(m_hwnd, IDC_DONT_SHOW_ME_CHECK)) &&
		(NULL != m_pszRegVal))
	{
		m_reDontShow.SetValue(m_pszRegVal, TRUE);
	}

	::EndDialog(m_hwnd, IDOK);

	DebugExitBOOL(CDontShowDlg::OnOk, bRet);

	return bRet;
}

///////////////////////////////////////////////////////////////////////////////
//

/*  F  E N A B L E  D O N T  S H O W  */
/*-------------------------------------------------------------------------
    %%Function: FEnableDontShow

    Return TRUE if the "Don't Show" dialog is enabled
-------------------------------------------------------------------------*/
BOOL FEnableDontShow(LPCTSTR pszKey)
{
	RegEntry reUI(UI_KEY, HKEY_CURRENT_USER);
	return (0 == reUI.GetNumber(pszKey, 0));
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dstest.h ===
#ifndef _DSTEST_H_
#define _DSTEST_H_

#define DS_AVAILABLE	1
#define DS_FULLDUPLEX   2
#define DS_FULLDUPLEX_RECOMMENDED 3

UINT DirectSoundCheck(UINT waveInID, UINT waveOutID, HWND hwnd);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\enumvar.cpp ===
/************************************************************************* 
** 
**  This is a part of the Microsoft Source Code Samples. 
** 
**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. 
** 
**  This source code is only intended as a supplement to Microsoft Development 
**  Tools and/or WinHelp documentation.  See these sources for detailed 
**  information regarding the Microsoft samples programs. 
** 
**  OLE Automation TypeLibrary Browse Helper Sample 
** 
**  enumvar.cpp 
** 
**  CEnumVariant implementation 
** 
**  Written by Microsoft Product Support Services, Windows Developer Support 
** 
*************************************************************************/ 

#include <windows.h> 
#include "precomp.h"
#include "Enumvar.h"   
 
/* 
 * CEnumVariant::Create 
 * 
 * Purpose: 
 *  Creates an instance of the IEnumVARIANT enumerator object and initializes it. 
 * 
 * Parameters: 
 *  psa        Safe array containing items to be enumerated. 
 *  cElements  Number of items to be enumerated.  
 *  ppenumvariant    Returns enumerator object. 
 * 
 * Return Value: 
 *  HRESULT 
 * 
 */ 
//static 
HRESULT  
CEnumVariant::Create(SAFEARRAY FAR* psa, ULONG cElements, CEnumVariant** ppenumvariant)  
{    
    HRESULT hr; 
    CEnumVariant FAR* penumvariant = NULL; 
    long lLBound; 
                       
    *ppenumvariant = NULL; 
     
    penumvariant = new CEnumVariant(); 
    if (penumvariant == NULL) 
        goto error;  
         
    penumvariant->m_cRef = 0; 
     
    // Copy elements into safe array that is used in enumerator implemenatation and  
    // initialize state of enumerator. 
    hr = SafeArrayGetLBound(psa, 1, &lLBound); 
    if (FAILED(hr)) 
        goto error; 
    penumvariant->m_cElements = cElements;     
    penumvariant->m_lLBound = lLBound; 
    penumvariant->m_lCurrent = lLBound;                   
    hr = SafeArrayCopy(psa, &penumvariant->m_psa); 
    if (FAILED(hr)) 
       goto error; 
     
    *ppenumvariant = penumvariant; 
    return NOERROR; 
     
error:  
    if (penumvariant == NULL) 
        return E_OUTOFMEMORY;    
                               
    if (penumvariant->m_psa)  
        SafeArrayDestroy(penumvariant->m_psa);    
    penumvariant->m_psa = NULL;      
    delete penumvariant; 
    return hr; 
} 
 
/* 
 * CEnumVariant::CEnumVariant 
 * 
 * Purpose: 
 *  Constructor for CEnumVariant object. Initializes members to NULL. 
 * 
 */ 
CEnumVariant::CEnumVariant() 
{     
    m_psa = NULL; 
} 
 
/* 
 * CEnumVariant::~CEnumVariant 
 * 
 * Purpose: 
 *  Destructor for CEnumVariant object.  
 * 
 */ 
CEnumVariant::~CEnumVariant() 
{                    
    if (m_psa) SafeArrayDestroy(m_psa); 
} 
 
/* 
 * CEnumVariant::QueryInterface, AddRef, Release 
 * 
 * Purpose: 
 *  Implements IUnknown::QueryInterface, AddRef, Release 
 * 
 */ 
STDMETHODIMP 
CEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)  
{    
    *ppv = NULL; 
         
    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)  
        *ppv = this;      
    else return E_NOINTERFACE;  
 
    AddRef(); 
    return NOERROR;     
} 
 
 
STDMETHODIMP_(ULONG) 
CEnumVariant::AddRef(void) 
{ 
 
#ifdef _DEBUG    
    TCHAR ach[50]; 
    wsprintf(ach, TEXT("Ref = %ld, Enum\r\n"), m_cRef+1);  
    TRACE_OUT((ach));
#endif   
     
    return ++m_cRef;  // AddRef Application Object if enumerator will outlive application object 
} 
 
 
STDMETHODIMP_(ULONG) 
CEnumVariant::Release(void) 
{ 
 
#ifdef _DEBUG    
    TCHAR ach[50]; 
    wsprintf(ach, TEXT("Ref = %ld, Enum\r\n"), m_cRef-1);  
    TRACE_OUT((ach));
#endif   
     
    if(--m_cRef == 0) 
    { 
        delete this; 
        return 0; 
    } 
    return m_cRef; 
} 
 
/* 
 * CEnumVariant::Next 
 * 
 * Purpose: 
 *  Retrieves the next cElements elements. Implements IEnumVARIANT::Next.  
 * 
 */ 
STDMETHODIMP 
CEnumVariant::Next(ULONG cElements, VARIANT FAR* pvar, ULONG FAR* pcElementFetched) 
{  
    HRESULT hr; 
    ULONG l; 
    long l1; 
    ULONG l2; 
     
    if (pcElementFetched != NULL) 
        *pcElementFetched = 0; 
         
    // Retrieve the next cElements elements. 
    for (l1=m_lCurrent, l2=0; l1<(long)(m_lLBound+m_cElements) && l2<cElements; l1++, l2++) 
    { 
       hr = SafeArrayGetElement(m_psa, &l1, &pvar[l2]);  
       if (FAILED(hr)) 
           goto error;  
    } 
    // Set count of elements retrieved 
    if (pcElementFetched != NULL) 
        *pcElementFetched = l2; 
    m_lCurrent = l1; 
     
    return  (l2 < cElements) ? S_FALSE : NOERROR; 
 
error: 
    for (l=0; l<cElements; l++) 
        VariantClear(&pvar[l]); 
    return hr;     
} 
 
/* 
 * CEnumVariant::Skip 
 * 
 * Purpose: 
 *  Skips the next cElements elements. Implements IEnumVARIANT::Skip.  
 * 
 */ 
STDMETHODIMP 
CEnumVariant::Skip(ULONG cElements) 
{    
    m_lCurrent += cElements;  
    if (m_lCurrent > (long)(m_lLBound+m_cElements)) 
    { 
        m_lCurrent =  m_lLBound+m_cElements; 
        return S_FALSE; 
    }  
    else return NOERROR; 
} 
 
/* 
 * CEnumVariant::Reset 
 * 
 * Purpose: 
 *  Resets the current element in the enumerator to the beginning. Implements IEnumVARIANT::Reset.  
 * 
 */ 
STDMETHODIMP 
CEnumVariant::Reset() 
{  
    m_lCurrent = m_lLBound; 
    return NOERROR; 
} 
 
/* 
 * CEnumVariant::Clone 
 * 
 * Purpose: 
 *  Creates a copy of the current enumeration state. Implements IEnumVARIANT::Clone.  
 * 
 */ 
STDMETHODIMP 
CEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum) 
{ 
    CEnumVariant FAR* penum = NULL; 
    HRESULT hr; 
     
    *ppenum = NULL; 
     
    hr = CEnumVariant::Create(m_psa, m_cElements, &penum); 
    if (FAILED(hr)) 
        goto error;         
    penum->AddRef(); 
    penum->m_lCurrent = m_lCurrent;  
     
    *ppenum = penum;         
    return NOERROR; 
      
error: 
    if (penum) 
        penum->Release(); 
    return hr;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\enumvar.h ===
/*++ 
 
Copyright (c) 1996 Microsoft Corporation 
 
Module Name: 
 
    CEnumVar.h 
 
Abstract: 
 
Author: 
 
Environment: 
 
    User mode 
 
Revision History : 
 
--*/ 
#ifndef _CENUMVAR_H_ 
#define _CENUMVAR_H_ 
 
class FAR CEnumVariant : public IEnumVARIANT 
{ 
public: 
    // IUnknown methods 
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj) ; 
    STDMETHOD_(ULONG, AddRef)() ; 
    STDMETHOD_(ULONG, Release)() ; 
 
    // IEnumVARIANT methods 
    STDMETHOD(Next)(ULONG cElements, 
                    VARIANT FAR* pvar, 
                    ULONG FAR* pcElementFetched); 
    STDMETHOD(Skip)(ULONG cElements); 
    STDMETHOD(Reset)(); 
    STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppenum); 
 
    CEnumVariant(); 
    ~CEnumVariant(); 
 
	static HRESULT Create(SAFEARRAY FAR* psa, ULONG cElements, CEnumVariant** ppenumvariant);


private: 
    ULONG m_cRef; 

    ULONG m_cElements;
    long m_lLBound;
    long m_lCurrent;
	SAFEARRAY* m_psa;

}; 
 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\floatbar.cpp ===
// File: floatbar.cpp

#include "precomp.h"

#include "global.h"
#include "ConfRoom.h"
#include "cmd.h"
#include "FloatBar.h"
#include "resource.h"
#include "ConfPolicies.h"

CFloatToolbar::CFloatToolbar(CConfRoom* pcr):
	m_pConfRoom		(pcr),
	m_hwnd			(NULL),
	m_hwndT			(NULL),
	m_hBmp			(NULL),
    m_fInPopup      (FALSE)
{
	TRACE_OUT(("Constructing CFloatToolbar"));
}

CFloatToolbar::~CFloatToolbar()
{
	TRACE_OUT(("Destructing CFloatToolbar"));

    ASSERT(!m_fInPopup);

	if (NULL != m_hBmp)
	{
		::DeleteObject(m_hBmp);
	}
	
	if (NULL != m_hwnd)
	{
		// bug 1450: don't destroy the window inside the notification,
		// instead, use PostMessage() to insure that we return from the
		// WM_NOTIFY message before the window is destroyed:
		::PostMessage(m_hwnd, WM_CLOSE, 0L, 0L);
		// DestroyWindow(m_hwnd);
	}

}

/****************************************************************************
*
*    CLASS:    CFloatToolbar
*
*    MEMBER:   FloatWndProc(HWND, unsigned, WORD, LONG)
*
*    PURPOSE:
*
****************************************************************************/

LRESULT CALLBACK CFloatToolbar::FloatWndProc(
	HWND hWnd,                /* window handle                   */
	UINT message,             /* type of message                 */
	WPARAM wParam,            /* additional information          */
	LPARAM lParam)            /* additional information          */
{
	CFloatToolbar* pft;
	LPCREATESTRUCT lpcs;

	switch (message)
	{
		case WM_CREATE:
		{
			TRACE_OUT(("Float Window created"));
			
			lpcs = (LPCREATESTRUCT) lParam;
			pft = (CFloatToolbar*) lpcs->lpCreateParams;
			ASSERT(pft);
			::SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) pft);

			const COLORMAP MyColorMap[] =
			{
				{TOOLBAR_MASK_COLOR,		::GetSysColor(COLOR_BTNFACE)},     // bright grey
				{TOOLBAR_HIGHLIGHT_COLOR,	::GetSysColor(COLOR_BTNHIGHLIGHT)},// white
			};
			pft->m_hBmp = ::CreateMappedBitmap(	GetInstanceHandle(),
												IDB_POPUPBAR,
												0,
												(LPCOLORMAP) MyColorMap,
												2);

            CConfRoom *  pcr = GetConfRoom();

            BYTE bASState   = (pcr && pcr->IsSharingAllowed()) ? TBSTATE_ENABLED : 0;
			BYTE bChatState = (pcr && pcr->IsChatAllowed()) ? TBSTATE_ENABLED : 0;
            BYTE bWBState   = (pcr && pcr->IsNewWhiteboardAllowed()) ? TBSTATE_ENABLED : 0;
            BYTE bFTState   = (pcr && pcr->IsFileTransferAllowed()) ? TBSTATE_ENABLED : 0;

			TBBUTTON tbFloatButtonAry[] =
			{
				{ ShareBitmapIndex     , ID_TB_SHARING      , bASState,     TBSTYLE_BUTTON, 0, -1 },
				{ ChatBitmapIndex      , ID_TB_CHAT         , bChatState,   TBSTYLE_BUTTON, 0, -1 },
				{ WhiteboardBitmapIndex, ID_TB_NEWWHITEBOARD, bWBState,     TBSTYLE_BUTTON, 0, -1 },
				{ FTBitmapIndex        , ID_TB_FILETRANSFER , bFTState,     TBSTYLE_BUTTON, 0, -1 },
			} ;

			ASSERT(pft->m_pConfRoom);

			pft->m_hwndT = CreateToolbarEx(hWnd,
										WS_CHILD | WS_VISIBLE | CCS_NODIVIDER |
										TBSTYLE_FLAT | TBSTYLE_TOOLTIPS | CCS_ADJUSTABLE,
										ID_FLOAT_TOOLBAR,
										NUM_FLOATBAR_TOOLBAR_BITMAPS,
										NULL,					// no instance
										(UINT_PTR) pft->m_hBmp,		// bitmap handle
										tbFloatButtonAry,		// buttons
										ARRAY_ELEMENTS(tbFloatButtonAry),
										16, 16,					// button sizes
										16, 16,					// bitmap sizes
										sizeof(TBBUTTON));

			ASSERT(pft->m_hwndT);
			
			// Put buttons in the correct state:
			pft->UpdateButtons();
			
			// Make the toolbar control window active so we can insure we will get a
			// WM_ACTIVATE when the user clicks somewhere off the toolbar
			::SetForegroundWindow(pft->m_hwndT);

			break;
		}

		case WM_ACTIVATE:
		{
			// Click outside the toolbar:
			pft = (CFloatToolbar*) ::GetWindowLongPtr(hWnd, GWLP_USERDATA);

            //
            // Kill the toolbar if we're not in the middle of handling the
            // popup menu with the list of apps to share.  In that case,
            // activation will cancel menu mode and we'll get a chance to
            // kill ourselves after we come back.
            //
            // We don't want to because COMCTL32 will trash our heap.  It
            // can't handle the toolbar window and structure going away
            // while processing a TBN_DROPDOWN notification.  When we return
            // back it will try to use the now-freed window data.
            //
            // Yes, we post ourselves a WM_CLOSE on destroy, but with a
            // message box up or other things, this could easily be
            // processed long before menu processing returns.
            //
			if ((NULL != pft) &&
                (!pft->m_fInPopup) &&
                (NULL != pft->m_hwnd) &&
                (NULL != pft->m_hwndT))
			{
				// NULL out the object pointer:
				::SetWindowLongPtr(hWnd, GWLP_USERDATA, 0L);
				delete pft;
			}
			break;
		}
		
		case WM_NOTIFY:
		{
			// BUGBUG: Copied from CConfRoom : put this is a central location:
			LPNMHDR pnmh = (LPNMHDR) lParam;
			
			if (TTN_NEEDTEXT == pnmh->code)
			{
				LPTOOLTIPTEXT lpToolTipText = (LPTOOLTIPTEXT)lParam;
				if (0 == (TTF_IDISHWND & lpToolTipText->uFlags))
				{
					lpToolTipText->hinst = ::GetInstanceHandle();
					lpToolTipText->lpszText = (LPTSTR) lpToolTipText->hdr.idFrom;
				}
			}
			break;
		}

		case WM_COMMAND:
		{
			TRACE_OUT(("Float Window command wp=0x%x", wParam));
			
			pft = (CFloatToolbar*) ::GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if (NULL != pft)
			{
                if (NULL != pft->m_pConfRoom)
                {
                    ::PostMessage(pft->m_pConfRoom->GetTopHwnd(), WM_COMMAND,
                        wParam, lParam);
                }

                //
                // If we're in the middle of the popup, don't kill ourself.
                // We wait until the stack unwinds back above.
                //
                if (!pft->m_fInPopup)
                {
    				// Dismiss the floating toolbar window:
	    			// NULL out the object pointer:
		    		::SetWindowLongPtr(hWnd, GWLP_USERDATA, 0L);
				    delete pft;
                }
			}
			break;
		}

		default:
		{
			return ::DefWindowProc(hWnd, message, wParam, lParam);
		}
	}
	return FALSE;
}

/****************************************************************************
*
*    CLASS:    CFloatToolbar
*
*    MEMBER:   Create(POINT ptClickPos)
*
*    PURPOSE:  Creates a floating toolbar window
*
****************************************************************************/

HWND CFloatToolbar::Create(POINT ptClickPos)
{
	// BUGBUG: move these defines once the size is finalized
	static const int TOOLBAR_WIDTH  = 6 + 23 * NUM_FLOATBAR_STANDARD_TOOLBAR_BUTTONS;
	static const int TOOLBAR_HEIGHT = 6 + 22 * 1;

	HWND hwndDesktop = GetDesktopWindow();
	RECT rctDesktop;

	if (NULL != hwndDesktop)
	{
		if (GetWindowRect(hwndDesktop, &rctDesktop))
		{
			// First attempt will be to center the toolbar horizontally
			// with respect to the mouse position and place it directly
			// above vertically.

			int xPos = ptClickPos.x - (TOOLBAR_WIDTH / 2);
			int yPos = ptClickPos.y - (TOOLBAR_HEIGHT);

			// If we are too high on the screen (the taskbar is probably
			// docked on top), then use the click position as the top of
			// where the toolbar will appear.
			
			if (yPos < 0)
			{
				yPos = ptClickPos.y;
			}

			// Repeat the same logic for the horizontal position
			if (xPos < 0)
			{
				xPos = ptClickPos.x;
			}

			// If the toolbar if off the screen to the right, then right-justify it
			if (xPos > (rctDesktop.right - TOOLBAR_WIDTH))
			{
				xPos = ptClickPos.x - TOOLBAR_WIDTH;
			}

			m_hwnd = CreateWindowEx(WS_EX_PALETTEWINDOW,
									g_szFloatWndClass,
									g_szEmpty,
									WS_POPUP | WS_VISIBLE | WS_DLGFRAME,
									xPos, yPos,
									TOOLBAR_WIDTH, TOOLBAR_HEIGHT,
									NULL,
									NULL,
									_Module.GetModuleInstance(),
									(LPVOID) this);


			return m_hwnd;
		}
	}

	// Something went wrong
	return NULL;
}

/****************************************************************************
*
*    CLASS:    CFloatToolbar
*
*    MEMBER:   UpdateButtons()
*
*    PURPOSE:  Puts the toolbar buttons in their correct state
*
****************************************************************************/

BOOL CFloatToolbar::UpdateButtons()
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dstest.cpp ===
#include "precomp.h"
#include <confreg.h>
#include "audiowiz.h"
#include <dsound.h>
#include <mmsystem.h>
#include "wavedev.h"
#include <nmdsprv.h>

#include "dstest.h"

// assume 10 direct sound devices as a max
#define MAX_DS_DEVS 10

// directsound functions
typedef HRESULT (WINAPI *LPFNDSCREATE)(const GUID *, LPDIRECTSOUND *, IUnknown FAR *);
typedef HRESULT (WINAPI *LPFNDSENUM)(LPDSENUMCALLBACKA , LPVOID);

// directsound capture functions
typedef HRESULT (WINAPI *DS_CAP_CREATE)(LPGUID, LPDIRECTSOUNDCAPTURE *, LPUNKNOWN);
typedef HRESULT (WINAPI *DS_CAP_ENUM)(LPDSENUMCALLBACKA, LPVOID);


static HRESULT MapWaveOutIdToGuid(UINT waveOutId, GUID *pGuid, LPFNDSCREATE dsCreate, LPFNDSENUM dsEnum);
static HRESULT MapWaveInIdToGuid(UINT waveInId, GUID *pGuid, DS_CAP_CREATE dscCreate, DS_CAP_ENUM dscEnum);




struct GuidDescription
{
	GUID guid;
	BOOL fAllocated;
};

static GuidDescription guidList_DS[MAX_DS_DEVS];
static int nGList_DS = 0;


static GuidDescription guidList_DSC[MAX_DS_DEVS];
static int nGList_DSC = 0;



static BOOL CALLBACK DSEnumCallback(GUID FAR * lpGuid, LPTSTR lpstrDescription,
                    LPTSTR lpstrModule, LPVOID lpContext)
{
	GuidDescription *pList;
	int *pListSize;

	if (lpContext)
	{
		pList = guidList_DS;
		pListSize = &nGList_DS;
	}
	else
	{
		pList = guidList_DSC;
		pListSize = &nGList_DSC;
	}

	if (lpGuid)
	{
		pList[*pListSize].guid = *lpGuid;
	}
	else
	{
		pList[*pListSize].guid = GUID_NULL;
	}

	pList->fAllocated = FALSE;
//	pList->szDescription = new TCHAR[lstrlen(lpstrDescription) + 1];
//	if (pList->szDescription)
//	{
//		lstrcpy(pList->szDescription, lpstrDescription);
//	}	

	*pListSize = *pListSize + 1;

	if ((*pListSize) < MAX_DS_DEVS)
		return TRUE;
	return FALSE;
}








// returns a set of flags (see dstest.h) indicating full duplex
// capabilities
UINT DirectSoundCheck(UINT waveInID, UINT waveOutID, HWND hwnd)
{
	BOOL bRet;
	HRESULT hr;
	HINSTANCE hDSI;
	LPFNDSCREATE dsCreate;
	LPFNDSENUM dsEnum;
	GUID dsguid, dscguid;
	LPDIRECTSOUND pDirectSound = NULL;
	MMRESULT mmr;
	int nRetVal = 0;
	DSBUFFERDESC dsBufDesc;
	LPDIRECTSOUNDBUFFER pDirectSoundBuffer;
	WAVEFORMATEX waveFormat = {WAVE_FORMAT_PCM,1,8000,16000,2,16,0};
	DS_CAP_CREATE dsCapCreate = NULL;
	DS_CAP_ENUM dsCapEnum = NULL;
	DSCBUFFERDESC dscBufDesc;
	LPDIRECTSOUNDCAPTURE pDirectSoundCapture=NULL;
	LPDIRECTSOUNDCAPTUREBUFFER pDSCBuffer = NULL;

    //
    // If changing DirectSound is prevented by policy and the current
    // setting is off, skip the test.  If the setting is on, we always
    // want to perform the test in case the system is no longer DS capable.
    //
    RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
    if (rePol.GetNumber(REGVAL_POL_NOCHANGE_DIRECTSOUND, DEFAULT_POL_NOCHANGE_DIRECTSOUND))
    {
        // changing DS is prevented by policy.
    	RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
        if (re.GetNumber(REGVAL_DIRECTSOUND, DSOUND_USER_DISABLED) != DSOUND_USER_ENABLED)
    	{
	    	return 0;
        }
	}

	PlaySound(NULL, NULL, NULL); // cancel any running playsound

	hDSI = NmLoadLibrary(TEXT("DSOUND.DLL"),TRUE);

	if (hDSI == NULL)
	{
		return 0; // direct sound is not available!
	}

	// check for Direct Sound 5 or higher
	// Existance of DirectSoundCapture functions implies DSound v.5
	dsEnum = (LPFNDSENUM)GetProcAddress(hDSI, "DirectSoundEnumerateA");
	dsCreate = (LPFNDSCREATE)GetProcAddress(hDSI, "DirectSoundCreate");
	dsCapEnum = (DS_CAP_ENUM)GetProcAddress(hDSI, "DirectSoundCaptureEnumerateA");
	dsCapCreate = (DS_CAP_CREATE)GetProcAddress(hDSI, TEXT("DirectSoundCaptureCreate"));

	if ((dsCapCreate == NULL) || (dsCreate == NULL) || (dsEnum == NULL) || (dsCapEnum==NULL))
	{
		FreeLibrary(hDSI);
		return 0;
	}

	hr = MapWaveOutIdToGuid(waveOutID, &dsguid, dsCreate, dsEnum);
	if (FAILED(hr))
	{
		WARNING_OUT(("Unable to map waveOutID to DirectSound guid!"));
		FreeLibrary(hDSI);
		return 0;
	}

	hr = MapWaveInIdToGuid(waveInID, &dscguid, dsCapCreate, dsCapEnum);
	if (FAILED(hr))
	{
		WARNING_OUT(("Unable to map waveOutID to DirectSound guid!"));
		FreeLibrary(hDSI);
		return 0;
	}

	nRetVal = DS_AVAILABLE;


	// Open DirectSound First
	hr = dsCreate((dsguid==GUID_NULL)?NULL:&dsguid, &pDirectSound, NULL);
	if (FAILED(hr))
	{
		WARNING_OUT(("Direct Sound failed to open by itself!"));
		FreeLibrary(hDSI);
		return 0;
	}

	// set cooperative level
	hr = pDirectSound->SetCooperativeLevel(hwnd, DSSCL_PRIORITY);
	if (hr != DS_OK)
	{
		WARNING_OUT(("Direct Sound: failed to set cooperative level"));
		pDirectSound->Release();
		FreeLibrary(hDSI);
		return 0;
	}


	ZeroMemory(&dsBufDesc,sizeof(dsBufDesc));
	dsBufDesc.dwSize = sizeof(dsBufDesc);
	dsBufDesc.dwFlags = DSBCAPS_PRIMARYBUFFER;
	hr = pDirectSound->CreateSoundBuffer(&dsBufDesc,&pDirectSoundBuffer,NULL);
	if (hr == S_OK)
	{
		pDirectSoundBuffer->SetFormat(&waveFormat);
	}
	else
	{
		WARNING_OUT(("Direct Sound: failed to set format"));
		pDirectSound->Release();
		FreeLibrary(hDSI);
		return 0;
	}



	// now attempt to open DirectSoundCapture
	hr = dsCapCreate((dscguid==GUID_NULL)?NULL:&dscguid, &pDirectSoundCapture, NULL);
	if (SUCCEEDED(hr))
	{
		dscBufDesc.dwSize = sizeof(dscBufDesc);
		dscBufDesc.dwFlags = 0;
		dscBufDesc.dwBufferBytes = 1000;
		dscBufDesc.dwReserved = 0;
		dscBufDesc.lpwfxFormat = &waveFormat;
		hr = pDirectSoundCapture->CreateCaptureBuffer(&dscBufDesc, &pDSCBuffer, NULL);
		if (SUCCEEDED(hr))
		{
			// full duplex is avaiable;
			nRetVal |= DS_FULLDUPLEX;
		}
	}

	if (pDSCBuffer)
	{
		pDSCBuffer->Release();
	}
	if (pDirectSoundCapture)
	{
		pDirectSoundCapture->Release();
	}

	pDirectSoundBuffer->Release();
	pDirectSound->Release();


	FreeLibrary(hDSI);

	return nRetVal;

}



HRESULT MapWaveOutIdToGuid(UINT waveOutID, GUID *pGuid, LPFNDSCREATE dsCreate, LPFNDSENUM dsEnum)
{
	waveOutDev waveOut(waveOutID);
	MMRESULT mmr;
	HRESULT hr;
	LPDIRECTSOUND pDS;
	DSCAPS dscaps;
	BOOL fEmulFound, bRet;
	int index;
	GUID *pIID;
	WAVEOUTCAPS waveOutCaps;

	if (waveOutID == WAVE_MAPPER || waveOutGetNumDevs()==1)
	{
		// we want the default or there is only one DS device, take the easy way out
		*pGuid =  GUID_NULL;
		return S_OK;
	}


	// The New way.  DirectX on Win98/NT 5 gives an IKsProperty interface
	// to generate the mapping correctly

	ZeroMemory(&waveOutCaps, sizeof(WAVEOUTCAPS));
	mmr = waveOutGetDevCaps(waveOutID, &waveOutCaps, sizeof(WAVEOUTCAPS));
	if (mmr == MMSYSERR_NOERROR)
	{
		hr = DsprvGetWaveDeviceMapping(waveOutCaps.szPname, FALSE, pGuid);
		if (SUCCEEDED(hr))
		{
			TRACE_OUT(("dstest.cpp: Succeeded in mapping Wave ID to DS guid through IKsProperty interface\r\n"));
			return hr;
		}
		// if we failed to make a mapping, fall through to the old code path
		WARNING_OUT(("dstest.cpp: Failed to map Wave ID to DS guid through IKsProperty interface\r\n"));
	}



	// the old way!
	// try to figure out which Guid maps to a wave id
	// Do this by opening the wave device corresponding to the wave id and then
	// all the DS devices in sequence and see which one fails.
	// Yes, this is a monstrous hack and clearly unreliable
	ZeroMemory(guidList_DS, sizeof(guidList_DS));
	nGList_DS = 0;

	hr = dsEnum((LPDSENUMCALLBACK)DSEnumCallback, (VOID*)TRUE);
	if (hr != DS_OK)
	{
		WARNING_OUT(("DirectSoundEnumerate failed\n"));
		return hr;
	}

	mmr = waveOut.Open(8000, 16);

	if (mmr != MMSYSERR_NOERROR)
	{
		return DSERR_INVALIDPARAM;
	}

	// now open all the DS devices in turn
	for (index = 0; index < nGList_DS; index++)
	{
		if (guidList_DS[index].guid==GUID_NULL)
			pIID = NULL;
		else
			pIID = &(guidList_DS[index].guid);
		hr = dsCreate(pIID, &pDS, NULL);
		if (hr != DS_OK)
		{
			guidList_DS[index].fAllocated = TRUE;
		}
		else
		{
			pDS->Release();
		}
	}

	waveOut.Close();

	hr = DSERR_ALLOCATED;

	dscaps.dwSize = sizeof(dscaps);
	fEmulFound = FALSE;
	// try opening the DS devices that failed the first time
	for (index = 0; index < nGList_DS; index++)
	{
		if (guidList_DS[index].fAllocated == TRUE)
		{
			if (guidList_DS[index].guid==GUID_NULL)
				pIID = NULL;
			else
				pIID = &(guidList_DS[index].guid);

			hr = dsCreate(pIID, &pDS, NULL);
			if (hr == DS_OK)
			{
				*pGuid = guidList_DS[index].guid;
				// get dsound capabilities.
				pDS->GetCaps(&dscaps);
				pDS->Release();
				if (dscaps.dwFlags & DSCAPS_EMULDRIVER)
					fEmulFound = TRUE;	// keep looking in case there's also a native driver
				else
					break;	// native DS driver. Look no further
					
			}
		}
	}

	if (fEmulFound)
		hr = DS_OK;
		
	if (hr != DS_OK)
	{
		WARNING_OUT(("Can't map id %d to DSound guid!\n", waveOutID));
		hr = DSERR_ALLOCATED;
	}

	return hr;
}





HRESULT MapWaveInIdToGuid(UINT waveInId, GUID *pGuid, DS_CAP_CREATE dscCreate, DS_CAP_ENUM dscEnum)
{

	HRESULT hr;
	waveInDev WaveIn(waveInId);
	WAVEINCAPS waveInCaps;
	UINT uNumWaveDevs;
	GUID guid = GUID_NULL;
	int nIndex;
	MMRESULT mmr;
	WAVEFORMATEX waveFormat = {WAVE_FORMAT_PCM, 1, 8000, 16000, 2, 16, 0};
	IDirectSoundCapture *pDSC=NULL;

	*pGuid = GUID_NULL;

	// only one wave device, take the easy way out
	uNumWaveDevs = waveInGetNumDevs();

	if ((uNumWaveDevs <= 1) || (waveInId == WAVE_MAPPER))
	{
		return S_OK;
	}

	// more than one wavein device
	// try to use the IKSProperty interface to map a WaveIN ID to
	// DirectSoundCaptureGuid
	// Win98 and Windows 2000 only.  (Probably will fail on Win95)

	mmr = waveInGetDevCaps(waveInId, &waveInCaps, sizeof(WAVEINCAPS));
	if (mmr == MMSYSERR_NOERROR)
	{
		hr = DsprvGetWaveDeviceMapping(waveInCaps.szPname, TRUE, &guid);
		if (SUCCEEDED(hr))
		{
			*pGuid = guid;
			return S_OK;
		}
	}


	// Use the old way to map devices

	ZeroMemory(guidList_DSC, sizeof(guidList_DSC));
	nGList_DSC = 0;


	hr = dscEnum((LPDSENUMCALLBACK)DSEnumCallback, NULL);
	if (hr != DS_OK)
	{
		WARNING_OUT(("DirectSoundCaptureEnumerate failed\n"));
		return hr;
	}



	//  hack approach to mapping the device to a guid
	mmr = WaveIn.Open(waveFormat.nSamplesPerSec, waveFormat.wBitsPerSample);
	if (mmr != MMSYSERR_NOERROR)
	{
		return S_FALSE;
	}

	// find all the DSC devices that fail to open
	for (nIndex = 0; nIndex < nGList_DSC; nIndex++)
	{
		guidList_DSC[nIndex].fAllocated = FALSE;

		if (guidList_DSC[nIndex].guid == GUID_NULL)
		{
			hr = dscCreate(NULL, &pDSC, NULL);
		}
		else
		{
			hr = dscCreate(&(guidList_DSC[nIndex].guid), &pDSC, NULL);
		}

		if (FAILED(hr))
		{
			guidList_DSC[nIndex].fAllocated = TRUE;
		}
		else
		{
			pDSC->Release();
			pDSC=NULL;
		}
	}

	WaveIn.Close();

	// scan through the list of allocated devices and
	// see which one opens
	for (nIndex = 0; nIndex < nGList_DSC; nIndex++)
	{
		if (guidList_DSC[nIndex].fAllocated)
		{
			if (guidList_DSC[nIndex].guid == GUID_NULL)
			{
				hr = dscCreate(NULL, &pDSC, NULL);
			}
			else
			{
				hr = dscCreate(&(guidList_DSC[nIndex].guid), &pDSC, NULL);
			}
			if (SUCCEEDED(hr))
			{
				// we have a winner
				pDSC->Release();
				pDSC = NULL;
				*pGuid = guidList_DSC[nIndex].guid;
				return S_OK;
			}
		}
	}


	// if we got to this point, it means we failed to map a device
	// just use GUID_NULL and return an error
	return S_FALSE;
}



// This function answers the question:
// we have full duplex and DirectSound, but do we really
// trust it to work well in FD-DS Mode ?  Returns TRUE if so,
// FALSE otherwise.

/*BOOL IsFDDSRecommended(UINT waveInId, UINT waveOutId)
{
	WAVEINCAPS waveInCaps;
	WAVEOUTCAPS waveOutCaps;
	MMRESULT mmr;
	TCHAR szRegKey[30];
	RegEntry re(AUDIODEVCAPS_KEY, HKEY_LOCAL_MACHINE, FALSE);
	LONG lCaps;

	mmr = waveInGetDevCaps(waveInId, &waveInCaps, sizeof(waveInCaps));
	if (mmr != MMSYSERR_NOERROR)
	{
		return FALSE;
	}

	mmr = waveOutGetDevCaps(waveOutId, &waveOutCaps, sizeof(waveOutCaps));
	if (mmr != MMSYSERR_NOERROR)
	{
		return FALSE;
	}

	// assume that if the two devices are made by different manufacturers
	// then DirectSound can always be enabled (because it's two serpate devices)
	if (waveInCaps.wMid != waveOutCaps.wMid)
	{
		return TRUE;
	}


	// does a key for this specific product exist
	wsprintf(szRegKey, "Dev-%d-%d", waveInCaps.wMid, waveInCaps.wPid);
	lCaps = re.GetNumber(szRegKey, -1);

	if (lCaps == -1)
	{
		// maybe we have a string for all of the products
		// by this manufacturer
		wsprintf(szRegKey, "Dev-%d", waveInCaps.wMid);
		lCaps = re.GetNumber(szRegKey, -1);
	}

	if (lCaps == -1)
	{
		// it's an unknown device, we can't trust it to be
		// full duplex - direct sound
		return FALSE;
	}

	
	// examine this devices caps
	if (lCaps & DEVCAPS_AUDIO_FDDS)
	{
		return TRUE;
	}

	return FALSE;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\floatbar.h ===
/****************************************************************************
*
*    FILE:     FloatTBar.h
*
*    CREATED:  Chris Pirich (ChrisPi) 7-27-95
*
****************************************************************************/

class CFloatToolbar
{
private:
	enum { 
			IndexShareBtn,
			IndexChatBtn,
			IndexWBBtn,
			IndexFTBtn,
			NUM_FLOATBAR_STANDARD_TOOLBAR_BUTTONS
	};

	enum {
			ShareBitmapIndex,
			WhiteboardBitmapIndex,
			ChatBitmapIndex,
			FTBitmapIndex,
				// This has to be the last index for 
				// the count to be correct...
			NUM_FLOATBAR_TOOLBAR_BITMAPS

	};


	HWND		m_hwndT;
	HBITMAP		m_hBmp;
	CConfRoom*	m_pConfRoom;
    BOOL        m_fInPopup;

	BOOL		UpdateButtons();
public:
	HWND		m_hwnd;

	// Methods:
				CFloatToolbar(CConfRoom* pcr);
				~CFloatToolbar();
	HWND		Create(POINT ptClickPos);
	static LRESULT CALLBACK FloatWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\friends.h ===
/****************************************************************************
*
*    FILE:     Friends.h
*
*    CONTENTS: Friends-Related Utility Function Prototypes
*
****************************************************************************/

#ifndef _FRIENDS_H_
#define _FRIENDS_H_
#include <clink.h>

// Functions:

#endif  // ! _FRIENDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\fthook.h ===
#ifndef __FtHook_h__
#define __FtHook_h__

#include "IMbFt.h"

namespace CFt
{

	// These are per-process/SDK session
HRESULT InitFt();
bool IsFtActive();
HRESULT EnsureLoadFtApplet();
HRESULT StartNewConferenceSession();
void CloseFtApplet();
bool IsMemberInFtSession(T120NodeID gccID);

HRESULT SendFile(LPCSTR pszFileName,
				 T120NodeID gccID,
				 MBFTEVENTHANDLE *phEvent,
				 MBFTFILEHANDLE *phFile);

HRESULT CancelFt(MBFTEVENTHANDLE hEvent, MBFTFILEHANDLE hFile);
HRESULT AcceptFileOffer(MBFT_FILE_OFFER *pOffer, LPCSTR pszRecvFileDir, LPCSTR pszFileName);
HRESULT ShowFtUI();


HRESULT Advise(IMbftEvents* pSink);
HRESULT UnAdvise(IMbftEvents* pSink);

///////////////////////////////////////////////////////////////////////
//

class CFtEvents : public IMbftEvents
{

public:

	// IMbftEvent Interface
	STDMETHOD(OnInitializeComplete)(void);
	STDMETHOD(OnPeerAdded)(MBFT_PEER_INFO *pInfo);
	STDMETHOD(OnPeerRemoved)(MBFT_PEER_INFO *pInfo);
	STDMETHOD(OnFileOffer)(MBFT_FILE_OFFER *pOffer);
	STDMETHOD(OnFileProgress)(MBFT_FILE_PROGRESS *pProgress);
	STDMETHOD(OnFileEnd)(MBFTFILEHANDLE hFile);
	STDMETHOD(OnFileError)(MBFT_EVENT_ERROR *pEvent);
	STDMETHOD(OnFileEventEnd)(MBFTEVENTHANDLE hEvent);
	STDMETHOD(OnSessionEnd)(void);
};

}; // end namespace CFt

#endif // __FtHook_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\fthook.cpp ===
#include "precomp.h"
#include "FtHook.h"
#include "NmManager.h"
#include "NmConference.h"
#include "iAppLdr.h"

namespace CFt
{

static CFtEvents*					s_pFtEventsObj = NULL;
static IMbftControl*				s_pMbftControl = NULL;
static bool							s_bInitialized = false;
static CSimpleArray<IMbftEvents*>*	s_pEventSinkArray = NULL;
static CSimpleArray<T120NodeID>*	s_pFtMemberList = NULL;
static HINSTANCE					s_hmsconfft = NULL;

PFNCREATEMBFTOBJECT pfnFT_CreateInterface;

HRESULT InitFt()
{
	pfnFT_CreateInterface = NULL;
	s_pEventSinkArray = new CSimpleArray<IMbftEvents*>;
	s_pFtMemberList = new CSimpleArray<T120NodeID>;
	s_pFtEventsObj = new CFtEvents();
	return (s_pFtEventsObj ? S_OK : E_OUTOFMEMORY);
}

bool IsFtActive()
{
	return s_bInitialized && s_pMbftControl;
}

HRESULT EnsureLoadFtApplet()
{
	HRESULT hr = S_FALSE;

	if(T120_NO_ERROR == ::T120_LoadApplet(APPLET_ID_FT,
										  FALSE,
										  0,    
										  _Module.InitControlMode(),
										  NULL))

	{
		s_bInitialized = true;
		hr = S_OK;
	}

	return hr;
}

HRESULT ShowFtUI()
{
	if(T120_NO_ERROR == ::T120_LoadApplet(APPLET_ID_FT,
										  TRUE,         
										  0,            
										  FALSE,		
										  NULL))		
	{
		s_bInitialized = true;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT StartNewConferenceSession()
{
	HRESULT hr = E_FAIL;
	if(s_bInitialized && !s_pMbftControl)
	{
		if (S_OK == EnsureLoadFtApplet())
		{
			ASSERT (s_hmsconfft == NULL);
			ASSERT (pfnFT_CreateInterface == NULL);

			s_hmsconfft = NmLoadLibrary(_T("nmft.dll"),FALSE);
		
			if (s_hmsconfft)
			{
				pfnFT_CreateInterface = (PFNCREATEMBFTOBJECT) GetProcAddress(s_hmsconfft, _T("FT_CreateInterface"));
				if (pfnFT_CreateInterface)
				{
					hr = pfnFT_CreateInterface(&s_pMbftControl, s_pFtEventsObj);
					ASSERT (SUCCEEDED(hr));
					ASSERT (s_pMbftControl);
				}
				FreeLibrary(s_hmsconfft);
			}
			s_hmsconfft = NULL;
			pfnFT_CreateInterface = NULL;
		}
	}

	return hr;
}

void CloseFtApplet()
{
	if(s_pEventSinkArray)
	{
		ASSERT(0 == s_pEventSinkArray->GetSize());
		delete s_pEventSinkArray;
		s_pEventSinkArray = NULL;
	}

	if(s_pFtMemberList)
	{
		delete s_pFtMemberList;
		s_pFtMemberList = NULL;
	}
	if(s_pFtEventsObj)
	{
		delete s_pFtEventsObj;
		s_pFtEventsObj = NULL;
	}

	if(s_bInitialized)
	{
		s_bInitialized = false;
	}
}

bool IsMemberInFtSession(T120NodeID gccID)
{
	if(s_pFtMemberList)		
	{
		return (-1 != s_pFtMemberList->Find(gccID));
	}
	
	return false;
}

HRESULT Advise(IMbftEvents* pSink)
{
	HRESULT hr = EnsureLoadFtApplet();

	if(s_pEventSinkArray)
	{
		ASSERT(-1 == s_pEventSinkArray->Find(pSink));
		s_pEventSinkArray->Add(pSink);
		hr = S_OK;
	}

	return hr;
}

HRESULT UnAdvise(IMbftEvents* pSink)
{
	HRESULT hr = E_UNEXPECTED;
	
	if(s_pEventSinkArray)
	{
		s_pEventSinkArray->Remove(pSink);
		hr = S_OK;
	}

	return hr;
}

HRESULT CancelFt(MBFTEVENTHANDLE hEvent, MBFTFILEHANDLE hFile)
{
	if(s_pMbftControl)
	{
		s_pMbftControl->CancelFt(hEvent, hFile);
		return S_OK;
	}

	return E_FAIL;
}

HRESULT AcceptFileOffer(MBFT_FILE_OFFER *pOffer, LPCSTR pszRecvFileDir, LPCSTR pszFileName)
{
	if(s_pMbftControl)
	{
		return s_pMbftControl->AcceptFileOffer(pOffer, pszRecvFileDir, pszFileName);
	}

	return E_FAIL;
}


HRESULT SendFile(LPCSTR pszFileName,
				 T120NodeID gccID,
				 MBFTEVENTHANDLE *phEvent,
				 MBFTFILEHANDLE *phFile)
{
	if(s_pMbftControl)
	{
		return s_pMbftControl->SendFile(pszFileName, gccID, phEvent, phFile);
	}
	
	return E_FAIL;
}



	// IMbftEvent Interface
STDMETHODIMP CFtEvents::OnInitializeComplete(void)
{
	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnInitializeComplete();
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnPeerAdded(MBFT_PEER_INFO *pInfo)
{
	if(s_pFtMemberList)
	{
		if(-1 == s_pFtMemberList->Find(pInfo->NodeID))
		{
			s_pFtMemberList->Add(pInfo->NodeID);
		}
	}

	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnPeerAdded(pInfo);
		}
	}

	return S_OK;
}

STDMETHODIMP CFtEvents::OnPeerRemoved(MBFT_PEER_INFO *pInfo)
{

	if(s_pFtMemberList)
	{
		s_pFtMemberList->Remove(pInfo->NodeID);
	}

	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnPeerRemoved(pInfo);
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnFileOffer(MBFT_FILE_OFFER *pOffer)
{
	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnFileOffer(pOffer);
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnFileProgress(MBFT_FILE_PROGRESS *pProgress)
{
	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnFileProgress(pProgress);
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnFileEnd(MBFTFILEHANDLE hFile)
{
	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnFileEnd(hFile);
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnFileError(MBFT_EVENT_ERROR *pEvent)
{
	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnFileError(pEvent);
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnFileEventEnd(MBFTEVENTHANDLE hEvent)
{
	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnFileEventEnd(hEvent);
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnSessionEnd(void)
{
	if(s_pFtMemberList)
	{
		s_pFtMemberList->RemoveAll();
	}

	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnSessionEnd();
		}
	}

	if(s_pMbftControl)
	{
		s_pMbftControl->ReleaseInterface();
		s_pMbftControl = NULL;
	}

	return S_OK;
}


}; // end namespace CFt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\gal.h ===
// File: GAL.h

#ifndef __GAL_h__
#define __GAL_h__

#include "richaddr.h"

#include <mapix.h>

    // lst.h contains the template list class that we are using
#include "lst.h"
#include "calv.h"


    // Various debugging macros to facilitate testing
    // if the TESTING_CGAL macro is defined as non-zero there
    // is significant overhaed in exhaustively testing the CGAL stuff...
#ifdef _DEBUG
    #define TESTING_CGAL 1
#else 
    #define TESTING_CGAL 0
#endif // _DEBUG
   
#if TESTING_CGAL 
    #define VERIFYCACHE _VerifyCache( );
    #define TESTCGAL    _Test();
#else 
    #define VERIFYCACHE
    #define TESTCGAL
#endif // TESTING_CGAL

#define CONSTANT( x ) enum{ x }


#define MAKE_GAL_ERROR( e )         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, e )
#define GAL_E_GAL_NOT_FOUND                 MAKE_GAL_ERROR( 0x0001 )
#define GAL_E_GETROWCOUNT_FAILED            MAKE_GAL_ERROR( 0x0002 )
#define GAL_E_SETCOLUMNS_FAILED             MAKE_GAL_ERROR( 0x0003 )
#define GAL_E_FINDROW_FAILED                MAKE_GAL_ERROR( 0x0004 )
#define GAL_E_SEEKROW_FAILED                MAKE_GAL_ERROR( 0x0005 )
#define GAL_E_SEEKROWAPPROX_FAILED          MAKE_GAL_ERROR( 0x0006 )
#define GAL_E_CREATEBOOKMARK_FAILED         MAKE_GAL_ERROR( 0x0007 )
#define GAL_E_QUERYROWS_FAILED              MAKE_GAL_ERROR( 0x0008 )
#define GAL_E_FREEBOOKMARK_FAILED           MAKE_GAL_ERROR( 0x0009 )
#define GAL_E_NOINSTANCEKEY                 MAKE_GAL_ERROR( 0x000a )
#define GAL_E_NOENTRYID                     MAKE_GAL_ERROR( 0x000b )

    // CGAL is the Exchange Global Address List View....

class CGAL : public CALV
{

public: // Data Types

        // A CGalEntry holds information about an individual entry in the GAL
    class CGalEntry {
    private:
        LPTSTR      m_szName;					// PR_DISPLAY_NAME
        LPTSTR      m_szEMail;					// PR_ACCOUNT
        SBinary     m_EntryID;					// PR_ENTRYID
        SBinary     m_InstanceKey;				// PR_INSTANCE_KEY
        ULONG       m_ulDisplayType;			// PR_DISPLAY_TYPE
		LPTSTR      m_szBusinessTelephoneNum;	// PR_BUSINESS_TELEPHONE_NUMBER;

    public: // Constructiors / destructiors / initializers / assignment
        CGalEntry( void );
        CGalEntry( const CGalEntry& r );
        CGalEntry( LPCTSTR szName, LPCTSTR szEMail, SBinary& rInstanceKey, SBinary& rEntryID, ULONG ulDisplayType, LPCTSTR szBusinessTelephoneNum );
        CGalEntry( LPCTSTR szName, LPCTSTR szEMail );
        ~CGalEntry( void );

        CGalEntry& operator=( const CGalEntry& r );

            // Get functions
        LPCTSTR GetName( void ) const				{ return m_szName;					}
        LPCTSTR GetEMail( void ) const				{ return m_szEMail;					}
		LPCTSTR GetBusinessTelephone( void ) const	{ return m_szBusinessTelephoneNum;	}
        const SBinary& GetInstanceKey( void ) const { return m_InstanceKey;				}
        const SBinary& GetEntryID( void ) const     { return m_EntryID;					}
        ULONG GetDisplayType( void ) const          { return m_ulDisplayType;			}

            // Comparison Operators
        bool operator==( const CGalEntry& r ) const;
        bool operator!=( const CGalEntry& r ) const { return !( *this == r ); }
        bool operator>=( LPCTSTR sz ) const;
        bool operator<=( LPCTSTR sz ) const;
        bool operator<( LPCTSTR sz ) const;
  
    };

private: // Static Data

    enum ePropertyIndices { 
             NAME_PROP_INDEX = 0,
             ACCOUNT_PROP_INDEX,
             INSTANCEKEY_PROP_INDEX,
             ENTRYID_PROP_INDEX,
             DISPLAY_TYPE_INDEX,
			 BUSINESS_PHONE_NUM_PROP_INDEX,
             NUM_PROPS
           };

    enum eAsyncLogonState {
        AsyncLogonState_Idle,
        AsyncLogonState_LoggingOn,
        AsyncLogonState_LoggedOn,
        AsyncLogonState_Error

    };

    CONSTANT( NUM_LISTVIEW_PAGES_IN_CACHE   = 15 );
    CONSTANT( INVALID_CACHE_INDEX           = -1 );
    CONSTANT( DefaultMaxCacheSize           = 1000 );
    CONSTANT( DefaultBlockSize              = 50 );

    static LPCTSTR         msc_szNoDisplayName;
    static LPCTSTR         msc_szNoEMailName;
	static LPCTSTR         msc_szNoBusinessTelephoneNum;
    static const char*          msc_szNMExchangeAtrValue;
    static const char*          msc_szNMPolRegKey;
    static const char*          msc_szDefaultILSServerRegKey;
    static const char*          msc_szDefaultILSServerValue;
    static const char*          msc_szSMTPADDRESSNAME;

private: // Data
	HRESULT                     m_hrGALError;
	CGalEntry                   msc_ErrorEntry_NoGAL; 
	HWND						m_hWndListView;


        // Cache Stuff
    int                         m_nBlockSize;
    lst< CGalEntry* >           m_EntryCache;
    int                         m_IndexOfFirstItemInCache;
    int                         m_IndexOfLastItemInCache;
    bool                        m_bBeginningBookmarkIsValid;
    bool                        m_bEndBookmarkIsValid;
    BOOKMARK                    m_BookmarkOfFirstItemInCache;
    BOOKMARK                    m_BookmarkOfItemAfterLastItemInCache;
    int                         m_MaxCacheSize;
    int                         m_MaxJumpSize;
   
public: // Async globals (public so they can be accessed by static functions)
	static HINSTANCE            m_hInstMapi32DLL;
	static HANDLE               m_hEventEndAsyncThread;
	static HANDLE               m_hAsyncLogOntoGalThread;
	static eAsyncLogonState     m_AsyncLogonState;

	    // Mapi Interfaces
	static IAddrBook           *m_pAddrBook;
	static IMAPITable          *m_pContentsTable;
	static IMAPIContainer      *m_pGAL;
	static ULONG                m_nRows;

	static BOOL FLoadMapiFns(void);
	static VOID UnloadMapiFns(void);


public:
	CGAL();
	~CGAL();

	// CALV methods
	virtual VOID  ShowItems( HWND hwnd );
	virtual VOID  ClearItems(void);
	virtual BOOL  GetSzAddress(LPTSTR psz, int cchMax, int iItem);
	virtual ULONG OnListFindItem( LPCTSTR szPartialMatchingString ); 
	virtual void  OnListGetColumn1Data( int iItemIndex, int cchTextMax, LPTSTR szBuf );
	virtual void  OnListGetColumn2Data( int iItemIndex, int cchTextMax, LPTSTR szBuf );
	virtual void  OnListGetColumn3Data( int iItemIndex, int cchTextMax, TCHAR* szBuf );
	virtual VOID  CmdProperties( void );
	virtual void  OnListCacheHint( int indexFrom, int indexTo );
	virtual int   OnListGetImageForItem( int iIndex );
	virtual bool  IsItemBold( int index );
	virtual RAI * GetAddrInfo(void);


private: // Helper Fns
    DWORD _GetExchangeAttribute( void );

        // Helper fns to get GAL Entries
    CGalEntry* _GetEntry( int index );
    CGalEntry* _GetItemFromCache( int index );
    CGalEntry* _GetEntriesAtBeginningOfList( int index );
    CGalEntry* _GetEntriesAtEndOfList( int index );
    CGalEntry* _LongJumpTo( int index );
    bool _CreateEndBookmark( int index, lst< CGalEntry* >::iterator& IEntry );
    bool _CreateBeginningBookmark( void );
    int _FindItemInCache( LPCTSTR szPartialMatchString );
    void _ResetCache( void );
    HRESULT _MakeGalEntry( SRow& rRow, CGalEntry** ppEntry );
    HRESULT _KillExcessItemsFromFrontOfCache( void );
    HRESULT _KillExcessItemsFromBackOfCache( void );
    bool _GetSzAddressFromExchangeServer(int iItem, LPTSTR psz, int cchMax);
    void _CopyPropertyString( LPTSTR psz, SPropValue& rProp, int cchMax );
    HRESULT _SetCursorTo( LPCTSTR szPartialMatch );
    HRESULT _SetCursorTo( const SBinary& rInstanceKey );
    HRESULT _SetCursorTo( const CGalEntry& rEntry );

    
	bool _IsLoggedOn( void ) const { return AsyncLogonState_LoggedOn == m_AsyncLogonState; }
	HRESULT _GetPhoneNumbers( const SBinary& rEntryID, int* pcPhoneNumbers, LPTSTR** ppszPhoneNums );
	HRESULT _GetEmailNames( int* pnEmailNames, LPTSTR** ppszEmailNames, int iItem );

	// Async logon/logoff
	HRESULT _AsyncLogOntoGAL(void);
	static HRESULT _sAsyncLogOntoGal(void);
	static HRESULT _sAsyncLogoffGal(void);
	static DWORD CALLBACK _sAsyncLogOntoGalThreadfn(LPVOID);
	static HRESULT _sInitListViewAndGalColumns(HWND hwnd);

#if TESTING_CGAL 

    void _VerifyCache( void );    
    void _Test( void );

#endif // #if TESTING_CGAL 

};

// These should be removed...
#define msc_ErrorEntry_FindRowFailed        msc_ErrorEntry_NoGAL
#define msc_ErrorEntry_SeekRowFailed        msc_ErrorEntry_NoGAL
#define msc_ErrorEntry_SeekRowApproxFailed  msc_ErrorEntry_NoGAL
#define msc_ErrorEntry_CreateBookmarkFailed msc_ErrorEntry_NoGAL
#define msc_ErrorEntry_QueryRowsFailed      msc_ErrorEntry_NoGAL
#define msc_ErrorEntry_FreeBookmarkFailed   msc_ErrorEntry_NoGAL
#define msc_ErrorEntry_NoInstanceKeyFound   msc_ErrorEntry_NoGAL

#endif // __GAL_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\gencpl.cpp ===
// File: gencpl.cpp

#include "precomp.h"
#include <oprahcom.h>
#include "resource.h"
#include "help_ids.h"
#include "csetting.h"
#include "confwnd.h"
#include "conf.h"
#include "ConfCpl.h"
#include "ConfPolicies.h"
#include <nmremote.h>

extern int MessageBoxResource(HWND hwnd, UINT uMessage, UINT uTitle, UINT uFlags);


const int MAXPASSWORDLENGTH = 36;
const int MINPASSWORDLENGTH = 7;

INT_PTR CALLBACK RemotePasswordDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	HWND hOldPasswordText, hNewPasswordText, hVerificationText;
	int nOldPasswordLength, nNewPasswordLength, nVerificationLength;
	CHAR lpOldPassword[MAXPASSWORDLENGTH], lpNewPassword[MAXPASSWORDLENGTH], lpVerification[MAXPASSWORDLENGTH];
	WCHAR lpwszOldPassword[MAXPASSWORDLENGTH], lpwszNewPassword[MAXPASSWORDLENGTH];
	PBYTE pbHashedPassword=NULL;
	DWORD cbHashedPassword=0;
	
	PBYTE pbRegPassword = NULL;
	DWORD cbRegPassword;

	switch (iMsg)
	{
            case WM_INITDIALOG:
                SendDlgItemMessage(hDlg, IDC_EDITOLDPASSWORD, EM_LIMITTEXT,
                                   MAXPASSWORDLENGTH - 1, 0);
                SendDlgItemMessage(hDlg, IDC_EDITNEWPASSWORD, EM_LIMITTEXT,
                                   MAXPASSWORDLENGTH - 1, 0);
                SendDlgItemMessage(hDlg, IDC_EDITVERIFICATION, EM_LIMITTEXT,
                               MAXPASSWORDLENGTH - 1, 0);
                
                // If there's no old password, disable that UI
                {
                    RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
                    if ( 0 == reLM.GetBinary(REMOTE_REG_PASSWORD, (void **)&pbRegPassword))
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_EDITOLDPASSWORD), FALSE);
                        SetFocus(GetDlgItem(hDlg, IDC_EDITNEWPASSWORD));
                    }
                }
                
                return TRUE;
                
	case WM_COMMAND: 
		switch (LOWORD(wParam))
		{
		case IDOK: {
			RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
			CHash hashObject;
			
			hOldPasswordText = GetDlgItem(hDlg,IDC_EDITOLDPASSWORD);
			hNewPasswordText = GetDlgItem(hDlg,IDC_EDITNEWPASSWORD);
			hVerificationText = GetDlgItem(hDlg,IDC_EDITVERIFICATION);
			nOldPasswordLength = GetWindowText(hOldPasswordText,lpOldPassword,MAXPASSWORDLENGTH);
			MultiByteToWideChar(CP_ACP, 0, lpOldPassword, -1, lpwszOldPassword, MAXPASSWORDLENGTH);

			cbRegPassword = reLM.GetBinary(REMOTE_REG_PASSWORD, (void **)&pbRegPassword);

			// Decode password string
			cbHashedPassword = hashObject.GetHashedData((LPBYTE)lpwszOldPassword, 
								sizeof(WCHAR)*strlen(lpOldPassword), 
								(void **)&pbHashedPassword);

			if (0 != cbRegPassword && !(cbHashedPassword == cbRegPassword && 0 == memcmp(pbHashedPassword,pbRegPassword,cbHashedPassword))) {
				// Error Case - Old password incorrect.
				MessageBoxResource(hDlg,IDS_REMOTE_OLD_PASSWORD_WRONG_TEXT,IDS_REMOTE_OLD_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
				SetWindowText(hOldPasswordText,NULL);
				SetWindowText(hNewPasswordText,NULL);
				SetWindowText(hVerificationText,NULL);
				SetFocus(hOldPasswordText);
				break;
			}
			nNewPasswordLength = GetWindowText(hNewPasswordText,lpNewPassword,MAXPASSWORDLENGTH);
			nVerificationLength = GetWindowText(hVerificationText,lpVerification,MAXPASSWORDLENGTH);
			if (lstrcmp(lpNewPassword,lpVerification) != 0) {
				// Error Case - New password and verification do not match.
				MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_WRONG_TEXT,IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
				SetWindowText(hNewPasswordText,NULL);
				SetWindowText(hVerificationText,NULL);
				SetFocus(hNewPasswordText);
				break;
			}
                        if (nNewPasswordLength < MINPASSWORDLENGTH)
                        {
                            MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_LENGTH_TEXT,IDS_REMOTE_NEW_PASSWORD_LENGTH_TITLE,MB_OK | MB_ICONERROR);
                            SetWindowText(hNewPasswordText,NULL);
                            SetWindowText(hVerificationText,NULL);
                            SetFocus(hNewPasswordText);
                            break;
                        }
			if (!lstrlen(lpVerification)) {
				// Don't allow empty password
				MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_EMPTY,IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
				SetWindowText(hNewPasswordText,NULL);
				SetWindowText(hVerificationText,NULL);
				SetFocus(hNewPasswordText);
				break;
			}
			if (!FAnsiSz(lpNewPassword)) {
				// Error Case - T.120 can't handle UNICODE passwords
				MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_INVALID_TEXT,IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
				SetWindowText(hNewPasswordText,NULL);
				SetWindowText(hVerificationText,NULL);
				SetFocus(hNewPasswordText);
				break;
			}

			// If we get here, then go ahead and change the password.
			MultiByteToWideChar(CP_ACP, 0, lpNewPassword, -1, lpwszNewPassword, MAXPASSWORDLENGTH);
			cbHashedPassword = hashObject.GetHashedData((LPBYTE)lpwszNewPassword, 
								sizeof(WCHAR)*lstrlen(lpNewPassword), 
								(void **)&pbHashedPassword);
			ASSERT (0 != cbHashedPassword);

			reLM.SetValue(REMOTE_REG_PASSWORD,pbHashedPassword,cbHashedPassword);
			MessageBoxResource(hDlg,IDS_REMOTE_PASSWORD_CHANGED_TEXT,IDS_REMOTE_PASSWORD_CHANGED_TITLE,MB_OK | MB_ICONEXCLAMATION);
			// Return 1 if non-null password is set
			EndDialog(hDlg, *lpNewPassword != _T('\0'));
			break;
		}
		case IDCANCEL:
			EndDialog(hDlg,0);
			break;
		default:
			break;
		}
		return TRUE;

	}
	return FALSE;
}

int MessageBoxResource(HWND hwnd, UINT uMessage, UINT uTitle, UINT uFlags)
{
	TCHAR szTitle[MAX_PATH];
	TCHAR szMessage[MAX_PATH];

	FLoadString(uMessage,szMessage,CCHMAX(szMessage));
	FLoadString(uTitle,szTitle,CCHMAX(szTitle));
	return MessageBox(hwnd, szMessage, szTitle, uFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\gal.cpp ===
// File: GAL.cpp

#include "precomp.h"
#include "resource.h"
#include "help_ids.h"

#include "dirutil.h"

#include "GAL.h"
#include "MapiInit.h"
#include "AdLkup.h"
#include <lst.h>



#define NM_INVALID_MAPI_PROPERTY 0

    // Registry Stuff
/* static */ LPCTSTR CGAL::msc_szDefaultILSServerRegKey    = ISAPI_CLIENT_KEY;
/* static */ LPCTSTR CGAL::msc_szDefaultILSServerValue     = REGVAL_SERVERNAME;
/* static */ LPCTSTR CGAL::msc_szNMPolRegKey               = POLICIES_KEY;
/* static */ LPCTSTR CGAL::msc_szNMExchangeAtrValue        = REGVAL_POL_NMADDRPROP;
/* static */ LPCTSTR CGAL::msc_szSMTPADDRESSNAME           = TEXT( "SMTP" );

    // If there is no DISPLAY_NAME or ACCOUNT_NAME, don't display anything
/* static */ LPCTSTR CGAL::msc_szNoDisplayName			= TEXT( "" );
/* static */ LPCTSTR CGAL::msc_szNoEMailName			= TEXT( "" );
/* static */ LPCTSTR CGAL::msc_szNoBusinessTelephoneNum	= TEXT( "" );

// Async stuff - there is only one instance of the GAL thread
/* static */ HINSTANCE CGAL::m_hInstMapi32DLL          = NULL;
/* static */ HANDLE    CGAL::m_hEventEndAsyncThread    = NULL;
/* static */ HANDLE    CGAL::m_hAsyncLogOntoGalThread  = NULL;
/* static */ CGAL::eAsyncLogonState CGAL::m_AsyncLogonState = CGAL::AsyncLogonState_Idle;

/* static */ IAddrBook      * CGAL::m_pAddrBook        = NULL;
/* static */ IMAPITable     * CGAL::m_pContentsTable   = NULL;
/* static */ IMAPIContainer * CGAL::m_pGAL             = NULL;
/* static */ ULONG            CGAL::m_nRows = 0;


static const int _rgIdMenu[] = {
	IDM_DLGCALL_SPEEDDIAL,
	0
};


CGAL::CGAL() :
	CALV(IDS_DLGCALL_GAL, II_GAL, _rgIdMenu, true ),
    m_nBlockSize( DefaultBlockSize ),
    m_MaxCacheSize( DefaultMaxCacheSize ), 
    m_bBeginningBookmarkIsValid( false ),
    m_bEndBookmarkIsValid( false ),
    m_hrGALError( S_OK ),
	m_hWndListView(NULL)
{
	DbgMsg(iZONE_OBJECTS, "CGAL - Constructed(%08X)", this);

	_ResetCache();

	msc_ErrorEntry_NoGAL = CGalEntry();

	if (NULL == m_hInstMapi32DLL)
	{
		WARNING_OUT(("MAPI32.dll was not loaded?"));
		return;
	}

		//////////////////////////////////////////////////////////////////////////////////////////
		// We have to see if the GAL is available.. 
		// this is modified from Q188482 and Q171636
		//////////////////////////////////////////////////////////////////////////////////////////

		// first we have to initialize MAPI for this ( the main ) thread...
	MAPIINIT_0 mi = { MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS };
	TRACE_OUT(("Initializing MAPI"));
	HRESULT hr = lpfnMAPIInitialize(&mi);
	
	if( SUCCEEDED( hr ) )
	{
		TRACE_OUT(("MAPI Initialized"));

			// We have to get a pointer to the AdminProfile which is basically
			// a manipulator for the mapisvc.inf file that should be on user's computer
		LPPROFADMIN pAdminProfiles = NULL; 
		hr = lpfnMAPIAdminProfiles( 0L, &pAdminProfiles );

		if( SUCCEEDED( hr ) )
		{	ASSERT( pAdminProfiles );

				// Get the profile table to search for the default profile
			LPMAPITABLE pProfTable = NULL;
			hr = pAdminProfiles->GetProfileTable( 0L, &pProfTable );
			if( SUCCEEDED( hr ) )
			{	ASSERT( pProfTable );

					// Set the restriction to search for the default profile			
				SRestriction Restriction;
				SPropValue spv;
				Restriction.rt = RES_PROPERTY;
				Restriction.res.resProperty.relop = RELOP_EQ;
				Restriction.res.resProperty.ulPropTag = PR_DEFAULT_PROFILE;
				Restriction.res.resProperty.lpProp = &spv;
				spv.ulPropTag = PR_DEFAULT_PROFILE;
				spv.Value.b = TRUE;

					// Find the default profile....
				hr = pProfTable->FindRow( &Restriction, BOOKMARK_BEGINNING, 0 );
				if( SUCCEEDED( hr ) )
				{
					// We have a default profile
					LPSRowSet pRow = NULL;
					hr = pProfTable->QueryRows( 1, 0, &pRow );
					if( SUCCEEDED( hr ) )
					{	ASSERT( pRow );

						// The profile table entry really should have only two properties, 
						//  We will simply enumerate the proprtiies instead of hard-coding the
						//  order of the properties ( in case it changes in the future )
						//  PR_DISPLAY_NAME and PR_DEFAULT_PROFILE
						for( UINT iCur = 0; iCur < pRow->aRow->cValues; ++iCur )
						{
								// We are only interested in the PR_DISPLAY_NAME property
							if( pRow->aRow->lpProps[iCur].ulPropTag == PR_DISPLAY_NAME )
							{
									// Now that we have the default profile, we want to get the
									// profile admin interface for this profile

								LPSERVICEADMIN pSvcAdmin = NULL;  // Pointer to IServiceAdmin object
								hr = pAdminProfiles->AdminServices( pRow->aRow->lpProps[iCur].Value.LPSZ,
																	NULL,
																	0L,
																	0L,
																	&pSvcAdmin 
																  );
								
								if( SUCCEEDED( hr ) )
								{ ASSERT( pSvcAdmin );

									LPMAPITABLE pSvcTable = NULL;
									if( SUCCEEDED( hr = pSvcAdmin->GetMsgServiceTable( 0L, &pSvcTable ) ) )
									{	ASSERT( pSvcTable );

										enum {iSvcName, iSvcUID, cptaSvc};
										SizedSPropTagArray (cptaSvc, sptCols) = { cptaSvc,
																			  PR_SERVICE_NAME,
																			  PR_SERVICE_UID };

										Restriction.rt = RES_PROPERTY;
										Restriction.res.resProperty.relop = RELOP_EQ;
										Restriction.res.resProperty.ulPropTag = PR_SERVICE_NAME;
										Restriction.res.resProperty.lpProp = &spv;
										spv.ulPropTag = PR_SERVICE_NAME;
										spv.Value.LPSZ = _T("MSEMS");

										LPSRowSet pRowExch = NULL;
										if ( SUCCEEDED( hr = lpfnHrQueryAllRows( pSvcTable,
																					(LPSPropTagArray)&sptCols,
																					&Restriction,
																					NULL,
																					0,
																					&pRowExch ) ) )
										{
											SetAvailable(TRUE);
											lpfnFreeProws( pRowExch );
											iCur = pRow->aRow->cValues;
										}

										pSvcTable->Release();
										pSvcTable = NULL;
									}

									pSvcAdmin->Release();
									pSvcAdmin = NULL;
								}
							}
						}

						lpfnFreeProws( pRow );
					}
				}

				pProfTable->Release();
				pProfTable = NULL;
			}

			pAdminProfiles->Release();
			pAdminProfiles = NULL;
		}

		lpfnMAPIUninitialize();
	}
	
	m_MaxJumpSize = m_nBlockSize;
}


CGAL::~CGAL()
{   
	// Kill the cache
	_ResetCache();

	DbgMsg(iZONE_OBJECTS, "CGAL - Destroyed(%08X)", this);
}   


// static function to load MAPI32.dll
BOOL CGAL::FLoadMapiFns(void)
{
	if (NULL != m_hInstMapi32DLL)
		return TRUE;

	return LoadMapiFns(&m_hInstMapi32DLL);
}

// static function to unload MAPI32.dll and logoff, if necessary
VOID CGAL::UnloadMapiFns(void)
{
	if (NULL != m_hAsyncLogOntoGalThread)
	{
		TRACE_OUT(("Setting AsyncLogOntoGalThread End Event"));
		ASSERT(NULL != m_hEventEndAsyncThread);
		SetEvent(m_hEventEndAsyncThread);

		WARNING_OUT(("Waiting for AsyncLogOntoGalThread to exit (start)"));
		WaitForSingleObject(m_hAsyncLogOntoGalThread, 30000); // 30 seconds max
		WARNING_OUT(("Waiting for AsyncLogOntoGalThread to exit (end)"));

		CloseHandle(m_hAsyncLogOntoGalThread);
		m_hAsyncLogOntoGalThread = NULL;

		CloseHandle(m_hEventEndAsyncThread);
		m_hEventEndAsyncThread = NULL;
	}

	if (NULL != m_hInstMapi32DLL)
	{
		FreeLibrary(m_hInstMapi32DLL);
		m_hInstMapi32DLL = NULL;
	}
}

/* virtual */ int CGAL::OnListGetImageForItem( int iIndex ) {


    if( !_IsLoggedOn() )
    {
        return II_INVALIDINDEX;
    }

    CGalEntry* pEntry = _GetEntry( iIndex );
    
    if( pEntry->GetDisplayType() == DT_MAILUSER ) { return II_INVALIDINDEX; }

    switch( pEntry->GetDisplayType() ) {
        case DT_DISTLIST:               return II_DISTLIST;
        case DT_FORUM:                  return II_FORUM;
        case DT_AGENT:                  return II_AGENT;
        case DT_ORGANIZATION:           return II_ORGANIZATION;
        case DT_PRIVATE_DISTLIST:       return II_PRIVATE_DISTLIST;
        case DT_REMOTE_MAILUSER:        return II_REMOTE_MAILUSER;

        default:    
            ERROR_OUT(("We have an invalid Display Type"));
            return II_INVALIDINDEX;
    }

	return II_INVALIDINDEX;

}


/* virtual */ bool CGAL::IsItemBold( int index ) {


    if( !_IsLoggedOn() )
    {
        return false;
    }

    CGalEntry* pEntry = _GetEntry( index );

    switch( pEntry->GetDisplayType() ) {
        case DT_DISTLIST:               
        case DT_PRIVATE_DISTLIST:       
            return true;
        
        case DT_MAILUSER:
        case DT_FORUM:                  
        case DT_AGENT:                  
        case DT_ORGANIZATION:           
        case DT_REMOTE_MAILUSER:        
            return false;

        default:
            ERROR_OUT(("Invalid DT in CGAL::IsItemBold"));
            return false;
    }

    return false;

}

HRESULT CGAL::_GetEmailNames( int* pnEmailNames, LPTSTR** ppszEmailNames, int iItem )
{	
	HRESULT hr = S_OK;
	*pnEmailNames = 1;
	*ppszEmailNames = new LPTSTR[1];
	(*ppszEmailNames)[0] = NULL;
		
	CGalEntry* pCurSel = _GetItemFromCache( iItem );
	if( pCurSel )
	{
		(*ppszEmailNames)[0] = PszAlloc( pCurSel->GetEMail() );
	}

	return hr;
}


/* virtual */ RAI * CGAL::GetAddrInfo(void)
{

	RAI* pRai = NULL;


	int iItem = GetSelection();

	if (-1 != iItem) 
	{
		HWND hwnd = GetHwnd();
		LPTSTR* pszPhoneNums = NULL;
		LPTSTR* pszEmailNames = NULL;
		int nPhoneNums = 0;
		int nEmailNames = 0;


		CGalEntry* pCurSel = _GetItemFromCache( iItem );


		if( g_fGkEnabled )
		{
			if( g_bGkPhoneNumberAddressing )
			{
				_GetPhoneNumbers( pCurSel->GetInstanceKey(), &nPhoneNums, &pszPhoneNums );
			}
			else
			{
				_GetEmailNames( &nEmailNames, &pszEmailNames, iItem );
			}
		}
		else
		{ // This is regular call placement mode

			if( g_fGatewayEnabled )
			{
				_GetPhoneNumbers( pCurSel->GetInstanceKey(), &nPhoneNums, &pszPhoneNums );
			}

			nEmailNames = 1;
			pszEmailNames = new LPTSTR[1];
			pszEmailNames[0] = new TCHAR[CCHMAXSZ];
			GetSzAddress( pszEmailNames[0], CCHMAXSZ, iItem );
		}

		if( nPhoneNums || nEmailNames )
		{

			int nItems = nPhoneNums + nEmailNames;
			DWORD cbLen = sizeof(RAI) + sizeof(DWSTR)* nItems;
			pRai = reinterpret_cast<RAI*>(new BYTE[ cbLen ]);
			ZeroMemory(pRai, cbLen);
			pRai->cItems = nItems;


			int iCur = 0;
			lstrcpyn( pRai->szName, pCurSel->GetName(), CCHMAX(pRai->szName) );

				// First copy the e-mail names
			for( int i = 0; i < nEmailNames; i++ )
			{
				DWORD dwAddressType = g_fGkEnabled ? NM_ADDR_ALIAS_ID : NM_ADDR_ULS;
				pRai->rgDwStr[iCur].dw = dwAddressType;
				pRai->rgDwStr[iCur].psz = pszEmailNames[i];
				++iCur;
			}
			delete [] pszEmailNames;

				// Copy the phone numbirs
			for( i = 0; i < nPhoneNums; i++ )
			{
				pRai->rgDwStr[iCur].dw = g_fGkEnabled ? NM_ADDR_ALIAS_E164 : NM_ADDR_H323_GATEWAY;
				pRai->rgDwStr[iCur].psz = pszPhoneNums[i];
				++iCur;
			}
			delete [] pszPhoneNums;
		}

	}

	return pRai;

}


HRESULT CGAL::_GetPhoneNumbers( const SBinary& rEntryID, int* pcPhoneNumbers, LPTSTR** ppszPhoneNums )
{
	
	HRESULT hr = S_OK;

	if( pcPhoneNumbers && ppszPhoneNums )
	{
		*pcPhoneNumbers = 0;
		*ppszPhoneNums = NULL;

		ULONG PhoneNumPropTags[] = {
			PR_BUSINESS_TELEPHONE_NUMBER,
			PR_HOME_TELEPHONE_NUMBER,
			PR_PRIMARY_TELEPHONE_NUMBER,
			PR_BUSINESS2_TELEPHONE_NUMBER,
			PR_CELLULAR_TELEPHONE_NUMBER,
			PR_RADIO_TELEPHONE_NUMBER,
			PR_CAR_TELEPHONE_NUMBER,
			PR_OTHER_TELEPHONE_NUMBER,
			PR_PAGER_TELEPHONE_NUMBER
		};

		BYTE* pb = new BYTE[ sizeof( SPropTagArray ) + sizeof( ULONG ) * ARRAY_ELEMENTS(PhoneNumPropTags) ];

		if( pb )
		{
			SPropTagArray* pta = reinterpret_cast<SPropTagArray*>(pb);

			pta->cValues = ARRAY_ELEMENTS(PhoneNumPropTags);

			for( UINT iCur = 0; iCur < pta->cValues; iCur++ )
			{
				pta->aulPropTag[iCur] = PhoneNumPropTags[iCur];
			}

			hr = m_pContentsTable->SetColumns(pta, TBL_BATCH);
			if (SUCCEEDED(hr))
			{
				if( SUCCEEDED( hr = _SetCursorTo( rEntryID ) ) )
				{
					LPSRowSet   pRow;
							// Get the item from the GAL
					if ( SUCCEEDED ( hr = m_pContentsTable->QueryRows( 1, TBL_NOADVANCE, &pRow ) ) ) 
					{
						lst<LPTSTR> PhoneNums;

						// First we have to find out how many nums there are
						for( UINT iCur = 0; iCur < pRow->aRow->cValues; ++iCur )
						{
							if( LOWORD( pRow->aRow->lpProps[iCur].ulPropTag ) != PT_ERROR )
							{
								TCHAR szExtractedAddress[CCHMAXSZ];

								DWORD dwAddrType = g_fGkEnabled ? NM_ADDR_ALIAS_E164 : NM_ADDR_H323_GATEWAY;
								
								ExtractAddress( dwAddrType, 
#ifdef UNICODE
												pRow->aRow->lpProps[iCur].Value.lpszW, 
#else
												pRow->aRow->lpProps[iCur].Value.lpszA, 
#endif // UNICODE
												szExtractedAddress, 
												CCHMAX(szExtractedAddress) 
											  );


								if( IsValidAddress( dwAddrType, szExtractedAddress ) )
								{
									++(*pcPhoneNumbers);
									PhoneNums.push_back(PszAlloc(
#ifdef UNICODE
																	pRow->aRow->lpProps[iCur].Value.lpszW
#else
																	pRow->aRow->lpProps[iCur].Value.lpszA
#endif // UNICODE
																)
													   );
								}
							}
						}
						
						*ppszPhoneNums = new LPTSTR[ PhoneNums.size() ];
						if( *ppszPhoneNums )
						{
							lst<LPTSTR>::iterator I = PhoneNums.begin();
							int iCur = 0;
							while( I != PhoneNums.end() )
							{	
								*ppszPhoneNums[iCur] = *I;
								++iCur, ++I;
							}
						}
						else
						{
							hr = E_OUTOFMEMORY;
						}

						lpfnFreeProws( pRow );
					}
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			}			

			delete [] pb;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = E_POINTER;
	}
	return hr;
}


/* virtual */ void CGAL::OnListCacheHint( int indexFrom, int indexTo ) {

    if( !_IsLoggedOn() )
    {
        return;
    }
//        TRACE_OUT(("OnListCacheHint( %d, %d )", indexFrom, indexTo ));

}


/* virtual */ VOID CGAL::CmdProperties( void ) {

	int iItem = GetSelection();
	if (-1 == iItem) {
		return;
    }


    HRESULT hr;
	HWND hwnd = GetHwnd();

    CGalEntry* pCurSel = _GetItemFromCache( iItem );

    const SBinary& rEntryID = pCurSel->GetEntryID();

    ULONG ulFlags = DIALOG_MODAL;

#ifdef UNICODE
    ulFlags |= MAPI_UNICODE;
#endif // UNICODE

	hr = m_pAddrBook->Details( reinterpret_cast< LPULONG >(  &hwnd ), 
                               NULL, 
                               NULL,
                               rEntryID.cb, 
                               reinterpret_cast< LPENTRYID >( rEntryID.lpb ),
		                       NULL, 
                               NULL, 
                               NULL, 
                               ulFlags
                             );    
}


    // This is called when the Global Address List item is selected from the
    //  combo box in the call dialog
/* virtual */ VOID CGAL::ShowItems(HWND hwnd)
{
	CALV::SetHeader(hwnd, IDS_ADDRESS);
	ListView_SetItemCount(hwnd, 0);
	
	m_hWndListView = hwnd;

	if(SUCCEEDED(m_hrGALError))
	{
		TCHAR szPhoneNumber[CCHMAXSZ];
		if( FLoadString(IDS_PHONENUM, szPhoneNumber, CCHMAX(szPhoneNumber)) )
		{
			LV_COLUMN lvc;
			ClearStruct(&lvc);
			lvc.mask = LVCF_TEXT | LVCF_SUBITEM;
			lvc.pszText = szPhoneNumber;
			lvc.iSubItem = 2;
			ListView_InsertColumn(hwnd, IDI_DLGCALL_PHONENUM, &lvc);
		}

		m_MaxCacheSize = ListView_GetCountPerPage(hwnd) * NUM_LISTVIEW_PAGES_IN_CACHE;
		if (m_MaxCacheSize < m_MaxJumpSize)
		{
			// The cache has to be at least as big as the jump size
			m_MaxCacheSize = m_MaxJumpSize * 2;
		}

		if (!_IsLoggedOn())
		{
			_AsyncLogOntoGAL();
		}
		else 
		{
			_sInitListViewAndGalColumns(hwnd);
		}
	}
}


/*  C L E A R  I T E M S  */
/*-------------------------------------------------------------------------
    %%Function: ClearItems
    
-------------------------------------------------------------------------*/
VOID CGAL::ClearItems(void)
{
	CALV::ClearItems();

	if( IsWindow(m_hWndListView) )
	{
		ListView_DeleteColumn(m_hWndListView, IDI_DLGCALL_PHONENUM);
	}
	else
	{
		WARNING_OUT(("m_hWndListView is not valid in CGAL::ClearItems"));
	}
}



/*  _  S  I N I T  L I S T  V I E W  A N D  G A L  C O L U M N S  */
/*-------------------------------------------------------------------------
    %%Function: _sInitListViewAndGalColumns
    
-------------------------------------------------------------------------*/
HRESULT CGAL::_sInitListViewAndGalColumns(HWND hwnd)
{
	// Set the GAL columns before we let the listview try to get the data
	struct SPropTagArray_sptCols {
		ULONG cValues;
		ULONG aulPropTag[ NUM_PROPS ];
	} sptCols;

	sptCols.cValues = NUM_PROPS;
	sptCols.aulPropTag[ NAME_PROP_INDEX ]						= PR_DISPLAY_NAME;
	sptCols.aulPropTag[ ACCOUNT_PROP_INDEX ]					= PR_ACCOUNT;
	sptCols.aulPropTag[ INSTANCEKEY_PROP_INDEX ]				= PR_INSTANCE_KEY;
	sptCols.aulPropTag[ ENTRYID_PROP_INDEX ]					= PR_ENTRYID;
	sptCols.aulPropTag[ DISPLAY_TYPE_INDEX ]					= PR_DISPLAY_TYPE;
	sptCols.aulPropTag[ BUSINESS_PHONE_NUM_PROP_INDEX ]			= PR_BUSINESS_TELEPHONE_NUMBER;

	HRESULT hr = m_pContentsTable->SetColumns((LPSPropTagArray) &sptCols, TBL_BATCH);
	if (SUCCEEDED(hr))
	{
		// Get the row count so we can initialize the OWNER DATA ListView
		hr = m_pContentsTable->GetRowCount(0, &m_nRows);
		if (SUCCEEDED(hr))
		{
			// Set the list view size to the number of entries in the GAL
			ListView_SetItemCount(hwnd, m_nRows);
		}
	}

	return hr;
}


/*  _  A S Y N C  L O G  O N T O  G  A  L  */
/*-------------------------------------------------------------------------
    %%Function: _AsyncLogOntoGAL
    
-------------------------------------------------------------------------*/
HRESULT CGAL::_AsyncLogOntoGAL(void)
{

	if ((AsyncLogonState_Idle != m_AsyncLogonState) ||
		(NULL != m_hAsyncLogOntoGalThread))
	{
		return S_FALSE;
	}

	m_AsyncLogonState = AsyncLogonState_LoggingOn;
	ASSERT(NULL == m_hEventEndAsyncThread);
	m_hEventEndAsyncThread = CreateEvent(NULL, TRUE, FALSE, NULL);

	DWORD dwThID;
	TRACE_OUT(("Creating AsyncLogOntoGal Thread"));
	m_hAsyncLogOntoGalThread = CreateThread(NULL, 0, _sAsyncLogOntoGalThreadfn, 
	                                        static_cast< LPVOID >(GetHwnd()), 0, &dwThID);

	if (NULL == m_hAsyncLogOntoGalThread)
	{
		m_AsyncLogonState = AsyncLogonState_Idle;
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

/* static */ DWORD CALLBACK CGAL::_sAsyncLogOntoGalThreadfn(LPVOID pv)
{
	SetBusyCursor(TRUE);
	HRESULT hr = _sAsyncLogOntoGal();
	SetBusyCursor(FALSE);

	if (S_OK == hr)
	{
		TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling _InitListViewAndGalColumns"));
		_sInitListViewAndGalColumns((HWND) pv);

		// This keeps the thread around until we're done
		WaitForSingleObject(m_hEventEndAsyncThread, INFINITE);
	}

	// Clean up in the same thread
	hr = _sAsyncLogoffGal();

	return (DWORD) hr;
}


/* static */ HRESULT CGAL::_sAsyncLogOntoGal(void)
{
	ULONG cbeid = 0L;
	LPENTRYID lpeid = NULL;
	HRESULT hr = S_OK;
	ULONG ulObjType;

	MAPIINIT_0 mi = { MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS };

	TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling MAPIInitialize"));

	hr = lpfnMAPIInitialize(&mi);
	if (FAILED(hr))
		return hr;

    TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling MAPILogonEx"));
    IMAPISession* pMapiSession;
    hr = lpfnMAPILogonEx( NULL, 
                          NULL, 
                          NULL, 
                          MAPI_EXTENDED | MAPI_USE_DEFAULT, 
                          &pMapiSession );
	if (FAILED(hr))
		return hr;

        // Open the main address book
	TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling OpenAddressBook"));
	ASSERT(NULL == m_pAddrBook);
	hr = pMapiSession->OpenAddressBook(NULL, NULL, AB_NO_DIALOG, &m_pAddrBook);

	pMapiSession->Release();
	pMapiSession = NULL;

	if (FAILED(hr))
		return hr;

	TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling HrFindExchangeGlobalAddressList "));
	hr = HrFindExchangeGlobalAddressList(m_pAddrBook, &cbeid, &lpeid);
	if (FAILED(hr))
		return hr;

	TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling OpenEntry"));
	ASSERT(NULL == m_pGAL);
	hr = m_pAddrBook->OpenEntry(cbeid, lpeid, NULL, MAPI_BEST_ACCESS,
	                            &ulObjType, reinterpret_cast< IUnknown** >( &m_pGAL));
	if (FAILED(hr))
		return hr;

	if (ulObjType != MAPI_ABCONT)
		return GAL_E_GAL_NOT_FOUND;

	TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling GetContentsTable"));
	ASSERT(NULL == m_pContentsTable);
	hr = m_pGAL->GetContentsTable(0L, &m_pContentsTable);
	if (FAILED(hr))
		return hr;

	m_AsyncLogonState = AsyncLogonState_LoggedOn;

	return hr;
}    
    
/* static */ HRESULT CGAL::_sAsyncLogoffGal(void)
{
	// Free and release all the stuff that we hold onto
	TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Releasing MAPI Interfaces"));

	if (NULL != m_pContentsTable)
	{
		m_pContentsTable->Release();
		m_pContentsTable = NULL;
	}
	if (NULL != m_pAddrBook)
	{
		m_pAddrBook->Release();
		m_pAddrBook = NULL;
	}
	if (NULL != m_pGAL)
	{
		m_pGAL->Release();
		m_pGAL = NULL;
	}

	WARNING_OUT(("in _AsyncLogOntoGalThreadfn: Calling lpfnMAPIUninitialize"));        
	lpfnMAPIUninitialize();

	m_AsyncLogonState = AsyncLogonState_Idle;
	return S_OK;
}



HRESULT CGAL::_SetCursorTo( const CGalEntry& rEntry ) {
    return _SetCursorTo( rEntry.GetInstanceKey() );
}


HRESULT CGAL::_SetCursorTo( LPCTSTR szPartialMatch ) {


        // Find the row that matches the partial String based on the DISPLAY_NAME;
    SRestriction Restriction;
    SPropValue spv;
    Restriction.rt = RES_PROPERTY;
    Restriction.res.resProperty.relop = RELOP_GE;
    Restriction.res.resProperty.lpProp = &spv;
    Restriction.res.resProperty.ulPropTag = PR_DISPLAY_NAME;
    spv.ulPropTag = PR_DISPLAY_NAME;

#ifdef  UNICODE
    spv.Value.lpszW = const_cast< LPTSTR >( szPartialMatch );
#else 
    spv.Value.lpszA = const_cast< LPTSTR >( szPartialMatch );
#endif // UNICODE

        // Find the first row that is lexographically greater than or equal to the search string
    HRESULT hr = m_pContentsTable->FindRow( &Restriction, BOOKMARK_BEGINNING, 0 );
    if( FAILED( hr ) ) {
        if( MAPI_E_NOT_FOUND == hr ) {
             // This is not really an error, because we handle it from the calling 
             //   function.  That is, we don't have to set m_hrGALError here...
            return MAPI_E_NOT_FOUND;
        }

        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return GAL_E_QUERYROWS_FAILED;
    }

    return S_OK;
}

HRESULT CGAL::_SetCursorTo( const SBinary& rInstanceKey ) {

    HRESULT hr;

        // there is an exchange reg key, we have to get the user's data from the GAL
    SRestriction Restriction;
    SPropValue spv;

        // Search for the user using the instance key data that is in the CGalEntry for the currently
        //   selected list box item
    Restriction.rt = RES_PROPERTY;
    Restriction.res.resProperty.relop = RELOP_EQ;
    Restriction.res.resProperty.ulPropTag = PR_INSTANCE_KEY;
    Restriction.res.resProperty.lpProp = &spv;

    spv.ulPropTag = PR_INSTANCE_KEY;

        // Get the INSTANCE_KEY from the cache
    spv.Value.bin.cb = rInstanceKey.cb;
    spv.Value.bin.lpb = new byte[ spv.Value.bin.cb ];
    ASSERT( spv.Value.bin.cb );
    memcpy( spv.Value.bin.lpb, rInstanceKey.lpb, spv.Value.bin.cb );

        // find the user in the table...
    hr = m_pContentsTable->FindRow( &Restriction, BOOKMARK_BEGINNING, 0 );

    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_FINDROW_FAILED;
        delete [] ( spv.Value.bin.lpb );
        return GAL_E_FINDROW_FAILED;
    }

    delete [] ( spv.Value.bin.lpb );
    return S_OK;
}


bool CGAL::_GetSzAddressFromExchangeServer( int iItem, LPTSTR psz, int cchMax ) {
    
    HRESULT hr;

        // In the registry, there may be a key that says what the MAPI attribute
        // is in which the users' ILS server is stored in the GAL... If the 
        // reg key exists, we have to get the property from the GAL
    DWORD dwAttr = _GetExchangeAttribute( );
    bool bExtensionFound = ( NM_INVALID_MAPI_PROPERTY != dwAttr );

        // Re-create the table so that it includes the MAPI property tag found in the EXCHANGE REG ATTRUBITE
    SizedSPropTagArray( 3, sptColsExtensionFound ) = { 3, PR_EMAIL_ADDRESS, PR_ADDRTYPE, PROP_TAG( PT_TSTRING, dwAttr) };
    SizedSPropTagArray( 2, sptColsExtensionNotFound ) = { 2, PR_EMAIL_ADDRESS, PR_ADDRTYPE };
    const int EmailPropertyIndex = 0;
    const int EmailAddressTypePropertyIndex = 1;
    const int ExtensionPropertyIndex = 2;
    
    if( bExtensionFound ) {
        if(FAILED(hr = m_pContentsTable->SetColumns( ( LPSPropTagArray ) &sptColsExtensionFound, TBL_BATCH ) ) ) {
            m_hrGALError = GAL_E_SETCOLUMNS_FAILED;
            return false;
        }
    }
    else {
        if(FAILED(hr = m_pContentsTable->SetColumns( ( LPSPropTagArray ) &sptColsExtensionNotFound, TBL_BATCH ) ) ) {
            m_hrGALError = GAL_E_SETCOLUMNS_FAILED;
            return false;
        }
    }

    if( FAILED( hr = _SetCursorTo( *_GetItemFromCache( iItem ) ) ) ) {
        return false;
    }

    LPSRowSet   pRow;
            // Get the item from the GAL
    if ( SUCCEEDED ( hr = m_pContentsTable->QueryRows( 1, TBL_NOADVANCE, &pRow ) ) ) {
        
        if( bExtensionFound ) {
                // Copy the extension data from the entry if it is there
            if( LOWORD( pRow->aRow->lpProps[ ExtensionPropertyIndex ].ulPropTag ) != PT_ERROR ) {
                TRACE_OUT(("Using custom Exchange data for address"));
                _CopyPropertyString( psz, pRow->aRow->lpProps[ ExtensionPropertyIndex ], cchMax );
                lpfnFreeProws( pRow );
                return true;
            }
        }
            // If the extension was not found in the reg, or if there was no extension data. 
            // use the e-mail address if it is SMTP type...
        if( LOWORD( pRow->aRow->lpProps[ EmailAddressTypePropertyIndex ].ulPropTag ) != PT_ERROR ) {
                // Check to see if the address type is SMTP
#ifdef UNICODE
            TRACE_OUT(("Email address %s:%s", pRow->aRow->lpProps[ EmailAddressTypePropertyIndex ].Value.lpszW, pRow->aRow->lpProps[ EmailPropertyIndex ].Value.lpszW ));
            if( !lstrcmp( msc_szSMTPADDRESSNAME, pRow->aRow->lpProps[ EmailAddressTypePropertyIndex ].Value.lpszW ) ) {
#else
            TRACE_OUT(("Email address %s:%s", pRow->aRow->lpProps[ EmailAddressTypePropertyIndex ].Value.lpszA, pRow->aRow->lpProps[ EmailPropertyIndex ].Value.lpszA ));
            if( !lstrcmp( msc_szSMTPADDRESSNAME, pRow->aRow->lpProps[ EmailAddressTypePropertyIndex ].Value.lpszA ) ) {     
#endif // UNICODE
                TRACE_OUT(("Using SMTP E-mail as address"));
                if( LOWORD( pRow->aRow->lpProps[ EmailPropertyIndex ].ulPropTag ) != PT_ERROR ) {
                    FGetDefaultServer( psz, cchMax - 1 );
                    int ServerPrefixLen = lstrlen( psz );
                    psz[ ServerPrefixLen ] = TEXT( '/' );
                    ++ServerPrefixLen;
                    ASSERT( ServerPrefixLen < cchMax );
                    _CopyPropertyString( psz + ServerPrefixLen, pRow->aRow->lpProps[ EmailPropertyIndex ], cchMax - ServerPrefixLen );
                    lpfnFreeProws( pRow );
                    return true;
                }
            }
        }

        lpfnFreeProws( pRow );
    }
    else {
        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return false;
    }

        // This means that we did not find the data on the server
    return false;
}


void CGAL::_CopyPropertyString( LPTSTR psz, SPropValue& rProp, int cchMax ) {

#ifdef  UNICODE    
    lstrcpyn( psz, rProp.Value.lpszW, cchMax );
#else
    lstrcpyn( psz, rProp.Value.lpszA, cchMax );
#endif // UNICODE

}


    // When the user selects CALL, we have to
    // Create an address for them to callto://

BOOL CGAL::GetSzAddress(LPTSTR psz, int cchMax, int iItem)
{
	// try and get the data from the exchange server as per the spec...
	if (_GetSzAddressFromExchangeServer(iItem, psz, cchMax))
	{
		TRACE_OUT(("CGAL::GetSzAddress() returning address [%s]", psz));                    
		return TRUE;
	}


	// If the data is not on the server, we are going to create the address in the format
	//      <default_server>/<PR_ACCOUNT string>        
	if (!FGetDefaultServer(psz, cchMax - 1))
		return FALSE;

	// Because the syntax is callto:<servername>/<username> 
	// we have to put in the forward-slash
	int cch = lstrlen(psz);
	psz[cch++] = '/';
	psz += cch;
	cchMax -= cch;

	// There was no data on the server for us, so we will just use the PR_ACCOUNT data that we have cached
	return CALV::GetSzData(psz, cchMax, iItem, IDI_DLGCALL_ADDRESS);
}



    // When the user types in a search string ( partial match string ) in the edit box
    //  above the ListView, we want to show them the entries starting with the given string
ULONG CGAL::OnListFindItem( LPCTSTR szPartialMatchingString ) {

    if( !_IsLoggedOn() )
    {
        return 0;
    }

        // If we have such an item cached, return the index to it
    int index;
    if( -1 != (  index = _FindItemInCache( szPartialMatchingString ) ) ) {
        return index;
    }
        // if the edit box is empty ( NULL string ), then we know to return item 0
    if( szPartialMatchingString[ 0 ] == '\0' ) {
        return 0;
    }
    
    HRESULT hr;
    if( FAILED( hr = _SetCursorTo( szPartialMatchingString ) ) ) {
        if( MAPI_E_NOT_FOUND == hr ) {
            return m_nRows - 1;
        }
        return 0;
    }


        // We have to find the row number of the cursor where the partial match is...
    ULONG ulRow, ulPositionNumerator, ulPositionDenominator;
    m_pContentsTable->QueryPosition( &ulRow, &ulPositionNumerator, &ulPositionDenominator );
    if( ulRow == 0xFFFFFFFF  ) {
        // If QueryPosition is unable to determine the ROW, it will return the row based on the
        //     fraction ulPositionNumerator/ulPositionDenominator
        ulRow = MulDiv( m_nRows, ulPositionNumerator, ulPositionDenominator );
    }

        // Kill the cache, becasue we are jumping to a new block of data
        //  We do this because the _FindItemInCache call above failed to
        //  return the desired item...
    _ResetCache();        
    m_IndexOfFirstItemInCache = ulRow;
    m_IndexOfLastItemInCache = ulRow - 1;
        
    // Jump back a few, so we can cache some entries before the one we are looking for
    long lJumped;
    hr = m_pContentsTable->SeekRow( BOOKMARK_CURRENT, -( m_nBlockSize / 2 ), &lJumped );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_SEEKROW_FAILED;
        return 0;
    }

        // We hawe to change the sign of lJumped because we are jumping backwards
    lJumped *= -1;

    // Set the begin bookmark
    hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfFirstItemInCache );
    ASSERT( SUCCEEDED( hr ) );
    m_bBeginningBookmarkIsValid = true;

    // Read in a block of rows
    LPSRowSet pRow = NULL;
    hr = m_pContentsTable->QueryRows( m_nBlockSize, 0, &pRow );

    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return 0;
    }

        // For each item in the block

        // This should always be the case,
        // but we vant to make sure that we have enough rows to get to the
        // item that we are looking for...
    ASSERT( pRow->cRows >= static_cast< ULONG >( lJumped ) );

    for( ULONG i = 0; i < pRow->cRows; i++ ) {
        
        CGalEntry* pEntry;

        if( FAILED( _MakeGalEntry( pRow->aRow[ i ], &pEntry ) ) ) { 
            lpfnFreeProws( pRow );
            return 0;
        }
                    
        if( 0 == lJumped ) {
            ulRow = m_IndexOfLastItemInCache + 1;
        }

        --lJumped;

        m_EntryCache.push_back( pEntry );
        m_IndexOfLastItemInCache++;
    }

    lpfnFreeProws( pRow );

    // Set the end bookmark
    hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfItemAfterLastItemInCache );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
        return 0;
    }

    m_bEndBookmarkIsValid = true;

    VERIFYCACHE

    return ulRow;
}


    // This is called by the ListView Notification handler.  Because the ListView is OWNERDATA
    //  it has to ask us every time it needs the string data for the columns...
void CGAL::OnListGetColumn1Data( int iItemIndex, int cchTextMax, LPTSTR szBuf ) {

    if( !_IsLoggedOn() )
    {
        lstrcpyn( szBuf, g_cszEmpty, cchTextMax );
    }
    else 
    {
        LPCTSTR pszName = _GetEntry( iItemIndex )->GetName();
        if( NULL == pszName ) 
        {
            pszName = g_cszEmpty;
        }
        lstrcpyn( szBuf, pszName, cchTextMax );
    }
}

    // This is called by the ListView Notification handler.  Because the ListView is OWNERDATA
    //  it has to ask us every time it needs the string data for the columns...
void CGAL::OnListGetColumn2Data( int iItemIndex, int cchTextMax, LPTSTR szBuf ) {
    if( !_IsLoggedOn() )
    {
        lstrcpyn( szBuf, g_cszEmpty, cchTextMax );
    }
    else {

        LPCTSTR pszEMail = _GetEntry( iItemIndex )->GetEMail();
        if( NULL == pszEMail ) 
        {
            pszEMail = g_cszEmpty;
        }

        lstrcpyn( szBuf, pszEMail, cchTextMax );
    }
}

    // This is called by the ListView Notification handler.  Because the ListView is OWNERDATA
    //  it has to ask us every time it needs the string data for the columns...
void CGAL::OnListGetColumn3Data( int iItemIndex, int cchTextMax, LPTSTR szBuf ) {
    if( !_IsLoggedOn() )
    {
        lstrcpyn( szBuf, g_cszEmpty, cchTextMax );
    }
    else {
		
		lstrcpyn( szBuf, g_cszEmpty, cchTextMax );

        LPCTSTR pszBusinessTelephone = _GetEntry( iItemIndex )->GetBusinessTelephone();
        if( NULL == pszBusinessTelephone ) 
        {
            pszBusinessTelephone = g_cszEmpty;
        }
        lstrcpyn( szBuf, pszBusinessTelephone, cchTextMax );
    }
}


    // When the user types in a search string in the edit box, we first check to see if there is an
    //  item in the cache that satisfys the partial search criteria
int CGAL::_FindItemInCache( LPCTSTR szPartialMatchString ) {

    if( m_EntryCache.size() == 0 ) { return -1; }
    if( ( *( m_EntryCache.front() ) <= szPartialMatchString ) && ( *( m_EntryCache.back() ) >= szPartialMatchString ) ) {
        int index = m_IndexOfFirstItemInCache;
        lst< CGalEntry* >::iterator I = m_EntryCache.begin();
        while( ( *( *I ) ) < szPartialMatchString ) {
            ++I;
            ++index;
        }
        return index;
    }

    return -1;
}

    // _GetEntry returns a reference to the desired entry.  If the entry is in the cache, it retrieves it, and if
    //  it is not in the cache, it loads it from the GAL and saves it in the cache
CGAL::CGalEntry* CGAL::_GetEntry( int index )
{
	CGalEntry* pRet = &msc_ErrorEntry_NoGAL;

	if (!_IsLoggedOn() || FAILED(m_hrGALError))
	{
	//   rRet = msc_ErrorEntry_NoGAL;
	}
        // If the entry is in the cache, return it
    else if( ( index >= m_IndexOfFirstItemInCache ) && ( index <= m_IndexOfLastItemInCache ) ) {
        pRet = _GetItemFromCache( index );        
    }
    else if( m_EntryCache.size() == 0 ) {
        // If the cache is empty, LongJump
        // Do a long jump to index, reset the cached data and return the item at index
        pRet = _LongJumpTo( index );
    }
    else if( ( index < m_IndexOfFirstItemInCache ) && ( ( m_IndexOfFirstItemInCache - index  ) <= m_MaxJumpSize ) ) {
        // If index is less than the first index by less than m_MaxJumSize
        // Fill in the entries below the first index and return the item at _index_
        pRet = _GetEntriesAtBeginningOfList( index );
    }
    else if( ( index > m_IndexOfLastItemInCache ) && ( ( index - m_IndexOfLastItemInCache ) <= m_MaxJumpSize ) ) {
        // else if index is greater than the last index by less than m_MaxJumpSize
        // Fill in the entries above the last index and return the item at _index_
        pRet = _GetEntriesAtEndOfList( index );
    }
    else {
        // Do a long jump to index, reset the cached data and return the item at index
        pRet = _LongJumpTo( index );
    }

    return pRet;
}



    // If the ListView needs an item that is far enough away from the current cache block to require a 
    //   new cache block, this function in called.  The cache is destroyed and a new cache block is 
    //   created at the longjump item's index
CGAL::CGalEntry* CGAL::_LongJumpTo( int index ) {

    HRESULT hr;

        // first we have to kill the cache and free the old bookmarks because they will no longer be valid...
    _ResetCache();

        // Seek approximately to the spot that we are looking for...    
    int CacheIndex = index;
    int Offset = m_nBlockSize / 2;

    if( CacheIndex < Offset ) {
        CacheIndex = 0;
    }
    else {
        CacheIndex -= Offset;
    }

    hr = m_pContentsTable->SeekRowApprox( CacheIndex, m_nRows );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_SEEKROWAPPROX_FAILED;
        return &msc_ErrorEntry_SeekRowApproxFailed;
    }

    m_IndexOfFirstItemInCache = CacheIndex;
    m_IndexOfLastItemInCache = m_IndexOfFirstItemInCache - 1;

    // Set the beginningBookmark
    hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfFirstItemInCache );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
        return &msc_ErrorEntry_CreateBookmarkFailed;
    }

    m_bBeginningBookmarkIsValid = true;

    lst< CGalEntry* >::iterator IRet = m_EntryCache.end();


    // Get a block of rows
    LPSRowSet   pRow = NULL;
    hr = m_pContentsTable->QueryRows( m_nBlockSize, 0, &pRow );

    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return &msc_ErrorEntry_QueryRowsFailed;
    }

        // For each item in the block
    for( ULONG i = 0; i < pRow->cRows; i++ ) {

        CGalEntry* pEntry;
        if( FAILED( _MakeGalEntry( pRow->aRow[ i ], &pEntry ) ) ) { 
            lpfnFreeProws( pRow );
            return &msc_ErrorEntry_NoInstanceKeyFound; 
        }

        m_EntryCache.push_back( pEntry );

            // if the current item is equal to the first item in our list, we are done
        m_IndexOfLastItemInCache++;
        if( m_IndexOfLastItemInCache == index ) {
            IRet = --( m_EntryCache.end() ); 
        }
    }


    if( IRet == m_EntryCache.end() ) {
        // There is a small chance that this could happen
        // if there were problems on the server.
        WARNING_OUT(("In CGAL::_LongJumpTo(...) QueryRows only returned %u items", pRow->cRows ));
        WARNING_OUT(("\tm_IndexOfFirstItemInCache = %u, m_IndexOfLastItemInCache = %u, index = %u", m_IndexOfFirstItemInCache, m_IndexOfLastItemInCache, index ));
        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return &msc_ErrorEntry_QueryRowsFailed;
    }

    lpfnFreeProws( pRow );

    ASSERT( ( m_IndexOfLastItemInCache - m_IndexOfFirstItemInCache ) == static_cast< int >( m_EntryCache.size() - 1 ) );

    // Set the beginningBookmark
    hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfItemAfterLastItemInCache );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
        return &msc_ErrorEntry_CreateBookmarkFailed;
    }
    m_bEndBookmarkIsValid = true;

    VERIFYCACHE

    return *IRet;
}


    // If the user is scrolling backwards and comes to an index whose data is not in the cache, we hawe
    //  to get some entries at the beginning of the list... We will start at a position somewhat before the
    //  first item's index  and keep getting items from the GAL until we have all the items up to the first item
    //  in the list.  We continue to jump back a little and get items to the beginning of the list until we have
    //  cached the requested index.  Because we have the item handy, we will return it
CGAL::CGalEntry* CGAL::_GetEntriesAtBeginningOfList( int index ) {
        
    HRESULT hr;
        
        // The beginning bookmark may not be valid, because the user may have been scrolling forward
        //  and because the cache is kept at a constant size, the item at the front bookmark may have
        //  been removed from the cache.  If this is the case, we have to re-create the front bookmark
    if( !m_bBeginningBookmarkIsValid ) {
        if( _CreateBeginningBookmark() ) {
                // This means that the listView needs to be update 
            ListView_RedrawItems( GetHwnd(), 0, m_nRows );
            return &msc_ErrorEntry_FindRowFailed;
        }
    }

    // Seek row to the beginning bookmark -m_nBlockSize items
    long lJumped;
    hr = m_pContentsTable->SeekRow( m_BookmarkOfFirstItemInCache, -m_nBlockSize, &lJumped );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_SEEKROW_FAILED;
        return &msc_ErrorEntry_SeekRowFailed;
    }

    lJumped *= -1; // We have to change the sign on this number ( which will be negative )

    ASSERT( SUCCEEDED( hr ) );

    if( 0 == lJumped ) {
        // We are at the beginning of the list
        m_IndexOfLastItemInCache -= m_IndexOfFirstItemInCache;
        m_IndexOfFirstItemInCache = 0;
    }
    else {
        // Free the beginningBookmark
        hr = m_pContentsTable->FreeBookmark( m_BookmarkOfFirstItemInCache );       
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_FREEBOOKMARK_FAILED;
            return &msc_ErrorEntry_FreeBookmarkFailed;
        }

        // Set the beginningBookmark
        hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfFirstItemInCache );
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
            return &msc_ErrorEntry_CreateBookmarkFailed;
        }
    }

    // QueryRow for lJumped items

    lst< CGalEntry* >::iterator IInsertPos = m_EntryCache.begin();

    // Get a block of rows
    LPSRowSet   pRow = NULL;
    hr = m_pContentsTable->QueryRows( lJumped, 0, &pRow );

    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return &msc_ErrorEntry_QueryRowsFailed;
    }

        // For each item in the block
    for( ULONG i = 0; i < pRow->cRows; i++ ) {

        CGalEntry* pEntry;

        if( FAILED( _MakeGalEntry( pRow->aRow[ i ], &pEntry ) ) ) { 
            lpfnFreeProws( pRow );
            return &msc_ErrorEntry_NoInstanceKeyFound; 
        }

        // if the current item is equal to the first item in our list, we are done
        --m_IndexOfFirstItemInCache;
        m_EntryCache.insert( IInsertPos, pEntry );
    }

    VERIFYCACHE

    lpfnFreeProws( pRow );

    if( FAILED( _KillExcessItemsFromBackOfCache() ) ) {
            // THis ist the only thing that can fail in _KillExcessItemsFromBackOfCache
        return &msc_ErrorEntry_FreeBookmarkFailed;
    }

    ASSERT( ( m_IndexOfLastItemInCache - m_IndexOfFirstItemInCache ) == static_cast< int >( m_EntryCache.size() - 1 ) );
           
    // return the item corresponding to the index
    return _GetItemFromCache( index );
}


HRESULT CGAL::_KillExcessItemsFromBackOfCache( void ) {

    // if the cache size is greater than m_MaxCacheSize
    if( m_EntryCache.size() > static_cast< size_t >( m_MaxCacheSize ) ) {
        // kill as many as we need to from the front of the list, fixing m_IndexOfFirstItemInCache
        int NumItemsToKill = ( m_EntryCache.size() - m_MaxCacheSize );
        while( NumItemsToKill-- ) {
            delete m_EntryCache.back();
            m_EntryCache.erase( --( m_EntryCache.end() ) );
            --m_IndexOfLastItemInCache;
        }

        // Free the beginning bookmark
        if( m_bEndBookmarkIsValid ) {
            // flag the front bookmark as invalid
            m_bEndBookmarkIsValid = false;
            HRESULT hr = m_pContentsTable->FreeBookmark( m_BookmarkOfItemAfterLastItemInCache );       
            if( FAILED( hr ) ) {
                m_hrGALError = GAL_E_FREEBOOKMARK_FAILED;
                return m_hrGALError;
            }
        }
    }
       
    return S_OK;
}


// In certain circumstances _CreateBeginningBookmark will return TRUE to indicate that the listView needs to be updated...
bool CGAL::_CreateBeginningBookmark( void ) {

    HRESULT hr;
    bool bRet = false;

    if( FAILED( hr = _SetCursorTo( *m_EntryCache.front() ) ) ) {
        if( MAPI_E_NOT_FOUND == hr ) {
                // The item is not in the table anymore. We have to
            _LongJumpTo( m_IndexOfFirstItemInCache );            
            return true;
        }
        else {
            m_hrGALError = GAL_E_FINDROW_FAILED;
            return false;
        }
    }

    hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfFirstItemInCache );
    m_bBeginningBookmarkIsValid = true;
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
        return false;
    }

    return false;
}


// ruturn true if the item at IEntry is the item requested at index
bool CGAL::_CreateEndBookmark( int index, lst< CGalEntry* >::iterator& IEntry ) {

    HRESULT hr;
    bool bRet = false;
    IEntry = m_EntryCache.end();

    hr = _SetCursorTo( *m_EntryCache.back() );
    if( FAILED( hr ) ) {



    }
    if( FAILED( hr ) ) {
        if( MAPI_E_NOT_FOUND == hr ) {
                // This means that the listView needs to be update 
            ListView_RedrawItems( GetHwnd(), 0, m_nRows );
            IEntry = m_EntryCache.end();
            return true;
        }
        else {
            m_hrGALError = GAL_E_FINDROW_FAILED;
            return false;
        }
    }

    // Get a block of entries
    LPSRowSet   pRow = NULL;

        // Get a bunch of rows
    hr = m_pContentsTable->QueryRows( m_nBlockSize, 0, &pRow );

    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return false;
    }
    
    // If no entries are returned, this means that we have hit the end of the list
    if( 0 == ( pRow->cRows )  ) { 
        hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfItemAfterLastItemInCache );
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
            return true;
        }

        m_bEndBookmarkIsValid = true;

        IEntry = --( m_EntryCache.end() );
        return true;
    }

    // Verify that the first entry is the last item in our list
    ASSERT( 0 == memcmp( pRow->aRow[ 0 ].lpProps[ INSTANCEKEY_PROP_INDEX ].Value.bin.lpb, m_EntryCache.back()->GetInstanceKey().lpb, pRow->aRow[ 0 ].lpProps[ INSTANCEKEY_PROP_INDEX ].Value.bin.cb ) );
    
        // for each entry returned
    for( ULONG i = 1; i < pRow->cRows; i++ ) {

        CGalEntry* pEntry;
        
        if( FAILED( _MakeGalEntry( pRow->aRow[ i ], &pEntry ) ) ) {
            lpfnFreeProws( pRow );
            return false;
        }

        // push it to the back of the entry list and increment m_IndexOfLastItemInCache
        m_EntryCache.push_back( pEntry );

        m_IndexOfLastItemInCache++;
        if( m_IndexOfLastItemInCache == index ) {
            bRet = true;
            IEntry = --( m_EntryCache.end() );
        }
    }

    lpfnFreeProws( pRow );

    if( FAILED( _KillExcessItemsFromFrontOfCache() ) ) {
            // This is the only thang that can fail in _KillExcessItemsFromFrontOfCache
        return false;
    }

    ASSERT( ( m_IndexOfLastItemInCache - m_IndexOfFirstItemInCache ) == static_cast< int >( m_EntryCache.size() - 1 ) );        

    // Create a bookmark and store it in m_BookmarkOfItemAfterLastItemInCache
    hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfItemAfterLastItemInCache );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
        return true;
    }

    m_bEndBookmarkIsValid = true;

    return bRet;
}


    // If the user is scrolling forwards and the ListView requests an item that is a little bit beyond the 
    //  end of the cache, we have to get some more entries...
CGAL::CGalEntry* CGAL::_GetEntriesAtEndOfList( int index ) {
    
    lst< CGalEntry* >::iterator IRet;
    HRESULT hr;        

    // if m_bEndBookmarkIsValid
    if( m_bEndBookmarkIsValid ) {
        // SeekRow to m_BookmarkOfItemAfterLastItemInCache
        hr = m_pContentsTable->SeekRow( m_BookmarkOfItemAfterLastItemInCache, 0, NULL );
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_SEEKROW_FAILED;
            return &msc_ErrorEntry_SeekRowFailed;
        }
    }
    else {
        // Set the end bookmark to the item after the last item in the cache
        if( _CreateEndBookmark( index, IRet ) ) {
            if( IRet != m_EntryCache.end() ) {
                VERIFYCACHE     
                return *IRet;
            }
            
            // this means that the end item is no longer in the GAL table
            //  we have to update the list view
            _LongJumpTo( index );
            ListView_RedrawItems( GetHwnd(), 0, m_nRows );
            return &msc_ErrorEntry_FindRowFailed;
        }
    }

    if( index > m_IndexOfLastItemInCache ) {
        // Get a block of entries
        LPSRowSet   pRow = NULL;

            // Get a bunch of rows
        hr = m_pContentsTable->QueryRows( m_nBlockSize, 0, &pRow );
    
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_QUERYROWS_FAILED;
            return &msc_ErrorEntry_QueryRowsFailed;
        }
        
        // If no entries are returned, this means that we have hit the end of the list
        if( 0 == ( pRow->cRows )  ) { 
            return m_EntryCache.back();
        }

            // for each entry returned
        for( ULONG i = 0; i < pRow->cRows; i++ ) {

            CGalEntry* pEntry;  
            if( FAILED( _MakeGalEntry( pRow->aRow[ i ], &pEntry ) ) ) {
                lpfnFreeProws( pRow );
                return &msc_ErrorEntry_NoInstanceKeyFound;
            }

                // push it to the back of the entry list and increment m_IndexOfLastItemInCache
            m_EntryCache.push_back( pEntry );

            m_IndexOfLastItemInCache++;
            // if m_IndexOfLastItemInCache == index, store the iterator for when we return the entry
            if( index == m_IndexOfLastItemInCache ) {
                IRet = --( m_EntryCache.end() );
            }
        }
        lpfnFreeProws( pRow );

        // Free m_BookmarkOfItemAfterLastItemInCache
        hr = m_pContentsTable->FreeBookmark( m_BookmarkOfItemAfterLastItemInCache );       
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_FREEBOOKMARK_FAILED;
            return &msc_ErrorEntry_FreeBookmarkFailed;
        }

        
        // Create a bookmark and store it in m_BookmarkOfItemAfterLastItemInCache
        hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfItemAfterLastItemInCache );
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
            return &msc_ErrorEntry_CreateBookmarkFailed;
        }

        ASSERT( ( m_IndexOfLastItemInCache - m_IndexOfFirstItemInCache ) == static_cast< int >( m_EntryCache.size() - 1 ) );
    } 


    if( FAILED( _KillExcessItemsFromFrontOfCache() ) ) {
            // This is the only thang that can fail in _KillExcessItemsFromFrontOfCache
        return &msc_ErrorEntry_FreeBookmarkFailed;
    }
        
    VERIFYCACHE

    // return the entry
    return *IRet;
}


    // The only thing that can fail is freebookmark, in which case GAL_E_FREEBOOKMARK_FAILED is returned
HRESULT CGAL::_KillExcessItemsFromFrontOfCache( void ) {

    // if the cache size is greater than m_MaxCacheSize
    if( m_EntryCache.size() > static_cast< size_t >( m_MaxCacheSize ) ) {

        // kill as many as we need to from the front of the list, fixing m_IndexOfFirstItemInCache
        int NumItemsToKill = ( m_EntryCache.size() - m_MaxCacheSize );
        while( NumItemsToKill-- ) {
            delete m_EntryCache.front();                
            m_EntryCache.erase( m_EntryCache.begin() );
            ++m_IndexOfFirstItemInCache;
        }


        // flag the front bookmark as invalid
        m_bBeginningBookmarkIsValid = false;
        HRESULT hr = m_pContentsTable->FreeBookmark( m_BookmarkOfFirstItemInCache );       
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_FREEBOOKMARK_FAILED;
            return GAL_E_FREEBOOKMARK_FAILED;
        }

    }

    return S_OK;
}


    // _GetItemInCache will return an entry from the cache
    //    the cache size should be set to a small enough number that
    //    the fact that we are using a linear search should not be a problem
    //    if we wanted to support a larger cache, another collection class other than a lst class
    //    would be used ( like a tree or a hash table )
CGAL::CGalEntry* CGAL::_GetItemFromCache( int index ) {
    
    ASSERT( ( m_IndexOfLastItemInCache - m_IndexOfFirstItemInCache ) == static_cast< int >( m_EntryCache.size() - 1 ) );
    lst< CGalEntry* >::iterator I = m_EntryCache.begin();
    int i = m_IndexOfFirstItemInCache;
    while( i != index ) {
        ASSERT( I != m_EntryCache.end() );
        ++i, ++I;
    }
    return *I;
}



    // There may be a registry key that stores the mapi property that the user should 
    //   use to find the ils server and username of people that the user calls with the GAL....
    //   If this reg key exists, the MAPI property will be queried when the user presses the CALL button 
    //   in the dialog....
DWORD CGAL::_GetExchangeAttribute( void ) {


    RegEntry re( msc_szNMPolRegKey, HKEY_CURRENT_USER );
    
    return re.GetNumber( msc_szNMExchangeAtrValue, NM_INVALID_MAPI_PROPERTY );
}

void CGAL::_ResetCache( void ) {
    HRESULT hr;

    lst< CGalEntry* >::iterator I = m_EntryCache.begin();
    while( I != m_EntryCache.end() ) {
        delete ( *I );
        I++;
    }
    m_EntryCache.erase( m_EntryCache.begin(), m_EntryCache.end() );
    m_IndexOfFirstItemInCache = INVALID_CACHE_INDEX;
    m_IndexOfLastItemInCache = INVALID_CACHE_INDEX - 1;
    if( m_bBeginningBookmarkIsValid ) {
        hr = m_pContentsTable->FreeBookmark( m_BookmarkOfFirstItemInCache );       
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_FREEBOOKMARK_FAILED;
            return;
        }
    }
    if( m_bEndBookmarkIsValid ) {
        hr = m_pContentsTable->FreeBookmark( m_BookmarkOfItemAfterLastItemInCache );       
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_FREEBOOKMARK_FAILED;
            return;
        }
    }
}


    // Create a GAL Entry from a SRow structure returned by QueryRows
    // The username and EMail name may be absent, this is not an error
    // if the INSTANCE_KEY is missing, that would constitute an error
HRESULT CGAL::_MakeGalEntry( SRow& rRow, CGalEntry** ppEntry ) {

    *ppEntry = NULL;

    LPSPropValue lpProps = rRow.lpProps;

    LPCTSTR szName;
    if( LOWORD( lpProps[ NAME_PROP_INDEX ].ulPropTag ) != PT_ERROR ) {

#ifdef  UNICODE
        szName = lpProps[ NAME_PROP_INDEX ].Value.lpszW;        
#else 
        szName = lpProps[ NAME_PROP_INDEX ].Value.lpszA;
#endif // UNICODE
    }
    else {
        szName = msc_szNoDisplayName;
    }

	LPCTSTR szEMail;
    if( LOWORD( lpProps[ ACCOUNT_PROP_INDEX ].ulPropTag ) != PT_ERROR ) {

#ifdef  UNICODE
        szEMail = lpProps[ ACCOUNT_PROP_INDEX ].Value.lpszW;
#else 
        szEMail = lpProps[ ACCOUNT_PROP_INDEX ].Value.lpszA;
#endif // UNICODE

    }
    else {
        szEMail = msc_szNoEMailName;
    }
            
        // Get the instance key    
    if( LOWORD( lpProps[ INSTANCEKEY_PROP_INDEX ].ulPropTag ) == PT_ERROR ) {
        m_hrGALError = GAL_E_NOINSTANCEKEY;
        return m_hrGALError;
    }
    ASSERT( PR_INSTANCE_KEY == lpProps[ INSTANCEKEY_PROP_INDEX ].ulPropTag );        
    SBinary& rInstanceKey = lpProps[ INSTANCEKEY_PROP_INDEX ].Value.bin;

        // Get the entryid    
    if( LOWORD( lpProps[ ENTRYID_PROP_INDEX ].ulPropTag ) == PT_ERROR ) {
        m_hrGALError = GAL_E_NOENTRYID;
        return m_hrGALError;
    }
    ASSERT( PR_ENTRYID == lpProps[ ENTRYID_PROP_INDEX ].ulPropTag );        
    SBinary& rEntryID = lpProps[ ENTRYID_PROP_INDEX ].Value.bin;
    
        // Get the display Type
    ULONG ulDisplayType = DT_MAILUSER;
    if( LOWORD( lpProps[ DISPLAY_TYPE_INDEX ].ulPropTag ) != PT_ERROR ) {
        ulDisplayType = lpProps[ DISPLAY_TYPE_INDEX ].Value.ul;
    }

		// Get the business telephone number
	LPCTSTR szBusinessTelephoneNum;
    if( LOWORD( lpProps[ BUSINESS_PHONE_NUM_PROP_INDEX ].ulPropTag ) != PT_ERROR ) {

#ifdef  UNICODE
        szBusinessTelephoneNum = lpProps[ BUSINESS_PHONE_NUM_PROP_INDEX ].Value.lpszW;
#else 
        szBusinessTelephoneNum = lpProps[ BUSINESS_PHONE_NUM_PROP_INDEX ].Value.lpszA;
#endif // UNICODE

    }
    else {
        szBusinessTelephoneNum = msc_szNoBusinessTelephoneNum;
    }

    *ppEntry = new CGalEntry( szName, szEMail, rInstanceKey, rEntryID, ulDisplayType, szBusinessTelephoneNum );

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

CGAL::CGalEntry::CGalEntry( void )
    : m_szName( NULL ), 
      m_szEMail( NULL ),
      m_ulDisplayType( DT_MAILUSER ),
	  m_szBusinessTelephoneNum(NULL)
{ 
    m_EntryID.cb = 0;
    m_EntryID.lpb = NULL;
    m_InstanceKey.cb = 0;
    m_InstanceKey.lpb = NULL;
}

CGAL::CGalEntry::CGalEntry( const CGalEntry& r ) 
    : m_szName( NULL ), 
      m_szEMail( NULL ),
      m_ulDisplayType( DT_MAILUSER ),
	  m_szBusinessTelephoneNum(NULL)
{ 
    m_EntryID.cb = 0;
    m_EntryID.lpb = NULL;
    m_InstanceKey.cb = 0;
    m_InstanceKey.lpb = NULL;
     *this = r; 
}

CGAL::CGalEntry::CGalEntry( LPCTSTR szName, LPCTSTR szEMail, SBinary& rInstanceKey, SBinary& rEntryID, ULONG ulDisplayType, LPCTSTR szBusinessTelephoneNum  ) 
    : m_ulDisplayType( ulDisplayType )
{
    m_EntryID.cb = rEntryID.cb;
    m_InstanceKey.cb = rInstanceKey.cb;

    if( m_EntryID.cb ) {
        m_EntryID.lpb = new BYTE[ m_EntryID.cb ];
        memcpy( m_EntryID.lpb, rEntryID.lpb, m_EntryID.cb );
    }

    if( m_InstanceKey.cb ) {
        m_InstanceKey.lpb = new BYTE[ m_InstanceKey.cb ];
        memcpy( m_InstanceKey.lpb, rInstanceKey.lpb, m_InstanceKey.cb );
    }

    m_szName = PszAlloc( szName );
    m_szEMail = PszAlloc( szEMail );
	m_szBusinessTelephoneNum = PszAlloc( szBusinessTelephoneNum );
}

CGAL::CGalEntry::CGalEntry( LPCTSTR szName, LPCTSTR szEMail ) 
    : m_ulDisplayType( DT_MAILUSER ),
	  m_szBusinessTelephoneNum(NULL)
{
    m_EntryID.cb = 0;
    m_EntryID.lpb = NULL;
    m_InstanceKey.cb = 0;
    m_InstanceKey.lpb = NULL;

    m_szName = PszAlloc( szName );
    m_szEMail = PszAlloc( szEMail );
}


CGAL::CGalEntry::~CGalEntry( void ) {
    delete [] m_szName;
    delete [] m_szEMail;
    delete [] m_EntryID.lpb;
    delete [] m_InstanceKey.lpb;
	delete [] m_szBusinessTelephoneNum;
}


CGAL::CGalEntry& CGAL::CGalEntry::operator=( const CGalEntry& r ) {
    if( this != &r ) {
        
        m_ulDisplayType = r.m_ulDisplayType;

        delete [] m_EntryID.lpb;        
        m_EntryID.lpb = NULL;
        delete [] m_InstanceKey.lpb;    
        m_InstanceKey.lpb = NULL;

        delete [] m_szName;
        delete [] m_szEMail;
		delete [] m_szBusinessTelephoneNum;

        m_szName = NULL;
        m_szEMail = NULL;
		m_szBusinessTelephoneNum = NULL;

        m_EntryID.cb = r.m_EntryID.cb;
        if( m_EntryID.cb ) {
            m_EntryID.lpb = new BYTE[ m_EntryID.cb ];
            memcpy( m_EntryID.lpb, r.m_EntryID.lpb, m_EntryID.cb );
        }

        m_InstanceKey.cb = r.m_InstanceKey.cb;
        if( m_InstanceKey.cb ) {
            m_InstanceKey.lpb = new BYTE[ m_InstanceKey.cb ];
            memcpy( m_InstanceKey.lpb, r.m_InstanceKey.lpb, m_InstanceKey.cb );
        }

        m_szName = PszAlloc( r.m_szName );
        m_szEMail = PszAlloc( r.m_szEMail );
		m_szBusinessTelephoneNum = PszAlloc( r.m_szBusinessTelephoneNum );
    }
    
    return *this;
}

bool CGAL::CGalEntry::operator==( const CGalEntry& r ) const {
    return ( ( m_InstanceKey.cb == r.m_InstanceKey.cb ) && ( 0 == memcmp( &m_InstanceKey.cb, &r.m_InstanceKey.cb, m_InstanceKey.cb ) ) );
}

bool CGAL::CGalEntry::operator>=( LPCTSTR sz ) const {
    return ( 0 <= lstrcmpi( m_szName, sz ) );
}

bool CGAL::CGalEntry::operator<( LPCTSTR sz ) const {
    return ( 0 > lstrcmpi( m_szName, sz ) );
}

bool CGAL::CGalEntry::operator<=( LPCTSTR sz ) const {
    return ( 0 >= lstrcmpi( m_szName, sz ) );
}


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////






/////////////////////////////////////////////////////////////////////////
// Testin functions... These are pretty streight-forward....
#if TESTING_CGAL 
    void CGAL::_VerifyCache( void ) {
#if 0
        if( !IS_ZONE_ENABLED( ghZoneApi, ZONE_GALVERIFICATION_FLAG ) ) { return; }
        HRESULT hr;
        hr = _SetCursorTo( *m_EntryCache.front() );

        lst< CGalEntry* >::iterator I = m_EntryCache.begin();
        while( m_EntryCache.end() != I ) {
            LPSRowSet   pRow;
            hr = m_pContentsTable->QueryRows ( 50, 0, &pRow );
            ASSERT( SUCCEEDED( hr ) );
            for( ULONG i = 0; i < pRow->cRows; i++ ) {
                CGalEntry* pEntry;
                _MakeGalEntry( pRow->aRow[ i ], &pEntry );
                if( ( **I ) != ( *pEntry ) ) {
                    ULONG Count;
                    hr = m_pContentsTable->GetRowCount( 0, &Count );
                    ASSERT( SUCCEEDED( hr ) );
                    ASSERT( 0 );
                    lpfnFreeProws( pRow );
                    delete pEntry;
                    return;
                }
                delete pEntry;
                I++;
                if( m_EntryCache.end() == I ) { break; }

            }
            lpfnFreeProws( pRow );
        }
#endif
    }

    char* _MakeRandomString( void ) {
        static char sz[ 200 ];
        int len = ( rand() % 6 ) + 1;
        sz[ len ] = '\0';
        for( int i = len - 1; len >= 0; len-- ) {
            sz[ len ] = ( rand() % 26 ) + 'a'; 
        }

        return sz;
    }

    void CGAL::_Test( void ) {
        int e = 7557;
        _GetEntry( e );
        for( int o = 0; o < 10; o++ ) {
            _GetEntry( e - o );
        }
        for( int i = 0; i < 500; i++ ) {
            int nEntry = rand() % ( m_nRows - 1 );
            _GetEntry( nEntry );
            if( rand() % 2 ) {
                // Slide for a while
                int j, NewIndex;
                int nSlide = rand() % 100;
                if( rand() % 2 ) {
                    // Slide Up for a while
                    for( j = 0; j < nSlide; j++ ) {
                        NewIndex = j + nEntry;
                        if( ( NewIndex >= 0 ) && ( NewIndex < static_cast< int >( m_nRows ) ) ) {
                            _GetEntry( NewIndex );
                        }
                    }

                }
                else {
                        // Slide Down for a while
                    for( j = 0; j < nSlide; j++ ) {
                        NewIndex = nEntry - j;
                        if( ( NewIndex >= 0 ) && ( NewIndex < static_cast< int >( m_nRows ) ) ) {
                            _GetEntry( NewIndex );
                        }
                    }
                }
            }
        }
        TRACE_OUT(( "The first test is successful!" ));

        _ResetCache();
        
        for( i = 0; i < 500; i++ ) {
            int nEntry = OnListFindItem( _MakeRandomString() );
            if( rand() % 2 ) {
                // Slide for a while
                int j, NewIndex;
                int nSlide = rand() % 100;
                if( rand() % 2 ) {
                    // Slide Up for a while
                    for( j = 0; j < nSlide; j++ ) {
                        NewIndex = j + nEntry;
                        if( ( NewIndex >= 0 ) && ( NewIndex < static_cast< int >( m_nRows )  ) ) {
                            _GetEntry( NewIndex );
                        }
                    }

                }
                else {
                        // Slide Down for a while
                    for( j = 0; j < nSlide; j++ ) {
                        NewIndex = nEntry - j;
                        if( ( NewIndex >= 0 ) && ( NewIndex < static_cast< int >( m_nRows )  ) ) {
                            _GetEntry( NewIndex );
                        }

                    }
                }
            }

        }

        TRACE_OUT(( "The second test is successful!" ));

    }

#endif // #if TESTING_CGAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\getip.cpp ===
#include "precomp.h"
#include "getip.h"

#define MAX_HOSTNAME_LENGTH	80

int __stdcall GetIPAddresses(char **szAddressArray, int numAddresses)
{
	hostent *pHostent;
	char szHostname[MAX_HOSTNAME_LENGTH];
	int nRet, nIndex;
	int nCount;
	in_addr* pInterfaceAddr;


	nRet = gethostname(szHostname, MAX_HOSTNAME_LENGTH);
	szHostname[MAX_HOSTNAME_LENGTH-1] = '\0';


	if (nRet < 0)
	{
		return nRet;
	}


	pHostent = gethostbyname(szHostname);

	if (pHostent == NULL)
	{
		return -1;
	}


	nCount = 0;
	for (nIndex = 0; nIndex < numAddresses; nIndex++)
	{
		if (pHostent->h_addr_list[nIndex] != NULL)
			nCount++;
		else
			break;
	}

	// enumerate the addresses backwards - PPP addresses will get listed
	// first ???
	for (nIndex = (nCount-1); nIndex >= 0; nIndex--)
	{
		pInterfaceAddr = (in_addr*)(pHostent->h_addr_list[nIndex]);
		lstrcpy(szAddressArray[nCount - 1 - nIndex], inet_ntoa(*pInterfaceAddr));
	}

	return nCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\getip.h ===
#ifndef NMCONF_GETIP_H
#define NMCONF_GETIP_H


int __stdcall GetIPAddresses(char **szAddressArray, int numAddresses);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\history.h ===
// File: history.h

#ifndef _HISTORY_H_
#define _HISTORY_H_

#include "calv.h"


// The header for a record in the call log file
typedef struct _tagLogHdr {
	DWORD dwSize;              // size of this entire record
	DWORD dwCLEF;              // CallLogEntry Flags (CLEF_*)
	DWORD dwPF;                // Participant flags (PF_*)
	DWORD cbName;              // size of szName, in bytes, including NULL
        DWORD cbData;              // size of rgData, in bytes
        DWORD cbCert;              // size of certificate, in bytes
	SYSTEMTIME 	sysTime;       // date/time of record creation
//  WCHAR szName;              // null terminated display name (in UNICODE)
//  BYTE  ri[];                // Roster Information
} LOGHDR;


class CHISTORY : public CALV
{
private:
	HANDLE m_hFile;
	LPTSTR m_pszFile;

	int
	Compare
	(
		LPARAM	param1,
		LPARAM	param2
	);
	static
	int
	CALLBACK
	StaticCompare
	(
		LPARAM	param1,
		LPARAM	param2,
		LPARAM	pThis
	);

public:
	CHISTORY();
	~CHISTORY();

	VOID CmdDelete(void);
	VOID CmdProperties(void);

	// CALV methods
	VOID ShowItems(HWND hwnd);
	VOID ClearItems(void);
	VOID OnCommand(WPARAM wParam, LPARAM lParam);

	//
	HANDLE  OpenLogFile(VOID);
	BOOL    FSetFilePos(DWORD dwOffset);
	BOOL    FReadData(PVOID pv, UINT cb);
	HRESULT ReadEntry(DWORD dwOffset, LOGHDR * pLogHdr, LPTSTR * ppszName, LPTSTR * ppszAddress);
	VOID    LoadFileData(HWND hwnd);
	HRESULT WriteData(LPDWORD pdwOffset, PVOID pv, DWORD cb);
	HRESULT DeleteEntry(DWORD dwOffset);

	UINT    GetStatusString(DWORD dwCLEF);
};

#endif /* _HISTORY_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\history.cpp ===
// File: history.cpp

#include "precomp.h"
#include "resource.h"

#include "dirutil.h"
#include "upropdlg.h"
#include "history.h"

// CCallLogEntry flags:
const DWORD CLEF_ACCEPTED =			0x00000001;
const DWORD CLEF_REJECTED =			0x00000002;
const DWORD CLEF_AUTO_ACCEPTED =	0x00000004; // call was auto-accepted
const DWORD CLEF_TIMED_OUT =		0x00000008; // call was rejected due to timeout
const DWORD CLEF_SECURE =           0x00000010; // call was secure

const DWORD CLEF_NO_CALL  =         0x40000000; // No call back information
const DWORD CLEF_DELETED  =         0x80000000; // Record marked for deletion

const WCHAR g_cszwULS[] = L"ULS:";

static const int _rgIdMenu[] = {
	IDM_DLGCALL_DELETE,
	0
};


/*  C  H  I  S  T  O  R  Y  */
/*-------------------------------------------------------------------------
    %%Function: CHISTORY

-------------------------------------------------------------------------*/
CHISTORY::CHISTORY() :
	CALV(IDS_DLGCALL_HISTORY, II_HISTORY, _rgIdMenu)
{
	DbgMsg(iZONE_OBJECTS, "CHISTORY - Constructed(%08X)", this);

	RegEntry re(LOG_INCOMING_KEY, HKEY_CURRENT_USER);
	m_pszFile = PszAlloc(re.GetString(REGVAL_LOG_FILE));

	// Make sure file exists and can be read/written
	m_hFile = OpenLogFile();
	SetAvailable(NULL != m_hFile);
}

CHISTORY::~CHISTORY()
{
	if (NULL != m_hFile)
	{
		CloseHandle(m_hFile);
	}
	delete m_pszFile;

	DbgMsg(iZONE_OBJECTS, "CHISTORY - Destroyed(%08X)", this);
}


int
CHISTORY::Compare
(
	LPARAM	param1,
	LPARAM	param2
)
{
	int ret = 0;

	LPTSTR pszName1, pszAddress1;
	LPTSTR pszName2, pszAddress2;
	LOGHDR logHdr1, logHdr2;

	if (SUCCEEDED(ReadEntry((DWORD)param1, &logHdr1, &pszName1, &pszAddress1)))
	{
		if (SUCCEEDED(ReadEntry((DWORD)param2, &logHdr2, &pszName2, &pszAddress2)))
		{
			FILETIME ft1, ft2;

			SystemTimeToFileTime(&logHdr1.sysTime, &ft1);
			SystemTimeToFileTime(&logHdr2.sysTime, &ft2);

			// Sort in reverse order so most recent is at the top
			ret = -CompareFileTime(&ft1, &ft2);

			delete pszName2;
			delete pszAddress2;
		}

		delete pszName1;
		delete pszAddress1;
	}

	return(ret);
}


int
CALLBACK
CHISTORY::StaticCompare
(
	LPARAM	param1,
	LPARAM	param2,
	LPARAM	pThis
)
{
	return(reinterpret_cast<CHISTORY*>(pThis)->Compare(param1, param2));
}


///////////////////////////////////////////////////////////////////////////
// CALV methods


/*  S H O W  I T E M S  */
/*-------------------------------------------------------------------------
    %%Function: ShowItems

-------------------------------------------------------------------------*/
VOID CHISTORY::ShowItems(HWND hwnd)
{
	CALV::SetHeader(hwnd, IDS_ADDRESS);

	TCHAR szReceived[CCHMAXSZ];
	if( FLoadString(IDS_RECEIVED, szReceived, CCHMAX(szReceived)) )
	{
		LV_COLUMN lvc;
		ClearStruct(&lvc);
		lvc.mask = LVCF_TEXT | LVCF_SUBITEM;
		lvc.pszText = szReceived;
		lvc.iSubItem = IDI_MISC1;
		ListView_InsertColumn(hwnd, IDI_MISC1, &lvc);
	}

	if (!FAvailable())
		return;

	LoadFileData(hwnd);

	ListView_SortItems( hwnd, StaticCompare, (LPARAM) this );
}


VOID CHISTORY::ClearItems(void)
{
	CALV::ClearItems();

	HWND hWndListView = GetHwnd();
	if( IsWindow(hWndListView) )
	{
		ListView_DeleteColumn(hWndListView, IDI_MISC1);
	}
}


VOID CHISTORY::OnCommand(WPARAM wParam, LPARAM lParam)
{
	switch (GET_WM_COMMAND_ID(wParam, lParam))
		{
	case IDM_DLGCALL_DELETE:
		CmdDelete();
		break;
	case IDM_DLGCALL_PROPERTIES:
		CmdProperties();
		break;
	default:
		CALV::OnCommand(wParam, lParam);
		break;
		}
}

VOID CHISTORY::CmdDelete(void)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return;

	LPARAM lParam = LParamFromItem(iItem);
	if (SUCCEEDED(DeleteEntry((DWORD)lParam)))
	{
		DeleteItem(iItem);
	}
}


UINT CHISTORY::GetStatusString(DWORD dwCLEF)
{
	if (CLEF_ACCEPTED & dwCLEF)
		return IDS_HISTORY_ACCEPTED;

	if (CLEF_TIMED_OUT & dwCLEF)
		return IDS_HISTORY_NOT_ANSWERED;

	ASSERT(CLEF_REJECTED & dwCLEF);
	return IDS_HISTORY_IGNORED;
}


VOID CHISTORY::CmdProperties(void)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return;

	LPTSTR pszName;
	LPTSTR pszAddress;
	TCHAR  szStatus[CCHMAXSZ];
	TCHAR  szTime[CCHMAXSZ];
	LOGHDR logHdr;
	PBYTE  pbCert = NULL;
        PCCERT_CONTEXT pCert = NULL;

	LPARAM lParam = LParamFromItem(iItem);

	if (SUCCEEDED(ReadEntry((DWORD)lParam, &logHdr, &pszName, &pszAddress)))
	{
	    if (logHdr.dwCLEF & CLEF_SECURE)  // is secure call
	    {
	        ASSERT(logHdr.cbCert);
	        pbCert = new BYTE[logHdr.cbCert];
                if (FSetFilePos(lParam+sizeof(logHdr)+logHdr.cbName+logHdr.cbData))
	        {
                    if (FReadData(pbCert, logHdr.cbCert))
                    {
                        pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, logHdr.cbCert);
                        if (NULL == pCert)
                        {
                            WARNING_OUT(("Certificate in Call Log is damaged."));
                        }
                    }
	        }
	        delete []pbCert;
	    }
	
            FLoadString(GetStatusString(logHdr.dwCLEF), szStatus, CCHMAX(szStatus));
            FmtDateTime(&logHdr.sysTime, szTime, CCHMAX(szTime));

            if (NULL == pszAddress)
            {
                pszAddress = PszLoadString(IDS_HISTORY_NO_ADDRESS);
            }

            UPROPDLGENTRY rgProp[] = {
                {IDS_UPROP_ADDRESS,  pszAddress},
                {IDS_UPROP_STATUS,   szStatus},
                {IDS_UPROP_RECEIVED, szTime},
            };

			CUserPropertiesDlg dlgUserProp(GetHwnd(), IDI_LARGE);
			dlgUserProp.DoModal(rgProp, ARRAY_ELEMENTS(rgProp), pszName, pCert);
	}

        if ( pCert )
            CertFreeCertificateContext ( pCert );

	delete pszName;
	delete pszAddress;
}


///////////////////////////////////////////////////////////////////////////


/*  O P E N  L O G  F I L E  */
/*-------------------------------------------------------------------------
    %%Function: OpenLogFile

    Open the log file and return a handle to file.
    Return NULL if there was a problem.
-------------------------------------------------------------------------*/
HANDLE CHISTORY::OpenLogFile(VOID)
{
	HANDLE hFile = CreateFile(m_pszFile, GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
		OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (INVALID_HANDLE_VALUE == hFile)
	{
		ERROR_OUT(("OpenLogFile: Unable to open call log file"));
		hFile = NULL;
	}

	return hFile;
}

BOOL CHISTORY::FSetFilePos(DWORD dwOffset)
{
	ASSERT(NULL != m_hFile);
	return (INVALID_FILE_SIZE != SetFilePointer(m_hFile, dwOffset, NULL, FILE_BEGIN));
}


/*  L O A D  F I L E  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: LoadFileData

    Load the call log data from the file
-------------------------------------------------------------------------*/
VOID CHISTORY::LoadFileData(HWND hwnd)
{
	HANDLE hFile = OpenLogFile();
	if (NULL == hFile)
		return;

	LPTSTR pszName, pszAddress;
	LOGHDR logHdr;
	DWORD dwOffset = 0;

	HRESULT hr = S_OK;
	while (SUCCEEDED(hr))
	{
		hr = ReadEntry(dwOffset, &logHdr, &pszName, &pszAddress);
		if (S_OK == hr)
		{
			TCHAR szTime[CCHMAXSZ];
            FmtDateTime(&logHdr.sysTime, szTime, CCHMAX(szTime));

			DlgCallAddItem(hwnd, pszName, pszAddress, II_COMPUTER, dwOffset, 0,
				szTime);
		}

		dwOffset += logHdr.dwSize;

		delete pszName;
		pszName = NULL;
		delete pszAddress;
		pszAddress = NULL;
	}

	CloseHandle(hFile);
}


/*  R E A D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: ReadEntry

    Read the next entry from the file.

    Return Values:
    	S_OK    - data was read successfully
    	S_FALSE - data exists, but was deleted
    	E_FAIL  - problem reading file
-------------------------------------------------------------------------*/
HRESULT CHISTORY::ReadEntry(DWORD dwOffset,
	LOGHDR * pLogHdr, LPTSTR * ppszName, LPTSTR * ppszAddress)
{
	ASSERT(NULL != m_hFile);

	*ppszName = NULL;
	*ppszAddress = NULL;

	if (!FSetFilePos(dwOffset))
		return E_FAIL;

	// Read record header
	if (!FReadData(pLogHdr, sizeof(LOGHDR)) )
		return E_FAIL;
	
	// Read Name
	WCHAR szwName[CCHMAXSZ_NAME];
	if (!FReadData(szwName, min(pLogHdr->cbName, sizeof(szwName))))
		return E_FAIL;

	*ppszName = PszFromBstr(szwName);

	if (FReadData(szwName, min(pLogHdr->cbData, sizeof(szwName))))
	{
		LPCWSTR pchw = _StrStrW(szwName, g_cszwULS);
		if (NULL != pchw)
		{
			pchw += CCHMAX(g_cszwULS)-1; // -1 for NULL
			*ppszAddress = PszFromBstr(pchw);
		}
	}

	return (0 == (pLogHdr->dwCLEF & CLEF_DELETED)) ? S_OK : S_FALSE;
}


/*  R E A D  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: FReadData

-------------------------------------------------------------------------*/
BOOL CHISTORY::FReadData(PVOID pv, UINT cb)
{
	DWORD cbRead;

	ASSERT(NULL != m_hFile);
	ASSERT(NULL != pv);

	if (0 == cb)
		return TRUE;

	if (!ReadFile(m_hFile, pv, cb, &cbRead, NULL))
		return FALSE;

	return (cb == cbRead);
}


/*  D E L E T E  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: DeleteEntry

    Delete a single entry.
-------------------------------------------------------------------------*/
HRESULT CHISTORY::DeleteEntry(DWORD dwOffset)
{
	// Calculate offset to "CLEF"
	dwOffset += FIELD_OFFSET(LOGHDR,dwCLEF);

	if (!FSetFilePos(dwOffset))
		return E_FAIL;

	DWORD dwFlags;
	if (!FReadData(&dwFlags, sizeof(dwFlags)))
		return E_FAIL;

	dwFlags = dwFlags | CLEF_DELETED;

	if (!FSetFilePos(dwOffset))
		return E_FAIL;

	return WriteData(&dwOffset, &dwFlags, sizeof(dwFlags));
}


/*  W R I T E  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: WriteData

    Write the data to the file.
    The file will be automatically opened/close if hFile is NULL.
-------------------------------------------------------------------------*/
HRESULT CHISTORY::WriteData(LPDWORD pdwOffset, PVOID pv, DWORD cb)
{
	ASSERT(NULL != m_hFile);
	ASSERT(0 != cb);
	ASSERT(NULL != pv);
	ASSERT(NULL != pdwOffset);
	ASSERT(INVALID_FILE_SIZE != *pdwOffset);

	HRESULT hr = E_FAIL;

	if (FSetFilePos(*pdwOffset))
	{
		DWORD cbWritten;
		if (WriteFile(m_hFile, pv, cb, &cbWritten, NULL) && (cb == cbWritten))
		{
			*pdwOffset += cbWritten;
			hr = S_OK;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\ldap.h ===
// File: ldap.h

#ifndef _CLDAP_H_
#define _CLDAP_H_

#include <winldap.h>
#include "oblist.h"
#include "calv.h"


#define LDAP_PORT_W2K		1002			//	Default W2K ldap port (1002)...
#define	DEFAULT_LDAP_PORT	LDAP_PORT_W2K
#define	ALTERNATE_LDAP_PORT	LDAP_PORT


// Generic user data
typedef struct {
	TCHAR szEmail[CCHMAXSZ_EMAIL];
	TCHAR szName[CCHMAXSZ_NAME];
	TCHAR szFirst[CCHMAXSZ_FIRSTNAME];
	TCHAR szLast[CCHMAXSZ_LASTNAME];
	TCHAR szComment[CCHMAXSZ_COMMENT];
	TCHAR szVersion[CCHMAXSZ_VERSION];
	BOOL  fAudioSend;
	BOOL  fVideoSend;
} LDAPUSERDATA;

typedef struct _dirCache {
	LPTSTR pszServer;         // the server name
	DWORD  dwTickExpire;      // expiration time
	LPBYTE pData;             // pointer to linked list of server data
} DIRCACHE;


class CLDAP : public CALV
{
private:
	LDAP * m_pLdap;
	ULONG  m_ulPort;
	TCHAR  m_szServer[CCHMAXSZ_SERVER];
	TCHAR  m_szAddress[CCHMAXSZ_SERVER];
	HANDLE m_hThread;
	ULONG  m_msgId;
	HWND   m_hWnd;
	HANDLE	m_hSearchMutex;
	bool	m_bSearchCancelled;

public:
	// Constructor and destructor
	CLDAP();
	~CLDAP();

	VOID SetServer(LPCTSTR pcszServer);
	LPCTSTR PszServer(void)   {return m_szServer;}

	BOOL FLoggedOn(void)      {return (NULL != m_pLdap);}
	BOOL FOpenServer(void);
	VOID CloseServer(void);
	HRESULT DoQuery(void);
	VOID AddEntries(LDAPMessage * pResult);
	BOOL FGetUserData(LDAPUSERDATA * pLdapUserData);
	LPTSTR GetNextAttribute(LPCTSTR pszExpect, LPTSTR psz, int cchMax, LPTSTR pszAttrib, LDAPMessage * pEntry, BerElement * pElement);

	VOID StopSearch(void);
	VOID StartSearch(void);
	VOID AsyncSearch(void);
	static DWORD CALLBACK _sAsyncSearchThreadFn(LPVOID pv);
	VOID EnsureThreadStopped(void);

	static DWORD CALLBACK _sAsyncPropertyThreadFn(LPVOID pv);
	VOID ShowProperties(void);

	// CALV methods
	VOID ShowItems(HWND hwnd);
	VOID ClearItems(void);
	BOOL GetSzAddress(LPTSTR psz, int cchMax, int iItem);
	VOID OnCommand(WPARAM wParam, LPARAM lParam);
	VOID CmdProperties(void);
	VOID CmdAddToWab(void);
	virtual RAI * GetAddrInfo(void);
	BOOL GetSzName(LPTSTR psz, int cchMax, int iItem);

	void
	CacheServerData(void);

	int  GetIconId(LPCTSTR psz);

private:

	void
	forceSort(void);

	int
	lvAddItem
	(
		int		item,
		int		iInCallImage,
		int		iAudioImage,
		int		iVideoImage,
		LPCTSTR	address,
		LPCTSTR	firstName,
		LPCTSTR	lastName,
		LPCTSTR	location,
		LPCTSTR	comments
	);

	void
	FreeDirCache
	(
		DIRCACHE *	pDirCache
	);

	void
	DirComplete
	(
		bool	fPostUiUpdate
	);

	POSITION
	FindCachedData(void);

	void
	ClearServerCache(void);

	void
	DisplayDirectory(void);

private:

	int			m_uniqueId;
	BOOL		m_fDirInProgress;
	UINT		m_cTotalEntries;
	UINT		m_cEntries;
	BOOL		m_fHaveRefreshed;
	DWORD		m_dwTickStart;
	BOOL        m_fIsCacheable;   // Data can be cached
	BOOL		m_fNeedsRefresh;
	BOOL		m_fCancelling;
	BOOL        m_fCacheDirectory; // TRUE if directory data should be cached
	DWORD       m_cMinutesExpire;  // Number of minutes before cached data expires
	COBLIST     m_listDirCache;    // list of cached data (DIRCACHE)
};


#endif /* _CLDAP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\ldap.cpp ===
// File: ldap.cpp

#include "precomp.h"
#include "resource.h"

#include "mapidefs.h"
#include "pfnwldap.h"
#include "ldap.h"
#include "wab.h"

#include "dirutil.h"
#include "dlgcall2.h" // for WM_DISPLAY_MESSAGE
#include "upropdlg.h"

#define CDIRCACHE_IMAGES			3

// static strings
static const TCHAR s_szSearchFormat3[]  = TEXT("(&(objectClass=RTPerson)(cn=%s)%s)");
static const TCHAR s_szSearchFormat2[]  = TEXT("(&(objectClass=RTPerson)(cn=%s)(sappid=ms-netmeeting)(sprotid=h323)%s)");
static const TCHAR s_szSearchCategory[] = TEXT("(ILSA39321630=%d)");

static LPCTSTR s_pszOrg                 = TEXT("o=Microsoft");

static const TCHAR s_cszAttribShow[]      = TEXT("sFlags");        // "Hide Me" (1=Show, 0=Hidden)
static const TCHAR s_cszAttribEmail[]     = TEXT("cn");            // Email address
static const TCHAR s_cszAttribFirstName[] = TEXT("givenName");     // First Name
static const TCHAR s_cszAttribLastName[]  = TEXT("surName");       // Last Name
static const TCHAR s_cszAttribLocation[]  = TEXT("location");		   // Location
static const TCHAR s_cszAttribComment[]   = TEXT("comment");       // Comments

static const TCHAR s_cszAttribInACall[]   = TEXT("ilsA26214430");  // 400 = in a call
static const TCHAR s_cszAttribVersion[]   = TEXT("ilsA26279966");  // 401 = version number
static const TCHAR s_cszAttribAudio[]     = TEXT("ilsA32833566");  // 501 = send audio
static const TCHAR s_cszAttribVideo[]     = TEXT("ilsA32964638");  // 503 = send video
static const TCHAR s_cszAttribCategory[]  = TEXT("ilsA39321630");  // 600 = category


static LPCTSTR s_rgAttrNameAddr[] = {
	(LPTSTR) s_cszAttribShow,
	(LPTSTR) s_cszAttribEmail,
	(LPTSTR) s_cszAttribFirstName,
	(LPTSTR) s_cszAttribLastName,
	(LPTSTR) s_cszAttribLocation,
	(LPTSTR) s_cszAttribInACall,
	(LPTSTR) s_cszAttribAudio,
	(LPTSTR) s_cszAttribVideo,
	(LPTSTR) s_cszAttribComment,
	NULL};


static LPCTSTR s_rgAttrAll[] = {
	(LPTSTR) s_cszAttribFirstName,
	(LPTSTR) s_cszAttribLastName,
	(LPTSTR) s_cszAttribComment,
	(LPTSTR) s_cszAttribAudio,
	(LPTSTR) s_cszAttribVideo,
	(LPTSTR) s_cszAttribVersion,
	(LPTSTR) s_cszAttribCategory,
	NULL};


static const int _rgIdMenu[] = {
	IDM_DLGCALL_SPEEDDIAL,
	IDM_DLGCALL_WAB,
	-1,
	IDM_DLGCALL_REFRESH,
	IDM_DLGCALL_STOP,
	0
};

// Local functions
VOID ConvertVersionInfo(LPTSTR pszVersion, LPTSTR pszCategory);


///////////////////////////////////////////////////////////////////////

CLDAP::CLDAP() :
	CALV(0, II_SERVER, _rgIdMenu),
	m_pLdap(NULL),
	m_ulPort(DEFAULT_LDAP_PORT),
	m_msgId(0),
	m_hThread(NULL),
	m_hWnd( NULL ),
	m_hSearchMutex( NULL ),

	m_fDirInProgress( FALSE ),
	m_cTotalEntries( 0 ),
	m_cEntries( 0 ),
	m_fHaveRefreshed( FALSE ),
	m_dwTickStart( 0 ),
	m_fIsCacheable( FALSE ),
	m_fNeedsRefresh( FALSE ),
	m_bSearchCancelled( false ),
	m_uniqueId( 0 )
{
	DbgMsg(iZONE_OBJECTS, "CLDAP - Constructed(%08X)", this);

	HRESULT hr = WLDAP::Init();
	SetAvailable(S_OK == hr);

	m_szServer[0] = _T('\0');
	m_szAddress[0] = _T('\0');
	
	m_hSearchMutex = CreateMutex( NULL, false, NULL );

	RegEntry reUI(UI_KEY, HKEY_CURRENT_USER);
	m_fCacheDirectory = (0 != reUI.GetNumber(
		REGVAL_CACHE_DIRECTORY, DEFAULT_CACHE_DIRECTORY));
	
	m_cMinutesExpire = reUI.GetNumber(
		REGVAL_CACHE_DIRECTORY_EXPIRATION, DEFAULT_CACHE_DIRECTORY_EXPIRATION);

}

CLDAP::~CLDAP()
{
	CloseServer();

	if (NULL != m_hThread)
	{
		WARNING_OUT(("CLDAP - waiting for AsyncSearch Thread to exit (start)"));
		WaitForSingleObject(m_hThread, 10000); // 10 seconds max
		WARNING_OUT(("CLDAP - waiting for AsyncSearch to exit (end)"));
	}

	if( m_hSearchMutex )
	{
		CloseHandle( m_hSearchMutex );
	}

	// Free any cached data
	while (!m_listDirCache.IsEmpty())
	{
		DIRCACHE * pDirCache = (DIRCACHE *) m_listDirCache.RemoveHead();
		ASSERT(NULL != pDirCache);
		FreeDirCache(pDirCache);
	}

	DbgMsg(iZONE_OBJECTS, "CLDAP - Destroyed(%08X)", this);
}




///////////////////////////////////////////////////////////////////////////
// CALV methods


/*  S H O W  I T E M S  */
/*-------------------------------------------------------------------------
    %%Function: ShowItems

-------------------------------------------------------------------------*/
VOID CLDAP::ShowItems(HWND hwnd)
{
	DBGENTRY(CLDAP::ShowItems);

	m_hWnd = hwnd;
	SetWindow( hwnd );		//	set in base class too...

	CALV::ClearItems();
	DisplayDirectory();

	DBGEXIT(CLDAP::ShowItems);
}


/*  C L E A R  I T E M S  */
/*-------------------------------------------------------------------------
    %%Function: ClearItems

-------------------------------------------------------------------------*/
VOID CLDAP::ClearItems(void)
{
	DBGENTRY( CLDAP::ClearItems );

	StopSearch();

	DBGEXIT( CLDAP::ClearItems );
}


/* virtual */
RAI * CLDAP::GetAddrInfo(void)
{
	DBGENTRY(CLDAP::GetAddrInfo);

	int		selectedItem	= CALV::GetSelection();
	RAI *	pRai			= NULL;

	if( selectedItem != -1 )
	{
		if( (pRai = new RAI) != NULL )
		{
			pRai->cItems		= 1;
			pRai->rgDwStr->dw	= NM_ADDR_ULS;

			GetSzName( pRai->szName, CCHMAX( pRai->szName ), selectedItem );

			TCHAR	buffer[ CCHMAXSZ ];

			GetSzAddress( buffer, CCHMAX( buffer ),selectedItem );
			pRai->rgDwStr->psz = PszAlloc( buffer );
		}
	}

	DBGEXIT(CLDAP::GetAddrInfo);

	return( pRai );
}


/*  G E T  S Z  A D D R E S S  */
/*-------------------------------------------------------------------------
    %%Function: GetSzAddress

-------------------------------------------------------------------------*/
BOOL CLDAP::GetSzAddress(LPTSTR psz, int cchMax, int iItem)
{
	DBGENTRY(CLDAP::GetSzAddress);

	BOOL bRet = TRUE;

	int cch = lstrlen(m_szServer);

	if ((cch+2) < cchMax)
	{
		lstrcpy(psz, m_szServer);
		psz += cch;
		*psz++ = _T('/');
		cchMax -= (cch+1);

		bRet = CALV::GetSzData( psz, cchMax, iItem, COLUMN_INDEX_ADDRESS );
	}
	else
	{
		bRet = FALSE;
	}


	DBGEXIT(CLDAP::GetSzAddress);
	
	return bRet;
}


/*  O N  C O M M A N D  */
/*-------------------------------------------------------------------------
    %%Function: OnCommand

-------------------------------------------------------------------------*/
VOID CLDAP::OnCommand(WPARAM wParam, LPARAM lParam)
{
	switch (GET_WM_COMMAND_ID(wParam, lParam))
		{
	case IDM_DLGCALL_STOP:
		StopSearch();
		break;
	case IDM_DLGCALL_REFRESH:
		if (NULL == m_hThread)
		{
			CALV::ClearItems();
			StartSearch();
		}
		break;
	case IDM_DLGCALL_WAB:
		CmdAddToWab();
		break;
	default:
		CALV::OnCommand(wParam, lParam);
		break;
		}
}


/*  C M D  P R O P E R T I E S  */
/*-------------------------------------------------------------------------
    %%Function: CmdProperties

-------------------------------------------------------------------------*/
VOID CLDAP::CmdProperties(void)
{
	DBGENTRY(CLDAP::CmdProperties);

	DWORD dwThID;

	HANDLE hThread = CreateThread(NULL, 0, _sAsyncPropertyThreadFn,
                             (LPVOID) this, 0, &dwThID);
	CloseHandle(hThread);

	DBGEXIT(CLDAP::CmdProperties);
}

DWORD CALLBACK CLDAP::_sAsyncPropertyThreadFn(LPVOID pv)
{
	DBGENTRY(CLDAP::_sAsyncPropertyThreadFn);

	CLDAP * pThis = (CLDAP *) pv;
	ASSERT(NULL != pThis);
	pThis->ShowProperties();

	DBGEXIT(CLDAP::_sAsyncPropertyThreadFn);

	return 0;
}

VOID CLDAP::ShowProperties(void)
{
	DBGENTRY(CLDAP::ShowProperties);

	SetBusyCursor(TRUE);
	LDAPUSERDATA ldapUserData;
	BOOL fOk = FGetUserData(&ldapUserData);
	SetBusyCursor(FALSE);
	if (!fOk)
		return;

	TCHAR szHasHardware[CCHMAXSZ];
	FLoadString(IDS_HARDWARE_DETECTED, szHasHardware, CCHMAX(szHasHardware));
	TCHAR szNoHardware[CCHMAXSZ];
	FLoadString(IDS_NO_HARDWARE_DETECTED, szNoHardware, CCHMAX(szNoHardware));

	UPROPDLGENTRY rgProp[] = {
		{IDS_UPROP_EMAIL, ldapUserData.szEmail},
		{IDS_UPROP_COMMENTS,  ldapUserData.szComment},
		{IDS_UPROP_VIDEO, ldapUserData.fVideoSend ? szHasHardware : szNoHardware},
		{IDS_UPROP_AUDIO, ldapUserData.fAudioSend ? szHasHardware : szNoHardware},
		{IDS_UPROP_VERSION,   ldapUserData.szVersion},
	};

	CUserPropertiesDlg dlgUserProp(GetHwnd(), IDI_LARGE);
	dlgUserProp.DoModal(rgProp, ARRAY_ELEMENTS(rgProp), ldapUserData.szName, NULL);

	DBGEXIT(CLDAP::ShowProperties);
}


/*  C M D  A D D  T O  W A B  */
/*-------------------------------------------------------------------------
    %%Function: CmdAddToWab

-------------------------------------------------------------------------*/
VOID CLDAP::CmdAddToWab(void)
{
	DBGENTRY(CLDAP::CmdAddToWab);

	LDAPUSERDATA ldapUserData;
	if (!FGetUserData(&ldapUserData))
		return;

	CreateWabEntry(ldapUserData.szName, ldapUserData.szFirst, ldapUserData.szLast, ldapUserData.szEmail,
		NULL, NULL, ldapUserData.szComment, m_szServer);

	DBGEXIT(CLDAP::CmdAddToWab);
}

///////////////////////////////////////////////////////////////////////////


/*  S E T  S E R V E R  */
/*-------------------------------------------------------------------------
    %%Function: SetServer

-------------------------------------------------------------------------*/
VOID CLDAP::SetServer(LPCTSTR pcszServer)
{
	DBGENTRY(CLDAP::SetServer);

	if ((0 != lstrcmpi(m_szServer, pcszServer)) || (DEFAULT_LDAP_PORT != m_ulPort))
	{
		CloseServer();
		
		int cch;
		LPCTSTR pszSeparator = _StrChr(pcszServer, _T(':'));
		if (NULL != pszSeparator)
		{
			cch = (pszSeparator - pcszServer) + 1;
			if (cch >= CCHMAX(m_szAddress))
				return;
			m_ulPort = DecimalStringToUINT(pszSeparator + 1);	
		}
		else
		{
			cch = CCHMAX(m_szAddress);
			m_ulPort = DEFAULT_LDAP_PORT;
		}

		// save the information before changing the server name
		CacheServerData();

		lstrcpyn(m_szAddress, pcszServer, cch);
		lstrcpyn(m_szServer, pcszServer, CCHMAX(m_szServer));
	}
	

	DBGEXIT(CLDAP::SetServer);
}


/*  D I R E C T O R Y  S T A R T  */
/*-------------------------------------------------------------------------
    %%Function: DirectoryStart

    Initiate directory request
-------------------------------------------------------------------------*/
VOID CLDAP::StartSearch(void)
{
	DBGENTRY(CLDAP::StartSearch);

        if (NULL == m_hThread)
        {
            DWORD dwThID;

			AddRef();
            m_bSearchCancelled = false;
            HANDLE hThread = CreateThread(NULL, 0, _sAsyncSearchThreadFn,
                                          (LPVOID) this, CREATE_SUSPENDED, &dwThID);
            if (NULL != hThread)
            {
		m_hThread = hThread;
		ResumeThread(hThread);
            }
			else
			{
				Release();
			}
        }

	DBGEXIT(CLDAP::StartSearch);
}

DWORD CALLBACK CLDAP::_sAsyncSearchThreadFn(LPVOID pv)
{

	DBGENTRY(CLDAP::_sAsyncSearchThreadFn);

	CLDAP * pThis = (CLDAP *) pv;
	ASSERT(NULL != pThis);
	pThis->AsyncSearch();
	pThis->Release();

	DBGEXIT(CLDAP::_sAsyncSearchThreadFn);

	return 0;
}

VOID CLDAP::AsyncSearch(void)
{
	DBGENTRY(CLDAP::AsyncSearch);
	
	HRESULT hr;

	WARNING_OUT(("AsyncSearch Started"));
	ASSERT(NULL != m_hThread);

	SetBusyCursor(TRUE);
	//	We can not call EnableWindow() from this thread as it av's some of the time.  This is a
	//	known windows bug.  It also doesn't really solve the problem (#4726) it was put in here
	//	to solve anyway.  We will work around this in a future build by re-architecting this so
	//	this little helper thread doesn't mess with the ui at all.  It is problematic and very
	//	inefficient anyway.
//	::EnableWindow(GetDlgItem(GetParent(GetHwnd()), IDM_DLGCALL_REFRESH), FALSE);

	m_fDirInProgress	= TRUE;
	m_dwTickStart		= ::GetTickCount();
	m_uniqueId			= 0;

	if( SUCCEEDED( WaitWithMessageLoop( m_hSearchMutex ) ) )
	{
		if (!FAvailable())
		{
			hr = E_ACCESSDENIED;
		}
		else if (!FOpenServer())
		{
			CloseServer();
			hr = E_FAIL;
		}
		else
		{
			hr = DoQuery();
		}

		SetBusyCursor(FALSE);	//	This should be moved outside the if so it is always executed...

	//	We can not call EnableWindow() from this thread as it av's some of the time.  This is a
	//	known windows bug.  It also doesn't really solve the problem (#4726) it was put in here
	//	to solve anyway.  We will work around this in a future build by re-architecting this so
	//	this little helper thread doesn't mess with the ui at all.  It is problematic and very
	//	inefficient anyway.
//		::EnableWindow(GetDlgItem(GetParent(GetHwnd()), IDM_DLGCALL_REFRESH), TRUE);

		HWND hwnd = GetHwnd();
		if (-1 == ListView_GetNextItem(hwnd, -1, LVNI_ALL | LVNI_FOCUSED))
		{
			// No selection - set focus to the first item
			ListView_SetItemState(hwnd, 0, LVIS_FOCUSED, LVIS_FOCUSED);
		}

		ReleaseMutex( m_hSearchMutex );

		if (FAILED(hr))
		{
			PostMessage(GetParent(hwnd), WM_DISPLAY_MSG, IDS_ULSLOGON_ERROR, 0);
		}

		WARNING_OUT(("AsyncSearch Complete"));

		// Close the thread handle safely
		HANDLE hThread = m_hThread;
		m_hThread = NULL;
		CloseHandle(hThread);
	}

	if (m_fDirInProgress)
	{
		// Only cache if data took more than 2 seconds to retrieve
		m_fIsCacheable = ((::GetTickCount() - m_dwTickStart) > 2000);
		m_fDirInProgress = FALSE;
	}

	DBGEXIT(CLDAP::AsyncSearch);
}




///////////////////////////////////////////////////////////////////////////


/*  F  O P E N  S E R V E R  */
/*-------------------------------------------------------------------------
    %%Function: FOpenServer

    Make sure the connection to the LDAP server is open
-------------------------------------------------------------------------*/
BOOL CLDAP::FOpenServer(void)
{
	DBGENTRY(CLDAP::FOpenServer);

	BOOL bRet = TRUE;
	
	if( NULL == m_pLdap )
	{
		if( m_bSearchCancelled )
		{
			bRet = FALSE;
		}
		else
		{
			WARNING_OUT(("Opening Server [%s] Port [%d]", m_szAddress, m_ulPort));

			m_pLdap = WLDAP::ldap_open(m_szAddress, m_ulPort);

			if( (m_pLdap == NULL) && (m_ulPort == DEFAULT_LDAP_PORT) )
			{
				m_pLdap = WLDAP::ldap_open(m_szAddress, ALTERNATE_LDAP_PORT);		//	Automatically retry with alternate port...

				if( m_pLdap != NULL )
				{
					m_ulPort = ALTERNATE_LDAP_PORT;
				}
			}

			if(NULL != m_pLdap)
			{
				LONG lTimeOut = 30; // seconds for timeout
				WLDAP::ldap_set_option(m_pLdap, LDAP_OPT_TIMELIMIT, &lTimeOut);
				

				// Defaults to ILS 2
				ASSERT(LDAP_VERSION2 == m_pLdap->ld_version);

				ULONG ulRet = WLDAP::ldap_simple_bind_s(m_pLdap, NULL, NULL);

				WARNING_OUT(("Logon [%s] complete", m_szServer));
			}
			else
			{
				WARNING_OUT(("ldap_open err=%d", GetLastError()));
				return FALSE;
			}
		}
	}

	DBGEXIT(CLDAP::FOpenServer);
	return bRet;
}


/*  C L O S E  S E R V E R  */
/*-------------------------------------------------------------------------
    %%Function: CloseServer

-------------------------------------------------------------------------*/
VOID CLDAP::CloseServer(void)
{
	DBGENTRY(CLDAP::CloseServer);

	if(m_pLdap)
	{
		StopSearch();

		if( SUCCEEDED( WaitWithMessageLoop( m_hSearchMutex ) ) )
		{

			WLDAP::ldap_unbind(m_pLdap);
			m_pLdap = NULL;

			ReleaseMutex( m_hSearchMutex );
		}

		WARNING_OUT(("Logoff [%s] complete", m_szServer));
	}
}


/*  G E T  N E X T  A T T R I B U T E  */
/*-------------------------------------------------------------------------
    %%Function: GetNextAttribute

-------------------------------------------------------------------------*/
LPTSTR CLDAP::GetNextAttribute(LPCTSTR pszExpect, LPTSTR psz, int cchMax, LPTSTR pszAttrib, LDAPMessage * pEntry, BerElement * pElement)
{
	
	DBGENTRY(CLDAP::GetNextAttribute);

	ASSERT(NULL != psz);

	if ((NULL == pszAttrib) || (0 != lstrcmpi(pszAttrib, pszExpect)))
	{
		*psz = _T('\0');
	}
	else
	{
		LPTSTR * rgVal = WLDAP::ldap_get_values(m_pLdap, pEntry, pszAttrib);
		if( rgVal[0] )
		{
			lstrcpyn(psz, rgVal[0], cchMax);
		}
		else
		{
			psz[0] = _T('\0');
		}
		WLDAP::ldap_value_free(rgVal);

		pszAttrib = WLDAP::ldap_next_attribute(m_pLdap, pEntry, pElement);
	}


	DBGEXIT(CLDAP::GetNextAttribute);

	return pszAttrib;
}


/*  D O  Q U E R Y  */
/*-------------------------------------------------------------------------
    %%Function: DoQuery

-------------------------------------------------------------------------*/
HRESULT CLDAP::DoQuery(void)
{

	DBGENTRY(CLDAP::DoQuery);

	HRESULT hr = S_FALSE;

	ASSERT(FLoggedOn());

	TCHAR szSearch[MAX_PATH];
	ASSERT(CCHMAX(s_szSearchFormat3) + CCHMAX(s_szSearchCategory) < CCHMAX(szSearch));
	ASSERT(CCHMAX(s_szSearchFormat2) + CCHMAX(s_szSearchCategory) < CCHMAX(szSearch));

	if( !m_bSearchCancelled )
	{
		wsprintf(szSearch,
			(LDAP_VERSION2 == m_pLdap->ld_version) ? s_szSearchFormat2 : s_szSearchFormat3,
			(LDAP_VERSION2 == m_pLdap->ld_version) ? TEXT("%") : TEXT("*"), _T(""));
		ASSERT(lstrlen(szSearch) < CCHMAX(szSearch));

		ASSERT(0 == m_msgId); // one search at a time

		m_msgId = WLDAP::ldap_search(m_pLdap, (PCHAR) "objectClass=RTPerson", LDAP_SCOPE_BASE,
			szSearch, (PCHAR *) s_rgAttrNameAddr, 0);

		if( m_msgId == -1 )
		{
			m_msgId = 0;
			hr = E_FAIL;
		}
		else
		{
			SendMessage( m_hWnd, WM_SETREDRAW, FALSE, 0 );

			while( (0 != m_msgId) && (!m_bSearchCancelled) )
			{
				LDAP_TIMEVAL timeOut = {2, 0};
				LDAPMessage * pResult = NULL;
WARNING_OUT(("DoQuery calling ldap_result"));
				int iResult = WLDAP::ldap_result(m_pLdap, m_msgId, 0, &timeOut, &pResult);
WARNING_OUT( ("DoQuery back from ldap_result: 0x%08X", iResult) );
				if (0 == iResult)
				{
					SendMessage( m_hWnd, WM_SETREDRAW, TRUE, 0 );
					UpdateWindow( m_hWnd );
					SendMessage( m_hWnd, WM_SETREDRAW, FALSE, 0 );
					continue;
				}

				if (LDAP_RES_SEARCH_ENTRY != iResult)
				{
					// S_FALSE = abandoned
//					hr = (-1 == iResult) ? S_OK : S_FALSE;
					hr = (-1 == iResult) ? E_FAIL : S_FALSE;
					break;
				}

				AddEntries(pResult);

				WLDAP::ldap_msgfree(pResult);
			}

			SendMessage( m_hWnd, WM_SETREDRAW, TRUE, 0 );

			m_msgId = 0;
			DirComplete( TRUE );

			forceSort();
		}
	}

	DBGEXIT(CLDAP::DoQuery);
	return hr;
}


/*  A D D  E N T R I E S  */
/*-------------------------------------------------------------------------
    %%Function: AddEntries

    Add the Entries to the listbox.  (Data ordered by s_rgAttrNameAddr.)
-------------------------------------------------------------------------*/
VOID CLDAP::AddEntries(LDAPMessage * pResult)
{
	DBGENTRY(CLDAP::AddEntries);

	LDAPMessage * pEntry;
	BerElement  * pElement;

	for (pEntry = WLDAP::ldap_first_entry(m_pLdap, pResult);
		 NULL != pEntry;
		 pEntry = WLDAP::ldap_next_entry(m_pLdap, pEntry))
	{
		LPTSTR pszAttrib = WLDAP::ldap_first_attribute(m_pLdap, pEntry, &pElement);
		if (NULL == pszAttrib)
			break;

		// Must have a "Show Me" attribute
		if (0 != lstrcmpi(pszAttrib, s_cszAttribShow))
			continue;

		LPTSTR * rgVal = WLDAP::ldap_get_values(m_pLdap, pEntry, pszAttrib);
		BOOL fShow = (_T('1') == *rgVal[0]);
		WLDAP::ldap_value_free(rgVal);

		if (!fShow)
			continue;
		pszAttrib = WLDAP::ldap_next_attribute(m_pLdap, pEntry, pElement);

		TCHAR szEmail[CCHMAXSZ_EMAIL];
		pszAttrib = GetNextAttribute(s_cszAttribEmail, szEmail, CCHMAX(szEmail),
			pszAttrib, pEntry, pElement);

		TCHAR szFirstName[CCHMAXSZ_FIRSTNAME];
		pszAttrib = GetNextAttribute(s_cszAttribFirstName, szFirstName, CCHMAX(szFirstName),
			pszAttrib, pEntry, pElement);

		TCHAR szLastName[CCHMAXSZ_LASTNAME];
		pszAttrib = GetNextAttribute(s_cszAttribLastName, szLastName, CCHMAX(szLastName),
			pszAttrib, pEntry, pElement);

		TCHAR szLocation[CCHMAXSZ_LASTNAME];
		pszAttrib = GetNextAttribute(s_cszAttribLocation, szLocation, CCHMAX(szLocation),
			pszAttrib, pEntry, pElement);

		TCHAR szTemp[4];
		pszAttrib = GetNextAttribute(s_cszAttribInACall, szTemp, CCHMAX(szTemp),
			pszAttrib, pEntry, pElement);

		int iInCallImage = (szTemp[0] == _T('1')) ? II_IN_A_CALL : II_COMPUTER;

		pszAttrib = GetNextAttribute(s_cszAttribAudio, szTemp, CCHMAX(szTemp),
			pszAttrib, pEntry, pElement);

		int iAudioImage = (szTemp[0] == _T('1')) ? II_AUDIO_CAPABLE : 0;

		pszAttrib = GetNextAttribute(s_cszAttribVideo, szTemp, CCHMAX(szTemp),
			pszAttrib, pEntry, pElement);

		int iVideoImage = (szTemp[0] == _T('1')) ? II_VIDEO_CAPABLE : 0;

		TCHAR szComment[CCHMAXSZ_COMMENT];
		pszAttrib = GetNextAttribute(s_cszAttribComment, szComment, CCHMAX(szComment),
			pszAttrib, pEntry, pElement);

		lvAddItem( 0, iInCallImage, iAudioImage, iVideoImage, szEmail, szFirstName, szLastName, szLocation, szComment );
	}

	DBGEXIT(CLDAP::AddEntries);
}


//--------------------------------------------------------------------------//
//	CLDAP::lvAddItem.														//
//--------------------------------------------------------------------------//
int
CLDAP::lvAddItem
(
	int		item,
	int		iInCallImage,
	int		iAudioImage,
	int		iVideoImage,
	LPCTSTR	address,
	LPCTSTR	firstName,
	LPCTSTR	lastName,
	LPCTSTR	location,
	LPCTSTR	comments
){
	LV_ITEM	lvItem;

	ClearStruct( &lvItem );

	lvItem.mask			= LVIF_PARAM;
	lvItem.iItem		= item;
	lvItem.lParam		= m_uniqueId++;			// assign a unique lParam for this item

	int index	= ListView_InsertItem( m_hWnd, &lvItem );

	if( index != -1 )
	{
		if( lastName )
		{
			ListView_SetItemText( m_hWnd, index, COLUMN_INDEX_LAST_NAME, (LPTSTR) lastName );
		}

		if( firstName )
		{
			ListView_SetItemText( m_hWnd, index, COLUMN_INDEX_FIRST_NAME, (LPTSTR) firstName );
		}

		if( iAudioImage != 0 )
		{
			lvItem.mask		= LVIF_IMAGE;
			lvItem.iSubItem	= COLUMN_INDEX_AUDIO;
			lvItem.iImage	= iAudioImage;

			ListView_SetItem( m_hWnd, &lvItem );
		}

		if( iVideoImage != 0 )
		{
			lvItem.mask		= LVIF_IMAGE;
			lvItem.iSubItem	= COLUMN_INDEX_VIDEO;
			lvItem.iImage	= iVideoImage;

			ListView_SetItem( m_hWnd, &lvItem );
		}

		if( address )
		{
			lvItem.mask			= LVIF_IMAGE | LVIF_TEXT;
			lvItem.iSubItem		= COLUMN_INDEX_ADDRESS;
			lvItem.iImage		= iInCallImage;
			lvItem.pszText		= (LPTSTR) address;
			lvItem.cchTextMax	= lstrlen( lvItem.pszText );

			ListView_SetItem( m_hWnd, &lvItem );
		}

		if( location )
		{
			ListView_SetItemText( m_hWnd, index, COLUMN_INDEX_LOCATION, (LPTSTR) location );
		}

		if( comments )
		{
			ListView_SetItemText( m_hWnd, index, COLUMN_INDEX_COMMENTS, (LPTSTR) comments );
		}
	}

	return( index );

}	//	End of CLDAP::lvAddItem.


/*  S T O P  S E A R C H  */
/*-------------------------------------------------------------------------
    %%Function: StopSearch

-------------------------------------------------------------------------*/
VOID CLDAP::StopSearch(void)
{
	DBGENTRY(CLDAP::StopSearch);

	m_bSearchCancelled = true;

	if (0 != m_msgId)
	{
//	Dont call ldap_abandon() from this thread as the search thread may be inside ldap_result()
//	at the time.  For now just set m_msgId to zero and the search thread will stop when ldap_result()
//	returns.
//		ULONG uResult = WLDAP::ldap_abandon(m_pLdap, m_msgId);
		WARNING_OUT(("Stopping Search..."));
		m_msgId = 0;

		m_fDirInProgress = FALSE;
		m_fIsCacheable = FALSE;

		DirComplete(FALSE);
	}

	DBGEXIT(CLDAP::StopSearch);
}



/*  F  G E T  U S E R  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: FGetUserData

    Get the data for a single user.
-------------------------------------------------------------------------*/
BOOL CLDAP::FGetUserData(LDAPUSERDATA * pLdapUserData)
{
	DBGENTRY(CLDAP::FGetUserData);
	ClearStruct(pLdapUserData);

	if (!FLoggedOn())
	{
		DBGEXIT(CLDAP::FGetUserData);
		return FALSE;
	}

	int iItem = CALV::GetSelection();
	if (-1 == iItem)
	{
		DBGEXIT(CLDAP::FGetUserData);
		return FALSE;
	}
	if (!GetSzData(pLdapUserData->szEmail, CCHMAX(pLdapUserData->szEmail), iItem, COLUMN_INDEX_ADDRESS))
	{
		DBGEXIT(CLDAP::FGetUserData);
		return FALSE;
	}

	TCHAR szSearch[CCHMAX(s_szSearchFormat2) + CCHMAXSZ_EMAIL];
	wsprintf(szSearch,
		(LDAP_VERSION2 == m_pLdap->ld_version) ? s_szSearchFormat2 : s_szSearchFormat3,
		pLdapUserData->szEmail, g_cszEmpty);
	ASSERT(lstrlen(szSearch) < CCHMAX(szSearch));

	LDAPMessage * pResult = NULL;

	ULONG ulRet = WLDAP::ldap_search_s(m_pLdap, (LPTSTR) "objectClass=RTPerson", LDAP_SCOPE_BASE,
		szSearch, (PCHAR *) s_rgAttrAll, FALSE, &pResult);
	if (LDAP_SUCCESS != ulRet)
	{
		WLDAP::ldap_msgfree(pResult);
		WARNING_OUT(("ldap_search (code=%08X)", ulRet));
		DBGEXIT(CLDAP::FGetUserData);
		return FALSE;
	}

	LDAPMessage * pEntry = WLDAP::ldap_first_entry(m_pLdap, pResult);
	if (NULL != pEntry)
	{
		BerElement * pElement;
		LPTSTR pszAttrib = WLDAP::ldap_first_attribute(m_pLdap, pEntry, &pElement);
			// Make sure that the first attribute is s_cszAttribFirstName...
		if ((NULL != pszAttrib) && (0 == lstrcmpi(pszAttrib, s_cszAttribFirstName)))
		{
			LPTSTR * rgVal = WLDAP::ldap_get_values(m_pLdap, pEntry, pszAttrib);
			WLDAP::ldap_value_free(rgVal);
//			pszAttrib = WLDAP::ldap_next_attribute(m_pLdap, pEntry, pElement);

			pszAttrib = GetNextAttribute(s_cszAttribFirstName,
					pLdapUserData->szFirst, CCHMAX(pLdapUserData->szFirst),
					pszAttrib, pEntry, pElement);

			pszAttrib = GetNextAttribute(s_cszAttribLastName,
					pLdapUserData->szLast, CCHMAX(pLdapUserData->szLast),
					pszAttrib, pEntry, pElement);

			CombineNames(pLdapUserData->szName, CCHMAX(pLdapUserData->szName),
					pLdapUserData->szFirst, pLdapUserData->szLast);

			pszAttrib = GetNextAttribute(s_cszAttribComment,
					pLdapUserData->szComment, CCHMAX(pLdapUserData->szComment),
					pszAttrib, pEntry, pElement);

			TCHAR szTemp[4];
			pszAttrib = GetNextAttribute(s_cszAttribAudio, szTemp, CCHMAX(szTemp),
					pszAttrib, pEntry, pElement);
			pLdapUserData->fAudioSend = _T('1') == szTemp[0];
			pszAttrib = GetNextAttribute(s_cszAttribVideo, szTemp, CCHMAX(szTemp),
					pszAttrib, pEntry, pElement);
			pLdapUserData->fVideoSend = _T('1') == szTemp[0];

			pszAttrib = GetNextAttribute(s_cszAttribVersion,
				pLdapUserData->szVersion, CCHMAX(pLdapUserData->szVersion),
					pszAttrib, pEntry, pElement);
			pszAttrib = GetNextAttribute(s_cszAttribCategory, szTemp, CCHMAX(szTemp),
					pszAttrib, pEntry, pElement);
			ConvertVersionInfo(pLdapUserData->szVersion, szTemp);
		}
	}

	WLDAP::ldap_msgfree(pResult);

	DBGEXIT(CLDAP::FGetUserData);
	return TRUE;
}


/*  C O N V E R T  V E R S I O N  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: ConvertVersionInfo

-------------------------------------------------------------------------*/
VOID ConvertVersionInfo(LPTSTR pszVersion, LPTSTR pszCategory)
{
	UINT uVer = DecimalStringToUINT(pszVersion);

	if (0 == uVer)
	{
		lstrcpy(pszVersion, FEmptySz(pszCategory) ? TEXT("1.0") : TEXT("2"));
	}
	else
	{
		LPCTSTR pszRel;

		switch (LOBYTE(HIWORD(uVer)))
			{
		case 3:  pszRel = TEXT("2.11"); break;
		case 4:  pszRel = TEXT("3.0");  break;
		case 5:  pszRel = TEXT("4.0");  break;
		default: pszRel = g_cszEmpty;   break;
			}

		TCHAR szFormat[CCHMAXSZ];
		FLoadString(IDS_FORMAT_VERSION, szFormat, CCHMAX(szFormat));
		wsprintf(pszVersion, szFormat, pszRel,
			HIBYTE(HIWORD(uVer)), LOBYTE(HIWORD(uVer)), LOWORD(uVer));
	}
}

//--------------------------------------------------------------------------//
//	CLDAP::FreeDirCache.													//
//--------------------------------------------------------------------------//
void
CLDAP::FreeDirCache
(
	DIRCACHE *	pDirCache
){
	TRACE_OUT(("FreeDirCache [%s] filter=%d, expire=%d",
		pDirCache->pszServer, pDirCache->dwTickExpire));

	ASSERT(NULL != pDirCache);
	PBYTE pb = pDirCache->pData;
	delete pDirCache->pszServer;
	delete pDirCache;

	while (NULL != pb)
	{
		PBYTE pTemp = pb;
		pb = (PBYTE) * (DWORD_PTR *) pb;
		delete pTemp;
	}

}	//	End of CLDAP::FreeDirCache.


//--------------------------------------------------------------------------//
//	CLDAP::FreeDirCache.													//
//--------------------------------------------------------------------------//
void
CLDAP::DirComplete
(
	bool	//fPostUiUpdate
){

	if( m_fDirInProgress )
	{
		// Only cache if data took more than 2 seconds to retrieve
		m_fIsCacheable = ((::GetTickCount() - m_dwTickStart) > 2000);
		m_fDirInProgress = FALSE;
	}

	m_cTotalEntries	= 0;
	m_cEntries		= 0;

}	//	End of CLDAP:DirComplete.


//--------------------------------------------------------------------------//
//	CLDAP::GetSzName.														//
//--------------------------------------------------------------------------//
BOOL
CLDAP::GetSzName
(
	LPTSTR	psz,
	int		cchMax,
	int		iItem
){
	TCHAR	szOrder[ MAX_PATH ];

	bool	bFirstNameFirst	= ((::LoadString( ::GetInstanceHandle(), IDS_NAME_ORDER, szOrder, CCHMAX(szOrder)) == 0) ||
								(_T( '1' ) == szOrder[ 1 ]));

	int		iFirst			= bFirstNameFirst? COLUMN_INDEX_FIRST_NAME: COLUMN_INDEX_LAST_NAME;
	int		iLast			= bFirstNameFirst? COLUMN_INDEX_LAST_NAME: COLUMN_INDEX_FIRST_NAME;

	GetSzData( psz, cchMax, iItem, iFirst );

	int	length	= lstrlen( psz );

	if( (length > 0) && (length < cchMax - 1) )
	{
		lstrcat( psz, TEXT( " " ) );
		length++;
	}

	GetSzData( &psz[ length ], cchMax - length, iItem, iLast );

	return( lstrlen( psz ) > 0 );

}	//	End of CLDAP::GetSzName.


static const int	CDIRCACHE_SZ	= 5;	//	number of strings
static const int	CDIRCACHE_IMAGE	= 3;	//	number of images


//--------------------------------------------------------------------------//
//	CLDAP::CacheServerData.													//
//--------------------------------------------------------------------------//
void
CLDAP::CacheServerData(void)
{
	DIRCACHE * pDirCache;

	if (!m_fCacheDirectory)
		return; // User disabled directory caching

	if (!m_fIsCacheable)
	{
		TRACE_OUT(("CacheServerData: not caching [%s]", m_szServer));
		return;
	}

	if (m_fDirInProgress)
		return; // don't cache partial data

	// Remove any previous cached data
	POSITION pos = FindCachedData();

	if (NULL != pos)
	{
		pDirCache = (DIRCACHE *) m_listDirCache.RemoveAt(pos);
		ASSERT(NULL != pDirCache);
		FreeDirCache(pDirCache);
	}

	DWORD dwTickExpire = m_dwTickStart + (m_cMinutesExpire * 60000);

	if (dwTickExpire < GetTickCount())
	{
		TRACE_OUT(("CacheServerData: [%s] data has expired", m_szServer));
		return; // data is already expired
	}

	int cItems = ListView_GetItemCount(m_hWnd);
	if (0 == cItems)
		return; // nothing to cache

	pDirCache = new DIRCACHE;
	if (NULL == pDirCache)
		return;

	pDirCache->pszServer = PszAlloc(m_szServer);
	pDirCache->dwTickExpire = dwTickExpire;
	pDirCache->pData = NULL;

	LPTSTR pPrev = (LPTSTR) &pDirCache->pData;

	m_listDirCache.AddTail(pDirCache);

	LV_ITEM lvi;
	lvi.cchTextMax = MAX_PATH;
	for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
	{
		int		iInCallImage	= -1;
		int		iAudioImage		= -1;
		int		iVideoImage		= -1;
		int		i				= 0;			// index into rgcb, rgsz
		int		cb				= 0;			// total length of string data
		int		rgcb[CDIRCACHE_SZ];				// size of each string
		TCHAR	rgsz[CDIRCACHE_SZ][MAX_PATH];	// string buffers

		// Get the string data for each column
		lvi.mask = LVIF_IMAGE;
		for (lvi.iSubItem = 0; lvi.iSubItem < MAX_DIR_COLUMNS; lvi.iSubItem++)
		{
			if( (lvi.iSubItem != COLUMN_INDEX_AUDIO) && (lvi.iSubItem != COLUMN_INDEX_VIDEO) )
			{
				lvi.mask |= LVIF_TEXT;
				lvi.pszText = rgsz[i];
				ListView_GetItem(m_hWnd, &lvi);
				rgcb[i] = lstrlen(lvi.pszText);
				cb += rgcb[i] + 1;		//	Plus one for the NULL...
				i++;

				if( lvi.iSubItem == COLUMN_INDEX_ADDRESS )
				{
					iInCallImage = lvi.iImage;
				}
			}
			else
			{
				lvi.mask &= ~LVIF_TEXT;
				ListView_GetItem(m_hWnd, &lvi);

				if( lvi.iSubItem == COLUMN_INDEX_AUDIO )
				{
					iAudioImage = lvi.iImage;
				}
				else if( lvi.iSubItem == COLUMN_INDEX_VIDEO)
				{
					iVideoImage = lvi.iImage;
				}
			}
		}

		// allocate space for: a link (DWORD), strings (cb), images (CDIRCACHE_IMAGES)
		PBYTE pData = new BYTE[ sizeof(DWORD_PTR) + cb + CDIRCACHE_IMAGES ];
		if (NULL == pData)
		{
			// can't hold all data - give up and return
			ClearServerCache();
			return;
		}
		* ((DWORD_PTR *) pData) = 0;  // link to next item is null
		PBYTE pb = pData + sizeof(DWORD_PTR);

		// copy the string data into the buffer
		for (i = 0; i < CDIRCACHE_SZ; i++)
		{
			lstrcpy((LPTSTR) pb, rgsz[i]);
			pb += rgcb[i] + 1;
		}

		*pb++ = (BYTE) iInCallImage;
		*pb++ = (BYTE) iAudioImage;
		*pb = (BYTE) iVideoImage;
		* ((DWORD_PTR *) pPrev) = (DWORD_PTR) pData; // link into the previous data
		pPrev = (LPTSTR) pData;
	}

	TRACE_OUT(("CacheServerData: [%s]  expire=%d",
		m_szServer, dwTickExpire));

}	//	End of CLDAP::CacheServerData.


//--------------------------------------------------------------------------//
//	CLDAP::FindCachedData.													//
//--------------------------------------------------------------------------//
POSITION
CLDAP::FindCachedData(void)
{
	DWORD dwTick = GetTickCount();
	TRACE_OUT(("Searching for cached data on [%s]", m_szServer));

	POSITION pos = m_listDirCache.GetHeadPosition();
	while (NULL != pos)
	{
		POSITION posSav = pos;
		DIRCACHE * pDirCache = (DIRCACHE *) m_listDirCache.GetNext(pos);
		ASSERT(NULL != pDirCache);
		if ((0 == lstrcmp(m_szServer, pDirCache->pszServer)) &&
			(pDirCache->dwTickExpire > dwTick))
		{
			return posSav;
		}
	}

	return NULL;

}	//	End of CLDAP::FindCachedData.


//--------------------------------------------------------------------------//
//	CLDAP::ClearServerCache.												//
//--------------------------------------------------------------------------//
void
CLDAP::ClearServerCache(void)
{
	DWORD dwTick = GetTickCount();

	POSITION pos = m_listDirCache.GetHeadPosition();
	while (NULL != pos)
	{
		POSITION posSav = pos;
		DIRCACHE * pDirCache = (DIRCACHE *) m_listDirCache.GetNext(pos);
		ASSERT(NULL != pDirCache);
		
		if ( (0 == lstrcmp(m_szServer, pDirCache->pszServer)) || (pDirCache->dwTickExpire < dwTick) )
		{
			m_listDirCache.RemoveAt(posSav);
			FreeDirCache(pDirCache);
		}
#ifdef DEBUG
		else
		{
			TRACE_OUT(("Keeping cached data for [%s] , expire=%d",
				pDirCache->pszServer, pDirCache->dwTickExpire));
		}
#endif /* DEBUG */
	}

}	//	End of CLDAP::ClearServerCache.


//--------------------------------------------------------------------------//
//	CLDAP::DisplayDirectory.												//
//--------------------------------------------------------------------------//
void
CLDAP::DisplayDirectory(void)
{
	POSITION pos = FindCachedData();

	if (NULL == pos)
	{
		// no cached information - request new data
		StartSearch();
		return;
	}

	DIRCACHE * pDirCache = (DIRCACHE *) m_listDirCache.GetFromPosition(pos);
	ASSERT(NULL != pDirCache);
	LPTSTR pDirLine = (LPTSTR) pDirCache->pData;

	StopSearch(); // In case the previous server is slow
	CALV::ClearItems();

	m_fIsCacheable = FALSE; // don't bother attempting to re-cache this data

	// Restore the cached server information
	TRACE_OUT(("Restoring cached data for [%s]  expire=%d",
		m_szServer, pDirCache->dwTickExpire));

	SendMessage( m_hWnd, WM_SETREDRAW, FALSE, 0 );

	while (NULL != pDirLine)
	{
		DWORD_PTR *pNext	= * (DWORD_PTR * * ) pDirLine; pDirLine += sizeof(DWORD_PTR);
		LPTSTR pszEmail		= (LPTSTR) pDirLine; pDirLine += lstrlen(pDirLine)+1;
		LPTSTR pszLast		= (LPTSTR) pDirLine; pDirLine += lstrlen(pDirLine)+1;
		LPTSTR pszFirst		= (LPTSTR) pDirLine; pDirLine += lstrlen(pDirLine)+1;
		LPTSTR pszLocation	= (LPTSTR) pDirLine; pDirLine += lstrlen(pDirLine)+1;
		LPTSTR pszComment	= (LPTSTR) pDirLine; pDirLine += lstrlen(pDirLine)+1;
		int iiCall			= (int) * (char *) pDirLine; pDirLine++;
		int iiAudio			= (int) * (char *) pDirLine; pDirLine++;
		int iiVideo			= (int) * (char *) pDirLine;

		lvAddItem( 0, iiCall, iiAudio, iiVideo, pszEmail, pszFirst, pszLast, pszLocation, pszComment );

		pDirLine = (LPTSTR) pNext;
	}

	forceSort();
	SendMessage( m_hWnd, WM_SETREDRAW, TRUE, 0 );

}	//	End of CLDAP::DisplayDirectory.


//--------------------------------------------------------------------------//
//	CLDAP::forceSort.														//
//--------------------------------------------------------------------------//
void
CLDAP::forceSort(void)
{
	NM_LISTVIEW	nmlv;

	nmlv.hdr.code		= LVN_COLUMNCLICK;
	nmlv.hdr.hwndFrom	= m_hWnd;
	nmlv.iSubItem		= -1;	//	default sort column...

	SendMessage( GetParent( m_hWnd ), WM_NOTIFY, GetDlgCtrlID( m_hWnd ), (LPARAM) &nmlv );

}	//	End of CLDAP::forceSort.


//--------------------------------------------------------------------------//
//	CLDAP::GetIconId.														//
//--------------------------------------------------------------------------//
int
CLDAP::GetIconId(LPCTSTR psz)
{

	return( CDirectoryManager::isWebDirectory( psz )? II_WEB_DIRECTORY: CALV::GetIconId( NULL ) );

}	//	End of CLDAP::GetIconId.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\mail.cpp ===
// File: mail.cpp

#include "precomp.h"
#include "resource.h"
#include <mapi.h>
#include <clinkid.h>
#include <clink.h>
#include "mail.h"
#include "ConfUtil.h"

typedef struct _tagMAIL_ADDRESS
{
	LPTSTR pszAddress;
	LPTSTR pszDisplayName;
} MAIL_ADDRESS, *LPMAIL_ADDRESS;


// Send an e-mail message using the default mail provider
HRESULT SendMailMessage(LPMAIL_ADDRESS pmaTo, LPCTSTR pcszSubject,
						LPCTSTR pcszText, LPCTSTR pcszFile);

/* Given an existing Conference Shortcut, bring up a mail message with */
/* it included as an attachment.  The Conference Shortcut should have */
/* been saved to disk prior to this call. */
BOOL SendConfLinkMail(LPMAIL_ADDRESS pmaTo, IConferenceLink* pconflink, LPCTSTR pcszNoteText);



/////////////////////////////////////////////////////////////////////////////////////
// These variables are only used in this module, so we will make them static...
// This keeps it out of the global namespace but more importantly it tells
// the person reading this code that they don't have to worry about any othur
// source file changing the variables directly...
static HANDLE s_hSendMailThread = NULL;
static const TCHAR s_cszWinIniMail[] = _TEXT("Mail");
static const TCHAR s_cszWinIniMAPI[] = _TEXT("MAPI");

// MAPISendMail:
typedef ULONG (FAR PASCAL *LPMSM)(LHANDLE,ULONG,lpMapiMessage,FLAGS,ULONG);

BOOL IsSimpleMAPIInstalled()
{
	return (BOOL) GetProfileInt(s_cszWinIniMail, s_cszWinIniMAPI, 0);
}

BOOL CreateInvitationMail(LPCTSTR pszMailAddr, LPCTSTR pszMailName,
                          LPCTSTR pcszName, LPCTSTR pcszAddress,
                          DWORD dwTransport, BOOL fMissedYou)
{
	BOOL bRet = FALSE;
	TCHAR szTempFile[MAX_PATH];
	WCHAR wszTempFile[MAX_PATH];

	ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
	ASSERT(IS_VALID_STRING_PTR(pcszAddress, CSTR));
	// password not supported yet
	// ASSERT(IS_VALID_STRING_PTR(pcszPassword, CSTR));
	
	LPTSTR pszFileName = NULL;
	if (0 == GetTempPath(MAX_PATH, szTempFile))
	{
		ERROR_OUT(("GetTempPath failed!"));
		return FALSE;
	}

	pszFileName = szTempFile + lstrlen(szTempFile);

	// the +3 is for null terminators
	// append the conference name and the shortcut extension to the temp directory
	if (((lstrlen(pcszName) + lstrlen(szTempFile) + lstrlen(g_cszConfLinkExt) + 3)
			> sizeof(szTempFile)) ||
		(0 == lstrcat(szTempFile, pcszName)) ||
		(0 == lstrcat(szTempFile, g_cszConfLinkExt)))
	{
		ERROR_OUT(("Could not create temp file name!"));
		return FALSE;
	}

	// Filter names to allow only legal filename characters
	SanitizeFileName(pszFileName);

	// convert to UNICODE because IPersistFile interface expects UNICODE
	if (0 == MultiByteToWideChar(CP_ACP,
								0L,
								szTempFile,
								sizeof(szTempFile),
								wszTempFile,
								sizeof(wszTempFile)))
	{
		ERROR_OUT(("Could not create wide temp file string!"));
		return FALSE;
	}

	IUnknown* punk = NULL;
	
	// Create a ConfLink object - try to obtain an IUnknown pointer
	HRESULT hr = CoCreateInstance(	CLSID_ConfLink, 
									NULL,
									CLSCTX_INPROC_SERVER |
										CLSCTX_INPROC_HANDLER |
										CLSCTX_LOCAL_SERVER,
									IID_IUnknown,
									(LPVOID*) &punk);
	if (FAILED(hr))
	{
		ERROR_OUT(("CoCreateInstance ret %lx", (DWORD)hr));
		return FALSE;
	}

		ASSERT(IS_VALID_INTERFACE_PTR(punk, IUnknown));
		
		// Try to obtain a IConferenceLink pointer
		IConferenceLink* pcl = NULL;
		hr = punk->QueryInterface(IID_IConferenceLink, (LPVOID*) &pcl);
		
		if (SUCCEEDED(hr))
		{
			ASSERT(IS_VALID_INTERFACE_PTR(pcl, IConferenceLink));
			
			// Set the conference name and address
			pcl->SetAddress(pcszAddress);
			pcl->SetName(pcszName);
			pcl->SetTransport(dwTransport);
			pcl->SetCallFlags(CRPCF_DEFAULT);

			// Try to obtain a IPersistFile pointer
			IPersistFile* ppf = NULL;
			hr = punk->QueryInterface(IID_IPersistFile, (LPVOID*) &ppf);

			if (SUCCEEDED(hr))
			{
				ASSERT(IS_VALID_INTERFACE_PTR(ppf, IPersistFile));
			
				// Save the object using the filename generated above
				hr = ppf->Save(wszTempFile, TRUE);
				
				// Release the IPersistFile pointer
				ppf->Release();
				ppf = NULL;

				TCHAR szNoteText[512];
				if (fMissedYou)
				{
					TCHAR szFormat[MAX_PATH];
					if (FLoadString(IDS_MISSED_YOU_FORMAT, szFormat, CCHMAX(szFormat)))
					{
						RegEntry reULS(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
						wsprintf(szNoteText, szFormat, reULS.GetString(REGVAL_ULS_NAME));
					}
				}
				else
				{
					FLoadString(IDS_SEND_MAIL_NOTE_TEXT, szNoteText, CCHMAX(szNoteText));
				}

				MAIL_ADDRESS maDestAddress;
				maDestAddress.pszAddress = (LPTSTR) pszMailAddr;
				maDestAddress.pszDisplayName = (LPTSTR) pszMailName;

				// Send it using MAPI
				bRet = SendConfLinkMail(&maDestAddress, pcl, szNoteText);
			}
			// Release the IConferenceLink pointer
			pcl->Release();
			pcl = NULL;
		}

		// Release the IUnknown pointer
		punk->Release();
		punk = NULL;

	return bRet;
}

// SendConfLinkMail creates a mail message using Simple MAPI and attaches one
// file to it - a Conference Shortcut which is passed in via the IConferenceLink
// interface pointer.

BOOL SendConfLinkMail(LPMAIL_ADDRESS pmaTo, IConferenceLink* pconflink, LPCTSTR pcszNoteText)
{
	ASSERT(IS_VALID_INTERFACE_PTR((PCIConferenceLink)pconflink, IConferenceLink));
	HRESULT hr = E_FAIL;

	// File
	TCHAR szFile[MAX_PATH];
	LPOLESTR	pwszFile = NULL;
	IPersistFile* pPersistFile = NULL;

	if (SUCCEEDED(pconflink->QueryInterface(IID_IPersistFile,
											(LPVOID*) &pPersistFile)))
	{
		
		if (SUCCEEDED(pPersistFile->GetCurFile(&pwszFile)))
		{
#ifndef _UNICODE
			WideCharToMultiByte(CP_ACP,
								0L,
								pwszFile,
								-1,
								szFile,
								sizeof(szFile),
								NULL,
								NULL);

			// Free the string using the Shell Allocator
			LPMALLOC pMalloc = NULL;
			if (SUCCEEDED(SHGetMalloc(&pMalloc)))
			{
				pMalloc->Free(pwszFile);
				pwszFile = NULL;
				pMalloc->Release();
				pMalloc = NULL;
			}

#else  // ndef _UNICODE
#error Unicode not handled here!
#endif // ndef _UNICODE

			hr = SendMailMessage(pmaTo, NULL, pcszNoteText, szFile);
			// BUGBUG: need unique ret val for this case
			// BUGBUG: should we move error UI out of this function?
			if (FAILED(hr))
			{
				::PostConfMsgBox(IDS_CANT_SEND_SENDMAIL_IN_PROGRESS);
			}
		}
		else
		{
			ERROR_OUT(("GetCurFile failed - can't send message!"));
			pPersistFile->Release();
			return FALSE;
		}
		pPersistFile->Release();
	}
	else
	{
		ERROR_OUT(("Did not get IPersistFile pointer - can't send message!"));
		return FALSE;
	}
	
	return SUCCEEDED(hr);
}

//
// BEGIN STOLEN CODE FROM IE 3.0 (sendmail.c) -------------------------------
//

const TCHAR g_cszAthenaV1Name[] = _TEXT("Internet Mail and News");
const TCHAR g_cszAthenaV2Name[] = _TEXT("Outlook Express");
const TCHAR g_cszAthenaV1DLLPath[] = _TEXT("mailnews.dll");

BOOL IsAthenaDefault()
{
	TCHAR szAthena[80];
	LONG cb = ARRAY_ELEMENTS(szAthena);

	return (ERROR_SUCCESS == RegQueryValue(HKEY_LOCAL_MACHINE, REGVAL_IE_CLIENTS_MAIL, szAthena, &cb)) &&
			((lstrcmpi(szAthena, g_cszAthenaV1Name) == 0) ||
				(lstrcmpi(szAthena, g_cszAthenaV2Name) == 0));
}

HMODULE LoadMailProvider()
{
    TCHAR szMAPIDLL[MAX_PATH];

    if (IsAthenaDefault())
    {
		RegEntry reMailClient(REGVAL_IE_CLIENTS_MAIL, HKEY_LOCAL_MACHINE);
		PTSTR pszMailClient = reMailClient.GetString(NULL);
		if ((NULL != pszMailClient) && (_T('\0') != pszMailClient[0]))
		{
			reMailClient.MoveToSubKey(pszMailClient);
			PTSTR pszDllPath = reMailClient.GetString(REGVAL_MAIL_DLLPATH);
			if ((NULL == pszDllPath) || (_T('\0') == pszDllPath[0]))
			{
				pszDllPath = (PTSTR) g_cszAthenaV1DLLPath;
			}
			return ::LoadLibraryEx(pszDllPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
		}
		else
		{
			ERROR_OUT(("No e-mail client in registry but IsAthenaDefault() returned TRUE"));
		}
	}

    // read win.ini (bogus hu!) for mapi dll provider
    if (GetProfileString(	TEXT("Mail"), TEXT("CMCDLLName32"), TEXT(""),
							szMAPIDLL, ARRAY_ELEMENTS(szMAPIDLL)) <= 0)
        lstrcpy(szMAPIDLL, TEXT("mapi32.dll"));

    return ::LoadLibraryEx(szMAPIDLL, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
}

typedef struct {
	TCHAR szToAddress[MAX_PATH];
	TCHAR szToDisplayName[MAX_PATH];
	TCHAR szSubject[MAX_PATH];
	TCHAR szText[MAX_PATH];
	TCHAR szFile[MAX_PATH];
	BOOL fDeleteFile;
	MapiMessage mm;
	MapiRecipDesc mrd;
	MapiFileDesc mfd;
} MAPI_FILES;

MAPI_FILES* _AllocMapiFiles(LPMAIL_ADDRESS pmaTo, LPCTSTR pcszSubject,
							LPCTSTR pcszText, LPCTSTR pcszFile, BOOL fDeleteFile)
{
	MAPI_FILES* pmf = new MAPI_FILES;
	if (pmf)
	{
		::ZeroMemory(pmf, sizeof(MAPI_FILES));
		pmf->fDeleteFile = fDeleteFile;
		if (NULL != pcszSubject)
		{
			lstrcpyn(pmf->szSubject, pcszSubject, CCHMAX(pmf->szSubject));
		}
		else
		{
			pmf->szSubject[0] = _T('\0');
		}
		if (NULL != pcszText)
		{
			lstrcpyn(pmf->szText, pcszText, CCHMAX(pmf->szText));
		}
		else
		{
			pmf->szText[0] = _T('\0');
		}
		pmf->mm.nFileCount = (NULL != pcszFile) ? 1 : 0;
		if (pmf->mm.nFileCount)
		{
			lstrcpyn(pmf->szFile, pcszFile, CCHMAX(pmf->szFile));
			pmf->mm.lpFiles = &(pmf->mfd);
			pmf->mfd.lpszPathName = pmf->szFile;
			pmf->mfd.lpszFileName = pmf->szFile;
			pmf->mfd.nPosition = (UINT)-1;
		}
		pmf->mm.lpszSubject = pmf->szSubject;
		pmf->mm.lpszNoteText = pmf->szText;

		if( ( NULL != pmaTo ) && !FEmptySz(pmaTo->pszAddress ) )
		{
			pmf->mm.lpRecips = &(pmf->mrd);

			pmf->mrd.ulRecipClass = MAPI_TO;
			pmf->mm.nRecipCount = 1;

			// If we're sending via Athena and a friendly name is specified, 
			// we pass both the friendly name and address.  If we're sending 
			// via Simple MAPI, we pass just the address in the name field.
			// This is necessary so that the email client can do the address 
			// resolution as appropriate for the installed mail system.  This
			// is not necessary for Athena since it assumes that all addresses
			// are SMTP addresses.

			if (IsAthenaDefault() 
				&& NULL != pmaTo->pszDisplayName && _T('\0') != pmaTo->pszDisplayName[0])
			{
				lstrcpyn(
					pmf->szToDisplayName, 
					pmaTo->pszDisplayName,
					CCHMAX(pmf->szToDisplayName));
				pmf->mrd.lpszName = pmf->szToDisplayName;

				lstrcpyn(
					pmf->szToAddress, 
					pmaTo->pszAddress, 
					CCHMAX(pmf->szToAddress));
				pmf->mrd.lpszAddress = pmf->szToAddress;
			}
			else
			{
				lstrcpyn(
					pmf->szToDisplayName, 
					pmaTo->pszAddress, 
					CCHMAX(pmf->szToDisplayName));
				pmf->mrd.lpszName = pmf->szToDisplayName;
				
				pmf->mrd.lpszAddress = NULL;
			}
		}
		else
		{
			// No recepients
			pmf->mm.lpRecips = NULL;
		}
	}
	return pmf;
}

VOID _FreeMapiFiles(MAPI_FILES *pmf)
{
	if (pmf->fDeleteFile)
	{
		::DeleteFile(pmf->szFile);
	}
	delete pmf;
}

STDAPI_(DWORD) MailRecipientThreadProc(LPVOID pv)
{
	DebugEntry(MailRecipientThreadProc);
	MAPI_FILES* pmf = (MAPI_FILES*) pv;
	
	DWORD dwRet = S_OK;

	if (pmf)
	{
		HMODULE hmodMail = LoadMailProvider();
		if (hmodMail)
		{
			LPMSM pfnSendMail;
			if (pfnSendMail = (LPMSM) ::GetProcAddress(hmodMail, "MAPISendMail"))
			{
				dwRet = pfnSendMail(0, 0, &pmf->mm, MAPI_LOGON_UI | MAPI_DIALOG, 0);
			}
			::FreeLibrary(hmodMail);
		}
		_FreeMapiFiles(pmf);
	}
		
		// s_hSendMailThread can't be NULL because we don't resume this thread
		// until s_hSendMailThread is set to a non-null value, so this is a sanity check
	ASSERT(s_hSendMailThread);		

			
	HANDLE hThread = s_hSendMailThread;

	s_hSendMailThread = NULL;
	::CloseHandle(hThread);

	DebugExitULONG(MailRecipientThreadProc, dwRet);
	return dwRet;
}

//
// END STOLEN CODE FROM IE 3.0 (sendmail.c) ---------------------------------
//


VOID SendMailMsg(LPTSTR pszAddr, LPTSTR pszName)
{
	// Create Send Mail structure to pass on
	MAIL_ADDRESS maDestAddress;
	maDestAddress.pszAddress = pszAddr;
	maDestAddress.pszDisplayName = pszName;
    
        // We are adding the callto://pszName link 
        // to the body of the e-mail message
    TCHAR sz[MAX_PATH];
    USES_RES2T
    lstrcpy( sz, RES2T(IDS_NMCALLTOMAILTEXT) );
    lstrcat( sz, pszAddr );
        
        // Only send the text part if pszName is not a NULL string
	HRESULT hr = SendMailMessage(&maDestAddress, NULL, ( *pszAddr ) ? sz : NULL, NULL);
	if (FAILED(hr))
	{
		::PostConfMsgBox(IDS_CANT_SEND_SENDMAIL_IN_PROGRESS);
	}
}


const int MESSAGE_THREAD_SHUTDOWN_TIMEOUT = 5000; // milliseconds

HRESULT SendMailMessage(LPMAIL_ADDRESS pmaTo, LPCTSTR pcszSubject,
						LPCTSTR pcszText, LPCTSTR pcszFile)
{
	DebugEntry(SendMailMessage);
	HRESULT hr = E_FAIL;

	if (NULL != s_hSendMailThread)
	{
		// Athena takes a while to get out of MAPISendMail after the message is closed,
		// so we wait around a few seconds in case you just finished sending a message..
		HCURSOR hCurPrev = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
		::WaitForSingleObject(s_hSendMailThread, MESSAGE_THREAD_SHUTDOWN_TIMEOUT);
		::SetCursor(hCurPrev);
	}

	if (NULL == s_hSendMailThread)
	{
		MAPI_FILES* pmf = _AllocMapiFiles(	pmaTo, pcszSubject, pcszText,
											pcszFile, TRUE);
		if (NULL != pmf)
		{
			DWORD dwThreadID;

				// We create the thread suspended because in the thread fn
				// we call closehandle on s_hSendMailThread...if we create
				// the thread not suspended there is a race condition where
				// s_hSendMailThread may not have been assigned the return
				// value of CreateThread before it is checked in the thread fn

			s_hSendMailThread = ::CreateThread(	NULL,
												0,
												MailRecipientThreadProc,
												pmf,
												CREATE_SUSPENDED,
												&dwThreadID);

				// If the thread was created, we have to call Resume Thread...
			if( s_hSendMailThread )
			{
				if( 0xFFFFFFFF != ResumeThread( s_hSendMailThread ) )
				{
					hr = S_OK;
				}
				else
				{
					// This would indicate an error...
					hr = HRESULT_FROM_WIN32(GetLastError());
				}
			}
			else
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
			}
		}
	}
	else
	{
		WARNING_OUT(("can't send mail - mail thread already in progress"));
	}

	DebugExitHRESULT(SendMailMessage, hr);
	return hr;
}

BOOL IsSendMailInProgress()
{
	return (NULL != s_hSendMailThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\makefile.inc ===
#That forces BUILD.EXE to rebuild the rc file when the .rgs files change
conf.rc:  $(O)\NetMeeting.tlb NetMeeting.rgs VideoWindow.rgs NmManager.rgs NmApp.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\mail.h ===
#ifndef _MAIL_H_
#define _MAIL_H_


// Read win.ini and determine if Simple MAPI is available
BOOL IsSimpleMAPIInstalled(void);
// Check to see if Athena is the default mail client
BOOL IsAthenaDefault(void);

// Send a mail message
VOID SendMailMsg(LPTSTR pszAddr, LPTSTR pszName);

// Are we in the middle of sending a mail message
BOOL IsSendMailInProgress(void);

/* Create a Conference Shortcut and bring up a mail message with */
/* the shortcut included as an attachment. */
BOOL CreateInvitationMail(LPCTSTR pszMailAddr, LPCTSTR pszMailName,
                          LPCTSTR pcszName, LPCTSTR pcszAddress, 
                          DWORD dwTransport, BOOL fMissedYou);

#endif // _MAIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\mapiinit.h ===
#ifndef __MapiInit_h__
#define __MapiInit_h__

#include <mapix.h>

// This defines a bunch of macros for pretty GetProcAddress stuff...
    // DECLARE_PFNTYPE is for those functions that are not defined as the example above
#define DECLARE_PFNTYPE( FnName ) typedef FnName FAR* LP##FnName;
#define DECLARE_PFNTYPE_INST( FnName )   LP##FnName lpfn##FnName = NULL;

    // DECLARE_PROC goes in the header file 
#define DECLARE_PROC( FnDecl, FnName ) extern LP##FnDecl lpfn##FnName;
    
    // DECLARE_PROC_INST goes in the .c or .cpp file            
#define DECLARE_PROC_INST( FnDecl, FnName )   LP##FnDecl lpfn##FnName = NULL;

    // This begins a proc map as described at the top of this file
#define BEGIN_PROC_MAP( LibName ) APIFCN LibName##ProcList[] = {

    // Each function that is being loaded has an entry in the proc map
#define PROC_MAP_ENTRY( FnName )    { (LPVOID * ) &lpfn##FnName, #FnName },

    // Some functions we have to give an explicit name
#define PROC_MAP_ENTRY_EXPLICIT_NAME( pFnName, FnName )    { (LPVOID * ) &lpfn##pFnName, #FnName },

    // This is at the end of a proc map
#define END_PROC_MAP     };

    // User calls LOAD_PROCS with the PROC map that they have built....
#define LOAD_PROCS(szDllName, LibName, pHInstance) HrInitLpfn(LibName##ProcList, ARRAY_ELEMENTS(LibName##ProcList), pHInstance, szDllName);

typedef void ( STDAPICALLTYPE FREEPROWS ) ( LPSRowSet lpRows );
typedef FREEPROWS FAR* LPFREEPROWS;


typedef HRESULT( STDAPICALLTYPE HRQUERYALLROWS ) ( 
    LPMAPITABLE lpTable, 
    LPSPropTagArray lpPropTags,
    LPSRestriction lpRestriction,
    LPSSortOrderSet lpSortOrderSet,
    LONG crowsMax,
    LPSRowSet FAR *lppRows
);
typedef HRQUERYALLROWS FAR* LPHRQUERYALLROWS;


typedef HRESULT( STDAPICALLTYPE HRGETONEPROP ) (
	LPMAPIPROP lpMapiProp, 
	ULONG ulPropTag,
    LPSPropValue FAR *lppProp
);
typedef HRGETONEPROP FAR* LPHRGETONEPROP;

    // We are forward declaring them like this so that
    // the fns can be visible from several cpp files....

    // MAPI32.DLL stuff
DECLARE_PROC( MAPIINITIALIZE, MAPIInitialize );
DECLARE_PROC( MAPIUNINITIALIZE, MAPIUninitialize );
DECLARE_PROC( MAPIALLOCATEBUFFER, MAPIAllocateBuffer );
DECLARE_PROC( MAPIALLOCATEMORE, MAPIAllocateMore );
DECLARE_PROC( MAPIFREEBUFFER, MAPIFreeBuffer );
DECLARE_PROC( MAPILOGONEX, MAPILogonEx );
DECLARE_PROC( MAPIADMINPROFILES, MAPIAdminProfiles );
DECLARE_PROC( FREEPROWS, FreeProws );
DECLARE_PROC( HRQUERYALLROWS, HrQueryAllRows );
DECLARE_PROC( HRGETONEPROP, HrGetOneProp );

bool LoadMapiFns( HINSTANCE* phInstMapi32DLL );


#endif // __MapiInit_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\mapiinit.cpp ===
#include "precomp.h"
#include "MapiInit.h"

    // MAPI32.DLL stuff
DECLARE_PROC_INST( MAPIINITIALIZE, MAPIInitialize );
DECLARE_PROC_INST( MAPIUNINITIALIZE, MAPIUninitialize );
DECLARE_PROC_INST( MAPIALLOCATEBUFFER, MAPIAllocateBuffer );
DECLARE_PROC_INST( MAPIALLOCATEMORE, MAPIAllocateMore );
DECLARE_PROC_INST( MAPIFREEBUFFER, MAPIFreeBuffer );
DECLARE_PROC_INST( MAPILOGONEX, MAPILogonEx );
DECLARE_PROC_INST( FREEPROWS, FreeProws );
DECLARE_PROC_INST( HRQUERYALLROWS, HrQueryAllRows );
DECLARE_PROC_INST( HRGETONEPROP, HrGetOneProp );
DECLARE_PROC_INST( MAPIADMINPROFILES, MAPIAdminProfiles);

    // MAPI Proc Mak
BEGIN_PROC_MAP( MAPI32 )
    PROC_MAP_ENTRY( MAPIInitialize )
    PROC_MAP_ENTRY( MAPIUninitialize )
    PROC_MAP_ENTRY( MAPIAllocateBuffer )
    PROC_MAP_ENTRY( MAPIAllocateMore )
    PROC_MAP_ENTRY( MAPIFreeBuffer )
    PROC_MAP_ENTRY( MAPILogonEx )
	PROC_MAP_ENTRY( MAPIAdminProfiles )
    PROC_MAP_ENTRY_EXPLICIT_NAME( FreeProws, FreeProws@4 )
    PROC_MAP_ENTRY_EXPLICIT_NAME( HrQueryAllRows, HrQueryAllRows@24 )
	PROC_MAP_ENTRY_EXPLICIT_NAME( HrGetOneProp, HrGetOneProp@12 )
END_PROC_MAP

bool LoadMapiFns( HINSTANCE* phInstMapi32DLL ) {
    
    HRESULT hr = LOAD_PROCS(TEXT("MAPI32.DLL"), MAPI32, phInstMapi32DLL );
    return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\global.h ===
// File: global.h
//
// Global NetMeeting UI definitions

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#define TAPI_CURRENT_VERSION 0x00010004

#ifndef WS_EX_NOINHERIT_LAYOUT
#define WS_EX_NOINHERIT_LAYOUT   0x00100000L // Disable inheritence of mirroring by children
#endif

inline HINSTANCE GetInstanceHandle()	{ return _Module.GetResourceModule(); }

// colors:
#define TOOLBAR_MASK_COLOR                 (RGB(255,   0, 255)) // MAGENTA
#define TOOLBAR_HIGHLIGHT_COLOR	           (RGB(255, 255, 255)) // WHITE

// string constants
const UINT  CCHMAXUINT =         12;

const int CCHMAXSZ =            256;   // Maximum generic string length
const int CCHMAXSZ_ADDRESS =    256;   // Maximum length of an address
const int CCHMAXSZ_SERVER =     128;   // Maximum length of an address

const int CCHMAXSZ_EMAIL =      128;   // Maximum length of an email name
const int CCHMAXSZ_FIRSTNAME =  128;   // Maximum length of a first name
const int CCHMAXSZ_LASTNAME =   128;   // Maximum length of a last name
const int CCHMAXSZ_NAME =       256;   // Maximum user name, displayed (combined first+last name)
const int CCHMAXSZ_LOCATION =   128;   // Maximum length of a Location
const int CCHMAXSZ_PHONENUM =   128;   // Maximum length of a Phone number
const int CCHMAXSZ_COMMENT =    256;   // Maximum length for comments
const int CCHMAXSZ_VERSION =    128;   // Maximum length for version info

const int CCHEXT =                3;   // Maximum CHARACTERS in a filename extension


// defines:
const int MAX_ITEMLEN =                                 256;

// Timers 300-399 are used by the ASMaster class
const int TASKBAR_DBLCLICK_TIMER =			666;

const int IDT_SCROLLBAR_REPEAT =            667;
const int IDT_SCROLLBAR_REPEAT_PERIOD =     250; // 0.25 sec

const int IDT_FLDRBAR_TIMER =               668;
const int IDT_FLDRBAR_TIMER_PERIOD =       1000; // 1 second

const int FRIENDS_REFRESH_TIMER =			681;
const int DIRECTORY_REFRESH_TIMER =			682;

const int WINSOCK_ACTIVITY_TIMER =			683;
const int WINSOCK_ACTIVITY_TIMER_PERIOD =	55000; // 55 seconds

const int AUDIODLG_MIC_TIMER =				69;
const int AUDIODLG_MIC_TIMER_PERIOD =		500; // 0.5 sec

const int POPUPMSG_TIMER =					1000;
const int MOUSE_MOVE_TIP_TIMEOUT =			3000; // 3 seconds
const int SHADOW_ACTIVATE_TIP_TIMEOUT =     5000; // 5 seconds
const int ROSTER_TIP_TIMEOUT =              3000; // 3 seconds

// Help id related constants:
const int MAIN_MENU_POPUP_HELP_OFFSET =     39000;
const int TOOLS_MENU_POPUP_HELP_OFFSET =    39100;
const int HELP_MENU_POPUP_HELP_OFFSET =	    39200;
const int VIEW_MENU_POPUP_HELP_OFFSET =	    39400;
const int MENU_ID_HELP_OFFSET =              2000;

// Indexes for IDB_ICON_IMAGES image list:
const int II_INVALIDINDEX =        -1;
const int II_PERSON_BLUE =          0;     // Blue shirt
const int II_PERSON_RED =           1;     // Red shirt
const int II_PERSON_GREY =          2;     // Person disabled (Grey shirt)
const int II_PEOPLE =               3;     // 2 people
const int II_BLANK =                4;     // 
const int II_BUDDY =                5;     // Buddy List Application
const int II_SPEEDDIAL =            6;     // Speed Dial
const int II_DIRECTORY =            7;     // Directory
const int II_SERVER =               8;     // ILS Server
const int II_WAB =                  9;     // Windows Address Book
const int II_WAB_CARD =            10;     // Contact Card
const int II_COMPUTER =            11;     // Computer (generic)
const int II_IN_A_CALL =           12;     // Computer busy
const int II_NETMEETING =          13;     // NetMeeting World
const int II_HISTORY =             14;     // History
const int II_UNKNOWN =             15;     // ?
const int II_OUTLOOK_WORLD =       16;     // Outlook World
const int II_OUTLOOK_AGENT =       17;     // Outlook Agent
const int II_OUTLOOK_GROUP =       18;     // Outlook Group
const int II_IE =                  19;     // Internet Explorer
const int II_WEB_DIRECTORY =	   20;     // Web View Directory
const int II_AUDIO_CAPABLE =	   21;     // Audio Capable
const int II_VIDEO_CAPABLE =	   22;     // Video Capable
const int II_AUDIO_COLUMN_HEADER = 23;     // Audio Listview Column Header Icon
const int II_VIDEO_COLUMN_HEADER = 24;     // Video Listview Column Header Icon

// Alternate definitions for the small icons
const int II_PERSON =              II_PERSON_BLUE; // Person (generic)
const int II_USER =                II_PERSON_BLUE; // Member (generic)
const int II_GAL =                 II_WAB; // Global Address List

    // MAPI PR_DISPLAY_TYPE types
const int II_DISTLIST =            II_OUTLOOK_GROUP;
const int II_FORUM =               II_OUTLOOK_GROUP;
const int II_AGENT =               II_OUTLOOK_AGENT;
const int II_ORGANIZATION =        II_PEOPLE;
const int II_PRIVATE_DISTLIST =    II_OUTLOOK_GROUP;
const int II_REMOTE_MAILUSER =     II_OUTLOOK_WORLD;


// NavBar measurements
const int DXP_NAVBAR =            78;
const int DXP_NAVBAR_ICON =       32;
const int DYP_NAVBAR_ICON =       32;
const int DXP_NAVBAR_MARGIN =      3;
const int DYP_NAVBAR_MARGIN =      8;
const int DYP_NAVBAR_ICON_SPACING =3;
const int DXP_NAVBAR_ICON_BORDER = 2;
const int DXP_NAVBAR_ICON_ADJUST = 6;

// SplitBar measurements
const int DYP_SPLITBAR_MARGIN =    3;

// TitleBar measurements
const int DXP_TITLE_ICON_ADJUST =  4;
const int DYP_TITLE_ICON_ADJUST =  1;
const int DYP_TITLE_MARGIN     =   1; // almost no border

const int DXP_ICON_SMALL =        16;
const int DYP_ICON_SMALL =        16;

const int DXP_ICON_LARGE =        32;
const int DYP_ICON_LARGE =        32;

const int DYP_TITLEBAR = DYP_NAVBAR_ICON + (DYP_TITLE_ICON_ADJUST*2);  // Height of view title bar
const int DYP_TITLEBAR_LARGE = DYP_NAVBAR_ICON + (DYP_TITLE_ICON_ADJUST*2);
const int DYP_TITLEBAR_SMALL = DYP_ICON_SMALL + (DYP_TITLE_ICON_ADJUST*2);


// General UI measurements
const int UI_SPLITTER_WIDTH =          4;
const int UI_MINIMUM_VIEW_WIDTH =    120;
const int UI_MINIMUM_DIRVIEW_HEIGHT = 90;
const int UI_MINIMUM_VIEW_HEIGHT =    50;
const int UI_TAB_VERTICAL_MARGIN =     4;
const int UI_TAB_HORIZONTAL_MARGIN =   2;
const int UI_TAB_LEFT_MARGIN =         2;
const int UI_TAB_INTERNAL_MARGIN =     4;

// Video Window measurements
const int VIDEO_WIDTH_SQCIF =        128;
const int VIDEO_HEIGHT_SQCIF =        96;
const int VIDEO_WIDTH_QCIF =         176;
const int VIDEO_HEIGHT_QCIF =        144;
const int VIDEO_WIDTH_CIF =          352;
const int VIDEO_HEIGHT_CIF =         288;
const int VIDEO_GRAB_SIZE =           20;

#define VIDEO_WIDTH_DEFAULT 	VIDEO_WIDTH_QCIF
#define VIDEO_HEIGHT_DEFAULT	VIDEO_HEIGHT_QCIF

const int UI_VIDEO_BORDER =            6;


// Window IDs:
const UINT ID_STATUS =              600;
const UINT ID_TOOLBAR =             601;
const UINT ID_LISTVIEW =            602;
const UINT ID_DIR_LISTVIEW =        603;
const UINT ID_REBAR =               604;
const UINT ID_BRAND =               605;
const UINT ID_NAVBAR =              606;
const UINT ID_REBAR_FRAME =         607;
const UINT ID_VIDEO_VIEW =          608;
const UINT ID_FLDRBAR =             609;
const UINT ID_FLOAT_TOOLBAR =		610;
const UINT ID_LOGVIEW_LISTVIEW =	615;
const UINT ID_LOGVIEW_COMBOEX =		616;
const UINT ID_FRIENDSVIEW_LISTVIEW =617;
const UINT ID_AUDIO_BAND =			620;
const UINT ID_TITLE_BAR =           621;
const UINT ID_SPLIT_BAR =           622;
const UINT ID_SCROLL_BAR =          623;
const UINT ID_NAVBARCONTAINER =     624;
const UINT ID_TASKBAR_ICON =        650;
const UINT ID_CHAT_EDIT =           660;
const UINT ID_CHAT_MSG =            661;
const UINT ID_CHAT_LIST =           662;
const UINT ID_CHAT_SEND =           663;
const UINT ID_CHAT_DEST =           664;
const UINT ID_AUDIOLEVEL_BAND =			666;

const UINT ID_FIRST_EDITPANE =		1000;
const UINT ID_BANNER =				1000;
const UINT ID_CHATPANE =			1002;
const UINT ID_LAST_EDITPANE =		2000;

const int ID_AUDIODLG_GROUPBOX =	3300;
const int ID_AUDIODLG_MIC_TRACK =	3301;
const int ID_AUDIODLG_SPKR_TRACK =	3302;

// other id's:
const int MAX_REDIAL_ITEMS =        50;
const int ID_FIRST_REDIAL_ITEM =	31900;
const int ID_LAST_REDIAL_ITEM =     ID_FIRST_REDIAL_ITEM + MAX_REDIAL_ITEMS;

const int ID_EXTENDED_TOOLS_SEP =	32000;
const int ID_EXTENDED_TOOLS_ITEM =	32001;
const int MAX_EXTENDED_TOOLS_ITEMS=	50;

// Misc command ids:
const int ID_POPUPMSG_TIMEOUT =		28000;
const int ID_POPUPMSG_CLICK =		28001;

extern DWORD g_wsLayout;

#endif // ! _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\mapimyinfo.h ===
#include "precomp.h"

#define MAPIDLL					"MAPI32.DLL"

#define MAPIINITname			"MAPIInitialize"
#define MAPILOGONEXname			"MAPILogonEx"
#define MAPIFREEBUFFERname		"MAPIFreeBuffer"
#define MAPIUNINITIALIZEname	"MAPIUninitialize"

HRESULT MAPIGetMyInfo();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\membercollection.cpp ===
#include "Precomp.h"
#include "MemberCollection.h"
#include "Confroom.h"
#include "Particip.h"
#include "EnumVar.h"

//////////////////////////////////////////////////////////
// Construction / destruction / initialization
//////////////////////////////////////////////////////////

CMemberCollection::~CMemberCollection()
{
	_FreeMemberCollection();
}

//static 
HRESULT CMemberCollection::CreateInstance(CSimpleArray<IMember*>& rMemberObjs, IMemberCollection** ppMemberCollection)
{
	HRESULT hr = S_OK;
		
	CComObject<CMemberCollection>* p = NULL;
	p = new CComObject<CMemberCollection>(NULL);
	if(p)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hr = p->FinalConstruct();
		p->InternalFinalConstructRelease();
		if(hr == S_OK)
		{
			hr = p->QueryInterface(IID_IMemberCollection, reinterpret_cast<void**>(ppMemberCollection));
			if(SUCCEEDED(hr))
			{
				hr = p->_Init(rMemberObjs);
			}
		}

		if(FAILED(hr))		
		{
			delete p;
			*ppMemberCollection = NULL;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	
	return hr;
}

//////////////////////////////////////////////////////////
// IMemberCollection
//////////////////////////////////////////////////////////

STDMETHODIMP CMemberCollection::get_Item(VARIANT Index, IMember** ppMember)
{
	DBGENTRY(CMemberCollection::get_Item);
	HRESULT hr = S_OK;


	if(ppMember)
	{
		*ppMember = NULL;

		switch(Index.vt)
		{
			case VT_BSTR:
                LPTSTR  szName;
                hr =  BSTR_to_LPTSTR (&szName, Index.bstrVal);				        
                if (SUCCEEDED(hr))
                {
                    *ppMember = _GetMemberFromName(szName);		
                    if(*ppMember)
                    {
                        (*ppMember)->AddRef();
                    }
                    else
                    {
                        hr = E_FAIL;
                    }

                    // Free resources
                    //
                    delete (szName);
                }
                break;

			case VT_I2:
				if(m_Members.GetSize() < Index.iVal)
				{
					*ppMember = m_Members[Index.iVal];
					(*ppMember)->AddRef();
				}
				else
				{
					hr = E_INVALIDARG;
				}
				
				break;

			case VT_I4:
				if(m_Members.GetSize() < Index.lVal)
				{
					*ppMember = m_Members[Index.lVal];
					(*ppMember)->AddRef();
				}
				else
				{
					hr = E_INVALIDARG;
				}
				break;

			default:
				hr = E_INVALIDARG;
		}
	}
	else
	{
		hr = E_POINTER;
	}
	

	DBGEXIT_HR(CMemberCollection::get_Item,hr);
	return hr;
}

STDMETHODIMP CMemberCollection::_NewEnum(IUnknown** ppunk)
{
	DBGENTRY(CMemberCollection::_NewEnum);
	HRESULT hr = S_OK;

	
	SAFEARRAY* psa;
	SAFEARRAYBOUND rgsabound[1];
	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = m_Members.GetSize();

	psa = SafeArrayCreate(VT_DISPATCH, m_Members.GetSize(), rgsabound);

	if(psa)
	{
		for(int i = 0; i < m_Members.GetSize(); ++i)
		{
			CComPtr<IDispatch> spDispatch;
			hr = m_Members[i]->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(&spDispatch));
			ASSERT(SUCCEEDED(hr));

			CComVariant var(spDispatch);

			long ix[1] = {i};
			SafeArrayPutElement(psa, ix, &var);
		}

		CEnumVariant* pEnumVar = NULL;
		hr = CEnumVariant::Create(psa, m_Members.GetSize(), &pEnumVar);
		if(SUCCEEDED(hr))
		{
			hr = pEnumVar->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(ppunk));
		}

		SafeArrayDestroy(psa);
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	DBGEXIT_HR(CMemberCollection::_NewEnum,hr);
	return hr;
}

STDMETHODIMP CMemberCollection::get_Count(LONG * pnCount)
{
	DBGENTRY(CMemberCollection::get_Count);
	HRESULT hr = S_OK;

	if(pnCount)
	{
		*pnCount = m_Members.GetSize();	
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	DBGEXIT_HR(CMemberCollection::get_Count,hr);
	return hr;
}


//////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////
HRESULT CMemberCollection::_Init(CSimpleArray<IMember*>& rMemberObjs)
{
	HRESULT hr = S_OK;
	
	for(int i = 0; i < rMemberObjs.GetSize(); ++i)
	{
		IMember* pMember = rMemberObjs[i];
		pMember->AddRef();
		m_Members.Add(pMember);
	}

	return hr;	
}


void CMemberCollection::_FreeMemberCollection()
{
	for(int i = 0; i < m_Members.GetSize(); ++i)
	{
		m_Members[i]->Release();				
	}

	m_Members.RemoveAll();
}


IMember* CMemberCollection::_GetMemberFromName(LPCTSTR pszName)
{
	IMember* pRet = NULL;
	
	for(int i = 0; i < m_Members.GetSize(); ++i)
	{
		CComBSTR bstrName;
		if(SUCCEEDED(m_Members[i]->get_Name(&bstrName)))
		{
                        LPTSTR  szName;
                        hr =  BSTR_to_LPTSTR (&szName, bstrName);				        
                        if (SUCCEEDED(hr))
                        {
                            if(!lstrcmp(szName, pszName))
                            {
                                pRet = m_Members[i];
                                delete  (szName);
                                break;
                            }
                            delete  (szName);
                        }		    
		}
	}

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\mapimyinfo.cpp ===
#include "precomp.h"
#include "confpolicies.h"
#include "MapiMyInfo.h"

#define USES_IID_IMailUser
#define USES_IID_IAddrBook

#define INITGUID
#include <initguid.h>
#include <mapiguid.h>
#include <mapix.h>
#include <mapiutil.h>
#include <mapitags.h>

HRESULT MAPIGetMyInfo()
{
	HRESULT hr = E_FAIL;
	
	enum eProps
	{
		NAME,
		SUR_NAME,
		EMAIL,
		LOCATION,
		PHONENUM,
		COMMENT,
		PROP_COUNT
	};

	typedef struct tagData
	{
		DWORD dwPropVal;
		int   iIndex;
	} PROPDATA;
	
	HMODULE hMapi	= NmLoadLibrary( MAPIDLL , TRUE);
	if( NULL == hMapi )
	{
		return hr;
	}

	LPMAPIINITIALIZE	pfnMAPIInitialize		= (LPMAPIINITIALIZE)GetProcAddress( hMapi, MAPIINITname );
	LPMAPILOGONEX		pfnMAPILogonEx			= (LPMAPILOGONEX)GetProcAddress( hMapi, MAPILOGONEXname );
	LPMAPIFREEBUFFER	pfnMAPIFreeBuffer		= (LPMAPIFREEBUFFER)GetProcAddress( hMapi, MAPIFREEBUFFERname );
	LPMAPIUNINITIALIZE	pfnMAPIUninitialize		= (LPMAPIUNINITIALIZE)GetProcAddress( hMapi, MAPIUNINITIALIZEname );
	if( !(pfnMAPIInitialize && pfnMAPILogonEx && pfnMAPIFreeBuffer && pfnMAPIUninitialize) )
	{
		return hr;
	}

	PROPDATA PropData[ PROP_COUNT ];
	ZeroMemory( PropData, sizeof( PropData ) );

	PropData[NAME].dwPropVal		= ConfPolicies::GetGALName();
	PropData[SUR_NAME].dwPropVal	= ConfPolicies::GetGALSurName();
	PropData[EMAIL].dwPropVal		= ConfPolicies::GetGALEmail();
	PropData[LOCATION].dwPropVal	= ConfPolicies::GetGALLocation();
	PropData[PHONENUM].dwPropVal	= ConfPolicies::GetGALPhoneNum();
	PropData[COMMENT].dwPropVal		= ConfPolicies::GetGALComment();

	// First four are required, rest are optional
	if( !( PropData[NAME].dwPropVal && PropData[SUR_NAME].dwPropVal && PropData[EMAIL].dwPropVal && PropData[PHONENUM].dwPropVal) )
	{
		ERROR_OUT(("One or more required MAPI property fields are not set"));
		return hr;
	}

	SizedSPropTagArray( PROP_COUNT, SizedPropTagArray );
	LPSPropTagArray	lpSPropTagArray	= (LPSPropTagArray) &SizedPropTagArray;
	ZeroMemory( lpSPropTagArray, sizeof( lpSPropTagArray ) );

	// We can not retrieve the same property from this array twice.  Therefore never insert
	// until we are sure that the value is not there already.
	int insertAt;
	BOOL bPointAtNew = TRUE;
	int iCurPropTagArrayIndex = 0;
	for( int i = 0; i < PROP_COUNT; i++ )
	{
		if( PropData[i].dwPropVal )
		{
			bPointAtNew = TRUE;
			for( insertAt = 0; insertAt < iCurPropTagArrayIndex; insertAt++ )
			{
				if( PropData[insertAt].dwPropVal == PropData[i].dwPropVal )
				{
					bPointAtNew = FALSE;
					break;
				}
			}
			PropData[i].iIndex = insertAt;
			++iCurPropTagArrayIndex;
			lpSPropTagArray->aulPropTag[PropData[i].iIndex] = PROP_TAG( PT_TSTRING, PropData[i].dwPropVal );
			if( bPointAtNew ) 
			{
				lpSPropTagArray->cValues++;
			}
		}
	}

	hr = pfnMAPIInitialize( NULL );
	if( SUCCEEDED( hr ) )
	{
		LPMAILUSER		pMailUser				= NULL;
		LPADRBOOK		pAddrBook				= NULL;
		LPMAPISESSION	pMapiSession			= NULL;

		LPSPropValue	pPropValues				= NULL;
		LPENTRYID		pPrimaryIdentityEntryID	= NULL;

		hr = pfnMAPILogonEx(	NULL, // parent window
								NULL, // profile name
								NULL, // password
								MAPI_USE_DEFAULT | MAPI_NO_MAIL,
								&pMapiSession );
		if( SUCCEEDED( hr ) )
		{
			ULONG cbPrimaryIdentitySize	= 0;		
			hr = pMapiSession->QueryIdentity(	&cbPrimaryIdentitySize,
												&pPrimaryIdentityEntryID );
			if( SUCCEEDED( hr ) )
			{
				hr = pMapiSession->OpenAddressBook(	NULL, // parent window
													NULL, // Get an IAddrBook pointer
													AB_NO_DIALOG, // Supress UI interaction
													&pAddrBook );
				if( SUCCEEDED( hr ) )
				{
					ULONG uEntryType = 0;
					hr = pAddrBook->OpenEntry(	cbPrimaryIdentitySize,
												pPrimaryIdentityEntryID,
												&IID_IMailUser,
												0, // Flags
												&uEntryType,
												(LPUNKNOWN *)&pMailUser );
					if( SUCCEEDED( hr ) )
					{
						if( MAPI_MAILUSER == uEntryType )
						{	
							ULONG	cValues;
							hr = pMailUser->GetProps( lpSPropTagArray,
														fMapiUnicode,
														&cValues,
														&pPropValues );
							if( SUCCEEDED( hr ) ) 
							{
								// Check for full success
								for( i = 0; i < (int)lpSPropTagArray->cValues; i++ )
								{
										// We failed if a prop was specified, but none returned....
									if( ( PT_ERROR == LOWORD( pPropValues[i].ulPropTag ) ) && ( 0 != PropData[i].dwPropVal ) )
									{
										hr = E_FAIL;
										goto cleanup;
									}
								}

								// TODO - are there limitations on the length of this?
								RegEntry reIsapi( ISAPI_CLIENT_KEY, HKEY_CURRENT_USER );

								LPCTSTR pszName = pPropValues[ PropData[NAME].iIndex ].Value.LPSZ;
								if(pszName)
								{
									reIsapi.SetValue( REGVAL_ULS_FIRST_NAME, pszName );	
								}

								LPCTSTR pszSurName = pPropValues[ PropData[SUR_NAME].iIndex ].Value.LPSZ;
								if(pszSurName)
								{
									reIsapi.SetValue( REGVAL_ULS_LAST_NAME, pszSurName );	
								}

								LPCTSTR pszEmail = pPropValues[ PropData[EMAIL].iIndex ].Value.LPSZ;
								if(pszEmail)
								{
									reIsapi.SetValue( REGVAL_ULS_EMAIL_NAME, pszEmail );	
								}
								
								LPCTSTR pszPhoneNum = pPropValues[ PropData[PHONENUM].iIndex ].Value.LPSZ;
								if(pszPhoneNum)
								{
									reIsapi.SetValue( REGVAL_ULS_PHONENUM_NAME, pszPhoneNum );	
								}
								
								if(pszName)
								{
									TCHAR szULSName[ MAX_DCL_NAME_LEN + 1];
									wsprintf(	szULSName, 
												TEXT("%s %s"), 
												pszName,
												pszSurName
											);
									szULSName[ MAX_DCL_NAME_LEN ] = 0;
									reIsapi.SetValue( REGVAL_ULS_NAME, szULSName );
								}
								
								// Set Resolve Name
								LPCTSTR pszServerName = reIsapi.GetString( REGVAL_SERVERNAME );
								if( pszServerName && pszEmail)
								{
									TCHAR szBuffer[ MAX_PATH ];
									wsprintf(	szBuffer,
												TEXT("%s/%s"),
												pszServerName,
												pszEmail );
									szBuffer[ MAX_PATH - 1 ] = 0;
									reIsapi.SetValue( REGVAL_ULS_RES_NAME, szBuffer );
								}


									// Optional properties...
								if( PropData[ COMMENT ].dwPropVal )
								{
									reIsapi.SetValue( REGVAL_ULS_COMMENTS_NAME, pPropValues[ PropData[ COMMENT ].iIndex ].Value.LPSZ );
								}
								else
								{
									reIsapi.DeleteValue( REGVAL_ULS_COMMENTS_NAME );
								}

								if( PropData[LOCATION].dwPropVal )
								{
									reIsapi.SetValue( REGVAL_ULS_LOCATION_NAME, pPropValues[ PropData[LOCATION].iIndex ].Value.LPSZ );
								}
								else
								{
									reIsapi.DeleteValue( REGVAL_ULS_LOCATION_NAME );
								}

								// Generate a cert based on the entered information for secure calls
    							TCHAR szName[ MAX_PATH ];
	    						TCHAR szSurName[ MAX_PATH ];
		    					TCHAR szEmail[ MAX_PATH ];
			    				lstrcpy( szName, reIsapi.GetString( REGVAL_ULS_FIRST_NAME ) );
				    			lstrcpy( szSurName, reIsapi.GetString( REGVAL_ULS_LAST_NAME ) );
					    		lstrcpy( szEmail, reIsapi.GetString( REGVAL_ULS_EMAIL_NAME ) );
						    	MakeCertWrap(szName, szSurName, szEmail, 0);

								hr = S_OK;
							}
						}
					}
				}
			}
		}

cleanup:
		if( NULL != pPropValues )
		{
			pfnMAPIFreeBuffer( pPropValues );
		}

		if( NULL != pPrimaryIdentityEntryID )
		{
			pfnMAPIFreeBuffer( pPrimaryIdentityEntryID );
		}

		if( NULL != pMailUser)
		{
			pMailUser->Release();
		}

		if( NULL != pAddrBook)
		{
			pAddrBook->Release();
		}

		if( NULL != pMapiSession )
		{
			pMapiSession->Release();
		}

		pfnMAPIUninitialize();

		FreeLibrary( hMapi );
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\memmove.cpp ===
#include "precomp.h"

// In debug mode, we link with CRT, so we don't need this!
#ifndef _DEBUG


	/***
	*memmove.c - contains memmove routine
	*
	*       Copyright (c) 1988-1997, Microsoft Corporation. All right reserved.
	*
	*Purpose:
	*       memmove() copies a source memory buffer to a destination buffer.
	*       Overlapping buffers are treated specially, to avoid propogation.
	*
	*******************************************************************************/

	#if defined (_M_ALPHA)
	#pragma function(memmove)
	#endif  /* defined (_M_ALPHA) */

	/***
	*memmove - Copy source buffer to destination buffer
	*
	*Purpose:
	*       memmove() copies a source memory buffer to a destination memory buffer.
	*       This routine recognize overlapping buffers to avoid propogation.
	*       For cases where propogation is not a problem, memcpy() can be used.
	*
	*Entry:
	*       void *dst = pointer to destination buffer
	*       const void *src = pointer to source buffer
	*       size_t count = number of bytes to copy
	*
	*Exit:
	*       Returns a pointer to the destination buffer
	*
	*Exceptions:
	*******************************************************************************/

	void * __cdecl memmove (
			void * dst,
			const void * src,
			size_t count
			)
	{
			void * ret = dst;

	#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC)
			{
			extern void RtlMoveMemory( void *, const void *, size_t count );

			RtlMoveMemory( dst, src, count );
			}
	#else  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */
			if (dst <= src || (char *)dst >= ((char *)src + count)) {
					/*
					 * Non-Overlapping Buffers
					 * copy from lower addresses to higher addresses
					 */
					while (count--) {
							*(char *)dst = *(char *)src;
							dst = (char *)dst + 1;
							src = (char *)src + 1;
					}
			}
			else {
					/*
					 * Overlapping Buffers
					 * copy from higher addresses to lower addresses
					 */
					dst = (char *)dst + count - 1;
					src = (char *)src + count - 1;

					while (count--) {
							*(char *)dst = *(char *)src;
							dst = (char *)dst - 1;
							src = (char *)src - 1;
					}
			}
	#endif  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */

			return(ret);
	}

#endif // !_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\membercollection.h ===
#ifndef __MemberCollection_h__
#define __MemberCollection_h__

class CParticipant;

#include "NetMeeting.h"
#include "ias.h"

class ATL_NO_VTABLE CMemberCollection :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IMemberCollection, &IID_IMemberCollection, &LIBID_NetMeetingLib>
{

protected:
	CSimpleArray<IMember*> m_Members;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CMemberCollection)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMemberCollection)
	COM_INTERFACE_ENTRY(IMemberCollection)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


//////////////////////////////////////////////////////////
// Construction / destruction / initialization
//////////////////////////////////////////////////////////

~CMemberCollection();

static HRESULT CreateInstance(CSimpleArray<IMember*>& rMemberObjs, IMemberCollection** ppMemberCollection);

//////////////////////////////////////////////////////////
// IMemberCollection
//////////////////////////////////////////////////////////
	STDMETHOD(get_Item)(VARIANT Index, IMember** ppMember);
	STDMETHOD(_NewEnum)(IUnknown** ppunk);
    STDMETHOD(get_Count)(LONG * pnCount);

//////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////
	HRESULT _Init(CSimpleArray<IMember*>& rMemberObjs);
	void _FreeMemberCollection();
	IMember* _GetMemberFromName(LPCTSTR pszName);

};


#endif // __MemberCollection_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\mixer.cpp ===
#include "precomp.h"
#include <mixer.h>

//
// private APIs
//


#define MAX_MICROPHONE_DEVS 10

static MMRESULT mixerGetControlValue ( HMIXER, MIXVOLUME *, DWORD, UINT );
static MMRESULT mixerSetControlValue ( HMIXER, MIXVOLUME *, DWORD, UINT );
static MMRESULT mixerGetControlId ( HMIXER, DWORD *, DWORD, DWORD );
static MMRESULT mixerGetControlByType ( HMIXER, DWORD, DWORD, MIXERCONTROL *pMixerControl);

// used for AGC detection
static const char *szGain =  "gain";
static const char *szBoost = "boost";
static const char *szAGC   = "agc";


struct AGCDetails
{
	WORD wMID; // manufacturer ID
	WORD wPID; // product ID
	DWORD dwAGCID; // AGC ID
};



// we shouldn't have to use this table scheme anymore.
// CMixerDevice::DetectAGC will autodetect the control ID
static const AGCDetails AGCList[] =
{
//  MID    PID   AGCID
    {2,     409,   27},  // Creative Labs
    {21,     42,   13},  // Turtle Beach Tropez
    {132,     3, 2072},  // Crystal MMX
    {384,     7,   28},  // Xitel Storm 3d PCI
    {385,    32,   35}   // Aztech PCI-331
};


static BOOL GetAGCID(WORD wMID, WORD wPID, DWORD *pdwAGCID)
{
	int nIndex;
	int nAGCEntries = sizeof(AGCList) / sizeof(AGCDetails);

	for (nIndex = 0; nIndex < nAGCEntries; nIndex++)
	{
		if ( (AGCList[nIndex].wMID == wMID) &&
		     (AGCList[nIndex].wPID == wPID))
		{
			*pdwAGCID = AGCList[nIndex].dwAGCID;
			return TRUE;
		}
	}
	return FALSE;
}

/********************************************************************************\
*                                                                                *
*  void NewMixVolume(MIXVOLUME* lpMixVolDest, const MIXVOLUME& mixVolSource,     *
*                    DWORD      dwNewVolume)                                     *
*                                                                                *
*  NewMixVolume takes the current mixer value (mixVolSource), and converts it    *
*  to its adjusted value (lpMixVolDest) using the new volume settings            *
*  (dwNewVolume) and the proportionality between the left and right volumes of   *
*  mixVolSource. Note that if mixVolSource's left and right volumes are both     *
*  equal to zero, then their proportionality is set to 1/1.                      *
*                                                                                *
*  March 2001 Matthew Maddin (mmaddin@microsoft)                                 *
*                                                                                *
\********************************************************************************/
void NewMixVolume(MIXVOLUME* lpMixVolDest, const MIXVOLUME& mixVolSource, DWORD dwNewVolume)
{
    // If the source's left volume is the greater than the right volume, 
    // then it is the used to calculate the proportionality.
    if(mixVolSource.leftVolume == max(mixVolSource.leftVolume, mixVolSource.rightVolume))
    {
        // Set the left volume to the new value.
        lpMixVolDest->leftVolume = dwNewVolume;

        // If the left volume is non-zero, then continue with the proportionality calculation.
        if(mixVolSource.leftVolume)
        {
            // Calculate proportionality using the equation: NewRight = OldRight * (NewLeft/OldLeft)
            // where (NewLeft/OldLeft) Is the proportionality.
            lpMixVolDest->rightVolume = (mixVolSource.rightVolume*lpMixVolDest->leftVolume)/mixVolSource.leftVolume;

        }
        // Otherwise we cannot compute the proportionality and reset it to 1/1.
        // Note that 1/1 is not necessarily the 'correct' value. 
        else
        {
            // To maintain a ratio of 1/1 the right volume must equal the left volume.
            lpMixVolDest->rightVolume = lpMixVolDest->leftVolume;

        }

    }
    // Otherwise use the right volume to calculate the proportionality.
    else
    {
        // Set the right volume to the new value.
        lpMixVolDest->rightVolume = dwNewVolume;

        // If the right volume is non-zero, then continue with the proportionality calculation.
        if(mixVolSource.rightVolume)
        {
            // Calculate proportionality using the equation: NewLeft = OldLeft * (NewRight/OldRight)
            // where (NewRight/OldRight) Is the proportionality.
            lpMixVolDest->leftVolume = (mixVolSource.leftVolume*lpMixVolDest->rightVolume)/mixVolSource.rightVolume;

        }
        // Otherwise we cannot compute the proportionality and reset it to 1/1.
        // Note that 1/1 is not necessarily the 'correct' value. 
        else
        {
            // To maintain a ratio of 1/1 the left volume must equal the right volume.
            lpMixVolDest->leftVolume = lpMixVolDest->rightVolume;

        }

    }

}


//
//	Init
//
//	Enumerate all existing mixers in the system. For each mixer,
//	we enumerate all lines with destination Speaker and WaveIn.
//	For each such line, we cache the control id and control value
//	of volume control. An invalid flag will be tagged to any control
//  not supported by this mixer.
//	When an application is finished with all mixers operations,
//	it must call ReleaseAllMixers to free all memory resources and
//	mixers.
//
//	THIS MUST BE THE FIRST API TO CALL TO START MIXER OPERATIONS.
//
//	Input: The handle of the window which will handle all callback
//	messages MM_MIXM_CONTROL_CHANGE and MM_MIXM_LINE_CHANGE.
//
//	Output: TRUE if success; otherwise, FALSE.
//
BOOL CMixerDevice::Init( HWND hWnd, UINT uWaveDevId, DWORD dwFlags)
{
	UINT uMixerIdx, uDstIdx, uSrcIdx, uMixerIdCheck;
	MMRESULT mmr = MMSYSERR_NOERROR;
	MIXERLINE mlDst, mlSrc;
	UINT_PTR nMixers, nWaveInDevs, uIndex;

	//get the mixer device corresponding to the wave device
#ifndef _WIN64
	mmr = mixerGetID((HMIXEROBJ)uWaveDevId, &uMixerIdx, dwFlags);
#else
	mmr = MMSYSERR_NODRIVER;
#endif

	if ((mmr != MMSYSERR_NOERROR) && (mmr != MMSYSERR_NODRIVER)) {
		return FALSE;
	}

	// a simple fix for cheesy sound cards that don't make a
	// direct mapping between waveDevice and mixer device
	// e.g. MWAVE cards and newer SB NT 4 drivers
	// If there is only ONE mixer device  and if no other waveIn device
	// uses it, then it is probably valid.

	if ((mmr == MMSYSERR_NODRIVER) && (dwFlags == MIXER_OBJECTF_WAVEIN))
	{
		nMixers = mixerGetNumDevs();
		nWaveInDevs = waveInGetNumDevs();
		if (nMixers == 1)
		{
			uMixerIdx = 0;
			for (uIndex = 0; uIndex < nWaveInDevs; uIndex++)
			{
				mmr = mixerGetID((HMIXEROBJ)uIndex, &uMixerIdCheck, dwFlags);
				if ((mmr == MMSYSERR_NOERROR) && (uMixerIdCheck == uMixerIdx))
				{
					return FALSE;  // the mixer belongs to another waveIn Device
				}
			}
		}
		else
		{
			return FALSE;
		}
	}


	// open the mixer such that we can get notification messages
	mmr = mixerOpen (
			&m_hMixer,
			uMixerIdx,
			(DWORD_PTR) hWnd,
			0,
			(hWnd ? CALLBACK_WINDOW : 0) | MIXER_OBJECTF_MIXER);
	if (mmr != MMSYSERR_NOERROR) {
		return FALSE;
	}

	// get mixer caps
	mmr = mixerGetDevCaps (uMixerIdx, &(m_mixerCaps), sizeof (MIXERCAPS));
	if ((mmr != MMSYSERR_NOERROR) || (0 == m_mixerCaps.cDestinations)) {
		mixerClose(m_hMixer);
		return FALSE;
	}

	for (uDstIdx = 0; uDstIdx < m_mixerCaps.cDestinations; uDstIdx++)
	{
		ZeroMemory (&mlDst, sizeof (mlDst));
		mlDst.cbStruct = sizeof (mlDst);
		mlDst.dwDestination = uDstIdx;

		// get the mixer line for this destination
		mmr = mixerGetLineInfo ((HMIXEROBJ)m_hMixer, &mlDst,
					MIXER_GETLINEINFOF_DESTINATION | MIXER_OBJECTF_HMIXER);
		if (mmr != MMSYSERR_NOERROR) continue;

		// examine the type of this destination line
		if (((MIXER_OBJECTF_WAVEOUT == dwFlags) &&
			 (MIXERLINE_COMPONENTTYPE_DST_SPEAKERS == mlDst.dwComponentType)) ||
			((MIXER_OBJECTF_WAVEIN == dwFlags) &&
			 (MIXERLINE_COMPONENTTYPE_DST_WAVEIN == mlDst.dwComponentType)))
		{
			 // fill in more info about DstLine
			m_DstLine.ucChannels = mlDst.cChannels;
			if (!(mlDst.fdwLine & MIXERLINE_LINEF_DISCONNECTED))
			{
				// get id and value of volume control
				mmr = mixerGetControlId (
						m_hMixer,
						&m_DstLine.dwControlId,
						mlDst.dwLineID,
						MIXERCONTROL_CONTROLTYPE_VOLUME);
				m_DstLine.fIdValid = (mmr == MMSYSERR_NOERROR);

				m_DstLine.dwLineId = mlDst.dwLineID;
				m_DstLine.dwCompType = mlDst.dwComponentType;
				m_DstLine.dwConnections = mlDst.cConnections;

				// -----------------------------------------------------
				// enumerate all sources for this destination
				for (uSrcIdx = 0; uSrcIdx < mlDst.cConnections; uSrcIdx++)
				{
					// get the info of the line with specific src and dst...
					ZeroMemory (&mlSrc, sizeof (mlSrc));
					mlSrc.cbStruct = sizeof (mlSrc);
					mlSrc.dwDestination = uDstIdx;
					mlSrc.dwSource = uSrcIdx;

					mmr = mixerGetLineInfo (
							(HMIXEROBJ)m_hMixer,
							&mlSrc,
							MIXER_GETLINEINFOF_SOURCE | MIXER_OBJECTF_HMIXER);
					if (mmr == MMSYSERR_NOERROR)
					{
						if (((MIXERLINE_COMPONENTTYPE_DST_SPEAKERS == mlDst.dwComponentType) &&
							 (MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT == mlSrc.dwComponentType)) ||
							((MIXERLINE_COMPONENTTYPE_DST_WAVEIN == mlDst.dwComponentType) &&
							 (MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE == mlSrc.dwComponentType)))
						{
							// fill in more info about this source
							m_SrcLine.ucChannels = mlSrc.cChannels;

							// get id and value of volume control
							mmr = mixerGetControlId (
									m_hMixer,
									&m_SrcLine.dwControlId,
									mlSrc.dwLineID,
									MIXERCONTROL_CONTROLTYPE_VOLUME);
							m_SrcLine.fIdValid = (mmr == MMSYSERR_NOERROR);

							m_SrcLine.dwLineId = mlSrc.dwLineID;
							m_SrcLine.dwCompType = mlSrc.dwComponentType;
							m_SrcLine.dwConnections = mlSrc.cConnections;
							m_SrcLine.dwControls = mlSrc.cControls;

							DetectAGC();

							break;
						}
					}
				}
			}
			break;
		}
	}
		
    return TRUE;
}

CMixerDevice* CMixerDevice::GetMixerForWaveDevice( HWND hWnd, UINT uWaveDevId, DWORD dwFlags)
{
	CMixerDevice* pMixerDev = new CMixerDevice;
	if (NULL != pMixerDev)
	{
		if (!pMixerDev->Init(hWnd, uWaveDevId, dwFlags))
		{
			delete pMixerDev;
			pMixerDev = NULL;
		}
	}
	return pMixerDev;
}



// general method for setting the volume
// for recording, this will try to set both the master and microphone volume controls
// for playback, it will only set the WaveOut playback line (master line stays put)
BOOL CMixerDevice::SetVolume(MIXVOLUME * pdwVolume)
{
	BOOL fSetMain=FALSE, fSetSub;
	BOOL fMicrophone;
	
	// is this the microphone channel ?
	fMicrophone = ((m_DstLine.dwCompType == MIXERLINE_COMPONENTTYPE_DST_WAVEIN) ||
	               (m_SrcLine.dwCompType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE));

	fSetSub = SetSubVolume(pdwVolume);

	if ((fMicrophone) || (!fSetSub))
	{
		fSetMain = SetMainVolume(pdwVolume);
	}

	return (fSetSub || fSetMain);

}


BOOL CMixerDevice::SetMainVolume(MIXVOLUME * pdwVolume)
{
	MMRESULT mmr = MMSYSERR_ERROR;

	if (m_DstLine.fIdValid) {
		mmr = mixerSetControlValue (
				m_hMixer,
				pdwVolume,
				m_DstLine.dwControlId,
				2);
	}
	return (mmr == MMSYSERR_NOERROR);
}

BOOL CMixerDevice::SetSubVolume(MIXVOLUME * pdwVolume)
{
	MMRESULT mmr = MMSYSERR_ERROR;

	if (m_SrcLine.fIdValid)
	{
		mmr = mixerSetControlValue (
			m_hMixer,
			pdwVolume,
			m_SrcLine.dwControlId,
			m_SrcLine.ucChannels);
	}
	return (mmr == MMSYSERR_NOERROR);
}

//
// Gets the volume (0 - 65535) of the master volume
// returns TRUE if succesful,
// returns FALSE if it fails or if this control is not available
//

BOOL CMixerDevice::GetMainVolume(MIXVOLUME * pdwVolume)
{
	BOOL fRet = FALSE;

	if (m_DstLine.fIdValid)
	{
		MMRESULT mmr = ::mixerGetControlValue(
									m_hMixer,
									pdwVolume,
									m_DstLine.dwControlId,
		                            2);
		fRet = (mmr == MMSYSERR_NOERROR);
	}

	return fRet;
}

//
// Gets the volume (0 - 65535) of the sub volume
// returns TRUE if succesful,
// returns FALSE if it fails or if this control is not available
//

BOOL CMixerDevice::GetSubVolume(MIXVOLUME * pdwVolume)
{
	BOOL fRet = FALSE;

	if (m_SrcLine.fIdValid)
	{
		MMRESULT mmr = ::mixerGetControlValue(
									m_hMixer,
									pdwVolume,
									m_SrcLine.dwControlId,
									m_SrcLine.ucChannels);
		fRet = (mmr == MMSYSERR_NOERROR);
	}

	return fRet;
}


BOOL CMixerDevice::GetVolume(MIXVOLUME * pdwVol)
{
	MIXVOLUME dwSub={0,0}, dwMain={0,0};
	BOOL fSubAvail, fMainAvail, fMicrophone;

	// is this the microphone channel ?
	fMicrophone = ((m_DstLine.dwCompType == MIXERLINE_COMPONENTTYPE_DST_WAVEIN) ||
	               (m_SrcLine.dwCompType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE));


	fSubAvail = GetSubVolume(&dwSub);
	fMainAvail = GetMainVolume(&dwMain);

	if ((!fSubAvail) && (!fMainAvail))
	{
		pdwVol->leftVolume = 0;
		pdwVol->rightVolume = 0;
		return FALSE;
	}

	// don't return an average volume in the case of the speaker mixer
	if (fSubAvail && fMainAvail && fMicrophone)
	{
		pdwVol->leftVolume =  dwSub.leftVolume;
		pdwVol->rightVolume = dwSub.rightVolume;
	}

	else if (fSubAvail)
	{
		pdwVol->leftVolume =  dwSub.leftVolume;
		pdwVol->rightVolume = dwSub.rightVolume;
	}

	else
	{
		pdwVol->leftVolume =  dwMain.leftVolume;
		pdwVol->rightVolume = dwMain.rightVolume;
	}

	return TRUE;

}


// Return the value of the Auto Gain Control
// Returns FALSE if the control is not supported.
// pfOn is OUTPUT, OPTIONAL - value of AGC
BOOL CMixerDevice::GetAGC(BOOL *pfOn)
{
	MIXVOLUME dwValue;
	MMRESULT mmr;

	if ((m_SrcLine.fIdValid==FALSE) || (m_SrcLine.fAgcAvailable==FALSE))
	{
		return FALSE;
	}

	mmr = mixerGetControlValue(m_hMixer, &dwValue, m_SrcLine.dwAGCID, 1);
	if (mmr != MMSYSERR_NOERROR)
	{
		return FALSE;
	}

	if (pfOn)
	{
 		*pfOn = dwValue.leftVolume || dwValue.rightVolume;
	}
	
	return TRUE;
}

/*
	Hack API to turn MIC Auto Gain Control on or off.
	Its a hack because it only works on SB16/AWE32 cards.
*/
BOOL CMixerDevice::SetAGC(BOOL fOn)
{
	MIXVOLUME dwValue;
	MMRESULT mmr;

	if ((m_SrcLine.fIdValid==FALSE) || (m_SrcLine.fAgcAvailable==FALSE))
	{
		return FALSE;
	}

	mmr = mixerGetControlValue(m_hMixer, &dwValue, m_SrcLine.dwAGCID, 1);
	if (mmr != MMSYSERR_NOERROR)
	{
		return FALSE;
	}

	if (dwValue.leftVolume == (DWORD)fOn && dwValue.rightVolume == (DWORD)fOn)
	{
		return TRUE;
	}
	
	dwValue.leftVolume  = fOn;
	dwValue.rightVolume = fOn;
	mmr = mixerSetControlValue(m_hMixer, &dwValue, m_SrcLine.dwAGCID, 1);
	return (mmr == MMSYSERR_NOERROR);
}


// this method tries to determine if an AGC control is available by
// looking for a microphone sub-control that has a corresponding text
// string with the words "gain", "boost", or "agc" in in.
// If it can't  auto-detect it through string compares, it falls
// back to a table lookup scheme.  (Auto-detect will probably not work
// in localized versions of the driver.  But hardly anyone localizes
// their drivers.)
BOOL CMixerDevice::DetectAGC()
{
	MIXERLINECONTROLS mlc;
	MIXERCONTROL *aMC=NULL;
	MIXERCONTROL *pMC;
	MMRESULT mmrQuery;
	DWORD dwIndex;


	if ((m_SrcLine.fIdValid == FALSE) || (m_SrcLine.dwCompType != MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE))
	{
		return FALSE;
	}

	// make sure that dwControls isn't set to something outrageous
	if ((m_SrcLine.dwControls > 0) && (m_SrcLine.dwControls < 30))
	{
		aMC = new MIXERCONTROL[m_SrcLine.dwControls];

		mlc.cbStruct = sizeof(MIXERLINECONTROLS);
		mlc.dwLineID = m_SrcLine.dwLineId;
		mlc.dwControlType = 0; // not set ???
		mlc.cControls = m_SrcLine.dwControls;
		mlc.cbmxctrl = sizeof(MIXERCONTROL);  // set to sizeof 1 MC structure
		mlc.pamxctrl = aMC;


		mmrQuery = mixerGetLineControls((HMIXEROBJ)m_hMixer, &mlc, MIXER_OBJECTF_HMIXER|MIXER_GETLINECONTROLSF_ALL );
		if (mmrQuery == MMSYSERR_NOERROR)
		{
			for (dwIndex = 0; dwIndex < mlc.cControls; dwIndex++)
			{
				pMC = &aMC[dwIndex];

				// make sure we don't get a fader, mute, or some other control
				if ( (!(pMC->dwControlType & MIXERCONTROL_CT_CLASS_SWITCH)) ||
					 (pMC->dwControlType == MIXERCONTROL_CONTROLTYPE_MUTE) )
				{
					continue;
				}

				CharLower(pMC->szName);   // CharLower is a Win32 string function
				CharLower(pMC->szShortName);
				if ( _StrStr(pMC->szName, szGain) || _StrStr(pMC->szName, szBoost) || _StrStr(pMC->szName, szAGC) ||
			         _StrStr(pMC->szShortName, szGain) || _StrStr(pMC->szShortName, szBoost) || _StrStr(pMC->szShortName, szAGC) )
				{
					m_SrcLine.fAgcAvailable = TRUE;
					m_SrcLine.dwAGCID = pMC->dwControlID;
					TRACE_OUT(("CMixerDevice::DetectAGC - Autodetected control ID %d as AGC\r\n", m_SrcLine.dwAGCID));
					break;
				}
			}
		}
	}

	// if we didn't find the mixer dynamically, consult our old list
	if (!m_SrcLine.fAgcAvailable)
	{
		m_SrcLine.fAgcAvailable = GetAGCID(m_mixerCaps.wMid, m_mixerCaps.wPid, &(m_SrcLine.dwAGCID));
	}

	if (aMC)
		delete [] aMC;

	return m_SrcLine.fAgcAvailable;
}



BOOL CMixerDevice::EnableMicrophone()
{
	MIXERLINE mixerLine;
	MIXERCONTROL mixerControl;
	MIXERCONTROLDETAILS mixerControlDetails, mixerControlDetailsOrig;
	UINT uIndex, numItems, numMics, numMicsSet, fMicFound;
	UINT uMicIndex = 0;
	UINT aMicIndices[MAX_MICROPHONE_DEVS];
	MIXERCONTROLDETAILS_LISTTEXT *aListText = NULL;
	MIXERCONTROLDETAILS_BOOLEAN *aEnableList = NULL;
	MMRESULT mmr;
	BOOL fLoopback=FALSE;
	UINT uLoopbackIndex=0;

	// check to see if component type is valid (which means the line exists!)
	// even if the volume control doesn't exist or isn't slidable,
	// there may still be a select switch
	if ((m_SrcLine.dwCompType != MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE) ||
	    (m_DstLine.dwCompType != MIXERLINE_COMPONENTTYPE_DST_WAVEIN))
	{
		return FALSE;
	}

	// try to find the mixer list
	if (    (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CT_CLASS_LIST, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MIXER, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MUX, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_SINGLESELECT, &mixerControl))
	   )
	{
		TRACE_OUT(("CMixerDevice::EnableMicrophone-Unable to find mixer list!"));

		// if no mixer list, see if there is a "mute" control...
		return UnMuteVolume();

		// note: even though we don't have a mixer mux/select control
		// we could still find a way to mute the loopback line
		// unfortunately, we don't have the code that finds the line id
		// of the loopback control

	}

	ZeroMemory(&mixerControlDetails, sizeof(MIXERCONTROLDETAILS));

	mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
	mixerControlDetails.dwControlID = mixerControl.dwControlID;
	if (MIXERCONTROL_CONTROLF_UNIFORM & mixerControl.fdwControl)
		mixerControlDetails.cChannels = 1;
	else
		mixerControlDetails.cChannels = m_DstLine.ucChannels;

	if (MIXERCONTROL_CONTROLF_MULTIPLE & mixerControl.fdwControl)
		mixerControlDetails.cMultipleItems = (UINT)mixerControl.cMultipleItems;
	else
		mixerControlDetails.cMultipleItems = 1;

	// weirdness - you have to set cbDetails to the size of a single LISTTEXT item
	// setting it to anything larger will make the call fail
	mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_LISTTEXT);


	numItems = mixerControlDetails.cMultipleItems;
	if (m_DstLine.dwConnections > numItems)
		numItems = m_DstLine.dwConnections;

	aListText = new MIXERCONTROLDETAILS_LISTTEXT[numItems];
	aEnableList = new MIXERCONTROLDETAILS_BOOLEAN[numItems];
	if ((aListText == NULL) || (aEnableList == NULL))
	{
		WARNING_OUT(("CMixerDevice::EnableMicrophone-Out of memory"));
		return FALSE;
	}

	ZeroMemory(aListText, sizeof(MIXERCONTROLDETAILS_LISTTEXT)*numItems);
	ZeroMemory(aEnableList, sizeof(MIXERCONTROLDETAILS_BOOLEAN)*numItems);

	mixerControlDetails.paDetails = aListText;

	// preserve the settings, some values will change after this call
	mixerControlDetailsOrig = mixerControlDetails;

	// query for the text of the list
	mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
	                             MIXER_GETCONTROLDETAILSF_LISTTEXT
	                             |MIXER_OBJECTF_HMIXER);

	// some sound cards don't specify CONTROLF_MULTIPLE
	// try doing what sndvol32 does for MUX controls
	if (mmr != MMSYSERR_NOERROR)
	{
		mixerControlDetails = mixerControlDetailsOrig;
		mixerControlDetails.cChannels = 1;
		mixerControlDetails.cMultipleItems = m_DstLine.dwConnections;
		mixerControlDetailsOrig = mixerControlDetails;
		mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
		                             MIXER_GETCONTROLDETAILSF_LISTTEXT
		                             |MIXER_OBJECTF_HMIXER);
	}

	if (mmr != MMSYSERR_NOERROR)
	{
		delete [] aListText;
		delete [] aEnableList;
		return FALSE;
	}

	// enumerate for the microphone
	numMics = 0;
	fMicFound = FALSE;
	for (uIndex = 0; uIndex < mixerControlDetails.cMultipleItems; uIndex++)
	{
		// dwParam1 of the listText structure is the LineID of the source
		// dwParam2 should be the component type, but unfoturnately not
		// all sound cards obey this rule.
		ZeroMemory (&mixerLine, sizeof(MIXERLINE));
		mixerLine.cbStruct = sizeof(MIXERLINE);
		mixerLine.dwLineID = aListText[uIndex].dwParam1;

		mmr = mixerGetLineInfo ((HMIXEROBJ)m_hMixer, &mixerLine,
					MIXER_GETLINEINFOF_LINEID | MIXER_OBJECTF_HMIXER);

		if ((mmr == MMSYSERR_NOERROR) &&
		    (mixerLine.dwComponentType == m_SrcLine.dwCompType) &&
			 (numMics < MAX_MICROPHONE_DEVS))
		{
			aMicIndices[numMics] = uIndex;
			numMics++;
		}

		if (aListText[uIndex].dwParam1 == m_SrcLine.dwLineId)
		{
			uMicIndex = uIndex;
			fMicFound = TRUE;  // can't rely on uIndex or uNumMics not zero
		}

		if ((mmr == MMSYSERR_NOERROR) &&
		    (mixerLine.dwComponentType == MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT))
		{
			fLoopback = TRUE;
			uLoopbackIndex = uIndex;
		}

	}

	if (fMicFound == FALSE)
	{
		delete [] aListText;
		delete [] aEnableList;
		return FALSE;
	}

	// now we know which position in the array to set, let's do it.
	mixerControlDetails = mixerControlDetailsOrig;
	mixerControlDetails.paDetails = aEnableList;
	mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

	// find out what's already marked as set.
	mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
	        MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);

	if ( (mmr == MMSYSERR_NOERROR) &&
	     ( (aEnableList[uMicIndex].fValue != 1) || (fLoopback && aEnableList[uLoopbackIndex].fValue == 1) )
	   )
	{
		// how many microphone's are already enabled ?
		// if another microphone is already enabled and if the device is MUX type
		// we won't attempt to turn one on.
		numMicsSet = 0;
		for (uIndex = 0; uIndex < numMics; uIndex++)
		{
			if ((aEnableList[aMicIndices[uIndex]].fValue == 1) &&
			    (uIndex != uMicIndex))
			{
				numMicsSet++;
			}
		}


		if ( (mixerControl.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX)
		   ||(mixerControl.dwControlType == MIXERCONTROL_CONTROLTYPE_SINGLESELECT))
		{
			ZeroMemory(aEnableList, sizeof(aEnableList)*numItems);
			aEnableList[uMicIndex].fValue = 1;
			if (numMicsSet == 0)
			{
				mmr = mixerSetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
			                             MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
			}
			else
			{
				mmr = MMSYSERR_ERROR;  // a mike has already been enabled
			}
		}
		else
		{
			mixerControlDetails = mixerControlDetailsOrig;
			mixerControlDetails.paDetails = aEnableList;
			mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

			// enable the microphone
			aEnableList[uMicIndex].fValue = 1;

			mmr = mixerSetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
		                             MIXER_GETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);


			// disable the loopback input
			if (fLoopback)
			{
				aEnableList[uLoopbackIndex].fValue = 0;

				mixerSetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
			                             MIXER_GETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);

			}

			
		}
	}

	delete []aEnableList;
	delete []aListText;

	return (mmr == MMSYSERR_NOERROR);

}


BOOL CMixerDevice::UnMuteVolume()
{
	MIXERCONTROL mixerControl;
	MIXERCONTROLDETAILS mixerControlDetails;
	MIXERCONTROLDETAILS_BOOLEAN mcdb;
	MMRESULT mmrMaster=MMSYSERR_ERROR, mmrSub=MMSYSERR_ERROR;

	// try to unmute the master volume (playback only)
	if (m_DstLine.dwCompType == MIXERLINE_COMPONENTTYPE_DST_SPEAKERS)
	{


		mmrMaster = mixerGetControlByType(m_hMixer,
		            m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MUTE,
			          &mixerControl);

		if (mmrMaster == MMSYSERR_NOERROR)
		{
			ZeroMemory(&mixerControlDetails, sizeof(MIXERCONTROLDETAILS));
			mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
			mixerControlDetails.dwControlID = mixerControl.dwControlID;

			mixerControlDetails.cChannels = 1;
			mixerControlDetails.cMultipleItems = 0;

			mcdb.fValue = 0;
			mixerControlDetails.paDetails = &mcdb;
			mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

			mmrMaster = mixerSetControlDetails((HMIXEROBJ)m_hMixer,
			            &mixerControlDetails,
			            MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
		
		}
	}


	// Unmute the source line
	// this will unmute WaveOut, and possibly the microphone
	// (Use EnableMicrophone() above to handle all the potential microphone cases)

	if ((m_SrcLine.dwCompType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE) ||
		(m_SrcLine.dwCompType == MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT))
	{

	
		mmrSub = mixerGetControlByType(m_hMixer,
		         m_SrcLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MUTE,
			     &mixerControl);

		if (mmrSub == MMSYSERR_NOERROR)
		{
			ZeroMemory(&mixerControlDetails, sizeof(MIXERCONTROLDETAILS));
			mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
			mixerControlDetails.dwControlID = mixerControl.dwControlID;

			mixerControlDetails.cChannels = 1;
			mixerControlDetails.cMultipleItems = 0;

			mcdb.fValue = 0;
			mixerControlDetails.paDetails = &mcdb;
			mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

			mmrSub =  mixerSetControlDetails((HMIXEROBJ)m_hMixer,
				      &mixerControlDetails,
					  MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
		}
	}


	return ((mmrSub == MMSYSERR_NOERROR) || (mmrMaster == MMSYSERR_NOERROR));

}



//////////////////////////////////////////////////
//
// The following are private APIs
//

static MMRESULT mixerGetControlValue ( HMIXER hMixer, MIXVOLUME *pdwValue,
								DWORD dwControlId, UINT ucChannels )
{
	MIXERCONTROLDETAILS mxcd;
	MMRESULT mmr;

	ZeroMemory (&mxcd, sizeof (mxcd));
	mxcd.cbStruct = sizeof (mxcd);
	mxcd.dwControlID = dwControlId;
	mxcd.cChannels = ucChannels;
	mxcd.cbDetails = sizeof (DWORD);
	mxcd.paDetails = (PVOID) pdwValue;
	mmr = mixerGetControlDetails ((HMIXEROBJ) hMixer, &mxcd,
			MIXER_GETCONTROLDETAILSF_VALUE | MIXER_OBJECTF_HMIXER);
	return mmr;
}


static MMRESULT mixerSetControlValue ( HMIXER hMixer, MIXVOLUME * pdwValue,
								DWORD dwControlId, UINT ucChannels )
{
	MIXERCONTROLDETAILS mxcd;
	MMRESULT mmr;

	ZeroMemory (&mxcd, sizeof (mxcd));
	mxcd.cbStruct = sizeof (mxcd);
	mxcd.dwControlID = dwControlId;
	mxcd.cChannels = ucChannels;
	mxcd.cbDetails = sizeof (DWORD);
	mxcd.paDetails = (PVOID) pdwValue;
	mmr = mixerSetControlDetails ((HMIXEROBJ) hMixer, &mxcd,
			MIXER_SETCONTROLDETAILSF_VALUE | MIXER_OBJECTF_HMIXER);
	return mmr;
}


static MMRESULT mixerGetControlId ( HMIXER hMixer, DWORD *pdwControlId,
							 DWORD dwLineId, DWORD dwControlType )
{
	MIXERLINECONTROLS mxlc;
	MIXERCONTROL mxc;
	MMRESULT mmr;

	ZeroMemory (&mxlc, sizeof (mxlc));
	ZeroMemory (&mxc, sizeof (mxc));
	mxlc.cbStruct = sizeof (mxlc);
	mxlc.dwLineID = dwLineId;
	mxlc.dwControlType = dwControlType;
	mxlc.cControls = 1;
	mxlc.cbmxctrl = sizeof (mxc);
	mxlc.pamxctrl = &mxc;
	mmr = mixerGetLineControls ((HMIXEROBJ) hMixer, &mxlc,
				MIXER_GETLINECONTROLSF_ONEBYTYPE | MIXER_OBJECTF_HMIXER);
	*pdwControlId = mxc.dwControlID;
	return mmr;
}


// similar to above, except returns the whole control
static MMRESULT mixerGetControlByType ( HMIXER hMixer, DWORD dwLineId, DWORD dwControlType, MIXERCONTROL *pMixerControl)
{
	MIXERLINECONTROLS mxlc;
	MMRESULT mmr;

	ZeroMemory (&mxlc, sizeof (mxlc));
	ZeroMemory (pMixerControl, sizeof (MIXERCONTROL));
	mxlc.cbStruct = sizeof (mxlc);
	mxlc.dwLineID = dwLineId;
	mxlc.dwControlType = dwControlType;
	mxlc.cControls = 1;
	mxlc.cbmxctrl = sizeof (MIXERCONTROL);
	mxlc.pamxctrl = pMixerControl;
	mmr = mixerGetLineControls ((HMIXEROBJ) hMixer, &mxlc,
				MIXER_GETLINECONTROLSF_ONEBYTYPE | MIXER_OBJECTF_HMIXER);
	
	return mmr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\menuutil.h ===
#ifndef _MENUUTIL_H_
#define _MENUUTIL_H_

const int MENUPOS_CALL			= 0;
const int MENUPOS_VIEW			= 1;
const int MENUPOS_TOOLS			= 2;
const int MENUPOS_HELP			= 3;

const int MENUPOS_TOOLS_VIDEO		= 0;

// Owner Draw Info:
struct MYOWNERDRAWSTRUCT
{
	HICON	hIcon;
	HICON	hIconSel;
	int		iImage;
	PVOID	pvObj;
	BOOL	fCanCheck;
	BOOL	fChecked;
	LPTSTR	pszText;
};
typedef MYOWNERDRAWSTRUCT* PMYOWNERDRAWSTRUCT;

const int MENUICONSIZE = 16;
const int MENUICONGAP = 3;
const int MENUICONSPACE = 3;
const int MENUTEXTOFFSET = MENUICONSIZE + (2 * MENUICONSPACE) + MENUICONGAP;
const int MENUSELTEXTOFFSET = MENUICONSIZE + (2 * MENUICONSPACE) + 1;


struct TOOLSMENUSTRUCT
{
    MYOWNERDRAWSTRUCT   mods;
	UINT				uID;
	TCHAR				szExeName[MAX_PATH];
	TCHAR				szDisplayName[MAX_PATH];
};

UINT FillInTools(	HMENU hMenu, 
					UINT uIDOffset, 
					LPCTSTR pcszRegKey, 
					CSimpleArray<TOOLSMENUSTRUCT*>& rToolsList);

UINT CleanTools(HMENU hMenu, 
				CSimpleArray<TOOLSMENUSTRUCT*>& rToolsList);


#endif // _MENUUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\menuutil.cpp ===
// File: menuutil.cpp

#include "precomp.h"
#include "resource.h"
#include "MenuUtil.h"
#include "cmd.h"
#include "ConfUtil.h"



/****************************************************************************
*
*    FUNCTION: FillInTools()
*
*    PURPOSE:  Fills in the Tools menu from a specified reg key
*
****************************************************************************/

UINT FillInTools(	HMENU hMenu, 
					UINT uIDOffset, 
					LPCTSTR pcszRegKey, 
					CSimpleArray<TOOLSMENUSTRUCT*>& rToolsList)
{
	ASSERT(pcszRegKey);

	RegEntry reToolsKey(pcszRegKey, HKEY_LOCAL_MACHINE);
	if (ERROR_SUCCESS == reToolsKey.GetError())
	{
		BOOL fFirstItem = TRUE;
		RegEnumValues rev(&reToolsKey);
		while (ERROR_SUCCESS == rev.Next())
		{
			TOOLSMENUSTRUCT* ptms = new TOOLSMENUSTRUCT;
			if (NULL != ptms)
			{
				ptms->mods.iImage = 0;
				ptms->mods.hIcon = NULL;
				ptms->mods.hIconSel = NULL;
				ptms->mods.fChecked = FALSE;
				ptms->mods.fCanCheck = FALSE;
				ptms->mods.pszText = (LPTSTR) &(ptms->szDisplayName);
				ptms->uID = ID_EXTENDED_TOOLS_ITEM + uIDOffset;
				if ((REG_SZ == rev.GetType()) && (0 != rev.GetDataLength()))
				{
					lstrcpyn(	ptms->szExeName,
								(LPTSTR) rev.GetData(),
								ARRAY_ELEMENTS(ptms->szExeName));
					SHFILEINFO shfi;
					if (NULL != SHGetFileInfo(
									ptms->szExeName,
									0,
									&shfi,
									sizeof(shfi),
									SHGFI_ICON | SHGFI_SMALLICON))
					{
						ptms->mods.hIcon = shfi.hIcon;
					}
				}
				else
				{
					ptms->szExeName[0] = _T('\0');
				}
				if (NULL == ptms->mods.hIcon)
				{
					// The icon wasn't filled in, so use a default icon
					ptms->mods.hIcon = ::LoadIcon(NULL, IDI_APPLICATION);
				}
				lstrcpyn(	ptms->szDisplayName,
							rev.GetName(),
							ARRAY_ELEMENTS(ptms->szDisplayName));

				rToolsList.Add(ptms);

				if (fFirstItem)
				{
					// add a separator first
					::AppendMenu(	hMenu,
									MF_SEPARATOR,
									ID_EXTENDED_TOOLS_SEP,
									NULL);
					fFirstItem = FALSE;
				}
				
				if (::AppendMenu(	hMenu,
									MF_ENABLED | MF_OWNERDRAW,
									ptms->uID,
									(LPCTSTR) ptms))
				{
					uIDOffset++;
				}
			}
		}
	}

	return uIDOffset;
}

/****************************************************************************
*
*    FUNCTION: CleanTools()
*
*    PURPOSE:  Cleans up a tools menu
*
****************************************************************************/

UINT CleanTools(HMENU hMenu, 
				CSimpleArray<TOOLSMENUSTRUCT*>& rToolsList)
{
	DebugEntry(CleanTools);

	if (NULL != hMenu)
	{
		// remove separator
		::RemoveMenu(hMenu, ID_EXTENDED_TOOLS_SEP, MF_BYCOMMAND);
	}
	
	while (0 != rToolsList.GetSize())
	{
		TOOLSMENUSTRUCT* ptms = rToolsList[0];

		if (NULL != ptms)
		{
			if (NULL != ptms->mods.hIcon)
			{
				::DestroyIcon(ptms->mods.hIcon);
			}
			if (NULL != ptms->mods.hIconSel)
			{
				::DestroyIcon(ptms->mods.hIconSel);
			}
			
			if (NULL != hMenu)
			{
				::RemoveMenu(hMenu, ptms->uID, MF_BYCOMMAND);
			}

			delete ptms;
			rToolsList.RemoveAt(0);
		}
	}
	
	DebugExitULONG(CleanTools, 0);
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\mrulist.h ===
// File: mrulist.h

// CMRUList class - a simple class for maintaining the list of
// most recently used items.
//
// Warning: this class doesn't not perform parameter validation
// and is not safe in a multi-threaded environment
//
// FUTURE: This chews up almost 4K for the string data!
//         Allow for generic type.

#ifndef _MRULIST_H_
#define _MRULIST_H_

const int MRU_MAX_ENTRIES = 15;
const int MRU_MAX_STRING  = 256;

class CMRUList
{
private:
	TCHAR	m_szNames[MRU_MAX_ENTRIES][MRU_MAX_STRING];
	BOOL	m_fDirty;
	int		m_nValidEntries;
	LPTSTR	m_pszRegKey;

	BOOL	ShiftEntries(int nSrc, int nDest, int cEntries=0);

public:
			CMRUList();
			~CMRUList();
	BOOL	Load(LPCTSTR pcszRegKey);
	BOOL	Save();
	int		GetNumEntries()						{ return m_nValidEntries; };

	// Note: these functions do not check if a valid index has been passed in
	LPCTSTR	GetNameEntry(int nEntryIndex)		{ return m_szNames[nEntryIndex];		};
	
	LPCTSTR PszEntry(int iItem)   {return m_szNames[(m_nValidEntries-iItem)-1];};


	BOOL	AddNewEntry(LPCTSTR pcszName);
	int		FindEntry(LPCTSTR pcszName);
	BOOL	MoveEntryToTop(int nIndex);

	bool
	DeleteEntry
	(
		const TCHAR * const	entry
	);

	bool
	ReplaceEntry
	(
		const TCHAR * const	oldEntry,
		const TCHAR * const	newEntry
	);

	bool
	AppendEntry
	(
		const TCHAR * const	entry
	);

};

#endif // ! _MRULIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\mixer.h ===
// File: mixer.h

#ifndef _MIXER_H_
#define _MIXER_H_

typedef struct tagMixLVolume
{
	DWORD leftVolume;
	DWORD rightVolume;
}MIXVOLUME;

void NewMixVolume(MIXVOLUME* lpMixVolDest, const MIXVOLUME& mixVolSource, DWORD dwNewVolume);

typedef struct tagMixLine
{
	UINT	ucChannels;
	BOOL	fIdValid;
	DWORD	dwControlId;

	DWORD dwLineId;   // line ID of destination
	DWORD dwCompType; // Component type
	DWORD dwConnections; // number of sources associated with this line

	DWORD dwControls;  // number of sub controls (such as AGC) associated with this line
	BOOL fAgcAvailable;
	DWORD dwAGCID;
} MIXLINE;

class CMixerDevice
{
private:
	HMIXER	 	m_hMixer;
	MIXERCAPS	m_mixerCaps;
	MIXLINE		m_DstLine;
	MIXLINE		m_SrcLine;

	BOOL		Init( HWND hWnd, UINT uWaveDevId, DWORD dwFlags);

	BOOL DetectAGC();


protected:
	CMixerDevice()
	{
		m_hMixer = NULL;
		ZeroMemory (&m_DstLine, sizeof(m_DstLine));
		ZeroMemory (&m_SrcLine, sizeof(m_SrcLine));
	}

public:
	~CMixerDevice()
	{
		if (NULL != m_hMixer)
		{
			mixerClose(m_hMixer);
		}
	}

	BOOL SetVolume (MIXVOLUME * pdwVolume);
	BOOL CanSetVolume () { return m_DstLine.fIdValid || m_SrcLine.fIdValid; }
	BOOL SetMainVolume(MIXVOLUME * pdwVolume);
	BOOL SetSubVolume(MIXVOLUME * pdwVolume);
	BOOL SetAGC(BOOL fOn);
	BOOL GetMainVolume(MIXVOLUME * pdwVolume);
	BOOL GetSubVolume(MIXVOLUME * pdwVolume);
	BOOL GetVolume(MIXVOLUME * pdwVolume);
	BOOL GetAGC(BOOL *pfOn);
	BOOL EnableMicrophone();
	BOOL UnMuteVolume();

	static CMixerDevice* GetMixerForWaveDevice( HWND hWnd, UINT uWaveDevId, DWORD dwFlags);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\mrulist2.h ===
// File: mrulist.h

#ifndef _MRULIST2_H_
#define _MRULIST2_H_

#include "ConfUtil.h"
#include "richaddr.h"

typedef VOID * PMRUE;  // MRU Entries

enum {
	MRUTYPE_SZ = 1,
	MRUTYPE_DW = 2,
};

class CMRUList2
{
private:
	const DWSTR * m_prgDwStr;// {{cCol, pszKey}, {mruType, pszPrefix1}, {mruType, pszPrefix2},...}
	int     m_cCol;       // number of "columns" (data entries in m_prgDwStr)
	int     m_cEntryMax;  // maximum number of entries
	int	    m_cEntry;     // current number of entries
	PMRUE * m_rgpEntry;   // array of pointers to MRU data
	BOOL    m_fDirty;     // TRUE if data was changed
	BOOL    m_fReversed;  // Load/Save data reversed (old style)

	BOOL    FValidCol(int i)    {return ((i >= 0) && (i < m_cCol));}
	BOOL    FValidIndex(int i)  {return ((i >= 0) && (i < m_cEntry));}
	BOOL    FDirty()            {return m_fDirty;}
	BOOL    FReversed()         {return m_fReversed;}

	inline PMRUE GetEntry(int iItem)
	{
		ASSERT(FValidIndex(iItem));
		return m_rgpEntry[iItem];
	}

	inline int MruTypeForCol(int iCol)
	{
		ASSERT(FValidCol(iCol));
		return m_prgDwStr[1+iCol].dw;
	}

	inline LPCTSTR PszPrefixForCol(int iCol)
	{
		ASSERT(FValidCol(iCol));
		return m_prgDwStr[1+iCol].psz;
	}

	inline LPCTSTR PszRegKey(void)
	{
		return m_prgDwStr[0].psz;
	}

	VOID    ShiftEntriesDown(int cItem);

protected:
	virtual int CompareEntry(int iItem, PMRUE pEntry);

public:
	CMRUList2(const DWSTR * prgDwStr, int cEntryMax, BOOL fReverse = FALSE);
	~CMRUList2();

	int     GetNumEntries()     {return m_cEntry;}
	VOID    SetDirty(BOOL fDirty)     {m_fDirty = fDirty;}

	// Generic functions
	int     FindEntry(PMRUE pEntry);
	VOID    MoveEntryToTop(int iItem);
	PMRUE   LoadEntry(RegEntry * pre, int iItem);
	VOID    StoreEntry(RegEntry * pre, int iItem);
	VOID    DeleteEntry(PMRUE pEntry);
	VOID    DeleteEntry(int iItem);

	void
	DeleteEntry
	(
		const TCHAR * const	primaryString
	);
	 
	HRESULT Save(void);

	LPCTSTR GetString(int iItem, int iCol);
	DWORD GetDWORD(int iItem, int iCol);

	LPCTSTR GetString(PMRUE pEntry, int iCol);
	DWORD GetDWORD(PMRUE pEntry, int iCol);

	HRESULT AddEntry(PMRUE pEntry);
	HRESULT AddEntry(LPCTSTR pcsz);
	HRESULT AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2);
	HRESULT AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2, DWORD dw3);
};


#endif /* _MRULIST2_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\mrulist.cpp ===
// File: MruList.cpp

#include "precomp.h"

#include "MRUList.h"
#include "ConfUtil.h"

CMRUList::CMRUList() :
	m_nValidEntries		(0),
	m_pszRegKey			(NULL),
	m_fDirty			(FALSE)
{
	DebugEntry(CMRUList::CMRUList);

	// Clear out information
	for (int i = 0; i < MRU_MAX_ENTRIES; i++)
	{
		m_szNames[i][0] = _T('\0'); 
	}

	DebugExitVOID(CMRUList::CMRUList);
}

CMRUList::~CMRUList()
{
	DebugEntry(CMRUList::~CMRUList);

	if (m_fDirty)
	{
		Save();
	}
	delete m_pszRegKey;

	DebugExitVOID(CMRUList::~CMRUList);
}

BOOL CMRUList::ShiftEntries(int nSrc, int nDest, int cEntries)
{
	DebugEntry(CMRUList::ShiftEntries);

	BOOL bRet = TRUE;

	ASSERT(m_nValidEntries > 0);
	ASSERT(nSrc >= 0 && nSrc < MRU_MAX_ENTRIES);
	ASSERT(nDest >= 0 && nDest < MRU_MAX_ENTRIES);
	ASSERT(nSrc != nDest);
	
	if ((0 == cEntries) || (cEntries > (MRU_MAX_ENTRIES - nSrc)))
	{
		TRACE_OUT((	"CMRUList::ShiftEntries: Adjusting cEntries from %d to %d", 
					cEntries, 
					(MRU_MAX_ENTRIES - nSrc)));
		cEntries = (MRU_MAX_ENTRIES - nSrc);
	}
	
	if (nSrc > nDest)
	{
		// Copy forwards (first to last)
		
		for (int i = 0; i < cEntries; i++)
		{
			lstrcpy(m_szNames[nDest + i], m_szNames[nSrc + i]);
		}
	}
	else
	{
		// Copy backwards (last to first)
		
		for (int i = (cEntries - 1); i >= 0; i--)
		{
			lstrcpy(m_szNames[nDest + i], m_szNames[nSrc + i]);
		}
	}

	DebugExitBOOL(CMRUList::ShiftEntries, bRet);

	return bRet;
}

BOOL CMRUList::Load(LPCTSTR pcszRegKey)
{
	DebugEntry(CMRUList::Load);
	BOOL bRet = TRUE;

	ASSERT(pcszRegKey);
	delete m_pszRegKey;
	m_pszRegKey = PszAlloc(pcszRegKey);
		
	RegEntry reMRU(pcszRegKey, HKEY_CURRENT_USER);
	int nCount = 0;

	if (ERROR_SUCCESS == reMRU.GetError())
	{
		// Determine how many entries has been saved in the registry:
		nCount = reMRU.GetNumber(REGVAL_MRU_COUNT, 0);
	}

	ASSERT(nCount <= MRU_MAX_ENTRIES);

	for (int i = 0; i < nCount; i++)
	{
		TCHAR szRegName[MAX_PATH];
		LPSTR pStr;

		// Retrieve the name from the registry:
		wsprintf(szRegName, "%s%d", REGVAL_NAME_MRU_PREFIX, i);
		pStr = reMRU.GetString(szRegName);
		if( NULL == pStr )
			*m_szNames[i] = '\0';
		else
			lstrcpyn(m_szNames[i], pStr, MRU_MAX_STRING);
	}

	// Set the valid entries member variable:
	m_nValidEntries = nCount;
	
	// Clear the dirty flag since we have just loaded:
	m_fDirty = FALSE;

	DebugExitBOOL(CMRUList::Load, bRet);

	return bRet;
}

BOOL CMRUList::Save()
{
	DebugEntry(CMRUList::Save);

	BOOL bRet = FALSE;

	if (NULL != m_pszRegKey)
	{
		RegEntry reMRU(m_pszRegKey, HKEY_CURRENT_USER);

		if (ERROR_SUCCESS == reMRU.GetError())
		{
			// Save the number of entries to the registry:
			reMRU.SetValue(REGVAL_MRU_COUNT, m_nValidEntries);

			for (int i = 0; i < m_nValidEntries; i++)
			{
				TCHAR szRegName[MAX_PATH];

				// Set the name in the registry:
				wsprintf(szRegName, "%s%d", REGVAL_NAME_MRU_PREFIX, i);
				reMRU.SetValue(szRegName, m_szNames[i]);
			}

			reMRU.FlushKey();
			
			if (ERROR_SUCCESS == reMRU.GetError())
			{
				// Clear the dirty flag since we have just saved:
				m_fDirty = FALSE;
				bRet = TRUE;
			}
		}
	}
	else
	{
		ERROR_OUT(("Can't save MRU info - no reg key stored!"));
	}

	DebugExitBOOL(CMRUList::Save, bRet);

	return bRet;
}

BOOL CMRUList::MoveEntryToTop(int nIndex)
{
	DebugEntry(CMRUList::MoveEntryToTop);

	BOOL bRet = TRUE;
	
	ASSERT(nIndex >= 0 && nIndex < m_nValidEntries);

	if (nIndex < (m_nValidEntries - 1))
	{
		TCHAR	szTempName[MRU_MAX_STRING];
		lstrcpy(szTempName, m_szNames[nIndex]);

		// Move everything down by 1:
		ShiftEntries(nIndex + 1, nIndex, m_nValidEntries - nIndex);

		lstrcpy(m_szNames[m_nValidEntries - 1], szTempName);
	}

	// Set the dirty flag:
	m_fDirty = TRUE;

	DebugExitBOOL(CMRUList::MoveEntryToTop, bRet);

	return bRet;
}


/*  A D D  N E W  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: AddNewEntry

    Return TRUE if the entry is NEW.
-------------------------------------------------------------------------*/
BOOL CMRUList::AddNewEntry(LPCTSTR pcszName)
{
	DebugEntry(CMRUList::AddNewEntry);

	int nExistingEntry = FindEntry(pcszName);
	BOOL bRet = (-1 == nExistingEntry); // bRet = TRUE if this is NEW
	if (!bRet)
	{
		// This entry already exists, move it to the top:
		MoveEntryToTop(nExistingEntry);
	}
	else
	{
		// This entry doesn't exist already, so add it:
		if (MRU_MAX_ENTRIES == m_nValidEntries)
		{
			ShiftEntries(1, 0);

			m_nValidEntries--;
		}
		
		ASSERT(m_nValidEntries < MRU_MAX_ENTRIES);
		
		// Set the index to be one past the last current entry:
		int nCopyIndex = m_nValidEntries;

		lstrcpyn(m_szNames[nCopyIndex], pcszName, MRU_MAX_STRING - 1);

		// Increment the number of valid entries:
		m_nValidEntries++;
		
		// Set the dirty flag:
		m_fDirty = TRUE;
	}

	DebugExitBOOL(CMRUList::AddNewEntry, bRet);

	return bRet;
}


/*  F I N D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: FindEntry

    Performs a case-insensitive search for the string
-------------------------------------------------------------------------*/
int CMRUList::FindEntry(LPCTSTR pcszName)
{
	for (int i = 0; i < m_nValidEntries; i++)
	{
		if (0 == lstrcmpi(m_szNames[i], pcszName))
		{
			return i;
		}
	}

	return -1; // not found
}


//--------------------------------------------------------------------------//
//	CMRUList::DeleteEntry.													//
//--------------------------------------------------------------------------//
bool
CMRUList::DeleteEntry
(
	const TCHAR * const	entry
){
	int		entryIndex	= FindEntry( entry );
	bool	deleted		= (entryIndex != -1);

	if( deleted )
	{
		ShiftEntries( entryIndex + 1, entryIndex );

		m_nValidEntries--;

		m_fDirty = TRUE;
	}

	return( deleted );

}	//	End of CMRUList::DeleteEntry.


//--------------------------------------------------------------------------//
//	CMRUList::ReplaceEntry.													//
//--------------------------------------------------------------------------//
bool
CMRUList::ReplaceEntry
(
	const TCHAR * const	oldEntry,
	const TCHAR * const	newEntry
){
	int		entryIndex	= FindEntry( oldEntry );
	bool	replaced	= (entryIndex != -1);

	if( replaced )
	{
		lstrcpyn( m_szNames[ entryIndex ], newEntry, MRU_MAX_STRING - 1 );

		m_fDirty = TRUE;
	}

	return( replaced );

}	//	End of CMRUList::ReplaceEntry.


//--------------------------------------------------------------------------//
//	CMRUList::AppendEntry.													//
//--------------------------------------------------------------------------//
bool
CMRUList::AppendEntry
(
	const TCHAR * const	entry
){
	DebugEntry( CMRUList::AppendEntry );

	bool	result;
	
	if( (result = (FindEntry( entry ) == -1)) != false )
	{
		//	This entry doesn't already exist so we'll append it on...
		if( m_nValidEntries == MRU_MAX_ENTRIES )
		{
			//	The list is full so we'll replace the last one...
			lstrcpyn( m_szNames[ 0 ], entry, MRU_MAX_STRING - 1 );
		}
		else
		{
			if( m_nValidEntries > 0 )
			{
				ShiftEntries( 0, 1 );
			}

			lstrcpyn( m_szNames[ 0 ], entry, MRU_MAX_STRING - 1 );
			m_nValidEntries++;
		}

		//	Set the dirty flag...
		m_fDirty = TRUE;
	}

	DebugExitBOOL( CMRUList::AppendEntry, result );

	return( result );

}	//	End of CMRUList::AppendEntry.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\multistatetoolbar.cpp ===
#include "precomp.h"
#include "MultiStateToolbar.h"



CMultiStateToolbar::CMultiStateToolbar( void )
: 	m_cxButton( 0 ),
    m_cyButton( 0 ),
	m_cxBtnBitmaps( 0 ),
    m_cyBtnBitmaps( 0 ),
    m_himlTB(NULL),
    m_himlTBHot(NULL),
    m_himlTBDisabled(NULL)
{
    DBGENTRY(CMultiStateToolbar::CMultiStateToolbar);

    DBGEXIT(CMultiStateToolbar::CMultiStateToolbar);
}

CMultiStateToolbar::~CMultiStateToolbar( void )
{
    DBGENTRY(CMultiStateToolbar::~CMultiStateToolbar);

    _KillAllButtons();

    if(m_himlTB) 
    {
        ImageList_Destroy(m_himlTB);
        m_himlTB = NULL;
    }

    if(m_himlTBHot)
    {
        ImageList_Destroy(m_himlTBHot);
        m_himlTBHot = NULL;
    }

    if(m_himlTBDisabled)
    {
        ImageList_Destroy(m_himlTBDisabled);
        m_himlTBDisabled = NULL;
    }

    if( ::IsWindow( m_hWnd ) )
    {
        DestroyWindow();
    }

	m_hWnd = NULL;

    DBGEXIT(CMultiStateToolbar::~CMultiStateToolbar);
}   

HRESULT CMultiStateToolbar::Create( HWND hWndParent, 
                                    DWORD dwID,
                                    int cxButton,
                                    int cyButton,
	                                int cxBtnBitmaps,
                                    int cyBtnBitmaps
 )
{
    DBGENTRY(CMultiStateToolbar::Create);
    HRESULT hr = S_OK;

    m_cxButton = cxButton;
    m_cyButton = cyButton;
    m_cxBtnBitmaps = cxBtnBitmaps;
    m_cyBtnBitmaps = cyBtnBitmaps;

	DWORD dwStyle = WS_CHILD | WS_CLIPSIBLINGS | 
			        TBSTYLE_FLAT | TBSTYLE_TOOLTIPS | TBSTYLE_ALTDRAG |
			        CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NORESIZE;

    HWND hWndToolbar = CreateToolbarEx( hWndParent,
                                        dwStyle,
                                        dwID,
                                        0,              // nBitmaps
										NULL,			// instance
										NULL,			// NO bitmap ID!
										NULL,			// buttons
										0,				// number of buttons
										m_cxButton,     // button sizes
                                        m_cyButton,   
										m_cxBtnBitmaps, // bitmap sizes
                                        m_cyBtnBitmaps,   
										sizeof(TBBUTTON)
                                       );

    if( hWndToolbar )
    {
		DWORD dwStyle = ::SendMessage(hWndToolbar, TB_GETEXTENDEDSTYLE, 0, 0);
		dwStyle |= TBSTYLE_EX_DRAWDDARROWS;
		::SendMessage(hWndToolbar, TB_SETEXTENDEDSTYLE, 0, (LPARAM) dwStyle);

        SubclassWindow( hWndToolbar );
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    DBGEXIT_HR(CMultiStateToolbar::Create,hr);
    return hr;
}


HRESULT CMultiStateToolbar::Show( BOOL bShow )
{
    DBGENTRY(CMultiStateToolbar::Show);
    HRESULT hr = S_OK;

    ShowWindow( bShow ? SW_SHOW : SW_HIDE );
        
    DBGEXIT_HR(CMultiStateToolbar::Show,hr);
    return hr;    
}

HRESULT CMultiStateToolbar::InsertItem( int cStates, LPCTSTR szTitle, ItemStateInfo* pItemStates, int* pIndex )
{
    DBGENTRY(CMultiStateToolbar::InsertItem);
    HRESULT hr = S_OK;

    if( NULL == m_himlTB )
    {
        hr = _CreateImageLists();
    }


    TBItemData* pNewItemData = new TBItemData;
    pNewItemData->CurrentState = 0;
    pNewItemData->cStates = cStates;
    pNewItemData->pStateData = new TBItemStateData[ pNewItemData->cStates ];

    int cImageListItemsBeforeInsertion = ImageList_GetImageCount( m_himlTB );

        // For each state
    for( int iState = 0; iState < cStates; iState++ )
    {
            // Insert the bitmaps
	    if( pItemStates[iState].hItemBitmap )
        {
	        if (-1 != ImageList_AddMasked(m_himlTB, pItemStates[iState].hItemBitmap, TOOLBAR_MASK_COLOR))
	        {
		        SendMessage(TB_SETIMAGELIST, 0, (LPARAM) m_himlTB);
	        }
            else
            {
                hr = E_FAIL;
            }
        }

        if( SUCCEEDED( hr ) )
        {
	        if( pItemStates[iState].hItemHotBitmap )
            {
	            if (-1 != ImageList_AddMasked(m_himlTBHot, pItemStates[iState].hItemHotBitmap, TOOLBAR_MASK_COLOR))
	            {
		            SendMessage(TB_SETHOTIMAGELIST, 0, (LPARAM) m_himlTBHot);
	            }
                else
                {
                    hr = E_FAIL;
                }
            }
        }

        if( SUCCEEDED( hr ) )
        {
	        if( pItemStates[iState].hItemDisabledBitmap )
            {
	            if (-1 != ImageList_AddMasked(m_himlTBDisabled, pItemStates[iState].hItemDisabledBitmap, TOOLBAR_MASK_COLOR))
	            {
		            SendMessage(TB_SETDISABLEDIMAGELIST, 0, (LPARAM) m_himlTBDisabled);
	            }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
        
        // save the state data

        pNewItemData->pStateData[iState].BitmapId = cImageListItemsBeforeInsertion + iState;
        pNewItemData->pStateData[iState].CommandId = pItemStates[iState].dwID;
        pNewItemData->pStateData[iState].TbStyle = pItemStates[iState].TbStyle;
        pNewItemData->pStateData[iState].StringId = SendMessage( TB_ADDSTRING, 0, reinterpret_cast<LPARAM>( szTitle ) );

    }

    int nButtons = SendMessage(TB_BUTTONCOUNT, 0, 0 );

    // Insert the Item



    TBBUTTON tbi;
    ClearStruct(&tbi);
    tbi.iBitmap = pNewItemData->pStateData[0].BitmapId;
    tbi.idCommand = pNewItemData->pStateData[0].CommandId;
    tbi.fsState = TBSTATE_ENABLED;
    tbi.fsStyle = pNewItemData->pStateData[0].TbStyle;
    tbi.dwData = reinterpret_cast<DWORD>(pNewItemData);
    tbi.iString = pNewItemData->pStateData[0].StringId;
    
    SendMessage(TB_INSERTBUTTON, nButtons, reinterpret_cast<LPARAM>(&tbi));
    
    if( pIndex )
    {
        *pIndex = nButtons;
    }

    DBGEXIT_HR(CMultiStateToolbar::InsertItem,hr);
    return hr;
}




HRESULT CMultiStateToolbar::InsertBlock( int nItems, 
                                         CMultiStateToolbar::BlockData* pAryOfItemData,
                                         HINSTANCE hInstance, 
                                         int idTBBitmap,
                                         int idTBBitmapHot,
                                         int idTBBitmapDisabled,
                                         int* pIndexFirst
                                       )
{
    DBGENTRY(CMultiStateToolbar::InsertBlock);
    HRESULT hr = S_OK;
    
    if( pAryOfItemData )
    {
        if( NULL == m_himlTB )
        {
            hr = _CreateImageLists();
        }

        if( SUCCEEDED( hr ) )
        {
            HBITMAP hBmp = NULL;
            int cImageListItemsBeforeInsertion = ImageList_GetImageCount( m_himlTB );

                // Load the Normal Toolbar Bitmap
	        hBmp = (HBITMAP) LoadImage(hInstance, MAKEINTRESOURCE(idTBBitmap), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE);

	        if( hBmp )
            {
	            if (-1 != ImageList_AddMasked(m_himlTB, hBmp, TOOLBAR_MASK_COLOR))
	            {
		            SendMessage(TB_SETIMAGELIST, 0, (LPARAM) m_himlTB);
	            }
                else
                {
                    hr = E_FAIL;
                }

	            DeleteObject(hBmp);
            }

            if( SUCCEEDED( hr ) )
            {
                    // Load the Hot Toolbar Bitmap
	            hBmp = (HBITMAP) LoadImage(hInstance, MAKEINTRESOURCE(idTBBitmapHot), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE);

	            if( hBmp )
                {
	                if (-1 != ImageList_AddMasked(m_himlTBHot, hBmp, TOOLBAR_MASK_COLOR))
	                {
		                SendMessage(TB_SETHOTIMAGELIST, 0, (LPARAM) m_himlTBHot);
	                }
                    else
                    {
                        hr = E_FAIL;
                    }

	                DeleteObject(hBmp);
                }
            }

            if( SUCCEEDED( hr ) )
            {
                // Load the Disabled Toolbar Bitmap
	            hBmp = (HBITMAP) LoadImage(hInstance, MAKEINTRESOURCE(idTBBitmapDisabled), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE);

	            if( hBmp )
                {
	                if (-1 != ImageList_AddMasked(m_himlTBDisabled, hBmp, TOOLBAR_MASK_COLOR))
	                {
		                SendMessage(TB_SETDISABLEDIMAGELIST, 0, (LPARAM) m_himlTBDisabled);
	                }
                    else
                    {
                        hr = E_FAIL;
                    }

	                DeleteObject(hBmp);
                }
            }
            
            int nButtons = SendMessage(TB_BUTTONCOUNT, 0, 0 );

            if( pIndexFirst )
            {
                *pIndexFirst = nButtons; 
            }

                // For each button to be inserted...
            for( int iItem = 0; SUCCEEDED( hr ) && ( iItem < nItems ) ; iItem++ )
            {
                TBItemData* pNewItemData = new TBItemData;
                pNewItemData->CurrentState = 0;
                pNewItemData->cStates = pAryOfItemData[iItem].cbStates;
                pNewItemData->pStateData = new TBItemStateData[ pNewItemData->cStates ];
                
                int iStringID = SendMessage( TB_ADDSTRING, 0, reinterpret_cast<LPARAM>( pAryOfItemData[iItem].szTitle ) );
                for( int iState = 0; iState < pAryOfItemData[iItem].cbStates; iState++ )
                {
                    pNewItemData->pStateData[iState].BitmapId = pAryOfItemData[iItem].pStateData[iState].dwBitmapIndex;
                    pNewItemData->pStateData[iState].CommandId = pAryOfItemData[iItem].pStateData[iState].dwID;
                    pNewItemData->pStateData[iState].TbStyle = pAryOfItemData[iItem].pStateData[iState].TbStyle;
                    pNewItemData->pStateData[iState].StringId = iStringID;
                }

                TBBUTTON tbi;
                ClearStruct(&tbi);
                tbi.iBitmap = cImageListItemsBeforeInsertion + pNewItemData->pStateData[0].BitmapId;
                tbi.idCommand = pNewItemData->pStateData[0].CommandId;
                tbi.fsState = TBSTATE_ENABLED;
                tbi.fsStyle = pNewItemData->pStateData[0].TbStyle;
                tbi.dwData = reinterpret_cast<DWORD>(pNewItemData);
                tbi.iString = pNewItemData->pStateData[0].StringId;
                
                if( SendMessage(TB_INSERTBUTTON, nButtons, reinterpret_cast<LPARAM>(&tbi)) )
                {
                    ++nButtons;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }
    else
    {
        hr = E_POINTER;

    }
    
    DBGEXIT_HR(CMultiStateToolbar::InsertBlock,hr);
    return hr;
}

HRESULT CMultiStateToolbar::EnableItem( DWORD dwCmd, BOOL bEnable /* = TRUE */)
{
    DBGENTRY(CMultiStateToolbar::EnableItem);
    HRESULT hr = S_OK;

    if( ::IsWindow( _GetToolbarWindow() ) )
    {
        if( !SendMessage(TB_ENABLEBUTTON, dwCmd, bEnable ) )
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    DBGEXIT_HR(CMultiStateToolbar::EnableItem,hr);
    return hr;
}

HRESULT CMultiStateToolbar::SetItemState( int iIndex, int NewState )
{
    DBGENTRY(CMultiStateToolbar::SetItemState);
    HRESULT hr = S_OK;

    if( ::IsWindow( _GetToolbarWindow() ) )
    {
        TBBUTTON tbb;
        ClearStruct(&tbb);
        SendMessage( TB_GETBUTTON, iIndex, reinterpret_cast<LPARAM>(&tbb));

        TBItemData* pItemData = reinterpret_cast<TBItemData*>(tbb.dwData);
        if( pItemData )
        {
            if( NewState < pItemData->cStates )
            {
                if( pItemData->CurrentState != NewState )
                {
                    // We have to change the state
                    TBBUTTONINFO tbbi;
                    ClearStruct(&tbbi);
                    tbbi.cbSize = sizeof( TBBUTTONINFO );
                    tbbi.dwMask = TBIF_IMAGE | TBIF_COMMAND | TBIF_STYLE; 
                    tbbi.idCommand = pItemData->pStateData[NewState].CommandId;
                    tbbi.iImage = pItemData->pStateData[NewState].BitmapId;
                    tbbi.fsStyle = pItemData->pStateData[NewState].TbStyle;

                    // NOTE:  Changing the string stuff is not supported....
                    if( SendMessage( TB_SETBUTTONINFO, pItemData->pStateData[pItemData->CurrentState].CommandId, reinterpret_cast<LPARAM>(&tbbi) ) )
                    {
                        pItemData->CurrentState = NewState;
                    }

                    // force the image to be redrawn
				    RECT rc;
				    SendMessage(TB_GETITEMRECT, iIndex, reinterpret_cast<LPARAM>(&rc));
				    InvalidateRect(&rc);
                    InvalidateRect(NULL, TRUE);


                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }



    DBGEXIT_HR(CMultiStateToolbar::SetItemState,hr);
    return hr;
}

HRESULT CMultiStateToolbar::ShowLabels( BOOL bShowLabels)
{
    DBGENTRY(CMultiStateToolbar::ShowLabels);
    HRESULT hr = S_OK;

    if( !bShowLabels )
    {
        SendMessage(TB_SETBUTTONSIZE, 0, MAKELPARAM( m_cxBtnBitmaps, m_cyBtnBitmaps ) );
    }
    else
    {
        SendMessage(TB_SETBUTTONSIZE, 0, MAKELPARAM( m_cxButton, m_cyButton ) );
    }

    SendMessage(TB_SETMAXTEXTROWS, bShowLabels ? 1 : 0, 0);


    DBGEXIT_HR(CMultiStateToolbar::ShowLabels,hr);
    return hr;
}


HRESULT CMultiStateToolbar::Resize( RECT& rc )
{
    DBGENTRY(CMultiStateToolbar::Resize);
    HRESULT hr = S_OK;

	if( !SetWindowPos( NULL, &rc, SWP_NOACTIVATE | SWP_NOZORDER) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    DBGEXIT_HR(CMultiStateToolbar::Resize,hr);
    return hr;
}


HRESULT CMultiStateToolbar::GetWindow( HWND* phWnd )
{
    DBGENTRY(CMultiStateToolbar::GetWindow);
    HRESULT hr = S_OK;
    if( phWnd )
    {
        ASSERT( NULL == *phWnd );

        *phWnd = _GetToolbarWindow();
    }
    else
    {
        hr = E_POINTER;

    }

    DBGEXIT_HR(CMultiStateToolbar::GetWindow,hr);
    return hr;
}



LRESULT CMultiStateToolbar::OnDestroy(UINT uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult )
{
    DBGENTRY(CMultiStateToolbar::OnDestroy);
   
    _KillAllButtons();

    DBGEXIT(CMultiStateToolbar::OnDestroy);
    return 0;
}


LRESULT CMultiStateToolbar::OnNcDestroy(UINT uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult )
{

    // There is a bug in ATL that if you don't handle WM_NCDESTROY,
    // ATL will call CallWindowProc will a NULL hWnd... this causes assertions
    // on Debug Win95 and Bounds Checker reports an error as well..        

    DBGENTRY(CMultiStateToolbar::OnNcDestroy);
   
    DBGEXIT(CMultiStateToolbar::OnNcDestroy);
    return 0;
}


void CMultiStateToolbar::_KillAllButtons( void )
{
    DBGENTRY(CMultiStateToolbar::_KillAllButtons);

    if( ::IsWindow( _GetToolbarWindow() ) )
    {
        int nButtons = SendMessage(TB_BUTTONCOUNT, 0, 0 );
        for( int iButton = 0; iButton < nButtons; iButton++ )
        {
            TBBUTTON tbb;
            ClearStruct(&tbb);

            if( SendMessage( TB_GETBUTTON, 0, reinterpret_cast<LPARAM>(&tbb)) )
            {
                TBItemData* pItemData = reinterpret_cast<TBItemData*>(tbb.dwData);
                if( pItemData )
                {
                    delete [] pItemData->pStateData;
                }

                delete [] pItemData;
            }

            SendMessage( TB_DELETEBUTTON, 0, 0 );
        }
    }

    DBGEXIT(CMultiStateToolbar::_KillAllButtons);
}


HRESULT CMultiStateToolbar::_CreateImageLists( void )
{   
    DBGENTRY(CMultiStateToolbar::_CreateImageLists);
    HRESULT hr = S_OK;        
    
	m_himlTB = ImageList_Create( m_cxBtnBitmaps, 
                                 m_cyBtnBitmaps, 
                                 ILC_COLOR16 | ILC_MASK, 
                                 1,     // Initial size
                                 1      // Grow By
                                );

	m_himlTBHot = ImageList_Create( m_cxBtnBitmaps, 
                                    m_cyBtnBitmaps, 
                                    ILC_COLOR16 | ILC_MASK, 
                                    1,     // Initial size
                                    1      // Grow By
                                  );

	m_himlTBDisabled = ImageList_Create( m_cxBtnBitmaps, 
                                         m_cyBtnBitmaps, 
                                         ILC_COLOR4 | ILC_MASK, 
                                         1,     // Initial size
                                         1      // Grow By
                                        );

    if(! ( m_himlTB && m_himlTBHot && m_himlTBDisabled ) )
    {   // One of the create calls failed
        ASSERT( 0 );
        // I think that this is the only reason ImageList_Create would fail...
        hr = E_OUTOFMEMORY;
    }
    

    DBGEXIT_HR(CMultiStateToolbar::_CreateImageLists,hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\multistatetoolbar.h ===
#ifndef __MultiStateToolbar_h__
#define __MultiStateToolbar_h__

class CMultiStateToolbar 
: public CWindowImpl< CMultiStateToolbar  >
{

public:

    // Datatypes
    struct ItemStateInfo
    {
        DWORD   dwID;
        BYTE    TbStyle;
        HBITMAP hItemBitmap;
        HBITMAP hItemHotBitmap;
        HBITMAP hItemDisabledBitmap;
    };

    struct BlockItemStateData
    {
        DWORD   dwID;
        DWORD   dwBitmapIndex;
        BYTE    TbStyle;
    };

    struct BlockData
    {
        LPCTSTR             szTitle;
        int                 cbStates;
        BlockItemStateData* pStateData;
    };

    
    struct TBItemStateData
    {
        DWORD  BitmapId;
        DWORD  CommandId;
        DWORD  StringId;
        BYTE   TbStyle;
    };

    struct TBItemData
    {
        int              cStates;
        int              CurrentState;
        TBItemStateData *pStateData;
    };

public:
    // Construction and destruction
    CMultiStateToolbar( void );
    ~CMultiStateToolbar( void );

    // Methods
    HRESULT Create( HWND hWndParent, 
                    DWORD dwID,
                    int cxButton,
                    int cyButton,
	                int cxBtnBitmaps,
                    int cyBtnBitmaps
                  );

    HRESULT Show( BOOL bShow );
    HRESULT InsertItem( int cStates, LPCTSTR szTitle, ItemStateInfo* pItemStates, int* pIndex );

    HRESULT InsertBlock( int nItems, 
                         BlockData* pItemData,
                         HINSTANCE hInstance, 
                         int idTBBitmap,
                         int idTBBitmapHot,
                         int idTBBitmapDisabled,
                         int* pIndexFirst
                       );

    HRESULT EnableItem( DWORD dwCmd, BOOL bEnable = TRUE );
    HRESULT SetItemState( int iIndex, int NewState );
    HRESULT ShowLabels( BOOL bShowLabels );
    HRESULT Resize( RECT& rc );
    HRESULT GetWindow( HWND* phWnd );


BEGIN_MSG_MAP(CMultiStateToolbar)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_NCDESTROY,OnNcDestroy)
END_MSG_MAP()

        // Message handlers
    LRESULT OnDestroy(UINT uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
    LRESULT OnNcDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
        // This is here in case we change the toolbar to be a CContainedWindow
    HWND _GetToolbarWindow( void ) { return m_hWnd; }
    HRESULT _CreateImageLists( void );
    void _KillAllButtons( void );

    // Data
private:
	int m_cxButton;
    int m_cyButton;
	int m_cxBtnBitmaps;
    int m_cyBtnBitmaps;

    HIMAGELIST m_himlTB;
    HIMAGELIST m_himlTBHot;
    HIMAGELIST m_himlTBDisabled;
};

#endif // __MultiStateToolbar_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmapp.cpp ===
#include "precomp.h"
#include "NetMeeting.h"
#include "mslablti.h"
#include "nameres.h"
#include "conf.h"
#include "ConfRoom.h"
#include "call.h"
#include "conf.h"
#include "Callto.h"
#include "version.h"

// NetMeeting SDK includes
#include "SdkInternal.h"
#include "NmEnum.h"
#include "NmMember.h"
#include "NmManager.h"
#include "NmConference.h"
#include "NmCall.h"
#include "SDKWindow.h"
#include "NmApp.h"

//////////////////////////////////////////
// Static Data
//////////////////////////////////////////

/*static*/ CSimpleArray<CNetMeetingObj*>* CNetMeetingObj::ms_pNetMeetingObjList = NULL;

///////////////////////////////////////////////////////////////////////////
// Construction / Destruction
/////////////////////////////////////////////////////////////////////////////

static SIZE s_CreateModeSizeMap[] =
{
	{ 244, 410 }, // CMainUI::CreateFull
	{ 244, 158 }, // CMainUI::CreateDataOnly
	{ 196, 200 }, // CMainUI::CreatePreviewOnly
	{ 196, 200 }, // CMainUI::CreateRemoteOnly
	{ 180, 148 }, // CMainUI::CreatePreviewNoPause
	{ 180, 148 }, // CMainUI::CreateRemoteNoPause
	{ 240, 318 }, // CMainUI::CreateTelephone
};



CNetMeetingObj::CNetMeetingObj()
: m_pMainView(NULL),
  m_CreateMode(CMainUI::CreateFull)
{
	DBGENTRY(CNetMeetingObj::CNetMeetingObj);

	m_bAutoSize = true;
	m_bDrawFromNatural = true;
	m_bWindowOnly = true;

	SIZE sizehm;
	AtlPixelToHiMetric(&s_CreateModeSizeMap[m_CreateMode], &m_sizeNatural);
	m_sizeExtent = m_sizeNatural;

	CNetMeetingObj* p = const_cast<CNetMeetingObj*>(this);
	ms_pNetMeetingObjList->Add(p);

	DBGEXIT(CNetMeetingObj::CNetMeetingObj);
}

CNetMeetingObj::~CNetMeetingObj()
{
	DBGENTRY(CNetMeetingObj::~CNetMeetingObj);

	if(m_pMainView)
	{
		m_pMainView->Release();
		m_pMainView = NULL;
	}

	CNetMeetingObj* p = const_cast<CNetMeetingObj*>(this);
	ms_pNetMeetingObjList->Remove(p);

		// If we are the last guy on the block, we should delay unload
	if(0 == _Module.GetLockCount())
	{
		_Module.Lock();
		CSDKWindow::PostDelayModuleUnlock();
	}

	DBGEXIT(CNetMeetingObj::~CNetMeetingObj);
}


LRESULT CNetMeetingObj::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(SIZE_MINIMIZED != wParam)
	{
		if(m_pMainView)
		{
			int nWidth = LOWORD(lParam);  // width of client area
			int nHeight = HIWORD(lParam); // height of client area

			::SetWindowPos(m_pMainView->GetWindow(), NULL, 0, 0, nWidth, nHeight, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
		}
	}

	return 0;	
}

LRESULT CNetMeetingObj::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	BOOL bInConference;		
	if(!_Module.IsUIVisible())
	{
		if(SUCCEEDED(IsInConference(&bInConference)) && bInConference)
		{

			USES_RES2T
			TCHAR res1[RES_CH_MAX];
			RES2T(IDS_CONTAINER_GOING_AWAY_BUT_ACVITE_CONFERENCE);
			COPY_RES2T(res1);

			int iRet = ::MessageBox(m_hWnd,
									res1,
									RES2T(IDS_MSGBOX_TITLE),
									MB_SETFOREGROUND | MB_YESNO | MB_ICONQUESTION);
			if(IDNO == iRet)
			{
				UnDock();
			}
			else
			{
					// This means that the user wants to close the conference
				ASSERT(g_pConfRoom);
				if(g_pConfRoom)
				{
					g_pConfRoom->LeaveConference();
				}
			}
		}
	}
	else
	{		
		ASSERT(g_pConfRoom);

		if(g_pConfRoom)
		{
				// Bring the window to the front
			g_pConfRoom->BringToFront();
		}
	}

	return 0;
}

HRESULT CNetMeetingObj::FinalConstruct()
{
	HRESULT hr = S_OK;

	if(!g_pInternalNmManager)
	{	

		if(!CheckRemoteControlService())
		{
			return E_FAIL;
		}

		hr = InitConfExe(FALSE);
	}

	return hr;
}


//static
HRESULT CNetMeetingObj::InitSDK()
{
	DBGENTRY(CNetMeetingObj::InitSDK);
	HRESULT hr = S_OK;
	
	ASSERT(NULL == ms_pNetMeetingObjList);

	hr = (ms_pNetMeetingObjList = new CSimpleArray<CNetMeetingObj*>) ? S_OK : E_OUTOFMEMORY;
	
	DBGEXIT_HR(CNetMeetingObj::InitSDK,hr);
	return hr;
}

//static
void CNetMeetingObj::CleanupSDK()
{
	DBGENTRY(CNetMeetingObj::CleanupSDK);

	if(ms_pNetMeetingObjList)
	{
		delete ms_pNetMeetingObjList;
	}

	DBGEXIT(CNetMeetingObj::CleanupSDK);
}


/////////////////////////////////////////////////////////////////////////////
// CComControlBase
/////////////////////////////////////////////////////////////////////////////
HWND CNetMeetingObj::CreateControlWindow(HWND hWndParent, RECT& rcPos)
{
	DBGENTRY(CNetMeetingObj::CreateControlWindow);

	Create(hWndParent, rcPos);

	if(m_hWnd)
	{
		m_pMainView = new CMainUI;
		
		if(m_pMainView)
		{
			m_pMainView->Create(m_hWnd, g_pConfRoom, m_CreateMode, true);

			RECT rcClient = {0, 0, 0, 0};
			GetClientRect(&rcClient);

			::SetWindowPos(m_pMainView->GetWindow(), NULL, 0, 0, rcClient.right, rcClient.bottom, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

			ShowWindow(TRUE);
		}
		else
		{
			ERROR_OUT(("Out of memory, new CMainUI failed"));
		}
	}
	
	DBGEXIT(CNetMeetingObj::CreateControlWindow);
	return m_hWnd;
}


/////////////////////////////////////////////////////////////////////////////
// INetMeeting
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNetMeetingObj::Version(long *pdwVersion)
{
	DBGENTRY(CNetMeetingObj::Version);
	HRESULT hr = E_POINTER;

	if(pdwVersion)
	{
		*pdwVersion = VER_PRODUCTVERSION_DW;
		hr = S_OK;
	}
	
	DBGEXIT_HR(CNetMeetingObj::Version,hr);
	return hr;
}

STDMETHODIMP CNetMeetingObj::UnDock()
{
	DBGENTRY(CNetMeetingObj::UnDock);
	HRESULT hr = S_OK;

	::CreateConfRoomWindow();
	
	DBGEXIT_HR(CNetMeetingObj::UnDock,hr);
	return hr;
}	


STDMETHODIMP CNetMeetingObj::IsInConference(BOOL *pbInConference)
{
	DBGENTRY(CNetMeetingObj::IsInConference);
	HRESULT hr = S_OK;

	*pbInConference = FIsConferenceActive();

	DBGEXIT_HR(CNetMeetingObj::IsInConference,hr);
	return hr;
}


STDMETHODIMP CNetMeetingObj::CallTo(BSTR bstrCallToString)
{
	DBGENTRY( CNetMeetingObj::CallTo );

	HRESULT	hr;

	ASSERT( g_pCCallto != NULL );

    LPTSTR  szName;
    hr =  BSTR_to_LPTSTR (&szName, bstrCallToString);				        
    if (SUCCEEDED(hr))
    {    
        if(CCallto::DoUserValidation(szName))
        {
        	hr = g_pCCallto->Callto(	bstrCallToString ?
        								szName:
        								g_cszEmpty,					//	pointer to the callto url to try to place the call with...
        								NULL,						//	pointer to the display name to use...
        								NM_ADDR_CALLTO,				//	callto type to resolve this callto as...
        								false,						//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
        								NULL,						//	security preference, NULL for none. must be "compatible" with secure param if present...
        								false,						//	whether or not save in mru...
        								true,						//	whether or not to perform user interaction on errors...
        								NULL,						//	if bUIEnabled is true this is the window to parent error/status windows to...
        								NULL );						//	out pointer to INmCall * to receive INmCall * generated by placing call...
        }
        
        delete  (szName);
    }

	DBGEXIT_HR(CNetMeetingObj::CallTo,hr);
	return( S_OK );
}


STDMETHODIMP CNetMeetingObj::LeaveConference()
{
	DBGENTRY(CNetMeetingObj::HangUp);
	HRESULT hr = S_OK;

	CConfRoom::HangUp(FALSE);

	DBGEXIT_HR(CNetMeetingObj::HangUp,hr);
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////
// IPersistPropertyBag
//////////////////////////////////////////////////////////////////////////////////////

struct CreateModeMapEntry
{
	LPCTSTR					szName;
	CMainUI::CreateViewMode mode;
};


static CreateModeMapEntry s_CreateModeMap[] =
{
		// Note: These are compared with lstrcmpi
	{ _T("Full"), CMainUI::CreateFull },
	{ _T("DataOnly"), CMainUI::CreateDataOnly },
	{ _T("PreviewOnly"), CMainUI::CreatePreviewOnly },
	{ _T("RemoteOnly"), CMainUI::CreateRemoteOnly },
	{ _T("PreviewNoPause"), CMainUI::CreatePreviewNoPause },
	{ _T("RemoteNoPause"), CMainUI::CreateRemoteNoPause },
	{ _T("Telephone"), CMainUI::CreateTelephone },
};

void CNetMeetingObj::_SetMode(LPCTSTR pszMode)
{
	ULONG nEntries = ARRAY_ELEMENTS(s_CreateModeMap);
	for(ULONG i = 0; i < nEntries; ++i)
	{
		if(!lstrcmpi(s_CreateModeMap[i].szName, pszMode))
		{
			m_CreateMode = s_CreateModeMap[i].mode;

			SIZE sizehm;
			AtlPixelToHiMetric(&s_CreateModeSizeMap[m_CreateMode], &m_sizeNatural);
			m_sizeExtent = m_sizeNatural;

			break;
		}
	}


 	//Allow these modes to be sized
 	if (CMainUI::CreatePreviewNoPause == m_CreateMode
 		|| CMainUI::CreateRemoteNoPause == m_CreateMode
 	)
 	{
 		m_bAutoSize = false;
 	}


}


STDMETHODIMP CNetMeetingObj::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CComVariant var;
    var.vt = VT_BSTR;

    HRESULT hr = pPropBag->Read(L"MODE", &var, pErrorLog);
    if(SUCCEEDED(hr))
    {
        if(var.vt == VT_BSTR)
        {
            LPTSTR  szName;
            hr =  BSTR_to_LPTSTR (&szName, var.bstrVal);				        
            if (SUCCEEDED(hr))
            {    
                _SetMode(szName);
                delete (szName);
            }
        }
    }

	return IPersistPropertyBagImpl<CNetMeetingObj>::Load(pPropBag, pErrorLog);
}

STDMETHODIMP CNetMeetingObj::_ParseInitString(LPCTSTR* ppszInitString, LPTSTR szName, LPTSTR szValue)
{
	HRESULT hr = E_FAIL;

	if(**ppszInitString)
	{
		
			// First read the name
		const TCHAR* pCur = *ppszInitString;

			// Skip Whitespace
		while(*pCur == ' ')
		{
			pCur = CharNext(pCur);
		}

		bool bEqFound = false;

		while( *pCur != '=' && *pCur != ' ' && *pCur != '\0')
		{
			*szName = *pCur;
			szName = CharNext(szName);
			pCur = CharNext(pCur);
		}
	
		*szName	= '\0';
		if(*pCur == '=')
		{
			bEqFound = true;
		}

			// Skip over seperator
		pCur = CharNext(pCur);

			// Skip Whitespace
		while(*pCur == ' ')
		{
			pCur = CharNext(pCur);
		}

			// If we have not found the equal sign separator, we have to make sure to skip it...
		if(!bEqFound && ('=' == *pCur))
		{
				// Skip over the equal sign
			pCur = CharNext(pCur);

				// Skip Whitespace
			while(*pCur == ' ')
			{
				pCur = CharNext(pCur);
			}
		}

			// Read the value
		while( *pCur != ' ' && *pCur != '\0')
		{
			if(*pCur == ',')
			{
				if(*CharNext(pCur) == ',')
				{
					pCur = CharNext(pCur);		
				}
				else
				{
					break;
				}
			}

			*szValue = *pCur;
			szValue = CharNext(szValue);
			pCur = CharNext(pCur);
		}
	
		*szValue = '\0';

			// Skip over last seperator
		pCur = CharNext(pCur);

			// Skip Whitespace
		while(*pCur == ' ')
		{
			pCur = CharNext(pCur);
		}

		*ppszInitString = pCur;
		hr = S_OK;
	}

	return hr;
}


// IPersistStreamInit
STDMETHODIMP CNetMeetingObj::Load(LPSTREAM pStm)
{
	HRESULT hr = E_FAIL;
	
	if(pStm)
	{
            STATSTG stat;
            pStm->Stat(&stat, 0);
            BSTR  pb  = SysAllocStringLen(NULL, stat.cbSize.LowPart); 
            if(pb)
            {
                ULONG cbRead;

                hr = pStm->Read(pb, stat.cbSize.LowPart, &cbRead);

                if(SUCCEEDED(hr))
                {
                    TCHAR szName[MAX_PATH];
                    TCHAR szValue[MAX_PATH];

                    LPTSTR  lpszName;
                    hr =  BSTR_to_LPTSTR (&lpszName, pb);				        
                    if (SUCCEEDED(hr))
                    {    
                        LPCTSTR pszInitString = lpszName;

                        while(SUCCEEDED(_ParseInitString(&pszInitString, szName, szValue)))
                        {
                            if(!lstrcmpi(szName, _T("mode")))
                            {
                            	_SetMode(szValue);
                            }
                        }
                        
                        delete  (lpszName);
                    }

                }

                SysFreeString(pb);

            }
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
// INetMeeting_Events_Enabled
//////////////////////////////////////////////////////////////////////////////////////
// IProvideClassInfo2
//////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNetMeetingObj::GetClassInfo(ITypeInfo** pptinfo)
{
	DBGENTRY(CNetMeetingObj::GetClassInfo);

	CComPtr<IMarshalableTI> spmti;
	HRESULT hr = CoCreateInstance(CLSID_MarshalableTI, NULL, CLSCTX_INPROC, IID_IMarshalableTI, reinterpret_cast<void**>(&spmti));
	if( SUCCEEDED( hr ) )
	{
		if( SUCCEEDED( hr = spmti->Create(CLSID_NetMeeting, LIBID_NetMeetingLib, LANG_NEUTRAL, 1, 0) ) )
		{
			hr = spmti->QueryInterface(IID_ITypeInfo, reinterpret_cast<void**>(pptinfo));			
		}
	}

	DBGEXIT_HR(CNetMeetingObj::GetClassInfo,hr);

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////////////////////////////////


//static
void CNetMeetingObj::Broadcast_ConferenceStarted()
{
	DBGENTRY(CNetMeetingObj::Broadcast_ConferenceStarted);
	
	if(ms_pNetMeetingObjList)
	{
		for(int i = 0; i < ms_pNetMeetingObjList->GetSize(); ++i)
		{
			(*ms_pNetMeetingObjList)[i]->Fire_ConferenceStarted();
		}
	}

	DBGEXIT(CNetMeetingObj::Broadcast_ConferenceStarted);
}

//static
void CNetMeetingObj::Broadcast_ConferenceEnded()
{
	DBGENTRY(CNetMeetingObj::Broadcast_ConferenceEnded);

	if(ms_pNetMeetingObjList)
	{
		for(int i = 0; i < ms_pNetMeetingObjList->GetSize(); ++i)
		{
			(*ms_pNetMeetingObjList)[i]->Fire_ConferenceEnded();
		}
	}

	DBGEXIT(CNetMeetingObj::Broadcast_ConferenceEnded);
}
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\mrulist2.cpp ===
// File: mrulist.cpp

#include "precomp.h"

#include "mrulist2.h"

typedef struct {
	LPTSTR psz1;
	LPTSTR psz2;
} SZSZ;
typedef SZSZ * PSZSZ;

typedef struct {
	LPTSTR psz1;
	LPTSTR psz2;
	DWORD  dw;
} SZSZDW;
typedef SZSZDW * PSZSZDW;


/*  C  M  R  U  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: CMRUList2
    
-------------------------------------------------------------------------*/
CMRUList2::CMRUList2(const DWSTR * prgDwStr, int cEntryMax, BOOL fReversed) :
	m_prgDwStr   (prgDwStr),
	m_cEntryMax (cEntryMax),
	m_fReversed (fReversed),
	m_cEntry    (0),
	m_rgpEntry  (NULL),
	m_fDirty    (FALSE)
{
	DBGENTRY(CMRUList2::CMRUList2);

	ASSERT(NULL != prgDwStr);
	m_cCol = m_prgDwStr[0].dw;

	int cb = m_cEntryMax * sizeof(PMRUE);
	m_rgpEntry = new PMRUE[cb];
	if (NULL == m_rgpEntry)
	{
		ERROR_OUT(("CMRUList2 - out of memory"));
		return;
	}
	ZeroMemory(m_rgpEntry, cb);

	RegEntry re(PszRegKey(), HKEY_CURRENT_USER);
	if (ERROR_SUCCESS != re.GetError())
		return;

	m_cEntry = min(re.GetNumber(REGVAL_MRU_COUNT, 0), m_cEntryMax);
	for (int i = 0; i < m_cEntry; i++)
	{
		m_rgpEntry[i] = LoadEntry(&re, i);
	}
}

CMRUList2::~CMRUList2()
{
	DBGENTRY(CMRUList2::~CMRUList2);

	if (m_fDirty)
	{
		Save();
	}

	for (int i = 0; i < m_cEntry; i++)
	{
		DeleteEntry(m_rgpEntry[i]);
	}
	delete m_rgpEntry;
}


///////////////////////////////////////////////////////////////////////////

PMRUE CMRUList2::LoadEntry(RegEntry * pre, int iItem)
{
	if (m_fReversed)
	{
		iItem = (m_cEntry - (iItem+1));
	}

	PMRUE pEntry = (PMRUE) new PVOID[m_cCol*sizeof(PVOID)];
	if (NULL != pEntry)
	{
		PVOID ** ppv = (PVOID **) pEntry;
		for (int iCol = 0; iCol < m_cCol; iCol++, ppv++)
		{
			TCHAR szKey[MAX_PATH];
			wsprintf(szKey, TEXT("%s%d"), PszPrefixForCol(iCol), iItem);
			switch (MruTypeForCol(iCol))
				{
			default:
			case MRUTYPE_SZ:
				* (LPTSTR *)ppv = PszAlloc(pre->GetString(szKey));
				break;
			case MRUTYPE_DW:
				* (DWORD *) ppv = pre->GetNumber(szKey);
				break;
				}
		}
	}

	return pEntry;
}

VOID CMRUList2::StoreEntry(RegEntry * pre, int iItem)
{
	PVOID ** ppv = (PVOID **) GetEntry(iItem);

	if (m_fReversed)
	{
		iItem = (m_cEntry - (iItem+1));
	}

	for (int iCol = 0; iCol < m_cCol; iCol++, ppv++)
	{
		TCHAR szKey[MAX_PATH];
		wsprintf(szKey, TEXT("%s%d"), PszPrefixForCol(iCol), iItem);
		switch (MruTypeForCol(iCol))
			{
		default:
		case MRUTYPE_SZ:
			pre->SetValue(szKey, * (LPCTSTR *)ppv);
			break;
		case MRUTYPE_DW:
			pre->SetValue(szKey, * (ULONG *) ppv);
			break;
			}
	}
}

VOID CMRUList2::DeleteEntry(PMRUE pEntry)
{
	PVOID ** ppv = (PVOID **) pEntry;
	for (int iCol = 0; iCol < m_cCol; iCol++, ppv++)
	{
		switch (MruTypeForCol(iCol))
			{
		default:
		case MRUTYPE_SZ:
			delete *ppv;
			break;
		case MRUTYPE_DW:
			break;
			}
	}
	delete pEntry;
}

VOID CMRUList2::DeleteEntry(int iItem)
{
	if ((iItem < 0) || (iItem >= m_cEntry))
		return; // nothing to do

	// delete the data
	DeleteEntry(m_rgpEntry[iItem]);

	// decrement the count
	m_cEntry--;

	// shift items up
	for ( ; iItem < m_cEntry; iItem++)
	{
		m_rgpEntry[iItem] = m_rgpEntry[iItem+1];
	}

	// the list has been modified
	m_fDirty = TRUE;
}


//--------------------------------------------------------------------------//
//	CMRUList2::DeleteEntry.													//
//		This DeleteEntry() deletes the first entry it finds thats primary	//
//		string matches the one passed in.									//
//--------------------------------------------------------------------------//
void
CMRUList2::DeleteEntry
(
	const TCHAR * const	primaryString
){
	int	items	= GetNumEntries();

	for( int nn = 0; nn < items; nn++ )
	{
		if( StrCmpI( primaryString, * ((const TCHAR * const * const) m_rgpEntry[ nn ]) ) == 0 )
		{
			DeleteEntry( nn );
			break;
		}
	}

}	//	End of CMRUList2::DeleteEntry.


/*  C O M P A R E  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CompareEntry
    
-------------------------------------------------------------------------*/
int CMRUList2::CompareEntry(int iItem, PMRUE pEntry)
{
	ASSERT(NULL != pEntry);

	int iRet = 0;

	PVOID * ppv1 = (PVOID *) GetEntry(iItem);
	PVOID * ppv2 = (PVOID *) pEntry;
	for (int iCol = 0; iCol < m_cCol; iCol++, ppv1++, ppv2++)
	{
		switch (MruTypeForCol(iCol))
			{
		default:
		case MRUTYPE_SZ:
			iRet = lstrcmpi(* (LPCTSTR *) ppv1, * (LPCTSTR *) ppv2);
			break;
		case MRUTYPE_DW:
			iRet = (* (int *) ppv1) - (* (int *) ppv2);
			break;
			}

		if (0 != iRet)
			break;
	}

	return iRet;
}


/*  F I N D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: FindEntry

     Return -1 if the item is not found.
-------------------------------------------------------------------------*/
int CMRUList2::FindEntry(PMRUE pEntry)
{
	int cItems = GetNumEntries();
	for (int i = 0; i < cItems; i++)
	{
		if (0 == CompareEntry(i, pEntry))
		{
			return i;
		}
	}

	return -1; // not found
}



		
/*  S A V E  */
/*-------------------------------------------------------------------------
    %%Function: Save
    
-------------------------------------------------------------------------*/
HRESULT CMRUList2::Save(void)
{
	DBGENTRY(CMRUList2::Save);

	// Retrieve the data from the registry
	RegEntry re(PszRegKey(), HKEY_CURRENT_USER);
	if (ERROR_SUCCESS != re.GetError())
		return E_FAIL;

	re.SetValue(REGVAL_MRU_COUNT, m_cEntry);
	for (int i = 0; i < m_cEntry; i++)
	{
		StoreEntry(&re, i);
	}

	return S_OK;
}


/*  S H I F T  E N T R I E S  D O W N  */
/*-------------------------------------------------------------------------
    %%Function: ShiftEntriesDown

    Shift the entires down by one slot leaving the first position open.
-------------------------------------------------------------------------*/
VOID CMRUList2::ShiftEntriesDown(int cItem)
{
	if (cItem < 1)
		return; // nothing to do

	int iItem;
	for (iItem = cItem; iItem > 0; iItem--)
	{
		m_rgpEntry[iItem] = m_rgpEntry[iItem-1];
	}

	// the list has been modified
	m_fDirty = TRUE;
}


/*  M O V E  E N T R Y  T O  T O P  */
/*-------------------------------------------------------------------------
    %%Function: MoveEntryToTop
    
-------------------------------------------------------------------------*/
VOID CMRUList2::MoveEntryToTop(int iItem)
{
	DBGENTRY(CMRUList2::MoveEntryToTop);

	if ((iItem < 1) || (iItem >= m_cEntry))
		return; // nothing to do

	PMRUE pEntry = GetEntry(iItem);
	ShiftEntriesDown(iItem);
	m_rgpEntry[0] = pEntry;
}


/*  A D D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: AddEntry

	Put the entry into the top of the list.
	The data is owned by the list after this.
	
    Returns:
    	S_OK    - added to the head of the list
    	S_FALSE - already in list (item is moved to top)
-------------------------------------------------------------------------*/
HRESULT CMRUList2::AddEntry(PMRUE pEntry)
{
	DBGENTRY(CMRUList2::AddEntry);

	HRESULT ret = S_OK;

	// the list has been modified
	m_fDirty = TRUE;

	int cShift;
	int iItem = FindEntry(pEntry);
	if (-1 != iItem)
	{
		// This entry already exists, delete it so we get the new info
		DeleteEntry(m_rgpEntry[iItem]);
		cShift = iItem;
		ret = S_FALSE; // Success, but already in the list
	}
	else if (m_cEntryMax == m_cEntry)
	{
		// drop the last item
		DeleteEntry(m_rgpEntry[m_cEntry-1]);
		cShift = m_cEntry-1;
	}
	else
	{
		cShift = m_cEntry;
		m_cEntry++;
	}
	ShiftEntriesDown(cShift);

	// add it to the head of the list
	m_rgpEntry[0] = pEntry;

	return ret;
}


HRESULT CMRUList2::AddEntry(LPCTSTR pcsz)
{
	LPTSTR * ppsz = new LPTSTR;
	LPTSTR psz = PszAlloc(pcsz);
	if ((NULL == ppsz) || (NULL == psz))
	{
		delete ppsz;
		delete psz;
		return E_OUTOFMEMORY;
	}

	*ppsz = psz;

	return AddEntry((PMRUE) ppsz);
}

HRESULT CMRUList2::AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2)
{
	PSZSZ pSzSz = new SZSZ;
	if (NULL == pSzSz)
		return E_OUTOFMEMORY;

	pSzSz->psz1 = PszAlloc(pcsz1);
	pSzSz->psz2 = PszAlloc(pcsz2);
	if ((NULL == pSzSz->psz1) || (NULL == pSzSz->psz1))
	{
		// something failed - don't add anything
		DeleteEntry(pSzSz);
		return E_OUTOFMEMORY;
	}
	
	return AddEntry((PMRUE) pSzSz);
}

HRESULT CMRUList2::AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2, DWORD dw3)
{
	PSZSZDW pData = new SZSZDW;
	if (NULL == pData)
		return E_OUTOFMEMORY;

	pData->psz1 = PszAlloc(pcsz1);
	pData->psz2 = PszAlloc(pcsz2);
	if ((NULL == pData->psz1) || (NULL == pData->psz1))
	{
		// something failed - don't add anything
		DeleteEntry(pData);
		return E_OUTOFMEMORY;
	}
	pData->dw = dw3;
	
	return AddEntry((PMRUE) pData);
}


/*-------------------------------------------------------------------------
    %%Function: GetString

    Return the data associated with the entry
-------------------------------------------------------------------------*/
LPCTSTR CMRUList2::GetString(int iItem, int iCol)
{
	if (!FValidIndex(iItem))
	{
		return(NULL);
	}

	return(GetString(GetEntry(iItem), iCol));
}

DWORD CMRUList2::GetDWORD(int iItem, int iCol)
{
	if (!FValidIndex(iItem))
	{
		return(0);
	}

	return(GetDWORD(GetEntry(iItem), iCol));
}

LPCTSTR CMRUList2::GetString(PMRUE pEntry, int iCol)
{
	if (iCol >= m_cCol
		|| MRUTYPE_SZ != m_prgDwStr[iCol+1].dw
		)
	{
		return(NULL);
	}

	LPTSTR * ppsz = reinterpret_cast<LPTSTR *>(pEntry);
	return * (ppsz+iCol);
}

DWORD CMRUList2::GetDWORD(PMRUE pEntry, int iCol)
{
	if (iCol >= m_cCol
		|| MRUTYPE_DW != m_prgDwStr[iCol+1].dw
		)
	{
		return(0);
	}

	DWORD * ppdw = reinterpret_cast<DWORD *>(pEntry);
	return * (ppdw+iCol);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmapp.h ===
#ifndef __NmApp_h__
#define __NmApp_h__

#include "rToolbar.h"
#include "resource.h"       // main symbols
#include "NetMeeting.h"
#include <NetMeetingCP.h>

class CMainUI;

/////////////////////////////////////////////////////////////////////////////
// CNetMeetingObj
class ATL_NO_VTABLE CNetMeetingObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<INetMeeting, &IID_INetMeeting, &LIBID_NetMeetingLib>,
	public CComControl<CNetMeetingObj>,
	public IPersistStreamInitImpl<CNetMeetingObj>,
	public IPersistPropertyBagImpl<CNetMeetingObj>,
	public IOleControlImpl<CNetMeetingObj>,
	public IOleObjectImpl<CNetMeetingObj>,
	public IOleInPlaceActiveObjectImpl<CNetMeetingObj>,
	public IViewObjectExImpl<CNetMeetingObj>,
	public IOleInPlaceObjectWindowlessImpl<CNetMeetingObj>,
	public CComCoClass<CNetMeetingObj, &CLSID_NetMeeting>,
	public IObjectSafetyImpl<CNetMeetingObj, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
	public IConnectionPointContainerImpl<CNetMeetingObj>,
	public CProxy_INetMeetingEvents<CNetMeetingObj>,
	public IProvideClassInfo2Impl<&CLSID_NetMeeting, &DIID__INetMeetingEvents, &LIBID_NetMeetingLib, NetMeetingLib_Ver_Major, NetMeetingLib_Ver_Minor>
{

// Static Data
	static CSimpleArray<CNetMeetingObj*>* ms_pNetMeetingObjList;

	CMainUI*				m_pMainView;
	CMainUI::CreateViewMode m_CreateMode;

public:

		// So we are not released when we set up our notificatinos sink
DECLARE_PROTECT_FINAL_CONSTRUCT()

	// Because this is in a local server, we are not going to be able to be aggregated...
DECLARE_NOT_AGGREGATABLE(CNetMeetingObj)

	// This is the resource ID for the .rgs file
DECLARE_REGISTRY_RESOURCEID(IDR_NMAPP)

BEGIN_COM_MAP(CNetMeetingObj)
	COM_INTERFACE_ENTRY(INetMeeting)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CNetMeetingObj)
	CONNECTION_POINT_ENTRY(DIID__INetMeetingEvents)
END_CONNECTION_POINT_MAP()

BEGIN_PROP_MAP(CNetMeetingObj)
END_PROP_MAP()

BEGIN_MSG_MAP(CNetMeetingObj)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()

// Construction / Destruction
CNetMeetingObj();
~CNetMeetingObj();
HRESULT FinalConstruct();

static HRESULT InitSDK();
static void CleanupSDK();

static UINT GetObjectCount() { return ms_pNetMeetingObjList ? ms_pNetMeetingObjList->GetSize() : 0; };

LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

///////////////////////////////////////////////////////////////////////////
// IViewObjectEx stuff
///////////////////////////////////////////////////////////////////////////
DECLARE_VIEW_STATUS(0)


///////////////////////////////////////////////////////////////////////////
// CComControl Stuff
///////////////////////////////////////////////////////////////////////////
  virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos);

///////////////////////////////////////////////////////////////////////////
// INetMeeting methods
/////////////////////////////////////////////////////////////

	STDMETHOD(Version)(long* pdwBuildNumber);
	STDMETHOD(UnDock)();
	STDMETHOD(IsInConference)(BOOL *pbInConference);
	STDMETHOD(CallTo)(BSTR bstrCallToString);
	STDMETHOD(LeaveConference)();

// IPersistPropertyBag
	STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);	

// IPersistStreamInit
	STDMETHOD(Load)(LPSTREAM pStm);

/////////////////////////////////////////////////////////////
// IProvideClassInfo2
	STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo);

// Events
	static void Broadcast_ConferenceStarted();
	static void Broadcast_ConferenceEnded();


private:
	void CNetMeetingObj::_SetMode(LPCTSTR pszMode);
	STDMETHODIMP _ParseInitString(LPCTSTR *ppszInitString, LPTSTR szName, LPTSTR szValue);

};



#endif //__NmApp_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmcall.cpp ===
#include "precomp.h"

// NetMeeting SDK includes
#include "NmEnum.h"
#include "NmCall.h"
#include "NmApp.h"
#include "NmManager.h"
#include "NmConference.h"
#include "SDKWindow.h"


//////////////////////////////////////////
// Static Data
//////////////////////////////////////////


/*static*/ CSimpleArray<CNmCallObj*>* CNmCallObj::ms_pCallObjList = NULL;


//////////////////////////////////////////
// Construction and destruction
//////////////////////////////////////////

CNmCallObj::CNmCallObj()
:  m_pNmManagerObj(NULL),
   m_State(NM_CALL_INIT)
{
	DBGENTRY(CNmCallObj::CNmCallObj);

	if(ms_pCallObjList)
	{
		CNmCallObj* p = const_cast<CNmCallObj*>(this);			
		ms_pCallObjList->Add(p);
	}
	else
	{
		ERROR_OUT(("ms_pCallObjList is NULL"));
	}

	DBGEXIT(CNmCallObj::CNmCallObj);
}


HRESULT CNmCallObj::FinalConstruct()
{
	DBGENTRY(CNmCallObj::FinalConstruct);
	HRESULT hr = S_OK;
	
	RECT rc;		

	m_dwInteralINmCallAdvise = 0;

	DBGEXIT_HR(CNmCallObj::FinalConstruct,hr);
	return hr;
}

CNmCallObj::~CNmCallObj()
{
	DBGENTRY(CNmCallObj::~CNmCallObj);

	if(ms_pCallObjList)
	{
		CNmCallObj* p = const_cast<CNmCallObj*>(this);			
		ms_pCallObjList->Remove(p);
	}
	else
	{
		ERROR_OUT(("ms_pCallObjList is NULL"));
	}

	DBGEXIT(CNmCallObj::~CNmCallObj);
}


ULONG CNmCallObj::InternalRelease()
{
	ATLASSERT(m_dwRef > 0);

	--m_dwRef;

	if((1 == m_dwRef) && m_dwInteralINmCallAdvise)
	{
		CComQIPtr<INmCall> spCall = GetUnknown();		

		DWORD dwAdvise = m_dwInteralINmCallAdvise;
		m_dwInteralINmCallAdvise = 0;

		CComPtr<INmCall> spInternalCall = m_spInternalINmCall;
		m_spInternalINmCall = NULL;

		AtlUnadvise(spInternalCall, IID_INmCallNotify2,dwAdvise);
	}

	return m_dwRef;

}


//static 
HRESULT CNmCallObj::CreateInstance(CNmManagerObj* pNmManagerObj, INmCall* pInternalINmCall, INmCall** ppCall)
{
	DBGENTRY(CNmCallObj::CreateInstance);
	HRESULT hr = S_OK;

	CComObject<CNmCallObj>* p = NULL;
	p = new CComObject<CNmCallObj>(NULL);
	if(p)
	{
		p->m_spInternalINmCall = pInternalINmCall;

		// We don't have to addref because our lifetime is enclosed within the CNmManagerObj
		p->m_pNmManagerObj = pNmManagerObj;

		hr = _CreateInstanceGuts(p, ppCall);
		if(SUCCEEDED(hr))
		{
			hr = AtlAdvise(pInternalINmCall, *ppCall, IID_INmCallNotify2, &p->m_dwInteralINmCallAdvise);
			if(FAILED(hr))		
			{
				delete p;
			}
		}


	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	
	DBGEXIT_HR(CNmCallObj::CreateInstance,hr);
	return hr;
}

/*static*/
HRESULT CNmCallObj::_CreateInstanceGuts(CComObject<CNmCallObj> *p, INmCall** ppCall)
{
	DBGENTRY(CNmCallObj::_CreateInstanceGuts);
	HRESULT hr = S_OK;

	if(ppCall)
	{
		if(ms_pCallObjList)
		{
			if(p != NULL)
			{
				p->SetVoid(NULL);
				p->InternalFinalConstructAddRef();
				hr = p->FinalConstruct();
				p->InternalFinalConstructRelease();
				if(hr == S_OK)
					hr = p->QueryInterface(IID_INmCall, reinterpret_cast<void**>(ppCall));
				if(FAILED(hr))
				{
					*ppCall = NULL;
					delete p;
				}
			}
			else
			{
				hr = E_UNEXPECTED;
			}
		}
		else
		{
			ERROR_OUT(("You must first call InitSDK!"));
			hr = E_UNEXPECTED;
		}
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmCallObj::_CreateInstanceGuts,hr);
	return hr;
			
}



/*static*/ HRESULT CNmCallObj::InitSDK()
{
	DBGENTRY(CNmCallObj::InitSDK);
	HRESULT hr = S_OK;
	if(!ms_pCallObjList)
	{
		ms_pCallObjList = new CSimpleArray<CNmCallObj*>;
		if(!ms_pCallObjList)
		{
			hr = E_OUTOFMEMORY;
		}

	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmCallObj::InitSDK,hr);
	return hr;
}

/*static*/void CNmCallObj::CleanupSDK()
{
	DBGENTRY(CNmCallObj::CleanupSDK);
	
	delete ms_pCallObjList;	
	ms_pCallObjList = NULL;

	DBGEXIT(CNmCallObj::CleanupSDK);
}



//////////////////////////////////////////
// INmCall
//////////////////////////////////////////


STDMETHODIMP CNmCallObj::IsIncoming(void)
{
	DBGENTRY(CNmCallObj::IsIncoming);
	HRESULT hr = S_OK;

	if(m_spInternalINmCall)
	{
		hr = m_spInternalINmCall->IsIncoming();
	}
	else
	{
		hr = E_UNEXPECTED;
		ERROR_OUT(("Why don't I have an internal INmCall??"));
	}

	DBGEXIT_HR(CNmCallObj::IsIncoming,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::GetState(NM_CALL_STATE *pState)
{
	DBGENTRY(CNmCallObj::GetState);
	HRESULT hr = S_OK;
	
	if(pState)
	{
		*pState = m_State;
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmCallObj::GetState,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::GetName(BSTR *pbstrName)
{
	DBGENTRY(CNmCallObj::GetName);
	HRESULT hr = E_FAIL;

	if(m_spInternalINmCall)
	{
		hr = m_spInternalINmCall->GetName(pbstrName);
	}

	DBGEXIT_HR(CNmCallObj::GetName,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::GetAddr(BSTR *pbstrAddr, NM_ADDR_TYPE * puType)
{
	DBGENTRY(CNmCallObj::GetAddr);
	HRESULT hr = E_FAIL;

	if(m_spInternalINmCall)
	{
		hr = m_spInternalINmCall->GetAddr(pbstrAddr, puType);
	}

	DBGEXIT_HR(CNmCallObj::GetAddr,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	DBGENTRY(CNmCallObj::GetUserData);
	HRESULT hr = S_OK;

	if(m_spInternalINmCall)
	{
		hr = m_spInternalINmCall->GetUserData(rguid, ppb, pcb);
	}
	else
	{
		hr = E_UNEXPECTED;
		ERROR_OUT(("Why don't I have an internal INmCall??"));
	}

	DBGEXIT_HR(CNmCallObj::GetUserData,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::GetConference(INmConference **ppConference)
{
	DBGENTRY(CNmCallObj::GetConference);
	HRESULT hr = S_OK;
	
	if(ppConference)
	{
		*ppConference = m_spConference;

		if(*ppConference)
		{
			(*ppConference)->AddRef();
		}
		else
		{
			hr = S_FALSE;
		}
	}
	else
	{
		hr = E_POINTER;
	}
	
	DBGEXIT_HR(CNmCallObj::GetConference,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::Accept(void)
{
	DBGENTRY(CNmCallObj::Accept);
	HRESULT hr = S_OK;

	g_bSDKPostNotifications = true;

	if(m_spInternalINmCall)
	{
		m_spInternalINmCall->Accept();
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	g_bSDKPostNotifications = false;

	DBGEXIT_HR(CNmCallObj::Accept,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::Reject(void)
{
	DBGENTRY(CNmCallObj::Reject);
	HRESULT hr = S_OK;

	g_bSDKPostNotifications = true;

	if(m_spInternalINmCall)
	{
		m_spInternalINmCall->Reject();
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	g_bSDKPostNotifications = false;

	DBGEXIT_HR(CNmCallObj::Reject,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::Cancel(void)
{
	DBGENTRY(CNmCallObj::Cancel);
	HRESULT hr = S_OK;

	g_bSDKPostNotifications = true;

	if(m_spInternalINmCall)
	{
		m_spInternalINmCall->Cancel();
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	g_bSDKPostNotifications = false;

	DBGEXIT_HR(CNmCallObj::Cancel,hr);
	return hr;
}

////////////////////////////////////////////////
// INmCallNotify methods
////////////////////////////////////////////////
STDMETHODIMP CNmCallObj::NmUI(CONFN uNotify)
{
	DBGENTRY(CNmCallObj::NmUI);
	HRESULT hr = S_OK;

	hr = Fire_NmUI(uNotify);

	DBGEXIT_HR(CNmCallObj::NmUI,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::StateChanged(NM_CALL_STATE uState)
{
	DBGENTRY(CNmCallObj::StateChanged);
	HRESULT hr = S_OK;
	
	if(m_State != uState)
	{
		m_State = uState;

		Fire_StateChanged(uState);
		
	}

	DBGEXIT_HR(CNmCallObj::StateChanged,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::Failed(ULONG uError)
{
	DBGENTRY(CNmCallObj::Failed);
	HRESULT hr = S_OK;

	hr = Fire_Failed(uError);

	DBGEXIT_HR(CNmCallObj::Failed,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::Accepted(INmConference *pInternalConference)
{
	DBGENTRY(CNmCallObj::Accepted);
	HRESULT hr = E_NOTIMPL;


	if(m_pNmManagerObj)
	{
		INmConference* pSDKConference = m_pNmManagerObj->GetSDKConferenceFromInternalConference(pInternalConference);
		if(pSDKConference)
		{
			pSDKConference->AddRef();
			Fire_Accepted(pSDKConference);
			pSDKConference->Release();
		}
	}

	DBGEXIT_HR(CNmCallObj::Accepted,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////
// IInternalCallObj methods
///////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmCallObj::GetInternalINmCall(INmCall** ppCall)
{
	DBGENTRY(CNmCallObj::GetInternalINmCall);
	HRESULT hr = S_OK;

	ASSERT(ppCall);
	
	*ppCall = m_spInternalINmCall;
	(*ppCall)->AddRef();

	DBGEXIT_HR(CNmCallObj::GetInternalINmCall,hr);
	return hr;
}




////////////////////////////////////////////////
// Helper fns
////////////////////////////////////////////////

HRESULT CNmCallObj::_ReleaseResources()
{
	HRESULT hr = S_OK;

	return hr;
}


//////////////////////////////////////////////////////////////////////
// Notification Firing Fns
/////////////////////////////////////////////////////////////////////


// static 
HRESULT CNmCallObj::StateChanged(INmCall* pInternalNmCall, NM_CALL_STATE uState)
{
	DBGENTRY(CNmCallObj::StateChanged);
	HRESULT hr = S_OK;
	if(ms_pCallObjList)
	{
		hr = E_FAIL;
		for(int i = 0; i < ms_pCallObjList->GetSize(); ++i)
		{
			if(pInternalNmCall == (*ms_pCallObjList)[i]->m_spInternalINmCall)
			{
				(*ms_pCallObjList)[i]->StateChanged(uState);
				break;
			}
		}
	}
	else
	{
		ERROR_OUT(("ms_pCallObjList is null!"));
	}
	
	DBGEXIT_HR(CNmCallObj::StateChanged,hr);
	return hr;		
}


HRESULT CNmCallObj::Fire_NmUI(CONFN uNotify)
{
	DBGENTRY(CNmCallObj::Fire_NmUI);
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmCallNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmCallObj, &IID_INmCallNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmCallNotify* pNotify = reinterpret_cast<INmCallNotify*>(pCP->m_vec.GetAt(i));
			if(pNotify)
			{
				pNotify->NmUI(uNotify);
			}
		}
	}
	else
	{
		CSDKWindow::PostCallNmUi(this, uNotify);
	}

	DBGEXIT_HR(CNmCallObj::Fire_NmUI,hr);
	return hr;
}

HRESULT CNmCallObj::Fire_StateChanged(NM_CALL_STATE uState)
{
	DBGENTRY(CNmCallObj::Fire_StateChanged);
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmCallNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmCallObj, &IID_INmCallNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmCallNotify* pNotify = reinterpret_cast<INmCallNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->StateChanged(uState);
			}
		}
	}
	else
	{
		CSDKWindow::PostCallStateChanged(this, uState);
	}

	DBGEXIT_HR(CNmCallObj::Fire_StateChanged,hr);
	return hr;	
}


HRESULT CNmCallObj::Fire_Failed(ULONG uError)
{
	DBGENTRY(CNmCallObj::Fire_Failed);
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmCallNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmCallObj, &IID_INmCallNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmCallNotify* pNotify = reinterpret_cast<INmCallNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->Failed(uError);
			}
		}
	}
	else
	{
		CSDKWindow::PostFailed(this, uError);
	}

	DBGEXIT_HR(CNmCallObj::Fire_Failed,hr);
	return hr;
}

HRESULT CNmCallObj::Fire_Accepted(INmConference* pConference)
{
	DBGENTRY(CNmCallObj::Fire_Accepted);
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmCallNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmCallObj, &IID_INmCallNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmCallNotify* pNotify = reinterpret_cast<INmCallNotify*>(pCP->m_vec.GetAt(i));
	
			if(pNotify)
			{
				pNotify->Accepted(pConference);
			}
		}
	}
	else
	{
		CSDKWindow::PostAccepted(this, pConference);
	}

	DBGEXIT_HR(CNmCallObj::Fire_Accepted,hr);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Helper Fns
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmcall.h ===
#ifndef __NmCall_h__
#define __NmCall_h__

#include "NetMeeting.h"
#include "SDKInternal.h"

class CCall;
class CNmManagerObj;

/////////////////////////////////////////////////////////////////////////////
// CNmCallObj
class ATL_NO_VTABLE CNmCallObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmCallObj>,
	public IConnectionPointImpl<CNmCallObj, &IID_INmCallNotify, CComDynamicUnkArray>,
	public INmCall,
	public INmCallNotify2,
	public IInternalCallObj
{

friend HRESULT CreateEnumNmCall(IEnumNmCall** ppEnum);

protected:
		
// data
	static CSimpleArray<CNmCallObj*>* ms_pCallObjList;
	NM_CALL_STATE			m_State;
	CComPtr<INmConference>	m_spConference;
	CComPtr<INmCall>		m_spInternalINmCall;
	DWORD					m_dwInteralINmCallAdvise;
	CNmManagerObj*			m_pNmManagerObj;

public:

	static HRESULT InitSDK();
	static void CleanupSDK();

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmCallObj)

BEGIN_COM_MAP(CNmCallObj)
	COM_INTERFACE_ENTRY(INmCall)
	COM_INTERFACE_ENTRY(IInternalCallObj)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(INmCallNotify)
	COM_INTERFACE_ENTRY(INmCallNotify2)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CNmCallObj)
	CONNECTION_POINT_ENTRY(IID_INmCallNotify)
END_CONNECTION_POINT_MAP()


// Construction and destruction

	CNmCallObj();
	~CNmCallObj();

	HRESULT FinalConstruct();
	ULONG InternalRelease();

	//static HRESULT CreateInstance(INmCall* pInternalINmCall, INmCall** ppCall);
	static HRESULT CreateInstance(CNmManagerObj* pNmManagerObj, INmCall* pInternalINmCall, INmCall** ppCall);

	// INmCall methods
	STDMETHOD(IsIncoming)(void);
	STDMETHOD(GetState)(NM_CALL_STATE *pState);
	STDMETHOD(GetName)(BSTR *pbstrName);
	STDMETHOD(GetAddr)(BSTR *pbstrAddr, NM_ADDR_TYPE * puType);
	STDMETHOD(GetUserData)(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	STDMETHOD(GetConference)(INmConference **ppConference);
	STDMETHOD(Accept)(void);
	STDMETHOD(Reject)(void);
	STDMETHOD(Cancel)(void);

	// INmCallNotify2 methods
	STDMETHOD(NmUI)(CONFN uNotify);
	STDMETHOD(StateChanged)(NM_CALL_STATE uState);
	STDMETHOD(Failed)(ULONG uError);
	STDMETHOD(Accepted)(INmConference *pInternalConference);

		// We don't care about these...
    STDMETHOD(CallError)(UINT cns) { return S_OK; }
	STDMETHOD(RemoteConference)(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin) { return S_OK; }
	STDMETHOD(RemotePassword)(BSTR bstrConference, BSTR *pbstrPassword, BYTE *pb, DWORD cb, BOOL fIsService) { return S_OK; }

	// IInternalCallObj methods
	STDMETHOD(GetInternalINmCall)(INmCall** ppCall);

	static HRESULT StateChanged(INmCall* pInternalNmCall, NM_CALL_STATE uState);

		// INmCallNotify Notification Firing Fns
	HRESULT Fire_NmUI(CONFN uNotify);
	HRESULT Fire_StateChanged(NM_CALL_STATE uState);
	HRESULT Fire_Failed(ULONG uError);
	HRESULT Fire_Accepted(INmConference* pConference);

private:
// Helper Fns
	HRESULT _ReleaseResources();
	static HRESULT _CreateInstanceGuts(CComObject<CNmCallObj> *p, INmCall** ppCall);
};

//HRESULT CreateEnumNmCall(IEnumNmCall** ppEnum);

#endif // __NmCall_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmchannelaudio.h ===
#ifndef __NmChannelAudio_h__
#define __NmChannelAudio_h__

/////////////////////////////////////////////////////////////////////////////
// CNmChannelAudioObj
class ATL_NO_VTABLE CNmChannelAudioObj :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmChannelAudioObj>,
	public IConnectionPointImpl<CNmChannelAudioObj, &IID_INmChannelNotify, CComDynamicUnkArray>,
	public IConnectionPointImpl<CNmChannelAudioObj, &IID_INmChannelAudioNotify, CComDynamicUnkArray>,
	public INmChannelAudio,
	public INmChannelAudioNotify,
	public IInternalChannelObj
{

protected:
	bool m_bIsIncoming;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmChannelAudioObj)

BEGIN_COM_MAP(CNmChannelAudioObj)
	COM_INTERFACE_ENTRY(INmChannel)
	COM_INTERFACE_ENTRY(INmChannelAudio)
	COM_INTERFACE_ENTRY(INmChannelNotify)
	COM_INTERFACE_ENTRY(INmChannelAudioNotify)
	COM_INTERFACE_ENTRY(IInternalChannelObj)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CNmChannelAudioObj)
	CONNECTION_POINT_ENTRY(IID_INmChannelNotify)
	CONNECTION_POINT_ENTRY(IID_INmChannelAudioNotify)
END_CONNECTION_POINT_MAP()


		// Construction and destruection
	CNmChannelAudioObj();
	~CNmChannelAudioObj();
	static HRESULT CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel, bool bIsIncoming);

		// InmChannelAudio methods
	STDMETHOD(IsIncoming)(void);
	STDMETHOD(GetState)(NM_AUDIO_STATE *puState);
    STDMETHOD(GetProperty)(NM_AUDPROP uID,ULONG_PTR *puValue);
    STDMETHOD(SetProperty)(NM_AUDPROP uID,ULONG_PTR uValue);

	// INmChannelAudioNotify methods
    STDMETHOD(StateChanged)(NM_AUDIO_STATE uState);
	STDMETHOD(PropertyChanged)(DWORD dwReserved);

	// IInternalChannelObj methods
	STDMETHOD(GetInternalINmChannel)(INmChannel** ppChannel);
	STDMETHOD(ChannelRemoved)();

	// Helpers
	HRESULT Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	HRESULT Fire_StateChanged(NM_AUDIO_STATE uState);
	HRESULT Fire_PropertyChanged(DWORD dwReserved);
	void _OnActivate(bool bActive) {;}

	virtual CNmConferenceObj* GetConfObj() = 0;	
	virtual void RemoveMembers() = 0;
	virtual BOOL GetbActive() = 0;
	virtual bool IsChannelValid() = 0;

	STDMETHOD(Activate)(BOOL bActive);

	HRESULT _IsActive();
	HRESULT _SetActive(BOOL bActive);
};


#endif // __NmChannelAudio_h__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmchannelaudio.cpp ===
#include "precomp.h"

// NetMeeting gunk
#include "confroom.h"

// Netmeeting SDK stuff
#include "NmEnum.h"
#include "SDKInternal.h"
#include "NmConference.h"
#include "NmChannel.h"
#include "NmChannelAudio.h"


CNmChannelAudioObj::CNmChannelAudioObj()
{
	DBGENTRY(CNmChannelAudioObj::CNmChannelAudioObj);

	DBGEXIT(CNmChannelAudioObj::CNmChannelAudioObj);
}

CNmChannelAudioObj::~CNmChannelAudioObj()
{
	DBGENTRY(CNmChannelAudioObj::~CNmChannelAudioObj);

	DBGEXIT(CNmChannelAudioObj::~CNmChannelAudioObj);	
}

//
HRESULT CNmChannelAudioObj::CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel, bool bIsIncoming)
{
	DBGENTRY(CNmChannelAudioObj::CreateInstance);
	HRESULT hr = S_OK;

	typedef CNmChannel<CNmChannelAudioObj, &IID_INmChannelAudio, NMCH_AUDIO> channel_type;

	channel_type* p = NULL;
	p = new CComObject<channel_type>(NULL);

	if (p != NULL)
	{
		if(ppChannel)
		{
			p->SetVoid(NULL);

			hr = p->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));

			if(SUCCEEDED(hr))
			{
					// We don't have to RefCount this because our lifetime is
					// contained in the CConf's lifetime
				p->m_pConfObj = pConfObj;
				p->m_bIsIncoming = bIsIncoming;
			}

			if(FAILED(hr))
			{
				*ppChannel = NULL;
			}



		}
		else
		{
			hr = E_POINTER;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	if(FAILED(hr))
	{
		delete p;
	}


	DBGEXIT_HR(CNmChannelAudioObj::CreateInstance,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////
// INmChannelAudio2 methods
///////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelAudioObj::IsIncoming(void)
{
	DBGENTRY(CNmChannelAudioObj::IsIncoming);
	HRESULT hr = E_UNEXPECTED;

	hr = m_bIsIncoming ? S_OK : S_FALSE;

	DBGEXIT_HR(CNmChannelAudioObj::IsIncoming,hr);
	return hr;
}

STDMETHODIMP CNmChannelAudioObj::GetState(NM_AUDIO_STATE *puState)
{
	DBGENTRY(CNmChannelAudioObj::GetState);
	HRESULT hr = E_POINTER;

	if(puState)
	{
		hr = S_OK;

		*puState = NM_AUDIO_IDLE;

		if(S_OK == _IsActive())
		{
			if( ((S_OK == IsIncoming()) && IsSpeakerMuted()) || ((S_FALSE == IsIncoming()) && IsMicMuted()))
			{
				*puState = NM_AUDIO_LOCAL_PAUSED;
			}
			else
			{
				*puState = NM_AUDIO_TRANSFERRING;
			}	
		}
	}
	
	DBGEXIT_HR(CNmChannelAudioObj::GetState,hr);
	return hr;
}

STDMETHODIMP CNmChannelAudioObj::GetProperty(NM_AUDPROP uID,ULONG_PTR *puValue)
{
	DBGENTRY(CNmChannelAudioObj::GetProperty);
	HRESULT hr = E_POINTER;

	if(puValue)
	{
		hr = E_FAIL;

		if(IsChannelValid())
		{
			switch(uID)
			{
				case NM_AUDPROP_LEVEL:
				{
					HRESULT hIncoming = IsIncoming();

					if(S_OK == hIncoming)
					{ // This is the receive channel
						*puValue = GetSpeakerVolume();
						hr = S_OK;
					}
					else if(S_FALSE == hIncoming)
					{ // This is the send channel
						*puValue = GetRecorderVolume();	
						hr = S_OK;
					}

					break;
				}
					

				case NM_AUDPROP_PAUSE:
				{
					HRESULT hIncoming = IsIncoming();

					if(S_OK == hIncoming)
					{ // This is the receive channel
						*puValue = IsSpeakerMuted() ? 1 : 0;
						hr = S_OK;
					}
					else if(S_FALSE == hIncoming)
					{ // This is the send channel
						*puValue = IsMicMuted() ? 1 : 0;
						hr = S_OK;
					}

					break;
				}
					
				default:
					hr = E_INVALIDARG;
					break;
			}
		}
	}

	DBGEXIT_HR(CNmChannelAudioObj::GetProperty,hr);
	return hr;
}

STDMETHODIMP CNmChannelAudioObj::SetProperty(NM_AUDPROP uID,ULONG_PTR uValue)
{
	DBGENTRY(CNmChannelAudioObj::SetProperty);
	HRESULT hr = E_FAIL;

	if(IsChannelValid())
	{
		switch(uID)
		{
			case NM_AUDPROP_LEVEL:
			{
				hr = E_INVALIDARG;

				if(uValue < NM_MAX_AUDIO_LEVEL)
				{
					HRESULT hIncoming = IsIncoming();

					if(S_OK == hIncoming)
					{ // This is the receive channel
						SetSpeakerVolume((ULONG)uValue);
						hr = S_OK;
					}
					else if(S_FALSE == hIncoming)
					{ // This is the send channel
						SetRecorderVolume((ULONG)uValue);	
						hr = S_OK;
					}
				}

				break;
			}

			case NM_AUDPROP_PAUSE:
			{
				HRESULT hIncoming = IsIncoming();

				if(S_OK == hIncoming)
				{ // This is the receive channel
					MuteSpeaker(uValue ? TRUE : FALSE);
					hr = S_OK;
				}
				else if(S_FALSE == hIncoming)
				{ // This is the send channel
					MuteMicrophone(uValue ? TRUE : FALSE);
					hr = S_OK;
				}

				break;
			}
				
			default:
				hr = E_INVALIDARG;
				break;
		}
	}

	DBGEXIT_HR(CNmChannelAudioObj::SetProperty,hr);
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////
//INmChannelAudioNotify
///////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CNmChannelAudioObj::StateChanged(NM_AUDIO_STATE uState)
{
	DBGENTRY(CNmChannelAudioObj::StateChanged);
	HRESULT hr = S_OK;

	Activate(NM_AUDIO_IDLE != uState);

		// The internal GetState is a bit funky at times...
	GetState(&uState);

	hr = Fire_StateChanged(uState);

	DBGEXIT_HR(CNmChannelAudioObj::StateChanged,hr);
	return hr;
}

STDMETHODIMP CNmChannelAudioObj::PropertyChanged(DWORD dwReserved)
{
	DBGENTRY(CNmChannelAudioObj::PropertyChanged);
	HRESULT hr = S_OK;

	hr = Fire_PropertyChanged(dwReserved);

	DBGEXIT_HR(CNmChannelAudioObj::PropertyChanged,hr);
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// IInternalChannelObj methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelAudioObj::GetInternalINmChannel(INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelAudioObj::GetInternalINmChannel);
	HRESULT hr = E_POINTER;

	if(ppChannel)
	{
		*ppChannel = NULL;
		hr = S_OK;
	}

	DBGEXIT_HR(CNmChannelAudioObj::GetInternalINmChannel,hr);

	return hr;
}

HRESULT CNmChannelAudioObj::ChannelRemoved()
{
	HRESULT hr = S_OK;

	RemoveMembers();

	CNmConferenceObj* pConfObj = GetConfObj();
	if(pConfObj)
	{
		hr = pConfObj->Fire_ChannelChanged(NM_CHANNEL_REMOVED, com_cast<INmChannel>(GetUnknown()));
	}
	else
	{
		ERROR_OUT(("ChannelRemoved, but no ConfObject"));
		hr = E_UNEXPECTED;
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

HRESULT CNmChannelAudioObj::Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CNmChannelAudioObj::Fire_MemberChanged);
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelNotify
		/////////////////////////////////////////////////////
	IConnectionPointImpl<CNmChannelAudioObj, &IID_INmChannelNotify, CComDynamicUnkArray>* pCP = this;
	for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
	{
		INmChannelNotify* pNotify = reinterpret_cast<INmChannelNotify*>(pCP->m_vec.GetAt(i));

		if(pNotify)
		{
			pNotify->MemberChanged(uNotify, pMember);
		}
	}
		/////////////////////////////////////////////////////
		// INmChannelAudioNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelAudioObj, &IID_INmChannelAudioNotify, CComDynamicUnkArray>* pCP2 = this;
	for(i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelAudioNotify* pNotify2 = reinterpret_cast<INmChannelAudioNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->MemberChanged(uNotify, pMember);
		}
	}
	
	DBGEXIT_HR(CNmChannelAudioObj::Fire_MemberChanged,hr)
	return hr;
}


HRESULT CNmChannelAudioObj::Fire_StateChanged(NM_AUDIO_STATE uState)
{
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelAudioNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelAudioObj, &IID_INmChannelAudioNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelAudioNotify* pNotify2 = reinterpret_cast<INmChannelAudioNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->StateChanged(uState);
		}
	}
	
	DBGEXIT_HR(CNmChannelAudioObj::Fire_MemberChanged,hr)
	return hr;
}

HRESULT CNmChannelAudioObj::Fire_PropertyChanged(DWORD dwReserved)
{

	HRESULT hr = S_OK;
		/////////////////////////////////////////////////////
		// INmChannelAudioNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelAudioObj, &IID_INmChannelAudioNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelAudioNotify* pNotify2 = reinterpret_cast<INmChannelAudioNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->PropertyChanged(dwReserved);
		}
	}
	
	DBGEXIT_HR(CNmChannelAudioObj::Fire_MemberChanged,hr)
	return hr;
}


HRESULT CNmChannelAudioObj::_IsActive()
{
	return GetbActive() ? S_OK : S_FALSE;
}

	// We don't support switchable AV anymore
HRESULT CNmChannelAudioObj::_SetActive(BOOL bActive)
{
	if (GetbActive() == bActive)
		return S_OK;

	return E_FAIL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmchannelappshare.h ===
#ifndef __NmChannelAppShare_h__
#define __NmChannelAppShare_h__

/////////////////////////////////////////////////////////////////////////////
// CNmChannelAppShareObj
class ATL_NO_VTABLE CNmChannelAppShareObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmChannelAppShareObj>,
	public IConnectionPointImpl<CNmChannelAppShareObj, &IID_INmChannelNotify, CComDynamicUnkArray>,
	public IConnectionPointImpl<CNmChannelAppShareObj, &IID_INmChannelAppShareNotify, CComDynamicUnkArray>,
	public INmChannelAppShare,
	public INmChannelAppShareNotify,
	public IInternalChannelObj
{
protected:

	CSimpleArray<INmSharableApp*> m_ArySharableApps;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmChannelAppShareObj)

BEGIN_COM_MAP(CNmChannelAppShareObj)
	COM_INTERFACE_ENTRY(INmChannel)
	COM_INTERFACE_ENTRY(INmChannelAppShare)
	COM_INTERFACE_ENTRY(IInternalChannelObj)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(INmChannelNotify)
	COM_INTERFACE_ENTRY(INmChannelAppShareNotify)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CNmChannelAppShareObj)
	CONNECTION_POINT_ENTRY(IID_INmChannelNotify)
	CONNECTION_POINT_ENTRY(IID_INmChannelAppShareNotify)
END_CONNECTION_POINT_MAP()


		// Construction and destruection
	CNmChannelAppShareObj();
	~CNmChannelAppShareObj();

	static HRESULT CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel);

	// INmChannelAppShare methods
    STDMETHOD(GetState)(NM_SHARE_STATE *puState);
    STDMETHOD(SetState)(NM_SHARE_STATE uState);
    STDMETHOD(EnumSharableApp)(IEnumNmSharableApp **ppEnum);

	// IInternalChannelObj methods
	STDMETHOD(GetInternalINmChannel)(INmChannel** ppChannel);
	STDMETHOD(ChannelRemoved)();

	// interface INmChannelAppShareNotify methods
	STDMETHOD(StateChanged)(NM_SHAPP_STATE uState,INmSharableApp *pApp);

	// Helpers
	HRESULT Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	HRESULT Fire_StateChanged(NM_SHAPP_STATE uState, INmSharableApp *pApp);
	void _OnActivate(bool bActive) {;}


	virtual CNmConferenceObj* GetConfObj() = 0;	
	virtual void RemoveMembers() = 0;
	virtual BOOL GetbActive() = 0;

	STDMETHOD(Activate)(BOOL bActive);

	HRESULT _IsActive();
	HRESULT _SetActive(BOOL bActive);

	static HRESULT GetSharableAppName(HWND hWnd, LPTSTR sz, UINT cchMax);

};


#endif // __NmChannelAppShare_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmchannelappshare.cpp ===
#include "Precomp.h"
#include "Resource.h"
#include "confroom.h"
#include "ias.h"
#include "NmEnum.h"
#include "SDKInternal.h"
#include "NmConference.h"
#include "NmChannel.h"
#include "NmChannelAppShare.h"
#include "NmSharableApp.h"
#include "SDKWindow.h"


CNmChannelAppShareObj::CNmChannelAppShareObj()
{
	DBGENTRY(CNmChannelAppShareObj::CNmChannelAppShareObj);

	DBGEXIT(CNmChannelAppShareObj::CNmChannelAppShareObj);
}

CNmChannelAppShareObj::~CNmChannelAppShareObj()
{
	DBGENTRY(CNmChannelAppShareObj::~CNmChannelAppShareObj);

	for(int j = 0; j < m_ArySharableApps.GetSize(); ++j)
	{
		m_ArySharableApps[j]->Release();
	}
	m_ArySharableApps.RemoveAll();


	DBGEXIT(CNmChannelAppShareObj::~CNmChannelAppShareObj);	
}


//static
HRESULT CNmChannelAppShareObj::CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelAppShareObj::CreateInstance);
	HRESULT hr = S_OK;

	typedef CNmChannel<CNmChannelAppShareObj, &IID_INmChannelAppShare, NMCH_SHARE> channel_type;

	channel_type* p = NULL;
	p = new CComObject<channel_type>(NULL);

	if (p != NULL)
	{
		if(ppChannel)
		{
			p->SetVoid(NULL);

			hr = p->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));

			if(SUCCEEDED(hr))
			{

				
					// We don't have to RefCount this because our lifetime is
					// contained in the CConf's lifetime
				p->m_pConfObj = pConfObj;
			}
			if(FAILED(hr))
			{
				*ppChannel = NULL;
			}

		}
		else
		{
			hr = E_POINTER;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}


	if(FAILED(hr))
	{
		delete p;
	}


	DBGEXIT_HR(CNmChannelAppShareObj::CreateInstance,hr);
	return hr;
}



///////////////////////////////////////////////////////////////////////////////////
// INmChannelAppShare methods
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNmChannelAppShareObj::GetState(NM_SHARE_STATE *puState)
{
	DBGENTRY(CNmChannelAppShareObj::GetState);
	HRESULT hr = E_UNEXPECTED;

	INmMember* pMember = GetConfObj()->GetLocalSDKMember();

	if(pMember)
	{
		hr = pMember->GetShareState(puState);
	}
	
	DBGEXIT_HR(CNmChannelAppShareObj::GetState,hr);
	return hr;
}

STDMETHODIMP CNmChannelAppShareObj::SetState(NM_SHARE_STATE uState)
{
	DWORD uf;
	HRESULT hr = S_OK;

	if (!(S_OK == IsActive()))
		return E_FAIL;

	if(!GetConfObj() || !GetConfObj()->GetLocalSDKMember())
	{
		return E_UNEXPECTED;
	}

	if(NM_SHARE_UNKNOWN)
	{
		return E_FAIL;
	}
	else
	{
		if(NM_SHARE_WORKING_ALONE == uState)
		{
			return ::AllowControl(false);
		}

		if(NM_SHARE_COLLABORATING == uState)
		{
			return ::AllowControl(true);

		}

		if(NM_SHARE_IN_CONTROL == uState)
		{
			NM_SHARE_STATE uCurrentState; 
			if(SUCCEEDED(hr = GetState(&uCurrentState)))
			{	
				if(NM_SHARE_COLLABORATING == uCurrentState)
				{	
					// Yank control from the person that is controlling you
					return ::RevokeControl(0);
				}
			}
			else
			{
				return hr;
			}

			return ::AllowControl(true);
		}
	}

	return E_UNEXPECTED;
}


//static 
HRESULT CNmChannelAppShareObj::GetSharableAppName(HWND hWnd, LPTSTR sz, UINT cchMax)
{
	HRESULT hr = S_OK;
	ASSERT(sz);

	::GetWindowText(hWnd, sz, cchMax);
	return hr;
}


static INmSharableApp* _SharableAppAryHasThisHWND(CSimpleArray<INmSharableApp*>& ArySharableApps, HWND hWnd)
{
	for(int i = 0; i < ArySharableApps.GetSize(); ++i)
	{
		HWND h;
		if(SUCCEEDED(ArySharableApps[i]->GetHwnd(&h)))
		{
			if(hWnd == h) return ArySharableApps[i];

		}
	}

	return NULL;
}

STDMETHODIMP CNmChannelAppShareObj::EnumSharableApp(IEnumNmSharableApp **ppEnum)
{
	DBGENTRY(CNmChannelAppShareObj::EnumSharableApp);
	HRESULT hr = E_UNEXPECTED;

	IAS_HWND_ARRAY* pAry;
	hr = ::GetShareableApps(&pAry);
	if(SUCCEEDED(hr))
	{
		for(UINT i = 0; i < pAry->cEntries; ++i)
		{
			HWND hWnd = pAry->aEntries[i].hwnd;
			TCHAR szName[MAX_PATH];

			if(!_SharableAppAryHasThisHWND(m_ArySharableApps, hWnd))
			{
				hr = GetSharableAppName(hWnd, szName, CCHMAX(szName));

				if(FAILED(hr)) goto end;

				INmSharableApp* pApp;
				hr = CNmSharableAppObj::CreateInstance(hWnd, szName, &pApp);
				if(SUCCEEDED(hr))
				{
					m_ArySharableApps.Add(pApp);
				}
			}
		}

		hr = CreateEnumFromSimpleAryOfInterface<IEnumNmSharableApp, INmSharableApp>(m_ArySharableApps, ppEnum);

		FreeShareableApps(pAry);
	}
	
end:

	DBGEXIT_HR(CNmChannelAppShareObj::EnumSharableApp,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// IInternalChannelObj methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelAppShareObj::GetInternalINmChannel(INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelAppShareObj::GetInternalINmChannel);
	HRESULT hr = S_OK;

	if(ppChannel)
	{
		hr = GetUnknown()->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmChannelAppShareObj::GetInternalINmChannel,hr);

	return hr;
}

HRESULT CNmChannelAppShareObj::ChannelRemoved()
{
	HRESULT hr = S_OK;

	RemoveMembers();

	CNmConferenceObj* pConfObj = GetConfObj();
	if(pConfObj)
	{
		hr = pConfObj->Fire_ChannelChanged(NM_CHANNEL_REMOVED, com_cast<INmChannel>(GetUnknown()));
	}
	else
	{
		ERROR_OUT(("ChannelRemoved, but no ConfObject"));
		hr = E_UNEXPECTED;
	}

	return hr;
}


// interface INmChannelAppShareNotify methods
STDMETHODIMP CNmChannelAppShareObj::StateChanged(NM_SHAPP_STATE uState,INmSharableApp *pApp)
{
	if(pApp)
	{
		HWND hWnd;
		if(SUCCEEDED(pApp->GetHwnd(&hWnd)))
		{
		
			INmSharableApp* pExistingApp = _SharableAppAryHasThisHWND(m_ArySharableApps, hWnd);
			if(!pExistingApp)
			{
				pExistingApp = pApp;
				pExistingApp->AddRef();
				m_ArySharableApps.Add(pExistingApp);
			}
			
			Fire_StateChanged(uState, pExistingApp);
		}
	}
		
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

HRESULT CNmChannelAppShareObj::Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CNmChannelAppShareObj::Fire_MemberChanged);
	HRESULT hr = S_OK;


		/////////////////////////////////////////////////////
		// INmChannelNotify
		/////////////////////////////////////////////////////
	IConnectionPointImpl<CNmChannelAppShareObj, &IID_INmChannelNotify, CComDynamicUnkArray>* pCP = this;
	for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
	{
		INmChannelNotify* pNotify = reinterpret_cast<INmChannelNotify*>(pCP->m_vec.GetAt(i));

		if(pNotify)
		{
			pNotify->MemberChanged(uNotify, pMember);
		}
	}
		/////////////////////////////////////////////////////
		// INmChannelNotify2
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelAppShareObj, &IID_INmChannelAppShareNotify, CComDynamicUnkArray>* pCP2 = this;
	for(i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelAppShareNotify* pNotify2 = reinterpret_cast<INmChannelAppShareNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->MemberChanged(uNotify, pMember);
		}
	}
	
	DBGEXIT_HR(CNmChannelAppShareObj::Fire_MemberChanged,hr)
	return hr;
}

extern bool g_bSDKPostNotifications;

HRESULT CNmChannelAppShareObj::Fire_StateChanged(NM_SHAPP_STATE uNotify, INmSharableApp *pApp)
{
	DBGENTRY(CNmChannelAppShareObj::Fire_StateChanged);
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmChannelAppShareNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmChannelAppShareObj, &IID_INmChannelAppShareNotify, CComDynamicUnkArray>* pCP2 = this;
		for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
		{
			INmChannelAppShareNotify* pNotify2 = reinterpret_cast<INmChannelAppShareNotify*>(pCP2->m_vec.GetAt(i));

			if(pNotify2)
			{
				pNotify2->StateChanged(uNotify, pApp);
			}
		}
	}
	else
	{
		CSDKWindow::PostStateChanged(this, uNotify, pApp);
	}
	
	DBGEXIT_HR(CNmChannelAppShareObj::Fire_StateChanged,hr)
	return hr;
}

HRESULT CNmChannelAppShareObj::_IsActive()
{
	DBGENTRY(CNmChannelAppShareObj::_IsActive);
	
	return GetbActive() ? S_OK : S_FALSE;
}

HRESULT CNmChannelAppShareObj::_SetActive(BOOL bActive)
{
	if (GetbActive() == bActive)
		return S_FALSE;

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmchannel.h ===
#ifndef __NmChannel_h__
#define __NmChannel_h__

#include "imsconf3.h"

class CNmConferenceObj;

template<class T, const IID* piid, DWORD dwCh>
class ATL_NO_VTABLE CNmChannel : public T
{
friend class CNmChannelDataObj;
friend class CNmChannelAudioObj;
friend class CNmChannelVideoObj;
friend class CNmChannelFtObj;
friend class CNmChannelAppShareObj;

	public:	

	CNmChannel() : m_bActive(false), m_pConfObj(NULL) { ; }

	~CNmChannel()
	{
		DBGENTRY(CNmChannel::~CNmChannel);

		RemoveMembers();

		DBGEXIT(CNmChannel::~CNmChannel);
	}


	// INmChannel methods
	STDMETHOD(IsSameAs)(INmChannel *pChannel);
	STDMETHOD(IsActive)(void);
	STDMETHOD(SetActive)(BOOL fActive);
	STDMETHOD(GetConference)(INmConference **ppConference);
	STDMETHOD(GetInterface)(IID *_piid);
	STDMETHOD(GetNmch)(ULONG *puCh);
	STDMETHOD(EnumMember)(IEnumNmMember **ppEnum);
	STDMETHOD(GetMemberCount)(ULONG * puCount);

	// INmChannelNotify
    STDMETHOD(NmUI)(CONFN uNotify);
    STDMETHOD(MemberChanged)(NM_MEMBER_NOTIFY uNotify, INmMember *pInternalMember);
	STDMETHOD(NotifySinksOfAllMembers)()
	{
		for(int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
		{
			Fire_MemberChanged(NM_MEMBER_ADDED, m_SDKMemberObjs[i]);
		}

		return S_OK;
	}

	STDMETHOD(NotifySinksOfLocalMember)()
	{
		Fire_MemberChanged(NM_MEMBER_ADDED, GetConfObj()->GetLocalSDKMember());
		return S_OK;
	}

	virtual bool IsChannelValid()
	{
		if(m_pConfObj)
		{
			NM_CONFERENCE_STATE state;
			if(SUCCEEDED(m_pConfObj->GetState(&state)) && (NM_CONFERENCE_IDLE != state))
			{
				return true;
			}
		}
		
		return false;
	}

	virtual CNmConferenceObj* GetConfObj() { return m_pConfObj; }
	virtual BOOL GetbActive() { return m_bActive; }

	virtual void RemoveMembers()
	{

			// Free our conferencing objects
		while(m_SDKMemberObjs.GetSize())
		{
			Fire_MemberChanged(NM_MEMBER_REMOVED, m_SDKMemberObjs[0]);
			CComPtr<INmMember> sp = m_SDKMemberObjs[0];
			m_SDKMemberObjs.RemoveAt(0);
			sp.p->Release();
		}
	}

	STDMETHOD(Activate)(BOOL bActive) 
	{ 
		if(m_bActive != ((bActive) ? TRUE : FALSE))
		{
			m_bActive = ((bActive) ? TRUE : FALSE);
			_OnActivate(bActive ? true : false);
		}

		return S_OK;
	}


	STDMETHOD(SDKMemberAdded)(INmMember* pSDKMember)
	{
		HRESULT hr = S_FALSE;

		if(!_MemberInChannel(pSDKMember))
		{
				// Add the member
			pSDKMember->AddRef();
			m_SDKMemberObjs.Add(pSDKMember);

				// Notify the sinks
			Fire_MemberChanged(NM_MEMBER_ADDED, pSDKMember);
			hr = S_OK;
		}

		return hr;
	}

	STDMETHOD(SDKMemberRemoved)(INmMember* pSDKMember)
	{
		HRESULT hr = S_FALSE;

		for(int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
		{
			CComPtr<INmMember> spMember = m_SDKMemberObjs[i];

			if(spMember.IsEqualObject(pSDKMember))
			{
				m_SDKMemberObjs.RemoveAt(i);

				Fire_MemberChanged(NM_MEMBER_REMOVED, spMember);

				spMember.p->Release();

				hr = S_OK;

				break;
			}
		}

		return hr;
	}

	STDMETHOD(SDKMemberChanged)(INmMember* pSDKMember) 
	{
		return Fire_MemberChanged(NM_MEMBER_UPDATED, pSDKMember); 
	}

	void NotifySinkOfMembers(INmChannelNotify* pNotify)
	{
		for(int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
		{
			pNotify->MemberChanged(NM_MEMBER_ADDED, m_SDKMemberObjs[i]);
		}
	}

	STDMETHOD(FireNotificationsToSyncState)()
	{
		for(int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
		{
			Fire_MemberChanged(NM_MEMBER_ADDED, m_SDKMemberObjs[i]);
		}

		return S_OK;
	}

protected: // Helper Fns
	INmMember* _GetSDKMemberFromInternalMember(INmMember* pInternalMember);
	HRESULT _RemoveMember(INmMember* pInternalMember);
	virtual bool _MemberInChannel(INmMember* pSDKMember);

private:
	CSimpleArray<INmMember*>	m_SDKMemberObjs;
	CNmConferenceObj*			m_pConfObj;
	BOOL						m_bActive;
};



///////////////////////////////////////////////////////////////////
// INmChannel
///////////////////////////////////////////////////////////////////

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::IsSameAs(INmChannel *pChannel)
{
	DBGENTRY(CNmChannel::IsSameAs);
	HRESULT hr = E_NOTIMPL;
	CComPtr<IUnknown> pUnk(GetUnknown());

	hr = pUnk.IsEqualObject(pChannel) ? S_OK : S_FALSE;

	DBGEXIT_HR(CNmChannel::IsSameAs,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::IsActive(void)
{
	DBGENTRY(CNmChannel::IsActive);

	HRESULT hr = _IsActive();

	DBGEXIT_HR(CNmChannel::IsActive,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::SetActive(BOOL fActive)
{
	DBGENTRY(CNmChannel::SetActive);

	HRESULT hr = _SetActive(fActive);

	DBGEXIT_HR(CNmChannel::SetActive,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::GetConference(INmConference **ppConference)
{
	DBGENTRY(CNmChannel::GetConference);
	HRESULT hr = S_OK;

	if(m_pConfObj)
	{	
		IUnknown* pUnk = m_pConfObj->GetUnknown();
		if(pUnk)
		{
			hr = pUnk->QueryInterface(IID_INmConference,reinterpret_cast<void**>(ppConference));
		}
		else
		{
			hr = S_FALSE;
		}
	}

	DBGEXIT_HR(CNmChannel::GetConference,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::GetInterface(IID *_piid)
{
	DBGENTRY(CNmChannel::GetInterface);
	HRESULT hr = S_OK;

	if(piid)
	{
		*_piid = *piid;
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmChannel::GetInterface,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::GetNmch(ULONG *puCh)
{
	DBGENTRY(CNmChannel::GetNmch);
	HRESULT hr = S_OK;

	if(puCh)
	{
		*puCh = dwCh;			
	}
	else
	{
		hr = E_POINTER;			
	}		

	DBGEXIT_HR(CNmChannel::GetNmch,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::EnumMember(IEnumNmMember **ppEnum)
{
	DBGENTRY(CNmChannel::EnumMember);
	HRESULT hr = S_OK;

	hr = CreateEnumFromSimpleAryOfInterface<IEnumNmMember, INmMember>(m_SDKMemberObjs, ppEnum);

	DBGEXIT_HR(CNmChannel::EnumMember,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::GetMemberCount(ULONG * puCount)
{
	DBGENTRY(CNmChannel::GetMemberCount);
	HRESULT hr = S_OK;

	if(puCount)
	{
		*puCount = m_SDKMemberObjs.GetSize();
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmChannel::GetMemberCount,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////
// INmChannelNotify
///////////////////////////////////////////////////////////////////

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::NmUI(CONFN uNotify)
{
	DBGENTRY(CNmChannel::NmUI);
	HRESULT hr = S_OK;

	DBGEXIT_HR(CNmChannel::NmUI,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pInternalMember)
{
	DBGENTRY(CNmChannel::MemberChanged);
	HRESULT hr = S_OK;

	if(pInternalMember && m_pConfObj)
	{
		INmMember* pMember = NULL;

		if(NM_MEMBER_ADDED == uNotify)
		{
				// Only add it if we haven't added it yet
			if(!(pMember = _GetSDKMemberFromInternalMember(pInternalMember)))
			{
				pMember = m_pConfObj->GetSDKMemberFromInternalMember(pInternalMember);
				ASSERT(pMember);

				pMember->AddRef();
				m_SDKMemberObjs.Add(pMember);
			}
			else
			{
					// We already have this member
				goto end;
			}
		}

		if(!pMember)
		{
			pMember = _GetSDKMemberFromInternalMember(pInternalMember);
		}

			// It is possable that the member has already been removed..
		if(pMember)
		{
			if(NM_MEMBER_REMOVED == uNotify)
			{
				_RemoveMember(pInternalMember);
			}
			else
			{
				Fire_MemberChanged(uNotify, pMember);
			}
		}
	}
	else
	{
		ERROR_OUT(("The member is not in the conference yet!!!"));
		hr = E_UNEXPECTED;
	}

end:

	DBGEXIT_HR(CNmChannel::MemberChanged,hr);
	return hr;
}


template<class T, const IID* piid, DWORD dwCh>
INmMember* CNmChannel<T, piid, dwCh>::_GetSDKMemberFromInternalMember(INmMember* pInternalMember)
{
	INmMember* pRet = NULL;

	for( int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
	{
		CComQIPtr<IInternalMemberObj> spInternal = m_SDKMemberObjs[i];
		ASSERT(spInternal);

		CComPtr<INmMember> spMember;
		if(SUCCEEDED(spInternal->GetInternalINmMember(&spMember)))
		{
			if(spMember.IsEqualObject(pInternalMember))
			{
				pRet = m_SDKMemberObjs[i];
				break;
			}
		}
	}

	return pRet;
}


template<class T, const IID* piid, DWORD dwCh>
HRESULT CNmChannel<T, piid, dwCh>::_RemoveMember(INmMember* pInternalMember)
{
	HRESULT hr = E_FAIL;

	for( int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
	{
		CComQIPtr<IInternalMemberObj> spSDKObj = m_SDKMemberObjs[i];
		CComPtr<INmMember> spSDKMember = m_SDKMemberObjs[i];
		ASSERT(spSDKObj);

		CComPtr<INmMember> spMember;
		if(SUCCEEDED(spSDKObj->GetInternalINmMember(&spMember)))
		{
				// Worst case we return S_FALSE to indicate that there is no such member
			hr = S_FALSE;

			if(spMember.IsEqualObject(pInternalMember))
			{
				m_SDKMemberObjs.RemoveAt(i);

				Fire_MemberChanged(NM_MEMBER_REMOVED, spSDKMember);

				spSDKMember.p->Release();
				hr = S_OK;
				break;
			}
		}
	}

	return hr;	
}

template<class T, const IID* piid, DWORD dwCh>
bool CNmChannel<T, piid, dwCh>::_MemberInChannel(INmMember* pSDKMember)
{
	for( int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
	{
		
		CComPtr<INmMember> spMember = m_SDKMemberObjs[i];
		if(spMember.IsEqualObject(pSDKMember))
		{
			return true;
		}
	}

	return false;
}



#endif // __NmChannel_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmchanneldata.cpp ===
#include "precomp.h"

// NetMeeting SDK stuff
#include "NmEnum.h"
#include "SDKInternal.h"
#include "NmConference.h"
#include "NmChannel.h"
#include "NmChannelData.h"


CNmChannelDataObj::CNmChannelDataObj()
{
	DBGENTRY(CNmChannelDataObj::CNmChannelDataObj);

	DBGEXIT(CNmChannelDataObj::CNmChannelDataObj);
}

CNmChannelDataObj::~CNmChannelDataObj()
{
	DBGENTRY(CNmChannelDataObj::~CNmChannelDataObj);

	m_spInternalINmChannelData = NULL;

	DBGEXIT(CNmChannelDataObj::~CNmChannelDataObj);	
}


HRESULT CNmChannelDataObj::FinalConstruct()
{
	DBGENTRY(CNmChannelDataObj::FinalConstruct);
	HRESULT hr = S_OK;

	if(m_spInternalINmChannelData)
	{
		if(SUCCEEDED(hr))
		{
			hr = AtlAdvise(m_spInternalINmChannelData, GetUnknown(), IID_INmChannelDataNotify2, &m_dwInternalAdviseCookie);
		}
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmChannelDataObj::FinalConstruct,hr);
	return hr;
}



ULONG CNmChannelDataObj::InternalRelease()
{
	ATLASSERT(m_dwRef > 0);

	--m_dwRef;

	if((1 == m_dwRef) && m_dwInternalAdviseCookie)
	{
		++m_dwRef;
		DWORD dwAdvise = m_dwInternalAdviseCookie;
		m_dwInternalAdviseCookie = 0;
		AtlUnadvise(m_spInternalINmChannelData, IID_INmChannelDataNotify2, dwAdvise);
		--m_dwRef;
	}

	return m_dwRef;

}
//
HRESULT CNmChannelDataObj::CreateInstance(CNmConferenceObj* pConfObj, INmChannel* pInternalINmChannel, INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelDataObj::CreateInstance);


	HRESULT hr = S_OK;

	typedef CNmChannel<CNmChannelDataObj, &IID_INmChannelData, NMCH_DATA> channel_type;

	channel_type* p = NULL;
	p = new CComObject<channel_type>(NULL);

	if (p != NULL)
	{
		if(ppChannel)
		{
			p->SetVoid(NULL);

			hr = p->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));

			if(SUCCEEDED(hr))
			{
				p->m_spInternalINmChannelData = com_cast<INmChannelData>(pInternalINmChannel);
				if(p->m_spInternalINmChannelData)
				{

						// We don't have to RefCount this because our lifetime is
						// contained in the CConf's lifetime
					p->m_pConfObj = pConfObj;

						// We do this so that we don't accidentally Release out of memory
					++p->m_dwRef;
					hr = p->FinalConstruct();
					--p->m_dwRef;
				}
				else
				{
					hr = E_FAIL;
				}
			}

			if(FAILED(hr))
			{
				*ppChannel = NULL;
			}			
		}
		else
		{
			hr = E_POINTER;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	if(FAILED(hr))
	{
		delete p;
	}


	DBGEXIT_HR(CNmChannelDataObj::CreateInstance,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////
// INmChannelData methods
///////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelDataObj::GetGuid(GUID *pguid)
{
	DBGENTRY(CNmChannelDataObj::GetGuid);
	HRESULT hr = E_UNEXPECTED;

	if(m_spInternalINmChannelData)
	{
		hr = m_spInternalINmChannelData->GetGuid(pguid);
	}

	DBGEXIT_HR(CNmChannelDataObj::GetGuid,hr);
	return hr;
}

STDMETHODIMP CNmChannelDataObj::SendData(INmMember *pMember, ULONG uSize, byte *pvBuffer, ULONG uOptions)
{
	DBGENTRY(CNmChannelDataObj::SendData);
	HRESULT hr = S_OK;

	if(m_spInternalINmChannelData)
	{
		CComPtr<INmMember> spInternalMember;

		if(pMember)
		{
			CComPtr<IInternalMemberObj> spMemberObj = com_cast<IInternalMemberObj>(pMember);
			if(spMemberObj)
			{
				hr = spMemberObj->GetInternalINmMember(&spInternalMember);
			}
		}

		if(SUCCEEDED(hr))
		{
			hr = m_spInternalINmChannelData->SendData(spInternalMember, uSize, pvBuffer, uOptions);
		}
	}
	else
	{
		hr = E_UNEXPECTED;
	}
		
	DBGEXIT_HR(CNmChannelDataObj::SendData,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////
// INmChannelData2 methods
///////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelDataObj::RegistryAllocateHandle(ULONG numberOfHandlesRequested)
{
	DBGENTRY(CNmChannelDataObj::RegistryAllocateHandle);
	HRESULT hr = E_UNEXPECTED;

	if(m_spInternalINmChannelData)
	{
		CComPtr<INmChannelData2> spChannel = com_cast<INmChannelData2>(m_spInternalINmChannelData);
		if(spChannel)
		{
			hr = spChannel->RegistryAllocateHandle(numberOfHandlesRequested);
		}
	}


	DBGEXIT_HR(CNmChannelDataObj::RegistryAllocateHandle,hr);
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////
//INmChannelDataNotify2
///////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelDataObj::DataSent(INmMember *pMember, ULONG uSize,byte *pvBuffer)
{
	DBGENTRY(CNmChannelDataObj::DataSent);
	HRESULT hr = S_OK;

	ASSERT(GetConfObj());
	INmMember* pSDKMember = GetConfObj()->GetSDKMemberFromInternalMember(pMember);

	hr = Fire_DataSent(pSDKMember, uSize, pvBuffer);

	DBGEXIT_HR(CNmChannelDataObj::DataSent,hr);
	return hr;
}

STDMETHODIMP CNmChannelDataObj::DataReceived(INmMember *pInternalMember, ULONG uSize,byte *pvBuffer, ULONG dwFlags)
{
	DBGENTRY(CNmChannelDataObj::DataReceived);
	HRESULT hr = S_OK;

	ASSERT(GetConfObj());
	CComPtr<INmMember> spSDKMember = GetConfObj()->GetSDKMemberFromInternalMember(pInternalMember);

	hr = Fire_DataReceived(spSDKMember, uSize, pvBuffer, dwFlags);

	DBGEXIT_HR(CNmChannelDataObj::DataReceived,hr);
	return hr;
}

STDMETHODIMP CNmChannelDataObj::AllocateHandleConfirm(ULONG handle_value, ULONG chandles)
{
	DBGENTRY(CNmChannelDataObj::AllocateHandleConfirm);
	HRESULT hr = S_OK;

	DBGEXIT_HR(CNmChannelDataObj::AllocateHandleConfirm,hr);
	return hr;
}



///////////////////////////////////////////////////////////////////////////////
// IInternalChannelObj methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelDataObj::GetInternalINmChannel(INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelDataObj::GetInternalINmChannel);
	HRESULT hr = S_OK;

	if(ppChannel)
	{
		hr = m_spInternalINmChannelData->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmChannelDataObj::GetInternalINmChannel,hr);

	return hr;
}

HRESULT CNmChannelDataObj::ChannelRemoved()
{
	HRESULT hr = S_OK;

	RemoveMembers();

	CNmConferenceObj* pConfObj = GetConfObj();
	if(pConfObj)
	{
		hr = pConfObj->Fire_ChannelChanged(NM_CHANNEL_REMOVED, com_cast<INmChannel>(GetUnknown()));
	}
	else
	{
		ERROR_OUT(("ChannelRemoved, but no ConfObject"));
		hr = E_UNEXPECTED;
	}

	if(m_dwInternalAdviseCookie)
	{
		ASSERT(m_spInternalINmChannelData);
		AtlUnadvise(m_spInternalINmChannelData, IID_INmChannelDataNotify, m_dwInternalAdviseCookie);
		m_dwInternalAdviseCookie = 0;
	}

	m_spInternalINmChannelData = NULL;

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

HRESULT CNmChannelDataObj::Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CNmChannelDataObj::Fire_MemberChanged);
	HRESULT hr = S_OK;


		/////////////////////////////////////////////////////
		// INmChannelNotify
		/////////////////////////////////////////////////////
	IConnectionPointImpl<CNmChannelDataObj, &IID_INmChannelNotify, CComDynamicUnkArray>* pCP = this;
	for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
	{
		INmChannelNotify* pNotify = reinterpret_cast<INmChannelNotify*>(pCP->m_vec.GetAt(i));

		if(pNotify)
		{
			pNotify->MemberChanged(uNotify, pMember);
		}
	}
		/////////////////////////////////////////////////////
		// INmChannelDataNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelDataObj, &IID_INmChannelDataNotify, CComDynamicUnkArray>* pCP2 = this;
	for(i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelDataNotify* pNotify2 = reinterpret_cast<INmChannelDataNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->MemberChanged(uNotify, pMember);
		}
	}

	DBGEXIT_HR(CNmChannelDataObj::Fire_MemberChanged,hr)
	return hr;
}


HRESULT CNmChannelDataObj::Fire_DataSent(INmMember *pSDKMember, ULONG uSize,byte *pvBuffer)
{
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelDataNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelDataObj, &IID_INmChannelDataNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelDataNotify* pNotify2 = reinterpret_cast<INmChannelDataNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->DataSent(pSDKMember, uSize, pvBuffer);
		}
	}

	return hr;
}

HRESULT CNmChannelDataObj::Fire_DataReceived(INmMember *pSDKMember, ULONG uSize, byte *pvBuffer, ULONG dwFlags)
{
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelDataNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelDataObj, &IID_INmChannelDataNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelDataNotify* pNotify2 = reinterpret_cast<INmChannelDataNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->DataReceived(pSDKMember, uSize, pvBuffer, dwFlags);
		}
	}

	return hr;
}

HRESULT CNmChannelDataObj::_IsActive()
{

	HRESULT hr = E_FAIL;
	
	if(m_spInternalINmChannelData)
	{
		hr = m_spInternalINmChannelData->IsActive();
	}
	
	return hr;
}

HRESULT CNmChannelDataObj::_SetActive(BOOL bActive)
{
	if (GetbActive() == bActive)
		return S_FALSE;

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmchanneldata.h ===
#ifndef __NmChannelData_h__
#define __NmChannelData_h__

/////////////////////////////////////////////////////////////////////////////
// CNmChannelDataObj
class ATL_NO_VTABLE CNmChannelDataObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmChannelDataObj>,
	public IConnectionPointImpl<CNmChannelDataObj, &IID_INmChannelNotify, CComDynamicUnkArray>,
	public IConnectionPointImpl<CNmChannelDataObj, &IID_INmChannelDataNotify, CComDynamicUnkArray>,
	public INmChannelData2,
	public INmChannelDataNotify2,
	public IInternalChannelObj
{

protected:
	CComPtr<INmChannelData>		m_spInternalINmChannelData;
	DWORD						m_dwInternalAdviseCookie;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmChannelDataObj)

BEGIN_COM_MAP(CNmChannelDataObj)
	COM_INTERFACE_ENTRY(INmChannel)
	COM_INTERFACE_ENTRY(INmChannelData)
	COM_INTERFACE_ENTRY(INmChannelData2)
	COM_INTERFACE_ENTRY(INmChannelNotify)
	COM_INTERFACE_ENTRY(INmChannelDataNotify)
	COM_INTERFACE_ENTRY(INmChannelDataNotify2)
	COM_INTERFACE_ENTRY(IInternalChannelObj)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CNmChannelDataObj)
	CONNECTION_POINT_ENTRY(IID_INmChannelNotify)
	CONNECTION_POINT_ENTRY(IID_INmChannelDataNotify)
END_CONNECTION_POINT_MAP()

		// Construction and destruection
	CNmChannelDataObj();
	~CNmChannelDataObj();
	HRESULT FinalConstruct();
	ULONG InternalRelease();
	static HRESULT CreateInstance(CNmConferenceObj* pConfObj, INmChannel* pInternalINmChannel, INmChannel** ppChannel);

	// INmChannelData methods
    STDMETHOD(GetGuid)(GUID *pguid);
    STDMETHOD(SendData)(INmMember *pMember, ULONG uSize, byte *pvBuffer, ULONG uOptions);

	// INmChannelData2 methods
	STDMETHOD(RegistryAllocateHandle)(ULONG numberOfHandlesRequested);

	//INmChannelDataNotify
    STDMETHOD(DataSent)(INmMember *pMember, ULONG uSize,byte *pvBuffer);
    STDMETHOD(DataReceived)(INmMember *pInternalMember,ULONG uSize,byte *pvBuffer, ULONG dwFlags);
    STDMETHOD(AllocateHandleConfirm)(ULONG handle_value, ULONG chandles);

	// IInternalChannelObj methods
	STDMETHOD(GetInternalINmChannel)(INmChannel** ppChannel);
	STDMETHOD(ChannelRemoved)();

	// Helpers
	HRESULT Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	HRESULT Fire_DataSent(INmMember *pSDKMember, ULONG uSize,byte *pvBuffer);
	HRESULT Fire_DataReceived(INmMember *pSDKMember, ULONG uSize, byte *pvBuffer, ULONG dwFlags);
	void _OnActivate(bool bActive) {;}

	virtual CNmConferenceObj* GetConfObj() = 0;
	virtual void RemoveMembers() = 0;
	virtual BOOL GetbActive() = 0;

	HRESULT _IsActive();
	HRESULT _SetActive(BOOL bActive);

};


#endif // __NmChannelData_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmchannelft.cpp ===
#include "precomp.h"
#include "resource.h"
#include "ConfUtil.h"
#include "ConfPolicies.h"

// SDK includes
#include "NmEnum.h"
#include "NmConference.h"
#include "SDKInternal.h"
#include "NmMember.h"
#include "NmChannel.h"
#include "NmChannelFt.h"
#include "NmFt.h"
#include "FtHook.h"


CNmChannelFtObj::CNmChannelFtObj()
: m_bSentSinkLocalMember(false)
{
	DBGENTRY(CNmChannelFtObj::CNmChannelFtObj);

	DBGEXIT(CNmChannelFtObj::CNmChannelFtObj);
}

CNmChannelFtObj::~CNmChannelFtObj()
{
	DBGENTRY(CNmChannelFtObj::~CNmChannelFtObj);

	CFt::UnAdvise(this);

		// Free our Ft objects
	for(int i = 0; i < m_SDKFtObjs.GetSize(); ++i)
	{
		m_SDKFtObjs[i]->Release();
	}

	DBGEXIT(CNmChannelFtObj::~CNmChannelFtObj);	
}

//
HRESULT CNmChannelFtObj::CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelFtObj::CreateInstance);
	HRESULT hr = S_OK;

	typedef CNmChannel<CNmChannelFtObj, &IID_INmChannelFt, NMCH_FT> channel_type;

	channel_type* p = NULL;
	p = new CComObject<channel_type>(NULL);

	if (p != NULL)
	{
		if(ppChannel)
		{
		p->SetVoid(NULL);

		hr = p->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));

		if(SUCCEEDED(hr))
		{
				// We don't have to RefCount this because our lifetime is
				// contained in the CConf's lifetime
			p->m_pConfObj = pConfObj;
		}

		if(FAILED(hr))
		{
			*ppChannel = NULL;
		}

	}
	else
	{
			hr = E_POINTER;
		}

	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	if(FAILED(hr))
	{
		delete p;
	}

	DBGEXIT_HR(CNmChannelFtObj::CreateInstance,hr);
	return hr;
}



/*  V A L I D A T E  F I L E  */
/*-------------------------------------------------------------------------
    %%Function: ValidateFile

    Verify that a file is a valid to send (it exists, not a folder, etc.)
-------------------------------------------------------------------------*/
HRESULT ValidateFile(LPCTSTR pszFile, DWORD *pdwSizeInBytes)
{
	WIN32_FIND_DATA findData;
	*pdwSizeInBytes = 0;

	HRESULT hr = S_OK;
	if (FEmptySz(pszFile) || (MAX_PATH < lstrlen(pszFile)))
	{
		TRACE_OUT(("SendFile: invalid filename"));
		return E_INVALIDARG;
	}

	// get file information
	HANDLE hFind = FindFirstFile(pszFile, &findData);
	if (INVALID_HANDLE_VALUE == hFind)
	{
		TRACE_OUT(("SendFile: Bad Filename [%s]", pszFile));
		return E_INVALIDARG;
	}
	FindClose(hFind);
	if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
		WARNING_OUT(("SendFile: [%s] is a directory", pszFile));
		return E_INVALIDARG;
	}

	// Check whether we are allowed to send files of this size.
	DWORD dwMaxSendFileSize = ConfPolicies::GetMaxSendFileSize();

	if (dwMaxSendFileSize) {
		DWORD dwFileSizeInK = (findData.nFileSizeLow >> 10) |
						(findData.nFileSizeHigh << (sizeof(DWORD) * 8 - 10));
		if ((dwFileSizeInK >= dwMaxSendFileSize) ||
			((findData.nFileSizeHigh >> 10) > 0)) {
			return NM_E_FILE_TOO_BIG;
		}
	}

	*pdwSizeInBytes = findData.nFileSizeLow;

	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////////
// INmChannelFt methods
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNmChannelFtObj::SendFile(INmFt **ppFt, INmMember *pMember, BSTR bstrFile, ULONG uOptions)
{
	DBGENTRY(CNmChannelFtObj::SendFile);
	HRESULT hr = S_OK;


       LPTSTR  szName = NULL;
       BSTR_to_LPTSTR (&szName, bstrFile);				        

	LPCTSTR szFileName = szName;
	DWORD dwSizeInBytes = 0;
	hr = ValidateFile(szFileName,&dwSizeInBytes);
	ULONG gccID = 0;
	MBFTEVENTHANDLE hEvent;
	MBFTFILEHANDLE hFile;


		// We should never be passed NULL because of the marshalling code...
	ASSERT(ppFt);

	if(!GetbActive())
	{
			// We are not active yet!
		hr = E_FAIL;
		goto end;
	}


	if(SUCCEEDED(hr))
	{

		if(pMember)
		{
			// Make sure that this member is valid and in the channel
			if(!_MemberInChannel(pMember))
			{
				hr = E_INVALIDARG;
				goto end;
			}

			hr = pMember->GetID(&gccID);
			if(FAILED(hr)) goto end;
		}

		hr = CFt::SendFile(szFileName,
						   static_cast<T120NodeID>(gccID),
						   &hEvent,
						   &hFile);
		if(SUCCEEDED(hr))
		{
			hr = CNmFtObj::CreateInstance(
				this, 
				hEvent,
				hFile,
				false,			// bIsIncoming
				szFileName,		// FileName
				dwSizeInBytes,	// Size in Bytes of the file
				pMember,
				ppFt
				);

			if(SUCCEEDED(hr))
			{
				(*ppFt)->AddRef();
				m_SDKFtObjs.Add(*ppFt);

				Fire_FtUpdate(CONFN_FT_STARTED, *ppFt);
			}
		}
	}

end:

        if(szName)
        {
            delete (szName);
        }

	DBGEXIT_HR(CNmChannelFtObj::SendFile,hr);
	return hr;
}

STDMETHODIMP CNmChannelFtObj::SetReceiveFileDir(BSTR bstrDir)
{
        DBGENTRY(CNmChannelFtObj::SetReceiveFileDir);
        HRESULT hr = E_INVALIDARG;

        if(bstrDir)
        {

            LPTSTR  szDir;
            hr =  BSTR_to_LPTSTR (&szDir, bstrDir);				        
            if (SUCCEEDED(hr))
            {    
                if(szDir)
                {
                    if(FEnsureDirExists(szDir))
                    {
                        hr = _ChangeRecDir(szDir);
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
               delete (szDir);
            }
        }

        DBGEXIT_HR(CNmChannelFtObj::SetReceiveFileDir,hr);
        return hr;
}

// static
HRESULT CNmChannelFtObj::_ChangeRecDir(LPTSTR pszRecDir)
{
	PSTR  psz;
	TCHAR szPath[MAX_PATH];
	
	HRESULT hr = S_OK;

	RegEntry reFileXfer(FILEXFER_KEY, HKEY_CURRENT_USER);

	if (NULL == pszRecDir)
	{
		// NULL directory specified - get info from registry or use default
		psz = reFileXfer.GetString(REGVAL_FILEXFER_PATH);
		if (!FEmptySz(psz))
		{
			lstrcpyn(szPath, psz, CCHMAX(szPath));
		}
		else
		{
			TCHAR szInstallDir[MAX_PATH];
			GetInstallDirectory(szInstallDir);
			FLoadString1(IDS_FT_RECDIR_DEFAULT, szPath, szInstallDir);
		}

		pszRecDir = szPath;
	}

	psz = pszRecDir;

	// Remove trailing backslash, if any
	for (; *psz; psz = CharNext(psz))
	{
		if ((_T('\\') == *psz) && (_T('\0') == *CharNext(psz)) )
		{
			*psz = _T('\0');
			break;
		}
	}

	TRACE_OUT(("ChangeRecDir [%s]", pszRecDir));


	if (!FEnsureDirExists(pszRecDir))
	{
		WARNING_OUT(("ChangeRecDir: FT directory is invalid [%s]", pszRecDir));
		hr = E_FAIL;
	}
	else
	{
		// update the registry
		reFileXfer.SetValue(REGVAL_FILEXFER_PATH, pszRecDir);

	}

	return hr;
}

STDMETHODIMP CNmChannelFtObj::GetReceiveFileDir(BSTR *pbstrDir)
{
	DBGENTRY(CNmChannelFtObj::GetReceiveFileDir);
	HRESULT hr = S_OK;
	
	if(pbstrDir)
	{
		RegEntry reFileXfer(FILEXFER_KEY, HKEY_CURRENT_USER);
		*pbstrDir = T2BSTR(reFileXfer.GetString(REGVAL_FILEXFER_PATH));
		if(!*pbstrDir)
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmChannelFtObj::GetReceiveFileDir,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// IInternalChannelObj methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelFtObj::GetInternalINmChannel(INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelFtObj::GetInternalINmChannel);
	HRESULT hr = S_OK;

	if(ppChannel)
	{
		*ppChannel = NULL;
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmChannelFtObj::GetInternalINmChannel,hr);

	return hr;
}

HRESULT CNmChannelFtObj::ChannelRemoved()
{
	HRESULT hr = S_OK;

	RemoveMembers();

	CNmConferenceObj* pConfObj = GetConfObj();
	if(pConfObj)
	{
		hr = pConfObj->Fire_ChannelChanged(NM_CHANNEL_REMOVED, com_cast<INmChannel>(GetUnknown()));
	}
	else
	{
		ERROR_OUT(("ChannelRemoved, but no ConfObject"));
		hr = E_UNEXPECTED;
	}

	m_bSentSinkLocalMember = false;


	return hr;
}

void CNmChannelFtObj::_OnActivate(bool bActive)
{
	bActive ? CFt::Advise(this) : CFt::UnAdvise(this);
}


///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

HRESULT CNmChannelFtObj::Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CNmChannelFtObj::Fire_MemberChanged);
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelNotify
		/////////////////////////////////////////////////////
	IConnectionPointImpl<CNmChannelFtObj, &IID_INmChannelNotify, CComDynamicUnkArray>* pCP = this;
	for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
	{
		if(NM_MEMBER_ADDED == uNotify)
		{
			if(!m_bSentSinkLocalMember)
			{
				m_bSentSinkLocalMember = true;
				NotifySinksOfLocalMember();
			}
		}

		INmChannelNotify* pNotify = reinterpret_cast<INmChannelNotify*>(pCP->m_vec.GetAt(i));

		if(pNotify)
		{
			pNotify->MemberChanged(uNotify, pMember);
		}
	}
		/////////////////////////////////////////////////////
		// INmChannelFtNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelFtObj, &IID_INmChannelFtNotify, CComDynamicUnkArray>* pCP2 = this;
	for(i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		if(NM_MEMBER_ADDED == uNotify)
		{
			if(!m_bSentSinkLocalMember)
			{
				m_bSentSinkLocalMember = true;
				NotifySinksOfLocalMember();
			}
		}

		INmChannelFtNotify* pNotify2 = reinterpret_cast<INmChannelFtNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->MemberChanged(uNotify, pMember);
		}
	}
	
	DBGEXIT_HR(CNmChannelFtObj::Fire_MemberChanged,hr);
	return hr;
}


HRESULT CNmChannelFtObj::Fire_FtUpdate(CONFN uNotify, INmFt* pNmFt)
{
	DBGENTRY(CNmChannelFtObj::Fire_FtUpdate);
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelFtNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelFtObj, &IID_INmChannelFtNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelFtNotify* pNotify2 = reinterpret_cast<INmChannelFtNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->FtUpdate(uNotify, pNmFt);
		}
	}
	
	DBGEXIT_HR(CNmChannelFtObj::Fire_FtUpdate,hr);
	return hr;
}

void CNmChannelFtObj::_RemoveFt(INmFt* pFt)
{
	INmFt* pRet = NULL;

	for( int i = 0; i < m_SDKFtObjs.GetSize(); ++i)
	{
		CComPtr<INmFt> spFt = m_SDKFtObjs[i];
		if(spFt.IsEqualObject(pFt))
		{	
			m_SDKFtObjs.RemoveAt(i);
			spFt.p->Release();
			break;
		}
	}
}

INmMember* CNmChannelFtObj::GetSDKMemberFromInternalMember(INmMember* pInternalMember)
{
	ASSERT(GetConfObj());
	return GetConfObj()->GetSDKMemberFromInternalMember(pInternalMember);
}

HRESULT CNmChannelFtObj::_IsActive()
{
	return GetbActive() ? S_OK : S_FALSE;
}

HRESULT CNmChannelFtObj::_SetActive(BOOL bActive)
{
	if (GetbActive() == bActive)
		return S_FALSE;

	return E_FAIL;
}


	// IMbftEvent Interface
STDMETHODIMP CNmChannelFtObj::OnInitializeComplete(void)
{
	// This is handled by the conference object
	return S_OK;
}

STDMETHODIMP CNmChannelFtObj::OnPeerAdded(MBFT_PEER_INFO *pInfo)
{
	// This is handled by the conference object
	return S_OK;
}

STDMETHODIMP CNmChannelFtObj::OnPeerRemoved(MBFT_PEER_INFO *pInfo)
{
	// This is handled by the conference object
	return S_OK;
}

STDMETHODIMP CNmChannelFtObj::OnFileOffer(MBFT_FILE_OFFER *pOffer)
{
	CNmConferenceObj* pConfObj = GetConfObj();

	if(pConfObj)
	{
		CComPtr<INmMember> spMember;

		HRESULT hr = S_OK;

		if(pOffer->NodeID)
		{
			hr = pConfObj->GetMemberFromNodeID(pOffer->NodeID, &spMember);
		}

		if(SUCCEEDED(hr))
		{
			RegEntry reFileXfer(FILEXFER_KEY, HKEY_CURRENT_USER);
			ASSERT(1 == pOffer->uNumFiles);

			CFt::AcceptFileOffer(   pOffer, 
									reFileXfer.GetString(REGVAL_FILEXFER_PATH),
									pOffer->lpFileInfoList[0].szFileName
								);

			CComPtr<INmFt> spFt;

			hr = CNmFtObj::CreateInstance(
				this, 
				pOffer->hEvent,							// hEvent
				0,										// hFile is 0 for now...
				true,									// bIsIncoming
				pOffer->lpFileInfoList[0].szFileName,	// FileName
				pOffer->lpFileInfoList[0].lFileSize,	// Size in Bytes of the file
				spMember,
				&spFt
				);

			if(SUCCEEDED(hr))
			{
				spFt.p->AddRef();
				m_SDKFtObjs.Add(spFt.p);

				Fire_FtUpdate(CONFN_FT_STARTED, spFt);
			}
		}
	}

	return S_OK;
}


INmFt* CNmChannelFtObj::_GetFtFromHEvent(MBFTEVENTHANDLE hEvent)
{
	for(int i = 0; i < m_SDKFtObjs.GetSize(); ++i)
	{
		UINT CurhEvent;
		if(SUCCEEDED(com_cast<IInternalFtObj>(m_SDKFtObjs[i])->GetHEvent(&CurhEvent)) && (hEvent == CurhEvent))
		{
			return m_SDKFtObjs[i];
		}
	}

	return NULL;
}


STDMETHODIMP CNmChannelFtObj::OnFileProgress(MBFT_FILE_PROGRESS *pProgress)
{
	DBGENTRY(CNmChannelFtObj::OnFileProgress);
	HRESULT hr = S_OK;

	INmFt* pFt = _GetFtFromHEvent(pProgress->hEvent);
	if(pFt)
	{
		com_cast<IInternalFtObj>(pFt)->OnFileProgress(pProgress->hFile, pProgress->lFileSize, pProgress->lBytesTransmitted);
		Fire_FtUpdate(CONFN_FT_PROGRESS, pFt);
	}

	DBGEXIT_HR(CNmChannelFtObj::OnFileProgress,hr);
	return hr;
}

STDMETHODIMP CNmChannelFtObj::OnFileEnd(MBFTFILEHANDLE hFile)
{
	// according to Lon, this is bogus
	return S_OK;
	
}

STDMETHODIMP CNmChannelFtObj::OnFileError(MBFT_EVENT_ERROR *pEvent)
{
	DBGENTRY(CNmChannelFtObj::OnFileError);
	HRESULT hr = S_OK;

	INmFt* pFt = _GetFtFromHEvent(pEvent->hEvent);
	if(pFt)
	{
		com_cast<IInternalFtObj>(pFt)->OnError();
	}
	
	DBGEXIT_HR(CNmChannelFtObj::OnFileError,hr);
	return hr;
}

STDMETHODIMP CNmChannelFtObj::OnFileEventEnd(MBFTEVENTHANDLE hEvent)
{
	INmFt* pFt = _GetFtFromHEvent(hEvent);

	if(pFt)
	{
		bool bHasSomeoneCanceled = (S_FALSE == com_cast<IInternalFtObj>(pFt)->FileTransferDone());
		
		Fire_FtUpdate(bHasSomeoneCanceled ? CONFN_FT_CANCELED : CONFN_FT_COMPLETE, pFt);

		_RemoveFt(pFt);
	}
		
	return S_OK;
}

STDMETHODIMP CNmChannelFtObj::OnSessionEnd(void)
{
	CFt::UnAdvise(this);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmchannelft.h ===
#ifndef __NmChannelFt_h__
#define __NmChannelFt_h__

#include "SDKInternal.h"
#include "FtHook.h"

/////////////////////////////////////////////////////////////////////////////
// CNmChannelFtObj
class ATL_NO_VTABLE CNmChannelFtObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmChannelFtObj>,
	public IConnectionPointImpl<CNmChannelFtObj, &IID_INmChannelNotify, CComDynamicUnkArray>,
	public IConnectionPointImpl<CNmChannelFtObj, &IID_INmChannelFtNotify, CComDynamicUnkArray>,
	public INmChannelFt,
	public IInternalChannelObj,
	public IMbftEvents
{

protected:
	CSimpleArray<INmFt*>		m_SDKFtObjs;
	bool						m_bSentSinkLocalMember;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmChannelFtObj)

BEGIN_COM_MAP(CNmChannelFtObj)
	COM_INTERFACE_ENTRY(INmChannel)
	COM_INTERFACE_ENTRY(INmChannelFt)
	COM_INTERFACE_ENTRY(IInternalChannelObj)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CNmChannelFtObj)
	CONNECTION_POINT_ENTRY(IID_INmChannelNotify)
	CONNECTION_POINT_ENTRY(IID_INmChannelFtNotify)
END_CONNECTION_POINT_MAP()


		// Construction and destruection
	CNmChannelFtObj();
	~CNmChannelFtObj();
	static HRESULT CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel);

	// INmChannelFtMethods
    STDMETHOD(SendFile)(INmFt **ppFt, INmMember *pMember, BSTR bstrFile, ULONG uOptions);
    STDMETHOD(SetReceiveFileDir)(BSTR bstrDir);
    STDMETHOD(GetReceiveFileDir)(BSTR *pbstrDir);

	// IInternalChannelObj methods
	STDMETHOD(GetInternalINmChannel)(INmChannel** ppChannel);
	STDMETHOD(ChannelRemoved)();
	STDMETHOD(Activate)(BOOL bActive);

	// IMbftEvent Interface
	STDMETHOD(OnInitializeComplete)(void);
	STDMETHOD(OnPeerAdded)(MBFT_PEER_INFO *pInfo);
	STDMETHOD(OnPeerRemoved)(MBFT_PEER_INFO *pInfo);
	STDMETHOD(OnFileOffer)(MBFT_FILE_OFFER *pOffer);
	STDMETHOD(OnFileProgress)(MBFT_FILE_PROGRESS *pProgress);
	STDMETHOD(OnFileEnd)(MBFTFILEHANDLE hFile);
	STDMETHOD(OnFileError)(MBFT_EVENT_ERROR *pEvent);
	STDMETHOD(OnFileEventEnd)(MBFTEVENTHANDLE hEvent);
	STDMETHOD(OnSessionEnd)(void);

	INmMember* GetSDKMemberFromInternalMember(INmMember* pInternalMember);
	INmFt* GetSDKFtFromInternalFt(INmFt* pInternalFt);
  
	// Helpers
	HRESULT Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	HRESULT Fire_FtUpdate(CONFN uNotify, INmFt* pNmFt);
	void _OnActivate(bool bActive);


	virtual CNmConferenceObj* GetConfObj() = 0;
	virtual void RemoveMembers() = 0;
	virtual BOOL GetbActive() = 0;
	virtual bool _MemberInChannel(INmMember* pSDKMember) = 0;

	virtual void NotifySinkOfMembers(INmChannelNotify* pNotify) = 0; 

	void _RemoveFt(INmFt* pFt);

	HRESULT _IsActive();
	HRESULT _SetActive(BOOL bActive);
	
	HRESULT _ChangeRecDir(LPTSTR pszRecDir);

	INmFt* _GetFtFromHEvent(MBFTEVENTHANDLE hEvent);
};


#endif // __NmChannelFt_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmconference.h ===
#ifndef __NmConference_h__
#define __NmConference_h__

#include "SDKInternal.h"
#include "FtHook.h"


// Forward decls
class CNmMemberObj;
class CNmManagerObj;

/////////////////////////////////////////////////////////////////////////////
// CNmConferenceObj
class ATL_NO_VTABLE CNmConferenceObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmConferenceObj>,
	public IConnectionPointImpl<CNmConferenceObj, &IID_INmConferenceNotify, CComDynamicUnkArray>,
	public INmConference,
	public INmConferenceNotify2,
	public IInternalConferenceObj,
	public IMbftEvents
{

protected:
// Data
	CComPtr<INmConference>		m_spInternalINmConference;
	CSimpleArray<INmMember*>	m_SDKMemberObjs;
	CSimpleArray<INmChannel*>	m_SDKChannelObjs;
	CSimpleArray<GUID>			m_DataChannelGUIDList;
	DWORD						m_dwInternalINmConferenceAdvise;
	CNmManagerObj*				m_pManagerObj;
	NM_CONFERENCE_STATE			m_State;
	bool						m_bFTHookedUp;
	BOOL						m_bLocalVideoActive;
	BOOL						m_bRemoteVideoActive;

public:

DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmConferenceObj)

BEGIN_COM_MAP(CNmConferenceObj)
	COM_INTERFACE_ENTRY(INmConference)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(INmConferenceNotify)
	COM_INTERFACE_ENTRY(INmConferenceNotify2)
	COM_INTERFACE_ENTRY(IInternalConferenceObj)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CNmConferenceObj)
	CONNECTION_POINT_ENTRY(IID_INmConferenceNotify)
END_CONNECTION_POINT_MAP()

// Construction/destruction
	CNmConferenceObj();
	~CNmConferenceObj();
	HRESULT FinalConstruct();
	ULONG InternalRelease();

	static HRESULT CreateInstance(CNmManagerObj* pManagerObj, INmConference* pInternalINmConferenece, INmConference** ppConference);
	static HRESULT InitSDK();
	static void CleanupSDK();

	// INmConference methods
	STDMETHOD(GetName)(BSTR *pbstrName);
	STDMETHOD(GetID)(ULONG * puID);
	STDMETHOD(GetState)(NM_CONFERENCE_STATE *pState);
	STDMETHOD(GetNmchCaps)(ULONG *puchCaps);
	STDMETHOD(GetTopProvider)(INmMember **ppMember);
	STDMETHOD(EnumMember)(IEnumNmMember **ppEnum);
	STDMETHOD(GetMemberCount)(ULONG *puCount);
	STDMETHOD(CreateChannel)(INmChannel **ppChannel, ULONG uNmCh, INmMember *pMember);
	STDMETHOD(EnumChannel)(IEnumNmChannel **ppEnum);
	STDMETHOD(GetChannelCount)(ULONG *puCount);
	STDMETHOD(CreateDataChannel)(INmChannelData **ppChannel, REFGUID rguid);
	STDMETHOD(Host)(void);
	STDMETHOD(Leave)(void);
	STDMETHOD(IsHosting)(void);
	STDMETHOD(LaunchRemote)(REFGUID rguid, INmMember *pMember);

	// INmConferenceNotify2 methods:
	//
	STDMETHOD(NmUI)(CONFN uNotify);
	STDMETHOD(StateChanged)(NM_CONFERENCE_STATE uState);
	STDMETHOD(MemberChanged)(NM_MEMBER_NOTIFY uNotify, INmMember *pInternalMember);
	STDMETHOD(ChannelChanged)(NM_CHANNEL_NOTIFY uNotify, INmChannel *pInternalChannel);
	STDMETHOD(StreamEvent)(NM_STREAMEVENT uEvent, UINT uSubCode,INmChannel *pInternalChannel);

	//IInternalConferenceObj
	STDMETHOD(GetInternalINmConference)(INmConference** ppConference); 
	STDMETHOD(GetMemberFromNodeID)(DWORD dwNodeID, INmMember** ppMember);
	STDMETHOD(RemoveAllMembersAndChannels)();
	STDMETHOD(AppSharingStateChanged)(BOOL bActive);
	STDMETHOD(SharableAppStateChanged)(HWND hWnd, NM_SHAPP_STATE state);
	STDMETHOD(ASLocalMemberChanged)();
	STDMETHOD(ASMemberChanged)(UINT gccID);
	STDMETHOD(FireNotificationsToSyncState)();
	STDMETHOD(AppSharingChannelChanged)();
	STDMETHOD(FireNotificationsToSyncToInternalObject)();
	STDMETHOD(EnsureFTChannel)();
	STDMETHOD(AudioChannelActiveState)(BOOL bActive, BOOL bIsIncoming);
	STDMETHOD(VideoChannelActiveState)(BOOL bActive, BOOL bIsIncoming);
	STDMETHOD(VideoChannelPropChanged)(DWORD dwProp, BOOL bIsIncoming);
	STDMETHOD(VideoChannelStateChanged)(NM_VIDEO_STATE uState, BOOL bIsIncoming);


	// IMbftEvent Interface
	STDMETHOD(OnInitializeComplete)(void);
	STDMETHOD(OnPeerAdded)(MBFT_PEER_INFO *pInfo);
	STDMETHOD(OnPeerRemoved)(MBFT_PEER_INFO *pInfo);
	STDMETHOD(OnFileOffer)(MBFT_FILE_OFFER *pOffer);
	STDMETHOD(OnFileProgress)(MBFT_FILE_PROGRESS *pProgress);
	STDMETHOD(OnFileEnd)(MBFTFILEHANDLE hFile);
	STDMETHOD(OnFileError)(MBFT_EVENT_ERROR *pEvent);
	STDMETHOD(OnFileEventEnd)(MBFTEVENTHANDLE hEvent);
	STDMETHOD(OnSessionEnd)(void);

		// Notifications
	HRESULT Fire_NmUI(CONFN uNotify);
	HRESULT Fire_StateChanged(NM_CONFERENCE_STATE uState);
	HRESULT Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	HRESULT Fire_ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pInternalChannel);

	INmMember* GetSDKMemberFromInternalMember(INmMember* pInternalMember);
	INmChannel* GetSDKChannelFromInternalChannel(INmChannel* pInternalChannel);
	INmMember* GetLocalSDKMember();

private:
// helper Fns

	static HRESULT _CreateInstanceGuts(CComObject<CNmConferenceObj> *p, INmConference** ppConference);
	HRESULT _RemoveMember(INmMember* pInternalMember);
	HRESULT _RemoveChannel(INmChannel* pSDKChannel);
	void _FreeInternalStuff();
	bool _IsGuidInDataChannelList(GUID& rg);
	HRESULT _AddAppShareChannel();
	HRESULT _AddFileTransferChannel();
	void _EnsureFtChannelAdded();
	void AddMemberToAsChannel(INmMember* pSDKMember);
	void RemoveMemberFromAsChannel(INmMember* pSDKMember);
	void AddMemberToFtChannel(INmMember* pSDKMember);
	void RemoveMemberFromFtChannel(INmMember* pSDKMember);
	INmChannel* _GetAppSharingChannel();
	INmChannel* _GetFtChannel();
	INmChannel* _GetAudioChannel(BOOL bIncoming);
	INmChannel* _GetVideoChannel(BOOL bIncoming);
	HRESULT _ASMemberChanged(INmMember *pSDKMember);
	void _EnsureMemberHasAVChannelsIfNeeded(INmMember* pSDKMember);
	void _EnsureMemberHasAVChannel(ULONG ulch, INmMember* pSDKMember);
	void _EnsureSentConferenceCreatedNotification();

};

#endif // __NmConference_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmchannelvideo.cpp ===
#include "precomp.h"
#include "confroom.h"
#include "NmEnum.h"
#include "SDKInternal.h"
#include "NmConference.h"
#include "NmChannel.h"
#include "NmChannelVideo.h"


CNmChannelVideoObj::CNmChannelVideoObj()
{
	DBGENTRY(CNmChannelVideoObj::CNmChannelVideoObj);

	DBGEXIT(CNmChannelVideoObj::CNmChannelVideoObj);
}

CNmChannelVideoObj::~CNmChannelVideoObj()
{
	DBGENTRY(CNmChannelVideoObj::~CNmChannelVideoObj);

	DBGEXIT(CNmChannelVideoObj::~CNmChannelVideoObj);	
}


//
HRESULT CNmChannelVideoObj::CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel, bool bIsIncoming)
{
	DBGENTRY(CNmChannelVideoObj::CreateInstance);

	HRESULT hr = S_OK;

	typedef CNmChannel<CNmChannelVideoObj, &IID_INmChannelVideo, NMCH_VIDEO> channel_type;

	channel_type* p = NULL;
	p = new CComObject<channel_type>(NULL);

	if (p != NULL)
	{
		if(ppChannel)
		{
			p->SetVoid(NULL);

			hr = p->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));

			if(SUCCEEDED(hr))
			{

				p->m_bIsIncoming = bIsIncoming;

					// We don't have to RefCount this because our lifetime is
					// contained in the CConf's lifetime
				p->m_pConfObj = pConfObj;

			}

			if(FAILED(hr))
			{
				*ppChannel = NULL;
			}
		}
		else
		{
			hr = E_POINTER;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}


	if(FAILED(hr))
	{
		delete p;
	}


	DBGEXIT_HR(CNmChannelVideoObj::CreateInstance,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////
// INmChannelVideo2 methods
///////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CNmChannelVideoObj::IsIncoming(void)
{
	DBGENTRY(CNmChannelVideoObj::IsIncoming);
	HRESULT hr = E_UNEXPECTED;

	hr = m_bIsIncoming ? S_OK : S_FALSE;

	DBGEXIT_HR(CNmChannelVideoObj::IsIncoming,hr);
	return hr;
}

STDMETHODIMP CNmChannelVideoObj::GetState(NM_VIDEO_STATE *puState)
{
	DBGENTRY(CNmChannelVideoObj::GetState);
	HRESULT hr = E_POINTER;

	if(puState)
	{
		if(m_bIsIncoming)
		{
			hr = GetRemoteVideoState(puState);				
		}
		else
		{
			hr = GetLocalVideoState(puState);
		}
	}

	DBGEXIT_HR(CNmChannelVideoObj::GetState,hr);
	return hr;
}

STDMETHODIMP CNmChannelVideoObj::GetProperty(NM_VIDPROP uID,ULONG_PTR *puValue)
{
	DBGENTRY(CNmChannelVideoObj::GetProperty);
	HRESULT hr = E_INVALIDARG;
    ULONG ulValue;

	switch(uID)
	{
		case NM_VIDPROP_PAUSE:

			if(m_bIsIncoming)
			{
				*puValue = IsRemoteVideoPaused();
			}
			else
			{
				*puValue = IsLocalVideoPaused();
			}
			hr = S_OK;
			break;

		case NM_VIDPROP_IMAGE_QUALITY:
			hr = GetImageQuality(&ulValue, m_bIsIncoming);
            *puValue = ulValue;
			break;

		case NM_VIDPROP_CAMERA_DIALOG:
			if(m_bIsIncoming)
			{
				return E_FAIL;
			}

			hr = GetCameraDialog(&ulValue);
            *puValue = ulValue;
			break;

		case NM_VIDPROP_WINDOW_AUTO_SIZE:
		case NM_VIDPROP_WINDOW_SIZE:
		case NM_VIDPROP_WINDOW_POSITION:
		case NM_VIDPROP_WINDOW_TOP_MOST:
		case NM_VIDPROP_WINDOW_VISIBLE:
		case NM_VIDPROP_IMAGE_PREFERRED_SIZE:
			hr = E_FAIL;
			break;
	}

	DBGEXIT_HR(CNmChannelVideoObj::GetProperty,hr);
	return hr;
}

STDMETHODIMP CNmChannelVideoObj::SetProperty(NM_VIDPROP uID,ULONG_PTR uValue)
{
	DBGENTRY(CNmChannelVideoObj::SetProperty);
	HRESULT hr = E_INVALIDARG;

	switch(uID)
	{
		case NM_VIDPROP_PAUSE:
			if(m_bIsIncoming)
			{
				PauseRemoteVideo((ULONG)uValue);
			}
			else
			{
				PauseLocalVideo((ULONG)uValue);
			}
			hr = S_OK;
			break;

		case NM_VIDPROP_IMAGE_QUALITY:
			hr = SetImageQuality((ULONG)uValue, m_bIsIncoming);
			break;

		case NM_VIDPROP_CAMERA_DIALOG:
			
			if (m_bIsIncoming)
			{
				hr = E_FAIL;
			}
			else
			{	
				hr = E_INVALIDARG;
				if((NM_VIDEO_SOURCE_DIALOG == uValue) || (NM_VIDEO_FORMAT_DIALOG == uValue))
				{
					hr = SetCameraDialog((ULONG)uValue);
				}
			}

			break;

		case NM_VIDPROP_WINDOW_AUTO_SIZE:
		case NM_VIDPROP_WINDOW_SIZE:
		case NM_VIDPROP_WINDOW_POSITION:
		case NM_VIDPROP_WINDOW_TOP_MOST:
		case NM_VIDPROP_WINDOW_VISIBLE:
		case NM_VIDPROP_IMAGE_PREFERRED_SIZE:
			hr = E_FAIL;
			break;
	}

	DBGEXIT_HR(CNmChannelVideoObj::SetProperty,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////
//INmChannelVideoNotify2
///////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CNmChannelVideoObj::StateChanged(NM_VIDEO_STATE uState)
{
	DBGENTRY(CNmChannelVideoObj::StateChanged);
	HRESULT hr = S_OK;

	Activate(NM_VIDEO_IDLE != uState);
		
	hr = Fire_StateChanged(uState);

	DBGEXIT_HR(CNmChannelVideoObj::StateChanged,hr);
	return hr;
}

STDMETHODIMP CNmChannelVideoObj::PropertyChanged(DWORD dwReserved)
{
	DBGENTRY(CNmChannelVideoObj::PropertyChanged);
	HRESULT hr = S_OK;
	
	hr = Fire_PropertyChanged(dwReserved);

	DBGEXIT_HR(CNmChannelVideoObj::PropertyChanged,hr);
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// IInternalChannelObj methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelVideoObj::GetInternalINmChannel(INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelVideoObj::GetInternalINmChannel);
	HRESULT hr = E_POINTER;

	if(ppChannel)
	{
		*ppChannel = NULL;
		hr = S_OK;
	}

	DBGEXIT_HR(CNmChannelVideoObj::GetInternalINmChannel,hr);

	return hr;
}


HRESULT CNmChannelVideoObj::ChannelRemoved()
{
	HRESULT hr = S_OK;

	RemoveMembers();

	CNmConferenceObj* pConfObj = GetConfObj();

	if(pConfObj)
	{
		hr = pConfObj->Fire_ChannelChanged(NM_CHANNEL_REMOVED, com_cast<INmChannel>(GetUnknown()));
	}
	else
	{
		ERROR_OUT(("ChannelRemoved, but no ConfObject"));
		hr = E_UNEXPECTED;
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

HRESULT CNmChannelVideoObj::Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CNmChannelVideoObj::Fire_MemberChanged);
	HRESULT hr = S_OK;


		/////////////////////////////////////////////////////
		// INmChannelNotify
		/////////////////////////////////////////////////////
	IConnectionPointImpl<CNmChannelVideoObj, &IID_INmChannelNotify, CComDynamicUnkArray>* pCP = this;
	for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
	{
		INmChannelNotify* pNotify = reinterpret_cast<INmChannelNotify*>(pCP->m_vec.GetAt(i));

		if(pNotify)
		{
			pNotify->MemberChanged(uNotify, pMember);
		}
	}
		/////////////////////////////////////////////////////
		// INmChannelVideoNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelVideoObj, &IID_INmChannelVideoNotify, CComDynamicUnkArray>* pCP2 = this;
	for(i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelVideoNotify* pNotify2 = reinterpret_cast<INmChannelVideoNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->MemberChanged(uNotify, pMember);
		}
	}
	
	DBGEXIT_HR(CNmChannelVideoObj::Fire_MemberChanged,hr)
	return hr;
}


HRESULT CNmChannelVideoObj::Fire_StateChanged(NM_VIDEO_STATE uState)
{
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelVideoNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelVideoObj, &IID_INmChannelVideoNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelVideoNotify* pNotify2 = reinterpret_cast<INmChannelVideoNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->StateChanged(uState);
		}
	}
	
	DBGEXIT_HR(CNmChannelVideoObj::Fire_MemberChanged,hr)
	return hr;
}

HRESULT CNmChannelVideoObj::Fire_PropertyChanged(DWORD dwReserved)
{

	HRESULT hr = S_OK;
		/////////////////////////////////////////////////////
		// INmChannelVideoNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelVideoObj, &IID_INmChannelVideoNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelVideoNotify* pNotify2 = reinterpret_cast<INmChannelVideoNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->PropertyChanged(dwReserved);
		}
	}
	
	DBGEXIT_HR(CNmChannelVideoObj::Fire_MemberChanged,hr)
	return hr;
}

HRESULT CNmChannelVideoObj::_IsActive()
{
	return GetbActive() ? S_OK : S_FALSE;
}

HRESULT CNmChannelVideoObj::_SetActive(BOOL bActive)
{
	if (GetbActive() == bActive)
		return S_FALSE;

	return E_FAIL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmchannelvideo.h ===
#ifndef __NmChannelVideo_h__
#define __NmChannelVideo_h__

/////////////////////////////////////////////////////////////////////////////
// CNmChannelVideoObj
class ATL_NO_VTABLE CNmChannelVideoObj :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmChannelVideoObj>,
	public IConnectionPointImpl<CNmChannelVideoObj, &IID_INmChannelNotify, CComDynamicUnkArray>,
	public IConnectionPointImpl<CNmChannelVideoObj, &IID_INmChannelVideoNotify, CComDynamicUnkArray>,
	public INmChannelVideo,
	public INmChannelVideoNotify,
	public IInternalChannelObj
{

protected:
	bool m_bIsIncoming;
public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmChannelVideoObj)

BEGIN_COM_MAP(CNmChannelVideoObj)
	COM_INTERFACE_ENTRY(INmChannel)
	COM_INTERFACE_ENTRY(INmChannelVideo)
	COM_INTERFACE_ENTRY(INmChannelNotify)
	COM_INTERFACE_ENTRY(INmChannelVideoNotify)
	COM_INTERFACE_ENTRY(IInternalChannelObj)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CNmChannelVideoObj)
	CONNECTION_POINT_ENTRY(IID_INmChannelNotify)
	CONNECTION_POINT_ENTRY(IID_INmChannelVideoNotify)
END_CONNECTION_POINT_MAP()


		// Construction and destruection
	CNmChannelVideoObj();
	~CNmChannelVideoObj();
	static HRESULT CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel, bool bIsIncoming);

	// INmChannelVideo methods
	STDMETHOD(IsIncoming)(void);
	STDMETHOD(GetState)(NM_VIDEO_STATE *puState);
    STDMETHOD(GetProperty)(NM_VIDPROP uID,ULONG_PTR *puValue);
    STDMETHOD(SetProperty)(NM_VIDPROP uID,ULONG_PTR uValue);

	// INmChannelVideoNotify methods		
    STDMETHOD(StateChanged)(NM_VIDEO_STATE uState);
	STDMETHOD(PropertyChanged)(DWORD dwReserved);

	// IInternalChannelObj methods
	STDMETHOD(GetInternalINmChannel)(INmChannel** ppChannel);
	STDMETHOD(ChannelRemoved)();

	// Helpers
	HRESULT Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	HRESULT Fire_StateChanged(NM_VIDEO_STATE uState);
	HRESULT Fire_PropertyChanged(DWORD dwReserved);
	void _OnActivate(bool bActive) {;}

	virtual CNmConferenceObj* GetConfObj() = 0;	
	virtual void RemoveMembers() = 0;
	virtual BOOL GetbActive() = 0;

	STDMETHOD(Activate)(BOOL bActive);

	HRESULT _IsActive();
	HRESULT _SetActive(BOOL bActive);

};


#endif // __NmChannelVideo_h__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmconference.cpp ===
#include "precomp.h"
#include "wbguid.h"
#include "confroom.h"

// SDK Includes
#include "NmEnum.h"
#include "SDKInternal.h"
#include "NmManager.h"
#include "NmConference.h"
#include "NmMember.h"
#include "NmCall.h"
#include "SDKWindow.h"
#include "NmChannelData.h"
#include "NmChannelFt.h"
#include "NmChannelAudio.h"
#include "NmChannelVideo.h"
#include "NmChannelAppShare.h"
#include "NmSharableApp.h"
#include "FtHook.h"

extern INmManager2* g_pInternalNmManager;

/////////////////////////////////////////////////////////
// Construction/destruction
/////////////////////////////////////////////////////////


CNmConferenceObj::CNmConferenceObj()
: m_dwInternalINmConferenceAdvise( 0 ),
  m_State(NM_CONFERENCE_IDLE),
  m_bFTHookedUp(false)
{
	DBGENTRY(CNmConferenceObj::CNmConferenceObj);


	DBGEXIT(CNmConferenceObj::CNmConferenceObj);
}

CNmConferenceObj::~CNmConferenceObj()
{
	DBGENTRY(CNmConferenceObj::~CNmConferenceObj);

	CFt::UnAdvise(this);
	m_bFTHookedUp = false;

		// this will protect us form re-deleting ourselves
	++m_dwRef;

	_FreeInternalStuff();

	// We don't have to release because we didn't addref
	// This is safe because our lifetime is contianed in the CNmManageObj's lifetime
	m_pManagerObj = NULL;

	DBGEXIT(CNmConferenceObj::~CNmConferenceObj);
}



HRESULT CNmConferenceObj::FinalConstruct()
{
	DBGENTRY(CNmConferenceObj::FinalConstruct);
	HRESULT hr = S_OK;

	if(m_spInternalINmConference)
	{
		hr = AtlAdvise(m_spInternalINmConference, GetUnknown(), IID_INmConferenceNotify2, &m_dwInternalINmConferenceAdvise);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmConferenceObj::FinalConstruct,hr);
	return hr;
}



ULONG CNmConferenceObj::InternalRelease()
{
	ATLASSERT(m_dwRef > 0);

	--m_dwRef;

	if((1 == m_dwRef) && m_dwInternalINmConferenceAdvise)
	{	
		++m_dwRef;
		DWORD dwAdvise = m_dwInternalINmConferenceAdvise;
		CComPtr<INmConference> spConf = m_spInternalINmConference;
		m_spInternalINmConference = NULL;

			// This keeps us from getting here twice!
		m_dwInternalINmConferenceAdvise = 0;
		AtlUnadvise(spConf, IID_INmConferenceNotify2, dwAdvise);
		--m_dwRef;
	}

	return m_dwRef;

}


/*static*/ HRESULT CNmConferenceObj::InitSDK()
{
	DBGENTRY(CNmConferenceObj::InitSDK);
	HRESULT hr = S_OK;

	DBGEXIT_HR(CNmConferenceObj::InitSDK,hr);
	return hr;
}

/*static*/void CNmConferenceObj::CleanupSDK()
{
	DBGENTRY(CNmConferenceObj::CleanupSDK);
	
	DBGEXIT(CNmConferenceObj::CleanupSDK);
}


/*static*/
HRESULT CNmConferenceObj::CreateInstance(CNmManagerObj* pManagerObj, INmConference* pInternalINmConferenece, INmConference** ppConference)
{
	DBGENTRY(CNmConferenceObj::CreateInstance);
	HRESULT hr = S_OK;

	CComObject<CNmConferenceObj>* p = NULL;
	p = new CComObject<CNmConferenceObj>(NULL);

	if (p != NULL)
	{
		if(SUCCEEDED(hr))
		{
			CNmConferenceObj* pThis = static_cast<CNmConferenceObj*>(p);

			pThis->m_spInternalINmConference = pInternalINmConferenece;
			if(pInternalINmConferenece)
			{
				pInternalINmConferenece->GetState(&pThis->m_State);
			}
				// We don't have to RefCount this because our lifetime is
				// contained in the CNMManageuObj's lifetime
			pThis->m_pManagerObj = pManagerObj;
		}

		hr = _CreateInstanceGuts(p, ppConference);				
	}

	DBGEXIT_HR(CNmConferenceObj::CreateInstance,hr);
	return hr;
}



/*static*/
HRESULT CNmConferenceObj::_CreateInstanceGuts(CComObject<CNmConferenceObj> *p, INmConference** ppConference)
{
	DBGENTRY(CNmConferenceObj::_CreateInstanceGuts);
	HRESULT hr = S_OK;

	if(ppConference)
	{
		if(p != NULL)
		{
			p->SetVoid(NULL);

				// We do this so that we don't accidentally Release out of memory
			++p->m_dwRef;
			hr = p->FinalConstruct();
			--p->m_dwRef;

			if(hr == S_OK)
				hr = p->QueryInterface(IID_INmConference, reinterpret_cast<void**>(ppConference));

			if(FAILED(hr))
			{	*ppConference = NULL;
				delete p;
			}
		}
		else
		{
			hr = E_UNEXPECTED;
		}
	}
	else
	{		
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmConferenceObj::_CreateInstanceGuts,hr);
	return hr;
			
}


/////////////////////////////////////////////////////////
// INmConference methods
/////////////////////////////////////////////////////////

STDMETHODIMP CNmConferenceObj::GetName(BSTR *pbstrName)
{
	DBGENTRY(CNmConferenceObj::GetName);
	HRESULT hr = S_OK;

	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->GetName(pbstrName);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}

STDMETHODIMP CNmConferenceObj::GetID(ULONG * puID)
{
	HRESULT hr = S_OK;

	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->GetID(puID);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;

}

STDMETHODIMP CNmConferenceObj::GetState(NM_CONFERENCE_STATE *pState)
{
	DBGENTRY(CNmConferenceObj::GetState);
	HRESULT hr = S_OK;

	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->GetState(pState);
	}
	else
	{
		hr = E_UNEXPECTED;	
	}

	DBGEXIT_HR(CNmConferenceObj::GetState,hr);
	return hr;
}

STDMETHODIMP CNmConferenceObj::GetNmchCaps(ULONG *puchCaps)
{
	HRESULT hr = S_OK;

	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->GetNmchCaps(puchCaps);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}

STDMETHODIMP CNmConferenceObj::GetTopProvider(INmMember **ppMember)
{
	HRESULT hr = E_FAIL;

	if(ppMember)
	{	*ppMember = NULL;

		if(m_spInternalINmConference)
		{
			INmMember* pInternalMember;
			if(SUCCEEDED(m_spInternalINmConference->GetTopProvider(&pInternalMember)))
			{
				*ppMember = GetSDKMemberFromInternalMember(pInternalMember);

				if(*ppMember)
				{
					(*ppMember)->AddRef();
					hr = S_OK;
				}

					// This is commented out for clairity.
					// the GetTopProvider method in nmcom does not
					// actually addref the pointer (!)
				//pInternalMember->Release
			}
		}
	}
	else
	{
		hr = E_POINTER;
	}
	
	return hr;
}

STDMETHODIMP CNmConferenceObj::EnumMember(IEnumNmMember **ppEnum)
{	
	DBGENTRY(CNmConferenceObj::EnumMember);
	HRESULT hr = S_OK;
			
	if(ppEnum)
	{
		hr = CreateEnumFromSimpleAryOfInterface<IEnumNmMember, INmMember>(m_SDKMemberObjs, ppEnum);
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmConferenceObj::EnumMember,hr);
	return hr;
}

STDMETHODIMP CNmConferenceObj::GetMemberCount(ULONG *puCount)
{
	DBGENTRY(CNmConferenceObj::GetMemberCount);
	HRESULT hr = S_OK;

	if(puCount)
	{
		*puCount = m_SDKMemberObjs.GetSize();
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmConferenceObj::GetMemberCount,hr);
	return hr;

}

STDMETHODIMP CNmConferenceObj::CreateChannel(INmChannel **ppChannel, ULONG uNmCh, INmMember *pMember)
{
	ATLTRACENOTIMPL(_T("CNmConferenceObj::GetName"));
}

STDMETHODIMP CNmConferenceObj::EnumChannel(IEnumNmChannel **ppEnum)
{
	DBGENTRY(CNmConferenceObj::EnumChannel);
	HRESULT hr = E_NOTIMPL;

	if(ppEnum)
	{
		hr = CreateEnumFromSimpleAryOfInterface<IEnumNmChannel, INmChannel>(m_SDKChannelObjs, ppEnum);
	}
	else
	{
		hr = E_POINTER;
	}


	DBGEXIT_HR(CNmConferenceObj::EnumChannel,hr);
	return hr;
}

STDMETHODIMP CNmConferenceObj::GetChannelCount(ULONG *puCount)
{
	DBGENTRY(CNmConferenceObj::GetChannelCount);
	HRESULT hr = S_OK;


	if(puCount)
	{
		*puCount = m_SDKChannelObjs.GetSize();
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmConferenceObj::GetChannelCount,hr);
	return hr;
}


// NetMeeting 2.0 chat guid: {340F3A60-7067-11D0-A041-444553540000}
const GUID g_guidNM2Chat =
{ 0x340f3a60, 0x7067, 0x11d0, { 0xa0, 0x41, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } };

STDMETHODIMP CNmConferenceObj::CreateDataChannel(INmChannelData **ppChannel, REFGUID rguid)
{
	HRESULT hr = S_OK;

	if(m_spInternalINmConference)
	{
		if(!InlineIsEqualGUID(rguid, g_guidNM2Chat))
		{

			GUID g = rguid;
			if(!_IsGuidInDataChannelList(g))
			{
				m_DataChannelGUIDList.Add(g);
			}

			CComPtr<INmChannelData> spInternalDataChannel;
			hr = m_spInternalINmConference->CreateDataChannel(&spInternalDataChannel, rguid);
			if(SUCCEEDED(hr))
			{
				INmChannel* pSDKChannel = GetSDKChannelFromInternalChannel(spInternalDataChannel);

				if(pSDKChannel && ppChannel)
				{
					*ppChannel = com_cast<INmChannelData>(pSDKChannel);
					if(*ppChannel)
					{
						(*ppChannel)->AddRef();
					}
					else
					{
						hr = E_UNEXPECTED;
					}
				}
			}
			else
			{
				m_DataChannelGUIDList.Remove(g);
			}
		}
		else
		{
			hr = NM_E_CHANNEL_ALREADY_EXISTS;
		}
	}
	else
	{
		hr = NM_E_NO_T120_CONFERENCE;
	}

	return hr;	
}

STDMETHODIMP CNmConferenceObj::Host(void)
{
	HRESULT hr =  S_OK;

	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->Host();
	}
	else
	{
		hr = E_UNEXPECTED;
	}
	return hr;
}

STDMETHODIMP CNmConferenceObj::Leave(void)
{
	DBGENTRY(CNmConferenceObj::Leave);
	HRESULT hr = S_OK;
	
	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->Leave();

		_FreeInternalStuff();

		if(!m_pManagerObj->OfficeMode())
		{
			StateChanged(NM_CONFERENCE_IDLE);
		}
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmConferenceObj::Leave,hr);
	return hr;		
}

STDMETHODIMP CNmConferenceObj::IsHosting(void)
{
	HRESULT hr = E_UNEXPECTED;

	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->IsHosting();
	}
	
	return hr;
}

STDMETHODIMP CNmConferenceObj::LaunchRemote(REFGUID rguid, INmMember *pMember)
{
	HRESULT hr = E_UNEXPECTED;

	if(m_spInternalINmConference)
	{
		CComPtr<INmMember> spInternalMember;
		if(pMember)
		{
			CComPtr<IInternalMemberObj> spObj = com_cast<IInternalMemberObj>(pMember);
			ASSERT(spObj);
			spObj->GetInternalINmMember(&spInternalMember);
		}

		hr = m_spInternalINmConference->LaunchRemote(rguid, spInternalMember);
	}
	
	return hr;
}

/////////////////////////////////////////////////
// INmConferenceNotify2 methods:
/////////////////////////////////////////////////
STDMETHODIMP CNmConferenceObj::NmUI(CONFN uNotify)
{
	DBGENTRY(CNmConferenceObj::NmUI);
	HRESULT hr = S_OK;

	hr = Fire_NmUI(uNotify);

	DBGEXIT_HR(CNmConferenceObj::NmUI,hr);
	return hr;
}

void CNmConferenceObj::_EnsureSentConferenceCreatedNotification()
{
	if(m_pManagerObj && !m_pManagerObj->m_bSentConferenceCreated)
	{	
			//	If we have not sent conference created, send it now!
		CComQIPtr<INmConference> spConf(GetUnknown());
		m_pManagerObj->Fire_ConferenceCreated(spConf);
	}
}

STDMETHODIMP CNmConferenceObj::StateChanged(NM_CONFERENCE_STATE uState)
{
	DBGENTRY(CNmConferenceObj::StateChanged);
	HRESULT hr = S_OK;

	if(m_State != uState)
	{	
		m_State = uState;
		if(m_State == NM_CONFERENCE_IDLE)
		{
			if(m_bFTHookedUp)
			{
				CFt::UnAdvise(this);
				m_bFTHookedUp = false;
			}

			if(m_pManagerObj)
			{
				m_pManagerObj->m_bSentConferenceCreated = false;
			}

			_FreeInternalStuff();
		
		}
		else if(NM_CONFERENCE_ACTIVE == m_State)
		{
			EnsureFTChannel();
		}

		hr = Fire_StateChanged(uState);

		if(NM_CONFERENCE_WAITING == m_State)
		{
			_EnsureSentConferenceCreatedNotification();
		}
	}

	DBGEXIT_HR(CNmConferenceObj::StateChanged,hr);
	return hr;
}


void CNmConferenceObj::AddMemberToAsChannel(INmMember* pSDKMember)
{
	INmChannel* pChannel = _GetAppSharingChannel();

	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->SDKMemberAdded(pSDKMember);
	}
}

void CNmConferenceObj::RemoveMemberFromAsChannel(INmMember* pSDKMember)
{
	INmChannel* pChannel = _GetAppSharingChannel();
	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->SDKMemberRemoved(pSDKMember);
	}
}

void CNmConferenceObj::AddMemberToFtChannel(INmMember* pSDKMember)
{
	INmChannel* pChannel = _GetFtChannel();

	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->SDKMemberAdded(pSDKMember);
	}
}

void CNmConferenceObj::RemoveMemberFromFtChannel(INmMember* pSDKMember)
{
	INmChannel* pChannel = _GetFtChannel();
	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->SDKMemberRemoved(pSDKMember);
	}
}

STDMETHODIMP CNmConferenceObj::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pInternalMember)
{
	DBGENTRY(CNmConferenceObj::MemberChanged);
	HRESULT hr = S_OK;

	if(pInternalMember)
	{
		CComPtr<INmMember> spMember;

		if(NM_MEMBER_ADDED == uNotify)
		{
			if(NULL == _GetAppSharingChannel())
			{
					// We don't get notified of this channel, so 
					// we have to add it manually
				_AddAppShareChannel();	
			}

				// We actually get this notification multiple times, so just check to make sure...
			if(!GetSDKMemberFromInternalMember(pInternalMember))
			{
				hr = CNmMemberObj::CreateInstance(this, pInternalMember, &spMember);
				if(SUCCEEDED(hr))
				{
					spMember.p->AddRef();
					m_SDKMemberObjs.Add(spMember.p);
				}
			}
		}

		CComPtr<INmMember> spSDKMember = GetSDKMemberFromInternalMember(pInternalMember);

		if(NM_MEMBER_REMOVED == uNotify)
		{
			_RemoveMember(pInternalMember);
		}

		Fire_MemberChanged(uNotify, spSDKMember);

		if((NM_MEMBER_ADDED == uNotify) || (NM_MEMBER_UPDATED == uNotify))
		{
				// Add the member to the AS Channel iff they have NMCH_DATA
			ASSERT(spSDKMember);

			ULONG uchCaps = 0;
			if(SUCCEEDED(spSDKMember->GetNmchCaps(&uchCaps)))
			{
				if(NMCH_DATA & uchCaps)
				{
						// This method will handle being called multiple times for the same member
					AddMemberToAsChannel(spSDKMember);
				}
			}
		}

		if(SUCCEEDED(hr) && (uNotify != NM_MEMBER_REMOVED))
		{
			ULONG ulGCCid;
			if(SUCCEEDED(spSDKMember->GetID(&ulGCCid)))
			{
				if(CFt::IsMemberInFtSession(static_cast<T120NodeID>(ulGCCid)))
				{		
						// Make sure that the user is in the channel
					AddMemberToFtChannel(spSDKMember);
				}
			}

			_EnsureMemberHasAVChannelsIfNeeded(spSDKMember);
		}
	}
	else
	{
		WARNING_OUT(("Why are we pased a NULL member?"));
	}

	DBGEXIT_HR(CNmConferenceObj::MemberChanged,hr);
	return hr;
}


STDMETHODIMP CNmConferenceObj::FireNotificationsToSyncState()
{
	// this is no longer used...
	ASSERT(0);
	return S_OK;
}


STDMETHODIMP CNmConferenceObj::EnsureFTChannel()
{
	if(m_pManagerObj && m_pManagerObj->FileTransferNotifications())
	{
		if(!m_bFTHookedUp)
		{
				// When the conference is active, we should add ourselves
			CFt::Advise(this);
			_EnsureFtChannelAdded();

			m_bFTHookedUp = true;

			if(CFt::IsFtActive())
			{
				// This means that the channel is Active
				INmChannel* pChannel = _GetFtChannel();

				if(pChannel)
				{
					com_cast<IInternalChannelObj>(pChannel)->Activate(true);

					Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);
				}
			}
		}
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::AudioChannelActiveState(BOOL bActive, BOOL bIsIncoming)
{
	
	INmChannel* pChannel = _GetAudioChannel(bIsIncoming);

	if(pChannel && ((pChannel->IsActive() == S_OK) != bActive))
	{
		com_cast<IInternalChannelObj>(pChannel)->Activate(bActive);

		Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::VideoChannelActiveState(BOOL bActive, BOOL bIsIncoming)
{
	
	INmChannel* pChannel = _GetVideoChannel(bIsIncoming);

	if(pChannel && ((pChannel->IsActive() == S_OK) != bActive))
	{
		com_cast<IInternalChannelObj>(pChannel)->Activate(bActive);

		Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::VideoChannelPropChanged(DWORD dwProp, BOOL bIsIncoming)
{
	INmChannel* pChannel = _GetVideoChannel(bIsIncoming);

	if(pChannel)
	{
		com_cast<INmChannelVideoNotify>(pChannel)->PropertyChanged(dwProp);
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::VideoChannelStateChanged(NM_VIDEO_STATE uState, BOOL bIsIncoming)
{
	INmChannel* pChannel = _GetVideoChannel(bIsIncoming);

	if(pChannel)
	{
		com_cast<INmChannelVideoNotify>(pChannel)->StateChanged(uState);
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pInternalChannel)
{
	DBGENTRY(CNmConferenceObj::ChannelChanged);
	HRESULT hr = S_OK;

	if(pInternalChannel)
	{
		if(NM_CHANNEL_ADDED == uNotify)
		{
			ULONG ulCh = NMCH_NONE;
			hr = pInternalChannel->GetNmch(&ulCh);
			if(SUCCEEDED(hr))
			{
				CComPtr<INmChannel> spChannel;
				hr = E_UNEXPECTED;

				switch(ulCh)
				{
					case NMCH_VIDEO:
						// this means that the channel is "Active"
						{
							BOOL bIncoming = (S_OK == com_cast<INmChannelVideo>(pInternalChannel)->IsIncoming());
							INmChannel* pVidChannel = _GetVideoChannel(bIncoming);
							if(pVidChannel)
							{
								com_cast<IInternalChannelObj>(pVidChannel)->Activate(true);
							}
							else
							{
								if(bIncoming)
								{
									m_bRemoteVideoActive = true;
								}
								else
								{
									m_bLocalVideoActive = true;
								}
							}
						}
						break;

					case NMCH_AUDIO:
						// this means that the channel is "Active"
						{
							BOOL bIncoming = (S_OK == com_cast<INmChannelAudio>(pInternalChannel)->IsIncoming());
							INmChannel* pAudioChannel = _GetAudioChannel(bIncoming);
							if(pAudioChannel)
							{
								com_cast<IInternalChannelObj>(pAudioChannel)->Activate(true);
							}
						}

						break;

					case NMCH_DATA:

						if(m_pManagerObj && m_pManagerObj->DataNotifications())
						{
							if(pInternalChannel)
							{
								CComPtr<INmChannelData> spDataChannel = com_cast<INmChannelData>(pInternalChannel);
								GUID g;
								if(spDataChannel && SUCCEEDED(spDataChannel->GetGuid(&g)))
								{
									if(_IsGuidInDataChannelList(g))
									{
											// We only do this if this GUID is in our list
										hr = CNmChannelDataObj::CreateInstance(this, pInternalChannel, &spChannel);
									}
								}
							}
						}
						break;

					case NMCH_FT:
						break;

					case NMCH_SHARE:
						// Currently, we don't get notified of the App Sharing "channel"
					default:
						ERROR_OUT(("Unknown channel type"));
						break;
				}

				if(SUCCEEDED(hr))
				{
					spChannel.p->AddRef();
					m_SDKChannelObjs.Add(spChannel.p);
					Fire_ChannelChanged(NM_CHANNEL_ADDED, spChannel);

						// Add all the members from the internal channel
					CComPtr<IEnumNmMember> spEnumMember;
					if(SUCCEEDED(pInternalChannel->EnumMember(&spEnumMember)))
					{
						INmMember* pMember = NULL;

						ULONG ulFetched = 0;
						while(S_OK == spEnumMember->Next(1, &pMember, &ulFetched))
						{
							
							CComPtr<INmMember> spSDKMember = GetSDKMemberFromInternalMember(pMember);

							if(spSDKMember)
							{
								com_cast<IInternalChannelObj>(spChannel)->SDKMemberAdded(spSDKMember);
							}
							else
							{
								ERROR_OUT(("We should not have members of a channel before they are in the conference"));
							}

							pMember->Release();
							pMember = NULL;
						}
					}

				}
			}
		}
		else
		{
			INmChannel* pChannel = GetSDKChannelFromInternalChannel(pInternalChannel);

			if(SUCCEEDED(hr) && pChannel)
			{
				if(NM_CHANNEL_REMOVED == uNotify)
				{
					_RemoveChannel(pChannel);
				}
				else
				{
					Fire_ChannelChanged(uNotify, pChannel);
				}
			}
		}
	}
	else
	{	
		hr = E_UNEXPECTED;
		ERROR_OUT(("ChannelChanged was passed a NULL INmChannel"));
	}

	DBGEXIT_HR(CNmConferenceObj::ChannelChanged,hr);
	return hr;
}

STDMETHODIMP CNmConferenceObj::StreamEvent(NM_STREAMEVENT uEvent, UINT uSubCode, INmChannel *pInternalChannel)
{
	DBGENTRY(CNmConferenceObj::StreamEvent);
	HRESULT hr = S_OK;
	
	DBGEXIT_HR(CNmConferenceObj::StreamEvent,hr);
	return hr;
}


	// IMbftEvent Interface
STDMETHODIMP CNmConferenceObj::OnInitializeComplete(void)
{
	// This means that the channel is Active
	INmChannel* pChannel = _GetFtChannel();

	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->Activate(true);

		Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnPeerAdded(MBFT_PEER_INFO *pInfo)
{
	CComPtr<INmMember> spMember;
	HRESULT hr = E_FAIL;

	if(CFt::IsMemberInFtSession(pInfo->NodeID))
	{
		hr = GetMemberFromNodeID(pInfo->NodeID, &spMember);

		if(SUCCEEDED(hr))
		{
			AddMemberToFtChannel(spMember);
		}
	}

	return hr;
}

STDMETHODIMP CNmConferenceObj::OnPeerRemoved(MBFT_PEER_INFO *pInfo)
{
	CComPtr<INmMember> spMember;

	HRESULT hr = GetMemberFromNodeID(pInfo->NodeID, &spMember);

	if(SUCCEEDED(hr))
	{
		RemoveMemberFromFtChannel(spMember);
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnFileOffer(MBFT_FILE_OFFER *pOffer)
{
	// The FT Channel and FT Object will handle this
	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnFileProgress(MBFT_FILE_PROGRESS *pProgress)
{

	// The FT Channel and FT Object will handle this
	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnFileEnd(MBFTFILEHANDLE hFile)
{

	// The FT Channel and FT Object will handle this
	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnFileError(MBFT_EVENT_ERROR *pEvent)
{

	// The FT Channel and FT Object will handle this
	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnFileEventEnd(MBFTEVENTHANDLE hEvent)
{

	// The FT Channel and FT Object will handle this
	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnSessionEnd(void)
{
	// This means that the channel is Active
	INmChannel* pChannel = _GetFtChannel();

	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->Activate(false);

		Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);

		_RemoveChannel(pChannel);
	}

	CFt::UnAdvise(this);
	m_bFTHookedUp = false;

	return S_OK;
}


////////////////////////////////////////////////////////////////////////
//IInternalConferenceObj
////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmConferenceObj::GetInternalINmConference(INmConference** ppConference)
{
	DBGENTRY(CNmConferenceObj::GetInternalINmConference);
	HRESULT hr = S_OK;
	
	ASSERT(ppConference);
	
	*ppConference = m_spInternalINmConference;
	if(*ppConference)
	{
		(*ppConference)->AddRef();
	}

	DBGEXIT_HR(CNmConferenceObj::GetInternalINmConference,hr);
	return hr;
}


STDMETHODIMP CNmConferenceObj::GetMemberFromNodeID(DWORD dwNodeID, INmMember** ppMember)
{
	HRESULT hr = E_POINTER;

	if(ppMember)
	{
		hr = E_FAIL;
		for(int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
		{
			DWORD dwGCCID;
			HRESULT hrRes;
			if(SUCCEEDED(hrRes = m_SDKMemberObjs[i]->GetID(&dwGCCID)))
			{
				if(dwGCCID == dwNodeID)
				{
					*ppMember = m_SDKMemberObjs[i];
					(*ppMember)->AddRef();
					hr = S_OK;
				}
			}
			else hr = hrRes;
		}
	}
	
	return hr;
}


STDMETHODIMP CNmConferenceObj::RemoveAllMembersAndChannels()
{
	HRESULT hr = S_OK;

	_FreeInternalStuff();	

	return hr;
}

STDMETHODIMP CNmConferenceObj::AppSharingChannelChanged()
{

	HRESULT hr = E_UNEXPECTED;

	INmChannel* pChannel = _GetAppSharingChannel();

	if(pChannel)
	{
		Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);
	}

	return hr;
}


STDMETHODIMP CNmConferenceObj::FireNotificationsToSyncToInternalObject()
{
	if(m_spInternalINmConference)
	{

			// Add all the members from the internal conference
		CComPtr<IEnumNmMember> spEnumMember;
		if(SUCCEEDED(m_spInternalINmConference->EnumMember(&spEnumMember)))
		{
			INmMember* pMember = NULL;

			ULONG ulFetched = 0;
			while(S_OK == spEnumMember->Next(1, &pMember, &ulFetched))
			{
				MemberChanged(NM_MEMBER_ADDED, pMember);
				pMember->Release();
				pMember = NULL;
			}
		}


			// Fire the CHANNEL_ADDED notifications
		for(int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
		{
			Fire_ChannelChanged(NM_CHANNEL_ADDED, m_SDKChannelObjs[i]);
				
				// Tell the channel to fire the MEMBER_ADDED notificaitnos, etc.
			com_cast<IInternalChannelObj>(m_SDKChannelObjs[i])->FireNotificationsToSyncState();
		}

		if(0 != m_SDKMemberObjs.GetSize())
		{
			if(NULL == _GetAppSharingChannel())
			{
						// We don't get notified of this channel, so 
						// we have to add it manually
					_AddAppShareChannel();	
			}

			EnsureFTChannel();

			for(i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
			{
				ULONG uchCaps = 0;
				if(SUCCEEDED(m_SDKMemberObjs[i]->GetNmchCaps(&uchCaps)))
				{
					if(NMCH_DATA & uchCaps)
					{
							// This method will handle being called multiple times for the same member
						AddMemberToAsChannel(m_SDKMemberObjs[i]);
					}
				}			
				
				
				ULONG ulGCCid;
				if(SUCCEEDED(m_SDKMemberObjs[i]->GetID(&ulGCCid)))
				{
					if(CFt::IsMemberInFtSession(static_cast<T120NodeID>(ulGCCid)))
					{		
							// Make sure that the user is in the channel
						AddMemberToFtChannel(m_SDKMemberObjs[i]);
					}
				}
			}
		}
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::AppSharingStateChanged(BOOL bActive)
{

	HRESULT hr = E_UNEXPECTED;

	INmChannel* pChannel = _GetAppSharingChannel();

	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->Activate(bActive);

		Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);
	}

	return hr;
}


INmChannel* CNmConferenceObj::_GetAppSharingChannel()
{
	INmChannel* pChannel = NULL;

	for(int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		ULONG ulch;
		if(SUCCEEDED(m_SDKChannelObjs[i]->GetNmch(&ulch)))
		{
			if(NMCH_SHARE == ulch)
			{
				pChannel = m_SDKChannelObjs[i];
				break;
			}
		}
	}

	return pChannel;
}


INmChannel* CNmConferenceObj::_GetFtChannel()
{
	INmChannel* pChannel = NULL;

	for(int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		ULONG ulch;
		if(SUCCEEDED(m_SDKChannelObjs[i]->GetNmch(&ulch)))
		{
			if(NMCH_FT == ulch)
			{
				pChannel = m_SDKChannelObjs[i];
				break;
			}
		}
	}

	return pChannel;
}


INmChannel* CNmConferenceObj::_GetAudioChannel(BOOL bIncoming)
{
	INmChannel* pChannel = NULL;

	for(int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		ULONG ulch;
		if(SUCCEEDED(m_SDKChannelObjs[i]->GetNmch(&ulch)))
		{
			if((NMCH_AUDIO == ulch) && ((S_OK == com_cast<INmChannelAudio>(m_SDKChannelObjs[i])->IsIncoming()) == bIncoming))
			{
				pChannel = m_SDKChannelObjs[i];
				break;
			}
		}
	}

	return pChannel;
}

INmChannel* CNmConferenceObj::_GetVideoChannel(BOOL bIncoming)
{
	INmChannel* pChannel = NULL;

	for(int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		ULONG ulch;
		if(SUCCEEDED(m_SDKChannelObjs[i]->GetNmch(&ulch)))
		{
			if((NMCH_VIDEO == ulch) && ((S_OK == com_cast<INmChannelVideo>(m_SDKChannelObjs[i])->IsIncoming()) == bIncoming))
			{
				pChannel = m_SDKChannelObjs[i];
				break;
			}
		}
	}

	return pChannel;
}


STDMETHODIMP CNmConferenceObj::SharableAppStateChanged(HWND hWnd, NM_SHAPP_STATE state)
{
	INmChannel* pChannelAs = _GetAppSharingChannel();

	HRESULT hr = S_OK;

	if(pChannelAs)
	{
		CComPtr<INmSharableApp> spSharableApp;

		TCHAR szName[MAX_PATH];

		hr = CNmChannelAppShareObj::GetSharableAppName(hWnd, szName, CCHMAX(szName));

		if(SUCCEEDED(hr))
		{
			hr = CNmSharableAppObj::CreateInstance(hWnd, szName, &spSharableApp);

			if(SUCCEEDED(hr))
			{
				com_cast<INmChannelAppShareNotify>(pChannelAs)->StateChanged(state, spSharableApp);
			}
		}
	}

	return hr;
}

STDMETHODIMP CNmConferenceObj::ASLocalMemberChanged()
{
	return _ASMemberChanged(GetLocalSDKMember());
}

STDMETHODIMP CNmConferenceObj::ASMemberChanged(UINT gccID)
{
	CComPtr<INmMember> spMember;

	HRESULT hr = GetMemberFromNodeID(gccID, &spMember);

	if(SUCCEEDED(hr))
	{
		hr = _ASMemberChanged(spMember);
	}

	return hr;
}

HRESULT CNmConferenceObj::_ASMemberChanged(INmMember *pSDKMember)
{
	if(pSDKMember)
	{
		Fire_MemberChanged(NM_MEMBER_UPDATED, pSDKMember);
		
		INmChannel* pChannel = _GetAppSharingChannel();
		if(pChannel)
		{
			com_cast<IInternalChannelObj>(pChannel)->SDKMemberChanged(pSDKMember);
		}
	}
	else
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

////////////////////////////////////////////////////////////////////////
// Notifications
////////////////////////////////////////////////////////////////////////


HRESULT CNmConferenceObj::Fire_NmUI(CONFN uNotify)
{
	DBGENTRY(CNmConferenceObj::Fire_NmUI)
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmConferenceNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmConferenceObj, &IID_INmConferenceNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmConferenceNotify* pNotify = reinterpret_cast<INmConferenceNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->NmUI(uNotify);
			}
		}
	}
	else
	{
		CSDKWindow::PostConferenceNmUI(this, uNotify);
	}

	DBGEXIT_HR(CNmConferenceObj::Fire_NmUI,hr);
	return hr;
}

HRESULT CNmConferenceObj::Fire_StateChanged(NM_CONFERENCE_STATE uState)
{
	DBGENTRY(CNmConferenceObj::Fire_StateChanged)
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmConferenceNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmConferenceObj, &IID_INmConferenceNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmConferenceNotify* pNotify = reinterpret_cast<INmConferenceNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->StateChanged(uState);
			}
		}
	}
	else
	{
		CSDKWindow::PostConferenceStateChanged(this, uState);
	}

	DBGEXIT_HR(CNmConferenceObj::Fire_StateChanged,hr);
	return hr;
}

extern bool g_bOfficeModeSuspendNotifications;

HRESULT CNmConferenceObj::Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CNmConferenceObj::Fire_MemberChanged);
	HRESULT hr = S_OK;

	if(m_pManagerObj->OfficeMode() && g_bOfficeModeSuspendNotifications)
	{
			// We don't have to notify anyone at all...
		return S_OK;			
	}

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmConferenceNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmConferenceObj, &IID_INmConferenceNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmConferenceNotify* pNotify = reinterpret_cast<INmConferenceNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->MemberChanged(uNotify, pMember);
			}
		}
	}
	else
	{
		CSDKWindow::PostConferenceMemberChanged(this, uNotify, pMember);
	}
	
	DBGEXIT_HR(CNmConferenceObj::Fire_MemberChanged,hr);
	return hr;
}



HRESULT CNmConferenceObj::Fire_ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
	DBGENTRY(CNmConferenceObj::Fire_ChannelChanged);
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmConferenceNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmConferenceObj, &IID_INmConferenceNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmConferenceNotify* pNotify = reinterpret_cast<INmConferenceNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->ChannelChanged(uNotify, pChannel);
			}
		}
	}
	else
	{
		CSDKWindow::PostConferenceChannelChanged(this, uNotify, pChannel);
	}

	DBGEXIT_HR(CNmConferenceObj::Fire_ChannelChanged,hr);
	return hr;
}


/////////////////////////////////////////////////
// helper Fns
/////////////////////////////////////////////////

INmChannel* CNmConferenceObj::GetSDKChannelFromInternalChannel(INmChannel* pInternalChannel)
{
	DBGENTRY(CNmConferenceObj::GetSDKChannelFromInternalChannel);

	INmChannel* pRet = NULL;

	for( int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		CComQIPtr<IInternalChannelObj> spInternal = m_SDKChannelObjs[i];
		if(spInternal)
		{
			CComPtr<INmChannel> spChannel;
			if(SUCCEEDED(spInternal->GetInternalINmChannel(&spChannel)))
			{
				if(spChannel.IsEqualObject(pInternalChannel))
				{
					pRet = m_SDKChannelObjs[i];
					break;
				}
			}
		}
	}

	DBGEXIT(CNmConferenceObj::GetSDKChannelFromInternalChannel);
	return pRet;
}


INmMember* CNmConferenceObj::GetSDKMemberFromInternalMember(INmMember* pInternalMember)
{
	DBGENTRY(CNmConferenceObj::GetSDKMemberFromInternalMember);

	INmMember* pRet = NULL;

	for( int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
	{
		CComQIPtr<IInternalMemberObj> spInternal = m_SDKMemberObjs[i];
		if(spInternal)
		{
			CComPtr<INmMember> spMember;
			if(SUCCEEDED(spInternal->GetInternalINmMember(&spMember)))
			{
				if(spMember.IsEqualObject(pInternalMember))
				{
					pRet = m_SDKMemberObjs[i];
					break;
				}
			}
		}
	}

	DBGEXIT(CNmConferenceObj::GetSDKMemberFromInternalMember);
	return pRet;
}


INmMember* CNmConferenceObj::GetLocalSDKMember()
{
	INmMember* pRet = NULL;

	for( int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
	{
		if(S_OK == m_SDKMemberObjs[i]->IsSelf())
		{
			pRet = m_SDKMemberObjs[i];
			break;
		}
	}

	return pRet;

}


HRESULT CNmConferenceObj::_RemoveMember(INmMember* pInternalMember)
{
	HRESULT hr = S_OK;

	for( int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
	{
		CComPtr<INmMember> spSDKMember = m_SDKMemberObjs[i];
		CComQIPtr<IInternalMemberObj> spMemberObj = spSDKMember;

		CComPtr<INmMember> spInternal;
		if(SUCCEEDED(spMemberObj->GetInternalINmMember(&spInternal)))
		{
			if(spInternal.IsEqualObject(pInternalMember))
			{
					// Remove the member from each of the channels
				for(int iChan = 0; iChan < m_SDKChannelObjs.GetSize(); ++iChan)
				{
					com_cast<IInternalChannelObj>(m_SDKChannelObjs[iChan])->SDKMemberRemoved(m_SDKMemberObjs[i]);
				}
				
					// Remove our reference to the member
				m_SDKMemberObjs.RemoveAt(i);
				spSDKMember.p->Release();
				break;
			}
		}
	}

	return hr;	
}


HRESULT CNmConferenceObj::_RemoveChannel(INmChannel* pSDKChannel)
{
	HRESULT hr = S_OK;

	for( int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		CComPtr<INmChannel> spChannel = m_SDKChannelObjs[i];

		if(spChannel.IsEqualObject(pSDKChannel))
		{
			m_SDKChannelObjs.RemoveAt(i);

			com_cast<IInternalChannelObj>(spChannel)->ChannelRemoved();

			spChannel.p->Release();

			break;
		}
	}

	return hr;
}

void CNmConferenceObj::_EnsureFtChannelAdded()
{
	if(NULL == _GetFtChannel())
	{
		_AddFileTransferChannel();
	}
}

HRESULT CNmConferenceObj::_AddFileTransferChannel()
{
	HRESULT hr = S_OK;

	if(m_pManagerObj && m_pManagerObj->FileTransferNotifications())
	{
		CComPtr<INmChannel> spChannel;
		hr = CNmChannelFtObj::CreateInstance(this, &spChannel);

		if(SUCCEEDED(hr))
		{
				// Add the channel to our list
			spChannel.p->AddRef();
			m_SDKChannelObjs.Add(spChannel.p);

				// Fire the notification
			Fire_ChannelChanged(NM_CHANNEL_ADDED, spChannel);
		}
	}

	return hr;
}



HRESULT CNmConferenceObj::_AddAppShareChannel()
{
	HRESULT hr = S_OK;

	if(m_pManagerObj && m_pManagerObj->AppSharingNotifications())
	{
		CComPtr<INmChannel> spChannel;
		hr = CNmChannelAppShareObj::CreateInstance(this, &spChannel);

		if(SUCCEEDED(hr))
		{
				// Add the channel to our list
			spChannel.p->AddRef();
			m_SDKChannelObjs.Add(spChannel.p);

				// Fire the notification
			Fire_ChannelChanged(NM_CHANNEL_ADDED, spChannel);

				// If app sharing is arleady active, send the notification
			CConfRoom* pcr = GetConfRoom();

			if(pcr && pcr->FCanShare())
			{
				AppSharingStateChanged(true);
			}
		}
	}

	return hr;
}

void CNmConferenceObj::_FreeInternalStuff()
{

	if(m_dwInternalINmConferenceAdvise)
	{
		AtlUnadvise(m_spInternalINmConference, IID_INmConferenceNotify2, m_dwInternalINmConferenceAdvise);
		m_dwInternalINmConferenceAdvise = 0;
	}

	m_spInternalINmConference = NULL;

	while(m_SDKChannelObjs.GetSize())
	{
		CComPtr<INmChannel> spChannel = m_SDKChannelObjs[0];
		m_SDKChannelObjs[0]->Release();
		m_SDKChannelObjs.RemoveAt(0);

		CComPtr<IInternalChannelObj> spChanObj = com_cast<IInternalChannelObj>(spChannel);
		ASSERT(spChanObj);

		spChanObj->Activate(FALSE);
		Fire_ChannelChanged(NM_CHANNEL_UPDATED, spChannel);

		com_cast<IInternalChannelObj>(spChannel)->ChannelRemoved();
	}

		// Free our Member objects
	while(m_SDKMemberObjs.GetSize())
	{
		INmMember* pMember = m_SDKMemberObjs[0];
		
		m_SDKMemberObjs.RemoveAt(0);

		Fire_MemberChanged(NM_MEMBER_REMOVED, pMember);

		pMember->Release();
	}

	m_SDKMemberObjs.RemoveAll();

	if(m_pManagerObj)
	{
		m_pManagerObj->RemoveConference(com_cast<INmConference>(GetUnknown()));
	}
}

bool CNmConferenceObj::_IsGuidInDataChannelList(GUID& rg)
{
	return -1 != m_DataChannelGUIDList.Find(rg);
}

void CNmConferenceObj::_EnsureMemberHasAVChannelsIfNeeded(INmMember* pSDKMember)
{
	ULONG ulCaps = 0;
	BOOL bIsSelf = (S_OK == pSDKMember->IsSelf());
	if(bIsSelf || SUCCEEDED(pSDKMember->GetNmchCaps(&ulCaps)))
	{
		if(bIsSelf || (NMCH_AUDIO & ulCaps))
		{
			_EnsureMemberHasAVChannel(NMCH_AUDIO, pSDKMember);
		}

		if(bIsSelf || (NMCH_VIDEO & ulCaps))
		{
			_EnsureMemberHasAVChannel(NMCH_VIDEO, pSDKMember);
		}
	}
}

void CNmConferenceObj::_EnsureMemberHasAVChannel(ULONG ulch, INmMember* pSDKMember)
{
	INmChannel* pChannel = NULL;

		// First we have to check to see if the user has this channel
	for(int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		ULONG ulchChannel;
		if(SUCCEEDED(m_SDKChannelObjs[i]->GetNmch(&ulchChannel)))
		{
			if(ulch == ulchChannel)
			{
				INmMember *pChannelMember = NULL;
				CComPtr<IEnumNmMember> spEnum;
				if(SUCCEEDED(m_SDKChannelObjs[i]->EnumMember(&spEnum)))
				{
					ULONG cFetched = 0;
					if(S_OK == spEnum->Next(1, &pChannelMember, &cFetched))
					{
						if(CComPtr<INmMember>(pSDKMember).IsEqualObject(pChannelMember))
						{
								// This means that we already have this member in a channel
							pChannelMember->Release();
							return;
						}

						pChannelMember->Release();
					}
				}
			}
		}
	}

	CComPtr<INmChannel> spChannel;
	
		// Now we have to add the channel
	if(NMCH_AUDIO == ulch)
	{
		if(m_pManagerObj && m_pManagerObj->AudioNotifications())
		{
			CNmChannelAudioObj::CreateInstance(this, &spChannel, S_FALSE == pSDKMember->IsSelf());

				// Add the channel to our list
			spChannel.p->AddRef();
			m_SDKChannelObjs.Add(spChannel.p);
			Fire_ChannelChanged(NM_CHANNEL_ADDED, spChannel);

				// Add the member to the channel
			com_cast<IInternalChannelObj>(spChannel)->SDKMemberAdded(pSDKMember);
			
			spChannel = NULL;
		}
	}

	if(NMCH_VIDEO == ulch)
	{
		if(m_pManagerObj && m_pManagerObj->VideoNotifications())
		{
			CNmChannelVideoObj::CreateInstance(this, &spChannel, S_FALSE == pSDKMember->IsSelf());

				// Add the channel to our list
			spChannel.p->AddRef();
			m_SDKChannelObjs.Add(spChannel.p);
			Fire_ChannelChanged(NM_CHANNEL_ADDED, spChannel);

				// Add the member to the channel
			com_cast<IInternalChannelObj>(spChannel)->SDKMemberAdded(pSDKMember);

		}
	}

		// We activate the video channels if the m_bXXXVideoActive flags are set
	if(spChannel && (NMCH_VIDEO == ulch))
	{
		if(S_OK == pSDKMember->IsSelf())
		{
			if(m_bLocalVideoActive)
			{
					// Add the member to the channel
				com_cast<IInternalChannelObj>(spChannel)->Activate(true);
				Fire_ChannelChanged(NM_CHANNEL_UPDATED, spChannel);
			}
		}
		else
		{
			if(m_bRemoteVideoActive)
			{
					// Add the member to the channel
				com_cast<IInternalChannelObj>(spChannel)->Activate(true);
				Fire_ChannelChanged(NM_CHANNEL_UPDATED, spChannel);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmft.cpp ===
#include "precomp.h"

#include "NmChannel.h"
#include "NmChannelFt.h"
#include "NmFt.h"


//static 
HRESULT CNmFtObj::CreateInstance(
		CNmChannelFtObj* pChannelObj, 
		MBFTEVENTHANDLE hFileEvent,
		MBFTFILEHANDLE hFile,
		bool bIncoming,
		LPCTSTR szFileName,
		DWORD dwSizeInBytes,
		INmMember* pSDKMember,
		INmFt** ppNmFt)
{	
	DBGENTRY(CNmFtObj::CreateInstance);
	HRESULT hr = S_OK;

	CComObject<CNmFtObj>* p = NULL;
	p = new CComObject<CNmFtObj>(NULL);
	if(p)
	{
		p->SetVoid(NULL);
		if(hr == S_OK)
		{
			hr = p->QueryInterface(IID_INmFt, reinterpret_cast<void**>(ppNmFt));
			if(SUCCEEDED(hr))
			{
				p->m_pChannelFtObj		= pChannelObj;
				p->m_hFileEvent			= hFileEvent;
				p->m_hFile				= hFile;
				p->m_bIncoming			= bIncoming;
				p->m_strFileName		= szFileName;
				p->m_dwSizeInBytes		= dwSizeInBytes;
				p->m_spSDKMember		= pSDKMember;
				p->m_State				= bIncoming ? NM_FT_RECEIVING : NM_FT_SENDING;
				p->m_dwBytesTransferred = 0;
				p->m_bSomeoneCanceled	= false;
			}
		}

		if(FAILED(hr))		
		{
			delete p;
			*ppNmFt = NULL;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}	

	DBGEXIT_HR(CNmFtObj::CreateInstance,hr);
	return hr;
}


////////////////////////////////////////////////
// INmFt interface

STDMETHODIMP CNmFtObj::IsIncoming(void)
{
	DBGENTRY(CNmFtObj::IsIncoming);

	HRESULT hr = m_bIncoming ? S_OK : S_FALSE;

	DBGEXIT_HR(CNmFtObj::IsIncoming,hr);
	return hr;
}

STDMETHODIMP CNmFtObj::GetState(NM_FT_STATE *puState)
{
	DBGENTRY(CNmFtObj::GetState);
	HRESULT hr = S_OK;
	
	*puState = m_State;

	DBGEXIT_HR(CNmFtObj::GetState,hr);
	return hr;
}

STDMETHODIMP CNmFtObj::GetName(BSTR *pbstrName)
{
	DBGENTRY(CNmFtObj::GetName);
	HRESULT hr = S_OK;

	*pbstrName = m_strFileName.Copy();

	DBGEXIT_HR(CNmFtObj::GetName,hr);
	return hr;
}

STDMETHODIMP CNmFtObj::GetSize(ULONG *puBytes)
{
	DBGENTRY(CNmFtObj::GetSize);
	HRESULT hr = S_OK;

	*puBytes = m_dwSizeInBytes;

	DBGEXIT_HR(CNmFtObj::GetSize,hr);
	return hr;
}

STDMETHODIMP CNmFtObj::GetBytesTransferred(ULONG *puBytes)
{
	DBGENTRY(CNmFtObj::GetBytesTransferred);
	HRESULT hr = S_OK;

	*puBytes = m_dwBytesTransferred;

	DBGEXIT_HR(CNmFtObj::GetBytesTransferred,hr);
	return hr;
}

STDMETHODIMP CNmFtObj::GetMember(INmMember **ppMember)
{
	DBGENTRY(CNmFtObj::GetMember);
	HRESULT hr = S_OK;

	*ppMember = m_spSDKMember;

	if(*ppMember)
	{
		(*ppMember)->AddRef();
	}

	DBGEXIT_HR(CNmFtObj::GetMember,hr);
	return hr;
}
	

STDMETHODIMP CNmFtObj::Cancel(void)
{
	if((NM_FT_INVALID == m_State) || (NM_FT_COMPLETE == m_State))
	{
		return E_FAIL;
	}

	return CFt::CancelFt(m_hFileEvent, m_hFile);
}


////////////////////////////////////////////////
// IInternalFtObj interface

STDMETHODIMP CNmFtObj::GetHEvent(UINT *phEvent)
{
	ASSERT(phEvent);

	*phEvent = m_hFileEvent;

	return S_OK;
}

STDMETHODIMP CNmFtObj::OnFileProgress(UINT hFile, ULONG lFileSize, ULONG lBytesTransmitted)
{
	m_hFile = hFile;
	m_dwBytesTransferred = lBytesTransmitted;

	return S_OK;
}

STDMETHODIMP CNmFtObj::FileTransferDone()
{
	m_dwBytesTransferred = m_dwSizeInBytes;
	m_State = NM_FT_COMPLETE;

		// Return S_FALSE if someone canceled
	return m_bSomeoneCanceled ? S_FALSE : S_OK;
}

STDMETHODIMP CNmFtObj::OnError()
{
	m_bSomeoneCanceled = true;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmft.h ===
#ifndef __NmFt_h__
#define __NmFt_h__

class CNmChannelFtObj;

class ATL_NO_VTABLE CNmFtObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public INmFt,
	public IInternalFtObj

{
protected:
	CNmChannelFtObj*	m_pChannelFtObj;
	MBFTEVENTHANDLE		m_hFileEvent;
	MBFTFILEHANDLE		m_hFile;
	bool				m_bIncoming;
	CComBSTR			m_strFileName;
	DWORD				m_dwSizeInBytes;
	CComPtr<INmMember>	m_spSDKMember;
	NM_FT_STATE			m_State;
	DWORD				m_dwBytesTransferred;
	bool				m_bSomeoneCanceled;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmFtObj)

BEGIN_COM_MAP(CNmFtObj)
	COM_INTERFACE_ENTRY(INmFt)
	COM_INTERFACE_ENTRY(IInternalFtObj)
END_COM_MAP()

////////////////////////////////////////////////	
// Construction and destruction

	static HRESULT CreateInstance(
		CNmChannelFtObj* pChannelObj, 
		MBFTEVENTHANDLE hFileEvent,
		MBFTFILEHANDLE hFile,
		bool bIncoming,
		LPCTSTR szFileName,
		DWORD dwSizeInBytes,
		INmMember* pSDKMember,
		INmFt** ppNmFt);

////////////////////////////////////////////////
// INmFt interface

	STDMETHOD(IsIncoming)(void);
	STDMETHOD(GetState)(NM_FT_STATE *puState);
	STDMETHOD(GetName)(BSTR *pbstrName);
	STDMETHOD(GetSize)(ULONG *puBytes);
	STDMETHOD(GetBytesTransferred)(ULONG *puBytes);
	STDMETHOD(GetMember)(INmMember **ppMember);
	STDMETHOD(Cancel)(void);


////////////////////////////////////////////////
// IInternalFtObj interface

	STDMETHOD(GetHEvent)(UINT *phEvent);
	STDMETHOD(OnFileProgress)(UINT hFile, ULONG lFileSize, ULONG lBytesTransmitted);
	STDMETHOD(FileTransferDone)();
	STDMETHOD(OnError)();

};


#endif // __NmFt_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmenum.h ===
#ifndef __NmEnum_h__
#define __NmEnum_h__

// This is used to create IEnumXXX objects for CSimpleArray<CComPtr<XXX> > objects
template <class TEnum, class TItf>
HRESULT CreateEnumFromSimpleAryOfInterface(CSimpleArray<TItf*>& rObjArray, TEnum** ppEnum)
{

	DBGENTRY(CreateEnum);

	HRESULT hr = S_OK;
	typedef CComEnum<TEnum, &__uuidof(TEnum), TItf*, _CopyInterface<TItf> > enum_type;
	
	enum_type* pComEnum = new CComObject< enum_type >;	

	if(pComEnum)
	{
		TItf** apInterface = NULL;

		int nItems = rObjArray.GetSize();
		if(nItems)
		{ 
			apInterface = new TItf*[nItems];

			if(apInterface)
			{
				for(int i = 0; i < rObjArray.GetSize(); ++i)
				{
					hr = rObjArray[i]->QueryInterface(__uuidof(TItf), reinterpret_cast<void**>(&apInterface[i]));
					if(FAILED(hr))
					{
						delete [] apInterface;
						goto end;
					}
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}

		TItf** begin = apInterface;
		TItf** end = apInterface + nItems;

		if(begin == end)
		{
			// Hack to get around ATL bug.
			// The problem is that for empty enums ATL returns E_FAIL for Next instead of S_FALSE
			hr = pComEnum->Init(reinterpret_cast<TItf**>(69), reinterpret_cast<TItf**>(69), NULL, AtlFlagNoCopy);
		}
		else
		{
			hr = pComEnum->Init(begin, end, NULL, AtlFlagTakeOwnership);
		}

		if(SUCCEEDED(hr))
		{
			hr = pComEnum->QueryInterface(__uuidof(TEnum), reinterpret_cast<void**>(ppEnum));
		}

		if(FAILED(hr))
		{
			delete [] apInterface;
		}

	}
	else
	{
		hr = E_NOINTERFACE;
	}
	
	end:
	
	DBGEXIT_HR(CreateEnum,hr);
	return hr;
}

#endif // __NmEnum_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmmanager.h ===
#ifndef __NmManager_h__
#define __NmManager_h__

#include "resource.h"       // main symbols
#include "SDKInternal.h"
#include "ias.h"
#include "iplgxprt.h"
#include "it120xprt.h"

extern bool g_bSDKPostNotifications;


/////////////////////////////////////////////////////////////////////////////
// CNmManagerObj
class ATL_NO_VTABLE CNmManagerObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNmManagerObj, &CLSID_NmManager>,
	public IConnectionPointContainerImpl<CNmManagerObj>,
	public IConnectionPointImpl<CNmManagerObj, &IID_INmManagerNotify, CComDynamicUnkArray>,
	public INmManager,
	public INmObject,
	public INmManagerNotify,
	public IInternalConfExe,
	public IPluggableTransport

{
	friend class CNmConferenceObj;
// Datatypes and constants
	CONSTANT(MSECS_PER_SEC_CPU_USAGE = 900);

// Static Data
	static CSimpleArray<CNmManagerObj*>*	ms_pManagerObjList;
	static DWORD							ms_dwID;

// Member Data
	bool									m_bNmActive;
	bool									m_bInitialized;
	ULONG									m_uOptions;
	ULONG									m_chCaps;
	CSimpleArray<INmConference*>			m_SDKConferenceObjs;
	CSimpleArray<INmCall*>					m_SDKCallObjs;
	CComPtr<INmManager2>					m_spInternalNmManager;
	DWORD									m_dwInternalNmManagerAdvise;
	bool									m_bSentConferenceCreated;
	DWORD									m_dwID;
	DWORD									m_dwSysInfoID;


	CComBSTR	m_bstrConfName;

    static IT120PluggableTransport          *ms_pT120Transport;
	
public:

#ifdef ENABLE_UPDATE_CONNECTION
    static IPluggableTransportNotify        *ms_pPluggableTransportNotify;
#endif

	static HRESULT InitSDK();
	static void CleanupSDK();

// Because this is in a local server, we are not going to be able to be aggregated...
DECLARE_NOT_AGGREGATABLE(CNmManagerObj)

// This is the resource ID for the .rgs file
DECLARE_REGISTRY_RESOURCEID(IDR_NMMANAGER)

BEGIN_COM_MAP(CNmManagerObj)
	COM_INTERFACE_ENTRY(INmManager)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(INmObject)
	COM_INTERFACE_ENTRY(INmManagerNotify)
	COM_INTERFACE_ENTRY(IInternalConfExe)
	COM_INTERFACE_ENTRY(IPluggableTransport)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CNmManagerObj)
	CONNECTION_POINT_ENTRY(IID_INmManagerNotify)
END_CONNECTION_POINT_MAP()


///////////////////////////////////////////////
// Construction and destruction

	CNmManagerObj();
	~CNmManagerObj();

	HRESULT FinalConstruct();
	void FinalRelease();

	ULONG InternalRelease();

///////////////////////////////////////////////
// INmManager

	STDMETHOD(Initialize)( ULONG * puOptions, ULONG * puchCaps);
	STDMETHOD(GetSysInfo)(INmSysInfo **ppSysInfo);
	STDMETHOD(CreateConference)(INmConference **ppConference, BSTR bstrName, BSTR bstrPassword, ULONG uchCaps);
	STDMETHOD(EnumConference)(IEnumNmConference **ppEnum);
	STDMETHOD(CreateCall)(INmCall **ppCall, NM_CALL_TYPE callType,NM_ADDR_TYPE addrType, BSTR bstrAddr, INmConference *pConference);
	STDMETHOD(CallConference)(INmCall **ppCall, NM_CALL_TYPE callType,NM_ADDR_TYPE uType, BSTR bstrAddr, BSTR bstrConferenceName, BSTR bstrPassword);
	STDMETHOD(EnumCall)(IEnumNmCall **ppEnum);

// INmObject
	STDMETHOD(CallDialog)(long hwnd, int cdOptions);
	STDMETHOD(ShowLocal)(NM_APPID id);
	STDMETHOD(VerifyUserInfo)(UINT_PTR hwnd, NM_VUI options);

// IInternalConfExe
	STDMETHOD(LoggedIn)();
	STDMETHOD(IsRunning)();
	STDMETHOD(InConference)();
	STDMETHOD(LDAPLogon)(BOOL bLogon);
	STDMETHOD(GetLocalCaps)(DWORD* pdwLocalCaps);
	STDMETHOD(IsNetMeetingRunning)();
	STDMETHOD(GetActiveConference)(INmConference** ppConf);
	STDMETHOD(ShellCalltoProtocolHandler)(BSTR url, BOOL bStrict);
	STDMETHOD(Launch)();
	STDMETHOD(LaunchApplet)(NM_APPID appid, BSTR strCmdLine);
	STDMETHOD(GetUserData)(REFGUID rguid, BYTE **ppb, ULONG *pcb);
    STDMETHOD(SetUserData)(REFGUID rguid, BYTE *pb, ULONG cb);
	STDMETHOD(SetSysInfoID)(DWORD dwID) { m_dwSysInfoID = dwID; return S_OK; }
	STDMETHOD(DisableH323)(BOOL bDisableH323);
	STDMETHOD(SetCallerIsRTC)(BOOL bCallerIsRTC);
	STDMETHOD(DisableInitialILSLogon)(BOOL bDisableH323);

//
// INmManagerNotify methods:
//
    STDMETHOD(NmUI)(CONFN uNotify);
    STDMETHOD(ConferenceCreated)(INmConference *pInternalConference);
    STDMETHOD(CallCreated)(INmCall *pInternalCall);

//
// IPluggableTransport
//
    STDMETHOD(CreateConnection)(
                    BSTR               *pbstrConnectionID,      // For placing a call and closing connection
                    PLUGXPRT_CALL_TYPE  eCaller,                // Caller or Callee
                    DWORD               dwProcessID,            // Used for DuplicateHandle
                    HCOMMDEV            hCommLink,              // Handle to communications file handle
                    HEVENT              hevtDataAvailable,      // Ready To Read event ( data avail )
                    HEVENT              hevtWriteReady,         // Ready To Write event 
                    HEVENT              hevtConnectionClosed,   // Connection closed ( unexpectedly???) 
                    PLUGXPRT_FRAMING    eFraming,               // framing of bits sent on link
                    PLUGXPRT_PARAMETERS *pParams                // OPTIONAL framing specific parameters
                );

#ifdef ENABLE_UPDATE_CONNECTION
    STDMETHOD(UpdateConnection)(
                    BSTR                bstrConnectionID,
                    DWORD               dwProcessID,            // Used for DuplicateHandle
                    HCOMMDEV            hCommLink               // Handle to communications file handle
                    ); 
#endif

    STDMETHOD(CloseConnection)(BSTR bstrConnectionID); 

    STDMETHOD(EnableWinsock)(void); 

    STDMETHOD(DisableWinsock)(void);

#ifdef ENABLE_UPDATE_CONNECTION
    STDMETHOD(AdvisePluggableTransport)(IPluggableTransportNotify *, DWORD *pdwCookie);

    STDMETHOD(UnAdvisePluggableTransport)(DWORD dwCookie);
#endif

//
// Notifications
//
	HRESULT Fire_NmUI(CONFN uNotify);
    HRESULT Fire_ConferenceCreated(INmConference *pConference);
	HRESULT Fire_CallCreated(INmCall* pCall);


	INmConference* GetSDKConferenceFromInternalConference(INmConference* pInternalConference);
	INmCall* GetSDKCallFromInternalCall(INmCall* pInternalCall);

	HRESULT RemoveCall(INmCall* pSDKCallObj);
	HRESULT RemoveConference(INmConference* pSDKConferenceObj);

	bool AudioNotifications();
	bool VideoNotifications();
	bool DataNotifications();
	bool FileTransferNotifications();
	bool AppSharingNotifications();
	bool OfficeMode() const  { return m_bInitialized && (NM_INIT_OBJECT == m_uOptions); }

	static void NetMeetingLaunched();

	static void AppSharingChannelChanged();
	void _AppSharingChannelChanged();

	static void AppSharingChannelActiveStateChanged(bool bActive);
	void _AppSharingChannelActiveStateChanged(bool bActive);

	static void SharableAppStateChanged(HWND hWnd, NM_SHAPP_STATE state);
	void _SharableAppStateChanged(HWND hWnd, NM_SHAPP_STATE state);

	static void ASLocalMemberChanged();
	void _ASLocalMemberChanged();

	static void ASMemberChanged(UINT gccID);
	void _ASMemberChanged(UINT gccID);

	static void NM211_CONF_NM_STARTED(bool bConfStarted);

	static void AudioChannelActiveState(BOOL bActive, BOOL bIsIncoming);
	void _AudioChannelActiveState(BOOL bActive, BOOL bIsIncoming);

	static void VideoChannelActiveState(BOOL bActive, BOOL bIsIncoming);
	void _VideoChannelActiveState(BOOL bActive, BOOL bIsIncoming);

	static void OnShowUI(BOOL fShow);

	static UINT GetManagerCount() { return ms_pManagerObjList->GetSize(); };
	static UINT GetManagerCount(ULONG uOption);

	static void VideoPropChanged(DWORD dwProp, BOOL bIsIncoming);
	void _VideoPropChanged(DWORD dwProp, BOOL bIsIncoming);

	static void VideoChannelStateChanged(NM_VIDEO_STATE uState, BOOL bIsIncoming);
	void _VideoChannelStateChanged(NM_VIDEO_STATE uState, BOOL bIsIncoming);

private:
///////////////////////////////////////////////
// Helper Fns

	INmConference* _GetActiveConference();

    void EnsureTransportInterface(void);
    static BOOL InitPluggableTransportSDK(void);
    static void CleanupPluggableTransportSDK(void);

	DWORD MapNmCallTypeToCallFlags(NM_CALL_TYPE callType,
				NM_ADDR_TYPE addrType, UINT uCaps);
	HRESULT SdkPlaceCall(NM_CALL_TYPE callType,
						 NM_ADDR_TYPE addrType,
						 BSTR bstrAddr,
						 BSTR bstrConf,
						 BSTR bstrPw,
						 INmCall **ppInternalCall);
};

#endif //__NmManager_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmmember.cpp ===
#include "precomp.h"
#include "confroom.h"

// NetMeeting SDK stuff
#include "SDKInternal.h"
#include "NmConference.h"
#include "NmMember.h"


/////////////////////////////////////////////////////////////////////////
// Construction and Destruction
/////////////////////////////////////////////////////////////////////////




CNmMemberObj::CNmMemberObj(): m_bIsSelf(false)
{
	DBGENTRY(CNmMemberObj::CNmMemberObj);
	DBGEXIT(CNmMemberObj::CNmMemberObj);
}

CNmMemberObj::~CNmMemberObj()
{
	DBGENTRY(CNmMemberObj::~CNmMemberObj);

	DBGEXIT(CNmMemberObj::~CNmMemberObj);
}

//static
HRESULT CNmMemberObj::CreateInstance(CNmConferenceObj* pConfObj, INmMember* pInternalINmMember, INmMember** ppMember)
{
	DBGENTRY(CNmMemberObj::CreateInstance);
	HRESULT hr = E_OUTOFMEMORY;

	CComObject<CNmMemberObj>* p = NULL;
	p = new CComObject<CNmMemberObj>(NULL);

	if (p != NULL)
	{
            CNmMemberObj* pThis = static_cast<CNmMemberObj*>(p);

            pThis->m_spInternalINmMember = pInternalINmMember;
            pThis->m_pConferenceObj = pConfObj;

            pThis->m_bIsSelf = (pInternalINmMember && (S_OK == pInternalINmMember->IsSelf()));

            if(pThis != NULL)
            {
                pThis->SetVoid(NULL);

                // We do this so that we don't accidentally Release out of memory
                ++pThis->m_dwRef;
                hr = pThis->FinalConstruct();
                --pThis->m_dwRef;

                if(hr == S_OK)
                {
                    hr = pThis->QueryInterface(IID_INmMember, reinterpret_cast<void**>(ppMember));
                }
            }
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	if(FAILED(hr))
	{
		delete p;
	}

	DBGEXIT_HR(CNmMemberObj::CreateInstance,hr);
	return hr;
}


/////////////////////////////////////////////////////////////////////////
// INmMember methods
/////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmMemberObj::GetName(BSTR *pbstrName)
{
	DBGENTRY(CNmMemberObj::GetName);
	HRESULT hr = S_OK;
	
	if(m_spInternalINmMember)
	{
		hr = m_spInternalINmMember->GetName(pbstrName);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::GetName,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetID(ULONG * puID)
{
	DBGENTRY(CNmMemberObj::GetID);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		hr = m_spInternalINmMember->GetID(puID);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::GetID,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetNmVersion(ULONG *puVersion)
{
	DBGENTRY(CNmMemberObj::GetNmVersion);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		m_spInternalINmMember->GetNmVersion(puVersion);
	}
	else
	{
		hr = E_UNEXPECTED;
	}


	DBGEXIT_HR(CNmMemberObj::GetNmVersion,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetAddr(BSTR *pbstrAddr, NM_ADDR_TYPE *puType)
{
	DBGENTRY(CNmMemberObj::GetAddr);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		hr = m_spInternalINmMember->GetAddr(pbstrAddr, puType);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::GetAddr,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	DBGENTRY(CNmMemberObj::GetUserData);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		m_spInternalINmMember->GetUserData(rguid, ppb, pcb);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::GetUserData,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetConference(INmConference **ppConference)
{
	DBGENTRY(CNmMemberObj::GetConference);
	HRESULT hr = S_OK;

	if(ppConference)
	{
		hr = E_FAIL;

		if(m_pConferenceObj)
		{
			IUnknown * pUnk = m_pConferenceObj->GetUnknown();
			if(SUCCEEDED(pUnk->QueryInterface(IID_INmConference, reinterpret_cast<void**>(ppConference))))
			{
				hr = S_OK;
			}
		}
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmMemberObj::GetConference,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetNmchCaps(ULONG *puchCaps)
{
	DBGENTRY(CNmMemberObj::GetNmchCaps);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		hr = m_spInternalINmMember->GetNmchCaps(puchCaps);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::GetNmchCaps,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetShareState(NM_SHARE_STATE *puState)
{
	DBGENTRY(CNmMemberObj::GetShareState);
	HRESULT hr = E_POINTER;

	if(puState)
	{		
		ULONG ulGCCId;
		hr = GetID(&ulGCCId);

		if(SUCCEEDED(hr))
		{
			hr = ::GetShareState(ulGCCId, puState);
		}
	}

	DBGEXIT_HR(CNmMemberObj::GetShareState,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::IsSelf(void)
{
	DBGENTRY(CNmMemberObj::IsSelf);
	HRESULT hr = S_OK;

	hr = m_bIsSelf ? S_OK : S_FALSE;

	DBGEXIT_HR(CNmMemberObj::IsSelf,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::IsMCU(void)
{
	DBGENTRY(CNmMemberObj::IsMCU);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		hr = m_spInternalINmMember->IsMCU();
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::IsMCU,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::Eject(void)
{
	DBGENTRY(CNmMemberObj::Eject);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		hr = m_spInternalINmMember->Eject();
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::Eject,hr);
	return hr;
}

/////////////////////////////////////////////////////////////////////////
// IInternalMemberObj methods
/////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNmMemberObj::GetInternalINmMember(INmMember** ppMember)
{
	DBGENTRY(CNmMemberObj::GetInternalINmMember);
	HRESULT hr = S_OK;

	ASSERT(ppMember);

	*ppMember = m_spInternalINmMember;
	(*ppMember)->AddRef();

	DBGEXIT_HR(CNmMemberObj::GetInternalINmMember,hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmldap.h ===
#ifndef __NmLdap_h__
#define __NmLdap_h__

#include <cstring.hpp>
#include	"ldap.h"

class CKeepAlive;


class CNmLDAP
{

private:

	typedef CSTRING string_type;

	enum eState {
		Uninitialized,
		Idle,			// Idle means we are not logged in, or connected
		Binding,		// We are waiting for bind_s to complete in helper thread
		Bound,			// The bind operation is complete
		AddingUser,		// We are waiting for the result to ldap_add
		UserAdded,		// ldap_add completed successfully
		SettingAppInfo, // We are waiting for result to ldap_modify( app attributes )
		ModifyingAttrs,	// We are waiting for result to ldap_modify( some attrs )
		LoggedIn,		// We are logged in to ldap server and m_ldap session is closed ( we are connectionless )
		LoggingOff		// We are waiting for result to ldap_delete
	};

	enum eCurrentOp {
		Op_NoOp,				// We are not in the middle of multi-state operation
		Op_Logon,				// Logon is: ldap_bind, ldap_add, ldap_modify
		Op_Logoff,				// Logoff is ldap_bind, ldap_delete
		Op_Refresh_Logoff,		// Refresh is ldap_bind, ldap_delete, ldap_unbind, Op_Logon
		Op_Modifying_InCallAttr,// Modify in-call attrs is ldap_bind, ldap_modify
	};

	enum eTimerEvent {
		PollForResultTimer = 666,	// This is the timer ID passed to WM_TIMER
		WaitForLogoffTimer
	};

	enum { RESULT_POLL_INTERVAL = 1000 };				// We poll ldap_result for this many milliseconds
	enum { LOGOFF_WAIT_INTERVAL = 5000 };				// Max amound of time we will wait for logof to complete in the destructor...
	
/////////////////////////////////////////////////
/// Data

    CKeepAlive *m_pKeepAlive;

	// This indicates weather we have loaded wldap32.dll and the ldap functions
	static bool ms_bLdapDLLLoaded;
	HWND		m_hWndHidden;			// Hidden window for handling WM_TIMER and custom messages
	eState		m_State;				// The current state we are in
	eCurrentOp	m_CurrentOp;			// The current multi-state operation we are performing
	LDAP*		m_pLdap;				// The current ldap session ( kept for multi-state and multi-state operations )
	INT			m_uMsgID;				// Current async operation message id ( or INVALID_MSG_ID )
	UINT_PTR	m_ResultPollTimer;	    // Timer ID given to us by SetTimer
	UINT_PTR	m_LogoffTimer;			
	HANDLE		m_hEventWaitForLogoffDone;	// We attempt to logoff asynchronously
	HANDLE		m_hBindThread;

	string_type m_strCurrentServer;		// If we are logged in, we are logged in to this server
	string_type m_strCurrentDN;			// If we are logged in, this is our current DN

		// User attributes
	string_type m_strServer;
	string_type m_strSurName;
	string_type m_strGivenName;
	string_type m_strEmailName;
	string_type m_strComment;
	string_type m_strLocation;
	string_type m_strSecurityToken;
	bool		m_bVisible;
	bool		m_bAudioHardware;
	bool		m_bVideoHardware;
	bool		m_bInCall;
	bool		m_bDirty;
	bool		m_bRefreshAfterBindCompletes;
	bool		m_bLogoffAfterBindCompletes;
	bool		m_bSendInCallAttrWhenDone;
	int			m_iPort;

public:

	CNmLDAP();
	~CNmLDAP();

	HRESULT Initialize(HINSTANCE hInst);				// Initialize the CNmLDAP object
	HRESULT LogonAsync(LPCTSTR pcszServer = NULL);		// Logon to the specified server ( or default if NULL )
	HRESULT Logoff();									// Logoff from the current surver
	HRESULT OnSettingsChanged();						// Refresh our information on the server
	HRESULT OnCallStarted();							// Update server information about our call state
	HRESULT OnCallEnded();								// Update server information about our call state
	bool IsLoggedOn() const;							// Are we logged on?
	bool IsLoggingOn() const;							// Are we logged on?
	bool IsBusy() const;								// Are we in the middle of an async operation?
	HRESULT GetStatusText(LPTSTR psz, int cch, UINT *idIcon=NULL) const;	// Status text for status bar for example

	// Static fns used for resolving users, etc.
	static HRESULT ResolveUser(LPCTSTR pcszName, LPCTSTR pcszServer, LPTSTR pszIPAddr, DWORD cchMax, int port = DEFAULT_LDAP_PORT);
	static bool IsInitialized() { return ms_bLdapDLLLoaded; }

private:

		// Window Procedure and helpers
	LRESULT WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	static LRESULT _sWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	static DWORD _sAsyncBindThreadFn(LPVOID lpParameter);

	void _AddUser();
	void _DeleteUser();
	void _SetAppInfo();
	void _ModifyInCallAttr();
	HRESULT _BindAsync();
	HRESULT _bCallChangedHelper();
	HRESULT _GetUserSettingsFromRegistryAndGlobals();
	void _OnLoggedOn();
	void _OnLoggedOff();
	void _OnLoggingOn();
	void _OnLoggingOff();
	void _AbandonAllAndSetState(eState new_state);
	void _AbandonAllAndSetToIdle() { _AbandonAllAndSetState(Idle); }
    void _AbandonAllAndRecoverState(void) { _AbandonAllAndSetState((ModifyingAttrs == m_State && NULL != m_pKeepAlive) ? LoggedIn : Idle); }
    void _AbandonAllAndRecoverState(eCurrentOp op) { _AbandonAllAndSetState((Op_Modifying_InCallAttr == op && NULL != m_pKeepAlive) ? LoggedIn : Idle); }

	void _MakeStatusText(UINT uResID, LPTSTR psz, UINT cch) const;
	HRESULT _InternalLogoff(bool bRefreshLogoff);
	HRESULT _RefreshServer();
	void _OnAddingUserResult(int Result);
	void _OnSettingAppInfoOrModifyingAttrsResult(int Result);
	void _OnLoggingOffResult(int Result);
	void _OnUserBindComplete(INT LdapResult, DWORD LastError );
	void _OnTimer(UINT_PTR TimerID);
	void _GetIpAddressOfLdapSession( LPTSTR szIpAddr, int cchMax, DWORD *pdwIPAddr );

	static HRESULT _LoadLdapDLL();

    HRESULT OnReLogon(void);
};


void InitNmLdapAndLogon();

extern CNmLDAP* g_pLDAP;
extern CPing*	g_pPing;





enum { INITIAL_REFRESH_INTERVAL_MINUTES = 2 };		// Initial time before we send a message to the server to reset the TTL
enum { MIN_REFRESH_TIMEOUT_INTERVAL_MINUTES = 1 };	// Minimum timeout interval
enum { REFRESH_TIMEOUT_MARGIN = 2 };				// We send a refresh REFRESH_TIMEOUT_MARGIN minutes before the server TTL

enum { PING_TIMEOUT_INTERVAL = (10 * 1000) };		
enum { PING_RETRIES = 9 };

enum { LDAP_TIMEOUT_IN_SECONDS = 45 };


class CKeepAlive
{
    friend DWORD KeepAliveThreadProc(LPVOID);

public:

    // called in the main thread
    CKeepAlive(BOOL *pfRet, HWND hwndMainThread,
               DWORD dwLocalIPAddress,
               const TCHAR * const pcszServerName, UINT nPort,
               LPTSTR pszKeepAliveFilter);

    BOOL Start(void);
    BOOL End(BOOL fSync = FALSE);

protected:

    // called in the worker thread
    ~CKeepAlive(void);
    BOOL SetServerIPAddress(void);
    DWORD GetLocalIPAddress(LDAP *ld);
    BOOL Ping(void);
    BOOL Bind(LDAP *ld);
    BOOL KeepAlive(LDAP *ld, UINT *pnRefreshInterval);
    DWORD GetLocalIPAddress(void) { return m_dwLocalIPAddress; }
    void SetLocalIPAddress(DWORD dwLocalIPAddress) { m_dwLocalIPAddress = dwLocalIPAddress; }
    LPTSTR GetServerName(void) { return m_pszServerName; }
    DWORD GetServerIPAddress(void) { return m_dwServerIPAddress; }
    UINT GetServerPortNumber(void) { return m_nPort; }
    void UpdateIPAddressOnServer(void);

private:

    // called in the worker thread
    void GetNewInterval(LDAP *ld, LDAPMessage *pMsg, UINT *pnRefreshInternval);
    void ReLogon(void);

private:

    HWND        m_hwndMainThread;
    DWORD       m_dwLocalIPAddress;
    DWORD       m_dwServerIPAddress;
    LPTSTR      m_pszServerName;
    UINT        m_nPort;
    LPTSTR      m_pszKeepAliveFilter;
    HANDLE      m_hThread;
    DWORD       m_dwThreadID;
    BOOL        m_fAborted;
};


#endif // __NmLdap_h__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmldap.cpp ===
#include "precomp.h"
#include "resource.h"
#include "pfnwldap.h"
#include "conf.h"
#include "cr.h"
#include <cstring.hpp>
#include <ulsreg.h>
#include "NmLdap.h"
#include "version.h"
#include "call.h"
#include "confapi.h"
#include "confutil.h"
#include "dirutil.h"

// One global instance
CNmLDAP* g_pLDAP = NULL;
CPing*	 g_pPing = NULL;


// This flag indicates weather or not we have loaded the LDAP dll ( WLDAP::Init() )
/*static*/ bool CNmLDAP::ms_bLdapDLLLoaded = false;

////////////////////////////////////////////////////////////////////////////////////////
// Helper Macros

// the ldap_modify function takes an LDAPMod** type
// If it took an array of LDAPMod ( an LDAPMod* type )
// Then life would be easier for us to make static lists
// Unfortunately, this is not how it works, so we have macros
// to pretty things up ( and hopefully not to confuse anyone )

// This is to declare an LDAPMod with one val
#define DECLARE_LDAP_MOD( t, x, y )\
	LPTSTR aVals_##x[] = { y, NULL };\
	LDAPMod LDAPMod_##x = { t, _T(#x), aVals_##x }

// This is to declare an LDAPMod with 2 vals
#define DECLARE_LDAP_MOD2( t, x, y1, y2 )\
	LPTSTR aVals_##x[] = { y1, y2, NULL };\
	LDAPMod LDAPMod_##x = { t, _T(#x), aVals_##x }

#define LDAP_MOD_ENTRY( x ) &LDAPMod_##x
#define LDAP_MOD_ADD_ENTRY( x ) &LDAPMod_add_##x

////////////////////////////////////////////////////////////////////////////////////////
// Some helpful deffinitions

#define LDAP_REFRESH_BASE_DN		_T("objectClass=RTPerson")
#define RESOLVE_USER_SEARCH_FILTER	_T("(&(objectClass=RTPerson)(cn=%s))")


//NOTE: The LDAP_REFRESH_FILTER... notice the sttl=10... aparently, this is how you request the
// server to restart the TTL countdown... the sttl= value can be anything BUT '*' ( the value you would
// expecte it to be... ) This is a link to the "Dynamir Ldap Extension RFC" if you want more info
// http://www.critical-angle.com/ldapworld/draft-ietf-asid-ldapv3ext-04.txt

#define LDAP_REFRESH_FILTER			_T("(&(objectClass=RTPerson)(cn=%s)(sttl=10))")


#define LOGIN_USER_FILTER			_T("c=-,o=Microsoft,cn=%s,objectClass=RTPerson")
#define IP_ADDRESS_ATTR_NAME		_T("sipaddress")
#define STTL_ATTR_NAME				_T("sttl")
#define CNmLDAP_WCNAME				_T("CNmLDAP_WCNAME")

#define LDAP_MODOP_ADDAPP			_T("0")
#define LDAP_MODOP_DELETEAPP		_T("1")
#define LDAP_MODOP_MODIFYUSER		_T("2")
#define LDAP_MODOP_MODIFYAPP		_T("3")

#define LDAP_ATTR_FALSE				_T("0")
#define LDAP_ATTR_TRUE				_T("1")
#define LDAP_ATTR_BUSINESS			_T("2")

	// We are not using the country name anymore, but we can't leave the country
	// field blank ( empty string ), it is just the way that SiteServer is written...
#define LDAP_ATTR_DUMMY_COUNTRYNAME	_T("-")

#define INVALID_MSG_ID				((ULONG) -1)	// same as ldap_****()
#define LDAP_RESULT_ERROR			((ULONG) -1)	
#define LDAP_RESULT_TIMEOUT         0

	// When the bind helper thread function gets the result to bind_s function
	// it passes it to this thread via PostMessage( m_hWndHidder, WM_USER_BIND_COMPLETE, ret, err )
#define WM_USER_BIND_COMPLETE		(WM_APP + 1) // wParam = Return code from bind_s, lParam = GetLastError()
#define WM_NEED_RELOGON             (WM_APP + 2)


CNmLDAP::CNmLDAP()
: m_State(Uninitialized),
  m_pKeepAlive(NULL),
  m_hWndHidden(NULL),
  m_pLdap(NULL),
  m_ResultPollTimer(0),
  m_LogoffTimer(0),
  m_uMsgID(INVALID_MSG_ID),
  m_CurrentOp(Op_NoOp),
  m_bVisible(true),
  m_bDirty(false),
  m_bRefreshAfterBindCompletes(false),
  m_bLogoffAfterBindCompletes(false),
  m_bSendInCallAttrWhenDone(false),
  m_bInCall(false),
  m_hEventWaitForLogoffDone(NULL),
  m_hBindThread(NULL),
  m_iPort(DEFAULT_LDAP_PORT),
  m_bAudioHardware(false),
  m_bVideoHardware(false)


{
	DBGENTRY(CNmLDAP::CNmLDAP);

	SetLoggedOn( false );

	DBGEXIT(CNmLDAP::CNmLDAP);
}

CNmLDAP::~CNmLDAP()
{
	DBGENTRY(CNmLDAP::~CNmLDAP);

    if (NULL != m_pKeepAlive)
    {
        m_pKeepAlive->End(TRUE); // synchronous end
        m_pKeepAlive = NULL;
    }

	if((m_State != Idle) && (m_State != Uninitialized))
	{
			// Make sure that someone at least has already called Logoff()
		ASSERT((LoggingOff == m_State) || (Op_Logoff == m_CurrentOp));

			// We are logging off, but we would like to wait a while to make sure that
			// all of our async operations are completed... We don't want to wait too long,
			// Though... Basically we set a timer to pass a message to us... if we get that
			// message, we signal m_hEventWaitForLogoffDone....  if any of the async operations
			// complete during this time, they will also signal this event....We make sure to
			// hawe a message loop ( AtlWaitWithWessageLoop ) so that our wndproc will be called
		m_hEventWaitForLogoffDone = CreateEvent(NULL,TRUE,FALSE,NULL);

		if(m_hEventWaitForLogoffDone)
		{
			m_LogoffTimer = ::SetTimer(m_hWndHidden, WaitForLogoffTimer, LOGOFF_WAIT_INTERVAL, NULL);
			if(m_LogoffTimer)
			{
				AtlWaitWithMessageLoop(m_hEventWaitForLogoffDone);
			}

			CloseHandle(m_hEventWaitForLogoffDone);
			m_hEventWaitForLogoffDone = NULL;
		}
		else
		{
			ERROR_OUT(("Create Event failed"));
		}

		if( Binding == m_State )
		{
			WARNING_OUT(("Aborting an ldap_bind because we are closing down in ~CNmLDAP"));
			TerminateThread(m_hBindThread, 0);				
			CloseHandle(m_hBindThread);
		}
		else if(Idle != m_State)
		{
			WARNING_OUT(("Aborting pending LDAP operation in ~CNmLDAP"));
			_AbandonAllAndSetToIdle();
		}
	}

	if( NULL != m_hWndHidden )
	{
		DestroyWindow( m_hWndHidden );
		m_hWndHidden = NULL;
	}

	m_State = Uninitialized;

	SetLoggedOn( false );

	DBGEXIT(CNmLDAP::~CNmLDAP);
}

HRESULT CNmLDAP::_bCallChangedHelper()
{
TRACE_OUT(("CNmLDAP::_bCallChangedHelper:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_OK;

	if( IsLoggedOn() || IsBusy() )
	{
		if(LoggedIn == m_State)
		{	
				// We simply have to bind and call ldap_modify
			m_CurrentOp = Op_Modifying_InCallAttr;
			hr = _BindAsync();
		}
		else if((SettingAppInfo == m_State) ||
				(ModifyingAttrs == m_State) ||
				(AddingUser == m_State)
			   )
		{
			// the other states will be calling ldap_mod( user Attributes ) which will pick up
			// the change to m_bInCall. The states listed above are the ones that occur after
			// the user attributes have been sent to the server... There are  also other states
			// that logoff, so they don't care about sending the update to the user attribute to the server
			m_bSendInCallAttrWhenDone = true;
		}
	}

TRACE_OUT(("CNmLDAP::_bCallChangedHelper:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	return hr;
}

HRESULT CNmLDAP::OnCallStarted()
{

	DBGENTRY(CNmLDAP::OnCallStarted);
TRACE_OUT(("CNmLDAP::OnCallStarted:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_OK;

	ASSERT(ms_bLdapDLLLoaded);

	if( !m_bInCall )
	{
		m_bInCall = true;
		hr = _bCallChangedHelper();
	}

TRACE_OUT(("CNmLDAP::OnCallStarted:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::OnCallStarted,hr);
	return hr;
}

HRESULT CNmLDAP::OnCallEnded()
{
	DBGENTRY(CNmLDAP::OnCallEnded);
TRACE_OUT(("CNmLDAP::OnCallEnded:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_OK;

	ASSERT(ms_bLdapDLLLoaded);

	if( m_bInCall )
	{
		m_bInCall = false;
		hr = _bCallChangedHelper();
	}

TRACE_OUT(("CNmLDAP::OnCallEnded:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::OnCallEnded,hr);
	return hr;
}


bool CNmLDAP::IsLoggedOn() const
{
	DBGENTRY(CNmLDAP::IsLoggedOn);
TRACE_OUT(("CNmLDAP::IsLoggedOn:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	
	bool bRet =   ( ( LoggedIn == m_State )					||
					( ModifyingAttrs == m_State )			||
					( Op_Refresh_Logoff == m_CurrentOp )	||
					( Op_Modifying_InCallAttr == m_CurrentOp )
				  );

TRACE_OUT(("CNmLDAP::IsLoggedOn:exit(%d):   m_State:%d:   m_currentOp:%d", bRet, m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::IsLoggedOn);

	return bRet;
}

bool CNmLDAP::IsLoggingOn() const
{
	DBGENTRY(CNmLDAP::IsLoggingOn);
TRACE_OUT(("CNmLDAP::IsLoggingOn:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	bool bRet = ( ( AddingUser == m_State )		||
				  ( UserAdded == m_State )		||
				  ( SettingAppInfo == m_State ) ||
				  ( Op_Logon == m_CurrentOp )
				);

TRACE_OUT(("CNmLDAP::IsLoggingOn:exit(%d):   m_State:%d:   m_currentOp:%d", bRet, m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::IsLoggingOn);

	return bRet;
}

bool CNmLDAP::IsBusy() const
{
	DBGENTRY(CNmLDAP::IsBusy);
TRACE_OUT(("CNmLDAP::IsBusy:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	
	bool bRet = !((LoggedIn == m_State) || ( Idle == m_State ) || (Uninitialized == m_State));

TRACE_OUT(("CNmLDAP::IsBusy:exit(%d):   m_State:%d:   m_currentOp:%d", bRet, m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::IsBusy);

	return bRet;
}


void CNmLDAP::_MakeStatusText(UINT uResID, LPTSTR psz, UINT cch) const
{
	const TCHAR * const	server = CDirectoryManager::get_displayName( m_strCurrentServer );

	USES_RES2T;
	LPCTSTR pszFmt = RES2T(uResID);
	LPTSTR pszStr = new TCHAR[(lstrlen(pszFmt) + lstrlen(server) - 1)];
	if(pszStr)
	{
		wsprintf(pszStr, pszFmt, server);
		lstrcpyn(psz, pszStr, cch);
   		delete [] pszStr;
	}
}


HRESULT CNmLDAP::GetStatusText(LPTSTR psz, int cch, UINT *idIcon ) const
{
	DBGENTRY(CNmLDAP::GetStatusText);

	UINT idDummy;
	if (NULL == idIcon)
	{
		// Just so we don't need to do switches all over the place
		idIcon = &idDummy;
	}

	HRESULT hr = S_OK;

	TRACE_OUT(("m_State = %d", m_State));
TRACE_OUT(("CNmLDAP::GetStatusText:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	if(psz)
	{
		if( cch > 1 )
		{
			USES_RES2T
			switch(m_State)
			{
				case LoggedIn:
				case ModifyingAttrs:
					*idIcon = IDI_NET;
					_MakeStatusText(ID_STATUS_LOGGEDON_FORMAT, psz, cch);
					break;

				case Binding:
				{
					switch(m_CurrentOp)
					{
						case Op_Logon:
							*idIcon = IDS_STATUS_WAITING;
							_MakeStatusText(ID_STATUS_LOGON_FORMAT, psz, cch);
							break;

						case Op_Modifying_InCallAttr:
							*idIcon = IDI_NET;
							_MakeStatusText(ID_STATUS_LOGGEDON_FORMAT, psz, cch);
							break;
							
						case Op_Refresh_Logoff:
							if( lstrcmpi(m_strServer,m_strCurrentServer))
							{
								*idIcon = IDS_STATUS_WAITING;
								_MakeStatusText(ID_STATUS_LOGOFF_FORMAT, psz, cch);
							}
							else
							{
								*idIcon = IDI_NET;
								_MakeStatusText(ID_STATUS_LOGGEDON_FORMAT, psz, cch);
							}
							break;

						case Op_Logoff:
							*idIcon = IDI_NETGRAY;
							lstrcpyn(psz, RES2T(ID_STATUS_LOGGEDOFF), cch);
							break;
					}
					break;
				}

				case AddingUser:
				case UserAdded:
				case SettingAppInfo:
					*idIcon = IDS_STATUS_WAITING;
					_MakeStatusText(ID_STATUS_LOGON_FORMAT, psz, cch);
					break;


				case LoggingOff:
					*idIcon = IDS_STATUS_WAITING;
					_MakeStatusText(ID_STATUS_LOGOFF_FORMAT, psz, cch);
					break;
				
				case Bound:					
				case Idle:
				case Uninitialized:
					*idIcon = IDI_NETGRAY;
					lstrcpyn(psz, RES2T(ID_STATUS_LOGGEDOFF), cch);
					break;

				default:
					ERROR_OUT(("Not a regognized state: %d", m_State));
					break;
			}

		}
		else
		{
			hr = E_INVALIDARG;
		}
	}
	else
	{
		hr = E_POINTER;
	}



TRACE_OUT(("CNmLDAP::GetStatusText:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::GetStatusText,hr);
	return hr;
}

HRESULT CNmLDAP::OnSettingsChanged()
{
	DBGENTRY(CNmLDAP::OnSettingsChanged);
TRACE_OUT(("CNmLDAP::OnSettingsChanged:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_OK;
	ASSERT(ms_bLdapDLLLoaded);

	if(S_OK == _GetUserSettingsFromRegistryAndGlobals())
	{
        hr = OnReLogon();
	}

TRACE_OUT(("CNmLDAP::OnSettingsChanged:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::OnSettingsChanged,hr);
	return hr;
}

HRESULT CNmLDAP::OnReLogon(void)
{
    HRESULT hr = S_OK;
    ASSERT(ms_bLdapDLLLoaded);

	m_bDirty = true;

	if(IsLoggedOn() || IsBusy())
	{
		hr = _RefreshServer();
	}

    return hr;
}

HRESULT CNmLDAP::_RefreshServer()
{
	DBGENTRY(CNmLDAP::_RefreshServer);
TRACE_OUT(("CNmLDAP::_RefreshServer:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_OK;

	ASSERT(ms_bLdapDLLLoaded);

	if( m_bDirty )
	{
		if(Binding == m_State)
		{
			if(Op_Logon == m_CurrentOp) // we are logging on and haven't sent any user information yet
			{	
				// Check to see if we have not changed the server name
				if( !lstrcmpi(m_strServer, CDirectoryManager::get_defaultServer() ) )
				{
						// Simply update the user settings
					_GetUserSettingsFromRegistryAndGlobals();
				}
				else
				{	
						// Since the server has changed, we have to do a logoff(from old)/logon(to new)
					_InternalLogoff(true);
				}
			}
			else if(m_CurrentOp != Op_Logoff)
			{
					// If we are in the middle of a bind operation, which happens
					// in another thread, we just have to wait for it to complete
					// before we go any further
				m_bRefreshAfterBindCompletes = true;
			}
		}
		else if(Idle == m_State)
		{
			_GetUserSettingsFromRegistryAndGlobals();
			LogonAsync();
		}
		else
		{
			_InternalLogoff(true);
		}
	}

TRACE_OUT(("CNmLDAP::_RefreshServer:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::_RefreshServer,hr);
	return hr;
}

void CNmLDAP::_AbandonAllAndSetState(eState new_state)
{
TRACE_OUT(("CNmLDAP::_AbandonAllAndSetState:enter:   new_state=%d,  m_State:%d:   m_currentOp:%d", new_state, m_State, m_CurrentOp));
	if(m_ResultPollTimer)
	{
		::KillTimer(m_hWndHidden,m_ResultPollTimer);
		m_ResultPollTimer = 0;
	}

	if(m_pLdap)
	{		
		if( INVALID_MSG_ID != m_uMsgID )
		{
			WLDAP::ldap_abandon(m_pLdap, m_uMsgID);			
		}
	
		WLDAP::ldap_unbind(m_pLdap);
	}
	m_pLdap = NULL;
	m_uMsgID = INVALID_MSG_ID;
	m_State = new_state;
	m_CurrentOp	= Op_NoOp;

	SetLoggedOn( IsLoggedOn() );
TRACE_OUT(("CNmLDAP::_AbandonAllAndSetState:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
}


HRESULT CNmLDAP::_InternalLogoff(bool bRefreshLogoff)
{
	DBGENTRY(CNmLDAP::_InternalLogoff);
TRACE_OUT(("CNmLDAP::_InternalLogoff:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_OK;

	ASSERT(ms_bLdapDLLLoaded);

	if( ( LoggingOff != m_State ) && ( Idle != m_State ) )
	{
		if(bRefreshLogoff)
		{
			m_CurrentOp = Op_Refresh_Logoff;

				// If the server names are different, this means
				// that we should display "logging off" XXX
			if( lstrcmpi(m_strServer, m_strCurrentServer) )
			{
				_OnLoggingOff();
			}
		}
		else
		{	
			_OnLoggingOff();
			m_CurrentOp = Op_Logoff;
		}

		if( LoggedIn == m_State )
		{
			hr = _BindAsync();
		}
		else if( Binding == m_State )
		{
			m_bLogoffAfterBindCompletes = true;
		}
		else if( (INVALID_MSG_ID != m_uMsgID ) && (NULL != m_pLdap ))
		{
				// Kill the timer
			ASSERT(m_ResultPollTimer);	
			::KillTimer(m_hWndHidden,m_ResultPollTimer);
			m_ResultPollTimer = 0;
			
				// Abandon the current op
			WLDAP::ldap_abandon(m_pLdap, m_uMsgID);		
			m_uMsgID = INVALID_MSG_ID;
			m_State = Bound;

			SetLoggedOn( IsLoggedOn() );
		}

		if(Bound == m_State)
		{
			ASSERT(m_pLdap);
			_DeleteUser();
		}

	}

TRACE_OUT(("CNmLDAP::_InternalLogoff:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::_InternalLogoff,hr);
	return hr;
}
HRESULT CNmLDAP::Logoff()
{
	DBGENTRY(CNmLDAP::Logoff);
TRACE_OUT(("CNmLDAP::Logoff:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	HRESULT hr = _InternalLogoff(false);

TRACE_OUT(("CNmLDAP::Logoff:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::Logoff,hr);

	return hr;
}

HRESULT CNmLDAP::Initialize( HINSTANCE hInst )
{
	HRESULT hr = S_OK;
	DBGENTRY(CNmLDAP::Initialize);
TRACE_OUT(("CNmLDAP::Initialize:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	ASSERT( Uninitialized == m_State );

	if( ms_bLdapDLLLoaded || SUCCEEDED( hr = WLDAP::Init()))
	{
		ms_bLdapDLLLoaded = true;
		
////////////////////////////////////////
// Initialize user data
		_GetUserSettingsFromRegistryAndGlobals();

////////////////////////////////////////
// Initialize hidden Window


		WNDCLASS wcHidden =
		{
			0L,
			_sWndProc,
			0,
			0,
			hInst,
			NULL,
			NULL,
			NULL,
			NULL,
			CNmLDAP_WCNAME
		};
		
		if(RegisterClass(&wcHidden))
		{
			m_hWndHidden = ::CreateWindow( CNmLDAP_WCNAME, g_szEmpty, 0, 0, 0, 0, 0, NULL, NULL, hInst, this);

			if( m_hWndHidden )
			{
				m_State = Idle;
				SetLoggedOn( IsLoggedOn() );
			}
			else
			{
				hr = HRESULT_FROM_WIN32(GetLastError());	
			}
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		ERROR_OUT(("WLDAP::Init failed ( could not load wldap32.dll? )"));
	}

TRACE_OUT(("CNmLDAP::Initialize:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::Initialize,hr);

	return hr;	
}

HRESULT CNmLDAP::_GetUserSettingsFromRegistryAndGlobals()
{
	DBGENTRY(CNmLDAP::_GetUserSettingsFromRegistryAndGlobals);
TRACE_OUT(("CNmLDAP::_GetUserSettingsFromRegistryAndGlobals:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_FALSE;	// this would indicate that nothing changed

	RegEntry reULS(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);

	if(lstrcmpi(m_strSurName, reULS.GetString(ULS_REGKEY_LAST_NAME)))
	{
		hr = S_OK;
		m_strSurName = reULS.GetString(ULS_REGKEY_LAST_NAME);
	}

	if(lstrcmpi(m_strGivenName, reULS.GetString(ULS_REGKEY_FIRST_NAME)))
	{
		hr = S_OK;
		m_strGivenName = reULS.GetString(ULS_REGKEY_FIRST_NAME);
	}

	if(lstrcmpi(m_strEmailName, reULS.GetString(REGVAL_ULS_EMAIL_NAME)))
	{
		hr = S_OK;
		m_strEmailName = reULS.GetString(REGVAL_ULS_EMAIL_NAME);
	}

	if(lstrcmpi(m_strComment, reULS.GetString(ULS_REGKEY_COMMENTS)))
	{
		hr = S_OK;
		m_strComment = reULS.GetString(ULS_REGKEY_COMMENTS);
	}

	if(lstrcmpi(m_strLocation, reULS.GetString(ULS_REGKEY_LOCATION)))
	{
		hr = S_OK;
		m_strLocation = reULS.GetString(ULS_REGKEY_LOCATION);
	}

	if(lstrcmpi(m_strSecurityToken, reULS.GetString(ULS_REGKEY_CLIENT_ID)))
	{
		hr = S_OK;
		m_strSecurityToken = reULS.GetString(ULS_REGKEY_CLIENT_ID);
	}


	if(*m_strSecurityToken == '\0')
	{	// The string was not found...

			// When we log onto the LDAP server, we pass a fairly unique ID
			// This is passed as the value to the ssecurity attribute
			// In the case that NetMeeting goes away without actually logging
			// off of the ILS server, when NetMeeting tries to log back on,
			// it will pass this unique ID... if the server has not closed the
			// session account for the user, the server uses this ID to "authenticate"
			// that we are the same user as the last session...
		TCHAR szNewClientID[MAX_PATH];
		wsprintf(szNewClientID,"%lu", ::GetTickCount());
		m_strSecurityToken = szNewClientID;
		reULS.SetValue(ULS_REGKEY_CLIENT_ID,szNewClientID);
		hr = S_OK;
	}

	if( lstrcmpi(m_strServer, CDirectoryManager::get_defaultServer()))
	{
		hr = S_OK;
		m_strServer = CDirectoryManager::get_defaultServer();
		m_iPort = DEFAULT_LDAP_PORT;
	}


	if(m_bVisible != (!reULS.GetNumber(ULS_REGKEY_DONT_PUBLISH, REGVAL_ULS_DONT_PUBLISH_DEFAULT)))
	{
		m_bVisible = !reULS.GetNumber(ULS_REGKEY_DONT_PUBLISH, REGVAL_ULS_DONT_PUBLISH_DEFAULT);
		hr = S_OK;
	}

	if(m_bAudioHardware != (0 != (g_uMediaCaps & CAPFLAG_SEND_AUDIO)))
	{
		m_bAudioHardware = (0 != (g_uMediaCaps & CAPFLAG_SEND_AUDIO));
		hr = S_OK;
	}

	if(m_bVideoHardware != (0 != (g_uMediaCaps & CAPFLAG_SEND_VIDEO)))
	{
		m_bVideoHardware = (0 != (g_uMediaCaps & CAPFLAG_SEND_VIDEO));
		hr = S_OK;
	}
	
TRACE_OUT(("CNmLDAP::_GetUserSettingsFromRegistryAndGlobals:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::_GetUserSettingsFromRegistryAndGlobals,hr);
	return hr;
}


HRESULT CNmLDAP::LogonAsync( LPCTSTR pcszServer /*=NULL*/)
{
	HRESULT hr = S_OK;
	DBGENTRY(CNmLDAP::LogonAsync);
TRACE_OUT(("CNmLDAP::LogonAsync:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

//		Idle						// Normal logon
		//Binding					
//			Op_Logoff				// Change it to logon refresh
//		Bound						// ldap_umbind-> Logon normal
//		LoggingOff					// Change to Op_Refresh_Logoff
//		Uninitialized		// return error
//		AddingUser					// do nothing
//		UserAdded					// do nothing
//		SettingAppInfo				// do nothing
//		ModifyingAttrs				// do nothing
//		LoggedIn					// do nothing
//		Op_Refresh_Logoff		// Do nothing
//		Op_Modifying_InCallAttr	// Do Nothing
//		Op_Logon				// Do Nothing

	if( Uninitialized != m_State)
	{
		if(Bound == m_State)
		{
			_AbandonAllAndSetToIdle();
		}

		if(Idle == m_State)
		{
			if(pcszServer)
			{
				m_strServer = pcszServer;
				m_iPort = DEFAULT_LDAP_PORT;
			}
			else
			{
				if(!IsLoggedOn())
				{
					_GetUserSettingsFromRegistryAndGlobals();
				}
			}

			m_strCurrentServer = m_strServer;

			g_pCCallto->SetIlsServerName( m_strCurrentServer );

			TCHAR* szDN = new TCHAR[ lstrlen( LOGIN_USER_FILTER ) + lstrlen(m_strEmailName) + 1 ];
			if( szDN )
			{
				wsprintf(szDN, LOGIN_USER_FILTER, (LPCTSTR) m_strEmailName);
				m_strCurrentDN = szDN;

				delete [] szDN;

				m_CurrentOp = Op_Logon;
				hr = _BindAsync();
				if( SUCCEEDED(hr) )
				{
					_OnLoggingOn();
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
		else if((Op_Logoff == m_CurrentOp) || (LoggingOff == m_State))
		{
				m_CurrentOp = Op_Refresh_Logoff;
		}
	}
	else
	{
		hr = E_FAIL;
	}

TRACE_OUT(("CNmLDAP::LogonAsync:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::LogonAsync,hr);
	return hr;
}

HRESULT CNmLDAP::_BindAsync()
{
	DBGENTRY(CNmLDAP::_BindAsync);
TRACE_OUT(("CNmLDAP::_BindAsync:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	ASSERT(( LoggedIn == m_State ) || ( Idle == m_State ));
	ASSERT( m_CurrentOp != Op_NoOp );
	ASSERT(m_hBindThread == NULL);

	HRESULT hr = S_OK;

		// Set our state to Binding
	m_State = Binding;
	SetLoggedOn( IsLoggedOn() );

		// Start the bind in another thread
	DWORD dwBindThreadID = 0;
	m_hBindThread = CreateThread(NULL, 0, _sAsyncBindThreadFn, this, 0, &dwBindThreadID);

	if(NULL == m_hBindThread)
	{
		ERROR_OUT(("CreateThread failed"));
		hr = HRESULT_FROM_WIN32(GetLastError());
		WLDAP::ldap_unbind(m_pLdap);
		m_pLdap = NULL;
		m_CurrentOp = Op_NoOp;
		m_State = Idle;
	}

	SetLoggedOn( IsLoggedOn() );

TRACE_OUT(("CNmLDAP::_BindAsync:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::_BindAsync,hr);
	return hr;
}


/*static*/
DWORD CNmLDAP::_sAsyncBindThreadFn(LPVOID lpParameter)
{

	DBGENTRY(CNmLDAP::_sAsyncBindThreadFn);

	ASSERT(lpParameter);

	CNmLDAP* pThis = reinterpret_cast<CNmLDAP*>(lpParameter);
	ASSERT(pThis);
	ULONG ulRet = LDAP_OPERATIONS_ERROR;
	ULONG ulErr = ERROR_INVALID_HANDLE;
	if( pThis )
	{		
		WSADATA	wsaData;

		if( WSAStartup( 0x0101, &wsaData ) == 0 )
		{
			if( wsaData.wVersion > 1 )
			{
				pThis->m_pLdap = WLDAP::ldap_init( const_cast<LPTSTR>((LPCTSTR)pThis->m_strCurrentServer), pThis->m_iPort );

				if( pThis->m_pLdap )
				{
					::SetLastError(NO_ERROR);
					ulRet = WLDAP::ldap_bind_s(pThis->m_pLdap, const_cast<LPTSTR>(g_szEmpty), const_cast<LPTSTR>(g_szEmpty), LDAP_AUTH_SIMPLE );

					if( ulRet == LDAP_SUCCESS )
					{
						ulErr = ::GetLastError();
						::SendMessage(pThis->m_hWndHidden, WM_USER_BIND_COMPLETE, ulRet, ulErr);
					}
					else if( pThis->m_iPort == DEFAULT_LDAP_PORT )
					{
						WLDAP::ldap_unbind( pThis->m_pLdap );
						pThis->m_pLdap = WLDAP::ldap_init( const_cast<LPTSTR>((LPCTSTR)pThis->m_strCurrentServer), ALTERNATE_LDAP_PORT);		//	Automatically retry with alternate port...

						if( pThis->m_pLdap != NULL )
						{
							::SetLastError(NO_ERROR);
							ulRet = WLDAP::ldap_bind_s(pThis->m_pLdap, const_cast<LPTSTR>(g_szEmpty), const_cast<LPTSTR>(g_szEmpty), LDAP_AUTH_SIMPLE );

							if( ulRet == LDAP_SUCCESS )
							{
								pThis->m_iPort = ALTERNATE_LDAP_PORT;
							}

							ulErr = ::GetLastError();
							::SendMessage(pThis->m_hWndHidden, WM_USER_BIND_COMPLETE, ulRet, ulErr);
						}		
						else
						{
							TRACE_OUT(("ldap_init failed"));
							pThis->m_State = Idle;
							pThis->m_CurrentOp = Op_NoOp;
						}
					}
				}
				else
				{
					TRACE_OUT(("ldap_init failed"));
					pThis->m_State = Idle;
					pThis->m_CurrentOp = Op_NoOp;
				}
			}

			WSACleanup();
		}
	}

	DBGEXIT(CNmLDAP::_sAsyncBindThreadFn);

	return ulRet;
}


LRESULT CNmLDAP::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LRESULT lr = TRUE;
	DBGENTRY(CNmLDAP::WndProc);

	switch( uMsg )
	{
		case WM_USER_BIND_COMPLETE:		
			_OnUserBindComplete((INT)wParam, (DWORD)lParam);
			break;

		case WM_TIMER:
			lr = FALSE; // This means that we handle the message
			_OnTimer(wParam);
			break;

        case WM_NEED_RELOGON:
            OnReLogon();
            break;

		default:
			lr = DefWindowProc(hwnd, uMsg, wParam, lParam);
			break;
	}

	DBGEXIT_ULONG(CNmLDAP::WndProc,lr);
	return lr;
}


void CNmLDAP::_OnTimer(UINT_PTR TimerID)
{
	DBGENTRY(CNmLDAP::_OnTimer);
TRACE_OUT(("CNmLDAP::_OnTimer:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	// We check the timer ID values first because we may have killed the timer,
	// and the message couldv be simply vestigal ( that means left over from an earlier time)...

	if(m_LogoffTimer && (WaitForLogoffTimer == TimerID))
	{
			// We are waiting in the distructor for an async operation to complete
			// and we have waited too long... kill the timer and set the m_hEventWaitForLogoffDone event
		::KillTimer(m_hWndHidden, m_LogoffTimer);
		m_LogoffTimer = 0;

		if(m_hEventWaitForLogoffDone)
		{
			SetEvent(m_hEventWaitForLogoffDone);
		}
	}
	else if( (INVALID_MSG_ID != m_uMsgID) && m_ResultPollTimer && (PollForResultTimer == TimerID ))
	{
		ASSERT(m_pLdap);
		::KillTimer( m_hWndHidden, m_ResultPollTimer );
		m_ResultPollTimer = 0;

		LDAPMessage *pMsg = NULL;
		LDAP_TIMEVAL TimeoutVal = { 0, 0 };
		INT res = WLDAP::ldap_result( m_pLdap, m_uMsgID, LDAP_MSG_ALL, &TimeoutVal, &pMsg );
		
		if( 0 == res )
		{
			// ldap_result timedout
			m_ResultPollTimer = ::SetTimer( m_hWndHidden, PollForResultTimer, RESULT_POLL_INTERVAL, NULL );

			if( !m_ResultPollTimer )
			{
				ERROR_OUT(("SetTimer failed!"));
				_AbandonAllAndRecoverState();
			}
		}
		else if( LDAP_RESULT_ERROR == res )
		{
			ERROR_OUT(("ldap_result failed"));
            _AbandonAllAndRecoverState();
		}
		else
		{
				// We got the result, so reset this
			m_uMsgID = INVALID_MSG_ID;

			if( AddingUser == m_State )
			{
				_OnAddingUserResult(pMsg->lm_returncode);
				WLDAP::ldap_msgfree(pMsg);
			}
			else if( ( SettingAppInfo == m_State ) || ( ModifyingAttrs == m_State ) )
			{
				_OnSettingAppInfoOrModifyingAttrsResult(pMsg->lm_returncode);
				WLDAP::ldap_msgfree(pMsg);
			}
			else if( LoggingOff == m_State )
			{	
				_OnLoggingOffResult(pMsg->lm_returncode);
				WLDAP::ldap_msgfree(pMsg);
			}
		}
	}

TRACE_OUT(("CNmLDAP::_OnTimer:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnTimer);
}


void CNmLDAP::_OnUserBindComplete(INT LdapResult, DWORD LastError )
{
	DBGENTRY(CNmLDAP::_OnUserBindComplete);
TRACE_OUT(("CNmLDAP::_OnUserBindComplete:enter(%d):   m_State:%d:   m_currentOp:%d", LdapResult, m_State, m_CurrentOp));

	ASSERT(m_hBindThread);
	ASSERT(Binding == m_State);

	CloseHandle(m_hBindThread);
	m_hBindThread = NULL;

	if(LDAP_SUCCESS == LdapResult)
	{
		m_State = Bound;
		SetLoggedOn( IsLoggedOn() );

		if( m_bRefreshAfterBindCompletes )
		{
				// If a refresh is attempted while
				// the bind operation is in progress
				// we just wait for the bind to complete
				// then we well do the refresh
			m_bRefreshAfterBindCompletes = false;
			_RefreshServer();
		}
		else if( m_bLogoffAfterBindCompletes )
		{
			m_bLogoffAfterBindCompletes = false;
			_DeleteUser();
		}
		else
		{
			if( Op_Logon == m_CurrentOp )
			{
				m_CurrentOp = Op_NoOp;
				_AddUser();
			}
			else if( Op_Logoff == m_CurrentOp )
			{
				m_CurrentOp = Op_NoOp;
				_DeleteUser();
			}
			else if( Op_Refresh_Logoff == m_CurrentOp )
			{	
				_DeleteUser();
			}
			else if( Op_Modifying_InCallAttr == m_CurrentOp )
			{
				m_CurrentOp = Op_NoOp;
				_ModifyInCallAttr();
			}
		}
	}
	else
	{
		eCurrentOp OldOp = m_CurrentOp;
	    _AbandonAllAndRecoverState(OldOp);
		
		if( ( Op_Refresh_Logoff == OldOp ) && ( lstrcmpi( m_strCurrentServer, m_strServer ) ) )
		{
			// If the server names have changed...
			// Suppose that the server you are logged on to
			// goes down and then you change the server that you want
			// to be logged on to ( before you have any indication that
			// the server has gone down... You want to log off the old server
			// But the server is not available... We are basically going to
			// ignore the fact that there was a problem logging off
			// from the server, and we are going to simply log on to the new server
			_OnLoggedOff();
			LogonAsync();
		}
		else if( Op_Logoff == OldOp )
		{
				// We don't have to put up a message box...
			_OnLoggedOff();
		}
		else
		{
			if( (LDAP_SERVER_DOWN == LdapResult) || (LDAP_TIMEOUT == LdapResult) )
			{
                if (Op_Modifying_InCallAttr == OldOp)
                {
				    ERROR_OUT(("ldap_bind for InCallAttr returns server-down or timeout"));
                }
                else
                {
					::PostConfMsgBox(IDS_ULSLOGON_BADSERVER);	
					_OnLoggedOff();
                }
			}
			else
			{
				ERROR_OUT(("ldap_bind returned error 0x%08x LdapResult, GetLastError == 0x%08x", LdapResult, LastError));
			}
		}
	}

TRACE_OUT(("CNmLDAP::_OnUserBindComplete:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnUserBindComplete);
}

void CNmLDAP::_OnLoggingOffResult(int Result)
{
	DBGENTRY(CNmLDAP::_OnLoggingOffResult);
TRACE_OUT(("CNmLDAP::_OnLoggingOffResult:enter(%d):   m_State:%d:   m_currentOp:%d", Result, m_State, m_CurrentOp));
	
	if( (LDAP_SUCCESS == Result) || (LDAP_NO_SUCH_OBJECT == Result) || (LDAP_SERVER_DOWN == Result))
	{
			// We are waiting in the destructor for the ldap logof operations to complete
			// Now that it has, we hawe to signal the destructor unblocks
		if(m_hEventWaitForLogoffDone)
		{
			SetEvent(m_hEventWaitForLogoffDone);
		}

		_OnLoggedOff();
	}
	else
	{
		ERROR_OUT(("Ldap Error 0x%08x", Result));
	}


	WLDAP::ldap_unbind(m_pLdap);
	m_State = Idle;
	m_pLdap = NULL;
	SetLoggedOn( IsLoggedOn() );

	if( Op_Refresh_Logoff == m_CurrentOp )
	{
		m_CurrentOp = Op_NoOp;
		LogonAsync();
	}

TRACE_OUT(("CNmLDAP::_OnLoggingOffResult:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnLoggingOffResult);
}


void CNmLDAP::_OnSettingAppInfoOrModifyingAttrsResult(int Result)
{
	DBGENTRY(CNmLDAP::_OnSettingAppInfoOrModifyingAttrsResult);
TRACE_OUT(("CNmLDAP::_OnSettingAppInfoOrModifyingAttrsResult:enter(%d):   m_State:%d:   m_currentOp:%d", Result, m_State, m_CurrentOp));
	
	if( LDAP_SUCCESS == Result)
	{
	    // start the keep alive thread
        if (NULL != m_pKeepAlive)
        {
            m_pKeepAlive->Start();
        }

		if(SettingAppInfo == m_State)
		{
			m_State = LoggedIn;
			SetLoggedOn( IsLoggedOn() );
			_OnLoggedOn();
		}
		else
		{
			m_State = LoggedIn;
			SetLoggedOn( IsLoggedOn() );
		}

		if( m_bSendInCallAttrWhenDone )
		{
			m_bSendInCallAttrWhenDone = false;
			_ModifyInCallAttr();
		}
		else
		{
			WLDAP::ldap_unbind(m_pLdap);

			if(m_ResultPollTimer)
			{
				::KillTimer(m_hWndHidden,m_ResultPollTimer);
				m_ResultPollTimer = 0;
			}

			m_uMsgID = INVALID_MSG_ID;

			m_pLdap = NULL;
			m_State = LoggedIn;
			SetLoggedOn( IsLoggedOn() );
		}
	}
	else
	{
		ERROR_OUT( ("Ldap Error 0x%08x, DN=%s", Result, m_strCurrentDN) );
		if (ModifyingAttrs == m_State && NULL != m_pKeepAlive)
		{
    		_AbandonAllAndRecoverState();
    		if(LDAP_NO_SUCH_OBJECT == Result)
    		{			
        		_OnLoggedOff();
    			LogonAsync();
    		}
		}
		else
		{
    		_AbandonAllAndSetToIdle();
    		_OnLoggedOff();

    		if(LDAP_NO_SUCH_OBJECT == Result)
    		{			
    			LogonAsync();
    		}
        }
	}

TRACE_OUT(("CNmLDAP::_OnSettingAppInfoOrModifyingAttrsResult:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnSettingAppInfoOrModifyingAttrsResult);
}


void CNmLDAP::_OnAddingUserResult( int Result)
{
	DBGENTRY(CNmLDAP::_OnAddingUserResult);	
TRACE_OUT(("CNmLDAP::_OnAddingUserResult:enter(%d):   m_State:%d:   m_currentOp:%d", Result, m_State, m_CurrentOp));

	if( LDAP_SUCCESS == Result )
	{
		m_State = UserAdded;
		SetLoggedOn( IsLoggedOn() );
		_SetAppInfo();
	}
	else
	{
		UINT	uStringID;

		switch( Result )
		{
			case LDAP_ALREADY_EXISTS:
				uStringID = IDS_ULSLOGON_DUPLICATE;
				break;

			case LDAP_NAMING_VIOLATION:
				uStringID = IDS_ULSLOGON_WORD_FILTER;
				break;

			case LDAP_UNWILLING_TO_PERFORM:
				uStringID = IDS_ILLEGALEMAILNAME;
				break;

			case LDAP_UNDEFINED_TYPE:
			case LDAP_SERVER_DOWN:
				// W2K server returns this under heavy load situations...
				uStringID = IDS_ULSLOGON_ERROR;
				break;

			default:
				uStringID = IDS_ULSLOGON_ERROR;
				ERROR_OUT( ("Ldap Error 0x%08x, DN=%s", Result, m_strCurrentDN) );
				break;
		}

		::PostConfMsgBox( uStringID );
		_OnLoggedOff();

		WLDAP::ldap_unbind(m_pLdap);
		m_pLdap = NULL;
		m_State = Idle;
		SetLoggedOn( IsLoggedOn() );
	}

TRACE_OUT(("CNmLDAP::_OnAddingUserResult:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnAddingUserResult);	
}


/*static*/
LRESULT CNmLDAP::_sWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LRESULT lr = 0;

	if( WM_NCCREATE != uMsg )
	{
		CNmLDAP* pNmLdap = reinterpret_cast<CNmLDAP*>( ::GetWindowLongPtr( hwnd, GWLP_USERDATA ) );
		
		if( pNmLdap )
		{
			lr = pNmLdap->WndProc( hwnd, uMsg, wParam, lParam );
		}
	}
	else
	{
		lr = TRUE; // This means to continue creating the window
		CREATESTRUCT* pCreateStruct = reinterpret_cast<CREATESTRUCT*>(lParam);
		if( pCreateStruct )
		{
			::SetWindowLongPtr( hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pCreateStruct->lpCreateParams));
		}
	}

	return lr;
}

void CNmLDAP::_SetAppInfo()
{
	DBGENTRY(CNmLDAP::_SetInfo);
TRACE_OUT(("CNmLDAP::_SetInfo:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	ASSERT(NULL != m_pLdap);
	ASSERT(UserAdded == m_State);
	ASSERT(INVALID_MSG_ID == m_uMsgID);

		// These are the app attribute vals
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, smodop, LDAP_MODOP_ADDAPP);
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, sappid, _T("ms-netmeeting"));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, smimetype, _T("text/iuls"));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, sappguid, _T("008aff194794cf118796444553540000"));
	DECLARE_LDAP_MOD2(LDAP_MOD_ADD, sprotid, _T("t120"), _T("h323"));
	DECLARE_LDAP_MOD2(LDAP_MOD_ADD, sprotmimetype, _T("text/t120"), _T("text/h323"));
	DECLARE_LDAP_MOD2(LDAP_MOD_ADD, sport, _T("1503"), _T("1720"));

		// This is the app mod array
	LDAPMod *apModApp[] =
	{
		LDAP_MOD_ENTRY(smodop),
		LDAP_MOD_ENTRY(sappid),
		LDAP_MOD_ENTRY(smimetype),
		LDAP_MOD_ENTRY(sappguid),
		LDAP_MOD_ENTRY(sprotid),
		LDAP_MOD_ENTRY(sprotmimetype),
		LDAP_MOD_ENTRY(sport),
		NULL
	};

	m_uMsgID = WLDAP::ldap_modify( m_pLdap, const_cast<LPTSTR>((LPCTSTR)m_strCurrentDN), apModApp );

	if( INVALID_MSG_ID != m_uMsgID )
	{
		m_ResultPollTimer = ::SetTimer( m_hWndHidden, PollForResultTimer, RESULT_POLL_INTERVAL, NULL );

		ASSERT(m_ResultPollTimer);

		m_State = SettingAppInfo;
	}
	else
	{
		DWORD dwErr;
		ERROR_OUT(("ldap_modify returned error 0x%08x", (WLDAP::ldap_get_option(m_pLdap, LDAP_OPT_ERROR_NUMBER, &dwErr), dwErr)));
		WLDAP::ldap_unbind(m_pLdap);
		m_pLdap = NULL;
		m_State = Idle;
	}

	SetLoggedOn( IsLoggedOn() );
TRACE_OUT(("CNmLDAP::_SetInfo:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_SetInfo);
}


void CNmLDAP::_ModifyInCallAttr()
{
TRACE_OUT(("CNmLDAP::_ModifyInCallAttr:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DECLARE_LDAP_MOD(LDAP_MOD_REPLACE, smodop, LDAP_MODOP_MODIFYUSER);
	DECLARE_LDAP_MOD(LDAP_MOD_REPLACE, ilsA26214430, m_bInCall ? LDAP_ATTR_TRUE : LDAP_ATTR_FALSE);

	LDAPMod *apMod[] =
	{
		LDAP_MOD_ENTRY(smodop),
		LDAP_MOD_ENTRY(ilsA26214430),
		NULL
	};

	TRACE_OUT(("About to modify InCallAttrs for this person: %s", m_strCurrentDN));
	m_uMsgID = WLDAP::ldap_modify( m_pLdap, const_cast<LPTSTR>((LPCTSTR)m_strCurrentDN), apMod );

	if( INVALID_MSG_ID != m_uMsgID )
	{
		m_ResultPollTimer = ::SetTimer( m_hWndHidden, PollForResultTimer, RESULT_POLL_INTERVAL, NULL );
		
		ASSERT(m_ResultPollTimer);

		m_State = ModifyingAttrs;
	}
	else
	{
		DWORD dwErr;
		ERROR_OUT(("ldap_modify returned error 0x%08x", (WLDAP::ldap_get_option(m_pLdap, LDAP_OPT_ERROR_NUMBER, &dwErr), dwErr)));
		WLDAP::ldap_unbind(m_pLdap);
		m_pLdap = NULL;
		m_State = (NULL != m_pKeepAlive) ? LoggedIn : Idle; // restore the state
	}

	SetLoggedOn( IsLoggedOn() );
TRACE_OUT(("CNmLDAP::_ModifyInCallAttr:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

}


void CNmLDAP::_DeleteUser()
{
	DBGENTRY(CNmLDAP::_DeleteUser);
TRACE_OUT(("CNmLDAP::_DeleteUser:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

    // end the keep alive thread
    if (NULL != m_pKeepAlive)
    {
        m_pKeepAlive->End();
        m_pKeepAlive = NULL;
    }

	ASSERT(NULL != m_pLdap);
	ASSERT(Bound == m_State);
	ASSERT(INVALID_MSG_ID == m_uMsgID);

	m_uMsgID = WLDAP::ldap_delete(m_pLdap, const_cast<LPTSTR>((LPCTSTR)(m_strCurrentDN)));
	if( INVALID_MSG_ID != m_uMsgID )
	{
		m_State = LoggingOff;
		m_ResultPollTimer = ::SetTimer( m_hWndHidden, PollForResultTimer, RESULT_POLL_INTERVAL, NULL );
		ASSERT(m_ResultPollTimer);
	}
	else
	{
		WLDAP::ldap_unbind(m_pLdap);
		m_pLdap = NULL;
		m_State = Idle;
	}

	SetLoggedOn( IsLoggedOn() );

TRACE_OUT(("CNmLDAP::_DeleteUser:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_DeleteUser);
}

void CNmLDAP::_AddUser()
{
	DBGENTRY(CNmLDAP::_AddUser);
TRACE_OUT(("CNmLDAP::_AddUser:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	ASSERT(NULL != m_pLdap);
	ASSERT(Bound == m_State);
	ASSERT(INVALID_MSG_ID == m_uMsgID);

		// These are the user attribute values
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, cn, const_cast<LPTSTR>((LPCTSTR)m_strEmailName));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, givenname, const_cast<LPTSTR>((LPCTSTR)m_strGivenName));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, surname, const_cast<LPTSTR>((LPCTSTR)m_strSurName));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, rfc822mailbox, const_cast<LPTSTR>((LPCTSTR)m_strEmailName));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, location, const_cast<LPTSTR>((LPCTSTR)m_strLocation));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, comment, const_cast<LPTSTR>((LPCTSTR)m_strComment));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, sflags, m_bVisible ? LDAP_ATTR_TRUE : LDAP_ATTR_FALSE );
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, ilsA26214430, m_bInCall ? LDAP_ATTR_TRUE : LDAP_ATTR_FALSE );
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, ilsA32833566, m_bAudioHardware ? LDAP_ATTR_TRUE : LDAP_ATTR_FALSE );
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, ilsA32964638, m_bVideoHardware ? LDAP_ATTR_TRUE : LDAP_ATTR_FALSE );
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, ilsA39321630, LDAP_ATTR_BUSINESS );
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, ssecurity, const_cast<LPTSTR>((LPCTSTR)m_strSecurityToken));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, c, LDAP_ATTR_DUMMY_COUNTRYNAME);

		// We have to get IP address dynamically
	TCHAR szIpAddr[MAX_PATH];
	szIpAddr[0] = _T('\0');

    DWORD dwLocalIPAddress = INADDR_NONE;
	_GetIpAddressOfLdapSession( szIpAddr, CCHMAX(szIpAddr), &dwLocalIPAddress );

	DECLARE_LDAP_MOD(LDAP_MOD_ADD, sipaddress, szIpAddr);
		
		// We store the version info on the server
	TCHAR szVer[MAX_PATH];
	wsprintf(szVer,"%lu",VER_PRODUCTVERSION_DW);
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, ilsA26279966, szVer);

		// This is the user mod array
	LDAPMod *apModUser[] =
	{
		LDAP_MOD_ENTRY(cn),
		LDAP_MOD_ENTRY(givenname),
		LDAP_MOD_ENTRY(surname),
		LDAP_MOD_ENTRY(rfc822mailbox),
		LDAP_MOD_ENTRY(location),
		LDAP_MOD_ENTRY(comment),
		LDAP_MOD_ENTRY(c),
		LDAP_MOD_ENTRY(sipaddress),
		LDAP_MOD_ENTRY(sflags),
		LDAP_MOD_ENTRY(ssecurity),
		LDAP_MOD_ENTRY(ilsA26214430),
		LDAP_MOD_ENTRY(ilsA26279966),
		LDAP_MOD_ENTRY(ilsA32833566),
		LDAP_MOD_ENTRY(ilsA32964638),
		LDAP_MOD_ENTRY(ilsA39321630),
		NULL
	};

	TCHAR* szDN = new TCHAR[ lstrlen(LOGIN_USER_FILTER) + lstrlen(m_strEmailName) + 1 ];
	if( szDN )
	{
		wsprintf(szDN, LOGIN_USER_FILTER, (LPCTSTR) m_strEmailName);
		m_strCurrentDN = szDN;
		delete [] szDN;
	}

	TCHAR* szRefresh = new TCHAR[ lstrlen(LDAP_REFRESH_FILTER) + lstrlen(m_strEmailName) + 1 ];
	if( szRefresh )
	{
		wsprintf(szRefresh, LDAP_REFRESH_FILTER, (LPCTSTR)m_strEmailName);
	}

	m_uMsgID = WLDAP::ldap_add( m_pLdap, const_cast<LPTSTR>((LPCTSTR)m_strCurrentDN), apModUser );

	if( INVALID_MSG_ID != m_uMsgID )
	{
		m_State = AddingUser;
		m_ResultPollTimer = ::SetTimer( m_hWndHidden, PollForResultTimer, RESULT_POLL_INTERVAL, NULL );
		ASSERT(m_ResultPollTimer);

		// create the keep alive object
		if (NULL != m_pKeepAlive)
		{
            m_pKeepAlive->End();
            m_pKeepAlive = NULL;
		}
		BOOL fRet = FALSE;
	    m_pKeepAlive = new CKeepAlive(&fRet,
	                                  m_hWndHidden,
	                                  dwLocalIPAddress,
	                                  m_strCurrentServer, m_iPort,
	                                  szRefresh);
	    ASSERT(NULL != m_pKeepAlive && fRet);
	}
	else
	{
		WLDAP::ldap_unbind(m_pLdap);
		m_pLdap = NULL;
		m_State = Idle;
	}

    delete [] szRefresh;

	SetLoggedOn( IsLoggedOn() );

TRACE_OUT(("CNmLDAP::_AddUser:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_AddUser);
}

void CNmLDAP::_OnLoggedOn()
{
	DBGENTRY(CNmLDAP::_OnLoggedOn);
TRACE_OUT(("CNmLDAP::_OnLoggedOn:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	::UpdateUI(CRUI_STATUSBAR | CRUI_CALLANIM, TRUE);	
	
TRACE_OUT(("CNmLDAP::_OnLoggedOn:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnLoggedOn);
}

void CNmLDAP::_OnLoggedOff()
{
	DBGENTRY(CNmLDAP::_OnLoggedOff);
TRACE_OUT(("CNmLDAP::_OnLoggedOff:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	::UpdateUI(CRUI_STATUSBAR | CRUI_CALLANIM, TRUE);	

TRACE_OUT(("CNmLDAP::_OnLoggedOff:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnLoggedOff);
}


void CNmLDAP::_OnLoggingOn()
{
	DBGENTRY(CNmLDAP::_OnLoggingOn);
TRACE_OUT(("CNmLDAP::_OnLoggingOn:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	::UpdateUI(CRUI_STATUSBAR | CRUI_CALLANIM, TRUE);	

TRACE_OUT(("CNmLDAP::_OnLoggingOn:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnLoggingOn);
}


void CNmLDAP::_OnLoggingOff()
{
	DBGENTRY(CNmLDAP::_OnLoggingOff);
TRACE_OUT(("CNmLDAP::_OnLoggingOff:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	::UpdateUI(CRUI_STATUSBAR | CRUI_CALLANIM, TRUE);	

TRACE_OUT(("CNmLDAP::_OnLoggingOff:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnLoggingOff);
}

void CNmLDAP::_GetIpAddressOfLdapSession( LPTSTR szIpAddr, int cchMax, DWORD *pdwIPAddr )
{
	DBGENTRY(CNmLDAP::_GetIpAddressOfLdapSession);

    if (NULL != szIpAddr)
    {
	    szIpAddr[0] = _T('\0');
	}
	SOCKET s = INVALID_SOCKET;

	if( LDAP_SUCCESS == WLDAP::ldap_get_option(m_pLdap, LDAP_OPT_DESC, &s ))
	{
		SOCKADDR_IN addr;
		int NameLen = sizeof(addr);
		if(0 == getsockname(s, reinterpret_cast<SOCKADDR*>(&addr), &NameLen))
		{
		    if (NULL != szIpAddr)
		    {
			    wsprintf(szIpAddr, "%u", addr.sin_addr.s_addr);
			}
			if (NULL != pdwIPAddr)
			{
			    *pdwIPAddr = addr.sin_addr.s_addr;
			}
		}
	}

	DBGEXIT(CNmLDAP::_GetIpAddressOfLdapSession);
}


void InitNmLdapAndLogon()
{
	ASSERT( NULL == g_pLDAP );

	g_pLDAP = new CNmLDAP;

	if(g_pLDAP)
	{
						// Initialize the LDAP object...
		if( SUCCEEDED(g_pLDAP->Initialize( _Module.GetModuleInstance())))
		{
			g_pLDAP->LogonAsync();
		}
		else
		{
			delete g_pLDAP;
			g_pLDAP = NULL;
		}
	}
	else
	{
		ERROR_OUT(("new CNmLDAP returned NULL"));
	}
}



/////////////////////////////////////////////////////////
//
// CKeepAlive
//


void CALLBACK KeepAliveTimerProc(HWND, UINT, UINT_PTR, DWORD)
{
    // doing nothing at all
}


DWORD KeepAliveThreadProc(LPVOID pParam)
{
    // make sure we have a valid socket
	WSADATA	wsaData;
    int iRet = ::WSAStartup(0x0101, &wsaData);
    ASSERT(! iRet);
    if (! iRet)
    {
        CKeepAlive *pKeepAlive = (CKeepAlive *) pParam;
        ASSERT(NULL != pKeepAlive);

        // translate server name into ip address
        if (pKeepAlive->SetServerIPAddress())
        {
            // start the timer
            UINT nKeepAliveInterval = INITIAL_REFRESH_INTERVAL_MINUTES;
            UINT_PTR nTimerID = ::SetTimer(NULL, 0, nKeepAliveInterval * 60 * 1000, KeepAliveTimerProc);
            ASSERT(nTimerID);

            // watch for the timer message
            MSG msg, msg2;
            while (::GetMessage(&msg, NULL, 0, 0))
            {
                msg2 = msg; // keep a copy of this message

                // dispatch messages
                ::DispatchMessage(&msg);

                // intercept the WM_TIMER message thru msg2
                if (WM_TIMER == msg2.message && nTimerID == msg2.wParam)
                {
                    BOOL fRetry = TRUE;

                    // kill the timer to avoid timer overrun
                    ::KillTimer(NULL, nTimerID);
                    nTimerID = 0;

                    // ping the server in case of dialup networking
                    if (pKeepAlive->Ping())
                    {
                        // connect to the server
                        LDAP *ld = WLDAP::ldap_open(pKeepAlive->GetServerName(),
                                                    pKeepAlive->GetServerPortNumber());
                        if (NULL != ld)
                        {
                            if (pKeepAlive->Bind(ld))
                            {
                                if (pKeepAlive->KeepAlive(ld, &nKeepAliveInterval))
                                {
                                    // successfully send a keep alive
                                    fRetry = FALSE;

                                    DWORD dwLocalIPAddress = pKeepAlive->GetLocalIPAddress(ld);
                                    if (INADDR_NONE != dwLocalIPAddress)
                                    {
                                        if (pKeepAlive->GetLocalIPAddress() != dwLocalIPAddress)
                                        {
                                            pKeepAlive->SetLocalIPAddress(dwLocalIPAddress);
                                            pKeepAlive->UpdateIPAddressOnServer();
                                        }
                                    }
                                }
                            }
                            WLDAP::ldap_unbind(ld);
                        }
                    }

                    // start the new timer based on the new internal
                    nTimerID = ::SetTimer(NULL, 0,
                                          fRetry ? (15 * 1000) : (nKeepAliveInterval * 60 * 1000),
                                          KeepAliveTimerProc);
                    ASSERT(nTimerID);
                } // if wm timer
            } // while get message

            if (nTimerID)
            {
                ::KillTimer(NULL, nTimerID);
            }
        }

        delete pKeepAlive;
        ::WSACleanup();
    }
    return 0;
}


CKeepAlive::CKeepAlive
(
    BOOL               *pfRet,
    HWND                hwndMainThread,
    DWORD               dwLocalIPAddress,
    const TCHAR * const pcszServerName,
    UINT                nPort,
    LPTSTR              pszKeepAliveFilter
)
:
    m_hwndMainThread(hwndMainThread),
    m_dwLocalIPAddress(dwLocalIPAddress),
    m_dwServerIPAddress(INADDR_NONE),
    m_pszServerName(NULL),
    m_nPort(nPort),
    m_pszKeepAliveFilter(NULL),
    m_hThread(NULL),
    m_dwThreadID(0),
    m_fAborted(FALSE)
{
    *pfRet = FALSE; // assume failure

    // sanity check
    ASSERT(NULL != hwndMainThread);
    ASSERT(INADDR_NONE != dwLocalIPAddress && 0 != dwLocalIPAddress);
    ASSERT(nPort);

    // create the server name
    ASSERT(NULL != pcszServerName);
    ULONG nStrLen = ::lstrlen(pcszServerName) + 1;
    m_pszServerName = new TCHAR[nStrLen];
    if (NULL != m_pszServerName)
    {
        ::CopyMemory(m_pszServerName, pcszServerName, nStrLen * sizeof(TCHAR));

		TCHAR * const	pszPort	= StrChr( m_pszServerName, ':' );

		if( pszPort != NULL )
		{
			//	Truncate the server name here for dns lookup....
			//	and this port number overrides the nPort parameter...
			*pszPort = '\0';
			HRESULT	hrResult = DecimalStringToUINT( pszPort + 1, m_nPort );
			ASSERT( hrResult == S_OK );
			if( hrResult != S_OK )
			{
				m_nPort = DEFAULT_LDAP_PORT;
			}
		}

        // create the fresh filter
        ASSERT(NULL != pszKeepAliveFilter);
        nStrLen = ::lstrlen(pszKeepAliveFilter) + 1;
        m_pszKeepAliveFilter = new TCHAR[nStrLen];
        if (NULL != m_pszKeepAliveFilter)
        {
            ::CopyMemory(m_pszKeepAliveFilter, pszKeepAliveFilter, nStrLen * sizeof(TCHAR));
            *pfRet = TRUE;
        }
    }
}


CKeepAlive::~CKeepAlive(void)
{
    delete m_pszServerName;
    delete m_pszKeepAliveFilter;
}


BOOL CKeepAlive::Start(void)
{
    if (! m_dwThreadID)
    {
        ASSERT(NULL == m_hThread);

        // create the worker thread
        m_hThread = ::CreateThread(NULL, 0, KeepAliveThreadProc, this, 0, &m_dwThreadID);
    }

    ASSERT(NULL != m_hThread);
    return (NULL != m_hThread);
}


BOOL CKeepAlive::End(BOOL fSync)
{
    DWORD dwRet = WAIT_OBJECT_0;

    // cache thread handle and ID
    HANDLE hThread = m_hThread;
    DWORD dwThreadID = m_dwThreadID;

    // abort any pending operation
    m_fAborted = TRUE;

    // notify the worker thread to go away
    if (m_dwThreadID)
    {
        ASSERT(NULL != m_hThread);
        m_dwThreadID = 0;
        ::PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    }

    // wait for the worker thread exit for 5 seconds
    if (NULL != hThread)
    {
        // need more work to unblock it
        if (fSync)
        {
            dwRet = ::WaitForSingleObject(hThread, 5000); // 5 second timeout
            ASSERT(WAIT_TIMEOUT != dwRet);
        }

        ::CloseHandle(hThread);
    }

    return (WAIT_TIMEOUT != dwRet);
}


BOOL CKeepAlive::SetServerIPAddress(void)
{
    ASSERT(NULL != m_pszServerName);

    // check to see if the server name is a dotted IP address string
    m_dwServerIPAddress = ::inet_addr(m_pszServerName);
    if (INADDR_NONE == m_dwServerIPAddress)
    {
        // it is not a dotted string, it must be a name.
        // get the host entry by name
        PHOSTENT phe = ::gethostbyname(m_pszServerName);
        if (phe != NULL)
        {
            // get info from the host entry
            m_dwServerIPAddress = *(DWORD *) phe->h_addr;
        }
    }

    ASSERT(INADDR_NONE != m_dwServerIPAddress);
    return (INADDR_NONE != m_dwServerIPAddress);
}


BOOL CKeepAlive::Ping(void)
{
    BOOL fRet = TRUE; // assume success
    if (NULL != g_pPing)
    {
        if (g_pPing->IsAutodialEnabled())
        {
            ASSERT(INADDR_NONE != m_dwServerIPAddress);
            HRESULT hr = g_pPing->Ping(m_dwServerIPAddress, PING_TIMEOUT_INTERVAL, PING_RETRIES);
            fRet = (S_OK == hr);
        }
    }
    return fRet;
}


BOOL CKeepAlive::Bind(LDAP *ld)
{
    ASSERT(NULL != ld);

    if (! m_fAborted)
    {
        // anonymous bind
        ULONG nMsgID = WLDAP::ldap_bind(ld, TEXT(""), TEXT(""), LDAP_AUTH_SIMPLE);
        if (INVALID_MSG_ID != nMsgID)
        {
            // poll the result every quarter second
            const ULONG c_nTimeoutInQuarterSecond = 4 * LDAP_TIMEOUT_IN_SECONDS;
            for (ULONG i = 0; (i < c_nTimeoutInQuarterSecond) && (! m_fAborted); i++)
            {
                // no timeout, if no result, return immediately
                LDAP_TIMEVAL TimeVal;
                TimeVal.tv_usec = 0;
                TimeVal.tv_sec = 0;

                // check the result
                LDAPMessage *pMsg = NULL;
                ULONG nResultType = WLDAP::ldap_result(ld, nMsgID, LDAP_MSG_ALL, &TimeVal, &pMsg);
                if (nResultType == LDAP_RES_BIND)
                {
                    ASSERT(NULL != pMsg);
                    WLDAP::ldap_msgfree(pMsg);
                    return TRUE;
                }

                // deal with timeout or error
                if (LDAP_RESULT_TIMEOUT == nResultType)
                {
                    if (! m_fAborted)
                    {
                        ::Sleep(250); // sleep for a quarter second
                        continue;
                    }
                }

                ASSERT(LDAP_RESULT_ERROR != nResultType);
                break;
            }

            // failure, do the cleanup
            WLDAP::ldap_abandon(ld, nMsgID);
        }
    }

    return FALSE;
}


DWORD CKeepAlive::GetLocalIPAddress(LDAP *ld)
{
    SOCKET s = INVALID_SOCKET;
    if (LDAP_SUCCESS == WLDAP::ldap_get_option(ld, LDAP_OPT_DESC, &s))
    {
        SOCKADDR_IN addr;
        int NameLen = sizeof(addr);
        if (0 == ::getsockname(s, (SOCKADDR *) &addr, &NameLen))
        {
            return addr.sin_addr.s_addr;
        }
    }
    return INADDR_NONE;
}


BOOL CKeepAlive::KeepAlive(LDAP *ld, UINT *pnKeepAliveInterval)
{
    LPTSTR aTTLAttr[] = { STTL_ATTR_NAME, NULL };
    UINT nMsgID = WLDAP::ldap_search(ld,
                                     LDAP_REFRESH_BASE_DN,
                                     LDAP_SCOPE_BASE,
                                     m_pszKeepAliveFilter,
                                     aTTLAttr,
                                     FALSE);
    if (INVALID_MSG_ID != nMsgID)
    {
        // poll the result every quarter second
        const ULONG c_nTimeoutInQuarterSecond = 4 * LDAP_TIMEOUT_IN_SECONDS;
        BOOL fError = FALSE;
        for (ULONG i = 0; (i < c_nTimeoutInQuarterSecond) && (! m_fAborted) && (! fError); i++)
        {
            // no timeout, if no result, return immediately
            LDAP_TIMEVAL TimeVal;
            TimeVal.tv_usec = 0;
            TimeVal.tv_sec = 0;

            // check the result
            LDAPMessage *pMsg = NULL;
            ULONG nResultType = WLDAP::ldap_result(ld, nMsgID, LDAP_MSG_ALL, &TimeVal, &pMsg);
            switch (nResultType)
            {
            case LDAP_RESULT_TIMEOUT:
                if (! m_fAborted)
                {
                    ::Sleep(250); // sleep for a quarter second
                }
                break;
            case LDAP_RESULT_ERROR:
                fError = TRUE;
                break;
            default:
                ASSERT(LDAP_RES_SEARCH_ENTRY == nResultType ||
                       LDAP_RES_SEARCH_RESULT == nResultType);
                ASSERT(NULL != pMsg);
                switch (pMsg->lm_returncode)
                {
                case LDAP_SUCCESS:
                    GetNewInterval(ld, pMsg, pnKeepAliveInterval);
                    break;
                case LDAP_NO_SUCH_OBJECT:
                    ReLogon();
                    fError = TRUE;
                    break;
                default:
                    break;
                }
                WLDAP::ldap_msgfree(pMsg);
                return (! fError);
            }
        }

        // failure, do the cleanup
        WLDAP::ldap_abandon(ld, nMsgID);
    }

    return FALSE;
}


void CKeepAlive::GetNewInterval(LDAP *ld, LDAPMessage *pMsg, UINT *pnKeepAliveInterval)
{
    // get the first entry which should contain the new ttl value
    LDAPMessage *pEntry = WLDAP::ldap_first_entry(ld, pMsg);
    if (NULL != pEntry)
    {
        // get the first attribute which should be the new ttl value
        BerElement *pElement = NULL;
        LPTSTR pszAttrib = WLDAP::ldap_first_attribute(ld, pEntry, &pElement);
        if (NULL != pszAttrib)
        {
            // it should be ttl attribute
            ASSERT(! lstrcmpi(STTL_ATTR_NAME, pszAttrib));

            // get the value
            LPTSTR *ppszTTL = WLDAP::ldap_get_values(ld, pEntry, pszAttrib);
            if (NULL != ppszTTL)
            {
                if (NULL != ppszTTL[0])
                {
                    int iRefresh = ::RtStrToInt(ppszTTL[0]) - REFRESH_TIMEOUT_MARGIN;
                    if (iRefresh > 0)
                    {
                        if (iRefresh < MIN_REFRESH_TIMEOUT_INTERVAL_MINUTES)
                        {
                            iRefresh = MIN_REFRESH_TIMEOUT_INTERVAL_MINUTES;
                        }
                        *pnKeepAliveInterval = (UINT) iRefresh;
                    }
                }
                WLDAP::ldap_value_free(ppszTTL);
            }
        }
    }
}


void CKeepAlive::ReLogon(void)
{
    ::PostMessage(m_hwndMainThread, WM_NEED_RELOGON, 0, 0);
}


void CKeepAlive::UpdateIPAddressOnServer(void)
{
    ::PostMessage(m_hwndMainThread, WM_NEED_RELOGON, 0, 0);
}



/////////////////////////////////////////////////////////
//
// ResolveUser
//

typedef struct tagResolveInfo
{
    // given
    DWORD       cchMax;
    LPTSTR      pszIPAddress;
    // created
    LPTSTR      pszSearchFilter;
    LDAP       *ld;
}
    RESOLVE_INFO;


void FreeResolveInfo(RESOLVE_INFO *pInfo)
{
    if (NULL != pInfo)
    {
        delete pInfo->pszSearchFilter;

        if (NULL != pInfo->ld)
        {
            WLDAP::ldap_unbind(pInfo->ld);
        }

        delete pInfo;
    }
}


DWORD ResolveUserThreadProc(LPVOID pParam)
{
    RESOLVE_INFO *pInfo = (RESOLVE_INFO *) pParam;
    ASSERT(NULL != pInfo);

    // send the search request
    TCHAR* attrs[] = { IP_ADDRESS_ATTR_NAME, NULL };
    ULONG nMsgID = WLDAP::ldap_search(pInfo->ld,
                                TEXT("objectClass=RTPerson"),
                                LDAP_SCOPE_BASE,
                                pInfo->pszSearchFilter,
                                attrs,
                                0);
    if (INVALID_MSG_ID != nMsgID)
    {
        LDAPMessage *pMsg = NULL;
        LDAP_TIMEVAL SearchTimeout = { LDAP_TIMEOUT_IN_SECONDS, 0 };
        ULONG nResultType = WLDAP::ldap_result(pInfo->ld,
                                         nMsgID,
                                         LDAP_MSG_ALL,
                                         &SearchTimeout,
                                         &pMsg);
        switch (nResultType)
        {
        case LDAP_RESULT_TIMEOUT:
        case LDAP_RESULT_ERROR:
            WLDAP::ldap_abandon(pInfo->ld, nMsgID);
            break;
        default:
            {
                ASSERT(LDAP_RES_SEARCH_ENTRY == nResultType ||
                       LDAP_RES_SEARCH_RESULT == nResultType);
                ASSERT(NULL != pMsg);

                // get the first entry
                LDAPMessage *pEntry = WLDAP::ldap_first_entry(pInfo->ld, pMsg);
                if (NULL != pEntry)
                {
                    BerElement *pElement = NULL;

                    // get the first attribute
                    LPTSTR pszAttrib = WLDAP::ldap_first_attribute(pInfo->ld, pEntry, &pElement);
                    if (NULL != pszAttrib)
                    {
                        ASSERT(! lstrcmpi(IP_ADDRESS_ATTR_NAME, pszAttrib));

                        // get the value
                        LPTSTR *ppszIPAddress = WLDAP::ldap_get_values(pInfo->ld, pEntry, pszAttrib);
                        if (NULL != ppszIPAddress)
                        {
                            if (NULL != ppszIPAddress[0])
                            {
                                BYTE temp[sizeof(DWORD)];
                                *(DWORD *) &temp[0] = ::RtStrToInt(ppszIPAddress[0]);
                                ::wsprintf(pInfo->pszIPAddress, TEXT("%u.%u.%u.%u"),
                                            (UINT) temp[0], (UINT) temp[1],
                                            (UINT) temp[2], (UINT) temp[3]);
                            }

                            WLDAP::ldap_value_free(ppszIPAddress);
                        }
                    } // if attribute
                } // if entry

                WLDAP::ldap_msgfree(pMsg);
            }
            break;
        } // switch
    } // if msg id

    return 0;
}


/*static*/
HRESULT CNmLDAP::ResolveUser( LPCTSTR pcszName, LPCTSTR pcszServer, LPTSTR pszIPAddress, DWORD cchMax, int port )
{
    HRESULT hr = E_OUTOFMEMORY;
    RESOLVE_INFO *pInfo = NULL;

    // clean up the return buffer
    *pszIPAddress = TEXT('\0');

    // make sure the wldap32.dll is loaded
    if( ms_bLdapDLLLoaded || SUCCEEDED( hr = WLDAP::Init()))
    {
        ms_bLdapDLLLoaded = true;

        // create a resolve info which exchanges info between this thread and a background thread.
        pInfo = new RESOLVE_INFO;
        if (NULL != pInfo)
        {
            // cleanup
            ::ZeroMemory(pInfo, sizeof(*pInfo));

            // remember return buffer and its size
            pInfo->pszIPAddress = pszIPAddress;
            pInfo->cchMax = cchMax;

            // create search filter
            ULONG cbFilterSize = ::lstrlen(RESOLVE_USER_SEARCH_FILTER) + ::lstrlen(pcszName) + 2;
            pInfo->pszSearchFilter = new TCHAR[cbFilterSize];
            if (NULL != pInfo->pszSearchFilter)
            {
                // construct search filter
                ::wsprintf(pInfo->pszSearchFilter, RESOLVE_USER_SEARCH_FILTER, pcszName);

                // create ldap block that is NOT connected to server yet.
                pInfo->ld = WLDAP::ldap_init(const_cast<LPTSTR>(pcszServer), port);

				if( pInfo->ld != NULL )
				{
					ULONG ulResult = WLDAP::ldap_bind_s(pInfo->ld, TEXT(""), TEXT(""), LDAP_AUTH_SIMPLE);

					if( (ulResult != LDAP_SUCCESS) && (port == DEFAULT_LDAP_PORT) )
					{
						WLDAP::ldap_unbind(pInfo->ld);
						pInfo->ld = WLDAP::ldap_init(const_cast<LPTSTR>(pcszServer), ALTERNATE_LDAP_PORT);		//	Automatically retry with alternate port...

						if( pInfo->ld != NULL )
						{
							ulResult = WLDAP::ldap_bind_s(pInfo->ld, TEXT(""), TEXT(""), LDAP_AUTH_SIMPLE);
		
							if( ulResult != LDAP_SUCCESS )
							{
								WLDAP::ldap_unbind(pInfo->ld);
								pInfo->ld = NULL;
							}
						}
					}
				}

                ASSERT(NULL != pInfo->ld);
                if (NULL != pInfo->ld)
                {
                    DWORD dwThreadID = 0;
                    HANDLE hThread = ::CreateThread(NULL, 0, ResolveUserThreadProc, pInfo, 0, &dwThreadID);
                    if (NULL != hThread)
                    {
                        // wait for the thread to exit
                        hr = ::WaitWithMessageLoop(hThread);
                        DWORD dwIPAddr = ::inet_addr(pszIPAddress);
                        hr = (dwIPAddr && INADDR_NONE != dwIPAddr) ? S_OK : E_FAIL;

                        // close thread
                        ::CloseHandle(hThread);
                    }
                } // if ld
            } // if search filter
        } // if new resolve info
    } // if init

    ::FreeResolveInfo(pInfo);
    return  hr;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmres.h ===
// File: nmres.h

// Why isn't this defined in winres.h or winresrc.h?
#ifndef ACS_TIMER
#define ACS_TIMER 0x08
#endif


// this is only defined in the NT 5 build environment
#ifndef WS_EX_NOINHERIT_LAYOUT  
#define WS_EX_NOINHERIT_LAYOUT   0x00100000L
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmmember.h ===
#ifndef __NmMember_h__
#define __NmMember_h__

#include "NetMeeting.h"
class CNmConferenceObj;

/////////////////////////////////////////////////////////////////////////////
// CNmMemberObj
class ATL_NO_VTABLE CNmMemberObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public INmMember,
	public IInternalMemberObj
{

	CComPtr<INmMember>		m_spInternalINmMember;
	CNmConferenceObj*		m_pConferenceObj;
	bool					m_bIsSelf;


public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmMemberObj)

BEGIN_COM_MAP(CNmMemberObj)
	COM_INTERFACE_ENTRY(INmMember)
	COM_INTERFACE_ENTRY(IInternalMemberObj)
END_COM_MAP()


	CNmMemberObj();
	~CNmMemberObj();
	static HRESULT CreateInstance(CNmConferenceObj* pConfObj, INmMember* pInternalINmMember, INmMember** ppMember);


	// INmMember methods
	STDMETHOD(GetName)(BSTR *pbstrName);
	STDMETHOD(GetID)(ULONG * puID);
	STDMETHOD(GetNmVersion)(ULONG *puVersion);
	STDMETHOD(GetAddr)(BSTR *pbstrAddr, NM_ADDR_TYPE *puType);
	STDMETHOD(GetUserData)(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	STDMETHOD(GetConference)(INmConference **ppConference);
	STDMETHOD(GetNmchCaps)(ULONG *puchCaps);
	STDMETHOD(GetShareState)(NM_SHARE_STATE *puState);
	STDMETHOD(IsSelf)(void);
	STDMETHOD(IsMCU)(void);
	STDMETHOD(Eject)(void);

	// IInternalMemberObj methods		
	STDMETHOD(GetInternalINmMember)(INmMember** ppMember);


};


#endif // __NmMember_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmmanager.cpp ===
#include "precomp.h"

// NetMeeting stuff

#include "AtlExeModule.h" 
#include "ConfUtil.h"
#include "NmLdap.h"
#include "call.h"
#include "common.h"
#include "ConfMan.h"
#include "cmd.h"
#include "conf.h"
#include "iAppLdr.h"
#include "confroom.h"
#include "ConfPolicies.h"
#include "cmd.h"
#include "ConfWnd.h"
#include "Taskbar.h"
#include "certui.h"

// NetMeeting SDK includes
#include "NmEnum.h"
#include "NmManager.h"
#include "NmConference.h"
#include "NmCall.h"
#include "SDKWindow.h"
#include "dlgCall2.h"


bool g_bSDKPostNotifications;
extern BOOL g_fLoggedOn;
extern INmSysInfo2 * g_pNmSysInfo;
extern GUID g_csguidSecurity;

//static
CSimpleArray<CNmManagerObj*>* CNmManagerObj::ms_pManagerObjList = NULL;
bool g_bOfficeModeSuspendNotifications = false;
DWORD CNmManagerObj::ms_dwID = 1;

BOOL InitAppletSDK(void);
void CleanupAppletSDK(void);


///////////////////////////////////////////////
// Construction\Destruction
///////////////////////////////////////////////


CNmManagerObj::CNmManagerObj() 
: m_bInitialized(false), 
  m_chCaps(NMCH_NONE), 
  m_bNmActive(false),
  m_bSentConferenceCreated(false),
  m_dwID(0),
  m_dwSysInfoID(0),
  m_uOptions(0)

{
	DBGENTRY(CNmManagerObj::CNmManagerObj);

	CNmManagerObj* p = const_cast<CNmManagerObj*>(this);
	ms_pManagerObjList->Add(p);
	
	DBGEXIT(CNmManagerObj::CNmManagerObj);
}

CNmManagerObj::~CNmManagerObj()
{
	DBGENTRY(CNmManagerObj::~CNmManagerObj);

	CNmManagerObj* p = const_cast<CNmManagerObj*>(this);
	ms_pManagerObjList->Remove(p);

		// Free our conferencing objects
	while(m_SDKConferenceObjs.GetSize())
	{
		CComPtr<INmConference> sp = m_SDKConferenceObjs[0];
		m_SDKConferenceObjs.RemoveAt(0);
		sp.p->Release();
	}

		// Free our conferencing objects
	while(m_SDKCallObjs.GetSize())
	{
		CComPtr<INmCall> sp = m_SDKCallObjs[0];
		m_SDKCallObjs.RemoveAt(0);
		sp.p->Release();
	}

	m_spInternalNmManager = NULL;

	DBGEXIT(CNmManagerObj::~CNmManagerObj);
}

HRESULT CNmManagerObj::FinalConstruct()
{
	DBGENTRY(CNmManagerObj::FinalContstruct);
	HRESULT hr = S_OK;		

	m_bInitialized = false;
	m_dwInternalNmManagerAdvise = 0;

	DBGEXIT_HR(CNmManagerObj::FinalContstruct,hr);
	return hr;
}


ULONG CNmManagerObj::InternalRelease()
{
	ATLASSERT(m_dwRef > 0);

	--m_dwRef;

	if((1 == m_dwRef) && m_dwInternalNmManagerAdvise)
	{
		++m_dwRef;
		DWORD dwAdvise = m_dwInternalNmManagerAdvise;
		m_dwInternalNmManagerAdvise = 0;
		AtlUnadvise(m_spInternalNmManager, IID_INmManagerNotify, dwAdvise);
		--m_dwRef;
	}

	return m_dwRef;

}


void CNmManagerObj::FinalRelease()
{
	DBGENTRY(CNmManagerObj::FinalRelease);
	
	if(m_bInitialized)
	{
		switch(m_uOptions)
		{
			case NM_INIT_CONTROL:
					// Even though we have the NM_INIT_CONTROL flag set here
					// We may not me in INIT_CONTROL mode. NetMeeting may have 
					// already been up when we initialized.  In that case the UI is active
				if(_Module.InitControlMode())
				{
						// If we are the last NmManager object with NM_INIT_CONTROL, then
						// we should switch the UI mode away from InitControl
					if((GetManagerCount(NM_INIT_CONTROL) == 1))
					{
						if(!_Module.IsSDKCallerRTC())
						{
							_Module.SetInitControlMode(FALSE);
							::AddTaskbarIcon(::GetHiddenWindow());
						}
					}
				}
				break;

			case NM_INIT_OBJECT:
				// Check to see if this is the last "office" client
				if (GetManagerCount(NM_INIT_OBJECT) == 1)
				{
					CConfMan::AllowAV(TRUE);					
				}
				break;

			default:
				break;
		}
	}

	DBGEXIT(CNmManagerObj::FinalRelease);
}

/*static*/ HRESULT CNmManagerObj::InitSDK()
{
	DBGENTRY(CNmManagerObj::InitSDK);
	HRESULT hr = S_OK;

    g_bSDKPostNotifications = false;

	ms_pManagerObjList = new CSimpleArray<CNmManagerObj*>;
	if(!ms_pManagerObjList)
	{
		hr = E_OUTOFMEMORY;
	}

    ::InitAppletSDK();
    InitPluggableTransportSDK();

	DBGEXIT_HR(CNmManagerObj::InitSDK,hr);
	return hr;
}

/*static*/void CNmManagerObj::CleanupSDK()
{
	DBGENTRY(CNmManagerObj::CleanupSDK);

    ::CleanupAppletSDK();
    CleanupPluggableTransportSDK();

	delete ms_pManagerObjList;

	DBGEXIT(CNmManagerObj::CleanupSDK);
}


///////////////////////////////////////////////
// INmManager methods
///////////////////////////////////////////////

STDMETHODIMP CNmManagerObj::Initialize( ULONG * puOptions, ULONG *puchCaps)
{
	DBGENTRY(CNmManagerObj::Initialize);
	HRESULT hr = S_OK;

		// If the remote control service is running, this will bring up a dialog
		// that the user can choose weather or not to kill the remote control session
		// If they do want to kill the session then the mananger object will initialize properly
	if(!CheckRemoteControlService())
	{
		return E_FAIL;
	}

	m_uOptions = puOptions ? *puOptions : NM_INIT_NORMAL;

	if(puOptions && (*puOptions > NM_INIT_BACKGROUND))
	{
		hr = E_INVALIDARG;
		goto end;
	}

	if(!m_bInitialized)
	{
		bool bStartedNetMeeting = false;

		if(!g_pInternalNmManager)
		{
			if(NM_INIT_NO_LAUNCH == m_uOptions)
			{
					// We don't launch NetMeeting in this case...
				m_bNmActive = false;
				goto end;
			}

			if (NM_INIT_CONTROL == m_uOptions)
			{
				_Module.SetInitControlMode(TRUE);
			}
			
			hr = InitConfExe(NM_INIT_NORMAL == m_uOptions);

			bStartedNetMeeting = SUCCEEDED(hr);
		}

		if(SUCCEEDED(hr))
		{
			if(NM_INIT_OBJECT == m_uOptions)
			{
				if (!_Module.IsUIVisible())
				{
					CConfMan::AllowAV(FALSE);
				}
			}

			m_bNmActive = true;

			CFt::EnsureLoadFtApplet();

			m_spInternalNmManager = g_pInternalNmManager;

				// The old NetMeeting ignored this param...
				// for the time being, we are ignoring it too.

			//m_chCaps = puchCaps ? *puchCaps : NMCH_ALL;
			m_chCaps = NMCH_ALL;

			hr = AtlAdvise(m_spInternalNmManager,GetUnknown(),IID_INmManagerNotify, &m_dwInternalNmManagerAdvise);	
		}
	}
	else
	{
		hr = E_FAIL;
	}

end:

	m_bInitialized = SUCCEEDED(hr);
	if(m_bInitialized)
	{
		INmConference2* pConf = ::GetActiveConference();
	
		if(pConf)
		{
			ConferenceCreated(pConf);
				
				// If there is no manager notify hooked in, we simply 
				// sync up with the Internal conference object state
			IConnectionPointImpl<CNmManagerObj, &IID_INmManagerNotify, CComDynamicUnkArray>* pCP = this;
			if((0 == pCP->m_vec.GetSize()) && !m_bSentConferenceCreated)
			{
					// It must be the first conference, because we are newly-initialized
				ASSERT(m_SDKConferenceObjs[0]);

					// Sinc up the channels, etc.
				com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[0])->FireNotificationsToSyncToInternalObject();
			}
		}
	}

	DBGEXIT_HR(CNmManagerObj::Initialize,hr);
	return hr;
}

	// This is not guarenteed to work if called from conf.exe's process!!!
STDMETHODIMP CNmManagerObj::GetSysInfo(INmSysInfo **ppSysInfo)
{	
	DBGENTRY(CNmManagerObj::GetSysInfo);
	HRESULT hr = S_OK;

	hr = CoCreateInstance(CLSID_NmSysInfo, NULL, CLSCTX_ALL, IID_INmSysInfo, reinterpret_cast<void**>(ppSysInfo));

	if(*ppSysInfo)
	{
		m_dwID = ++ms_dwID;
		com_cast<IInternalSysInfoObj>(*ppSysInfo)->SetID(m_dwID);
	}

	DBGEXIT_HR(CNmManagerObj::GetSysInfo,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::CreateConference(INmConference **ppConference, BSTR bstrName, BSTR bstrPassword, ULONG uchCaps)
{
	DBGENTRY(CNmManagerObj::CreateConference);
	HRESULT hr = S_OK;

	if(m_bInitialized)
	{
		if(m_bNmActive)
		{
			if(ppConference)
			{
				if(m_spInternalNmManager)
				{
					switch(ConfPolicies::GetSecurityLevel())
					{
						case REQUIRED_POL_SECURITY:
							m_chCaps = uchCaps | NMCH_SECURE;
							break;
						case DISABLED_POL_SECURITY:
							m_chCaps = uchCaps & ~NMCH_SECURE;
							break;
						default:
							m_chCaps = uchCaps;
							break;
					}


					if(OfficeMode()) g_bOfficeModeSuspendNotifications = true;

					CComPtr<INmConference> spInternalINmConference;
					hr = m_spInternalNmManager->CreateConference(&spInternalINmConference, bstrName, bstrPassword, m_chCaps);
					if(SUCCEEDED(hr))
					{
							// This was created by the previous call
						*ppConference = GetSDKConferenceFromInternalConference(spInternalINmConference);

						if(*ppConference)
						{
							(*ppConference)->AddRef();
						}
						else
						{
							hr = E_UNEXPECTED;
						}
					}

					if(OfficeMode()) g_bOfficeModeSuspendNotifications = false;
				}
				else
				{
					hr = E_UNEXPECTED;
				}
			}
			else
			{
				hr = E_POINTER;
			}
		}
		else
		{
			hr = NM_E_NOT_ACTIVE;
		}
	}
	else
	{
		hr = NM_E_NOT_INITIALIZED;
	}

	DBGEXIT_HR(CNmManagerObj::CreateConference,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::EnumConference(IEnumNmConference **ppEnum)
{
	DBGENTRY(CNmManagerObj::EnumConference);
	HRESULT hr = S_OK;

	if(m_bInitialized)
	{
		if(m_bNmActive)
		{
			hr = CreateEnumFromSimpleAryOfInterface<IEnumNmConference, INmConference>(m_SDKConferenceObjs, ppEnum);
		}
		else
		{
			hr = NM_E_NOT_ACTIVE;
		}
	}
	else
	{		
		hr = NM_E_NOT_INITIALIZED;
	}	


	DBGEXIT_HR(CNmManagerObj::EnumConference,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::CreateCall(INmCall **ppCall, NM_CALL_TYPE callType, NM_ADDR_TYPE addrType, BSTR bstrAddr, INmConference *pConference)
{
	DBGENTRY(CNmManagerObj::CreateCall);
	HRESULT hr = S_OK;

	
	if(!m_bInitialized)
	{
		hr = NM_E_NOT_INITIALIZED;
		goto end;
	}

	if(!m_bNmActive)
	{
		hr = NM_E_NOT_ACTIVE;
		goto end;
	}

	if(m_spInternalNmManager)
	{
		if(!pConference)
		{	// Get the active conference
			pConference	= _GetActiveConference();

			if(!pConference)
			{ // There is no active	conf, so create	a new one

				CComPtr<INmConference> spInternalINmConference;						

					// TODO: What about	NMCH_SECURE?
				ULONG ulCaps = NMCH_AUDIO |	NMCH_VIDEO | NMCH_DATA | NMCH_SHARE	| NMCH_FT;

				CCalltoParams  params;
				bool bSecure = FALSE;

				LPTSTR  szName;
				hr =  BSTR_to_LPTSTR (&szName, bstrAddr);				        
				if (SUCCEEDED(hr))
				{    
					params.SetParams(szName);
					bSecure	= params.GetBooleanParam("secure",bSecure);
					delete (szName);
				}

				if(ConfPolicies::OutgoingSecurityPreferred() ||	bSecure)
				{
					ulCaps |= NMCH_SECURE;
				}	

				hr = m_spInternalNmManager->CreateConference(&spInternalINmConference, NULL, NULL, ulCaps);
				if(SUCCEEDED(hr))
				{
						// the above call to CreateConference generates	a callback,	so we have this	object now!
					pConference	= GetSDKConferenceFromInternalConference(spInternalINmConference);
				}
			}
		}

		CComPtr<INmCall> spInternalINmCall;

		if(SUCCEEDED(hr))
		{
		
			if(addrType == NM_ADDR_CALLTO)
			{
				ASSERT( g_pCCallto != NULL );

				if(NM_CALL_DEFAULT == callType)
				{
                    LPTSTR  szName;
                    hr =  BSTR_to_LPTSTR (&szName, bstrAddr);				        
                    if (SUCCEEDED(hr))
                    {    
						hr = g_pCCallto->Callto(szName,		//	pointer to the callto url to try to place the call with...
							NULL,					//	pointer to the display name to use...
							NM_ADDR_CALLTO,			//	callto type to resolve this callto as...
							false,					//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
							NULL,					//	security preference, NULL for none. must be "compatible" with secure param if present...
							false,					//	whether or not save in mru...
							false,					//	whether or not to perform user interaction on errors...
							NULL,					//	if bUIEnabled is true this is the window to parent error/status windows to...
							&spInternalINmCall );	//	out pointer to INmCall * to receive INmCall * generated by placing call...
							delete (szName);
                    }
                    else
                    {
                        goto end;
                    }
                                
				}
				else
				{
					hr = E_INVALIDARG;
					goto end;
				}
			}
			else
			{
				hr = SdkPlaceCall(callType, addrType, bstrAddr, NULL, NULL, &spInternalINmCall);
			}

			if(SUCCEEDED(hr))
			{
				CallCreated(spInternalINmCall);

				if(ppCall)
				{
					*ppCall = GetSDKCallFromInternalCall(spInternalINmCall);
					if(*ppCall)
					{
						(*ppCall)->AddRef();
					}
				}
			}
		}
	}
	else
	{
		hr = E_UNEXPECTED;
		ERROR_OUT(("Why don't we have a manager object"));
	}

end:
	DBGEXIT_HR(CNmManagerObj::CreateCall,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::CallConference(INmCall **ppCall, NM_CALL_TYPE callType, NM_ADDR_TYPE addrType, BSTR bstrAddr, BSTR bstrConferenceName, BSTR bstrPassword)
{
	DBGENTRY(CNmManagerObj::CallConference);
	HRESULT hr = S_OK;
	
	if(!m_bInitialized)
	{
		hr = NM_E_NOT_INITIALIZED;
		goto end;
	}

	if(!m_bNmActive)
	{
		hr = NM_E_NOT_ACTIVE;
		goto end;
	}

	{
		CComPtr<INmCall> spInternalINmCall;

		hr = SdkPlaceCall(callType, addrType, bstrAddr, bstrConferenceName, bstrPassword, &spInternalINmCall);
				
		if(SUCCEEDED(hr))
		{
			CallCreated(spInternalINmCall);
			*ppCall = GetSDKCallFromInternalCall(spInternalINmCall);
			if(*ppCall)
			{
				(*ppCall)->AddRef();
			}
		}
	}

end:
	DBGEXIT_HR(CNmManagerObj::CallConference,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::EnumCall(IEnumNmCall **ppEnum)
{
	DBGENTRY(CNmManagerObj::EnumCall);
	HRESULT hr = S_OK;

	if(m_bInitialized)
	{
		if(m_bNmActive)
		{
			hr = CreateEnumFromSimpleAryOfInterface<IEnumNmCall, INmCall>(m_SDKCallObjs, ppEnum);
		}
		else
		{
			hr = NM_E_NOT_ACTIVE;
		}
	}
	else
	{
		hr = NM_E_NOT_INITIALIZED;
	}

	DBGEXIT_HR(CNmManagerObj::EnumCall,hr);
	return hr;
}

///////////////////////////////////////////////
// INmObject methods
///////////////////////////////////////////////

STDMETHODIMP CNmManagerObj::CallDialog(long hwnd, int cdOptions)
{
	DBGENTRY(CNmManagerObj::CallDialog);
	HRESULT hr = S_OK;

	CFindSomeone::findSomeone(GetConfRoom());

	g_bSDKPostNotifications = true;

	if(OfficeMode() && !m_bSentConferenceCreated)
	{
		Fire_ConferenceCreated(m_SDKConferenceObjs[0]);
	}

	g_bSDKPostNotifications = false;

	DBGEXIT_HR(CNmManagerObj::CallDialog,hr);
	return hr;

}

extern "C" { BOOL WINAPI StartStopOldWB(LPCTSTR lpsz); }

STDMETHODIMP CNmManagerObj::ShowLocal(NM_APPID id)
{
	if(!m_bInitialized)
	{
		return NM_E_NOT_INITIALIZED;
	}

	if(!m_bNmActive)
	{
		return NM_E_NOT_ACTIVE;
	}

	switch (id)
		{
	case NM_APPID_WHITEBOARD:
		StartStopOldWB(NULL);
		return S_OK;

	case NM_APPID_T126_WHITEBOARD:
		return (T120_NO_ERROR == ::T120_LoadApplet(APPLET_ID_WB, TRUE , 0, FALSE, NULL)) ? S_OK : E_FAIL;

	case NM_APPID_CHAT:
		return (T120_NO_ERROR == T120_LoadApplet(APPLET_ID_CHAT, TRUE , 0, FALSE, NULL)) ? S_OK : E_FAIL;

	case NM_APPID_FILE_TRANSFER:
		return CFt::ShowFtUI();

	case NM_APPID_APPSHARING:
		if(g_pConfRoom && g_pConfRoom->IsSharingAllowed())
		{
			g_pConfRoom->CmdShowSharing();
			return S_OK;
		}
	
		return NM_E_SHARING_NOT_AVAILABLE;

	default:
		ERROR_OUT(("Unknown flag passed to ShowLocal"));
		break;
		}

	return E_INVALIDARG;
}

STDMETHODIMP CNmManagerObj::VerifyUserInfo(UINT_PTR hwnd, NM_VUI options)
{
	ASSERT(0);
	return E_UNEXPECTED;
}


////////////////////////////////////////////////////////////
// IInternalConfExe
////////////////////////////////////////////////////////////

STDMETHODIMP CNmManagerObj::LoggedIn()
{
	DBGENTRY(STDMETHODIMP CNmManagerObj::LoggedIn);
	HRESULT hr = g_fLoggedOn ? S_OK : S_FALSE;

	DBGEXIT_HR(STDMETHODIMP CNmManagerObj::LoggedIn,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::IsRunning()
{
	DBGENTRY(STDMETHODIMP CNmManagerObj::IsRunning);
	HRESULT hr = g_pInternalNmManager ? S_OK : S_FALSE;

	DBGEXIT_HR(STDMETHODIMP CNmManagerObj::IsRunning,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::InConference()
{
	DBGENTRY(STDMETHODIMP CNmManagerObj::InConference);
	HRESULT hr = ::FIsConferenceActive() ? S_OK : S_FALSE;

	DBGEXIT_HR(STDMETHODIMP CNmManagerObj::InConference,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::LDAPLogon(BOOL bLogon)
{
	DBGENTRY(STDMETHODIMP CNmManagerObj::LDAPLogon);
	HRESULT hr = S_OK;

	if(g_pLDAP)
	{
		hr = bLogon ? g_pLDAP->LogonAsync() : g_pLDAP->Logoff();
	}
	else
	{
		hr = E_FAIL;
	}

	DBGEXIT_HR(STDMETHODIMP CNmManagerObj::LDAPLogon,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::GetLocalCaps(DWORD* pdwLocalCaps)
{
	DBGENTRY(STDMETHODIMP CNmManagerObj::);
	HRESULT hr = S_OK;

	*pdwLocalCaps = g_uMediaCaps;

	DBGEXIT_HR(STDMETHODIMP CNmManagerObj::,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::IsNetMeetingRunning()
{
	return g_pInternalNmManager ? S_OK : S_FALSE;
}


STDMETHODIMP CNmManagerObj::GetActiveConference(INmConference** ppConf)
{
	if(ppConf && ms_pManagerObjList && m_dwSysInfoID)
	{
		for(int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			if((*ms_pManagerObjList)[i]->m_dwID == m_dwSysInfoID)
			{
				if((*ms_pManagerObjList)[i]->m_SDKConferenceObjs.GetSize() != 0)
				{
					*ppConf = (*ms_pManagerObjList)[i]->m_SDKConferenceObjs[0];
					(*ppConf)->AddRef();
					return S_OK;
				}
			}
		}
	}

	return E_FAIL;
}


//--------------------------------------------------------------------------//
//	CNmManagerObj::ShellCalltoProtocolHandler.								//
//--------------------------------------------------------------------------//
STDMETHODIMP
CNmManagerObj::ShellCalltoProtocolHandler
(
	BSTR	url,
	BOOL	bStrict
){
	ASSERT( g_pCCallto != NULL );

	HRESULT result = S_OK;
	
	if(!g_pInternalNmManager)
	{
		if(!CheckRemoteControlService())
		{
			return E_FAIL;
		}

		result = InitConfExe();
	}

	if( SUCCEEDED( result ) )
	{
        LPTSTR  szName;
        result =  BSTR_to_LPTSTR (&szName, url);				        
        if (SUCCEEDED(result))
        {    
            if(CCallto::DoUserValidation(szName))
            {
                result = g_pCCallto->Callto(szName,	//	pointer to the callto url to try to place the call with...
    									NULL,			//	pointer to the display name to use...
    									NM_ADDR_CALLTO,	//	callto type to resolve this callto as...
    									false,			//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
    									NULL,			//	security preference, NULL for none. must be "compatible" with secure param if present...
    									false,			//	whether or not save in mru...
    									true,			//	whether or not to perform user interaction on errors...
    									NULL,			//	if bUIEnabled is true this is the window to parent error/status windows to...
    									NULL );			//	out pointer to INmCall * to receive INmCall * generated by placing call...
            }

            delete  (szName);
        }
	}

	return( result );

}	//	End of CNmManagerObj::ShellCalltoProtocolHandler.

//--------------------------------------------------------------------------//
//	CNmManagerObj::Launch.													//
//--------------------------------------------------------------------------//
STDMETHODIMP
CNmManagerObj::Launch()
{
	if(_Module.InitControlMode()) 
	{	
		return E_FAIL;
	}
	else
	{
		if(!g_pInternalNmManager)
		{
			if(!CheckRemoteControlService())
			{
				return E_FAIL;
			}

			InitConfExe();
		}
		else
		{
			::CreateConfRoomWindow();
		}
	}

	return S_OK;

}	//	End of CNmManagerObj::Launch.


LPTSTR StripDoubleQuotes(LPTSTR sz)
{
	BOOL    fSkippedQuote = FALSE;

	if (sz)
	{
		int     cchLength;

		// Skip past first quote
		if (fSkippedQuote = (*sz == '"'))
			sz++;

		cchLength = lstrlen(sz);

		//
		// NOTE:
		// There may be DBCS implications with this.  Hence we check to see
		// if we skipped the first quote; we assume that if the file name
		// starts with a quote it must end with one also.  But we need to check
		// it out.
		//
		// Strip last quote
		if (fSkippedQuote && (cchLength > 0) && (sz[cchLength - 1] == '"'))
		{
			BYTE * pLastQuote = (BYTE *)&sz[cchLength - 1];
			*pLastQuote = '\0';
		}
	}

	return sz;
}


STDMETHODIMP CNmManagerObj::LaunchApplet(NM_APPID appid, BSTR strCmdLine)
{

	if(!g_pInternalNmManager)
	{
		if(!CheckRemoteControlService())
		{
			return E_FAIL;
		}

		InitConfExe();
	}

       LPTSTR  szName = NULL;
       BSTR_to_LPTSTR (&szName, strCmdLine);				        

	switch(appid)
	{
		case NM_APPID_WHITEBOARD:
			CmdShowOldWhiteboard(strCmdLine ? StripDoubleQuotes(szName) : NULL);
			break;

		case NM_APPID_T126_WHITEBOARD:
			::CmdShowNewWhiteboard(strCmdLine ? StripDoubleQuotes(szName) : NULL);
			break;

		case NM_APPID_CHAT:
			CmdShowChat();
			break;
	}

	if(szName)
    	{
           delete (szName);
	}

	return S_OK;
}


STDMETHODIMP CNmManagerObj::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	if(g_pNmSysInfo)
	{
		return g_pNmSysInfo->GetUserData(rguid, ppb, pcb);
	}

	return NM_E_NOT_ACTIVE;
}

STDMETHODIMP CNmManagerObj::SetUserData(REFGUID rguid, BYTE *pb, ULONG cb)
{
	//
	// Special case this guid to allow changing cert via SetUserData
	//
	if ( g_csguidSecurity == rguid )
	{
		return SetCertFromCertInfo ( (PCERT_INFO) pb );
	}
	if(g_pNmSysInfo)
	{
		return g_pNmSysInfo->SetUserData(rguid, pb, cb);
	}

	return NM_E_NOT_ACTIVE;
}

STDMETHODIMP CNmManagerObj::DisableH323(BOOL bDisableH323)
{
	if(!g_pInternalNmManager)
	{
		_Module.SetSDKDisableH323(bDisableH323);
		return S_OK;
	}

	return NM_E_ALREADY_RUNNING;
}

STDMETHODIMP CNmManagerObj::SetCallerIsRTC (BOOL bCallerIsRTC)
{
	if(!g_pInternalNmManager)
	{
		_Module.SetSDKCallerIsRTC(bCallerIsRTC);
		return S_OK;
	}

	return NM_E_ALREADY_RUNNING;
}

STDMETHODIMP CNmManagerObj::DisableInitialILSLogon(BOOL bDisable)
{
	if(!g_pInternalNmManager)
	{
		_Module.SetSDKDisableInitialILSLogon(bDisable);
		return S_OK;
	}

	return NM_E_ALREADY_RUNNING;
}

///////////////////////////////////////////////
// INmManagerNotify methods:
///////////////////////////////////////////////

STDMETHODIMP CNmManagerObj::NmUI(CONFN uNotify)
{
	DBGENTRY(CNmManagerObj::NmUI);
	HRESULT hr = S_OK;

		// We should not be sending other notifactions
	ASSERT(CONFN_NM_STARTED == uNotify);
	hr = Fire_NmUI(uNotify);

	DBGEXIT_HR(CNmManagerObj::NmUI,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::ConferenceCreated(INmConference *pInternalConference)
{
	DBGENTRY(CNmManagerOebj::ConferenceCreated);
	HRESULT hr = S_OK;

	CComPtr<INmConference> spConf;

	hr = CNmConferenceObj::CreateInstance(this, pInternalConference, &spConf);

	if(SUCCEEDED(hr))
	{
		spConf.p->AddRef();
		m_SDKConferenceObjs.Add(spConf.p);
		Fire_ConferenceCreated(spConf);

		if(!CFt::IsFtActive() && FileTransferNotifications())
		{
			CFt::StartNewConferenceSession();
		}
	}

	DBGEXIT_HR(CNmManagerObj::ConferenceCreated,hr);
	return hr;
}


STDMETHODIMP CNmManagerObj::CallCreated(INmCall *pInternalCall)
{
	DBGENTRY(CNmManagerObj::CallCreated);
	HRESULT hr = S_OK;

	if(m_bInitialized)
	{
		if(NULL == GetSDKCallFromInternalCall(pInternalCall))
		{	
			// First we make sure that we don't have the call object yet
			CComPtr<INmCall> spCall;
			hr = CNmCallObj::CreateInstance(this, pInternalCall, &spCall);		

			if(SUCCEEDED(hr))
			{
				spCall.p->AddRef();
				m_SDKCallObjs.Add(spCall.p);
				Fire_CallCreated(spCall);
			}
		}
	}

	DBGEXIT_HR(CNmManagerObj::CallCreated,hr);
	return hr;
}


///////////////////////////////////////////////
// Notifications
///////////////////////////////////////////////

HRESULT CNmManagerObj::Fire_ConferenceCreated(INmConference *pConference)
{
	DBGENTRY(CNmManagerObj::Fire_ConferenceCreated);
	HRESULT hr = S_OK;

		// Som SDK clients need this to come in at a specific time....
	if(m_bSentConferenceCreated || OfficeMode() && g_bOfficeModeSuspendNotifications)
	{
			// We don't have to notify anyone at all...
		return S_OK;			
	}

	if(!g_bSDKPostNotifications)
	{
		IConnectionPointImpl<CNmManagerObj, &IID_INmManagerNotify, CComDynamicUnkArray>* pCP = this;

		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			m_bSentConferenceCreated = true;

			INmManagerNotify* pNotify = reinterpret_cast<INmManagerNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->ConferenceCreated(pConference);

							// Sinc up the channels, etc.
				com_cast<IInternalConferenceObj>(pConference)->FireNotificationsToSyncToInternalObject();

			}
		}
	}
	else
	{
		hr = CSDKWindow::PostConferenceCreated(this, pConference);
	}

	DBGEXIT_HR(CNmManagerObj::Fire_ConferenceCreated,hr);
	return hr;		
}

HRESULT CNmManagerObj::Fire_CallCreated(INmCall* pCall)
{
	DBGENTRY(CNmManagerObj::Fire_CallCreated);
	HRESULT hr = S_OK;

		// Always send Outgoing call notifications
		// Only send incoming call notifications to INIT CONTROL clients.
	if((S_OK != pCall->IsIncoming()) || _Module.InitControlMode())
	{
		if(!g_bSDKPostNotifications)
		{
			IConnectionPointImpl<CNmManagerObj, &IID_INmManagerNotify, CComDynamicUnkArray>* pCP = this;

			for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
			{
				INmManagerNotify* pNotify = reinterpret_cast<INmManagerNotify*>(pCP->m_vec.GetAt(i));

				if(pNotify)
				{
					pNotify->CallCreated(pCall);
				}
			}
		}
		else
		{
			hr = CSDKWindow::PostCallCreated(this, pCall);	
		}
	}

	DBGEXIT_HR(CNmManagerObj::Fire_CallCreated,hr);
	return hr;		
}


HRESULT CNmManagerObj::Fire_NmUI(CONFN uNotify)
{
	DBGENTRY(CNmManagerObj::Fire_NmUI);
	HRESULT hr = S_OK;

		// notice the InSendMessage statement.
		// The problem is that we can get this notificaiton in
		// response to the taskbar icon being clicked. In that case
		// an inter-thread SendMessage is occuring.  If we try to make
		// the NmUi call, we will get RPC_E_CANTCALLOUT_INPUTSYNCCALL
	if(!g_bSDKPostNotifications && !InSendMessage())
	{
		IConnectionPointImpl<CNmManagerObj, &IID_INmManagerNotify, CComDynamicUnkArray>* pCP = this;

		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			
			INmManagerNotify* pNotify = reinterpret_cast<INmManagerNotify*>(pCP->m_vec.GetAt(i));
			if(pNotify)
			{
				pNotify->NmUI(uNotify);
			}
		}
	}
	else
	{
		hr = CSDKWindow::PostManagerNmUI(this, uNotify);
	}

	DBGEXIT_HR(CNmManagerObj::Fire_NmUI,hr);
	return hr;		
}



///////////////////////////////////////////////
// Helper Fns
///////////////////////////////////////////////

INmConference* CNmManagerObj::_GetActiveConference()
{
	INmConference* pConf = NULL;

	if(m_SDKConferenceObjs.GetSize())
	{
		pConf = m_SDKConferenceObjs[0];
	}

	return pConf;
}
	


INmCall* CNmManagerObj::GetSDKCallFromInternalCall(INmCall* pInternalCall)
{

	INmCall* pRet = NULL;

	for( int i = 0; i < m_SDKCallObjs.GetSize(); ++i)
	{
		CComQIPtr<IInternalCallObj> spInternal = m_SDKCallObjs[i];
		ASSERT(spInternal);

		CComPtr<INmCall> spCall;
		if(SUCCEEDED(spInternal->GetInternalINmCall(&spCall)))
		{
			if(spCall.IsEqualObject(pInternalCall))
			{
				pRet = m_SDKCallObjs[i];
				break;
			}
		}
	}

	return pRet;
}

INmConference* CNmManagerObj::GetSDKConferenceFromInternalConference(INmConference* pInternalConference)
{

	INmConference* pRet = NULL;

	for( int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		CComQIPtr<IInternalConferenceObj> spInternal = m_SDKConferenceObjs[i];
		ASSERT(spInternal);

		CComPtr<INmConference> spConference;
		if(SUCCEEDED(spInternal->GetInternalINmConference(&spConference)))
		{
			if(spConference.IsEqualObject(pInternalConference))
			{
				pRet = m_SDKConferenceObjs[i];
				break;
			}
		}
	}

	return pRet;
}

HRESULT CNmManagerObj::RemoveCall(INmCall* pSDKCallObj)
{
	HRESULT hr = S_OK;
	for(int i = 0; i < m_SDKCallObjs.GetSize(); ++i)
	{
		CComPtr<INmCall> spSDKCallObj = m_SDKCallObjs[i];
		if(spSDKCallObj.IsEqualObject(pSDKCallObj))
		{
			m_SDKCallObjs.RemoveAt(i);
			spSDKCallObj.p->Release();
		}
	}

	return hr;
}


HRESULT CNmManagerObj::RemoveConference(INmConference* pSDKConferenceObj)
{
	HRESULT hr = S_OK;
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		CComPtr<INmConference> spSDKConferenceObj = m_SDKConferenceObjs[i];
		if(spSDKConferenceObj.IsEqualObject(pSDKConferenceObj))
		{
			m_SDKConferenceObjs.RemoveAt(i);
			spSDKConferenceObj.p->Release();
		}
	}

	return hr;
}

bool CNmManagerObj::AudioNotifications()
{
	return m_bInitialized && (m_chCaps & NMCH_AUDIO);
}

bool CNmManagerObj::VideoNotifications()
{
	return m_bInitialized && (m_chCaps & NMCH_VIDEO);
}

bool CNmManagerObj::DataNotifications()
{
	return m_bInitialized && (m_chCaps & NMCH_DATA);
}

bool CNmManagerObj::FileTransferNotifications()
{
	return m_bInitialized && (m_chCaps & NMCH_FT);
}

bool CNmManagerObj::AppSharingNotifications()
{
	return m_bInitialized && (m_chCaps & NMCH_SHARE);
}



//static 
void CNmManagerObj::NetMeetingLaunched()
{
	ASSERT(ms_pManagerObjList);

	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->Fire_NmUI(CONFN_NM_STARTED);
		}
	}
}


//static 
void CNmManagerObj::SharableAppStateChanged(HWND hWnd, NM_SHAPP_STATE state)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_SharableAppStateChanged(hWnd, state);
		}
	}
}


void CNmManagerObj::_SharableAppStateChanged(HWND hWnd, NM_SHAPP_STATE state)
{
		// Free our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->SharableAppStateChanged(hWnd, state);
	}
}

//static 
void CNmManagerObj::AppSharingChannelChanged()
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_AppSharingChannelChanged();
		}
	}
}

void CNmManagerObj::_AppSharingChannelChanged()
{
		// Free our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->AppSharingChannelChanged();
	}
}

//static 
void CNmManagerObj::AppSharingChannelActiveStateChanged(bool bActive)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_AppSharingChannelActiveStateChanged(bActive);
		}
	}
}


void CNmManagerObj::_AppSharingChannelActiveStateChanged(bool bActive)
{
		// Free our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->AppSharingStateChanged(bActive);
	}
}

//static 
void CNmManagerObj::ASLocalMemberChanged()
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_ASLocalMemberChanged();
		}
	}
}

void CNmManagerObj::_ASLocalMemberChanged()
{
		// notify our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->ASLocalMemberChanged();
	}	
}

//static
void CNmManagerObj::ASMemberChanged(UINT gccID)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_ASMemberChanged(gccID);
		}
	}
}

void CNmManagerObj::_ASMemberChanged(UINT gccID)
{
		// notify our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->ASMemberChanged(gccID);
	}	
}

// static
void CNmManagerObj::AudioChannelActiveState(BOOL bActive, BOOL bIsIncoming)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_AudioChannelActiveState(bActive, bIsIncoming);
		}
	}
}

void CNmManagerObj::_AudioChannelActiveState(BOOL bActive, BOOL bIsIncoming)
{
		// notify our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->AudioChannelActiveState(bActive ? TRUE : FALSE, bIsIncoming);
	}	
}

// static
void CNmManagerObj::VideoChannelActiveState(BOOL bActive, BOOL bIsIncoming)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_VideoChannelActiveState(bActive, bIsIncoming);
		}
	}
}

void CNmManagerObj::_VideoChannelActiveState(BOOL bActive, BOOL bIsIncoming)
{
		// notify our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->VideoChannelActiveState(bActive ? TRUE : FALSE, bIsIncoming);
	}	
}

// static
void CNmManagerObj::VideoPropChanged(DWORD dwProp, BOOL bIsIncoming)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_VideoPropChanged(dwProp, bIsIncoming);
		}
	}
}

void CNmManagerObj::_VideoPropChanged(DWORD dwProp, BOOL bIsIncoming)
{
		// notify our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->VideoChannelPropChanged(dwProp, bIsIncoming);
	}	
}

// static
void CNmManagerObj::VideoChannelStateChanged(NM_VIDEO_STATE uState, BOOL bIsIncoming)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_VideoChannelStateChanged(uState, bIsIncoming);
		}
	}
}

void CNmManagerObj::_VideoChannelStateChanged(NM_VIDEO_STATE uState, BOOL bIsIncoming)
{
		// notify our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->VideoChannelStateChanged(uState, bIsIncoming);
	}	
}

UINT CNmManagerObj::GetManagerCount(ULONG uOption)
{
	UINT nMgrs = 0;
	for(int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
	{
		if(uOption == (*ms_pManagerObjList)[i]->m_uOptions)
		{
			nMgrs++;
		}
	}
	return nMgrs;
}

void CNmManagerObj::OnShowUI(BOOL fShow)
{
	_Module.SetUIVisible(fShow);

	if (fShow)
	{
		CConfMan::AllowAV(TRUE);
	}
	else
	{
		if(0 != GetManagerCount(NM_INIT_OBJECT))
		{
			CConfMan::AllowAV(FALSE);
		}
	}
}

HRESULT CNmManagerObj::SdkPlaceCall(NM_CALL_TYPE callType,
						 NM_ADDR_TYPE addrType,
						 BSTR bstrAddr,
						 BSTR bstrConf,
						 BSTR bstrPw,
						 INmCall **ppInternalCall)
{

	HRESULT hr;
       LPTSTR  szAddr = NULL;
       LPTSTR  szConf = NULL;
       LPTSTR  szPw = NULL;


	DWORD dwFlags = MapNmCallTypeToCallFlags(callType, addrType, g_uMediaCaps);
	if (0 == dwFlags)
	{
		hr = NM_CALLERR_MEDIA;
		goto end;
	}

	{

               BSTR_to_LPTSTR (&szAddr, bstrAddr);				        


		if(NM_ADDR_T120_TRANSPORT == addrType)
		{
			//
			// Check if  "+secure=true" parameter was passed
			//
			CCalltoParams  params;
			bool bSecure = FALSE;

                     params.SetParams(szAddr);
                     bSecure = params.GetBooleanParam("secure",bSecure);
	

			//
			// Yes it was in the parameters.
			// Now make sure to remove it
			// The addre now is like "111.222.333.444+secure=true"
			// The call will only work if we pass the ip address only
			//
			if(bSecure)
			{

				// Get the syze of the bstr
				int cch = lstrlen(szAddr);
				BYTE *pByte =  (BYTE *) szAddr;

				for(int i = 0; i < cch;i++)
				{
					// Null terminate the string
					if(*pByte == '+')
					{
						*pByte = '\0';
						break;
					}
					pByte++;
				}
				
				
				dwFlags |= CRPCF_SECURE;
			}
		}
		
		CCallResolver  CallResolver(szAddr, addrType);
		hr = CallResolver.Resolve();
		if (FAILED(hr))
		{
			goto end;
		}

		CCall* pCall = new CCall(CallResolver.GetPszAddr(), szAddr, NM_ADDR_CALLTO, FALSE, FALSE);


		if(NULL == pCall)
		{
			goto end;
		}

		pCall->AddRef();
		switch(CallResolver.GetAddrType())
		{
			case NM_ADDR_ULS:
			case NM_ADDR_IP:
			case NM_ADDR_MACHINENAME:
			case NM_ADDR_H323_GATEWAY:
				ASSERT(FIpAddress(CallResolver.GetPszAddrIP()));
				/////////////////////////////////////////////
				// !!!!! HEY RYAN, WERE FALLING THROUGH !!!!!
				/////////////////////////////////////////////
			case NM_ADDR_T120_TRANSPORT:

                            BSTR_to_LPTSTR (&szConf, bstrConf);				        
                            BSTR_to_LPTSTR (&szPw, bstrPw);				        
				hr = pCall->PlaceCall(
						dwFlags, // dwFlags
						CallResolver.GetAddrType(), // addrType
						NULL,	// szSetup
						(NM_ADDR_T120_TRANSPORT == CallResolver.GetAddrType()) ?
							CallResolver.GetPszAddr() :
							CallResolver.GetPszAddrIP(), // szDestination
						CallResolver.GetPszAddr(),// szAlias
						NULL,				// szURL
						(szConf),	// szConference
						(szPw),		// szPassword
						NULL);				// szUserData
				break;

			default:
				ERROR_OUT(("Don't know this call type"));
				ASSERT(0);
				break;
		}

		if( FAILED(hr) && (pCall->GetState() == NM_CALL_INVALID ) )
		{
			// just release the call to free the data
			// otherwise wait for the call state to be changed
			pCall->Release();
		}

		if(ppInternalCall && SUCCEEDED(hr))
		{
			*ppInternalCall = pCall->GetINmCall();
			(*ppInternalCall)->AddRef();
		}

		pCall->Release();
	}

end:


	if( FAILED( hr ) && _Module.IsUIActive() )
	{
		DisplayCallError( hr, szAddr );
	}

       delete szAddr;
       delete szConf;
       delete szPw;

	return hr;
}


DWORD CNmManagerObj::MapNmCallTypeToCallFlags(NM_CALL_TYPE callType, NM_ADDR_TYPE addrType, UINT uCaps)
{
	DWORD dwFlags = 0;
    BOOL fForceSecure = FALSE;

	// Check global conference status
	if (INmConference *pConf = ::GetActiveConference())
	{
		// We are in a conference.  Use the conference security setting.
		DWORD dwCaps;

		if ((S_OK == pConf->GetNmchCaps(&dwCaps)) &&
			(NMCH_SECURE & dwCaps))
		{
			fForceSecure = TRUE;
		}
	}
	else
	{
	    fForceSecure = (REQUIRED_POL_SECURITY == ConfPolicies::GetSecurityLevel());
	}

	switch(addrType)
	{
		case NM_ADDR_T120_TRANSPORT:
			dwFlags = CRPCF_T120 | CRPCF_DATA;
			if(ConfPolicies::OutgoingSecurityPreferred() || fForceSecure)
			{
				dwFlags |= CRPCF_SECURE;
			}

			break;

		default:
			switch (callType)
			{
				case NM_CALL_T120:
					if (fForceSecure)
					{
						dwFlags = CRPCF_T120 | CRPCF_DATA | CRPCF_SECURE;
					}
					else
					{
						dwFlags = CRPCF_T120 | CRPCF_DATA;
					}
					break;

				case NM_CALL_H323:
					if (!fForceSecure)
					{
						dwFlags = CRPCF_H323CC;
						if (uCaps & (CAPFLAG_RECV_AUDIO | CAPFLAG_SEND_AUDIO))
							dwFlags |= CRPCF_AUDIO;
						if (uCaps & (CAPFLAG_RECV_VIDEO | CAPFLAG_SEND_VIDEO))
							dwFlags |= CRPCF_VIDEO;
					}
					break;

				case NM_CALL_DEFAULT:
					if (fForceSecure)
					{
						dwFlags = CRPCF_T120 | CRPCF_DATA | CRPCF_SECURE;
					}
					else
					{
						dwFlags = CRPCF_DEFAULT;
						// strip AV if policies prohibit
						if((uCaps & (CAPFLAG_RECV_AUDIO |CAPFLAG_SEND_AUDIO)) == 0)
						{
							dwFlags &= ~CRPCF_AUDIO;
						}
						if((uCaps & (CAPFLAG_RECV_VIDEO |CAPFLAG_SEND_VIDEO)) == 0)
						{
							dwFlags &= ~CRPCF_VIDEO;
						}
					}
					break;

				default:
					dwFlags = 0;
					break;
			}
	}

	return dwFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmsharableapp.cpp ===
#include "precomp.h"
#include "Confroom.h"

// SDK includes
#include "SDKInternal.h"
#include "NmChannel.h"
#include "NmChannelAppShare.h"
#include "NmSharableApp.h"

HRESULT CNmSharableAppObj::CreateInstance(HWND hWnd, 
										  LPCTSTR szName,
										  INmSharableApp** ppNmSharableApp)
{

	HRESULT hr = S_OK;

	CComObject<CNmSharableAppObj>* p = NULL;
	p = new CComObject<CNmSharableAppObj>(NULL);

	if (p != NULL)
	{
		if(SUCCEEDED(hr))
		{
			p->m_hWnd = hWnd;
		}

		if(ppNmSharableApp)
		{
			p->SetVoid(NULL);

			hr = p->QueryInterface(IID_INmSharableApp, reinterpret_cast<void**>(ppNmSharableApp));

			if(FAILED(hr))
			{
				delete p;
				*ppNmSharableApp = NULL;
			}
		}
		else
		{
			delete p;
			hr = E_POINTER;
		}
		
	}

	return hr;
}


STDMETHODIMP CNmSharableAppObj::GetName(BSTR *pbstrName)
{
	HRESULT hr = E_POINTER;

	if(pbstrName) 
	{
		TCHAR szName[MAX_PATH];
		hr = CNmChannelAppShareObj::GetSharableAppName(m_hWnd, szName, CCHMAX(szName));
		if(SUCCEEDED(hr))
		{
			*pbstrName = CComBSTR(szName).Copy();

			if(*pbstrName)
			{
				hr = S_OK;
			}
			else
			{
				hr = E_OUTOFMEMORY;	
			}

		}
	}
	return hr;	
}

STDMETHODIMP CNmSharableAppObj::GetHwnd(HWND * phwnd)
{
	HRESULT hr = E_POINTER;

	if(phwnd)
	{
		*phwnd = m_hWnd;
		hr = S_OK;
	}

	return hr;

}

STDMETHODIMP CNmSharableAppObj::GetState(NM_SHAPP_STATE *puState)
{
	HRESULT hr = E_POINTER;
	if(puState)
	{
		hr = ::GetWindowState(puState, m_hWnd);
	}
	
	return hr;

}

extern bool g_bSDKPostNotifications;

STDMETHODIMP CNmSharableAppObj::SetState(NM_SHAPP_STATE uState)
{
	HRESULT hr = E_UNEXPECTED;

	g_bSDKPostNotifications = true;

	if(NM_SHAPP_SHARED == uState)
	{
		hr = ::ShareWindow(m_hWnd);
	}
	else if(NM_SHAPP_NOT_SHARED == uState)
	{
		hr = ::UnShareWindow(m_hWnd);
	}

	g_bSDKPostNotifications = false;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nr_uls.h ===
#ifndef NR_ULS_INCLUDED
#define NR_ULS_INCLUDED

#include "nrcommon.h"

DWORD ResolveULSName ( LPCSTR szName, LPBYTE lpResult,
	LPDWORD lpdwResult, LPSTR lpszDisplayName, LPDWORD lpdwDisplayName,
	BOOL fTypeKnown, DWORD dwFlags, LPUINT puRequest, PASR pAsr );

DWORD CheckULSName ( LPCSTR szName );

DWORD InitializeULSNameRes();

#endif // NR_ULS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nr_ip.h ===
#ifndef NR_IP_INCLUDED
#define NR_IP_INCLUDED

#include "winsock.h"
#include "regentry.h"
#include "confreg.h"
#include "nrcommon.h"

// Below definitions from NetNameValidate for computer names
/*** Internal definitions ***/
/* NOTE - These should be defined globally */
#define CTRL_CHARS_STR	CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3
#define	CNLEN	15

#define CTRL_CHARS_0	    "\001\002\003\004\005\006\007"
#define CTRL_CHARS_1	"\010\011\012\013\014\015\016\017"
#define CTRL_CHARS_2	"\020\021\022\023\024\025\026\027"
#define CTRL_CHARS_3	"\030\031\032\033\034\035\036\037"

#define ILLEGAL_NAME_CHARS_STR	"\"/\\[]:|<>+=;,?" CTRL_CHARS_STR

extern DWORD ResolveIpName ( LPCSTR szName, LPBYTE lpResult,
	LPDWORD lpdwResult, LPSTR lpszDisplayName, LPDWORD lpdwDisplayName,
	BOOL fTypeKnown, DWORD dwFlags, LPUINT puRequest, PASR pAsr );

extern DWORD CheckIpName ( LPCSTR szName );

extern DWORD InitializeIp ( VOID );

extern DWORD DeinitializeIp ( VOID );

extern BOOL NEAR IsDottedDecimalIpAddress ( LPCSTR szName, LPSTR szOut );
extern BOOL NEAR IsDottedDNSAddress ( LPCSTR szName, LPSTR szOut );

#endif // NR_IP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\nmsharableapp.h ===
#ifndef __NmSharableApp_h__
#define __NmSharableApp_h__

class ATL_NO_VTABLE CNmSharableAppObj :
	public CComObjectRootEx<CComSingleThreadModel>,
	public INmSharableApp
{

protected:

		// Data
	HWND			m_hWnd;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmSharableAppObj)

BEGIN_COM_MAP(CNmSharableAppObj)
	COM_INTERFACE_ENTRY(INmSharableApp)
END_COM_MAP()

////////////////////////////////////////////////	
// Construction and destruction

	static HRESULT CreateInstance(HWND hWnd, 
								  LPCTSTR szName,
								  INmSharableApp** ppNmSharableApp);

    STDMETHOD(GetName)(BSTR *pbstrName);

    STDMETHOD(GetHwnd)(HWND * phwnd);

    STDMETHOD(GetState)(NM_SHAPP_STATE *puState);

    STDMETHOD(SetState)(NM_SHAPP_STATE uState);

};

#endif // __NmSharableApp_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\passdlg.h ===
/****************************************************************************
*
*    FILE:     PassDlg.h
*
*    CREATED:  Chris Pirich (ChrisPi) 1-25-96
*
****************************************************************************/

#ifndef _PASSDLG_H_
#define _PASSDLG_H_

#include <cstring.hpp>

class CPasswordDlg
{
protected:
	HWND		m_hwndParent;
	HWND		m_hwnd;

	CSTRING		m_strConfName;
	CSTRING		m_strPassword;
        CSTRING     m_strCert;
        BOOL        m_fRemoteIsRDS;

        static CSTRING *m_pstrUser;
        static CSTRING *m_pstrDomain;

	BOOL		ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

	// Handlers:
	BOOL		OnOk();

public:
	// Properties:

	LPCTSTR		GetPassword() { return (LPCTSTR) m_strPassword; };
	
	// Methods:
				CPasswordDlg(HWND hwndParent, LPCTSTR pcszConfName, LPCTSTR pCertText, BOOL fIsService);
	//			~CPasswordDlg();
	INT_PTR	DoModal();

	static INT_PTR CALLBACK PasswordDlgProc(	HWND hDlg,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);
        static BOOL          Init();
        static VOID          Cleanup();
};

#endif // _PASSDLG_H_








=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\passdlg.cpp ===
// File: passdlg.cpp

#include "precomp.h"
#include "resource.h"
#include "PassDlg.h"
#include "help_ids.h"

#define USERSIZE        20
#define DOMAINSIZE      15
#define PASSWDSIZE      256

static const DWORD aHelpIdsPassword[] = {
	IDC_EDIT_PASSWORD,  IDH_ADV_PASSWORD,
	0, 0   // terminator
};


/****************************************************************************
*
*    CLASS:    CPasswordDlg
*
*    MEMBER:   CPasswordDlg()
*
*    PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CPasswordDlg::CPasswordDlg(HWND hwndParent, LPCTSTR pcszConfName, LPCTSTR pCertText, BOOL fIsService):
	m_hwndParent(hwndParent),
        m_strConfName((LPCTSTR) pcszConfName),
        m_hwnd(NULL),
	m_fRemoteIsRDS(fIsService),
	m_strCert(pCertText)
{
	DebugEntry(CPasswordDlg::CPasswordDlg);

	DebugExitVOID(CPasswordDlg::CPasswordDlg);
}


/****************************************************************************
*
*    CLASS:    CPasswordDlg
*
*    MEMBER:   DoModal()
*
*    PURPOSE:  Brings up the modal dialog box
*
****************************************************************************/

INT_PTR CPasswordDlg::DoModal()
{
	DebugEntry(CPasswordDlg::DoModal);

	INT_PTR nRet = DialogBoxParam(	::GetInstanceHandle(),
                                        m_fRemoteIsRDS ? MAKEINTRESOURCE(IDD_PASSWORD_RDS): MAKEINTRESOURCE(IDD_PASSWORD),
                                        m_hwndParent,
                                        CPasswordDlg::PasswordDlgProc,
                                        (LPARAM) this);

	DebugExitINT_PTR(CPasswordDlg::DoModal, nRet);

	return nRet;
}

/****************************************************************************
*
*    CLASS:    CPasswordDlg
*
*    MEMBER:   PasswordDlgProc()
*
*    PURPOSE:  Dialog Proc - handles all messages
*
****************************************************************************/

INT_PTR CALLBACK CPasswordDlg::PasswordDlgProc(HWND hDlg,
                                            UINT uMsg,
                                            WPARAM wParam,
                                            LPARAM lParam)
{
	BOOL bMsgHandled = FALSE;

	// uMsg may be any value.
	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hDlg, WND));

	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			if (NULL != lParam)
			{
				((CPasswordDlg*) lParam)->m_hwnd = hDlg;
				SetWindowLongPtr(hDlg, DWLP_USER, lParam);

				// Set the conference name
                                if (((CPasswordDlg*) lParam)->m_fRemoteIsRDS)
                                {
                                    ::SetDlgItemText( hDlg, IDC_EDIT_RDS_CERT, ((CPasswordDlg*) lParam)->m_strCert);
                                    ::SendDlgItemMessage( hDlg, IDC_EDIT_USERNAME, EM_LIMITTEXT, (WPARAM) USERSIZE, 0);
                                    ::SendDlgItemMessage( hDlg, IDC_EDIT_PASSWORD, EM_LIMITTEXT, (WPARAM) PASSWDSIZE, 0);
                                    ::SendDlgItemMessage( hDlg, IDC_EDIT_DOMAIN, EM_LIMITTEXT, (WPARAM) DOMAINSIZE, 0);
                                    ::SetDlgItemText( hDlg, IDC_EDIT_USERNAME, *(m_pstrUser));
                                    ::SetDlgItemText( hDlg, IDC_EDIT_DOMAIN, *(m_pstrDomain));
                                }
                                else
                                {
                                    ::SetDlgItemText( hDlg, IDC_STATIC_CONFNAME, ((CPasswordDlg*) lParam)->m_strConfName);
                                }

				// Bring it to the foreground
				::SetForegroundWindow(hDlg);
			}

			bMsgHandled = TRUE;
			break;
		}

		default:
		{
			CPasswordDlg* ppd = (CPasswordDlg*) GetWindowLongPtr(	hDlg,
																DWLP_USER);

			if (NULL != ppd)
			{
				bMsgHandled = ppd->ProcessMessage(uMsg, wParam, lParam);
			}
		}
	}

	return bMsgHandled;
}

/****************************************************************************
*
*    CLASS:    CPasswordDlg
*
*    MEMBER:   ProcessMessage()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CPasswordDlg::ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL bRet = FALSE;
		
	ASSERT(m_hwnd);
	
	switch (uMsg)
	{
		case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
				case IDOK:
				{
					bRet = OnOk();
					break;
				}

				case IDCANCEL:
				{
					EndDialog(m_hwnd, LOWORD(wParam));
					bRet = TRUE;
					break;
				}

				case IDC_EDIT_PASSWORD:
				{
					if (!m_fRemoteIsRDS && EN_CHANGE == HIWORD(wParam))
					{
                                            BOOL fEnable = 0 != ::GetWindowTextLength(
                                                GetDlgItem(m_hwnd, IDC_EDIT_PASSWORD));
                                            ::EnableWindow(GetDlgItem(m_hwnd, IDOK), fEnable);
					}
					break;
				}

				case IDC_EDIT_USERNAME:
				{
					if (EN_CHANGE == HIWORD(wParam))
					{
						BOOL fEnable = 0 != ::GetWindowTextLength(
                                                    GetDlgItem(m_hwnd, IDC_EDIT_USERNAME));
						::EnableWindow(GetDlgItem(m_hwnd, IDOK), fEnable);
					}
					break;
				}
			}
			break;
		}
			
		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, aHelpIdsPassword);
			break;

		case WM_HELP:
			DoHelp(lParam, aHelpIdsPassword);
			break;

		default:
			break;
	}

	return bRet;
}

BOOL CPasswordDlg::OnOk()
{
	// BUGBUG: how long can a password be? - Remember to limit the edit control text
        TCHAR szBuf[256];
        TCHAR szUser[USERSIZE+1];
        TCHAR szDomain[DOMAINSIZE+1];

        if (m_fRemoteIsRDS)
        {
            if ( 0!= GetDlgItemText(m_hwnd, IDC_EDIT_USERNAME, szUser, CCHMAX(szUser)))
            {
                ASSERT(strlen(szUser));
                m_strPassword = szUser; // add user name
                m_strPassword += ":";
                if ( 0 != GetDlgItemText(m_hwnd, IDC_EDIT_DOMAIN, szDomain, CCHMAX(szDomain)))
                {
                    m_strPassword += szDomain;
                }
                else
                {
                    m_strPassword += ".";
                }
                m_strPassword += ":";
            }
            else
            {
                ERROR_OUT(("CPasswordDlg::OnOk - unable to get username"));
            }
            *(CPasswordDlg::m_pstrUser) = szUser;
            *(CPasswordDlg::m_pstrDomain) = szDomain;
        }

	if (0 != GetDlgItemText(m_hwnd, IDC_EDIT_PASSWORD, szBuf, CCHMAX(szBuf)))
	{
            m_strPassword += szBuf;    // add password
	}

        EndDialog(m_hwnd, IDOK);
	return TRUE;
}

BOOL CPasswordDlg::Init()
{
    if (0 == m_pstrDomain)
    {
        m_pstrDomain = new CSTRING;
        m_pstrUser = new CSTRING;
        if (NULL == m_pstrUser || NULL == m_pstrDomain)
        {
            ERROR_OUT(("CPassword::Init() -- failed to allocate memory"));
            return FALSE;
        }
    }
    return TRUE;
}

VOID CPasswordDlg::Cleanup()
{
    if (m_pstrDomain)
        delete m_pstrDomain;
    if (m_pstrUser)
        delete m_pstrUser;
}

CSTRING *CPasswordDlg::m_pstrDomain = NULL;
CSTRING *CPasswordDlg::m_pstrUser = NULL;



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\pfndrawd.cpp ===
// File: pfndrawd.cpp

#include "precomp.h"
#include "pfndrawd.h"

PFN_DRAWDIBDRAW	      DRAWDIB::DrawDibDraw = NULL;
PFN_DRAWDIBOPEN	      DRAWDIB::DrawDibOpen = NULL;
PFN_DRAWDIBCLOSE      DRAWDIB::DrawDibClose = NULL;
PFN_DRAWDIBSETPALETTE DRAWDIB::DrawDibSetPalette = NULL;

HINSTANCE DRAWDIB::m_hInstance = NULL;
#define DRAWDIB_APIFCN_ENTRY(pfn)  {(PVOID *) &DRAWDIB::##pfn, #pfn}

APIFCN s_apiFcnDrawDib[] = {
	DRAWDIB_APIFCN_ENTRY(DrawDibDraw),
	DRAWDIB_APIFCN_ENTRY(DrawDibOpen),
	DRAWDIB_APIFCN_ENTRY(DrawDibClose),
	DRAWDIB_APIFCN_ENTRY(DrawDibSetPalette),
};

HRESULT DRAWDIB::Init(void)
{
	if (NULL != m_hInstance)
		return S_OK;

	return HrInitLpfn(s_apiFcnDrawDib, ARRAY_ELEMENTS(s_apiFcnDrawDib), &m_hInstance, TEXT("MSVFW32.DLL"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\particip.cpp ===
// File: particip.cpp

#include "precomp.h"
#include "resource.h"
#include "dshowdlg.h"

#include "rostinfo.h"
#include "upropdlg.h"  // for CmdProperties()
#include "confroom.h"  // for FTopProvider()
#include "cmd.h"
#include "particip.h"
#include "..\..\core\imember.h"   // for CNmMember (remove ASAP)
#include "certui.h"
#include "wabutil.h"
#include "ulswizrd.h"

GUID g_csguidSecurity = GUID_SECURITY;
GUID g_csguidMeetingSettings = GUID_MTGSETTINGS;

extern BOOL FCreateSpeedDial(LPCTSTR pcszName, LPCTSTR pcszAddress,
			NM_ADDR_TYPE addrType = NM_ADDR_UNKNOWN, DWORD dwCallFlags = CRPCF_DEFAULT,
			LPCTSTR pcszRemoteConfName = NULL, LPCTSTR pcszPassword = NULL,
			LPCTSTR pcszPathPrefix = NULL);

/*  C  P A R T I C I P A N T  */
/*-------------------------------------------------------------------------
    %%Function: CParticipant
    
-------------------------------------------------------------------------*/
CParticipant::CParticipant(INmMember * pMember) :
    m_pMember (pMember),
    m_pszName (NULL),
    m_dwGccId (0),
    m_fLocal  (FALSE),
    m_fAudio  (FALSE),
    m_fVideo  (FALSE),
    m_fData   (FALSE),
    RefCount  (NULL)
{
    HRESULT hr;
    ASSERT(NULL != m_pMember);
    m_pMember->AddRef();

    // Get the member's display name
    BSTR  bstr;
    hr = m_pMember->GetName(&bstr);
    if (SUCCEEDED(hr))
    {
        hr = BSTR_to_LPTSTR(&m_pszName, bstr);
        SysFreeString(bstr);
    }

    if (FEmptySz(m_pszName))
    {
        delete m_pszName;
        m_pszName = PszLoadString(IDS_UNKNOWN);
    }

    // These bits should never change
    m_fLocal = (m_pMember->IsSelf() == S_OK);
    m_fMcu = (m_pMember->IsMCU() == S_OK);

    // update all other fields
    Update();

    DbgMsg(iZONE_OBJECTS, "Obj: %08X created CParticipant", this);
}

CParticipant::~CParticipant()
{
    delete m_pszName;
    ASSERT(NULL != m_pMember);
    m_pMember->Release();

    DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CParticipant", this);
}

ULONG STDMETHODCALLTYPE CParticipant::AddRef(void)
{
    return RefCount::AddRef();
}
    
ULONG STDMETHODCALLTYPE CParticipant::Release(void)
{
    return RefCount::Release();
}


/*  U P D A T E  */
/*-------------------------------------------------------------------------
    %%Function: Update

    Update the cached information about the participant
-------------------------------------------------------------------------*/
VOID CParticipant::Update(void)
{
    HRESULT hr = m_pMember->GetID(&m_dwGccId);
    ASSERT(SUCCEEDED(hr));

    ULONG nmchCaps;
    hr = m_pMember->GetNmchCaps(&nmchCaps);
    ASSERT(SUCCEEDED(hr));

    DWORD dwFlags = GetDwFlags();
    m_fData = dwFlags & PF_T120;
    m_fH323  = dwFlags & PF_H323;
    m_fAudio = dwFlags & PF_MEDIA_AUDIO;
    m_fVideo = dwFlags & PF_MEDIA_VIDEO;

    DWORD uCaps = GetDwCaps();
    m_fAudioBusy = uCaps & CAPFLAG_AUDIO_IN_USE;
    m_fVideoBusy = uCaps & CAPFLAG_VIDEO_IN_USE;
    m_fHasAudio = uCaps & CAPFLAG_SEND_AUDIO;
    m_fHasVideo = uCaps & CAPFLAG_SEND_VIDEO;
    m_fCanRecVideo = uCaps & CAPFLAG_RECV_VIDEO;

}

DWORD CParticipant::GetDwFlags(void)
{
    CNmMember * pMember = (CNmMember *) m_pMember;
    ASSERT(NULL != pMember);

    return pMember->GetDwFlags();
}

DWORD CParticipant::GetDwCaps(void)
{
    CNmMember * pMember = (CNmMember *) m_pMember;
    ASSERT(NULL != pMember);

    return pMember->GetCaps();
}


/*  E X T R A C T  U S E R  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: ExtractUserData

    Extract the user data associated with the tag.
    Note: This function can be called with a length of 0 to determine
    if the data exists.
-------------------------------------------------------------------------*/
HRESULT CParticipant::ExtractUserData(LPTSTR psz, UINT cchMax, PWSTR pwszKey)
{
    CRosterInfo ri;
    HRESULT hr = ri.Load(((CNmMember *) m_pMember)->GetUserInfo());
    if (FAILED(hr))
        return hr;

    hr = ri.ExtractItem(NULL, pwszKey, psz, cchMax);
    return hr;
}

HRESULT CParticipant::GetIpAddr(LPTSTR psz, UINT cchMax)
{
    return ExtractUserData(psz, cchMax, (PWSTR) g_cwszIPTag);
}

HRESULT CParticipant::GetUlsAddr(LPTSTR psz, UINT cchMax)
{
    return ExtractUserData(psz, cchMax, (PWSTR) g_cwszULSTag);
}

HRESULT CParticipant::GetEmailAddr(LPTSTR psz, UINT cchMax)
{
    return ExtractUserData(psz, cchMax, (PWSTR) g_cwszULS_EmailTag);
}

HRESULT CParticipant::GetPhoneNum(LPTSTR psz, UINT cchMax)
{
    return ExtractUserData(psz, cchMax, (PWSTR) g_cwszULS_PhoneNumTag);
}

HRESULT CParticipant::GetLocation(LPTSTR psz, UINT cchMax)
{
    return ExtractUserData(psz, cchMax, (PWSTR) g_cwszULS_LocationTag);
}


///////////////////////////////////////////////////////////////////////////
// Participant Commands

VOID CParticipant::OnCommand(HWND hwnd, WORD wCmd)
{
    switch (wCmd)
        {
    case IDM_POPUP_EJECT:
        CmdEject();
        break;

    case IDM_POPUP_PROPERTIES:
        CmdProperties(hwnd);
        break;

    case IDM_POPUP_SPEEDDIAL:
        CmdCreateSpeedDial();
        break;

    case IDM_POPUP_ADDRESSBOOK:
        CmdCreateWabEntry(hwnd);
        break;

    case IDM_POPUP_GIVECONTROL:
        CmdGiveControl();
        break;

    case IDM_POPUP_CANCELGIVECONTROL:
        CmdCancelGiveControl();
        break;

    default:
        ERROR_OUT(("CParticipant::OnCommand - Unknown command %08X", wCmd));
        break;
        } /* switch (wCmd) */
}


/*  C M D  E J E C T  */
/*-------------------------------------------------------------------------
    %%Function: CmdEject
    
-------------------------------------------------------------------------*/
VOID CParticipant::CmdEject(void)
{
    ASSERT(NULL != m_pMember);
    m_pMember->Eject();
}

BOOL CParticipant::FEnableCmdEject(void)
{
    if (FLocal())
        return FALSE; // can't eject ourselves

    if (!FData())
        return TRUE; // allow ejecting a/v-only users

    if (!::FTopProvider())
        return FALSE; // we must be the top provider

    return TRUE;
}



/*  C M D  S E N D  F I L E  */
/*-------------------------------------------------------------------------
    %%Function: CmdSendFile
    
-------------------------------------------------------------------------*/
VOID CParticipant::CmdSendFile(void)
{
}

BOOL CParticipant::FEnableCmdSendFile(void)
{
    // can't send to ourselves, an mcu, or someone without data caps
    if (FLocal() || FMcu() || !FData())
        return FALSE;

    return TRUE;
}



/*  C M D  C R E A T E  S P E E D  D I A L  */
/*-------------------------------------------------------------------------
    %%Function: CmdCreateSpeedDial
    
-------------------------------------------------------------------------*/
VOID CParticipant::CmdCreateSpeedDial(void)
{
    TCHAR szAddr[MAX_PATH];
    HRESULT hr = GetUlsAddr(szAddr, CCHMAX(szAddr));
    if (FAILED(hr))
    {
        WARNING_OUT(("CParticipant::CmdCreateSpeedDial - Unable to obtain ULS address"));
        return;
    }

    ::FCreateSpeedDial(m_pszName, szAddr, NM_ADDR_ULS, CRPCF_DEFAULT, NULL, NULL, NULL);
}

BOOL CParticipant::FEnableCmdCreateSpeedDial(void)
{
    if (FLocal())
        return FALSE;

    return SUCCEEDED(GetUlsAddr(NULL, 0));
}


/*  C M D  C R E A T E  W A B  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CmdCreateWabEntry
    
-------------------------------------------------------------------------*/
void CParticipant::CmdCreateWabEntry(HWND hwnd)
{
	// get the email address
	TCHAR szEmail[MAX_EMAIL_NAME_LENGTH];
	if (S_OK != GetEmailAddr(szEmail, CCHMAX(szEmail)))
	{
		return;
	}

	// get the server/email address
	TCHAR szULS[MAX_EMAIL_NAME_LENGTH + MAX_SERVER_NAME_LENGTH + 1];
	if (S_OK != GetUlsAddr(szULS, CCHMAX(szULS)))
	{
		return;
	}

	// get the location
	TCHAR szLocation[MAX_LOCATION_NAME_LENGTH] = "";
	GetLocation(szLocation, CCHMAX(szLocation));

	// get the phone number
	TCHAR szPhone[MAX_PHONENUM_LENGTH] = "";
	GetPhoneNum(szPhone, CCHMAX(szPhone));

	CWABUTIL WabUtil;
	WabUtil.CreateWabEntry(hwnd, GetPszName(), szEmail,
				szLocation, szPhone, szULS);
}

BOOL CParticipant::FEnableCmdCreateWabEntry(void)
{
    if (FLocal())
        return FALSE;

    return SUCCEEDED(GetUlsAddr(NULL, 0));
}


/*  C M D  C O N T R O L  */
//
// CalcControlCmd()
//
// This puts the right string in the popup, and enables/disables the command
//
VOID CParticipant::CalcControlCmd(HMENU hPopup)
{
    UINT            iPos;
    UINT            cmd;
    UINT            flags;
    TCHAR           szItem[256];
    CConfRoom *     pcr;

    // Our item should 3rd to last.
    iPos = GetMenuItemCount(hPopup);
    ASSERT(iPos >= 3);
    iPos -= 3;

    cmd = GetMenuItemID(hPopup, iPos);
    ASSERT((cmd == IDM_POPUP_GIVECONTROL) || (cmd == IDM_POPUP_CANCELGIVECONTROL));

    flags = MF_GRAYED;
    cmd   = IDM_POPUP_GIVECONTROL;

    //
    // If we, the local dude, are a controllable host, then enable the command
    // if this person is in the share and of course not ourselves.
    //
    pcr = GetConfRoom();
    if (!m_fLocal && pcr && pcr->FIsControllable())
    {
        IAS_PERSON_STATUS status;

        // Get this person's share status
        pcr->GetPersonShareStatus(m_dwGccId, &status);

        if (status.InShare && (status.Version >= IAS_VERSION_30))
        {
            flags = MF_ENABLED;

            // Get local person's share status
            pcr->GetPersonShareStatus(0, &status);
            if (status.ControlledByPending == m_dwGccId)
            {
                cmd = IDM_POPUP_CANCELGIVECONTROL;
            }
        }
    }

    flags |= MF_STRING | MF_BYPOSITION;

    LoadString(::GetInstanceHandle(),
        ((cmd == IDM_POPUP_GIVECONTROL) ? IDS_COMMAND_GIVECONTROL : IDS_COMMAND_CANCELGIVECONTROL),
        szItem, CCHMAX(szItem));

    ModifyMenu(hPopup, iPos, flags, cmd, szItem);
}


//
// CmdGiveControl()
//
VOID CParticipant::CmdGiveControl(void)
{
    CConfRoom * pcr;

    if (pcr = GetConfRoom())
    {
        pcr->GiveControl(m_dwGccId);
    }
}


//
// CmdCancelGiveControl()
//
VOID CParticipant::CmdCancelGiveControl(void)
{
    CConfRoom * pcr;

    if (pcr = GetConfRoom())
    {
        pcr->CancelGiveControl(m_dwGccId);
    }
}



/*  C M D  P R O P E R T I E S  */
/*-------------------------------------------------------------------------
    %%Function: CmdProperties
    
-------------------------------------------------------------------------*/
VOID CParticipant::CmdProperties(HWND hwnd)
{
    CNmMember * pMember = (CNmMember *) m_pMember;
    ULONG uCaps = pMember->GetCaps();

    TCHAR szEmail[MAX_PATH];
    TCHAR szLocation[MAX_PATH];
    TCHAR szPhoneNum[MAX_PATH];
    TCHAR szVideo[256];
    TCHAR szAudio[256];
    TCHAR szSharing[256];
    TCHAR szControlFmt[256];
    TCHAR szControl[MAX_PATH];
    TCHAR szT[256];
    PCCERT_CONTEXT      pCert = NULL;
    CConfRoom *         pcr;
    IAS_PERSON_STATUS   status;
    UINT                ids;

    UPROPDLGENTRY rgUPDE[] = 
    {
        { IDS_UPROP_EMAIL,      szEmail },
        { IDS_UPROP_LOCATION,   szLocation },
        { IDS_UPROP_PHONENUM,   szPhoneNum },
        { IDS_UPROP_VIDEO,      szVideo },
        { IDS_UPROP_AUDIO,      szAudio },
        { IDS_UPROP_SHARING,    szSharing },
        { IDS_UPROP_CONTROL,    szControl }
    };

    szEmail[0] = _T('\0');
    szLocation[0] = _T('\0');
    szPhoneNum[0] = _T('\0');
    

    ::LoadString(::GetInstanceHandle(),
        (CAPFLAG_SEND_VIDEO & uCaps) ? IDS_HARDWARE_DETECTED : IDS_NO_HARDWARE_DETECTED,
        szVideo, CCHMAX(szVideo));

    ::LoadString(::GetInstanceHandle(),
        (CAPFLAG_SEND_AUDIO & uCaps) ? IDS_HARDWARE_DETECTED : IDS_NO_HARDWARE_DETECTED,
        szAudio, CCHMAX(szAudio));

    ExtractUserData(szEmail,   CCHMAX(szEmail),   (PWSTR) g_cwszULS_EmailTag);
    ExtractUserData(szLocation,    CCHMAX(szLocation),    (PWSTR) g_cwszULS_LocationTag);
    ExtractUserData(szPhoneNum, CCHMAX(szPhoneNum), (PWSTR) g_cwszULS_PhoneNumTag);

    //
    // Get sharing, control info.
    //
    ZeroMemory(&status, sizeof(status));
    status.cbSize = sizeof(status);
    if (pcr = GetConfRoom())
    {
        pcr->GetPersonShareStatus(m_dwGccId, &status);
    }

    //
    // Sharing
    //
    szSharing[0] = _T('\0');
    if (status.InShare)
    {
        if (status.AreSharing == IAS_SHARING_APPLICATIONS)
        {
            ids = IDS_SHARING_APPS;
        }
        else if (status.AreSharing == IAS_SHARING_DESKTOP)
        {
            ids = IDS_SHARING_DESKTOP;
        }
        else
        {
            ids = IDS_SHARING_NOTHING;
        }
    
        ::LoadString(::GetInstanceHandle(), ids, szSharing, CCHMAX(szSharing));
    }

    //
    // Control
    //
    szControl[0] = _T('\0');
    if (status.InShare)
    {
        if ((status.InControlOf) || (status.ControlledBy))
        {
            UINT            gccID;
            CParticipant *  pPart = NULL;

            if (status.InControlOf)
            {
                gccID = status.InControlOf;
                ids = IDS_CONTROL_INCONTROLOF;
            }
            else
            {
                gccID = status.ControlledBy;
                ids = IDS_CONTROL_CONTROLLEDBY;
            }

            if (pcr)
            {
                CSimpleArray<CParticipant*>& memberList = pcr->GetParticipantList();
                for (int i = 0; i < memberList.GetSize(); ++i)
                {
                    ASSERT(memberList[i]);
                    if (memberList[i]->GetGccId() == gccID)
                    {
                        pPart = memberList[i];
                        break;
                    }
                }
            }

            if (pPart)
            {
                lstrcpy(szT, pPart->GetPszName());
            }
            else
            {
                ::LoadString(::GetInstanceHandle(), IDS_UNKNOWN, szT, CCHMAX(szT));
            }

            ::LoadString(::GetInstanceHandle(), ids, szControlFmt, CCHMAX(szControlFmt));
            wsprintf(szControl, szControlFmt, szT);
        }
        else if (status.Controllable)
        {
            ::LoadString(::GetInstanceHandle(), IDS_CONTROL_CONTROLLABLE,
                szControl, CCHMAX(szControl));
        }
        else if (status.AreSharing)
        {
            ::LoadString(::GetInstanceHandle(), IDS_CONTROL_NOTCONTROLLABLE,
                szControl, CCHMAX(szControl));
        }
    }


    PBYTE pb = NULL;
    ULONG cb = 0;

    //
    // Certificate
    //
    if (pMember->GetUserData(g_csguidSecurity,&pb,&cb) == S_OK) {
        ASSERT(pb);
        ASSERT(cb);

        pCert = CertCreateCertificateContext ( X509_ASN_ENCODING, pb, cb);

        if ( NULL == pCert )
        {
            ERROR_OUT(("Error creating cert context from user data"));
        }
        CoTaskMemFree(pb);
    }


    CUserPropertiesDlg dlgUserProp(hwnd, IDI_LARGE);
    dlgUserProp.DoModal(rgUPDE, ARRAY_ELEMENTS(rgUPDE), m_pszName, pCert);
    if ( pCert )
        CertFreeCertificateContext ( pCert );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\particip.h ===
#ifndef _PARTICIP_H_
#define _PARTICIP_H_

#include "SDKInternal.h"

// BUGBUG:
// This is defined as 128 because the RNC_ROSTER structure has the
// same limitation.  Investigate what the appropriate number is.
const int MAX_PARTICIPANT_NAME = 128;

struct PARTICIPANT
{
	UINT	uID;
	UINT	uCaps;
	DWORD	dwFlags;
	PWSTR	pwszUserInfo;
	TCHAR	szName[MAX_PARTICIPANT_NAME];
};
typedef PARTICIPANT* PPARTICIPANT;



class CParticipant : public RefCount
{
private:
	INmMember * m_pMember;
	
	LPTSTR m_pszName;    // Display Name
	DWORD  m_dwGccId;    // GCC UserId
	BOOL   m_fLocal;     // True if local user
	BOOL   m_fMcu;       // True if local user
	BOOL   m_fAudio;     // audio is active
	BOOL   m_fVideo;     // video is active
	BOOL   m_fData;      // In T.120 connection
	BOOL   m_fH323;      // In H323 connection
	BOOL   m_fAudioBusy;   // CAPFLAG_AUDIO_IN_USE
	BOOL   m_fVideoBusy;   // CAPFLAG_VIDEO_IN_USE
	BOOL   m_fHasAudio;    // CAPFLAG_SEND_AUDIO
	BOOL   m_fHasVideo;    // CAPFLAG_SEND_VIDEO
	BOOL   m_fCanRecVideo; // CAPFLAG_RECV_VIDEO

public:
	CParticipant(INmMember * pMember);
	~CParticipant();

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);

	VOID    Update(void);
	DWORD   GetDwFlags(void);
	DWORD   GetDwCaps(void);

	// Internal methods
	INmMember * GetINmMember()   {return m_pMember;}
	LPTSTR  GetPszName()         {return m_pszName;}
	BOOL    FLocal()             {return m_fLocal;}
	BOOL    FAudio()             {return m_fAudio;}
	BOOL    FVideo()             {return m_fVideo;}
	BOOL    FData()              {return m_fData;}
	BOOL    FMcu()               {return m_fMcu;}
	BOOL    FH323()              {return m_fH323;}
	BOOL	FAudioBusy()         {return m_fAudioBusy;}
	BOOL	FVideoBusy()         {return m_fVideoBusy;}
	BOOL	FHasAudio()          {return m_fHasAudio;}
	BOOL	FCanSendVideo()      {return m_fHasVideo;}
	BOOL    FCanRecVideo()       {return m_fCanRecVideo;}
	DWORD   GetGccId()           {return m_dwGccId;}

	HRESULT ExtractUserData(LPTSTR psz, UINT cchMax, PWSTR pwszKey);

	HRESULT GetIpAddr(LPTSTR psz, UINT cchMax);
	HRESULT GetUlsAddr(LPTSTR psz, UINT cchMax);
	HRESULT GetEmailAddr(LPTSTR psz, UINT cchMax);
	HRESULT GetPhoneNum(LPTSTR psz, UINT cchMax);
	HRESULT GetLocation(LPTSTR psz, UINT cchMax);

	VOID    OnCommand(HWND hwnd, WORD wCmd);

	// Commands
	VOID    CmdSendFile(void);
	BOOL    FEnableCmdSendFile(void);

	VOID    CmdEject(void);
	BOOL    FEnableCmdEject(void);

	VOID    CmdCreateSpeedDial(void);
	BOOL    FEnableCmdCreateSpeedDial(void);

	VOID    CmdCreateWabEntry(HWND hwnd);
	BOOL    FEnableCmdCreateWabEntry(void);

    VOID    CalcControlCmd(HMENU hPopup);
    VOID    CmdGiveControl(void);
    VOID    CmdCancelGiveControl(void);

	VOID    CmdProperties(HWND hwnd);
};

#endif // _PARTICIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\pfnsetupapi.h ===
// File: pfnsetupapi.h

#ifndef _PFNSETUPAPI_H_
#define _PFNSETUPAPI_H_

#include "setupapi.h"

typedef BOOL ( *PFN_SET_INSTALL)(HWND, HINF, LPCTSTR, UINT, HKEY, LPCTSTR, UINT, PSP_FILE_CALLBACK, PVOID, HDEVINFO, PSP_DEVINFO_DATA );
typedef HINF ( *PFN_SET_OPFILE)( LPCTSTR, LPCTSTR, DWORD, PUINT );
typedef VOID ( *PFN_SET_CLFILE)(  HINF );

class SETUPAPI
{
private:
	static HINSTANCE m_hInstance;

protected:
	SETUPAPI() {};
	~SETUPAPI() {};
	
public:
	static HRESULT Init(void);
	static void DeInit(void);
	
	static PFN_SET_INSTALL		SetupInstallFromInfSection;
	static PFN_SET_OPFILE	    SetupOpenInfFile;
	static PFN_SET_CLFILE		SetupCloseInfFile;
};

#endif /* _PFNSETUPAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\pfnsetupapi.cpp ===
// File: pfnsetupapi.cpp

#include "precomp.h"
#include "pfnsetupapi.h"

PFN_SET_INSTALL		SETUPAPI::SetupInstallFromInfSection = NULL;
PFN_SET_OPFILE	    SETUPAPI::SetupOpenInfFile = NULL;
PFN_SET_CLFILE		SETUPAPI::SetupCloseInfFile = NULL;
	
HINSTANCE SETUPAPI::m_hInstance = NULL;


#define SETUPAPI_APIFCN_ENTRYA(pfn)  {(PVOID *) &SETUPAPI::##pfn, #pfn ## "A"}
#define SETUPAPI_APIFCN_ENTRYW(pfn)  {(PVOID *) &SETUPAPI::##pfn, #pfn ## "A"}
#define SETUPAPI_APIFCN_ENTRYNONE(pfn)  {(PVOID *) &SETUPAPI::##pfn, #pfn }

#ifdef UNICODE
#define SETUPAPI_APIFCN_ENTRY SETUPAPI_APIFCN_ENTRYW
#else
#define SETUPAPI_APIFCN_ENTRY SETUPAPI_APIFCN_ENTRYA
#endif

APIFCN s_apiFcnSETUPAPI[] = {
	SETUPAPI_APIFCN_ENTRY(SetupInstallFromInfSection),
	SETUPAPI_APIFCN_ENTRY(SetupOpenInfFile),
	SETUPAPI_APIFCN_ENTRYNONE(SetupCloseInfFile)
};

HRESULT SETUPAPI::Init(void)
{
	if (NULL != SETUPAPI::m_hInstance)
		return S_OK;

	return HrInitLpfn(s_apiFcnSETUPAPI, ARRAY_ELEMENTS(s_apiFcnSETUPAPI), &SETUPAPI::m_hInstance, TEXT("SETUPAPI.DLL"));
}

void SETUPAPI::DeInit(void)
{
	// TODO - why does the main thread die when I unload this?
	if( NULL != SETUPAPI::m_hInstance )
		FreeLibrary( SETUPAPI::m_hInstance );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\pfndrawd.h ===
// File: pfndrawd.h

#ifndef _PFNDRAWD_H_
#define _PFNDRAWD_H_

#include <vfw.h>

typedef HDRAWDIB (VFWAPI * PFN_DRAWDIBOPEN) ();

typedef BOOL (VFWAPI * PFN_DRAWDIBCLOSE) (HDRAWDIB hdd);

typedef BOOL (VFWAPI * PFN_DRAWDIBDRAW) (HDRAWDIB hdd,
	HDC hdc, int xDst, int yDst, int dxDst, int dyDst,
	LPBITMAPINFOHEADER lpbi, LPVOID lpBits,
	int xSrc, int ySrc, int dxSrc, int dySrc, UINT wFlags);

typedef BOOL (VFWAPI * PFN_DRAWDIBSETPALETTE) (HDRAWDIB hdd, HPALETTE hpal);


class DRAWDIB
{
private:
	static HINSTANCE m_hInstance;

protected:
	DRAWDIB() {};
	~DRAWDIB() {};
	
public:
	static HRESULT Init(void);
	
	static PFN_DRAWDIBDRAW	     DrawDibDraw;
	static PFN_DRAWDIBOPEN	     DrawDibOpen;
	static PFN_DRAWDIBCLOSE      DrawDibClose;
	static PFN_DRAWDIBSETPALETTE DrawDibSetPalette;
};

#endif /* _PFNDRAWD_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\pfnver.h ===
// File: pfnver.h

#ifndef _PFNVER_H_
#define _PFNVER_H_

// from version.dll
typedef DWORD (WINAPI * PFN_GETVERINFOSIZE) (LPTSTR, LPDWORD);
typedef BOOL  (WINAPI * PFN_GETVERINFO)     (LPTSTR, DWORD, DWORD, LPVOID);
typedef BOOL  (WINAPI * PFN_VERQUERYVAL)    (const LPVOID, LPTSTR, LPVOID *, PUINT);

class DLLVER
{
private:
	static HINSTANCE m_hInstance;

protected:
	DLLVER() {};
	~DLLVER() {};
	
public:
	static HRESULT Init(void);
	
	static PFN_GETVERINFOSIZE GetFileVersionInfoSize;
	static PFN_GETVERINFO     GetFileVersionInfo;
	static PFN_VERQUERYVAL    VerQueryValue;
};

#endif /* _PFNVER_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\pfnver.cpp ===
// File: pfnver.cpp

#include "precomp.h"
#include "pfnver.h"

#ifdef DEBUG

HINSTANCE DLLVER::m_hInstance = NULL;

PFN_GETVERINFOSIZE DLLVER::GetFileVersionInfoSize = NULL;
PFN_GETVERINFO     DLLVER::GetFileVersionInfo = NULL;
PFN_VERQUERYVAL    DLLVER::VerQueryValue = NULL;

#define DLLVER_APIFCN_ENTRY(pfn)  {(PVOID *) &DLLVER::##pfn, #pfn}

APIFCN s_apiFcnDllVer[] = {
	DLLVER_APIFCN_ENTRY(GetFileVersionInfoSize),
	DLLVER_APIFCN_ENTRY(GetFileVersionInfo),
	DLLVER_APIFCN_ENTRY(VerQueryValue),
};

HRESULT DLLVER::Init(void)
{
	if (NULL != m_hInstance)
		return S_OK;

	return HrInitLpfn(s_apiFcnDllVer, ARRAY_ELEMENTS(s_apiFcnDllVer), &m_hInstance, TEXT("VERSION.dll"));
}

#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\pfnwininet.h ===
// File: pfnwininet.h

#ifndef _PFNWININET_H_
#define _PFNWININET_H_

#include <wininet.h>

#define HINTERNETKILL( hInternet ) if( hInternet ) { WININET::InternetCloseHandle( hInternet ); hInternet = NULL; }

typedef HINTERNET (*PFN_IOPEN)( LPCSTR, DWORD, LPCSTR, LPCSTR, DWORD);
typedef INTERNET_STATUS_CALLBACK (*PFN_ISETCALLBACK)( HINTERNET, INTERNET_STATUS_CALLBACK);
typedef HINTERNET (*PFN_IOPENURL)( HINTERNET, LPCSTR, LPCSTR, DWORD, DWORD, DWORD );
typedef BOOL (*PFN_IREADFILE)(HINTERNET, LPVOID, DWORD, LPDWORD );
typedef BOOL (*PFN_IQUERYDATA)( HINTERNET, LPDWORD, DWORD, DWORD );
typedef BOOL (*PFN_ICLOSEHAN)( HINTERNET );
//typedef BOOL (*PFN_IREADFILEEX)(HINTERNET, LPINTERNET_BUFFERS, DWORD, DWORD);

class WININET
{
private:
	static HINSTANCE m_hInstance;

protected:
	WININET() {};
	~WININET() {};
	
public:
	static HRESULT Init(void);
	static void DeInit(void);
	
	static PFN_IOPEN			InternetOpen;
	static PFN_ISETCALLBACK	    InternetSetStatusCallback;
	static PFN_IOPENURL			InternetOpenUrl;
	static PFN_IREADFILE		InternetReadFile;
	static PFN_IQUERYDATA		InternetQueryDataAvailable;
	static PFN_ICLOSEHAN		InternetCloseHandle;
//	static PFN_IREADFILEEX		InternetReadFileEx;
};

#endif /* _PFNWININET_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\pfnwldap.cpp ===
// File: pfnwldap.cpp

#include "precomp.h"
#include "pfnwldap.h"

static const TCHAR * s_pcszWldap32 = TEXT("wldap32.dll");

HINSTANCE WLDAP::m_hInstance = NULL;

PFN_LDAP_ABANDON         WLDAP::ldap_abandon = NULL;
PFN_LDAP_BIND_S          WLDAP::ldap_bind_s = NULL;
PFN_LDAP_BIND			 WLDAP::ldap_bind = NULL;
PFN_LDAP_ADD		     WLDAP::ldap_add = NULL;
PFN_LDAP_SIMPLE_BIND_S   WLDAP::ldap_simple_bind_s = NULL;
PFN_LDAP_FIRST_ATTRIBUTE WLDAP::ldap_first_attribute = NULL;
PFN_LDAP_FIRST_ENTRY     WLDAP::ldap_first_entry = NULL;
PFN_LDAP_GET_VALUES      WLDAP::ldap_get_values = NULL;
PFN_LDAP_MSGFREE         WLDAP::ldap_msgfree = NULL;
PFN_LDAP_NEXT_ATTRIBUTE  WLDAP::ldap_next_attribute = NULL;
PFN_LDAP_NEXT_ENTRY      WLDAP::ldap_next_entry = NULL;
PFN_LDAP_OPEN            WLDAP::ldap_open = NULL;
PFN_LDAP_OPEN            WLDAP::ldap_init = NULL;
PFN_LDAP_RESULT          WLDAP::ldap_result = NULL;
PFN_LDAP_SEARCH          WLDAP::ldap_search = NULL;
PFN_LDAP_SEARCH_S        WLDAP::ldap_search_s = NULL;
PFN_LDAP_SET_OPTION      WLDAP::ldap_set_option = NULL;
PFN_LDAP_UNBIND          WLDAP::ldap_unbind = NULL;
PFN_LDAP_VALUE_FREE      WLDAP::ldap_value_free = NULL;
PFN_LDAP_MODIFY			 WLDAP::ldap_modify = NULL;
PFN_LDAP_DELETE			 WLDAP::ldap_delete = NULL;
PFN_LDAP_GET_OPTION		WLDAP::ldap_get_option = NULL;


#define WLDAP_APIFCN_ENTRY(pfn)  {(PVOID *) &WLDAP::##pfn, #pfn}

APIFCN s_apiFcnWldap[] = {
	WLDAP_APIFCN_ENTRY(ldap_abandon),
	WLDAP_APIFCN_ENTRY(ldap_bind_s),
	WLDAP_APIFCN_ENTRY(ldap_bind),
	WLDAP_APIFCN_ENTRY(ldap_add),
	WLDAP_APIFCN_ENTRY(ldap_first_attribute),
	WLDAP_APIFCN_ENTRY(ldap_first_attribute),
	WLDAP_APIFCN_ENTRY(ldap_first_entry),
	WLDAP_APIFCN_ENTRY(ldap_get_values),
	WLDAP_APIFCN_ENTRY(ldap_msgfree),
	WLDAP_APIFCN_ENTRY(ldap_next_attribute),
	WLDAP_APIFCN_ENTRY(ldap_next_entry),
	WLDAP_APIFCN_ENTRY(ldap_open),
	WLDAP_APIFCN_ENTRY(ldap_init),
	WLDAP_APIFCN_ENTRY(ldap_result),
	WLDAP_APIFCN_ENTRY(ldap_search),
	WLDAP_APIFCN_ENTRY(ldap_search_s),
	WLDAP_APIFCN_ENTRY(ldap_set_option),
	WLDAP_APIFCN_ENTRY(ldap_simple_bind_s),
	WLDAP_APIFCN_ENTRY(ldap_unbind),
	WLDAP_APIFCN_ENTRY(ldap_value_free),
	WLDAP_APIFCN_ENTRY(ldap_modify),
	WLDAP_APIFCN_ENTRY(ldap_delete),
	WLDAP_APIFCN_ENTRY(ldap_get_option)
};

HRESULT WLDAP::Init(void)
{
	if (NULL != m_hInstance)
		return S_OK;

	return HrInitLpfn(s_apiFcnWldap, ARRAY_ELEMENTS(s_apiFcnWldap), &m_hInstance, s_pcszWldap32);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\pfnwininet.cpp ===
// File: pfnwininet.cpp

#include "precomp.h"
#include "pfnwininet.h"

PFN_IOPEN				WININET::InternetOpen = NULL;
PFN_ISETCALLBACK	    WININET::InternetSetStatusCallback = NULL;
PFN_IOPENURL			WININET::InternetOpenUrl = NULL;
PFN_IREADFILE			WININET::InternetReadFile = NULL;
PFN_IQUERYDATA			WININET::InternetQueryDataAvailable = NULL;
PFN_ICLOSEHAN			WININET::InternetCloseHandle = NULL;
//PFN_IREADFILEEX			WININET::InternetReadFileEx = NULL;
	
HINSTANCE WININET::m_hInstance = NULL;


#define WININET_APIFCN_ENTRYA(pfn)  {(PVOID *) &WININET::##pfn, #pfn ## "A"}
#define WININET_APIFCN_ENTRYW(pfn)  {(PVOID *) &WININET::##pfn, #pfn ## "A"}
#define WININET_APIFCN_ENTRYNONE(pfn)  {(PVOID *) &WININET::##pfn, #pfn }

#ifdef UNICODE
#define WININET_APIFCN_ENTRY WININET_APIFCN_ENTRYW
#else
#define WININET_APIFCN_ENTRY WININET_APIFCN_ENTRYA
#endif

APIFCN s_apiFcnWinInet[] = {
	WININET_APIFCN_ENTRYA(InternetOpen),
	WININET_APIFCN_ENTRYNONE(InternetSetStatusCallback),
	WININET_APIFCN_ENTRY(InternetOpenUrl),
	WININET_APIFCN_ENTRYNONE(InternetReadFile),
	WININET_APIFCN_ENTRYNONE(InternetQueryDataAvailable),
	WININET_APIFCN_ENTRYNONE(InternetCloseHandle)
};

HRESULT WININET::Init(void)
{
	if (NULL != WININET::m_hInstance)
		return S_OK;

	return HrInitLpfn(s_apiFcnWinInet, ARRAY_ELEMENTS(s_apiFcnWinInet), &WININET::m_hInstance, TEXT("WININET.DLL"));
}

void WININET::DeInit(void)
{
	// TODO - why does the main thread die when I unload this?
	if( NULL != WININET::m_hInstance )
		FreeLibrary( WININET::m_hInstance );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\pfnwldap.h ===
// File: pfnwldap.h

#ifndef _PFNWLDAP_H_
#define _PFNWLDAP_H_

#include <winldap.h>

// Why aren't these in winldap.h ?

typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_ABANDON)(LDAP *ld, ULONG msgid);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_BIND_S)(LDAP *ld, PCHAR dn, PCHAR cred, ULONG method);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_BIND)(LDAP *ld, PCHAR dn, PCHAR cred, ULONG method);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_ADD) (LDAP *ld, PCHAR dn, LDAPMod *attrs[]);


typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_SIMPLE_BIND_S)(LDAP *ld, PCHAR dn, PCHAR passwd);
typedef WINLDAPAPI PCHAR * (LDAPAPI * PFN_LDAP_GET_VALUES)(LDAP *ld, LDAPMessage *entry, PCHAR attr);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_MSGFREE)(LDAPMessage *res);
typedef WINLDAPAPI LDAP *  (LDAPAPI * PFN_LDAP_OPEN)(PCHAR HostName, ULONG PortNumber);
typedef WINLDAPAPI LDAP *  (LDAPAPI * PFN_LDAP_INIT)(PCHAR HostName, ULONG PortNumber);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_RESULT)(LDAP *ld, ULONG msgid, ULONG all, struct l_timeval *timeout, LDAPMessage **res);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_SET_OPTION)(LDAP *ld, int option, void *invalue);

typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_UNBIND)(LDAP *ld);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_VALUE_FREE)(PCHAR *vals);

typedef WINLDAPAPI LDAPMessage * (LDAPAPI * PFN_LDAP_FIRST_ENTRY)(LDAP *ld, LDAPMessage *res);
typedef WINLDAPAPI LDAPMessage * (LDAPAPI * PFN_LDAP_NEXT_ENTRY) (LDAP *ld, LDAPMessage *entry);

typedef WINLDAPAPI PCHAR (LDAPAPI * PFN_LDAP_FIRST_ATTRIBUTE)(LDAP *ld, LDAPMessage *entry, BerElement **ptr);
typedef WINLDAPAPI PCHAR (LDAPAPI * PFN_LDAP_NEXT_ATTRIBUTE) (LDAP *ld, LDAPMessage *entry, BerElement *ptr);

typedef WINLDAPAPI ULONG (LDAPAPI * PFN_LDAP_SEARCH)  (LDAP *ld, PCHAR base, ULONG scope, PCHAR filter, PCHAR attrs[], ULONG attrsonly);
typedef WINLDAPAPI ULONG (LDAPAPI * PFN_LDAP_SEARCH_S)(LDAP *ld, PCHAR base, ULONG scope, PCHAR filter, PCHAR attrs[], ULONG attrsonly, LDAPMessage **res);
typedef WINLDAPAPI ULONG (LDAPAPI * PFN_LDAP_MODIFY)  (LDAP *ld, PCHAR dn, LDAPMod *mods[]);
typedef WINLDAPAPI ULONG (LDAPAPI * PFN_LDAP_DELETE)  (LDAP *ld, PCHAR dn);

typedef WINLDAPAPI ULONG (LDAPAPI * PFN_LDAP_GET_OPTION)  ( LDAP *ld, int option, void *outvalue );


class WLDAP
{
private:
	static HINSTANCE m_hInstance;

protected:
	WLDAP() {};
	~WLDAP() {};
	
public:
	static HRESULT Init(void);
	
	static PFN_LDAP_ABANDON         ldap_abandon;
	static PFN_LDAP_BIND_S          ldap_bind_s;
	static PFN_LDAP_BIND			ldap_bind;
	static PFN_LDAP_ADD				ldap_add;
	static PFN_LDAP_FIRST_ATTRIBUTE ldap_first_attribute;
	static PFN_LDAP_FIRST_ENTRY     ldap_first_entry;
	static PFN_LDAP_GET_VALUES      ldap_get_values;
	static PFN_LDAP_MSGFREE         ldap_msgfree;
	static PFN_LDAP_NEXT_ATTRIBUTE  ldap_next_attribute;
	static PFN_LDAP_NEXT_ENTRY      ldap_next_entry;
	static PFN_LDAP_OPEN            ldap_open;
	static PFN_LDAP_INIT            ldap_init;
	static PFN_LDAP_RESULT          ldap_result;
	static PFN_LDAP_SEARCH          ldap_search;
	static PFN_LDAP_SEARCH_S        ldap_search_s;
	static PFN_LDAP_SET_OPTION      ldap_set_option;
	static PFN_LDAP_SIMPLE_BIND_S   ldap_simple_bind_s;
	static PFN_LDAP_UNBIND          ldap_unbind;
	static PFN_LDAP_VALUE_FREE      ldap_value_free;
	static PFN_LDAP_MODIFY			ldap_modify;
	static PFN_LDAP_DELETE			ldap_delete;
	static PFN_LDAP_GET_OPTION		ldap_get_option;
};


#endif /* _PFNWLDAP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\popupmsg.cpp ===
// File: popupmsg.cpp

#include "precomp.h"
#include "resource.h"
#include "PopupMsg.h"

#include "conf.h"
#include "call.h"
#include "certui.h"

const int POPUPMSG_LEFT_MARGIN        =   2;
const int POPUPMSG_TOP_MARGIN         =   2;
const int POPUPMSG_CLIENT_MARGIN      =   5;
const int POPUPMSG_ICON_GAP           =   3;
const int POPUPMSG_WIDTH              = 350;
const int POPUPMSG_HEIGHT             =  32;
const int POPUPMSG_DLG_DEF_TEXT_WIDTH = 100;


const TCHAR g_cszTrayWndClass[]       = _TEXT("Shell_TrayWnd");
const TCHAR g_cszTrayNotifyWndClass[] = _TEXT("TrayNotifyWnd");

extern GUID g_csguidSecurity;
///////////////////////////////////////////////////////////////////////////

UINT CPopupMsg::m_uVisiblePixels = 0;
/*static*/ CSimpleArray<CPopupMsg*>*	CPopupMsg::m_splstPopupMsgs = NULL;

CPopupMsg::CPopupMsg(PMCALLBACKPROC pcp, LPVOID pContext):
	m_pCallbackProc		(pcp),
	m_pContext			(pContext),
	m_fRing				(FALSE),
	m_hwnd				(NULL),
	m_hIcon				(NULL),
	m_fAutoSize			(FALSE),
	m_hInstance			(NULL),
	m_nWidth			(0),
	m_nHeight			(0),
	m_nTextWidth		(POPUPMSG_DLG_DEF_TEXT_WIDTH)
{
	TRACE_OUT(("Constructing CPopupMsg"));

	if (NULL != m_splstPopupMsgs)
	{
		CPopupMsg* p = const_cast<CPopupMsg*>(this);
		m_splstPopupMsgs->Add(p);
	}
}

CPopupMsg::~CPopupMsg()
{
	TRACE_OUT(("Destructing CPopupMsg"));
	
	if (NULL != m_hIcon)
	{
		DestroyIcon(m_hIcon);
	}
	
	if (NULL != m_hwnd)
	{
		KillTimer(m_hwnd, POPUPMSG_TIMER);
		KillTimer(m_hwnd, POPUPMSG_RING_TIMER);
		
		DestroyWindow(m_hwnd);
		if (m_fAutoSize)
		{
			m_uVisiblePixels -= m_nHeight;
		}
	}

	if (NULL != m_splstPopupMsgs)
	{
		CPopupMsg* p = const_cast<CPopupMsg*>(this);			
		if( !m_splstPopupMsgs->Remove(p) )
		{
			TRACE_OUT(("CPopupMsg object is not in the list"));
		}
	}
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   PlaySound()
*
*    PURPOSE:  Plays the sound or beeps the system speaker
*
****************************************************************************/

VOID CPopupMsg::PlaySound()
{
	if (FALSE == ::PlaySound(m_szSound, NULL,
			SND_APPLICATION | SND_ALIAS | SND_ASYNC | SND_NOWAIT))
	{
		// Use the computer speaker to beep:
		TRACE_OUT(("PlaySound() failed, trying MessageBeep()"));
		::MessageBeep(0xFFFFFFFF);
	}
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   Change(LPCTSTR)
*
*    PURPOSE:  Changes the text on an existing popup message
*
****************************************************************************/

BOOL CPopupMsg::Change(LPCTSTR pcszText)
{
	BOOL bRet = FALSE;
	
	// BUGBUG: doesn't handle dialog message
	
	if (NULL != m_hwnd)
	{
		bRet = ::SetWindowText(m_hwnd, pcszText);
	}

	return bRet;
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   Init()
*
*    PURPOSE:  Allocates a static list of these objects
*
****************************************************************************/

BOOL CPopupMsg::Init()
{
	ASSERT(NULL == m_splstPopupMsgs);
	return (NULL != (m_splstPopupMsgs = new CSimpleArray<CPopupMsg*>));
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   Cleanup()
*
*    PURPOSE:  Removes all of the objects of this type
*
****************************************************************************/

VOID CPopupMsg::Cleanup()
{
	if (NULL != m_splstPopupMsgs)
	{
		for( int i = 0; i < m_splstPopupMsgs->GetSize(); ++i )
		{	
			ASSERT( (*m_splstPopupMsgs)[i] != NULL);
			CPopupMsg *pThis = (*m_splstPopupMsgs)[i];
			delete pThis;
		}

		delete m_splstPopupMsgs;
		m_splstPopupMsgs = NULL;
	}
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   PMWndProc(HWND, unsigned, WORD, LONG)
*
*    PURPOSE:
*
****************************************************************************/

LRESULT CALLBACK CPopupMsg::PMWndProc(
	HWND hWnd,                /* window handle                   */
	UINT message,             /* type of message                 */
	WPARAM wParam,            /* additional information          */
	LPARAM lParam)            /* additional information          */
{
	CPopupMsg* ppm;
	LPCREATESTRUCT lpcs;

	switch (message)
	{
		case WM_CREATE:
		{
			TRACE_OUT(("PopupMsg Window created"));
			
			lpcs = (LPCREATESTRUCT) lParam;
			ppm = (CPopupMsg*) lpcs->lpCreateParams;
			ASSERT(ppm && "NULL object passed in WM_CREATE!");
			SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) ppm);

			// Create a timer to make the window time-out and disappear:
			::SetTimer(hWnd, POPUPMSG_TIMER, ppm->m_uTimeout, NULL);
			
			// For now, if you pass a callback, you get ringing.
			// If not, there is no ring
			if (NULL != ppm->m_fPlaySound)
			{
				ppm->PlaySound();
				
				if (NULL != ppm->m_fRing)
				{
					// Create a timer to make the ringer start:
					::SetTimer(hWnd, POPUPMSG_RING_TIMER, POPUPMSG_RING_INTERVAL, NULL);
				}
			}

			break;
		}

		case WM_TIMER:
		{
			ppm = (CPopupMsg*) GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if (POPUPMSG_TIMER == wParam)
			{
				// Message timed out:
				if (NULL != ppm)
				{
					PMCALLBACKPROC pCallback;
					if (NULL != (pCallback = ppm->m_pCallbackProc))
					{
						ppm->m_pCallbackProc = NULL;
						pCallback(ppm->m_pContext, PMF_CANCEL | PMF_TIMEOUT);
					}
					
					// Self-destruct:
					if (NULL != ppm->m_hwnd)
					{
						// NULL out the object pointer:
						SetWindowLongPtr(hWnd, GWLP_USERDATA, 0L);
						delete ppm;
					}
				}
			}
			else if (POPUPMSG_RING_TIMER == wParam)
			{
				if (NULL != ppm)
				{
					ppm->PlaySound();
				}
				
				// Create a timer to make it ring again:
				::SetTimer(	hWnd,
							POPUPMSG_RING_TIMER,
							POPUPMSG_RING_INTERVAL,
							NULL);
			}
				
			break;
		}

		case WM_LBUTTONUP:
		{
			// Clicked on the message:
			ppm = (CPopupMsg*) GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if (NULL != ppm)
			{
				::PlaySound(NULL, NULL, 0); // stop playing the ring sound
				::KillTimer(ppm->m_hwnd, POPUPMSG_TIMER);
				::KillTimer(ppm->m_hwnd, POPUPMSG_RING_TIMER);
				
				PMCALLBACKPROC pCallback;
				if (NULL != (pCallback = ppm->m_pCallbackProc))
				{
					ppm->m_pCallbackProc = NULL;
					pCallback(ppm->m_pContext, PMF_OK);
				}
				
				// Self-destruct:
				if (NULL != ppm->m_hwnd)
				{
					// NULL out the object pointer:
					SetWindowLongPtr(hWnd, GWLP_USERDATA, 0L);
					delete ppm;
				}
			}
			break;
		}

		case WM_PAINT:
		{
			// Handle painting:
			PAINTSTRUCT ps;
			HDC hdc;
			int nHorizTextOffset = POPUPMSG_LEFT_MARGIN;
			
			if (hdc = ::BeginPaint(hWnd, &ps))
			{
				// Start by painting the icon (if needed)
				ppm = (CPopupMsg*) ::GetWindowLongPtr(hWnd, GWLP_USERDATA);
				if ((NULL != ppm) &&
					(NULL != ppm->m_hIcon))
				{
					if (::DrawIconEx(	hdc,
										POPUPMSG_LEFT_MARGIN,
										POPUPMSG_TOP_MARGIN,
										ppm->m_hIcon,
										POPUPMSG_ICON_WIDTH,
										POPUPMSG_ICON_HEIGHT,
										0,
										NULL,
										DI_NORMAL))
					{
						// We painted an icon, so make sure the text is shifted
						// to the right by the right amount:
						nHorizTextOffset += (POPUPMSG_ICON_WIDTH + POPUPMSG_ICON_GAP);
					}
				}
				
				// Draw the text with a transparent background:
				int bkOld = ::SetBkMode(hdc, TRANSPARENT);
				COLORREF crOld = ::SetTextColor(hdc, ::GetSysColor(COLOR_WINDOWTEXT));
				HFONT hFontOld = (HFONT) ::SelectObject(hdc, g_hfontDlg);
				
				TCHAR szWinText[POPUPMSG_MAX_LENGTH];
				szWinText[0] = _T('\0');
				
				::GetWindowText(hWnd, szWinText, sizeof(szWinText));

				RECT rctClient;
				if (::GetClientRect(hWnd, &rctClient))
				{
					rctClient.left += nHorizTextOffset;
					
					::DrawText(	hdc, szWinText, -1, &rctClient,
								DT_SINGLELINE | DT_NOCLIP | DT_VCENTER | DT_NOPREFIX);
				}

				::SetBkMode(hdc, bkOld);
				::SetTextColor(hdc, crOld);
				::SelectObject(hdc, hFontOld);
				
				::EndPaint(hWnd, &ps);
			}
			break;
		}

		default:
		{
			return DefWindowProc(hWnd, message, wParam, lParam);
		}
	}
	return(FALSE);
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   PMDlgProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Handles messages associated with the incoming call dialog
*
****************************************************************************/

INT_PTR CALLBACK CPopupMsg::PMDlgProc(	HWND hDlg,
									UINT uMsg,
									WPARAM wParam,
									LPARAM lParam)
{
	CPopupMsg* ppm;

	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			TRACE_OUT(("PopupMsg Window created"));

			AddModelessDlg(hDlg);
	
			ppm = (CPopupMsg*) lParam;
			ASSERT(ppm && "NULL object passed in WM_INITDIALOG!");
			::SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) ppm);

			TRACE_OUT(("CPopupMsg m_nTextWidth=%d in WM_INITDIALOG", ppm->m_nTextWidth));

			// If the dialog is too big, then resize the text width.
			RECT rctDlg;
			RECT rctDesk;
			HWND hwndDesk;
			if (::GetWindowRect(hDlg, &rctDlg) &&
				(hwndDesk = ::GetDesktopWindow()) &&
				::GetWindowRect(hwndDesk, &rctDesk))
			{
				int nDlgWidth = rctDlg.right - rctDlg.left;
				ppm->m_nTextWidth -= max(	0,
											nDlgWidth + ppm->m_nTextWidth -
												(rctDesk.right - rctDesk.left));
			}

			RECT rctCtrl;
			// Move the "Authenticate" button, if it's there
			HWND hwndAuth = ::GetDlgItem(hDlg, IDB_AUTH);
			if ((NULL != hwndAuth) && ::GetWindowRect(hwndAuth, &rctCtrl)) {
				// Turn rctCtrl's top and left into client coords:
				::MapWindowPoints(NULL, hDlg, (LPPOINT) &rctCtrl, 1);
				::SetWindowPos(	hwndAuth,
								NULL,
								rctCtrl.left + ppm->m_nTextWidth,
								rctCtrl.top,
								0, 0,
								SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE | SWP_NOREDRAW);

			}
			// Move the "Accept" button (IDOK)
			HWND hwndOK = ::GetDlgItem(hDlg, IDOK);
			if ((NULL != hwndOK) && ::GetWindowRect(hwndOK, &rctCtrl))
			{
				// Turn rctCtrl's top and left into client coords:
				::MapWindowPoints(NULL, hDlg, (LPPOINT) &rctCtrl, 1);
				::SetWindowPos(	hwndOK,
								NULL,
								rctCtrl.left + ppm->m_nTextWidth,
								rctCtrl.top,
								0, 0,
								SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE | SWP_NOREDRAW);
			}
			// Move the "Ignore" button (IDCANCEL)
			HWND hwndCancel = ::GetDlgItem(hDlg, IDCANCEL);
			if ((NULL != hwndCancel) && ::GetWindowRect(hwndCancel, &rctCtrl))
			{
				// Turn rctCtrl's top and left into client coords:
				::MapWindowPoints(NULL, hDlg, (LPPOINT) &rctCtrl, 1);
				::SetWindowPos(	hwndCancel,
								NULL,
								rctCtrl.left + ppm->m_nTextWidth,
								rctCtrl.top,
								0, 0,
								SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE | SWP_NOREDRAW);
			}
			// Stretch the text field:
			HWND hwndText = ::GetDlgItem(hDlg, IDC_MSG_STATIC);
			if ((NULL != hwndText) && ::GetWindowRect(hwndText, &rctCtrl))
			{
				::SetWindowPos(	hwndText,
								NULL,
								0, 0,
								ppm->m_nTextWidth,
								rctCtrl.bottom - rctCtrl.top,
								SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);

				// and set the font
				::SendMessage(hwndText, WM_SETFONT, (WPARAM) g_hfontDlg, 0);
			}

			// Create a timer to make the window time-out and disappear:
			::SetTimer(hDlg, POPUPMSG_TIMER, ppm->m_uTimeout, NULL);
			
			// For now, if you pass a callback, you get ringing.
			// If not, there is no ring
			if (NULL != ppm->m_fPlaySound)
			{
				ppm->PlaySound();
				
				if (NULL != ppm->m_fRing)
				{
					// Create a timer to make the ringer start:
					::SetTimer(hDlg, POPUPMSG_RING_TIMER, POPUPMSG_RING_INTERVAL, NULL);
				}
			}
			return TRUE;
		}

		case WM_TIMER:
		{
			ppm = (CPopupMsg*) GetWindowLongPtr(hDlg, GWLP_USERDATA);
			if (POPUPMSG_TIMER == wParam)
			{
				// Message timed out:
				if (NULL != ppm)
				{
					PMCALLBACKPROC pCallback;
					if (NULL != (pCallback = ppm->m_pCallbackProc))
					{
						ppm->m_pCallbackProc = NULL;
						// hide the dialog in case the callback doesn't
						// return immediately
						::ShowWindow(ppm->m_hwnd, SW_HIDE);
						pCallback(ppm->m_pContext, PMF_CANCEL | PMF_TIMEOUT);
					}
					
					// Self-destruct:
					if (NULL != ppm->m_hwnd)
					{
						// NULL out the object pointer:
						SetWindowLongPtr(hDlg, GWLP_USERDATA, 0L);
						delete ppm;
					}
				}
			}
			else if (POPUPMSG_RING_TIMER == wParam)
			{
				if (NULL != ppm)
				{
					ppm->PlaySound();
				}
				
				// Create a timer to make it ring again:
				::SetTimer(	hDlg,
							POPUPMSG_RING_TIMER,
							POPUPMSG_RING_INTERVAL,
							NULL);
			}
				
			return TRUE;
		}

		case WM_COMMAND:
		{
			// Clicked on one of the buttons:
			ppm = (CPopupMsg*) GetWindowLongPtr(hDlg, GWLP_USERDATA);
			if (NULL != ppm)
			{
				// stop playing the ring sound
				::PlaySound(NULL, NULL, 0);
				::KillTimer(ppm->m_hwnd, POPUPMSG_RING_TIMER);
				::KillTimer(ppm->m_hwnd, POPUPMSG_TIMER);
				
				PMCALLBACKPROC pCallback;
				if (NULL != (pCallback = ppm->m_pCallbackProc))
				{
					ppm->m_pCallbackProc = NULL; // prevent this from firing twice
					// hide the dialog in case the callback doesn't
					// return immediately
					::ShowWindow(ppm->m_hwnd, SW_HIDE);
					pCallback(ppm->m_pContext,
						(IDB_AUTH == LOWORD(wParam)) ? PMF_AUTH : (IDOK == LOWORD(wParam)) ? PMF_OK : PMF_CANCEL);
				}
				
				// Self-destruct:
				if (NULL != ppm->m_hwnd)
				{
					// NULL out the object pointer:
					SetWindowLongPtr(hDlg, GWLP_USERDATA, 0L);
					delete ppm;
				}
			}
			return TRUE;
		}

		case WM_DESTROY:
		{
			::RemoveModelessDlg(hDlg);
			break;
		}

		default:
			break;
	} /* switch (uMsg) */

	return FALSE;
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   SecurePMDlgProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Handles messages associated with the incoming call dialog
*
****************************************************************************/

INT_PTR CALLBACK CPopupMsg::SecurePMDlgProc(	HWND hDlg,
											UINT uMsg,
											WPARAM wParam,
											LPARAM lParam)
{
	CPopupMsg* ppm;

	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			TRACE_OUT(("PopupMsg Window created"));

			AddModelessDlg(hDlg);
	
			ppm = (CPopupMsg*) lParam;
			ASSERT(ppm && "NULL object passed in WM_INITDIALOG!");
			::SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) ppm);

			TRACE_OUT(("CPopupMsg m_nTextWidth=%d in WM_INITDIALOG", ppm->m_nTextWidth));

			RegEntry re(UI_KEY, HKEY_CURRENT_USER);
			if (1 == re.GetNumber(REGVAL_SHOW_SECUREDETAILS, DEFAULT_SHOW_SECUREDETAILS)) {				
				ExpandSecureDialog(hDlg,ppm);
			}
			// Create a timer to make the window time-out and disappear:
			::SetTimer(hDlg, POPUPMSG_TIMER, ppm->m_uTimeout, NULL);
			
			// For now, if you pass a callback, you get ringing.
			// If not, there is no ring
			if (NULL != ppm->m_fPlaySound)
			{
				ppm->PlaySound();
				
				if (NULL != ppm->m_fRing)
				{
					// Create a timer to make the ringer start:
					::SetTimer(hDlg, POPUPMSG_RING_TIMER, POPUPMSG_RING_INTERVAL, NULL);
				}
			}
			return TRUE;
		}

		case WM_TIMER:
		{
			ppm = (CPopupMsg*) GetWindowLongPtr(hDlg, GWLP_USERDATA);
			if (POPUPMSG_TIMER == wParam)
			{
				// Message timed out:
				if (NULL != ppm)
				{
					PMCALLBACKPROC pCallback;
					if (NULL != (pCallback = ppm->m_pCallbackProc))
					{
						ppm->m_pCallbackProc = NULL;
						// hide the dialog in case the callback doesn't
						// return immediately
						::ShowWindow(ppm->m_hwnd, SW_HIDE);
						pCallback(ppm->m_pContext, PMF_CANCEL | PMF_TIMEOUT);
					}
					
					// Self-destruct:
					if (NULL != ppm->m_hwnd)
					{
						// NULL out the object pointer:
						SetWindowLongPtr(hDlg, GWLP_USERDATA, 0L);
						delete ppm;
					}
				}
			}
			else if (POPUPMSG_RING_TIMER == wParam)
			{
				if (NULL != ppm)
				{
					ppm->PlaySound();
				}
				
				// Create a timer to make it ring again:
				::SetTimer(	hDlg,
							POPUPMSG_RING_TIMER,
							POPUPMSG_RING_INTERVAL,
							NULL);
			}
				
			return TRUE;
		}

		case WM_COMMAND:
		{
			ppm = (CPopupMsg*) GetWindowLongPtr(hDlg, GWLP_USERDATA);
			switch (LOWORD(wParam)) {
			case IDOK:
			case IDCANCEL:
				// Clicked on one of the buttons:

				if (NULL != ppm)
				{
					// stop playing the ring sound
					::PlaySound(NULL, NULL, 0);
					::KillTimer(ppm->m_hwnd, POPUPMSG_RING_TIMER);
					::KillTimer(ppm->m_hwnd, POPUPMSG_TIMER);
					
					PMCALLBACKPROC pCallback;
					if (NULL != (pCallback = ppm->m_pCallbackProc))
					{
						ppm->m_pCallbackProc = NULL; // prevent this from firing twice
						// hide the dialog in case the callback doesn't
						// return immediately
						::ShowWindow(ppm->m_hwnd, SW_HIDE);
						pCallback(ppm->m_pContext, (IDOK == LOWORD(wParam)) ? PMF_OK : PMF_CANCEL);
					}
					
					// Self-destruct:
					if (NULL != ppm->m_hwnd)
					{
						// NULL out the object pointer:
						SetWindowLongPtr(hDlg, GWLP_USERDATA, 0L);
						delete ppm;
					}
				}
				break;
			case IDB_DETAILS:
				RegEntry re(UI_KEY, HKEY_CURRENT_USER);
				if (1 == re.GetNumber(REGVAL_SHOW_SECUREDETAILS,DEFAULT_SHOW_SECUREDETAILS)) {
					// Currently expanded, so shrink
					re.SetValue(REGVAL_SHOW_SECUREDETAILS,(DWORD)0);
					ShrinkSecureDialog(hDlg);
				}
				else {
					// Currently shrunk, so expand
					re.SetValue(REGVAL_SHOW_SECUREDETAILS,1);
					ExpandSecureDialog(hDlg,ppm);
				}
				break;
			}
			return TRUE;
		}

		case WM_DESTROY:
		{
			::RemoveModelessDlg(hDlg);
			break;
		}

		default:
			break;
	} /* switch (uMsg) */

	return FALSE;
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   Create()
*
*    PURPOSE:  Creates a popup message window
*
****************************************************************************/

HWND CPopupMsg::Create(	LPCTSTR pcszText, BOOL fRing, LPCTSTR pcszIconName,
						HINSTANCE hInstance, UINT uIDSoundEvent,
						UINT uTimeout, int xCoord, int yCoord)
{
	ASSERT(pcszText);
	
	m_fRing = fRing;
	m_fPlaySound = (BOOL) uIDSoundEvent;
	m_uTimeout = uTimeout;
	// First try to load the icon:
	m_hInstance = hInstance;
	if ((NULL != m_hInstance) && (NULL != pcszIconName))
	{
		m_hIcon = (HICON) LoadImage(m_hInstance,
									pcszIconName,
									IMAGE_ICON,
									POPUPMSG_ICON_WIDTH,
									POPUPMSG_ICON_HEIGHT,
									LR_DEFAULTCOLOR);
	}
	else
	{
		m_hIcon = NULL;
	}

	if ((NULL == m_hInstance) ||
		(!::LoadString(	m_hInstance,
						uIDSoundEvent,
						m_szSound,
						CCHMAX(m_szSound))))
	{
		m_szSound[0] = _T('\0');
	}

	// initialize window size with default values:
	m_nWidth = POPUPMSG_WIDTH;
	m_nHeight = POPUPMSG_HEIGHT;

	HWND hwndDesktop = GetDesktopWindow();
	if (NULL != hwndDesktop)
	{
		RECT rctDesktop;
		::GetWindowRect(hwndDesktop, &rctDesktop);
		HDC hdc = GetDC(hwndDesktop);
		if (NULL != hdc)
		{
			HFONT hFontOld = (HFONT) SelectObject(hdc, g_hfontDlg);
			SIZE size;
			if (GetTextExtentPoint32(hdc, pcszText, lstrlen(pcszText), &size))
			{
				// don't make it wider than the desktop
				m_nWidth = min(	rctDesktop.right - rctDesktop.left,
								size.cx + (2 * POPUPMSG_CLIENT_MARGIN));
				m_nHeight = size.cy + (2 * POPUPMSG_CLIENT_MARGIN);
				
				// If we have succesfully loaded an icon, make size
				// adjustments:
				if (NULL != m_hIcon)
				{
					m_nWidth += POPUPMSG_ICON_WIDTH + POPUPMSG_ICON_GAP;
					if (size.cy < POPUPMSG_ICON_HEIGHT)
					{
						m_nHeight = POPUPMSG_ICON_HEIGHT +
										(2 * POPUPMSG_CLIENT_MARGIN);
					}
				}
			}

			// Reselect old font
			SelectObject(hdc, hFontOld);
			ReleaseDC(hwndDesktop, hdc);
		}
	
		POINT pt;
		GetIdealPosition(&pt, xCoord, yCoord);

		m_hwnd = CreateWindowEx(WS_EX_PALETTEWINDOW,
									g_szPopupMsgWndClass,
									pcszText,
									WS_POPUP | /* WS_VISIBLE |*/ WS_DLGFRAME,
									pt.x, pt.y,
									m_nWidth, m_nHeight,
									NULL,
									NULL,
									::GetInstanceHandle(),
									(LPVOID) this);
		if (m_fAutoSize)
		{
			m_uVisiblePixels += m_nHeight;
		}

		// Show, but don't activate
		::ShowWindow(m_hwnd, SW_SHOWNA);
		// Repaint
    	::UpdateWindow(m_hwnd);

		return m_hwnd;
	}

	// Something went wrong
	return NULL;
}


/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   CreateDlg()
*
*    PURPOSE:  Creates a popup dialog message window
*
****************************************************************************/

HWND CPopupMsg::CreateDlg(	LPCTSTR pcszText, BOOL fRing, LPCTSTR pcszIconName,
							HINSTANCE hInstance, UINT uIDSoundEvent,
							UINT uTimeout, int xCoord, int yCoord)
{
	ASSERT(pcszText);
	
	m_fRing = fRing;
	m_fPlaySound = (BOOL) uIDSoundEvent;
	m_uTimeout = uTimeout;
	// First try to load the icon:
	m_hInstance = hInstance;
	if ((NULL != m_hInstance) && (NULL != pcszIconName))
	{
		m_hIcon = (HICON) LoadImage(m_hInstance,
									pcszIconName,
									IMAGE_ICON,
									POPUPMSG_ICON_WIDTH,
									POPUPMSG_ICON_HEIGHT,
									LR_DEFAULTCOLOR);
	}
	else
	{
		m_hIcon = NULL;
	}

	if ((NULL == m_hInstance) ||
		(!::LoadString(	m_hInstance,
						uIDSoundEvent,
						m_szSound,
						sizeof(m_szSound))))
	{
		m_szSound[0] = _T('\0');
	}

	// init with large defaults in case getwindowrect fails
	RECT rctDesktop = { 0x0000, 0x0000, 0xFFFF, 0xFFFF };
	HWND hwndDesktop = GetDesktopWindow();
	if (NULL != hwndDesktop)
	{
		::GetWindowRect(hwndDesktop, &rctDesktop);
		HDC hdc = GetDC(hwndDesktop);
		if (NULL != hdc)
		{
			HFONT hFontOld = (HFONT) SelectObject(hdc, g_hfontDlg);
			SIZE size;
			if (::GetTextExtentPoint32(hdc, pcszText, lstrlen(pcszText), &size))
			{
				m_nTextWidth = size.cx;
			}
			::SelectObject(hdc, hFontOld);
			::ReleaseDC(hwndDesktop, hdc);
		}
	}

	KillScrnSaver();

	INmCall * pCall = NULL;
	PBYTE pb = NULL;
	ULONG cb = 0;

	int id;
	
	if (m_pContext != NULL) {
		pCall = ((CCall *)m_pContext)->GetINmCall();
	}
	if (NULL != pCall && S_OK == pCall->GetUserData(g_csguidSecurity,&pb,&cb)) {
		// This is an encrypted call
		CoTaskMemFree(pb);
		id = IDD_SECURE_INCOMING_CALL;
		m_hwnd = ::CreateDialogParam(m_hInstance, MAKEINTRESOURCE(id),
			::GetMainWindow(),CPopupMsg::SecurePMDlgProc,(LPARAM) this);

	}
	else {
		id = IDD_INCOMING_CALL;
		m_hwnd = ::CreateDialogParam(m_hInstance, MAKEINTRESOURCE(id),
			::GetMainWindow(),CPopupMsg::PMDlgProc,(LPARAM) this);
	}
		
	if (NULL != m_hwnd)
	{
		::SetDlgItemText(m_hwnd, IDC_MSG_STATIC, pcszText);

		RECT rctDlg;
		::GetWindowRect(m_hwnd, &rctDlg);

		// Stretch the width to fit the person's name,
		// but not wider than the desktop.
		// int nDeskWidth = rctDesktop.right - rctDesktop.left;

		// Resize the non-secure dialog
		m_nWidth = (rctDlg.right - rctDlg.left) + ((IDD_INCOMING_CALL == id) ? m_nTextWidth : 0);
		// if (m_nWidth > nDeskWidth)
		// {
		//	m_nTextWidth -= (m_nWidth - nDeskWidth);
		//	m_nWidth = nDeskWidth;
		// }
		m_nHeight = rctDlg.bottom - rctDlg.top;
		
		POINT pt;
		GetIdealPosition(&pt, xCoord, yCoord);

		// Show, move, make topmost, but don't activate
		::SetWindowPos(	m_hwnd,
						HWND_TOPMOST,
						pt.x,
						pt.y,
						m_nWidth,
						m_nHeight,
						SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_DRAWFRAME);
		
		if (m_fAutoSize)
		{
			m_uVisiblePixels += m_nHeight;
		}
	}

	return m_hwnd;
}

BOOL CPopupMsg::GetIdealPosition(LPPOINT ppt, int xCoord, int yCoord)
{
	ASSERT(ppt);

	BOOL bRet = FALSE;
	HWND hwndDesktop = GetDesktopWindow();
	RECT rctDesktop;

	if (NULL != hwndDesktop)
	{
		int yBottomofTrayRect = 0;
	
		if ((-1 == xCoord) && (-1 == yCoord))
		{
			m_fAutoSize = TRUE;
			// BUGBUG: We search for the tray notification window by looking for
			// hard coded window class names.  This is safe if we're running
			// Win 95 build 950.6, but maybe not otherwise...

			HWND hwndTray = FindWindowEx(NULL, NULL, g_cszTrayWndClass, NULL);
			if (NULL != hwndTray)
			{
				HWND hwndTrayNotify = FindWindowEx(hwndTray, NULL, g_cszTrayNotifyWndClass, NULL);

				if (NULL != hwndTrayNotify)
				{
					RECT rctTrayNotify;
					
					if (GetWindowRect(hwndTrayNotify, &rctTrayNotify))
					{
						xCoord = rctTrayNotify.right;
						yCoord = rctTrayNotify.top;
						yBottomofTrayRect = rctTrayNotify.bottom;
					}
				}
			}
		}

		if (GetWindowRect(hwndDesktop, &rctDesktop))
		{
			// Make sure that xCoord and yCoord are on the screen (bugs 1817,1819):
			xCoord = min(rctDesktop.right, xCoord);
			xCoord = max(rctDesktop.left, xCoord);
			
			yCoord = min(rctDesktop.bottom, yCoord);
			yCoord = max(rctDesktop.top, yCoord);
			
			// First attempt will be to center the toolbar horizontally
			// with respect to the mouse position and place it directly
			// above vertically.

			ppt->x = xCoord - (m_nWidth / 2);
			// Make the window higher if there are exisiting visible messages
			ppt->y = yCoord - m_uVisiblePixels - m_nHeight;

			// If we are too high on the screen (the taskbar is probably
			// docked on top), then use the click position as the top of
			// where the toolbar will appear.
			
			if (ppt->y < 0)
			{
				ppt->y = yCoord;
				
				// Even better, if we have found the tray rect and we know that
				// we have docked on top, then use the bottom of the rect instead
				// of the top
				if (0 != yBottomofTrayRect)
				{
					ppt->y = yBottomofTrayRect;
					// Make the window lower if there are
					// exisiting visible messages
					ppt->y += m_uVisiblePixels;
				}
			}

			// Repeat the same logic for the horizontal position
			if (ppt->x < 0)
			{
				ppt->x = xCoord;
			}

			// If the toolbar if off the screen to the right, then right-justify it
			if (ppt->x > (rctDesktop.right - m_nWidth))
			{
				ppt->x = max(0, xCoord - m_nWidth);
			}

			bRet = TRUE;
		}
	}

	return bRet;
}

VOID CPopupMsg::ExpandSecureDialog(HWND hDlg,CPopupMsg * ppm)
{
	RECT rect, editrect;
	// Change the dialog to the expanded version.

	if (GetWindowRect(hDlg,&rect) &&
		GetWindowRect(GetDlgItem(hDlg,IDC_SECURE_CALL_EDIT),&editrect)) {

		int nHeight = rect.bottom - rect.top;
		int nWidth = rect.right - rect.left;
		//
		// Grow by height of edit control plus 7 dialog unit margin as
		// given by edit control offset within control:
		//
		int deltaHeight = ( editrect.bottom - editrect.top ) +
							( editrect.left - rect.left );

		SetWindowPos(hDlg,NULL,
		rect.left,(rect.top - deltaHeight > 0 ? rect.top - deltaHeight : 0),
			nWidth,nHeight + deltaHeight, SWP_NOZORDER);
			
		// Make the edit box visible.
		HWND hEditBox = GetDlgItem(hDlg, IDC_SECURE_CALL_EDIT);
		if (hEditBox != NULL) {
			ShowWindow(hEditBox,SW_SHOW);
			EnableWindow(hEditBox, TRUE);
			// Get security information, if any.
			if (NULL != ppm) {
				INmCall * pCall = NULL;
				PBYTE pb = NULL;
				ULONG cb = 0;
				
				if (NULL != ppm->m_pContext) {
					pCall = ((CCall *)ppm->m_pContext)->GetINmCall();
				}
				if (NULL != pCall && S_OK == pCall->GetUserData(g_csguidSecurity,&pb,&cb)) {
					ASSERT(pb);
					ASSERT(cb);
					if ( TCHAR * pCertText = FormatCert( pb, cb )) {
						SetDlgItemText(hDlg,IDC_SECURE_CALL_EDIT,pCertText);
						delete pCertText;
					}
					else {
						ERROR_OUT(("FormatCert failed"));
					}
					CoTaskMemFree(pb);
				}
			}
		}

		// Move the buttons southward.
		HWND hButton = GetDlgItem(hDlg, IDOK);
		if (hButton && GetWindowRect(hButton,&rect)) {
			MapWindowPoints(HWND_DESKTOP,hDlg,(LPPOINT)&rect,2);
			SetWindowPos(hButton,NULL,rect.left,rect.top + deltaHeight,0,0,
				SWP_NOZORDER | SWP_NOSIZE);
		}
		hButton = GetDlgItem(hDlg, IDCANCEL);
		if (hButton && GetWindowRect(hButton,&rect)) {
			MapWindowPoints(HWND_DESKTOP,hDlg,(LPPOINT)&rect,2);
			SetWindowPos(hButton,NULL,rect.left,rect.top + deltaHeight,0,0,
				SWP_NOZORDER | SWP_NOSIZE);
		}
		hButton = GetDlgItem(hDlg, IDB_DETAILS);
		if (hButton && GetWindowRect(hButton,&rect)) {
			MapWindowPoints(HWND_DESKTOP,hDlg,(LPPOINT)&rect,2);
			SetWindowPos(hButton,NULL,rect.left,rect.top + deltaHeight,0,0,
				SWP_NOZORDER | SWP_NOSIZE);

			// Change text on Details button
			TCHAR lpButtonString[MAX_PATH];
			::FLoadString(IDS_SECURITY_NODETAILS, lpButtonString, MAX_PATH);
			SetDlgItemText(hDlg,IDB_DETAILS,lpButtonString);	
		}

	}
}

VOID CPopupMsg::ShrinkSecureDialog(HWND hDlg)
{
	RECT rect,editrect;
	// Change the dialog to the normal version.
	if (GetWindowRect(hDlg,&rect) &&
		GetWindowRect(GetDlgItem(hDlg,IDC_SECURE_CALL_EDIT),&editrect)) {
		int nHeight = rect.bottom - rect.top;
		int nWidth = rect.right - rect.left;
		//
		// Grow by height of edit control plus 7 dialog unit margin as
		// given by edit control offset within control:
		//
		int deltaHeight = ( editrect.bottom - editrect.top ) +
							( editrect.left - rect.left );

		SetWindowPos(hDlg,NULL,
		rect.left,(rect.top - deltaHeight > 0 ? rect.top + deltaHeight : 0),
			nWidth,nHeight - deltaHeight,SWP_NOZORDER);
			
		// Make the edit box invisible.
		HWND hEditBox = GetDlgItem(hDlg, IDC_SECURE_CALL_EDIT);
		if (hEditBox != NULL) {
			ShowWindow(hEditBox,SW_HIDE);
			EnableWindow(hEditBox,FALSE);
		}

		// Move the buttons northward.
		HWND hButton = GetDlgItem(hDlg, IDOK);
		if (hButton && GetWindowRect(hButton,&rect)) {
			MapWindowPoints(HWND_DESKTOP,hDlg,(LPPOINT)&rect,2);
			SetWindowPos(hButton,NULL,rect.left,rect.top - deltaHeight,0,0,
				SWP_NOZORDER | SWP_NOSIZE);
		}
		hButton = GetDlgItem(hDlg, IDCANCEL);
		if (hButton && GetWindowRect(hButton,&rect)) {
			MapWindowPoints(HWND_DESKTOP,hDlg,(LPPOINT)&rect,2);
			SetWindowPos(hButton,NULL,rect.left,rect.top - deltaHeight,0,0,
				SWP_NOZORDER | SWP_NOSIZE);
		}
		hButton = GetDlgItem(hDlg, IDB_DETAILS);
		if (hButton && GetWindowRect(hButton,&rect)) {
			MapWindowPoints(HWND_DESKTOP,hDlg,(LPPOINT)&rect,2);
			SetWindowPos(hButton,NULL,rect.left,rect.top - deltaHeight,0,0,
				SWP_NOZORDER | SWP_NOSIZE);

			TCHAR lpButtonString[MAX_PATH];
			::FLoadString(IDS_SECURITY_DETAILS, lpButtonString, MAX_PATH);
			SetDlgItemText(hDlg,IDB_DETAILS,lpButtonString);	

		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\precomp.cpp ===
#include "precomp.h"


#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\progressbar.cpp ===
// File: Progressbar.cpp

#include "precomp.h"

#include "ProgressBar.h"
#include "GenControls.h"

#define SIGNAL_STATUS_TRANSMIT  0x01  // data is being received/sent
#define SIGNAL_STATUS_JAMMED    0x02  // wave dev failed to open


CProgressBar::CProgressBar()
{
	for (int i=0; i<ARRAY_ELEMENTS(m_hbs); ++i)
	{
		m_hbs[i] = NULL;
	}
}

CProgressBar::~CProgressBar()
{
	for (int i=0; i<ARRAY_ELEMENTS(m_hbs); ++i)
	{
		if (NULL != m_hbs[i])
		{
			DeleteObject(m_hbs[i]);
			m_hbs[i] = NULL;
		}
	}
}

BOOL CProgressBar::Create(
	HBITMAP hbFrame,	// The outside (static) part of the progress bar
	HBITMAP hbBar,		// The inside part of the progress bar that jumps around
	HWND hWndParent		// The parent of the toolbar window
	)
{
	ASSERT(NULL!=hbFrame && NULL!=hbBar);

	SetFrame(hbFrame);
	SetBar(hbBar);

	if (!CGenWindow::Create(hWndParent, 0, g_szEmpty, 0, 0))
	{
		return(FALSE);
	}

	return(TRUE);
}

void CProgressBar::GetDesiredSize(SIZE *ppt)
{
	CGenWindow::GetDesiredSize(ppt);

	if (NULL == GetFrame())
	{
		return;
	}

	SIZE sizeBitmap;
	CBitmapButton::GetBitmapSizes(&m_hbs[Frame], &sizeBitmap, 1);
	ppt->cx += sizeBitmap.cx;
	ppt->cy += sizeBitmap.cy;
}

LRESULT CProgressBar::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_PAINT, OnPaint);
	}

	return(CGenWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

void CProgressBar::OnPaint(HWND hwnd)
{
	if (NULL == GetFrame() || NULL == GetBar() || 0 == GetMaxValue())
	{
		FORWARD_WM_PAINT(hwnd, CGenWindow::ProcessMessage);
		return;
	}

	PAINTSTRUCT ps;
	HDC hdc = BeginPaint(hwnd, &ps);

	HDC hdcTemp = CreateCompatibleDC(hdc);
	if (NULL != hdcTemp)
	{
		HPALETTE hPal = GetPalette();
		HPALETTE hOld = NULL;
		if (NULL != hPal)
		{
			hOld = SelectPalette(hdc, hPal, TRUE);
			RealizePalette(hdc);
			SelectPalette(hdcTemp, hPal, TRUE);
			RealizePalette(hdcTemp);
		}

		SIZE sizes[NumBitmaps];
		CBitmapButton::GetBitmapSizes(m_hbs, sizes, NumBitmaps);

		// BUGBUG georgep: This is going to flicker, so I will need to fix that

		SelectObject(hdcTemp, GetFrame());
		BitBlt(hdc, 0, 0, sizes[Frame].cx, sizes[Frame].cy, hdcTemp, 0, 0, SRCCOPY);

		// BUGBUG georgep: We should clean out the "uncovered" area here

		UINT cur = GetCurrentValue();
		UINT max = GetMaxValue();
		if (cur > max)
		{
			cur = max;
		}

		SelectObject(hdcTemp, GetBar());
		// Center the bitmap, but only display to the current percentage
		BitBlt(hdc, (sizes[Frame].cx-sizes[Bar].cx)/2, (sizes[Frame].cy-sizes[Bar].cy)/2,
			(sizes[Bar].cx*cur)/max, sizes[Bar].cy, hdcTemp, 0, 0, SRCCOPY);

		// This is where we should attempt to alpha blend the inner onto the
		// outer for a few pixels in either direction

		// Clean up
		DeleteDC(hdcTemp);

		if (NULL != hPal)
		{
			SelectPalette(hdc, hOld, TRUE);
		}
	}

	EndPaint(hwnd, &ps);
}

// Change the max value displayed by this progress bar
void CProgressBar::SetMaxValue(UINT maxVal)
{
	m_maxVal = maxVal;
	InvalidateRect(GetWindow(), NULL, FALSE);
}

// Change the current value displayed by this progress bar
void CProgressBar::SetCurrentValue(UINT curVal)
{
	m_curVal = curVal;
	InvalidateRect(GetWindow(), NULL, FALSE);
}





static const int DefWidth = 170;
static const int DefHeight = 23;

CProgressTrackbar::CProgressTrackbar() :
	m_nValChannel(0)
{
	m_desSize.cx = DefWidth;
	m_desSize.cy = DefHeight;
}

CProgressTrackbar::~CProgressTrackbar()
{
}

BOOL CProgressTrackbar::Create(
	HWND hWndParent,	// The parent of the toolbar window
	INT_PTR nId,			// The ID of the control
	IScrollChange *pNotify	// Object to notify of changes
	)
{
	if (!CFillWindow::Create(
		hWndParent,
		nId,
		"NMTrackbar",
		0,
		WS_EX_CONTROLPARENT
		))
	{
		return(FALSE);
	}

	// Create the Win32 button
	CreateWindowEx(0, TRACKBAR_CLASS, g_szEmpty,
		TBS_HORZ|TBS_NOTICKS|TBS_BOTH
		|WS_CLIPSIBLINGS|WS_TABSTOP|WS_VISIBLE|WS_CHILD,
		0, 0, 10, 10,
		GetWindow(), reinterpret_cast<HMENU>(nId), _Module.GetModuleInstance(), NULL);

	m_pNotify = pNotify;
	if (NULL != m_pNotify)
	{
		m_pNotify->AddRef();
	}

	return(TRUE);
}

void CProgressTrackbar::GetDesiredSize(SIZE *ppt)
{
	*ppt = m_desSize;
}

void CProgressTrackbar::SetDesiredSize(SIZE *psize)
{
	m_desSize = *psize;
	OnDesiredSizeChanged();
}

LRESULT CProgressTrackbar::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_NOTIFY        , OnNotify);
		HANDLE_MSG(hwnd, WM_HSCROLL       , OnScroll);
		HANDLE_MSG(hwnd, WM_VSCROLL       , OnScroll);
		HANDLE_MSG(hwnd, WM_CTLCOLORSTATIC, OnCtlColor);
		HANDLE_MSG(hwnd, WM_NCDESTROY     , OnNCDestroy);
	}

	return(CFillWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

HBRUSH CProgressTrackbar::OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
{
	return(GetBackgroundBrush());
}

LRESULT CProgressTrackbar::PaintChannel(LPNMCUSTOMDRAW pCustomDraw)
{
	static const int NUM_RECTANGLES_MAX = 16;
	static const int NUM_RECTANGLES_MIN = 6;
	static const int g_nAudMeterHeight = 7;

	static const int BorderWidth = 1;

	HDC hdc = pCustomDraw->hdc;
	BOOL bGotDC = FALSE;
	DWORD dwVolume = m_nValChannel;
	bool bTransmitting;

	bTransmitting = HIWORD(dwVolume) & SIGNAL_STATUS_TRANSMIT;
	dwVolume = LOWORD(dwVolume);

	if (!hdc)
	{
		hdc = GetDC(GetWindow());
		bGotDC = TRUE;
	}

	// rectangle leading is 1

	UINT max = GetMaxValue();
	if (dwVolume > max)
	{
		dwVolume = max;
	}

	RECT rect = pCustomDraw->rc;

	int nVuWidth = rect.right - rect.left - 2*BorderWidth;
	if (nVuWidth < (NUM_RECTANGLES_MIN*2))
		return(0);


	// "rect" represents the edges of the meter's outer rectangle

	// compute the number of individual rectangles to use
	// we do the computation this way so that sizing the rebar band
	// makes the size changes consistant
	int nRectsTotal;
	nRectsTotal = (nVuWidth + (g_nAudMeterHeight - 1)) / g_nAudMeterHeight;
	nRectsTotal = min(nRectsTotal, NUM_RECTANGLES_MAX);
	nRectsTotal = max(nRectsTotal, NUM_RECTANGLES_MIN);

	// nRectangleWidth - width of colored rectangle - no leading
	int nRectangleWidth = (nVuWidth/nRectsTotal) - 1;

	// nVuWidth - width of entire VU meter including edges
	nVuWidth = (nRectangleWidth + 1)*nRectsTotal;

	// re-adjust meter size to be an integral number of rects
	int nDiff = (rect.right - rect.left) - (nVuWidth + 2*BorderWidth);

	// Subtract 1 since there is no border on the last one
	rect.right = rect.left + nVuWidth + 2*BorderWidth - 1;

	// center vu-meter across whole channel area so that the
	// slider's thumb is always covering some portion of the channel
	rect.left += (nDiff/2);
	rect.right += (nDiff/2);

	// the background color may change on us!
	COLORREF GreyColor = GetSysColor(COLOR_3DFACE);
	static const COLORREF RedColor = RGB(255,0,0);
	static const COLORREF YellowColor = RGB(255,255,0);
	static const COLORREF GreenColor = RGB(0,255,0);

	COLORREF ShadowColor = GetSysColor(COLOR_3DSHADOW);
	COLORREF HiLiteColor = GetSysColor(COLOR_3DHIGHLIGHT);
	COLORREF LiteColor = GetSysColor(COLOR_3DLIGHT);
	COLORREF DkShadowColor = GetSysColor(COLOR_3DDKSHADOW);

	HBRUSH hGreyBrush = CreateSolidBrush(GreyColor);

	HPEN hShadowPen = CreatePen(PS_SOLID, 0, ShadowColor);

	HBRUSH hRedBrush = CreateSolidBrush (RedColor);
	HBRUSH hGreenBrush = CreateSolidBrush(GreenColor);
	HBRUSH hYellowBrush = CreateSolidBrush(YellowColor);

	RECT rectDraw = rect;

	// draw the 3D frame border
	// HACKHACK georgep: draw outside the rect they gave us
	++rect.bottom;
	DrawEdge(hdc, &rect, BDR_RAISEDINNER, BF_RECT);

	HPEN hOldPen = reinterpret_cast<HPEN>(SelectObject(hdc, hShadowPen));

	// the top and left of the meter has a 2 line border
	// the bottom and right of the meter has a 2 line border
	rectDraw.top    += 1;
	rectDraw.left   += 1;
	rectDraw.right  = rectDraw.left + nRectangleWidth;


	// how many colored rectangles do we draw ?
	int nRects = (dwVolume * nRectsTotal) / max;

	// not transmitting - don't show anything
	if ((false == bTransmitting))
		nRects = 0;

	// transmitting or receiving something very quiet - 
	// light up at least one rectangle
	else if ((bTransmitting) && (nRects == 0))
		nRects = 1;
	
	HBRUSH hCurrentBrush = hGreenBrush;

	POINT ptOld;
	MoveToEx(hdc, 0, 0, &ptOld);

	for (int nIndex = 0; nIndex < nRectsTotal; nIndex++)
	{
		// far left fourth of the bar is green
		// right fourth of the bar is red
		// middle is yellow
		if (nIndex > ((nRectsTotal*3)/4))
			hCurrentBrush = hRedBrush;
		else if (nIndex >= nRectsTotal/2)
			hCurrentBrush = hYellowBrush;

		if (nIndex >= nRects)
			hCurrentBrush = hGreyBrush;

		FillRect(hdc, &rectDraw, hCurrentBrush);

		if (nIndex != (nRectsTotal-1))
		{
			MoveToEx(hdc, rectDraw.left + nRectangleWidth, rectDraw.top, NULL);
			LineTo(hdc, rectDraw.left + nRectangleWidth, rectDraw.bottom);
		}

		rectDraw.left += nRectangleWidth + 1;  // +1 for the leading
		rectDraw.right = rectDraw.left + nRectangleWidth;
	}

	MoveToEx(hdc, ptOld.x, ptOld.y, NULL);
	SelectObject (hdc, hOldPen);

	if (bGotDC)
	{
		ReleaseDC(GetWindow(), hdc);
	}

	DeleteObject(hGreyBrush);

	DeleteObject(hShadowPen);

	DeleteObject(hRedBrush);
	DeleteObject(hGreenBrush);
	DeleteObject(hYellowBrush);

	return(CDRF_SKIPDEFAULT);
}

LRESULT CProgressTrackbar::PaintThumb(LPNMCUSTOMDRAW pCustomDraw)
{
	return(0);

#if FALSE // {
	HBITMAP hbThumb = GetThumb();
	ASSERT(NULL != hbThumb);

	// Draw in the upper left
	HDC hdcDraw = pCustomDraw->hdc;
	HDC hdcTemp = CreateCompatibleDC(hdcDraw);

	if (NULL != hdcTemp)
	{
		HPALETTE hPal = GetPalette();
		HPALETTE hOld = NULL;
		if (NULL != hPal)
		{
			hOld = SelectPalette(hdcDraw, hPal, TRUE);
			RealizePalette(hdcDraw);
			SelectPalette(hdcTemp, hPal, TRUE);
			RealizePalette(hdcTemp);
		}

		SIZE sizeBitmap[NumBitmaps];
		CBitmapButton::GetBitmapSizes(m_hbs, sizeBitmap, NumBitmaps);

		HBITMAP hbThumb = GetThumb();
		if (NULL != SelectObject(hdcTemp, hbThumb))
		{
			RECT rc = pCustomDraw->rc;

			StretchBlt(hdcDraw,
				rc.left, rc.top,
				rc.right-rc.left, rc.bottom-rc.top,
				hdcTemp,
				0, 0, sizeBitmap[Thumb].cx, sizeBitmap[Thumb].cy,
				SRCCOPY);

			// BUGBUG georgep: We should clear any "uncovered" area here
		}

		DeleteDC(hdcTemp);

		if (NULL != hPal)
		{
			SelectPalette(hdcDraw, hOld, TRUE);
		}
	}

	return(CDRF_SKIPDEFAULT);
#endif // FALSE }
}

LRESULT CProgressTrackbar::OnNotify(HWND hwnd, int id, NMHDR *pHdr)
{
	if (NM_CUSTOMDRAW != pHdr->code)
	{
		return(FORWARD_WM_NOTIFY(hwnd, id, pHdr, CGenWindow::ProcessMessage));
	}

	LPNMCUSTOMDRAW pCustomDraw = reinterpret_cast<LPNMCUSTOMDRAW>(pHdr);

	switch (pCustomDraw->dwDrawStage)
	{
		case CDDS_PREPAINT:
			return(CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT);
			break;

		case CDDS_ITEMPREPAINT:
			switch (pCustomDraw->dwItemSpec)
			{
			case TBCD_CHANNEL:
				return(PaintChannel(pCustomDraw));

			case TBCD_THUMB:
				return(PaintThumb(pCustomDraw));
			}

		default:
			break;

	}

	return(FORWARD_WM_NOTIFY(hwnd, id, pHdr, CGenWindow::ProcessMessage));
}

void CProgressTrackbar::OnScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
{
	if (NULL != m_pNotify)
	{
		m_pNotify->OnScroll(this, code, pos);
		return;
	}

	// Translate the hwndCtl and let the parent handle the message
	FORWARD_WM_HSCROLL(GetParent(hwnd), GetWindow(), code, pos, SendMessage);
}

void CProgressTrackbar::OnNCDestroy(HWND hwnd)
{
	if (NULL != m_pNotify)
	{
		m_pNotify->Release();
		m_pNotify = NULL;
	}

	FORWARD_WM_NCDESTROY(hwnd, CFillWindow::ProcessMessage);
}

// Change the max value displayed by this progress bar
void CProgressTrackbar::SetMaxValue(UINT maxVal)
{
	HWND hwnd = GetChild();

	::SendMessage(	hwnd,
					TBM_SETRANGE,
					FALSE,
					MAKELONG(0, maxVal));
}

// Return the max value displayed by this progress bar
UINT CProgressTrackbar::GetMaxValue()
{
	HWND hwnd = GetChild();

	return(static_cast<UINT>(::SendMessage(	hwnd,
					TBM_GETRANGEMAX,
					0,
					0)));
}

// Change the current value displayed by this progress bar
void CProgressTrackbar::SetTrackValue(UINT curVal)
{
	HWND hwnd = GetChild();

	::SendMessage(	hwnd,
					TBM_SETPOS,
					TRUE,
					curVal);
}


// Return the current value displayed by this progress bar
UINT CProgressTrackbar::GetTrackValue()
{
	HWND hwnd = GetChild();

	return(static_cast<UINT>(::SendMessage(	hwnd,
					TBM_GETPOS,
					0,
					0)));
}

// Change the current value displayed by this progress bar
void CProgressTrackbar::SetProgressValue(UINT curVal)
{
	if (curVal != m_nValChannel)
	{
		m_nValChannel = curVal;
		SchedulePaint();
	}
}


// Return the current value displayed by this progress bar
UINT CProgressTrackbar::GetProgressValue()
{
	return(m_nValChannel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\precomp.h ===
// File: precomp.h


// Windows SDK Preprocessor macros
#define OEMRESOURCE

// Standard Windows SDK includes
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <shellapi.h>
#include <winsock.h>
#include <commdlg.h>
#include <cderr.h>
#include <winldap.h>
#include <wincrypt.h>
#include <time.h>
#include <strutil.h>


// ATL preprocessor macros

// If _ATL_NO_FORCE_LIBS is not present, ATL will force inclusion of
// several lib files via #pragma comment( lib, XXX )... this is here to
// save us from confusion in the future...
#define _ATL_NO_FORCE_LIBS

// We should really only put this in for w2k
#define _ATL_NO_DEBUG_CRT


// This makes the ATL Host window use a NoLock creator class, so we don't
// Lock the local server. We have to make sure to close ATL host windows before
// We exit, though!
#define _ATL_HOST_NOLOCK

#if 1
	#define ATL_TRACE_LEVEL 0
#else
	#define ATL_TRACE_LEVEL 4
	#define _ATL_DEBUG_INTERFACES
	#define _ATL_DEBUG_QI
#endif

#define _ATL_APARTMENT_THREADED

// This overrides ATLTRACE and ATLTRACE2 to use our debugging libraries and output stuff.
#include <ConfDbg.h>

// We should really only put this in for w2k
#define _ASSERTE(expr) ASSERT(expr)

#include "ConfAtlTrace.h"

// ATL includes
#include <atlbase.h>
// #include <winres.h>
#ifdef SubclassWindow
        // SubclassWindow definition from windowsx.h screws up ATL's CContainedWindow::SubclassWindow
        // as well as CWindowImplBase::SubclassWindow in atlwin.h
    #undef SubclassWindow
#endif

#include <atlconv.h>
#include <atlbase.h>
#include "AtlExeModule.h"
#include <atlcom.h>
#include <atlctl.h>
#include <atlwin.h>
#include <atlhost.h>

// Standard NetMeeting includes
#include <NmStd.h>
#include <standrd.h>
#include <ping.h>
#include <capflags.h>
#include <debspew.h>
#include <RegEntry.h>
#include <ConfReg.h>
#include <oprahcom.h>
#include <dllutil.h>
#include <nmhelp.h>

// Global Object definitions
#include "refcount.h"

// Global NetMeeting UI defintions
#include "global.h"
#include "strings.h"
#include "syspol.h"

#include <ConfEvt.h>
#include <mtgset.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\popupmsg.h ===
/****************************************************************************
*
*    FILE:     PopupMsg.h
*
*    CREATED:  Chris Pirich (ChrisPi) 1-3-96
*
****************************************************************************/

#ifndef _POPUPMSG_H_
#define _POPUPMSG_H_

const DWORD PMF_OK =				0x00000001;
const DWORD PMF_CANCEL =			0x00000002;
const DWORD PMF_TIMEOUT =			0x00000004;
const DWORD PMF_AUTH =				0x00000008;
const DWORD PMF_KILLED =			0x00000010;

typedef VOID (CALLBACK* PMCALLBACKPROC)(LPVOID, DWORD);
const int POPUPMSG_MAX_SOUNDNAME =	64;
const int POPUPMSG_TIMEOUT =		20000;	// 20 seconds
const int POPUPMSG_RING_INTERVAL =	4000;	// 4 seconds
const int POPUPMSG_ICON_HEIGHT =	16;
const int POPUPMSG_ICON_WIDTH =		16;
const int POPUPMSG_RING_TIMER =		1001;
const int POPUPMSG_MAX_LENGTH =		256;

class CPopupMsg
{
private:
	static UINT		m_uVisiblePixels;
	static CSimpleArray<CPopupMsg*>*	m_splstPopupMsgs;
	BOOL			m_fAutoSize;
	HICON			m_hIcon;
	HINSTANCE		m_hInstance;
	PMCALLBACKPROC	m_pCallbackProc;
	LPVOID			m_pContext;
	BOOL			m_fRing;
	BOOL			m_fPlaySound;
	TCHAR			m_szSound[POPUPMSG_MAX_SOUNDNAME];
	
	UINT			m_uTimeout;
	int				m_nWidth;
	int				m_nHeight;
	int				m_nTextWidth;

	BOOL			GetIdealPosition(LPPOINT ppt, int xCoord, int yCoord);
	VOID			PlaySound();

public:
	HWND			m_hwnd;

	// Methods:
					CPopupMsg(PMCALLBACKPROC pcp, LPVOID pContext=NULL);
					~CPopupMsg();
	BOOL			Change(LPCTSTR pcszText);
	HWND			Create(	LPCTSTR pcszText,
							BOOL fRing=FALSE,
							LPCTSTR pcszIconName=NULL,
							HINSTANCE hInstance=NULL,
							UINT uIDSoundEvent=0,
							UINT uTimeout=POPUPMSG_TIMEOUT,
							int xPos = -1,
							int yPos = -1);
	HWND			CreateDlg(	LPCTSTR pcszText,
								BOOL fRing=FALSE,
								LPCTSTR pcszIconName=NULL,
								HINSTANCE hInstance=NULL,
								UINT uIDSoundEvent=0,
								UINT uTimeout=POPUPMSG_TIMEOUT,
								int xPos = -1,
								int yPos = -1);

	static VOID		ExpandSecureDialog(HWND hDlg,CPopupMsg * ppm);
	static VOID		ShrinkSecureDialog(HWND hDlg);

	static BOOL		Init();
	static VOID		Cleanup();
	static LRESULT CALLBACK	PMWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK	PMDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK	SecurePMDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
};

#endif // ! _POPUPMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\progressbar.h ===
// File: Progressbar.h

#ifndef _PROGRESSBAR_H_
#define _PROGRESSBAR_H_

#include "GenWindow.h"
#include "GenContainers.h"

// A progress window class. This uses an outer and inner bitmap to show the progress
class // DECLSPEC_UUID("")
CProgressBar : public CGenWindow
{
public:
	// Default constructor; inits a few intrinsics
	CProgressBar();

	// Create the toolbar window; this object now owns the bitmaps passed in
	BOOL Create(
		HBITMAP hbOuter,	// The outside (static) part of the progress bar
		HBITMAP hbInner,	// The inside part of the progress bar that jumps around
		HWND hWndParent		// The parent of the toolbar window
		);

#if FALSE
	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CProgressBar) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CGenWindow::QueryInterface(riid, ppv));
	}
#endif // FALSE

	virtual void GetDesiredSize(SIZE *ppt);

	// Change the max value displayed by this progress bar
	void SetMaxValue(UINT maxVal);

	// Return the max value displayed by this progress bar
	UINT GetMaxValue() { return(m_maxVal); }

	// Change the current value displayed by this progress bar
	void SetCurrentValue(UINT curVal);

	// Return the current value displayed by this progress bar
	UINT GetCurrentValue() { return(m_curVal); }

protected:
	virtual ~CProgressBar();

	// Forward WM_COMMAND messages to the parent window
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	enum BitmapParts
	{
		Frame,	// The bitmap that displays the control when at 0%
		Bar,	// The bitmap that gets blasted onto the outer bitmap up to the desired percentage
		NumBitmaps
	} ;

	// The bitmaps that make up the progress bar
	HBITMAP m_hbs[NumBitmaps];
	// The max progress value
	UINT m_maxVal;
	// The current progress value
	UINT m_curVal;

	// Get/set the outer bitmap
	void SetFrame(HBITMAP hbFrame) { m_hbs[Frame] = hbFrame; }
	HBITMAP GetFrame() { return(m_hbs[Frame]); }

	// Get/set the inner bitmap
	void SetBar(HBITMAP hbBar) { m_hbs[Bar] = hbBar; }
	HBITMAP GetBar() { return(m_hbs[Bar]); }

	// Specialized painting function
	void OnPaint(HWND hwnd);
} ;

class CProgressTrackbar;

interface IScrollChange : IUnknown
{
	virtual void OnScroll(CProgressTrackbar *pTrackbar, UINT code, int pos) = 0;
} ;

// A progress window class. This uses an outer and inner bitmap to show the progress
class // DECLSPEC_UUID("")
CProgressTrackbar : public CFillWindow
{
public:
	// Default constructor; inits a few intrinsics
	CProgressTrackbar();

	// Create the toolbar window; this object now owns the bitmaps passed in
	BOOL Create(
		HWND hWndParent,	// The parent of the toolbar window
		INT_PTR nId=0,			// The ID of the control
		IScrollChange *pNotify=NULL	// Object to notify of changes
		);

#if FALSE
	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CProgressTrackbar) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CGenWindow::QueryInterface(riid, ppv));
	}
#endif // FALSE

	virtual void GetDesiredSize(SIZE *ppt);

	// Sets the desired size for this control
	void SetDesiredSize(SIZE *psize);

	// Change the max value displayed by this progress bar
	void SetMaxValue(UINT maxVal);

	// Return the max value displayed by this progress bar
	UINT GetMaxValue();

	// Change the current position of the thumb
	void SetTrackValue(UINT curVal);

	// Return the current position of the thumb
	UINT GetTrackValue();

	// Change the current value displayed by the channel
	void SetProgressValue(UINT curVal);

	// Return the current value displayed by the channel
	UINT GetProgressValue();

protected:
	virtual ~CProgressTrackbar();

	// Forward WM_COMMAND messages to the parent window
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	void SchedulePaint()
	{
		// HACK: SETRANGEMAX is the only way to force the slider to update itself...
		SendMessage(GetChild(), TBM_SETRANGEMAX, TRUE, GetMaxValue());
	}

private:
	// The desired size for the control; defaults to (170,23)
	SIZE m_desSize;
	// The current channel value
	UINT m_nValChannel;
	// The object ot notify of changes
	IScrollChange *m_pNotify;

	// Notify handler for custom draw
	LRESULT OnNotify(HWND hwnd, int id, NMHDR *pHdr);
	// Send scroll messages to the parent
	void OnScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos);
	// Set the correct background color
	HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type);
	// Free the listener
	void OnNCDestroy(HWND hwnd);

	// Paint the parts of the slider
	LRESULT PaintChannel(LPNMCUSTOMDRAW pCustomDraw);
	LRESULT PaintThumb(LPNMCUSTOMDRAW pCustomDraw);
} ;

#endif // _PROGRESSBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\redial.cpp ===
// File: redial.cpp

#include <precomp.h>
#include "resource.h"

// from confroom.cpp
VOID PlaceCall(LPCTSTR pcszName, LPCTSTR pcszAddress, NM_ADDR_TYPE addrType);


/*  B U I L D  R E D I A L  L I S T  M E N U  */
/*-------------------------------------------------------------------------
    %%Function: BuildRedialListMenu
    
-------------------------------------------------------------------------*/
BOOL BuildRedialListMenu(HMENU hPopupMenu, RegEntry * pRe)
{
	ASSERT(NULL != hPopupMenu);

	MENUITEMINFO mmi;
	InitStruct(&mmi);
	mmi.fMask = MIIM_STATE | MIIM_ID | MIIM_TYPE;
	mmi.wID = ID_FIRST_REDIAL_ITEM;
	mmi.fType = MFT_STRING;

	int cItem = pRe->GetNumber(REGVAL_MRU_COUNT, 0);
	if (0 == cItem)
	{
		// Insert a "stub" item
		TCHAR szMenuText[MAX_PATH];
		if (FLoadString(IDS_REDIAL_EMPTY, szMenuText, CCHMAX(szMenuText)))
		{
			mmi.fState = MFS_DISABLED;
			mmi.dwTypeData = szMenuText;
			mmi.cch = lstrlen(mmi.dwTypeData);
			InsertMenuItem(hPopupMenu, 0, TRUE, &mmi);;
		}
	}
	else
	{
		mmi.fState = MFS_ENABLED;

		for (int iItem = 0; iItem < cItem; iItem++)
		{
			TCHAR szKey[MAX_PATH];
			wsprintf(szKey, TEXT("%s%d"), REGVAL_NAME_MRU_PREFIX, iItem);
			mmi.dwTypeData = (LPTSTR) pRe->GetString(szKey);
			mmi.cch = lstrlen(mmi.dwTypeData);
			InsertMenuItem(hPopupMenu, iItem, TRUE, &mmi);;
			mmi.wID++;
		}
	}

	return TRUE;
}


/*  D I S P L A Y  R E D I A L  L I S T  P O P U P  */
/*-------------------------------------------------------------------------
    %%Function: DisplayRedialListPopup
    
-------------------------------------------------------------------------*/
int DisplayRedialListPopup(HMENU hPopupMenu, RECT const *rc)
{
	TPMPARAMS tpm;
	tpm.cbSize = sizeof(tpm);

	tpm.rcExclude = *rc;

	// Popup the menu (making sure it doesn't cover the button)
	int id = ::TrackPopupMenuEx(hPopupMenu,
				TPM_VERTICAL | TPM_TOPALIGN | TPM_RETURNCMD,
				tpm.rcExclude.left, tpm.rcExclude.bottom,
				::GetMainWindow(), &tpm);
	return (0 == id) ? -1 :  id -= ID_FIRST_REDIAL_ITEM;
}



/*  D O  T B  R E D I A L  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: DoTbRedialList
    
-------------------------------------------------------------------------*/
VOID DoTbRedialList(HWND hwndRedial, RECT const *prcExclude)
{
	RECT rcExclude;

	ASSERT(NULL != hwndRedial);

	if (NULL == prcExclude)
	{
		GetClientRect(hwndRedial, &rcExclude);
	}
	else
	{
		rcExclude = *prcExclude;
	}
	::MapWindowPoints(hwndRedial, NULL, (LPPOINT)&rcExclude, 2);

	HMENU hPopupMenu = CreatePopupMenu();
	if (NULL == hPopupMenu)
		return;

	RegEntry re(DLGCALL_MRU_KEY, HKEY_CURRENT_USER);

	if (BuildRedialListMenu(hPopupMenu, &re))
	{
		int iItem = DisplayRedialListPopup(hPopupMenu, &rcExclude);
		if (-1 != iItem)
		{
			TCHAR szKey[MAX_PATH];
			wsprintf(szKey, TEXT("%s%d"), REGVAL_DLGCALL_ADDR_MRU_PREFIX, iItem);

			TCHAR szAddress[CCHMAXSZ_ADDRESS];
			lstrcpyn(szAddress, re.GetString(szKey), CCHMAX(szAddress));
			if (!FEmptySz(szAddress))
			{
				wsprintf(szKey, TEXT("%s%d"), REGVAL_DLGCALL_TYPE_MRU_PREFIX, iItem);
				NM_ADDR_TYPE addrType = (NM_ADDR_TYPE) re.GetNumber(szKey);

				wsprintf(szKey, TEXT("%s%d"), REGVAL_DLGCALL_NAME_MRU_PREFIX, iItem);
				PlaceCall(re.GetString(szKey), szAddress, addrType);
			}
		}
	}
	::DestroyMenu(hPopupMenu);
}


VOID DoTbRedialList(HWND hwndToolbar, UINT uCmd)
{
	RECT rcShow;

	// Determine which toolbar button was pressed:
	int nIndex = SendMessage(hwndToolbar, TB_COMMANDTOINDEX, uCmd, 0);
	// Get it's position
	::SendMessage(hwndToolbar, TB_GETITEMRECT, nIndex, (LPARAM) &rcShow);
	DoTbRedialList(hwndToolbar, &rcShow);
}



/*  G E T  R E D I A L  H E L P  T E X T  */
/*-------------------------------------------------------------------------
    %%Function: GetRedialHelpText
    
-------------------------------------------------------------------------*/
VOID GetRedialHelpText(LPTSTR psz, int cchMax, int id)
{
	TCHAR szKey[MAX_PATH];
	TCHAR szName[CCHMAXSZ_NAME];
	TCHAR szAddress[CCHMAXSZ_ADDRESS];
	TCHAR szUsing[MAX_PATH];
	TCHAR szFormat[MAX_PATH];

	SetEmptySz(psz);

	RegEntry re(DLGCALL_MRU_KEY, HKEY_CURRENT_USER);
	wsprintf(szKey, TEXT("%s%d"), REGVAL_DLGCALL_NAME_MRU_PREFIX, id);
	lstrcpyn(szName, re.GetString(szKey), CCHMAX(szName));
	if (FEmptySz(szName))
		return;

	if (!FLoadString(IDS_REDIAL_FORMAT, szFormat, CCHMAX(szFormat)))
		return;

	wsprintf(szKey, TEXT("%s%d"), REGVAL_DLGCALL_TYPE_MRU_PREFIX, id);
	int idsUsing;
	switch (re.GetNumber(szKey))
		{
	case NM_ADDR_IP:
	case NM_ADDR_MACHINENAME:
		idsUsing = IDS_CALLUSING_IP;
		break;
	case NM_ADDR_H323_GATEWAY:
		idsUsing = IDS_CALLUSING_PHONE;
		break;
	case NM_ADDR_ULS:
		idsUsing = IDS_CALLUSING_ILS;
		break;
	case NM_ADDR_ALIAS_ID:
	case NM_ADDR_ALIAS_E164:
		idsUsing = IDS_CALLUSING_GK;
		break;
	default:
		idsUsing = 0;
		break;
		}

	if (0 == idsUsing)
	{
		SetEmptySz(szUsing);
	}
	else if (!FLoadString(idsUsing, szUsing, CCHMAX(szUsing)))
	{
		return;
	}
	
	wsprintf(szKey, TEXT("%s%d"), REGVAL_DLGCALL_ADDR_MRU_PREFIX, id);
	lstrcpyn(szAddress, re.GetString(szKey), CCHMAX(szAddress));

	if ((lstrlen(szAddress) + lstrlen(szFormat) + lstrlen(szUsing) + lstrlen(szName)) > cchMax)
	{
		// Just display the address if it won't fit
		lstrcpyn(psz, szAddress, cchMax);
		return;
	}

	wsprintf(psz, szFormat, szName, szUsing, szAddress);
	ASSERT(lstrlen(psz) < cchMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\rdswiz.cpp ===
// File: rdswiz.cpp

#include "precomp.h"
#include "confcpl.h"
#include "conf.h"
#include "nmremote.h"

#define NUM_RDSPAGES 4

VOID EnableRDS(BOOL fEnabledRDS);
INT_PTR CALLBACK RemotePasswordDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
extern int MessageBoxResource(HWND hwnd, UINT uMessage, UINT uTitle, UINT uFlags);

INT_PTR CALLBACK RDSWizard0Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK RDSWizard1Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK RDSWizard2Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK RDSWizard3Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

typedef struct _RDSWIZINFO
{
    BOOL fEnabledRDS;
    PBYTE pbHashedPassword;
    DWORD cbHashedPassword;
    CHash* pHash;
} RDSWIZINFO, *PRDSWIZINFO;

BOOL IntCreateRDSWizard(HWND hwndOwner)
{
    UINT uNumPages = 0;
    LPPROPSHEETPAGE ppsp = new PROPSHEETPAGE[NUM_RDSPAGES];
    if (NULL == ppsp)
    {
        ERROR_OUT(("IntCreateRDSWizard: fail to allocate memory"));
        return FALSE;
    }
    CHash hashObject;
    RDSWIZINFO rdsconfig = { FALSE, NULL, 0, &hashObject };

    FillInPropertyPage(&ppsp[uNumPages++], IDD_RDSWIZ_INTRO, RDSWizard0Proc, (LPARAM) &rdsconfig);
    FillInPropertyPage(&ppsp[uNumPages++], IDD_RDSWIZ_NTPASSWORDS , RDSWizard1Proc, (LPARAM) &rdsconfig);
    FillInPropertyPage(&ppsp[uNumPages++], IDD_RDSWIZ_SCRNSVR, RDSWizard2Proc, (LPARAM) &rdsconfig);
    FillInPropertyPage(&ppsp[uNumPages++], IDD_RDSWIZ_CONGRATS, RDSWizard3Proc, (LPARAM) &rdsconfig);

    PROPSHEETHEADER psh;
    InitStruct(&psh);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.nPages = uNumPages;
    psh.ppsp = ppsp;

    INT_PTR iRet = PropertySheet(&psh);
    if (-1 == iRet)
    {
        ERROR_OUT(("IntCreateRDSWizard: fail to create PropertySheet"));
        return FALSE;
    }

    delete []ppsp;
    return TRUE;
}

INT_PTR CALLBACK RDSWizard0Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    static PRDSWIZINFO prds;
    switch(iMsg)
    {
        case WM_INITDIALOG:
        {
            prds = (PRDSWIZINFO ) ((PROPSHEETPAGE *)lParam)->lParam;
            ASSERT(prds);
            return TRUE;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                    break;
                }
                case PSN_WIZNEXT:
                {
                    prds->fEnabledRDS = TRUE;
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
    }
    return FALSE;
}

const int MAXPASSWORDLENGTH = 36;
const int MINPASSWORDLENGTH = 7;

INT_PTR CALLBACK RDSWizard1Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hOldPasswordText, hNewPasswordText, hVerificationText;
    int nOldPasswordLength, nNewPasswordLength, nVerificationLength;
    CHAR lpOldPassword[MAXPASSWORDLENGTH], lpNewPassword[MAXPASSWORDLENGTH], lpVerification[MAXPASSWORDLENGTH];
    WCHAR lpwszOldPassword[MAXPASSWORDLENGTH], lpwszNewPassword[MAXPASSWORDLENGTH];
    PBYTE pbRegPassword;
    DWORD cbRegPassword;

    static PRDSWIZINFO prds;
    switch(iMsg)
    {
        case WM_INITDIALOG:
        {
            prds = (PRDSWIZINFO )((PROPSHEETPAGE*)lParam)->lParam;
            if (!::IsWindowsNT())
            {
                ASSERT(prds->pHash);
                RegEntry reLM(REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
                cbRegPassword = reLM.GetBinary(REMOTE_REG_PASSWORD, (void **)&pbRegPassword);

                if (0 == cbRegPassword)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_RDSPASSWORDO), FALSE);
                    SetFocus(GetDlgItem(hDlg, IDC_EDIT_RDSPASSWORD));
                }
                SendDlgItemMessage(hDlg, IDC_EDIT_RDSPASSWORDO, EM_LIMITTEXT,MAXPASSWORDLENGTH - 1, 0);
                SendDlgItemMessage(hDlg, IDC_EDIT_RDSPASSWORD, EM_LIMITTEXT,MAXPASSWORDLENGTH - 1, 0);
                SendDlgItemMessage(hDlg, IDC_EDIT_RDSPASSWORDV, EM_LIMITTEXT,MAXPASSWORDLENGTH - 1, 0);
            }
            return TRUE;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    break;
                }
                case PSN_WIZNEXT:
                {
                    if (!::IsWindowsNT())
                    {
                        PBYTE pbHashedPassword = NULL;
                        DWORD cbHashedPassword = 0;

                        RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);

                        hOldPasswordText = GetDlgItem(hDlg, IDC_EDIT_RDSPASSWORDO);
                        hNewPasswordText = GetDlgItem(hDlg, IDC_EDIT_RDSPASSWORD);
                        hVerificationText = GetDlgItem(hDlg, IDC_EDIT_RDSPASSWORDV);

                        nOldPasswordLength = GetWindowText(hOldPasswordText,lpOldPassword,MAXPASSWORDLENGTH);
                        MultiByteToWideChar(CP_ACP, 0, lpOldPassword, -1, lpwszOldPassword, MAXPASSWORDLENGTH);
            cbRegPassword = reLM.GetBinary(REMOTE_REG_PASSWORD, (void **)&pbRegPassword);
            cbHashedPassword = prds->pHash->GetHashedData((LPBYTE)lpwszOldPassword,
                                                                    sizeof(WCHAR)*strlen(lpOldPassword),
                                                                    (void **)&pbHashedPassword);

            if (0 != cbRegPassword && !(cbHashedPassword == cbRegPassword && 0 == memcmp(pbHashedPassword,pbRegPassword,cbHashedPassword)))
                        {
                            // Error Case - Old password incorrect.
                            MessageBoxResource(hDlg,IDS_REMOTE_OLD_PASSWORD_WRONG_TEXT,IDS_REMOTE_OLD_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
                            SetWindowText(hOldPasswordText,NULL);
                            SetWindowText(hNewPasswordText,NULL);
                            SetWindowText(hVerificationText,NULL);
                            SetFocus(hOldPasswordText);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
            }
                        nNewPasswordLength = GetWindowText(hNewPasswordText,lpNewPassword,MAXPASSWORDLENGTH);
                        nVerificationLength = GetWindowText(hVerificationText,lpVerification,MAXPASSWORDLENGTH);

                        if (0 != lstrcmp(lpNewPassword, lpVerification))
                        {
                            MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_WRONG_TEXT,IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
                            SetWindowText(hNewPasswordText,NULL);
                            SetWindowText(hVerificationText,NULL);
                            SetFocus(hNewPasswordText);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }
                        if (nNewPasswordLength < MINPASSWORDLENGTH)
                        {
                            MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_LENGTH_TEXT,IDS_REMOTE_NEW_PASSWORD_LENGTH_TITLE,MB_OK | MB_ICONERROR);
                            SetWindowText(hNewPasswordText,NULL);
                            SetWindowText(hVerificationText,NULL);
                            SetFocus(hNewPasswordText);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }
                        if (!lstrlen(lpVerification)) {
                            // Don't allow empty password
                            MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_EMPTY,IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
                            SetWindowText(hNewPasswordText,NULL);
                            SetWindowText(hVerificationText,NULL);
                            SetFocus(hNewPasswordText);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }
                        if (!FAnsiSz(lpNewPassword)) {
                            // Error Case - T.120 can't handle UNICODE passwords
                            MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_INVALID_TEXT,IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
                            SetWindowText(hNewPasswordText,NULL);
                            SetWindowText(hVerificationText,NULL);
                            SetFocus(hNewPasswordText);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }
                        MultiByteToWideChar(CP_ACP, 0, lpNewPassword, -1, lpwszNewPassword, MAXPASSWORDLENGTH);
                        prds->cbHashedPassword = prds->pHash->GetHashedData((LPBYTE)lpwszNewPassword, sizeof(WCHAR)*lstrlen(lpNewPassword), (void **)&prds->pbHashedPassword);

                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
                    }
                    break;
                }

                default:
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
                    break;
                }
            }
            return TRUE;
        }
    }
    return FALSE;
}

INT_PTR CALLBACK RDSWizard2Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    static PRDSWIZINFO prds;

    switch(iMsg)
    {
        case WM_INITDIALOG:
        {
            prds = (PRDSWIZINFO )((PROPSHEETPAGE*)lParam)->lParam;
            SendDlgItemMessage(hDlg, IDC_SCRSAVER_NOW, BM_SETCHECK, 1, 0);
            return TRUE;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    break;
                }

                case PSN_WIZNEXT:
                {
                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_SCRSAVER_NOW))
                    {
        			STARTUPINFO sSI;
        			PROCESS_INFORMATION sPI;

        			ZeroMemory (&sSI, sizeof(sSI));
        			sSI.cb = sizeof(sSI);

                            TCHAR szWindir[MAX_PATH];

                            if (GetSystemDirectory(szWindir, sizeof(szWindir)/sizeof(szWindir[0])))
                            {
                                TCHAR szCmdLine[MAX_PATH * 2];
                                PROCESS_INFORMATION pi = {0};
                                STARTUPINFO si = {0};

                                si.cb = sizeof(si);
                                
                                wsprintf(szCmdLine, "\"%s\\Rundll32.exe\" shell32.dll,Control_RunDLL desk.cpl,,1", szWindir);

                                if (CreateProcess(NULL,
                                                  szCmdLine,
                                                  NULL,
                                                  NULL,
                                                  TRUE, // we want the watcher to inherit hProcess, so we must set bInheritHandles = TRUE
                                                  0,
                                                  NULL,
                                                  NULL,
                                                  &si,
                                                  &pi))
                                {
                                    CloseHandle(pi.hThread);
                                    CloseHandle(pi.hProcess);
                                }
                            }

                    }
                    break;
                }
            }
            break;
        }
    }
    return FALSE;
}

INT_PTR CALLBACK RDSWizard3Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    static PRDSWIZINFO prds;
    switch(iMsg)
    {
        case WM_INITDIALOG:
        {
            prds = (PRDSWIZINFO ) ((PROPSHEETPAGE*)lParam)->lParam;
            PropSheet_SetWizButtons(hDlg, PSWIZB_FINISH);
            return TRUE;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
                    break;
                }
                case PSN_WIZFINISH:
                {
                    ASSERT(prds->fEnabledRDS);
                    EnableRDS(prds->fEnabledRDS);
                    if (!::IsWindowsNT())
                    {
                        ASSERT(prds->pbHashedPassword);
                        ASSERT(prds->cbHashedPassword);
                        RegEntry reLM(REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
                        reLM.SetValue(REMOTE_REG_PASSWORD,prds->pbHashedPassword,prds->cbHashedPassword);
                    }
                    break;
                }
            }
            break;
        }
    }
    return FALSE;
}

INT_PTR CALLBACK RDSSettingDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch(iMsg)
    {
        case WM_INITDIALOG:
        {
            if (::IsWindowsNT())
            {
                ShowWindow(GetDlgItem(hDlg, IDC_RDS_PASSWORD), SW_HIDE);
            }

            RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
            if (reLM.GetNumber(REMOTE_REG_RUNSERVICE, DEFAULT_REMOTE_RUNSERVICE))
            {
                SendDlgItemMessage(hDlg, IDC_RDS_RUNRDS, BM_SETCHECK, 1, 0);
            }

            return TRUE;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    EnableRDS(BST_CHECKED==IsDlgButtonChecked(hDlg, IDC_RDS_RUNRDS));
                    EndDialog(hDlg, 1);
                    break;
                }

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    break;

                case IDC_RDS_PASSWORD:
                    DialogBox(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_REMOTE_PASSWORD), hDlg, RemotePasswordDlgProc);
                    break;

                case IDC_BUTTON_RDSWIZ:
                {
                    IntCreateRDSWizard(hDlg);
                    RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
                    SendDlgItemMessage(hDlg, IDC_RDS_RUNRDS, BM_SETCHECK, reLM.GetNumber(REMOTE_REG_RUNSERVICE, DEFAULT_REMOTE_RUNSERVICE) ? 1 : 0, 0);
                    break;
                }
                default:
                    break;
            }
            break;
        }
        default:
            break;
    }
    return FALSE;
}

VOID EnableRDS(BOOL fEnabledRDS)
{
    //
    // Can RDS be touched?  Check policies and app sharing state.
    //
    if (ConfPolicies::IsRDSDisabled())
        return;

    if (::IsWindowsNT())
    {
        if (!g_fNTDisplayDriverEnabled)
            return;
    }

    {
        RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
        reLM.SetValue(REMOTE_REG_RUNSERVICE, fEnabledRDS ? 1 : 0);
        reLM.SetValue(REMOTE_REG_ACTIVATESERVICE, (ULONG)0);
        if (::IsWindowsNT())
        {
            SC_HANDLE hSCManager = NULL;
            SC_HANDLE hRemoteControl = NULL;
            SERVICE_STATUS serviceStatus;

            hSCManager = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
            hRemoteControl = OpenService(hSCManager,REMOTE_CONTROL_NAME,SERVICE_ALL_ACCESS);

            if (hSCManager)
            {
                if (hRemoteControl)
                {
                    ChangeServiceConfig(hRemoteControl,
                                        SERVICE_NO_CHANGE,
                                        fEnabledRDS ? SERVICE_AUTO_START : SERVICE_DEMAND_START,
                                        SERVICE_NO_CHANGE,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);
                    BOOL fSuccess = QueryServiceStatus(hRemoteControl, &serviceStatus);
                    if (fEnabledRDS)
                    {
                        if (fSuccess && SERVICE_STOPPED == serviceStatus.dwCurrentState)
                            StartService(hRemoteControl,0,NULL);
                    }
                    else
                    {
                        if (fSuccess && SERVICE_PAUSED == serviceStatus.dwCurrentState)
                        {
                            if (!ControlService(hRemoteControl,
                                    SERVICE_CONTROL_STOP, &serviceStatus))
                            {
                                WARNING_OUT(("EnableRDS: ControlService failed %d (%x)",
                                    GetLastError(), GetLastError() ));
                            }
                        }
                    }
                    CloseServiceHandle(hRemoteControl);
                }
                else
                {
                    WARNING_OUT(("EnableRDS: OpenService failed %x", GetLastError() ));
                }
                CloseServiceHandle(hSCManager);
            }
            else
            {
                ERROR_OUT(("EnableRDS: OpenSCManager failed: %x", GetLastError() ));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\refcount.cpp ===
// File: refcount.cpp
//
// RefCount class

#include "precomp.h"
#include "ConfUtil.h"


/*  R E F  C O U N T  */
/*-------------------------------------------------------------------------
    %%Function: Init
    
-------------------------------------------------------------------------*/
void RefCount::Init(OBJECTDESTROYEDPROC ObjectDestroyed)
{
	ASSERT((!ObjectDestroyed) ||
		IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

	m_ulcRef = 1;
	m_ObjectDestroyed = ObjectDestroyed;
	DbgMsgRefCount("Ref: %08X c=%d (created)", this, m_ulcRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
#ifdef DEBUG
	m_fTrack = FALSE;
#endif
}

/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount()
{
	Init(NULL);
}

/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount(OBJECTDESTROYEDPROC ObjectDestroyed)
{
	Init(ObjectDestroyed);
}


RefCount::~RefCount(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	// m_ulcRef may be any value.
	DbgMsgRefCount("Ref: %08X c=%d (destroyed)", this, m_ulcRef);

	if (m_ObjectDestroyed)
	{
		m_ObjectDestroyed();
		m_ObjectDestroyed = NULL;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	ASSERT(m_ulcRef < ULONG_MAX);
	m_ulcRef++;
	DbgMsgRefCount("Ref: %08X c=%d (AddRef)", this, m_ulcRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

#ifdef DEBUG
	if (m_fTrack)
	{
		DbgMsg(iZONE_OBJECTS, "Obj: %08X c=%d (AddRef)  *** Tracking", this, m_ulcRef);
	}
#endif
	return m_ulcRef;
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	if (m_ulcRef > 0)
	{
		m_ulcRef--;
	}

#ifdef DEBUG
	if (m_fTrack)
	{
		DbgMsg(iZONE_OBJECTS, "Obj: %08X c=%d (Release) *** Tracking", this, m_ulcRef);
	}
#endif

	ULONG ulcRef = m_ulcRef;
	DbgMsgRefCount("Ref: %08X c=%d (Release)", this, m_ulcRef);

	if (! ulcRef)
	{
		delete this;
	}

	return ulcRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\richaddr.h ===
// File richaddr.h
//
// RichAddress definitions

#ifndef _RICH_ADDR_H_
#define _RICH_ADDR_H_

#include "SDKInternal.h"

typedef struct  DWSTR
    {
    DWORD dw;
    LPTSTR psz;
}	DWSTR;


typedef struct  RichAddressInfo
{
	TCHAR szName[ 256 ];
	int cItems;
	DWSTR rgDwStr[ 1 ];
} RichAddressInfo, RAI;

interface IEnumRichAddressInfo
{
public:
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;

	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetAddress( 
        long index,
        RichAddressInfo **ppAddr) = 0;
};

inline
bool
hasValidUserInfo
(
	const RichAddressInfo * const	rai
){
	return( (rai != NULL) && (rai->cItems > 0) && (rai->rgDwStr[ 0 ].psz != NULL) && (rai->rgDwStr[ 0 ].psz[ 0 ] != '\0') );
}

#endif /* _RICH_ADDR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\refcount.h ===
// File: refcount.h

#ifndef _REFCOUNT_H_
#define _REFCOUNT_H_

// RefCount destructor callback function
typedef void (*OBJECTDESTROYEDPROC)(void);
VOID STDMETHODCALLTYPE DLLObjectDestroyed(void);
VOID DllLock(void);


//////////////////////////////////////////////////////////////////////////


class RefCount
{
private:
	ULONG m_ulcRef;
	OBJECTDESTROYEDPROC m_ObjectDestroyed;

#ifdef DEBUG
	BOOL m_fTrack;
#endif

	void Init(OBJECTDESTROYEDPROC ObjectDestroyed);

public:
	RefCount();
	RefCount(OBJECTDESTROYEDPROC ObjectDestroyed);
	// Virtual destructor defers to destructor of derived class.
	virtual ~RefCount(void);

	// IUnknown
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);

#ifdef DEBUG
	VOID SetTrack(BOOL fTrack)  {m_fTrack = fTrack;}
#endif
};
DECLARE_STANDARD_TYPES(RefCount);


// Special version of the above that calls our standard Dll locking functions
class DllRefCount : public RefCount
{
public:
	DllRefCount() : RefCount(&DLLObjectDestroyed) {DllLock();}
	~DllRefCount(void) {};
};

#endif /* _REFCOUNT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Conf.rc
//
#define IDC_ONDESKTOP                   0
#define IDC_ONQUICKLAUNCH               1
#define IDI_CONFROOM                    2
#define IDB_SHOWDBG                     3
#define IDS_LICENSEDTO                  8
#define IDS_COPYRIGHT                   9
#define IDB_INTROWIZ                    10
#define IDS_ABOUT_COPYRIGHT             10
#define IDS_DIRLIST_STATIC_WIDTH        13
#define IDS_SPLASHFONT                  13
#define IDS_SPLASHFONTSIZE              14
#define IDS_REMOTE_VIDEO_TITLE          18
#define IDS_MYVIDEO                     19
#define IDS_SPEEDDIAL_FOLDER            20
#define IDS_NONHOST_TOOLS               21
#define IDS_NONHOST_YOUACCEPT           22
#define IDS_NONHOST_YOUINVITE           23
#define IDS_TOOLBAR_TEXTROWS            35
#define IDS_TOOLBAR_BUTTON_WIDTH        36
#define IDS_DEFAULT_LAYOUT              42
#define IDS_UPROP_EMAIL                 71
#define IDS_UPROP_CITY                  72
#define IDS_UPROP_COUNTRY               73
#define IDS_UPROP_STATUS                74
#define IDS_UPROP_RECEIVED              75
#define IDS_UPROP_ADDRESS               76
#define IDS_UPROP_VIDEO                 77
#define IDS_UPROP_AUDIO                 78
#define IDS_UPROP_COMMENTS              79
#define IDS_UPROP_SECURITY              80
#define IDS_UPROP_SHARING               81
#define IDS_UPROP_CONTROL               82
#define IDS_UPROP_VERSION               83
#define IDS_CANT_START_NM_BECAUSE_SDK_APP_OWNS_NM 84
#define IDS_CONTAINER_GOING_AWAY_BUT_ACVITE_CONFERENCE 85
#define IDI_HOSTMEET                    90
#define IDI_SM_WORLD                    91
#define IDR_NETMEETING                  92
#define IDR_VIDEOWINDOW                 93
#define IDR_NMMANAGER                   95
#define IDR_NMAPP                       96
#define IDR_NMAPPLET                    97
#define IDD_PASSWORD                    101
#define IDB_TOOLBAR                     102
#define IDD_PAGE_SERVER                 102
#define IDR_CONFROOM_MENU               103
#define IDD_OPTIONS                     103
#define IDB_CONFROOM_TOOLBAR            104
#define IDM_CONNECT                     104
#define IDR_USERPOPUP                   105
#define IDM_ALISTEN                     105
#define IDR_TASKBAR_POPUP               105
#define IDR_USER_POPUP                  107
#define IDD_SECURITY                    107
#define IDB_POPUPBAR                    108
#define IDD_RDSWIZ_W98PASSWORD          108
#define IDD_RDSWIZ_NTPASSWORDS          109
#define IDS_HARDWARE_DETECTED           110
#define IDD_RDSWIZ_CONGRATS             110
#define IDS_NO_HARDWARE_DETECTED        111
#define IDI_SPKERROR                    111
#define IDI_MICERROR                    112
#define IDD_PASSWORD_RDS                113
#define IDI_MICEMPTY                    114
#define IDD_CALL                        115
#define IDI_SPKEMPTY                    116
#define IDB_DIRECTORY                   119
#define IDB_CALL_UP                     120
#define IDB_WHITEBOARD                  120
#define IDB_CALL_DOWN                   121
#define IDD_INTROWIZ                    121
#define IDB_DIAL                        121
#define IDD_ADV_CALL                    122
#define IDB_HANGUP                      122
#define IDB_SHARE                       123
#define IDR_ACCELERATORS                124
#define IDB_CHAT                        124
#define IDS_SHARING_NOTHING             126
#define IDS_SHARING_APPS                127
#define IDS_SHARING_DESKTOP             128
#define IDS_CONTROL_CONTROLLEDBY        129
#define IDS_CONTROL_INCONTROLOF         130
#define IDS_CONTROL_CONTROLLABLE        131
#define IDS_CONTROL_NOTCONTROLLABLE     132
#define IDD_CHOOSECONF                  134
#define IDI_NET                         135
#define IDC_CALL_ANIMATION              136
#define IDA_CALL_ANIMATION              137
#define IDB_CALL                        138
#define IDB_PLAYPAUSE                   139
#define IDB_AUDIO                       141
#define IDB_PIP                         142
#define IDD_HOST_SETTINGS               143
#define IDD_USER_PROPERTIES             144
#define IDB_ADDRESSBAR                  145
#define IDB_CONFROOM_TOOLBAR_HOT        146
#define IDD_DBG_VERSION                 147
#define IDD_DBG_OPTIONS                 148
#define IDI_SPEAKER                     148
#define IDI_MICFONE                     149
#define IDI_SIGNAL_LEVEL                150
#define IDD_INCOMING_CALL               151
#define IDD_ABOUT_BOX                   152
#define IDD_CALL_PROGRESS               153
#define IDD_DONT_SHOW_ME                154
#define IDB_SHOWAV                      155
#define IDI_USER_WATCHING               156
#define IDB_DIALSTAR                    156
#define IDI_USER_WORKING_ALONE          157
#define IDB_DIAL1                       157
#define IDD_USER_CREDENTIALS            158
#define IDB_DIAL2                       158
#define IDB_DIAL3                       159
#define IDI_CHECKON                     160
#define IDB_DIAL4                       160
#define IDI_CHECKOFF                    161
#define IDB_DIAL5                       161
#define IDB_DIAL6                       162
#define IDD_CREATE_SPEED_DIAL           163
#define IDB_DIAL7                       163
#define IDB_DIAL8                       164
#define IDB_DIAL9                       165
#define IDB_DIALPOUND                   166
#define IDC_STIDERC                     167
#define IDB_DIAL0                       167
#define IDB_SPLASH                      173
#define IDB_DIR_TOOLBAR                 174
#define IDB_DIR_TOOLBAR_HOT             175
#define IDB_ICON_IMAGES                 175
#define IDR_CALL                        180
#define IDB_COOLBAR_BACK                182
#define IDD_SECURE_INCOMING_CALL        183
#define IDB_FILE_TRANSFER               183
#define IDS_NO_USER_CERTS               184
#define IDD_VIDEOWIZ                    185
#define IDD_RDSWIZ_INTRO                185
#define IDI_NETGRAY                     185
#define IDD_VIDEOWIZ_NO_CAMERA          186
#define IDD_SHRTCUTWIZ                  186
#define IDD_VIDEOWIZ_NO_PENTIUM         187
#define IDB_VIDEO_LOGO_SMALL            187
#define IDR_VIDEO_POPUP                 188
#define IDI_DIRECTORY                   188
#define IDR_MAINUI                      189
#define IDI_WEBVIEW                     190
#define IDI_HELP                        191
#define IDI_REFRESH                     192
#define IDI_VIDEO_OUT                   193
#define IDD_BANDWIDTH                   193
#define IDD_OPT_GENERAL                 194
#define IDI_NO_AUDIO                    195
#define IDI_NEWHTMLWINDOW               195
#define IDI_DELETE                      196
#define IDI_NO_VIDEO                    197
#define IDM_AUDIO_CUSTOM                200
#define IDD_EDIT                        201
#define IDD_TEXT                        202
#define IDEC_EMAIL                      202
#define IDB_VIDEO_LOGO                  202
#define IDEC_SERVER                     203
#define IDC_DRAG_HAND                   203
#define IDRC_YES                        204
#define IDS_UNKNOWN                     205
#define IDRC_NO                         205
#define IDD_HOSTNAME                    206
#define IDEC_FIRSTNAME                  206
#define IDD_LBALIAS                     207
#define IDEC_LASTNAME                   207
#define IDD_LBADDR                      208
#define IDS_NAME_ORDER                  209
#define IDI_AUDIO_OPTIONS               211
#define IDEC_PHONENUM                   211
#define IDI_DIR_OPTIONS                 213
#define IDI_GEN_OPT                     217
#define IDI_GEN_OPT2                    218
#define IDI_GEN_OPT3                    219
#define IDS_LOGGED_ON                   220
#define IDI_MY_INF_OPT                  220
#define IDS_NOT_LOGGED_ON               221
#define IDS_FINDING                     222
#define IDS_DISCONNECTED                223
#define IDI_VID_OPT3                    223
#define IDI_MEDIUM                      224
#define IDI_LARGE                       225
#define IDI_SMALL                       227
#define IDI_LOW_QUAL                    229
#define IDI_HIGH_QUAL                   230
#define IDI_CALL_OPTIONS                231
#define IDS_COMMAND_GIVECONTROL         232
#define IDS_COMMAND_CANCELGIVECONTROL   233
#define IDD_APPSHARINGWIZ_NEEDSP        235
#define IDD_APPSHARINGWIZ_HAVESP        237
#define IDD_VIDWIZ                      238
#define IDD_REMOTE                      245
#define IDD_REMOTE_PASSWORD             246
#define IDD_SERVICE_RUNNING             250
#define IDI_SECURITY                    254
#define IDI_CERT                        256
#define IDS_RELEASE_NOTES_MISSING       260
#define IDS_NEED_RESTART                280
#define IDS_NEED_NEXTCALL               282
#define IDS_WONT_SUSPEND                287
#define IDM_AUDFORMAT                   300
#define IDS_INVITE_PERMISSION           300
#define IDS_MSGBOX_TITLE                301
#define IDS_CLOSEWINDOW_PERMISSION      302
#define IDS_JOIN_ATTEMPT                303
#define IDS_JOIN_PERMISSION             304
#define IDS_INVITE_COULD_NOT_CONNECT    305
#define IDS_COULD_NOT_CONNECT           305
#define IDS_INVITE_DENIED               306
#define IDS_HANGUP_ATTEMPT              307
#define IDS_CALL_MISSING_ADDRESS        308
#define IDS_JOIN_DENIED                 309
#define IDS_CLOSE_DISCONNECT_PERMISSION 311
#define IDS_UNKNOWN_PERSON              312
#define IDS_ERROR_BAD_ADMIN_SETTINGS    313
#define IDS_RESOLVE_FAILED              314
#define IDS_COULD_NOT_INVITE            315
#define IDS_CONNECT_REMOTE_NO_SECURITY  316
#define IDS_CONNECT_REMOTE_DOWNLEVEL_SECURITY 317
#define IDS_INVITE_CONF_ENDED           318
#define IDS_CONNECT_SECURITY_FAILED     319
#define IDS_CONNECT_AUTHENTICATION_FAILED 320
#define IDS_ALREADY_CALLING             321
#define IDS_CONFERENCE_ENDED_BEFORE_JOIN 322
#define IDS_GK_CALLEE_NOT_REGISTERED    323
#define IDS_GK_TIMEOUT                  324
#define IDS_GK_REJECTED                 325
#define IDS_GK_NOT_REGISTERED           326
#define IDS_CONNECT_REMOTE_REQUIRE_SECURITY 327
#define IDS_INVITE_DENIED_REMOTE_CONF   328
#define IDS_ERRMSG_HOST                 330
#define IDS_TRANSPORT_UNAVAILABLE       331
#define IDS_CALL_LOOPBACK               332
#define IDS_AUDIO_IN_USE_REMOTE_AFTER_DATA 333
#define IDS_AUDIO_IN_USE_REMOTE         334
#define IDS_AUDIO_IN_USE_LOCAL_AFTER_DATA 335
#define IDS_AUDIO_IN_USE_LOCAL          336
#define IDS_INCALL_JOIN_FAILED          338
#define IDS_CONFERENCE_DOES_NOT_EXIST   342
#define IDS_REMOTE_MEDIA_ERROR          343
#define IDS_CANT_INVITE_MCU             344
#define IDS_NMCALLTOMAILTEXT            345
#define IDS_CLOSEWINDOW_PERMISSION_FT   346
#define IDS_CLOSE_DISCONNECT_PERMISSION_FT 347
#define IDS_HANGUP_ATTEMPT_FT           348
#define IDS_REMOTE_PLACING_CALL         349
#define IDS_BACKLEVEL_LOADED            363
#define IDS_CANT_START                  364
#define IDS_T120_ALREADY_INITIALIZED    366
#define IDS_AUDIO_CONNECT_FAILED        370
#define IDS_AUDIO_FAILED_AFTER_DATA     371
#define IDS_AUDIO_NOT_AVAILABLE         372
#define IDS_NO_CALL_LOG_INFO            380
#define IDS_BROWSER_ADDRESS_STATIC      390
#define IDS_MEDIAPHONE_TITLE            400
#define IDS_MEDIAPHONE_INCALL           401
#define IDS_MEDIAPHONE_NOTINCALL        402
#define IDS_MEDIAPHONE_INAUDIOCALL      403
#define IDS_MEDIAPHONE_INCALL_ONE       403
#define IDS_ABOUT_TITLE                 410
#define IDS_ABOUT_OTHER                 411
#define IDS_DEFAULT_CONF_NAME           420
#define IDS_LOGOFF_ULS                  430
#define IDS_LOGOFF_ULS_FORMAT           430
#define IDS_LOGON_ULS                   431
#define IDS_LOGON_ULS_FORMAT            431
#define IDS_LOGGED_OFF_CONFIRM          432
#define IDS_ULS_CHANGED_PROMPT          434
#define IDS_CALL_CANCELED_FORMAT        439
#define IDS_FMTBUFFER                   440
#define IDS_CERTERR_NOISSUER            441
#define IDS_CERTERR_SIG                 442
#define IDS_CERTERR_EXPIRED             443
#define IDS_CERTERR_REVOKED             444
#define IDS_CERT_VERIFIED               445
#define IDS_CERTERR_SELFISSUED          446
#define IDS_GATEWAY_DISPLAY_NAME        463
#define IDS_FAVORITES_ITEM_HELP         501
#define IDS_FT_RECDIR_DEFAULT           566
#define IDS_STATUS_FINDING              603
#define IDS_STATUS_SETTING_UP           604
#define IDS_STATUS_WAITING              606
#define IDS_STATUS_IN_CALL              607
#define IDS_STATUS_NOT_IN_CALL          608
#define IDS_STATUS_SENDFILE             609
#define IDS_STATUS_RECEIVEFILE          610
#define IDS_STATUS_IN_SECURE_CALL       611
#define IDS_STATUS_DO_NOT_DISTURB       613
#define IDI_DO_NOT_DISTURB              613
#define IDS_NEW                         658
#define IDS_OPEN                        659
#define IDS_SAVE                        660
#define IDS_CUT                         661
#define IDS_COPY                        662
#define IDS_PASTE                       663
#define IDS_PRINT                       664
#define IDS_ABOUT                       665
#define IDS_CALL_TT                     700
#define IDS_START_SERVER                701
#define IDS_STOP_SERVER                 702
#define IDS_HOST_WARNING                703
#define IDS_DO_NOT_DISTURB_WARNING      704
#define IDS_MACHINENAMEWARNING          713
#define IDS_UNRESOLVED_MESSAGE          720
#define IDS_UNRESOLVED_CAPTION          721
#define IDS_CALLERR_E_BAD_PHONE_NUMBER  800
#define IDS_CALLERR_E_NO_PHONE_SUPPORT  801
#define IDS_CALLERR_E_BAD_IPADDRESS     802
#define IDS_CALLERR_E_BAD_HOSTNAME      803
#define IDS_CALLERR_E_NO_ILS            804
#define IDS_CALLERR_E_ILS_RESOLUTION_FAILED 805
#define IDS_CALLERR_E_NO_ADDRESS        806
#define IDS_CALLERR_E_INVALID_ADDRESS   807
#define IDS_CALLERR_E_NO_GATEKEEPER     808
#define IDS_CALLERR_E_NO_GATEWAY        809
#define IDS_CALLERR_E_PARAM_ERROR       810
#define IDS_CALLERR_E_SECURITY_MISMATCH 811
#define IDS_CALLERR_E_UNESCAPE_ERROR    812
#define IDS_ULSLOGON_BADSERVER          950
#define IDS_ULSLOGON_OLDCLIENT          951
#define IDS_ULSLOGON_ERROR              952
#define IDS_ULSLOGON_DUPLICATE          954
#define IDS_ULSLOGON_OUTOFMEMORY        955
#define IDS_ULSLOGON_UNRECOVERABLE      956
#define IDS_ULSLOGON_BADPROP            957
#define IDS_ULSLOGON_REFUSED            958
#define IDS_ULSLOGON_TIMEOUT            959
#define IDS_ULSLOGON_WORD_FILTER        960
#define IDC_UP_CRED                     971
#define IDS_ULS_DEFAULT                 998
#define IDC_CALL                        1000
#define IDC_EDIT_PASSWORD               1000
#define IDC_ATW_SLIDER1                 1000
#define IDC_SEC_SECURECALL              1000
#define IDC_SCRSAVER_NOW                1000
#define IDA_DLGCALL                     1000
#define IDM_DLGCALL                     1000
#define IDM_DLGCALL_ENTER               1000
#define IDC_DELAY                       1001
#define IDC_NAMECOMBO                   1001
#define IDC_CHECK_SAVE_PASSWORD         1001
#define IDC_CONFNAME_EDIT               1001
#define IDC_UPROP_ICON                  1001
#define IDC_BUTTON_ATW_TEST             1001
#define IDC_CHECK_USE_GATEWAY           1001
#define IDC_SCRSAVER_LATER              1001
#define IDL_DLGCALL_LIST                1001
#define IDC_ATCOMBO                     1002
#define IDC_STATIC_CONFNAME             1002
#define IDC_CHECK_USE_PHONE_NUMBERS     1002
#define IDC_ENABLE_RDS                  1002
#define IDL_DLGCALL_LISTOWNERDATA       1002
#define IDC_NAMESTATIC                  1003
#define IDC_CONFNAME_LISTVIEW           1003
#define IDC_ATW_PROGRESS                1003
#define IDC_CHECK_USE_ACCOUNT           1003
#define IDC_EDIT_RDSPASSWORDV           1003
#define IDC_BUTTON_RDSWIZ               1003
#define IDL_DLGCALL_ILS_LISTVIEW        1003
#define IDC_ATSTATIC                    1004
#define IDC_UPROP_SHARING               1004
#define IDC_ATW_SLIDER2                 1004
#define IDC_STATIC_SERVER_NAME          1004
#define IDL_DLGCALL_WEB_VIEW            1004
#define IDC_UP_VALUE1                   1005
#define IDC_ATPROPERTIES                1005
#define IDC_STATIC_GATEWAY_NAME         1005
#define IDC_MCU                         1006
#define IDC_UPROP_EMAIL                 1006
#define IDC_ANSWERING_AUTOANSWER        1006
#define IDC_UP_VALUE2                   1006
#define IDC_STATIC_PHONE_NUMBER         1006
#define IDC_UPROP_CITY                  1007
#define IDC_AUTOACCEPT                  1007
#define IDC_UP_VALUE3                   1007
#define IDC_VUMETER                     1007
#define IDC_SECURE_CALL_MSG             1007
#define IDC_STATIC_GATEKEEPER_NAME      1007
#define IDC_UPROP_COUNTRY               1008
#define IDC_UP_VALUE4                   1008
#define IDC_SECURE_CALL_EDIT            1008
#define IDC_RADIO1                      1008
#define IDC_STATIC_PROXY_NAME           1008
#define IDC_UPROP_COMMENTS              1009
#define IDC_ANSWERING_NRINGS            1009
#define IDC_UP_VALUE5                   1009
#define IDC_EDIT_MEETING_NAME           1009
#define IDG_GKMODE                      1009
#define IDC_CONFERENCING_CONFNAME       1010
#define IDC_UP_VALUE6                   1010
#define IDC_CHECK_ONLY_ALLOW_INVITEES   1010
#define IDC_UP_VALUE7                   1011
#define IDC_EDIT_MEETING_PASSWORD       1011
#define IDC_STATIC_ADDRESS              1011
#define IDC_DLGCALL_COMBO               1011
#define IDC_UP_VALUE8                   1012
#define IDC_CHECK_MEETING_IS_PASSWORD_PROTECTED 1012
#define IDC_EDIT_NEW_INVITEE            1012
#define IDC_STATIC_CALLUSING            1012
#define IDC_UPROP_NAME                  1013
#define IDC_BUTTON_BROWSE_FOR_INVITEE   1013
#define IDC_EDIT_USERNAME               1013
#define IDE_CALLOPT_GK_PHONE_NUMBER     1013
#define IDC_BUTTON_REMOVE_USER          1014
#define IDC_EDIT_DOMAIN                 1014
#define IDC_VIDEO_MIRROR                1014
#define IDC_BUTTON_MODIFY_USER          1015
#define IDC_EDIT_RDS_CERT               1015
#define IDC_LIST_MEETING_INVITEES       1016
#define IDC_EDIT_RDSPASSWORD            1016
#define IDC_BUTTON_ADD_USER             1017
#define IDC_EDIT_RDSPASSWORDO           1017
#define IDC_REMOTECTL_ALLOW             1018
#define IDC_RADIO_VIEW_MODIFY_ACCESS_PRIVS 1018
#define IDC_IP_ADDRESS                  1018
#define IDC_REMOTECTL_PASSWORD          1019
#define IDC_RADIO_VIEW_MODIFY_MEETING_DOCUMENT_LINKS 1019
#define IDC_IPADDR_STATIC               1019
#define IDC_RADIO_GENERAL_MEETING_SETTINGS 1020
#define IDC_BANDWIDTH                   1020
#define IDC_ADV_CONF_EDIT               1021
#define IDE_DLGCALL_NAME                1021
#define IDC_ALWAYS_RUNNING              1021
#define IDC_RADIO_GENERAL_MEETING_SETTINGS2 1022
#define IDC_CHECK_USE_PROXY             1023
#define IDC_ADV_ADDRESS_COMBO           1025
#define IDC_ADV_USING_COMBO             1026
#define IDC_ANSWERING_AUTO              1027
#define IDE_CALLOPT_PROXY_SERVER        1028
#define IDC_AUDIO_MOST                  1029
#define IDC_AUDIO_MODERATE              1030
#define IDC_AUDIO_SOME                  1031
#define IDC_AUDIO_LEAST                 1032
#define IDC_FULLDUPLEX                  1033
#define IDC_AUTOANSWER                  1034
#define IDC_CSD_SAVE_DESKTOP_RADIO      1035
#define IDC_AUTOACCEPTJOIN              1035
#define IDC_DIALINGLOCATION             1037
#define IDC_CSD_SPEEDDIAL_LIST_RADIO    1037
#define IDC_DIALINGPROPERTIES           1038
#define IDL_DBG_VERINFO                 1042
#define IDC_DBG_VER_OPRAH               1044
#define IDC_DBG_TRACE_CALL              1045
#define IDC_USER_NAME                   1045
#define IDC_USER_EMAIL                  1046
#define IDC_DBG_TRACE_FILE              1047
#define IDC_DBG_VER_WINDOWS             1047
#define IDC_USER_LASTNAME               1047
#define IDC_DBG_ASSERT_BREAK            1048
#define IDC_DBG_VER_AUDIO               1048
#define IDC_USER_LOCATION               1048
#define IDC_USER_INTERESTS              1050
#define IDC_MSG_STATIC                  1051
#define IDC_ABOUT_VERSION_STATIC        1052
#define IDC_ADVANCED_CALL_OPTS          1053
#define IDC_DONT_SHOW_ME_CHECK          1054
#define IDC_USER_PUBLISH                1054
#define IDC_TEXT_STATIC                 1055
#define IDC_NAMESERVER                  1055
#define IDC_ICON_STATIC                 1056
#define IDL_DEBUG                       1056
#define IDC_CSD_CALL_USING_COMBO        1059
#define IDE_HOST_GENERAL                1059
#define IDC_CSD_ADDRESS_EDIT            1060
#define IDC_DESCRIPTION_TEXT            1060
#define IDE_HOST_SETTINGS               1060
#define IDE_HOST_PASSWORD               1061
#define IDE_HOST_YOUACCEPT              1062
#define IDE_HOST_YOUINVITE              1063
#define IDE_HOST_TOOLS                  1064
#define IDC_SHOWHELPMESSAGES            1064
#define IDE_HOST_TOOLS2                 1065
#define IDC_USEULS                      1065
#define IDC_START_AUDIO_WIZ             1066
#define IDC_WEBVIEW2                    1066
#define IDC_AUTOGAIN                    1067
#define IDC_AUTOMIX                     1068
#define IDC_CALIBPROGRESS               1069
#define IDC_FULLDUPLEXCAP               1069
#define IDC_WIZARD_BMP                  1070
#define IDC_WIZBMP                      1070
#define IDC_STATIC_SPEED_DIAL_INSTRUCTIONS 1071
#define IDC_WIZARD_BMP2                 1071
#define IDC_CALIBTIMELEFT               1072
#define IDC_WAVEIN                      1072
#define IDC_AUDIOCHECKREASON            1073
#define IDC_VIDEO_SEND                  1074
#define IDC_DUPLEX                      1074
#define IDC_VIDEO_RECEIVE               1075
#define IDC_VIDEOAVAIL                  1076
#define IDC_RECVOLUME                   1076
#define IDC_TRK_MIC                     1077
#define IDC_MICSENSE_MANUAL             1078
#define IDC_MICSENSE_AUTO               1079
#define IDC_ERRTITLE                    1079
#define IDC_ERRTEXT                     1080
#define IDC_SHOWONTASKBAR               1080
#define IDC_ERRWIZICON                  1081
#define IDC_RESTOREAPPONCALL            1081
#define IDC_RADIO144KBS                 1082
#define IDC_RADIO288KBS                 1083
#define IDC_PROPERTIES                  1083
#define IDS_ERROR_SECURITY_AND_GATEKEEPER_ENABLED 1083
#define IDC_RADIOMOREKBS                1084
#define IDC_RADIOISDN                   1085
#define IDC_WAVEOUT                     1085
#define IDC_START                       1086
#define IDC_RADIOBWCODEC                1088
#define IDC_RADIOMANUALCODEC            1089
#define IDC_ADVANCEDCODEC               1090
#define IDC_COMBOBW                     1091
#define IDC_COMBOCAP                    1092
#define IDC_CHECKDEFAULT                1093
#define IDS_UPROP_LOCATION              1094
#define IDC_CODECLIST                   1095
#define IDS_UPROP_PHONENUM              1095
#define IDC_CODECUP                     1096
#define IDC_CODECDOWN                   1097
#define IDC_CODECDEFAULT                1098
#define IDC_MENUPROPERTIES              1099
#define IDS_MISSED_YOU_FORMAT           1100
#define IDC_MYINFO_GROUP                1103
#define IDC_MYINFO_GROUP2               1104
#define IDC_VIDEO_AUTOSEND              1107
#define IDC_VIDEO_AUTORECEIVE           1108
#define IDC_VIDEO_CLOSELOCAL            1109
#define IDS_SPEED_DIAL_SAVED_ON_DESKTOP 1110
#define IDC_VIDEO_CLOSEREMOTE           1110
#define IDS_SPEED_DIAL_SAVE_ERROR       1111
#define IDC_VIDEO_SOURCE                1111
#define IDC_VIDEO_FORMAT                1112
#define IDC_LOGON_TO_SERVER             1113
#define IDC_UNLISTED                    1114
#define IDC_VIDEO_SQCIF                 1115
#define IDC_VIDEO_QCIF                  1116
#define IDC_VIDEO_CIF                   1117
#define IDC_VIDEO_QUALITY               1119
#define IDC_VIDEO_QUALITY_DESC          1120
#define IDC_VIDEO_QUALITY_LOW           1121
#define IDC_VIDEO_QUALITY_HIGH          1122
#define IDC_VIDEO_OPENLOCAL             1123
#define IDC_VIDEO_SEND_NOTE             1124
#define IDC_NEVER                       1133
#define IDC_ASKME                       1134
#define IDC_AUTOMATIC                   1135
#define IDC_WARNME                      1136
#define IDC_WARNCOUNT                   1137
#define IDC_CODECMANUAL                 1138
#define IDC_FRIENDS_REFRESH_AT_START    1138
#define IDC_CODECLISTLABEL              1139
#define IDC_ABOUT_COPYRIGHT             1141
#define IDC_PSD_AUTOMATIC_CHECK         1142
#define IDC_MSD_ICON                    1143
#define IDC_MSD_WARNME_CHECKBOX         1144
#define IDC_MSD_WARNCOUNT_EDIT          1145
#define IDC_PSD_STATIC                  1146
#define IDC_PSD_ICON                    1150
#define IDC_CSD_CREATE_GROUPBOX         1151
#define IDC_CSD_SD_INFO_GROUP           1152
#define IDC_CATEGORY_GROUP              1158
#define IDC_GENERAL_GROUP               1162
#define IDC_UP_PROP1                    1163
#define IDC_MICSENSE_GROUP              1164
#define IDC_UP_PROP2                    1164
#define IDC_UP_PROP3                    1165
#define IDC_SENDRECEIVE_GROUP           1166
#define IDC_UP_PROP4                    1166
#define IDC_QUALITY_GROUP               1167
#define IDC_UP_PROP5                    1167
#define IDC_CAMERA_GROUP                1168
#define IDC_UP_PROP6                    1168
#define IDC_MSD_EXPLANATION_STATIC      1168
#define IDC_ADDFRIENDS_GROUP            1169
#define IDC_VWCOMBO                     1169
#define IDC_UP_PROP7                    1169
#define IDC_DIRECTORY_GROUP             1170
#define IDL_DBG_LIST                    1170
#define IDC_UP_PROP8                    1170
#define IDC_GROUP_VOLUME                1171
#define IDC_ATW_PLAYTEXT                1172
#define IDC_ATW_PLAYBACK_ERROR          1173
#define IDC_ATW_RECORD_ERROR            1174
#define IDS_WEB_PAGE_FORMAT_WEBVIEW     1174
#define IDS_WEB_PAGE_FORMAT_FREE        1175
#define IDS_WEB_PAGE_FORMAT_NEWS        1176
#define IDS_WEB_PAGE_FORMAT_FAQ         1177
#define IDE_HOST_NAME                   1177
#define IDS_WEB_PAGE_FORMAT_FEEDBACK    1178
#define IDS_WEB_PAGE_FORMAT_BEST        1179
#define ID_OK                           1179
#define IDS_WEB_PAGE_FORMAT_SEARCH      1180
#define ID_CANCEL                       1180
#define IDS_WEB_PAGE_FORMAT_MSHOME      1181
#define IDC_EDITOLDPASSWORD             1181
#define ID_START_CONF                   1181
#define IDS_WEB_PAGE_FORMAT_SUPPORT     1182
#define ID_EXIT                         1182
#define IDS_WEB_PAGE_FORMAT_GETCAMERA   1183
#define IDC_AUTH_EDIT                   1184
#define IDC_VERIFICATION                1185
#define IDC_AUTH_GROUP                  1185
#define IDC_EDITVERIFICATION            1186
#define IDC_DIRECTSOUND                 1186
#define IDC_PASSWORD                    1187
#define IDC_SEC_GENERAL                 1189
#define IDC_SEC_INCOMING                1190
#define IDC_SEC_OUTGOING                1191
#define IDC_SEC_GEN_TEXT                1193
#define IDC_OLDPASSWORD                 1194
#define IDC_SEC_CRED                    1194
#define IDC_NEWPASSWORD                 1195
#define IDC_SEC_CRED_TEXT               1195
#define IDC_EDITNEWPASSWORD             1196
#define IDC_COMBO1                      1196
#define IDC_SEC_CERTLIST                1196
#define IDC_COMBO_CODEC                 1196
#define IDC_SEC_VIEWCREDS               1197
#define IDC_SEC_CHANGECERT              1198
#define IDS_AUDIO_WAVE_DEVICE_IN_USE    1200
#define IDE_HOST_SECURE                 1202
#define IDC_SEC_PRIVACY_ONLY            1203
#define IDC_SEC_PRIVACY_AUTH            1204
#define IDE_HOST_YOUSHARE               1205
#define IDE_HOST_YOUWB                  1206
#define IDE_HOST_YOUCHAT                1207
#define IDE_HOST_YOUFT                  1208
#define IDE_HOST_YOUAUDIO               1209
#define IDE_HOST_YOUVIDEO               1210
#define IDS_INVITE_SOUND                1300
#define IDS_JOIN_SOUND                  1301
#define IDS_PERSON_JOINED_SOUND         1302
#define IDS_PERSON_LEFT_SOUND           1303
#define IDD_ACD                         1400
#define IDS_HISTORY_NO_ADDRESS          1401
#define IDB_ACD_ADDRESS                 1401
#define IDS_HISTORY_ACCEPTED            1402
#define IDL_ACD_ADDRESS                 1402
#define IDS_HISTORY_IGNORED             1403
#define IDL_ACD_ADDR_TYPE               1403
#define IDS_HISTORY_NOT_ANSWERED        1404
#define IDC_ACD_USING_STATIC            1405
#define IDC_ACD_DIRECTORY               1406
#define IDS_INCOMING_CALL_LOG           1430
#define IDS_COLUMN_NAME                 1500
#define IDS_COLUMN_CONNECTION           1501
#define IDS_COLUMN_AUDIO                1501
#define IDS_CONNECTION                  1502
#define IDS_COLUMN_VIDEO                1502
#define IDS_SPEED                       1503
#define IDS_COLUMN_DATA                 1503
#define IDS_PERMISSIONS                 1504
#define IDB_AUTH                        1533
#define IDB_DETAILS                     1533
#define IDS_TT_TB_NEW_CALL              1600
#define IDS_TT_TB_SHARING               1601
#define IDS_TT_TB_CHAT                  1602
#define IDS_TT_TB_NEWWHITEBOARD         1603
#define IDS_TT_TB_FILETRANSFER          1604
#define IDS_TT_FILE_HANGUP              1605
#define IDS_TT_TB_DIRECTORY             1606
#define IDS_TT_TB_SHOWAVTB              1607
#define IDS_TT_TB_PLAYPAUSE             1608
#define IDS_TT_TB_PICINPIC              1609
#define IDS_TT_TB_AUDIOTUNING           1610
#define IDS_TT_DIALPAD                  1611
#define IDS_TT_ADDRESS_BAR              1612
#define IDS_TT_MUTE_MIC                 1613
#define IDS_TT_ADJUST_MIC               1614
#define IDS_TT_MUTE_SPK                 1615
#define IDS_TT_ADJUST_SPK               1616
#define IDS_TT_TB_SHOWROSTER            1617
#define IDS_TT_TB_HIDEAVTB              1618
#define IDS_TT_TB_PAUSE                 1619
#define IDS_TT_NEWWINDOW                1624
#define IDS_TT_REFRESH                  1625
#define IDS_TT_HELP                     1626
#define IDS_TT_DELETE_ILS               1627
#define IDS_MUTE                        1700
#define IDS_AUTO_DET_SILENCE            1701
#define IDS_SPEAKER                     1702
#define IDS_MICROPHONE                  1703
#define IDC_SECURE_CALL                 2000
#define IDG_CALLOPT                     2101
#define IDG_DIRECTMODE                  2101
#define IDE_CALLOPT_GW_SERVER           2104
#define IDC_CALLOPT_GK_USE              2105
#define IDE_CALLOPT_GK_SERVER           2106
#define IDE_CALLOPT_GK_ACCOUNT          2110
#define IDS_STATIC_ACCOUNT              2111
#define IDS_LOCAL_VIDEO_TITLE           3000
#define IDS_VIDEO_CLOSE_WARNING         3002
#define IDS_VIDEO_OPEN_WARNING          3003
#define IDS_VIDEO_NO_CAMERA             3004
#define IDS_VIDEO_NOT_IN_CALL           3005
#define IDS_VIDEO_NOT_SENDING           3006
#define IDS_VIDEO_NOT_RECEIVING         3007
#define IDS_VIDEO_UNDOCKED              3008
#define IDS_VIDEO_PAUSED                3009
#define IDS_VIDEO_DISABLED              3010
#define IDS_VIDEO_STATE_IDLE            3011
#define IDS_VIDEO_STATE_PREVIEWING      3012
#define IDS_VIDEO_STATE_SENDING         3013
#define IDS_VIDEO_STATE_RECEIVING       3014
#define IDS_VIDEO_STATE_PAUSED          3015
#define IDS_VIDEO_STATE_NOTSENDING      3016
#define IDS_VIDEO_STATE_NOTRECEIVING    3017
#define IDS_VIDEO_STATE_REMOTEPAUSED    3018
#define LVS_OWNERDATA                   0x1000
#define IDM_DLGCALL_PROPERTIES          4101
#define IDM_DLGCALL_CALL                4102
#define IDM_DLGCALL_DELETE              4103
#define IDM_DLGCALL_SPEEDDIAL           4104
#define IDM_DLGCALL_WAB                 4105
#define IDM_DLGCALL_ALWAYS_ENABLED      4150
#define IDM_DLGCALL_STOP                4150
#define IDM_DLGCALL_REFRESH             4151
#define IDM_DLGCALL_NEWWINDOW           4152
#define IDM_DLGCALL_DELETE_ILS          4153
#define IDC_SPLASHPIC                   5061
#define IDC_STATIC_MYINFO               6000
#define IDC_RDS_RUNRDS                  6001
#define IDC_SEC_RDS                     6002
#define IDC_RDS_PASSWORD                6003
#define ID_STATUS_LOGON_FORMAT          8500
#define ID_STATUS_LOGOFF_FORMAT         8501
#define ID_STATUS_LOGGEDON_FORMAT       8502
#define ID_STATUS_LOGGEDOFF             8503
#define ID_STATUS_ULSDISCONNECT_FORMAT  8504
#define ID_STATUS_LOGGED_ONTO_GATEKEEPER 8505
#define IDS_NEEDPHONENUM                8506
#define ID_STATUS_LOGING_ONTO_GATEKEEPER 8509
#define ID_STATUS_NOT_LOGGED_ON_TO_GATEKEEPER 8510
#define IDS_ERR_GK_LOGON_TIMEOUT        8511
#define IDS_ERR_GK_LOGON_REJECTED       8512
#define IDS_ERR_GK_NOT_FOUND            8513
#define IDS_ERR_CANT_CALL_NOT_LOGGED_ONTO_GATEKEEPER 8514
#define IDS_PHONENUM                    9000
#define IDS_FORMAT_VERSION              9001
#define IDS_NAME                        9002
#define IDS_ADDRESS                     9003
#define IDS_DLGCALL_HISTORY             9005
#define IDS_DLGCALL_WAB                 9006
#define IDS_DLGCALL_GAL                 9007
#define IDS_DLGCALL_BL                  9008
#define IDS_DLGCALL_SPEEDDIAL           9009
#define IDS_DLGCALL_TITLE               9010
#define IDS_DLGCALL_HDR                 9011
#define IDS_DLGCALL_CALL                9012
#define IDS_DLGCALL_CLOSE               9013
#define IDS_DLGCALL_EDIT_TOOLTIP        9014
#define IDS_DLGCALL_EDIT_HDR            9015
#define IDS_DLGCALL_COMBO_TOOLTIP       9016
#define IDS_SECURITY_CHECKBOX           9017
#define IDS_ACD_CT_AUTOMATIC            9018
#define IDS_ACD_CT_IP                   9019
#define IDS_ACD_CT_ILS                  9020
#define IDS_ACD_CT_PHONE                9021
#define IDS_ACD_CT_ALIAS                9022
#define IDS_ACD_CTF_IP                  9023
#define IDS_ACD_CTF_ILS                 9024
#define IDS_ACD_CTF_PHONE               9025
#define IDS_ACD_CTF_ALIAS               9026
#define IDS_ERR_CALLTO                  9027
#define IDS_NO_DIRECTORY_SERVICES_OR_ADDRESS_BOOKS 9028
#define IDS_DIR_COLUMN_FIRST            9040
#define IDS_DIR_COLUMN_AUDIO            9040
#define IDS_DIR_COLUMN_VIDEO            9041
#define IDS_DIR_COLUMN_LAST_NAME        9042
#define IDS_DIR_COLUMN_FIRST_NAME       9043
#define IDS_DIR_COLUMN_EMAIL            9044
#define IDS_DIR_COLUMN_LOCATION         9045
#define IDS_DIR_COLUMN_COMMENTS         9046
#define IDS_RECEIVED                    9047
#define IDS_DLGCALL_CONFIRM_DELETE_ILS  9050
#define IDS_DLGCALL_CANT_DELETE_DEFAULT_ILS 9051

#define	IDS_323_TYPE			12345
#define	IDS_SPEED_DIAL_TYPE 	12346
#define IDS_INTEL_PHONE_TYPE  12347
#define IDS_INFO_TIP          12348

#define IDS_CPLNAME                     20001
#define IDS_CPLDESCRIPTION              20002
#define IDS_BADPATH                     20004
#define IDS_BROWSETITLE                 20005
#define IDS_NOUSERDETAILS               20006
#define IDS_NOSAVEUSERDETAILS           20007
#define IDS_MICROPHONEVOL               20009
#define IDS_OFMAXVOL                    20010
#define IDS_UNSUPPORTEDCARD             20011
#define IDS_NORECVOLCNTRL               20012
#define IDS_NEEDUSERNAME                20013
#define IDS_CANTOPENWAVE                20014
#define IDS_QUITPROGRAM                 20015
#define IDS_CANCELANDRETRY              20017
#define IDS_ALLPAGESDISABLED            20018
#define IDS_KBS                         20019
#define IDS_BW144KBS                    20020
#define IDS_BW288KBS                    20021
#define IDS_BWMOREKBS                   20022
#define IDS_CODECNAME                   20023
#define IDS_MAXBITRATE                  20024
#define IDS_CPUUTIL                     20025
#define IDS_FATAL_AUDIO_ERROR           20026
#define IDS_AUDIO_ERROR                 20027
#define IDS_ILLEGAL_GATEKEEPERSERVER_NAME 20031
#define IDS_ILLEGALEMAILNAME            20032
#define IDS_NO_MICROPHONE               20033
#define IDS_NO_MICWARNING               20034
#define IDS_NOAUDIOTUNING               20035
#define IDS_BWISDN                      20036
#define IDS_ILLEGAL_GATEWAY_NAME        20037
#define IDS_BAD_ADMINISTRATOR_SETTINGS_GK_LOGON_INFORMATION 20038
#define IDS_ILLEGAL_PHONE_NUMBER        20039
#define IDS_NO_ILS_SERVER               20040
#define IDS_ILLEGAL_PROXY_NAME          20041
#define IDS_ILLEGAL_WEBDIR_DISPLAYNAME  20042
#define IDS_ILLEGAL_WEBDIR_ILS          20043
#define IDS_ILLEGAL_WEBDIR_URL          20044
#define IDS_ENABLEAPPSHARING_NEEDNTSP   20070
#define IDS_ENABLEAPPSHARING_INSTALL_CONFIRM 20071
#define IDS_ENABLEAPPSHARING_INSTALL_FAILURE 20072
#define IDS_ENABLEAPPSHARING_INSTALL_COMPLETE 20073
#define IDS_NMDD_DISPLAYNAME            20074
#define IDS_NMDD_INFNAME                20075
#define IDS_RWSWARNING                  20076
#define IDS_RDSWARNING                  20077
#define IDD_ANSWERING                   20102
#define IDD_FILEXFER                    20105
#define IDD_AUDIO                       20107
#define IDD_USERINFO                    20108
#define IDR_TOOLBAR                     20109
#define IDD_AUDIOCALIBWIZ0              20110
#define IDD_AUDIOCALIBWIZ1              20111
#define IDD_AUDIOCALIBWIZ2              20112
#define IDD_AUDIOCALIBWIZ3              20113
#define IDD_AUDIOCALIBWIZ4              20114
#define IDD_DETSOUNDCARDWIZ             20115
#define IDI_SOUNDERROR                  20116
#define IDD_AUDIOCALIBERRWIZ            20117
#define IDI_AUDIOCALIBERROR             20118
#define IDD_BANDWIDTHWIZ                20119
#define IDD_ADVANCEDCODEC               20122
#define IDD_VIDEO                       20123
#define IDD_PAGE_USER                   20124
#define IDD_CALLOPT                     20126
#define IDD_DBG_LIST                    20128
#define IDD_HOST                        20129
#define IDD_HOSTWIZ_INTRO               20130
#define IDD_RDSWIZ_ENABLE               20130
#define IDD_HOSTWIZ_INTRO_GENERAL       20131
#define IDD_RDSWIZ_SCRNSVR              20131
#define IDD_HOSTWIZ_GENERAL             20132
#define IDD_RDS_SETTINGS                20132
#define IDD_HOSTWIZ_INTRO_INVITEES      20133
#define IDD_HOSTWIZ_INVITEES            20134
#define IDD_HOSTWIZ_INTRO_ADVANCED      20135
#define IDD_HOSTWIZ_ADVANCED            20136
#define IDD_HOSTWIZ_INTRO_ACCESS_PRIVS  20137
#define IDD_HOSTWIZ_INTRO_DOCLINK       20138
#define IDD_HOSTWIZ_INTRO_ADVANCED_GENERAL 20139
#define IDD_HOSTWIZ_INTRO_AUTOSHARE     20140
#define ID_CTRL_TAB                     27001
#define ID_CTRL_SHIFT_TAB               27002
#define ID_TOGGLE_FOCUS                 27003
#define IDS_CALL_HELP                   39000
#define IDS_VIEW_HELP                   39001
#define IDS_TOOLS_HELP                  39002
#define IDS_HELP_HELP                   39003
#define IDS_SYSTEM_HELP                 39010
#define IDS_VIDEO_HELP                  39100
#define IDS_MS_ON_WEB_HELP              39202
#define IDS_TBSUBMENU_HELP              39400
#define IDM_FLDR_DROPDOWN               40003
#define ID_TOOLS_RDSWIZARD              40003
#define IDM_VIEW_DATAONLY               40005
#define IDM_VIEW_ONTOP                  40006
#define IDM_VIDEO_GETACAMERA            40009
#define ID_VIEW_STATUSBAR               40010
#define ID_NAV_SHIFT_TAB                40011
#define ID_NAV_TAB                      40012
#define ID_AUTOACCEPT                   40012
#define ID_TOOLS_OPTIONS                40016
#define ID_HELP_HELPTOPICS              40022
#define ID_HELP_ABOUTOPRAH              40023
#define IDM_VIEW_TOOLBAR                40027
#define IDM_VIEW_STATUSBAR              40028
#define IDM_CALL_MEETINGSETTINGS        40031
#define IDM_POPUP_ADDRESSBOOK           40032
#define IDM_POPUP_CANCELGIVECONTROL     40033
#define IDM_POPUP_SPEEDDIAL             40034
#define IDM_POPUP_PROPERTIES            40035
#define IDM_POPUP_GIVECONTROL           40036
#define IDM_VIEW_COMPACT                40037
#define IDM_VIEW_DIALPAD                40039
#define ID_TB_SHARING                   40040
#define ID_TB_CHAT                      40041
#define ID_TB_FILETRANSFER              40042
#define ID_TB_NEWWHITEBOARD             40043
#define ID_TB_WHITEBOARD                40044
#define ID_TOOLS_AUDIOMUTE              40048
#define IDM_EDIT_FIND                   40050
#define IDM_FILE_EXIT                   40052
#define ID_TOOLS_MUTESPEAKER            40056
#define IDM_TBPOPUP_OPEN                40057
#define IDM_TBPOPUP_STOP                40058
#define IDM_VIEW_CALLDLG                40063
#define IDM_FILE_HANGUP                 40064
#define ID_TOOLS_STOPSHARINGPROGRAM     40071
#define ID_TB_NEW_CALL                  40075
#define ID_TB_REDIAL                    40076
#define ID_TB_PICINPIC                  40077
#define ID_TB_DIRECTORY                 40078
#define ID_TB_INCOMING                  40079
#define ID_TB_REJECT                    40080
#define ID_TB_CREDENTIALS               40081
#define ID_TB_AUDIOTUNING               40082
#define ID_TB_SHOWAVTB                  40083
#define ID_TB_DIAL0                     40085
#define ID_TB_DIAL1                     40086
#define ID_TB_DIAL2                     40087
#define ID_TB_DIAL3                     40088
#define ID_TB_DIAL4                     40089
#define ID_TB_DIAL5                     40090
#define ID_TB_DIAL6                     40091
#define ID_TB_DIAL7                     40092
#define ID_TB_DIAL8                     40093
#define ID_TB_DIAL9                     40094
#define ID_TB_DIALSTAR                  40095
#define ID_TB_DIALPOUND                 40096
#define ID_TB_TUNEMIC_LEFT              40102
#define ID_TB_TUNEMIC_CENTER            40103
#define ID_TB_TUNEMIC_RIGHT             40104
#define ID_TB_TUNEMIC_UNMUTE            40105
#define ID_TB_TUNESPEAKER_LEFT          40106
#define ID_TB_TUNESPEAKER_CENTER        40107
#define ID_TB_TUNESPEAKER_RIGHT         40108
#define ID_TB_TUNESPEAKER_UNMUTE        40109
#define ID_TOOLS_SENDFILE               40110
#define ID_TB_PLAYPAUSE                 40111
#define ID_FILE_CONF_HOST               40112
#define ID_TB_HELP                      40113
#define IDM_FILE_DIRECTORY              40119
#define ID_TOOLS_CANCEL_SEND            40125
#define ID_TOOLS_CANCEL_RECEIVE         40126
#define ID_TOOLS_AUDIO_WIZARD           40127
#define ID_PRIVATE_TAB                  40128
#define ID_PRIVATE_SHIFTTAB             40129
#define ID_FILE_CREATE_SPEED_DIAL       40136
#define ID_FILE_DO_NOT_DISTURB          40137
#define IDM_FILE_LAUNCH_WEB_PAGE        40140
#define IDM_FILE_LOGON_ULS              40142
#define ID_PRIVATE_ENTER                40143
#define IDM_POPUP_EJECT                 40172
#define ID_HELP_RELEASE_NOTES           40173
#define IDM_DIRPOPUP_PROPERTIES         40174
#define ID_HELP_WEB_FREE                40175
#define ID_HELP_WEB_NEWS                40176
#define ID_HELP_WEB_FAQ                 40177
#define ID_HELP_WEB_FEEDBACK            40178
#define ID_HELP_WEB_MSHOME              40181
#define ID_HELP_WEB_SUPPORT             40182
#define ID_PRIVATE_UPDATE_UI            40185
#define ID_TOOLS_SENDVIDEO              40211
#define ID_TOOLS_RECEIVEVIDEO           40212
#define ID_TOOLS_UNDOCKLOCAL            40213
#define ID_TOOLS_UNDOCKREMOTE           40214
#define IDM_VIEW_UNDOCKLOCAL            40215
#define IDM_VIEW_UNDOCKREMOTE           40216
#define ID_STOP                         40229
#define ID_TOOLS_ENABLEAPPSHARING       40231
#define ID_FILE_EXIT_ACTIVATERDS        40232
#define IDM_VIDEO_COPY                  40600
#define IDM_VIDEO_FREEZE                40601
#define IDM_VIDEO_ZOOM1                 40603
#define IDM_VIDEO_ZOOM2                 40604
#define IDM_VIDEO_ZOOM3                 40605
#define IDM_VIDEO_ZOOM4                 40606
#define IDM_VIDEO_ALWAYSONTOP           40608
#define IDM_VIDEO_SOURCE                40611
#define IDM_VIDEO_FORMAT                40612
#define IDM_VIDEO_FRAMESIZE1            40617
#define IDM_VIDEO_FRAMESIZE2            40618
#define IDM_VIDEO_FRAMESIZE3            40619
#define IDM_VIDEO_PROPERTIES            40624
#define IDM_VIDEO_HIDE                  40627
#define IDM_VIDEO_DOCK                  40628
#define IDM_VIDEO_PLAY                  40629
#define IDM_VIDEO_PAUSE                 40630
#define IDM_VIDEO_UNDOCK                40631
#define ID_FILE_SAVEAS                  40635
#define IDS_TOOLS_RDSWIZARD_HELP        42003
#define IDS_VIEW_DATAONLY               42005
#define IDS_VIEW_ONTOP                  42006
#define IDS_HELP_GETACAMERA             42008
#define IDS_VIEW_LARGEICONS_HELP        42011
#define IDS_VIEW_DETAILS_HELP           42014
#define IDS_TOOLS_OPTIONS_HELP          42016
#define IDS_HELP_HELPTOPICS_HELP        42022
#define IDS_HELP_ABOUTOPRAH_HELP        42023
#define IDS_VIEW_STATUSBAR_HELP         42028
#define IDS_CALL_MEETINGSETTINGS        42031
#define IDS_POPUP_ADDRESSBOOK           42032
#define IDS_POPUP_CANCELGIVECONTROL     42033
#define IDS_POPUP_SPEEDDIAL             42034
#define IDS_POPUP_PROPERTIES            42035
#define IDS_POPUP_GIVECONTROL           42036
#define IDS_VIEW_COMPACT_HELP           42037
#define IDS_VIEW_DIALPAD_HELP           42039
#define IDS_TB_SHARING                  42040
#define IDS_TB_CHAT                     42041
#define IDS_TB_FILETRANSFER             42042
#define IDS_TB_NEWWHITEBOARD            42043
#define IDS_TB_WHITEBOARD               42044
#define IDS_FILE_EXIT_HELP              42052
#define IDS_VIEW_CALLDLG_HELP           42063
#define IDS_FILE_HANGUP_HELP            42064
#define IDS_FILE_PLACE_CALL_HELP        42067
#define IDS_FILE_NEW_DIALING_SHORTCUT_HELP 42069
#define IDS_FILE_ADVANCED_PLACE_CALL_HELP 42075
#define IDS_TB_PICINPIC                 42077
#define IDS_FILE_CONF_HOST              42112
#define IDS_FILE_CONF_PARTICIPANT       42113
#define IDS_VIEW_AUDIO                  42117
#define IDS_FILE_DIRECTORY              42119
#define IDS_TOOLS_CANCEL_SEND_HELP      42125
#define IDS_TOOLS_CANCEL_RECEIVE_HELP   42126
#define IDS_TOOLS_AUDIO_WIZARD_HELP     42127
#define IDS_FILE_CANCEL_CALL_HELP       42130
#define IDS_FILE_CREATE_SPEED_DIAL      42136
#define IDS_FILE_DO_NOT_DISTURB         42137
#define IDS_FILE_LAUNCH_WEB_PAGE        42140
#define IDS_FILE_ULS                    42142
#define IDS_POPUP_EJECT                 42172
#define IDS_HELP_RELEASE_NOTES          42173
#define IDS_DIRPOPUP_PROPERTIES         42174
#define IDS_HELP_WEB_FREE               42175
#define IDS_HELP_WEB_NEWS               42176
#define IDS_HELP_WEB_FAQ                42177
#define IDS_HELP_WEB_FEEDBACK           42178
#define IDS_HELP_WEB_BEST               42179
#define IDS_HELP_WEB_SEARCH             42180
#define IDS_HELP_WEB_MSHOME             42181
#define IDS_HELP_WEB_SUPPORT            42182
#define IDS_TOOLS_SENDVIDEO_HELP        42211
#define IDS_TOOLS_RECEIVEVIDEO_HELP     42212
#define IDS_TOOLS_UNDOCKLOCAL_HELP      42213
#define IDS_TOOLS_UNDOCKREMOTE_HELP     42214
#define IDS_VIEW_UNDOCKLOCAL_HELP       42215
#define IDS_VIEW_UNDOCKREMOTE_HELP      42216
#define IDS_STOP_HELP                   42229
#define IDS_TOOLS_ENABLEAPPSHARING_HELP 42231
#define IDS_FILE_EXIT_ACTIVATERDS_HELP  42232
#define IDS_CERT_FAILED                 42241
#define IDS_SECURITY_DETAILS            42243
#define IDS_SECURITY_NODETAILS          42244
#define IDS_GENERIC_NMDC_TEXT           42246
#define IDS_VIDEO_ZOOM1                 42603
#define IDS_VIDEO_ZOOM2                 42604
#define IDS_VIDEO_ZOOM3                 42605
#define IDS_VIDEO_ZOOM4                 42606
#define IDS_VIDEO_UNDOCK                42631
#define IDS_COUNTRY_DEFAULT             42990
#define IDS_SIZE_HELP                   61440
#define IDS_MOVE_HELP                   61456
#define IDS_MINIMIZE_HELP               61472
#define IDS_MAXIMIZE_HELP               61488
#define IDS_CLOSE_HELP                  61536
#define IDS_RESTORE_HELP                61728
#define IDS_ATW_PLAYBACK                61729
#define IDS_ATW_PLAYBACK_NOMIX          61730
#define IDS_PLAYBACK_ERROR              61731
#define IDS_PLAYBACK_ERROR2             61732
#define IDS_RECORD_ERROR                61733
#define IDS_TESTBUTTON_TEXT             61734
#define IDS_STOPBUTTON_TEXT             61735
#define IDS_REMOTE_NEW_PASSWORD_INVALID_TEXT 61743
#define IDS_REMOTE_OLD_PASSWORD_WRONG_TEXT 61744
#define IDS_REMOTE_OLD_PASSWORD_WRONG_TITLE 61745
#define IDS_REMOTE_NEW_PASSWORD_WRONG_TEXT 61746
#define IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE 61747
#define IDS_REMOTE_PASSWORD_CHANGED_TEXT 61748
#define IDS_REMOTE_PASSWORD_CHANGED_TITLE 61749
#define IDS_AUTOCONF_SERVERNAME_MISSING 61750
#define IDS_AUTOCONF_FAILED             61751
#define IDS_AUTOCONF_NO_WININET         61752
#define IDS_AUTOCONF_NEED_SETUPAPIS     61753
#define IDS_AUTOCONF_PARSE_ERROR        61754
#define IDS_REMOTE_NEW_PASSWORD_EMPTY   61757
#define IDS_MS_INTERNET_DIRECTORY       61758
#define IDS_ILLEGAL_GK_MODE             61761
#define IDS_ILLEGAL_ACCOUNT             61762
#define IDS_REMOTE_NEW_PASSWORD_LENGTH_TITLE 61763
#define IDS_REMOTE_NEW_PASSWORD_LENGTH_TEXT 61764



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        196
#define _APS_NEXT_COMMAND_VALUE         40013
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\roomlist.cpp ===
// File: roomlist.cpp

#include "precomp.h"
#include "resource.h"
#include "ConfRoom.h"
#include "RoomList.h"
#include "RToolbar.h"
#include "VidView.h"
#include "RostInfo.h"
#include "particip.h"


static const int RL_NUM_ICON_COLUMNS =		0;


/*  C  R O O M  L I S T  V I E W  */
/*-------------------------------------------------------------------------
    %%Function: CRoomListView

-------------------------------------------------------------------------*/
CRoomListView::CRoomListView():
	// m_iSortColumn		(0),
	m_lUserData(0),
	m_fSortAscending	(TRUE)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CRoomListView", this);
}

CRoomListView::~CRoomListView()
{
	ListView_DeleteAllItems(m_hWnd);

	if(IsWindow())
	{
		DestroyWindow();		
	}

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CRoomListView", this);
}

CParticipant * CRoomListView::GetParticipant(void)
{
	LPARAM lParam = GetSelectedLParam();
	return (CParticipant *) lParam;
}

//////////////////////////////////////////////////////////////////////////
// CRoomListView::CView

VOID CRoomListView::Show(BOOL fVisible)
{
	if (NULL != m_hWnd)
	{
		::ShowWindow(m_hWnd, fVisible ? SW_SHOW : SW_HIDE);
	}
}

VOID CRoomListView::ShiftFocus(HWND hwndCur, BOOL fForward)
{
	if ((NULL == hwndCur) && (NULL != m_hWnd))
	{
		::SetFocus(m_hWnd);
	}
}

VOID CRoomListView::Redraw(void)
{
	if (NULL == m_hWnd)
		return;

	// Invalidate entire client area and force erase:
	::InvalidateRect(m_hWnd, NULL, TRUE);

	// Force an immediate repaint:
	::UpdateWindow(m_hWnd);
}

VOID CRoomListView::ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	// Pass all messages to the list view window:
	if (NULL != m_hWnd)
	{
		::SendMessage(m_hWnd, uMsg, wParam, lParam);
	}
}



BOOL CRoomListView::Create(HWND hwndParent)
{
	DBGENTRY(CRoomListView::FCreate);

	RECT rcPos;
	SetRect( &rcPos, 0, 0, 0, 0 );
	DWORD dwStyle = WS_CHILD | WS_TABSTOP | LVS_REPORT | LVS_SINGLESEL | LVS_AUTOARRANGE | LVS_SHAREIMAGELISTS;
	DWORD dwExStyle = WS_EX_CLIENTEDGE;
	
	CWindowImpl<CRoomListView>::Create( hwndParent, rcPos, g_szEmpty, dwStyle, dwExStyle, ID_LISTVIEW );

	if (NULL == m_hWnd)
		return FALSE;

	// initialize the list view window

	// Associate the image list with the list view
	ListView_SetImageList(m_hWnd, g_himlIconSmall, LVSIL_SMALL);

	// Now initialize the columns we will need
	// Initialize the LV_COLUMN structure
	// the mask specifies that the .fmt, .ex, width, and .subitem members
	// of the structure are valid,

	LV_COLUMN lvC;			// List View Column structure
	ClearStruct(&lvC);
	TCHAR pszText[256];		// place to store some text

	lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvC.fmt = LVCFMT_LEFT;

	SIZE size;
	GetDesiredSize(&size);
	int iWidth = size.cx;

	// default width of the non-icon columns (-1 to prevent creating a scrollbar)
	int iIconColWidth = ::GetSystemMetrics(SM_CXSMICON) + 7; // 7 additional pixels
	int iTextColWidth = ((iWidth - (RL_NUM_ICON_COLUMNS * iIconColWidth))
							/ (NUM_COLUMNS - RL_NUM_ICON_COLUMNS)) - 1;
	lvC.pszText = pszText;

	// Add the columns.
    for (int index = 0; index < NUM_COLUMNS; index++)
	{
		HD_ITEM hdi;
		hdi.mask = HDI_IMAGE | HDI_FORMAT;
		hdi.fmt = HDF_IMAGE;
		lvC.iSubItem = index;
		switch (index)
		{
			case COLUMN_INDEX_NAME:
			default:
			{
				// These are text or text&icon columns
				hdi.iImage = -1;
				lvC.cx = iTextColWidth;
				break;
			}
		}
		LoadString(::GetInstanceHandle(),
					IDS_COLUMN_NAME + index,
					pszText,
					CCHMAX(pszText));
		if (-1 != ListView_InsertColumn(m_hWnd, index, &lvC))
		{
			if (-1 != hdi.iImage)
			{
				ASSERT(ListView_GetHeader(m_hWnd));
				Header_SetItem(ListView_GetHeader(m_hWnd), index, &hdi);
			}
		}
		else
		{
			WARNING_OUT(("Could not insert column %d in list view", index));
		}
	}
	ASSERT(ListView_GetHeader(m_hWnd));
	Header_SetImageList(ListView_GetHeader(m_hWnd), g_himlIconSmall);

	// set the style to do drag and drop headers and full row select
	dwExStyle = ListView_GetExtendedListViewStyle(m_hWnd);
	dwExStyle |= (LVS_EX_SUBITEMIMAGES | LVS_EX_HEADERDRAGDROP);
	ListView_SetExtendedListViewStyle(m_hWnd, dwExStyle);
	
	return TRUE;
}

LRESULT CRoomListView::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	int cx = LOWORD(lParam);

	HWND hwndHeader = ListView_GetHeader(m_hWnd);
	if (NULL != hwndHeader)
	{
		// This check is to avoid a RIP in debug windows
		ListView_SetColumnWidth(m_hWnd, 0, cx);
	}

	bHandled = FALSE;
	return(0);
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   Add(int iPosition, LPARAM lParam)
*
*    PURPOSE:  Adds a item to the list view
*
****************************************************************************/

BOOL CRoomListView::Add(int iPosition, CParticipant * pPart)
{
	DebugEntry(CRoomListView::Add);
	BOOL bRet = FALSE;

	int nPrevCount = ListView_GetItemCount(m_hWnd);
	LV_ITEM lvI;        // List view item structure

	// Fill in the LV_ITEM structure
	// The mask specifies the the .pszText, .iImage, .lParam and .state
	// members of the LV_ITEM structure are valid.
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
	lvI.state = (0 == nPrevCount) ? LVIS_FOCUSED : 0;
	lvI.stateMask = LVIS_FOCUSED;
	lvI.iItem = iPosition;
	lvI.iSubItem = 0;

	// The parent window is responsible for storing the text. The List view
	// window will send a LVN_GETDISPINFO when it needs the text to display
	lvI.pszText = LPSTR_TEXTCALLBACK;
	lvI.cchTextMax = MAX_ITEMLEN;
	lvI.iImage = I_IMAGECALLBACK;
	lvI.lParam = (LPARAM) pPart;

	if (-1 != ListView_InsertItem(m_hWnd, &lvI))
	{
		pPart->AddRef(); // the ListView keeps a reference on this

		// set the text for each of the columns for report view
		for (int iSubItem = 1; iSubItem < NUM_COLUMNS; iSubItem++)
		{
			ListView_SetItemText(	m_hWnd,
									iPosition,
									iSubItem,
									LPSTR_TEXTCALLBACK);
		}
		ListView_SortItems( m_hWnd,
							CRoomListView::RoomListViewCompareProc,
							(LPARAM)(this));
	}
	
	DebugExitBOOL(CRoomListView::Add, bRet);
	return bRet;
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   LParamToPos(LPARAM lParam)
*
*    PURPOSE:  Returns the position index associated with the lParam value
*
****************************************************************************/

int CRoomListView::LParamToPos(LPARAM lParam)
{
	// Note: retuns -1 on failure
	
	LV_FINDINFO lvF;
	lvF.flags = LVFI_PARAM;
	lvF.lParam = lParam;

	return ListView_FindItem(m_hWnd, -1, &lvF);
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   GetSelectedLParam()
*
*    PURPOSE:  Returns the lParam of the selected item or NULL (no sel.)
*
****************************************************************************/

LPARAM CRoomListView::GetSelectedLParam()
{
	LPARAM lRet = NULL;

	if (::GetFocus() == m_hWnd)
	{
		// The list view has the focus, so find the selected item (if any)
		int iItem = ListView_GetNextItem(m_hWnd, -1, LVNI_ALL | LVNI_SELECTED);
		if (-1 != iItem)
		{
			LV_ITEM lvi;
			lvi.iItem = iItem;
			lvi.iSubItem = 0;
			lvi.mask = LVIF_PARAM;
			if (ListView_GetItem(m_hWnd, &lvi))
			{
				lRet = lvi.lParam;
			}
		}
	}

	return lRet;
}

/*  R E M O V E  */
/*-------------------------------------------------------------------------
    %%Function: Remove

	Removes an item from the list view
-------------------------------------------------------------------------*/
VOID CRoomListView::Remove(LPARAM lParam)
{
	DBGENTRY(CRoomListView::Remove);

	int iPosition = LParamToPos(lParam);
	if (-1 == iPosition)
		return;

	ListView_DeleteItem(m_hWnd, iPosition);
}


/*  O N  C H A N G E  P A R T I C I P A N T  */
/*-------------------------------------------------------------------------
    %%Function: OnChangeParticipant

    Updates the user's status information
-------------------------------------------------------------------------*/
VOID CRoomListView::OnChangeParticipant(CParticipant * pPart, NM_MEMBER_NOTIFY uNotify)
{
	DBGENTRY(CRoomListView::OnChangeParticipant);


	switch (uNotify)
		{
	case NM_MEMBER_ADDED:
	{
		// Add the new member to the start of the list
		Add(0, pPart);
		break;
	}

	case NM_MEMBER_REMOVED:
	{
		// Remove the member from the list
		Remove((LPARAM) pPart);
		break;
	}

	case NM_MEMBER_UPDATED:
	{
		int iPos = LParamToPos((LPARAM) pPart);
		if (-1 == iPos)
			return;

		ListView_RedrawItems(m_hWnd, iPos, iPos);
		ListView_SortItems(m_hWnd, CRoomListView::RoomListViewCompareProc, (LPARAM)(this));
		break;
	}

	default:
		break;
		}
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   OnNotify(WPARAM, LPARAM)
*
*    PURPOSE:  Handles WM_NOTIFY messages sent to the list view
*
****************************************************************************/

LRESULT	CRoomListView::OnNotify(WPARAM wParam, LPARAM lParam)
{
	LRESULT lRet = 0L;
	
	LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
	ASSERT(pLvdi);
	
	if (ID_LISTVIEW == wParam)
	{
		switch(pLvdi->hdr.code)
		{
			case NM_DBLCLK:
			case NM_RETURN:
			{
				if (0x8000 & ::GetKeyState(VK_MENU))
				{
					::PostMessage(::GetMainWindow(), WM_COMMAND, IDM_POPUP_PROPERTIES, 0);
				}
				break;
			}
			
			case NM_CLICK:
			case NM_RCLICK:
			{
				LV_HITTESTINFO lvhi;
				::GetCursorPos(&(lvhi.pt));
				::MapWindowPoints(NULL, m_hWnd, &(lvhi.pt), 1);
				ListView_SubItemHitTest(m_hWnd, &lvhi);
				if (LVHT_ONITEMICON | lvhi.flags)
				{
					lRet = OnClick(&lvhi, (NM_CLICK == pLvdi->hdr.code));
				}
				break;
			}

			case LVN_DELETEITEM:
			{
				NM_LISTVIEW  * pnmv = (NM_LISTVIEW *) lParam;
				CParticipant * pPart = (CParticipant *) pnmv->lParam;

				ASSERT(pPart);

				if (pPart)
				{
					pPart->Release();
				}

				break;
			}

			case LVN_GETDISPINFO:
			{
				GetDispInfo(pLvdi);
				break;
			}

			case LVN_COLUMNCLICK:
			{
				// The user clicked on one of the column headings - sort by
				// this column.
				TRACE_OUT(("CRoomListView::OnNotify called (NM_COLUMNCLICK)"));
				NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
				ASSERT(pNm);

				if (pNm->iSubItem == m_iSortColumn)
				{
					m_fSortAscending = !m_fSortAscending;
				}
				else
				{
					m_fSortAscending = TRUE;
				}
				// m_iSortColumn = pNm->iSubItem;
				ListView_SortItems( pNm->hdr.hwndFrom,
									CRoomListView::RoomListViewCompareProc,
									(LPARAM)(this));
				break;
			}

			default:
				break;
		}
	}

	return lRet;
}

/*  G E T  D I S P  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: GetDispInfo

    Get the display information for a participant
-------------------------------------------------------------------------*/
VOID CRoomListView::GetDispInfo(LV_DISPINFO * pLvdi)
{
	CParticipant * pPart = (CParticipant *) (pLvdi->item.lParam);
	if (NULL == pPart)
		return;

	// Get the text
	if (pLvdi->item.mask & LVIF_TEXT)
	{
		switch (pLvdi->item.iSubItem)
			{
		case COLUMN_INDEX_NAME:
		{
			lstrcpyn(pLvdi->item.pszText, pPart->GetPszName(), pLvdi->item.cchTextMax);
			break;
		}

		default:
			break;
			}
	}

	// Get the Image
	if (pLvdi->item.mask & LVIF_IMAGE)
	{
		switch (pLvdi->item.iSubItem)
			{
		case COLUMN_INDEX_NAME:
		{
			pLvdi->item.iImage = II_USER;
			break;
		}
		default:
			break;
			}
	}
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   LoadColumnInfo(RegEntry* pre)
*
*    PURPOSE:  Loads the column position info in the registry
*
****************************************************************************/

BOOL CRoomListView::LoadSettings(RegEntry* pre)
{
	DebugEntry(CRoomListView::LoadColumnInfo);

	// BUGBUG georgep: Using a fixed initial width for now; should take a max
	// of longest name and the window width
	ListView_SetColumnWidth(m_hWnd, 0, 300);

	DebugExitBOOL(CRoomListView::LoadColumnInfo, TRUE);
	return TRUE;
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   OnClick(LV_HITTESTINFO*, BOOL)
*
*    PURPOSE:  Handles creating a popup menu when clicking on some icons
*
****************************************************************************/

/*  O N  C L I C K  */
/*-------------------------------------------------------------------------
    %%Function: OnClick

	Handles creating a popup menu when clicking on some icons
-------------------------------------------------------------------------*/
LRESULT CRoomListView::OnClick(LV_HITTESTINFO* plvhi, BOOL fLeftClick)
{
	ASSERT(NULL != plvhi);

	// Select the item:
	ListView_SetItemState(m_hWnd, plvhi->iItem,
			LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

	switch (plvhi->iSubItem)
	{
		case COLUMN_INDEX_NAME:
		{
			if (fLeftClick)
				return 0; // selection
			break;
		}

		default:
			return 0;
	}

	// convert back to screen coords
	::MapWindowPoints(m_hWnd, NULL, &(plvhi->pt), 1);
	OnPopup(plvhi->pt);

	return 1;
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   OnPopup(POINT)
*
*    PURPOSE:  Handles popup menu
*
****************************************************************************/

BOOL CRoomListView::OnPopup(POINT pt)
{
	CParticipant * pPart = GetParticipant();
	if (NULL == pPart)
		return FALSE;
	
	// Get the menu for the popup from the resource file.
	HMENU hMenu = LoadMenu(::GetInstanceHandle(), MAKEINTRESOURCE(IDR_USER_POPUP));
	if (NULL == hMenu)
		return FALSE;

	// Get the first menu in it which we will use for the call to
	// TrackPopup(). This could also have been created on the fly using
	// CreatePopupMenu and then we could have used InsertMenu() or
	// AppendMenu.
	HMENU hMenuTrackPopup = GetSubMenu(hMenu, 0);
	ASSERT(NULL != hMenuTrackPopup);

	::EnableMenuItem(hMenuTrackPopup, IDM_POPUP_SPEEDDIAL,
				pPart->FEnableCmdCreateSpeedDial() ? MF_ENABLED : MF_GRAYED);

	::EnableMenuItem(hMenuTrackPopup, IDM_POPUP_ADDRESSBOOK,
				pPart->FEnableCmdCreateWabEntry() ? MF_ENABLED : MF_GRAYED);

	::EnableMenuItem(hMenuTrackPopup, IDM_POPUP_EJECT,
				pPart->FEnableCmdEject() ? MF_ENABLED : MF_GRAYED);

    // GiveControl/CancelGiveControl()
    pPart->CalcControlCmd(hMenuTrackPopup);


	BOOL fShowMenu = TRUE;
	// Check to see if we have "special" coordinates that signify
	// that we entered here as a result of a keyboard click
	// instead of a mouse click - and if so, get some default coords
	if ((0xFFFF == pt.x) && (0xFFFF == pt.y))
	{
		int iPos = LParamToPos((LPARAM)pPart);
		RECT rctIcon;
		if ((-1 == iPos) ||
			(FALSE == ListView_GetItemRect(	m_hWnd,
											iPos,
											&rctIcon,
											LVIR_ICON)))
		{
			fShowMenu = FALSE;
		}
		else
		{
			// Convert from client coords to screen coords
			::MapWindowPoints(m_hWnd, NULL, (LPPOINT)&rctIcon, 2);
			pt.x = rctIcon.left + ((rctIcon.right - rctIcon.left) / 2);
			pt.y = rctIcon.top + ((rctIcon.bottom - rctIcon.top) / 2);
		}
	}

	if (fShowMenu)
	{
		HWND hwnd = ::GetMainWindow();

		// Draw and track the "floating" popup
		int cmd = TrackPopupMenu(	hMenuTrackPopup,
						TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
						pt.x,
						pt.y,
						0,
						hwnd,
						NULL);

		// Get this again since we just ended a message loop
		pPart = GetParticipant();

		if (0 != cmd && NULL != pPart)
		{
			pPart->OnCommand(hwnd, (WORD)cmd);
		}
	}

	// We are finished with the menu now, so destroy it
	DestroyMenu(hMenu);

	return TRUE;
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   Callback used for sorting the list view
*
****************************************************************************/

int CALLBACK CRoomListView::RoomListViewCompareProc(LPARAM lParam1,
													LPARAM lParam2,
													LPARAM lParamSort)
{
	DebugEntry(RoomListViewCompareProc);

	CParticipant * pPart1 = (CParticipant *)lParam1;
	CParticipant * pPart2 = (CParticipant *)lParam2;

	CRoomListView* prlv = (CRoomListView*) lParamSort;
	ASSERT(prlv);
	int iResult = 0;

	if (pPart1 && pPart2)
	{
		switch (prlv->m_iSortColumn)
		{
			case COLUMN_INDEX_NAME:
			{
				LPTSTR lpStr1 = pPart1->GetPszName();
				LPTSTR lpStr2 = pPart2->GetPszName();
				iResult = lstrcmpi(lpStr1, lpStr2);
				break;
			}

			default:
			{
				ERROR_OUT(("Sorting by unknown label"));
				break;
			}
		}

	}

	if (!prlv->m_fSortAscending)
	{
		iResult = -iResult;
	}
	
	DebugExitINT(RoomListViewCompareProc, iResult);
	return iResult;
}


VOID TileBltWatermark(UINT x, UINT y, UINT cx, UINT cy, UINT xOff, UINT yOff, HDC hdcDst, HDC hdcSrc,
	UINT cxWatermark, UINT cyWatermark)
{
	DBGENTRY(CRoomListView::TileBltWatermark)

	int cxPart, cyPart;
	BOOL fxTile, fyTile;
ReCheck:
	fxTile = ((xOff + cx) > cxWatermark);
	fyTile = ((yOff + cy) > cyWatermark);

	if (!fxTile && !fyTile)
	{
		// no tiling needed -- blt and leave
		BitBlt(hdcDst, x, y, cx, cy, hdcSrc, xOff, yOff, SRCCOPY);
		DBGEXIT(CRoomListView::TileBltWatermark)
		return;
	}

	if (!fxTile)
	{
		// vertically tile
		cyPart = cyWatermark - yOff;
		BitBlt(hdcDst, x, y, cx, cyPart, hdcSrc, xOff, yOff, SRCCOPY);
		y += cyPart;
		cy -= cyPart;
		yOff = 0;
		goto ReCheck;
	}

	if (!fyTile)
	{
		// horizontally tile
		cxPart = cxWatermark - xOff;
		BitBlt(hdcDst, x, y, cxPart, cy, hdcSrc, xOff, yOff, SRCCOPY);
		x += cxPart;
		cx -= cxPart;
		xOff = 0;
		goto ReCheck;
	}

	// tile both ways
	cyPart = cyWatermark - yOff;
	TileBltWatermark(x, y, cx, cyPart, xOff, yOff, hdcDst, hdcSrc, cxWatermark, cyWatermark);
	y += cyPart;
	cy -= cyPart;
	yOff = 0;
	goto ReCheck;
}

void CRoomListView::GetDesiredSize(SIZE *ppt)
{
	// BUGBUG georgep: faking these numbers; should use something dependent on the font size
	ppt->cx = 200;
	ppt->cy = 100;
}


// a quick but simple function to convert the "unicode" characters
// from the H.245 roster info struct to ascii
int Unicode4ToAsciiOEM009(char *szIn, char *szOut)
{
	while (*szIn)
	{
		*szOut = (*szIn) - 4;
		szIn++;
		szOut++;
	}

	*szOut = '\0';
	return 0;

}










=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\roomlist.h ===
// File: roomlist.h

#ifndef _ROOMLIST_H_
#define _ROOMLIST_H_

#include "GenWindow.h"

class CParticipant;

void TileBltWatermark(UINT x, UINT y, UINT cx, UINT cy, UINT xOff, UINT yOff, HDC hdcDst, HDC hdcSrc,
	UINT cxWatermark, UINT cyWatermark);

class CRoomListView : public CWindowImpl<CRoomListView>, public IGenWindow
{
private:
	enum
	{
		COLUMN_INDEX_NAME = 0,
		NUM_COLUMNS
	};

	// Member Variables:
	enum { m_iSortColumn = COLUMN_INDEX_NAME };

	BOOL m_fSortAscending;
	LPARAM m_lUserData;

	LRESULT     OnClick(LV_HITTESTINFO* plvhi, BOOL fLeftClick);

	// static methods
	static int CALLBACK RoomListViewCompareProc(LPARAM lParam1,
												LPARAM lParam2,
												LPARAM lParamSort);
	LPARAM	GetSelectedLParam();
	VOID    GetDispInfo(LV_DISPINFO * pLvdi);
	int		LParamToPos(LPARAM lParam);

	BOOL    Add(int iPosition, CParticipant * pPart);
	VOID    Remove(LPARAM lParam);

public:
	// Methods:
			CRoomListView();
			~CRoomListView();

	// begin IGenWindow interface
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID iid, LPVOID *pObj)
	{ return(E_NOTIMPL); }
	virtual ULONG STDMETHODCALLTYPE AddRef(void) { return(3); }
	virtual ULONG STDMETHODCALLTYPE Release(void) { return(2); }

	virtual void GetDesiredSize(SIZE *ppt);
	virtual HBRUSH GetBackgroundBrush() { return(NULL); }
	virtual HPALETTE GetPalette() { return(NULL); }
	virtual void OnDesiredSizeChanged() {}

	// Get the LPARAM of user data
	virtual LPARAM GetUserData() { return(m_lUserData); }

	// end IGenWindow interface

	void SetUserData(LPARAM lUserData) { m_lUserData = lUserData; }

	// CView
	BOOL    Create(HWND hwndParent);
	VOID    Show(BOOL fVisible);
	VOID    ShiftFocus(HWND hwndCur, BOOL fForward);
	VOID    Redraw(void);
	VOID    SaveSettings(RegEntry * pre) {}
	BOOL	LoadSettings(RegEntry * pre);

	HWND	GetHwnd()       const {return m_hWnd;}
	BOOL	IsChildWindow(HWND hwnd)
			{
				return ((hwnd == m_hWnd) || ::IsChild(m_hWnd, hwnd));
			}

	VOID    ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
	BOOL    OnPopup(POINT pt);

	VOID    OnChangeParticipant(CParticipant * pPart, NM_MEMBER_NOTIFY uNotify);

	CParticipant * GetParticipant();

	// Handlers:
	LRESULT	OnNotify(WPARAM wParam, LPARAM lParam);

//////////////////////////////////
// ATLWin stuff 

	// This is a superclass of a SysListTreeView32
DECLARE_WND_SUPERCLASS(NULL,_T("SysListView32"))

	// Message map
BEGIN_MSG_MAP(CComponentWnd)
	MESSAGE_HANDLER(c_msgFromHandle,OnFromHandle)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
END_MSG_MAP()

private:
		// Message Map Handlers
	LRESULT OnFromHandle(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return(reinterpret_cast<LRESULT>(static_cast<IGenWindow*>(this)));
	}

	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		CGenWindow::SetHotControl(NULL);
		bHandled = FALSE;
		return(0);
	}

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};

#endif // _ROOMLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\rostinfo.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/

//
//	File:		RostInfo.cpp
//	Created:	ChrisPi		6/17/96
//	Modified:
//
//	The CRosterInfo class is implemented, which is used for adding user
//  information to the T.120 roster
//

#include "precomp.h"
#include <RostInfo.h>
#include "confutil.h"

GUID g_csguidRostInfo = GUID_ROSTINFO;

static const HROSTINFO g_cshriEOList = (HROSTINFO)((LONG_PTR)-1);

CRosterInfo::~CRosterInfo()
{
	DebugEntry(CRosterInfo::~CRosterInfo);

	while (FALSE == m_ItemList.IsEmpty())
	{
		PWSTR pwszItem = (PWSTR) m_ItemList.RemoveHead();
		ASSERT(pwszItem);
		delete pwszItem;
	}
	delete m_pvSaveData;

	DebugExitVOID(CRosterInfo::~CRosterInfo);
}

HRESULT CRosterInfo::AddItem(PCWSTR pcwszTag, PCWSTR pcwszData)
{
	DebugEntry(CRosterInfo::AddItem);
	ASSERT(pcwszTag);
	ASSERT(pcwszData);
	HRESULT hr = E_OUTOFMEMORY;

	int nTagLength = lstrlenW(pcwszTag);
	int nDataLength = lstrlenW(pcwszData);

	// +1 for tag sep, +1 for rost info sep
	PWSTR pwszNewItem = new WCHAR[nTagLength + 1 + nDataLength + 1];
	if (NULL != pwszNewItem)
	{
		::CopyMemory(	(PVOID) pwszNewItem,
						pcwszTag,
						sizeof(WCHAR) * nTagLength);
		pwszNewItem[nTagLength] = g_cwchRostInfoTagSeparator;
		::CopyMemory(	(PVOID) &(pwszNewItem[nTagLength + 1]),
						pcwszData,
						sizeof(WCHAR) * nDataLength);
		pwszNewItem[nTagLength + 1 + nDataLength] = g_cwchRostInfoSeparator;
		m_ItemList.AddTail(pwszNewItem);
		hr = S_OK;
	}

	DebugExitHRESULT(CRosterInfo::AddItem, hr);
	return hr;
}

HRESULT CRosterInfo::ExtractItem(	PHROSTINFO phRostInfo,
									PCWSTR pcwszTag,
									LPTSTR pszBuffer,
									UINT cbLength)
{
	DebugEntry(CRosterInfo::ExtractItem);
	ASSERT(pcwszTag);
	HRESULT hr = E_FAIL;
	
	
	POSITION pos;
	if ((NULL == phRostInfo) ||
		(NULL == *phRostInfo))
	{
		pos = m_ItemList.GetHeadPosition();
	}
	else
	{
		pos = *phRostInfo;
	}

	if (g_cshriEOList != pos)
	{
		while (NULL != pos)
		{
			PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
			if (NULL != phRostInfo)
			{
				*phRostInfo = (NULL != pos) ? pos : g_cshriEOList;
			}
			ASSERT(pwszItem);
			int nItemLength = lstrlenW(pwszItem);
			int nTagLength = lstrlenW(pcwszTag);
			
			// NOTE: CRT is used for memcmp
			if ((nItemLength > nTagLength) &&
				(0 == memcmp(	pcwszTag,
								pwszItem,
								sizeof(WCHAR) * nTagLength)) &&
				(g_cwchRostInfoTagSeparator == pwszItem[nTagLength]))
			{
				if (NULL != pszBuffer)
				{
					LPTSTR  szName;
                                   BSTR bstrItem = ::SysAllocString(&pwszItem[nTagLength + 1]);
                                   if(bstrItem)
                                   {
        					hr =  BSTR_to_LPTSTR (&szName,bstrItem);				        
        					if (SUCCEEDED(hr))
        					{    
        						lstrcpyn(pszBuffer, szName, cbLength);
        						delete szName;
        					}
        					SysFreeString(bstrItem);
                                   }
				}

				hr = S_OK;
				break;
			}
		}
	}

	DebugExitHRESULT(CRosterInfo::ExtractItem, hr);
	return hr;
}

HRESULT CRosterInfo::Load(PVOID pData)
{
	DebugEntry(CRosterInfo::Load);
	HRESULT hr = E_FAIL;

	PWSTR pwszUserInfo = (PWSTR) pData;
	if (NULL != pwszUserInfo)
	{
		hr = S_OK;
		while (L'\0' != pwszUserInfo[0])
		{
			// this includes the null terminator
			int nItemLenNT = lstrlenW(pwszUserInfo) + 1;
			PWSTR pwszNewItem = new WCHAR[nItemLenNT];
			if (NULL != pwszNewItem)
			{
				::CopyMemory(	pwszNewItem,
								pwszUserInfo,
								sizeof(WCHAR) * nItemLenNT);
				m_ItemList.AddTail(pwszNewItem);
				// Skip past this item and the n.t.
				pwszUserInfo += nItemLenNT;
			}
			else
			{
				hr = E_OUTOFMEMORY;
				break;
			}
		}
	}
	else
	{
		TRACE_OUT(("CRosterInfo::Load() called with NULL pData"));
	}

	DebugExitHRESULT(CRosterInfo::Load, hr);
	return hr;
}

UINT CRosterInfo::GetSize()
{
	UINT uSize = sizeof(WCHAR); // for last separator

	POSITION pos = m_ItemList.GetHeadPosition();
	while (NULL != pos)
	{
		PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
		ASSERT(pwszItem);
		uSize += sizeof(WCHAR) * (lstrlenW(pwszItem) + 1);
	}

	return uSize;
}

HRESULT CRosterInfo::Save(PVOID* ppvData, PUINT pcbLength)
{
	DebugEntry(CRosterInfo::Save);
	ASSERT(ppvData);
	ASSERT(pcbLength);
	HRESULT hr = E_FAIL;

	*pcbLength = GetSize();
	delete m_pvSaveData;
	m_pvSaveData = new BYTE[*pcbLength];
	if (NULL != m_pvSaveData)
	{
		PWSTR pwszDest = (PWSTR) m_pvSaveData;
		POSITION pos = m_ItemList.GetHeadPosition();
		while (NULL != pos)
		{
			PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
			ASSERT(pwszItem);
			::CopyMemory(	pwszDest,
							pwszItem,
							sizeof(WCHAR) * (lstrlenW(pwszItem) + 1));
			pwszDest += (lstrlenW(pwszItem) + 1);
		}
		int nLastSepPos = (*pcbLength / sizeof(WCHAR)) - 1;
		((PWSTR)m_pvSaveData)[nLastSepPos] = g_cwchRostInfoSeparator;
		*ppvData = m_pvSaveData;
		hr = S_OK;
	}

	DebugExitHRESULT(CRosterInfo::Save, hr);
	return hr;
}

#ifdef DEBUG
VOID CRosterInfo::Dump()
{
	POSITION pos = m_ItemList.GetHeadPosition();
	while (NULL != pos)
	{
		PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
		ASSERT(pwszItem);
		TRACE_OUT(("\t%ls", pwszItem));
	}
}
#endif // DEBUG

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\rtoolbar.h ===
/****************************************************************************
*
*    FILE:     RToolbar.h
*
*    CREATED:  Chris Pirich (ChrisPi) 7-27-95
*
****************************************************************************/

#ifndef _RTOOLBAR_H_
#define _RTOOLBAR_H_

#include "GenContainers.h"
#include "GenControls.h"

#include "ConfRoom.h"
#include "imsconf3.h"
#include "ProgressBar.h"
#include "VidView.h"

// Forward declarations
class CVideoWindow;
class CRoomListView;
class CProgressTrackbar;
class CAudioControl;
class CButton;
class CRosterParent;
class CCallingBar;

// The NetMeeting main ui window
class DECLSPEC_UUID("{00FF7C0C-D831-11d2-9CAE-00C04FB17782}")
CMainUI : public CToolbar,
	public IConferenceChangeHandler,
	public IScrollChange,
	public IVideoChange,
	public IButtonChange
{
public:
	// NMAPP depends on the order of these
	enum CreateViewMode
	{
		CreateFull = 0,
		CreateDataOnly,
		CreatePreviewOnly,
		CreateRemoteOnly,
		CreatePreviewNoPause,
		CreateRemoteNoPause,
		CreateTelephone,
	} ;

	// Methods:
	CMainUI();

	BOOL Create(
		HWND hwndParent,		// The parent window for this one
		CConfRoom *pConfRoom,	// The main conference room class for
								// implementing some features

		CreateViewMode eMode = CreateFull,
		BOOL bEmbedded = FALSE
		);

	// Leaving these for now in case I need them later
	VOID		UpdateButtons() {}
	VOID		ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
	VOID		SaveSettings();

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CMainUI) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CToolbar::QueryInterface(riid, ppv));
	}

	ULONG STDMETHODCALLTYPE AddRef()
	{ return(CToolbar::AddRef()); }
	ULONG STDMETHODCALLTYPE Release()
	{ return(CToolbar::Release()); }

	// IGenWindow stuff
	virtual HBRUSH GetBackgroundBrush();
	virtual HPALETTE GetPalette();

	// IConferenceChangeHandler stuff
	virtual void OnCallStarted();
	virtual void OnCallEnded();

	virtual void OnAudioLevelChange(BOOL fSpeaker, DWORD dwVolume);
	virtual void OnAudioMuteChange(BOOL fSpeaker, BOOL fMute);

	virtual void OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify);
	virtual void OnChangePermissions();

	virtual void OnVideoChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel);

	virtual void StateChange(CVideoWindow *pVideo, NM_VIDEO_STATE uState);

	// Change to/from compact view
	void SetCompact(
		BOOL bCompact	// TRUE if going to compact view
		);
	// Returns TRUE if we are currently in compact view
	BOOL IsCompact() { return(m_eViewMode == ViewCompact); }

	// Change to/from data-only view
	void SetDataOnly(
		BOOL bDataOnly	// TRUE if going to data-only view
		);
	// Returns TRUE if we are currently in compact view
	BOOL IsDataOnly() { return(m_eViewMode == ViewDataOnly); }

	// Change to/from dialing view
	void SetDialing(
		BOOL bDialing	// TRUE if going to dialing view
		);
	// Returns TRUE if we are currently in dialing view
	BOOL IsDialing() { return(m_bDialing != FALSE); }
	// Returns TRUE if you can change dialing mode
	BOOL IsDialingAllowed() { return(m_eViewMode != ViewDataOnly); }

	// Change to/from Picture-in-picture view
	void SetPicInPic(
		BOOL bPicInPic	// TRUE if going to Picture-in-picture view
		);
	// Returns TRUE if we are currently in Picture-in-picture view
	BOOL IsPicInPic() { return(m_bPicInPic != FALSE); }
	// Returns TRUE if you can change Picture-in-picture mode
	BOOL IsPicInPicAllowed();

	// Change to/from compact view
	void SetAudioTuning(
		BOOL bTuning	// TRUE if going to audio tuning view
		);
	// Returns TRUE if we are currently in audio tuning view
	BOOL IsAudioTuning() { return(m_bAudioTuning != FALSE); }

	// Accessor for the local video window
	CVideoWindow* GetLocalVideo() { return(m_pLocalVideo); }
	// Accessor for the remote video window
	CVideoWindow* GetRemoteVideo() { return(m_pRemoteVideo); }
	// Get the roster window
	CRoomListView *GetRoster() const;

	// Init menu items
	void OnInitMenu(HMENU hMenu);
	// Public function for sending commands to this window
	void OnCommand(int id) { OnCommand(GetWindow(), id, NULL, 0); }

	// IScrollChange
	virtual void OnScroll(CProgressTrackbar *pTrackbar, UINT code, int pos);

	// IButtonChange
	virtual void OnClick(CButton *pButton);

	BOOL OnQueryEndSession();
	void OnClose();

	// Get the ConfRoom for this object
	CConfRoom *GetConfRoom() { return(m_pConfRoom); }

	static BOOL NewVideoWindow(CConfRoom *pConfRoom);
	static void CleanUpVideoWindow();

protected:
	virtual ~CMainUI();

	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	enum TempViewMode
	{
		ViewNormal = 0,
		ViewCompact,
		ViewDataOnly,
	} ;

	static CFrame *s_pVideoFrame;

	// Implements some features
	CConfRoom	*m_pConfRoom;
	// The background brush
	HBRUSH m_hbBack;
	// Local video window
	CVideoWindow *m_pLocalVideo;
	// Remote video window
	CVideoWindow *m_pRemoteVideo;
	// Audio output (microphone) level
	CProgressTrackbar * m_pAudioMic;
	// Audio input (speaker) level
	CProgressTrackbar * m_pAudioSpeaker;
	// The roster window
	CRosterParent *m_pRoster;
	// The roster window
	CCallingBar *m_pCalling;
	// The accelerator table for this window
	CTranslateAccelTable *m_pAccel;

	// The current view mode
	TempViewMode m_eViewMode : 4;
	// Whether we are currently in dialing mode
	BOOL m_bDialing : 1;
	// Whether we are currently in audio tuning mode
	BOOL m_bAudioTuning : 1;
	// Whether we are previewing the local video
	BOOL m_bPreviewing : 1;
	// Whether we are showing the PiP window
	BOOL m_bPicInPic : 1;
	// Whether we are currently showing the AV toolbar
	BOOL m_bShowAVTB : 1;
	// Whether anybody changed the view state
	BOOL m_bStateChanged : 1;

	// Creates the calling toolbar
	void CreateDialTB(
		CGenWindow *pParent	// The parent window
		);
	// Creates the "band" with the video window and "data" buttons
	void CreateVideoAndAppsTB(
		CGenWindow *pParent,	// The parent window
		CreateViewMode eMode,			// The view mode
		BOOL bEmbedded
		);
	// Creates the A/V toolbar
	void CreateAVTB(
		CGenWindow *pParent,	// The parent window
		CreateViewMode eMode			// The view mode
		);
	// Creates the answering toolbar
	void CreateCallsTB(
		CGenWindow *pParent	// The parent window
		);
	// Creates the "data" toolbar
	void CreateAppsTB(
		CGenWindow *pParent	// The parent window
		);
	// Creates the video and showAV button
	void CreateVideoAndShowAVTB(
		CGenWindow *pParent	// The parent window
		);
	// Creates the dialing window
	void CreateDialingWindow(
		CGenWindow *pParent	// The parent window
		);
	// Creates the audio-tuning window
	void CreateAudioTuningWindow(
		CGenWindow *pParent	// The parent window
		);

	void CreateRosterArea(
		CGenWindow *pParent,	// The parent window
		CreateViewMode eMode	// The view mode
		);

	// Update the visible state of all the windows
	void UpdateViewState();

public:
	// Change to/from compact view
	void SetShowAVTB(
		BOOL bShow	// TRUE if showing the AV toolbar
		);

	// Returns TRUE if we are currently showing the AV toolbar in compact mode
	BOOL IsShowAVTB() { return(m_bShowAVTB != FALSE); }

	BOOL IsStateChanged() { return(m_bStateChanged != FALSE); }

private:
	// Get the associated audio control object
	CAudioControl *GetAudioControl();

	// Handles some commands and forwards the rest to the parent
	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
	// Timer message for audio levels
	void OnTimer(HWND hwnd, UINT id);
	// Unadvise the IConferenceChangeHandler
	void OnDestroy(HWND hwnd);
	// Roster context menu
	void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);

	// Toggle the mic/speaker mute mode
	void ToggleMute(BOOL bSpeaker);
	// Update the control state to reflect the mute state
	void UpdateMuteState(BOOL bSpeaker, CButton *pButton);
	// Update the state of the Play/Pause button
	BOOL GetPlayPauseState();
	// Update the state of the Play/Pause button
	void UpdatePlayPauseState();
	// Toggle the pause state of all I/O devices
	void TogglePlayPause();
	// Change the audio level by the given percent (up or down)
	void BumpAudio(BOOL bSpeaker, int pct);
	// Set a property on the audio channel
	void SetAudioProperty(BOOL bSpeaker, NM_AUDPROP uID, ULONG uValue);

	// Get the video HWND
	HWND GetVideoWindow(BOOL bLocal);
	// Returns TRUE if you can preview
	BOOL CanPreview();
	// Are we currently in preview mode?
	BOOL IsPreviewing() { return((m_bPreviewing || NULL == GetVideoWindow(FALSE)) && CanPreview()); }
};

// Private structure for defining a button
struct Buttons
{
	int idbStates;		// Bitmap ID for the states
	UINT nInputStates;	// Number of input states in the bitmap
	UINT nCustomStates;	// Number of custom states in the bitmap
	int idCommand;		// Command ID for WM_COMMAND messages
	UINT idTooltip;		// String ID for the tooltip
} ;

// Helper function for adding a bunch of buttons to a parent window
void AddButtons(
	CGenWindow *pParent,			// The parent window
	const Buttons buttons[],		// Array of structures describing the buttons
	int nButtons,					// Number of buttons to create
	BOOL bTranslateColors = TRUE,	// Use system background colors
	CGenWindow *pCreated[] = NULL,	// Created CGenWindow's will be put here
	IButtonChange *pNotify=NULL		// Notification of clicks
	);

#endif // _RTOOLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\rtoolbar.cpp ===
// File: rtoolbar.cpp

#include "precomp.h"

#include "RToolbar.h"
#include "GenContainers.h"
#include "GenControls.h"
#include "Conf.h"
#include "ConfRoom.h"
#include "RoomList.h"
#include "particip.h"
#include "VidView.h"
#include "ProgressBar.h"
#include "AudioCtl.h"
#include "CallingBar.h"
#include "resource.h"
#include "topWindow.h"
#include "dlgCall2.h"
#include "ulswizrd.h"
#include "audiowiz.h"
#include "sdialdlg.h"

#include	"callto.h"

#define ZeroArray(_a) ZeroMemory(_a, sizeof(_a))

void ShiftFocus(HWND hwndTop, BOOL bForward);

class CRemoteVideo : public CVideoWindow
{
public:
	CRemoteVideo(BOOL bEmbedded = FALSE) :
		CVideoWindow(REMOTE, bEmbedded)
	{
	}

	// Stick the child in the lower-right corner of the window
	virtual void Layout()
	{
		CVideoWindow::Layout();

		HWND hwnd = GetWindow();

		HWND hwndLocal = GetFirstChild(hwnd);

		if (NULL != hwndLocal)
		{
			RECT rcRemote;
			GetClientRect(hwnd, &rcRemote);

			int left = rcRemote.right  *5/8;
			int top  = rcRemote.bottom *5/8;

			SetWindowPos(hwndLocal, NULL, left, top,
				rcRemote.right-left, rcRemote.bottom-top, SWP_NOZORDER);
		}
	}
} ;

// This just exists to send WM_NOTIFY messages back to the Roster
class CRosterParent : public CFillWindow
{
private:
	CRoomListView *m_pRoster;

	void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
	{
		POINT pt = { xPos, yPos };

		CRoomListView *pView = GetRoster();
		if ((NULL != pView) && (pView->GetHwnd() == hwndContext))
		{
			pView->OnPopup(pt);
		}

		FORWARD_WM_CONTEXTMENU(hwnd, hwndContext, xPos, yPos, CFillWindow::ProcessMessage);
	}

	inline LRESULT RosterNotify(CRoomListView *pRoster, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		return(pRoster->OnNotify(wParam, lParam));
	}

	// Just forward to the Roster
	LRESULT OnNotify(HWND hwnd, int id, NMHDR *pHdr)
	{
		// pass on all notifications:
		if (ID_LISTVIEW == pHdr->idFrom)
		{
			CRoomListView *pView = GetRoster();
			if (NULL != pView)
			{
				// Forward to the roster
				return(FORWARD_WM_NOTIFY(pView, id, pHdr, RosterNotify));
			}
		}

		return(FORWARD_WM_NOTIFY(hwnd, id, pHdr, CFillWindow::ProcessMessage));
	}


protected:
	~CRosterParent()
	{
		// delete can handle NULL
		delete m_pRoster;
	}

	virtual LRESULT ProcessMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		switch (uMsg)
		{
			HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
			HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);

		case WM_DESTROY:
			delete m_pRoster;
			m_pRoster = NULL;
			break;
		}

		return(CFillWindow::ProcessMessage(hwnd, uMsg, wParam, lParam));
	}

public:
	CRosterParent() : m_pRoster(NULL) {}

	BOOL Create(HWND hwndParent)
	{
		m_pRoster = new CRoomListView();
		if (NULL == m_pRoster)
		{
			return(FALSE);
		}

		if (!CFillWindow::Create(hwndParent, 0))
		{
			return(FALSE);
		}

		return(m_pRoster->Create(GetWindow()));
	}

	CRoomListView *GetRoster() const
	{
		return(m_pRoster);
	}
} ;

CToolbar *CreateToolbar(
	CGenWindow *pParent,
	const Buttons buttons[]=NULL,
	int nButtons=0,
	LPARAM lHideModes=0,
	DWORD dwExStyle=0
	);

#define ReleaseIt(pUnk) if (NULL != (pUnk)) { (pUnk)->Release(); (pUnk) = NULL; }

enum CheckStates
{
	Unchecked = 0,
	Checked = 1,
} ;

const static int MainHMargin = 8;
const static int MainVMargin = 5;
const static int MainGap = 4;

const static int SunkenHMargin = 8;
const static int SunkenVMargin = 2;

const static int ButtonsGap = 12;

const static int AudioMax = 100;
const static int AudioVolMax = 0xffff;
const static int AudioBump = 10;

enum MainTimers
{
	IDT_AUDIO = 1,
} ;

// Set these bits in the hide mode to hide in certain situations
enum HideModes
{
	Inherit			= 0x0000,

	Normal			= 0x0001,
	Compact			= 0x0002,
	DataOnly		= 0x0004,
	NoAVTB			= 0x0008,
	Roster			= 0x0010,
	AudioTuning		= 0x0020,
	Dialing			= 0x0040,
	Receiving		= 0x0080,
	ReceivingWPiP	= 0x0100,
	Previewing		= 0x0200,
	Video			= Receiving|ReceivingWPiP|Previewing,

	Ignore			= 0x4000,
	IfNoChildren	= 0x8000,
} ;

// Sets the hide mode bits on a window
static inline void SetHideModes(CGenWindow *pWin, LPARAM modes)
{
	if (NULL != pWin)
	{
		pWin->SetUserData(modes);
	}
}

// Gets the hide mode bits on a window
static inline LPARAM GetHideModes(IGenWindow *pWin)
{
	return(pWin->GetUserData());
}

CMainUI::CMainUI() :
	m_hbBack(NULL),
	m_eViewMode(ViewNormal),
	m_pLocalVideo(NULL),
	m_pRemoteVideo(NULL),
	m_pAudioMic(NULL),
	m_pAudioSpeaker(NULL),
	m_pRoster(NULL),
	m_pCalling(NULL),
	m_bDialing(FALSE),
	m_bAudioTuning(FALSE),
	m_bPreviewing(TRUE),
	m_bPicInPic(FALSE),
	m_bStateChanged(FALSE),
	m_bShowAVTB(FALSE)
{
}

CMainUI::~CMainUI()
{
	if (NULL != m_hbBack)
	{
		DeleteObject(m_hbBack);
		m_hbBack = NULL;
	}

	ReleaseIt(m_pLocalVideo);
	ReleaseIt(m_pRemoteVideo);
	ReleaseIt(m_pAudioMic);
	ReleaseIt(m_pAudioSpeaker);
	ReleaseIt(m_pRoster);
	ReleaseIt(m_pCalling);
}

void SplitBitmap(UINT nCols, UINT nRows, HBITMAP hbmSrc, HBITMAP hbmDst[])
{
	BITMAP bm;
	GetObject(hbmSrc, sizeof(bm), &bm);
	int nWid = bm.bmWidth  / nCols;
	int nHgt = bm.bmHeight / nRows;

	HDC hdcScreen = GetDC(NULL);
	HDC hdcSrc = CreateCompatibleDC(hdcScreen);
	HDC hdcDst = CreateCompatibleDC(hdcScreen);
	ReleaseDC(NULL, hdcScreen);

	if (NULL != hdcSrc && NULL != hdcDst)
	{
		SelectObject(hdcSrc, hbmSrc);

		for(UINT i=0; i<nRows; ++i)
		{
			for (UINT j=0; j<nCols; ++j)
			{
				HBITMAP hbmTemp = CreateCompatibleBitmap(hdcSrc, nWid, nHgt);
				if (NULL != hbmTemp)
				{
					SelectObject(hdcDst, hbmTemp);
					BitBlt(hdcDst, 0, 0, nWid, nHgt, hdcSrc, j*nWid, i*nHgt, SRCCOPY);
				}
				hbmDst[i*nCols + j] = hbmTemp;
			}
		}
	}

	DeleteDC(hdcSrc);
	DeleteDC(hdcDst);
}

// Helper function for adding a bunch of buttons to a parent window
void AddButtons(
	CGenWindow *pParent,		// The parent window
	const Buttons buttons[],	// Array of structures describing the buttons
	int nButtons,				// Number of buttons to create
	BOOL bTranslateColors,		// Use system background colors
	CGenWindow *pCreated[],		// Created CGenWindow's will be put here
	IButtonChange *pNotify		// Notification of clicks
	)
{
	if (NULL == buttons)
	{
		// Nothing to do
		return;
	}

	HWND hwnd = pParent->GetWindow();

	for (int i=0; i<nButtons; ++i)
	{
		if (NULL != pCreated)
		{
			// Init in case of error
			pCreated[i] = NULL;
		}

		CBitmapButton *pButton;

		pButton = new CBitmapButton();
		if (NULL == pButton)
		{
			continue;
		}

		// Create the actual window
		if (!pButton->Create(hwnd, buttons[i].idCommand, _Module.GetModuleInstance(),
			buttons[i].idbStates, bTranslateColors,
			buttons[i].nInputStates, buttons[i].nCustomStates, pNotify))
		{
			pButton->Release();
			continue;
		}

		// Save off the created button if requested
		if (NULL != pCreated)
		{
			// HACKHACK georgep: Not AddRef'ing; will let caller do that if interested
			pCreated[i] = pButton;
		}

		if (0 != buttons[i].idTooltip)
		{
			USES_RES2T
			pButton->SetTooltip(RES2T(buttons[i].idTooltip));
			pButton->SetWindowtext(RES2T(buttons[i].idTooltip));
		}

		// By default, do not hide individual buttons
		SetHideModes(pButton, Ignore);

		// Release our reference to the button
		pButton->Release();
	}
}

CToolbar *CreateToolbar(
	CGenWindow *pParent,
	const Buttons buttons[],
	int nButtons,
	LPARAM lHideModes,
	DWORD dwExStyle
	)
{
	CToolbar *ret;

	ret = new CToolbar();
	if (NULL == ret)
	{
		return(NULL);
	}
	if (!ret->Create(pParent->GetWindow(), dwExStyle))
	{
		ret->Release();
		return(NULL);
	}

	SetHideModes(ret, lHideModes);
	AddButtons(ret, buttons, nButtons, TRUE);

	return(ret);
}

void CMainUI::CreateDialTB(CGenWindow *pParent)
{
	// Create the toolbar
	m_pCalling = new CCallingBar();
	if (NULL != m_pCalling)
	{
		SetHideModes(m_pCalling, Compact);

		m_pCalling->Create(pParent, m_pConfRoom);

		// m_pCalling->Release();
	}
}

void CMainUI::CreateAppsTB(CGenWindow *pParent)
{
	const static int AppsHMargin = 5;
	const static int AppsVMargin = 0;
	const static int AppsHGap = 11;

	static const Buttons appButtons[] =
	{
		{ IDB_SHARE         , CBitmapButton::Disabled+1, 1, ID_TB_SHARING       , IDS_TT_TB_SHARING       , },
		{ IDB_CHAT          , CBitmapButton::Disabled+1, 1, ID_TB_CHAT          , IDS_TT_TB_CHAT          , },
		{ IDB_WHITEBOARD    , CBitmapButton::Disabled+1, 1, ID_TB_NEWWHITEBOARD , IDS_TT_TB_NEWWHITEBOARD , },
		{ IDB_FILE_TRANSFER , CBitmapButton::Disabled+1, 1, ID_TB_FILETRANSFER  , IDS_TT_TB_FILETRANSFER  , },
	} ;

	// Create the "data" buttons toolbar
	CToolbar *pApps = CreateToolbar(pParent, appButtons, ARRAY_ELEMENTS(appButtons), Compact);
	if (NULL != pApps)
	{
		// HACKHACK georgep: These numbers make it appear about right
		pApps->m_hMargin = AppsHMargin;
		pApps->m_vMargin = AppsVMargin;
		pApps->m_gap = AppsHGap;

		// pApps->m_bMinDesiredSize = TRUE;

		pApps->Release();
	}
}

void CMainUI::CreateVideoAndAppsTB(CGenWindow *pParent, CreateViewMode eMode, BOOL bEmbedded)
{
	CLayeredView::LayoutStyle lVidDialStyle = CLayeredView::Center;

	switch (eMode)
	{
	case CreateFull:
	case CreatePreviewOnly:
	case CreateRemoteOnly:
	case CreateTelephone:
		break;

	case CreatePreviewNoPause:
	case CreateRemoteNoPause:
		lVidDialStyle = CLayeredView::Fill;
		break;

	default:
		return;
	}

	// Create the toolbar
	CBorderWindow *pVideoAndCalling = new CBorderWindow();
	if (NULL != pVideoAndCalling)
	{
		if (pVideoAndCalling->Create(pParent->GetWindow()))
		{
			SetHideModes(pVideoAndCalling, DataOnly);

			pVideoAndCalling->m_hGap = 4;
			pVideoAndCalling->m_vGap = 4;

			// This is the center part of the border window
			CLayeredView *pVidAndDial = new CLayeredView();
			if (NULL != pVidAndDial)
			{
				if (pVidAndDial->Create(pVideoAndCalling->GetWindow()))
				{
					pVideoAndCalling->m_uParts |= CBorderWindow::Center;

					pVidAndDial->m_lStyle = lVidDialStyle;

					CGenWindow *pLocalParent = pVidAndDial;

					if (CreateFull == eMode
						|| CreateTelephone == eMode
						)
					{
						CreateDialingWindow(pVidAndDial);
					}

					if (CreateFull == eMode
						|| CreateRemoteOnly == eMode
						|| CreateRemoteNoPause == eMode
						)
					{
						// Create the remote video window
						m_pRemoteVideo = new CRemoteVideo(bEmbedded);
						if (NULL != m_pRemoteVideo)
						{
							SetHideModes(m_pRemoteVideo, Dialing|Previewing|DataOnly);

							m_pRemoteVideo->Create(pVidAndDial->GetWindow(), GetPalette(), this);

							pLocalParent = m_pRemoteVideo;
						}
					}

					if (CreateFull == eMode
						|| CreatePreviewOnly == eMode
						|| CreatePreviewNoPause == eMode
						)
					{
						// Create the local video window, even though we don't show it yet
						m_pLocalVideo = new CVideoWindow(CVideoWindow::LOCAL, bEmbedded);
						if (NULL != m_pLocalVideo)
						{
							SetHideModes(m_pLocalVideo, Dialing|Receiving|DataOnly);

							m_pLocalVideo->Create(pLocalParent->GetWindow(), GetPalette(), this);
							ShowWindow(m_pLocalVideo->GetWindow(), SW_HIDE);
						}
					}
				}

				pVidAndDial->Release();
			}

			if (CreateFull == eMode
				|| CreateTelephone == eMode
				)
			{
				// create the toolbar
				static const Buttons abOsr2Calling[] =
				{
					{ IDB_DIAL     , CBitmapButton::Disabled+1,    1, ID_TB_NEW_CALL , IDS_TT_TB_NEW_CALL , },
					{ IDB_HANGUP   , CBitmapButton::Disabled+1,    1, IDM_FILE_HANGUP, IDS_TT_FILE_HANGUP, },
					{ IDB_DIRECTORY, CBitmapButton::Disabled+1,    1, ID_TB_DIRECTORY, IDS_TT_TB_DIRECTORY, },
					{ IDB_SHOWAV   , CBitmapButton::Hot+1, Checked+1, ID_TB_SHOWAVTB , IDS_TT_TB_SHOWAVTB , },
				} ;
				CGenWindow *agwOsr2Calling[ARRAY_ELEMENTS(abOsr2Calling)];

				// This is the right-hand part of the border window
				CToolbar *ptbOsr2Calling = CreateToolbar(pVideoAndCalling, NULL, 0, DataOnly);
				if (NULL != ptbOsr2Calling)
				{
					pVideoAndCalling->m_uParts |= CBorderWindow::Right;

					ptbOsr2Calling->m_bVertical = TRUE;
					ptbOsr2Calling->m_nAlignment = Center;

					ZeroArray(agwOsr2Calling);
					AddButtons(ptbOsr2Calling, abOsr2Calling, ARRAY_ELEMENTS(abOsr2Calling),
						TRUE, agwOsr2Calling);

					SetHideModes(agwOsr2Calling[0], Normal);
					SetHideModes(agwOsr2Calling[3], Normal);

					ptbOsr2Calling->m_uRightIndex = 3;

					ptbOsr2Calling->Release();
				}
			}

			// This is the bottom part of the border window
			CreateAVTB(pVideoAndCalling, eMode);
			pVideoAndCalling->m_uParts |= CBorderWindow::Bottom;
		}

		pVideoAndCalling->Release();
	}
}

void CMainUI::CreateAVTB(CGenWindow *pParent, CreateViewMode eMode)
{
	switch (eMode)
	{
	case CreateFull:
	case CreatePreviewOnly:
	case CreateRemoteOnly:
		break;

	default:
		return;
	}

	const static int AVHMargin = 10;
	const static int AVVMargin = 2;
	const static int AVHGap = ButtonsGap;

	// create the toolbar
	static const Buttons avButtons[] =
	{
		{ IDB_PLAYPAUSE, CBitmapButton::Disabled+1,         2, ID_TB_PLAYPAUSE  , IDS_TT_TB_PLAYPAUSE  , },
		{ IDB_PIP      , CBitmapButton::Disabled+1,         1, ID_TB_PICINPIC   , IDS_TT_TB_PICINPIC   , },
		{ IDB_AUDIO    , CBitmapButton::Disabled+1, Checked+1, ID_TB_AUDIOTUNING, IDS_TT_TB_AUDIOTUNING, },
	} ;

	int nButtons = eMode == CreateFull ? ARRAY_ELEMENTS(avButtons) : 1;

	CToolbar *pAV = CreateToolbar(pParent, NULL, 0, NoAVTB|DataOnly);
	if (NULL != pAV)
	{
		CGenWindow *aButtons[ARRAY_ELEMENTS(avButtons)];
		ZeroArray(aButtons);
		AddButtons(pAV, avButtons, nButtons, TRUE, aButtons);

		CGenWindow *pAT;
        
        //
        // If video is completely disabled by policy, disable video buttons
        //
        if (!FIsSendVideoAllowed() && !FIsReceiveVideoAllowed())
        {
            pAT = aButtons[0];
            if (NULL != pAT)
            {
                EnableWindow(pAT->GetWindow(), FALSE);
            }

            pAT = aButtons[1];
            if (NULL != pAT)
            {
                EnableWindow(pAT->GetWindow(), FALSE);
            }
        }

        //
        // If audio is completely disabled by policy, disable audio buttons
        //
        pAT = aButtons[2];
		if (NULL != pAT)
		{
			ASSERT(ID_TB_AUDIOTUNING == GetDlgCtrlID(pAT->GetWindow()));

			if (!FIsAudioAllowed())
			{
				EnableWindow(pAT->GetWindow(), FALSE);
			}
		}

		pAV->m_hMargin = AVHMargin;
		pAV->m_vMargin = AVVMargin;
		pAV->m_gap     = AVHGap;
		pAV->Release();
	}
}

#if FALSE // {
void CMainUI::CreateCallsTB(CGenWindow *pParent)
{
	// create the toolbar
	static const Buttons callsButtons[] =
	{
		{ IDB_INCOMING   , CBitmapButton::Hot+1, 1, ID_TB_INCOMING   , IDS_TT_TB_INCOMING   , },
		{ IDB_HANGUP     , CBitmapButton::Hot+1, 1, IDM_FILE_HANGUP  , IDS_TT_FILE_HANGUP  , },
		{ IDB_CREDENTIALS, CBitmapButton::Hot+1, 1, ID_TB_CREDENTIALS, IDS_TT_TB_CREDENTIALS, },
	} ;

	CToolbar *pCalls = CreateToolbar(pParent, callsButtons, ARRAY_ELEMENTS(callsButtons),
		Compact);
	if (NULL != pCalls)
	{
		pCalls->Release();
	}
}
#endif // FALSE }

void CMainUI::CreateDialingWindow(
	CGenWindow *pParent	// The parent window
	)
{
	const static int DialHMargin = 17;
	const static int DialVMargin = 4;
	const static int DialHGap = 5;
	const static int DialVGap = 0;

	CEdgedWindow *pEdge = new CEdgedWindow();
	if (NULL == pEdge)
	{
		return;
	}
	SetHideModes(pEdge, Video|DataOnly);

	if (pEdge->Create(pParent->GetWindow()))
	{
		CToolbar *pDialing = CreateToolbar(pEdge, NULL, 0, Ignore);
		if (NULL != pDialing)
		{
			pDialing->m_bVertical = TRUE;
			pDialing->m_gap = DialVGap;
			pDialing->m_hMargin = DialHMargin;
			pDialing->m_vMargin = DialVMargin;

			static const Buttons dialButtons[] =
			{
				{ IDB_DIAL1    , CBitmapButton::Hot+1, 1, ID_TB_DIAL1    , IDS_TT_DIALPAD, },
				{ IDB_DIAL2    , CBitmapButton::Hot+1, 1, ID_TB_DIAL2    , IDS_TT_DIALPAD, },
				{ IDB_DIAL3    , CBitmapButton::Hot+1, 1, ID_TB_DIAL3    , IDS_TT_DIALPAD, },
				{ IDB_DIAL4    , CBitmapButton::Hot+1, 1, ID_TB_DIAL4    , IDS_TT_DIALPAD, },
				{ IDB_DIAL5    , CBitmapButton::Hot+1, 1, ID_TB_DIAL5    , IDS_TT_DIALPAD, },
				{ IDB_DIAL6    , CBitmapButton::Hot+1, 1, ID_TB_DIAL6    , IDS_TT_DIALPAD, },
				{ IDB_DIAL7    , CBitmapButton::Hot+1, 1, ID_TB_DIAL7    , IDS_TT_DIALPAD, },
				{ IDB_DIAL8    , CBitmapButton::Hot+1, 1, ID_TB_DIAL8    , IDS_TT_DIALPAD, },
				{ IDB_DIAL9    , CBitmapButton::Hot+1, 1, ID_TB_DIAL9    , IDS_TT_DIALPAD, },
				{ IDB_DIALSTAR , CBitmapButton::Hot+1, 1, ID_TB_DIALSTAR , IDS_TT_DIALPAD, },
				{ IDB_DIAL0    , CBitmapButton::Hot+1, 1, ID_TB_DIAL0    , IDS_TT_DIALPAD, },
				{ IDB_DIALPOUND, CBitmapButton::Hot+1, 1, ID_TB_DIALPOUND, IDS_TT_DIALPAD, },
			} ;

			for (int row=0; row<4; ++row)
			{
				CToolbar *pRowTB = CreateToolbar(pDialing);
				if (NULL != pRowTB)
				{
					pRowTB->m_gap = DialHGap;

					AddButtons(pRowTB, &dialButtons[row*3], 3, TRUE, NULL, this);
					pRowTB->Release();
				}
			}

			pDialing->Release();
		}
	}

	pEdge->Release();
}

// Creates the audio-tuning window
void CMainUI::CreateAudioTuningWindow(
	CGenWindow *pParent	// The parent window
	)
{
	static const int ATHMargin = 8;
	static const int ATVMargin = 6;

	static const int ATControlWidth = 170;

	CToolbar *pATWindow = CreateToolbar(pParent, NULL, 0, NoAVTB|Roster|DataOnly);
	if (NULL != pATWindow)
	{
		USES_RES2T
		pATWindow->m_bVertical = TRUE;
		pATWindow->m_nAlignment = Fill;

		pATWindow->m_gap = MainGap;

		CEdgedWindow *pEdge;

		pEdge = new CEdgedWindow();
		if (NULL != pEdge)
		{
			pEdge->m_hMargin = ATHMargin;
			pEdge->m_vMargin = ATVMargin;

			if (pEdge->Create(pATWindow->GetWindow()))
			{
				SetHideModes(pEdge, Ignore);

				CButton *pButton = new CButton();
				if (NULL != pButton)
				{
					pButton->Create(pEdge->GetWindow(), ID_TB_TUNEMIC_UNMUTE, NULL,
						BS_CHECKBOX|BS_ICON|WS_TABSTOP, this);
					pButton->SetTooltip(RES2T(IDS_TT_MUTE_MIC));
					pButton->SetWindowtext(RES2T(IDS_TT_MUTE_MIC));

					HICON hIcon = reinterpret_cast<HICON>(LoadImage(_Module.GetModuleInstance(),
						MAKEINTRESOURCE(IDI_MICFONE),
						IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
						LR_DEFAULTCOLOR));
					pButton->SetIcon(hIcon);

					pEdge->SetHeader(pButton);

					pButton->Release();
				}
				UpdateMuteState(FALSE, pButton);

				m_pAudioMic = new CProgressTrackbar();
				if (NULL != m_pAudioMic)
				{
					if (m_pAudioMic->Create(pEdge->GetWindow(), 0, this))
					{
						m_pAudioMic->SetTooltip(RES2T(IDS_TT_ADJUST_MIC));
						m_pAudioMic->SetWindowtext(RES2T(IDS_TT_ADJUST_MIC));

						m_pAudioMic->SetMaxValue(AudioMax);

						SIZE size;
						m_pAudioMic->GetDesiredSize(&size);
						size.cx = ATControlWidth;
						m_pAudioMic->SetDesiredSize(&size);
					}

					// m_pAudioMic->Release();
				}
			}

			pEdge->Release();
		}


		pEdge = new CEdgedWindow();
		if (NULL != pEdge)
		{
			pEdge->m_hMargin = ATHMargin;
			pEdge->m_vMargin = ATVMargin;

			if (pEdge->Create(pATWindow->GetWindow()))
			{
				SetHideModes(pEdge, Ignore);

				CButton *pButton = new CButton();
				if (NULL != pButton)
				{
					pButton->Create(pEdge->GetWindow(), ID_TB_TUNESPEAKER_UNMUTE, NULL,
						BS_CHECKBOX|BS_ICON|WS_TABSTOP, this);
					pButton->SetTooltip(RES2T(IDS_TT_MUTE_SPK));
					pButton->SetWindowtext(RES2T(IDS_TT_MUTE_SPK));

					HICON hIcon = reinterpret_cast<HICON>(LoadImage(_Module.GetModuleInstance(),
						MAKEINTRESOURCE(IDI_SPEAKER),
						IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
						LR_DEFAULTCOLOR));
					pButton->SetIcon(hIcon);

					pEdge->SetHeader(pButton);

					pButton->Release();
				}
				UpdateMuteState(TRUE, pButton);

				m_pAudioSpeaker = new CProgressTrackbar();
				if (NULL != m_pAudioSpeaker)
				{
					if (m_pAudioSpeaker->Create(pEdge->GetWindow(), 0, this))
					{
						m_pAudioSpeaker->SetTooltip(RES2T(IDS_TT_ADJUST_SPK));
						m_pAudioSpeaker->SetWindowtext(RES2T(IDS_TT_ADJUST_SPK));

						m_pAudioSpeaker->SetMaxValue(AudioMax);

						SIZE size;
						m_pAudioSpeaker->GetDesiredSize(&size);
						size.cx = ATControlWidth;
						m_pAudioSpeaker->SetDesiredSize(&size);
					}

					// m_pAudioSpeaker->Release();
				}
			}

			pEdge->Release();
		}

		pATWindow->Release();
	}

	CAudioControl *pAudioControl = GetAudioControl();
	if (NULL != pAudioControl)
	{
		// Force an update of the controls
		OnAudioLevelChange(TRUE , pAudioControl->GetSpeakerVolume());
		OnAudioLevelChange(FALSE, pAudioControl->GetRecorderVolume());
	}
}

void CMainUI::CreateRosterArea(CGenWindow *pParent, CreateViewMode eMode)
{
	switch (eMode)
	{
	case CreateFull:
	case CreateDataOnly:
	case CreateTelephone:
		break;

	default:
		return;
	}

	CLayeredView *pView = new CLayeredView();
	if (NULL == pView)
	{
		// Pretty bad
		return;
	}

	if (pView->Create(pParent->GetWindow()))
	{
		SetHideModes(pView, IfNoChildren);

		pView->m_lStyle = CLayeredView::Fill;

		if (eMode != CreateDataOnly)
		{
			CreateAudioTuningWindow(pView);
		}

		if (eMode != CreateTelephone)
		{
			CToolbar *pRosterAndCall = CreateToolbar(pView);
			if (NULL != pRosterAndCall)
			{
				pRosterAndCall->m_nAlignment = CToolbar::Fill;

				m_pRoster = new CRosterParent();
				if (NULL != m_pRoster)
				{
					m_pRoster->Create(pRosterAndCall->GetWindow());

					// HACKHACK georgep: Just calling SetUserData directly for now
					SetHideModes(m_pRoster, Compact|AudioTuning);
				}

				if (CreateDataOnly != eMode)
				{
					CToolbar *pCalling = CreateToolbar(pRosterAndCall);
					if (NULL != pCalling)
					{
						SetHideModes(pCalling, Normal|Compact);

						pCalling->m_bVertical = TRUE;

						static const Buttons abCalling[] =
						{
							{ IDB_HANGUP   , CBitmapButton::Disabled+1, 1, IDM_FILE_HANGUP, IDS_TT_FILE_HANGUP, },
							{ IDB_DIRECTORY, CBitmapButton::Disabled+1, 1, ID_TB_DIRECTORY, IDS_TT_TB_DIRECTORY, },
						} ;
						AddButtons(pCalling, abCalling, ARRAY_ELEMENTS(abCalling),
							TRUE, NULL, this);

						pCalling->Release();
					}
				}

				pRosterAndCall->m_uRightIndex = 1;
				pRosterAndCall->m_bHasCenterChild = TRUE;

				pRosterAndCall->Release();
			}
		}
	}

	pView->Release();
}

BOOL CMainUI::Create(
	HWND hwndParent,
	CConfRoom *pConfRoom,
	CreateViewMode eMode,
	BOOL bEmbedded
	)
{
	// Store this away so we can call some methods in it later
	m_pConfRoom = pConfRoom;
	ASSERT(m_pConfRoom);

	if (NULL == m_pConfRoom)
	{
		return(FALSE);
	}

	// Create the window
	if (!CToolbar::Create(hwndParent))
	{
		return(FALSE);
	}

	// Try to remain a little bit abstract
	CToolbar *pMain = this;

	m_pConfRoom->AddConferenceChangeHandler(this);

	// A vertical toolbar that fills all its area
	pMain->m_hMargin = MainHMargin;
	pMain->m_vMargin = MainVMargin;
	pMain->m_gap     = MainGap;

	if (CreateRemoteNoPause == eMode
		|| CreatePreviewNoPause == eMode
		)
	{
		pMain->m_hMargin = 0;
		pMain->m_vMargin = 0;

		pMain->m_bHasCenterChild = TRUE;

		//HACKHACK This only works because all these views have only 1 window
		pMain->m_uRightIndex = 1;
	}

	pMain->m_bVertical = TRUE;
	pMain->m_nAlignment = Fill;

	m_hbBack = CGenWindow::GetStandardBrush();

	// Create all the sub toolbars
	if (CreateFull == eMode
		|| CreateTelephone == eMode
		)
	{
		CreateDialTB(pMain);
	}

	CreateVideoAndAppsTB(pMain, eMode, bEmbedded);
	CreateRosterArea(pMain, eMode);

	if (CreateFull == eMode
		|| CreateDataOnly == eMode
		)
	{
		CreateAppsTB(pMain);
	}

	// Now we need to update to the current state of the conference
	if (m_pConfRoom->FIsConferenceActive())
	{
		OnCallStarted();

		CSimpleArray<CParticipant*>& lMembers = m_pConfRoom->GetParticipantList();
		for (int i=lMembers.GetSize()-1; i>=0; --i)
		{
			OnChangeParticipant(lMembers[i], NM_MEMBER_ADDED);
		}

		// Need to tell everybody what the active channels are
		INmConference2 *pNmConf = m_pConfRoom->GetActiveConference();
		if (NULL != pNmConf)
		{
			// Just in case
			pNmConf->AddRef();

			IEnumNmChannel *pEnumCh;
			if (SUCCEEDED(pNmConf->EnumChannel(&pEnumCh)))
			{
				INmChannel *pChannel;
				ULONG uGot;
				while (S_OK == pEnumCh->Next(1, &pChannel, &uGot) && 1 == uGot)
				{
					OnVideoChannelChanged(NM_CHANNEL_ADDED, pChannel);
					pChannel->Release();
				}

				pEnumCh->Release();
			}

			pNmConf->Release();
		}
	}

	if (CreateDataOnly == eMode)
	{
		SetDataOnly(TRUE);
	}

	if (CreateTelephone == eMode)
	{
		SetDialing(TRUE);
		SetAudioTuning(TRUE);
	}

	OnChangePermissions();

	UpdateViewState();

	UpdatePlayPauseState();

	return(TRUE);
}

HBRUSH CMainUI::GetBackgroundBrush()
{
	return(m_hbBack);
}

// REVIEW georgep: Should this loop until it gets an IGenWindow?
HPALETTE CMainUI::GetPalette()
{
	return(m_pConfRoom->GetPalette());
}

// Recursive function to hide/show windows for the current view
// Returns whether any of the children are visible
BOOL ShowWindows(
	HWND hwndParent,	// The parent window to start from
	LPARAM lDefMode,	// The hide mode to use if Inherit
	LPARAM hideMode		// The current hide mode
	)
{
	BOOL bRet = FALSE;

	for (HWND hwndChild=::GetWindow(hwndParent, GW_CHILD); NULL!=hwndChild;
		hwndChild=::GetWindow(hwndChild, GW_HWNDNEXT))
	{
		IGenWindow *pChild = IGenWindow::FromHandle(hwndChild);
		if (NULL == pChild)
		{
			continue;
		}

		LPARAM lMode = GetHideModes(pChild);
		if (Ignore == lMode)
		{
			if ((GetWindowStyle(hwndChild)&WS_VISIBLE) != 0)
			{
				bRet = TRUE;
			}

			continue;
		}
		if (Inherit == lMode)
		{
			lMode = lDefMode;
		}

		// recurse to child windows first to avoid flicker
		LPARAM lNoChildren = ShowWindows(hwndChild, lMode, hideMode) ? 0 : IfNoChildren;

		// If any of the hide mode bits are set, then hide the window
		// otherwise show it
		BOOL bShow = ((lMode&(hideMode|lNoChildren)) == 0);
		if (bShow)
		{
			bRet = TRUE;
		}

		ShowWindow(hwndChild, bShow ? SW_SHOW : SW_HIDE);
	}

	return(bRet);
}

BOOL CMainUI::CanPreview()
{
	HWND hwndLocal = GetVideoWindow(TRUE);

	return(NULL!=hwndLocal && GetLocalVideo()->IsXferAllowed());
}

void CMainUI::UpdateViewState()
{
	// Put together all the modes we ARE in, and hide any windows that want
	// to be hidden while in one of those modes
	// The default mode
	LPARAM hideModes;

	if (IsCompact())
	{
		hideModes = Compact;

		if (!IsShowAVTB())
		{
			hideModes |= NoAVTB;
		}
	}
	else if (IsDataOnly())
	{
		hideModes = DataOnly;
	}
	else
	{
		hideModes = Normal;
	}

	if (IsDialing())
	{
		hideModes |= Dialing;
	}
	else
	{
		// hwndRemote will be NULL for PreviewOnly mode
		HWND hwndRemote = GetVideoWindow(FALSE);
		if (NULL == hwndRemote)
		{
			hideModes |= Previewing;
		}
		else
		{
			HWND hwndLocal = GetVideoWindow(TRUE);

			BOOL bPreviewing = IsPreviewing();

			HWND parent = NULL;
			BOOL bZoomable;
			LONG style = GetWindowLong(hwndLocal, GWL_EXSTYLE);
			if (bPreviewing)
			{
				hideModes |= Previewing;
				parent = GetParent(hwndRemote);
				style |= WS_EX_CLIENTEDGE;
				bZoomable = TRUE;
			}
			else
			{
				hideModes |= (m_bPicInPic && CanPreview()) ? ReceivingWPiP : Receiving;
				parent = hwndRemote;
				style &= ~WS_EX_CLIENTEDGE;
				bZoomable = FALSE;
			}

			if (GetParent(hwndLocal) != parent)
			{
				SetWindowLong(hwndLocal, GWL_EXSTYLE, style);
				SetParent(hwndLocal, parent);
				SetWindowPos(hwndLocal, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);

				CVideoWindow *pVideo = GetLocalVideo();
				if (NULL != pVideo)
				{
					pVideo->SetZoomable(bZoomable);
				}
			}
		}
	}

	// Enable/disable the PiP window
	IGenWindow *pPiP = FindControl(ID_TB_PICINPIC);
	if (NULL != pPiP)
	{
		CComPtr<CGenWindow> spButton = com_cast<CGenWindow>(pPiP);

		BOOL bEnable = !IsPreviewing() && CanPreview() && !IsDialing();
		EnableWindow(spButton->GetWindow(), bEnable);
	}

	hideModes |= IsAudioTuning() && !IsDataOnly() ? AudioTuning : Roster;

	HWND hwnd = GetWindow();

	ShowWindows(hwnd, 0, hideModes);

	// If the focus is on a child window which is now not visible, but we are,
	// then change the focus to this window
	if (!IsWindowVisible(GetFocus()) && IsWindowActive(hwnd) && IsWindowVisible(hwnd))
	{
		SetFocus(hwnd);
	}

	IGenWindow *pButton = FindControl(ID_TB_AUDIOTUNING);
	CComPtr<CBitmapButton> spButton = com_cast<CBitmapButton>(pButton);
	if (spButton)
	{
		BOOL bAudioTuning = IsAudioTuning() && !IsCompact();
		spButton->SetCustomState(bAudioTuning ? Checked : Unchecked);
		USES_RES2T
		spButton->SetTooltip(RES2T(bAudioTuning ? IDS_TT_TB_SHOWROSTER : IDS_TT_TB_AUDIOTUNING));
		spButton->SetWindowtext(RES2T(bAudioTuning ? IDS_TT_TB_SHOWROSTER : IDS_TT_TB_AUDIOTUNING));
	}

	OnDesiredSizeChanged();
}

void CMainUI::SetCompact(BOOL bCompact)
{
	bCompact = bCompact != FALSE;
	if (IsCompact() == bCompact)
	{
		// Nothing to do
		return;
	}

	m_eViewMode = bCompact ? ViewCompact : ViewNormal;

	UpdateViewState();
}

void CMainUI::SetDataOnly(BOOL bDataOnly)
{
	bDataOnly = bDataOnly != FALSE;
	if (IsDataOnly() == bDataOnly)
	{
		// Nothing to do
		return;
	}

	m_eViewMode = bDataOnly ? ViewDataOnly : ViewNormal;

	UpdateViewState();
}

void CMainUI::SetDialing(BOOL bDialing)
{
	bDialing = bDialing != FALSE;
	if (IsDialing() == bDialing)
	{
		// Nothing to do
		return;
	}

	m_bDialing = bDialing;

	UpdateViewState();
}

void CMainUI::SetPicInPic(BOOL bPicInPic)
{
	bPicInPic = bPicInPic != FALSE;
	if (IsPicInPic() == bPicInPic)
	{
		// Nothing to do
		return;
	}

	m_bPicInPic = bPicInPic;

	UpdateViewState();
}

BOOL CMainUI::IsPicInPicAllowed()
{
	return(!IsDataOnly() && !m_bPreviewing && CanPreview());
}

void CMainUI::SetAudioTuning(BOOL bAudioTuning)
{
	if ((IsAudioTuning() && bAudioTuning) || (!IsAudioTuning() && !bAudioTuning))
	{
		// Nothing to do
		return;
	}

	m_bAudioTuning = bAudioTuning;

	if (IsAudioTuning())
	{
		SetTimer(GetWindow(), IDT_AUDIO, AUDIODLG_MIC_TIMER_PERIOD, NULL);
	}
	else
	{
		KillTimer(GetWindow(), IDT_AUDIO);
	}

	UpdateViewState();
}

void CMainUI::SetShowAVTB(BOOL bShowAVTB)
{
	if ((IsShowAVTB() && bShowAVTB) || (!IsShowAVTB() && !bShowAVTB))
	{
		// Nothing to do
		return;
	}

	m_bShowAVTB = bShowAVTB;

	UpdateViewState();
}

LRESULT CMainUI::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	static const UINT c_uMsgMSWheel = ::IsWindowsNT() ? WM_MOUSEWHEEL :
						::RegisterWindowMessage(_TEXT("MSWHEEL_ROLLMSG"));

	switch (message)
	{
		HANDLE_MSG(hwnd, WM_TIMER      , OnTimer);
		HANDLE_MSG(hwnd, WM_DESTROY    , OnDestroy);

	case WM_CREATE:
	{
		// Allow dialog-like keyboard support
		HACCEL hAccel = LoadAccelerators(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_MAINUI));
		if (NULL != hAccel)
		{
			m_pAccel = new CTranslateAccelTable(hwnd, hAccel);
			if (NULL != m_pAccel)
			{
				AddTranslateAccelerator(m_pAccel);
			}
		}
		break;
	}

	case WM_SETFOCUS:
		ShiftFocus(GetWindow(), TRUE);
		break;

	default:
		if (message == c_uMsgMSWheel)
		{
			CRoomListView *pView = GetRoster();
			if (NULL != pView)
			{
				::SendMessage(pView->GetHwnd(), message, wParam, lParam);
			}
			break;
		}

		break;
	}

	return(CToolbar::ProcessMessage(hwnd, message, wParam, lParam));
}

void CMainUI::OnScroll(CProgressTrackbar *pTrackbar, UINT code, int pos)
{
	BOOL bSpeaker = FALSE;

	if (m_pAudioSpeaker == pTrackbar)
	{
		bSpeaker = TRUE;
	}
	else if (m_pAudioMic == pTrackbar)
	{
	}
	else
	{
		// I don't think we should get here
		return;
	}

	// Can't trust the pos passed in
	pos = pTrackbar->GetTrackValue();

	CAudioControl *pAudioControl = GetAudioControl();
	if (NULL == pAudioControl)
	{
		return;
	}

	DWORD dwVolume = (pos*AudioVolMax + AudioMax/2)/AudioMax;
	dwVolume = min(max(dwVolume, 0), AudioVolMax);

	if (bSpeaker)
	{
		pAudioControl->SetSpeakerVolume(dwVolume);
	}
	else
	{
		pAudioControl->SetRecorderVolume(dwVolume);
	}
}

HWND CMainUI::GetVideoWindow(BOOL bLocal)
{
	CVideoWindow *pVideo = bLocal ? GetLocalVideo() : GetRemoteVideo();
	return(NULL == pVideo ? NULL : pVideo->GetWindow());
}

void CMainUI::ToggleMute(BOOL bSpeaker)
{
	CAudioControl *pAudioControl = GetAudioControl();
	if (NULL != pAudioControl)
	{
		BOOL bMuted = bSpeaker ? pAudioControl->IsSpkMuted() : pAudioControl->IsRecMuted();
		pAudioControl->MuteAudio(bSpeaker, !bMuted);
	}
}

void CMainUI::UpdateMuteState(BOOL bSpeaker, CButton *pButton)
{
	CAudioControl *pAudioControl = GetAudioControl();
	if (NULL != pAudioControl)
	{
		BOOL bMuted = bSpeaker ? pAudioControl->IsSpkMuted() : pAudioControl->IsRecMuted();

		pButton->SetChecked(!bMuted);
	}
}

void CMainUI::BumpAudio(BOOL bSpeaker, int pct)
{
	CAudioControl *pAudioControl = GetAudioControl();
	if (NULL != pAudioControl)
	{
		int dwVolume = static_cast<int>(bSpeaker ?
			pAudioControl->GetSpeakerVolume() : pAudioControl->GetRecorderVolume());
		dwVolume += (pct*AudioVolMax/100);
		dwVolume = min(max(dwVolume, 0), AudioVolMax);

		if (bSpeaker)
		{
			pAudioControl->SetSpeakerVolume(dwVolume);
		}
		else
		{
			pAudioControl->SetRecorderVolume(dwVolume);
		}
	}
}

void CMainUI::SetAudioProperty(BOOL bSpeaker, NM_AUDPROP uID, ULONG uValue)
{
	CAudioControl *pAudioControl = GetAudioControl();
	if (NULL != pAudioControl)
	{
		pAudioControl->SetProperty(bSpeaker, uID, uValue);
	}
}

// IButtonChange
void CMainUI::OnClick(CButton *pButton)
{
	HWND hwndCtl = pButton->GetWindow();

	OnCommand(GetWindow(), GetWindowLong(hwndCtl, GWL_ID), hwndCtl, BN_CLICKED);
}

void CMainUI::OnInitMenu(HMENU hMenu)
{
	CVideoWindow *pVideo = IsPreviewing() ? GetLocalVideo() : GetRemoteVideo();
	if (NULL != pVideo)
	{
		pVideo->UpdateVideoMenu(hMenu);

		pVideo = GetLocalVideo();
		EnableMenuItem(hMenu, IDM_VIDEO_UNDOCK,
			MF_BYCOMMAND|(NULL != pVideo && pVideo->IsXferAllowed() ? MF_ENABLED : MF_GRAYED|MF_DISABLED));
	}
}

static void AppendText(CCallingBar *pCalling, TCHAR cAdd)
{
	if (NULL != pCalling)
	{
		// I don't want to change a string that you can't see
		if (IsWindowVisible(pCalling->GetWindow()))
		{
			TCHAR szText[] = TEXT("0");
			szText[0] = cAdd;

			TCHAR szTemp[MAX_PATH];

			int nLen = pCalling->GetText(szTemp, ARRAY_ELEMENTS(szTemp));
			if (nLen + lstrlen(szText) <= ARRAY_ELEMENTS(szTemp) - 1)
			{
				lstrcat(szTemp, szText);
				pCalling->SetText(szTemp);
			}
		}
	}
}

void CMainUI::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	switch (id)
	{
	case ID_NAV_TAB:
		ShiftFocus(hwnd, TRUE);
		break;

	case ID_NAV_SHIFT_TAB:
		ShiftFocus(hwnd, FALSE);
		break;

	case IDM_VIEW_DIALPAD:
		SetDialing(!IsDialing());
		break;

	case ID_TB_PICINPIC:
		SetPicInPic(!IsPicInPic());
		break;

	case ID_TB_REJECT:
	case ID_TB_CREDENTIALS:
		break;

	case ID_TB_AUDIOTUNING:
	{
		m_bStateChanged = TRUE;

		SetAudioTuning(!IsAudioTuning());
		break;
	}

	case ID_TB_SHOWAVTB:
	{
		m_bStateChanged = TRUE;

		SetShowAVTB(!IsShowAVTB());

		if( 0 == hwndCtl )
			break;

		CComPtr<CBitmapButton> spButton = com_cast<CBitmapButton>(IGenWindow::FromHandle(hwndCtl));
		if (spButton)
		{
			BOOL bShow = IsShowAVTB();

			spButton->SetCustomState(bShow ? Checked : Unchecked);
			USES_RES2T
			spButton->SetTooltip(RES2T(bShow ? IDS_TT_TB_HIDEAVTB : IDS_TT_TB_SHOWAVTB));
			spButton->SetWindowtext(RES2T(bShow ? IDS_TT_TB_HIDEAVTB : IDS_TT_TB_SHOWAVTB));
		}
		break;
	}

	case ID_TB_TUNEMIC_UNMUTE:
		ToggleMute(FALSE);
		break;

	case ID_TB_TUNESPEAKER_UNMUTE:
		ToggleMute(TRUE);
		break;

	case ID_TB_DIAL0:
	case ID_TB_DIAL1:
	case ID_TB_DIAL2:
	case ID_TB_DIAL3:
	case ID_TB_DIAL4:
	case ID_TB_DIAL5:
	case ID_TB_DIAL6:
	case ID_TB_DIAL7:
	case ID_TB_DIAL8:
	case ID_TB_DIAL9:
		SetAudioProperty(FALSE, NM_AUDPROP_DTMF_DIGIT, id-ID_TB_DIAL0);
		AppendText(m_pCalling, '0'+id-ID_TB_DIAL0);
		break;

	case ID_TB_DIALSTAR:
		SetAudioProperty(FALSE, NM_AUDPROP_DTMF_DIGIT, 10);
		AppendText(m_pCalling, '*');
		break;

	case ID_TB_DIALPOUND:
		SetAudioProperty(FALSE, NM_AUDPROP_DTMF_DIGIT, 11);
		AppendText(m_pCalling, '#');
		break;

	case ID_TB_DIRECTORY:
	{
		CFindSomeone::findSomeone(m_pConfRoom);
	}
	break;

	case ID_TB_PLAYPAUSE:
		TogglePlayPause();
		break;

	case IDM_VIDEO_ZOOM1:
	case IDM_VIDEO_ZOOM2:
	case IDM_VIDEO_ZOOM3:
	case IDM_VIDEO_ZOOM4:
	case IDM_VIDEO_UNDOCK:
	case IDM_VIDEO_GETACAMERA:
	{
		CVideoWindow *pVideo = IsPreviewing() ? GetLocalVideo() : GetRemoteVideo();
		if (NULL != pVideo)
		{
			pVideo->OnCommand(id);
		}
		break;
	}

	case IDM_POPUP_EJECT:
	case IDM_POPUP_PROPERTIES:
	case IDM_POPUP_SPEEDDIAL:
	case IDM_POPUP_ADDRESSBOOK:
    case IDM_POPUP_GIVECONTROL:
    case IDM_POPUP_CANCELGIVECONTROL:
	{
		CRoomListView *pView = GetRoster();
		if (NULL != pView)
		{
			CParticipant * pPart = pView->GetParticipant();
			if (NULL != pPart)
			{
				pPart->OnCommand(hwnd, (WORD)id);
			}
		}
		break;
	}

	case ID_FILE_CREATE_SPEED_DIAL:
	{
		TCHAR szAddress[MAX_EMAIL_NAME_LENGTH + MAX_SERVER_NAME_LENGTH + 1];
		LPCTSTR pszAddress = NULL;
		CRoomListView *pView = GetRoster();
		if (NULL != pView)
		{
			CParticipant * pPart = pView->GetParticipant();
			if (NULL != pPart)
			{
				if (S_OK == pPart->GetUlsAddr(szAddress, CCHMAX(szAddress)))
				{
					pszAddress = szAddress;
				}
			}
		}

		CSpeedDialDlg sdd(hwnd, NM_ADDR_ULS);
		sdd.DoModal(pszAddress);
		break;
	}

	case ID_TB_CHAT:
	case ID_TB_NEWWHITEBOARD:
    case ID_TB_SHARING:
	case ID_TB_NEW_CALL:
	default:
		m_pConfRoom->OnCommand(hwnd, id, hwndCtl, codeNotify);
		break;
	}
}

void CMainUI::OnDestroy(HWND hwnd)
{
	if (NULL != m_pConfRoom)
	{
		m_pConfRoom->RemoveConferenceChangeHandler(this);
	}

	if (NULL != m_pAccel)
	{
		RemoveTranslateAccelerator(m_pAccel);
		m_pAccel->Release();
		m_pAccel = NULL;
	}
}

BOOL CMainUI::OnQueryEndSession()
{
	CMainUI::OnClose();

	return(TRUE);
}

void CMainUI::OnClose()
{
	CVideoWindow *pLocal = GetLocalVideo();
	if (NULL != pLocal)
	{
		pLocal->Pause(TRUE);
	}
}

VOID CMainUI::SaveSettings()
{
	CVideoWindow *pVideo;
	pVideo = GetLocalVideo();
	if (NULL != pVideo)
	{
		pVideo->SaveSettings();
	}
	pVideo = GetRemoteVideo();
	if (NULL != pVideo)
	{
		pVideo->SaveSettings();
	}
}

VOID CMainUI::ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CVideoWindow *pVideo;
	pVideo = GetLocalVideo();
	if (NULL != pVideo)
	{
		pVideo->ForwardSysChangeMsg(uMsg, wParam, lParam);
	}
	pVideo = GetRemoteVideo();
	if (NULL != pVideo)
	{
		pVideo->ForwardSysChangeMsg(uMsg, wParam, lParam);
	}

	CRoomListView *pView = GetRoster();
	if (NULL != pView)
	{
		pView->ForwardSysChangeMsg(uMsg, wParam, lParam);
	}

	switch (uMsg)
	{
	case WM_PALETTECHANGED:
		::RedrawWindow(GetWindow(), NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
		break;
	}
}

void CMainUI::OnTimer(HWND hwnd, UINT id)
{
	if (IDT_AUDIO == id)
	{
		CAudioControl *pAudioControl = GetAudioControl();
		if (NULL != pAudioControl)
		{
			DWORD dwLevel;

			dwLevel = pAudioControl->GetAudioSignalLevel(FALSE /*fSpeaker*/);	// This level ranges from 0-100
			m_pAudioMic->SetProgressValue(dwLevel);

			dwLevel = pAudioControl->GetAudioSignalLevel(TRUE /*fSpeaker*/);	// This level ranges from 0-100
			m_pAudioSpeaker->SetProgressValue(dwLevel);
		}
	}
}

// Get the associated audion control object
CAudioControl *CMainUI::GetAudioControl()
{
	return(m_pConfRoom->GetAudioControl());
}

static void EnableControl(IGenWindow *pControl, BOOL bEnable)
{
	if (NULL == pControl)
	{
		return;
	}

	CComPtr<CGenWindow> spControl = com_cast<CGenWindow>(pControl);
	if (spControl)
	{
		HWND hwnd = spControl->GetWindow();
		if (NULL != hwnd)
		{
			EnableWindow(hwnd, bEnable);
		}
	}
}

void CMainUI::OnChangePermissions()
{
    EnableControl(FindControl(ID_TB_NEW_CALL     ), m_pConfRoom->IsNewCallAllowed());
	EnableControl(FindControl(ID_TB_SHARING      ), m_pConfRoom->IsSharingAllowed());
	EnableControl(FindControl(ID_TB_CHAT         ), m_pConfRoom->IsChatAllowed());
	EnableControl(FindControl(ID_TB_NEWWHITEBOARD), m_pConfRoom->IsNewWhiteboardAllowed());
	EnableControl(FindControl(ID_TB_FILETRANSFER ), m_pConfRoom->IsFileTransferAllowed());
}

void CMainUI::OnCallStarted()
{
	m_bPreviewing = FALSE;
	UpdateViewState();
	UpdatePlayPauseState();
}

void CMainUI::OnCallEnded()
{
	m_bPreviewing = TRUE;
	UpdateViewState();
	UpdatePlayPauseState();
}

void CMainUI::OnAudioLevelChange(BOOL fSpeaker, DWORD dwVolume)
{
	CProgressTrackbar *pBar = fSpeaker ? m_pAudioSpeaker : m_pAudioMic;
	if (NULL != pBar)
	{
		pBar->SetTrackValue((dwVolume*AudioMax + AudioVolMax/2) / AudioVolMax);
	}
}

void CMainUI::OnAudioMuteChange(BOOL fSpeaker, BOOL fMute)
{
	IGenWindow *pButton = FindControl(fSpeaker ? ID_TB_TUNESPEAKER_UNMUTE : ID_TB_TUNEMIC_UNMUTE);
	if (NULL != pButton)
	{
		CComPtr<CButton> spButton = com_cast<CButton>(pButton);
		if (spButton)
		{
			UpdateMuteState(fSpeaker, spButton);
		}
	}
}

BOOL CMainUI::GetPlayPauseState()
{
	BOOL bMuted = TRUE;

	// We're just going to show the state for the "big" window
	if (IsPreviewing())
	{
		if (NULL != m_pLocalVideo)
		{
			bMuted = bMuted && m_pLocalVideo->IsPaused();
		}
	}
	else
	{
		if (NULL != m_pRemoteVideo)
		{
			bMuted = bMuted && m_pRemoteVideo->IsPaused();
		}
	}

	return(bMuted);
}

void CMainUI::UpdatePlayPauseState()
{
	BOOL bMuted = GetPlayPauseState();

	IGenWindow *pButton = FindControl(ID_TB_PLAYPAUSE);
	if (NULL != pButton)
	{
		CComPtr<CBitmapButton> spButton = com_cast<CBitmapButton>(pButton);
		if (spButton)
		{
			spButton->SetCustomState(bMuted ? 0 : 1);
			USES_RES2T
			spButton->SetTooltip(RES2T(bMuted ? IDS_TT_TB_PLAYPAUSE : IDS_TT_TB_PAUSE));
			spButton->SetWindowtext(RES2T(bMuted ? IDS_TT_TB_PLAYPAUSE : IDS_TT_TB_PAUSE));
		}
	}
}

void CMainUI::TogglePlayPause()
{
	// We're going to apply the current state to both videos
	BOOL bMute = !GetPlayPauseState();

	if (NULL != m_pRemoteVideo)
	{
		m_pRemoteVideo->Pause(bMute);
	}
	if (NULL != m_pLocalVideo)
	{
		m_pLocalVideo->Pause(bMute);
	}

	UpdatePlayPauseState();
}

void CMainUI::OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify)
{
	CRoomListView *pView = GetRoster();

	if (NULL != pView)
	{
		pView->OnChangeParticipant(pPart, uNotify);
	}
}

void CMainUI::OnVideoChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
	// BUGBUG georgep: This really should only go to one or the other,
	// depending on if it is incoming, but I'm sending to both
	CVideoWindow *pVideo;
	pVideo = GetRemoteVideo();
	if (NULL != pVideo)
	{
		pVideo->OnChannelChanged(uNotify, pChannel);
	}
	pVideo = GetLocalVideo();
	if (NULL != pVideo)
	{
		pVideo->OnChannelChanged(uNotify, pChannel);
	}
}

void CMainUI::StateChange(CVideoWindow *pVideo, NM_VIDEO_STATE uState)
{
	UpdatePlayPauseState();
}

CFrame *CMainUI::s_pVideoFrame = NULL;

class CVideoFrame : public CFrame
{
protected:
	virtual LRESULT ProcessMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		switch (uMsg)
		{
		case WM_DESTROY:
		{
			RECT rc;
			::GetWindowRect(hwnd, &rc);

			RegEntry reVideo( VIDEO_LOCAL_KEY, HKEY_CURRENT_USER );

			reVideo.SetValue(REGVAL_VIDEO_XPOS, rc.left);
			reVideo.SetValue(REGVAL_VIDEO_YPOS, rc.top);
			break;
		}
		}

		return(CFrame::ProcessMessage(hwnd, uMsg, wParam, lParam));
	}
} ;

BOOL CMainUI::NewVideoWindow(CConfRoom *pConfRoom)
{
	if (NULL == s_pVideoFrame)
	{
		s_pVideoFrame = new CVideoFrame();
		if (NULL == s_pVideoFrame)
		{
			// Could not initialize
			return(FALSE);
		}
	}

	HWND hwnd = s_pVideoFrame->GetWindow();
	if (NULL != hwnd)
	{
		return(s_pVideoFrame->SetForeground());
	}

	TCHAR szTitle[256];
	LoadString(::GetInstanceHandle(), IDS_MYVIDEO, szTitle, ARRAY_ELEMENTS(szTitle));
	HICON hiBig = LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_CONFROOM));

	if (!s_pVideoFrame->Create(
		NULL,			// Window owner
		szTitle,	// Window name
		(WS_OVERLAPPEDWINDOW&~(WS_THICKFRAME|WS_MAXIMIZEBOX)),			// Window style
		0,		// Extended window style
		0,					// Window pos: x
		0,					// Window pos: y
		500,				// Window size: width
		500,			// Window size: height
		_Module.GetModuleInstance(),		// The hInstance to create the window on
		hiBig,		// The icon for the window
		NULL		// Window menu
		))
	{
		return(FALSE);
	}

	BOOL bRet = FALSE;

	CMainUI *pMainUI = new CMainUI();
	if (NULL != pMainUI)
	{
		if (pMainUI->Create(s_pVideoFrame->GetWindow(), pConfRoom, CreatePreviewOnly))
		{
			// Make sure it is the right size before showing the window
			s_pVideoFrame->Resize();

			RegEntry reVideo( VIDEO_LOCAL_KEY, HKEY_CURRENT_USER );
			int x = reVideo.GetNumber(
					REGVAL_VIDEO_XPOS, 0x7fff );
			int y = reVideo.GetNumber(
					REGVAL_VIDEO_YPOS, 0x7fff );

			s_pVideoFrame->MoveEnsureVisible(x, y);

			bRet = s_pVideoFrame->SetForeground();
		}
		pMainUI->Release();
	}

	if (!bRet)
	{
		DestroyWindow(s_pVideoFrame->GetWindow());
	}
	return(bRet);
}

void CMainUI::CleanUpVideoWindow()
{
	if (NULL != s_pVideoFrame)
	{
		HWND hwnd = s_pVideoFrame->GetWindow();
		if (NULL != hwnd)
		{
			DestroyWindow(hwnd);
		}

		s_pVideoFrame->Release();
		s_pVideoFrame = NULL;
	}
}

CRoomListView *CMainUI::GetRoster() const
{
	return(NULL == m_pRoster ? NULL : m_pRoster->GetRoster());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\sdkwindow.cpp ===
#include "precomp.h"

// Net Meeting SDK includes
#include "NmManager.h"
#include "NmConference.h"
#include "NmCall.h"
#include "NmSharableApp.h"
#include "NmChannelAppShare.h"
#include "SDKWindow.h"



CSDKWindow* CSDKWindow::ms_pSDKWnd = NULL;
int CSDKWindow::ms_NumUnlocks = 0;



/////////////////////////////////////////////////////////////////////////////////
// Construction / destruction / initialization
/////////////////////////////////////////////////////////////////////////////////


//static
HRESULT CSDKWindow::InitSDK()
{
	DBGENTRY(CSDKWindow::InitSDK);
	HRESULT hr = S_OK;

	ASSERT(NULL == ms_pSDKWnd);

	ms_pSDKWnd = new CSDKWindow();
	if(ms_pSDKWnd)
	{
			// Create the window	
		RECT rc;
		ms_pSDKWnd->Create(NULL, rc, NULL, WS_POPUP);
		if(!ms_pSDKWnd->IsWindow())
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	DBGEXIT_HR(CSDKWindow::InitSDK,hr);
	return hr;

}
//static
void CSDKWindow::CleanupSDK()
{
	if(ms_pSDKWnd && ms_pSDKWnd->IsWindow())
	{
		ms_pSDKWnd->DestroyWindow();
	}

	delete ms_pSDKWnd;
}

//static
HRESULT CSDKWindow::PostDelayModuleUnlock()
{
	if(ms_pSDKWnd)
	{
		if(!ms_pSDKWnd->SetTimer(DELAY_UNLOAD_TIMER, DELAY_UNLOAD_INTERVAL))
		{
			return HRESULT_FROM_WIN32(GetLastError());			
		}

		++ms_NumUnlocks;
		return S_OK;
	}
	
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////////
// INmManagerNotify Posting functions
/////////////////////////////////////////////////////////////////////////////////

//static
HRESULT CSDKWindow::PostConferenceCreated(CNmManagerObj* pMgr, INmConference* pInternalNmConference)
{
	DBGENTRY(CSDKWindow::PostConferenceCreated);
	HRESULT hr = S_OK;

	ASSERT(ms_pSDKWnd);
	ASSERT(pMgr);

	pMgr->AddRef();

	if(pInternalNmConference)
	{
		pInternalNmConference->AddRef();
	}

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CONFERENCE_CREATED, reinterpret_cast<WPARAM>(pMgr), reinterpret_cast<LPARAM>(pInternalNmConference));

	DBGEXIT_HR(CSDKWindow::PostConferenceCreated,hr);
	return hr;
}



//static
HRESULT CSDKWindow::PostCallCreated(CNmManagerObj* pMgr, INmCall* pInternalNmCall)
{
	DBGENTRY(CSDKWindow::PostCallCreated);
	HRESULT hr = S_OK;

	ASSERT(ms_pSDKWnd);
	ASSERT(pMgr);

	pMgr->AddRef();

	if(pInternalNmCall)
	{
		pInternalNmCall->AddRef();
	}

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CALL_CREATED, reinterpret_cast<WPARAM>(pMgr), reinterpret_cast<LPARAM>(pInternalNmCall));

	DBGEXIT_HR(CSDKWindow::PostCallCreated,hr);
	return hr;
}


//static
HRESULT CSDKWindow::PostManagerNmUI(CNmManagerObj* pMgr, CONFN uNotify)
{
	DBGENTRY(CSDKWindow::PostManagerNmUI);
	HRESULT hr = S_OK;

	ASSERT(ms_pSDKWnd);
	ASSERT(pMgr);

	pMgr->AddRef();

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_MANAGER_NMUI, reinterpret_cast<WPARAM>(pMgr), uNotify);

	DBGEXIT_HR(CSDKWindow::PostManagerNmUI,hr);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////
// INmConferenceNotify Posting functions
/////////////////////////////////////////////////////////////////////////////////


HRESULT CSDKWindow::PostConferenceNmUI(CNmConferenceObj* pConf, CONFN uNotify)
{
	DBGENTRY(CSDKWindow::PostConferenceNmUI);
	HRESULT hr = S_OK;

	ASSERT(ms_pSDKWnd);
	ASSERT(pConf);

	pConf->AddRef();

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CONFERENCE_NMUI, reinterpret_cast<WPARAM>(pConf), uNotify);

	DBGEXIT_HR(CSDKWindow::PostConferenceNmUI,hr);
	return hr;
}


//static
HRESULT CSDKWindow::PostConferenceStateChanged(CNmConferenceObj* pConference, NM_CONFERENCE_STATE uState)
{
	DBGENTRY(CSDKWindow::PostConferenceStateChanged);
	HRESULT hr = S_OK;
	ASSERT(ms_pSDKWnd);
	ASSERT(pConference);

	pConference->AddRef();

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CONFERENCE_STATE_CHANGED, reinterpret_cast<WPARAM>(pConference), uState);


	DBGEXIT_HR(CSDKWindow::PostConferenceStateChanged,hr);
	return hr;
}


//static
HRESULT CSDKWindow::PostConferenceMemberChanged(CNmConferenceObj* pConf, NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CSDKWindow::PostConferenceMemberChanged);
	HRESULT hr = S_OK;

	ASSERT(ms_pSDKWnd);
	ASSERT(pConf);

	pConf->AddRef();

	if(pMember)
	{
		pMember->AddRef();
	}

	ConferenceMemberChanged *pParams = new ConferenceMemberChanged;
	pParams->uNotify = uNotify;
	pParams->pMember = pMember;

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CONFERENCE_MEMBER_CHANGED, reinterpret_cast<WPARAM>(pConf), reinterpret_cast<LPARAM>(pParams));

	DBGEXIT_HR(CSDKWindow::PostConferenceMemberChanged,hr);
	return hr;
}



//static
HRESULT CSDKWindow::PostConferenceChannelChanged(CNmConferenceObj* pConf, NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
	DBGENTRY(CSDKWindow::PostConferenceChannelChanged);
	HRESULT hr = S_OK;
	
	ASSERT(ms_pSDKWnd);
	ASSERT(pConf);

	pConf->AddRef();

	if(pChannel)
	{
		pChannel->AddRef();
	}

	ConferenceChannelChanged *pParams = new ConferenceChannelChanged;
	pParams->uNotify = uNotify;
	pParams->pChannel = pChannel;

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CONFERENCE_CHANNEL_CHANGED, reinterpret_cast<WPARAM>(pConf), reinterpret_cast<LPARAM>(pParams));

	DBGEXIT_HR(CSDKWindow::PostConferenceChannelChanged,hr);
	return hr;
}

//static
HRESULT CSDKWindow::PostStateChanged(CNmChannelAppShareObj* pAppShareChan, NM_SHAPP_STATE uNotify, INmSharableApp *pApp)
{
	HRESULT hr = S_OK;
	ASSERT(ms_pSDKWnd);
	ASSERT(pAppShareChan);
	ASSERT(pApp);

	pAppShareChan->AddRef();
	pApp->AddRef();

	StateChanged* pParams = new StateChanged;
	pParams->uNotify = uNotify;
	pParams->pApp = pApp;

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_STATE_CHANGED, reinterpret_cast<WPARAM>(pAppShareChan), reinterpret_cast<LPARAM>(pParams));

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////
// INmCallNotify Posting functions
/////////////////////////////////////////////////////////////////////////////////



//static
HRESULT CSDKWindow::PostCallStateChanged(CNmCallObj* pCall, NM_CALL_STATE uState)
{
	DBGENTRY(CSDKWindow::PostCallStateChanged);
	HRESULT hr = S_OK;
	ASSERT(ms_pSDKWnd);
	ASSERT(pCall);

	pCall->AddRef();

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CALL_STATE_CHANGED, reinterpret_cast<WPARAM>(pCall), uState);


	DBGEXIT_HR(CSDKWindow::PostCallStateChanged,hr);
	return hr;
}

//static
HRESULT CSDKWindow::PostCallNmUi(CNmCallObj* pCall, CONFN uNotify)
{
	DBGENTRY(CSDKWindow::PostCallNmUi);
	HRESULT hr = S_OK;
	ASSERT(ms_pSDKWnd);
	ASSERT(pCall);
	
	pCall->AddRef();

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_NMUI, reinterpret_cast<WPARAM>(pCall), uNotify);

	DBGEXIT_HR(CSDKWindow::PostCallNmUi,hr);
	return hr;
}

//static
HRESULT CSDKWindow::PostFailed(CNmCallObj* pCall, ULONG uError)
{
	DBGENTRY(CSDKWindow::PostFailed);
	HRESULT hr = S_OK;
	ASSERT(ms_pSDKWnd);
	ASSERT(pCall);

	pCall->AddRef();

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_FAILED, reinterpret_cast<WPARAM>(pCall), uError);

	DBGEXIT_HR(CSDKWindow::PostFailed,hr);
	return hr;
}

//static
HRESULT CSDKWindow::PostAccepted(CNmCallObj* pCall, INmConference* pConference)
{
	DBGENTRY(CSDKWindow::PostAccepted);
	HRESULT hr = S_OK;
	ASSERT(ms_pSDKWnd);
	ASSERT(pCall);

	pCall->AddRef();
	if(pConference)
	{
		pConference->AddRef();
	}	
	
	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_ACCEPTED, reinterpret_cast<WPARAM>(pCall), reinterpret_cast<LPARAM>(pConference));

	DBGEXIT_HR(CSDKWindow::PostAccepted,hr);
	return hr;
}



/////////////////////////////////////////////////////////////////////////////////
// INmManagerNotify message handling functions
/////////////////////////////////////////////////////////////////////////////////

LRESULT CSDKWindow::_OnMsgConferenceCreated(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgConferenceCreated);

	CNmManagerObj* pMgr = reinterpret_cast<CNmManagerObj*>(wParam);
	INmConference* pInternalConf = reinterpret_cast<INmConference*>(lParam);

	pMgr->Fire_ConferenceCreated(pInternalConf);
	pMgr->Release();
	if(pInternalConf)
	{
		pInternalConf->Release();
	}

	DBGEXIT(CSDKWindow::_OnMsgConferenceCreated);
	return 0;
}



LRESULT CSDKWindow::_OnMsgManagerNmUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgManagerNmUI);

	CNmManagerObj* pMgr = reinterpret_cast<CNmManagerObj*>(wParam);
	CONFN uNotify = static_cast<CONFN>(lParam);

	pMgr->Fire_NmUI(uNotify);
	pMgr->Release();

	DBGEXIT(CSDKWindow::_OnMsgManagerNmUI);
	return 0;
}


LRESULT CSDKWindow::_OnMsgCallCreated(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgCallCreated);

	CNmManagerObj* pMgr = reinterpret_cast<CNmManagerObj*>(wParam);
	INmCall* pInternalCall = reinterpret_cast<INmCall*>(lParam);

	pMgr->Fire_CallCreated(pInternalCall);
	pMgr->Release();
	if(pInternalCall)
	{
		pInternalCall->Release();
	}

	DBGEXIT(CSDKWindow::_OnMsgCallCreated);
	return 0;
}


/////////////////////////////////////////////////////////////////////////////////
// INmConferenceNotify message handling functions
/////////////////////////////////////////////////////////////////////////////////

LRESULT CSDKWindow::_OnMsgConferenceNmUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgConferenceNmUI);

	CNmConferenceObj* pConf = reinterpret_cast<CNmConferenceObj*>(wParam);
	CONFN uNotify = static_cast<CONFN>(lParam);

	pConf->Fire_NmUI(uNotify);
	pConf->Release();

	DBGEXIT(CSDKWindow::_OnMsgConferenceNmUI);
	return 0;
}


LRESULT CSDKWindow::_OnMsgConferenceStateChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgConferenceStateChanged);
	CNmConferenceObj* pConference = reinterpret_cast<CNmConferenceObj*>(wParam);
	NM_CONFERENCE_STATE uState = static_cast<NM_CONFERENCE_STATE>(lParam);

	pConference->Fire_StateChanged(uState);
	pConference->Release();
	
	DBGEXIT(CSDKWindow::_OnMsgConferenceStateChanged);
	return 0;
}

LRESULT CSDKWindow::_OnMsgConferenceMemberChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgConferenceMemberChanged);

	CNmConferenceObj* pConf = reinterpret_cast<CNmConferenceObj*>(wParam);
	ConferenceMemberChanged* pParams = reinterpret_cast<ConferenceMemberChanged*>(lParam);

	pConf->Fire_MemberChanged(pParams->uNotify, pParams->pMember);

	pConf->Release();
	if(pParams->pMember)
	{
		pParams->pMember->Release();
	}
	delete pParams;

	DBGEXIT(CSDKWindow::_OnMsgConferenceMemberChanged);
	return 0;
}


LRESULT CSDKWindow::_OnMsgConferenceChannelChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgConferenceChannelChanged);

	CNmConferenceObj* pConf = reinterpret_cast<CNmConferenceObj*>(wParam);
	ConferenceChannelChanged* pParams = reinterpret_cast<ConferenceChannelChanged*>(lParam);

	pConf->Fire_ChannelChanged(pParams->uNotify, pParams->pChannel);

	pConf->Release();
	if(pParams->pChannel)
	{
		pParams->pChannel->Release();
	}
	delete pParams;

	DBGEXIT(CSDKWindow::_OnMsgConferenceChannelChanged);
	return 0;
}

LRESULT CSDKWindow::_OnStateChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandlede)
{
	CNmChannelAppShareObj* pAppShareChan = reinterpret_cast<CNmChannelAppShareObj*>(wParam);
	StateChanged* pParams = reinterpret_cast<StateChanged*>(lParam);


	pAppShareChan->Fire_StateChanged(pParams->uNotify, pParams->pApp);

	pAppShareChan->Release();
	pParams->pApp->Release();

	delete pParams;

	return 0;
}


/////////////////////////////////////////////////////////////////////////////////
// INmCallNotify message handling functions
/////////////////////////////////////////////////////////////////////////////////


LRESULT CSDKWindow::_OnMsgCallStateChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgCallStateChanged);
	CNmCallObj* pCall = reinterpret_cast<CNmCallObj*>(wParam);
	NM_CALL_STATE uState = static_cast<NM_CALL_STATE>(lParam);

	pCall->Fire_StateChanged(uState);
	pCall->Release();
	
	DBGEXIT(CSDKWindow::_OnMsgCallStateChanged);
	return 0;
}

LRESULT CSDKWindow::_OnMsgCallNmUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnCallMsgNmUI);

	CNmCallObj* pCall = reinterpret_cast<CNmCallObj*>(wParam);
	CONFN uNotify = static_cast<CONFN>(lParam);

	pCall->Fire_NmUI(uNotify);
	pCall->Release();

	DBGEXIT(CSDKWindow::_OnMsgCallNmUI);
	return 0;
}

LRESULT CSDKWindow::_OnMsgFailed(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgFailed);

	CNmCallObj* pCall = reinterpret_cast<CNmCallObj*>(wParam);
	ULONG uError = (ULONG)lParam;
	
	pCall->Fire_Failed(uError);
	pCall->Release();

	DBGEXIT(CSDKWindow::_OnMsgFailed);
	return 0;
}

LRESULT CSDKWindow::_OnMsgAccepted(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgAccepted);

	CNmCallObj* pCall = reinterpret_cast<CNmCallObj*>(wParam);
	INmConference* pConf = reinterpret_cast<INmConference*>(lParam);

	pCall->Fire_Accepted(pConf);
	pCall->Release();
	if(pConf)
	{
		pConf->Release();
	}

	DBGEXIT(CSDKWindow::_OnMsgAccepted);
	return 0;
}

LRESULT CSDKWindow::_OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

	if(DELAY_UNLOAD_TIMER == wParam)
	{
		if(ms_NumUnlocks)
		{
			--ms_NumUnlocks;
			_Module.Unlock();	
		}	
		
		if(!ms_NumUnlocks)
		{
			KillTimer(DELAY_UNLOAD_TIMER);
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\seccpl.cpp ===
// File: seccpl.cpp

#include "precomp.h"
#include "conf.h"
#include <tsecctrl.h>
#include <certui.h>
#include <help_ids.h>
#include "ConfPolicies.h"

// Dialog ID to Help ID mapping
static const DWORD rgHelpIdsSecurity[] = {
IDC_SEC_GENERAL,        IDH_SECURITY_SECURITY,
IDC_SEC_GEN_TEXT,       IDH_SECURITY_SECURITY,
IDC_SEC_INCOMING,       IDH_SECURITY_INCOMING,
IDC_SEC_OUTGOING,       IDH_SECURITY_OUTGOING,

IDC_SEC_CRED,           IDH_SECURITY_CERTIFICATE,
IDC_SEC_CRED_TEXT,      IDH_SECURITY_CERTIFICATE,
IDC_SECURE_CALL_EDIT,   IDH_SECURITY_CERTIFICATE_LIST,
IDC_SEC_CHANGECERT,     IDH_SECURITY_CHANGE_CERTIFICATE,
IDC_SEC_PRIVACY_ONLY,   IDH_SECURITY_CERTIFICATE_PRIVACY,
IDC_SEC_PRIVACY_AUTH,   IDH_SECURITY_CERTIFICATE_PRIV_AUTH,
0, 0   // terminator
};


extern INmSysInfo2 * g_pNmSysInfo;

static PBYTE g_pbEncodedCert = NULL;
static DWORD g_cbEncodedCert = 0;


INT_PTR APIENTRY SecurityDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_DESTROY:
            if ( g_pbEncodedCert )
            {
                FreeT120EncodedCert ( g_pbEncodedCert );
                g_pbEncodedCert = NULL;
            }
            break;

        case WM_INITDIALOG:
        {
            int  security;
            BOOL fIncomingOn;
            BOOL fOutgoingOn;
            BOOL fBtnsAlterable;

            //
            // Get the current cert used by T.120
            //

            security = ConfPolicies::GetSecurityLevel();

            switch (security)
            {
                case DISABLED_POL_SECURITY:
                    fBtnsAlterable = FALSE;
                    fIncomingOn = FALSE;
                    fOutgoingOn = FALSE;
                    break;

                case REQUIRED_POL_SECURITY:
                    fBtnsAlterable = FALSE;
                    fIncomingOn = TRUE;
                    fOutgoingOn = TRUE;
                    break;

                default:
                    fBtnsAlterable = TRUE;
                    fIncomingOn = ConfPolicies::IncomingSecurityRequired();
                    fOutgoingOn = ConfPolicies::OutgoingSecurityPreferred();
                    break;
            }

            // Incoming
            ::CheckDlgButton(hDlg, IDC_SEC_INCOMING, fIncomingOn);
            ::EnableWindow(::GetDlgItem(hDlg, IDC_SEC_INCOMING), fBtnsAlterable);

            // Outgoing
            ::CheckDlgButton(hDlg, IDC_SEC_OUTGOING, fOutgoingOn);
            ::EnableWindow(::GetDlgItem(hDlg, IDC_SEC_OUTGOING), fBtnsAlterable);

            //
            // Set privacy versus authentication (cert used for security)
            //
            RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);
            BOOL fAuthentication = re.GetNumber(REGVAL_SECURITY_AUTHENTICATION,
                                        DEFAULT_SECURITY_AUTHENTICATION);


            //
            // If the user cert store is empty, reset the choice back
            // to privacy only
            //

            if ( fAuthentication && !NumUserCerts() )
            {
                re.SetValue(REGVAL_SECURITY_AUTHENTICATION, (DWORD)0);
                fAuthentication = 0;
            }

            // Handle certificate combo box.
            if (security != DISABLED_POL_SECURITY)
            {
                if ( !fAuthentication )
                {
                    if ( TCHAR * pCertText = new TCHAR[MAX_PATH] )
                    {
                        FLoadString(IDS_GENERIC_NMDC_TEXT, pCertText, MAX_PATH);
                        SetDlgItemText(hDlg,IDC_SECURE_CALL_EDIT,pCertText);
                        delete [] pCertText;
                    }
                }
                else
                {
                    if ( GetT120ActiveCert( &g_pbEncodedCert,
                                                    &g_cbEncodedCert ))
                    {
                        if (TCHAR * pCertText = FormatCert(g_pbEncodedCert,
                                                        g_cbEncodedCert))
                        {
                            SetDlgItemText(hDlg,IDC_SECURE_CALL_EDIT,pCertText);
                            delete [] pCertText;
                        }
                        else
                        {
                            WARNING_OUT(("FormatCert returns NULL"));
                        }
                    }
                    else
                    {
                        WARNING_OUT(("SecurityDlgProc init: no T120 cert"));
                    }
                }
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg,IDC_SECURE_CALL_EDIT), FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_SEC_CHANGECERT),   FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_SEC_PRIVACY_ONLY), FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_SEC_PRIVACY_AUTH), FALSE);
            }

            // Check the appropriate box:

            if (fAuthentication)
            {
                CheckRadioButton(hDlg, IDC_SEC_PRIVACY_ONLY, IDC_SEC_PRIVACY_AUTH,
                    IDC_SEC_PRIVACY_AUTH);
            }
            else
            {
                CheckRadioButton(hDlg, IDC_SEC_PRIVACY_ONLY, IDC_SEC_PRIVACY_AUTH,
                    IDC_SEC_PRIVACY_ONLY);
                EnableWindow(GetDlgItem(hDlg,IDC_SEC_CHANGECERT), FALSE);
            }

            return (TRUE);
        }

        case WM_NOTIFY:
            if (((NMHDR FAR *) lParam)->code == PSN_APPLY)
            {
                //
                // User can only change these settings if no policy
                // disabling security.
                //
                if (ConfPolicies::GetSecurityLevel() != DISABLED_POL_SECURITY)
                {
                    RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);

                    if (ConfPolicies::GetSecurityLevel() == DEFAULT_POL_SECURITY)
                    {
                        // Incoming
                        re.SetValue(REGVAL_SECURITY_INCOMING_REQUIRED,
                            (::IsDlgButtonChecked(hDlg, IDC_SEC_INCOMING) != FALSE));


                        // Outgoing
                        re.SetValue(REGVAL_SECURITY_OUTGOING_PREFERRED,
                            (::IsDlgButtonChecked(hDlg, IDC_SEC_OUTGOING) != FALSE));
                    }

                    BOOL fAuth = (::IsDlgButtonChecked(hDlg,
                                    IDC_SEC_PRIVACY_AUTH) != FALSE);

                    if ( fAuth )
                    {
                        if ( !SetT120ActiveCert ( FALSE, g_pbEncodedCert,
                                                        g_cbEncodedCert ))
                        {
                            //
                            // Did the new cert fail? if so put
                            // up an error dialog.

                            ConfMsgBox(hDlg, (LPCSTR)IDS_CERT_FAILED);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return PSNRET_INVALID_NOCHANGEPAGE;
                        }
                        else
                        {
                            SetT120CertInRegistry ( g_pbEncodedCert,
                                                    g_cbEncodedCert );
                        }
                    }
                    else
                    {
                        SetT120ActiveCert( TRUE, NULL, 0);
                    }

                    re.SetValue(REGVAL_SECURITY_AUTHENTICATION, fAuth );
                }
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDC_SEC_CHANGECERT:
                if (ChangeCertDlg(hDlg, ::GetInstanceHandle(),
                                    &g_pbEncodedCert, &g_cbEncodedCert ))
                {
                    TCHAR * pCertText = FormatCert(g_pbEncodedCert,
                                                    g_cbEncodedCert);
                    if (pCertText)
                    {
                        SetDlgItemText(hDlg,IDC_SECURE_CALL_EDIT,pCertText);
                        delete [] pCertText;
                    }
                    else
                    {
                        ERROR_OUT(("SEC_CHANGECERT: FormatCert failed"));
                    }
                }
                break;

            case IDC_SEC_PRIVACY_AUTH:
                if (!NumUserCerts())
                {
                    if ( SendDlgItemMessage(hDlg, IDC_SEC_PRIVACY_AUTH,
                                            BM_GETCHECK, 0, 0 ))
                    {
                        // Force setting back
                        CheckRadioButton(hDlg, IDC_SEC_PRIVACY_ONLY,
                            IDC_SEC_PRIVACY_AUTH, IDC_SEC_PRIVACY_ONLY);
                        SetFocus(GetDlgItem(hDlg, IDC_SEC_PRIVACY_ONLY));

                        // Bring up message box that this won't work:
                        ConfMsgBox(hDlg, (LPCSTR)IDS_NO_USER_CERTS);
                    }
                    return (TRUE);
                }

                if ( !g_pbEncodedCert )
                {
                    if ( !GetDefaultSystemCert( &g_pbEncodedCert,
                                            &g_cbEncodedCert ))
                    {
                        WARNING_OUT(("GetDefaultSystemCert failed"));
                    }
                }

                if ( g_pbEncodedCert )
                {
                    if (TCHAR * pCertText = FormatCert(g_pbEncodedCert,
                                                    g_cbEncodedCert))
                    {
                        SetDlgItemText(hDlg,IDC_SECURE_CALL_EDIT,pCertText);
                        delete [] pCertText;
                    }
                    else
                    {
                        WARNING_OUT(("FormatCert returns NULL"));
                    }
                }
                else
                {
                    WARNING_OUT(("SecurityDlgProc init: no T120 cert"));
                }

                EnableWindow(GetDlgItem(hDlg,IDC_SEC_CHANGECERT), TRUE);

                break;


            case IDC_SEC_PRIVACY_ONLY:

                if ( TCHAR * pCertText = new TCHAR[MAX_PATH] )
                {
                    FLoadString(IDS_GENERIC_NMDC_TEXT, pCertText, MAX_PATH);
                    SetDlgItemText(hDlg,IDC_SECURE_CALL_EDIT,pCertText);
                    delete [] pCertText;
                }

                EnableWindow(GetDlgItem(hDlg,IDC_SEC_CHANGECERT), FALSE);
                break;
            }
            break;

        case WM_CONTEXTMENU:
            DoHelpWhatsThis(wParam, rgHelpIdsSecurity);
            break;

        case WM_HELP:
            DoHelp(lParam, rgHelpIdsSecurity);
            break;

    }
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\sdkwindow.h ===
#ifndef __SDKWindow_h__
#define __SDKWindow_h__

class CNmChannelAppShareObj;
class CNmCallObj;

class CSDKWindow : public CWindowImpl<CSDKWindow>
{

static CSDKWindow* ms_pSDKWnd;

private:


// Conference Notification Parameter structures
	struct ConferenceMemberChanged 
	{	
		NM_MEMBER_NOTIFY uNotify;
		INmMember *pMember;
	};

	struct ConferenceChannelChanged 
	{	
		NM_CHANNEL_NOTIFY uNotify;
		INmChannel *pChannel;
	};

	struct StateChanged
	{
		NM_SHAPP_STATE uNotify;
		INmSharableApp *pApp;
	};
	

	CONSTANT(DELAY_UNLOAD_TIMER = 123);
	CONSTANT(DELAY_UNLOAD_INTERVAL = 10000);

	static int ms_NumUnlocks;

	// This will prevent soemone creating us other than Init
	CSDKWindow() { ; }

public:

		// NmManagerNotify
	CONSTANT(WM_APP_NOTIFY_MANAGER_NMUI					= (WM_APP + 10));
	CONSTANT(WM_APP_NOTIFY_CALL_CREATED					= (WM_APP + 11));
	CONSTANT(WM_APP_NOTIFY_CONFERENCE_CREATED			= (WM_APP + 12));

		//NmConferenceNotify
	CONSTANT(WM_APP_NOTIFY_CONFERENCE_NMUI				= (WM_APP + 20));
	CONSTANT(WM_APP_NOTIFY_CONFERENCE_STATE_CHANGED		= (WM_APP + 21));
	CONSTANT(WM_APP_NOTIFY_CONFERENCE_MEMBER_CHANGED	= (WM_APP + 22));
	CONSTANT(WM_APP_NOTIFY_CONFERENCE_CHANNEL_CHANGED	= (WM_APP + 23));

		// NmCallNotify
	CONSTANT(WM_APP_NOTIFY_NMUI					= (WM_APP + 31));
	CONSTANT(WM_APP_NOTIFY_CALL_STATE_CHANGED	= (WM_APP + 32));
	CONSTANT(WM_APP_NOTIFY_FAILED				= (WM_APP + 33));
	CONSTANT(WM_APP_NOTIFY_ACCEPTED				= (WM_APP + 34));

	CONSTANT(WM_APP_NOTIFY_STATE_CHANGED		= (WM_APP + 35));


DECLARE_WND_CLASS(NULL);

BEGIN_MSG_MAP(CSDKWindow)
		// Manager Notifications
	MESSAGE_HANDLER(WM_APP_NOTIFY_MANAGER_NMUI, _OnMsgManagerNmUI)
	MESSAGE_HANDLER(WM_APP_NOTIFY_CALL_CREATED, _OnMsgCallCreated)
	MESSAGE_HANDLER(WM_APP_NOTIFY_CONFERENCE_CREATED, _OnMsgConferenceCreated)

		// Conference Notify
	MESSAGE_HANDLER(WM_APP_NOTIFY_CONFERENCE_NMUI, _OnMsgConferenceNmUI)
	MESSAGE_HANDLER(WM_APP_NOTIFY_CONFERENCE_STATE_CHANGED, _OnMsgConferenceStateChanged)
	MESSAGE_HANDLER(WM_APP_NOTIFY_CONFERENCE_MEMBER_CHANGED, _OnMsgConferenceMemberChanged)
	MESSAGE_HANDLER(WM_APP_NOTIFY_CONFERENCE_CHANNEL_CHANGED, _OnMsgConferenceChannelChanged)

		// Call Notifications
	MESSAGE_HANDLER(WM_APP_NOTIFY_CALL_STATE_CHANGED, _OnMsgCallStateChanged)
	MESSAGE_HANDLER(WM_APP_NOTIFY_NMUI, _OnMsgCallNmUI)
	MESSAGE_HANDLER(WM_APP_NOTIFY_FAILED, _OnMsgFailed)
	MESSAGE_HANDLER(WM_APP_NOTIFY_ACCEPTED, _OnMsgAccepted)

	MESSAGE_HANDLER(WM_APP_NOTIFY_STATE_CHANGED, _OnStateChanged);

	MESSAGE_HANDLER(WM_TIMER, _OnTimer)
END_MSG_MAP();


public: 
	// Initialization
	static HRESULT InitSDK();
	static void CleanupSDK();

	static HRESULT PostDelayModuleUnlock();

	// Manager Notificyations
	static HRESULT PostManagerNmUI(CNmManagerObj* pMgr, CONFN uNotify);
	static HRESULT PostCallCreated(CNmManagerObj* pMgr, INmCall* pInternalNmCall);
	static HRESULT PostConferenceCreated(CNmManagerObj* pMgr, INmConference* pInternalNmConference);

	// Conference Notificyations
	static HRESULT PostConferenceNmUI(CNmConferenceObj* pConf, CONFN uNotify);
	static HRESULT PostConferenceStateChanged(CNmConferenceObj* pConf, NM_CONFERENCE_STATE uState);
	static HRESULT PostConferenceMemberChanged(CNmConferenceObj* pConf, NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	static HRESULT PostConferenceChannelChanged(CNmConferenceObj* pConf, NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel);

	// Call Notificyations
	static HRESULT PostCallNmUi(CNmCallObj* pCall, CONFN uNotify);
	static HRESULT PostCallStateChanged(CNmCallObj* pCall, NM_CALL_STATE uState);
	static HRESULT PostFailed(CNmCallObj* pCall, ULONG uError);
	static HRESULT PostAccepted(CNmCallObj* pCall, INmConference* pConference);

	static HRESULT PostStateChanged(CNmChannelAppShareObj* pAppShareChan, NM_SHAPP_STATE uNotify, INmSharableApp *pApp);

private: // Helpers 

	// Manager Mssages
	LRESULT _OnMsgManagerNmUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgConferenceCreated(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgCallCreated(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	// Conference message
	LRESULT _OnMsgConferenceNmUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgConferenceStateChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgConferenceMemberChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgConferenceChannelChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

		// Call Messages
	LRESULT _OnMsgCallStateChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgCallNmUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgFailed(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgAccepted(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	
	LRESULT _OnStateChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	
	LRESULT _OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

};

#endif // __SDKWindow_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\sdialdlg.cpp ===
// File: sdialdlg.cpp
//
// Speed Dials (Friends)

#include "precomp.h"
#include "resource.h"
#include "sdialdlg.h"
#include "call.h"
#include "cmd.h"
#include "ConfUtil.h"
#include "help_ids.h"

extern BOOL FCreateSpeedDial(LPCTSTR pcszName, LPCTSTR pcszAddress,
			NM_ADDR_TYPE addrType = NM_ADDR_UNKNOWN, DWORD dwCallFlags = CRPCF_DEFAULT,
			LPCTSTR pcszRemoteConfName = NULL, LPCTSTR pcszPassword = NULL,
			LPCTSTR pcszPathPrefix = NULL);


static const DWORD _rgHelpIdsSpeedDial[] = {
	IDC_STATIC_SPEED_DIAL_INSTRUCTIONS, IDH_STATIC_SPEED_DIAL_INSTRUCTIONS,
	IDC_CSD_SD_INFO_GROUP,				IDH_CSD_SD_INFO_GROUP,
	IDC_STATIC_ADDRESS, 				IDH_CSD_ADDRESS_EDIT,
	IDC_CSD_ADDRESS_EDIT,				IDH_CSD_ADDRESS_EDIT,
	IDC_STATIC_CALLUSING,				IDH_CSD_CALL_USING_COMBO,
	IDC_CSD_CALL_USING_COMBO,			IDH_CSD_CALL_USING_COMBO,
	IDC_CSD_CREATE_GROUPBOX,			IDH_CSD_CREATE_GROUPBOX,
	IDC_CSD_SPEEDDIAL_LIST_RADIO,		IDH_CSD_SPEEDDIAL_LIST_RADIO,
	IDC_CSD_SAVE_DESKTOP_RADIO, 		IDH_CSD_SAVE_DESKTOP_RADIO,
	0, 0   // terminator
};

CSpeedDialDlg::CSpeedDialDlg(HWND hwndParent, NM_ADDR_TYPE addrType) :
	m_hwndParent	(hwndParent),
	m_pszAddress	(NULL),
	m_addrType      (addrType),
	m_hwnd			(NULL)
{
	DBGENTRY(CSpeedDialDlg::CSpeedDialDlg);
}

CSpeedDialDlg::~CSpeedDialDlg()
{
	DBGENTRY(CSpeedDialDlg::~CSpeedDialDlg);

	// Free all strings
	delete m_pszAddress;
}

/****************************************************************************
*
*    CLASS:    CSpeedDialDlg
*
*    MEMBER:   DoModal()
*
*    PURPOSE:  Brings up the modal dialog box
*
****************************************************************************/

INT_PTR CSpeedDialDlg::DoModal(LPCTSTR pcszAddress)
{
	DBGENTRY(CSpeedDialDlg::DoModal);

	if (NULL != pcszAddress)
	{
		ASSERT(NULL == m_pszAddress);
		m_pszAddress = PszAlloc(pcszAddress);
	}

	INT_PTR nRet = DialogBoxParam(	::GetInstanceHandle(),
								MAKEINTRESOURCE(IDD_CREATE_SPEED_DIAL),
								m_hwndParent,
								CSpeedDialDlg::SpeedDialDlgProc,
								(LPARAM) this);

	DebugExitINT_PTR(CSpeedDialDlg::DoModal, nRet);
	return nRet;
}

/****************************************************************************
*
*    CLASS:    CSpeedDialDlg
*
*    MEMBER:   SpeedDialDlgProc()
*
*    PURPOSE:  Dialog Proc - handles all messages
*
****************************************************************************/

INT_PTR CALLBACK CSpeedDialDlg::SpeedDialDlgProc(	HWND hDlg,
												UINT uMsg,
												WPARAM wParam,
												LPARAM lParam)
{
	BOOL bMsgHandled = FALSE;
	ASSERT(IS_VALID_HANDLE(hDlg, WND));

	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			if (NULL != lParam)
			{
				((CSpeedDialDlg*) lParam)->m_hwnd = hDlg;
				::SetWindowLongPtr(hDlg, DWLP_USER, lParam);

				bMsgHandled = ((CSpeedDialDlg*) lParam)->OnInitDialog();
			}
			break;
		}

		default:
		{
			CSpeedDialDlg* psdd = (CSpeedDialDlg*) ::GetWindowLongPtr(hDlg,
																 DWLP_USER);

			if (NULL != psdd)
			{
				bMsgHandled = psdd->ProcessMessage(uMsg, wParam, lParam);
			}
		}
	}

	return bMsgHandled;
}


BOOL CSpeedDialDlg::AddAddressType(NM_ADDR_TYPE addrType, LPCTSTR lpcszDispName)
{
	int index = (int)::SendDlgItemMessage(m_hwnd, IDC_CSD_CALL_USING_COMBO,
				CB_ADDSTRING, 0, (LPARAM) lpcszDispName);

	if (CB_ERR == index)
		return FALSE;

	// Set the item data:
	::SendDlgItemMessage(m_hwnd, IDC_CSD_CALL_USING_COMBO,
				CB_SETITEMDATA, index,addrType);

	if (addrType == m_addrType)
	{
		// Select the transport:
		::SendDlgItemMessage(m_hwnd, IDC_CSD_CALL_USING_COMBO,
								CB_SETCURSEL, index, 0);
	}
	return TRUE;
}

BOOL CSpeedDialDlg::AddAddressType(NM_ADDR_TYPE addrType, UINT uStringID)
{
	TCHAR sz[MAX_PATH];

	if (!FLoadString(uStringID, sz, CCHMAX(sz)))
		return FALSE;

	return AddAddressType(addrType, sz);
}


BOOL CSpeedDialDlg::OnInitDialog(void)
{
	::CheckDlgButton(m_hwnd, IDC_CSD_SPEEDDIAL_LIST_RADIO, BST_CHECKED);

	// Fill in the "Call Using" list:
	AddAddressType(NM_ADDR_IP, IDS_ACD_CT_IP);
	AddAddressType(NM_ADDR_ULS, IDS_ACD_CT_ILS);
	if (FH323GatewayEnabled())
	{
		AddAddressType(NM_ADDR_H323_GATEWAY, IDS_GATEWAY_DISPLAY_NAME);
	}

	int iSelected = (int)::SendDlgItemMessage(m_hwnd,
					IDC_CSD_CALL_USING_COMBO, CB_GETCURSEL, 0, 0);
	if (CB_ERR == iSelected)
	{
		// The transport that we wanted to select was not available, so
		// we will select the first one that we added to the list:
		::SendDlgItemMessage(m_hwnd,
					IDC_CSD_CALL_USING_COMBO, CB_SETCURSEL, 0, 0);
		m_addrType = (NM_ADDR_TYPE) ::SendDlgItemMessage(m_hwnd,
					IDC_CSD_CALL_USING_COMBO, CB_GETITEMDATA, 0, 0);
	}

	if (!FEmptySz(m_pszAddress))
	{
		::SetDlgItemText(m_hwnd, IDC_CSD_ADDRESS_EDIT, m_pszAddress);
	}
	else if (NM_ADDR_ULS == m_addrType)
	{
		RegEntry re(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
		::SetDlgItemText(m_hwnd, IDC_CSD_ADDRESS_EDIT,
							re.GetString(REGVAL_ULS_RES_NAME));
	}

	Edit_LimitText(GetDlgItem(m_hwnd, IDC_CSD_ADDRESS_EDIT), CCHMAXSZ_ADDRESS - 1);

	RefreshOkButton();

	return TRUE;
}

/****************************************************************************
*
*    CLASS:    CSpeedDialDlg
*
*    MEMBER:   ProcessMessage()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CSpeedDialDlg::ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL bRet = FALSE;
	ASSERT(m_hwnd);
	
	switch (uMsg)
	{
		case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
				case IDOK:
				{
					bRet = OnOk();
					break;
				}

				case IDCANCEL:
				{
					::EndDialog(m_hwnd, LOWORD(wParam));
					bRet = TRUE;
					break;
				}

				case IDC_CSD_ADDRESS_EDIT:
				{
					if (EN_CHANGE == HIWORD(wParam))
					{
						RefreshOkButton();
					}
					break;
				}
			}
			break;

		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, _rgHelpIdsSpeedDial);
			break;

		case WM_HELP:
			DoHelp(lParam, _rgHelpIdsSpeedDial);
			break;
		}
	}

	return bRet;
}

NM_ADDR_TYPE CSpeedDialDlg::GetCurAddrType(void)
{
	int iIndex = (int)::SendDlgItemMessage(m_hwnd, IDC_CSD_CALL_USING_COMBO,
										CB_GETCURSEL, 0, 0);

	if (CB_ERR == iIndex)
		return NM_ADDR_UNKNOWN;
		

	return (NM_ADDR_TYPE) ::SendDlgItemMessage(m_hwnd,
				IDC_CSD_CALL_USING_COMBO, CB_GETITEMDATA, iIndex, 0);
}

BOOL CSpeedDialDlg::OnOk(void)
{
	m_addrType = GetCurAddrType();
	BOOL fSaveDesktop = (BST_CHECKED == ::IsDlgButtonChecked(m_hwnd,
												IDC_CSD_SAVE_DESKTOP_RADIO));

	TCHAR szBuf[MAX_PATH];
	if (0 != ::GetDlgItemText(	m_hwnd,
								IDC_CSD_ADDRESS_EDIT,
								szBuf,
								ARRAY_ELEMENTS(szBuf)))
	{
		// Copy address into the address:
		delete m_pszAddress;
		m_pszAddress = PszAlloc(szBuf);
	}

	::EndDialog(m_hwnd, IDOK);

	TRACE_OUT(("Creating Speed Dial:"));
	TRACE_OUT(("\tTransport ID: %d", GetAddrType()));
	TRACE_OUT(("\tAddress:      \"%s\"", GetAddress()));
	TRACE_OUT(("\tSaveDesktop:  %s", ::GetBOOLString(fSaveDesktop)));

	NM_ADDR_TYPE addrType = GetAddrType();
	DWORD crpcf = (NM_ADDR_H323_GATEWAY == addrType) ?
		(CRPCF_AUDIO | CRPCF_VIDEO) : CRPCF_DEFAULT;

	if (fSaveDesktop)
	{
		// Save on desktop
		BOOL fSavedOk = FALSE;
		
		LPITEMIDLIST pidl = NULL;
		TCHAR szPathPrefix[MAX_PATH];
		szPathPrefix[0] = _T('\0');

		if (NMGetSpecialFolderPath(NULL, szPathPrefix, CSIDL_DESKTOP, TRUE))
		{
			fSavedOk = ::FCreateSpeedDial(
							GetAddress(),	// pcszName
							GetAddress(),	// pcszAddress
							addrType,		// addrType
							crpcf,			// dwCallFlags
							NULL,			// pcszRemoteConfName
							NULL,			// pcszPassword
							szPathPrefix);	// pcszPathPrefix
		}
		else
		{
			ERROR_OUT(("NMGetSpecialFolderPath failed!"));
		}

		::ConfMsgBox(	m_hwnd,	(LPCTSTR) (fSavedOk ?
							(UINT_PTR)IDS_SPEED_DIAL_SAVED_ON_DESKTOP :
							(UINT_PTR)IDS_SPEED_DIAL_SAVE_ERROR));
	}
	else
	{
		::FCreateSpeedDial(
				GetAddress(),	// pcszName
				GetAddress(),	// pcszAddress
				addrType,		// addrType
				crpcf,			// dwCallFlags
				NULL,			// pcszRemoteConfName
				NULL,			// pcszPassword
				NULL);	// pcszPathPrefix
	}

	return TRUE;
}

VOID CSpeedDialDlg::RefreshOkButton()
{
	::EnableWindow(	GetDlgItem(m_hwnd, IDOK),
	 				0 != ::GetWindowTextLength(::GetDlgItem(m_hwnd, IDC_CSD_ADDRESS_EDIT)));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\sdialdlg.h ===
// File: sdialdlg.h

#ifndef _SDIALDLG_H_
#define _SDIALDLG_H_

#include "SDKInternal.h"

class CSpeedDialDlg
{
protected:
	HWND		m_hwndParent;
	HWND		m_hwnd;

	LPTSTR		m_pszAddress;
	LPTSTR		m_pszConfName;
	NM_ADDR_TYPE m_addrType;

	VOID		RefreshOkButton();
	BOOL		ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
	NM_ADDR_TYPE GetCurAddrType(void);
	BOOL		AddAddressType(NM_ADDR_TYPE addrType, LPCTSTR lpcszDispName);
	BOOL		AddAddressType(NM_ADDR_TYPE addrType, UINT uStringID);

	// Handlers:
	BOOL		OnTransportChanged();
	BOOL		OnOk();

public:
	// Properties:
	LPTSTR       GetAddress()       {return m_pszAddress;}
	NM_ADDR_TYPE GetAddrType()      {return m_addrType;}
	
	// Methods:
				CSpeedDialDlg(HWND hwndParent, NM_ADDR_TYPE addrType);
				~CSpeedDialDlg();
	INT_PTR	DoModal(LPCTSTR pcszAddress);

	static INT_PTR CALLBACK SpeedDialDlgProc(	HWND hDlg,
											UINT uMsg,
											WPARAM wParam,
											LPARAM lParam);

	// Handlers:
	BOOL		OnInitDialog();
};

#endif // _SDIALDLG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\setupdd.h ===
#ifndef _SETUPDD_H_
#define _SETUPDD_H_

/*
 * SETUPDD.H
 *
 * Global definitions for clients of the code to install the NM display
 * driver for Windows NT.
 *		
 * Author:
 *		dannygl, 05 Apr 97
 */

extern BOOL CanInstallNTDisplayDriver(void);
extern void OnEnableAppSharing(HWND hWnd);

#endif // _SETUPDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\setupdd.cpp ===
/*
 * SETUPDD.CPP
 *
 * The code to install the NM display driver for Windows NT.  This was
 * a standalone application launched by Setup that we are now importing
 * into NM itself.
 *		
 * Author:
 *		dannygl, 05 Apr 97
 */

#include "precomp.h"

#include "conf.h"
#include "confwnd.h"
#include "resource.h"
#include "setupdd.h"


// String to identify the DLL and function that we need to call to install
// the display driver on SP3. 
const TCHAR g_pcszDisplayCPLName[] = TEXT("DESK.CPL");
const CHAR g_pcszInstallDriverAPIName[] = "InstallGraphicsDriver";

const WCHAR g_pcwszDefaultModelName[] = L"Microsoft NetMeeting graphics driver";
const WCHAR g_pcwszDefaultINFName[] = L"MNMDD.INF";


// Maxmimum size of the model name string
const int NAME_BUFFER_SIZE = 128;

// Prototype for the function installed by the Display CPL
typedef DWORD (*PFNINSTALLGRAPHICSDRIVER)(
    HWND    hwnd,
    LPCWSTR pszSourceDirectory,
    LPCWSTR pszModel,
    LPCWSTR pszInf
    );


/* 
 * GetInstallDisplayDriverEntryPoint
 *
 * This function loads the DLL containing the display driver installation
 * code and retrieves the entry point for the installation function.  It
 * is used by the below functions as a utility function.
 *
 * It returns TRUE if it is able to load the library and get the entry point,
 * FALSE if either operation fails.  It is returns TRUE, it also returns the 
 * DLL module handle and the function address.
 */

BOOL
GetInstallDisplayDriverEntryPoint(
	HMODULE *phInstallDDDll,
	PFNINSTALLGRAPHICSDRIVER *ppfnInstallDDFunction)
{
	HMODULE hDll;
	PFNINSTALLGRAPHICSDRIVER pfn = NULL;

	ASSERT(NULL != phInstallDDDll
			&& NULL != ppfnInstallDDFunction);

	hDll = NmLoadLibrary(g_pcszDisplayCPLName,TRUE);

	if (NULL != hDll)
	{
		pfn = (PFNINSTALLGRAPHICSDRIVER) 
				GetProcAddress(hDll,
								g_pcszInstallDriverAPIName);
	}

	// If the entry point exists, we pass it and the DLL handle back to
	// the caller.  Otherwise, we unload the DLL immediately.
	if (NULL != pfn)
	{
		*phInstallDDDll = hDll;
		*ppfnInstallDDFunction = pfn;

		return TRUE;
	}
	else
	{
		if (NULL != hDll)
		{
			FreeLibrary(hDll);
		}

		return FALSE;
	}
}

/* 
 * CanInstallNTDisplayDriver
 *
 * This function determines whether the entry point for installing the
 * NT display driver is availalble (i.e. NT 4.0 SP3 or later).
 */

BOOL
CanInstallNTDisplayDriver(void)
{
	static BOOL fComputed = FALSE;
	static BOOL fRet = FALSE;
	
	ASSERT(::IsWindowsNT());

	// We verify that the major version number is exactly 4 and either
	// the minor version number is greater than 0 or the service pack
	// number (which is stored in the high byte of the low word of the
	// CSD version) is 3 or greater.
	if (! fComputed)
	{
		LPOSVERSIONINFO lposvi = GetVersionInfo();

		if (4 == lposvi->dwMajorVersion)
		{
			if (0 == lposvi->dwMinorVersion)
			{
				RegEntry re(NT_WINDOWS_SYSTEM_INFO_KEY, HKEY_LOCAL_MACHINE, FALSE);

				DWORD dwCSDVersion = 
					re.GetNumber(REGVAL_NT_CSD_VERSION, 0);

				if (3 <= HIBYTE(LOWORD(dwCSDVersion)))
				{
					// This is NT 4.0, SP 3 or later
					fRet = TRUE;
				}
			}
			else
			{
				// We assume that any future version of Windows NT 4.x (x > 0)
				// will support this.
				fRet = TRUE;
			}
		}

		fComputed = TRUE;
	}
			
	ASSERT(fComputed);

	return fRet;
}

/* 
 * OnEnableAppSharing
 *
 * Invoked when the "Enable Application Sharing" menu item is selected.
 *
 * This function determines whether the entry point for installing the
 * NT display driver is available.  If so, it prompts the user to confirm
 * this operation, proceeds with the installation, and then prompts the 
 * user to restart the computer.
 *
 * If not, it presents a text dialog with information about how to get
 * the necessary NT Service Pack(s).
 */

void
OnEnableAppSharing(
	HWND hWnd)
{
	ASSERT(::IsWindowsNT());
    BSTR pwszSourcePath =NULL;

	if (::CanInstallNTDisplayDriver())
	{
		// Confirm the installation with the user
		if (IDYES == ::ConfMsgBox(
							hWnd,
							(LPCTSTR) IDS_ENABLEAPPSHARING_INSTALL_CONFIRM,
							MB_YESNO | MB_ICONQUESTION))
		{
			BOOL fDriverInstallSucceeded = FALSE;
			
			HMODULE hDisplayCPL = NULL;
			PFNINSTALLGRAPHICSDRIVER pfnInstallGraphicsDriver;

			TCHAR pszSourcePath[MAX_PATH];
			LPWSTR pwszSourcePathEnd;
			WCHAR pwszModelNameBuffer[NAME_BUFFER_SIZE];
			LPCWSTR pcwszModelName;
			WCHAR pwszINFNameBuffer[MAX_PATH];
			LPCWSTR pcwszINFName;

			// Get the entry point for display driver installation
			if (! ::GetInstallDisplayDriverEntryPoint(
						&hDisplayCPL,
						&pfnInstallGraphicsDriver))
			{
				ERROR_OUT(("GetInstallDisplayDriverEntryPoint() fails"));
				goto OEAS_AbortInstall;
			}

			// The driver files are located in the NM directory.
			if (! ::GetInstallDirectory(pszSourcePath))
			{
				ERROR_OUT(("GetInstallDirectory() fails"));
				goto OEAS_AbortInstall;
			}
			
        		// Always write display name in UNICODE
        		if(FAILED(LPTSTR_to_BSTR(&pwszSourcePath, pszSourcePath)))
        		{
                            goto OEAS_AbortInstall;
        		}


			if (NULL == pwszSourcePath)
			{
				ERROR_OUT(("AnsiToUnicode() fails"));
				goto OEAS_AbortInstall;
			}

			// Strip the trailing backslash that GetInstallDirectory appends
			pwszSourcePathEnd = (LPWSTR)pwszSourcePath + lstrlenW((LPWSTR)pwszSourcePath);

			// Handle X:\, just to be safe
			if (pwszSourcePathEnd - (LPWSTR)pwszSourcePath > 3)
			{
				ASSERT(L'\\' == *(pwszSourcePathEnd - 1));

				*--pwszSourcePathEnd = L'\0';
			}

			// Read the model name string from the resource file
			if (0 < ::LoadStringW(GetInstanceHandle(), 
								IDS_NMDD_DISPLAYNAME, 
								pwszModelNameBuffer, 
								CCHMAX(pwszModelNameBuffer)))
			{
				pcwszModelName = pwszModelNameBuffer;
			}
			else
			{
				ERROR_OUT(("LoadStringW() fails, err=%lu", GetLastError()));
				pcwszModelName = g_pcwszDefaultModelName;
			}

			// Read the INF name string from the resource file
			if (0 < ::LoadStringW(GetInstanceHandle(), 
								IDS_NMDD_INFNAME, 
								pwszINFNameBuffer, 
								CCHMAX(pwszINFNameBuffer)))
			{
				pcwszINFName = pwszINFNameBuffer;
			}
			else
			{
				ERROR_OUT(("LoadStringW() fails, err=%lu", GetLastError()));
				pcwszINFName = g_pcwszDefaultINFName;
			}


			// Now we're set to call the actual installation function
			DWORD dwErr;

			dwErr = (*pfnInstallGraphicsDriver)(hWnd,
												(LPWSTR)pwszSourcePath,
												pcwszModelName,
												pcwszINFName);

			if (dwErr)
			{
				WARNING_OUT(("InstallGraphicsDriver() fails, err=%lu", dwErr));
			}

			if (ERROR_SUCCESS == dwErr)
			{
				fDriverInstallSucceeded = TRUE;
				g_fNTDisplayDriverEnabled = TRUE;
			}

OEAS_AbortInstall:

                        SysFreeString(pwszSourcePath);


			// If we failed to install the driver, we report an error.
			// If we succeeded, we prompt the user to restart the system.
			if (! fDriverInstallSucceeded)
			{
				::ConfMsgBox(
						hWnd,
						(LPCTSTR) IDS_ENABLEAPPSHARING_INSTALL_FAILURE,
						MB_OK | MB_ICONERROR);
			}
			else if (IDYES == ::ConfMsgBox(
									hWnd,
									(LPCTSTR) IDS_ENABLEAPPSHARING_INSTALL_COMPLETE,
									MB_YESNO | MB_ICONQUESTION))
			{
				// Initiate a system restart.  This involves getting the
				// necessary privileges first.
				HANDLE hToken;
				TOKEN_PRIVILEGES tkp;
				BOOL fRet;

				// Get the current process token handle so we can get shutdown 
				// privilege. 
				fRet = OpenProcessToken(
							GetCurrentProcess(), 
							TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
							&hToken);

				// Get the LUID for shutdown privilege.
				if (fRet) 
				{
					fRet = LookupPrivilegeValue(
								NULL, 
								SE_SHUTDOWN_NAME, 
								&tkp.Privileges[0].Luid);
				}
				else
				{
					hToken = NULL;
					WARNING_OUT(("OpenProcessToken() fails (error %lu)", GetLastError())); 
				}

				// Get shutdown privilege for this process. 
				if (fRet)
				{
					tkp.PrivilegeCount = 1; 
					tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 

					fRet = AdjustTokenPrivileges(
								hToken, 
								FALSE, 
								&tkp, 
								0, 
								(PTOKEN_PRIVILEGES) NULL, 
								0);

					// Special-case scenario where call succeeds but not all
					// privileges were set.
					if (fRet && ERROR_SUCCESS != GetLastError())
					{
						fRet = FALSE;
					}
				}
				else
				{
					WARNING_OUT(("LookupPrivilegeValue() fails (error %lu)", GetLastError())); 
				}


				if (! fRet)
				{
					WARNING_OUT(("AdjustTokenPrivileges() fails (error %lu)", GetLastError())); 
				}

				if (NULL != hToken)
				{
					CloseHandle(hToken);
				}

				if (! ::ExitWindowsEx(EWX_REBOOT, 0))
				{
					WARNING_OUT(("ExitWindowsEx() fails (error %lu)", GetLastError()));
				}
			}

			if (NULL != hDisplayCPL)
			{
				FreeLibrary(hDisplayCPL);
			}
		}
	}
	else
	{
		// Tell the user how to get the SP
		::ConfMsgBox(
			hWnd,
			(LPCTSTR) IDS_ENABLEAPPSHARING_NEEDNTSP);
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\speedial.h ===
// File: speedial.h

#ifndef _SPEEDIAL_H_
#define _SPEEDIAL_H_

#include "confevt.h"
#include "calv.h"

class CSPEEDDIAL : public CALV
{
private:
	TCHAR  m_szFile[MAX_PATH*2];  // large buffer for full path name to file
	LPTSTR m_pszFileName;         // pointer into m_szFile for filename
	int    m_cchFileNameMax;      // maximum length of filename

public:
	CSPEEDDIAL();
	~CSPEEDDIAL();

	VOID CmdDelete(void);
	BOOL FGetSelectedFilename(LPTSTR pszFile);

	// CALV methods
	VOID ShowItems(HWND hwnd);
	VOID OnCommand(WPARAM wParam, LPARAM lParam);
	RAI * GetAddrInfo(void);
};

// Utility routines
BOOL FGetSpeedDialFolder(LPTSTR pszBuffer, UINT cchMax, BOOL fCreate = FALSE);
BOOL FExistingSpeedDial(LPCTSTR pcszAddress, NM_ADDR_TYPE addrType);
BOOL FCreateSpeedDial(LPCTSTR pcszName, LPCTSTR pcszAddress,
			NM_ADDR_TYPE addrType = NM_ADDR_UNKNOWN, DWORD dwCallFlags = CRPCF_DEFAULT,
			LPCTSTR pcszRemoteConfName = NULL, LPCTSTR pcszPassword = NULL,
			LPCTSTR pcszPathPrefix = NULL);

#endif /* _SPEEDIAL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\splash.h ===
// File: splash.h

VOID StartSplashScreen ( HWND hwnd );
VOID StopSplashScreen ( VOID );
VOID UpdateSplashScreen ( VOID );

extern class CFrame *g_pSplashScreen;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\speedial.cpp ===
// File: speedial.cpp

#include "precomp.h"
#include "resource.h"

#include "dirutil.h"
#include "speedial.h"
#include "nameres.h" // for old transports
#include "callto.h"

static const TCHAR g_cszConfLinkExt[] = TEXT(".cnf");
static const TCHAR g_cszConfLinkFilter[] = TEXT("*.cnf");

static const TCHAR g_cszConferenceShortcutSection[] = TEXT("ConferenceShortcut");
static const TCHAR g_cszNameKey[]            = TEXT("ConfName");
static const TCHAR g_cszAddressKey[]         = TEXT("Address");
static const TCHAR g_cszTransportKey[]       = TEXT("Transport");
static const TCHAR g_cszRemoteConfNameKey[]  = TEXT("RemoteConfName");
static const TCHAR g_cszCallFlagsKey[]       = TEXT("CallFlags");
static const TCHAR g_cszPasswordKey[]        = TEXT("Password");

static const int _rgIdMenu[] = {
	IDM_DLGCALL_DELETE,
	0
};

inline VOID DwToSz(DWORD dw, LPTSTR psz)
{
	wsprintf(psz, TEXT("%d"), dw);
}

/*  C  S  P  E  E  D  D  I  A  L  */
/*-------------------------------------------------------------------------
    %%Function: CSPEEDDIAL

-------------------------------------------------------------------------*/
CSPEEDDIAL::CSPEEDDIAL() :
	CALV(IDS_DLGCALL_SPEEDDIAL, II_SPEEDDIAL, _rgIdMenu)
{
	DbgMsg(iZONE_OBJECTS, "CSPEEDDIAL - Constructed(%08X)", this);

	// Check the path to the speed dial folder
	if (!FGetSpeedDialFolder(m_szFile, CCHMAX(m_szFile)))
		return;

	int cchSpeedDialFolder = lstrlen(m_szFile);
	m_szFile[cchSpeedDialFolder++] = _T('\\');
	m_pszFileName = &m_szFile[cchSpeedDialFolder];
	m_cchFileNameMax = CCHMAX(m_szFile) - cchSpeedDialFolder;
	ASSERT(m_cchFileNameMax >= MAX_PATH);
	lstrcpyn(m_pszFileName, g_cszConfLinkFilter, m_cchFileNameMax);

	WIN32_FIND_DATA wfd;
	HANDLE hFind = ::FindFirstFile(m_szFile, &wfd);
	if (INVALID_HANDLE_VALUE == hFind)
		return;
	::FindClose(hFind);

	SetAvailable(TRUE);  // we found at least one file
}

CSPEEDDIAL::~CSPEEDDIAL()
{
	DbgMsg(iZONE_OBJECTS, "CSPEEDDIAL - Destroyed(%08X)", this);
}


///////////////////////////////////////////////////////////////////////////
// CALV methods


/*  S H O W  I T E M S  */
/*-------------------------------------------------------------------------
    %%Function: ShowItems

-------------------------------------------------------------------------*/
VOID CSPEEDDIAL::ShowItems(HWND hwnd)
{
	CALV::SetHeader(hwnd, IDS_ADDRESS);

	if (!FAvailable())
		return;

	lstrcpyn(m_pszFileName, g_cszConfLinkFilter, m_cchFileNameMax);

	WIN32_FIND_DATA wfd;
	HANDLE hFind = ::FindFirstFile(m_szFile, &wfd);
	if (INVALID_HANDLE_VALUE == hFind)
		return;

	for ( ; ; )
	{
		lstrcpyn(m_pszFileName, wfd.cFileName, m_cchFileNameMax);

		TCHAR szAddress[CCHMAXSZ_ADDRESS];
		if (0 != GetPrivateProfileString(g_cszConferenceShortcutSection,
				g_cszAddressKey, g_cszEmpty, szAddress, CCHMAX(szAddress), m_szFile))
		{
			TCHAR szName[MAX_PATH];
			lstrcpyn(szName, wfd.cFileName, lstrlen(wfd.cFileName) - CCHEXT); // no .cnf extension

			DlgCallAddItem(hwnd, szName, szAddress, II_COMPUTER);
		}

		if (FALSE == ::FindNextFile(hFind, &wfd))
		{
			::FindClose(hFind);
			break;
		}
	}
}


VOID CSPEEDDIAL::OnCommand(WPARAM wParam, LPARAM lParam)
{
	switch (GET_WM_COMMAND_ID(wParam, lParam))
		{
	case IDM_DLGCALL_DELETE:
		CmdDelete();
		break;
	default:
		CALV::OnCommand(wParam, lParam);
		break;
		}
}

BOOL CSPEEDDIAL::FGetSelectedFilename(LPTSTR pszFile)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return FALSE;

	if (!FGetSpeedDialFolder(pszFile, MAX_PATH))
		return FALSE;
	LPTSTR psz = pszFile + lstrlen(pszFile);
	*psz++ = _T('\\');

	int cchMax = (INT)(MAX_PATH - (CCHMAX(g_cszConfLinkExt) + psz - pszFile));
	if (!GetSzData(psz, cchMax, iItem, IDI_DLGCALL_NAME))
		return FALSE;

	lstrcat(pszFile, g_cszConfLinkExt);
	return TRUE;
}


VOID CSPEEDDIAL::CmdDelete(void)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return;

	TCHAR szFile[MAX_PATH];
	if (!FGetSelectedFilename(szFile))
		return;

	if (::DeleteFile(szFile))
	{
		DeleteItem(iItem);
	}
}


/*  G E T  A D D R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: GetAddrInfo

-------------------------------------------------------------------------*/
RAI * CSPEEDDIAL::GetAddrInfo(void)
{
	TCHAR szFile[MAX_PATH];
	if (!FGetSelectedFilename(szFile))
		return NULL;

	NM_ADDR_TYPE addrType;
	int iTransport = GetPrivateProfileInt(g_cszConferenceShortcutSection,
				g_cszTransportKey, NAMETYPE_UNKNOWN, szFile);
	switch (iTransport)
		{
	case NAMETYPE_IP:       addrType = NM_ADDR_IP;           break;
	case NAMETYPE_PSTN:     addrType = NM_ADDR_PSTN;         break;
	case NAMETYPE_ULS:      addrType = NM_ADDR_ULS;          break;
	case NAMETYPE_H323GTWY: addrType = NM_ADDR_H323_GATEWAY; break;

	case NAMETYPE_UNKNOWN:  addrType = NM_ADDR_ULS;          break;

	default:                addrType = NM_ADDR_UNKNOWN;      break;
		}

	RichAddressInfo *	pRai	= CALV::GetAddrInfo( addrType );

	if( hasValidUserInfo( pRai ) && (addrType == NM_ADDR_IP) )
	{
		unsigned long	ulDestination;

		if( GetIpAddress( pRai->rgDwStr[0].psz, ulDestination ) != S_OK )
		{
			pRai->rgDwStr[0].dw = NM_ADDR_MACHINENAME;
		}
	}

	return( pRai );
}




/*  F  C R E A T E  S P E E D  D I A L  */
/*-------------------------------------------------------------------------
    %%Function: FCreateSpeedDial

    Return TRUE if a new speed dial was created.

    If pcszPathPrefix is NULL the file will be created only if necessary.
-------------------------------------------------------------------------*/
BOOL FCreateSpeedDial(LPCTSTR pcszName, LPCTSTR pcszAddress,
			NM_ADDR_TYPE addrType, DWORD dwCallFlags,
			LPCTSTR pcszRemoteConfName, LPCTSTR pcszPassword,
			LPCTSTR pcszPathPrefix)
{
	TCHAR sz[MAX_PATH];
	TCHAR szFileName[MAX_PATH*2];
	if (FEmptySz(pcszPathPrefix))
	{
		if (FExistingSpeedDial(pcszAddress, addrType))
		{
			WARNING_OUT(("Duplicate SpeedDial already exists - not creating"));
			return FALSE;
		}

		if (!FGetSpeedDialFolder(szFileName, CCHMAX(szFileName), TRUE))
		{
			ERROR_OUT(("FGetSpeedDialFolder failed!"));
			return FALSE;
		}
	}
	else
	{
		lstrcpyn(szFileName, pcszPathPrefix, CCHMAX(szFileName));
	}

	if (!FCreateNewFile(szFileName, pcszName, g_cszConfLinkExt, szFileName, CCHMAX(szFileName)))
	{
		return FALSE;
	}

	// Write the data to the file
	WritePrivateProfileString(g_cszConferenceShortcutSection, g_cszNameKey, pcszName, szFileName);
	WritePrivateProfileString(g_cszConferenceShortcutSection, g_cszAddressKey, pcszAddress, szFileName);
	
	// Call Flags (normally CRPCF_DEFAULT)
	DwToSz(dwCallFlags, sz);
	WritePrivateProfileString(g_cszConferenceShortcutSection, g_cszCallFlagsKey, sz, szFileName);

	// Transports
	DWORD dwTransport;
	switch (addrType)
		{
	case NM_ADDR_IP:
		dwTransport = NAMETYPE_IP;
		break;

	case NM_ADDR_PSTN:
		dwTransport = NAMETYPE_PSTN;
		break;

	case NM_ADDR_ULS:
		dwTransport = NAMETYPE_ULS;
		break;

	case NM_ADDR_H323_GATEWAY:
		dwTransport = NAMETYPE_H323GTWY;
		break;

	case NM_ADDR_UNKNOWN:
	default:
		dwTransport = NAMETYPE_UNKNOWN;
		break;
		}
	DwToSz(dwTransport, sz);
	WritePrivateProfileString(g_cszConferenceShortcutSection, g_cszTransportKey, sz, szFileName);

	// Remote conference name
	if (!FEmptySz(pcszRemoteConfName))
	{
		WritePrivateProfileString(g_cszConferenceShortcutSection, g_cszRemoteConfNameKey,
			pcszName, pcszRemoteConfName);

		// Remote conference name
		if (!FEmptySz(pcszPassword))
		{
			WritePrivateProfileString(g_cszConferenceShortcutSection, g_cszPasswordKey,
				pcszName, pcszPassword);
		}
	}

	return TRUE;
}



/*  F  E X I S T I N G  S P E E D  D I A L  */
/*-------------------------------------------------------------------------
    %%Function: FExistingSpeedDial

-------------------------------------------------------------------------*/
BOOL FExistingSpeedDial(LPCTSTR pcszAddress, NM_ADDR_TYPE addrType)
{
	TCHAR szFile[MAX_PATH*2];
	if (!FGetSpeedDialFolder(szFile, CCHMAX(szFile)))
		return FALSE;

	lstrcat(szFile, "\\");
	int cchMax = lstrlen(szFile);
	LPTSTR pszFileName = &szFile[cchMax];      // points to the filename
	lstrcpy(pszFileName, g_cszConfLinkFilter);
	cchMax = CCHMAX(szFile) - cchMax;          // The max length of a filename

	WIN32_FIND_DATA wfd;
	HANDLE hFind = ::FindFirstFile(szFile, &wfd);
	if (INVALID_HANDLE_VALUE == hFind)
		return FALSE;

	BOOL fFound = FALSE;
	for ( ; ; )
	{
		lstrcpyn(pszFileName, wfd.cFileName, cchMax);

		TCHAR szAddress[CCHMAXSZ_ADDRESS];
		if (0 != GetPrivateProfileString(g_cszConferenceShortcutSection,
				g_cszAddressKey, g_cszEmpty, szAddress, CCHMAX(szAddress), szFile))
		{
			if (0 == lstrcmp(szAddress, pcszAddress))
			{
				fFound = TRUE;
				break;
			}
		}

		if (!FindNextFile(hFind, &wfd))
			break;
	}

	::FindClose(hFind);
	return fFound;
}


/*-------------------------------------------------------------------------
    %%Function: GetSpeedDialFolderName

-------------------------------------------------------------------------*/
bool GetSpeedDialFolderName(LPTSTR pszBuffer, int cbLength)
{
	ASSERT( pszBuffer != NULL );
	ASSERT( cbLength > 0 );

	RegEntry	re( CONFERENCING_KEY, HKEY_LOCAL_MACHINE );

	LPTSTR		pszFolder	= re.GetString( REGVAL_SPEED_DIAL_FOLDER );
	bool		bResult		= !FEmptySz( pszFolder );

	if( !bResult )
	{
		TCHAR	szNewFolder[ MAX_PATH ];

		if( GetInstallDirectory( szNewFolder ) )
		{
			TCHAR	szSDFolder[ MAX_PATH ];

			FLoadString( IDS_SPEEDDIAL_FOLDER, szSDFolder, CCHMAX( szSDFolder ) );

			ASSERT( (lstrlen( szNewFolder) + lstrlen( szSDFolder )) < CCHMAX( szNewFolder ) );

			lstrcat( szNewFolder, szSDFolder );

			pszFolder	= szNewFolder;
			bResult		= true;
	
			// Set the registry entry
			RegEntry	re2( CONFERENCING_KEY, HKEY_LOCAL_MACHINE );
			
			re2.SetValue( REGVAL_SPEED_DIAL_FOLDER, szNewFolder );
		}
	}

	if( bResult )
	{
		lstrcpyn( pszBuffer, pszFolder, cbLength );
	}

	return( bResult );

}


/*  C R E A T E  S P E E D  D I A L  F O L D E R  */
/*-------------------------------------------------------------------------
    %%Function: CreateSpeedDialFolder

-------------------------------------------------------------------------*/
BOOL CreateSpeedDialFolder(LPTSTR pszBuffer, int cbLength)
{
	BOOL	bResult	= FALSE;

	if( GetSpeedDialFolderName( pszBuffer, cbLength ) )
	{
		bResult = ::FEnsureDirExists( pszBuffer );
	}

	return( bResult );

}


/*  F  G E T  S P E E D  D I A L  F O L D E R  */
/*-------------------------------------------------------------------------
    %%Function: FGetSpeedDialFolder

-------------------------------------------------------------------------*/
BOOL FGetSpeedDialFolder(LPTSTR pszBuffer, UINT cchMax, BOOL fCreate)
{
	bool	bResult	= false;

	if( GetSpeedDialFolderName( pszBuffer, cchMax ) )
	{
		if( ::FDirExists( pszBuffer ) )
		{
			bResult = true;
		}
		else if( fCreate )
		{
			bResult = (CreateSpeedDialFolder( pszBuffer, cchMax ) != FALSE);
		}
	}

	return( (BOOL) bResult );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\statbar.h ===
// File: statbar.h

#ifndef _STATBAR_H_
#define _STATBAR_H_

#include "ConfRoom.h"

class CConfStatusBar
{
protected:
	static CConfStatusBar * m_pStatusBar;
public:
	static CConfStatusBar * GetInstance()   { return m_pStatusBar; }
	
private:
	enum StatIcon
	{
		StatConnect = 0,
		StatLogin,
		StatIconCount
	} ;

	HWND	m_hwnd;
	HWND	m_hwndLoginTT;					// The tooltip window
	HICON	m_hIconStatus[StatIconCount];	// handle to status bar icon
	DWORD   m_idIconStatus[StatIconCount];	// id of current status bar icon
	CConfRoom*	m_pcrParent;
	TCHAR	m_szULSStatus[MAX_PATH];

	BOOL    m_fVisible : 1;			// TRUE if status bar displayed

	VOID	SetIcon(StatIcon eIcon, DWORD dwId);
	VOID	SetText(UINT uID, LPCTSTR sz);
	void	SetTooltip(StatIcon eIcon, LPCTSTR szTip);

public:
			CConfStatusBar(CConfRoom* pcr);
			~CConfStatusBar();

	VOID	Update();
	int		GetHeight();
	BOOL	Create(HWND hwndParent);
	VOID	Show(BOOL fShow);
	VOID	ResizeParts();
	VOID	Resize(WPARAM wParam, LPARAM lParam);
	BOOL	OnDraw(LPDRAWITEMSTRUCT pdis);
	VOID	RemoveHelpText();
	VOID	SetHelpText(LPCTSTR pcszText);
	BOOL    FVisible()              { return (m_fVisible != FALSE); }
	HWND    GetHwnd()               { return m_hwnd; }
	VOID    ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif // _STATBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\statbar.cpp ===
/****************************************************************************
*
*    FILE:     StatBar.cpp
*
*    CREATED:  Chris Pirich (ChrisPi) 3-25-96
*
*    CONTENTS: CConfStatusBar object
*
****************************************************************************/

#include "precomp.h"
#include "resource.h"
#include "statbar.h"
#include "NmLdap.h"
#include "call.h"
#include "cr.h"
#include "confwnd.h"
#include "ConfPolicies.h"

static inline void TT_AddToolInfo(HWND hwnd, TOOLINFO *pti)
{
	SendMessage(hwnd, TTM_ADDTOOL, 0, reinterpret_cast<LPARAM>(pti));
}

static inline void TT_GetToolInfo(HWND hwnd, TOOLINFO *pti)
{
	SendMessage(hwnd, TTM_GETTOOLINFO, 0, reinterpret_cast<LPARAM>(pti));
}

static inline void TT_SetToolInfo(HWND hwnd, TOOLINFO *pti)
{
	SendMessage(hwnd, TTM_SETTOOLINFO, 0, reinterpret_cast<LPARAM>(pti));
}

// Status Bar area indexes
enum
{
	ID_SBP_TEXT,
	// ID_SBP_ULS,
	ID_SBP_ICON,
	NUM_STATUSBAR_WELLS
} ;

// Status Bar area measurements (pixels)
static const UINT DXP_SB_PROG =          96;
static const UINT DXP_SB_ULS =          0; // 220;
static const UINT DXP_SB_ICON =          22;
static const UINT DXP_SB_DEF_ICON =      40;

static const int IconBorder = 2;
static const int StatSepBorder = 2;

CConfStatusBar * CConfStatusBar::m_pStatusBar = NULL;

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   CConfStatusBar
*
*    PURPOSE:  Constructs object
*
****************************************************************************/

CConfStatusBar::CConfStatusBar(CConfRoom* pcr) :
	m_pcrParent		(pcr),
	m_fVisible		(FALSE),
	m_hwnd			(NULL)
{
	DebugEntry(CConfStatusBar::CConfStatusBar);

	ASSERT(NULL == m_pStatusBar);
	m_pStatusBar = this;

	m_szULSStatus[0] = _T('\0');

	for (int i=0; i<StatIconCount; ++i)
	{
		m_hIconStatus[i] = NULL;
		m_idIconStatus[i] = 0;
	}

	DebugExitVOID(CConfStatusBar::CConfStatusBar);
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   !CConfStatusBar
*
*    PURPOSE:  Destructs object
*
****************************************************************************/

CConfStatusBar::~CConfStatusBar()
{
	DebugEntry(CConfStatusBar::~CConfStatusBar);
	
	if (NULL != m_hwnd)
	{
		::DestroyWindow(m_hwnd);
	}

	m_pStatusBar = NULL;

	for (int i=0; i<StatIconCount; ++i)
	{
		if (NULL != m_hIconStatus[i])
		{
			DestroyIcon(m_hIconStatus[i]);
		}
	}

	DebugExitVOID(CConfStatusBar::~CConfStatusBar);
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   OnDraw(LPDRAWITEMSTRUCT pdis)
*
*    PURPOSE:  Handles drawing the status bar icon
*
****************************************************************************/

BOOL CConfStatusBar::OnDraw(LPDRAWITEMSTRUCT pdis)
{
	ASSERT(pdis);
	if (NULL != (pdis->itemData))
	{
		int nLeft = pdis->rcItem.left;
		int nTop = pdis->rcItem.top;
		int xSmIcon = ::GetSystemMetrics(SM_CXSMICON);
		int ySmIcon = ::GetSystemMetrics(SM_CYSMICON);

		int nWidth = xSmIcon;
		int nHeight = pdis->rcItem.bottom - pdis->rcItem.top;
		if (nHeight > ySmIcon)
		{
			nTop += (nHeight - ySmIcon) / 2;
			nHeight = ySmIcon;
		}

		for (int i=0; i<StatIconCount; ++i)
		{
			nLeft += IconBorder;

			if (NULL != m_hIconStatus[i])
			{
				::DrawIconEx(	pdis->hDC, 
								nLeft, 
								nTop, 
								m_hIconStatus[i],
								nWidth,
								nHeight,
								0,
								NULL,
								DI_NORMAL);
			}

			nLeft += xSmIcon;
		}
	}
	
	return TRUE;
}

VOID CConfStatusBar::ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (NULL == m_hwnd)
		return;

	::SendMessage(m_hwnd, uMsg, wParam, lParam);
}


/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   Resize(WPARAM wParam, LPARAM lParam)
*
*    PURPOSE:  Handles window resizing
*
****************************************************************************/
VOID CConfStatusBar::Resize(WPARAM wParam, LPARAM lParam)
{
	if (NULL != m_hwnd)
	{
		::SendMessage(m_hwnd, WM_SIZE, wParam, lParam);
		ResizeParts();
	}
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   Create(HWND hwndParent)
*
*    PURPOSE:  Creates the status bar window
*
****************************************************************************/

BOOL CConfStatusBar::Create(HWND hwndParent)
{
	DebugEntry(CConfStatusBar::Create);

	BOOL bRet = FALSE;
	
	m_hwnd = CreateStatusWindow(WS_CHILD | WS_BORDER,
								g_szEmpty,
								hwndParent,
								ID_STATUS);
	if (NULL != m_hwnd)
	{
		// Create the ToolTip
		m_hwndLoginTT = CreateWindowEx(0,
											TOOLTIPS_CLASS, 
											(LPSTR) NULL, 
											0, // styles 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											m_hwnd, 
											(HMENU) NULL, 
											::GetInstanceHandle(), 
											NULL); 

		// Add the ToolTips for the 2 icons
		if (NULL != m_hwndLoginTT)
		{
			TOOLINFO ti;

			ti.cbSize = sizeof(TOOLINFO);
			ti.hwnd = m_hwnd;
			ti.hinst = ::GetInstanceHandle();
			ti.lpszText = const_cast<LPTSTR>(g_szEmpty);
			SetRect(&ti.rect, 0, 0, 0, 0);

			for (UINT i=0; i<StatIconCount; ++i)
			{
				ti.uId = i;
				ti.uFlags = TTF_SUBCLASS;
				TT_AddToolInfo(m_hwndLoginTT, &ti);
			}
		}

		// create progress meter window
		ResizeParts();
		Update();
		bRet = TRUE;
	}
	else
	{
		WARNING_OUT(("CConfStatusBar::Create - Unable to create status window"));
	}

	DebugExitBOOL(CConfStatusBar::Create, bRet);

	return bRet;
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    FUNCTION: ResizeParts()
*
*    PURPOSE:  Calculates the correct size of the status bar parts
*
****************************************************************************/

VOID CConfStatusBar::ResizeParts()
{
	ASSERT(m_hwnd);

	int xSmIcon = ::GetSystemMetrics(SM_CXSMICON);

#ifdef RESIZEABLE_WINDOW
	UINT uIconPartWidth = DXP_SB_DEF_ICON;
	NONCLIENTMETRICS ncm;
	ncm.cbSize = sizeof(ncm);
	if (::SystemParametersInfo(	SPI_GETNONCLIENTMETRICS,
								0,
								&ncm,
								0))
	{
		m_nScrollWidth = ncm.iScrollWidth;
		uIconPartWidth = DXP_SB_ICON + m_nScrollWidth;
	}
#else // RESIZEABLE_WINDOW
	// Room for 2 icons
	UINT uIconPartWidth = StatSepBorder + IconBorder + xSmIcon
		+ IconBorder + xSmIcon + IconBorder + StatSepBorder;
#endif // RESIZEABLE_WINDOW

	// re-calculate positions of each tray part
	RECT rc;
	::GetWindowRect(m_hwnd, &rc);
	DWORD dxp = rc.right - rc.left;
	if (dxp > uIconPartWidth)
	{
		DWORD rgPos[NUM_STATUSBAR_WELLS];  // right edge positions for each part
		rgPos[ID_SBP_TEXT] = dxp - (DXP_SB_ULS + uIconPartWidth);
		// rgPos[ID_SBP_ULS] = dxp - uIconPartWidth;
		rgPos[ID_SBP_ICON] = (DWORD) -1;
		::SendMessage(	m_hwnd,
						SB_SETPARTS,
						(WPARAM) ARRAY_ELEMENTS(rgPos),
						(LPARAM) rgPos);

		if (m_hwndLoginTT)
		{
			TCHAR szTitle[MAX_PATH];
			TOOLINFO ti;
			ti.cbSize = sizeof(TOOLINFO); 
			ti.hwnd = m_hwnd;

			int nIconsLeft = dxp - uIconPartWidth + StatSepBorder + IconBorder;

			for (UINT i=0; i<StatIconCount; ++i)
			{
				ti.uId = i;
				ti.lpszText = szTitle;
				TT_GetToolInfo(m_hwndLoginTT, &ti);

				// HACKHACK georgep: Just setting the height to a large number, since
				// I don't know exactly where the icon will be drawn until it is drawn
				SetRect(&ti.rect, nIconsLeft, 0, nIconsLeft + xSmIcon, 1000);

				ti.uFlags = TTF_SUBCLASS;
				TT_SetToolInfo(m_hwndLoginTT, &ti);

				nIconsLeft += xSmIcon + IconBorder;
			}
		}
	}
}

void CConfStatusBar::SetTooltip(StatIcon eIcon, LPCTSTR szTip)
{
	TCHAR szTitle[MAX_PATH];
	TOOLINFO ti;
	ti.cbSize = sizeof(TOOLINFO); 
	ti.hwnd = m_hwnd;
	ti.lpszText = szTitle;

	ti.uId = eIcon;
	TT_GetToolInfo(m_hwndLoginTT, &ti);

	ti.lpszText = const_cast<LPTSTR>(szTip);
	ti.uFlags = TTF_SUBCLASS;
	TT_SetToolInfo(m_hwndLoginTT, &ti);
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   RemoveHelpText()
*
*    PURPOSE:  Removes the status bar help text
*
****************************************************************************/
VOID CConfStatusBar::RemoveHelpText()
{
	// Taking status bar out of simple mode
	if (NULL != m_hwnd)
	{
		::SendMessage(m_hwnd, SB_SIMPLE, FALSE, 0);
	}
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   SetHelpText(LPCTSTR pcszText)
*
*    PURPOSE:  Sets the status bar help text
*
****************************************************************************/

VOID CConfStatusBar::SetHelpText(LPCTSTR pcszText)
{
	// Putting status bar into simple mode
	if (NULL != m_hwnd)
	{
		::SendMessage(m_hwnd, SB_SIMPLE, TRUE, 0);
	
		// 255 means simple mode - only 1 pane
		::SendMessage(	m_hwnd,
						SB_SETTEXT,
						255 | SBT_NOBORDERS,
						(LPARAM) pcszText);
	}
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   Show(BOOL fShow)
*
*    PURPOSE:  Handles the toggling of the status bar window
*
****************************************************************************/

VOID CConfStatusBar::Show(BOOL fShow)
{
	DebugEntry(CConfStatusBar::Show);
	
	fShow = fShow != FALSE;
	if (m_fVisible != fShow)
	{
		m_fVisible = fShow;

		if (NULL != m_hwnd)
		{
			::ShowWindow(m_hwnd, m_fVisible ? SW_SHOW : SW_HIDE);
		}

		// Force a resize
		ResizeParts();
	}
	
	DebugExitVOID(CConfStatusBar::Show);
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   GetHeight()
*
*    PURPOSE:  Returns the height in pixels of the status bar
*
****************************************************************************/

int CConfStatusBar::GetHeight()
{
	RECT rc = {0, 0, 0, 0};

	if (m_fVisible && (NULL != m_hwnd))
	{
		GetWindowRect(m_hwnd, &rc);
	}
	return (rc.bottom - rc.top);
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   SetIcon(DWORD dwId)
*
*    PURPOSE:  Set the status bar icon
*
****************************************************************************/

VOID CConfStatusBar::SetIcon(StatIcon eIcon, DWORD dwId)
{
	DWORD &idIconStatus = m_idIconStatus[eIcon];
	HICON &hIconStatus  = m_hIconStatus [eIcon];

	if ((NULL != m_hwnd) && (dwId != idIconStatus))
	{
		TRACE_OUT(("Changing Icon from %d to %d", m_idIconStatus, dwId));
		// REVIEW: what happens to old m_hIconStatus?
		HICON hIcon = (HICON) ::LoadImage(::GetInstanceHandle(),
									MAKEINTRESOURCE(dwId),
									IMAGE_ICON,
									::GetSystemMetrics(SM_CXSMICON),
									::GetSystemMetrics(SM_CYSMICON),
									LR_DEFAULTCOLOR);
		if (NULL != hIcon)
		{
			idIconStatus = dwId;
			if (NULL != hIconStatus)
			{
				::DestroyIcon(hIconStatus);
			}
			hIconStatus = hIcon;
			::SendMessage(	m_hwnd,
							SB_SETTEXT, 
							ID_SBP_ICON | SBT_OWNERDRAW,
							(LPARAM) hIconStatus);
		}
		else
		{
			WARNING_OUT(("Unable to load status bar icon id=%d", dwId));
		}
	}
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   SetText(UINT uID, LPCTSTR pcszText)
*
*    PURPOSE:  Set the status bar text
*
****************************************************************************/

VOID CConfStatusBar::SetText(UINT uID, LPCTSTR pcszText)
{
	lstrcpyn( m_szULSStatus, pcszText, CCHMAX(m_szULSStatus) );

	if (NULL != m_hwnd)
	{
		::SendMessage(m_hwnd, SB_SETTEXT, uID, (LPARAM) pcszText);
	}
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    FUNCTION: Update()
*
*    PURPOSE:  Updates the status bar
*
****************************************************************************/

VOID CConfStatusBar::Update()
{
	DBGENTRY(CConfStatusBar::Update);

	ASSERT(m_pcrParent);

	if (!m_fVisible)
		return;

	TCHAR	szCallStatus[ MAX_PATH * 3 ];	//	Call status is status + url and url can be 512 by itself...
	UINT    uCallIcon = 0;
	DWORD	dwCallTick = 0;

	if (0 == dwCallTick)
	{
		// no current calls - check if switching a/v
		dwCallTick = GetCallStatus(szCallStatus, CCHMAX(szCallStatus), &uCallIcon);
	}
	
	// if a call was started more recently than any other action, OR nothing is going on
	// (in which case all ticks should equal zero), use the conference / call status
	if (dwCallTick == 0)
	{
		// All ticks are zero - Get the default conference status bar info
		m_pcrParent->GetConferenceStatus(szCallStatus, CCHMAX(szCallStatus), &uCallIcon);
	}

	SetText(ID_SBP_TEXT, szCallStatus);
	SetIcon(StatConnect, uCallIcon);
	SetTooltip(StatConnect, szCallStatus);

	TCHAR szOldULSStatus[ARRAY_ELEMENTS(m_szULSStatus)];
	lstrcpy(szOldULSStatus, m_szULSStatus);
	USES_RES2T
	switch( g_GkLogonState )
	{
		case NM_GK_IDLE:
			uCallIcon = IDI_NETGRAY;
			lstrcpy(m_szULSStatus, RES2T(ID_STATUS_NOT_LOGGED_ON_TO_GATEKEEPER));
			break;

		case NM_GK_LOGGING_ON:
			uCallIcon = IDS_STATUS_WAITING;
			lstrcpy(m_szULSStatus, RES2T(ID_STATUS_LOGING_ONTO_GATEKEEPER));
			break;

		case NM_GK_LOGGED_ON:
			uCallIcon = IDI_NET;
			lstrcpy(m_szULSStatus, RES2T(ID_STATUS_LOGGED_ONTO_GATEKEEPER));
			break;

		default:				
			uCallIcon = IDI_NETGRAY;
			if(ConfPolicies::CallingMode_Direct == ConfPolicies::GetCallingMode())
			{
				if(g_pLDAP)
				{
					g_pLDAP->GetStatusText(m_szULSStatus, CCHMAX(m_szULSStatus), &uCallIcon);
				}
				else
				{
					lstrcpy(m_szULSStatus, RES2T(ID_STATUS_LOGGEDOFF));
				}
			}
			else
			{
				lstrcpy(m_szULSStatus, RES2T(ID_STATUS_NOT_LOGGED_ON_TO_GATEKEEPER));
			}
			break;
	}

	if (lstrcmp(szOldULSStatus, m_szULSStatus))
	{
		SetTooltip(StatLogin, m_szULSStatus);
	}
	SetIcon(StatLogin, uCallIcon);

	::UpdateWindow(m_hwnd);
}



/*  F O R C E  S T A T U S  B A R  U P D A T E  */
/*-------------------------------------------------------------------------
    %%Function: ForceStatusBarUpdate

    Force an update of the status bar.
    This can be called from any thread.
    All main UI updates should be done from the main thread.
-------------------------------------------------------------------------*/
VOID ForceStatusBarUpdate(void)
{
	CConfRoom * pcr = ::GetConfRoom();
	if (NULL != pcr)
	{
		PostMessage(pcr->GetTopHwnd(), WM_STATUSBAR_UPDATE, 0, 0);
	}
}

///////////////////////////////////////////////////////////////////////////

/*  C M D  V I E W  S T A T U S  B A R  */
/*-------------------------------------------------------------------------
    %%Function: CmdViewStatusBar
    
-------------------------------------------------------------------------*/
VOID CmdViewStatusBar(void)
{
	CConfStatusBar * pStatusBar = CConfStatusBar::GetInstance();
	if (NULL == pStatusBar)
		return;

	CConfRoom * pcr = ::GetConfRoom();
	if (NULL == pcr)
		return;
	HWND hwnd = pcr->GetTopHwnd();

	// Turn off redraws:
	::SendMessage(hwnd, WM_SETREDRAW, FALSE, 0);

	// Toggle visibility
	pStatusBar->Show(!pStatusBar->FVisible());
	::SendMessage(hwnd, WM_SETREDRAW, TRUE, 0);

	pcr->ForceWindowResize();

	UpdateUI(CRUI_STATUSBAR);
}


/*  C H E C K  M E N U _  V I E W  S T A T U S  B A R  */
/*-------------------------------------------------------------------------
    %%Function: CheckMenu_ViewStatusBar
    
-------------------------------------------------------------------------*/
BOOL CheckMenu_ViewStatusBar(HMENU hMenu)
{
	BOOL fCheck = FALSE;
	CConfStatusBar * pStatusBar = CConfStatusBar::GetInstance();
	if (NULL != pStatusBar)
	{
		fCheck = pStatusBar->FVisible();
		if (NULL != hMenu)
		{
			::CheckMenuItem(hMenu, IDM_VIEW_STATUSBAR,
				fCheck ? MF_CHECKED : MF_UNCHECKED);
		}
	}

	return fCheck;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\splash.cpp ===
// File: splash.cpp

#include "precomp.h"
#include "resource.h"
#include "conf.h"

#include "GenWindow.h"
#include "GenContainers.h"
#include "GenControls.h"

static const int DXP_LOGO_LEFT      = 182;
static const int DYP_LOGO_COPYRIGHT = 24;
static const int LogoBorder         = 10;

CFrame *g_pSplashScreen = NULL;

HPALETTE PaletteFromBitmap(HINSTANCE hInst, LPCTSTR pszRes)
{
	HRSRC hFind = FindResource(hInst, pszRes, RT_BITMAP);
	if (NULL == hFind)
	{
		return(NULL);
	}
	HGLOBAL hRsrc = LoadResource(_Module.GetModuleInstance(), hFind);
	if (NULL == hRsrc)
	{
		return(NULL);
	}

	HPALETTE hRet = NULL;
	LPVOID pRsrc = LockResource(hRsrc);
	if (NULL != pRsrc)
	{
		BITMAPINFO *pbmi = reinterpret_cast<BITMAPINFO*>(pRsrc);
		BITMAPINFOHEADER &bmih = pbmi->bmiHeader;

		ASSERT(1 == bmih.biPlanes);

		if (8 >= bmih.biBitCount)
		{
			RGBQUAD *rgb = pbmi->bmiColors;

			struct
			{
				LOGPALETTE pal;
				PALETTEENTRY palPalEntry[256];
			} myPal;
			myPal.pal.palVersion = 0x300;
			myPal.pal.palNumEntries = LOWORD(bmih.biClrUsed);
			if (0 == myPal.pal.palNumEntries)
			{
				myPal.pal.palNumEntries = 1 << bmih.biBitCount;
			}
			ASSERT(myPal.pal.palNumEntries <= 1 << bmih.biBitCount);

			for (int i=myPal.pal.palNumEntries-1; i>=0; --i)
			{
				PALETTEENTRY &pe = myPal.pal.palPalEntry[i];

				pe.peRed   = rgb[i].rgbRed;
				pe.peGreen = rgb[i].rgbGreen;
				pe.peBlue  = rgb[i].rgbBlue;
				pe.peFlags = PC_NOCOLLAPSE;
			}

			hRet = CreatePalette(&myPal.pal);
		}

		UnlockResource(hRsrc);
	}

	FreeResource(hRsrc);

	return(hRet);
}

class CSplashFrame : public CFrame
{
public:
	CSplashFrame() : m_hPal(NULL) {}

	HPALETTE m_hPal;

	virtual HPALETTE GetPalette()
	{
		return(m_hPal);
	}

protected:
	~CSplashFrame()
	{
		if (NULL != m_hPal)
		{
			DeleteObject(m_hPal);
		}
	}
} ;

static HBITMAP LoadSplashBitmap()
{
	HBITMAP hBmp = (HBITMAP) LoadImage(::GetInstanceHandle(), MAKEINTRESOURCE(IDB_SPLASH),
			IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_CREATEDIBSECTION);

	if (NULL == hBmp)
	{
		ERROR_OUT(("Error loading splash screen bitmap"));
		return(NULL);
	}

	BITMAP bmp;
	GetObject(hBmp, sizeof(BITMAP), (LPVOID)&bmp);

	// Create a DC
	HDC hdc = CreateCompatibleDC(NULL);
	if (NULL == hdc)
	{
		return(hBmp);
	}

	// Use the dialog font but make sure it's the right size
	// it better be a scalable truetype font!
	LOGFONT logFont;
	::GetObject((HFONT)GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONT), &logFont );

	// Look for a string resource which sets the font size
	// and set the font size to this value if present
	USES_RES2T
	lstrcpy(logFont.lfFaceName, RES2T(IDS_SPLASHFONT));
	if ('\0' == logFont.lfFaceName[0])
	{
		lstrcpy(logFont.lfFaceName, TEXT("Arial"));
	}
	logFont.lfHeight = - LoadResInt(IDS_SPLASHFONTSIZE, 11);

	HFONT hFont = CreateFontIndirect (&logFont);
	if (NULL != hFont)
	{
		SelectObject(hdc, hFont);
	}
	SelectObject(hdc, hBmp);

	::SetTextColor(hdc, RGB(0, 0, 0)); // black

	// The following code assumes the bitmap is
	// a certain size, so assert on that here.
	// If this assertion doesn't hold the text positions
	// have to be adjusted.
	ASSERT(bmp.bmWidth == 398);
	ASSERT(bmp.bmHeight == 245);

	SetBkMode(hdc, TRANSPARENT);

	// Do the Copyright message (multiple lines)
	TCHAR sz[400]; // must be large enuf for owner+company and copyright text
	FLoadString(IDS_COPYRIGHT, sz, CCHMAX(sz));

	RECT rc ={
		DXP_LOGO_LEFT, DYP_LOGO_COPYRIGHT,
		bmp.bmWidth - LogoBorder, bmp.bmHeight - LogoBorder
	};
	DrawText(hdc, sz, -1, &rc, DT_LEFT | DT_NOPREFIX | DT_WORDBREAK);

//#define FINAL
#ifndef FINAL  // Don't just delete this - compile with FINAL defined!
		{
		COLORREF bkColor = SetTextColor(hdc, RGB(0xFF, 0, 0));
		HFONT hFontBig = CreateFont(-28, 0, 0, 0, FW_BOLD,
			FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_TT_PRECIS,
			CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
			DEFAULT_PITCH | FF_DONTCARE,
			TEXT("Arial"));

		FLoadString(IDS_ABOUT_OTHER, sz, CCHMAX(sz));
		if (NULL != hFontBig)
		{
			HFONT hOldFont = (HFONT)SelectObject (hdc, hFontBig);

			SetRect(&rc, 280, 151, bmp.bmWidth, bmp.bmHeight);
			DrawText(hdc, sz, lstrlen(sz), &rc,
				DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX);
			SelectObject(hdc, hOldFont);
			DeleteObject(hFontBig);
		}
		SetTextColor(hdc, bkColor);
	}
#endif /* FINAL */
#undef FINAL

	DeleteDC(hdc);

	if (NULL != hFont)
	{
		DeleteObject(hFont);
	}

	return(hBmp);
}

VOID UpdateSplashScreen ( VOID );

/*  S T A R T  S P L A S H  S C R E E N */
/*----------------------------------------------------------------------------
    %%Function: StartSplashScreen
 
----------------------------------------------------------------------------*/
VOID StartSplashScreen(HWND hwndParent)
{
	if (NULL != g_pSplashScreen)
	{
		return;
	}

	CSplashFrame *pFrame = new CSplashFrame();
	g_pSplashScreen = pFrame;
	if (NULL != pFrame)
	{
		if (!g_fHiColor)
		{
			pFrame->m_hPal = PaletteFromBitmap(_Module.GetModuleInstance(),
				MAKEINTRESOURCE(IDB_SPLASH));
		}

		if (pFrame->Create(hwndParent, g_szEmpty, WS_POPUP | WS_BORDER,
			WS_EX_TOOLWINDOW | g_wsLayout, -1000, -1000, 10, 10,
			_Module.GetModuleInstance()))
		{
			CBitmapButton *pButton = new CBitmapButton();
			if (NULL != pButton)
			{
				HBITMAP hBmp = LoadSplashBitmap();

				pButton->Create(pFrame->GetWindow(), 0, hBmp, 1);

				pFrame->Resize();

				pFrame->Layout();
				pButton->Layout();

				pFrame->MoveEnsureVisible(-1000, -1000);

				ShowWindow(pFrame->GetWindow(), SW_SHOW);

				UpdateSplashScreen();

				pButton->Release();
			}
		}
	}
}

/*  S T O P  S P L A S H  S C R E E N */
/*----------------------------------------------------------------------------
    %%Function: StopSplashScreen
 
----------------------------------------------------------------------------*/
VOID StopSplashScreen ( VOID )
{
	if (NULL != g_pSplashScreen)
	{
		HWND hwnd = g_pSplashScreen->GetWindow();
		if (NULL != hwnd)
		{
			DestroyWindow(hwnd);
		}

		g_pSplashScreen->Release();
		g_pSplashScreen = NULL;
	}
}

/*  U P D A T E  S P L A S H  S C R E E N */
/*----------------------------------------------------------------------------
    %%Function: UpdateSplashScreen
 
----------------------------------------------------------------------------*/
VOID UpdateSplashScreen ( VOID )
{
	if (NULL != g_pSplashScreen)
	{
		HWND hwnd = g_pSplashScreen->GetWindow();
		if (NULL != hwnd)
		{
			RedrawWindow(hwnd, NULL, NULL, RDW_ALLCHILDREN|RDW_UPDATENOW);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\strings.cpp ===
// File: strings.cpp

#include "precomp.h"

// Non-localizable strings

const TCHAR g_szEmpty[]   = _TEXT("");
const TCHAR g_cszBackgroundSwitch[] = _TEXT("Background");

// Window Class Names
const TCHAR g_szButton[]           = _TEXT("button");
const TCHAR g_szEdit[]             = _TEXT("edit");

const TCHAR g_szNMWindowClass[]    = _TEXT("NMWindowClass");
const TCHAR g_szConfRoomClass[]    = _TEXT("MPWClass");
const TCHAR g_szFloatWndClass[]    = _TEXT("MPFloatWClass");
const TCHAR g_szPopupMsgWndClass[] = _TEXT("MPPopupMsgWClass");
const TCHAR g_szRebarFrameClass[]  = _TEXT("ConfRebarFrameClass");
const TCHAR g_szAudioBandClass[]   = _TEXT("ConfAudioBandClass");
const TCHAR g_szAudioLevelBandClass[]   = _TEXT("ConfAudioLevelBandClass");

const TCHAR g_cszSysListView[]     = TEXT("SysListView32");
//
const TCHAR g_cszHelpFileName[]    = TEXT("conf.hlp");

// Frequently used registry keys (from confreg.h)
TCHAR * g_szConferencingKey        = _TEXT("SOFTWARE\\Microsoft\\Conferencing");
TCHAR * g_szUiKey                  = _TEXT("SOFTWARE\\Microsoft\\Conferencing\\UI");
TCHAR * g_szAudioKey               = _TEXT("SOFTWARE\\Microsoft\\Conferencing\\Audio Control");
TCHAR * g_szIlsKey                 = _TEXT("Software\\Microsoft\\User Location Service\\Client");


// moved over from api/nminf
// should be merged with above strings

const TCHAR * g_cszEmpty           = TEXT("");

const TCHAR * g_cszCallTo          = TEXT("callto:");
const TCHAR * g_cszConfExeName     = TEXT("conf.exe");

const TCHAR * g_cszListView        = TEXT("SysListView32");
const TCHAR * g_cszButton          = TEXT("Button");
const TCHAR * g_cszEdit            = TEXT("Edit");
const TCHAR * g_cszComboBox        = TEXT("ComboBox");
const TCHAR * g_cszComboBoxEx      = TEXT("ComboBoxEx32");
const TCHAR * g_cszStatic          = TEXT("STATIC");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\syspol.cpp ===
// File: syspol.cpp
//
// System policies
//
// This class tries to be efficient by only opening the key once
// and using KEY_QUERY_VALUE.
//
// Normally the policy keys don't exist, so the default setting is very important.

#include "precomp.h"
#include "syspol.h"

HKEY SysPol::m_hkey = NULL;


/*  F  E N S U R E  K E Y  O P E N  */
/*-------------------------------------------------------------------------
    %%Function: FEnsureKeyOpen
    
-------------------------------------------------------------------------*/
bool SysPol::FEnsureKeyOpen(void)
{
	if (NULL == m_hkey)
	{
		long lErr = ::RegOpenKeyEx(HKEY_CURRENT_USER, POLICIES_KEY, 0, KEY_QUERY_VALUE, &m_hkey);
		if (ERROR_SUCCESS != lErr)
		{
			WARNING_OUT(("FEnsureKeyOpen: problem opening system policy key. Err=%08X", lErr));
			return false;
		}
	}

	return true;
}

void SysPol::CloseKey(void)
{
	if (NULL != m_hkey)
	{
		::RegCloseKey(m_hkey);
		m_hkey = NULL;
	}
}


/*  G E T  N U M B E R  */
/*-------------------------------------------------------------------------
    %%Function: GetNumber
    
-------------------------------------------------------------------------*/
DWORD SysPol::GetNumber(LPCTSTR pszName, DWORD dwDefault)
{
	if (FEnsureKeyOpen())
	{
		DWORD dwType = REG_BINARY;
		DWORD dwValue = 0L;
		DWORD dwSize = sizeof(dwValue);
		long  lErr = ::RegQueryValueEx(m_hkey, pszName, 0, &dwType, (LPBYTE)&dwValue, &dwSize);
	
		if ((lErr == ERROR_SUCCESS) &&
		   ((REG_DWORD == dwType) ||  ((REG_BINARY == dwType) && (sizeof(dwValue) == dwSize))) )
		{
			dwDefault = dwValue;
		}
	}

	return dwDefault;
}


//////////////////////
// Positive Settings

bool SysPol::AllowDirectoryServices(void)
{
	return (0 == GetNumber(REGVAL_POL_NO_DIRECTORY_SERVICES, DEFAULT_POL_NO_DIRECTORY_SERVICES));
}

bool SysPol::AllowAddingServers(void)
{
	if (!AllowDirectoryServices())
		return FALSE;

	return (0 == GetNumber(REGVAL_POL_NO_ADDING_NEW_ULS, DEFAULT_POL_NO_ADDING_NEW_ULS));
}


//////////////////////
// Negative Settings


bool SysPol::NoAudio(void)
{
	return (0 != GetNumber(REGVAL_POL_NO_AUDIO, DEFAULT_POL_NO_AUDIO));
}

bool SysPol::NoVideoSend(void)
{
	return (0 != GetNumber(REGVAL_POL_NO_VIDEO_SEND, DEFAULT_POL_NO_VIDEO_SEND));
}

bool SysPol::NoVideoReceive(void)
{
	return (0 != GetNumber(REGVAL_POL_NO_VIDEO_RECEIVE, DEFAULT_POL_NO_VIDEO_RECEIVE));
}



UINT SysPol::GetMaximumBandwidth()
{
	UINT uRet;

	RegEntry re(POLICIES_KEY, HKEY_CURRENT_USER, FALSE);
	uRet = re.GetNumberIniStyle(REGVAL_POL_MAX_BANDWIDTH, 0);

	return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\stiderc.cpp ===
/* ----------------------------------------------------------------------

	Copyright (c) 1996, Microsoft Corporation
	All rights reserved

	stiderc.c

  ---------------------------------------------------------------------- */

#include "precomp.h"

#include "global.h"
#include "dirlist.h"

UINT gfOprahMode = 0;


VOID static _GetPsz(LPTSTR * ppsz, PTCHAR pszDest)
{
	PTCHAR pch = *ppsz;

	while (_T('\0') != *pch)
	{
		*pszDest++ = (*pch++)-1;
	}
	*pszDest = _T('\0');
	*ppsz = pch+1;
}


PTCHAR static _NextWord(PTCHAR pch)
{
	pch = (PTCHAR) _StrChr(pch, _T(','));
	if (NULL != pch)
	{
		*pch = _T('\0');
		pch++;
	}
	return pch;
}


HRESULT OprahDirectory(CDirListView* pdlv)
{
	HRSRC hRes;
	PVOID pData;
	LPTSTR psz;
	PTCHAR pch;
	TCHAR szEmail[32];
	TCHAR szCity[32];
	TCHAR szCountry[128];
	TCHAR rgsz[4][32];

	if (NULL == (hRes = FindResource(GetInstanceHandle(), MAKEINTRESOURCE(IDC_STIDERC), "CDAT")) ||
		(NULL == (psz = (LPTSTR) LockResource(LoadResource(GetInstanceHandle(), hRes))) ) )
	{
		return E_FAIL;
	}

	_GetPsz(&psz, szEmail);
	_GetPsz(&psz, szCity);
	_GetPsz(&psz, rgsz[0]);
	_GetPsz(&psz, rgsz[1]);
	_GetPsz(&psz, rgsz[2]);
	_GetPsz(&psz, rgsz[3]);

	for ( ; ; )
	{
		TCHAR szRow[MAX_PATH];

		UINT   bFlags;
		LPTSTR pszFirst;
		LPTSTR pszLast;
		LPTSTR pszComments;
		LPTSTR pszCity;
		LPTSTR pszCountry;

		_GetPsz(&psz, szRow);
		if (FEmptySz(szRow))
			break;

		pch = szRow;
		bFlags = (*pch) - _T('\0');
		pch++;

		pszFirst = pch;
		pch = _NextWord(pch);

		pszLast = pch;
		pch = _NextWord(pch);

		pszComments = pch;
		pch++;
		switch (*pch)
			{
		case _T(','):
			pch++;
		case _T('\0'):
			pszComments = rgsz[*pszComments-_T('1')];
			break;
		default:
			pch = _NextWord(pch);
			break;
			}

		if (FEmptySz(pch))
		{
			pszCity = szCity;
			pszCountry = TEXT("US");
		}
		else
		{
			pszCity = pch;
			pszCountry = _NextWord(pch);
		}

		if ((_T('\0') != pszCountry[0]) &&
			(_T('\0') != pszCountry[1]) &&
			(_T('\0') == pszCountry[2]))
		{
			if (pdlv->FFindCountry(szCountry, pszCountry))
			{
				pszCountry = szCountry;
			}
		}

		pdlv->Add(szEmail, pszFirst, pszLast, pszCity, pszCountry, pszComments,
			(bFlags & 0x04) ? II_IN_CALL : II_NOT_IN_CALL,
			(bFlags & 0x01) ? II_AUDIO_CAPABLE : 0,
			(bFlags & 0x02) ? II_VIDEO_CAPABLE : 0);
	}

	FreeResource(hRes);

	pdlv->CancelDirectory();

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\strings.h ===
// File: strings.h

#ifndef _STRINGS_H_
#define _STRINGS_H_

// Non-localizable strings

extern const TCHAR g_szEmpty[];
extern const TCHAR g_cszBackgroundSwitch[];

// Window Class Names
extern const TCHAR g_szButton[];
extern const TCHAR g_szEdit[];

extern const TCHAR g_szNMWindowClass[];
extern const TCHAR g_szConfRoomClass[];
extern const TCHAR g_szFloatWndClass[];
extern const TCHAR g_szPopupMsgWndClass[];
extern const TCHAR g_szRebarFrameClass[];
extern const TCHAR g_szAudioBandClass[];
extern const TCHAR g_szAudioLevelBandClass[];
extern const TCHAR g_szViewWndClass[];

extern const TCHAR g_cszSysListView[];       // SysListView32

extern const TCHAR g_cszHelpFileName[];      // conf.hlp
extern const TCHAR g_cszConfLinkExt[];       // .cnf

// Common strings from confreg.h (compiler can't pool strings across .obj files)

#undef CONFERENCING_KEY
#define CONFERENCING_KEY g_szConferencingKey
extern TCHAR * g_szConferencingKey;

#undef UI_KEY
#define UI_KEY g_szUiKey
extern TCHAR * g_szUiKey;

#undef AUDIO_KEY
#define AUDIO_KEY g_szAudioKey
extern TCHAR * g_szAudioKey;

#undef ISAPI_CLIENT_KEY
#define ISAPI_CLIENT_KEY g_szIlsKey
extern TCHAR * g_szIlsKey;

// Non-localizable strings
extern const TCHAR * g_cszEmpty;

extern const TCHAR * g_cszCallTo;           // callto:
extern const TCHAR * g_cszConfExeName;      // conf.exe

extern const TCHAR * g_cszListView;
extern const TCHAR * g_cszButton;
extern const TCHAR * g_cszEdit;
extern const TCHAR * g_cszComboBox;
extern const TCHAR * g_cszComboBoxEx;
extern const TCHAR * g_cszStatic;

#endif /* _STRINGS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\syspol.h ===
// File: syspol.h

#ifndef _SYSPOL_H_
#define _SYSPOL_H_


class SysPol
{
protected:
	static HKEY m_hkey;

	SysPol()  {ASSERT(FALSE);}; // This isn't a normal class
	~SysPol() {};

private:
	static bool  FEnsureKeyOpen(void);
	static DWORD GetNumber(LPCTSTR pszName, DWORD dwDefault = 0);

public:
	static void CloseKey(void);

	static bool AllowDirectoryServices(void);
	static bool AllowAddingServers(void);

	static bool NoAudio(void);
	static bool NoVideoSend(void);
	static bool NoVideoReceive(void);

	static UINT GetMaximumBandwidth();  // returns 0 if no policy key
};


#endif /* _SYSPOL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\t120app.cpp ===
#include "precomp.h"
#include "t120app.h"


BOOL InitAppletSDK(void)
{
    CheckStructCompatible();
    return TRUE;
}


void CleanupAppletSDK(void)
{
}


void CALLBACK T120AppletSessionCallback
(
    T120AppletSessionMsg    *pMsg
)
{
    CNmAppletSession *pSession = (CNmAppletSession *) pMsg->pSessionContext;
    if (NULL != pSession)
    {
        pSession->T120Callback(pMsg);
    }
}


void CALLBACK T120AppletCallback
(
    T120AppletMsg           *pMsg
)
{
    CNmAppletObj *pApplet = (CNmAppletObj *) pMsg->pAppletContext;
    if (NULL != pApplet)
    {
        pApplet->T120Callback(pMsg);
    }
}


//////////////////////////////////////////////////
//
//  CNmAppletSession
//

CNmAppletSession::CNmAppletSession
(
    CNmAppletObj           *pApplet,
    IT120AppletSession     *pSession,
    BOOL                    fAutoJoin
)
:
    m_cRef(1),
    m_pApplet(pApplet),
    m_pT120SessReq(NULL),
    m_pT120Session(pSession),
    m_pNotify(NULL),
    m_fAutoJoin(fAutoJoin)
{
    m_pApplet->AddRef();
    pSession->Advise(T120AppletSessionCallback, m_pApplet, this);
}


CNmAppletSession::~CNmAppletSession(void)
{
    ASSERT(0 == m_cRef);

    m_pApplet->Release();

    if (NULL != m_pT120Session)
    {
        m_pT120Session->ReleaseInterface();
        m_pT120Session = NULL;
    }
}


//////////////////////////////////////////////////
//
// IUnknown @ CNmAppletSession
//

HRESULT CNmAppletSession::QueryInterface
(
    REFIID          riid,
    void          **ppv
)
{
    if (NULL != ppv)
    {
        *ppv = NULL;

        if (riid == IID_IAppletSession || riid == IID_IUnknown)
        {
            *ppv = (IAppletSession *) this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    return E_POINTER;
}


ULONG CNmAppletSession::AddRef(void)
{
    ::InterlockedIncrement(&m_cRef);
    return (ULONG) m_cRef;
}


ULONG CNmAppletSession::Release(void)
{
    ASSERT(m_cRef > 0);

    if (::InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return (ULONG) m_cRef;
}


//////////////////////////////////////////////////
//
// Basic Info @ CNmAppletSession
//

HRESULT CNmAppletSession::GetConfID
(
    AppletConfID        *pnConfID
)
{
    if (NULL != m_pT120Session)
    {
        *pnConfID = m_pT120Session->GetConfID();

        return S_OK;
    }

    return APPLET_E_NO_SERVICE;
}


HRESULT CNmAppletSession::IsThisNodeTopProvider
(
    BOOL            *pfTopProvider
)
{
    if (NULL != m_pT120Session)
    {
        *pfTopProvider = m_pT120Session->IsThisNodeTopProvider();

        return S_OK;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// Join Conference @ CNmAppletSession
//

HRESULT CNmAppletSession::Join
(
    AppletSessionRequest    *pRequest
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Session)
        {
            if (NULL == m_pT120SessReq)
            {
                m_pT120SessReq = ::AllocateJoinSessionRequest(pRequest);
                if (NULL != m_pT120SessReq)
                {
                    T120Error rc = m_pT120Session->Join(m_pT120SessReq);
                    ASSERT(T120_NO_ERROR == rc);

                    if (T120_NO_ERROR == rc)
                    {
                        return S_OK;
                    }

                    ::FreeJoinSessionRequest(m_pT120SessReq);
                    m_pT120SessReq = NULL;

                    return APPLET_E_SERVICE_FAIL;
                }

                return APPLET_E_INVALID_JOIN_REQUEST;
            }

            return APPLET_E_ALREADY_JOIN;
        }

        return APPLET_E_NO_SERVICE;

    }
    return APPLET_E_NOT_ADVISED;
}


HRESULT CNmAppletSession::Leave(void)
{
    if (NULL != m_pT120Session)
    {
        if (m_fAutoJoin)
        {
            m_pT120Session->Leave();
            m_fAutoJoin = FALSE;

            return S_OK;
        }
        else
        if (NULL != m_pT120SessReq)
        {
            m_pT120Session->Leave();

            ::FreeJoinSessionRequest(m_pT120SessReq);
            m_pT120SessReq = NULL;

            return S_OK;
        }

        return APPLET_E_NOT_JOINED;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// Send Data @ CNmAppletSession
//

HRESULT CNmAppletSession::SendData
(
    BOOL               fUniformSend,
    AppletChannelID    nChannelID,
    AppletPriority     ePriority,
    ULONG              cbBufSize,
    BYTE              *pBuffer // size_is(cbBufSize)
)
{
    if (NULL != m_pT120Session)
    {
        if (cbBufSize && NULL != pBuffer)
        {
            T120Error rc = m_pT120Session->SendData(
                                    fUniformSend ? UNIFORM_SEND_DATA : NORMAL_SEND_DATA,
                                    nChannelID,
                                    ePriority,
                                    pBuffer,
                                    cbBufSize,
                                    APP_ALLOCATION);
            ASSERT(T120_NO_ERROR == rc);

            return (T120_NO_ERROR == rc) ? S_OK : APPLET_E_SERVICE_FAIL;
        }

        return E_INVALIDARG;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// Invoke Applet @ CNmAppletSession
//

HRESULT CNmAppletSession::InvokeApplet
(
    AppletRequestTag      *pnReqTag,
    AppletProtocolEntity  *pAPE,
    ULONG                  cNodes,
    AppletNodeID           aNodeIDs[] // size_is(cNodes)
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Session)
        {
            if (NULL != pAPE && NULL != pnReqTag)
            {
                // set up node list
                GCCSimpleNodeList NodeList;
                NodeList.cNodes = cNodes;
                NodeList.aNodeIDs = aNodeIDs;

                // set up ape list
                GCCAppProtEntityList APEList;
                APEList.cApes = 1;
                APEList.apApes = (T120APE **) &pAPE;

                T120Error rc = m_pT120Session->InvokeApplet(&APEList, &NodeList, pnReqTag);
                ASSERT(T120_NO_ERROR == rc);

                return (T120_NO_ERROR == rc) ? S_OK : APPLET_E_SERVICE_FAIL;
            }

            return E_POINTER;
        }

        return APPLET_E_NO_SERVICE;
    }

    return APPLET_E_NOT_ADVISED;
}


//////////////////////////////////////////////////
//
// Inquiry @ CNmAppletSession
//

HRESULT CNmAppletSession::InquireRoster
(
    AppletSessionKey    *pSessionKey
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Session)
        {
            T120Error rc = m_pT120Session->InquireRoster((T120SessionKey *) pSessionKey);
            ASSERT(T120_NO_ERROR == rc);

            return (T120_NO_ERROR == rc) ? S_OK : APPLET_E_SERVICE_FAIL;
        }

        return APPLET_E_NO_SERVICE;
    }

    return APPLET_E_NOT_ADVISED;
}


//////////////////////////////////////////////////
//
// Registry Services @ CNmAppletSession
//

HRESULT CNmAppletSession::RegistryRequest
(
    AppletRegistryRequest   *pRequest
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Session)
        {
            T120RegistryRequest reg_req;
            ::AppletRegistryRequestToT120One(pRequest, &reg_req);

            T120Error rc = m_pT120Session->RegistryRequest(&reg_req);
            ASSERT(T120_NO_ERROR == rc);

            return (T120_NO_ERROR == rc) ? S_OK : APPLET_E_SERVICE_FAIL;
        }

        return APPLET_E_NO_SERVICE;
    }

    return APPLET_E_NOT_ADVISED;
}


//////////////////////////////////////////////////
//
// Channel Services @ CNmAppletSession
//

HRESULT CNmAppletSession::ChannelRequest
(
    AppletChannelRequest    *pRequest
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Session)
        {
            T120Error rc = m_pT120Session->ChannelRequest((T120ChannelRequest *) pRequest);
            ASSERT(T120_NO_ERROR == rc);

            return (T120_NO_ERROR == rc) ? S_OK : APPLET_E_SERVICE_FAIL;
        }

        return APPLET_E_NO_SERVICE;
    }

    return APPLET_E_NOT_ADVISED;
}


//////////////////////////////////////////////////
//
// Token Services @ CNmAppletSession
//

HRESULT CNmAppletSession::TokenRequest
(
    AppletTokenRequest      *pRequest
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Session)
        {
            T120Error rc = m_pT120Session->TokenRequest((T120TokenRequest *) pRequest);
            ASSERT(T120_NO_ERROR == rc);

            return (T120_NO_ERROR == rc) ? S_OK : APPLET_E_SERVICE_FAIL;
        }

        return APPLET_E_NO_SERVICE;
    }

    return APPLET_E_NOT_ADVISED;
}


//////////////////////////////////////////////////
//
// Notification @ CNmAppletSession
//

HRESULT CNmAppletSession::Advise
(
    IAppletSessionNotify    *pNotify,
    DWORD                   *pdwCookie
)
{
    if (NULL != m_pT120Session)
    {
        if (NULL == m_pNotify)
        {
            if (NULL != pNotify && NULL != pdwCookie)
            {
                pNotify->AddRef();
                m_pNotify = pNotify;
                m_pSessionObj = this;
                *pdwCookie = 1;

                return S_OK;
            }

            return E_POINTER;
        }

        return APPLET_E_ALREADY_ADVISED;
    }

    return APPLET_E_NO_SERVICE;
}


HRESULT CNmAppletSession::UnAdvise
(
    DWORD           dwCookie
)
{
    if (NULL != m_pT120Session)
    {
        if (NULL != m_pNotify)
        {
            if (dwCookie == 1 && m_pSessionObj == this)
            {
                m_pNotify->Release();
                m_pNotify = NULL;

                return S_OK;
            }

            return APPLET_E_INVALID_COOKIE;
        }

        return APPLET_E_NOT_ADVISED;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// T120 Applet Session Callback @ CNmAppletSession
//

void CNmAppletSession::T120Callback
(
    T120AppletSessionMsg    *pMsg
)
{
    HRESULT hrNotify;
    HRESULT hrResult;
    IAppletSession *pAppletSession;
    T120ChannelID *aChannelIDs;
    AppletOctetString ostr;
    AppletRegistryCommand eRegistryCommand;
    AppletTokenCommand eTokenCommand;
    AppletRegistryItem RegItem;
    AppletRegistryItem *pRegItem;
    AppletRegistryEntryOwner EntryOwner;

    if (NULL != m_pNotify)
    {
        switch (pMsg->eMsgType)
        {
        //
        // Join Session
        //
        case T120_JOIN_SESSION_CONFIRM:
            hrResult = APPLET_E_SERVICE_FAIL;
            pAppletSession = NULL;
            aChannelIDs = NULL;
            if (T120_RESULT_SUCCESSFUL == pMsg->JoinSessionConfirm.eResult &&
                T120_NO_ERROR          == pMsg->JoinSessionConfirm.eError)
            {
                hrResult = S_OK;
                if (pMsg->JoinSessionConfirm.cResourceReqs)
                {
                    aChannelIDs = new T120ChannelID[pMsg->JoinSessionConfirm.cResourceReqs];
                    if (NULL != aChannelIDs)
                    {
                        for (ULONG i = 0; i < pMsg->JoinSessionConfirm.cResourceReqs; i++)
                        {
                            aChannelIDs[i] = pMsg->JoinSessionConfirm.aResourceReqs[i].nChannelID;
                        }
                    }
                    else
                    {
                        ASSERT(NULL != aChannelIDs);
                        hrResult = E_OUTOFMEMORY;
                    }
                }
            }
            if (S_OK == hrResult)
            {
                hrNotify = m_pNotify->JoinSessionConfirm(
                                hrResult,
                                pMsg->JoinSessionConfirm.uidMyself,
                                pMsg->JoinSessionConfirm.nidMyself,
                                pMsg->JoinSessionConfirm.sidMyself,
                                pMsg->JoinSessionConfirm.eidMyself,
                                pMsg->JoinSessionConfirm.cResourceReqs,
                                aChannelIDs);
                ASSERT(SUCCEEDED(hrNotify));
            }
            else
            {
                hrNotify = m_pNotify->JoinSessionConfirm(hrResult, 0, 0, 0, 0, 0, NULL);
                ASSERT(SUCCEEDED(hrNotify));
            }
            delete [] aChannelIDs;
            break;

        //
        // Detach User
        //
        case MCS_DETACH_USER_INDICATION:
            hrNotify = m_pNotify->LeaveSessionIndication(::GetAppletReason(pMsg->DetachUserInd.eReason),
                                              pMsg->DetachUserInd.nUserID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        //
        // Send Data
        //
        case MCS_SEND_DATA_INDICATION:
        case MCS_UNIFORM_SEND_DATA_INDICATION:
            ostr.cbStrSize = pMsg->SendDataInd.user_data.length;
            ostr.pbValue = pMsg->SendDataInd.user_data.value;
            hrNotify = m_pNotify->SendDataIndication(MCS_UNIFORM_SEND_DATA_INDICATION == pMsg->eMsgType,
                                          pMsg->SendDataInd.initiator,
                                          pMsg->SendDataInd.channel_id,
                                          (AppletPriority) pMsg->SendDataInd.data_priority,
                                          ostr);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        //
        // Roster
        //
        case GCC_APP_ROSTER_REPORT_INDICATION:
            hrNotify = m_pNotify->RosterReportIndication((ULONG) pMsg->AppRosterReportInd.cRosters,
                                              (AppletRoster **) pMsg->AppRosterReportInd.apAppRosters);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case GCC_APP_ROSTER_INQUIRE_CONFIRM:
            hrNotify = m_pNotify->InquireRosterConfirm(::GetHrResult(pMsg->AppRosterInquireConfirm.nResult),
                                            (ULONG) pMsg->AppRosterInquireConfirm.cRosters,
                                            (AppletRoster **) pMsg->AppRosterInquireConfirm.apAppRosters);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        //
        // Applet Invoke
        //
        case GCC_APPLICATION_INVOKE_CONFIRM:
            hrNotify = m_pNotify->InvokeAppletConfirm(pMsg->AppInvokeConfirm.nReqTag,
                                           ::GetHrResult(pMsg->AppInvokeConfirm.nResult));
            ASSERT(SUCCEEDED(hrNotify));
            break;

        //
        // Registry
        //
        case GCC_REGISTER_CHANNEL_CONFIRM:
            eRegistryCommand = APPLET_REGISTER_CHANNEL;
          RegistryCommon_1:
            if (NULL != pMsg->RegistryConfirm.pRegItem)
            {
                pRegItem = (AppletRegistryItem *) pMsg->RegistryConfirm.pRegItem;
            }
            else
            {
                ::ZeroMemory(&RegItem, sizeof(RegItem));
                pRegItem = &RegItem;
            }
            hrNotify = m_pNotify->RegistryConfirm(eRegistryCommand,
                                       ::GetHrResult(pMsg->RegistryConfirm.nResult),
                                        (AppletRegistryKey *) pMsg->RegistryConfirm.pRegKey,
                                        pRegItem,
                                        (AppletRegistryEntryOwner *) &pMsg->RegistryConfirm.EntryOwner,
                                        pMsg->RegistryConfirm.eRights);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case GCC_ASSIGN_TOKEN_CONFIRM:
            eRegistryCommand = APPLET_ASSIGN_TOKEN;
            goto RegistryCommon_1;

        case GCC_SET_PARAMETER_CONFIRM:
            eRegistryCommand = APPLET_SET_PARAMETER;
            goto RegistryCommon_1;

        case GCC_RETRIEVE_ENTRY_CONFIRM:
            hrResult = ::GetHrResult(pMsg->RegistryConfirm.nResult);
            if (GCC_RESULT_SUCCESSFUL == pMsg->RegistryConfirm.nResult)
            {
                if (NULL != pMsg->RegistryConfirm.pRegItem)
                {
                    pRegItem = (AppletRegistryItem *) pMsg->RegistryConfirm.pRegItem;
                }
                else
                {
                    ::ZeroMemory(&RegItem, sizeof(RegItem));
                    pRegItem = &RegItem;
                }
                hrNotify = m_pNotify->RegistryConfirm(APPLET_RETRIEVE_ENTRY,
                                           hrResult,
                                           (AppletRegistryKey *) pMsg->RegistryConfirm.pRegKey,
                                           pRegItem,
                                           (AppletRegistryEntryOwner *) &pMsg->RegistryConfirm.EntryOwner,
                                           pMsg->RegistryConfirm.eRights);
                ASSERT(SUCCEEDED(hrNotify));
            }
            else
            {
                ::ZeroMemory(&RegItem, sizeof(RegItem));
                ::ZeroMemory(&EntryOwner, sizeof(EntryOwner));
                hrNotify = m_pNotify->RegistryConfirm(APPLET_RETRIEVE_ENTRY,
                                           hrResult,
                                           (AppletRegistryKey *) pMsg->RegistryConfirm.pRegKey,
                                           &RegItem,
                                           &EntryOwner,
                                           APPLET_NO_MODIFICATION_RIGHTS_SPECIFIED);
                ASSERT(SUCCEEDED(hrNotify));
            }
            break;

        case GCC_DELETE_ENTRY_CONFIRM:
            hrResult = ::GetHrResult(pMsg->RegistryConfirm.nResult);
            if (GCC_RESULT_INDEX_ALREADY_OWNED == pMsg->RegistryConfirm.nResult)
            {
                if (NULL != pMsg->RegistryConfirm.pRegItem)
                {
                    pRegItem = (AppletRegistryItem *) pMsg->RegistryConfirm.pRegItem;
                }
                else
                {
                    ::ZeroMemory(&RegItem, sizeof(RegItem));
                    pRegItem = &RegItem;
                }
                hrNotify = m_pNotify->RegistryConfirm(APPLET_DELETE_ENTRY,
                                           hrResult,
                                           (AppletRegistryKey *) pMsg->RegistryConfirm.pRegKey,
                                           pRegItem,
                                           (AppletRegistryEntryOwner *) &pMsg->RegistryConfirm.EntryOwner,
                                           pMsg->RegistryConfirm.eRights);
                ASSERT(SUCCEEDED(hrNotify));
            }
            else
            {
                ::ZeroMemory(&RegItem, sizeof(RegItem));
                ::ZeroMemory(&EntryOwner, sizeof(EntryOwner));
                hrNotify = m_pNotify->RegistryConfirm(APPLET_DELETE_ENTRY,
                                           hrResult,
                                           (AppletRegistryKey *) pMsg->RegistryConfirm.pRegKey,
                                           &RegItem,
                                           &EntryOwner,
                                           APPLET_NO_MODIFICATION_RIGHTS_SPECIFIED);
                ASSERT(SUCCEEDED(hrNotify));
            }
            break;

        case GCC_ALLOCATE_HANDLE_CONFIRM:
            hrNotify = m_pNotify->AllocateHandleConfirm(::GetHrResult(pMsg->RegAllocHandleConfirm.nResult),
                                             pMsg->RegAllocHandleConfirm.nFirstHandle,
                                             pMsg->RegAllocHandleConfirm.cHandles);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        //
        // Channel
        //
        case MCS_CHANNEL_JOIN_CONFIRM:
            hrNotify = m_pNotify->ChannelConfirm(APPLET_JOIN_CHANNEL,
                                      ::GetHrResult(pMsg->ChannelConfirm.eResult),
                                      pMsg->ChannelConfirm.nChannelID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_CHANNEL_CONVENE_CONFIRM:
            hrNotify = m_pNotify->ChannelConfirm(APPLET_CONVENE_CHANNEL,
                                      ::GetHrResult(pMsg->ChannelConfirm.eResult),
                                      pMsg->ChannelConfirm.nChannelID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_CHANNEL_LEAVE_INDICATION:
            hrNotify = m_pNotify->ChannelIndication(APPLET_LEAVE_CHANNEL,
                                         pMsg->ChannelInd.nChannelID,
                                         ::GetAppletReason(pMsg->ChannelInd.eReason),
                                         0);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_CHANNEL_DISBAND_INDICATION:
            hrNotify = m_pNotify->ChannelIndication(APPLET_DISBAND_CHANNEL,
                                         pMsg->ChannelInd.nChannelID,
                                         ::GetAppletReason(pMsg->ChannelInd.eReason),
                                         0);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_CHANNEL_ADMIT_INDICATION:
            hrNotify = m_pNotify->ChannelIndication(APPLET_ADMIT_CHANNEL,
                                         pMsg->ChannelInd.nChannelID,
                                         APPLET_R_UNSPECIFIED,
                                         pMsg->ChannelInd.nManagerID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_CHANNEL_EXPEL_INDICATION:
            hrNotify = m_pNotify->ChannelIndication(APPLET_EXPEL_CHANNEL,
                                         pMsg->ChannelInd.nChannelID,
                                         ::GetAppletReason(pMsg->ChannelInd.eReason),
                                         0);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        //
        // Token
        //
        case MCS_TOKEN_GRAB_CONFIRM:
            eTokenCommand = APPLET_GRAB_TOKEN;
        Token_Common_1:
            hrNotify = m_pNotify->TokenConfirm(eTokenCommand,
                                    ::GetHrResult(pMsg->TokenConfirm.eResult),
                                    pMsg->TokenConfirm.nTokenID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_TOKEN_INHIBIT_CONFIRM:
            eTokenCommand = APPLET_INHIBIT_TOKEN;
            goto Token_Common_1;

        case MCS_TOKEN_GIVE_CONFIRM:
            eTokenCommand = APPLET_GIVE_TOKEN;
            goto Token_Common_1;

        case MCS_TOKEN_RELEASE_CONFIRM:
            eTokenCommand = APPLET_RELEASE_TOKEN;
            goto Token_Common_1;

        case MCS_TOKEN_TEST_CONFIRM:
            hrNotify = m_pNotify->TestTokenConfirm(pMsg->TokenConfirm.nTokenID,
                                        pMsg->TokenConfirm.eTokenStatus);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_TOKEN_GIVE_INDICATION:
            hrNotify = m_pNotify->TokenIndication(APPLET_GIVE_TOKEN,
                                       APPLET_R_UNSPECIFIED,
                                       pMsg->TokenInd.nTokenID,
                                       pMsg->TokenInd.nUserID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_TOKEN_PLEASE_INDICATION:
            hrNotify = m_pNotify->TokenIndication(APPLET_PLEASE_TOKEN,
                                       APPLET_R_UNSPECIFIED,
                                       pMsg->TokenInd.nTokenID,
                                       pMsg->TokenInd.nUserID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_TOKEN_RELEASE_INDICATION:
            hrNotify = m_pNotify->TokenIndication(APPLET_RELEASE_TOKEN,
                                       ::GetAppletReason(pMsg->TokenInd.eReason),
                                       pMsg->TokenInd.nTokenID,
                                       0);
            ASSERT(SUCCEEDED(hrNotify));
            break;
        } // switch
    } // if
}


HRESULT GetHrResult(T120Result rc)
{
    HRESULT hrResult;
    switch (rc)
    {
    case T120_RESULT_SUCCESSFUL:
        hrResult = S_OK;
        break;
    case GCC_RESULT_ENTRY_ALREADY_EXISTS:
        hrResult = APPLET_E_ENTRY_ALREADY_EXISTS;
        break;
    case GCC_RESULT_ENTRY_DOES_NOT_EXIST:
        hrResult = APPLET_E_ENTRY_DOES_NOT_EXIST;
        break;
    case GCC_RESULT_INDEX_ALREADY_OWNED:
        hrResult = APPLET_E_NOT_OWNER;
        break;
    default:
        hrResult = APPLET_E_SERVICE_FAIL;
        break;
    }
    return hrResult;
}


AppletReason GetAppletReason(T120Reason rc)
{
    AppletReason eAppletReason;
    switch (rc)
    {
    case REASON_USER_REQUESTED:
        eAppletReason = APPLET_R_USER_REJECTED;
        break;
    case REASON_DOMAIN_DISCONNECTED:
    case REASON_PROVIDER_INITIATED:
        eAppletReason = APPLET_R_CONFERENCE_GONE;
	ERROR_OUT (("WHAT!!!"));
        
        break;
    case REASON_TOKEN_PURGED:
    case REASON_CHANNEL_PURGED:
        eAppletReason = APPLET_R_RESOURCE_PURGED;
        break;
    default:
        eAppletReason = APPLET_R_UNSPECIFIED;
        break;
    }
    return eAppletReason;
}


//////////////////////////////////////////////////
//
// CNmAppletObj
//

CNmAppletObj::CNmAppletObj(void)
:
    m_cRef(0),
    m_pT120Applet(NULL),
    m_pT120AutoJoinReq(NULL),
    m_pNotify(NULL),
    m_nPendingConfID(0)
{
}


CNmAppletObj::~CNmAppletObj(void)
{
    ASSERT(0 == m_cRef);

    if (NULL != m_pT120Applet)
    {
        m_pT120Applet->ReleaseInterface();
        m_pT120Applet = NULL;
    }

    ::FreeJoinSessionRequest(m_pT120AutoJoinReq);
}


HRESULT CNmAppletObj::Initialize(void)
{
    T120Error rc = ::T120_CreateAppletSAP(&m_pT120Applet);
    if (T120_NO_ERROR == rc)
    {
        m_pT120Applet->Advise(T120AppletCallback, this);
        return S_OK;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// Auto Join @ CNmAppletObj
//

HRESULT CNmAppletObj::RegisterAutoJoin
(
    AppletSessionRequest    *pRequest
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Applet)
        {
            if (NULL != pRequest)
            {
                if (NULL == m_pT120AutoJoinReq)
                {
                    m_pT120AutoJoinReq = ::AllocateJoinSessionRequest(pRequest);
                    if (NULL != m_pT120AutoJoinReq)
                    {
                        T120Error rc = m_pT120Applet->RegisterAutoJoin(m_pT120AutoJoinReq);
                        ASSERT(T120_NO_ERROR == rc);

                        if (T120_NO_ERROR == rc)
                        {
                            return S_OK;
                        }

                        ::FreeJoinSessionRequest(m_pT120AutoJoinReq);
                        m_pT120AutoJoinReq = NULL;

                        return APPLET_E_SERVICE_FAIL;
                    }

                    return APPLET_E_INVALID_JOIN_REQUEST;
                }

                return APPLET_E_ALREADY_REGISTERED;
            }

            return E_POINTER;
        }

        return APPLET_E_NO_SERVICE;
    }

    return APPLET_E_NOT_ADVISED;
}


HRESULT CNmAppletObj::UnregisterAutoJoin(void)
{
    if (NULL != m_pT120Applet)
    {
        if (NULL != m_pT120AutoJoinReq)
        {
            m_pT120Applet->UnregisterAutoJoin();

            ::FreeJoinSessionRequest(m_pT120AutoJoinReq);
            m_pT120AutoJoinReq = NULL;

            return S_OK;
        }

        return APPLET_E_NOT_REGISTERED;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// Session @ CNmAppletObj
//

HRESULT CNmAppletObj::CreateSession
(
    IAppletSession    **ppSession,
    AppletConfID        nConfID
)
{
    if (NULL != m_pT120Applet)
    {
        if (NULL != ppSession)
        {
            *ppSession = NULL;

            if (nConfID)
            {
                IT120AppletSession *pT120Session = NULL;
                T120Error rc = m_pT120Applet->CreateSession(&pT120Session, nConfID);
                if (T120_NO_ERROR == rc)
                {
                    *ppSession = (IAppletSession *) new CNmAppletSession(this, pT120Session);
                    if (NULL != *ppSession)
                    {
                        return S_OK;
                    }

                    pT120Session->ReleaseInterface();
                    return E_OUTOFMEMORY;
                }

                return APPLET_E_SERVICE_FAIL;
            }

            return APPLET_E_INVALID_CONFERENCE;
        }

        return E_POINTER;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// Notification @ CNmAppletObj
//

HRESULT CNmAppletObj::Advise
(
    IAppletNotify       *pNotify,
    DWORD               *pdwCookie
)
{
    if (NULL != m_pT120Applet)
    {
        if (NULL == m_pNotify)
        {
            if (NULL != pNotify && NULL != pdwCookie)
            {
                pNotify->AddRef();
                m_pNotify = pNotify;
                m_pAppletObj = this;
                *pdwCookie = 1;

                if (m_nPendingConfID)
                {
                    m_pNotify->PermitToJoinSessionIndication(m_nPendingConfID, TRUE);
                    m_nPendingConfID = 0;
                }

                return S_OK;
            }

            return E_POINTER;
        }

        return APPLET_E_ALREADY_ADVISED;
    }

    return APPLET_E_NO_SERVICE;
}


HRESULT CNmAppletObj::UnAdvise
(
    DWORD               dwCookie
)
{
    if (NULL != m_pT120Applet)
    {
        if (NULL != m_pNotify)
        {
            if (dwCookie == 1 && m_pAppletObj == this)
            {
                m_pNotify->Release();
                m_pNotify = NULL;

                return S_OK;
            }

            return APPLET_E_INVALID_COOKIE;
        }

        return APPLET_E_NOT_ADVISED;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// T120 Applet @ CNmAppletObj
//

void CNmAppletObj::T120Callback
(
    T120AppletMsg           *pMsg
)
{
    HRESULT hrNotify;
    HRESULT hrResult;
    IAppletSession *pAppletSession;
    T120ChannelID *aChannelIDs;

    if (NULL != m_pNotify)
    {
        switch (pMsg->eMsgType)
        {
        case GCC_PERMIT_TO_ENROLL_INDICATION:
            ASSERT(0 == m_nPendingConfID);
            hrNotify = m_pNotify->PermitToJoinSessionIndication(
                                pMsg->PermitToEnrollInd.nConfID,
                                pMsg->PermitToEnrollInd.fPermissionGranted);
            ASSERT(SUCCEEDED(hrNotify));
            break;
        case T120_JOIN_SESSION_CONFIRM:
            hrResult = APPLET_E_SERVICE_FAIL;
            pAppletSession = NULL;
            aChannelIDs = NULL;
            if (T120_RESULT_SUCCESSFUL == pMsg->AutoJoinSessionInd.eResult &&
                T120_NO_ERROR          == pMsg->AutoJoinSessionInd.eError)
            {
                hrResult = S_OK;
                if (pMsg->AutoJoinSessionInd.cResourceReqs)
                {
                    aChannelIDs = new T120ChannelID[pMsg->AutoJoinSessionInd.cResourceReqs];
                    if (NULL != aChannelIDs)
                    {
                        for (ULONG i = 0; i < pMsg->AutoJoinSessionInd.cResourceReqs; i++)
                        {
                            aChannelIDs[i] = pMsg->AutoJoinSessionInd.aResourceReqs[i].nChannelID;
                        }
                    }
                    else
                    {
                        ASSERT(NULL != aChannelIDs);
                        hrResult = E_OUTOFMEMORY;
                    }
                }

                if (S_OK == hrResult)
                {
                    ASSERT(NULL != pMsg->AutoJoinSessionInd.pIAppletSession);
                    pAppletSession = new CNmAppletSession(this, pMsg->AutoJoinSessionInd.pIAppletSession, TRUE);
                    ASSERT(NULL != pAppletSession);

                    hrResult = (NULL != pAppletSession) ? S_OK : E_OUTOFMEMORY;
                }
            }

            if (S_OK == hrResult)
            {
                hrNotify = m_pNotify->AutoJoinSessionIndication(
                                pAppletSession,
                                hrResult,
                                pMsg->AutoJoinSessionInd.uidMyself,
                                pMsg->AutoJoinSessionInd.nidMyself,
                                pMsg->AutoJoinSessionInd.sidMyself,
                                pMsg->AutoJoinSessionInd.eidMyself,
                                pMsg->AutoJoinSessionInd.cResourceReqs,
                                aChannelIDs);
                ASSERT(SUCCEEDED(hrNotify));
            }
            else
            {
                hrNotify = m_pNotify->AutoJoinSessionIndication(NULL, hrResult, 0, 0, 0, 0, 0, NULL);
                ASSERT(SUCCEEDED(hrNotify));

                if (NULL != pMsg->AutoJoinSessionInd.pIAppletSession)
                {
                    pMsg->AutoJoinSessionInd.pIAppletSession->ReleaseInterface();
                }
            }

            delete [] aChannelIDs;
            break;
        } // switch
    }
    else
    {
        // free memory for unwanted message
        if (T120_JOIN_SESSION_CONFIRM == pMsg->eMsgType &&
            T120_RESULT_SUCCESSFUL    == pMsg->AutoJoinSessionInd.eResult &&
            T120_NO_ERROR             == pMsg->AutoJoinSessionInd.eError)
        {
            if (NULL != pMsg->AutoJoinSessionInd.pIAppletSession)
            {
                pMsg->AutoJoinSessionInd.pIAppletSession->ReleaseInterface();
            }
        }
        else
        if (GCC_PERMIT_TO_ENROLL_INDICATION == pMsg->eMsgType)
        {
            if (pMsg->PermitToEnrollInd.fPermissionGranted)
            {
                m_nPendingConfID = pMsg->PermitToEnrollInd.nConfID;
            }
            else
            {
                if (m_nPendingConfID == pMsg->PermitToEnrollInd.nConfID)
                {
                    m_nPendingConfID = 0;
                }
            }
        }
    }
}


//////////////////////////////////////////////////
//
// Join Session Request
//

T120JoinSessionRequest * AllocateJoinSessionRequest
(
    AppletSessionRequest    *pAppletRequest
)
{
    T120JoinSessionRequest *pT120One = new T120JoinSessionRequest;
    if (NULL != pT120One)
    {
        ::ZeroMemory(pT120One, sizeof(*pT120One));

        ULONG i;

        pT120One->dwAttachmentFlags = ATTACHMENT_DISCONNECT_IN_DATA_LOSS;

        if (! ::DuplicateSessionKey(&pT120One->SessionKey, (T120SessionKey *) &pAppletRequest->SessionKey))
        {
            goto MyError;
        }

        pT120One->fConductingCapable = FALSE;

        pT120One->nStartupChannelType = pAppletRequest->nStartupChannelType;

        if (::ConvertNonCollapsedCaps(&pT120One->apNonCollapsedCaps,
                                      pAppletRequest->apNonCollapsedCaps,
                                      pAppletRequest->cNonCollapsedCaps))
        {
            pT120One->cNonCollapsedCaps = pAppletRequest->cNonCollapsedCaps;
        }
        else
        {
            goto MyError;
        }

        if (::ConvertCollapsedCaps(&pT120One->apCollapsedCaps,
                                   pAppletRequest->apCollapsedCaps,
                                   pAppletRequest->cCollapsedCaps))
        {
            pT120One->cCollapsedCaps = pAppletRequest->cCollapsedCaps;
        }
        else
        {
            goto MyError;
        }

        if (0 != (pT120One->cStaticChannels = pAppletRequest->cStaticChannels))
        {
            pT120One->aStaticChannels = new T120ChannelID[pT120One->cStaticChannels];
            if (NULL != pT120One->aStaticChannels)
            {
                ::CopyMemory(pT120One->aStaticChannels,
                             pAppletRequest->aStaticChannels,
                             pT120One->cStaticChannels * sizeof(T120ChannelID));
            }
            else
            {
                goto MyError;
            }
        }

        if (0 != (pT120One->cResourceReqs = pAppletRequest->cDynamicChannels))
        {
            if (NULL != (pT120One->aResourceReqs = new T120ResourceRequest[pT120One->cResourceReqs]))
            {
                ::ZeroMemory(pT120One->aResourceReqs, pT120One->cResourceReqs * sizeof(T120ResourceRequest));
                for (i = 0; i < pT120One->cResourceReqs; i++)
                {
                    pT120One->aResourceReqs[i].eCommand = APPLET_JOIN_DYNAMIC_CHANNEL;
                    if (! ::DuplicateRegistryKey(&pT120One->aResourceReqs[i].RegKey,
                                                 (T120RegistryKey *) &pAppletRequest->aChannelRegistryKeys[i]))
                    {
                        goto MyError;
                    }
                }
            }
            else
            {
                goto MyError;
            }
        }

        return pT120One;
    }

MyError:

    ::FreeJoinSessionRequest(pT120One);
    return NULL;
}


void FreeJoinSessionRequest
(
    T120JoinSessionRequest  *pT120One
)
{
    if (NULL != pT120One)
    {
        ::FreeSessionKey(&pT120One->SessionKey);

        ::FreeNonCollapsedCaps(pT120One->apNonCollapsedCaps, pT120One->cNonCollapsedCaps);

        ::FreeCollapsedCaps(pT120One->apCollapsedCaps, pT120One->cCollapsedCaps);

        if (pT120One->cStaticChannels)
        {
            delete [] pT120One->aStaticChannels;
        }

        if (pT120One->cResourceReqs)
        {
            for (ULONG i = 0; i < pT120One->cResourceReqs; i++)
            {
                ::FreeRegistryKey(&pT120One->aResourceReqs[i].RegKey);
            }
            delete [] pT120One->aResourceReqs;
        }

        delete pT120One;
    }
}


BOOL ConvertCollapsedCaps(T120AppCap ***papDst, AppletCapability **apSrc, ULONG cItems)
{
    if (cItems)
    {
        T120AppCap **arr_ptr;
        ULONG cbTotalSize = cItems * (sizeof(T120AppCap*) + sizeof(T120AppCap));
        if (NULL != (arr_ptr = (T120AppCap**) new BYTE[cbTotalSize]))
        {
            ::ZeroMemory(arr_ptr, cbTotalSize);
            T120AppCap *arr_obj = (T120AppCap *) (arr_ptr + cItems);
            for (ULONG i = 0; i < cItems; i++)
            {
                arr_ptr[i] = &arr_obj[i];
                if (! ::DuplicateCollapsedCap(arr_ptr[i], (T120AppCap *) apSrc[i]))
                {
                    ::FreeCollapsedCaps(arr_ptr, cItems);
                    return FALSE;
                }
            }
        }

        *papDst = arr_ptr;
        return (NULL != arr_ptr);
    }

    *papDst = NULL;
    return TRUE;
}

void FreeCollapsedCaps(T120AppCap **apDst, ULONG cItems)
{
    if (cItems && NULL != apDst)
    {
        T120AppCap **arr_ptr = apDst;
        T120AppCap *arr_obj = (T120AppCap *) (arr_ptr + cItems);
        for (ULONG i = 0; i < cItems; i++)
        {
            ::FreeCollapsedCap(&arr_obj[i]);
        }
        delete [] (LPBYTE) arr_ptr;
    }
}


BOOL DuplicateCollapsedCap(T120AppCap *pDst, T120AppCap *pSrc)
{
    pDst->number_of_entities = pSrc->number_of_entities;
    pDst->capability_class = pSrc->capability_class; // no memory allocation
    return ::DuplicateCapID(&pDst->capability_id, &pSrc->capability_id);
}

void FreeCollapsedCap(T120AppCap *pDst)
{
    ::FreeCapID(&pDst->capability_id);
}


BOOL DuplicateCapID(T120CapID *pDst, T120CapID *pSrc)
{
    pDst->capability_id_type = pSrc->capability_id_type;
    switch (pDst->capability_id_type)
    {
    case GCC_STANDARD_CAPABILITY:
        pDst->standard_capability = pSrc->standard_capability;
        return TRUE;
    case GCC_NON_STANDARD_CAPABILITY:
        return ::DuplicateObjectKey(&pDst->non_standard_capability, &pSrc->non_standard_capability);
    }
    return FALSE;
}

void FreeCapID(T120CapID *pDst)
{
    switch (pDst->capability_id_type)
    {
    case GCC_NON_STANDARD_CAPABILITY:
        ::FreeObjectKey(&pDst->non_standard_capability);
        break;
    }
}


BOOL ConvertNonCollapsedCaps(T120NonCollCap ***papDst, AppletCapability2 **apSrc, ULONG cItems)
{
    if (cItems)
    {
        T120NonCollCap **arr_ptr;
        ULONG cbTotalSize = cItems * (sizeof(T120NonCollCap*) + sizeof(T120NonCollCap));
        if (NULL != (arr_ptr = (T120NonCollCap**) new BYTE[cbTotalSize]))
        {
            ::ZeroMemory(arr_ptr, cbTotalSize);
            T120NonCollCap *arr_obj = (T120NonCollCap *) (arr_ptr + cItems);
            for (ULONG i = 0; i < cItems; i++)
            {
                arr_ptr[i] = &arr_obj[i];
                if (! ::DuplicateNonCollapsedCap(arr_ptr[i], (T120NonCollCap *) apSrc[i]))
                {
                    ::FreeNonCollapsedCaps(arr_ptr, cItems);
                    return FALSE;
                }
            }
        }

        *papDst = arr_ptr;
        return (NULL != arr_ptr);
    }

    *papDst = NULL;
    return TRUE;
}

void FreeNonCollapsedCaps(T120NonCollCap **apDst, ULONG cItems)
{
    if (cItems && NULL != apDst)
    {
        T120NonCollCap **arr_ptr = apDst;
        T120NonCollCap *arr_obj = (T120NonCollCap *) (arr_ptr + cItems);
        for (ULONG i = 0; i < cItems; i++)
        {
            ::FreeNonCollapsedCap(&arr_obj[i]);
        }
        delete [] (LPBYTE) arr_ptr;
    }
}


BOOL DuplicateNonCollapsedCap(T120NonCollCap *pDst, T120NonCollCap *pSrc)
{
    if (::DuplicateCapID(&pDst->capability_id, &pSrc->capability_id))
    {
        if (NULL == pSrc->application_data)
        {
            return TRUE;
        }

        if (NULL != (pDst->application_data = new OSTR))
        {
            return ::DuplicateOSTR(pDst->application_data, pSrc->application_data);
        }
    }
    return FALSE;
}

void FreeNonCollapsedCap(T120NonCollCap *pDst)
{
    ::FreeCapID(&pDst->capability_id);

    if (NULL != pDst->application_data)
    {
        ::FreeOSTR(pDst->application_data);
        delete pDst->application_data;
    }
}


BOOL DuplicateRegistryKey(T120RegistryKey *pDst, T120RegistryKey *pSrc)
{
    if (::DuplicateSessionKey(&pDst->session_key, &pSrc->session_key))
    {
        return ::DuplicateOSTR(&pDst->resource_id, &pSrc->resource_id);
    }
    return FALSE;
}

void FreeRegistryKey(T120RegistryKey *pDst)
{
    ::FreeSessionKey(&pDst->session_key);
    ::FreeOSTR(&pDst->resource_id);
}


BOOL DuplicateSessionKey(T120SessionKey *pDst, T120SessionKey *pSrc)
{
    pDst->session_id = pSrc->session_id;
    return ::DuplicateObjectKey(&pDst->application_protocol_key, &pSrc->application_protocol_key);
}

void FreeSessionKey(T120SessionKey *pDst)
{
    ::FreeObjectKey(&pDst->application_protocol_key);
}


BOOL DuplicateObjectKey(T120ObjectKey *pDst, T120ObjectKey *pSrc)
{
    pDst->key_type = pSrc->key_type;
    switch (pDst->key_type)
    {
    case GCC_OBJECT_KEY:
        pDst->object_id.long_string_length = pSrc->object_id.long_string_length;
        if (pSrc->object_id.long_string_length && NULL != pSrc->object_id.long_string)
        {
            if (NULL != (pDst->object_id.long_string = new ULONG[pDst->object_id.long_string_length]))
            {
                ::CopyMemory(pDst->object_id.long_string,
                             pSrc->object_id.long_string,
                             pDst->object_id.long_string_length * sizeof(ULONG));
                return TRUE;
            }
        }
        break;
    case GCC_H221_NONSTANDARD_KEY:
        return ::DuplicateOSTR(&pDst->h221_non_standard_id, &pSrc->h221_non_standard_id);
    }
    return FALSE;
}


void FreeObjectKey(T120ObjectKey *pDst)
{
    switch (pDst->key_type)
    {
    case GCC_OBJECT_KEY:
        if (pDst->object_id.long_string_length)
        {
            delete [] pDst->object_id.long_string;
        }
        break;
    case GCC_H221_NONSTANDARD_KEY:
        ::FreeOSTR(&pDst->h221_non_standard_id);
        break;
    }
}


BOOL DuplicateOSTR(OSTR *pDst, OSTR *pSrc)
{
    if (pSrc->length && NULL != pSrc->value)
    {
        pDst->length = pSrc->length;
        if (NULL != (pDst->value = new BYTE[pDst->length]))
        {
            ::CopyMemory(pDst->value, pSrc->value, pDst->length);
            return TRUE;
        }
    }
    return FALSE;
}

void FreeOSTR(OSTR *pDst)
{
    if (pDst->length)
    {
        delete [] pDst->value;
    }
}


//////////////////////////////////////////////////
//
// Conversion
//

void AppletRegistryRequestToT120One
(
    AppletRegistryRequest   *pAppletRequest,
    T120RegistryRequest     *pT120One
)
{
    pT120One->eCommand = pAppletRequest->eCommand;
    pT120One->pRegistryKey = (T120RegistryKey *) &pAppletRequest->RegistryKey;
    switch (pT120One->eCommand)
    {
    case APPLET_REGISTER_CHANNEL:
        pT120One->nChannelID = pAppletRequest->nChannelID;
        break;
    case APPLET_SET_PARAMETER:
        pT120One->Param.postrValue = (OSTR *) &pAppletRequest->ostrParamValue;
        pT120One->Param.eModifyRights = pAppletRequest->eParamModifyRights;
        break;
    case APPLET_ALLOCATE_HANDLE:
        pT120One->cHandles = pAppletRequest->cHandles;
        break;
    case APPLET_RETRIEVE_ENTRY:
    case APPLET_DELETE_ENTRY:
    case APPLET_ASSIGN_TOKEN:
    case APPLET_MONITOR:
    default:
        break;
    }
}







#ifdef _DEBUG
void CheckStructCompatible(void)
{
    ASSERT(sizeof(AppletOctetString) == sizeof(OSTR));
    ASSERT(FIELD_OFFSET(AppletOctetString, cbStrSize) == FIELD_OFFSET(OSTR, length));
    ASSERT(FIELD_OFFSET(AppletOctetString, pbValue) == FIELD_OFFSET(OSTR, value));

    ASSERT(sizeof(AppletLongString) == sizeof(T120LongString));
    ASSERT(FIELD_OFFSET(AppletLongString, nStrLen) == FIELD_OFFSET(T120LongString, long_string_length));
    ASSERT(FIELD_OFFSET(AppletLongString, pnValue) == FIELD_OFFSET(T120LongString, long_string));

    ASSERT(sizeof(AppletObjectKey) == sizeof(T120ObjectKey));
    ASSERT(FIELD_OFFSET(AppletObjectKey, eType) == FIELD_OFFSET(T120ObjectKey, key_type));
    ASSERT(FIELD_OFFSET(AppletObjectKey, lstrObjectID) == FIELD_OFFSET(T120ObjectKey, object_id));
    ASSERT(FIELD_OFFSET(AppletObjectKey, ostrH221NonStdID) == FIELD_OFFSET(T120ObjectKey, h221_non_standard_id));

    ASSERT(sizeof(AppletSessionKey) == sizeof(T120SessionKey));
    ASSERT(FIELD_OFFSET(AppletSessionKey, AppletProtocolKey) == FIELD_OFFSET(T120SessionKey, application_protocol_key));
    ASSERT(FIELD_OFFSET(AppletSessionKey, nSessionID) == FIELD_OFFSET(T120SessionKey, session_id));

    ASSERT(sizeof(AppletRegistryKey) == sizeof(T120RegistryKey));
    ASSERT(FIELD_OFFSET(AppletRegistryKey, SessionKey) == FIELD_OFFSET(T120RegistryKey, session_key));
    ASSERT(FIELD_OFFSET(AppletRegistryKey, ostrResourceID) == FIELD_OFFSET(T120RegistryKey, resource_id));

    ASSERT(sizeof(AppletRegistryItem) == sizeof(T120RegistryItem));
    ASSERT(FIELD_OFFSET(AppletRegistryItem, ItemType) == FIELD_OFFSET(T120RegistryItem, item_type));
    ASSERT(FIELD_OFFSET(AppletRegistryItem, nChannelID) == FIELD_OFFSET(T120RegistryItem, channel_id));
    ASSERT(FIELD_OFFSET(AppletRegistryItem, nTokenID) == FIELD_OFFSET(T120RegistryItem, token_id));
    ASSERT(FIELD_OFFSET(AppletRegistryItem, ostrParamValue) == FIELD_OFFSET(T120RegistryItem, parameter));

    ASSERT(sizeof(AppletRegistryEntryOwner) == sizeof(T120RegistryEntryOwner));
    ASSERT(FIELD_OFFSET(AppletRegistryEntryOwner, fEntryOwned) == FIELD_OFFSET(T120RegistryEntryOwner, entry_is_owned));
    ASSERT(FIELD_OFFSET(AppletRegistryEntryOwner, nOwnerNodeID) == FIELD_OFFSET(T120RegistryEntryOwner, owner_node_id));
    ASSERT(FIELD_OFFSET(AppletRegistryEntryOwner, nOwnerEntityID) == FIELD_OFFSET(T120RegistryEntryOwner, owner_entity_id));

    ASSERT(sizeof(AppletCapabilityID) == sizeof(T120CapID));
    ASSERT(FIELD_OFFSET(AppletCapabilityID, eType) == FIELD_OFFSET(T120CapID, capability_id_type));
    ASSERT(FIELD_OFFSET(AppletCapabilityID, nNonStdCap) == FIELD_OFFSET(T120CapID, non_standard_capability));
    ASSERT(FIELD_OFFSET(AppletCapabilityID, nStdCap) == FIELD_OFFSET(T120CapID, standard_capability));

    ASSERT(sizeof(AppletCapability) == sizeof(T120AppCap));
    ASSERT(FIELD_OFFSET(AppletCapability, CapID) == FIELD_OFFSET(T120AppCap, capability_id));
    ASSERT(FIELD_OFFSET(AppletCapability, CapClass) == FIELD_OFFSET(T120AppCap, capability_class));
    ASSERT(FIELD_OFFSET(AppletCapability, cEntities) == FIELD_OFFSET(T120AppCap, number_of_entities));

    ASSERT(sizeof(AppletCapability2) == sizeof(T120NonCollCap));
    ASSERT(FIELD_OFFSET(AppletCapability2, CapID) == FIELD_OFFSET(T120NonCollCap, capability_id));
    ASSERT(FIELD_OFFSET(AppletCapability2, pCapData) == FIELD_OFFSET(T120NonCollCap, application_data));

    ASSERT(sizeof(AppletProtocolEntity) == sizeof(T120APE)); // array of structs vs array of pointers
    ASSERT(FIELD_OFFSET(AppletProtocolEntity, SessionKey) == FIELD_OFFSET(T120APE, session_key));
    ASSERT(FIELD_OFFSET(AppletProtocolEntity, eStartupChannelType) == FIELD_OFFSET(T120APE, startup_channel_type));
    ASSERT(FIELD_OFFSET(AppletProtocolEntity, fMustBeInvoked) == FIELD_OFFSET(T120APE, must_be_invoked));
    ASSERT(FIELD_OFFSET(AppletProtocolEntity, cExpectedCapabilities) == FIELD_OFFSET(T120APE, number_of_expected_capabilities));
    ASSERT(FIELD_OFFSET(AppletProtocolEntity, apExpectedCapabilities) == FIELD_OFFSET(T120APE, expected_capabilities_list));

    ASSERT(sizeof(AppletRecord) == sizeof(T120AppRecord));   // array of structs vs array of pointers
    ASSERT(FIELD_OFFSET(AppletRecord, nNodeID) == FIELD_OFFSET(T120AppRecord, node_id));
    ASSERT(FIELD_OFFSET(AppletRecord, nEntityID) == FIELD_OFFSET(T120AppRecord, entity_id));
    ASSERT(FIELD_OFFSET(AppletRecord, fEnrolledActively) == FIELD_OFFSET(T120AppRecord, is_enrolled_actively));
    ASSERT(FIELD_OFFSET(AppletRecord, fConductingCapable) == FIELD_OFFSET(T120AppRecord, is_conducting_capable));
    ASSERT(FIELD_OFFSET(AppletRecord, eStartupChannelType) == FIELD_OFFSET(T120AppRecord, startup_channel_type));
    ASSERT(FIELD_OFFSET(AppletRecord, nAppletUserID) == FIELD_OFFSET(T120AppRecord, application_user_id));
    ASSERT(FIELD_OFFSET(AppletRecord, cCapabilities) == FIELD_OFFSET(T120AppRecord, number_of_non_collapsed_caps));
    ASSERT(FIELD_OFFSET(AppletRecord, apCapabilities) == FIELD_OFFSET(T120AppRecord, non_collapsed_caps_list));

    ASSERT(sizeof(AppletRoster) == sizeof(T120AppRoster));   // array of structs vs array of pointers
    ASSERT(FIELD_OFFSET(AppletRoster, SessionKey) == FIELD_OFFSET(T120AppRoster, session_key));
    ASSERT(FIELD_OFFSET(AppletRoster, fRosterChanged) == FIELD_OFFSET(T120AppRoster, application_roster_was_changed));
    ASSERT(FIELD_OFFSET(AppletRoster, nInstanceNumber) == FIELD_OFFSET(T120AppRoster, instance_number));
    ASSERT(FIELD_OFFSET(AppletRoster, fNodesAdded) == FIELD_OFFSET(T120AppRoster, nodes_were_added));
    ASSERT(FIELD_OFFSET(AppletRoster, fNodesRemoved) == FIELD_OFFSET(T120AppRoster, nodes_were_removed));
    ASSERT(FIELD_OFFSET(AppletRoster, fCapabilitiesChanged) == FIELD_OFFSET(T120AppRoster, capabilities_were_changed));
    ASSERT(FIELD_OFFSET(AppletRoster, cRecords) == FIELD_OFFSET(T120AppRoster, number_of_records));
    ASSERT(FIELD_OFFSET(AppletRoster, apAppletRecords) == FIELD_OFFSET(T120AppRoster, application_record_list));
    ASSERT(FIELD_OFFSET(AppletRoster, cCapabilities) == FIELD_OFFSET(T120AppRoster, number_of_capabilities));
    ASSERT(FIELD_OFFSET(AppletRoster, apCapabilities) == FIELD_OFFSET(T120AppRoster, capabilities_list));


    ASSERT(sizeof(AppletChannelRequest) == sizeof(T120ChannelRequest));
    ASSERT(FIELD_OFFSET(AppletChannelRequest, eCommand) == FIELD_OFFSET(T120ChannelRequest, eCommand));
    ASSERT(FIELD_OFFSET(AppletChannelRequest, nChannelID) == FIELD_OFFSET(T120ChannelRequest, nChannelID));
    ASSERT(FIELD_OFFSET(AppletChannelRequest, cUsers) == FIELD_OFFSET(T120ChannelRequest, cUsers));
    ASSERT(FIELD_OFFSET(AppletChannelRequest, aUsers) == FIELD_OFFSET(T120ChannelRequest, aUsers));

    ASSERT(sizeof(AppletTokenRequest) == sizeof(T120TokenRequest));
    ASSERT(FIELD_OFFSET(AppletTokenRequest, eCommand) == FIELD_OFFSET(T120TokenRequest, eCommand));
    ASSERT(FIELD_OFFSET(AppletTokenRequest, nTokenID) == FIELD_OFFSET(T120TokenRequest, nTokenID));
    ASSERT(FIELD_OFFSET(AppletTokenRequest, uidGiveTo) == FIELD_OFFSET(T120TokenRequest, uidGiveTo));
    ASSERT(FIELD_OFFSET(AppletTokenRequest, hrGiveResponse) == FIELD_OFFSET(T120TokenRequest, eGiveResponse));
}
#endif // _DEBUG



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\t120app.h ===
#ifndef _T120_APPLET_H_
#define _T120_APPLET_H_

#include "iapplet.h"
#include <it120app.h>
#include "resource.h"


class CNmAppletObj;

class CNmAppletSession : public IAppletSession
{
public:

    CNmAppletSession(CNmAppletObj *, IT120AppletSession *, BOOL fAutoJoin = FALSE);
    ~CNmAppletSession(void);

    /* ------ IUnknown ------ */

    STDMETHODIMP    QueryInterface(REFIID iid, void **ppv);

    STDMETHODIMP_(ULONG)    AddRef(void);

    STDMETHODIMP_(ULONG)    Release(void);

    /* ------ Basic Info ------ */

    STDMETHODIMP    GetConfID(AppletConfID *pnConfID);

    STDMETHODIMP    IsThisNodeTopProvider(BOOL *pfTopProvider);

    /* ------ Join Conference ------ */

    STDMETHODIMP    Join(IN AppletSessionRequest *pRequest);

    STDMETHODIMP    Leave(void);

    /* ------ Send Data ------ */

    STDMETHODIMP    SendData(BOOL               fUniformSend,
                             AppletChannelID    nChannelID,
                             AppletPriority     ePriority,
                             ULONG              cbBufSize,
                             BYTE              *pBuffer); // size_is(cbBufSize)

    /* ------ Invoke Applet ------ */

    STDMETHODIMP    InvokeApplet(AppletRequestTag      *pnReqTag,
                                 AppletProtocolEntity  *pAPE,
                                 ULONG                  cNodes,
                                 AppletNodeID           aNodeIDs[]); // size_is(cNodes)

    /* ------ Inquiry ------ */

    STDMETHODIMP    InquireRoster(AppletSessionKey *pSessionKey);

    /* ------ Registry Services ------ */

    STDMETHODIMP    RegistryRequest(AppletRegistryRequest *pRequest);

    /* ------ Channel Services ------ */

    STDMETHODIMP    ChannelRequest(AppletChannelRequest *pRequest);

    /* ------ Token Services ------ */

    STDMETHODIMP    TokenRequest(AppletTokenRequest *pRequest);

    /* ------ Notification registration / unregistration------ */

    STDMETHODIMP    Advise(IAppletSessionNotify *pNotify, DWORD *pdwCookie);

    STDMETHODIMP    UnAdvise(DWORD dwCookie);


    void T120Callback(T120AppletSessionMsg *);

private:

    LONG                    m_cRef;

    CNmAppletObj           *m_pApplet;

    IT120AppletSession     *m_pT120Session;
    T120JoinSessionRequest *m_pT120SessReq;

    IAppletSessionNotify   *m_pNotify;
    CNmAppletSession       *m_pSessionObj;
    BOOL                    m_fAutoJoin;
};




class ATL_NO_VTABLE CNmAppletObj :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNmAppletObj, &CLSID_NmApplet>,
	public IApplet
{
public:

    CNmAppletObj(void);
    ~CNmAppletObj(void);

public:

DECLARE_REGISTRY_RESOURCEID(IDR_NMAPPLET)
DECLARE_NOT_AGGREGATABLE(CNmAppletObj)

BEGIN_COM_MAP(CNmAppletObj)
	COM_INTERFACE_ENTRY(IApplet)
END_COM_MAP()

    /* ------ Initialization ------ */

    STDMETHODIMP    Initialize(void);

    /* ------ Auto Join ------ */

    STDMETHODIMP    RegisterAutoJoin(AppletSessionRequest *pRequest);

    STDMETHODIMP    UnregisterAutoJoin(void);

    /* ------ Session ------ */

    STDMETHODIMP    CreateSession(IAppletSession **ppSession, AppletConfID nConfID);

    /* ------ Notification registration / unregistration------ */

    STDMETHODIMP    Advise(IAppletNotify *pNotify, DWORD *pdwCookie);

    STDMETHODIMP    UnAdvise(DWORD dwCookie);


    void T120Callback(T120AppletMsg *);

private:

    LONG                    m_cRef;

    IT120Applet            *m_pT120Applet;
    T120JoinSessionRequest *m_pT120AutoJoinReq;

    IAppletNotify          *m_pNotify;
    CNmAppletObj           *m_pAppletObj;
    T120ConfID              m_nPendingConfID;
};


HRESULT GetHrResult(T120Result rc);
AppletReason GetAppletReason(T120Reason rc);

T120JoinSessionRequest * AllocateJoinSessionRequest(AppletSessionRequest *);
void FreeJoinSessionRequest(T120JoinSessionRequest *);

BOOL ConvertCollapsedCaps(T120AppCap ***papDst, AppletCapability **apSrc, ULONG cItems);
void FreeCollapsedCaps(T120AppCap **apDst, ULONG cItems);

BOOL DuplicateCollapsedCap(T120AppCap *pDst, T120AppCap *pSrc);
void FreeCollapsedCap(T120AppCap *pDst);

BOOL DuplicateCapID(T120CapID *pDst, T120CapID *pSrc);
void FreeCapID(T120CapID *pDst);

BOOL ConvertNonCollapsedCaps(T120NonCollCap ***papDst, AppletCapability2 **apSrc, ULONG cItems);
void FreeNonCollapsedCaps(T120NonCollCap **apDst, ULONG cItems);

BOOL DuplicateNonCollapsedCap(T120NonCollCap *pDst, T120NonCollCap *pSrc);
void FreeNonCollapsedCap(T120NonCollCap *pDst);

BOOL DuplicateRegistryKey(T120RegistryKey *pDst, T120RegistryKey *pSrc);
void FreeRegistryKey(T120RegistryKey *pDst);

BOOL DuplicateSessionKey(T120SessionKey *pDst, T120SessionKey *pSrc);
void FreeSessionKey(T120SessionKey *pDst);

BOOL DuplicateObjectKey(T120ObjectKey *pDst, T120ObjectKey *pSrc);
void FreeObjectKey(T120ObjectKey *pDst);

BOOL DuplicateOSTR(OSTR *pDst, OSTR *pSrc);
void FreeOSTR(OSTR *pDst);

void AppletRegistryRequestToT120One(AppletRegistryRequest *, T120RegistryRequest *);


#ifdef _DEBUG
void CheckStructCompatible(void);
#else
#define CheckStructCompatible()
#endif


#endif // _T120_APPLET_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\t120xprt.cpp ===
#include "precomp.h"
#include "iplgxprt.h"
#include "nmmanager.h"


IT120PluggableTransport   * CNmManagerObj::ms_pT120Transport = NULL;
#ifdef ENABLE_UPDATE_CONNECTION
IPluggableTransportNotify * CNmManagerObj::ms_pPluggableTransportNotify = NULL;
#endif

BSTR LPSTR2BSTR(LPSTR pszConnID);
BOOL BSTR2LPSTR(BSTR bstrConnID, LPSTR pszConnID);


//////////////////////////////////////////////////
//
//  CPluggableTransport
//

void CNmManagerObj::EnsureTransportInterface(void)
{
    if (NULL == ms_pT120Transport)
    {
        T120Error rc = ::T120_CreatePluggableTransport(&ms_pT120Transport);
        ASSERT(T120_NO_ERROR == rc);
    }
}


BOOL CNmManagerObj::InitPluggableTransportSDK(void)
{
    ms_pT120Transport = NULL;
#ifdef ENABLE_UPDATE_CONNECTION
    ms_pPluggableTransportNotify = NULL;
#endif
    return TRUE;
}


void CNmManagerObj::CleanupPluggableTransportSDK(void)
{
    if (NULL != ms_pT120Transport)
    {
        ms_pT120Transport->ReleaseInterface();
        ms_pT120Transport = NULL;
    }
#ifdef ENABLE_UPDATE_CONNECTION
    ms_pPluggableTransportNotify = NULL;
#endif
}


//////////////////////////////////////////////////
//
// Connection @ CApplet
//

HRESULT CNmManagerObj::CreateConnection
(
    BSTR               *pbstrConnID,    // For placing a call and closing connection
    PLUGXPRT_CALL_TYPE  eCaller,        // caller or callee
    DWORD               dwProcessID,    // Used for DuplicateHandle
    HCOMMDEV            _hCommLink,     // Handle to communications file handle
    HEVENT              _hevtRead,      // Ready To Read event ( data avail )
    HEVENT              _hevtWrite,     // Ready To Write event 
    HEVENT              _hevtClosed,    // Connection closed ( unexpectedly???) 
    PLUGXPRT_FRAMING    eFraming,       // framing of bits sent on link
    PLUGXPRT_PARAMETERS *pParams        // OPTIONAL framing specific paramters
)
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        if (NULL != pbstrConnID)
        {
            if (dwProcessID && _hCommLink && _hevtRead && _hevtWrite && _hevtClosed)
            {
                HRESULT hr = E_ACCESSDENIED;
                HANDLE hProcess = ::OpenProcess(PROCESS_DUP_HANDLE, TRUE, dwProcessID);
                if (NULL != hProcess)
                {
                    HANDLE hCommLink;
                    if (::DuplicateHandle(hProcess, (HANDLE) _hCommLink,
                                          ::GetCurrentProcess(), &hCommLink,
                                          0, FALSE, DUPLICATE_SAME_ACCESS))
                    {
                        HANDLE hevtRead;
                        if (::DuplicateHandle(hProcess, (HANDLE) _hevtRead,
                                          ::GetCurrentProcess(), &hevtRead,
                                          0, FALSE, DUPLICATE_SAME_ACCESS))
                        {
                            HANDLE hevtWrite;
                            if (::DuplicateHandle(hProcess, (HANDLE) _hevtWrite,
                                          ::GetCurrentProcess(), &hevtWrite,
                                          0, FALSE, DUPLICATE_SAME_ACCESS))
                            {
                                HANDLE hevtClose;
                                if (::DuplicateHandle(hProcess, (HANDLE) _hevtClosed,
                                          ::GetCurrentProcess(), &hevtClose,
                                          0, FALSE, DUPLICATE_SAME_ACCESS))
                                {
                                    char szConnID[T120_CONNECTION_ID_LENGTH];
                                    T120Error rc = ms_pT120Transport->CreateConnection(
                                                        szConnID, eCaller, hCommLink,
                                                        hevtRead, hevtWrite, hevtClose,
                                                        eFraming, pParams);
                                    ASSERT(T120_NO_ERROR == rc);

                                    if (T120_NO_ERROR == rc)
                                    {
                                        *pbstrConnID = ::LPSTR2BSTR(szConnID);
                                        if (NULL != *pbstrConnID)
                                        {
                                            ::CloseHandle(hProcess);
                                            return S_OK;
                                        }

                                        hr = E_OUTOFMEMORY;
                                    }
                                    else
                                    {
                                        hr = E_HANDLE;
                                    }

                                    ::CloseHandle(hevtClose);
                                }

                                ::CloseHandle(hevtWrite);
                            }

                            ::CloseHandle(hevtRead);
                        }

                        ::CloseHandle(hCommLink);
                    }

                    ::CloseHandle(hProcess);
                }

                return hr;
            }

            return E_INVALIDARG;
        }

        return E_POINTER;
    }

    return E_OUTOFMEMORY;
}


#ifdef ENABLE_UPDATE_CONNECTION
HRESULT CNmManagerObj::UpdateConnection
(
    BSTR            bstrConnID,
    DWORD           dwProcessID,    // Used for DuplicateHandle
    HCOMMDEV        _hCommLink      // Handle to communications file handle
)
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        if (NULL != bstrConnID)
        {
            if (dwProcessID && _hCommLink)
            {
                HRESULT hr = E_ACCESSDENIED;
                HANDLE hProcess = ::OpenProcess(PROCESS_DUP_HANDLE, TRUE, dwProcessID);
                if (NULL != hProcess)
                {
                    HANDLE hCommLink;
                    if (::DuplicateHandle(hProcess, (HANDLE) _hCommLink,
                                          ::GetCurrentProcess(), &hCommLink,
                                          0, FALSE, DUPLICATE_SAME_ACCESS))
                    {
                        char szConnID[T120_CONNECTION_ID_LENGTH];
                        if (::BSTR2LPSTR(bstrConnID, szConnID))
                        {
                            T120Error rc = ms_pT120Transport->UpdateConnection(szConnID, hCommLink);
                            ASSERT(T120_NO_ERROR == rc);

                            if (T120_NO_ERROR == rc)
                            {
                                ::CloseHandle(hProcess);
                                return S_OK;
                            }

                            hr = E_HANDLE;
                        }

                        ::CloseHandle(hCommLink);
                    }

                    ::CloseHandle(hProcess);
                }

                return hr;
            }

            return E_INVALIDARG;
        }

        return E_POINTER;
    }

    return E_OUTOFMEMORY;
}
#endif


HRESULT CNmManagerObj::CloseConnection(BSTR bstrConnID) 
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        if (NULL != bstrConnID)
        {
            char szConnID[T120_CONNECTION_ID_LENGTH];
            if (::BSTR2LPSTR(bstrConnID, szConnID))
            {
                T120Error rc = ms_pT120Transport->CloseConnection(szConnID);
                ASSERT(T120_NO_ERROR == rc);

                return (T120_NO_ERROR == rc) ? S_OK : E_INVALIDARG;
            }

            return E_INVALIDARG;
        }

        return E_POINTER;
    }

    return E_OUTOFMEMORY;
}


//////////////////////////////////////////////////
//
// Winsock @ CApplet
//

HRESULT CNmManagerObj::EnableWinsock(void)
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        T120Error rc = ms_pT120Transport->EnableWinsock();
        ASSERT(T120_NO_ERROR == rc);

        return (T120_NO_ERROR == rc) ? S_OK : E_ACCESSDENIED;
    }

    return E_OUTOFMEMORY;
} 


HRESULT CNmManagerObj::DisableWinsock(void) 
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        T120Error rc = ms_pT120Transport->DisableWinsock();
        ASSERT(T120_NO_ERROR == rc);

        return (T120_NO_ERROR == rc) ? S_OK : E_ACCESSDENIED;
    }

    return E_OUTOFMEMORY;
}


#ifdef ENABLE_UPDATE_CONNECTION
void CALLBACK OnPluggableTransportNotify(PLUGXPRT_MESSAGE *pMsg)
{
    if (NULL != pMsg->pContext)
    {
        CNmManagerObj *p = (CNmManagerObj *) pMsg->pContext;
        IPluggableTransportNotify *pNotify = p->ms_pPluggableTransportNotify;

        if (NULL != pNotify)
        {
            BSTR bstr = ::LPSTR2BSTR(pMsg->pszConnID);
            if (NULL != bstr)
            {
                switch (pMsg->eState)
                {
                case PLUGXPRT_CONNECTING:
                    pNotify->OnConnecting(bstr, pMsg->eProtocol);
                    break;
                case PLUGXPRT_CONNECTED:
                    pNotify->OnConnected(bstr, pMsg->eProtocol, pMsg->eResult);
                    break;
                case PLUGXPRT_DISCONNECTING:
                    pNotify->OnDisconnecting(bstr, pMsg->eProtocol);
                    break;
                case PLUGXPRT_DISCONNECTED:
                    pNotify->OnDisconnected(bstr, pMsg->eProtocol, pMsg->eResult);
                    break;
                }

                ::SysFreeString(bstr);
            }
        }
    }
}
#endif


#ifdef ENABLE_UPDATE_CONNECTION
HRESULT CNmManagerObj::AdvisePluggableTransport(IPluggableTransportNotify *pNotify, DWORD *pdwCookie) 
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        // only allow one advise
        if (NULL == ms_pPluggableTransportNotify)
        {
            if (NULL != pNotify && NULL != pdwCookie)
            {
                pNotify->AddRef();
                ms_pPluggableTransportNotify = pNotify;

                AddRef();
                ms_pT120Transport->Advise(OnPluggableTransportNotify, this);

                *pdwCookie = (DWORD) this;

                return S_OK;
            }

            return E_POINTER;
        }

        return E_ACCESSDENIED;
    }

    return E_OUTOFMEMORY;
}
#endif


#ifdef ENABLE_UPDATE_CONNECTION
HRESULT CNmManagerObj::UnAdvisePluggableTransport(DWORD dwCookie) 
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        if (NULL != ms_pPluggableTransportNotify)
        {
            if (dwCookie == (DWORD) this)
            {
                ms_pPluggableTransportNotify->Release(); 
                ms_pPluggableTransportNotify = NULL;

                ms_pT120Transport->UnAdvise();
                Release();

                return S_OK;
            }

            return E_ACCESSDENIED;
        }

        return E_POINTER;
    }

    return E_OUTOFMEMORY;
}
#endif


BSTR LPSTR2BSTR(LPSTR pszConnID)
{
    WCHAR wszConnID[T120_CONNECTION_ID_LENGTH];

    if (::MultiByteToWideChar(CP_ACP, 0, pszConnID, -1, wszConnID, T120_CONNECTION_ID_LENGTH))
    {
        return ::SysAllocString(wszConnID);
    }

    return NULL;
}


BOOL BSTR2LPSTR(BSTR bstrConnID, LPSTR pszConnID)
{
    *pszConnID = '\0';
    return ::WideCharToMultiByte(CP_ACP, 0, bstrConnID, -1, pszConnID, T120_CONNECTION_ID_LENGTH, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\taskbar.h ===
#ifndef _TASKBAR_H_
#define _TASKBAR_H_

BOOL AddTaskbarIcon(HWND hwnd);
BOOL RemoveTaskbarIcon(HWND hwnd);
BOOL OnRightClickTaskbar();
BOOL RefreshTaskbarIcon(HWND hwnd);

#endif // _TASKBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\topwindow.cpp ===
// File: confroom.cpp

#include "precomp.h"

#include "TopWindow.h"

class CParticipant;

#include "dbgMenu.h"
#include "conf.h"
#include "FloatBar.h"
#include "StatBar.h"
#include "RToolbar.h"
#include "GenControls.h"
#include "resource.h"
#include "cr.h"
#include "taskbar.h"
#include "confman.h"
#include <EndSesn.h>
#include "cmd.h"
#include "MenuUtil.h"
#include "ConfPolicies.h"
#include "call.h"
#include "setupdd.h"
#include "VidView.h"
#include "audiowiz.h"
#include "NmLdap.h"
#include "ConfWnd.h"
#include <iappldr.h>
#include "ConfApi.h"
#include "confroom.h"
#include "NmManager.h"
#include "dlgAcd.h"
#include "dlgCall2.h"

static const TCHAR s_cszHtmlHelpFile[] = TEXT("conf.chm");

extern bool g_bInitControl;
BOOL IntCreateRDSWizard(HWND hwndOwner);
INT_PTR CALLBACK RDSSettingDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

extern BOOL FUiVisible(void);
extern BOOL FIsAVCapable();

inline DWORD MenuState(BOOL bEnabled)
{
	return(bEnabled ? MF_ENABLED : MF_DISABLED|MF_GRAYED);
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   CConfRoom()
*
*        PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CTopWindow::CTopWindow():
    m_hFontMenu                     (NULL),
	m_pConfRoom						(NULL),
	m_pSeparator					(NULL),
	m_pMainUI						(NULL),
	m_pStatusBar					(NULL),
	m_hwndPrevFocus					(NULL),

	m_fTaskbarDblClick				(FALSE),
	m_fMinimized					(FALSE),
	m_fClosing						(FALSE),
	m_fEnableAppSharingMenuItem		(FALSE),
        m_fExitAndActivateRDSMenuItem           (FALSE)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CTopWindow", this);

	// Load cursors:
	m_hWaitCursor = ::LoadCursor(NULL, IDC_APPSTARTING);
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   ~CConfRoom()
*
*        PURPOSE:  Destructor
*
****************************************************************************/

CTopWindow::~CTopWindow()
{
    // Delete the menu font:
    DeleteObject(m_hFontMenu);

	// Empty the tools menu list:
	CleanTools(NULL, m_ExtToolsList);

	CloseChildWindows();

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CTopWindow", this);
}

// This gets called from OnClose and from the destructor (just in case)
VOID CTopWindow::CloseChildWindows(void)
{
	HWND hwnd = GetWindow();

	// Hide the main window as soon as possible
	if (NULL != hwnd)
	{
		ShowWindow(hwnd, SW_HIDE);
	}

	// Delete the UI elements:
	delete m_pStatusBar;
	m_pStatusBar = NULL;

	// BUGBUG georgep: This function is getting called twice
	if (NULL != m_pMainUI)
	{
		m_pMainUI->Release();
		m_pMainUI = NULL;
	}
	
	if (NULL != m_pSeparator)
	{
		m_pSeparator->Release();
		m_pSeparator = NULL;
	}
	
    if (NULL != hwnd)
    {
		::DestroyWindow(hwnd);
        ASSERT(!GetWindow());
    }

	if (NULL != m_pConfRoom)
	{
		// Make sure we do not try this multiple times
		CConfRoom *pConfRoom = m_pConfRoom;
		m_pConfRoom = NULL;

		pConfRoom->Release();

		// BUGBUG georgep: We need true reference counting here
		delete pConfRoom;
	}
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateUI(DWORD dwUIMask)
*
*        PURPOSE:  Updates the appropriate pieces of the UI
*
****************************************************************************/

VOID CTopWindow::UpdateUI(DWORD dwUIMask)
{
	if ((CRUI_TOOLBAR & dwUIMask) && (NULL != m_pMainUI))
	{
		m_pMainUI->UpdateButtons();
	}
	if (CRUI_TITLEBAR & dwUIMask)
	{
		UpdateWindowTitle();
	}
	if (CRUI_STATUSBAR & dwUIMask)
	{
		UpdateStatusBar();
	}
	if (CRUI_CALLANIM & dwUIMask)
	{
		UpdateCallAnim();
	}
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateWindowTitle()
*
*        PURPOSE:  Updates the titlebar with the appropriate message
*
****************************************************************************/

BOOL CTopWindow::UpdateWindowTitle()
{
	TCHAR szTitle[MAX_PATH];
	TCHAR szBuf[MAX_PATH];
	BOOL bRet = FALSE;

	if (::LoadString(GetInstanceHandle(), IDS_MEDIAPHONE_TITLE, szBuf, sizeof(szBuf)))
	{
		lstrcpy(szTitle, szBuf);

		int nPart = m_pConfRoom->GetMemberCount();
		if (nPart > 2)
		{
			TCHAR szFormat[MAX_PATH];
			if (::LoadString(GetInstanceHandle(), IDS_MEDIAPHONE_INCALL, szFormat, sizeof(szFormat)))
			{
				wsprintf(szBuf, szFormat, (nPart - 1));
				lstrcat(szTitle, szBuf);
			}
		}
		else if (2 == nPart)
		{
			if (::LoadString(GetInstanceHandle(), IDS_MEDIAPHONE_INCALL_ONE, szBuf, sizeof(szBuf)))
			{
				lstrcat(szTitle, szBuf);
			}
		}
		else
		{
			if (::LoadString(GetInstanceHandle(), IDS_MEDIAPHONE_NOTINCALL, szBuf, sizeof(szBuf)))
			{
				lstrcat(szTitle, szBuf);
			}
		}

		HWND hwnd = GetWindow();
		if (NULL != hwnd)
		{
			bRet = ::SetWindowText(hwnd, szTitle);
		}
	}

	return bRet;
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   Create()
*
*        PURPOSE:  Creates a window
*
****************************************************************************/

BOOL CTopWindow::Create(CConfRoom *pConfRoom, BOOL fShowUI)
{
	ASSERT(NULL == m_pConfRoom);

	m_pConfRoom = pConfRoom;
	m_pConfRoom->AddRef();

	HICON hiBig = LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_CONFROOM));

	if (!CFrame::Create(
		NULL,
		g_szEmpty,
		(WS_OVERLAPPEDWINDOW&~(WS_THICKFRAME|WS_MAXIMIZEBOX)) | WS_CLIPCHILDREN,
		0,
		0, 0,
		100,
		100,
		_Module.GetModuleInstance(),
		hiBig,
		LoadMenu(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_CONFROOM_MENU)),
		g_szConfRoomClass
		))
	{
		return(FALSE);
	}

	// Do a resize early so if the menu wraps, it will be taken into account
	// by the following GetDesiredSize call
	Resize();

	SIZE defSize;
	GetDesiredSize(&defSize);

    InitMenuFont();

	RegEntry reConf(UI_KEY, HKEY_CURRENT_USER);

	// NOTE: it isn't actually the width and the height of the
	// window - it is the right and the bottom.
	RECT rctSize;
	rctSize.right  = defSize.cx;
	rctSize.bottom = defSize.cy;

	rctSize.left   = reConf.GetNumber(REGVAL_MP_WINDOW_X, DEFAULT_MP_WINDOW_X);
	rctSize.top    = reConf.GetNumber(REGVAL_MP_WINDOW_Y, DEFAULT_MP_WINDOW_Y);
	if (ERROR_SUCCESS != reConf.GetError())
	{
		// Center the window on the screen
		int dx = GetSystemMetrics(SM_CXFULLSCREEN);
		if (dx > rctSize.right)
		{
			rctSize.left = (dx - rctSize.right) / 2;
		}

		int dy = GetSystemMetrics(SM_CYFULLSCREEN);

#if FALSE
		// BUGBUG georgep: Should this be in GetDesiredSize?
		// adjust default height if using large video windows on a LAN
		if (dy >= 553) // 800 x 600
		{
			RegEntry reAudio(AUDIO_KEY, HKEY_CURRENT_USER);
			if (BW_MOREKBS == reAudio.GetNumber(REGVAL_TYPICALBANDWIDTH,BW_DEFAULT))
			{
				ASSERT(DEFAULT_MP_WINDOW_HEIGHT == rctSize.bottom);
				rctSize.bottom = DEFAULT_MP_WINDOW_HEIGHT_LAN;
			}
		}
#endif

		if (dy > rctSize.bottom)
		{
			rctSize.top = (dy - rctSize.bottom) / 2;
		}
	}

	rctSize.right += rctSize.left;
	rctSize.bottom += rctSize.top;
	
	WINDOWPLACEMENT wp;
	wp.length = sizeof(wp);

	HWND hwnd = GetWindow();

	::GetWindowPlacement(hwnd, &wp);
	wp.flags = 0;


	if (!fShowUI)
	{
		// NOUI - must hide
		wp.showCmd = SW_HIDE;
	}
	else
	{
		wp.showCmd = SW_SHOWNORMAL;

		STARTUPINFO si;
		si.cb = sizeof(si);
		::GetStartupInfo(&si);
		if ((STARTF_USESHOWWINDOW & si.dwFlags) &&
			(SW_SHOWMAXIMIZED != si.wShowWindow))
		{
			wp.showCmd = si.wShowWindow;
		}
	}


	wp.rcNormalPosition = rctSize;

	CNmManagerObj::OnShowUI(fShowUI);

	::SetWindowPlacement(hwnd, &wp);

	switch (wp.showCmd)
	{
		case SW_SHOWMINIMIZED:
		case SW_MINIMIZE:
		case SW_SHOWMINNOACTIVE:
		case SW_FORCEMINIMIZE:
		case SW_HIDE:
			break;
		default:
			if (0 != ::SetForegroundWindow(hwnd))
			{
				// BUGBUG georgep: Shouldn't the system do this for us?
				FORWARD_WM_QUERYNEWPALETTE(GetWindow(), ProcessMessage);
			}
			break;
	}
		
	// Paint the window completely (bug 171):
	// ::UpdateWindow(hwnd);

	//
	// Call GetSystemMenu(m_hwnd, FALSE) to get the private copy
	// of the system menu created NOW before we enter menu mode the
	// first time.private copy created.  That way calling
	// GetSystemMenu(m_hwnd, FALSE) in OnMenuSelect
	// won't wipe out the old menu and cause the sysmenu to be
	// positioned in the wrong place the first time.
	//
	::GetSystemMenu(hwnd, FALSE);

#ifdef DEBUG
	// Verify all of the menus have the proper text
	// TODO: Verify accelerator keys are unique per menu
	{
		HMENU hMenuMain = ::GetMenu(hwnd);
		for (int iMenu = 0; iMenu <= MENUPOS_HELP; iMenu++)
		{
			HMENU hMenuSub = ::GetSubMenu(hMenuMain, iMenu);
			for (int i = 0; ; i++)
			{
				TCHAR szMenu[MAX_PATH];
				MENUITEMINFO mii;
				InitStruct(&mii);
				mii.fMask = MIIM_TYPE | MIIM_DATA | MIIM_ID | MIIM_SUBMENU;
				mii.dwTypeData = szMenu;
				mii.cch = CCHMAX(szMenu);
				if (!GetMenuItemInfo(hMenuSub, i, TRUE, &mii))
					break; // out of for loop

				if (0 != (mii.fType & MFT_SEPARATOR))
					continue; // skip separators

				if (0 != (mii.hSubMenu))
					continue; // skip submenus
			}
		}
	}
#endif /* DEBUG */

	UpdateStatusBar();

	return(TRUE);
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   SaveSettings()
*
*        PURPOSE:  Saves UI settings in the registry
*
****************************************************************************/

VOID CTopWindow::SaveSettings()
{
	DebugEntry(CConfRoom::SaveSettings);
	RegEntry reConf(UI_KEY, HKEY_CURRENT_USER);
	
	// Save window coords to registry:
	WINDOWPLACEMENT wp;
	wp.length = sizeof(WINDOWPLACEMENT);

	if (::GetWindowPlacement(GetWindow(), &wp))
	{
		reConf.SetValue(REGVAL_MP_WINDOW_X,
						wp.rcNormalPosition.left);
		reConf.SetValue(REGVAL_MP_WINDOW_Y,
						wp.rcNormalPosition.top);
	}

	// Save window elements to the registry:
	reConf.SetValue(REGVAL_SHOW_STATUSBAR, CheckMenu_ViewStatusBar(NULL));

	if (NULL != m_pMainUI)
	{
		m_pMainUI->SaveSettings();

		// Only write if a setting has changed, so we can have default
		// behavior as long as possible
		if (m_fStateChanged)
		{
			int state = 0;

			if (m_pMainUI->IsCompact())
			{
				state = State_Compact;
			}
			else if (m_pMainUI->IsDataOnly())
			{
				state = State_DataOnly;
			}
			else
			{
				state = State_Normal;
			}

			if (m_pMainUI->IsPicInPic())
			{
				state |= SubState_PicInPic;
			}
			if (m_pMainUI->IsDialing())
			{
				state |= SubState_Dialpad;
			}
			if (IsOnTop())
			{
				state |= SubState_OnTop;
			}

			reConf.SetValue(REGVAL_MP_WINDOW_STATE, state);
		}
	}

	// NOTE: CMainUI saves its settings in its destructor
	
	DebugExitVOID(CConfRoom::SaveSettings);
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   BringToFront()
*
*        PURPOSE:  Restores the window (if minimized) and brings it to the front
*
****************************************************************************/

BOOL CTopWindow::BringToFront()
{
	ShowUI();
	return TRUE;
}


/*  S H O W  U  I  */
/*-------------------------------------------------------------------------
    %%Function: ShowUI

    Show the main NetMeeting window.
-------------------------------------------------------------------------*/
VOID CTopWindow::ShowUI(void)
{
	HWND hwnd = GetWindow();

	if (NULL == hwnd)
		return; // no ui to show?

	if (!IsWindowVisible(hwnd))
	{
		CNmManagerObj::OnShowUI(TRUE);

		ShowWindow(hwnd, SW_SHOW);
	}

	WINDOWPLACEMENT wp;
	wp.length = sizeof(wp);

	if (::GetWindowPlacement(hwnd, &wp) &&
		((SW_MINIMIZE == wp.showCmd) || (SW_SHOWMINIMIZED == wp.showCmd)))
	{
		// The window is minimized - restore it:
		::ShowWindow(hwnd, SW_RESTORE);
	}

	::SetForegroundWindow(hwnd);
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   ProcessMessage(HWND, UINT, WPARAM, LPARAM)
*
*        PURPOSE:  Handles messages except WM_CREATE and WM_COMMAND
*
****************************************************************************/

LRESULT CTopWindow::ProcessMessage( HWND hWnd,
								UINT message,
								WPARAM wParam,
								LPARAM lParam)
{
    static const UINT c_uMsgXchgConf = ::RegisterWindowMessage(_TEXT("Xchg_TAPIVideoRelease"));

	switch (message)
	{
		HANDLE_MSG(hWnd, WM_INITMENU     , OnInitMenu);
		HANDLE_MSG(hWnd, WM_INITMENUPOPUP, OnInitMenuPopup);
        HANDLE_MSG(hWnd, WM_MEASUREITEM,   OnMeasureItem);
        HANDLE_MSG(hWnd, WM_DRAWITEM,      OnDrawItem);
		HANDLE_MSG(hWnd, WM_COMMAND      , OnCommand);

		// The windowsx macro does not pass down the offset of the popup menu
		case WM_MENUSELECT:
			OnMenuSelect(hWnd, (HMENU)(lParam), (int)(LOWORD(wParam)),
				(UINT)(((short)HIWORD(wParam) == -1) ? 0xFFFFFFFF : HIWORD(wParam)));
			return(0);

		case WM_CREATE:
		{
			// We need to add our accelerator table before the children do
			m_pAccel = new CTranslateAccelTable(GetWindow(),
				::LoadAccelerators(GetInstanceHandle(), MAKEINTRESOURCE(IDR_ACCELERATORS)));
			if (NULL != m_pAccel)
			{
				AddTranslateAccelerator(m_pAccel);
			}

			// AddModelessDlg(hWnd);

			CreateChildWindows();

			InitDbgMenu(hWnd);

			break;
		}

		case WM_ACTIVATE:
		{
			if ((WA_INACTIVE == LOWORD(wParam)) && (FALSE == m_fMinimized))
			{
				m_hwndPrevFocus = ::GetFocus();
				TRACE_OUT(("Losing activation, focus on hwnd 0x%08x",
							m_hwndPrevFocus));
			}
			else if (NULL != m_hwndPrevFocus)
			{
				::SetFocus(m_hwndPrevFocus);
			}
			else
			{
				if (NULL != m_pMainUI)
				{
					::SetFocus(m_pMainUI->GetWindow());
				}
			}
			break;
		}

		case WM_GETMINMAXINFO:
		{
			if (FALSE != m_fMinimized)
			{
				// if the window is minimized, we don't want to handle this
				break;
			}

			SIZE size;
			GetDesiredSize(&size);

			((LPMINMAXINFO) lParam)->ptMinTrackSize.x = size.cx;
			((LPMINMAXINFO) lParam)->ptMinTrackSize.y = size.cy;
			return 0;
		}

		case WM_STATUSBAR_UPDATE:
			UpdateStatusBar();
			break;

		case WM_SYSCOLORCHANGE:
		{
			if (NULL != m_pMainUI)
			{
				m_pMainUI->ForwardSysChangeMsg(message, wParam, lParam);
			}
			break;
		}

		case WM_WININICHANGE:
		{
            InitMenuFont();

			// Propagate the message to the child windows:
			if (NULL != m_pStatusBar)
			{
				m_pStatusBar->ForwardSysChangeMsg(message, wParam, lParam);
			}
			if (NULL != m_pMainUI)
			{
				m_pMainUI->ForwardSysChangeMsg(message, wParam, lParam);
			}

			// Force a resize:
			if (NULL != m_pStatusBar)
			{
				m_pStatusBar->Resize(SIZE_RESTORED, 0);
			}
			ResizeChildWindows();
			break;
		}

		case WM_HELP:
		{
			LPHELPINFO phi = (LPHELPINFO) lParam;

			ASSERT(phi);
			TRACE_OUT(("WM_HELP, iContextType=%d, iCtrlId=%d",
						phi->iContextType, phi->iCtrlId));
			break;
		}

		case WM_SETCURSOR:
		{
			switch (LOWORD(lParam))
			{
				case HTLEFT:
				case HTRIGHT:
				case HTTOP:
				case HTTOPLEFT:
				case HTTOPRIGHT:
				case HTBOTTOM:
				case HTBOTTOMLEFT:
				case HTBOTTOMRIGHT:
				{
					break;
				}
				
				default:
				{
					if (g_cBusyOperations > 0)
					{
						::SetCursor(m_hWaitCursor);
						return TRUE;
					}
				}
			}
			// we didn't process the cursor msg:
			return CFrame::ProcessMessage(hWnd, message, wParam, lParam);
		}

		case WM_SIZE:
		{
			if (SIZE_MINIMIZED == wParam)
			{
				// transitioning to being minimized:
				m_fMinimized = TRUE;
			}
			else if ((SIZE_MAXIMIZED == wParam) || (SIZE_RESTORED == wParam))
			{
				if (m_fMinimized)
				{
					// transitioning from being minimized:
					m_fMinimized = FALSE;
					if (NULL != m_hwndPrevFocus)
					{
						::SetFocus(m_hwndPrevFocus);
					}
				}
				if (NULL != m_pStatusBar)
				{
					m_pStatusBar->Resize(wParam, lParam);
				}
				ResizeChildWindows();
			}

			// The menu may have wrapped or unwrapped
			OnDesiredSizeChanged();
			break;
		}

		case WM_SYSCOMMAND:
		{
			if (SC_MINIMIZE == wParam)
			{
				m_hwndPrevFocus = ::GetFocus();
				TRACE_OUT(("Being minimized, focus on hwnd 0x%08x",
							m_hwndPrevFocus));
			}
			return CFrame::ProcessMessage(hWnd, message, wParam, lParam);
		}
		
		// Doing this in QUERYENDSESSION so all apps have more CPU to shut down
		case WM_QUERYENDSESSION:
		{
			if (FIsConferenceActive() &&
				(IDNO == ::ConfMsgBox(  GetWindow(),
										(LPCTSTR) IDS_CLOSEWINDOW_PERMISSION,
										MB_SETFOREGROUND | MB_YESNO | MB_ICONQUESTION)))
			{
				return FALSE;
			}
			CMainUI *pMainUI = GetMainUI();
			if (NULL != pMainUI)
			{
				if (!pMainUI->OnQueryEndSession())
				{
					return(FALSE);
				}
			}
			m_pConfRoom->OnHangup(NULL, FALSE); // we've already confirmed
			return TRUE;
		}

		case WM_CLOSE:
			// HACKHACK: lParam shouldn't really be used in a WM_CLOSE
			OnClose(hWnd, lParam);
			break;

		case WM_DESTROY:
		{
			// RemoveModelessDlg(hWnd);

			if (NULL != m_pAccel)
			{
				RemoveTranslateAccelerator(m_pAccel);
				m_pAccel->Release();
				m_pAccel = NULL;
			}
			break;
		}

		case WM_POWERBROADCAST:
		{
			// Don't allow suspend while NetMeeting is running
			// so that we can receive calls.
			if (PBT_APMQUERYSUSPEND == wParam)
			{
				// Don't suspend on Win95 - we can't handle it
				if (g_osvi.dwMajorVersion == 4 && g_osvi.dwMinorVersion == 0
					&& g_osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
				{
					// Put up UI if lParam says it's ok to do so
					if ( lParam & 0x1 )
					{
						::PostConfMsgBox(IDS_WONT_SUSPEND);
					}
					return BROADCAST_QUERY_DENY;
				}
			}
			return CFrame::ProcessMessage(hWnd, message, wParam, lParam);
		}

		default:
		{
            if (message == c_uMsgXchgConf)
            {
                OnReleaseCamera();
            }
            else
            {
    			return CFrame::ProcessMessage(hWnd, message, wParam, lParam);
            }
            break;
		}
	}
	return 0;
}


//
// OnReleaseCamera()
//
// This is a hack for Exchange Real-Time server, so that NetMeeting will
// release the video camera while the user is in an Xchg multicast video
// conference, but can get it back when either
//      * the user goes to video options
//      * the conference ends
//
void CTopWindow::OnReleaseCamera(void)
{
    CVideoWindow *pLocal = GetLocalVideo();
    if (NULL != pLocal)
    {
        // Release camera if in use
        WARNING_OUT(("CTopWindow::OnReleaseCamera -- releasing capture device"));
        pLocal->SetCurrCapDevID((DWORD)-1);
    }
}


void CTopWindow::OnClose(HWND hwnd, LPARAM lParam)
{
	ASSERT(!m_fClosing);
	m_fClosing = TRUE;

	BOOL fNeedsHangup = FALSE;

	if (0 == CNmManagerObj::GetManagerCount(NM_INIT_OBJECT))
	{
		fNeedsHangup = FIsConferenceActive();

		if(fNeedsHangup && _Module.IsUIVisible())
		{
			UINT_PTR uMsg;
			if ((m_pConfRoom->GetMemberCount() <= 2) ||
				(FALSE == m_pConfRoom->FHasChildNodes()))
			{
				// Get confirmation
				// (DON'T mention that it will disconnect others)
				uMsg = IDS_CLOSEWINDOW_PERMISSION;
			}
			else
			{
				// Get confirmation
				// (DO mention that it will disconnect others)
				uMsg = IDS_CLOSE_DISCONNECT_PERMISSION;
			}
			UINT uMsgResult = ::ConfMsgBox( GetWindow(),
										(LPCTSTR) uMsg,
										MB_YESNO | MB_ICONQUESTION);
			if (IDNO == uMsgResult)
			{
				m_fClosing = FALSE;
				ShowUI();
				return;
			}
		}
	}

	BOOL fListen = (0 == lParam) && ConfPolicies::RunWhenWindowsStarts();

	if((0 != _Module.GetLockCount())  || fListen)
	{
			// Hang up before closing (don't need to confirm)
		if(fNeedsHangup)
		{
			m_pConfRoom->OnHangup(NULL, FALSE);
		}

		WARNING_OUT(("Hiding NetMeeting Window"));

		CNmManagerObj::OnShowUI(FALSE);

		ShowWindow(GetWindow(), SW_HIDE);

		m_fClosing = FALSE;
		return; // we're closed :-)
	}

	if (0 != g_uEndSessionMsg)
	{
		HWND hWndWB = FindWindow( "Wb32MainWindowClass", NULL );

		if (hWndWB)
		{
		DWORD_PTR dwResult = TRUE;

	::SendMessageTimeout( hWndWB,
							  g_uEndSessionMsg,
							  0,
							  0,
							  SMTO_BLOCK | SMTO_ABORTIFHUNG,
							  g_cuEndSessionMsgTimeout,
							  &dwResult
							);

			if( g_cuEndSessionAbort == dwResult )
		{
			m_fClosing = FALSE;
			ShowUI();
			return;
	}
		}
	}


	// Check to see if Chat can close

	if(!m_pConfRoom->CanCloseChat(GetWindow()) ||
	   !m_pConfRoom->CanCloseWhiteboard(GetWindow()) ||
	   !m_pConfRoom->CanCloseFileTransfer(GetWindow()))
	{
		m_fClosing = FALSE;
		if (!_Module.IsSDKCallerRTC())
		{
    		ShowUI();
        }
		return;
	}

	if(0 != _Module.GetLockCount())
	{
		m_fClosing = FALSE;
		return;
	}

	SignalShutdownStarting();

	// Shut the preview off, this speeds up closing the app
	// and avoids fault in connection point object
	// (see bug 3301)
	CMainUI *pMainUI = GetMainUI();
	if (NULL != pMainUI)
	{
		pMainUI->OnClose();
	}

	if (fNeedsHangup)
	{
		// Hang up before closing (don't need to confirm)
		m_pConfRoom->OnHangup(NULL, FALSE);
	}
	
	// Ensure that the help window goes away if it is up:
	ShutDownHelp();
	// Shut down the Find Someone window before destroying g_pConfRoom
	CFindSomeone::Destroy();

    m_pConfRoom->TerminateAppSharing();

	SaveSettings();

	m_pConfRoom->FreePartList();
	CloseChildWindows();
}

void CTopWindow::GetDesiredSize(SIZE *psize)
{
	HWND hwnd = GetWindow();

#if TRUE // {
	// Need to check the actual non-client area in case the menu has wrapped
	RECT rctWnd, rctCli;
	::GetWindowRect(hwnd, &rctWnd);
	::GetClientRect(hwnd, &rctCli);
	// Determine the size of the non-client portions of the window
	// NOTE: rctCli.left and rctCli.top are always zero
	int dx = rctWnd.right - rctWnd.left - rctCli.right;
	int dy = rctWnd.bottom - rctWnd.top - rctCli.bottom;
#else // }{
	RECT rcTemp = { 0, 0, 0, 0 };
	AdjustWindowRectEx(&rcTemp, GetWindowLong(hwnd, GWL_STYLE), TRUE,
		GetWindowLong(hwnd, GWL_EXSTYLE));

	int dx = rcTemp.right  - rcTemp.left;
	int dy = rcTemp.bottom - rcTemp.top;
#endif // }

	if (NULL != m_pMainUI)
	{
		SIZE size;

		m_pMainUI->GetDesiredSize(&size);
		dx += size.cx;
		dy += size.cy;
	}

	if (NULL != m_pSeparator)
	{
		SIZE size;

		m_pSeparator->GetDesiredSize(&size);
		dy += size.cy;
	}

	if (NULL != m_pStatusBar)
	{
		dy += m_pStatusBar->GetHeight();
	}

	psize->cx = dx;
	psize->cy = dy;
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   OnMeasureMenuItem(LPMEASUREITEMSTRUCT lpmis)
*
*        PURPOSE:  Handles WM_MEASUREITEM for owner drawn menus
*
****************************************************************************/

void CTopWindow::OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT * lpmis)
{
	if (ODT_MENU != lpmis->CtlType)
	{
		return;
	}

	ASSERT(ODT_MENU == lpmis->CtlType);
	PMYOWNERDRAWSTRUCT pmods = (PMYOWNERDRAWSTRUCT) lpmis->itemData;
	
	if (NULL != pmods)
	{
		//TRACE_OUT(("WM_MEASUREITEM, hIcon=0x%x, "
		//              "pszText=%s", pmods->hIcon, pmods->pszText));

		// get size of text:

		/* Retrieve a device context for the main window. */

		HDC hdc = GetDC(hwnd);


		HFONT hfontOld = SelectFont(hdc, m_hFontMenu);
		/*
		 * Retrieve the width and height of the item's string,
		 * and then copy the width and height into the
		 * MEASUREITEMSTRUCT structure's itemWidth and
		 * itemHeight members.
		 */

		SIZE size;
		GetTextExtentPoint32(   hdc,
								pmods->pszText,
								lstrlen(pmods->pszText),
								&size);
		
		/*
		 * Remember to leave space in the menu item for the
		 * check mark bitmap. Retrieve the width of the bitmap
		 * and add it to the width of the menu item.
		 */
		lpmis->itemHeight = size.cy;
		lpmis->itemWidth = size.cx + MENUICONSIZE + MENUICONGAP + (2 * MENUICONSPACE);
		if (pmods->fCanCheck)
		{
			lpmis->itemWidth += ::GetSystemMetrics(SM_CXMENUCHECK);
		}
		
		// Adjust height if necessary:
		NONCLIENTMETRICS ncm;
		ncm.cbSize = sizeof(ncm);
		if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE))
		{
			// BUGBUG: In order to look correct,
			// this is necessary - I'm not sure why - investigate
			ncm.iMenuHeight += 2;
			
			if (lpmis->itemHeight < (UINT) ncm.iMenuHeight)
			{
				lpmis->itemHeight = ncm.iMenuHeight;
			}
		}

		/*
		 * Select the old font back into the device context,
		 * and then release the device context.
		 */

		SelectObject(hdc, hfontOld);
		ReleaseDC(hwnd, hdc);
	}
	else
	{
		WARNING_OUT(("NULL pmods passed in WM_MEASUREITEM"));
	}
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   OnDrawItem(LPDRAWITEMSTRUCT lpdis)
*
*        PURPOSE:  Handles WM_DRAWITEM for owner drawn menus
*
****************************************************************************/

void CTopWindow::OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpdis)
{
	if (ID_STATUS == lpdis->CtlID)
	{
		if (NULL != m_pStatusBar)
		{
			m_pStatusBar->OnDraw(const_cast<DRAWITEMSTRUCT*>(lpdis));
		}
		return;
	}

	if (ODT_MENU != lpdis->CtlType)
	{
		return;
	}

	PMYOWNERDRAWSTRUCT pmods = (PMYOWNERDRAWSTRUCT) lpdis->itemData;
	BOOL fSelected = 0 != (lpdis->itemState & ODS_SELECTED);

	COLORREF crText = SetTextColor(lpdis->hDC,
		::GetSysColor(fSelected ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT));
	COLORREF crBkgnd = SetBkColor(lpdis->hDC,
		::GetSysColor(fSelected ? COLOR_HIGHLIGHT : COLOR_MENU));

	/*
	 * Remember to leave space in the menu item for the
	 * check mark bitmap. Retrieve the width of the bitmap
	 * and add it to the width of the menu item.
	 */
	int nIconX = (pmods->fCanCheck ? ::GetSystemMetrics(SM_CXMENUCHECK) : 0)
					+ lpdis->rcItem.left;
	int nTextY = lpdis->rcItem.top;

	// BUGBUG: remove hard-coded constants:
	int nTextX = nIconX + MENUTEXTOFFSET;
	
    HFONT hfontOld = SelectFont(lpdis->hDC, m_hFontMenu);

	// Adjust vertical centering:
	SIZE size;
	GetTextExtentPoint32(   lpdis->hDC,
							pmods->pszText,
							lstrlen(pmods->pszText),
							&size);

	if (size.cy < (lpdis->rcItem.bottom - lpdis->rcItem.top))
	{
		nTextY += ((lpdis->rcItem.bottom - lpdis->rcItem.top) - size.cy) / 2;
	}

	RECT rctTextOut = lpdis->rcItem;
	if (fSelected)
	{
		rctTextOut.left += (nIconX + MENUSELTEXTOFFSET);
	}
	ExtTextOut(lpdis->hDC, nTextX, nTextY, ETO_OPAQUE,
		&rctTextOut, pmods->pszText,
		lstrlen(pmods->pszText), NULL);

	if (pmods->fChecked)
	{
		ASSERT(pmods->fCanCheck);
		HDC hdcMem = ::CreateCompatibleDC(NULL);
		if (NULL != hdcMem)
		{
			HBITMAP hbmpCheck = ::LoadBitmap(       NULL,
												MAKEINTRESOURCE(OBM_CHECK));
			if (NULL != hbmpCheck)
			{
				HBITMAP hBmpOld = (HBITMAP) ::SelectObject(hdcMem, hbmpCheck);
				COLORREF crOldText = ::SetTextColor(lpdis->hDC, ::GetSysColor(COLOR_MENUTEXT));
											//              ::GetSysColor(fSelected ?
											//                      COLOR_HIGHLIGHTTEXT :
											//                      COLOR_MENUTEXT));
				COLORREF crOldBkgnd = ::SetBkColor( lpdis->hDC, ::GetSysColor(COLOR_MENU));
											//              ::GetSysColor(fSelected ?
											//                      COLOR_HIGHLIGHT :
											//                      COLOR_MENU));

				::BitBlt(       lpdis->hDC,
							lpdis->rcItem.left,
							nTextY,
                            ::GetSystemMetrics(SM_CXMENUCHECK),
                            ::GetSystemMetrics(SM_CYMENUCHECK),
							hdcMem,
							0,
							0,
							SRCCOPY);

				::SetTextColor(lpdis->hDC, crOldText);
				::SetBkColor(lpdis->hDC, crOldBkgnd);

				::SelectObject(hdcMem, hBmpOld);

		::DeleteObject(hbmpCheck);
			}
			::DeleteDC(hdcMem);
		}
	}

	HICON hIconMenu = pmods->hIcon;
	
	if (fSelected)
	{
		if (NULL != pmods->hIconSel)
		{
			hIconMenu = pmods->hIconSel;
		}

		RECT rctIcon = lpdis->rcItem;
		rctIcon.left = nIconX;
		rctIcon.right = nIconX + MENUICONSIZE + (2 * MENUICONSPACE);
		::DrawEdge( lpdis->hDC,
					&rctIcon,
					BDR_RAISEDINNER,
					BF_RECT | BF_MIDDLE);
	}
	int nIconY = lpdis->rcItem.top;
	if (MENUICONSIZE < (lpdis->rcItem.bottom - lpdis->rcItem.top))
	{
		nIconY += ((lpdis->rcItem.bottom - lpdis->rcItem.top) - MENUICONSIZE) / 2;
	}
	if (NULL != hIconMenu)
	{
		::DrawIconEx(   lpdis->hDC,
						nIconX + MENUICONSPACE,
						nIconY,
						hIconMenu,
						MENUICONSIZE,
						MENUICONSIZE,
						0,
						NULL,
						DI_NORMAL);
	}
	else
	{
		DrawIconSmall(lpdis->hDC, pmods->iImage,
						nIconX + MENUICONSPACE, nIconY);
	}

    SelectFont(lpdis->hDC, hfontOld);

	/*
	 * Return the text and background colors to their
	 * normal state (not selected).
	 */

	// Restore the colors
	SetTextColor(lpdis->hDC, crText);
	SetBkColor(lpdis->hDC, crBkgnd);
}



/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   ForceWindowResize()
*
*        PURPOSE:  Handles redrawing the window after something changed
*
****************************************************************************/

VOID CTopWindow::ForceWindowResize()
{
	HWND hwnd = GetWindow();

	DBGENTRY(CConfRoom::ForceWindowResize);

	if (m_fMinimized || !FUiVisible())
		return; // nothing to resize

	// Turn off redraws:
	::SendMessage(hwnd, WM_SETREDRAW, FALSE, 0);
	// resize:
	ResizeChildWindows();
	// Turn on redraws and then redraw everything:
	::SendMessage(hwnd, WM_SETREDRAW, TRUE, 0);
	::RedrawWindow( hwnd,
					NULL,
					NULL,
					RDW_ALLCHILDREN | RDW_INVALIDATE |
						RDW_ERASE | RDW_ERASENOW);
}




/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   OnCommand(WPARAM, LPARAM)
*
*        PURPOSE:  Handles command messages
*
****************************************************************************/

void CTopWindow::OnCommand(HWND hwnd, int wCommand, HWND hwndCtl, UINT codeNotify)
{
	switch(wCommand)
	{
		case ID_AUTOACCEPT:
			ConfPolicies::SetAutoAcceptCallsEnabled(!ConfPolicies::IsAutoAcceptCallsEnabled());
			break;

		case ID_PRIVATE_UPDATE_UI:
		{
			UpdateUI(codeNotify);
			break;
		}

		case ID_HELP_WEB_FREE:
		case ID_HELP_WEB_FAQ:
		case ID_HELP_WEB_FEEDBACK:
		case ID_HELP_WEB_MSHOME:
		case ID_HELP_WEB_SUPPORT:
		case ID_HELP_WEB_NEWS:
		{
			CmdLaunchWebPage(wCommand);
			break;
		}
		
		case IDM_FILE_DIRECTORY:
		{
			CFindSomeone::findSomeone(m_pConfRoom);
		}
		break;

		case IDM_FILE_LOGON_ULS:
		{
			
			if( ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_GateKeeper )
			{ // this means that we are in Gatekeeper mode

				if( IsGatekeeperLoggedOn() || IsGatekeeperLoggingOn() )
				{
						// The text of the menu item should have read "LogOff Gatekeeper"
						// so we are going to take the command and log off
					GkLogoff();
				}
				else
				{
						// The text of the menu item should have read "LogOn Gatekeeper"
						// so we are going to take the command and log on
					GkLogon();
				}
			}
			else
			{
				g_pConfRoom->ToggleLdapLogon();
			}
			break;
		}

		case ID_HELP_HELPTOPICS:
		{
			ShowNmHelp(s_cszHtmlHelpFile);
			break;
		}
		
		case ID_HELP_ABOUTOPRAH:
		{
			CmdShowAbout(hwnd);
			break;
		}

		case ID_HELP_RELEASE_NOTES:
		{
			CmdShowReleaseNotes();
			break;
		}

		case ID_STOP:
		{
			CancelAllOutgoingCalls();
			break;
		}

		// General Toolbar Commands:
        case ID_FILE_EXIT_ACTIVATERDS:
        {
            RegEntry re(REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
            re.SetValue(REMOTE_REG_ACTIVATESERVICE, 1);
            // then fall through IDM_FILE_EXIT
        }

		case IDM_FILE_EXIT:
		{
			// ISSUE: Should this be a PostMessage?
			::SendMessage(GetWindow(), WM_CLOSE, 0, 0);
			break;
		}

		case ID_FILE_CONF_HOST:
		{
			CmdHostConference(hwnd);
			break;
		}

		case ID_FILE_DO_NOT_DISTURB:
		{
			CmdDoNotDisturb(hwnd);
			UpdateUI(CRUI_STATUSBAR);
			break;
		}

		case IDM_VIEW_STATUSBAR:
		{
			CmdViewStatusBar();
			OnDesiredSizeChanged();
			break;
		}

		case IDM_VIEW_COMPACT:
			if (NULL != m_pMainUI)
			{
				m_fStateChanged = TRUE;
				m_pMainUI->SetCompact(!m_pMainUI->IsCompact());
			}
			break;

		case IDM_VIEW_DATAONLY:
			if (NULL != m_pMainUI)
			{
				m_fStateChanged = TRUE;
				m_pMainUI->SetDataOnly(!m_pMainUI->IsDataOnly());
			}
			break;

		case IDM_VIEW_DIALPAD:
			if (NULL != m_pMainUI)
			{
				m_fStateChanged = TRUE;
				m_pMainUI->SetDialing(!m_pMainUI->IsDialing());
			}
			break;

		case ID_TB_PICINPIC:
			if (NULL != m_pMainUI)
			{
				m_fStateChanged = TRUE;
				m_pMainUI->SetPicInPic(!m_pMainUI->IsPicInPic());
			}
			break;

		case IDM_VIEW_ONTOP:
			m_fStateChanged = TRUE;
			SetOnTop(!IsOnTop());
			break;

		case ID_TOOLS_ENABLEAPPSHARING:
		{
			::OnEnableAppSharing(GetWindow());
			break;
		}

                case ID_TOOLS_RDSWIZARD:
                {
					RegEntry reCU( CONFERENCING_KEY, HKEY_CURRENT_USER);

					BOOL fAlwaysRunning = (0 != reCU.GetNumber(
								REGVAL_CONF_ALWAYS_RUNNING,	ALWAYS_RUNNING_DEFAULT ));

					if (fAlwaysRunning)
					{
						TCHAR szMsg[2*RES_CH_MAX];
						USES_RES2T
						if (IDYES != MessageBox(GetWindow(),
							Res2THelper(IDS_RWSWARNING, szMsg, ARRAY_ELEMENTS(szMsg)), RES2T(IDS_MSGBOX_TITLE),
							MB_YESNO|MB_ICONHAND))
						{
							break;
						}

						reCU.SetValue(REGVAL_CONF_ALWAYS_RUNNING, (unsigned long)FALSE);
						RegEntry reRun(WINDOWS_RUN_KEY, HKEY_CURRENT_USER);
						reRun.DeleteValue(REGVAL_RUN_TASKNAME);
					}

                    RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
                    if (-1 != reLM.GetNumber(REMOTE_REG_RUNSERVICE,-1))
                    {
                        DialogBox(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_RDS_SETTINGS), hwnd, RDSSettingDlgProc);
                    }
                    else
                    {
                        IntCreateRDSWizard(hwnd);
                    }
                    break;
                }

		case ID_TOOLS_OPTIONS:
		{
			::LaunchConfCpl(hwnd, OPTIONS_DEFAULT_PAGE);
			break;
		}

		case ID_TOOLS_SENDVIDEO:
		{
			CVideoWindow *pVideo = GetLocalVideo();
			if (NULL != pVideo)
			{
				pVideo->Pause(!pVideo->IsPaused());
			}
			break;
		}
		
		case ID_TOOLS_RECEIVEVIDEO:
		{
			CVideoWindow *pVideo = GetRemoteVideo();
			if (NULL != pVideo)
			{
				pVideo->Pause(!pVideo->IsPaused());
			}
			break;
		}
		
		case ID_TOOLS_AUDIO_WIZARD:
		{
			CmdAudioCalibWizard(hwnd);
			break;
		}

		case IDM_FILE_HANGUP:
        case ID_TB_FILETRANSFER:
		case ID_TB_NEWWHITEBOARD:
		case ID_TB_WHITEBOARD:
		case ID_TB_CHAT:
        case ID_TB_SHARING:
		case ID_TB_NEW_CALL:
        case IDM_CALL_MEETINGSETTINGS:
			m_pConfRoom->OnCommand(hwnd, wCommand, NULL, 0);
            break;

		case IDM_VIDEO_ZOOM1:
		case IDM_VIDEO_ZOOM2:
		case IDM_VIDEO_ZOOM3:
		case IDM_VIDEO_ZOOM4:
		case IDM_VIDEO_UNDOCK:
		case IDM_VIDEO_GETACAMERA:
		case IDM_POPUP_EJECT:
		case IDM_POPUP_PROPERTIES:
		case IDM_POPUP_SPEEDDIAL:
		case IDM_POPUP_ADDRESSBOOK:
        case IDM_POPUP_GIVECONTROL:
        case IDM_POPUP_CANCELGIVECONTROL:
		case ID_FILE_CREATE_SPEED_DIAL:
		{
			if (NULL != m_pMainUI)
			{
				m_pMainUI->OnCommand(wCommand);
			}
			break;
		}

		default:
		{
			if ((wCommand >= ID_EXTENDED_TOOLS_ITEM) &&
				(wCommand <= ID_EXTENDED_TOOLS_ITEM + MAX_EXTENDED_TOOLS_ITEMS))
			{
				// The user clicked on a extensible tools menu item:
				OnExtToolsItem(wCommand);
				return;
			}
#ifdef DEBUG
			else if ((wCommand >= IDM_DEBUG_FIRST) &&
					(wCommand < IDM_DEBUG_LAST))
			{
				// The user clicked on a debug menu item:
				::OnDebugCommand(wCommand);
				return;
			}
#endif
			else
			{
				// The message was not handled:
				WARNING_OUT(("Command not handled [%08X]", wCommand));
				return;
			}
		}
	}
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: OnExtToolsItem(UINT uID)
*
*        PURPOSE:  Handles the action after a user selects an item from the
*                          extensible Tools menu.
*
****************************************************************************/

BOOL CTopWindow::OnExtToolsItem(UINT uID)
{
	HWND hwnd = GetWindow();

	DebugEntry(CConfRoom::OnExtToolsItem);
	
	BOOL bRet = FALSE;
	
	HMENU hMenuMain = GetMenu(hwnd);
	if (hMenuMain)
	{
		// Get the tools menu
		HMENU hMenuTools = GetSubMenu(hMenuMain, MENUPOS_TOOLS);
		if (hMenuTools)
		{
			MENUITEMINFO mmi;
			mmi.cbSize = sizeof(mmi);
			mmi.fMask = MIIM_DATA;
			if (GetMenuItemInfo(hMenuTools,
								uID,
								FALSE,
								&mmi))
			{
				TOOLSMENUSTRUCT* ptms = (TOOLSMENUSTRUCT*) mmi.dwItemData;
				ASSERT(NULL != ptms);
				TRACE_OUT(("Selected \"%s\" from Tools", ptms->szDisplayName));
				TRACE_OUT(("\tExeName: \"%s\"", ptms->szExeName));
				if ((HINSTANCE) 32 < ::ShellExecute(hwnd,
													NULL,
													ptms->szExeName,
													NULL,
													NULL,
													SW_SHOWDEFAULT))
				{
					bRet = TRUE;
				}
			}
		}
	}

	DebugExitBOOL(OnExtToolsItem, bRet);
	return bRet;
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: ResizeChildWindows()
*
*        PURPOSE:  Calculates the correct size of the child windows and resizes
*
****************************************************************************/

VOID CTopWindow::ResizeChildWindows(void)
{
	if (m_fMinimized)
		return;

	RECT rcl;
	GetClientRect(GetWindow(), &rcl);

	if (NULL != m_pStatusBar)
	{
		rcl.bottom -= m_pStatusBar->GetHeight();
	}

	if (NULL != m_pSeparator)
	{
		SIZE size;
		m_pSeparator->GetDesiredSize(&size);

		::SetWindowPos(m_pSeparator->GetWindow(), NULL,
						rcl.left, rcl.top, rcl.right-rcl.left, size.cy,
						SWP_NOACTIVATE | SWP_NOZORDER);

		rcl.top += size.cy;
	}

	if (NULL != m_pMainUI)
	{
		// Fill the window with the main UI
		::SetWindowPos(m_pMainUI->GetWindow(), NULL,
						rcl.left, rcl.top, rcl.right-rcl.left, rcl.bottom-rcl.top,
						SWP_NOACTIVATE | SWP_NOZORDER);
	}
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   OnMenuSelect(UINT, UINT, HMENU)
*
*        PURPOSE:  Called when passing over a menu item (to display status text)
*
****************************************************************************/

void CTopWindow::OnMenuSelect(HWND hwnd, HMENU hMenu, int uItem, UINT fuFlags)
{
	UINT uHelpID;
	TCHAR szHelpText[MAX_PATH];

	if (NULL == m_pStatusBar)
		return;

	if ((0xFFFF == LOWORD(fuFlags)) && (NULL == hMenu))
	{
		m_pStatusBar->RemoveHelpText();
		return;
	}

	if (!(MF_POPUP & fuFlags))
	{
		if (MF_SEPARATOR & fuFlags)
		{
			// show blank text in the status bar
			uHelpID = 0;
		}
		else if (MF_SYSMENU & fuFlags)
		{
			// An item from the system menu (these ID's map to our
			// string ID's directly)
			uHelpID = uItem;
		}
		else if ((uItem >= ID_EXTENDED_TOOLS_ITEM) &&
			(uItem <= ID_EXTENDED_TOOLS_ITEM + MAX_EXTENDED_TOOLS_ITEMS))
		{
			// BUGBUG georgep: No help for the extended tools items
			uHelpID = 0;
		}
#ifdef DEBUG
		else if ((uItem >= IDM_DEBUG) &&
				 (uItem <= IDM_DEBUG_LAST))
		{
			// debug only - don't complain
			uHelpID = 0;
		}
#endif
		else
		{
			uHelpID = MENU_ID_HELP_OFFSET + uItem;
		}
		
	}
	else
	{
		// This is a popup menu

		HMENU hMenuMain = ::GetMenu(GetWindow());
		if (hMenu == hMenuMain)
		{
#ifdef DEBUG
			if (uItem == (MENUPOS_HELP+1))
			{
				// This is a popup from the debug menu
				uHelpID = 0;
			}
			else
#endif
			{
				// This is a popup from the main window (i.e. Edit, View, etc.)
				uHelpID = MAIN_MENU_POPUP_HELP_OFFSET + uItem;
			}
		}
		else if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_TOOLS))
		{
			// This is a popup from the tools window (Video)
			uHelpID = TOOLS_MENU_POPUP_HELP_OFFSET + uItem;
		}
		else if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_HELP))
		{
			// This is a popup from the tools window (i.e. "Microsoft on the Web")
			uHelpID = HELP_MENU_POPUP_HELP_OFFSET + uItem;
		}

		// toolbar menu
		else if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_VIEW))
		{
				uHelpID = VIEW_MENU_POPUP_HELP_OFFSET + uItem;
		}
		// system menu
		else if (MF_SYSMENU & fuFlags)
		{
				uHelpID = IDS_SYSTEM_HELP;
		}
		else
		{
			// popup-menu that we haven't handled yet:
			// BUGBUG: this shouldn't be needed if we handle all pop-up menus!
			uHelpID = 0;
			WARNING_OUT(("Missing help text for popup menu"));
		}
	}


	if (0 == uHelpID)
	{
		// show blank text in the status bar
		szHelpText[0] = _T('\0');
	}
	else
	{
		int cch = ::LoadString(::GetInstanceHandle(), uHelpID,
			szHelpText, CCHMAX(szHelpText));
#ifdef DEBUG
		if (0 == cch)
		{
			wsprintf(szHelpText, TEXT("Missing help text for id=%d"), uHelpID);
			WARNING_OUT((szHelpText));
		}
#endif
	}

	m_pStatusBar->SetHelpText(szHelpText);
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   OnInitMenuPopup(HMENU)
*
*        PURPOSE:  Insures that menus are updated when they are selected
*
****************************************************************************/

void CTopWindow::OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
{
	if (fSystemMenu)
	{
		FORWARD_WM_INITMENUPOPUP(hwnd, hMenu, item, fSystemMenu, CFrame::ProcessMessage);
		return;
	}

	HMENU hMenuMain = ::GetMenu(GetWindow());
	if (hMenuMain)
	{
		// Check to see if we are on a dynamic menu:

		if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_CALL))
		{
			UpdateCallMenu(hMenu);
		}
		else if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_VIEW))
		{
			UpdateViewMenu(hMenu);
		}
		else if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_TOOLS))
		{
			UpdateToolsMenu(hMenu);
		}
		else if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_HELP))
		{
			UpdateHelpMenu(hMenu);
		}
	}
}


void CTopWindow::OnInitMenu(HWND hwnd, HMENU hMenu)
{
	if (NULL != m_pMainUI)
	{
		m_pMainUI->OnInitMenu(hMenu);
	}
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateCallAnim()
*
*        PURPOSE:  Handles the starting and stopping of the call progress anim
*
****************************************************************************/

VOID CTopWindow::UpdateCallAnim()
{


}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateStatusBar()
*
*        PURPOSE:  Updates the status bar object
*
****************************************************************************/

VOID CTopWindow::UpdateStatusBar()
{
	if (NULL != m_pStatusBar)
	{
		m_pStatusBar->Update();
	}
}


/*  C R E A T E  C H I L D  W I N D O W S  */
/*-------------------------------------------------------------------------
    %%Function: CreateChildWindows

    Creates all of the child windows and views
-------------------------------------------------------------------------*/
VOID CTopWindow::CreateChildWindows(void)
{
	DBGENTRY(CreateChildWindows);

    HRESULT hr = S_OK;

	RegEntry re(UI_KEY, HKEY_CURRENT_USER);
	
	HWND hwnd = GetWindow();

	ASSERT(NULL != hwnd);
	
	// get the size and position of the parent window
	RECT rcl;
	::GetClientRect(hwnd, &rcl);

	// Create the status bar:
	m_pStatusBar = new CConfStatusBar(m_pConfRoom);
	if (NULL != m_pStatusBar)
	{
		if (m_pStatusBar->Create(hwnd))
		{
			if (re.GetNumber(REGVAL_SHOW_STATUSBAR, DEFAULT_SHOW_STATUSBAR))
			{
				m_pStatusBar->Show(TRUE);
			}
		}
	}


	/*** Create the main views ***/

	m_pSeparator = new CSeparator();
	if (NULL != m_pSeparator)
	{
		m_pSeparator->Create(hwnd);
	}

	// Create the toolbar
	m_pMainUI = new CMainUI();
	if (NULL != m_pMainUI)
	{
		if (!m_pMainUI->Create(hwnd, m_pConfRoom))
		{
			ERROR_OUT(("ConfRoom creation of toolbar window failed!"));
		}
		else
		{
			int state = re.GetNumber(REGVAL_MP_WINDOW_STATE, DEFAULT_MP_WINDOW_STATE);

			switch (state & State_Mask)
			{
			case State_Normal:
				break;

			case State_Compact:
				m_pMainUI->SetCompact(TRUE);
				break;

			case State_DataOnly:
				m_pMainUI->SetDataOnly(TRUE);
				break;

			default:
				if (!FIsAVCapable())
				{
					// initialize the toolbar buttons:
					m_pMainUI->SetDataOnly(TRUE);
				}
				break;
			}

			if (0 != (state & SubState_PicInPic))
			{
				m_pMainUI->SetPicInPic(TRUE);
			}
			if (0 != (state & SubState_Dialpad))
			{
				m_pMainUI->SetDialing(TRUE);
			}
			if (0 != (state & SubState_OnTop))
			{
				SetOnTop(TRUE);
			}

			m_pMainUI->UpdateButtons();
		}
	}
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateCallMenu(HMENU hMenuCall)
*
*        PURPOSE:  Updates the call menu
*
****************************************************************************/

VOID CTopWindow::UpdateCallMenu(HMENU hMenuCall)
{
	if (NULL != hMenuCall)
	{
		{
			bool bEnabled = ConfPolicies::IsAutoAcceptCallsOptionEnabled();
			bool bChecked = ConfPolicies::IsAutoAcceptCallsEnabled();
			EnableMenuItem(hMenuCall, ID_AUTOACCEPT, MF_BYCOMMAND | (bEnabled ? MF_ENABLED : MF_GRAYED));
			CheckMenuItem (hMenuCall, ID_AUTOACCEPT, MF_BYCOMMAND | (bChecked ? MF_CHECKED : MF_UNCHECKED));
		}

		TCHAR szMenu[ MAX_PATH * 2 ];

		if( ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_GateKeeper )
		{
			//	This means that we are in gatekeeper mode...

			RegEntry	reConf( CONFERENCING_KEY, HKEY_CURRENT_USER );

			FLoadString1( IsGatekeeperLoggedOn()? IDS_LOGOFF_ULS: IDS_LOGON_ULS, szMenu, reConf.GetString( REGVAL_GK_SERVER ) );

			::ModifyMenu( hMenuCall, IDM_FILE_LOGON_ULS, MF_BYCOMMAND | MF_STRING, IDM_FILE_LOGON_ULS, szMenu );
		}
		else
		{
			const TCHAR * const	defaultServer	= CDirectoryManager::get_displayName( CDirectoryManager::get_defaultServer() );

			bool	bMenuItemShouldSayLogon	= ((NULL == g_pLDAP) || !(g_pLDAP->IsLoggedOn() || g_pLDAP ->IsLoggingOn()));

			FLoadString1( bMenuItemShouldSayLogon? IDS_LOGON_ULS: IDS_LOGOFF_ULS, szMenu, (void *) defaultServer );

			::ModifyMenu( hMenuCall, IDM_FILE_LOGON_ULS, MF_BYCOMMAND | MF_STRING, IDM_FILE_LOGON_ULS, szMenu );
			::EnableMenuItem( hMenuCall, IDM_FILE_LOGON_ULS, SysPol::AllowDirectoryServices()? MF_ENABLED: MF_GRAYED );
		}

		// Set the state of the hangup item:
		::EnableMenuItem(       hMenuCall,
							IDM_FILE_HANGUP,
							FIsConferenceActive() ? MF_ENABLED : MF_GRAYED);
		
		// Only enable the host conference item if we're not in a call:
		::EnableMenuItem(       hMenuCall,
							ID_FILE_CONF_HOST,
							(FIsConferenceActive() ||
							FIsCallInProgress()) ? MF_GRAYED : MF_ENABLED);

        //
        // Only enable the meeting settings item if we're in a call and there
        // are settings.
        //
        ::EnableMenuItem(hMenuCall,
            IDM_CALL_MEETINGSETTINGS,
            MF_BYCOMMAND |
            ((FIsConferenceActive() && (m_pConfRoom->GetMeetingSettings() != NM_PERMIT_ALL)) ?
                MF_ENABLED : MF_GRAYED));


        // Only enable the New Call menu item if permitted by settings
        ::EnableMenuItem(hMenuCall,
                         ID_TB_NEW_CALL,
                         MF_BYCOMMAND|MenuState(m_pConfRoom->IsNewCallAllowed()));

		// Check the "Do Not Disturb" menu item:
		::CheckMenuItem(hMenuCall,
						ID_FILE_DO_NOT_DISTURB,
						::FDoNotDisturb() ? MF_CHECKED : MF_UNCHECKED);

                RegEntry reLM(REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
                BOOL fActivated = reLM.GetNumber(REMOTE_REG_ACTIVATESERVICE, DEFAULT_REMOTE_ACTIVATESERVICE);
                BOOL fEnabled = reLM.GetNumber(REMOTE_REG_RUNSERVICE,DEFAULT_REMOTE_RUNSERVICE);
                if (fEnabled && !fActivated && !m_fExitAndActivateRDSMenuItem)
                {
                    TCHAR szExitAndActivateRDSMenuItem[MAX_PATH];
                    MENUITEMINFO mmi;

                    int cchExitAndActivateRDSMenuItem = ::LoadString(GetInstanceHandle(),
                                                                   ID_FILE_EXIT_ACTIVATERDS,
                                                                   szExitAndActivateRDSMenuItem,
                                                                   CCHMAX(szExitAndActivateRDSMenuItem));

                    if (0 == cchExitAndActivateRDSMenuItem)
                    {
                        ERROR_OUT(("LoadString(%d) failed", (int) ID_FILE_EXIT_ACTIVATERDS));
                    }
                    else
                    {
                        //ZeroMemory((PVOID) &mmi, sizeof(mmi));
                        mmi.cbSize = sizeof(mmi);
                        mmi.fMask = MIIM_STATE | MIIM_ID | MIIM_TYPE;
                        mmi.fState = MFS_ENABLED;
                        mmi.wID = ID_FILE_EXIT_ACTIVATERDS;
                        mmi.fType = MFT_STRING;
                        mmi.dwTypeData = szExitAndActivateRDSMenuItem;
                        mmi.cch = cchExitAndActivateRDSMenuItem;

                        if (InsertMenuItem(hMenuCall,-1,FALSE,&mmi))
                        {
                            m_fExitAndActivateRDSMenuItem = TRUE;
                        }
                        else
                        {
                            ERROR_OUT(("InsertMenuItem() failed, rc=%lu", (ULONG) GetLastError()));
                        }
                    }
                }
                else if (m_fExitAndActivateRDSMenuItem && (fActivated || !fEnabled))
                {
                    if (DeleteMenu(hMenuCall,ID_FILE_EXIT_ACTIVATERDS,MF_BYCOMMAND))
                    {
                        m_fExitAndActivateRDSMenuItem = FALSE;
                    }
                    else
                    {
                        ERROR_OUT(("DeleteMenu() failed, rc=%lu", (ULONG) GetLastError()));
                    }
                }

	}
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateHelpMenu(HMENU hMenuHelp)
*
*        PURPOSE:  Updates the help menu
*
****************************************************************************/

VOID CTopWindow::UpdateHelpMenu(HMENU hMenuHelp)
{
	if (NULL != hMenuHelp)
	{
		// Enable/disable web items
		UINT uEnable = ::CanShellExecHttp() ? MF_ENABLED : MF_GRAYED;
		::EnableMenuItem(hMenuHelp, IDM_FILE_LAUNCH_WEB_PAGE, uEnable);
		::EnableMenuItem(hMenuHelp, ID_HELP_WEB_FREE,     uEnable);
		::EnableMenuItem(hMenuHelp, ID_HELP_WEB_NEWS,     uEnable);
		::EnableMenuItem(hMenuHelp, ID_HELP_WEB_FAQ,      uEnable);
		::EnableMenuItem(hMenuHelp, ID_HELP_WEB_FEEDBACK, uEnable);
		::EnableMenuItem(hMenuHelp, ID_HELP_WEB_MSHOME,   uEnable);
		::EnableMenuItem(hMenuHelp, ID_HELP_WEB_SUPPORT,  uEnable);
	}
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateViewMenu(HMENU hMenuView)
*
*        PURPOSE:  Updates the view menu by placing a bullet next to the
*                          current view and a check mark next to the toolbar and
*                          status bar items
*
****************************************************************************/

VOID CTopWindow::UpdateViewMenu(HMENU hMenuView)
{
	if (NULL == hMenuView)
		return;

	CheckMenu_ViewStatusBar(hMenuView);

	CMainUI *pMainUI = GetMainUI();
	BOOL bChecked;
	BOOL bEnable;

	bChecked = (NULL != pMainUI && pMainUI->IsCompact());
	CheckMenuItem(hMenuView, IDM_VIEW_COMPACT,
		MF_BYCOMMAND|(bChecked ? MF_CHECKED : MF_UNCHECKED));
	bEnable = FIsAVCapable();
	EnableMenuItem(hMenuView, IDM_VIEW_COMPACT,
		MF_BYCOMMAND|(bEnable ? MF_ENABLED : MF_GRAYED|MF_DISABLED));


	bChecked = (NULL != pMainUI && pMainUI->IsDataOnly());
	CheckMenuItem(hMenuView, IDM_VIEW_DATAONLY,
		MF_BYCOMMAND|(bChecked ? MF_CHECKED : MF_UNCHECKED));
	bEnable = FIsAVCapable();
	EnableMenuItem(hMenuView, IDM_VIEW_DATAONLY,
		MF_BYCOMMAND|(bEnable ? MF_ENABLED : MF_GRAYED|MF_DISABLED));

	bChecked = (NULL != pMainUI && pMainUI->IsDialing());
	CheckMenuItem(hMenuView, IDM_VIEW_DIALPAD,
		MF_BYCOMMAND|(bChecked ? MF_CHECKED : MF_UNCHECKED));
	bEnable = (NULL != pMainUI && pMainUI->IsDialingAllowed());
	bEnable = bEnable && FIsAVCapable();
	EnableMenuItem(hMenuView, IDM_VIEW_DIALPAD,
		MF_BYCOMMAND|(bEnable ? MF_ENABLED : MF_GRAYED|MF_DISABLED));

	bChecked = (NULL != pMainUI && pMainUI->IsPicInPic());
	CheckMenuItem(hMenuView, ID_TB_PICINPIC,
		MF_BYCOMMAND|(bChecked ? MF_CHECKED : MF_UNCHECKED));
	bEnable = (NULL != pMainUI && pMainUI->IsPicInPicAllowed());
	EnableMenuItem(hMenuView, ID_TB_PICINPIC,
		MF_BYCOMMAND|(bEnable ? MF_ENABLED : MF_GRAYED|MF_DISABLED));

	bChecked = IsOnTop();
	CheckMenuItem(hMenuView, IDM_VIEW_ONTOP,
		MF_BYCOMMAND|(bChecked ? MF_CHECKED : MF_UNCHECKED));
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateToolsMenu(HMENU hMenuTools)
*
*        PURPOSE:  Updates the tools menu
*
****************************************************************************/

VOID CTopWindow::UpdateToolsMenu(HMENU hMenuTools)
{
    if (NULL != hMenuTools)
    {
        bool    fRDSDisabled = ConfPolicies::IsRDSDisabled();

		EnableMenuItem(hMenuTools, ID_TOOLS_AUDIO_WIZARD,
			FEnableAudioWizard() ? MF_ENABLED : MF_GRAYED);

		EnableMenuItem(hMenuTools, ID_TB_SHARING,
			MF_BYCOMMAND|MenuState(m_pConfRoom->IsSharingAllowed()));
        //
        // No app sharing, no RDS.
        //
        if (!m_pConfRoom->FIsSharingAvailable())
        {
            fRDSDisabled = TRUE;
        }

        // If this is NT, we need to handle adding or removing the menu item
        // to enable the display driver for application sharing.  We add the
        // menu item (immediately above the "Options" item) if the display
        // driver is not enabled and the item hasn't been added already.  We
        // remove the menu item if it's there and the display driver is
        // enabled, which should only happen if the user enabled it and then
        // choose to ignore the reboot prompt.
        if (::IsWindowsNT())
        {
            if (!g_fNTDisplayDriverEnabled && !m_fEnableAppSharingMenuItem)
            {
                // Add the menu item

                TCHAR szEnableAppSharingMenuItem[MAX_PATH];
                MENUITEMINFO mmi;

                int cchEnableAppSharingMenuItem =
                    ::LoadString(
                        GetInstanceHandle(),
                        ID_TOOLS_ENABLEAPPSHARING,
                        szEnableAppSharingMenuItem,
                        CCHMAX(szEnableAppSharingMenuItem));

                if (0 == cchEnableAppSharingMenuItem)
                {
                    ERROR_OUT(("LoadString(%d) failed", (int) ID_TOOLS_ENABLEAPPSHARING));
                }
                else
                {
                    //ZeroMemory((PVOID) &mmi, sizeof(mmi));
                    mmi.cbSize = sizeof(mmi);
                    mmi.fMask = MIIM_STATE | MIIM_ID | MIIM_TYPE;
                    mmi.fState = MFS_ENABLED;
                    mmi.wID = ID_TOOLS_ENABLEAPPSHARING;
                    mmi.fType = MFT_STRING;
                    mmi.dwTypeData = szEnableAppSharingMenuItem;
                    mmi.cch = cchEnableAppSharingMenuItem;

                    if (InsertMenuItem(
                        hMenuTools,
                        ID_TOOLS_OPTIONS,
                        FALSE,
                        &mmi))
                    {
                        m_fEnableAppSharingMenuItem = TRUE;
                    }
                    else
                    {
                        ERROR_OUT(("InsertMenuItem() failed, rc=%lu", (ULONG) GetLastError()));
                    }
                }
            }
            else if (m_fEnableAppSharingMenuItem && g_fNTDisplayDriverEnabled)
            {
                // Remove the menu item
                if (DeleteMenu(
                    hMenuTools,
                    ID_TOOLS_ENABLEAPPSHARING,
                    MF_BYCOMMAND))
                {
                    m_fEnableAppSharingMenuItem = FALSE;
                }
                else
                {
                    ERROR_OUT(("DeleteMenu() failed, rc=%lu", (ULONG) GetLastError()));
                }
            }
            if (m_fEnableAppSharingMenuItem)
                fRDSDisabled = TRUE;
        }
        else
        {
            // Windows 9.x;
            if (ConfPolicies::IsRDSDisabledOnWin9x())
            {
                fRDSDisabled = TRUE;
            }
        }

        EnableMenuItem(hMenuTools, ID_TOOLS_RDSWIZARD, MF_BYCOMMAND |
                       (fRDSDisabled ? MF_GRAYED : MF_ENABLED));

        //
        // LAURABU BOGUS:
        // Make installable tools a popup from Tools submenu, don't put these
        // flat!
        //
        CleanTools(hMenuTools, m_ExtToolsList);
        if (m_pConfRoom->GetMeetingPermissions() & NM_PERMIT_STARTOTHERTOOLS)
        {
            FillInTools(hMenuTools, 0, TOOLS_MENU_KEY, m_ExtToolsList);
        }

        BOOL fEnableSend = FALSE;
        BOOL fSending = FALSE;
        CVideoWindow *pLocal  = GetLocalVideo();
        if (NULL != pLocal)
        {
            fEnableSend = pLocal->IsXferAllowed() &&
                ((m_pConfRoom->GetMeetingPermissions() & NM_PERMIT_SENDVIDEO) != 0);
            fSending = fEnableSend &&
                !pLocal->IsPaused();
        }

        BOOL fEnableReceive = FALSE;
        BOOL fReceiving = FALSE;
        CVideoWindow *pRemote = GetRemoteVideo();
        if (NULL != pRemote)
        {
            fEnableReceive = pRemote->IsConnected();
            fReceiving = fEnableReceive &&
                !pRemote->IsPaused();
        }

        EnableMenuItem( hMenuTools,
                        MENUPOS_TOOLS_VIDEO,
                        (MF_BYPOSITION |
                         ((fEnableSend || fEnableReceive) ? MF_ENABLED : MF_GRAYED)));

        EnableMenuItem( hMenuTools,
                        ID_TOOLS_SENDVIDEO,
                        fEnableSend ? MF_ENABLED : MF_GRAYED);

        CheckMenuItem(  hMenuTools,
                        ID_TOOLS_SENDVIDEO,
                        fSending ? MF_CHECKED : MF_UNCHECKED);

        EnableMenuItem( hMenuTools,
                        ID_TOOLS_RECEIVEVIDEO,
                        fEnableReceive ? MF_ENABLED : MF_GRAYED);

        CheckMenuItem(  hMenuTools,
                        ID_TOOLS_RECEIVEVIDEO,
                        fReceiving ? MF_CHECKED : MF_UNCHECKED);

		EnableMenuItem(hMenuTools, ID_TOOLS_OPTIONS,
			MF_BYCOMMAND|MenuState(CanLaunchConfCpl()));

        //
        // OTHER TOOLS
        //
		EnableMenuItem(hMenuTools, ID_TB_NEWWHITEBOARD,
			MF_BYCOMMAND|MenuState(m_pConfRoom->IsNewWhiteboardAllowed()));
		EnableMenuItem(hMenuTools, ID_TB_WHITEBOARD,
			MF_BYCOMMAND|MenuState(m_pConfRoom->IsOldWhiteboardAllowed()));
		EnableMenuItem(hMenuTools, ID_TB_CHAT,
			MF_BYCOMMAND|MenuState(m_pConfRoom->IsChatAllowed()));
		EnableMenuItem(hMenuTools, ID_TB_FILETRANSFER,
			MF_BYCOMMAND|MenuState(m_pConfRoom->IsFileTransferAllowed()));
    }
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   SelAndRealizePalette()
*
*        PURPOSE:  Selects and realizes the NetMeeting palette
*
****************************************************************************/

BOOL CTopWindow::SelAndRealizePalette()
{
	BOOL bRet = FALSE;

	HPALETTE hPal = m_pConfRoom->GetPalette();
	if (NULL == hPal)
	{
		return(bRet);
	}

	HWND hwnd = GetWindow();

	HDC hdc = ::GetDC(hwnd);
	if (NULL != hdc)
	{
		::SelectPalette(hdc, hPal, FALSE);
		bRet = (GDI_ERROR != ::RealizePalette(hdc));

		::ReleaseDC(hwnd, hdc);
	}

	return bRet;
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   InitMenuFont()
*
*        PURPOSE:  Initializes/Updates the menu font member
*
****************************************************************************/

VOID CTopWindow::InitMenuFont()
{
	DebugEntry(CConfRoom::InitMenuFont);
	if (NULL != m_hFontMenu)
	{
		::DeleteObject(m_hFontMenu);
	}
	NONCLIENTMETRICS ncm;
	ncm.cbSize = sizeof(ncm);
	if (::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE))
	{
		m_hFontMenu = ::CreateFontIndirect(&(ncm.lfMenuFont));
		ASSERT(m_hFontMenu);
	}
	DebugExitVOID(CConfRoom::InitMenuFont);
}

CVideoWindow* CTopWindow::GetLocalVideo()
{
	CMainUI *pMainUI = GetMainUI();
	return (pMainUI ? pMainUI->GetLocalVideo() : NULL);
}

CVideoWindow* CTopWindow::GetRemoteVideo()
{
	CMainUI *pMainUI = GetMainUI();
	return (pMainUI ? pMainUI->GetRemoteVideo() : NULL);
}

BOOL CTopWindow::IsOnTop()
{
	return((GetWindowLong(GetWindow(), GWL_EXSTYLE)&WS_EX_TOPMOST) == WS_EX_TOPMOST);
}

void CTopWindow::SetOnTop(BOOL bOnTop)
{
	bOnTop = (bOnTop != FALSE);

	if (IsOnTop() == bOnTop)
	{
		// Nothing to do
		return;
	}

	SetWindowPos(GetWindow(), bOnTop ? HWND_TOPMOST : HWND_NOTOPMOST,
		0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);
}

HPALETTE CTopWindow::GetPalette()
{
	return(m_pConfRoom->GetPalette());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\taskbar.cpp ===
// File: taskbar.cpp

#include "precomp.h"
#include "resource.h"
#include "confroom.h"      // for CreateConfRoom
#include "cmd.h"
#include "conf.h"
#include "taskbar.h"
#include "confwnd.h"

BOOL AddTaskbarIcon(HWND hwnd)
{
	BOOL bRet = FALSE;
	
	RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);
	if (TASKBARICON_ALWAYS == re.GetNumber(REGVAL_TASKBAR_ICON, TASKBARICON_DEFAULT))
	{
		// Place a 16x16 icon in the taskbar notification area:	
		NOTIFYICONDATA tnid;

		tnid.cbSize = sizeof(NOTIFYICONDATA);
		tnid.hWnd = hwnd;
		tnid.uID = ID_TASKBAR_ICON;
		tnid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
		tnid.uCallbackMessage = WM_TASKBAR_NOTIFY;
		tnid.hIcon = LoadIcon(::GetInstanceHandle(), MAKEINTRESOURCE(IDI_SM_WORLD));

		::LoadString(::GetInstanceHandle(), IDS_MEDIAPHONE_TITLE,
			tnid.szTip, CCHMAX(tnid.szTip));

		if (FALSE == (bRet = Shell_NotifyIcon(NIM_ADD, &tnid)))
		{
				// We could just be re-adding the icon...
			if(GetLastError() != 0)
			{
				// ISSUE: How do we want to handle this error?
				ERROR_OUT(("Could not add notify icon!"));
			}
		}
		else
		{
			::RefreshTaskbarIcon(::GetHiddenWindow());
		}

		if (NULL != tnid.hIcon)
		{
			DestroyIcon(tnid.hIcon);
		}
	}
	
	return bRet;
}

BOOL RefreshTaskbarIcon(HWND hwnd)
{
	BOOL bRet = FALSE;
	
	RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);
	if (TASKBARICON_ALWAYS == re.GetNumber(REGVAL_TASKBAR_ICON, TASKBARICON_DEFAULT))
	{
		UINT uIconId = FDoNotDisturb() ? IDI_DO_NOT_DISTURB : IDI_SM_WORLD;

		NOTIFYICONDATA tnid;

		tnid.cbSize = sizeof(NOTIFYICONDATA);
		tnid.hWnd = hwnd;
		tnid.uID = ID_TASKBAR_ICON;
		tnid.uFlags = NIF_ICON;
		tnid.hIcon = LoadIcon(::GetInstanceHandle(), MAKEINTRESOURCE(uIconId));

		if (FALSE == (bRet = Shell_NotifyIcon(NIM_MODIFY, &tnid)))
		{
				// ISSUE: How do we want to handle this error?
			ERROR_OUT(("Could not change notify icon!"));
		}

		if (NULL != tnid.hIcon)
		{
			DestroyIcon(tnid.hIcon);
		}
	}

	return bRet;
}

BOOL RemoveTaskbarIcon(HWND hwnd)
{
	NOTIFYICONDATA tnid;

	tnid.cbSize = sizeof(NOTIFYICONDATA);
	tnid.hWnd = hwnd;
	tnid.uID = ID_TASKBAR_ICON;

	return Shell_NotifyIcon(NIM_DELETE, &tnid);
}		

BOOL OnRightClickTaskbar()
{
	TRACE_OUT(("OnRightClickTaskbar called"));

	POINT ptClick;
	if (FALSE == ::GetCursorPos(&ptClick))
	{
		ptClick.x = ptClick.y = 0;
	}
	
	// Get the menu for the popup from the resource file.
	HMENU hMenu = ::LoadMenu(GetInstanceHandle(), MAKEINTRESOURCE(IDR_TASKBAR_POPUP));
	if (NULL == hMenu)
	{
		return FALSE;
	}

	// Get the first menu in it which we will use for the call to
	// TrackPopup(). This could also have been created on the fly using
	// CreatePopupMenu and then we could have used InsertMenu() or
	// AppendMenu.
	HMENU hMenuTrackPopup = ::GetSubMenu(hMenu, 0);

	// Bold the Open menuitem.
	//
	MENUITEMINFO iInfo;

	iInfo.cbSize = sizeof(iInfo);
	iInfo.fMask = MIIM_STATE;
	if(::GetMenuItemInfo(hMenu, IDM_TBPOPUP_OPEN, FALSE, &iInfo))
	{
		iInfo.fState |= MFS_DEFAULT;
		::SetMenuItemInfo(hMenu, IDM_TBPOPUP_OPEN, FALSE , &iInfo);
	}

	if (0 != _Module.GetLockCount())
	{
		// Can't stop while an SDK app in charge...
		if(::GetMenuItemInfo(hMenu, IDM_TBPOPUP_STOP, FALSE, &iInfo))
		{
			iInfo.fState |= MFS_GRAYED | MFS_DISABLED;
			::SetMenuItemInfo(hMenu, IDM_TBPOPUP_STOP, FALSE , &iInfo);
		}
	}

	// Draw and track the "floating" popup 

	// According to the font view code, there is a bug in USER which causes
	// TrackPopupMenu to work incorrectly when the window doesn't have the
	// focus.  The work-around is to temporarily create a hidden window and
	// make it the foreground and focus window.

	HWND hwndDummy = ::CreateWindow(_TEXT("STATIC"), NULL, 0, 
									ptClick.x, 
									ptClick.y,
									1, 1, HWND_DESKTOP,
									NULL, _Module.GetModuleInstance(), NULL);
	if (NULL != hwndDummy)
	{
		HWND hwndPrev = ::GetForegroundWindow();	// to restore

		TPMPARAMS tpmp;
		tpmp.cbSize = sizeof(tpmp);
		tpmp.rcExclude.right = 1 + (tpmp.rcExclude.left = ptClick.x);
		tpmp.rcExclude.bottom = 1 + (tpmp.rcExclude.top = ptClick.y);
		
		::SetForegroundWindow(hwndDummy);
		::SetFocus(hwndDummy);

		int iRet = ::TrackPopupMenuEx(	hMenuTrackPopup, 
									TPM_RETURNCMD | TPM_HORIZONTAL | TPM_RIGHTALIGN | 
										TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
									ptClick.x, 
									ptClick.y,
									hwndDummy, 
									&tpmp);

		// Restore the previous foreground window (before destroying hwndDummy).
		if (hwndPrev)
		{
			::SetForegroundWindow(hwndPrev);
		}

		::DestroyWindow(hwndDummy);

		switch (iRet)
		{
			case IDM_TBPOPUP_OPEN:
			{
				::CreateConfRoomWindow();
				break;
			}
			case IDM_TBPOPUP_STOP:
			{
				::CmdShutdown();
				break;
			}
		}
	}
	
	// We are finished with the menu now, so destroy it
	::DestroyMenu(hMenuTrackPopup);
	::DestroyMenu(hMenu);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\topwindow.h ===
// File: confroom.h

#ifndef _TOPWINDOW_H_
#define _TOPWINDOW_H_

#include "GenWindow.h"
#include "GenContainers.h"
#include "ConfUtil.h"

class CConfRoom;
class CConfStatusBar;
class CMainUI;
class CSeparator;
class CVideoWindow;

struct IComponentWnd;
struct IAppSharing;
struct MYOWNERDRAWSTRUCT;
struct TOOLSMENUSTRUCT;

class CTopWindow : public CFrame
{
public:
	CTopWindow();

	// IGenWindow stuff
	virtual void GetDesiredSize(SIZE *ppt);
	virtual HPALETTE GetPalette();

	BOOL		FIsClosing() { return m_fClosing; }

	BOOL		Create(CConfRoom *pConfRoom, BOOL fShowUI);

	VOID        SaveSettings();
	BOOL		BringToFront();
	VOID		UpdateUI(DWORD dwUIMask);
	VOID		ForceWindowResize();
    void        OnReleaseCamera();

	CVideoWindow*	GetLocalVideo();
	CVideoWindow*	GetRemoteVideo();

protected:
	~CTopWindow();

	LRESULT		ProcessMessage(		HWND hWnd,
									UINT message,
									WPARAM wParam,
									LPARAM lParam);

private:
	enum WindowState
	{
		State_Default = 0,
		State_Normal,
		State_Compact,
		State_DataOnly,
		State_Mask = 0x00ff
	} ;

	enum WindowSubStates
	{
		SubState_OnTop		= 0x2000,
		SubState_Dialpad	= 0x4000,
		SubState_PicInPic	= 0x8000,
	} ;

    HFONT               m_hFontMenu;
	CTranslateAccelTable * m_pAccel;
	CConfRoom *			m_pConfRoom;
	CSeparator *        m_pSeparator;
	CMainUI *           m_pMainUI;
	CConfStatusBar *    m_pStatusBar;
	POINT				m_ptTaskbarClickPos;
	HWND				m_hwndPrevFocus;
	HCURSOR				m_hWaitCursor;
	CSimpleArray<TOOLSMENUSTRUCT*>		m_ExtToolsList;

	BOOL				m_fTaskbarDblClick : 1;
	BOOL				m_fMinimized : 1;
	BOOL				m_fClosing : 1;  // set when closing the NM UI
	BOOL				m_fEnableAppSharingMenuItem : 1;
        BOOL                            m_fExitAndActivateRDSMenuItem : 1;
		BOOL				m_fStateChanged : 1;

	BOOL		IsOnTop();
	void		SetOnTop(BOOL bOnTop);

	VOID        CreateChildWindows(void);

	void		OnInitMenu(HWND hwnd, HMENU hMenu);
	void		OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu);
	void		OnMenuSelect(HWND hwnd, HMENU hMenu, int uItem, UINT fuFlags);
    void        OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT * lpmis);
    void        OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpdis);
	void		OnCommand(HWND hwnd, int wCommand, HWND hwndCtl, UINT codeNotify);
	void		OnClose(HWND hwnd, LPARAM lParam);

	BOOL        SelAndRealizePalette();
    VOID        InitMenuFont();
	VOID        ResizeChildWindows(void);
	BOOL		UpdateWindowTitle();
	VOID		UpdateStatusBar();
	VOID        UpdateCallAnim();

	VOID        UpdateCallMenu(HMENU hMenu);
	VOID        UpdateViewMenu(HMENU hMenu);
	VOID        UpdateToolsMenu(HMENU hMenu);
	VOID        UpdateHelpMenu(HMENU hMenu);

	VOID		ShowUI(void);
    VOID        TerminateAppSharing(void);
	VOID        CloseChildWindows(void);
	BOOL		OnExtToolsItem(UINT uID);

	CMainUI *		GetMainUI()					{ return m_pMainUI;			}
};

#endif // _TOPWINDOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\ulscpl.cpp ===
/****************************************************************************
*
*	 FILE:	   UlsCpl.cpp
*
*	 CREATED:  Claus Giloi (ClausGi) 4-18-96
*
*	 CONTENTS: ULS-related control panel control data exchange functions
*
****************************************************************************/

#include "precomp.h"

#include "help_ids.h"
#include "ulswizrd.h"
#include "confcpl.h"
#include "NmLdap.h"
#include "call.h"
#include "statbar.h"
#include "confpolicies.h"
#include "conf.h"
#include "callto.h"


// Globals
static CULSWizard* s_pUlsWizard = NULL;

static ULS_CONF g_Old_ulsC;
static BOOL g_fOld_ulsC_saved = FALSE;

static bool s_fOldUseUlsServer;
static bool s_fOldTaskbarSetting;
static bool s_fOldAlwaysRunning;

static HWND s_hDlgUserInfo = NULL;


static DWORD	aUserHelpIds[]	=
{
	//	User information settings...
	IDC_MYINFO_GROUP,				IDH_MYINFO_MYINFO,
	IDG_DIRECTMODE,					IDH_MYINFO_MYINFO,
	IDC_STATIC_MYINFO,				IDH_MYINFO_MYINFO,
	IDC_USER_NAME,					IDH_MYINFO_FIRSTNAME,
	IDC_USER_LASTNAME,				IDH_MYINFO_LASTNAME,
	IDC_USER_EMAIL, 				IDH_MYINFO_EMAIL,
	IDC_USER_LOCATION,				IDH_MYINFO_LOCATION,
	IDC_USER_INTERESTS, 			IDH_MYINFO_COMMENTS,

	//	ILS settings...
	IDC_USER_PUBLISH,				IDH_MYINFO_PUBLISH,
	IDC_USEULS,						IDH_MYINFO_DIRECTORY_AT_START,
	IDC_NAMESERVER,					IDH_MYINFO_ULS_SERVER,
	IDC_STATIC_SERVER_NAME,			IDH_MYINFO_ULS_SERVER,

	// General stuff
	IDC_SHOWONTASKBAR,				IDH_GENERAL_SHOW_ON_TASKBAR,
	IDC_BANDWIDTH,					IDH_CALLING_BANDWIDTH,
	IDC_ADVANCED_CALL_OPTS,			IDH_CALLING_ADVANCED,

	//	NULL terminator...
	0,								0
};


static const DWORD	_rgHelpIdsCalling[]	=
{
	//	GateKeeper settings...
	IDC_CALLOPT_GK_USE,				IDH_SERVERS_USE_GATEKEEPER,
	IDG_GKMODE,						IDH_GENERAL_GENERAL,
	IDE_CALLOPT_GK_SERVER,			IDH_SERVERS_GATEKEEPER_NAME,
	IDC_STATIC_GATEKEEPER_NAME,		IDH_SERVERS_GATEKEEPER_NAME,
	IDC_CHECK_USE_ACCOUNT,			IDH_ADVCALL_USE_ACCOUNT,
	IDS_STATIC_ACCOUNT,				IDH_ADVCALL_ACCOUNT_NO,
	IDE_CALLOPT_GK_ACCOUNT,			IDH_ADVCALL_ACCOUNT_NO,
	IDC_CHECK_USE_PHONE_NUMBERS,	IDH_SERVERS_GATEKEEPER_PHONENO,
	IDC_STATIC_PHONE_NUMBER,		IDH_MYINFO_PHONE,
	IDE_CALLOPT_GK_PHONE_NUMBER,	IDH_MYINFO_PHONE,

	//	Direct proxy settings...
	IDG_DIRECTMODE,					IDH_GENERAL_GENERAL,
	IDC_CHECK_USE_PROXY,			IDH_ADVCALL_USE_PROXY,
	IDC_STATIC_PROXY_NAME,			IDH_ADVCALL_PROXY_NAME,
	IDE_CALLOPT_PROXY_SERVER,		IDH_ADVCALL_PROXY_NAME,

	//	Direct gateway settings...
	IDC_CHECK_USE_GATEWAY,			IDH_AUDIO_USEGATEWAY,
	IDC_STATIC_GATEWAY_NAME,		IDH_AUDIO_H323_GATEWAY,
	IDE_CALLOPT_GW_SERVER,			IDH_AUDIO_H323_GATEWAY,

	//	NULL terminator...
	0,								0
};

VOID FixServerDropList(HWND hdlg, int id, LPTSTR pszServer, UINT cchMax);
static void _SetLogOntoIlsButton( HWND hDlg, bool bLogOntoIlsWhenNmStarts );
void InitGWInfo( HWND hDlg, CULSWizard* pWiz, bool& rbOldEnableGateway, LPTSTR szOldServerNameBuf, UINT cch );
void InitProxyInfo( HWND hDlg, CULSWizard* pWiz, bool& rbOldEnableProxy, LPTSTR szOldServerNameBuf, UINT cch );

// Functions

inline bool FIsDlgButtonChecked(HWND hDlg, int nIDButton)
{
	return ( BST_CHECKED == IsDlgButtonChecked(hDlg, nIDButton) );
}


static BOOL InitULSDll ( VOID )
{
	delete s_pUlsWizard;
	return (NULL != (s_pUlsWizard = new CULSWizard()));
}

static BOOL DeInitULSDll ( VOID )
{
	if( s_pUlsWizard )
	{
		delete s_pUlsWizard;
		s_pUlsWizard = NULL;
	}
	return TRUE;
}


// implemented in wizard.cpp
extern UINT GetBandwidth();
extern void SetBandwidth(UINT uBandwidth);

// implemented in audiocpl.cpp
extern VOID UpdateCodecSettings(UINT uBandWidth);



static HRESULT InitULSControls(HWND hDlg, CULSWizard* pWiz,
						UINT ideditServerName,
						UINT ideditFirstName,
						UINT ideditLastName,
						UINT ideditEmailName,
						UINT ideditLocation,
						UINT ideditInterests,
						UINT idbtnDontPublish )
{

	HRESULT hr = (pWiz == NULL) ? E_NOINTERFACE : S_OK;

	if (SUCCEEDED(hr))
	{
		// Build up the flags for the getconfiguration call
		ULS_CONF ulsC;
		ClearStruct(&ulsC);

		if ( ideditServerName )
			ulsC.dwFlags |= ULSCONF_F_SERVER_NAME;

		if ( ideditFirstName )
			ulsC.dwFlags |= ULSCONF_F_FIRST_NAME;

		if ( ideditLastName )
			ulsC.dwFlags |= ULSCONF_F_LAST_NAME;

		if ( ideditEmailName )
			ulsC.dwFlags |= ULSCONF_F_EMAIL_NAME;

		if ( ideditLocation )
			ulsC.dwFlags |= ULSCONF_F_LOCATION;

		if ( ideditInterests )
			ulsC.dwFlags |= ULSCONF_F_COMMENTS;

		if ( idbtnDontPublish )
			ulsC.dwFlags |= ULSCONF_F_PUBLISH;

		// Get the current data
		hr = s_pUlsWizard->GetConfig(&ulsC);

		if (SUCCEEDED(hr))
		{
			// Save a copy of the struct to detect changes later
			g_Old_ulsC = ulsC;
			g_fOld_ulsC_saved = TRUE;

			if ( ideditFirstName )
				SetDlgItemText ( hDlg, ideditFirstName, ulsC.szFirstName );
			if ( ideditLastName )
				SetDlgItemText ( hDlg, ideditLastName, ulsC.szLastName );
			if ( ideditEmailName )
				SetDlgItemText ( hDlg, ideditEmailName, ulsC.szEmailName );
			if ( ideditLocation )
				SetDlgItemText ( hDlg, ideditLocation, ulsC.szLocation );
			if ( ideditInterests )
				SetDlgItemText ( hDlg, ideditInterests, ulsC.szComments );
			if ( idbtnDontPublish )
				SendDlgItemMessage ( hDlg, idbtnDontPublish, BM_SETCHECK,
					ulsC.fDontPublish ? TRUE : FALSE, 0 );
		}
	}

	if (FAILED(hr))
	{
		// There was a problem - disable everything
		DisableControl(hDlg, ideditServerName);
		DisableControl(hDlg, ideditFirstName);
		DisableControl(hDlg, ideditLastName);
		DisableControl(hDlg, ideditEmailName);
		DisableControl(hDlg, ideditLocation);
		DisableControl(hDlg, ideditInterests);
		DisableControl(hDlg, idbtnDontPublish);
	}

	return hr;
}

static BOOL IsULSEqual ( ULS_CONF * u1, ULS_CONF *u2, DWORD dwFlags )
{
	if ( lstrcmp ( u1->szServerName, u2->szServerName ) &&
		( dwFlags & ULSCONF_F_SERVER_NAME ) ||
		lstrcmp ( u1->szFirstName, u2->szFirstName ) &&
		( dwFlags & ULSCONF_F_FIRST_NAME ) ||
		lstrcmp ( u1->szLastName, u2->szLastName ) &&
		( dwFlags & ULSCONF_F_LAST_NAME ) ||
		lstrcmp ( u1->szEmailName, u2->szEmailName ) &&
		( dwFlags & ULSCONF_F_EMAIL_NAME ) ||
		lstrcmp ( u1->szLocation, u2->szLocation ) &&
		( dwFlags & ULSCONF_F_LOCATION ) ||
		lstrcmp ( u1->szComments, u2->szComments ) &&
		( dwFlags & ULSCONF_F_COMMENTS ) ||
		u1->fDontPublish != u2->fDontPublish &&
		( dwFlags & ULSCONF_F_PUBLISH ) )

		return FALSE;
	return TRUE;
}

static HRESULT SaveULSControls ( HWND hDlg,
						UINT ideditServerName,
						UINT ideditFirstName,
						UINT ideditLastName,
						UINT ideditEmailName,
						UINT ideditLocation,
						UINT ideditInterests,
						UINT idbtnDontPublish,
						BOOL bServerNameChanged
						 )
{

	// Check to see if the ULS is initialized

	if ( s_pUlsWizard == NULL ) {
		return E_NOINTERFACE;
	}

	// Now build up the flags for the setconfiguration call

	ULS_CONF ulsC;

	ulsC.dwFlags = 0;

	if ( ideditServerName )
		ulsC.dwFlags |= ULSCONF_F_SERVER_NAME;
	if ( ideditFirstName )
		ulsC.dwFlags |= ULSCONF_F_FIRST_NAME;
	if ( ideditLastName )
		ulsC.dwFlags |= ULSCONF_F_LAST_NAME;
	if ( ideditEmailName )
		ulsC.dwFlags |= ULSCONF_F_EMAIL_NAME;
	if ( ideditLocation )
		ulsC.dwFlags |= ULSCONF_F_LOCATION;
	if ( ideditInterests )
		ulsC.dwFlags |= ULSCONF_F_COMMENTS;
	if ( idbtnDontPublish )
		ulsC.dwFlags |= ULSCONF_F_PUBLISH;

	// Initialize the structure from the controls

	if ( ideditServerName )
	{
		GetDlgItemText( hDlg, ideditServerName, ulsC.szServerName, sizeof ( ulsC.szServerName ) );
		lstrcpyn( ulsC.szServerName, CDirectoryManager::get_dnsName( ulsC.szServerName ), sizeof ( ulsC.szServerName ) );
	}

	if ( ideditFirstName )
		GetDlgItemText ( hDlg, ideditFirstName, ulsC.szFirstName,
			sizeof( ulsC.szFirstName ) );
	if ( ideditLastName )
		GetDlgItemText ( hDlg, ideditLastName, ulsC.szLastName,
			sizeof( ulsC.szLastName ) );
	if ( ideditEmailName )
		GetDlgItemText ( hDlg, ideditEmailName, ulsC.szEmailName,
			sizeof( ulsC.szEmailName ) );
	if ( ideditLocation )
		GetDlgItemText ( hDlg, ideditLocation, ulsC.szLocation,
			sizeof( ulsC.szLocation ) );
	if ( ideditInterests )
		GetDlgItemText ( hDlg, ideditInterests, ulsC.szComments,
			sizeof( ulsC.szComments ) );
	if ( idbtnDontPublish )
		ulsC.fDontPublish =
			(BOOL)SendDlgItemMessage ( hDlg, idbtnDontPublish, BM_GETCHECK, 0, 0 );

	// Make the call

	HRESULT hRes = s_pUlsWizard->SetConfig( &ulsC );

	if ( hRes != S_OK) {
		ERROR_OUT(("ULSSetConfig call failed: %lx", hRes ));
		return hRes;
	}

	// Now check for changed ULS settings
	if ( g_fOld_ulsC_saved || bServerNameChanged) {
		if ( bServerNameChanged || !IsULSEqual ( &ulsC , &g_Old_ulsC, ulsC.dwFlags ))
		{
			g_dwChangedSettings |= CSETTING_L_ULSSETTINGS;

			if(ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_Direct)
			{
				BOOL bLogonToILSServer = TRUE;
				
				if(!g_pLDAP || !g_pLDAP->IsLoggedOn())
				{


				TCHAR res1[RES_CH_MAX];
				USES_RES2T
				RES2T(IDS_ULS_CHANGED_PROMPT);
				COPY_RES2T(res1);

					// Ask the user if they want to logon
					int iRet = ::MessageBox(hDlg,
											res1,
											RES2T(IDS_MSGBOX_TITLE),
											MB_SETFOREGROUND | MB_YESNO | MB_ICONQUESTION);
					if(IDNO == iRet)
					{
						bLogonToILSServer = FALSE;
					}
				}

				if(bLogonToILSServer)
				{ 
					if(NULL == g_pLDAP)
					{
						InitNmLdapAndLogon();
					}
					else
					{
						g_pLDAP->LogonAsync();
					}
				}
			}
		}
	}

	return S_OK;
}


/*	_  I N I T	U S E R  D L G	P R O C  */
/*-------------------------------------------------------------------------
	%%Function: _InitUserDlgProc

	Initialize the conferencing name fields
-------------------------------------------------------------------------*/
static void _InitUserDlgProc(HWND hdlg, PROPSHEETPAGE * ps, LPTSTR szOldServerNameBuf, UINT cch )
{
	RegEntry reCU( CONFERENCING_KEY, HKEY_CURRENT_USER);

	s_fOldAlwaysRunning = (0 != reCU.GetNumber(
				REGVAL_CONF_ALWAYS_RUNNING,	ALWAYS_RUNNING_DEFAULT ));

	CheckDlgButton( hdlg, IDC_ALWAYS_RUNNING, s_fOldAlwaysRunning ? BST_CHECKED : BST_UNCHECKED );

#ifndef TASKBARBKGNDONLY
	///////////////////////////////////////////////////////////
	//
	// Taskbar Icon Settings
	//
	// Initialize the icon-on-taskbar settings

	// Check the right button for taskbar icon use

	s_fOldTaskbarSetting = reCU.GetNumber(
				REGVAL_TASKBAR_ICON, TASKBARICON_DEFAULT )
				== TASKBARICON_ALWAYS;

	SendDlgItemMessage ( hdlg, IDC_SHOWONTASKBAR,
						 BM_SETCHECK,
						 s_fOldTaskbarSetting ? BST_CHECKED : BST_UNCHECKED,
						 0L );
#endif // ! TASKBARBKGNDONLY

#if USE_GAL
		if( ConfPolicies::IsGetMyInfoFromGALEnabled() && ConfPolicies::GetMyInfoFromGALSucceeded())
		{
			EnableWindow( GetDlgItem( hdlg, IDC_USER_NAME), FALSE );
			EnableWindow( GetDlgItem( hdlg, IDC_USER_LASTNAME), FALSE );
			EnableWindow( GetDlgItem( hdlg, IDC_USER_EMAIL), FALSE );
			EnableWindow( GetDlgItem( hdlg, IDC_USER_LOCATION), FALSE );
			EnableWindow( GetDlgItem( hdlg, IDC_USER_INTERESTS), FALSE );

			TCHAR szBuffer[ MAX_PATH ];
			FLoadString( IDS_MYINFO_CAPTION_DISABLED, szBuffer, CCHMAX( szBuffer ) );
			SetWindowText( GetDlgItem( hdlg, IDC_STATIC_MYINFO ), szBuffer );
		}
		else
		{
			TCHAR szBuffer[ MAX_PATH ];
			FLoadString( IDS_MYINFO_CAPTION_ENABLED, szBuffer, CCHMAX( szBuffer ) );
			SetWindowText( GetDlgItem( hdlg, IDC_STATIC_MYINFO ), szBuffer );
		}
#endif // USE_GAL

	if( ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_GateKeeper)
	{
			// Disable the ILS-related stuff
		EnableWindow( GetDlgItem( hdlg, IDC_NAMESERVER), FALSE );
		EnableWindow( GetDlgItem( hdlg, IDC_USER_PUBLISH), FALSE );
		EnableWindow( GetDlgItem( hdlg, IDC_USEULS), FALSE );
		EnableWindow( GetDlgItem( hdlg, IDC_STATIC_SERVER_NAME), FALSE );
	}

    EnableWindow( GetDlgItem( hdlg, IDC_ADVANCED_CALL_OPTS),
        ConfPolicies::IsAdvancedCallingAllowed());


	// Set the font
	SendDlgItemMessage(hdlg, IDC_USER_NAME,      WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	SendDlgItemMessage(hdlg, IDC_USER_LASTNAME,  WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	SendDlgItemMessage(hdlg, IDC_USER_LOCATION,  WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	SendDlgItemMessage(hdlg, IDC_USER_INTERESTS, WM_SETFONT, (WPARAM) g_hfontDlg, 0);

	// Limit the edit control
	SendDlgItemMessage(hdlg, IDC_USER_NAME, 	EM_LIMITTEXT, MAX_FIRST_NAME_LENGTH-1, 0);
	SendDlgItemMessage(hdlg, IDC_USER_LASTNAME, EM_LIMITTEXT, MAX_LAST_NAME_LENGTH-1, 0);
	SendDlgItemMessage(hdlg, IDC_USER_EMAIL,	EM_LIMITTEXT, MAX_EMAIL_NAME_LENGTH-1, 0);
	SendDlgItemMessage(hdlg, IDC_USER_LOCATION, EM_LIMITTEXT, MAX_LOCATION_NAME_LENGTH-1, 0);
	SendDlgItemMessage(hdlg, IDC_USER_INTERESTS,EM_LIMITTEXT, UI_COMMENTS_LENGTH-1, 0);

	InitULSDll();

	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

	// Init the server combobox... can we skip this stuff if we are not using ILS????
	FixServerDropList(hdlg, IDC_NAMESERVER, szOldServerNameBuf, cch );

	InitULSControls(hdlg, s_pUlsWizard,
		IDC_NAMESERVER,
		IDC_USER_NAME, IDC_USER_LASTNAME, IDC_USER_EMAIL,
		IDC_USER_LOCATION, IDC_USER_INTERESTS,
		IDC_USER_PUBLISH);
	
	// First the log onto directory servers stuff...
    s_fOldUseUlsServer = ConfPolicies::LogOntoIlsWhenNetMeetingStartsIfInDirectCallingMode();

	_SetLogOntoIlsButton( hdlg, s_fOldUseUlsServer);

	if (!SysPol::AllowDirectoryServices())
	{
		// Disable all items in this group
		DisableControl(hdlg, IDC_USEULS);
		DisableControl(hdlg, IDC_NAMESERVER);
		DisableControl(hdlg, IDC_USER_PUBLISH);
		DisableControl(hdlg, IDC_STATIC_SERVER_NAME);
	}

	s_hDlgUserInfo = hdlg;
}			

static void General_OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify, UINT *puBandwidth)
{
	INT_PTR CALLBACK BandwidthDlg( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

	switch(id)
	{
	case IDC_ADVANCED_CALL_OPTS:
	{
		DialogBox( GetInstanceHandle(), MAKEINTRESOURCE( IDD_CALLOPT ), hDlg, CallOptDlgProc );
		BOOL bEnable = (ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_Direct);

			// Disable/Enable the ILS-related stuff
		EnableWindow( GetDlgItem( hDlg, IDC_NAMESERVER), bEnable );
		EnableWindow( GetDlgItem( hDlg, IDC_USER_PUBLISH), bEnable );
		EnableWindow( GetDlgItem( hDlg, IDC_USEULS), bEnable );
		EnableWindow( GetDlgItem( hDlg, IDC_STATIC_SERVER_NAME), bEnable );

			// We are now in Gatekeeper mode, we should log off the ILS server
		if(!bEnable && g_pLDAP && g_pLDAP->IsLoggedOn())
		{
			g_pLDAP->Logoff();
		}

		break;
	}

	case IDC_BANDWIDTH:
		int nRet;

		nRet = (int)DialogBoxParam(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDD_BANDWIDTH), hDlg, BandwidthDlg, *puBandwidth);

		if (nRet != 0)
		{
			*puBandwidth = nRet;
		}

		break;

	case IDC_ALWAYS_RUNNING:
		if (FIsDlgButtonChecked( hDlg, IDC_ALWAYS_RUNNING ))
		{
			VOID EnableRDS(BOOL fEnabledRDS);

            RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
            BOOL bRDSRunning = reLM.GetNumber(REMOTE_REG_RUNSERVICE, DEFAULT_REMOTE_RUNSERVICE);

			if (bRDSRunning)
			{
				TCHAR szMsg[2*RES_CH_MAX];
				USES_RES2T
				if (IDYES != MessageBox(hDlg,
					Res2THelper(IDS_RDSWARNING, szMsg, ARRAY_ELEMENTS(szMsg)), RES2T(IDS_MSGBOX_TITLE),
					MB_YESNO|MB_ICONHAND))
				{
					CheckDlgButton(hDlg, IDC_ALWAYS_RUNNING, BST_UNCHECKED);
					break;
				}

				EnableRDS(FALSE);
			}
		}
		break;

	default:
		break;
	}
}
/*	U S E R  D L G	P R O C  */
/*-------------------------------------------------------------------------
	%%Function: UserDlgProc

-------------------------------------------------------------------------*/
INT_PTR APIENTRY UserDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static PROPSHEETPAGE * ps;
	static TCHAR s_szOldServerNameBuf[MAX_PATH];
	static UINT uOldBandwidth=0;
	static UINT uNewBandwidth=0;

	switch (message)
	{

		case WM_INITDIALOG:
		{
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			_InitUserDlgProc(hDlg, ps, s_szOldServerNameBuf, CCHMAX(s_szOldServerNameBuf) );

			uNewBandwidth = uOldBandwidth = GetBandwidth();

			return TRUE;
		}

		case WM_COMMAND:
			General_OnCommand(hDlg, LOWORD(wParam), (HWND)lParam, HIWORD(wParam), &uNewBandwidth);
			break;

		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {

				case PSN_KILLACTIVE:
				{
					int _IdFocus = 0;

					TCHAR szName[MAX_FIRST_NAME_LENGTH];
					TCHAR szLastName[MAX_LAST_NAME_LENGTH];
					TCHAR szEMail[MAX_EMAIL_NAME_LENGTH];

					// Check for no data in user name
					if (0 == GetDlgItemTextTrimmed(hDlg, IDC_USER_NAME, szName, CCHMAX(szName) ))
					{
						ConfMsgBox(hDlg, (LPCTSTR)IDS_NEEDUSERNAME);
						_IdFocus = IDC_USER_NAME;
					}
						// Check for no data in user name
					else if( 0 == GetDlgItemTextTrimmed(hDlg, IDC_USER_LASTNAME, szLastName, CCHMAX(szLastName)))
					{	
						ConfMsgBox(hDlg, (LPCTSTR)IDS_NEEDUSERNAME);
						_IdFocus = IDC_USER_LASTNAME;
					}
					else if( (!GetDlgItemText(hDlg, IDC_USER_EMAIL, szEMail, CCHMAX(szEMail)) || !FLegalEmailSz(szEMail)))
					{
							ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGALEMAILNAME);
							_IdFocus = IDC_USER_EMAIL;
					}

					TCHAR	szServerNameBuf[ MAX_PATH ];

					if( (!_IdFocus) &&
						FIsDlgButtonChecked( hDlg, IDC_USEULS )	&&
						(GetDlgItemTextTrimmed( hDlg, IDC_NAMESERVER, szServerNameBuf, CCHMAX( szServerNameBuf ) ) == 0) )
					{
						//	They specified logon to ILS at startup but didn't specify an ILS...
						ConfMsgBox( hDlg, (LPCTSTR) IDS_NO_ILS_SERVER );
						_IdFocus = IDC_NAMESERVER;
					}

					if( _IdFocus )
					{
						SetFocus(GetDlgItem(hDlg, _IdFocus));
						SendDlgItemMessage(hDlg, _IdFocus, EM_SETSEL, (WPARAM) 0, (LPARAM) -1);
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE );
						return TRUE;
					}
				}
				break;

				case PSN_APPLY:
				{
					RegEntry	reConf( CONFERENCING_KEY, HKEY_CURRENT_USER );

					bool fAlwaysRunning;

					fAlwaysRunning = FIsDlgButtonChecked( hDlg, IDC_ALWAYS_RUNNING );

//					if ( fAlwaysRunning != s_fOldAlwaysRunning )
					{
						reConf.SetValue(REGVAL_CONF_ALWAYS_RUNNING, fAlwaysRunning);

						RegEntry reRun(WINDOWS_RUN_KEY, HKEY_CURRENT_USER);
						if (fAlwaysRunning)
						{
							TCHAR szRunTask[MAX_PATH*2];
							TCHAR szInstallDir[MAX_PATH];

							if (GetInstallDirectory(szInstallDir))
							{
								RegEntry reConfLM(CONFERENCING_KEY, HKEY_LOCAL_MACHINE);
								wsprintf(szRunTask, _TEXT("\"%s%s\" -%s"),
									szInstallDir,
									reConfLM.GetString(REGVAL_NC_NAME),
									g_cszBackgroundSwitch);
								reRun.SetValue(REGVAL_RUN_TASKNAME, szRunTask);
							}
						}
						else
						{
							reRun.DeleteValue(REGVAL_RUN_TASKNAME);
						}
					}

#ifndef TASKBARBKGNDONLY
					///////////////////////////////////////////////////////////
					//
					// Taskbar Icon Settings
					//
					// Save taskbar icon state

					bool fTaskbarSetting;

					fTaskbarSetting = FIsDlgButtonChecked( hDlg,
						IDC_SHOWONTASKBAR );

					if ( fTaskbarSetting != s_fOldTaskbarSetting )
					{
						reConf.SetValue( REGVAL_TASKBAR_ICON,
								fTaskbarSetting? TASKBARICON_ALWAYS :
									TASKBARICON_NEVER );
						g_dwChangedSettings |= CSETTING_L_SHOWTASKBAR;
					}
#endif // ! TASKBARBKGNDONLY

        			//	Process "use uls server" setting...
					bool	fUseUlsServer	= FIsDlgButtonChecked( hDlg, IDC_USEULS ) ? true : false;

					if( fUseUlsServer != s_fOldUseUlsServer )
					{
						reConf.SetValue( REGVAL_DONT_LOGON_ULS, !fUseUlsServer );
						g_dwChangedSettings |= CSETTING_L_USEULSSERVER;
					}

					TCHAR szServerNameBuf[MAX_PATH];

					GetDlgItemTextTrimmed( hDlg, IDC_NAMESERVER, szServerNameBuf, CCHMAX( szServerNameBuf ) );

					if( lstrcmpi( szServerNameBuf, s_szOldServerNameBuf ) != 0 )
					{
						g_dwChangedSettings |= CSETTING_L_ULSSETTINGS;
					}

					///////////////////////////////////////////////////////////
					//
					// Conferencing Name Settings
					//
					// Just clean the rest
					TrimDlgItemText(hDlg, IDC_USER_LOCATION);
					TrimDlgItemText(hDlg, IDC_USER_INTERESTS);

					BOOL bServerNameChanged = g_dwChangedSettings & CSETTING_L_USEULSSERVER;

					HRESULT hRes = SaveULSControls(	hDlg,
													((g_dwChangedSettings & CSETTING_L_ULSSETTINGS) != 0)? IDC_NAMESERVER: 0,
													IDC_USER_NAME,
													IDC_USER_LASTNAME,
													IDC_USER_EMAIL,
													IDC_USER_LOCATION,
													IDC_USER_INTERESTS,
													IDC_USER_PUBLISH,
													bServerNameChanged);

					if( (g_dwChangedSettings & CSETTING_L_ULSSETTINGS) != 0 )
					{
						g_pCCallto->SetIlsServerName( CDirectoryManager::get_dnsName( szServerNameBuf ) );
					}

					ASSERT(S_OK == hRes);

					if (uNewBandwidth != uOldBandwidth)
					{
						g_dwChangedSettings |= CSETTING_L_BANDWIDTH;
						SetBandwidth(uNewBandwidth);
						UpdateCodecSettings(uNewBandwidth);
					}

					break;
				}

				case PSN_RESET:
					break;
			}
			break;

        case WM_CONTEXTMENU:
            DoHelpWhatsThis(wParam, aUserHelpIds);
            break;

		case WM_HELP:
			DoHelp(lParam, aUserHelpIds);
			break;

		case WM_DESTROY:
		{
			DeInitULSDll();
			break;
		}
	}
	return (FALSE);
}


VOID FixServerDropList(HWND hdlg, int id, LPTSTR pszServer, UINT cchMax)
{
	HWND hwndCtrl = GetDlgItem(hdlg, id);
	ASSERT(NULL != hwndCtrl);

	BOOL fComboBox = SysPol::AllowAddingServers();
	
	if (fComboBox)
	{
		// Limit the text in the edit control
        ComboBox_LimitText(GetDlgItem(hdlg, id), MAX_SERVER_NAME_LENGTH - 1);
	}
	else
	{
		// System policy does not allow adding new servers
		// Replace the combo list with a simple drop list

		RECT rc;
		GetWindowRect(hwndCtrl, &rc);
		LONG xpTop = rc.top;
		ComboBox_GetDroppedControlRect(hwndCtrl, &rc);
		rc.top = xpTop;
		::MapWindowPoints(NULL, hdlg, (LPPOINT) &rc, 2);

		DWORD dwStyle = GetWindowLong(hwndCtrl, GWL_STYLE);
		DWORD dwStyleEx = GetWindowLong(hwndCtrl, GWL_EXSTYLE);
		INT_PTR id2 = GetWindowLong(hwndCtrl, GWL_ID);
		HFONT hFont = (HFONT) ::SendMessage(hwndCtrl, WM_GETFONT, 0, 0);
		HWND hwndPrev = ::GetNextWindow(hwndCtrl, GW_HWNDPREV);

		DestroyWindow(hwndCtrl);

		dwStyle = CBS_DROPDOWNLIST | (dwStyle & ~CBS_DROPDOWN);

		hwndCtrl = ::CreateWindowEx(dwStyleEx, TEXT("COMBOBOX"), g_szEmpty, dwStyle,
				rc.left, rc.top, RectWidth(rc), RectHeight(rc),
				hdlg, (HMENU) id2, ::GetInstanceHandle(), 0);

		::SendMessage(hwndCtrl, WM_SETFONT, (WPARAM) hFont, 0);

		// Maintain the tab order
		::SetWindowPos(hwndCtrl, hwndPrev, 0, 0, 0, 0,
			SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER | SWP_NOREDRAW);
	}

	FillServerComboBox(hwndCtrl);

	// Find the item in the list
	int	index	= (int)::SendMessage( hwndCtrl, CB_FINDSTRINGEXACT, -1, (LPARAM) CDirectoryManager::get_displayName( pszServer ) );

	ComboBox_SetCurSel( hwndCtrl, (index == CB_ERR)? 0: index );

}


static void _SetCallingMode( HWND hDlg, ConfPolicies::eCallingMode eMode )
{
	switch( eMode )
	{
		case ConfPolicies::CallingMode_Direct:
			CheckDlgButton( hDlg, IDC_CALLOPT_GK_USE, BST_UNCHECKED );
			SendMessage( hDlg, WM_COMMAND, MAKEWPARAM(IDC_CALLOPT_GK_USE,0 ), 0 );
			break;

		case ConfPolicies::CallingMode_GateKeeper:
			CheckDlgButton( hDlg, IDC_CALLOPT_GK_USE, BST_CHECKED );
			SendMessage( hDlg, WM_COMMAND, MAKEWPARAM(IDC_CALLOPT_GK_USE,0 ), 0 );

			break;

		default:
			ERROR_OUT(("Invalid return val"));
			break;

	}
}

static void _SetLogOntoIlsButton( HWND hDlg, bool bLogOntoIlsWhenNmStarts )
{
	if( bLogOntoIlsWhenNmStarts )
	{
		CheckDlgButton( hDlg, IDC_USEULS, bLogOntoIlsWhenNmStarts ? BST_CHECKED : BST_UNCHECKED );
		SendMessage( hDlg, WM_COMMAND, MAKEWPARAM(IDC_USEULS, 0 ), 0 );
	}
}


// NOTE: This function is shared by the wizard page IDD_PAGE_SERVER
void InitDirectoryServicesDlgInfo( HWND hDlg, CULSWizard* pWiz, bool& rbOldEnableGateway, LPTSTR szOldServerNameBuf, UINT cch )
{
	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

		// Init the server combobox... can we skip this stuff if we are not using ILS????
	FixServerDropList(hDlg, IDC_NAMESERVER, szOldServerNameBuf, cch );

	InitULSControls(hDlg, pWiz,
		IDC_NAMESERVER,
		0, 0, 0,
		0, 0,
		IDC_USER_PUBLISH);

	// First the log onto directory servers stuff...
    s_fOldUseUlsServer = ConfPolicies::LogOntoIlsWhenNetMeetingStartsIfInDirectCallingMode();
	_SetLogOntoIlsButton( hDlg, s_fOldUseUlsServer);

	if (!SysPol::AllowDirectoryServices())
	{
		// Disable all items in this group
		DisableControl(hDlg, IDC_USEULS);
		DisableControl(hDlg, IDC_NAMESERVER);
		DisableControl(hDlg, IDC_USER_PUBLISH);
	}

}


void InitProxyInfo( HWND hDlg, CULSWizard* pWiz, bool& rbOldEnableProxy, LPTSTR szOldProxyNameBuf, UINT cch )
{
	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

	// proxy settings...
	HWND	hEditProxyServer	= GetDlgItem( hDlg, IDE_CALLOPT_PROXY_SERVER );

	if( hEditProxyServer )
	{
		SetWindowText( hEditProxyServer, reConf.GetString( REGVAL_PROXY ) );
		SendMessage( hEditProxyServer, EM_LIMITTEXT, CCHMAXSZ_SERVER - 1, 0 );

		rbOldEnableProxy = reConf.GetNumber( REGVAL_USE_PROXY )? true: false;

		if( rbOldEnableProxy )
		{
			CheckDlgButton( hDlg, IDC_CHECK_USE_PROXY, BST_CHECKED );
		}
		else
		{
			EnableWindow( hEditProxyServer, FALSE );
			DisableControl( hDlg, IDC_STATIC_PROXY_NAME );
		}
	}
}


void InitGWInfo( HWND hDlg, CULSWizard* pWiz, bool& rbOldEnableGateway, LPTSTR szOldServerNameBuf, UINT cch )
{
	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

	// H.323 gateway settings
	HWND	hEditGwServer	= GetDlgItem( hDlg, IDE_CALLOPT_GW_SERVER );

	if( hEditGwServer )
	{
		SetWindowText( hEditGwServer, reConf.GetString( REGVAL_H323_GATEWAY ) );
		SendMessage( hEditGwServer, EM_LIMITTEXT, CCHMAXSZ_SERVER - 1, 0 );

		rbOldEnableGateway = reConf.GetNumber( REGVAL_USE_H323_GATEWAY )? true: false;

		if( rbOldEnableGateway )
		{
			CheckDlgButton( hDlg, IDC_CHECK_USE_GATEWAY, BST_CHECKED );
		}
		else
		{
			EnableWindow( hEditGwServer, FALSE );
			DisableControl( hDlg, IDC_STATIC_GATEWAY_NAME );
		}
	}
}


// NOTE: This function is shared by the wizard page IDD_WIZPG_GKMODE_SETTINGS
void InitGatekeeperDlgInfo( HWND hDlg, HWND hDlgUserInfo, CULSWizard* pWiz)
{
	//////////////////////////////////////////
	// Set the gatekeeper data

		// First the server name
	TCHAR buffer[CCHMAXSZ_SERVER];

	ConfPolicies::GetGKServerName( buffer, CCHMAX( buffer ) );

	SendDlgItemMessage(hDlg, IDE_CALLOPT_GK_SERVER,  WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	SendDlgItemMessage(hDlg, IDE_CALLOPT_GK_SERVER, EM_LIMITTEXT, CCHMAXSZ_SERVER-1, 0);
	SetDlgItemText(hDlg, IDE_CALLOPT_GK_SERVER, buffer );

	ConfPolicies::GetGKAccountName( buffer, CCHMAX( buffer ) );

	SendDlgItemMessage(hDlg, IDE_CALLOPT_GK_ACCOUNT,  WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	SendDlgItemMessage(hDlg, IDE_CALLOPT_GK_ACCOUNT, EM_LIMITTEXT, CCHMAXSZ_SERVER-1, 0);
	SetDlgItemText(hDlg, IDE_CALLOPT_GK_ACCOUNT, buffer );

	ConfPolicies::eGKAddressingMode	addressingMode	= ConfPolicies::GetGKAddressingMode();

	bool bUsePhoneNumbers	= ((addressingMode == ConfPolicies::GKAddressing_PhoneNum) || (addressingMode == ConfPolicies::GKAddressing_Both));
	bool bUseAccount		= ((addressingMode == ConfPolicies::GKAddressing_Account) || (addressingMode == ConfPolicies::GKAddressing_Both));

	RegEntry reULS(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
	SendDlgItemMessage(hDlg, IDE_CALLOPT_GK_PHONE_NUMBER,  WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	SendDlgItemMessage(hDlg, IDE_CALLOPT_GK_PHONE_NUMBER, EM_LIMITTEXT, MAX_PHONENUM_LENGTH-1, 0);
	SetDlgItemText(hDlg, IDE_CALLOPT_GK_PHONE_NUMBER, reULS.GetString( REGVAL_ULS_PHONENUM_NAME ));

	if( bUsePhoneNumbers )
	{
		CheckDlgButton( hDlg, IDC_CHECK_USE_PHONE_NUMBERS, BST_CHECKED );
	}

	if( bUseAccount )
	{
		CheckDlgButton( hDlg, IDC_CHECK_USE_ACCOUNT, BST_CHECKED );
	}

  	EnableWindow( GetDlgItem( hDlg, IDC_STATIC_PHONE_NUMBER ), bUsePhoneNumbers );
    EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ), bUsePhoneNumbers );
   	EnableWindow( GetDlgItem( hDlg, IDS_STATIC_ACCOUNT ), bUseAccount );
    EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ), bUseAccount );
}


/*  C A L L  O P T  D L G  P R O C  */
/*-------------------------------------------------------------------------
    %%Function: CallOptDlgProc

-------------------------------------------------------------------------*/
INT_PTR APIENTRY CallOptDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static PROPSHEETPAGE * ps;

	static bool s_fEnableGk;
	static bool s_fEnableGw;
	static bool s_fEnableProxy;
    static bool s_fCantChangeCallMode;
	static bool s_InitialbUsingPhoneNum;
	static bool s_InitialbUsingAccount;
	static TCHAR s_szOldGatewayNameBuf[MAX_PATH];
	static TCHAR s_szOldProxyNameBuf[MAX_PATH];

	switch (message)
	{
		case WM_INITDIALOG:
		{
            s_fCantChangeCallMode = !ConfPolicies::UserCanChangeCallMode();

			InitProxyInfo( hDlg, s_pUlsWizard, s_fEnableProxy, s_szOldProxyNameBuf, CCHMAX( s_szOldProxyNameBuf ) );
			InitGWInfo( hDlg, s_pUlsWizard, s_fEnableGw, s_szOldGatewayNameBuf, CCHMAX( s_szOldGatewayNameBuf ) );

			InitGatekeeperDlgInfo( hDlg, s_hDlgUserInfo, s_pUlsWizard);

			s_InitialbUsingPhoneNum = FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PHONE_NUMBERS );
			s_InitialbUsingAccount = FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_ACCOUNT );

			s_fEnableGk = ( ConfPolicies::CallingMode_GateKeeper == ConfPolicies::GetCallingMode() );
			

			///////////////////////////////////////////	
			// Set the calling mode				
			_SetCallingMode( hDlg, ConfPolicies::GetCallingMode() );
			
			return TRUE;
		}
		break;

		case WM_COMMAND:
		
			switch (LOWORD(wParam))
			{

				case IDC_WARNME:
					EnableWindow(GetDlgItem(hDlg, IDC_WARNCOUNT),
							FIsDlgButtonChecked(hDlg, IDC_WARNME));
				break;

				case IDC_CALLOPT_GK_USE:
				{
					if( FIsDlgButtonChecked( hDlg, IDC_CALLOPT_GK_USE ) )
					{
						BOOL fUsePhone		= FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PHONE_NUMBERS );
						BOOL fUseAccount	= FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_ACCOUNT );

#if	defined( PROXY_SUPPORTED )
						// disable the non-gatekeeper items
						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_PROXY ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_PROXY_NAME ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_PROXY_SERVER ), FALSE );
#endif	//	defined( PROXY_SUPPORTED )

						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_GATEWAY ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_GATEWAY_NAME ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GW_SERVER ), FALSE );

						// Enable the gatekeeper options
                        EnableWindow( GetDlgItem( hDlg, IDC_CALLOPT_GK_USE ), !s_fCantChangeCallMode);
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_SERVER ),  !s_fCantChangeCallMode);
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_GATEKEEPER_NAME ),  !s_fCantChangeCallMode);
						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_PHONE_NUMBERS ), !s_fCantChangeCallMode);
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_PHONE_NUMBER ), fUsePhone);
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ), fUsePhone);
						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_ACCOUNT ), !s_fCantChangeCallMode );
						EnableWindow( GetDlgItem( hDlg, IDS_STATIC_ACCOUNT ), fUseAccount );
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ),  fUseAccount );

                        if (!s_fCantChangeCallMode)
                        {
    						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_GK_SERVER ) );
	    					SendDlgItemMessage( hDlg, IDE_CALLOPT_GK_SERVER, EM_SETSEL, 0, -1 );
                        }
                        else
                        {
                            if (fUsePhone)
                            {
        						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ) );
	        					SendDlgItemMessage( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER, EM_SETSEL, 0, -1 );
                            }
                            else if (fUseAccount)
                            {
        						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ) );
    	    					SendDlgItemMessage( hDlg, IDE_CALLOPT_GK_ACCOUNT, EM_SETSEL, 0, -1 );
                            }
                        }
					}
					else
					{
#if	defined( PROXY_SUPPORTED )
						// Enable the direct use options
						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_PROXY ), TRUE );
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_PROXY_NAME ), FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PROXY ) );
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_PROXY_SERVER ), FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PROXY ) );
#endif	//	defined( PROXY_SUPPORTED )

						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_GATEWAY ), !s_fCantChangeCallMode );
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_GATEWAY_NAME ), !s_fCantChangeCallMode && FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_GATEWAY ) );
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GW_SERVER ), !s_fCantChangeCallMode && FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_GATEWAY ) );

						// Disable the gatekeeper options
                        EnableWindow( GetDlgItem( hDlg, IDC_CALLOPT_GK_USE ), !s_fCantChangeCallMode);
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_SERVER ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_GATEKEEPER_NAME ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_PHONE_NUMBERS ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_PHONE_NUMBER ), FALSE);
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ),  FALSE );
						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_ACCOUNT ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDS_STATIC_ACCOUNT ), FALSE);
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ),  FALSE );
					}
					break;
				}

				case IDC_CHECK_USE_ACCOUNT:
				{
					if( FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_ACCOUNT ) )
					{	
						EnableWindow(GetDlgItem( hDlg, IDS_STATIC_ACCOUNT ), TRUE);
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ), TRUE);
						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ) );
						SendDlgItemMessage( hDlg, IDE_CALLOPT_GK_ACCOUNT, EM_SETSEL, 0, -1 );
					}
					else
					{
						EnableWindow(GetDlgItem( hDlg, IDS_STATIC_ACCOUNT ), FALSE);
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ), FALSE);
					}

					break;
				}

				case IDC_CHECK_USE_PHONE_NUMBERS:
				{
					if( FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PHONE_NUMBERS ) )
					{	
						EnableWindow(GetDlgItem( hDlg, IDC_STATIC_PHONE_NUMBER ), TRUE);
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ), TRUE);
						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ) );
						SendDlgItemMessage( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER, EM_SETSEL, 0, -1 );
					}
					else
					{
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ), FALSE);
						EnableWindow(GetDlgItem( hDlg, IDC_STATIC_PHONE_NUMBER ), FALSE);
					}

					break;
				}

				case IDC_CHECK_USE_PROXY:
				{
					if( FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PROXY ) != FALSE )
					{	
						EnableWindow(GetDlgItem( hDlg, IDC_STATIC_PROXY_NAME ), TRUE );
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_PROXY_SERVER ), TRUE );
						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_PROXY_SERVER ) );
						SendDlgItemMessage( hDlg, IDE_CALLOPT_PROXY_SERVER, EM_SETSEL, 0, -1 );
					}
					else
					{
						EnableWindow(GetDlgItem( hDlg, IDC_STATIC_PROXY_NAME ), FALSE );
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_PROXY_SERVER ), FALSE );
					}
				}					
				break;

				case IDC_CHECK_USE_GATEWAY:
				{
					if( FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_GATEWAY ) != FALSE )
					{	
						EnableWindow(GetDlgItem( hDlg, IDC_STATIC_GATEWAY_NAME ), TRUE );
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_GW_SERVER ), TRUE );
						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_GW_SERVER ) );
						SendDlgItemMessage( hDlg, IDE_CALLOPT_GW_SERVER, EM_SETSEL, 0, -1 );
					}
					else
					{
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_GW_SERVER ), FALSE );
						EnableWindow(GetDlgItem( hDlg, IDC_STATIC_GATEWAY_NAME ), FALSE );
					}
				}					
				break;

				case IDOK:
				{
					////////////////////////////////////////////////////////////////////
					// First we check to see that we have valid data
					
					int _IdFocus = 0;
						
						// Check to see if we are in gatekeeper mode...
					if( FIsDlgButtonChecked( hDlg, IDC_CALLOPT_GK_USE ) )
					{
							// Verify the gatekeeper settings
						TCHAR szServer[CCHMAXSZ_SERVER];
						if (!GetDlgItemText(hDlg, IDE_CALLOPT_GK_SERVER, szServer, CCHMAX(szServer)) ||
							!IsLegalGateKeeperServerSz(szServer))
						{
							ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGAL_GATEKEEPERSERVER_NAME);
							_IdFocus = IDE_CALLOPT_GK_SERVER;
						}
						if( (!_IdFocus) && (!FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PHONE_NUMBERS )) &&
							(!FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_ACCOUNT )) )
						{
								// must check either account or phone number...
							ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGAL_GK_MODE);
							_IdFocus = IDC_CHECK_USE_PHONE_NUMBERS;
						}
						if( (!_IdFocus) && FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PHONE_NUMBERS ) )
						{
								// Verify the phone number
							TCHAR szPhone[MAX_PHONENUM_LENGTH];
							if (!GetDlgItemText(hDlg, IDE_CALLOPT_GK_PHONE_NUMBER, szPhone, CCHMAX(szPhone)) ||
								!IsLegalE164Number(szPhone))
							{
								ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGAL_PHONE_NUMBER);
								_IdFocus = IDE_CALLOPT_GK_PHONE_NUMBER;
							}
						}
						if( (!_IdFocus) && FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_ACCOUNT ) )
						{
								// Verify the account
							TCHAR account[MAX_PATH];
							if (!GetDlgItemText(hDlg, IDE_CALLOPT_GK_ACCOUNT, account, CCHMAX(account)) )
							{
								ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGAL_ACCOUNT);
								_IdFocus = IDE_CALLOPT_GK_ACCOUNT;
							}
						}
					}

#if	defined( PROXY_SUPPORTED )
					//	Verify the proxy settings...
					if( (!_IdFocus) && FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PROXY ) && (!FIsDlgButtonChecked( hDlg, IDC_CALLOPT_GK_USE )) )
					{
						TCHAR szServer[CCHMAXSZ_SERVER];
						if (!GetDlgItemText(hDlg, IDE_CALLOPT_PROXY_SERVER, szServer, CCHMAX(szServer)) ||
							!IsLegalGatewaySz(szServer))
						{
							ConfMsgBox(hDlg, (LPCTSTR) IDS_ILLEGAL_PROXY_NAME);
							_IdFocus = IDE_CALLOPT_PROXY_SERVER;
						}
					}
#endif	//	defined( PROXY_SUPPORTED )

					//	Verify the gateway settings...
					if( (!_IdFocus) && FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_GATEWAY ) && (!FIsDlgButtonChecked( hDlg, IDC_CALLOPT_GK_USE )) )
					{
						TCHAR szServer[CCHMAXSZ_SERVER];
						if (!GetDlgItemText(hDlg, IDE_CALLOPT_GW_SERVER, szServer, CCHMAX(szServer)) ||
							!IsLegalGatewaySz(szServer))
						{
							ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGAL_GATEWAY_NAME);
							_IdFocus = IDE_CALLOPT_GW_SERVER;
						}
					}

					if( _IdFocus )
					{
						SetFocus(GetDlgItem(hDlg, _IdFocus));
						SendDlgItemMessage(hDlg, _IdFocus, EM_SETSEL, (WPARAM) 0, (LPARAM) -1);
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE );
					}
					else
					{
						RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

						// Handle the H323 Gateway setting:
						TCHAR buffer[CCHMAXSZ_SERVER];
						GetDlgItemText(hDlg, IDE_CALLOPT_GW_SERVER, buffer, CCHMAX(buffer));
						reConf.SetValue(REGVAL_H323_GATEWAY, buffer);
						g_pCCallto->SetGatewayName( buffer );

						bool fEnable = FIsDlgButtonChecked(hDlg, IDC_CHECK_USE_GATEWAY) ? true : false;
						if (fEnable != s_fEnableGw)
						{
							reConf.SetValue(REGVAL_USE_H323_GATEWAY, fEnable);
						}

						g_pCCallto->SetGatewayEnabled( fEnable );

#if	defined( PROXY_SUPPORTED )
						reConf.SetValue( REGVAL_USE_PROXY, FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PROXY ) );
						GetDlgItemText( hDlg, IDE_CALLOPT_PROXY_SERVER, buffer, CCHMAX( buffer ) );
						reConf.SetValue( REGVAL_PROXY, buffer );
#endif	//	defined( PROXY_SUPPORTED )

						bool	relogonRequired = false;

						// Gatekeeper / alias settings
						{
							TCHAR szServer[CCHMAXSZ_SERVER];
							GetDlgItemTextTrimmed(hDlg, IDE_CALLOPT_GK_SERVER, szServer, CCHMAX(szServer));
							if (0 != lstrcmp(szServer, reConf.GetString(REGVAL_GK_SERVER)))
							{
								reConf.SetValue(REGVAL_GK_SERVER, szServer);
								relogonRequired = true;
							}

							fEnable = FIsDlgButtonChecked(hDlg, IDC_CALLOPT_GK_USE) ? true : false;

							if( fEnable != s_fEnableGk )
							{
									// Set the calling mode
								reConf.SetValue(REGVAL_CALLING_MODE, fEnable ? CALLING_MODE_GATEKEEPER : CALLING_MODE_DIRECT );
								relogonRequired = true;
							}

							bool bUsingPhoneNum = FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PHONE_NUMBERS );
							bool bUsingAccount = FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_ACCOUNT );

							ConfPolicies::eGKAddressingMode	addressingMode;

							if( bUsingPhoneNum && bUsingAccount )
							{
								addressingMode = ConfPolicies::GKAddressing_Both;
							}
							else if( bUsingPhoneNum )
							{
								addressingMode = ConfPolicies::GKAddressing_PhoneNum;
							}
							else if( bUsingAccount )
							{
								addressingMode = ConfPolicies::GKAddressing_Account;
							}
							else
							{
								addressingMode = ConfPolicies::GKAddressing_Invalid;
							}

							if( (s_InitialbUsingPhoneNum != bUsingPhoneNum) ||
								(s_InitialbUsingAccount != bUsingAccount) )
							{
									// Set the calling mode
								reConf.SetValue(REGVAL_GK_METHOD, addressingMode );
								relogonRequired = true;
							}

							RegEntry reULS(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);

							GetDlgItemTextTrimmed( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER, buffer, CCHMAX( buffer ) );

							if( lstrcmp( buffer, reULS.GetString( REGVAL_ULS_PHONENUM_NAME ) ) != 0 )
							{
								reULS.SetValue( REGVAL_ULS_PHONENUM_NAME, buffer );
								relogonRequired = true;
							}

							GetDlgItemTextTrimmed( hDlg, IDE_CALLOPT_GK_ACCOUNT, buffer, CCHMAX( buffer ) );

							if( lstrcmp( buffer, reULS.GetString( REGVAL_ULS_GK_ACCOUNT ) ) != 0 )
							{
								reULS.SetValue( REGVAL_ULS_GK_ACCOUNT, buffer );
								relogonRequired = true;
							}
						}

						if( relogonRequired )
						{
							//	This means that we need to log on to the gatekeeper with this new changed info...

							reConf.FlushKey();
															
							if( fEnable )
							{
								if( s_fEnableGk )
								{
									//	We are already logged on to the gatekeeper so we must log off first...
									GkLogoff();
								}

								GkLogon();	
							}
							else
							{
								//	We are now in direct mode, we should log off the GateKeeper....
								GkLogoff();
								SetGkLogonState( NM_GK_NOT_IN_GK_MODE );
							}

							//	Update the status Bar...
							CConfStatusBar* pStatusBar = CConfStatusBar::GetInstance();								

							if( pStatusBar )
							{
								pStatusBar->Update();
							}
						}

						EndDialog( hDlg, IDOK );
					}
				}
				break;

				case IDCANCEL:
				{
					EndDialog( hDlg, IDCANCEL );
				}					
				break;

				default:
					break;

			}
			break;

		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, _rgHelpIdsCalling);
			break;

		case WM_HELP:
			DoHelp(lParam, _rgHelpIdsCalling);
			break;

		case WM_DESTROY:
			s_hDlgUserInfo = NULL;
			break;

		default:
			break;
	}

	return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\trackbar.h ===
#ifndef _TRACKBAR_H_
#define _TRACKBAR_H_

#define TRB_HORZ_W	150
#define TRB_HORZ_H	30

#define TRB_VERT_W	30
// #define TRB_VERT_H	150
#define TRB_VERT_H	140

// audio control group box
#define AC_VERT_H	40	// height
#define AC_VERT_W	20	// width
#define AC_VERT_M_X	6	// margin in x
#define AC_VERT_M_Y	16	// margin in y

#define TRB_CAPTION_X_MARGIN	4
#define TRB_CAPTION_Y_MARGIN	0


typedef struct tagTrackBarInfo
{
	WORD	wId;
	HWND	hWnd;
	HWND	hWndParent;
	DWORD	dwStyle;
	BOOL	fDlgUnit;
	POINT	pt;
	SIZE	size;
	WORD	wMin;
	WORD	wMax;
	WORD	wCurrPos;
	WORD	wTickFreq;
	WORD	wPageSize;
	// description
	PTSTR	pszTitle;
	PTSTR	pszMin;
	PTSTR	pszMid;
	PTSTR	pszMax;
}
	TRBARINFO;


enum
{
	UITB_CPU_ALLOC,			// cpu allocation
	UITB_NETWORK_BW,		// network bandwidth
	UITB_SILENCE_LEVEL_PS,	// silence threshold in property sheet
	UITB_SILENCE_LIMIT,		// silence buffer count
	UITB_SPEAKER_VOLUME,	// playback volume control
	UITB_RECORDER_VOLUME,		// recording volume control
	UITB_SPEAKER_VOLUME_MAIN,	// playback volume control
	UITB_RECORDER_VOLUME_MAIN,// recording volume control
	UITB_SILENCE_LEVEL_MAIN,// silence threshold in main UI window
	UITB_SILENCE_LIMIT_MAIN,
	UITB_NumOfSliders
};


extern TRBARINFO g_TrBarInfo[UITB_NumOfSliders];

#define ReversePos(p)  (((p)->wMax - (p)->wCurrPos) + (p)->wMin)

extern HWND g_hChkbSpkMute;
extern HWND g_hChkbRecMute;
extern HWND g_hChkbAutoDet;
#define g_hTrbSpkVol		(g_TrBarInfo[UITB_SPEAKER_VOLUME_MAIN].hWnd)
#define g_hTrbRecVol		(g_TrBarInfo[UITB_RECORDER_VOLUME_MAIN].hWnd)
#define g_hTrbSilenceLevel	(g_TrBarInfo[UITB_SILENCE_LEVEL_MAIN].hWnd)
#define g_hTrbSilenceLimit	(g_TrBarInfo[UITB_SILENCE_LIMIT_MAIN].hWnd)

BOOL CreateTrBar ( HWND, TRBARINFO *, BOOL, UINT );
LRESULT TrBarNotify ( WPARAM, LPARAM );
TRBARINFO *LocateTrBar ( HWND );
TRBARINFO *LocateTrBarByParent ( HWND );
void DrawTrBarCaption ( HWND );
BOOL CALLBACK PlayVolumeDlgProc ( HWND, UINT, WPARAM, LPARAM );
BOOL CALLBACK RecordVolumeDlgProc ( HWND, UINT, WPARAM, LPARAM );
void TrBarConvertDlgUnitToPixelUnit ( void );
BOOL DockVolumeDlg ( int, BOOL );
static BOOL CalcVolumeDlgRect ( int, RECT * );


#endif // _TRACKBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\ulswizrd.h ===
#ifndef _ULSWIZRD_H_
#define _ULSWIZRD_H_

// same as INTERNET_MAX_USER_NAME_LENGTH in wininet.h.
#define MAX_SERVER_NAME_LENGTH	128
#define MAX_FIRST_NAME_LENGTH	128
#define MAX_LAST_NAME_LENGTH	128
#define MAX_EMAIL_NAME_LENGTH	128
#define MAX_UID_LENGTH          256
#define MAX_LOCATION_NAME_LENGTH	128
#define MAX_PHONENUM_LENGTH	128
#define MAX_COMMENTS_LENGTH		256
#define	UI_COMMENTS_LENGTH		60	// ;Internal
#define MAX_CLNTSTRING_LENGTH	256 //max of above
//SS: username is concatenated first name with last name with space in between
#define MAX_USER_NAME_LENGTH	(MAX_FIRST_NAME_LENGTH + MAX_LAST_NAME_LENGTH + sizeof (TCHAR))

// Wizard

typedef struct tag_ULS_CONF
{
    DWORD   dwFlags;
    BOOL    fDontPublish;
    TCHAR   szServerName[MAX_SERVER_NAME_LENGTH];
    TCHAR   szFirstName[MAX_FIRST_NAME_LENGTH];
    TCHAR	szLastName[MAX_LAST_NAME_LENGTH];
    TCHAR   szEmailName[MAX_EMAIL_NAME_LENGTH];
    TCHAR	szLocation[MAX_LOCATION_NAME_LENGTH];
    TCHAR	szComments[MAX_COMMENTS_LENGTH];
	TCHAR	szUserName[MAX_USER_NAME_LENGTH];
}
    ULS_CONF;


#define ULSCONF_F_PUBLISH           0X00000001UL
#define ULSCONF_F_SERVER_NAME       0X00000002UL
#define ULSCONF_F_FIRST_NAME        0X00000004UL
#define ULSCONF_F_EMAIL_NAME        0X00000008UL
#define ULSCONF_F_LAST_NAME         0X00000010UL
#define ULSCONF_F_LOCATION	        0X00000020UL
#define ULSCONF_F_COMMENTS	        0X00000080UL
#define ULSCONF_F_USER_NAME			0x00000100UL

#define ULSWIZ_F_SHOW_BACK          0X00010000UL
#define ULSWIZ_F_NO_FINISH          0X00020000UL

class CULSWizard;

class CWizDirectCallingSettings
{
private:
	static HWND s_hDlg;
	CULSWizard* m_pWiz;
	ULS_CONF*	m_pConf;

	TCHAR m_szInitialServerName[MAX_SERVER_NAME_LENGTH];
	bool m_bInitialEnableGateway;
	
public:
	CWizDirectCallingSettings( CULSWizard* pWiz ) : m_pWiz( pWiz ) { 
		memset(m_szInitialServerName,0,sizeof(m_szInitialServerName)/sizeof(m_szInitialServerName[0])); }
	void SetULS_CONF( ULS_CONF* pConf ) { m_pConf = pConf; }
	static INT_PTR APIENTRY StaticDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
	static HWND GetHwnd(){ return s_hDlg; }
	static bool IsGatewayNameInvalid();
	static void OnWizFinish();
	


private:
	INT_PTR APIENTRY _DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
	BOOL _OnInitDialog();
	BOOL _OnSetActive();
	BOOL _OnKillActive();
	BOOL _OnWizBack();
	BOOL _OnWizNext();
	BOOL _OnWizFinish();
	BOOL _OnCommand( WPARAM wParam, LPARAM lParam );
	void _SetWizButtons();

};


class CULSWizard
{

CWizDirectCallingSettings	m_WizDirectCallingSettings;


public:

	CULSWizard::CULSWizard() : m_WizDirectCallingSettings( this )							
							   { ; }

    HRESULT GetWizardPages( PROPSHEETPAGE **, ULONG *, ULS_CONF **);
    HRESULT ReleaseWizardPages( PROPSHEETPAGE *);
    HRESULT SetConfig( ULS_CONF * );
    HRESULT GetConfig( ULS_CONF * );
};

#endif // _ULSWIZRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\upropdlg.h ===
/****************************************************************************
*
*    FILE:     UPropDlg.h
*
*    CREATED:  Chris Pirich (ChrisPi) 6-18-96
*
****************************************************************************/

#ifndef _UPROPDLG_H_
#define _UPROPDLG_H_


// 2 pages
#define PSP_MAX     2

struct UPROPDLGENTRY
{
	UINT	uProperty;
	LPTSTR	pszValue;
};
typedef UPROPDLGENTRY* PUPROPDLGENTRY;

class CUserPropertiesDlg
{
protected:
	HWND			m_hwndParent;
	HWND			m_hwnd;
	PUPROPDLGENTRY	m_pUPDE;
	int				m_nProperties;
	LPTSTR			m_pszName;
	UINT			m_uIcon;
	HICON			m_hIcon;
	PCCERT_CONTEXT	m_pCert;

	BOOL			OnPropertiesMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
	BOOL			OnCredentialsMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
	BOOL			OnInitPropertiesDialog();
	BOOL			OnInitCredentialsDialog();

	// Handlers:
	BOOL			OnOk();

public:
	
	// Methods:
					CUserPropertiesDlg(	HWND hwndParent,
										UINT uIcon);
					~CUserPropertiesDlg()	{ ::DestroyIcon(m_hIcon);	};
	INT_PTR	DoModal(PUPROPDLGENTRY pUPDE,
		            int nProperties,
		            LPTSTR pszName,
		            PCCERT_CONTEXT pCert);

	static INT_PTR CALLBACK UserPropertiesDlgProc(	HWND hDlg,
												UINT uMsg,
												WPARAM wParam,
												LPARAM lParam);
	static INT_PTR CALLBACK UserCredentialsDlgProc(	HWND hDlg,
												UINT uMsg,
												WPARAM wParam,
												LPARAM lParam);
};

#endif // _UPROPDLG_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\upropdlg.cpp ===
#include "precomp.h"

/****************************************************************************
*
*    FILE:     UPropDlg.cpp
*
*    CREATED:  Chris Pirich (ChrisPi) 6-18-96
*
*    CONTENTS: CUserPropertiesDlg object
*
****************************************************************************/

#include "resource.h"
#include "UPropDlg.h"
#include "certui.h"
#include "conf.h"

/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   CUserPropertiesDlg()
*
*    PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CUserPropertiesDlg::CUserPropertiesDlg(    HWND hwndParent,
                                        UINT uIcon):
    m_hwndParent    (hwndParent),
    m_uIcon         (uIcon),
    m_pCert         (NULL)
{
    DebugEntry(CUserPropertiesDlg::CUserPropertiesDlg);

    m_hIcon = ::LoadIcon(    ::GetInstanceHandle(),
                            MAKEINTRESOURCE(m_uIcon));

    DebugExitVOID(CUserPropertiesDlg::CUserPropertiesDlg);
}

/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   DoModal()
*
*    PURPOSE:  Brings up the modal dialog box
*
****************************************************************************/

INT_PTR CUserPropertiesDlg::DoModal
(
    PUPROPDLGENTRY  pUPDE,
    int             nProperties,
    LPTSTR          pszName,
    PCCERT_CONTEXT  pCert
)
{
    int             i;

    DBGENTRY(CUserPropertiesDlg::DoModal);

    m_pUPDE         = pUPDE;
    m_nProperties   = nProperties;
    m_pszName       = pszName;
    m_pCert         = pCert;

    PROPSHEETPAGE psp[PSP_MAX];
    for (i = 0; i < PSP_MAX; i++)
    {
        InitStruct(&psp[i]);
    }

    psp[0].dwFlags               = PSP_DEFAULT;
    psp[0].hInstance             = ::GetInstanceHandle();
    psp[0].pszTemplate           = MAKEINTRESOURCE(IDD_USER_PROPERTIES);
    psp[0].pfnDlgProc            = CUserPropertiesDlg::UserPropertiesDlgProc;
    psp[0].lParam                = (LPARAM) this;

    i = 1;

    if (pCert)
    {
        psp[i].dwFlags               = PSP_DEFAULT;
        psp[i].hInstance             = ::GetInstanceHandle();
        psp[i].pszTemplate           = MAKEINTRESOURCE(IDD_USER_CREDENTIALS);
        psp[i].pfnDlgProc            = CUserPropertiesDlg::UserCredentialsDlgProc;
        psp[i].lParam                = (LPARAM) this;
        i++;
    }


    PROPSHEETHEADER psh;
    InitStruct(&psh);

    psh.dwFlags         = PSH_NOAPPLYNOW | PSH_PROPTITLE | PSH_PROPSHEETPAGE;
    psh.hwndParent      = m_hwndParent;
    psh.hInstance       = ::GetInstanceHandle();
    psh.pszCaption      = m_pszName;

    psh.nPages =    i;

    ASSERT(0 == psh.nStartPage);
    psh.ppsp = psp;

    return ::PropertySheet(&psh);
}

/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   UserPropertiesDlgProc()
*
*    PURPOSE:  Dialog Proc - handles all messages
*
****************************************************************************/

INT_PTR CALLBACK CUserPropertiesDlg::UserPropertiesDlgProc(HWND hDlg,
                                                        UINT uMsg,
                                                        WPARAM wParam,
                                                        LPARAM lParam)
{
    BOOL bMsgHandled = FALSE;

    // uMsg may be any value.
    // wparam may be any value.
    // lparam may be any value.

    ASSERT(IS_VALID_HANDLE(hDlg, WND));

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ASSERT(NULL != lParam);
            CUserPropertiesDlg* pupd = (CUserPropertiesDlg*)
                                            ((PROPSHEETPAGE*) lParam)->lParam;
            ASSERT(NULL != pupd);
            pupd->m_hwnd = hDlg;
            bMsgHandled = pupd->OnInitPropertiesDialog();
            break;
        }

        default:
        {
#if 0
            CUserPropertiesDlg* pupd = (CUserPropertiesDlg*) ::GetWindowLongPtr(
                                                                    hDlg,
                                                                    DWLP_USER);

            if (NULL != pupd)
            {
                bMsgHandled = pupd->OnPropertiesMessage(uMsg, wParam, lParam);
            }
#endif // 0
        }
    }

    return bMsgHandled;
}

/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   UserCredentialsDlgProc()
*
*    PURPOSE:  Dialog Proc - handles all messages
*
****************************************************************************/

INT_PTR CALLBACK CUserPropertiesDlg::UserCredentialsDlgProc(HWND hDlg,
                                                        UINT uMsg,
                                                        WPARAM wParam,
                                                        LPARAM lParam)
{
    BOOL bMsgHandled = FALSE;

    // uMsg may be any value.
    // wparam may be any value.
    // lparam may be any value.

    ASSERT(IS_VALID_HANDLE(hDlg, WND));

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ASSERT(NULL != lParam);
            CUserPropertiesDlg* pupd = (CUserPropertiesDlg*)
                                            ((PROPSHEETPAGE*) lParam)->lParam;
            ASSERT(NULL != pupd);
            pupd->m_hwnd = hDlg;
            ::SetWindowLongPtr(hDlg, DWLP_USER, (DWORD_PTR)pupd);
            bMsgHandled = pupd->OnInitCredentialsDialog();
            break;
        }

        default:
        {
            CUserPropertiesDlg* pupd = (CUserPropertiesDlg*) ::GetWindowLongPtr(
                                                                    hDlg,
                                                                    DWLP_USER);

            if (NULL != pupd)
            {
                bMsgHandled = pupd->OnCredentialsMessage(uMsg, wParam, lParam);
            }
        }
    }

    return bMsgHandled;
}





/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   OnInitPropertiesDialog()
*
*    PURPOSE:  processes WM_INITDIALOG
*
****************************************************************************/

BOOL CUserPropertiesDlg::OnInitPropertiesDialog()
{
    ASSERT(m_hwnd);

    // Set the proper font (for DBCS systems)
    ::SendDlgItemMessage(m_hwnd, IDC_UPROP_NAME, WM_SETFONT, (WPARAM) g_hfontDlg, 0);

    ::SetDlgItemText(m_hwnd, IDC_UPROP_NAME, m_pszName);
    ::SendDlgItemMessage(    m_hwnd,
                            IDC_UPROP_ICON,
                            STM_SETIMAGE,
                            IMAGE_ICON,
                            (LPARAM) m_hIcon);
    TCHAR szBuffer[MAX_PATH];
    for (int i = 0; i < m_nProperties; i++)
    {
        // Fill in property:
        if (::LoadString(    ::GetInstanceHandle(),
                            m_pUPDE[i].uProperty,
                            szBuffer,
                            ARRAY_ELEMENTS(szBuffer)))
        {
            // NOTE: relies on consecutive control ID's
            ::SetDlgItemText(m_hwnd, IDC_UP_PROP1 + i, szBuffer);
        }

        ::SendDlgItemMessage(m_hwnd, IDC_UP_VALUE1 + i, WM_SETFONT,
                (WPARAM) g_hfontDlg, 0);

        // Fill in value:
        ASSERT(NULL != m_pUPDE[i].pszValue);
        if (0 == HIWORD(m_pUPDE[i].pszValue))
        {
            if (::LoadString(    ::GetInstanceHandle(),
                                PtrToUint(m_pUPDE[i].pszValue),
                                szBuffer,
                                ARRAY_ELEMENTS(szBuffer)))
            {
                // NOTE: relies on consecutive control ID's
                ::SetDlgItemText(m_hwnd, IDC_UP_VALUE1 + i, szBuffer);
            }
        }
        else
        {
            // NOTE: relies on consecutive control ID's
            ::SetDlgItemText(m_hwnd, IDC_UP_VALUE1 + i, m_pUPDE[i].pszValue);
        }
    }
    return TRUE;
}

/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   OnInitCredentialsDialog()
*
*    PURPOSE:  processes WM_INITDIALOG
*
****************************************************************************/

BOOL CUserPropertiesDlg::OnInitCredentialsDialog()
{
    ASSERT(m_hwnd);

    // Set the proper font (for DBCS systems)
    ::SendDlgItemMessage(m_hwnd, IDC_UPROP_NAME, WM_SETFONT, (WPARAM) g_hfontDlg, 0);

    ::SetDlgItemText(m_hwnd, IDC_UPROP_NAME, m_pszName);
    ::SendDlgItemMessage(    m_hwnd,
                            IDC_UPROP_ICON,
                            STM_SETIMAGE,
                            IMAGE_ICON,
                            (LPARAM) m_hIcon);

    ASSERT(m_pCert != NULL);

    if ( TCHAR * pSecText = FormatCert ( m_pCert->pbCertEncoded,
                                        m_pCert->cbCertEncoded ))
    {
        ::SetDlgItemText(m_hwnd, IDC_AUTH_EDIT, pSecText );
        delete pSecText;
    }
    else
    {
        ERROR_OUT(("OnInitCredentialsDialog: FormatCert failed"));
    }
    return TRUE;
}




/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   OnPropertiesMessage()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CUserPropertiesDlg::OnPropertiesMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bRet = FALSE;

    ASSERT(m_hwnd);

    switch (uMsg)
    {
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    bRet = OnOk();
                    break;
                }

                case IDCANCEL:
                {
                    // ::EndDialog(m_hwnd, LOWORD(wParam));
                    bRet = TRUE;
                    break;
                }

            }
            break;
        }

        default:
            break;
    }

    return bRet;
}

/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   OnCredentialsMessage()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CUserPropertiesDlg::OnCredentialsMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bRet = FALSE;

    ASSERT(m_hwnd);

    switch (uMsg)
    {
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    bRet = OnOk();
                    break;
                }

                case IDCANCEL:
                {
                    // ::EndDialog(m_hwnd, LOWORD(wParam));
                    bRet = TRUE;
                    break;
                }

                case IDC_SEC_VIEWCREDS:
                {
                    ViewCertDlg ( m_hwnd, m_pCert );
                    break;
                }
            }
            break;
        }

        default:
            break;
    }

    return bRet;
}



/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   OnOk()
*
*    PURPOSE:  processes the WM_COMMAND,IDOK message
*
****************************************************************************/

BOOL CUserPropertiesDlg::OnOk()
{
    DebugEntry(CUserPropertiesDlg::OnOk);
    BOOL bRet = TRUE;

    DebugExitBOOL(CUserPropertiesDlg::OnOk, bRet);
    return bRet;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\videocpl.cpp ===
// File: videocpl.cpp

#include "precomp.h"

#include "confcpl.h"
#include "help_ids.h"
#include "vidview.h"
#include "confroom.h"


static const DWORD aContextHelpIds[] = {

	IDC_SENDRECEIVE_GROUP,			IDH_VIDEO_SEND_RECEIVE,
	IDC_VIDEO_AUTOSEND, 			IDH_VIDEO_AUTO_SEND,
	IDC_VIDEO_AUTORECEIVE,			IDH_VIDEO_AUTO_RECEIVE,

	IDC_VIDEO_SQCIF,				IDH_VIDEO_SQCIF,
	IDC_VIDEO_QCIF, 				IDH_VIDEO_QCIF,
	IDC_VIDEO_CIF,					IDH_VIDEO_CIF,

	IDC_VIDEO_QUALITY_DESC, 		IDH_VIDEO_QUALITY,
	IDC_VIDEO_QUALITY,				IDH_VIDEO_QUALITY,
	IDC_VIDEO_QUALITY_LOW,			IDH_VIDEO_QUALITY,
	IDC_VIDEO_QUALITY_HIGH, 		IDH_VIDEO_QUALITY,

	IDC_CAMERA_GROUP,				IDH_VIDEO_CAMERA,
	IDC_COMBOCAP,					IDH_VIDEO_CAPTURE,
	IDC_VIDEO_SOURCE,				IDH_VIDEO_SOURCE,
	IDC_VIDEO_FORMAT,				IDH_VIDEO_FORMAT,
	IDC_VIDEO_MIRROR,               IDH_VIDEO_MIRROR,
	
	0, 0   // terminator
};

INT_PTR APIENTRY VideoDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	//BAD KARMA: this stuff should be in a struct and stored in "GWL_USERDATA"
	static PROPSHEETPAGE * ps;
	static BOOL fAllowSend = FALSE;
	static BOOL fAllowReceive = FALSE;
	static BOOL fOldAutoSend = FALSE;
	static BOOL fOldAutoReceive = FALSE;
	static BOOL fOldOpenLocalWindow = FALSE;
	static BOOL fOldCloseLocalWindow = FALSE;
	static DWORD dwOldQuality = FALSE;
	static DWORD dwNewQuality = 0;
	static DWORD dwOldFrameSize = 0;
	static DWORD dwNewFrameSize = 0;
	static BOOL fHasSourceDialog = FALSE;
	static BOOL fHasFormatDialog = FALSE;
	static BOOL dwFrameSizes = 0;
	static int nNumCapDev = 0;
	static DWORD dwOldCapDevID = 0;
	static DWORD dwNewCapDevID = 0;
	static int nMaxCapDevNameLen;
	static TCHAR *pszCapDevNames = (TCHAR *)NULL;
	static DWORD *pdwCapDevIDs = (DWORD *)NULL;
	static LPSTR szOldCapDevName = (LPSTR)NULL;
	static BOOL fOldMirror = FALSE;

	static CVideoWindow *m_pLocal  = NULL;
	static CVideoWindow *m_pRemote = NULL;


	RegEntry rePolicies( POLICIES_KEY, HKEY_CURRENT_USER );

	switch (message) {
		case WM_INITDIALOG:
		{
			RegEntry reVideo(VIDEO_KEY, HKEY_CURRENT_USER);
			LPSTR szTemp = (LPSTR)NULL;

			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;

			CConfRoom* pcr = ::GetConfRoom();
			ASSERT(NULL != pcr);
			m_pLocal  = pcr->GetLocalVideo();
			m_pRemote = pcr->GetRemoteVideo();
			ASSERT(NULL != m_pLocal && NULL != m_pRemote);

			fAllowSend = m_pLocal->IsXferAllowed();
			fAllowReceive = m_pRemote->IsXferAllowed();
			fOldAutoSend = m_pLocal->IsAutoXferEnabled();
			fOldAutoReceive = m_pRemote->IsAutoXferEnabled();
			fOldMirror = m_pLocal->GetMirror();
			dwFrameSizes = m_pLocal->GetFrameSizes();
			dwNewFrameSize = dwOldFrameSize = m_pLocal->GetFrameSize();
			dwNewQuality = dwOldQuality = m_pRemote->GetImageQuality();

			// If we have one or more capture devices installed, display its or their
			// names in a combo box. The user will be asked to select the device he/she
			// wants to use.

			if (nNumCapDev = m_pLocal->GetNumCapDev())
			{
				// Get the ID of the device currently selected
				nMaxCapDevNameLen = m_pLocal->GetMaxCapDevNameLen();
				dwOldCapDevID = reVideo.GetNumber(REGVAL_CAPTUREDEVICEID, ((UINT)-1));
				szTemp = reVideo.GetString(REGVAL_CAPTUREDEVICENAME);
				if (szTemp && (szOldCapDevName = (LPSTR)LocalAlloc(LPTR, sizeof(TCHAR) * nMaxCapDevNameLen)))
					lstrcpy(szOldCapDevName, szTemp);
				dwNewCapDevID = m_pLocal->GetCurrCapDevID();
				if ((!((dwOldCapDevID == ((UINT)-1)) || (dwNewCapDevID != dwOldCapDevID))) || (dwNewCapDevID == ((UINT)-1)))
					dwNewCapDevID = dwOldCapDevID;


				if (nMaxCapDevNameLen && (pdwCapDevIDs = (DWORD *)LocalAlloc(LPTR, nNumCapDev * (sizeof(TCHAR) * nMaxCapDevNameLen + sizeof(DWORD)))))
				{
					int i;

					pszCapDevNames = (TCHAR *)(pdwCapDevIDs + nNumCapDev);
					// Fill up the arrey of device IDs and names.
					// Only enabled capture devices are returned
					m_pLocal->EnumCapDev(pdwCapDevIDs, pszCapDevNames, nNumCapDev);

					// Are we still Ok?
					nNumCapDev = m_pLocal->GetNumCapDev();

					// Fill up the combo box with the capture devices names
					for (i=0; i<nNumCapDev; i++)
						SendMessage(GetDlgItem(hDlg, IDC_COMBOCAP), CB_INSERTSTRING, i, (LPARAM)(pszCapDevNames + i * nMaxCapDevNameLen));

					// Set the default capture device in the combo box
					for (i=0; i<nNumCapDev; i++)
					{
						if (!i)
						{
							SendMessage(GetDlgItem(hDlg, IDC_COMBOCAP), CB_SETCURSEL, 0, (LPARAM)NULL);
							// If for some reason, no device is registered yet, register one
							if (dwOldCapDevID == ((UINT)-1))
							{
								dwNewCapDevID = pdwCapDevIDs[i];
								reVideo.SetValue(REGVAL_CAPTUREDEVICEID, dwNewCapDevID);
								reVideo.SetValue(REGVAL_CAPTUREDEVICENAME, (LPSTR)(pszCapDevNames + i * nMaxCapDevNameLen));
							}
						}
						else
						{
							if (dwNewCapDevID == pdwCapDevIDs[i])
							{
								// The following will allow us to keep the right device
								// even if its ID has changed (if a lower ID device was
								// removed or added for instance)
								if (lstrcmp(szOldCapDevName, (LPSTR)(pszCapDevNames + i * nMaxCapDevNameLen)) != 0)
								{
									int j;

									// Look for the string in the array of device names
									for (j=0; j<nNumCapDev; j++)
										if (lstrcmp(szOldCapDevName, (LPSTR)(pszCapDevNames + j * nMaxCapDevNameLen)) == 0)
											break;
									if (j<nNumCapDev)
									{
										SendMessage(GetDlgItem(hDlg, IDC_COMBOCAP), CB_SETCURSEL, j, (LPARAM)NULL);
										if (dwNewCapDevID != (DWORD)j)
										{
											// The device ID has changed but the device name was found
											// Set the current device ID to the new onew
											reVideo.SetValue(REGVAL_CAPTUREDEVICEID, dwNewCapDevID = (DWORD)j);
											m_pLocal->SetCurrCapDevID(dwNewCapDevID);
										}
									}
									else
									{
										// This is either a totally new device or an updated version of the
										// driver. We should store the new string for that device
										reVideo.SetValue(REGVAL_CAPTUREDEVICENAME, (LPSTR)(pszCapDevNames + i * nMaxCapDevNameLen));
										SendMessage(GetDlgItem(hDlg, IDC_COMBOCAP), CB_SETCURSEL, i, (LPARAM)NULL);
									}
								}
								else
									SendMessage(GetDlgItem(hDlg, IDC_COMBOCAP), CB_SETCURSEL, i, (LPARAM)NULL);
							}
							else
							{
								if ((dwNewCapDevID >= (DWORD)nNumCapDev) || (dwNewCapDevID != pdwCapDevIDs[dwNewCapDevID]))
								{
									// Device is missing! Use the first one as the new default
									dwNewCapDevID = pdwCapDevIDs[0];
									reVideo.SetValue(REGVAL_CAPTUREDEVICEID, dwNewCapDevID);
									reVideo.SetValue(REGVAL_CAPTUREDEVICENAME, (LPSTR)(pszCapDevNames));
									m_pLocal->SetCurrCapDevID(dwNewCapDevID);
								}
							}
						}
					}
				}
			}
			else
				EnableWindow(GetDlgItem(hDlg, IDC_COMBOCAP), FALSE);

			// The dialog caps need to be evaluated
			fHasSourceDialog = m_pLocal->IsXferEnabled() &&
					m_pLocal->HasDialog(NM_VIDEO_SOURCE_DIALOG);
			fHasFormatDialog = m_pLocal->IsXferEnabled() &&
					m_pLocal->HasDialog(NM_VIDEO_FORMAT_DIALOG);

			///////////////////////////////////////////////////////////
			//
			// Sending and Receiving Video
			//

			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_AUTOSEND),
				fAllowSend && (0 != dwFrameSizes));
			CheckDlgButton(hDlg, IDC_VIDEO_AUTOSEND,
				fAllowSend && fOldAutoSend);

			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_AUTORECEIVE), fAllowReceive);
			CheckDlgButton(hDlg, IDC_VIDEO_AUTORECEIVE,
					fAllowReceive && fOldAutoReceive);



			///////////////////////////////////////////////////////////
			//
			// Video Image
			//


			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_SQCIF),
					fAllowSend && (dwFrameSizes & FRAME_SQCIF));
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_QCIF),
					fAllowSend && (dwFrameSizes & FRAME_QCIF));
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_CIF),
					fAllowSend && (dwFrameSizes & FRAME_CIF));

			switch (dwOldFrameSize & dwFrameSizes)
			{
				case FRAME_SQCIF:
					CheckDlgButton(hDlg, IDC_VIDEO_SQCIF, TRUE);
					break;

				case FRAME_CIF:
					CheckDlgButton(hDlg, IDC_VIDEO_CIF, TRUE);
					break;

				case FRAME_QCIF:
				default:
					CheckDlgButton(hDlg, IDC_VIDEO_QCIF, TRUE);
					break;
			}

			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_QUALITY),
					fAllowReceive);
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_QUALITY_DESC),
					fAllowReceive);
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_QUALITY_LOW),
					fAllowReceive);
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_QUALITY_HIGH),
					fAllowReceive);
			SendDlgItemMessage (hDlg, IDC_VIDEO_QUALITY, TBM_SETRANGE, FALSE,
				MAKELONG (NM_VIDEO_MIN_QUALITY, NM_VIDEO_MAX_QUALITY ));

			SendDlgItemMessage (hDlg, IDC_VIDEO_QUALITY, TBM_SETTICFREQ,
				( NM_VIDEO_MAX_QUALITY - NM_VIDEO_MIN_QUALITY )
														/ 8, 0 );

			SendDlgItemMessage (hDlg, IDC_VIDEO_QUALITY, TBM_SETPAGESIZE,
				0, ( NM_VIDEO_MAX_QUALITY - NM_VIDEO_MIN_QUALITY ) / 8 );

			SendDlgItemMessage (hDlg, IDC_VIDEO_QUALITY, TBM_SETLINESIZE,
				0, 1 );

			SendDlgItemMessage (hDlg, IDC_VIDEO_QUALITY, TBM_SETPOS, TRUE,
								dwOldQuality );


			///////////////////////////////////////////////////////////
			//
			// Video Card and Camera
			//

			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_SOURCE), fAllowSend && fHasSourceDialog);
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_FORMAT), fAllowSend && fHasFormatDialog);

			// mirror video button
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_MIRROR), fAllowSend);
			Button_SetCheck(GetDlgItem(hDlg, IDC_VIDEO_MIRROR), fOldMirror);

			return (TRUE);
		}

		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_APPLY:
				{
					BOOL fChecked;
					
					///////////////////////////////////////////////////////////
					//
					// Sending and Receiving Video
					//

					if (fAllowSend)
					{
						fChecked = IsDlgButtonChecked(hDlg, IDC_VIDEO_AUTOSEND);

						if ( fChecked != fOldAutoSend )
						{
							m_pLocal->EnableAutoXfer(fChecked);
							g_dwChangedSettings |= CSETTING_L_VIDEO;
						}
					}


					if (fAllowReceive)
					{
						fChecked = IsDlgButtonChecked(hDlg, IDC_VIDEO_AUTORECEIVE);

						if ( fChecked != fOldAutoReceive ) {
							m_pRemote->EnableAutoXfer(fChecked);
							g_dwChangedSettings |= CSETTING_L_VIDEO;
						}
					}

					///////////////////////////////////////////////////////////
					//
					// Video Image
					//

					if (dwNewFrameSize != dwOldFrameSize )
					{
						g_dwChangedSettings |= CSETTING_L_VIDEOSIZE;
					}

					if ( dwNewQuality != dwOldQuality )
					{
						g_dwChangedSettings |= CSETTING_L_VIDEO;
					}

					///////////////////////////////////////////////////////////
					//
					// Capture Device
					//

					if (dwNewCapDevID != dwOldCapDevID)
					{
						g_dwChangedSettings |= CSETTING_L_CAPTUREDEVICE;
					}

					break;
				}

				case PSN_RESET:
				{
					// restore settings
					if ( dwNewQuality != dwOldQuality )
					{
						m_pRemote->SetImageQuality(dwOldQuality);
					}

					if ( dwNewFrameSize != dwOldFrameSize )
					{
						m_pLocal->SetFrameSize(dwOldFrameSize);
					}

					if (dwNewCapDevID != dwOldCapDevID)
					{
						// Set the capture device ID back to its old value
						RegEntry reVideo(VIDEO_KEY, HKEY_CURRENT_USER);
						reVideo.SetValue(REGVAL_CAPTUREDEVICEID, dwOldCapDevID);
						reVideo.SetValue(REGVAL_CAPTUREDEVICENAME, szOldCapDevName);

						m_pLocal->SetCurrCapDevID(dwOldCapDevID);
					}

					m_pLocal->SetMirror(fOldMirror);
				}
			}
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_VIDEO_SOURCE:
					if ( HIWORD(wParam) == BN_CLICKED ) {
						m_pLocal->ShowDialog(NM_VIDEO_SOURCE_DIALOG);
					}
					break;

				case IDC_VIDEO_FORMAT:
					if ( HIWORD(wParam) == BN_CLICKED ) {
						m_pLocal->ShowDialog(NM_VIDEO_FORMAT_DIALOG);
					}
					break;
				case IDC_VIDEO_SQCIF:
					if (( HIWORD(wParam) == BN_CLICKED )
						&& (dwNewFrameSize != FRAME_SQCIF))
					{
						dwNewFrameSize = FRAME_SQCIF;
						m_pLocal->SetFrameSize(dwNewFrameSize);
					}
					break;
				case IDC_VIDEO_CIF:
					if (( HIWORD(wParam) == BN_CLICKED )
						&& (dwNewFrameSize != FRAME_CIF))
					{
						dwNewFrameSize = FRAME_CIF;
						m_pLocal->SetFrameSize(dwNewFrameSize);
					}
					break;
				case IDC_VIDEO_QCIF:
					if (( HIWORD(wParam) == BN_CLICKED )
						&& (dwNewFrameSize != FRAME_QCIF))
					{
						dwNewFrameSize = FRAME_QCIF;
						m_pLocal->SetFrameSize(dwNewFrameSize);
					}
					break;

				case IDC_VIDEO_MIRROR:
					if ((HIWORD(wParam) == BN_CLICKED))
					{
						BOOL bRet;
						bRet = Button_GetCheck((HWND)lParam);
						if (m_pLocal)
						{
							m_pLocal->SetMirror(bRet);
						}
					}

				case IDC_COMBOCAP:
					if (LBN_SELCHANGE == HIWORD(wParam))
					{
						int index;
						RegEntry reVideo(VIDEO_KEY, HKEY_CURRENT_USER);

						index = (int)SendMessage(GetDlgItem(hDlg, IDC_COMBOCAP), CB_GETCURSEL, 0, 0);
						dwNewCapDevID = pdwCapDevIDs[index];
						reVideo.SetValue(REGVAL_CAPTUREDEVICEID, dwNewCapDevID);
						reVideo.SetValue(REGVAL_CAPTUREDEVICENAME, (LPSTR)(pszCapDevNames + index * nMaxCapDevNameLen));

						if (dwNewCapDevID != (DWORD)m_pLocal->GetCurrCapDevID())
						{
							m_pLocal->SetCurrCapDevID(dwNewCapDevID);

							// The dialog caps need to be reevaluated
							fHasSourceDialog = m_pLocal->IsXferEnabled() &&
									m_pLocal->HasDialog(NM_VIDEO_SOURCE_DIALOG);
							fHasFormatDialog = m_pLocal->IsXferEnabled() &&
									m_pLocal->HasDialog(NM_VIDEO_FORMAT_DIALOG);
							EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_SOURCE), fAllowSend && fHasSourceDialog);
							EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_FORMAT), fAllowSend && fHasFormatDialog);

							// Update the size buttons
							dwFrameSizes = m_pLocal->GetFrameSizes();

							EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_SQCIF), fAllowSend && (dwFrameSizes & FRAME_SQCIF));
							if (dwNewFrameSize & FRAME_SQCIF)
							{
								if (dwFrameSizes & FRAME_SQCIF)
									CheckDlgButton(hDlg, IDC_VIDEO_SQCIF, TRUE);
								else
								{
									if (dwFrameSizes & FRAME_QCIF)
										dwNewFrameSize = FRAME_QCIF;
									else if (dwFrameSizes & FRAME_CIF)
										dwNewFrameSize = FRAME_CIF;
									CheckDlgButton(hDlg, IDC_VIDEO_SQCIF, FALSE);
								}
							}
							else
							{
								CheckDlgButton(hDlg, IDC_VIDEO_SQCIF, FALSE);
							}

							EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_QCIF), fAllowSend && (dwFrameSizes & FRAME_QCIF));
							if (dwNewFrameSize & FRAME_QCIF)
							{
								if (dwFrameSizes & FRAME_QCIF)
									CheckDlgButton(hDlg, IDC_VIDEO_QCIF, TRUE);
								else
								{
									if (dwFrameSizes & FRAME_SQCIF)
									{
										dwNewFrameSize = FRAME_SQCIF;
										CheckDlgButton(hDlg, IDC_VIDEO_SQCIF, TRUE);
									}
									else if (dwFrameSizes & FRAME_CIF)
										dwNewFrameSize = FRAME_CIF;
									CheckDlgButton(hDlg, IDC_VIDEO_QCIF, FALSE);
								}
							}
							else
							{
								CheckDlgButton(hDlg, IDC_VIDEO_QCIF, FALSE);
							}

							EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_CIF), fAllowSend && (dwFrameSizes & FRAME_CIF));
							if (dwNewFrameSize & FRAME_CIF)
							{
								if (dwFrameSizes & FRAME_CIF)
									CheckDlgButton(hDlg, IDC_VIDEO_CIF, TRUE);
								else
								{
									if (dwFrameSizes & FRAME_QCIF)
									{
										dwNewFrameSize = FRAME_QCIF;
										CheckDlgButton(hDlg, IDC_VIDEO_QCIF, TRUE);
									}
									else if (dwFrameSizes & FRAME_SQCIF)
									{
										dwNewFrameSize = FRAME_SQCIF;
										CheckDlgButton(hDlg, IDC_VIDEO_SQCIF, TRUE);
									}
									CheckDlgButton(hDlg, IDC_VIDEO_CIF, FALSE);
								}
							}
							else
							{
								CheckDlgButton(hDlg, IDC_VIDEO_CIF, FALSE);
							}

							m_pLocal->SetFrameSize(dwNewFrameSize);
						}
					}
					break;
			}
			break;

		case WM_HSCROLL:
			if (TB_ENDTRACK == LOWORD(wParam))
			{
				DWORD dwValue = (DWORD)SendDlgItemMessage( hDlg, IDC_VIDEO_QUALITY,
							TBM_GETPOS, 0, 0 );

				if ( dwValue != dwNewQuality ) {
					dwNewQuality = dwValue;
					m_pRemote->SetImageQuality(dwNewQuality);
				}
			}
			break;

		case WM_DESTROY:
			if (pdwCapDevIDs)
			{
				LocalFree(pdwCapDevIDs);
				pdwCapDevIDs = (DWORD *)NULL;
			}
			if (szOldCapDevName)
			{
				LocalFree(szOldCapDevName);
				szOldCapDevName = (LPSTR)NULL;
			}
			break;

		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, aContextHelpIds);
			break;

		case WM_HELP:
			DoHelp(lParam, aContextHelpIds);
			break;
	}
	return (FALSE);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\videowindow.cpp ===
// VideoWindow.cpp : Implementation of CVideoWindowObj
#include "Precomp.h"
#include "VidView.h"
#include "VideoWindow.h"

/////////////////////////////////////////////////////////////////////////////
// CVideoWindowObj


CVideoWindowObj::CVideoWindowObj()
: m_pVideoView( NULL ),
  m_hWndEdit( NULL )
{
	DBGENTRY(CVideoWindowObj::CVideoWindowObj);

	m_bWindowOnly = TRUE;

	DBGEXIT(CVideoWindowObj::CVideoWindowObj);
}

CVideoWindowObj::~CVideoWindowObj()
{
	DBGENTRY(CVideoWindowObj::~CVideoWindowObj);
	if( m_pVideoView )
	{
		delete m_pVideoView;
	}

	DBGEXIT(CVideoWindowObj::~CVideoWindowObj);
}


/*virtual*/ 
HWND CVideoWindowObj::CreateControlWindow(HWND hWndParent, RECT& rcPos)
{

	Create(hWndParent, rcPos);
	if( m_hWnd )
	{
		m_pVideoView = new CVideoView;
		if (NULL != m_pVideoView)
		{
			if (NULL == m_pVideoView->Create(m_hWnd))
			{
				delete m_pVideoView;
				m_pVideoView = NULL;
			}
			else
			{
				m_pVideoView->DeferredInit();
				m_pVideoView->Resize( m_rcPos.left, m_rcPos.top, RectWidth( m_rcPos ), RectHeight( m_rcPos ) );
				m_pVideoView->Show(TRUE);
			}
		}
    }
	else
	{
		ASSERT( 0 );
	}

	return m_hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\videowindow.h ===
// VideoWindow.h : Declaration of the CVideoWindowObj

#ifndef __VIDEOWINDOW_H_
#define __VIDEOWINDOW_H_

#include "resource.h"       // main symbols
#include "NetMeeting.h"

/////////////////////////////////////////////////////////////////////////////
// CVideoWindowObj
class ATL_NO_VTABLE CVideoWindowObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IVideoWindow, &IID_IVideoWindow, &LIBID_NetMeetingLib>,
	public CComControl<CVideoWindowObj>,
	public IPersistStreamInitImpl<CVideoWindowObj>,
	public IOleControlImpl<CVideoWindowObj>,
	public IOleObjectImpl<CVideoWindowObj>,
	public IOleInPlaceActiveObjectImpl<CVideoWindowObj>,
	public IViewObjectExImpl<CVideoWindowObj>,
	public IOleInPlaceObjectWindowlessImpl<CVideoWindowObj>,
	public CComCoClass<CVideoWindowObj, &CLSID_VideoWindow>,
	public ISupportErrorInfoImpl<&IID_IVideoWindow>,
	public IObjectSafetyImpl<CVideoWindowObj, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{

private:
	CVideoView*	m_pVideoView;
	HWND		m_hWndEdit;

public:
	CVideoWindowObj();
	~CVideoWindowObj();

DECLARE_REGISTRY_RESOURCEID(IDR_VIDEOWINDOW)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVideoWindowObj)
	COM_INTERFACE_ENTRY(IVideoWindow)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()

BEGIN_PROP_MAP(CVideoWindowObj)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CVideoWindowObj)
//	CHAIN_MSG_MAP(CComControl<CVideoWindowObj>)
	MESSAGE_HANDLER(WM_PAINT, MyOnPaint)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()

  virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos);

  LRESULT MyOnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
  {
	PAINTSTRUCT ps;
	::BeginPaint(m_hWnd, &ps );

	if( ::IsWindow( m_hWndEdit ) )
	{
		::InvalidateRect(m_hWndEdit, NULL, TRUE);
		::UpdateWindow( m_hWndEdit );
			TRACE_OUT(("MyOnPaint"));
	}
	
	::EndPaint( m_hWnd, &ps );

	return 1;
  }

// IViewObjectEx
	DECLARE_VIEW_STATUS(0)

public:
};

#endif //__VIDEOWINDOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\vidwiz.h ===
#ifndef _VIDWIZ_H
#define _VIDWIZ_H

#include "dcap.h"

// header file for Setup wizard's video capture device selection page



void UpdateVidConfigRegistry();
BOOL NeedVideoPropPage(BOOL fForce);
INT_PTR APIENTRY VidWizDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

BOOL InitVidWiz();
BOOL UnInitVidWiz();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\wab.cpp ===
// File: wab.cpp

#include "precomp.h"
#include "resource.h"

#include "dirutil.h"

#include "wab.h"
#include "wabtags.h"
#include "wabiab.h"
#include "lst.h"
#include "fnobjs.h"

static const int _rgIdMenu[] = {
	IDM_DLGCALL_SPEEDDIAL,
	0
};


// As of VC 6.0 on the Alpha, FreePsz couldn't be passed to a 
// template taking an F&. There is an internal compiler error
// One day, this will be fixed. For now, this call should be
// identical
class FreePszFunctor
{public:
	void operator()( LPTSTR sz ) { FreePsz( sz ); }
};
		



// There is only one instance of this object  (for CreateWabEntry)
CWAB * CWAB::m_spThis = NULL;

/*  C  W  A  B  */
/*-------------------------------------------------------------------------
    %%Function: CWAB
    
-------------------------------------------------------------------------*/
CWAB::CWAB() :
	CALV(IDS_DLGCALL_WAB, II_WAB, _rgIdMenu)
{
	DbgMsg(iZONE_OBJECTS, "CWAB - Constructed(%08X)", this);

	ASSERT(NULL == m_spThis);
	m_spThis = this;

	SetAvailable(NULL != m_pAdrBook);
}

CWAB::~CWAB()
{
	m_spThis = NULL;

	DbgMsg(iZONE_OBJECTS, "CWAB - Destroyed(%08X)", this);
}


///////////////////////////////////////////////////////////////////////////
// CALV methods

	

/*  S H O W  I T E M S  */
/*-------------------------------------------------------------------------
    %%Function: ShowItems
    
-------------------------------------------------------------------------*/
VOID CWAB::ShowItems(HWND hwnd)
{
	CALV::SetHeader(hwnd, IDS_ADDRESS);
	
	ShowNmEntires(hwnd);
}

HRESULT CWAB::ShowNmEntires(HWND hwnd)
{
	HRESULT hr;
	if (!FAvailable())
		return S_FALSE; // nothing to show

	hr = GetContainer();
	if (FAILED(hr))
		return hr;

	hr = EnsurePropTags();
	if (FAILED(hr))
		return hr;

	LPMAPITABLE pAB = NULL;
	hr = m_pContainer->GetContentsTable(0, &pAB);
	if (FAILED(hr) || (NULL == pAB))
		return hr;

	// reset the system to use the correct properties
	ASSERT(NULL != m_pPropTags);
	hr = pAB->SetColumns(GetTags(), 0);
	if (SUCCEEDED(hr))
	{
		// Read all the rows of the table one by one
		hr = pAB->SeekRow(BOOKMARK_BEGINNING, 0, NULL);
	}

	while (S_OK == hr)
	{
		LPSRowSet pRowAB = NULL;
		hr = pAB->QueryRows(1, 0, &pRowAB);
		if (FAILED(hr) || (NULL == pRowAB))
			break;

		int cNumRows = pRowAB->cRows;
		hr = (0 != cNumRows) ? S_OK : S_FALSE;
		if (S_OK == hr)
		{
			LPSPropValue lpProp = &(pRowAB->aRow[0].lpProps[ieidPR_NM_ADDRESS]);
			if (Get_PR_NM_ADDRESS() == lpProp->ulPropTag)
			{
				LPSTR pszName = pRowAB->aRow[0].lpProps[ieidPR_DISPLAY_NAME].Value.lpszA;
				SLPSTRArray * pMVszA = &(lpProp->Value.MVszA);
				if (0 != pMVszA->cValues)
				{
					// Find the default entry
					LPSPropValue lpPropDefault = &(pRowAB->aRow[0].lpProps[ieidPR_NM_DEFAULT]);
					ULONG iDefault = (Get_PR_NM_DEFAULT() == lpPropDefault->ulPropTag)
						? lpPropDefault->Value.ul : 0;
					ASSERT(iDefault <= pMVszA->cValues);
					LPCTSTR pszAddr = pMVszA->lppszA[iDefault];
					pszAddr = PszSkipCallTo(pszAddr);

					// This trick will only work if the sizeof(LPARAM) == sizeof(LPENTRYID)
					LPARAM lParam;
					if (sizeof(LPARAM) == pRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb)
					{
						lParam = * (LPARAM *) pRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
					}
					else
					{
						lParam = 0;
					}

					DlgCallAddItem(hwnd, pszName, pszAddr, II_WAB_CARD, lParam);
				}
			}
		}
		FreeProws(pRowAB);
    }

	pAB->Release();

	return hr;
}


/*  C M D  P R O P E R T I E S  */
/*-------------------------------------------------------------------------
    %%Function: CmdProperties
    
-------------------------------------------------------------------------*/
VOID CWAB::CmdProperties(void)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return;

	LV_ITEM lvi;
	ClearStruct(&lvi);
	lvi.iItem = iItem;
	lvi.mask = LVIF_PARAM;
	if (!ListView_GetItem(GetHwnd(), &lvi))
		return;

	HWND hwnd = GetParent(GetHwnd());
	m_pAdrBook->Details((LPULONG) &hwnd, NULL, NULL,
		    sizeof(LPARAM), (LPENTRYID) &lvi.lParam,
		    NULL, NULL, NULL, 0);

		// this is because we may have changed something in the Details dlg.
	CmdRefresh();

	ListView_SetItemState(GetHwnd(), iItem,
			LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

}

/*  G E T  A D D R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: GetAddrInfo
    
-------------------------------------------------------------------------*/
RAI * CWAB::GetAddrInfo(void)
{
	RAI* pRai = NULL;
	lst<LPTSTR> PhoneNums;
	lst<LPTSTR> EmailNames;
	lst<LPTSTR> ILSServers;

	int iItem = GetSelection();
	if (-1 != iItem)
	{

		LV_ITEM lvi;
		ClearStruct(&lvi);
		lvi.iItem = iItem;
		lvi.mask = LVIF_PARAM;
		if (ListView_GetItem(GetHwnd(), &lvi))
		{

			LPMAPIPROP pMapiProp = NULL;
			ULONG ulObjType = 0;
			HRESULT hr = m_pContainer->OpenEntry( sizeof(LPARAM), 
												  reinterpret_cast<LPENTRYID>(&lvi.lParam), 
												  NULL, 
												  0,
												  &ulObjType, 
												  reinterpret_cast<LPUNKNOWN*>(&pMapiProp)
												);

			if (SUCCEEDED(hr))
			{
				// Email Name
				if (FEnabledNmAddr(NM_ADDR_ALIAS_ID))
				{
					ULONG PropTags[] = { PR_EMAIL_ADDRESS };

					_GetLPSTRProps( EmailNames, PropTags, pMapiProp, ARRAY_ELEMENTS( PropTags ) );
				}


				// Phone number
				if (FEnabledNmAddr(NM_ADDR_ALIAS_E164) || FEnabledNmAddr(NM_ADDR_H323_GATEWAY))
				{

					ULONG PhoneNumPropTags[] = {
						PR_BUSINESS_TELEPHONE_NUMBER,
						PR_HOME_TELEPHONE_NUMBER,
						PR_PRIMARY_TELEPHONE_NUMBER,
						PR_BUSINESS2_TELEPHONE_NUMBER,
						PR_CELLULAR_TELEPHONE_NUMBER,
						PR_RADIO_TELEPHONE_NUMBER,
						PR_CAR_TELEPHONE_NUMBER,
						PR_OTHER_TELEPHONE_NUMBER,
						PR_PAGER_TELEPHONE_NUMBER
					};

					_GetLPSTRProps( PhoneNums, PhoneNumPropTags, pMapiProp, ARRAY_ELEMENTS( PhoneNumPropTags ) );
				}

				if (FEnabledNmAddr(NM_ADDR_ULS))
				{
					enum { iPrNmAddress = 0, iDefaultServer = 1 };
					ULONG PropTags[2];
					PropTags[iPrNmAddress] = Get_PR_NM_ADDRESS();
					PropTags[iDefaultServer] = Get_PR_NM_DEFAULT();

					if( m_pWabObject )
					{
						BYTE* pb = new BYTE[ sizeof( SPropTagArray ) + sizeof( ULONG ) * ARRAY_ELEMENTS( PropTags ) ];
						if( pb )
						{
								// Fill in the prop tags that we are interested in...
							SPropTagArray* pProps = reinterpret_cast<SPropTagArray*>(pb);
							pProps->cValues = ARRAY_ELEMENTS(PropTags);
							for( UINT iCur = 0; iCur < pProps->cValues; iCur++ )
							{
								pProps->aulPropTag[iCur] = PropTags[iCur];
							}

							LPSPropValue pData = NULL;
							ULONG cValues = ARRAY_ELEMENTS(PropTags);

							if( SUCCEEDED( hr = pMapiProp->GetProps( pProps, 0, &cValues, &pData ) ) && pData )
							{
									// Get teh ILS Servers
								if( LOWORD( pData[iPrNmAddress].ulPropTag ) != PT_ERROR )
								{
									for( ULONG iCurVal = 0; iCurVal < pData[iPrNmAddress].Value.MVszA.cValues; ++iCurVal )
									{	
										LPSTR pStr = pData[iPrNmAddress].Value.MVszA.lppszA[iCurVal];

											// Skip the callto://
										pStr = const_cast<LPSTR>(PszSkipCallTo(pStr));

											// Skip duplicate server names...
										if( !FEmptySz(pStr) && ( ILSServers.end() == find( ILSServers, IsEqLPTSTR( pStr ) ) ) )
										{
											ILSServers.push_back( PszAlloc( pStr ) );
										}
									}
								}

									// Get the default Server
								if( LOWORD( pData[iDefaultServer].ulPropTag ) != PT_ERROR )
								{
										// If the default server is not already in the front, put it there...
									if( pData[iDefaultServer].Value.l != 0 )
									{
											// Find the default server in the list
										lst<LPTSTR>::iterator I = ILSServers.begin();
										for( long lCur = 0; ( I != ILSServers.end() ) && ( lCur != pData[iDefaultServer].Value.l ); ++I, ++lCur )
										{ ; }

										ASSERT( I != ILSServers.end() );

										LPTSTR pszDefault = *I;
										ILSServers.erase(I);
										ILSServers.push_front( pszDefault );
									}
								}
									
								m_pWabObject->FreeBuffer(pData);
							}

							delete [] pb;
						}
						else
						{
							hr = E_OUTOFMEMORY;
						}
					}
					else
					{
						hr = E_FAIL;
					}


				}

				if( PhoneNums.size() || EmailNames.size() || ILSServers.size() )
				{
						// Initialize the RAI struct
					int nItems = PhoneNums.size() + EmailNames.size() + ILSServers.size();
					DWORD cbLen = sizeof(RAI) + sizeof(DWSTR)* nItems;
					pRai = reinterpret_cast<RAI*>(new BYTE[ cbLen ]);
					ZeroMemory(pRai, cbLen);
					pRai->cItems = nItems;
						
						// This is the display name...
					GetSzName(pRai->szName, CCHMAX(pRai->szName), iItem);

					int iCur = 0;
					lst<LPTSTR>::iterator I;

						// First copy the e-mail names
					for( I = EmailNames.begin(); I != EmailNames.end(); ++I, ++iCur )
					{
						pRai->rgDwStr[iCur].dw = NM_ADDR_ALIAS_ID;
						pRai->rgDwStr[iCur].psz = PszAlloc(*I);
					}
					for_each( EmailNames, FreePszFunctor() );
					
						// Copy the phone numbirs
					for( I = PhoneNums.begin(); I != PhoneNums.end(); ++I, ++iCur )
					{
						pRai->rgDwStr[iCur].dw = g_fGkEnabled ? NM_ADDR_ALIAS_E164 : NM_ADDR_H323_GATEWAY;
						pRai->rgDwStr[iCur].psz = PszAlloc(*I);
					}
					for_each( PhoneNums, FreePszFunctor() );

						// Copy the ils servers
					for( I = ILSServers.begin(); I != ILSServers.end(); ++I, ++iCur )
					{
						pRai->rgDwStr[iCur].dw = NM_ADDR_ULS;
						pRai->rgDwStr[iCur].psz = PszAlloc(*I);
					}
					for_each( ILSServers, FreePszFunctor() );

				}

				pMapiProp->Release();
			}
		}
	}

	return pRai;
}

HRESULT CWAB::_GetLPSTRProps( lst<LPSTR>& rLst, ULONG* paPropTags, LPMAPIPROP pMapiProp, int nProps )
{
	HRESULT hr = S_OK;

	if( m_pWabObject )
	{
		BYTE* pb = new BYTE[ sizeof( SPropTagArray ) + sizeof( ULONG ) * nProps ];
		if( pb )
		{
				// Fill in the prop tags that we are interested in...
			SPropTagArray* pProps = reinterpret_cast<SPropTagArray*>(pb);
			pProps->cValues = nProps;
			for( UINT iCur = 0; iCur < pProps->cValues; iCur++ )
			{
				pProps->aulPropTag[iCur] = paPropTags[iCur];
			}

			LPSPropValue pData = NULL;
			ULONG cValues = nProps;

			// Get the props
			if( SUCCEEDED( hr = pMapiProp->GetProps( pProps, 0, &cValues, &pData ) ) && pData )
			{
					// Extract thet props
				for( ULONG iCurVal = 0; iCurVal < cValues; ++iCurVal )
				{	
					if( LOWORD( pData[iCurVal].ulPropTag ) != PT_ERROR )
					{
						if( !FEmptySz(pData[iCurVal].Value.lpszA) && ( rLst.end() == find( rLst, IsEqLPTSTR( 
#ifdef UNICODE
																	pData[iCurVal].Value.lpszW 
#else
																	pData[iCurVal].Value.lpszA
#endif
) ) ) )
						{
							rLst.push_back( PszAlloc( pData[iCurVal].Value.lpszA ) );
						}
					}
				}
						
				m_pWabObject->FreeBuffer(pData);
			}

			delete [] pb;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;

}


/*  C R E A T E  W A B  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CreateWabEntry
    
-------------------------------------------------------------------------*/
HRESULT CreateWabEntry(LPTSTR pszDisplay, LPTSTR pszFirst, LPTSTR pszLast,
	LPTSTR pszEmail, LPTSTR pszLocation, LPTSTR pszPhoneNumber, LPTSTR pszComments,
	LPTSTR pszServer)
{
	CWAB * pWab = CWAB::GetInstance();
	if (NULL == pWab)
		return E_FAIL;

	HWND hwnd = GetParent(pWab->GetHwnd());
	return pWab->CreateWabEntry(hwnd, pszDisplay, pszFirst, pszLast, pszEmail,
		pszLocation, pszPhoneNumber, pszComments, pszServer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\wab.h ===
// File: wab.h

#ifndef _WAB_H_
#define _WAB_H_

#include "wabutil.h"
#include <lst.h>
#include "calv.h"

class CWAB : public CWABUTIL, public CALV
{
protected:
	static CWAB * m_spThis;
public:
	static CWAB * GetInstance() {return m_spThis;}

public:
	CWAB();
	~CWAB();

	HRESULT ShowNmEntires(HWND hwnd);

	// CALV methods
	VOID ShowItems(HWND hwnd);
	VOID CmdProperties(void);
	RAI * GetAddrInfo(void);

private:
	HRESULT _GetLPSTRProps( lst<LPSTR>& rLst, ULONG* paPropTags, LPMAPIPROP pMapiProp, int nProps );
};

// Utility routines
HRESULT CreateWabEntry(LPTSTR pszDisplay, LPTSTR pszFirst, LPTSTR pszLast,
	LPTSTR pcszEmail, LPTSTR pszLocation, LPTSTR pszPhoneNumber, LPTSTR pcszComments,
	LPTSTR pcszServer);

#endif /* _WAB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\vidview.cpp ===
// File: videview.cpp

#include "precomp.h"

#include "vidview.h"
#include "resource.h"
#include "confman.h"
#include "rtoolbar.h"
#include "pfndrawd.h"
#include "NmManager.h"
#include "cmd.h"

#define DibHdrSize(lpbi)		((lpbi)->biSize + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))
#define DibDataSize(lpbi)		((lpbi)->biSizeImage)
#define DibSize(lpbi)			(DibHdrSize(lpbi) + DibDataSize(lpbi))

typedef struct
{
	DWORD *pdwCapDevIDs;
	LPTSTR pszCapDevNames;
	DWORD dwNumCapDev;
} ENUM_CAP_DEV;

CSimpleArray<CVideoWindow *> *CVideoWindow::g_pVideos;
BOOL CVideoWindow::g_fMirror = FALSE;
BOOL CVideoWindow::g_bLocalOneTimeInited = FALSE;

static const TCHAR REGVAL_VIDEO_QUALITY[] = TEXT("ImageQuality");

static const UINT VIDEO_ZOOM_MIN = 50;
static const UINT VIDEO_ZOOM_MAX = 400;

static const UINT QCIF_WIDTH  = 176;
static const UINT QCIF_HEIGHT = 144;

CVideoWindow::CVideoWindow(VideoType eType, BOOL bEmbedded) :
	m_dwFrameSize(NM_VIDEO_MEDIUM),
	m_hdd(NULL),
#ifdef DISPLAYFPS
	m_cFrame (0),
	m_dwTick (GetTickCount()),
#endif // DISPLAYFPS
	m_pActiveChannel(NULL),
	m_dwCookie(0),
	m_dwImageQuality(NM_VIDEO_MIN_QUALITY),
	m_pNotify(NULL),
	m_fLocal(REMOTE!=eType),
	m_hBitmapMirror(NULL),
	m_hDCMirror(NULL),
	m_fZoomable(TRUE),
	m_bEmbedded(bEmbedded),
	m_hGDIObj(NULL)
{
	if (NULL == g_pVideos)
	{
		g_pVideos = new CSimpleArray<CVideoWindow*>;
	}
	if (NULL != g_pVideos)
	{
		CVideoWindow* p = static_cast<CVideoWindow*>(this);
		g_pVideos->Add(p);
	}

	m_sizeVideo.cx = 0;
	m_sizeVideo.cy = 0;

	RegEntry reAudio(AUDIO_KEY); // HKCU
	RegEntry reVideo( IsLocal() ? VIDEO_LOCAL_KEY : VIDEO_REMOTE_KEY,
			HKEY_CURRENT_USER );

	DWORD dwFrameSizeDefault = FRAME_QCIF;
	DWORD dwImageQualityDefault = NM_VIDEO_DEFAULT_QUALITY;
	int nVideoWidthDefault = VIDEO_WIDTH_QCIF;
	int nVideoHeightDefault = VIDEO_HEIGHT_QCIF;

	UINT uBandWidth = reAudio.GetNumber(REGVAL_TYPICALBANDWIDTH, BW_DEFAULT);
	if (uBandWidth == BW_144KBS)
	{
		dwImageQualityDefault = NM_VIDEO_MIN_QUALITY;
	}

	m_dwFrameSize = reVideo.GetNumber(
			REGVAL_VIDEO_FRAME_SIZE, dwFrameSizeDefault );

	if (!IsLocal())
	{
		m_dwImageQuality = reVideo.GetNumber(
				REGVAL_VIDEO_QUALITY, dwImageQualityDefault );
	}

	m_nXferOnConnect =
		IsLocal() ? VIDEO_SEND_CONNECT_DEFAULT :
		VIDEO_RECEIVE_CONNECT_DEFAULT;


	m_nXferOnConnect = reVideo.GetNumber(
		REGVAL_VIDEO_XFER_CONNECT,
		m_nXferOnConnect);

	m_zoom = 100;
}

VOID CVideoWindow::OnNCDestroy()
{
	// remote channel will get released upon the NM_CHANNEL_REMOVED
	// notification.  The preview channel needs to be released here,
	// and not in the destructor because of a circular ref count
	if (NULL != m_pActiveChannel)
	{
		NmUnadvise(m_pActiveChannel, IID_INmChannelVideoNotify, m_dwCookie);
		m_dwCookie = 0;
		m_pActiveChannel->Release();
		m_pActiveChannel = NULL;
	}

	if (NULL != m_pNotify)
	{
		m_pNotify->Release();
		m_pNotify = NULL;
	}
}

CVideoWindow::~CVideoWindow()
{
	CVideoWindow* p = static_cast<CVideoWindow*>(this);
	g_pVideos->Remove(p);
	if (0 == g_pVideos->GetSize())
	{
		delete g_pVideos;
		g_pVideos = NULL;
	}

	if (NULL != m_hdd)
	{
		DRAWDIB::DrawDibClose(m_hdd);
	}
	// BUGBUG PhilF: Does DrawDibClose() nuke the selected palette?


	// release resources related to mirror preview
	UnInitMirroring();
}

BOOL CVideoWindow::Create(HWND hwndParent, HPALETTE hpal, IVideoChange *pNotify)
{
	if (FAILED(DRAWDIB::Init()))
	{
		return(FALSE);
	}

	if (!CGenWindow::Create(
		hwndParent,
		0,
		IsLocal() ? TEXT("NMLocalVideo") : TEXT("NMRemoteVideo"),
		WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
		WS_EX_CLIENTEDGE))
	{
		return(FALSE);
	}

	SetWindowPos(GetWindow(), NULL, 0, 0, m_sizeVideo.cx, m_sizeVideo.cy,
		SWP_NOZORDER|SWP_NOACTIVATE);

	// We do NOT own this palette
	m_hPal = hpal;

	m_hdd = DRAWDIB::DrawDibOpen();
	if (NULL != m_hdd)
	{
		// Use the Indeo palette in 8 bit mode only if the decompressed
		// video data is H.261 or H.263. We will create this palette as
		// an identity palette.

		// PhilF: If the user is utilizing an installable codec, do we still want to do this?

		// Update the palette in the DrawDib surface
		if (NULL != hpal)
		{
			DRAWDIB::DrawDibSetPalette(m_hdd, hpal);
		}
	}

	if (NULL != pNotify)
	{
		m_pNotify = pNotify;
		m_pNotify->AddRef();
	}
	
	if (IsLocal())
	{
		// need to get PreviewChannel;
		INmManager2 *pManager = CConfMan::GetNmManager();
		ASSERT (NULL != pManager);
		pManager->GetPreviewChannel(&m_pActiveChannel);
		pManager->Release();

		if (m_pActiveChannel)
		{
			NmAdvise(m_pActiveChannel, static_cast<INmChannelVideoNotify*>(this),
				IID_INmChannelVideoNotify, &m_dwCookie);

			DWORD_PTR dwFrameSize = GetFrameSize();
			if (g_bLocalOneTimeInited)
			{
				m_pActiveChannel->GetProperty(NM_VIDPROP_IMAGE_PREFERRED_SIZE, &dwFrameSize);
			}
			else
			{
				DWORD dwSizes = GetFrameSizes();

				// if frame size is not valid
				if (!(m_dwFrameSize & dwSizes))
				{
					// find an alternate size
					if (FRAME_QCIF & dwSizes)
					{
						dwFrameSize = FRAME_QCIF;
					}
					else if (FRAME_SQCIF & dwSizes)
					{
						dwFrameSize = FRAME_SQCIF;
					}
					else if (FRAME_CIF & dwSizes)
					{
						dwFrameSize = FRAME_CIF;
					}
				}

				RegEntry reVideo( IsLocal() ? VIDEO_LOCAL_KEY : VIDEO_REMOTE_KEY,
						HKEY_CURRENT_USER );
				SetMirror(reVideo.GetNumber(REGVAL_VIDEO_MIRROR, TRUE));

				g_bLocalOneTimeInited = TRUE;
			}

			SetFrameSize((DWORD)dwFrameSize);
		}
	}

	ResizeWindowsToFrameSize();

	return TRUE;
}

DWORD CVideoWindow::GetFrameSizes()
{
	DWORD_PTR dwSizes = 0;
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetProperty(NM_VIDPROP_IMAGE_SIZES, &dwSizes);
	}

	return (DWORD)dwSizes;
}

VOID CVideoWindow::SetFrameSize(DWORD dwSize)
{
	DWORD dwPrevSize = m_dwFrameSize;

	m_dwFrameSize = dwSize;
	if (IsLocal())
	{
		if (NULL != m_pActiveChannel)
		{
			m_pActiveChannel->SetProperty(NM_VIDPROP_IMAGE_PREFERRED_SIZE, dwSize);
		}
	}

	if (dwPrevSize != dwSize)
	{
		if ((NULL == m_pActiveChannel) ||
			(!IsLocal() && (S_OK != m_pActiveChannel->IsActive())) ||
			(IsLocal() && IsPaused()))
		{
			ResizeWindowsToFrameSize();
		}
	}
}

VOID CVideoWindow::ResizeWindowsToFrameSize()
{
	SIZE size; 

	switch(m_dwFrameSize)
	{
	case FRAME_SQCIF:
		size.cx = VIDEO_WIDTH_SQCIF;
		size.cy = VIDEO_HEIGHT_SQCIF;
		break;
	case FRAME_CIF:
		if (IsLocal())
		{
			size.cx = VIDEO_WIDTH_CIF;
			size.cy = VIDEO_HEIGHT_CIF;
			break;
		}
		// else fall through to QCIF
	case FRAME_QCIF:
	default:
		size.cx = VIDEO_WIDTH_QCIF;
		size.cy = VIDEO_HEIGHT_QCIF;
		break;
	}

	SetVideoSize(&size);
}

STDMETHODIMP CVideoWindow::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmChannelVideoNotify) || (riid == IID_IUnknown))
	{
		*ppv = static_cast<INmChannelVideoNotify *>(this);
		DbgMsgApi("CVideoWindow::QueryInterface()");
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		DbgMsgApi("CVideoWindow::QueryInterface(): Called on unknown interface.");
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

STDMETHODIMP CVideoWindow::NmUI(CONFN uNotify)
{
	return S_OK;
}

STDMETHODIMP CVideoWindow::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	return S_OK;
}

STDMETHODIMP CVideoWindow::StateChanged(NM_VIDEO_STATE uState)
{
	InvalidateRect(GetWindow(), NULL, TRUE);

	if (NULL != m_pNotify)
	{
		m_pNotify->StateChange(this, uState);
	}

	CNmManagerObj::VideoChannelStateChanged(uState, !m_fLocal);

	return S_OK;
}

STDMETHODIMP CVideoWindow::PropertyChanged(DWORD dwReserved)
{
	if (NM_VIDPROP_FRAME == dwReserved)
	{
		OnFrameAvailable();
	}
	return S_OK;
}

HRESULT	CVideoWindow::OnChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
	INmChannelVideo* pChannelVideo;
	if (SUCCEEDED(pChannel->QueryInterface(IID_INmChannelVideo, (void**)&pChannelVideo)))
	{
		BOOL bIncoming = (S_OK == pChannelVideo->IsIncoming());
		if ((bIncoming && !IsLocal()) || (!bIncoming && IsLocal()))
		{
			switch (uNotify)
			{
			case NM_CHANNEL_ADDED:
				if (NULL == m_pActiveChannel)
				{
					pChannelVideo->AddRef();
					m_pActiveChannel = pChannelVideo;
					NmAdvise(m_pActiveChannel,static_cast<INmChannelVideoNotify*>(this),
						IID_INmChannelVideoNotify, &m_dwCookie);

					SetImageQuality(m_dwImageQuality);
				}

				if (!_Module.InitControlMode())
				{
					switch(m_nXferOnConnect)
					{
					case VIDEO_XFER_START:
						if (IsPaused())
						{
							Pause(FALSE);
						}
						break;

					case VIDEO_XFER_STOP:
						Pause(TRUE);
						break;

					default:
						if (!IsLocal())
						{
							Pause(TRUE);
						}
						break;
					}
				}
				break;

			case NM_CHANNEL_REMOVED:
				if (!IsLocal() && (pChannel == m_pActiveChannel))
				{
					NmUnadvise(m_pActiveChannel, IID_INmChannelVideoNotify, m_dwCookie);
					m_pActiveChannel->Release();
					m_pActiveChannel = NULL;
					m_dwCookie = 0;

					ResizeWindowsToFrameSize();
				}
			}

			// just in case we missed a notification
			// (in final version this should not be the case)
			// m_VideoWindow.OnStateChange();
		}

		pChannelVideo->Release();
	}

	return S_OK;
}

HRESULT CVideoWindow::SetImageQuality(DWORD dwQuality)
{
	HRESULT hr = E_FAIL;
	m_dwImageQuality = dwQuality;
	if (NULL != m_pActiveChannel)
	{
		hr = m_pActiveChannel->SetProperty(NM_VIDPROP_IMAGE_QUALITY, dwQuality);

		CNmManagerObj::VideoPropChanged(NM_VIDPROP_IMAGE_QUALITY, !IsLocal());
	}

	return hr;
}


HRESULT CVideoWindow::SetCameraDialog(ULONG ul)
{
	if(IsLocal())
	{
		return m_pActiveChannel->SetProperty(NM_VIDPROP_CAMERA_DIALOG, ul);
		CNmManagerObj::VideoPropChanged(NM_VIDPROP_CAMERA_DIALOG, IsLocal());
	}

	return E_FAIL;
}

HRESULT CVideoWindow::GetCameraDialog(ULONG* pul)
{
    HRESULT hr;
    DWORD_PTR dwPropVal;

	if(IsLocal())
	{
		hr = m_pActiveChannel->GetProperty(NM_VIDPROP_CAMERA_DIALOG, &dwPropVal);
        *pul = (ULONG)dwPropVal;
        return hr;
	}

	return E_FAIL;
}


BOOL CVideoWindow::IsXferAllowed()
{
	if (IsLocal())
	{
		return FIsSendVideoAllowed() && (NULL != m_pActiveChannel);
	}
	else
	{
		return FIsReceiveVideoAllowed();
	}
}

BOOL CVideoWindow::IsAutoXferEnabled()
{
	return(VIDEO_XFER_START == m_nXferOnConnect);
}

BOOL CVideoWindow::IsXferEnabled()
{
	if (NULL != m_pActiveChannel)
	{
		NM_VIDEO_STATE state;
		if (SUCCEEDED(m_pActiveChannel->GetState(&state)))
		{
			switch (state)
			{
			case NM_VIDEO_PREVIEWING:
			case NM_VIDEO_TRANSFERRING:
			case NM_VIDEO_REMOTE_PAUSED:
				return TRUE;
			case NM_VIDEO_IDLE:
			case NM_VIDEO_LOCAL_PAUSED:
			case NM_VIDEO_BOTH_PAUSED:
			default:
				return FALSE;
			}
		}
	}
	return FALSE;
}

HRESULT CVideoWindow::GetVideoState(NM_VIDEO_STATE* puState)
{
	if(m_pActiveChannel)
	{
		return m_pActiveChannel->GetState(puState);
	}

	return E_FAIL;
}

VOID CVideoWindow::Pause(BOOL fPause)
{
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->SetProperty(NM_VIDPROP_PAUSE, (ULONG)fPause);

		CNmManagerObj::VideoPropChanged(NM_VIDPROP_PAUSE, !IsLocal());
	}
}

BOOL CVideoWindow::IsPaused()
{
	if (NULL != m_pActiveChannel)
	{
		ULONG_PTR uPause;
		if (SUCCEEDED(m_pActiveChannel->GetProperty(NM_VIDPROP_PAUSE, &uPause)))
		{
			return (BOOL)uPause;
		}
	}
	return TRUE;
}

BOOL CVideoWindow::IsConnected()
{
	if (NULL != m_pActiveChannel)
	{
		NM_VIDEO_STATE state;
		if (SUCCEEDED(m_pActiveChannel->GetState(&state)))
		{
			switch (state)
			{
			case NM_VIDEO_LOCAL_PAUSED:
			case NM_VIDEO_TRANSFERRING:
			case NM_VIDEO_BOTH_PAUSED:
			case NM_VIDEO_REMOTE_PAUSED:
				return TRUE;
			case NM_VIDEO_IDLE:
			case NM_VIDEO_PREVIEWING:
			default:
				return FALSE;
			}
		}
	}
	return FALSE;
}

DWORD CVideoWindow::GetNumCapDev()
{
	DWORD_PTR dwNumDevs = 0;
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetProperty(NM_VIDPROP_NUM_CAPTURE_DEVS, &dwNumDevs);
	}
	return (DWORD)dwNumDevs;
}

DWORD CVideoWindow::GetMaxCapDevNameLen()
{
	DWORD_PTR dwLen = 0;
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetProperty(NM_VIDPROP_MAX_CAPTURE_NAME, &dwLen);
	}
	return (DWORD)dwLen;
}

DWORD CVideoWindow::GetCurrCapDevID()
{
	DWORD_PTR dwID = 0;
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetProperty(NM_VIDPROP_CAPTURE_DEV_ID, &dwID);
	}
	return (DWORD)dwID;
}

VOID CVideoWindow::SetCurrCapDevID(DWORD dwID)
{	
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->SetProperty(NM_VIDPROP_CAPTURE_DEV_ID, dwID);
        InvalidateRect(GetWindow(), NULL, TRUE);
	}
}

VOID CVideoWindow::EnableAutoXfer(BOOL fEnable)
{
	m_nXferOnConnect = fEnable ? VIDEO_XFER_START : VIDEO_XFER_NOP;

	RegEntry reXfer( IsLocal() ? VIDEO_LOCAL_KEY : VIDEO_REMOTE_KEY,
		HKEY_CURRENT_USER );
	
	reXfer.SetValue ( REGVAL_VIDEO_XFER_CONNECT, m_nXferOnConnect);
}

VOID CVideoWindow::EnumCapDev(DWORD *pdwCapDevIDs, LPTSTR pszCapDevNames, DWORD dwNumCapDev)
{
	ENUM_CAP_DEV enumCapDev;
	enumCapDev.pdwCapDevIDs = pdwCapDevIDs;
	enumCapDev.pszCapDevNames = pszCapDevNames;
	enumCapDev.dwNumCapDev = dwNumCapDev;

	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetProperty(NM_VIDPROP_CAPTURE_LIST, (DWORD_PTR *)&enumCapDev);
	}
}

VOID CVideoWindow::GetDesiredSize(SIZE *ppt)
{
	ppt->cx = m_sizeVideo.cx*m_zoom/100;
	ppt->cy = m_sizeVideo.cy*m_zoom/100;

	if (m_bEmbedded)
	{
		ppt->cx = min(ppt->cx, QCIF_WIDTH);
		ppt->cy = min(ppt->cy, QCIF_HEIGHT);
	}

	SIZE sGen;
	CGenWindow::GetDesiredSize(&sGen);

	ppt->cx += sGen.cx;
	ppt->cy += sGen.cy;
}

VOID CVideoWindow::SetVideoSize(LPSIZE lpsize)
{
	m_sizeVideo = *lpsize;

	OnDesiredSizeChanged();
}

#ifdef DEBUG
DWORD g_fDisplayFPS = FALSE;

#ifdef DISPLAYFPS
VOID CVideoWindow::UpdateFps(void)
{
	DWORD dwTick = GetTickCount();
	m_cFrame++;
	// Update display every 4 seconds
	if ((dwTick - m_dwTick) < 4000)
		return;

	TCHAR sz[32];
	wsprintf(sz, "%d FPS", m_cFrame / 4);
	SetWindowText(m_hwndParent, sz);

	m_cFrame = 0;
	m_dwTick = dwTick;
}
#endif /* DISPLAYFPS */
#endif // DEBUG

VOID CVideoWindow::OnFrameAvailable(void)
{
	::InvalidateRect(GetWindow(), NULL, FALSE);

#ifdef DISPLAYFPS
	if (g_fDisplayFPS)
	{
		UpdateFps();
	}
#endif // DISPLAYFPS
}


VOID CVideoWindow::PaintDib(HDC hdc, FRAMECONTEXT *pFrame)
{
	RECT rcVideo;
	GetClientRect(GetWindow(), &rcVideo);

	HPALETTE hpOld = NULL;

	if (NULL != m_hPal)
	{
		hpOld = SelectPalette(hdc, m_hPal, FALSE);
		RealizePalette(hdc);
	}

	// create the bitmap object, only if it doesn't exist
	// and if the mirror bitmap object isn't the right size
	if (!ShouldMirror() || !InitMirroring(rcVideo))
	{
		// ISSUE: (ChrisPi 2-19-97) should we use DDF_SAME_HDC?
		DRAWDIB::DrawDibDraw(m_hdd,hdc,
				rcVideo.left,
				rcVideo.top,
				RectWidth(rcVideo),
				RectHeight(rcVideo),
				&pFrame->lpbmi->bmiHeader,
				pFrame->lpData,
				pFrame->lpClipRect->left,
				pFrame->lpClipRect->top,
				RectWidth(pFrame->lpClipRect),
				RectHeight(pFrame->lpClipRect),
				0);
	}
	else
	{
		if (NULL != m_hPal)
		{
			SelectPalette(m_hDCMirror, m_hPal, FALSE);
			RealizePalette(m_hDCMirror);
		}

		DRAWDIB::DrawDibDraw(m_hdd,
				m_hDCMirror,
				0,
				0,
				RectWidth(rcVideo),
				RectHeight(rcVideo),
				&pFrame->lpbmi->bmiHeader,
				pFrame->lpData,
				pFrame->lpClipRect->left,
				pFrame->lpClipRect->top,
				RectWidth(pFrame->lpClipRect),
				RectHeight(pFrame->lpClipRect),
				0);

		::StretchBlt(hdc,
				rcVideo.right,
				rcVideo.top,
				-RectWidth(rcVideo),
				RectHeight(rcVideo),
				m_hDCMirror,
				0,
				0,
				RectWidth(rcVideo),
				RectHeight(rcVideo),
				SRCCOPY);

		// HACKHACK georgep; don't worry about deselecting the palette in
		// the temp DC
	}

	if (NULL != hpOld)
	{
		SelectPalette(hdc, hpOld, FALSE);
	}
}

/*  P A I N T  L O G O  */
/*-------------------------------------------------------------------------
    %%Function: PaintLogo

    Display the 256 color NetMeeting logo in the video window.
-------------------------------------------------------------------------*/
VOID CVideoWindow::PaintLogo(HDC hdc, UINT idbLargeLogo, UINT idbSmallLogo)
{
	RECT rcVideo;
	GetClientRect(GetWindow(), &rcVideo);

	::FillRect(hdc, &rcVideo, (HBRUSH)::GetStockObject(WHITE_BRUSH));

	// Create the memory DC
	HDC hdcMem = ::CreateCompatibleDC(hdc);
	if (NULL == hdcMem)
	{
		ERROR_OUT(("PaintLogo: Unable to CreateCompatibleDC"));
		return;
	}

	// Load the bitmap  (LoadBitmap doesn't work for 256 color images)
	HANDLE hBitmap = LoadImage(::GetInstanceHandle(),
			MAKEINTRESOURCE(idbLargeLogo), IMAGE_BITMAP, 0, 0,
			LR_CREATEDIBSECTION);

	if (NULL != hBitmap)
	{
		BITMAP bitmap;
		::GetObject(hBitmap, sizeof(bitmap), &bitmap);
		int cx = bitmap.bmWidth;
		int cy = bitmap.bmHeight;

		if (RectWidth(rcVideo) < cx || RectHeight(rcVideo) < cy)
		{
			HANDLE hNew = LoadImage(::GetInstanceHandle(),
				MAKEINTRESOURCE(idbSmallLogo), IMAGE_BITMAP, 0, 0,
				LR_CREATEDIBSECTION);
			if (NULL != hNew)
			{
				DeleteObject(hBitmap);
				hBitmap = hNew;

				::GetObject(hBitmap, sizeof(bitmap), &bitmap);
				cx = bitmap.bmWidth;
				cy = bitmap.bmHeight;
			}
		}

		HBITMAP hBmpTmp = (HBITMAP)::SelectObject(hdcMem, hBitmap);

		// Select and realize the palette
		HPALETTE hPalette = m_hPal;
		if (NULL != hPalette)
		{
			SelectPalette(hdcMem, hPalette, FALSE);
			RealizePalette(hdcMem);
			SelectPalette(hdc, hPalette, FALSE);
			RealizePalette(hdc);
		}

		int x = rcVideo.left + (RectWidth(rcVideo) - cx) / 2;
		int y = rcVideo.top + (RectHeight(rcVideo) - cy) / 2;
		::BitBlt(hdc, x, y, cx, cy, hdcMem, 0, 0, SRCCOPY);

		::SelectObject(hdcMem, hBmpTmp);
		::DeleteObject(hBitmap);
	}
	::DeleteDC(hdcMem);
}


VOID CVideoWindow::OnPaint()
{
	PAINTSTRUCT ps;
	HDC hdc;

	hdc = ::BeginPaint(GetWindow(), &ps);

	if( hdc )
	{
		if( RectWidth(ps.rcPaint) && RectHeight(ps.rcPaint) )
		{
			// This means that we have a non-zero surface area ( there may be something to paint )

			DBGENTRY(CVideoWindow::ProcessPaint);

			// paint the video rect
			FRAMECONTEXT fc;
			if ((S_OK == GetFrame(&fc)))
			{
				if (!IsPaused())
				{
					SIZE vidSize =
					{
						RectWidth(fc.lpClipRect),
						RectHeight(fc.lpClipRect)
					} ;

					if ((vidSize.cx != m_sizeVideo.cx) || (vidSize.cy != m_sizeVideo.cy))
					{
						// save the new image size
						SetVideoSize(&vidSize);
					}
				}

				PaintDib(hdc, &fc);

				ReleaseFrame(&fc);
			}
			else
			{
				PaintLogo(hdc, IDB_VIDEO_LOGO, IDB_VIDEO_LOGO_SMALL);
			}

			// check to see if needs painting outside the video rect
#if FALSE
			// Currently just stretching the video to the window size
			if (ps.rcPaint.left < m_rcVideo.left ||
				ps.rcPaint.top < m_rcVideo.top ||
				ps.rcPaint.right > m_rcVideo.right ||
				ps.rcPaint.bottom > m_rcVideo.bottom)
			{
				HFONT   hfOld;
				int nBkModeOld;
				RECT rc, rcClient;

				::GetClientRect(GetWindow(), &rcClient);

				// erase the background if requested
				if (ps.fErase)
				{
					::ExcludeClipRect(hdc,
						m_rcVideo.left,
						m_rcVideo.top,
						m_rcVideo.right,
						m_rcVideo.bottom);
					::FillRect(hdc, &rcClient, ::GetSysColorBrush(COLOR_BTNFACE));
				}

				nBkModeOld = ::SetBkMode(hdc, TRANSPARENT);
				hfOld = (HFONT)::SelectObject(hdc, g_hfontDlg);

				// paint the status text
				// first erase the old text if not already done
				if (!ps.fErase)
				{
					::FillRect(hdc, &m_rcStatusText, ::GetSysColorBrush(COLOR_BTNFACE));
				}
				TCHAR szState[MAX_PATH];
				if (GetState(szState, CCHMAX(szState)))
				{
					COLORREF crOld;

					crOld = ::SetTextColor(hdc, ::GetSysColor(COLOR_BTNTEXT));

					rc = m_rcStatusText;
					rc.left += STATUS_MARGIN;
					::DrawText(hdc,
							szState,
							-1,
							&rc,
							DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX);
					::SetTextColor(hdc, crOld);
				}

				// paint border around video
				rc = m_rcVideo;
				::InflateRect(&rc,
						::GetSystemMetrics(SM_CXEDGE),
						::GetSystemMetrics(SM_CYEDGE));
				::DrawEdge(hdc, &rc, EDGE_SUNKEN , BF_RECT);

				// restore DC stuff
				::SelectObject(hdc, hfOld);
				::SetBkMode(hdc, nBkModeOld);
			}
#endif // FALSE

			DBGEXIT(CVideoWindow::ProcessPaint);
		}

		::EndPaint(GetWindow(), &ps);
	}

}

VOID CVideoWindow::SetZoom(UINT zoom)
{
	if (m_zoom == zoom)
	{
		return;
	}

	m_zoom = zoom;
	OnDesiredSizeChanged();
}

void CVideoWindow::OnCommand(int idCmd)
{

	switch (idCmd)
	{
	case IDM_VIDEO_GETACAMERA:
		CmdLaunchWebPage(idCmd);
		break;

	case IDM_VIDEO_COPY:
		CopyToClipboard();
		break;

	case IDM_VIDEO_FREEZE:
		Pause(!IsPaused());
		break;

	case IDM_VIDEO_UNDOCK:
		CMainUI::NewVideoWindow(GetConfRoom());
		break;

	case IDM_VIDEO_ZOOM1:
		SetZoom(100);
		break;

	case IDM_VIDEO_ZOOM2:
		SetZoom(200);
		break;

	case IDM_VIDEO_ZOOM3:
		SetZoom(300);
		break;

	case IDM_VIDEO_ZOOM4:
		SetZoom(400);
		break;

	case IDM_VIDEO_PROPERTIES:
		LaunchConfCpl(GetWindow(), OPTIONS_VIDEO_PAGE);
		break;
	}
}

void CVideoWindow::UpdateVideoMenu(HMENU hMenu)
{
	EnableMenuItem(hMenu, IDM_VIDEO_COPY, MF_BYCOMMAND|(CanCopy() ? MF_ENABLED : MF_GRAYED|MF_DISABLED));
	EnableMenuItem(hMenu, IDM_VIDEO_UNDOCK, MF_BYCOMMAND|(IsLocal() ? MF_ENABLED : MF_GRAYED|MF_DISABLED));

    if (!FIsSendVideoAllowed() && !FIsReceiveVideoAllowed())
    {
        EnableMenuItem(hMenu, IDM_VIDEO_FREEZE, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
        EnableMenuItem(hMenu, IDM_VIDEO_PROPERTIES, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
        EnableMenuItem(hMenu, IDM_VIDEO_GETACAMERA, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
    }
    else
    {
    	CheckMenuItem(hMenu, IDM_VIDEO_FREEZE, MF_BYCOMMAND|(IsPaused() ? MF_CHECKED : MF_UNCHECKED));

    	UINT uEnable = ::CanShellExecHttp() ? MF_ENABLED : MF_GRAYED;
	    ::EnableMenuItem(hMenu, IDM_VIDEO_GETACAMERA, uEnable);
    }

	int nZoom = GetZoom();
    int idZoom;
	if (350 < nZoom) idZoom = IDM_VIDEO_ZOOM4;
    else if (250 < nZoom) idZoom = IDM_VIDEO_ZOOM3;
	else if (150 < nZoom) idZoom = IDM_VIDEO_ZOOM2;
    else idZoom = IDM_VIDEO_ZOOM1;

	UINT uFlags = IsZoomable() && !m_bEmbedded
	    ? MF_ENABLED : MF_GRAYED|MF_DISABLED;
    for (int id=IDM_VIDEO_ZOOM1; id<=IDM_VIDEO_ZOOM4; ++id)
	{
	    EnableMenuItem(hMenu, id, MF_BYCOMMAND|uFlags);
    	CheckMenuItem(hMenu, id, MF_BYCOMMAND|MF_UNCHECKED);
	}
    CheckMenuItem(hMenu, idZoom, MF_BYCOMMAND|MF_CHECKED);

	uFlags = CanLaunchConfCpl()
	    ? MF_ENABLED : MF_GRAYED|MF_DISABLED;
	EnableMenuItem(hMenu, IDM_VIDEO_PROPERTIES, MF_BYCOMMAND|uFlags);



}

void CVideoWindow::OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
{
	HMENU hmLoad = LoadMenu(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_VIDEO_POPUP));
	if (NULL != hmLoad)
	{
		HMENU hmPopup = GetSubMenu(hmLoad, 0);
		ASSERT(NULL != hmPopup);

		UpdateVideoMenu(hmPopup);

		int idCmd = TrackPopupMenu(hmPopup, TPM_RETURNCMD|TPM_RIGHTBUTTON,
			xPos, yPos, 0, hwnd, NULL);

		if (0 != idCmd)
		{
			OnCommand(idCmd);
		}

		DestroyMenu(hmLoad);
	}
}

LRESULT CVideoWindow::ProcessMessage(HWND hwnd, UINT message,
								 WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);

	case WM_ERASEBKGND:
		return 0;

	case WM_PAINT:
		OnPaint();
		return 0;

	case WM_NCDESTROY:
		OnNCDestroy();
		return 0;

	case WM_SIZE:
		// Need to redraw the whole window
		InvalidateRect(GetWindow(), NULL, FALSE);
		break;

	default:
		break;
	}
	return CGenWindow::ProcessMessage(hwnd, message, wParam, lParam) ;
}

#if FALSE
int CVideoWindow::GetState(LPTSTR lpszState, int nStateMax)
{
	int uStringID;

	NM_VIDEO_STATE state = NM_VIDEO_IDLE;

	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetState(&state);
	}

	if (IsLocal())
	{
		switch (state)
		{
			case NM_VIDEO_PREVIEWING:
				uStringID = IDS_VIDEO_STATE_PREVIEWING;
				break;
			case NM_VIDEO_TRANSFERRING:
				uStringID = IDS_VIDEO_STATE_SENDING;
				break;
			case NM_VIDEO_REMOTE_PAUSED:
				uStringID = IDS_VIDEO_STATE_REMOTEPAUSED;
				break;
			case NM_VIDEO_LOCAL_PAUSED:
			case NM_VIDEO_BOTH_PAUSED:
				uStringID = IDS_VIDEO_STATE_PAUSED;
				break;
			case NM_VIDEO_IDLE:
			default:
				uStringID = IDS_VIDEO_STATE_NOTSENDING;
				break;
		}
	}
	else
	{
		switch (state)
		{
			case NM_VIDEO_TRANSFERRING:
				uStringID = IDS_VIDEO_STATE_RECEIVING;
				break;
			case NM_VIDEO_REMOTE_PAUSED:
				uStringID = IDS_VIDEO_STATE_REMOTEPAUSED;
				break;
			case NM_VIDEO_LOCAL_PAUSED:
			case NM_VIDEO_BOTH_PAUSED:
				uStringID = IDS_VIDEO_STATE_PAUSED;
				break;
			case NM_VIDEO_IDLE:
			case NM_VIDEO_PREVIEWING:
			default:
				uStringID = IDS_VIDEO_STATE_NOTRECEIVING;
				break;
		}
	}

	return ::LoadString(
				::GetInstanceHandle(),
				uStringID,
				lpszState,
				nStateMax);
}
#endif // FALSE

// Return value will be TRUE if Windows can handle the format
static BOOL IsKnownDIBFormat(BITMAPINFOHEADER *pbmih)
{
	if (sizeof(BITMAPINFOHEADER) != pbmih->biSize)
	{
		return(FALSE);
	}

	if (1 != pbmih->biPlanes)
	{
		return(FALSE);
	}

	int bits = pbmih->biBitCount;
	int comp = pbmih->biCompression;

	switch (bits)
	{
	case 1:
		if (BI_RGB == comp)
		{
			return(TRUE);
		}
		break;

	case 4:
		if (BI_RGB == comp || BI_RLE4 == comp)
		{
			return(TRUE);
		}
		break;

	case 8:
		if (BI_RGB == comp || BI_RLE8 == comp)
		{
			return(TRUE);
		}
		break;

	case 16:
		if (BI_RGB == comp || BI_BITFIELDS == comp)
		{
			return(TRUE);
		}
		break;

	case 24:
	case 32:
		if (BI_RGB == comp)
		{
			return(TRUE);
		}
		break;

	default:
		break;
	}

	return(FALSE);
}

#ifdef TryPaintDIB
BOOL CVideoWindow::CopyToClipboard()
{
	FRAMECONTEXT fc;
	BOOL fSuccess = FALSE; 

	// Get the current frame and open the clipboard
	if (S_OK == GetFrame(&fc))
	{
		HWND hwnd = GetWindow();

		if (OpenClipboard(hwnd))
		{
			// Allocate memory that we will be giving to the clipboard
			BITMAPINFOHEADER *pbmih = &fc.lpbmi->bmiHeader;

			BOOL bCopy = IsKnownDIBFormat(pbmih);

			// BUGBUG georgep; I think this doesn't work for 15 or 16 bit DIBs
			int nColors = pbmih->biClrUsed;
			if (0 == nColors && pbmih->biBitCount <= 8)
			{
				nColors = 1 << pbmih->biBitCount;
			}
			// Special case for 16-bit bitfield bitmaps
			if (16 == pbmih->biBitCount && BI_BITFIELDS == pbmih->biCompression)
			{
				nColors = 3;
			}
			int nHdrSize = pbmih->biSize + nColors * sizeof(RGBQUAD);

			int bitsPer = pbmih->biBitCount;
			if (!bCopy)
			{
				bitsPer *= pbmih->biPlanes;
				if (bitsPer > 24)
				{
					bitsPer = 32;
				}
				// LAZYLAZY georgep: Skipping 16-bit format
				else if (bitsPer > 8)
				{
					bitsPer = 24;
				}
				else if (bitsPer > 4)
				{
					bitsPer = 8;
				}
				else if (bitsPer > 1)
				{
					bitsPer = 4;
				}
				else
				{
					bitsPer = 1;
				}
			}

			int nDataSize = bCopy ? pbmih->biSizeImage : 0;
			if (0 == nDataSize)
			{
				// Make an uncompressed DIB
				int nByteWidth = (pbmih->biWidth*bitsPer+7) / 8;
				nDataSize = ((nByteWidth + 3)&~3) * pbmih->biHeight;
			}

			// Allocate the total memory for the DIB
			HGLOBAL hCopy = GlobalAlloc(GHND, nHdrSize + nDataSize);
			if (NULL != hCopy)
			{
				BITMAPINFO *lpvCopy = reinterpret_cast<BITMAPINFO*>(GlobalLock(hCopy));

				CopyMemory(lpvCopy, pbmih, nHdrSize);

				// Create a temporary DC for drawing into
				HDC hdc = GetDC(hwnd);
				if (NULL != hdc)
				{
					HDC hdcTemp = CreateCompatibleDC(hdc);
					ReleaseDC(hwnd, hdc);
					hdc = hdcTemp;
				}

				if (NULL != hdc)
				{
					if (bCopy)
					{
						if (ShouldMirror())
						{
							// Create a DIB section for drawing into
							LPVOID pData;
							HBITMAP hDIB = CreateDIBSection(hdc, lpvCopy, DIB_RGB_COLORS, &pData, NULL, 0);
							if (NULL != hDIB)
							{
								// Draw into the DIB, and then copy the bits
								HGDIOBJ hOld = SelectObject(hdc, hDIB);

								RECT rc = { 0, 0, pbmih->biWidth, pbmih->biHeight };
								StretchDIBits(hdc, 0, 0, pbmih->biWidth, pbmih->biHeight,
									pbmih->biWidth, 0, -pbmih->biWidth, pbmih->biHeight,
									fc.lpData, lpvCopy, DIB_RGB_COLORS, SRCCOPY);

								CopyMemory(&lpvCopy->bmiColors[nColors], pData, nDataSize);

								// Start cleaning up
								SelectObject(hdc, hOld);
								DeleteObject(hDIB);
							}
						}
						else
						{
							CopyMemory(&lpvCopy->bmiColors[nColors], fc.lpData, nDataSize);
						}

						fSuccess = TRUE;
					}
					else
					{
						lpvCopy->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
						lpvCopy->bmiHeader.biPlanes = 1;
						lpvCopy->bmiHeader.biBitCount = bitsPer;
						lpvCopy->bmiHeader.biCompression = BI_RGB;
						lpvCopy->bmiHeader.biSizeImage = nDataSize;

						// Create a DIB section for drawing into
						LPVOID pData;
						HBITMAP hDIB = CreateDIBSection(hdc, lpvCopy, DIB_RGB_COLORS, &pData, NULL, 0);
						if (NULL != hDIB)
						{
							// Draw into the DIB, and then copy the bits
							HGDIOBJ hOld = SelectObject(hdc, hDIB);

							RECT rc = { 0, 0, pbmih->biWidth, pbmih->biHeight };
							PaintDib(hdc, &fc, &rc);

							CopyMemory(&lpvCopy->bmiColors[nColors], pData, nDataSize);

							// Start cleaning up
							SelectObject(hdc, hOld);
							DeleteObject(hDIB);

							fSuccess = TRUE;
						}
					}

					DeleteDC(hdc);
				}

				GlobalUnlock(hCopy);

				if (fSuccess)
				{
					// Set the DIB into the clipboard
					EmptyClipboard();
					fSuccess = (NULL != SetClipboardData(CF_DIB, (HANDLE)hCopy));
				}

				if (!fSuccess)
				{
					GlobalFree(hCopy);
				}
			}

			CloseClipboard();
		}

		ReleaseFrame(&fc);
	}
	
	return fSuccess;
}
#else // TryPaintDIB
BOOL CVideoWindow::CopyToClipboard()
{
	FRAMECONTEXT fc;
	BOOL fSuccess = FALSE; 
	
	if (S_OK == GetFrame(&fc))
	{
		if (OpenClipboard(GetWindow()))
		{
			EmptyClipboard();
			{
				HGLOBAL hCopy;
				BITMAPINFOHEADER *pbmih;
				
				pbmih = &fc.lpbmi->bmiHeader;
				hCopy = GlobalAlloc(GHND, DibSize(pbmih));
				if (NULL != hCopy)
				{
					LPVOID lpvCopy = GlobalLock(hCopy);
					int nHdrSize = DibHdrSize(pbmih);
					CopyMemory(lpvCopy, pbmih, nHdrSize);
					CopyMemory((LPBYTE)lpvCopy + nHdrSize, fc.lpData, DibDataSize(pbmih));
					GlobalUnlock(hCopy);
					fSuccess = (NULL != SetClipboardData(CF_DIB, (HANDLE)hCopy));
					if (!fSuccess)
					{
						GlobalFree(hCopy);
					}
				}
			}
			CloseClipboard();
		}
		ReleaseFrame(&fc);
	}
	
	return fSuccess;
}
#endif // TryPaintDIB

HRESULT CVideoWindow::GetFrame(FRAMECONTEXT *pFrameContext)
{
	HRESULT hr = E_FAIL;

	if (NULL != m_pActiveChannel)
	{
		hr = m_pActiveChannel->GetProperty(NM_VIDPROP_FRAME, (DWORD_PTR *)pFrameContext);
	}
	return hr;
}

HRESULT CVideoWindow::ReleaseFrame(FRAMECONTEXT *pFrameContext)
{
	HRESULT hr = E_FAIL;

	if (NULL != m_pActiveChannel)
	{
		hr = m_pActiveChannel->SetProperty(NM_VIDPROP_FRAME, (DWORD_PTR)pFrameContext);
	}
	return hr;
}

void CVideoWindow::SaveSettings()
{
	RegEntry re( IsLocal() ? VIDEO_LOCAL_KEY : VIDEO_REMOTE_KEY,
			HKEY_CURRENT_USER );

	re.SetValue(REGVAL_VIDEO_FRAME_SIZE, m_dwFrameSize);

	if (!IsLocal())
	{
		re.SetValue(REGVAL_VIDEO_QUALITY, m_dwImageQuality);
	}
	else
	{
		re.SetValue(REGVAL_VIDEO_MIRROR, GetMirror());
	}
}

VOID CVideoWindow::ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_PALETTECHANGED:
		OnPaletteChanged();
		break;
	}
}

VOID CVideoWindow::OnPaletteChanged(void)
{
	::RedrawWindow(GetWindow(), NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
}

BOOL CVideoWindow::HasDialog(DWORD dwDialog)
{
	DWORD_PTR dwDialogs = 0;
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetProperty(NM_VIDPROP_CAMERA_DIALOG, &dwDialogs);
	}
	return (BOOL)(dwDialogs & dwDialog);
}

VOID CVideoWindow::ShowDialog(DWORD dwDialog)
{
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->SetProperty(NM_VIDPROP_CAMERA_DIALOG, dwDialog);
	}
}


BOOL CVideoWindow::InitMirroring(RECT &rcVideo)
{
	HDC hdcWindow;

	if ((m_hBitmapMirror != NULL) && 
		(RectWidth(rcVideo) == m_sizeBitmapMirror.cx) &&
		(RectHeight(rcVideo) == m_sizeBitmapMirror.cy))
	{
		return TRUE;
	}

	hdcWindow = ::GetDC(NULL);

	UnInitMirroring();

	m_hBitmapMirror = ::CreateCompatibleBitmap(hdcWindow, RectWidth(rcVideo), RectHeight(rcVideo));

	if (m_hBitmapMirror == NULL)
	{
		ReleaseDC(NULL, hdcWindow);
		return FALSE;
	}

	m_hDCMirror = ::CreateCompatibleDC(hdcWindow);

	if (m_hDCMirror == NULL)
	{
		UnInitMirroring();
		ReleaseDC(NULL, hdcWindow);
		return FALSE;
	}
		
	// preserve the handle of the object being replaced
	m_hGDIObj = ::SelectObject(m_hDCMirror, m_hBitmapMirror);
	::SetMapMode(m_hDCMirror, GetMapMode(hdcWindow));

	m_sizeBitmapMirror.cx = RectWidth(rcVideo);
	m_sizeBitmapMirror.cy = RectHeight(rcVideo);
	ReleaseDC(NULL, hdcWindow);
	return TRUE;
}

VOID CVideoWindow::UnInitMirroring()
{
	if (m_hBitmapMirror)
	{
		if (m_hDCMirror)
		{
			::SelectObject(m_hDCMirror, m_hGDIObj);
		}
		::DeleteObject(m_hBitmapMirror);
		m_hBitmapMirror = NULL;
	}

	if (m_hDCMirror)
	{
		::DeleteObject(m_hDCMirror);
		m_hDCMirror = NULL;
	}
}

VOID CVideoWindow::InvalidateAll()
{
	for(int i = g_pVideos->GetSize()-1; i >= 0 ; --i)
	{
		CVideoWindow *pVideo = (*g_pVideos)[i];
		HWND hwnd = pVideo->GetWindow();
		if (NULL != hwnd)
		{
			InvalidateRect(hwnd, NULL, FALSE);
		}
	}
}

VOID CVideoWindow::SetMirror(BOOL bMirror)
{
	bMirror = bMirror != FALSE;

	if (g_fMirror != bMirror)
	{
		g_fMirror = bMirror;
		InvalidateAll();
	}
}

BOOL CVideoWindow::CanCopy()
{
	BOOL bCopy = (IsXferEnabled() && IsLocal()) || IsConnected();
	if (bCopy)
	{
		bCopy = FALSE;

		FRAMECONTEXT fc;
		if (S_OK == GetFrame(&fc))
		{
			BITMAPINFOHEADER *pbmih = &fc.lpbmi->bmiHeader;

			bCopy = IsKnownDIBFormat(pbmih);

			ReleaseFrame(&fc);
		}
	}

	return(bCopy);
}

BOOL CVideoWindow::FDidNotDisplayIntelLogo()
{
	return FALSE;
}

VOID CVideoWindow::DisplayIntelLogo( BOOL bDisplay )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\vidwiz.cpp ===
// File: vidwiz.cpp

#include "precomp.h"

#include "dcap.h"
#include "vidinout.h"
#include "vidwiz.h"
#include "confcpl.h"


static HINSTANCE g_hDcapLib;

typedef int (WINAPI *GNCD)();
typedef BOOL (WINAPI *FFCD)(FINDCAPTUREDEVICE*, char *);
typedef BOOL (WINAPI *FFCDBI)(FINDCAPTUREDEVICE*, int);

// implementations in DCAP32.DLL
static FFCD DLL_FindFirstCaptureDevice = NULL;
static FFCDBI DLL_FindFirstCaptureDeviceByIndex = NULL;
static GNCD DLL_GetNumCaptureDevices = NULL;

	// Defined in wizard.cpp
extern UINT_PTR GetPageBeforeVideoWiz();
extern UINT_PTR GetPageAfterVideo();

// index number of the user's selection on the combo box
static int g_nCurrentSelection = 0;

// set to true only if the user hit's back or next
static BOOL g_bCurrentValid = FALSE;

// was the user prompted to select a video device
static BOOL g_bPrompted = FALSE;


static char *BuildCaptureDeviceInfoString(FINDCAPTUREDEVICE *pCaptureDeviceInfo, char *szOut);


BOOL InitVidWiz()
{

	// initialize locals
	g_hDcapLib = NULL;
	DLL_FindFirstCaptureDevice = NULL;
	DLL_FindFirstCaptureDeviceByIndex = NULL;
	DLL_GetNumCaptureDevices = NULL;
	g_nCurrentSelection = 0;
   	g_bCurrentValid = FALSE;
	g_bPrompted = FALSE;

	g_hDcapLib = NmLoadLibrary("dcap32.dll",FALSE);
	if (g_hDcapLib == NULL)
		return FALSE;
	
	DLL_FindFirstCaptureDevice = (FFCD)GetProcAddress(g_hDcapLib, "FindFirstCaptureDevice");
	DLL_FindFirstCaptureDeviceByIndex = (FFCDBI)GetProcAddress(g_hDcapLib, "FindFirstCaptureDeviceByIndex");
	DLL_GetNumCaptureDevices = (GNCD)GetProcAddress(g_hDcapLib, "GetNumCaptureDevices");

	return TRUE;
}


// returns TRUE if the capture device id in the registry corresponds with
// the driver description string.
static BOOL IsVideoRegistryValid()
{
	RegEntry re(VIDEO_KEY);
	char szDriverDesc[200];
	char *szDriverDescReg;
	int numVideoDevices, nID;
	FINDCAPTUREDEVICE CaptureDeviceInfo;
	BOOL fRet;

	// just in case InitVidWiz wasn't called
	if (NULL == g_hDcapLib)
		return FALSE;

	numVideoDevices = DLL_GetNumCaptureDevices();	

	nID = re.GetNumber(REGVAL_CAPTUREDEVICEID, -1);
	szDriverDescReg = re.GetString(REGVAL_CAPTUREDEVICENAME);

	// no video devices and no registry entry is valid
	if ((numVideoDevices == 0) && (nID == -1))
	{
		return TRUE;
	}

	if ((numVideoDevices == 0) && (nID != -1))
	{
		return FALSE;
	}

	// TRUE == (numVideoDevice >= 1)

	// installed video devices but no registry entry is invalid
	if (nID == -1)
	{
		return FALSE;
	}

	CaptureDeviceInfo.dwSize = sizeof(FINDCAPTUREDEVICE);
	fRet = DLL_FindFirstCaptureDeviceByIndex(&CaptureDeviceInfo, nID);

	if (fRet == FALSE)
	{
		return FALSE;
	}

	BuildCaptureDeviceInfoString(&CaptureDeviceInfo, szDriverDesc);

	if (0 == lstrcmp(szDriverDescReg, szDriverDesc))
	{
		return TRUE;
	}
	return FALSE;
}


BOOL UnInitVidWiz()
{
	if (g_hDcapLib)
		FreeLibrary(g_hDcapLib);

	g_hDcapLib = NULL;

	return TRUE;
}


static char *BuildCaptureDeviceInfoString(FINDCAPTUREDEVICE *pCaptureDeviceInfo, char *szOut)
{
	if (pCaptureDeviceInfo->szDeviceDescription[0] != '\0')
	{
		lstrcpy(szOut, pCaptureDeviceInfo->szDeviceDescription);
	}
	else
	{
		lstrcpy(szOut, pCaptureDeviceInfo->szDeviceName);
	}

	if (pCaptureDeviceInfo->szDeviceVersion[0] != '\0')
	{
		lstrcat(szOut, _T(", "));
		lstrcat(szOut, pCaptureDeviceInfo->szDeviceVersion);
	}
	return szOut;
}


void UpdateVidConfigRegistry()
{
	FINDCAPTUREDEVICE CaptureDeviceInfo, *CaptureDevTable;
	RegEntry re(VIDEO_KEY);
	BOOL bRet;
	char strNameDesc[MAX_CAPDEV_NAME+MAX_CAPDEV_VERSION];
	int numVideoDevices, index, enum_index;

	// just in case InitVidWiz wasn't called
	if (NULL == g_hDcapLib)
		return;

	numVideoDevices = DLL_GetNumCaptureDevices();	

	// no devices - delete the registry entries
	if (numVideoDevices == 0)
	{
		re.DeleteValue(REGVAL_CAPTUREDEVICEID);
		re.DeleteValue(REGVAL_CAPTUREDEVICENAME);
		return;
	}


	// build a table of all the devices

	CaptureDevTable = (FINDCAPTUREDEVICE *)LocalAlloc(LPTR, numVideoDevices*sizeof(FINDCAPTUREDEVICE));

	if (NULL == CaptureDevTable)
	{
		ERROR_OUT(("UpdateVidConfigRegistry: Out of memory"));
		return;
	}

	index = 0;
	for (enum_index=0; enum_index < MAXVIDEODRIVERS; enum_index++)
	{
		CaptureDevTable[index].dwSize = sizeof(FINDCAPTUREDEVICE);
		bRet = DLL_FindFirstCaptureDeviceByIndex(&CaptureDevTable[index], enum_index);
		if (bRet == TRUE)
			index++;
		if (index == numVideoDevices)
			break;
	}

	if (index != numVideoDevices)
	{
		ERROR_OUT(("UpdateVidConfigReg: Device Enumeration Failure"));
		LocalFree(CaptureDevTable);
		return;
	}

	// if only one capture device:
	// don't bother to see if the previous entry was valid
	// just update the registry with the current default
	if (numVideoDevices == 1)
	{
		BuildCaptureDeviceInfoString(&CaptureDevTable[0], strNameDesc);
		re.SetValue(REGVAL_CAPTUREDEVICEID, CaptureDevTable[0].nDeviceIndex);
		re.SetValue(REGVAL_CAPTUREDEVICENAME, strNameDesc);
		LocalFree(CaptureDevTable);
		return;
	}

	// TRUE == (numVideoDevices >= 2)

	// user wasn't prompted - he must of had a valid registry to start with
	if (g_bPrompted == FALSE)
	{
		LocalFree(CaptureDevTable);
		return;
	}

	// the user pressed CANCEL during setup
	if (g_bCurrentValid == FALSE)
	{
		if (IsVideoRegistryValid() == TRUE)
		{
			LocalFree(CaptureDevTable);
			return;
		}
		else
			g_nCurrentSelection = 0;
	}
		

	CaptureDeviceInfo = CaptureDevTable[g_nCurrentSelection];

	BuildCaptureDeviceInfoString(&CaptureDeviceInfo, strNameDesc);
	re.SetValue(REGVAL_CAPTUREDEVICEID, CaptureDeviceInfo.nDeviceIndex);
	re.SetValue(REGVAL_CAPTUREDEVICENAME, strNameDesc);

	LocalFree(CaptureDevTable);

	return;
}


// if <= 1 video capture device, return false
// if 2 or more video devices and the Wizard is in force mode, return true
// if 2 or more video devices and a MATCHING registry entry, return false
// otherwise something is fishy - return true
BOOL NeedVideoPropPage(BOOL fForce)
{
	// just in case InitVidWiz wasn't called
	if (NULL == g_hDcapLib)
		return FALSE;

	// check the system policies for sending video
	if (_Module.IsSDKCallerRTC() || SysPol::NoVideoSend())
	{
		WARNING_OUT(("Video is disabled by system policies key\r\n"));
		return FALSE;
	}

	// count how many devices we have
	int numCaptureDevices = DLL_GetNumCaptureDevices();
	if (numCaptureDevices <= 1)
	{
		return FALSE;
	}

	// TRUE == (numCaptureDevice >= 2)

	if (fForce)
	{
		g_bPrompted = TRUE;
		return TRUE;
	}

	if (IsVideoRegistryValid() == TRUE)
	{
		return FALSE;
	}

	g_bPrompted = TRUE;
	return TRUE;
}



// Message handler for property page
INT_PTR APIENTRY VidWizDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	HWND  hwndCB;  // handle to the dialog box
	int index;
	char szDriverNameDesc[MAX_CAPDEV_NAME+MAX_CAPDEV_VERSION];
	static LONG_PTR button_mask;
	FINDCAPTUREDEVICE CaptureDeviceInfo;
	
	hwndCB = GetDlgItem(hDlg, IDC_VWCOMBO);

	switch(message)
	{
		case(WM_INITDIALOG) :
			button_mask = ((PROPSHEETPAGE *)lParam)->lParam;
			if (g_hDcapLib == NULL) break;
			for (index = 0; index < MAXVIDEODRIVERS; index++)
			{
				CaptureDeviceInfo.dwSize = sizeof(FINDCAPTUREDEVICE);
				if (DLL_FindFirstCaptureDeviceByIndex(&CaptureDeviceInfo, index))
				{
					BuildCaptureDeviceInfoString(&CaptureDeviceInfo, szDriverNameDesc);
					ComboBox_AddString(hwndCB, szDriverNameDesc);
				}
			}
			ComboBox_SetCurSel(hwndCB, g_nCurrentSelection);
			break;

		case(WM_NOTIFY) :
			switch (((NMHDR *)lParam)->code)
			{
				case PSN_WIZBACK:
				{
					UINT_PTR iPrev = GetPageBeforeVideoWiz();
					ASSERT( iPrev );
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, iPrev);
					g_bCurrentValid = TRUE;
					return TRUE;
				}

				case PSN_WIZNEXT:
				{
					UINT_PTR iNext = GetPageAfterVideo();
					ASSERT( iNext );
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, iNext);
					g_bCurrentValid = TRUE;
					return TRUE;
				}

				case PSN_WIZFINISH:
				case PSN_KILLACTIVE:
					SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					g_bCurrentValid = TRUE;
					break;

				case PSN_SETACTIVE:
					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), (button_mask & PSWIZB_NEXT) ? PSBTN_NEXT : PSBTN_FINISH);
					}
					else
					{
						PropSheet_SetWizButtons(GetParent(hDlg), button_mask);
					}
					break;

				case PSN_RESET:
					// psn_reset get's received even if user presses
					// cancel on another dialog.
					g_bCurrentValid = FALSE;
					break;

				default:
					return FALSE;
			}
			break;


		// combox box messages get sent here.
		// only one we need is when the user selects something
		case(WM_COMMAND) :
			if (HIWORD(wParam) == CBN_SELCHANGE)
			{
				g_nCurrentSelection = ComboBox_GetCurSel(hwndCB);
				break;
			}
			else
			{
				return FALSE;
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\vidview.h ===
/****************************************************************************
*
*	 FILE:	   VidView.h
*
*	 CREATED:  Chris Pirich (ChrisPi) 12-16-96
*
****************************************************************************/

#ifndef _VIDVIEW_H_
#define _VIDVIEW_H_

#include <ih323cc.h>

#include "GenWindow.h"
#include "SDKInternal.h"

typedef HANDLE HDRAWDIB; /* hdd */

class CVideoWindow;

interface IVideoChange : public IUnknown
{
	virtual void StateChange(CVideoWindow *pVideo, NM_VIDEO_STATE uState) = 0;
} ;

class CVideoWindow : public CGenWindow, public INmChannelVideoNotify
{
public:
	static VOID    SetMirror(BOOL bMirror);
	static BOOL    GetMirror() {return g_fMirror != FALSE;}

	enum VideoType
	{
		REMOTE,
		LOCAL
	} ;

	CVideoWindow(VideoType eType, BOOL bEmbedded);
	~CVideoWindow();

	BOOL	Create(HWND hwndOwner, HPALETTE hPal, IVideoChange *pNotify=NULL);

	BOOL	IsXferAllowed();
	BOOL	IsAutoXferEnabled();
	BOOL	IsXferEnabled();
	BOOL    IsPaused();
	BOOL    IsConnected();
	HRESULT GetVideoState(NM_VIDEO_STATE* puState);

	BOOL	CanCopy();

	BOOL	HasDialog(DWORD dwDialog);

	DWORD	GetFrameSize() { return(m_dwFrameSize); }
	DWORD	GetFrameSizes();
	DWORD	GetImageQuality() { return(m_dwImageQuality); }
	DWORD	GetNumCapDev();
	DWORD	GetMaxCapDevNameLen();
	DWORD	GetCurrCapDevID();

	VOID	SetCurrCapDevID(DWORD dwID);
	HRESULT	SetImageQuality(DWORD dwQuality);
	HRESULT SetCameraDialog(ULONG ul);
	HRESULT GetCameraDialog(ULONG* pul);
	VOID	SetFrameSize(DWORD dwSize);
	VOID    SetZoom(UINT nZoom);

	VOID	EnableAutoXfer(BOOL fEnable);

	VOID	ShowDialog(DWORD dwDialog);
	VOID	SaveSettings();
	VOID    Pause(BOOL fPause);
	VOID    RefreshWindow() { OnFrameAvailable(); }
	VOID	ResizeWindowsToFrameSize();

	VOID	EnumCapDev(DWORD *pdwCapDevIDs, LPTSTR pszCapDevNames, DWORD dwNumCapDev);

	VOID    OnPaletteChanged(void);
	VOID	OnMinimize(BOOL fMinimize) { /* Should this pause the video? */ }
	HRESULT OnChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel);
	VOID	ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);

	void	UpdateVideoMenu(HMENU hMenu);
	void	OnCommand(int idCmd);

	void SetZoomable(BOOL bZoomable) { m_fZoomable = (bZoomable!=FALSE); }
	BOOL IsZoomable() { return(m_fZoomable != FALSE); }

	// IUnknown
	STDMETHODIMP_(ULONG) AddRef(void) { return(CGenWindow::AddRef()); }
	STDMETHODIMP_(ULONG) Release(void) { return(CGenWindow::Release()); }
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	// INmChannelVideoNotify
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	STDMETHODIMP StateChanged(NM_VIDEO_STATE uState);
	STDMETHODIMP PropertyChanged(DWORD dwReserved);

	// IGenWindow
	virtual VOID GetDesiredSize(SIZE *ppt);

	static BOOL FDidNotDisplayIntelLogo();
	static VOID DisplayIntelLogo( BOOL bDisplay );

protected:
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	// Array keeping track of all video windows, so they can be invalidated
	// when the state changes (like mirroring)
	static CSimpleArray<CVideoWindow *> *g_pVideos;
	// Specifies whether we are mirroring the local video.
	static BOOL g_fMirror;
	// Specifies whether we have done one-time local video init stuff
	static BOOL g_bLocalOneTimeInited;

	static VOID InvalidateAll();

	INmChannelVideo* m_pActiveChannel;
	DWORD			m_dwCookie;
	DWORD			m_dwImageQuality;
	UINT			m_nXferOnConnect;

	DWORD			m_dwFrameSize;
	SIZE			m_sizeVideo;

	HDRAWDIB		m_hdd;
	HPALETTE		m_hPal;

	UINT			m_zoom;

	IVideoChange *m_pNotify;

	BOOL			m_fLocal : 1;
	// CMainUI uses this to disallow zoom on the PiP window
	BOOL			m_fZoomable : 1;
	// Use this to make sure the embedded window does not display CIF
	BOOL			m_bEmbedded : 1;

	VOID		SetVideoSize(LPSIZE lpsize);

	UINT		GetZoom() { return(m_zoom); }
	BOOL		ShouldMirror() { return(IsLocal() && GetMirror()); }

	VOID		OnFrameAvailable(void);
	VOID		PaintDib(HDC hdc, FRAMECONTEXT *pFrame);
	VOID		PaintLogo(HDC hdc, UINT idbLargeLogo, UINT idbSmallLogo);
	VOID		OnPaint();
	VOID		OnNCDestroy();
	void		OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);

	BOOL		CopyToClipboard();

	HRESULT 	GetFrame(FRAMECONTEXT *pFrameContext);
	HRESULT 	ReleaseFrame(FRAMECONTEXT *pFrameContext);

	BOOL        InitMirroring(RECT &rcVideo);
	VOID        UnInitMirroring();

	HBITMAP     m_hBitmapMirror;
	SIZE        m_sizeBitmapMirror;
	HDC         m_hDCMirror;
	HGDIOBJ     m_hGDIObj;

	

	BOOL		IsLocal() { return m_fLocal; }
};

#endif // _VIDVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\wabme.cpp ===
// File: wabme.cpp

#include "precomp.h"

#include "wabme.h"
#include "wabtags.h"
#include "wabiab.h"

BOOL GetKeyDataForProp(long nmProp, HKEY * phkey, LPTSTR * ppszSubKey, LPTSTR * ppszValue, BOOL *pfString)
{
        // Default to ULS registry key
        *phkey = HKEY_CURRENT_USER;
        *ppszSubKey = ISAPI_KEY "\\" REGKEY_USERDETAILS;
        *pfString = TRUE;

        switch (nmProp)
                {
        default:
                WARNING_OUT(("GetKeyDataForProp - invalid argument %d", nmProp));
                return FALSE;

        case NM_SYSPROP_EMAIL_NAME:    *ppszValue = REGVAL_ULS_EMAIL_NAME;    break;
        case NM_SYSPROP_SERVER_NAME:   *ppszValue = REGVAL_SERVERNAME;        break;
        case NM_SYSPROP_RESOLVE_NAME:  *ppszValue = REGVAL_ULS_RES_NAME;      break;
        case NM_SYSPROP_FIRST_NAME:    *ppszValue = REGVAL_ULS_FIRST_NAME;    break;
        case NM_SYSPROP_LAST_NAME:     *ppszValue = REGVAL_ULS_LAST_NAME;     break;
        case NM_SYSPROP_USER_NAME:     *ppszValue = REGVAL_ULS_NAME;          break;
        case NM_SYSPROP_USER_LOCATION: *ppszValue = REGVAL_ULS_LOCATION_NAME; break;
        case NM_SYSPROP_USER_COMMENTS: *ppszValue = REGVAL_ULS_COMMENTS_NAME; break;

                } /* switch (nmProp) */

        return TRUE;
}


/*  W A B  R E A D  M E  */
/*-------------------------------------------------------------------------
    %%Function: WabReadMe

    Prep the NetMeeting registry settings with the data from the WAB "Me" entry.
    This function is also used by the main UI wizard.
-------------------------------------------------------------------------*/
int WabReadMe(void)
{
        CWABME * pWab = new CWABME;
        if (NULL == pWab)
                return FALSE;

        HRESULT hr = pWab->ReadMe();

        delete pWab;

        return SUCCEEDED(hr);
}


/*  R E A D  M E  */
/*-------------------------------------------------------------------------
    %%Function: ReadMe

    Read the WAB data, if it exists (but don't create a default "ME")
-------------------------------------------------------------------------*/
HRESULT CWABME::ReadMe(void)
{
        if (NULL == m_pWabObject)
        {
                return E_FAIL; // no wab installed?
        }

        SBinary eid;
        HRESULT hr = m_pWabObject->GetMe(m_pAdrBook, AB_NO_DIALOG | WABOBJECT_ME_NOCREATE, NULL, &eid, 0);
        if (SUCCEEDED(hr))
        {
                ULONG ulObjType = 0;
                LPMAPIPROP pMapiProp = NULL;
                hr = m_pAdrBook->OpenEntry(eid.cb, (LPENTRYID) eid.lpb, NULL, 0,
                                                &ulObjType, (LPUNKNOWN *)&pMapiProp);
                if (SUCCEEDED(hr))
                {
                        if (NULL != pMapiProp)
                        {
                                EnsurePropTags(pMapiProp);

                                UpdateRegEntry(pMapiProp, NM_SYSPROP_EMAIL_NAME,    PR_EMAIL_ADDRESS);
                                UpdateRegEntry(pMapiProp, NM_SYSPROP_FIRST_NAME,    PR_GIVEN_NAME);
                                UpdateRegEntry(pMapiProp, NM_SYSPROP_LAST_NAME,     PR_SURNAME);
                                UpdateRegEntry(pMapiProp, NM_SYSPROP_USER_NAME,     PR_DISPLAY_NAME);
                                UpdateRegEntry(pMapiProp, NM_SYSPROP_USER_LOCATION, PR_LOCALITY);
                                UpdateRegEntry(pMapiProp, NM_SYSPROP_USER_COMMENTS, PR_COMMENT);

                                UpdateRegEntryCategory(pMapiProp);
                                UpdateRegEntryServer(pMapiProp);

                                pMapiProp->Release();
                        }
                }
        }
        return hr;
}



/*  U P D A T E  R E G  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: UpdateRegEntry
    
-------------------------------------------------------------------------*/
HRESULT CWABME::UpdateRegEntry(LPMAPIPROP pMapiProp, NM_SYSPROP nmProp, ULONG uProp)
{
        HKEY   hkey;
        LPTSTR pszSubKey;
        LPTSTR pszValue;
        BOOL   fString;
        ULONG  cValues;
        LPSPropValue pData;

        SPropTagArray prop;
        prop.cValues = 1;
        prop.aulPropTag[0] = uProp;

        HRESULT hr = pMapiProp->GetProps(&prop, 0, &cValues, &pData);
        if (S_OK == hr)
        {
                if ((1 == cValues) && !FEmptySz(pData->Value.lpszA))
                {
                        if (GetKeyDataForProp(nmProp, &hkey, &pszSubKey, &pszValue, &fString))
                        {
                                ASSERT((HKEY_CURRENT_USER == hkey) && fString);
                                RegEntry re(pszSubKey, hkey);
                                re.SetValue(pszValue, pData->Value.lpszA);
                                WARNING_OUT(("Updated - %s to [%s]", pszValue, pData->Value.lpszA));
                        }
                }
                m_pWabObject->FreeBuffer(pData);
        }

        return hr;
}


// Update the user's server and resolved names in the registry
// based on the "ME" data
HRESULT CWABME::UpdateRegEntryServer(LPMAPIPROP pMapiProp)
{
        HRESULT hr;
        HKEY    hkey;
        LPTSTR  pszSubKey;
        LPTSTR  pszValue;
        BOOL    fString;
        ULONG   cValues;
        LPSPropValue pData;

        SPropTagArray propTag;
        propTag.cValues = 1;
        propTag.aulPropTag[0] = Get_PR_NM_DEFAULT();

        ULONG iDefault = 0; // the default server
        hr = pMapiProp->GetProps(&propTag, 0, &cValues, &pData);
        if (S_OK == hr)
        {
                iDefault = pData->Value.ul;
                m_pWabObject->FreeBuffer(pData);
        }

        // ILS server data is in an array of strings like "callto://server/email@address"
        propTag.aulPropTag[0] = Get_PR_NM_ADDRESS();
        hr = pMapiProp->GetProps(&propTag, 0, &cValues, &pData);
        if (S_OK == hr)
        {
                SLPSTRArray * pMVszA = &(pData->Value.MVszA);
                if ((0 != cValues) && (0 != pMVszA->cValues))
                {
                        ASSERT(iDefault < pMVszA->cValues);
                        LPCTSTR pszAddr = pMVszA->lppszA[iDefault];
                        pszAddr = PszSkipCallTo(pszAddr);

                        // Resolve Name is "server/email@address"
                        if (GetKeyDataForProp(NM_SYSPROP_RESOLVE_NAME, &hkey, &pszSubKey, &pszValue, &fString))
                        {
                                ASSERT((HKEY_CURRENT_USER == hkey) && fString);
                                RegEntry re(pszSubKey, hkey);
                                re.SetValue(pszValue, pszAddr);
                                WARNING_OUT(("Updated - %s to [%s]", pszValue, pszAddr));
                        }

                        LPCTSTR pszSlash = _StrChr(pszAddr, _T('/'));
                        if (NULL != pszSlash)
                        {
                                pszSlash++;
                                TCHAR szServer[CCHMAXSZ_SERVER];
                                lstrcpyn(szServer, pszAddr, (int)min(CCHMAX(szServer), pszSlash - pszAddr));
                                if (GetKeyDataForProp(NM_SYSPROP_SERVER_NAME, &hkey, &pszSubKey, &pszValue, &fString))
                                {
                                        ASSERT((HKEY_CURRENT_USER == hkey) && fString);
                                        RegEntry re(pszSubKey, hkey);
                                        re.SetValue(pszValue, szServer);
                                        WARNING_OUT(("Updated - %s to [%s]", pszValue, szServer));
                                }
                        }
                }
                m_pWabObject->FreeBuffer(pData);
        }

        return hr;
}


// Update the user's category in the registry
// based on the WAB value for the "ME" NetMeeting user category
HRESULT CWABME::UpdateRegEntryCategory(LPMAPIPROP pMapiProp)
{
        HKEY   hkey;
        LPTSTR pszSubKey;
        LPTSTR pszValue;
        BOOL   fString;
        ULONG  cValues;
        LPSPropValue pData;

        SPropTagArray prop;
        prop.cValues = 1;
        prop.aulPropTag[0] = Get_PR_NM_CATEGORY();

        HRESULT hr = pMapiProp->GetProps(&prop, 0, &cValues, &pData);
        if (S_OK == hr)
        {
                if (1 == cValues)
                {
                        if (GetKeyDataForProp(NM_SYSPROP_USER_CATEGORY, &hkey, &pszSubKey, &pszValue, &fString))
                        {
                                ASSERT((HKEY_CURRENT_USER == hkey) && !fString);
                                RegEntry re(pszSubKey, hkey);
                                re.SetValue(pszValue, pData->Value.l);
                                WARNING_OUT(("Updated - category to %d", pData->Value.l));
                        }
                }
                m_pWabObject->FreeBuffer(pData);
        }

        return hr;
}




/*  W A B  W R I T E  M E  */
/*-------------------------------------------------------------------------
    %%Function: WabWriteMe

    Write the current NM settings to the WAB "Me" entry.
    This function is also used by the main UI wizard.
-------------------------------------------------------------------------*/
int WabWriteMe(void)
{
        CWABME * pWab = new CWABME;
        if (NULL == pWab)
                return FALSE;

        HRESULT hr = pWab->WriteMe();

        delete pWab;

        return SUCCEEDED(hr);
}


/*  W R I T E  M E  */
/*-------------------------------------------------------------------------
    %%Function: WriteMe

    Write the "ME" data only if no entry already exists.
-------------------------------------------------------------------------*/
HRESULT CWABME::WriteMe(void)
{
        return( S_OK );

        if (NULL == m_pWabObject)
        {
                return E_FAIL; // no wab installed?
        }

        SBinary eid;
        HRESULT hr = m_pWabObject->GetMe(m_pAdrBook, AB_NO_DIALOG, NULL, &eid, 0);
        if (SUCCEEDED(hr))
        {
                ULONG ulObjType = 0;
                LPMAPIPROP pMapiProp = NULL;
                hr = m_pAdrBook->OpenEntry(eid.cb, (LPENTRYID) eid.lpb, NULL, MAPI_MODIFY,
                                                &ulObjType, (LPUNKNOWN *)&pMapiProp);
                if (SUCCEEDED(hr))
                {
                        if (NULL != pMapiProp)
                        {
                                EnsurePropTags(pMapiProp);

                                UpdateProp(pMapiProp, NM_SYSPROP_FIRST_NAME,    PR_GIVEN_NAME);
                                UpdateProp(pMapiProp, NM_SYSPROP_LAST_NAME,     PR_SURNAME);
                                UpdateProp(pMapiProp, NM_SYSPROP_USER_NAME,     PR_DISPLAY_NAME);
                                UpdateProp(pMapiProp, NM_SYSPROP_USER_CITY,     PR_LOCALITY);           // Business
                                UpdateProp(pMapiProp, NM_SYSPROP_USER_CITY,     PR_HOME_ADDRESS_CITY);  // Personal
                                UpdateProp(pMapiProp, NM_SYSPROP_USER_COMMENTS, PR_COMMENT);

                                UpdatePropServer(pMapiProp);
                                
                                hr = pMapiProp->SaveChanges(FORCE_SAVE);
                                pMapiProp->Release();
                        }
                }
        }
        return hr;

}


/*  U P D A T E  P R O P  */
/*-------------------------------------------------------------------------
    %%Function: UpdateProp

    Update a WAB properly based on the corresponding registry string.
-------------------------------------------------------------------------*/
HRESULT CWABME::UpdateProp(LPMAPIPROP pMapiProp, NM_SYSPROP nmProp, ULONG uProp)
{
        HKEY   hkey;
        LPTSTR pszSubKey;
        LPTSTR pszValue;
        BOOL   fString;

        HRESULT hr = GetKeyDataForProp(nmProp, &hkey, &pszSubKey, &pszValue, &fString) ? S_OK : E_FAIL;

        if (SUCCEEDED(hr))
        {
                ASSERT((HKEY_CURRENT_USER == hkey) && fString);
                RegEntry re(pszSubKey, hkey);

                LPTSTR psz = re.GetString(pszValue);
                if (!FEmptySz(psz))
                {
                        hr = UpdatePropSz(pMapiProp, uProp, psz, FALSE);
                }
        }

        return hr;
}


// Update a WAB property to the given string.
// Replace existing data only if fReplace is TRUE
HRESULT CWABME::UpdatePropSz(LPMAPIPROP pMapiProp, ULONG uProp, LPTSTR psz, BOOL fReplace)
{
        HRESULT hr;

        if (!fReplace)
        {       // Don't replace existing data
                ULONG  cValues;
                LPSPropValue pData;

                SPropTagArray propTag;
                propTag.cValues = 1;
                propTag.aulPropTag[0] = uProp;

                hr = pMapiProp->GetProps(&propTag, 0, &cValues, &pData);
                if (S_OK == hr)
                {
                        if ((1 == cValues) && !FEmptySz(pData->Value.lpszA))
                        {
                                hr = S_FALSE;
                        }
                        m_pWabObject->FreeBuffer(pData);

                        if (S_OK != hr)
                                return hr;
                }
        }

        SPropValue propVal;
        propVal.ulPropTag = uProp;
        propVal.Value.lpszA = psz;
        
        hr = pMapiProp->SetProps(1, &propVal, NULL);
        WARNING_OUT(("Updated - property %08X to [%s]", uProp, propVal.Value.lpszA));

        return hr;
}


static const TCHAR g_pcszSMTP[] = TEXT("SMTP"); // value for PR_ADDRTYPE

// Update the default WAB "callto" information
HRESULT CWABME::UpdatePropServer(LPMAPIPROP pMapiProp)
{
        HKEY   hkey;
        LPTSTR pszSubKey;
        LPTSTR pszValue;
        BOOL   fString;

        TCHAR szServer[CCHMAXSZ_SERVER];
        GetKeyDataForProp(NM_SYSPROP_SERVER_NAME, &hkey, &pszSubKey, &pszValue, &fString);
        RegEntry re(pszSubKey, hkey);
        lstrcpyn(szServer, re.GetString(pszValue), CCHMAXSZ_SERVER);

        // Save the email address
        LPTSTR pszEmail = re.GetString(REGVAL_ULS_EMAIL_NAME);
        if (S_OK == UpdatePropSz(pMapiProp, PR_EMAIL_ADDRESS, pszEmail, FALSE))
        {
                UpdatePropSz(pMapiProp, PR_ADDRTYPE, (LPTSTR) g_pcszSMTP, FALSE);
        }

        // Create the full "callto://server/foo@bar.com"
        TCHAR sz[MAX_PATH*2];
        if (!FCreateCallToSz(szServer, pszEmail, sz, CCHMAX(sz)))
                return E_OUTOFMEMORY;

        LPTSTR psz = sz;
        SPropValue propVal;
        propVal.ulPropTag = Get_PR_NM_ADDRESS();
        propVal.Value.MVszA.cValues = 1;
        propVal.Value.MVszA.lppszA = &psz;
        
        HRESULT hr = pMapiProp->SetProps(1, &propVal, NULL);
        WARNING_OUT(("Updated - NM server [%s]", sz));
        if (SUCCEEDED(hr))
        {
                // Set this as the default
                propVal.ulPropTag = Get_PR_NM_DEFAULT();
                propVal.Value.ul = 0;
                hr = pMapiProp->SetProps(1, &propVal, NULL);
        }
        
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\wabme.h ===
// File: wabme.h

#ifndef _WABME_H_
#define _WABME_H_

#include "wabutil.h"
#include "SDKInternal.h"

class CWABME : public CWABUTIL
{
public:
	CWABME() {};
	~CWABME() {};

	HRESULT ReadMe(void);
	HRESULT UpdateRegEntry(LPMAPIPROP pMapiProp, NM_SYSPROP nmProp, ULONG uProp);
	HRESULT UpdateRegEntryLocation(LPMAPIPROP pMapiProp);
	HRESULT UpdateRegEntryServer(LPMAPIPROP pMapiProp);
	HRESULT UpdateRegEntryCategory(LPMAPIPROP pMapiProp);

	HRESULT WriteMe(void);
	HRESULT UpdateProp(LPMAPIPROP pMapiProp, NM_SYSPROP nmProp, ULONG uProp);
	HRESULT UpdatePropSz(LPMAPIPROP pMapiProp, ULONG uProp, LPTSTR psz, BOOL fReplace);
	HRESULT UpdatePropServer(LPMAPIPROP pMapiProp);
};

int WabReadMe();
int WabWriteMe();

#endif /* _WABME_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\wabutil.h ===
// File: wabutil.h

#ifndef _WABUTIL_H_
#define _WABUTIL_H_

#include "wabdefs.h"
#include "wabapi.h"

///////////////////////////////////////
// NetMeeting named prop IDs in the WAB

// DEFINE_OLEGUID(PS_Conferencing, 0x00062004, 0, 0);
#define PR_SERVERS          0x8056
#define CONF_DEFAULT_INDEX  0x8057
#define CONF_BACKUP_INDEX   0x8058
#define CONF_EMAIL_INDEX    0x8059

#define PR_NM_ADDRESS       PROP_TAG(PT_MV_STRING8, PR_SERVERS)
#define PR_NM_DEFAULT       PROP_TAG(PT_LONG, CONF_DEFAULT_INDEX)
#define PR_NM_BACKUP        PROP_TAG(PT_LONG, CONF_BACKUP_INDEX)

// CLSID_ConferenceManager (see confguid.h)
#define NM_TAG_MASK         0x0800
#define CONF_CATEGORY       0x8800
#define CONF_CTRYCODE       0x8801
#define PR_NM_CATEGORY      PROP_TAG(PT_LONG,    CONF_CATEGORY)

class CWABUTIL
{
private:
	BOOL   m_fTranslatedTags; // TRUE after GetNamedPropsTags succeeds

public:
	CWABUTIL();
	~CWABUTIL();

	// It's just easier if everything is public
	LPADRBOOK   m_pAdrBook;
	LPWABOBJECT m_pWabObject;
	LPABCONT    m_pContainer;

	LPSPropTagArray m_pPropTags;  // Translated tags
	LPSPropTagArray GetTags()    {return m_pPropTags;}

	ULONG   Get_PR_NM_ADDRESS();
	ULONG   Get_PR_NM_DEFAULT();
	ULONG   Get_PR_NM_CATEGORY();

	LPCTSTR PszSkipCallTo(LPCTSTR psz);
	BOOL    FCreateCallToSz(LPCTSTR pszServer, LPCTSTR pszEmail, LPTSTR pszCallTo, UINT cchMax);
	VOID    FreeProws(LPSRowSet prows);
	HRESULT GetContainer(void);

	HRESULT EnsurePropTags(void);
	HRESULT EnsurePropTags(LPMAPIPROP pMapiProp);
	HRESULT GetNamedPropsTag(LPMAPIPROP pMapiProp, LPSPropTagArray pProps);

	HRESULT HrGetWABTemplateID(ULONG * lpcbEID, LPENTRYID * lppEID);
	HRESULT CreateNewEntry(HWND hwndParent, ULONG cProps, SPropValue * pProps);
	HRESULT _CreateWabEntry(HWND hwndParent,
			LPCTSTR pszDisplay, LPCTSTR pszFirst, LPCTSTR pszLast, LPCTSTR pcszEmail,
			LPCTSTR pszLocation, LPCTSTR pszPhoneNum, LPCTSTR pcszComments, LPCTSTR pcszCallTo);
	HRESULT CreateWabEntry(HWND hwndParent,
			LPCTSTR pszDisplay, LPCTSTR pszFirst, LPCTSTR pszLast, LPCTSTR pcszEmail,
			LPCTSTR pszLocation, LPCTSTR pszPhoneNum, LPCTSTR pcszComments, LPCTSTR pcszServer);
	HRESULT CreateWabEntry(HWND hwndParent,
			LPCTSTR pszDisplay, LPCTSTR pszEmail,
			LPCTSTR pszLocation, LPCTSTR pszPhoneNum, LPCTSTR pszULSAddress);
};


// This is used for the ptaEid and m_pPropTags data
enum {
    ieidPR_ENTRYID = 0,    // Unique Entry ID
    ieidPR_DISPLAY_NAME,   // Display Name
	ieidPR_NM_ADDRESS,     // MVsz (array of "callto://server/email")
	ieidPR_NM_DEFAULT,     // Default Index into MVsz
	ieidPR_NM_CATEGORY,    // User Category/Rating (Personal=1, Business=2, Adult=4)
    ieidMax
};


#endif /* _WABUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\wavedev.h ===
#ifndef _WAVEDEV_H
#define _WAVEDEV_H

#include "WaveIo.h"

class waveInDev
{
private:
	UINT m_devID;
	HWAVEIN m_hwi;
	BOOL m_bOpen;  // is the device open ?
	WAVEFORMATEX m_waveFormat;
	BOOL m_fAllowMapper;
	HANDLE m_hEvent;

public:
	waveInDev(UINT uDevId, HANDLE hEvent=NULL);
	~waveInDev();

	MMRESULT Open(int hertz=8000, int bps=16);
	MMRESULT Reset();
	MMRESULT Close();

	MMRESULT PrepareHeader(WAVEHDR *pHdr);
	MMRESULT UnPrepareHeader(WAVEHDR *pHdr);

	MMRESULT Record(WAVEHDR *pHdr);

	void AllowMapper(BOOL fAllow);
};


// waveOutDev works in blocking/synchronous mode and
// non-blocking async mode.  If a window handle is passed
// as the second argument to the contructor, then the window
// will receive message from the waveOut device and the calls
// are non-blocking.  Otherwise, Play() and PlayFile are blocking.
class waveOutDev
{
private:
	UINT m_devID;
	HWAVEOUT m_hwo;
	BOOL m_bOpen;  // is the device open
	HANDLE m_hWnd;
	HANDLE m_hEvent;
	WAVEFORMATEX m_waveFormat;
	BOOL m_fAllowMapper;


	// playfile needs a temporary buffer
	char *m_pfBuffer;
	WAVEHDR m_waveHdr;
	int m_nBufferSize;
	TCHAR m_szPlayFile[150];
	WAVEFORMATEX m_PlayFileWf;
	BOOL m_fFileBufferValid;

public:
	waveOutDev(UINT uDevID, HWND hwnd=NULL);
	~waveOutDev();

	MMRESULT Open(int hertz=8000, int bps=16);
	MMRESULT Open(WAVEFORMATEX *pWaveFormat);
	MMRESULT Close();

	MMRESULT PrepareHeader(WAVEHDR *pWhdr, SHORT *shBuffer=NULL, int numSamples=0);
	MMRESULT Play(WAVEHDR *pWhdr);
	MMRESULT UnprepareHeader(WAVEHDR *pWhdr);

	MMRESULT PlayFile(LPCTSTR szFileName);

	void AllowMapper(BOOL fAllow);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\wabutil.cpp ===
// File: wabutil.cpp
//
// Generic Windows Address Book utility functions

#include "precomp.h"

#include "wabutil.h"
#include "wabtags.h"
#include "wabiab.h"

#include <confguid.h> // for CLSID_ConferenceManager


static const TCHAR _szCallToWab[] = TEXT("callto://"); // the prefix for NM WAB entries

static const TCHAR g_pcszSMTP[] = TEXT("SMTP"); // value for PR_ADDRTYPE

// see rgData in CreateWabEntry
static const int IENTRYPROP_NM_DEFAULT = 5;
static const int IENTRYPROP_NM_ADDRESS = 6;


// REVIEW: There should be an external header file for these.
// They are documented in http://fbi/wabapi.htm

// DEFINE_OLEGUID(PS_Conferencing, 0x00062004, 0, 0);
static const GUID PS_Conferencing = {0x00062004, 0, 0, {0xC0,0,0,0,0,0,0,0x46} };


/////////////////////////////////////////////////////////////////////

static const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_ENTRYID,
        PR_DISPLAY_NAME,
        PR_NM_ADDRESS,
        PR_NM_DEFAULT,
        PR_NM_CATEGORY
    }
};
static const SizedSPropTagArray(1, ptaEidOnly)=
{
        1, {PR_ENTRYID}
};


enum {
    icrPR_DEF_CREATE_MAILUSER = 0,
    icrMax
};

static const SizedSPropTagArray(icrMax, ptaCreate) =
{
    icrMax,
    {
        PR_DEF_CREATE_MAILUSER,
    }
};



/////////////////////////////////////////////////////////////////////
//
// Dynamic WAB interface

const static TCHAR _szWABRegPathKey[] = TEXT("Software\\Microsoft\\WAB\\DLLPath");
const static TCHAR _szWABDll[]        = TEXT("WAB32DLL.dll");
const static char  _szWABOpen[]       = "WABOpen";

class WABDLL
{
private:
        static HINSTANCE m_hInstLib;
        static LPWABOPEN m_pfnWABOpen;

protected:
        WABDLL();
        ~WABDLL() {};
        
public:
        static HRESULT WABOpen(LPADRBOOK FAR *, LPWABOBJECT FAR *, LPWAB_PARAM, DWORD);
};

LPWABOPEN WABDLL::m_pfnWABOpen = NULL;
HINSTANCE WABDLL::m_hInstLib = NULL;

HRESULT WABDLL::WABOpen(LPADRBOOK FAR * lppAdrBook, LPWABOBJECT FAR * lppWABObject,
                        LPWAB_PARAM lpWP, DWORD dwReserved)
{
        if (NULL == m_pfnWABOpen)
        {
            HKEY hKey;
            TCHAR szPath[MAX_PATH];

        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                _szWABRegPathKey, 0, KEY_READ, &hKey))
                {
                        // Probably don't have IE4 installed
                        lstrcpy(szPath, _szWABDll);
                }
                else
                {
                    DWORD dwType = 0;
                    DWORD cbData = sizeof(szPath); // the size in BYTES
                        RegQueryValueEx(hKey, g_cszEmpty, NULL, &dwType, (LPBYTE) szPath, &cbData);
                        RegCloseKey(hKey);
                        if (FEmptySz(szPath))
                return E_NOINTERFACE;
                }

                m_hInstLib = LoadLibrary(szPath);
                if (NULL == m_hInstLib)
            return E_NOINTERFACE;

                m_pfnWABOpen = (LPWABOPEN) GetProcAddress(m_hInstLib, _szWABOpen);
                if (NULL == m_pfnWABOpen)
                {
                        FreeLibrary(m_hInstLib);
            return E_NOINTERFACE;
                }
        }

        return m_pfnWABOpen(lppAdrBook, lppWABObject, lpWP, dwReserved);
}

///////////////////////////////////////////////////////////////////////////



/*  C  W  A  B  U  T  I  L  */
/*-------------------------------------------------------------------------
    %%Function: CWABUTIL
    
-------------------------------------------------------------------------*/
CWABUTIL::CWABUTIL() :
        m_pAdrBook(NULL),
        m_pWabObject(NULL),
        m_pContainer(NULL),
        m_pPropTags(NULL),
        m_fTranslatedTags(FALSE)
{
        // Make a copy of the property data
        m_pPropTags = (LPSPropTagArray) new BYTE[sizeof(ptaEid)];
        if (NULL != m_pPropTags)
        {
                CopyMemory(m_pPropTags, &ptaEid, sizeof(ptaEid));

                WABDLL::WABOpen(&m_pAdrBook, &m_pWabObject, NULL, 0);
        }
}

CWABUTIL::~CWABUTIL()
{
        delete m_pPropTags;

        if (NULL != m_pContainer)
        {
                m_pContainer->Release();
        }
        if (NULL != m_pWabObject)
        {
                m_pWabObject->Release();
        }
        if (NULL != m_pAdrBook)
        {
                m_pAdrBook->Release();
        }
}


/*  P S Z  S K I P  C A L L  T O  */
/*-------------------------------------------------------------------------
    %%Function: PszSkipCallTo

    Return a pointer after the "callto://" string.
-------------------------------------------------------------------------*/
LPCTSTR CWABUTIL::PszSkipCallTo(LPCTSTR psz)
{
        ASSERT(!FEmptySz(psz));

        TCHAR szTemp[CCHMAX(_szCallToWab)];
        lstrcpyn(szTemp, psz, CCHMAX(szTemp)); // FUTURE: Use StrCmpNI
        if (0 == lstrcmpi(szTemp, _szCallToWab))
        {
                psz += CCHMAX(_szCallToWab)-1;
        }

        return psz;
}

BOOL CWABUTIL::FCreateCallToSz(LPCTSTR pszServer, LPCTSTR pszEmail, LPTSTR pszDest, UINT cchMax)
{
        if ((lstrlen(pszServer) + lstrlen(pszEmail) + CCHMAX(_szCallToWab)) >= cchMax)
                return FALSE; // it won't fix
        
        // This has the format:  "callto://server/foo@bar.com"
        wsprintf(pszDest, TEXT("%s%s/%s"), _szCallToWab, pszServer, pszEmail);
        ASSERT(lstrlen(pszDest) < (int) cchMax);
        return TRUE;
}


ULONG CWABUTIL::Get_PR_NM_ADDRESS(void)
{
        ASSERT(m_fTranslatedTags);
        return m_pPropTags->aulPropTag[ieidPR_NM_ADDRESS];
}

ULONG CWABUTIL::Get_PR_NM_DEFAULT(void)
{
        ASSERT(m_fTranslatedTags);
        return m_pPropTags->aulPropTag[ieidPR_NM_DEFAULT];
}

ULONG CWABUTIL::Get_PR_NM_CATEGORY(void)
{
        ASSERT(m_fTranslatedTags);
        return m_pPropTags->aulPropTag[ieidPR_NM_CATEGORY];
}

/*  F R E E  P R O W S  */
/*-------------------------------------------------------------------------
    %%Function: FreeProws
    
-------------------------------------------------------------------------*/
VOID CWABUTIL::FreeProws(LPSRowSet prows)
{
        if (NULL == prows)
                return;

        for (ULONG irow = 0; irow < prows->cRows; irow++)
        {
                m_pWabObject->FreeBuffer(prows->aRow[irow].lpProps);
        }

        m_pWabObject->FreeBuffer(prows);
}


/*  G E T  C O N T A I N E R  */
/*-------------------------------------------------------------------------
    %%Function: GetContainer
    
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::GetContainer(void)
{
        if (NULL != m_pContainer)
                return S_OK;

        ASSERT(NULL != m_pWabObject);
        ASSERT(NULL != m_pAdrBook);

        // get the entryid for the WAB
        ULONG cbEID;
        LPENTRYID lpEID;
        HRESULT hr = m_pAdrBook->GetPAB(&cbEID, &lpEID);
        if (SUCCEEDED(hr))
        {
                // use the entryid to get the container
                ULONG ulObjType = 0;
            hr = m_pAdrBook->OpenEntry(cbEID, lpEID, NULL, 0,
                                                        &ulObjType, (LPUNKNOWN *)&m_pContainer);
                m_pWabObject->FreeBuffer(lpEID);
        }

        return hr;
}


/*  E N S U R E  P R O P  T A G S  */
/*-------------------------------------------------------------------------
    %%Function: EnsurePropTags

    Ensure the special property tags are available.
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::EnsurePropTags(void)
{
        if (m_fTranslatedTags)
                return S_OK;

        ASSERT(NULL != m_pContainer);

        LPSRowSet pRowSet = NULL;
        LPMAPITABLE pAB = NULL;
        // get the WAB contents
        HRESULT hr = m_pContainer->GetContentsTable(0, &pAB);
        if (FAILED(hr))
        {
                return hr; // probably empty
        }

        if ((SUCCEEDED(hr = pAB->SetColumns((LPSPropTagArray)&ptaEidOnly, 0))) &&
                (SUCCEEDED(hr = pAB->SeekRow(BOOKMARK_BEGINNING, 0, NULL))) &&
                (SUCCEEDED(hr = pAB->QueryRows(1, 0, &pRowSet))) &&
                (NULL != pRowSet) )
        {
                if (0 != pRowSet->cRows)
                {
                        LPMAPIPROP pMapiProp = NULL;
                        ULONG ulObjType = 0;
                        hr = m_pContainer->OpenEntry(pRowSet->aRow[0].lpProps[0].Value.bin.cb,
                                                                                (LPENTRYID) pRowSet->aRow[0].lpProps[0].Value.bin.lpb,
                                                                                NULL,   // the object's standard i/f
                                                                                0,              // flags
                                                                                &ulObjType,
                                                                                (LPUNKNOWN *)&pMapiProp);
                        if (SUCCEEDED(hr))
                        {
                                hr = GetNamedPropsTag(pMapiProp, m_pPropTags);
                        }

                        if (NULL != pMapiProp)
                        {
                                pMapiProp->Release();
                        }
                }
                FreeProws(pRowSet);
        }

        if (NULL != pAB)
        {
                pAB->Release();
        }

        return hr;
}


// Use this version when no m_pContainer is available
HRESULT CWABUTIL::EnsurePropTags(LPMAPIPROP pMapiProp)
{
        if (m_fTranslatedTags)
                return S_OK;

        return GetNamedPropsTag(pMapiProp, m_pPropTags);
}

/*  G E T  N A M E D  P R O P S  T A G  */
/*-------------------------------------------------------------------------
    %%Function: GetNamedPropsTag

    Translate the named properties into their proper values
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::GetNamedPropsTag(LPMAPIPROP pMapiProp, LPSPropTagArray pProps)
{
        ASSERT(!m_fTranslatedTags);
        ASSERT(NULL != pMapiProp);
        ASSERT(NULL != pProps);

        int iProp;
        int cProps = pProps->cValues;  // total number of property tags
        ASSERT(0 != cProps);

        int iName;
        int cNames = 0;  // The number of named tags to translate
        for (iProp = 0; iProp < cProps; iProp++)
        {
                if (0 != (PROP_ID(pProps->aulPropTag[iProp]) & 0x8000))
                {
                        cNames++;
                }
        }
        ASSERT(0 != cNames);
        
        // allocate memory for the named props pointers array
        int cb = sizeof(LPMAPINAMEID) * cNames;
        LPMAPINAMEID * pNameIds = (LPMAPINAMEID *) new BYTE[cb];
        if (NULL == pNameIds)
                return E_OUTOFMEMORY;
        ZeroMemory(pNameIds, cb);

        // run through the prop tag array and build a MAPINAMEID for each prop tag
        HRESULT hr = S_OK;
        iName = 0;
        for (iProp = 0; iProp < cProps; iProp++)
        {
                ULONG ulTag = pProps->aulPropTag[iProp];
                if (0 != (PROP_ID(ulTag) & 0x8000))
                {
                pNameIds[iName] = new MAPINAMEID;
                if (NULL == pNameIds[iName])
                {
                                hr = E_OUTOFMEMORY;
                                break;
                }

                        // Either Outlook public or NetMeeting private tag
                        BOOL fPrivate = 0 != (PROP_ID(ulTag) & NM_TAG_MASK);
                        GUID * pGuid = (GUID *) (fPrivate ? &CLSID_ConferenceManager : &PS_Conferencing);
                        
                        pNameIds[iName]->lpguid = pGuid;
                        pNameIds[iName]->ulKind = MNID_ID;
                        pNameIds[iName]->Kind.lID = PROP_ID(ulTag);
                        iName++;
                }
        }

        if (SUCCEEDED(hr))
        {
                LPSPropTagArray pta = NULL;

                // get the named props "real" tags
                hr = pMapiProp->GetIDsFromNames(cNames, pNameIds, MAPI_CREATE, &pta);
                if (SUCCEEDED(hr))
                {
                        if (NULL == pta)
                        {
                                hr = E_FAIL;
                        }
                        else
                        {
                                // replace the named tags with the real tags in the passed in prop tag array,
                                // maintaining the types.
                                ULONG * pul = &pta->aulPropTag[0];
                                for (iProp = 0; iProp < cProps; iProp++)
                                {
                                        ULONG ulTag = pProps->aulPropTag[iProp];
                                        if (0 != (PROP_ID(ulTag) & 0x8000))
                                        {
                                                // set the property types on the returned props
                                                pProps->aulPropTag[iProp] = CHANGE_PROP_TYPE(*pul++, PROP_TYPE(ulTag));
                                        }
                                }

                                m_pWabObject->FreeBuffer(pta);
                        }
                }
        }

        // Cleanup
    if (NULL != pNameIds)
    {
            for (iName = 0; iName < cNames; iName++)
			{
				delete pNameIds[iName];
			}

                delete [] pNameIds;
        }

        m_fTranslatedTags = SUCCEEDED(hr);
        return hr;
}


/*  H R  G E T  W  A  B  T E M P L A T E  I  D  */
/*-------------------------------------------------------------------------
    %%Function: HrGetWABTemplateID

        Gets the WABs default Template ID for MailUsers or DistLists.
        These Template IDs are needed for creating new mailusers and distlists.
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::HrGetWABTemplateID(ULONG * lpcbEID, LPENTRYID * lppEID)
{
    *lpcbEID = 0;
    *lppEID = NULL;

    if (NULL == m_pAdrBook)
    {
        return E_INVALIDARG;
    }
    ASSERT(NULL != m_pWabObject);

        ULONG cbWABEID;
        LPENTRYID lpWABEID;
        HRESULT hr = m_pAdrBook->GetPAB(&cbWABEID, &lpWABEID);
        if (FAILED(hr))
                return hr;

        LPABCONT lpContainer = NULL;
        ULONG ulObjectType = MAPI_MAILUSER;
        hr = m_pAdrBook->OpenEntry(cbWABEID, lpWABEID, NULL, 0,
              &ulObjectType, (LPUNKNOWN *)&lpContainer);
        if (SUCCEEDED(hr))
        {
                ULONG cNewProps;
            LPSPropValue lpCreateEIDs = NULL;

            // Get the default creation entryids
                hr = lpContainer->GetProps((LPSPropTagArray)&ptaCreate, 0, &cNewProps, &lpCreateEIDs);
            if (S_OK == hr)
                {
                    // Validate the properites
                    if (lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag == PR_DEF_CREATE_MAILUSER)
                    {
                        ULONG nIndex = icrPR_DEF_CREATE_MAILUSER;
                            *lpcbEID = lpCreateEIDs[nIndex].Value.bin.cb;
                            if (S_OK == m_pWabObject->AllocateBuffer(*lpcbEID, (LPVOID *) lppEID))
                            {
                                        CopyMemory(*lppEID,lpCreateEIDs[nIndex].Value.bin.lpb,*lpcbEID);
                                }
                        }
                }

                if (NULL != lpCreateEIDs)
                {
                        m_pWabObject->FreeBuffer(lpCreateEIDs);
                }
        }

        if (NULL != lpContainer)
        {
                lpContainer->Release();
        }

        if (NULL != lpWABEID)
        {
                m_pWabObject->FreeBuffer(lpWABEID);
        }

        return hr;
}


/*  C R E A T E  N E W  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CreateNewEntry
    
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::CreateNewEntry(HWND hwndParent, ULONG cProps, SPropValue * pProps)
{
        ULONG cbEID;
        LPENTRYID lpEID;
        ULONG cbTplEID;
        LPENTRYID lpTplEID;

        // Get the template id which is needed to create the new object
        HRESULT hr = HrGetWABTemplateID(&cbTplEID, &lpTplEID);
        if (FAILED(hr))
                return hr;

        // get the entryid for the WAB
        hr = m_pAdrBook->GetPAB(&cbEID, &lpEID);
        if (FAILED(hr))
                return hr;

        // use the entryid to get the container
        ULONG ulObjType = 0;
        LPABCONT pContainer = NULL;
        hr = m_pAdrBook->OpenEntry(cbEID, lpEID, NULL, 0, &ulObjType, (LPUNKNOWN *)&pContainer);
        m_pWabObject->FreeBuffer(lpEID);
        if (SUCCEEDED(hr))
        {
                LPMAPIPROP pMapiProp = NULL;
                hr = pContainer->CreateEntry(cbTplEID, lpTplEID, CREATE_CHECK_DUP_LOOSE, &pMapiProp);
                if (SUCCEEDED(hr))
                {
                        if (PR_NM_ADDRESS == m_pPropTags->aulPropTag[ieidPR_NM_ADDRESS])
                        {
                                GetNamedPropsTag(pMapiProp, m_pPropTags);
                        }
                        (pProps+IENTRYPROP_NM_DEFAULT)->ulPropTag = m_pPropTags->aulPropTag[ieidPR_NM_DEFAULT];
                        (pProps+IENTRYPROP_NM_ADDRESS)->ulPropTag = m_pPropTags->aulPropTag[ieidPR_NM_ADDRESS];

                        LPSPropProblemArray pErr = NULL;
                        hr = pMapiProp->SetProps(cProps, pProps, &pErr);
                        if (SUCCEEDED(hr))
                        {
                                hr = pMapiProp->SaveChanges(FORCE_SAVE);

                                // Show the new entry
                                if (SUCCEEDED(hr))
                                {
                                        ULONG cProp1;
                                        LPSPropValue pPropEid;
                                        hr = pMapiProp->GetProps((LPSPropTagArray)&ptaEidOnly, 0, &cProp1, &pPropEid);
                                        if (S_OK == hr)
                                        {
                                        hr = m_pAdrBook->Details((LPULONG) &hwndParent, NULL, NULL,
                                                                    pPropEid->Value.bin.cb,
                                                                    (LPENTRYID) pPropEid->Value.bin.lpb,
                                                                    NULL, NULL, NULL, DIALOG_MODAL);
                                        }

                                        if (S_OK != hr)
                                        {
                                                // There was a problem, delete the entry
                                                ENTRYLIST eList;
                                                eList.cValues = 1;
                                                eList.lpbin = (LPSBinary) &pPropEid->Value.bin;

                                                pContainer->DeleteEntries(&eList, 0);
                                        }

                                        m_pWabObject->FreeBuffer(pPropEid);
                                }
                        }
                        else
                        {
                                // How could this ever fail?
                                m_pWabObject->FreeBuffer(pErr);
                        }

                        pMapiProp->Release();
                }
        }

        if (NULL != pContainer)
        {
                pContainer->Release();
        }

        return hr;
}


/*  C R E A T E  W A B  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CreateWabEntry
    
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::_CreateWabEntry(HWND hwndParent, LPCTSTR pszDisplay, LPCTSTR pszFirst, LPCTSTR pszLast,
        LPCTSTR pszEmail, LPCTSTR pszLocation, LPCTSTR pszPhoneNum, LPCTSTR pszComments,
        LPCTSTR pszCallTo)
{
        // These must be non-null
        ASSERT(!FEmptySz(pszDisplay));
        ASSERT(!FEmptySz(pszEmail));

        SPropValue rgData[13]; // maximum number of properties
        ZeroMemory(rgData, sizeof(rgData));

        rgData[0].ulPropTag = PR_DISPLAY_NAME;
        rgData[0].Value.lpszA = const_cast<LPTSTR>(pszDisplay);
        rgData[1].ulPropTag = PR_GIVEN_NAME;
        rgData[1].Value.lpszA = const_cast<LPTSTR>(pszFirst);
        rgData[2].ulPropTag = PR_SURNAME;
        rgData[2].Value.lpszA = const_cast<LPTSTR>(pszLast);
        rgData[3].ulPropTag = PR_EMAIL_ADDRESS;
        rgData[3].Value.lpszA = const_cast<LPTSTR>(pszEmail);
        rgData[4].ulPropTag = PR_ADDRTYPE;
        rgData[4].Value.lpszA = (LPSTR) g_pcszSMTP;

        // There is only one default server

        ASSERT(5 == IENTRYPROP_NM_DEFAULT);
        // LPSPropTagArray pPropTags = pWab->GetTags();  // Translated tags
        //rgData[IENTRYPROP_NM_DEFAULT].ulPropTag = pPropTags->aulPropTag[ieidPR_NM_DEFAULT];
        rgData[IENTRYPROP_NM_DEFAULT].Value.ul = 0;

        ASSERT(6 == IENTRYPROP_NM_ADDRESS);
        //rgData[IENTRYPROP_NM_ADDRESS].ulPropTag = pPropTags->aulPropTag[ieidPR_NM_ADDRESS];
        rgData[IENTRYPROP_NM_ADDRESS].Value.MVszA.cValues = 1;
        rgData[IENTRYPROP_NM_ADDRESS].Value.MVszA.lppszA =  const_cast<LPTSTR*>(&pszCallTo);


        // Add any other non-null properties
        SPropValue * pProp = &rgData[7];

        if (!FEmptySz(pszLocation))
        {
                pProp->ulPropTag = PR_LOCALITY;
                pProp->Value.lpszA = const_cast<LPTSTR>(pszLocation);
                pProp++;
        }

        if (!FEmptySz(pszPhoneNum))
        {
                pProp->ulPropTag = PR_BUSINESS_TELEPHONE_NUMBER;
                pProp->Value.lpszA = const_cast<LPTSTR>(pszPhoneNum);
                pProp++;
        }

        if (!FEmptySz(pszComments))
        {
                pProp->ulPropTag = PR_COMMENT;
                pProp->Value.lpszA = const_cast<LPTSTR>(pszComments);
                pProp++;
        }
        ULONG cProp = (ULONG)(pProp - rgData);
        ASSERT(cProp <= ARRAY_ELEMENTS(rgData));

        return CreateNewEntry(hwndParent, cProp, rgData);
}

/*  C R E A T E  W A B  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CreateWabEntry
    
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::CreateWabEntry(HWND hwndParent, LPCTSTR pszDisplay,
        LPCTSTR pszFirst, LPCTSTR pszLast, LPCTSTR pszEmail, LPCTSTR pszLocation,
        LPCTSTR pszPhoneNum, LPCTSTR pszComments,       LPCTSTR pszServer)
{
        // This has the format:  "callto://server/foo@bar.com"
        TCHAR szCallTo[MAX_PATH*2];
        LPTSTR pszCallTo = szCallTo;
        if (!FCreateCallToSz(pszServer, pszEmail, szCallTo, CCHMAX(szCallTo)))
                return E_OUTOFMEMORY;

        return _CreateWabEntry(hwndParent, pszDisplay, pszFirst, pszLast,
                pszEmail, pszLocation, pszPhoneNum, pszComments, pszCallTo);
}

/*  C R E A T E  W A B  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CreateWabEntry
    
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::CreateWabEntry(HWND hwndParent,
        LPCTSTR pszDisplay, LPCTSTR pszEmail,
        LPCTSTR pszLocation, LPCTSTR pszPhoneNum, LPCTSTR pszULSAddress)
{

        // This has the format:  "callto://server/foo@bar.com"
        TCHAR szCallTo[MAX_PATH*2];
        LPTSTR pszCallTo = szCallTo;
        if ((lstrlen(pszULSAddress) + CCHMAX(_szCallToWab)) >= CCHMAX(szCallTo))
                return E_FAIL; // it won't fit
        wsprintf(szCallTo, TEXT("%s%s"), _szCallToWab, pszULSAddress);

        return _CreateWabEntry(hwndParent, pszDisplay, g_szEmpty, g_szEmpty,
                pszEmail, pszLocation, pszPhoneNum, g_szEmpty, pszCallTo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\waveio.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  waveio.h
//
//  Description:
//      Contains structure definitions and prototypes for the functions in
//      waveio.c.  Also contains Win16/Win32 portability definitions.
//
//
//==========================================================================;

#ifndef _INC_WAVEIO
#define _INC_WAVEIO                 // #defined if file has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

#ifdef WIN32
    //
    //  for compiling Unicode
    //
    #ifndef SIZEOF
    #ifdef UNICODE
        #define SIZEOF(x)       (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)       sizeof(x)
    #endif
    #endif
#else
    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef TEXT
    #define TEXT(a)             a
    #endif

    #ifndef SIZEOF
    #define SIZEOF(x)           sizeof(x)
    #endif

    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif
#endif


//
//
//
//
//
#ifdef WIN32
    #define WIOAPI      _stdcall
#else
#ifdef _WINDLL
    #define WIOAPI      FAR PASCAL _loadds
#else
    #define WIOAPI      FAR PASCAL
#endif
#endif


//
//
//
typedef UINT        WIOERR;


//
//
//
//
typedef struct tWAVEIOCB
{
    DWORD           dwFlags;
    HMMIO           hmmio;

    DWORD           dwDataOffset;
    DWORD           dwDataBytes;
    DWORD           dwDataSamples;

    LPWAVEFORMATEX  pwfx;

#if 0
    HWAVEOUT        hwo;
    DWORD           dwBytesLeft;
    DWORD           dwBytesPerBuffer;
    
    DISP FAR *      pDisp;
    INFOCHUNK FAR * pInfo;
#endif

} WAVEIOCB, *PWAVEIOCB, FAR *LPWAVEIOCB;



//
//  error returns from waveio functions
//
#define WIOERR_BASE             (0)
#define WIOERR_NOERROR          (0)
#define WIOERR_ERROR            (WIOERR_BASE+1)
#define WIOERR_BADHANDLE        (WIOERR_BASE+2)
#define WIOERR_BADFLAGS         (WIOERR_BASE+3)
#define WIOERR_BADPARAM         (WIOERR_BASE+4)
#define WIOERR_BADSIZE          (WIOERR_BASE+5)
#define WIOERR_FILEERROR        (WIOERR_BASE+6)
#define WIOERR_NOMEM            (WIOERR_BASE+7)
#define WIOERR_BADFILE          (WIOERR_BASE+8)
#define WIOERR_NODEVICE         (WIOERR_BASE+9)
#define WIOERR_BADFORMAT        (WIOERR_BASE+10)
#define WIOERR_ALLOCATED        (WIOERR_BASE+11)
#define WIOERR_NOTSUPPORTED     (WIOERR_BASE+12)



//
//  function prototypes and flag definitions
//
WIOERR WIOAPI wioFileClose
(
    LPWAVEIOCB              pwio,
    DWORD                   fdwClose
);

WIOERR WIOAPI wioFileOpen
(
    LPWAVEIOCB              pwio,
    LPCTSTR                 pszFilePath,
    DWORD                   fdwOpen
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _INC_WAVEIO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\waveio.cpp ===
// File: waveio.cpp

#include "precomp.h"
#include "waveio.h"



//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  waveio.c
//
//  Description:
//      Contains routines for opening and closing RIFF WAVE files.
//
//
//==========================================================================;




//--------------------------------------------------------------------------;
//  
//  WIOERR wioFileClose
//  
//  Description:
//  
//  
//  Arguments:
//      LPWAVEIOCB pwio:
//  
//      DWORD fdwClose:
//  
//  Return (WIOERR):
//  
//--------------------------------------------------------------------------;

WIOERR WIOAPI wioFileClose
(
    LPWAVEIOCB      pwio,
    DWORD           fdwClose
)
{
    //
    //  validate a couple of things...
    //
    if (NULL == pwio)
        return (WIOERR_BADPARAM);


    //
    //  get rid of stuff...
    //
//  wioStopWave(pwio);
    
    if (NULL != pwio->hmmio)
    {
        mmioClose(pwio->hmmio, 0);
    }
    
//  FreeWaveHeaders(lpwio);

#if 0
    if (pwio->pInfo)
        riffFreeINFO(&(lpwio->pInfo));
    
    if (pwio->pDisp)
        riffFreeDISP(&(lpwio->pDisp));
#endif

    if (NULL != pwio->pwfx)
        GlobalFreePtr(pwio->pwfx);

    _fmemset(pwio, 0, sizeof(*pwio));

    return (WIOERR_NOERROR);
} // wioFileClose()


//--------------------------------------------------------------------------;
//  
//  WIOERR wioFileOpen
//  
//  Description:
//  
//  
//  Arguments:
//      LPWAVEIOCB pwio:
//  
//      LPCTSTR pszFilePath:
//  
//      DWORD fdwOpen:
//  
//  Return (WIOERR):
//  
//  
//--------------------------------------------------------------------------;

WIOERR WIOAPI wioFileOpen
(
    LPWAVEIOCB      pwio,
    LPCTSTR         pszFilePath,
    DWORD           fdwOpen
)
{
    WIOERR      werr;
    HMMIO       hmmio;
    MMCKINFO    ckRIFF;
    MMCKINFO    ck;
    DWORD       dw;

    //
    //  validate a couple of things...
    //
    if (NULL == pwio)
        return (WIOERR_BADPARAM);

    //
    //  default our error return (assume the worst)
    //
    _fmemset(pwio, 0, sizeof(*pwio));
    werr = WIOERR_FILEERROR;

    pwio->dwFlags   = fdwOpen;

    //
    //  first try to open the file, etc.. open the given file for reading
    //  using buffered I/O
    //
    hmmio = mmioOpen((LPTSTR)pszFilePath, NULL, MMIO_READ | MMIO_ALLOCBUF);
    if (NULL == hmmio)
        goto wio_Open_Error;

    pwio->hmmio     = hmmio;


    //
    //  locate a 'WAVE' form type...
    //
    ckRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
    if (mmioDescend(hmmio, &ckRIFF, NULL, MMIO_FINDRIFF))
        goto wio_Open_Error;

    //
    //  we found a WAVE chunk--now go through and get all subchunks that
    //  we know how to deal with...
    //
    pwio->dwDataSamples = (DWORD)-1L;

#if 0
    if (lrt=riffInitINFO(&wio.pInfo))
    {
        lr=lrt;
        goto wio_Open_Error;
    }
#endif

    //
    //
    //
    while (MMSYSERR_NOERROR == mmioDescend(hmmio, &ck, &ckRIFF, 0))
    {
        //
        //  quickly check for corrupt RIFF file--don't ascend past end!
        //
        if ((ck.dwDataOffset + ck.cksize) > (ckRIFF.dwDataOffset + ckRIFF.cksize))
        {
//				TCHAR       ach[255];
//            wsprintf(ach, TEXT("This wave file might be corrupt. The RIFF chunk.ckid '%.08lX' (data offset at %lu) specifies a cksize of %lu that extends beyond what the RIFF header cksize of %lu allows. Attempt to load?"),
//                     ck.ckid, ck.dwDataOffset, ck.cksize, ckRIFF.cksize);
//            u = MessageBox(NULL, ach, TEXT("wioFileOpen"),
//                           MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL);
//            if (IDNO == u)
//            {
                werr = WIOERR_BADFILE;
                goto wio_Open_Error;
//            }
        }

        switch (ck.ckid)
        {
            case mmioFOURCC('L', 'I', 'S', 'T'):
                if (ck.fccType == mmioFOURCC('I', 'N', 'F', 'O'))
                {
#if 0
                    if(lrt=riffReadINFO(hmmio, &ck, wio.pInfo))
                    {
                        lr=lrt;
                        goto wio_Open_Error;
                    }
#endif
                }
                break;
                
            case mmioFOURCC('D', 'I', 'S', 'P'):
#if 0
                riffReadDISP(hmmio, &ck, &(wio.pDisp));
#endif
                break;
                
            case mmioFOURCC('f', 'm', 't', ' '):
                //
                //  !?! another format chunk !?!
                //
                if (NULL != pwio->pwfx)
                    break;

                //
                //  get size of the format chunk, allocate and lock memory
                //  for it. we always alloc a complete extended format header
                //  (even for PCM headers that do not have the cbSize field
                //  defined--we just set it to zero).
                //
                dw = ck.cksize;
                if (dw < sizeof(WAVEFORMATEX))
                    dw = sizeof(WAVEFORMATEX);

                pwio->pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, dw);
                if (NULL == pwio->pwfx)
                {
                    werr = WIOERR_NOMEM;
                    goto wio_Open_Error;
                }

                //
                //  read the format chunk
                //
                werr = WIOERR_FILEERROR;
                dw = ck.cksize;
                if (mmioRead(hmmio, (HPSTR)pwio->pwfx, dw) != (LONG)dw)
                    goto wio_Open_Error;
                break;


            case mmioFOURCC('d', 'a', 't', 'a'):
                //
                //  !?! multiple data chunks !?!
                //
                if (0L != pwio->dwDataBytes)
                    break;

                //
                //  just hang on to the total length in bytes of this data
                //  chunk.. and the offset to the start of the data
                //
                pwio->dwDataBytes  = ck.cksize;
                pwio->dwDataOffset = ck.dwDataOffset;
                break;


            case mmioFOURCC('f', 'a', 'c', 't'):
                //
                //  !?! multiple fact chunks !?!
                //
                if (-1L != pwio->dwDataSamples)
                    break;

                //
                //  read the first dword in the fact chunk--it's the only
                //  info we need (and is currently the only info defined for
                //  the fact chunk...)
                //
                //  if this fails, dwDataSamples will remain -1 so we will
                //  deal with it later...
                //
                mmioRead(hmmio, (HPSTR)&pwio->dwDataSamples, sizeof(DWORD));
                break;
        }

        //
        //  step up to prepare for next chunk..
        //
        mmioAscend(hmmio, &ck, 0);
    }

    //
    //  if no fmt chunk was found, then die!
    //
    if (NULL == pwio->pwfx)
    {
        werr = WIOERR_ERROR;
        goto wio_Open_Error;
    }

    //
    //  all wave files other than PCM are _REQUIRED_ to have a fact chunk
    //  telling the number of samples that are contained in the file. it
    //  is optional for PCM (and if not present, we compute it here).
    //
    //  if the file is not PCM and the fact chunk is not found, then fail!
    //
    if (-1L == pwio->dwDataSamples)
    {
        if (WAVE_FORMAT_PCM == pwio->pwfx->wFormatTag)
        {
            pwio->dwDataSamples = pwio->dwDataBytes / pwio->pwfx->nBlockAlign;
        }
        else
        {
            //
            //  !!! HACK HACK HACK !!!
            //
            //  although this should be considered an invalid wave file, we
            //  will bring up a message box describing the error--hopefully
            //  people will start realizing that something is missing???
            //
//            u = MessageBox(NULL, TEXT("This wave file does not have a 'fact' chunk and requires one! This is completely invalid and MUST be fixed! Attempt to load it anyway?"),
//                           TEXT("wioFileOpen"), MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL);
//            if (IDNO == u)
//            {
                werr = WIOERR_BADFILE;
                goto wio_Open_Error;
//            }

            //
            //  !!! need to hack stuff in here !!!
            //
            pwio->dwDataSamples = 0L;
        }
    }

    //
    //  cool! no problems.. 
    //
    return (WIOERR_NOERROR);


    //
    //  return error (after minor cleanup)
    //
wio_Open_Error:

    wioFileClose(pwio, 0L);
    return (werr);
} // wioFileOpen()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\wavedev.cpp ===
#include "precomp.h"
#include "WaveDev.h"
#include "WaveIo.h"



// utility function for both waveIndev and waveOutdev
// builds a PCM WaveFormatEx structure for a given sampling rate and size
static MMRESULT MakeWaveFormat(WAVEFORMATEX *pWF, int hertz, int bps)
{
	WAVEFORMATEX waveFormat;

	if ((bps != 8) && (bps != 16))
	{
		return WAVERR_BADFORMAT;
	}

	waveFormat.wFormatTag = WAVE_FORMAT_PCM;
	waveFormat.nChannels = 1;
	waveFormat.nSamplesPerSec = hertz;
	waveFormat.nAvgBytesPerSec = hertz * bps/8;
	waveFormat.nBlockAlign = bps/8;
	waveFormat.wBitsPerSample = (WORD)bps;
	waveFormat.cbSize = 0;

	*pWF = waveFormat;

	return MMSYSERR_NOERROR;
}




waveInDev::waveInDev(UINT uDevId, HANDLE hEvent) :
  m_devID(uDevId), m_hwi(NULL), m_bOpen(FALSE), m_fAllowMapper(TRUE),
  m_hEvent(hEvent)
{
	ZeroMemory(&m_waveFormat, sizeof(m_waveFormat));
	return;
}


waveInDev::~waveInDev()
{
	Close();
}

MMRESULT waveInDev::Open(int hertz, int bps)
{
	MMRESULT mmr;
	WAVEFORMATEX waveFormat;
	DWORD dwCallbackType = (m_hEvent ? CALLBACK_EVENT : CALLBACK_NULL );

	if (m_bOpen == TRUE)
		return MMSYSERR_NOERROR;

	mmr = MakeWaveFormat(&waveFormat, hertz, bps);
	if (mmr != MMSYSERR_NOERROR)
	{
		return mmr;
	}

	mmr = waveInOpen(&m_hwi, m_devID, &waveFormat, (DWORD_PTR)m_hEvent, 0, dwCallbackType);

	// begin hack, try to open wave_mapper
	// this may end up opening a different device!

	if ((mmr == WAVERR_BADFORMAT) && (m_fAllowMapper))
	{
		mmr = waveInOpen(&m_hwi, WAVE_MAPPER, &waveFormat, (DWORD_PTR)m_hEvent,
		                 0, dwCallbackType);
	}

	if (mmr == MMSYSERR_NOERROR)
		m_bOpen = TRUE;

	waveInStart(m_hwi);

	m_waveFormat = waveFormat;

	return mmr;
}


MMRESULT waveInDev::PrepareHeader(WAVEHDR *pWaveHdr)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = waveInPrepareHeader(m_hwi, pWaveHdr, sizeof(WAVEHDR));

	return mmr;

}



MMRESULT waveInDev::UnPrepareHeader(WAVEHDR *pWaveHdr)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = waveInUnprepareHeader(m_hwi, pWaveHdr, sizeof(WAVEHDR));

	return mmr;

}



MMRESULT waveInDev::Reset()
{
	MMRESULT mmr;
	if (m_bOpen == FALSE)
		return MMSYSERR_NOERROR;

	mmr = waveInReset(m_hwi);

	return mmr;
}


MMRESULT waveInDev::Close()
{
	MMRESULT mmr;
	if (m_bOpen == FALSE)
		return MMSYSERR_NOERROR;

	waveInReset(m_hwi);
	mmr = waveInClose(m_hwi);

	if (mmr == MMSYSERR_NOERROR)
		m_bOpen = FALSE;

	return mmr;
}


MMRESULT waveInDev::Record(WAVEHDR *pHdr)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	mmr = waveInAddBuffer(m_hwi, pHdr, sizeof(WAVEHDR));

	return mmr;

}


void waveInDev::AllowMapper(BOOL fAllowMapper)
{
	m_fAllowMapper = fAllowMapper;
}




waveOutDev::waveOutDev(UINT uDevID, HWND hwnd)
 : m_devID(uDevID), m_hwo(NULL), m_bOpen(FALSE), m_hWnd(hwnd),
   m_pfBuffer(NULL), m_nBufferSize(0), m_fFileBufferValid(FALSE),
	m_fAllowMapper(TRUE)
{
	ZeroMemory(&m_waveFormat, sizeof(m_waveFormat));
	ZeroMemory(m_szPlayFile, sizeof(m_szPlayFile));
	ZeroMemory(&m_waveHdr, sizeof(m_waveHdr));

	if (hwnd == NULL)
	{
		m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

		if (m_hEvent == NULL)
		{
			ERROR_OUT(("waveOutDev::waveOutDev - Unable to create event"));
		}
	}
	else
		m_hEvent = NULL;

}

waveOutDev::~waveOutDev()
{
	Close();
	if (m_hEvent)
		CloseHandle(m_hEvent);

	if (m_pfBuffer)
		LocalFree(m_pfBuffer);
}



MMRESULT waveOutDev::Open(int hertz, int bps)
{
	MMRESULT mmr;
	WAVEFORMATEX waveFormat;

	mmr = MakeWaveFormat(&waveFormat, hertz, bps);
	if (mmr != MMSYSERR_NOERROR)
	{
		return mmr;
	}

	return Open(&waveFormat);

}


MMRESULT waveOutDev::Open(WAVEFORMATEX *pWaveFormat)
{
	MMRESULT mmr;

	m_waveFormat = *pWaveFormat;

	if (m_bOpen == TRUE)
		return MMSYSERR_NOERROR;

	if (m_hWnd == NULL)
	{
		mmr = waveOutOpen(&m_hwo, m_devID, &m_waveFormat, (DWORD_PTR)m_hEvent,
		                  0, CALLBACK_EVENT);
	}
	else
	{
		mmr = waveOutOpen(&m_hwo, m_devID, &m_waveFormat, (DWORD_PTR)m_hWnd,
		                  0, CALLBACK_WINDOW);
	}


	// begin hack, try to open wave_mapper
	// this may end up opening a different device!

	if ((mmr == WAVERR_BADFORMAT) && (m_fAllowMapper))
	{
		if (m_hWnd == NULL)
		{
			mmr = waveOutOpen(&m_hwo, WAVE_MAPPER, &m_waveFormat,
			(DWORD_PTR)m_hEvent, 0, CALLBACK_EVENT);
		}
		else
		{
			mmr = waveOutOpen(&m_hwo, WAVE_MAPPER, &m_waveFormat,
			(DWORD_PTR)m_hWnd, 0, CALLBACK_WINDOW);
		}
	}

	if (mmr == MMSYSERR_NOERROR)
		m_bOpen = TRUE;


	return mmr;

}





MMRESULT waveOutDev::Close()
{
	MMRESULT mmr;
	if (m_bOpen == FALSE)
		return MMSYSERR_NOERROR;

	waveOutReset(m_hwo);

	if (m_waveHdr.dwFlags & WHDR_PREPARED)
	{
		waveOutUnprepareHeader(m_hwo, &m_waveHdr, sizeof(m_waveHdr));
		m_waveHdr.dwFlags = 0;
	}

	mmr = waveOutClose(m_hwo);

	if (mmr == MMSYSERR_NOERROR)
		m_bOpen = FALSE;
	else
		ERROR_OUT(("ATW:Close failed"));

	return mmr;
}

MMRESULT waveOutDev::PrepareHeader(WAVEHDR *pWhdr, SHORT *shBuffer, int numSamples)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	// if shBuffer is not NULL, we assume the caller wants us to fill in the
	// WAVEHDR struct
	if (shBuffer)
	{
		ZeroMemory(pWhdr, sizeof(WAVEHDR));
		pWhdr->lpData = (LPSTR)shBuffer;
		pWhdr->dwBufferLength = numSamples * m_waveFormat.nBlockAlign;
	}

	mmr = waveOutPrepareHeader(m_hwo, pWhdr, sizeof(WAVEHDR));

	return mmr;

}

MMRESULT waveOutDev::UnprepareHeader(WAVEHDR *pWaveHdr)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = waveOutUnprepareHeader(m_hwo, pWaveHdr, sizeof(WAVEHDR));

	return mmr;

}

MMRESULT waveOutDev::Play(WAVEHDR *pWaveHdr)
{
	MMRESULT mmr;
	DWORD dwTimeOut;
	DWORD dwRet;
	int numSamples;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	if (m_hEvent)
		ResetEvent(m_hEvent);

	mmr = waveOutWrite(m_hwo, pWaveHdr, sizeof(WAVEHDR));

	if (mmr != MMSYSERR_NOERROR)
		return mmr;

	if (m_hEvent)
	{
		numSamples = pWaveHdr->dwBufferLength / m_waveFormat.nBlockAlign;

		dwTimeOut = 5 * ((1000 * numSamples) / m_waveFormat.nSamplesPerSec);
	
		dwRet = WaitForSingleObject(m_hEvent, dwTimeOut);

		if ((dwRet != WAIT_ABANDONED) && (dwRet != WAIT_OBJECT_0))
		{
			ERROR_OUT(("waveOutDev::Play() - WaitForSingleObject Failed"));
			return WAVERR_LASTERROR + 1;
		}
	}

	return MMSYSERR_NOERROR;
}



// File io errors or anything unexpected results in -1 being returned
// Otherwise, returns the MMRESULT of the last waveOut call made
MMRESULT waveOutDev::PlayFile(LPCTSTR szFileName)
{
	MMRESULT mmr;
	WAVEIOCB waveiocb;
	WIOERR werr;
	DWORD dwSize;
	char * pBuff = NULL;


	// quick optimization
	// if the same file is being played twice in a row
	// the just replay the buffer

	if ((m_fFileBufferValid) && (0 == lstrcmp(szFileName, m_szPlayFile)))
	{
		Close();
		mmr = Open(&m_PlayFileWf);

		if (mmr == MMSYSERR_NOERROR)
		{
			mmr = PrepareHeader(&m_waveHdr, (SHORT*)m_pfBuffer, m_nBufferSize / m_PlayFileWf.nBlockAlign);
			if (mmr == MMSYSERR_NOERROR)
			{
				mmr = Play(&m_waveHdr);
			}
		}

		m_fFileBufferValid = (mmr == MMSYSERR_NOERROR);
		return mmr;
	}


	ZeroMemory(&waveiocb, sizeof(waveiocb));
	werr = wioFileOpen(&waveiocb, szFileName, 0);

	if (werr == WIOERR_NOERROR)
	{
		// prepare to read the samples!

		// quick hack, if the file to play was the same as the last,
		// then use the same buffer

		m_fFileBufferValid = FALSE;

		if (m_pfBuffer == NULL)
		{
			m_pfBuffer = (char *)LocalAlloc(LPTR, waveiocb.dwDataBytes);
		}
		else
		{
			pBuff = (char*)LocalReAlloc(m_pfBuffer, waveiocb.dwDataBytes, LMEM_MOVEABLE |LMEM_ZEROINIT);

			// If allocation was fine
			if(pBuff != NULL)
			{
				 m_pfBuffer = pBuff;
			}
			else
			{
				// Something is very wrong make sure to cleanup m_pfBuffer
				if (m_pfBuffer)
				{
					LocalFree(m_pfBuffer);
					m_pfBuffer = NULL;
				}
				
			}
		}

		if (m_pfBuffer == NULL)
		{
			wioFileClose(&waveiocb, 0);
			return -1;
		}

		// read
		mmioSeek(waveiocb.hmmio, waveiocb.dwDataOffset, SEEK_SET);
		dwSize = mmioRead(waveiocb.hmmio, m_pfBuffer, waveiocb.dwDataBytes);

		if (dwSize == 0)
			return -1;

		Close();
		mmr = Open(waveiocb.pwfx);
		if (mmr != MMSYSERR_NOERROR)
		{
			wioFileClose(&waveiocb, 0);
			return mmr;
		}

//		mmr = Play((short *)m_pfBuffer, dwSize / (waveiocb.pwfx)->nBlockAlign);

		mmr = PrepareHeader(&m_waveHdr, (SHORT*)m_pfBuffer,
		                           dwSize / (waveiocb.pwfx)->nBlockAlign);
		if (mmr == MMSYSERR_NOERROR)
		{
			mmr = Play(&m_waveHdr);
		}

		m_fFileBufferValid = (mmr == MMSYSERR_NOERROR);
		if (m_fFileBufferValid)
		{
			m_PlayFileWf = *(waveiocb.pwfx);
			lstrcpy(m_szPlayFile, szFileName);
			m_nBufferSize = dwSize;
		}

		wioFileClose(&waveiocb, 0);

		return mmr;
	}

	return -1;

}

void waveOutDev::AllowMapper(BOOL fAllowMapper)
{
	m_fAllowMapper = fAllowMapper;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\wizard.cpp ===
// File: wizard.cpp

#include "precomp.h"

#include <vfw.h>
#include <ulsreg.h>
#include "call.h"
#include "ulswizrd.h"
#include "ConfWnd.h"
#include "ConfCpl.h"
#include "mrulist.h"
#include "conf.h"
#include "setupdd.h"
#include "vidwiz.h"
#include "dstest.h"
#include "splash.h"
#include "nmmkcert.h"

#include "confroom.h" // for GetConfRoom
#include "FnObjs.h"

#include "ConfPolicies.h"
#include "SysPol.h"
#include "confUtil.h"
#include "shlWAPI.h"

#include "help_ids.h"

extern VOID SaveDefaultCodecSettings(UINT uBandWidth);
INT_PTR CALLBACK ShortcutWizDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// from ulscpl.cpp
VOID FixServerDropList(HWND hdlg, int id, LPTSTR pszServer, UINT cchMax);

static const TCHAR g_szRegOwner[]    = WIN_REGKEY_REGOWNER;	// concatenated string of first name + last name
static const TCHAR g_szClientFld[]   = ULS_REGISTRY TEXT ("\\") ULS_REGFLD_CLIENT;

static const TCHAR g_szFirstName[]   = ULS_REGKEY_FIRST_NAME;
static const TCHAR g_szLastName[]    = ULS_REGKEY_LAST_NAME;
static const TCHAR g_szEmailName[]   = ULS_REGKEY_EMAIL_NAME;
static const TCHAR g_szLocation[]    = ULS_REGKEY_LOCATION;
static const TCHAR g_szComments[]    = ULS_REGKEY_COMMENTS;
static const TCHAR g_szServerName[]  = ULS_REGKEY_SERVER_NAME;
static const TCHAR g_szDontPublish[] = ULS_REGKEY_DONT_PUBLISH;
static const TCHAR g_szResolveName[] = ULS_REGKEY_RESOLVE_NAME; // concatenated string of uls://servername/emailname
static const TCHAR g_szUserName[]    = ULS_REGKEY_USER_NAME;	// concatenated string of first name + last name


// These functions are implemented below:
static INT_PTR APIENTRY IntroWiz(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
static INT_PTR APIENTRY AppSharingWiz(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
static INT_PTR APIENTRY BandwidthWiz(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
static BOOL NeedAudioWizard(LPLONG plSoundCaps, BOOL fForce);


static void FillWizardPages ( PROPSHEETPAGE *pPage, LPARAM lParam );


struct INTRO_PAGE_CONFIG
{
	BOOL *	fContinue;
	BOOL	fAllowBack;
};

BOOL g_fSilentWizard = FALSE;

// This holdn the user info page HWND...
static HWND s_hDlgUserInfo = NULL;
static HWND s_hDlgGKSettings = NULL;

class IntroWiz
{
public:
	// The order of the pages
	// Make sure to change the order the pages are created at the same time
	// you change this
	enum
	{
		Intro,
		AppSharing,
		ULSFirst,
		ULSLast,
		Bandwidth,
		Video,
		Shortcuts,
		AudioFirst,
		Count
	} ;

	static void InitPages()
	{
		// Init to NULL before adding any pages
		for (int i=0; i<Count; ++i)
		{
			g_idWizOrder[i] = 0;
		}
	}

	static void SetPage(UINT nPage, UINT_PTR id)
	{
		g_idWizOrder[nPage] = id;
	}

	static UINT_PTR GetPrevPage(UINT nPageCur)
	{
		if (0 == nPageCur)
		{
			return(0);
		}

		for (int i=nPageCur-1; i>=1; --i)
		{
			if (0 != g_idWizOrder[i])
			{
				break;
			}
		}

		return(g_idWizOrder[i]);
	}

	static UINT_PTR GetNextPage(UINT nPageCur)
	{
		if (Count-1 <= nPageCur)
		{
			return(0);
		}

		for (int i=nPageCur+1; i<Count-1; ++i)
		{
			if (0 != g_idWizOrder[i])
			{
				break;
			}
		}

		return(g_idWizOrder[i]);
	}

	static BOOL HandleWizNotify(HWND hPage, NMHDR *pHdr, UINT nPageCur)
	{
		switch(pHdr->code)
		{
		case PSN_SETACTIVE:
			InitBackNext(hPage, nPageCur);

			if (g_fSilentWizard)
			{
				PropSheet_PressButton(GetParent(hPage), PSBTN_NEXT);
			}
			break;

        case PSN_WIZBACK:
		{
			UINT_PTR iPrev = GetPrevPage(nPageCur);
			SetWindowLongPtr(hPage, DWLP_MSGRESULT, iPrev);
			break;
		}

		case PSN_WIZNEXT:
		{
			UINT_PTR iPrev = GetNextPage(nPageCur);
			SetWindowLongPtr(hPage, DWLP_MSGRESULT, iPrev);
			break;
		}

		default:
			return(FALSE);
		}

		return(TRUE);
	}

private:
	static UINT_PTR g_idWizOrder[Count];

	static void InitBackNext(HWND hPage, UINT nPageCur)
	{
		DWORD dwFlags = 0;

		if (0 != nPageCur && 0 != GetPrevPage(nPageCur))
		{
			dwFlags |= PSWIZB_BACK;
		}

		if (Count-1 != nPageCur && 0 != GetNextPage(nPageCur))
		{
			dwFlags |= PSWIZB_NEXT;
		}
		else
		{
			dwFlags |= PSWIZB_FINISH;
		}

		PropSheet_SetWizButtons(::GetParent(hPage), dwFlags);
	}
} ;

UINT_PTR IntroWiz::g_idWizOrder[Count];

UINT_PTR GetPageBeforeULS()
{
	return(IntroWiz::GetPrevPage(IntroWiz::ULSFirst));
}

UINT_PTR GetPageBeforeVideoWiz()
{
	return(IntroWiz::GetPrevPage(IntroWiz::Video));
}

UINT_PTR GetPageBeforeAudioWiz()
{
	return(IntroWiz::GetPrevPage(IntroWiz::AudioFirst));
}

UINT_PTR GetPageAfterVideo()
{
	return(IntroWiz::GetNextPage(IntroWiz::Video));
}

UINT_PTR GetPageAfterULS()
{
	return(IntroWiz::GetNextPage(IntroWiz::ULSLast));
}

void HideWizard(HWND hwnd)
{
	SetWindowPos(hwnd, NULL, -1000, -1000, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
}

void ShowWizard(HWND hwnd)
{
	CenterWindow(hwnd, HWND_DESKTOP);
	g_fSilentWizard = FALSE;
	PostMessage(hwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
}


/*  F I L L  I N  P R O P E R T Y  P A G E  */
/*-------------------------------------------------------------------------
    %%Function: FillInPropertyPage

    Fill in the given PROPSHEETPAGE structure.
-------------------------------------------------------------------------*/
VOID FillInPropertyPage(PROPSHEETPAGE* psp, int idDlg,
    DLGPROC pfnDlgProc, LPARAM lParam, LPCTSTR pszProc)
{
	// Clear and set the size of the PROPSHEETPAGE
	InitStruct(psp);

	ASSERT(0 == psp->dwFlags);       // No special flags.
	ASSERT(NULL == psp->pszIcon);    // Don't use a special icon in the caption bar.

	psp->hInstance = ::GetInstanceHandle();
	psp->pszTemplate = MAKEINTRESOURCE(idDlg); // The dialog box template to use.
	psp->pfnDlgProc = pfnDlgProc;    // The dialog procedure that handles this page.
	psp->pszTitle = pszProc;         // The title for this page.
	psp->lParam = lParam;            // Special application-specific data.
}


static const UINT NOVALSpecified = 666;

UINT GetBandwidth()
{
	RegEntry reAudio(AUDIO_KEY, HKEY_CURRENT_USER);
	return(reAudio.GetNumber(REGVAL_TYPICALBANDWIDTH, NOVALSpecified ));
}

void SetBandwidth(UINT uBandwidth)
{
	RegEntry reAudio(AUDIO_KEY, HKEY_CURRENT_USER);
	reAudio.SetValue(REGVAL_TYPICALBANDWIDTH, uBandwidth);
}

HRESULT StartRunOnceWizard(LPLONG plSoundCaps, BOOL fForce, BOOL fVisible)
{
	LPPROPSHEETPAGE	pAudioPages = NULL;
	UINT			nNumAudioPages = 0;
	PWIZCONFIG		pAudioConfig;

	CULSWizard*		pIWizard = NULL;
	LPPROPSHEETPAGE	pULSPages = NULL;
	DWORD			dwNumULSPages = 0;
	ULS_CONF*		pulsConf = NULL;
	UINT			uOldBandwidth = 0;
	UINT			uBandwidth = 0;

	int				idAppSharingIntroWiz = 0;
	
	BOOL  fULSWiz     = FALSE;
	BOOL  fAudioWiz   = FALSE;
	BOOL  fVideoWiz   = FALSE;
	BOOL  fVidWizInit = FALSE;
	
    HRESULT         hrRet = E_FAIL;

	g_fSilentWizard = !fVisible;

    ASSERT(plSoundCaps);

	BOOL fNeedUlsWizard = FALSE;
	BOOL fNeedVideoWizard = FALSE;
	BOOL fNeedAudioWizard = NeedAudioWizard(plSoundCaps, fForce);

	if (fNeedAudioWizard)
	{
        if (GetAudioWizardPages(RUNDUE_NEVERBEFORE,
								WAVE_MAPPER,
								&pAudioPages,
								&pAudioConfig,
								&nNumAudioPages))
        {
            fAudioWiz = TRUE;
        }
        else
        {
			ERROR_OUT(("could not get AudioWiz pages"));
        }
	}

	fVidWizInit = InitVidWiz();
	if (fVidWizInit == FALSE)
	{
		fVideoWiz = FALSE;
		WARNING_OUT(("InitVidWiz failed"));
	}
		
	else
	{
		fNeedVideoWizard = NeedVideoPropPage(fForce);
		fVideoWiz = fNeedVideoWizard;
	}


    if (NULL != (pIWizard = new CULSWizard))
	{
		ASSERT (pIWizard);
		// BUGBUG: not checking return value:
		HRESULT hr = pIWizard->GetWizardPages (&pULSPages, &dwNumULSPages, &pulsConf);
		if (SUCCEEDED(hr))
		{
			ASSERT(pulsConf);
			
			TRACE_OUT(("ULS_CONF from UlsGetConfiguration:"));
			TRACE_OUT(("\tdwFlags:       0x%08x", pulsConf->dwFlags));
			TRACE_OUT(("\tszServerName:  >%s<", pulsConf->szServerName));
			TRACE_OUT(("\tszUserName:    >%s<", pulsConf->szUserName));
			TRACE_OUT(("\tszEmailName:   >%s<", pulsConf->szEmailName));

			fNeedUlsWizard = ((pulsConf->dwFlags &
			    (ULSCONF_F_EMAIL_NAME | ULSCONF_F_FIRST_NAME | ULSCONF_F_LAST_NAME)) !=
			    (ULSCONF_F_EMAIL_NAME | ULSCONF_F_FIRST_NAME | ULSCONF_F_LAST_NAME));

			// Don't bother with the ULS wizard if we have all the information
		    if ((!fForce) && !fNeedUlsWizard)
		    {
			    // We have all of the necessary names
                hrRet = S_OK;
                // release the pages we won't be needing them
        		pIWizard->ReleaseWizardPages (pULSPages);
        		delete pIWizard;
        		pIWizard = NULL;
                dwNumULSPages = 0;
            }
            else
			{
				// some information is not available - we need to run the
				// wizard...
				//SS: if for some reason the user name is not set
				//even though the others are set??
				fULSWiz = TRUE;
				if (::GetDefaultName(pulsConf->szUserName, CCHMAX(pulsConf->szUserName)))
				{
					// We have added a default name, so mark that structure
					// member as valid:
					pulsConf->dwFlags |= ULSCONF_F_USER_NAME;
				}
			}
        }
    }
    else
    {
		ERROR_OUT(("CreateUlsWizardInterface() failed!"));
    }

	// Determine if we need to display the app sharing info page, and if
	// so which one.
	if (::IsWindowsNT() && !g_fNTDisplayDriverEnabled)
	{
		idAppSharingIntroWiz = ::CanInstallNTDisplayDriver()
									? IDD_APPSHARINGWIZ_HAVESP
									: IDD_APPSHARINGWIZ_NEEDSP;
	}

    if ((fULSWiz || fAudioWiz || fVideoWiz))
    {
	    UINT nNumPages = 0;

        // Now fill in remaining PROPSHEETHEADER structures:
	    PROPSHEETHEADER	psh;
	    InitStruct(&psh);
	    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
	    psh.hInstance = ::GetInstanceHandle();
	    ASSERT(0 == psh.nStartPage);

        // alocate enough space for all pages
        DWORD nPages = dwNumULSPages + nNumAudioPages
									 + ( (0 != idAppSharingIntroWiz) ? 1 : 0 )
									 + (fVideoWiz ? 1 : 0)
									 + 2 // intro page & bandwidth page
									 + 1 // shortcuts page
									 ;

        LPPROPSHEETPAGE ppsp = new PROPSHEETPAGE[ nPages ];

	    if (NULL != ppsp)
	    {
			IntroWiz::InitPages();

			BOOL fContinue = TRUE;
		    INTRO_PAGE_CONFIG ipcIntro = { &fContinue, FALSE };
		    INTRO_PAGE_CONFIG ipcAppSharing = { &fContinue, TRUE };

            if (fULSWiz)
		    {
			    // Insert the intro page:

			    FillInPropertyPage(&ppsp[nNumPages++], IDD_INTROWIZ,
                        IntroWiz, (LPARAM) &ipcIntro);

				IntroWiz::SetPage(IntroWiz::Intro, IDD_INTROWIZ);

				// Insert an NT application page, if necessary.  It uses the
				// same dialog proc as the intro page.
				if (0 != idAppSharingIntroWiz)
				{
					FillInPropertyPage(&ppsp[nNumPages++], idAppSharingIntroWiz,
							AppSharingWiz, (LPARAM) &ipcAppSharing);

					IntroWiz::SetPage(IntroWiz::AppSharing, idAppSharingIntroWiz);
				}

			    ASSERT(pulsConf);
			    pulsConf->dwFlags |= (ULSWIZ_F_SHOW_BACK |
						((fAudioWiz || fVideoWiz) ? ULSWIZ_F_NO_FINISH : 0));
			    ::CopyMemory(	&(ppsp[nNumPages]),
							    pULSPages,
							    dwNumULSPages * sizeof(PROPSHEETPAGE));

				IntroWiz::SetPage(IntroWiz::ULSFirst,
					reinterpret_cast<UINT_PTR>(pULSPages[0].pszTemplate));
				IntroWiz::SetPage(IntroWiz::ULSLast,
					reinterpret_cast<UINT_PTR>(pULSPages[dwNumULSPages-1].pszTemplate));
			    nNumPages += dwNumULSPages;

				uBandwidth = uOldBandwidth = GetBandwidth();
				if( NOVALSpecified == uBandwidth )
				{
					FillInPropertyPage(&ppsp[nNumPages++], IDD_BANDWIDTHWIZ,
							BandwidthWiz, (LPARAM) &uBandwidth);
					IntroWiz::SetPage(IntroWiz::Bandwidth, IDD_BANDWIDTHWIZ);
				}
            }

			BOOL fShortcuts = fForce && !g_fSilentWizard;

			if (fVideoWiz)
			{
				LONG button_mask = 0;
				if (fULSWiz == TRUE)
					button_mask |= PSWIZB_BACK;
				if (fShortcuts || fAudioWiz)
					button_mask |= PSWIZB_NEXT;
				else
					button_mask |= PSWIZB_FINISH;
				
				FillInPropertyPage(&ppsp[nNumPages], IDD_VIDWIZ,
	                   VidWizDlg, button_mask, "NetMeeting");
				nNumPages++;
			
				IntroWiz::SetPage(IntroWiz::Video, IDD_VIDWIZ);
			}

			if (fShortcuts)
			{
				FillInPropertyPage(&ppsp[nNumPages], IDD_SHRTCUTWIZ,
					   ShortcutWizDialogProc, 0);
				nNumPages++;

				IntroWiz::SetPage(IntroWiz::Shortcuts, IDD_SHRTCUTWIZ);
			}

		    if (fAudioWiz)
		    {
			     if (fULSWiz || fVideoWiz)
			     {
				     pAudioConfig->uFlags |= STARTWITH_BACK;
			     }
			     ::CopyMemory(	&(ppsp[nNumPages]),
							    pAudioPages,
							    nNumAudioPages * sizeof(PROPSHEETPAGE));
			    nNumPages += nNumAudioPages;
				
				IntroWiz::SetPage(IntroWiz::AudioFirst,
					reinterpret_cast<UINT_PTR>(pAudioPages[0].pszTemplate));
		    }

			psh.ppsp = ppsp;
			psh.nPages = nNumPages;

			if( !PropertySheet(&psh) )
			{		// User hit CANCEL
				pIWizard->ReleaseWizardPages (pULSPages);
				delete pIWizard;
				delete [] ppsp;
				return S_FALSE;
			}
		
		    delete [] ppsp;

            if ((FALSE == fContinue) && fULSWiz)
		    {
			    // Clear out the flags, because we don't want to store
			    // any info in the registry (and therefore, we don't want
			    // to run)
			    pulsConf->dwFlags = 0;
		    }
	    }
    }

    if (fULSWiz)
    {
	    if (!(ULSCONF_F_USER_NAME & pulsConf->dwFlags))
	    {
    	    if (::GetDefaultName(pulsConf->szUserName, CCHMAX(pulsConf->szUserName)))
		    {
			    pulsConf->dwFlags |= ULSCONF_F_USER_NAME;
		    }
	    }
	
	    if ((S_OK == pIWizard->SetConfig (pulsConf)) &&
		    (ULSCONF_F_USER_NAME & pulsConf->dwFlags) &&
		    (ULSCONF_F_EMAIL_NAME & pulsConf->dwFlags) &&
		    (ULSCONF_F_FIRST_NAME & pulsConf->dwFlags) &&
		    (ULSCONF_F_LAST_NAME & pulsConf->dwFlags))
	    {
		    // We have all of the necessary names
            hrRet = S_OK;
	    }
        else
        {
		    WARNING_OUT(("Unable to obtain a name!"));
	    }

        TRACE_OUT(("ULS_CONF after running wizard:"));
	    TRACE_OUT(("\tdwFlags:       0x%08x", pulsConf->dwFlags));
	    TRACE_OUT(("\tszServerName:  >%s<", pulsConf->szServerName));
	    TRACE_OUT(("\tszUserName:    >%s<", pulsConf->szUserName));
	    TRACE_OUT(("\tszEmailName:   >%s<", pulsConf->szEmailName));
	
	    pIWizard->ReleaseWizardPages (pULSPages);
	    delete pIWizard;
	    pIWizard = NULL;
    }

	// Display the Splash screen as soon as possible
    if( SUCCEEDED(hrRet) && fForce && fVisible && (NULL == GetConfRoom()))
    {
    	::StartSplashScreen(NULL);
    }


	if (uOldBandwidth != uBandwidth)
	{
		SetBandwidth(uBandwidth);
		SaveDefaultCodecSettings(uBandwidth);
	}

    if (fAudioWiz)
    {
	    AUDIOWIZOUTPUT awo;
	    ReleaseAudioWizardPages(pAudioPages, pAudioConfig, &awo);
	    if (awo.uValid & SOUNDCARDCAPS_CHANGED)
	    {
		    *plSoundCaps = awo.uSoundCardCaps;
	    }
	    else
	    {
		    // The wizard was cancelled, so we should only take the
		    // information that tells us whether or not a sound card
		    // is present.
		    *plSoundCaps = (awo.uSoundCardCaps & SOUNDCARD_PRESENT);
		
		    // Write this value to the registry so that the wizard will not
		    // auto-launch the next time we run:
            RegEntry reSoundCaps(AUDIO_KEY, HKEY_CURRENT_USER);
		    reSoundCaps.SetValue(REGVAL_SOUNDCARDCAPS, *plSoundCaps);
	    }
    }


	// Even if the VidWiz page wasn't shown, we still need to call this
	// function (UpdateVidConfigRegistry) to fix the registry if the video
   // capture device configurations have changed since the last time.
	if (fVidWizInit)
	{
		UpdateVidConfigRegistry();
		UnInitVidWiz();
	}
	g_fSilentWizard = FALSE;

	return hrRet;
}



INT_PTR APIENTRY AppSharingWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
		{
			// Save the lParam information. in DWL_USER
			::SetWindowLongPtr(hDlg, DWLP_USER, ((PROPSHEETPAGE*)lParam)->lParam);
			if (g_fSilentWizard)
			{
				HideWizard(GetParent(hDlg));
			}
			else
			{
				ShowWizard(GetParent(hDlg));
			}

			return TRUE;
		}

		case WM_NOTIFY:
		{
			switch (((NMHDR FAR *) lParam)->code)
			{
				case PSN_SETACTIVE:
				{
					ASSERT(lParam);
					INTRO_PAGE_CONFIG* pipc = (INTRO_PAGE_CONFIG*)
												::GetWindowLongPtr(hDlg, DWLP_USER);
					ASSERT(pipc);

					DWORD dwFlags = pipc->fAllowBack ? PSWIZB_BACK : 0;
					if( IntroWiz::GetNextPage(IntroWiz::AppSharing) == 0 )
					{
						dwFlags |= PSWIZB_FINISH;						
					}
					else
					{
						dwFlags |= PSWIZB_NEXT;						
					}

					// Initialize the controls.
					PropSheet_SetWizButtons( ::GetParent(hDlg), dwFlags );

					if (g_fSilentWizard)
					{
						PropSheet_PressButton(
							GetParent(hDlg), PSBTN_NEXT);
					}
					break;
				}

				case PSN_KILLACTIVE:
				{
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
					return TRUE;
				}

				case PSN_WIZNEXT:
				{
					UINT_PTR iNext = IntroWiz::GetNextPage(IntroWiz::AppSharing);

					ASSERT( iNext );
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, iNext );
					return TRUE;
				}

				case PSN_RESET:
				{
					ASSERT(lParam);
					INTRO_PAGE_CONFIG* pipc = (INTRO_PAGE_CONFIG*)
												::GetWindowLongPtr(hDlg, DWLP_USER);
					ASSERT(pipc);
					*pipc->fContinue = FALSE;
					break;
				}
			}
			break;
		}

	default:
		break;
	}
	return FALSE;
}

INT_PTR APIENTRY IntroWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
		{
			// Save the lParam information. in DWL_USER
			::SetWindowLongPtr(hDlg, DWLP_USER, ((PROPSHEETPAGE*)lParam)->lParam);
			if (g_fSilentWizard)
			{
				HideWizard(GetParent(hDlg));
			}
			else
			{
				ShowWizard(GetParent(hDlg));
			}
			return TRUE;
		}

		case WM_NOTIFY:
		{
			switch (((NMHDR FAR *) lParam)->code)
			{
				case PSN_SETACTIVE:
				{
					ASSERT(lParam);
					INTRO_PAGE_CONFIG* pipc = (INTRO_PAGE_CONFIG*)
												::GetWindowLongPtr(hDlg, DWLP_USER);
					ASSERT(pipc);

					// Initialize the controls.
					PropSheet_SetWizButtons(
						::GetParent(hDlg),
						PSWIZB_NEXT | (pipc->fAllowBack ? PSWIZB_BACK : 0));

					if (g_fSilentWizard)
					{
						PropSheet_PressButton(
							GetParent(hDlg), PSBTN_NEXT);
					}
					break;
				}

				case PSN_KILLACTIVE:
				{
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
					return TRUE;
				}

				case PSN_WIZNEXT:
				{
					break;
				}

				case PSN_RESET:
				{
					ASSERT(lParam);
					INTRO_PAGE_CONFIG* pipc = (INTRO_PAGE_CONFIG*)
												::GetWindowLongPtr(hDlg, DWLP_USER);
					ASSERT(pipc);
					*pipc->fContinue = FALSE;
					break;
				}
			}
			break;
		}

	default:
		break;
	}
	return FALSE;
}

static void BandwidthWiz_InitDialog(HWND hDlg, UINT uOldBandwidth)
{
	INT idChecked;
	
	//set the initial value
	switch (uOldBandwidth)
	{
		case BW_144KBS:
			idChecked = IDC_RADIO144KBS;
			break;
		case BW_ISDN:
			idChecked = IDC_RADIOISDN;
			break;
		case BW_MOREKBS:
			idChecked = IDC_RADIOMOREKBS;
			break;
		case BW_288KBS:
		default:
			idChecked = IDC_RADIO288KBS;
			break;
	}

	CheckRadioButton(hDlg, IDC_RADIO144KBS, IDC_RADIOISDN, idChecked);
}

static void BandwidthWiz_OK(HWND hDlg, UINT *puBandwidth)
{
	//check the radio button
	if (IsDlgButtonChecked(hDlg,IDC_RADIO144KBS))
	{
		*puBandwidth = BW_144KBS; 						
	}							
	else if (IsDlgButtonChecked(hDlg,IDC_RADIO288KBS))
	{
		*puBandwidth = BW_288KBS; 						
	}							
	else if (IsDlgButtonChecked(hDlg,IDC_RADIOISDN))
	{
		*puBandwidth = BW_ISDN;							
	}							
	else
	{
		*puBandwidth = BW_MOREKBS;							
	}							

//	if (BW_MOREKBS != *puBandwidth)
//	{
//		// disable refresh of speed dials if not on a LAN
//		RegEntry re(UI_KEY, HKEY_CURRENT_USER);
//		re.SetValue(REGVAL_ENABLE_FRIENDS_AUTOREFRESH, (ULONG) 0L);
//	}
}

INT_PTR APIENTRY BandwidthWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	PROPSHEETPAGE *ps;
	static UINT *puBandwidth;
	static UINT uOldBandwidth;

	switch (message) {
		case WM_INITDIALOG:
		{
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			puBandwidth = (UINT*)ps->lParam;
			uOldBandwidth = *puBandwidth;

			BandwidthWiz_InitDialog(hDlg, uOldBandwidth);

			return (TRUE);
		}
		
		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_SETACTIVE:
				{
					// Initialize the controls.
					IntroWiz::HandleWizNotify(hDlg,
						reinterpret_cast<NMHDR*>(lParam), IntroWiz::Bandwidth);
					break;
				}

				case PSN_WIZBACK:
					return(IntroWiz::HandleWizNotify(hDlg,
						reinterpret_cast<NMHDR*>(lParam), IntroWiz::Bandwidth));

				case PSN_WIZFINISH:
				case PSN_WIZNEXT:
				{
					BandwidthWiz_OK(hDlg, puBandwidth);

					return(IntroWiz::HandleWizNotify(hDlg,
						reinterpret_cast<NMHDR*>(lParam), IntroWiz::Bandwidth));
				}

				case PSN_RESET:
					*puBandwidth = uOldBandwidth;
					break;

				default:
					break;													
			}
			break;

		default:
			break;
	}
	return FALSE;
}

static void BandwidthDlg_OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
	switch(id)
	{
	case IDOK:
	{
		UINT uBandwidth;
		BandwidthWiz_OK(hDlg, &uBandwidth);
		EndDialog(hDlg, uBandwidth);
		break;
	}

		// Fall through
	case IDCANCEL:
		EndDialog(hDlg, 0);
		break;

	default:
		break;
	}
}

INT_PTR CALLBACK BandwidthDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static const DWORD aContextHelpIds[] = {
		IDC_RADIO144KBS,	IDH_AUDIO_CONNECTION_SPEED,
		IDC_RADIO288KBS,	IDH_AUDIO_CONNECTION_SPEED,
		IDC_RADIOISDN,		IDH_AUDIO_CONNECTION_SPEED,
		IDC_RADIOMOREKBS,	IDH_AUDIO_CONNECTION_SPEED,

		0, 0   // terminator
	};

	switch (message) {
		HANDLE_MSG(hDlg, WM_COMMAND, BandwidthDlg_OnCommand);

	case WM_INITDIALOG:
		BandwidthWiz_InitDialog(hDlg, (UINT)lParam);
		break;

	case WM_CONTEXTMENU:
		DoHelpWhatsThis(wParam, aContextHelpIds);
		break;

	case WM_HELP:
		DoHelp(lParam, aContextHelpIds);
		break;
	
	default:
		return(FALSE);
	}

	return(TRUE);
}


BOOL NeedAudioWizard(LPLONG plSoundCaps, BOOL fForce)
{
	if (_Module.IsSDKCallerRTC() || SysPol::NoAudio())
	{
		WARNING_OUT(("Audio disabled through system policy switch"));
		return FALSE;
	}

	if (fForce)
	{
		return TRUE;
	}


    BOOL fAudioWiz = FALSE;

	RegEntry reSoundCaps(AUDIO_KEY, HKEY_CURRENT_USER);

	// a default that doesn't overlap with real values
	long lCapsNotPresent = 0x7FFFFFFF;

	*plSoundCaps = reSoundCaps.GetNumber(	REGVAL_SOUNDCARDCAPS,
											lCapsNotPresent);

	if (lCapsNotPresent == *plSoundCaps)
	{
		TRACE_OUT(("Missing sound caps - starting calib wizard"));
		fAudioWiz = TRUE;
	}
	else
	{
		if (!ISSOUNDCARDPRESENT(*plSoundCaps))
		{
			if (waveInGetNumDevs() && waveOutGetNumDevs())
				fAudioWiz = TRUE;
		}
		else
		{
			WAVEINCAPS	waveinCaps;
			WAVEOUTCAPS	waveoutCaps;
			
			//if the wavein has changed since last
			if (waveInGetDevCaps(reSoundCaps.GetNumber(REGVAL_WAVEINDEVICEID,WAVE_MAPPER),
				&waveinCaps, sizeof(WAVEINCAPS)) == MMSYSERR_NOERROR)
			{
				//check the name, if changed, run the wizard
				if (lstrcmp(reSoundCaps.GetString(REGVAL_WAVEINDEVICENAME),waveinCaps.szPname))
					fAudioWiz = TRUE;

			}
			else
				fAudioWiz = TRUE;


			//if the waveout has changed since last
			if (waveOutGetDevCaps(reSoundCaps.GetNumber(REGVAL_WAVEOUTDEVICEID,WAVE_MAPPER),
				&waveoutCaps, sizeof(WAVEOUTCAPS)) == MMSYSERR_NOERROR)
			{
				//check the name, if changed, run the wizard
				if (lstrcmp(reSoundCaps.GetString(REGVAL_WAVEOUTDEVICENAME),waveoutCaps.szPname))
					fAudioWiz = TRUE;

			}
			else
				fAudioWiz = TRUE;

		}

	}

    return fAudioWiz;
}


///////////////////////////////////////////////////////
//
// Wizard pages
//

DWORD SetUserPageWizButtons(HWND hDlg, DWORD dwConfFlags)
{
    DWORD dwButtonFlags = PSWIZB_BACK;

    // disable the 'Next' button if not all of first name, last name and email
    // are filled in
    if (!FEmptyDlgItem(hDlg, IDEC_FIRSTNAME) &&
    	!FEmptyDlgItem(hDlg, IDEC_LASTNAME) &&
		!FEmptyDlgItem(hDlg, IDC_USER_EMAIL))
    {
        dwButtonFlags |= (dwConfFlags & ULSWIZ_F_NO_FINISH) ? PSWIZB_NEXT : PSWIZB_FINISH;
    }
    PropSheet_SetWizButtons (GetParent (hDlg), dwButtonFlags);

    return dwButtonFlags;
}

void GetUserPageState(HWND hDlg, ULS_CONF *pConf)
{
    //strip the first name/email name and last name
    TrimDlgItemText(hDlg, IDEC_FIRSTNAME);
    TrimDlgItemText(hDlg, IDEC_LASTNAME);
    TrimDlgItemText(hDlg, IDC_USER_EMAIL);
    TrimDlgItemText(hDlg, IDC_USER_LOCATION);
	TrimDlgItemText(hDlg, IDC_USER_INTERESTS);

    Edit_GetText(GetDlgItem(hDlg, IDEC_FIRSTNAME),
            pConf->szFirstName, MAX_FIRST_NAME_LENGTH);
    Edit_GetText(GetDlgItem(hDlg, IDEC_LASTNAME),
            pConf->szLastName, MAX_LAST_NAME_LENGTH);
    Edit_GetText(GetDlgItem(hDlg, IDC_USER_EMAIL),
            pConf->szEmailName, MAX_EMAIL_NAME_LENGTH);
    Edit_GetText(GetDlgItem(hDlg, IDC_USER_LOCATION),
            pConf->szLocation, MAX_LOCATION_NAME_LENGTH);
    Edit_GetText(GetDlgItem(hDlg, IDC_USER_INTERESTS),
            pConf->szComments, MAX_COMMENTS_LENGTH);

    if (pConf->szFirstName[0]) pConf->dwFlags |= ULSCONF_F_FIRST_NAME;
    if (pConf->szLastName[0]) pConf->dwFlags |= ULSCONF_F_LAST_NAME;
    if (pConf->szEmailName[0]) pConf->dwFlags |= ULSCONF_F_EMAIL_NAME;
    if (pConf->szLocation[0]) pConf->dwFlags |= ULSCONF_F_LOCATION;
    if (pConf->szComments[0]) pConf->dwFlags |= ULSCONF_F_COMMENTS;
}

UINT_PTR GetPageAfterUser()
{
	UINT_PTR iNext = 0;

	if( SysPol::AllowDirectoryServices() )
	{
		iNext = IDD_PAGE_SERVER;
	}
	else
	{	
		iNext = GetPageAfterULS();
	}
	
	return iNext;
}

INT_PTR APIENTRY PageUserDlgProc ( HWND hDlg, UINT uMsg, WPARAM uParam, LPARAM lParam )
{
    ULS_CONF *pConf;
    PROPSHEETPAGE *pPage;
    static DWORD dwWizButtons;

    switch (uMsg)
    {
	
	case WM_DESTROY:
		s_hDlgUserInfo = NULL;
		break;

    case WM_INITDIALOG:
		s_hDlgUserInfo = hDlg;
        pPage = (PROPSHEETPAGE *) lParam;
        pConf = (ULS_CONF *) pPage->lParam;
        SetWindowLongPtr (hDlg, GWLP_USERDATA, lParam);

		// Set the font
		::SendDlgItemMessage(hDlg, IDEC_FIRSTNAME, WM_SETFONT, (WPARAM) g_hfontDlg, 0);
		::SendDlgItemMessage(hDlg, IDEC_LASTNAME, WM_SETFONT, (WPARAM) g_hfontDlg, 0);
		::SendDlgItemMessage(hDlg, IDC_USER_LOCATION, WM_SETFONT, (WPARAM) g_hfontDlg, 0);
		::SendDlgItemMessage(hDlg, IDC_USER_INTERESTS, WM_SETFONT, (WPARAM) g_hfontDlg, 0);

		// Limit the text
        Edit_LimitText(GetDlgItem(hDlg, IDEC_FIRSTNAME), MAX_FIRST_NAME_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDEC_LASTNAME), MAX_LAST_NAME_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDC_USER_EMAIL), MAX_EMAIL_NAME_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDC_USER_LOCATION), MAX_LOCATION_NAME_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDC_USER_INTERESTS), UI_COMMENTS_LENGTH - 1);

        if (pConf->dwFlags & ULSCONF_F_FIRST_NAME)
        {
            Edit_SetText(GetDlgItem(hDlg, IDEC_FIRSTNAME), pConf->szFirstName);
        }
        if (pConf->dwFlags & ULSCONF_F_LAST_NAME)
        {
            Edit_SetText(GetDlgItem(hDlg, IDEC_LASTNAME), pConf->szLastName);
        }

        if (pConf->dwFlags & ULSCONF_F_EMAIL_NAME)
        {
            Edit_SetText(GetDlgItem(hDlg, IDC_USER_EMAIL), pConf->szEmailName);
        }
        if (pConf->dwFlags & ULSCONF_F_LOCATION)
        {
            Edit_SetText(GetDlgItem(hDlg, IDC_USER_LOCATION), pConf->szLocation);
        }

#ifdef DEBUG
        if ((0 == (pConf->dwFlags & ULSCONF_F_COMMENTS)) &&
        	(0 == (pConf->dwFlags & ULSCONF_F_EMAIL_NAME)) )
		{
			extern VOID DbgGetComments(LPTSTR);
			DbgGetComments(pConf->szComments);
			pConf->dwFlags |= ULSCONF_F_COMMENTS;
		}
#endif

        if (pConf->dwFlags & ULSCONF_F_COMMENTS)
        {
            Edit_SetText(GetDlgItem (hDlg, IDC_USER_INTERESTS), pConf->szComments);
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID (uParam, lParam))
        {
        case IDEC_FIRSTNAME:
        case IDEC_LASTNAME:
        case IDC_USER_EMAIL:
            if (GET_WM_COMMAND_CMD(uParam,lParam) == EN_CHANGE)
            {
                pPage = (PROPSHEETPAGE *) GetWindowLongPtr (hDlg, GWLP_USERDATA);
                pConf = (ULS_CONF *) pPage->lParam;

                dwWizButtons = SetUserPageWizButtons(hDlg, pConf->dwFlags);
            }
            break;
        }
        break;

    case WM_NOTIFY:
        pPage = (PROPSHEETPAGE *) GetWindowLongPtr (hDlg, GWLP_USERDATA);
        pConf = (ULS_CONF *) pPage->lParam;
        switch (((NMHDR *) lParam)->code)
        {
        case PSN_KILLACTIVE:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, FALSE);
            break;
        case PSN_RESET:
            ZeroMemory (pConf, sizeof (ULS_CONF));
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, FALSE);
            break;
        case PSN_SETACTIVE:
            dwWizButtons = SetUserPageWizButtons(hDlg, pConf->dwFlags);
			if (g_fSilentWizard)
			{
				PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
			}
            break;
        case PSN_WIZBACK:
			return(IntroWiz::HandleWizNotify(hDlg,
				reinterpret_cast<NMHDR*>(lParam), IntroWiz::ULSFirst));

		case PSN_WIZNEXT:
		case PSN_WIZFINISH:

			if (!(dwWizButtons & ((PSN_WIZNEXT == ((NMHDR *) lParam)->code) ?
									PSWIZB_NEXT : PSWIZB_FINISH)))
            {
            	// Reject the next/finish button
				ShowWizard(GetParent(hDlg));
				::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
				return TRUE;
			}

            if (!FLegalEmailName(hDlg, IDC_USER_EMAIL))
            {
				ShowWizard(GetParent(hDlg));
				ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGALEMAILNAME);
				SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
				return TRUE;
            }
            GetUserPageState(hDlg, pConf);

			if( PSN_WIZNEXT == (((NMHDR *) lParam)->code) )
			{
				UINT_PTR iNext = GetPageAfterUser();
				ASSERT( iNext );
				SetWindowLongPtr(hDlg, DWLP_MSGRESULT, iNext);
					
				return TRUE;
			}
            break;

        default:
            return FALSE;
        }

    default:
        return FALSE;
    }

    return TRUE;
}


HRESULT CULSWizard::GetWizardPages ( PROPSHEETPAGE **ppPage, ULONG *pcPages, ULS_CONF **ppUlsConf )
{
	const int cULS_Pages = 5;

    PROPSHEETPAGE *pPage = NULL;
	ULONG cPages = 0;
    UINT cbSize = cULS_Pages * sizeof (PROPSHEETPAGE) + sizeof (ULS_CONF);
    ULS_CONF *pConf = NULL;
    HRESULT hr;

    if (ppPage == NULL || pcPages == NULL || ppUlsConf == NULL)
    {
        return E_POINTER;
    }

    pPage = (PROPSHEETPAGE*) LocalAlloc(LPTR, cbSize);
    if (pPage == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pConf = (ULS_CONF *) (((LPBYTE) pPage) +
                               cULS_Pages * sizeof (PROPSHEETPAGE));
    hr = GetConfig (pConf);
    if (hr != S_OK)
    {
    	// REVIEW: GetConfig will never fail, but if it did, pPage would not be released.
        return hr;
    }

#if USE_GAL
	if( !ConfPolicies::IsGetMyInfoFromGALEnabled() ||
	    !ConfPolicies::GetMyInfoFromGALSucceeded() ||
		ConfPolicies::InvalidMyInfo()
	  )
#endif // USE_GAL
	{
	    FillInPropertyPage(&pPage[cPages], IDD_PAGE_USER, PageUserDlgProc, (LPARAM) pConf);
	    cPages++;
	}


	m_WizDirectCallingSettings.SetULS_CONF( pConf );

	FillInPropertyPage( &pPage[cPages++],
						IDD_PAGE_SERVER,
						CWizDirectCallingSettings::StaticDlgProc,
						reinterpret_cast<LPARAM>(&m_WizDirectCallingSettings)
					  );

    *ppPage = pPage;
	*pcPages = cPages;
	*ppUlsConf = pConf;

    return S_OK;
}


HRESULT CULSWizard::ReleaseWizardPages ( PROPSHEETPAGE *pPage)
{
    LocalFree(pPage);

    return S_OK;
}



HRESULT CULSWizard::GetConfig ( ULS_CONF *pConf )
{
    HRESULT hr = E_POINTER;

	if (NULL != pConf)
	{
		::ZeroMemory (pConf, sizeof (ULS_CONF));
		// always return these as valid
	    pConf->dwFlags = ULSCONF_F_SERVER_NAME | ULSCONF_F_PUBLISH;
	    RegEntry reULS(g_szClientFld, HKEY_CURRENT_USER);
		// BUGBUG: ChrisPi - this was a bad idea - lstrcpyn() returns NULL on failure!
		if (_T('\0') != *(lstrcpyn(	pConf->szEmailName,
									reULS.GetString(g_szEmailName),
									CCHMAX(pConf->szEmailName))))
		{
			pConf->dwFlags |= ULSCONF_F_EMAIL_NAME;
		}
		if (_T('\0') != *(lstrcpyn(	pConf->szFirstName,
						reULS.GetString(g_szFirstName),
						CCHMAX(pConf->szFirstName))))
		{
			pConf->dwFlags |= ULSCONF_F_FIRST_NAME;
		}
		if (_T('\0') != *(lstrcpyn(	pConf->szLastName,
						reULS.GetString(g_szLastName),
						CCHMAX(pConf->szLastName))))
		{
			pConf->dwFlags |= ULSCONF_F_LAST_NAME;
		}
		if (_T('\0') != *(lstrcpyn(	pConf->szLocation,
						reULS.GetString(g_szLocation),
						CCHMAX(pConf->szLocation))))
		{
			pConf->dwFlags |= ULSCONF_F_LOCATION;
		}
		if (_T('\0') != *(lstrcpyn(	pConf->szUserName,
						reULS.GetString(g_szUserName),
						CCHMAX(pConf->szUserName))))
		{
			pConf->dwFlags |= ULSCONF_F_USER_NAME;
		}
		if (_T('\0') != *(lstrcpyn(	pConf->szComments,
						reULS.GetString(g_szComments),
						CCHMAX(pConf->szComments))))
		{
			pConf->dwFlags |= ULSCONF_F_COMMENTS;
		}
		
		if (!_Module.IsSDKCallerRTC())
		{
			lstrcpyn( pConf->szServerName, CDirectoryManager::get_defaultServer(), CCHMAX( pConf->szServerName ) );
		}
		else
		{
			lstrcpyn( pConf->szServerName, _T(" "), CCHMAX( pConf->szServerName ) );
		}

		pConf->fDontPublish = reULS.GetNumber(g_szDontPublish,
										REGVAL_ULS_DONT_PUBLISH_DEFAULT);
		pConf->dwFlags |= ULSCONF_F_PUBLISH;
		hr = S_OK;
	}
	
	return hr;
}




/*  S E T  C O N F I G  */
/*-------------------------------------------------------------------------
    %%Function: SetConfig

-------------------------------------------------------------------------*/
HRESULT CULSWizard::SetConfig ( ULS_CONF *pConf )
{
	if (pConf->dwFlags == 0)
	{
		// nothing to set value
		return S_OK;
	}

	if ((pConf->dwFlags & ULSCONF_F_EMAIL_NAME) &&
		(!FLegalEmailSz(pConf->szEmailName)) )
	{
		// email name must be legal
		return E_INVALIDARG;
	}

	RegEntry re(g_szClientFld);

	if (pConf->dwFlags & ULSCONF_F_PUBLISH)
	{
		re.SetValue(g_szDontPublish, (LONG) pConf->fDontPublish);
	}

	if (pConf->dwFlags & ULSCONF_F_EMAIL_NAME)
	{
		re.SetValue(g_szEmailName, pConf->szEmailName);
	}

	if (pConf->dwFlags & ULSCONF_F_FIRST_NAME)
	{
		re.SetValue(g_szFirstName, pConf->szFirstName);
	}

    if (pConf->dwFlags & ULSCONF_F_LAST_NAME)
    {
		re.SetValue(g_szLastName, pConf->szLastName);
	}
	
	if (pConf->dwFlags & ULSCONF_F_LOCATION)
	{
		re.SetValue(g_szLocation, pConf->szLocation);
	}
	
	if (pConf->dwFlags & ULSCONF_F_COMMENTS)
	{
		re.SetValue(g_szComments, pConf->szComments);
	}

	if (pConf->dwFlags & ULSCONF_F_SERVER_NAME)
	{
		CDirectoryManager::set_defaultServer( pConf->szServerName );
	}

	//SS:may be oprah should do this and store it as their own key
    if ((pConf->dwFlags & ULSCONF_F_FIRST_NAME) || (pConf->dwFlags & ULSCONF_F_LAST_NAME))
    {
		ULS_CONF ulcExisting;
		if ((ULSCONF_F_FIRST_NAME | ULSCONF_F_LAST_NAME) !=
			(pConf->dwFlags & (ULSCONF_F_FIRST_NAME | ULSCONF_F_LAST_NAME)) )
		{
			// If only one of these fields is being set, load the previous config:
			GetConfig(&ulcExisting);
		}

		CombineNames(pConf->szUserName, MAX_DCL_NAME_LEN,
			 (pConf->dwFlags & ULSCONF_F_FIRST_NAME) ?
					pConf->szFirstName : ulcExisting.szFirstName,
			(pConf->dwFlags & ULSCONF_F_LAST_NAME) ?
					pConf->szLastName : ulcExisting.szLastName);

		pConf->dwFlags |= ULSCONF_F_USER_NAME;
		re.SetValue(g_szUserName, pConf->szUserName);
    }

    if ((pConf->dwFlags & ULSCONF_F_SERVER_NAME) || (pConf->dwFlags & ULSCONF_F_EMAIL_NAME))
    {
		TCHAR szTemp[MAX_SERVER_NAME_LENGTH + MAX_EMAIL_NAME_LENGTH + 6];

		ULS_CONF ulcExisting;
		if ((ULSCONF_F_SERVER_NAME | ULSCONF_F_EMAIL_NAME) !=
			(pConf->dwFlags & (ULSCONF_F_SERVER_NAME | ULSCONF_F_EMAIL_NAME)))
		{
			// If only one of these fields is being set, load the previous config:
			GetConfig(&ulcExisting);
		}

		FCreateIlsName(szTemp,
			(pConf->dwFlags & ULSCONF_F_SERVER_NAME) ?
						pConf->szServerName : ulcExisting.szServerName,
			(pConf->dwFlags & ULSCONF_F_EMAIL_NAME) ?
						pConf->szEmailName : ulcExisting.szEmailName,
					CCHMAX(szTemp));

    	re.SetValue(g_szResolveName, szTemp);
    }


	// Generate a cert based on the entered information for secure calls
	// ...make sure all fields we care about are valid first
	#define ULSCONF_F_IDFIELDS (ULSCONF_F_FIRST_NAME|ULSCONF_F_LAST_NAME|\
					ULSCONF_F_EMAIL_NAME)

	if ((pConf->dwFlags & ULSCONF_F_IDFIELDS ) == ULSCONF_F_IDFIELDS)
	{
        //
        // LAURABU BUGBUG:
        // If we can't make a cert (France?) or have wrong SCHANNEL or
        // buggy crypto or unrecognized provider, can we propagate that info
        // and act like security is diabled (not available)?
        //
        // How/can we make a common "security not possible" setting we
        // can use.
        //
        MakeCertWrap(pConf->szFirstName, pConf->szLastName,
		    pConf->szEmailName,	0);

        //
        // LAURABU BOGUS!
        // Only do this when RDS is installed.  And just ONCE.
        //

		// Now make a local machine cert for RDS
		CHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
		DWORD cbComputerName = sizeof(szComputerName);
		if (GetComputerName(szComputerName, &cbComputerName))
		{
			MakeCertWrap(szComputerName, NULL, NULL, NMMKCERT_F_LOCAL_MACHINE);
		}
		else
		{
			ERROR_OUT(("GetComputerName failed: %x", GetLastError()));
		}
	}

	return S_OK;
}



bool IsLegalGatewaySz(LPCTSTR szServer)
{
	bool bRet = false;
	
	if( szServer && szServer[0] )
	{
		bRet = true;
	}
	
	return bRet;		
}

bool IsLegalGateKeeperServerSz(LPCTSTR szServer)
{
	
	bool bRet = false;
	
	if( szServer && szServer[0] )
	{
		bRet = true;
	}
	
	return bRet;		
}

bool IsLegalE164Number(LPCTSTR szPhone)
{
	
	if( (NULL == szPhone) || (0 == szPhone[0]) )
	{
		return false;
	}

	// assume a legal phone number is anything with at least 1
	// digit, *,or #.  Anything else will be considered the user's
	// own pretty print formatting (e.g. "876-5309")

	// the bad chars will get filtered out later

	while (*szPhone)
	{
		if ( ((*szPhone >= '0') && (*szPhone <= '9')) ||
		     ((*szPhone == '#') || (*szPhone == '*')) )
		{
			return true;
		}
		szPhone++;
	}
	
	return false;
}


/*  F  L E G A L  E M A I L  S Z  */
/*-------------------------------------------------------------------------
    %%Function: FLegalEmailSz

    A legal email name contains only ANSI characters.
	"a-z, A-Z, numbers 0-9 and some common symbols"
	It cannot include extended characters or < > ( ) /
-------------------------------------------------------------------------*/
BOOL FLegalEmailSz(PTSTR pszName)
{
    if (IS_EMPTY_STRING(pszName))
    	return FALSE;

    for ( ; ; )
    {
		UINT ch = (UINT) ((*pszName++) & 0x00FF);
		if (0 == ch)
			break;

		switch (ch)
			{
		default:
			if ((ch > (UINT) _T(' ')) && (ch <= (UINT) _T('~')) )
				break;
		// else fall thru to error code
		case '(': case ')':
		case '<': case '>':
		case '[': case ']':
		case '/': case '\\':
		case ':': case ';':
		case '+':
		case '=':
		case ',':
		case '\"':
			WARNING_OUT(("FLegalEmailSz: Invalid character '%s' (0x%02X)", &ch, ch));
			return FALSE;
			}
	}

	return TRUE;
}


/*  F  L E G A L  E M A I L  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: FLegalEmailName

-------------------------------------------------------------------------*/
BOOL FLegalEmailName(HWND hdlg, UINT id)
{
	TCHAR sz[MAX_PATH];
	
	GetDlgItemTextTrimmed(hdlg, id, sz, CCHMAX(sz));
	return FLegalEmailSz(sz);
}


/*  F I L L  S E R V E R  C O M B O  B O X  */
/*-------------------------------------------------------------------------
    %%Function: FillServerComboBox

-------------------------------------------------------------------------*/
VOID FillServerComboBox(HWND hwndCombo)
{
	CMRUList	MRUList;

	MRUList.Load( DIR_MRU_KEY );

	const TCHAR * const	pszDomainDirectory	= CDirectoryManager::get_DomainDirectory();

	if( pszDomainDirectory != NULL )
	{
		//	Make sure the configured domain server name is in the list...
		MRUList.AppendEntry( pszDomainDirectory );
	}

	if( CDirectoryManager::isWebDirectoryEnabled() )
	{
		//	Make sure the web directory is in the list...
		MRUList.AppendEntry( CDirectoryManager::get_webDirectoryIls() );
	}

	const TCHAR * const	defaultServer	= CDirectoryManager::get_defaultServer();

	if( lstrlen( defaultServer ) > 0 )
	{
		//	Make sure the default server name is in the list and at the top...
		MRUList.AddNewEntry( defaultServer );
	}

	::SendMessage( hwndCombo, WM_SETREDRAW, FALSE, 0 );
	::SendMessage( hwndCombo, CB_RESETCONTENT, 0, 0 );

	int nCount = MRUList.GetNumEntries();

	for( int nn = MRUList.GetNumEntries() - 1; nn >= 0; nn-- )
	{
		::SendMessage( hwndCombo, CB_ADDSTRING, 0, (LPARAM) CDirectoryManager::get_displayName( MRUList.GetNameEntry( nn ) ) );
	}

	::SendMessage( hwndCombo, WM_SETREDRAW, TRUE, 0 );

}	//	End of FillServerComboBox.


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// CWizDirectCallingSettings wizard page
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

/* static */ HWND CWizDirectCallingSettings::s_hDlg;

INT_PTR CWizDirectCallingSettings::StaticDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	INT_PTR bRet = FALSE;

	if ( message == WM_INITDIALOG )
	{
		PROPSHEETPAGE* pPage = reinterpret_cast<PROPSHEETPAGE*>(lParam);
		SetWindowLongPtr( hDlg, GWLP_USERDATA, pPage->lParam );

		s_hDlg = hDlg;
		CWizDirectCallingSettings* pThis = reinterpret_cast<CWizDirectCallingSettings*>(pPage->lParam);
		if( pThis )
		{
			bRet = pThis->_OnInitDialog();
		}

	}
	else
	{
		CWizDirectCallingSettings* pThis = reinterpret_cast<CWizDirectCallingSettings*>( GetWindowLongPtr( hDlg, GWLP_USERDATA ) );
		if( pThis )
		{
			bRet = pThis->_DlgProc(hDlg, message, wParam, lParam );
		}
	}

	return bRet;
}

/* static */ void CWizDirectCallingSettings::OnWizFinish()
{
	if( s_hDlg && IsWindow( s_hDlg ) )
	{
		CWizDirectCallingSettings* pThis = reinterpret_cast<CWizDirectCallingSettings*>( GetWindowLongPtr( s_hDlg, GWLP_USERDATA ) );
		if( pThis )
		{
			pThis->_OnWizFinish();
		}
	}
}


INT_PTR APIENTRY CWizDirectCallingSettings::_DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	BOOL bRet = FALSE;

	switch( message )
	{
		case WM_DESTROY:
			s_hDlg = NULL;
			break;

		case WM_NOTIFY:
		{
			NMHDR* pNmHdr = reinterpret_cast<NMHDR*>(lParam);
			switch(pNmHdr->code)
			{
				case PSN_SETACTIVE:		return _OnSetActive();
				case PSN_KILLACTIVE:	return _OnKillActive();
				case PSN_WIZBACK:		return _OnWizBack();
				case PSN_WIZNEXT:		bRet = _OnWizNext();

							// We fall through from the WIZ_NEXT becaus
							// we have to save the informaition when we change
							// pages
				case PSN_APPLY:
				case PSN_WIZFINISH:		_OnWizFinish();

			}
			break;
		}

		case WM_COMMAND:
			return _OnCommand(wParam, lParam);

		default:
			break;

	}
	return bRet;
}


/* static */ bool CWizDirectCallingSettings::IsGatewayNameInvalid()
{
	TCHAR szServer[MAX_SERVER_NAME_LENGTH];
	szServer[0] = NULL;

	if( s_hDlg )
	{
		GetDlgItemTextTrimmed(s_hDlg, IDE_CALLOPT_GW_SERVER, szServer, CCHMAX(szServer) );
	}
	else
	{
		GetDefaultGateway( szServer, CCHMAX( szServer ) );
	}

	return !IsLegalGatewaySz(szServer);
}

void CWizDirectCallingSettings::_SetWizButtons()
{
	DWORD dwFlags = NULL;
	
	if( ( BST_CHECKED == IsDlgButtonChecked( s_hDlg, IDC_CHECK_USE_GATEWAY ) ) && IsGatewayNameInvalid() )
	{
		dwFlags = PSWIZB_BACK;
	}
	else
	{
		dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
	}

	if( 0 == GetPageAfterULS() )
	{
		dwFlags |= PSWIZB_FINISH;
	}
	else
	{
		dwFlags |= PSWIZB_NEXT;
	}

	PropSheet_SetWizButtons( GetParent( s_hDlg ), dwFlags );
}

BOOL CWizDirectCallingSettings::_OnCommand( WPARAM wParam, LPARAM lParam )
{
	BOOL bRet = TRUE;

	switch( LOWORD( wParam ) )
	{
		case IDC_CHECK_USE_GATEWAY:
		{
			bool bEnable = ( BST_CHECKED == IsDlgButtonChecked( s_hDlg, IDC_CHECK_USE_GATEWAY ) );
			EnableWindow( GetDlgItem( s_hDlg, IDC_STATIC_GATEWAY_NAME ), bEnable );
			EnableWindow( GetDlgItem( s_hDlg, IDE_CALLOPT_GW_SERVER ), bEnable );
			_SetWizButtons();
		}
		break;

		case IDE_CALLOPT_GW_SERVER:
			if( HIWORD( wParam ) == EN_CHANGE )
			{		
				_SetWizButtons();
			}
			break;

		default:			
			break;
	}

	return bRet;
}


BOOL CWizDirectCallingSettings::_OnInitDialog()
{
	BOOL bRet = TRUE;

	_SetWizButtons();

	InitDirectoryServicesDlgInfo( s_hDlg, m_pWiz, m_bInitialEnableGateway, m_szInitialServerName, CCHMAX(m_szInitialServerName) );

	return bRet;
}


BOOL CWizDirectCallingSettings::_OnSetActive()
{
	_SetWizButtons();

	if (g_fSilentWizard)
	{
		PropSheet_PressButton(GetParent(s_hDlg), PSBTN_NEXT);
	}

	return FALSE;
}

BOOL CWizDirectCallingSettings::_OnKillActive()
{
	return FALSE;
}

BOOL CWizDirectCallingSettings::_OnWizBack()
{
	UINT iPrev = IDD_PAGE_USER;

#if USE_GAL
	if( !ConfPolicies::IsGetMyInfoFromGALEnabled() )
	{
		iPrev = IDD_PAGE_USER;
	}
	else
	{
		iPrev = GetPageBeforeULS();
	}
#endif
		
	ASSERT( iPrev );
	SetWindowLongPtr( s_hDlg, DWLP_MSGRESULT, iPrev );
	return TRUE;
}

BOOL CWizDirectCallingSettings::_OnWizFinish()
{
	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

	m_pConf->dwFlags |= ULSCONF_F_PUBLISH | ULSCONF_F_SERVER_NAME;

	// Get the server name
	SendDlgItemMessage( s_hDlg, IDC_NAMESERVER, WM_GETTEXT, CCHMAX( m_pConf->szServerName ), (LPARAM) m_pConf->szServerName );
	TrimSz( m_pConf->szServerName );

	lstrcpyn( m_pConf->szServerName, CDirectoryManager::get_dnsName( m_pConf->szServerName ), CCHMAX( m_pConf->szServerName ) );

		// Get the don't publish flags			
	m_pConf->fDontPublish = ( BST_CHECKED == IsDlgButtonChecked( s_hDlg, IDC_USER_PUBLISH ) );

	reConf.SetValue(REGVAL_DONT_LOGON_ULS, BST_CHECKED != IsDlgButtonChecked( s_hDlg, IDC_USEULS ));

	return FALSE;
}

BOOL CWizDirectCallingSettings::_OnWizNext()
{

	UINT_PTR iNext = GetPageAfterULS();
	ASSERT( iNext );
	SetWindowLongPtr( s_hDlg, DWLP_MSGRESULT, iNext );
	return TRUE;
}

// Taken from MSDN:
static HRESULT CreateLink(LPCSTR lpszPathObj,
    LPCTSTR lpszPathLink, LPCSTR lpszDesc)
{
    HRESULT hres;
    IShellLink* psl;

    // Get a pointer to the IShellLink interface.
    hres = CoCreateInstance(CLSID_ShellLink, NULL,
        CLSCTX_INPROC_SERVER, IID_IShellLink, reinterpret_cast<LPVOID *>(&psl));
    if (SUCCEEDED(hres)) {
        IPersistFile* ppf;

        // Set the path to the shortcut target and add the
        // description.
        psl->SetPath(lpszPathObj);
        if (NULL != lpszDesc)
        {
        	psl->SetDescription(lpszDesc);
        }

       // Query IShellLink for the IPersistFile interface for saving the
       // shortcut in persistent storage.
        hres = psl->QueryInterface(IID_IPersistFile,
            reinterpret_cast<LPVOID *>(&ppf));

        if (SUCCEEDED(hres)) {
#ifndef UNICODE
            WCHAR wsz[MAX_PATH];

            // Ensure that the string is ANSI.
            MultiByteToWideChar(CP_ACP, 0, lpszPathLink, -1,
                wsz, MAX_PATH);
#else // UNICODE
			LPCWSTR wsz = lpszPathLink;
#endif // UNICODE

            // Save the link by calling IPersistFile::Save.
            hres = ppf->Save(wsz, TRUE);
            ppf->Release();
        }
        psl->Release();
    }
    return hres;
}

void DeleteShortcut(int csidl, LPCTSTR pszSubDir)
{
	TCHAR szSpecial[MAX_PATH];
	if (!NMGetSpecialFolderPath(NULL, szSpecial, csidl, TRUE))
	{
		return;
	}

	USES_RES2T
	LPCTSTR pszNetMtg = RES2T(IDS_MEDIAPHONE_TITLE);

	TCHAR szPath[MAX_PATH];
	wsprintf(szPath, TEXT("%s%s\\%s.lnk"), szSpecial, pszSubDir, pszNetMtg);
	DeleteFile(szPath);
}

static void CreateShortcut(HWND hDlg, int csidl, LPCTSTR pszSubDir)
{
	TCHAR szSpecial[MAX_PATH];
	if (!NMGetSpecialFolderPath(hDlg, szSpecial, csidl, TRUE))
	{
		return;
	}
	USES_RES2T
	LPCTSTR pszNetMtg = RES2T(IDS_MEDIAPHONE_TITLE);

	TCHAR szPath[MAX_PATH];
	wsprintf(szPath, TEXT("%s%s\\%s.lnk"), szSpecial, pszSubDir, pszNetMtg);

	char szThis[MAX_PATH];
	int cb = ARRAY_ELEMENTS(szThis);
	GetModuleFileNameA(NULL, szThis, cb -1);
	szThis[cb -1] = 0;
	CreateLink(szThis, szPath, NULL);
}

INT_PTR CALLBACK ShortcutWizDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg)
	{
	case WM_INITDIALOG:
		CheckDlgButton(hDlg, IDC_ONDESKTOP, BST_CHECKED);
		CheckDlgButton(hDlg, IDC_ONQUICKLAUNCH, BST_CHECKED);
		break;

	case WM_DESTROY:
		if (IsDlgButtonChecked(hDlg, IDC_ONDESKTOP))
		{
			CreateShortcut(hDlg, CSIDL_DESKTOP, g_szEmpty);
		}
		if (IsDlgButtonChecked(hDlg, IDC_ONQUICKLAUNCH))
		{
			CreateShortcut(hDlg, CSIDL_APPDATA, QUICK_LAUNCH_SUBDIR);
		}
		break;

	case WM_NOTIFY:
	{
		NMHDR* pNmHdr = reinterpret_cast<NMHDR*>(lParam);
		switch(pNmHdr->code)
		{
		case PSN_RESET:
			// HACKHACK georgep: Uncheck the buttons so we will not try to
			// create the shortcuts
			CheckDlgButton(hDlg, IDC_ONDESKTOP, BST_UNCHECKED);
			CheckDlgButton(hDlg, IDC_ONQUICKLAUNCH, BST_UNCHECKED);

			// Fall through
		default:
			return(IntroWiz::HandleWizNotify(hDlg, pNmHdr, IntroWiz::Shortcuts));
		}
		break;
	}

	default:
		return(FALSE);
	}

	return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\clclsfct.h ===
/*
 * clsfact.h - IClassFactory implementation.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _CLSFACT_H_
#define _CLSFACT_H_

typedef PIUnknown (*NEWOBJECTPROC)(OBJECTDESTROYEDPROC);
DECLARE_STANDARD_TYPES(NEWOBJECTPROC);

typedef struct classconstructor
{
   PCCLSID pcclsid;

   NEWOBJECTPROC NewObject;
}
CLASSCONSTRUCTOR;
DECLARE_STANDARD_TYPES(CLASSCONSTRUCTOR);

/* Classes
 **********/

// object class factory

class CCLClassFactory : public RefCount,
                        public IClassFactory
{
private:
   NEWOBJECTPROC m_NewObject;

public:
   CCLClassFactory(NEWOBJECTPROC NewObject, OBJECTDESTROYEDPROC ObjectDestroyed);
   ~CCLClassFactory(void);

   // IClassFactory methods

   HRESULT STDMETHODCALLTYPE CreateInstance(PIUnknown piunkOuter, REFIID riid, PVOID *ppvObject);
   HRESULT STDMETHODCALLTYPE LockServer(BOOL bLock);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
   HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCCCLClassFactory(const CCLClassFactory *pcurlcf);

#endif

};
DECLARE_STANDARD_TYPES(CCLClassFactory);

/* Module Prototypes
 ********************/

PIUnknown NewConfLink(OBJECTDESTROYEDPROC ObjectDestroyed);
HRESULT GetClassConstructor(REFCLSID rclsid,
                            PNEWOBJECTPROC pNewObject);


#endif /* _CLSFACT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\clcnflnk.cpp ===
// File: conflnk.cpp

#include "precomp.h"

#include <shellapi.h>
#include <shlstock.h>
#include <ConfDir.h>
#include <ConfCli.h>

#include "clCnfLnk.hpp"
#include "resource.h"

#include	"atlbase.h"
#include	"confevt.h"
#include	"sdkInternal.h"
#include	"nameres.h"

/////////////////////////////////////////////////////////////////////
// Initialize GUIDs
//
#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include "CLinkId.h"

// from shlguid.h - must keep in sync
DEFINE_SHLGUID(CLSID_ShellLink,         0x00021401L, 0, 0);
#ifndef _UNICODE
DEFINE_SHLGUID(IID_IShellLink,          0x000214EEL, 0, 0);
DEFINE_SHLGUID(IID_IShellExtInit,       0x000214E8L, 0, 0);
DEFINE_SHLGUID(IID_IShellPropSheetExt,  0x000214E9L, 0, 0);
#endif // _UNICODE
#undef INITGUID
#pragma data_seg()
/////////////////////////////////////////////////////////////////////



#ifdef DEBUG

BOOL IsValidPCConfLink(PCCConfLink pcConfLink)
{
	return(	
		IS_VALID_READ_PTR(pcConfLink, CConfLink) &&
		FLAGS_ARE_VALID(pcConfLink->m_dwFlags, ALL_CONFLNK_FLAGS) &&
		(! pcConfLink->m_pszFile ||
			IS_VALID_STRING_PTR(pcConfLink->m_pszFile, STR)) &&
		(! pcConfLink->m_pszName ||
			IS_VALID_STRING_PTR(pcConfLink->m_pszName, STR)) &&
		IS_VALID_STRUCT_PTR((PCRefCount)pcConfLink, CRefCount) &&
		IS_VALID_INTERFACE_PTR((PCIDataObject)pcConfLink, IDataObject) &&
		IS_VALID_INTERFACE_PTR((PCIPersistFile)pcConfLink, IPersistFile) &&
		IS_VALID_INTERFACE_PTR((PCIPersistStream)pcConfLink, IPersistStream) &&
		IS_VALID_INTERFACE_PTR((PCIShellExtInit)pcConfLink, IShellExtInit) &&
		IS_VALID_INTERFACE_PTR((PCIShellPropSheetExt)pcConfLink, IShellPropSheetExt) &&
		IS_VALID_INTERFACE_PTR((PCIConferenceLink)pcConfLink, IConferenceLink));
}
#endif /* DEBUG */


CConfLink::CConfLink(OBJECTDESTROYEDPROC ObjectDestroyed) : 
	RefCount			(ObjectDestroyed),
	m_dwFlags			(0),
	m_dwCallFlags		(0),
	m_dwTransport		(0),
	m_pszFile			(NULL),
	m_pszName			(NULL),
	m_pszRemoteConfName	(NULL),
	m_pszAddress		(NULL)
{
	DebugEntry(CConfLink::CConfLink);

	// Don't validate this until after construction.

	ASSERT(	!ObjectDestroyed ||
			IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitVOID(CConfLink::CConfLink);

	return;
}

CConfLink::~CConfLink(void)
{
	DebugEntry(CConfLink::~CConfLink);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	delete m_pszFile;
	m_pszFile = NULL;

	delete m_pszName;
	m_pszName = NULL;

	delete m_pszAddress;
	m_pszAddress = NULL;

	delete m_pszRemoteConfName;
	m_pszRemoteConfName = NULL;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitVOID(CConfLink::~CConfLink);

	return;
}

HRESULT STDMETHODCALLTYPE CConfLink::SetAddress(PCSTR pcszAddress)
{
	HRESULT hr;
	PSTR pszNewAddress = NULL;

	DebugEntry(CConfLink::SetAddress);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	!pcszAddress ||
			IS_VALID_STRING_PTR(pcszAddress, CSTR));

	pszNewAddress = new char[lstrlen(pcszAddress) + 1];

	if (NULL != pszNewAddress)
	{
		lstrcpy(pszNewAddress, pcszAddress);
		hr = S_OK;
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	if (S_OK == hr)
	{
		if (NULL != m_pszAddress)
		{
			delete m_pszAddress;
		}
		
		m_pszAddress = pszNewAddress;

		Dirty(TRUE);

		TRACE_OUT(("CConfLink::SetAddress(): Set Address to %s.",
					CHECK_STRING(m_pszAddress)));
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	hr == S_OK ||
			hr == E_OUTOFMEMORY);

	DebugExitHRESULT(CConfLink::SetAddress, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::GetAddress(PSTR *ppszAddress)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetAddress);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_WRITE_PTR(ppszAddress, PSTR));

	*ppszAddress = NULL;

	if (NULL != m_pszAddress)
	{
		*ppszAddress = NULL;
		LPMALLOC pMalloc;
		
		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			// (+ 1) for null terminator.
			*ppszAddress = (PSTR) pMalloc->Alloc(lstrlen(m_pszAddress) + 1);
			pMalloc->Release();
			pMalloc = NULL;
		}

		if (NULL != *ppszAddress)
		{
			lstrcpy(*ppszAddress, m_pszAddress);

			hr = S_OK;

			TRACE_OUT(("CConfLink::GetAddress(): Got Address %s.", *ppszAddress));
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// No Name.
		hr = S_FALSE;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	(hr == S_OK &&
				IS_VALID_STRING_PTR(*ppszAddress, STR)) ||
			((	hr == S_FALSE ||
				hr == E_OUTOFMEMORY) &&
				! *ppszAddress));

	DebugExitHRESULT(CConfLink::GetAddress, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::SetRemoteConfName(PCSTR pcszRemoteConfName)
{
	HRESULT hr;

	DebugEntry(CConfLink::SetRemoteConfName);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	!pcszRemoteConfName ||
			IS_VALID_STRING_PTR(pcszRemoteConfName, CSTR));

	PSTR pszNewRemoteConfName = new char[lstrlen(pcszRemoteConfName) + 1];

	if (NULL != pszNewRemoteConfName)
	{
		lstrcpy(pszNewRemoteConfName, pcszRemoteConfName);
		hr = S_OK;
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	if (S_OK == hr)
	{
		if (NULL != m_pszRemoteConfName)
		{
			delete m_pszRemoteConfName;
		}
		
		m_pszRemoteConfName = pszNewRemoteConfName;

		Dirty(TRUE);

		TRACE_OUT(("CConfLink::SetRemoteConfName(): Set RemoteConfName to %s.",
					CHECK_STRING(m_pszRemoteConfName)));
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	hr == S_OK ||
			hr == E_OUTOFMEMORY);

	DebugExitHRESULT(CConfLink::SetRemoteConfName, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::GetRemoteConfName(PSTR *ppszRemoteConfName)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetRemoteConfName);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_WRITE_PTR(ppszRemoteConfName, PSTR));

	*ppszRemoteConfName = NULL;

	if (NULL != m_pszRemoteConfName)
	{
		*ppszRemoteConfName = NULL;
		LPMALLOC pMalloc;
		
		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			// (+ 1) for null terminator.
			*ppszRemoteConfName = (PSTR) pMalloc->Alloc(lstrlen(m_pszRemoteConfName) + 1);
			pMalloc->Release();
			pMalloc = NULL;
		}

		if (NULL != *ppszRemoteConfName)
		{
			lstrcpy(*ppszRemoteConfName, m_pszRemoteConfName);

			hr = S_OK;

			TRACE_OUT(("CConfLink::GetRemoteConfName(): Got RemoteConfName %s.",
						*ppszRemoteConfName));
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// No Name.
		hr = S_FALSE;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	(hr == S_OK &&
				IS_VALID_STRING_PTR(*ppszRemoteConfName, STR)) ||
			((	hr == S_FALSE ||
				hr == E_OUTOFMEMORY) &&
				! *ppszRemoteConfName));

	DebugExitHRESULT(CConfLink::GetRemoteConfName, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::SetName(PCSTR pcszName)
{
	HRESULT hr;
	BOOL bChanged;
	PSTR pszNewName = NULL;

	DebugEntry(CConfLink::SetName);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	!pcszName ||
			IS_VALID_STRING_PTR(pcszName, CSTR));

	bChanged = ! ((! pcszName && ! m_pszName) ||
					(pcszName && m_pszName &&
					! lstrcmp(pcszName, m_pszName)));

	if (bChanged && pcszName)
	{
		pszNewName = new(char[lstrlen(pcszName) + 1]);

		if (pszNewName)
		{
			lstrcpy(pszNewName, pcszName);
			hr = S_OK;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = S_OK;
	}

	if (hr == S_OK)
	{
		if (bChanged)
		{
			if (m_pszName)
			{
				delete m_pszName;
			}

			m_pszName = pszNewName;

			Dirty(TRUE);

			TRACE_OUT(("CConfLink::SetName(): Set Name to %s.",
						CHECK_STRING(m_pszName)));
		}
		else
		{
			TRACE_OUT(("CConfLink::SetName(): Name already %s.",
						CHECK_STRING(m_pszName)));
		}
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	hr == S_OK ||
			hr == E_OUTOFMEMORY);

	DebugExitHRESULT(CConfLink::SetName, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::GetName(PSTR *ppszName)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetName);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_WRITE_PTR(ppszName, PSTR));

	*ppszName = NULL;

	if (m_pszName)
	{
		*ppszName = NULL;
		LPMALLOC pMalloc;
		
		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			// (+ 1) for null terminator.
			*ppszName = (PSTR) pMalloc->Alloc(lstrlen(m_pszName) + 1);
			pMalloc->Release();
			pMalloc = NULL;
		}
		
		// ChrisPi: I changed this to use the above implementation because
		// SHAlloc is not available in the sdk shell32.lib
		
		// *ppszName = (PSTR)SHAlloc(lstrlen(m_pszURL) + 1);

		if (*ppszName)
		{
			lstrcpy(*ppszName, m_pszName);

			hr = S_OK;

			TRACE_OUT(("CConfLink::GetName(): Got Name %s.", *ppszName));
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// No Name.
		hr = S_FALSE;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	(hr == S_OK &&
				IS_VALID_STRING_PTR(*ppszName, STR)) ||
			((	hr == S_FALSE ||
				hr == E_OUTOFMEMORY) &&
				! *ppszName));

	DebugExitHRESULT(CConfLink::GetName, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::SetTransport(DWORD dwTransport)
{
	HRESULT hr;

	DebugEntry(CConfLink::SetTransport);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	m_dwTransport = dwTransport;

	Dirty(TRUE);

	TRACE_OUT(("CConfLink::SetTransport(): Set Transport to %#8x.",
				m_dwTransport));

	hr = S_OK;
	
	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::SetTransport, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::GetTransport(DWORD *pdwTransport)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetTransport);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_WRITE_PTR(pdwTransport, PDWORD));

	*pdwTransport = m_dwTransport;

	hr = S_OK;

	TRACE_OUT(("CConfLink::GetTransport(): Got Transport %#8x.",
				*pdwTransport));

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::GetTransport, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::SetCallFlags(DWORD dwCallFlags)
{
	HRESULT hr;

	DebugEntry(CConfLink::SetCallFlags);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	m_dwCallFlags = dwCallFlags;

	Dirty(TRUE);

	TRACE_OUT(("CConfLink::SetCallFlags(): Set CallFlags to %#8x.",
				m_dwCallFlags));

	hr = S_OK;
	
	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::SetCallFlags, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::GetCallFlags(DWORD *pdwCallFlags)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetCallFlags);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_WRITE_PTR(pdwCallFlags, PDWORD));

	*pdwCallFlags = m_dwCallFlags;

	hr = S_OK;

	TRACE_OUT(("CConfLink::GetCallFlags(): Got CallFlags %#8x.",
				*pdwCallFlags));

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::GetCallFlags, hr);

	return(hr);
}


#define STR_CALLTO			_T("callto:")
#define STR_CONFERENCE		_T("+conference=")
#define STR_GATEWAY			_T("+gateway=")
#define STR_SECURE			_T("+secure=true")
#define STR_PHONE			_T("+type=phone")
#define STR_NO_AV			_T("+av=false")
#define STR_NO_DATA			_T("+data=false")


//--------------------------------------------------------------------------//
//	CConfLink::InvokeCommand.												//
//--------------------------------------------------------------------------//
HRESULT
STDMETHODCALLTYPE
CConfLink::InvokeCommand
(
	PCLINVOKECOMMANDINFO	pclici
){
	DebugEntry( CConfLink::InvokeCommand );
	ASSERT( IS_VALID_STRUCT_PTR( this, CConfLink ) );
	ASSERT( IS_VALID_STRUCT_PTR( pclici, CCLINVOKECOMMANDINFO ) );

       LPTSTR url  = NULL;
       
	HRESULT	result = E_INVALIDARG;

	if(m_pszAddress)
	{
		if( m_dwTransport == NAMETYPE_CALLTO )
		{
			result = shellCallto( m_pszAddress, IS_FLAG_SET( pclici->dwFlags, ICL_INVOKECOMMAND_FL_ALLOW_UI ) );
		}
		else
		{
			long lMax =	lstrlen(STR_CALLTO) + 
						lstrlen(STR_CONFERENCE) + 
						lstrlen(STR_GATEWAY) + 
						lstrlen(STR_PHONE) + 
						lstrlen(STR_SECURE) + 
						lstrlen(STR_NO_AV) +
						lstrlen(STR_NO_DATA) +
						lstrlen(m_pszAddress) +
						(m_pszRemoteConfName ? lstrlen(m_pszRemoteConfName) : 0) +
						1; 

			url = (TCHAR*) new BYTE[(lMax)];
			if(!url)
			{
			    goto Cleanup;
			}

			lstrcpy( url, STR_CALLTO );

			if( m_dwTransport != NAMETYPE_H323GTWY )
			{
				lstrcat( url, m_pszAddress );
			}
			else
			{
				TCHAR *	const pSlash	= (TCHAR * const) _StrChr( m_pszAddress, '/' );

				if( pSlash != NULL )
				{
					*pSlash = '\0';
					lstrcat( url, pSlash + 1 );
					lstrcat( url, STR_GATEWAY );
				}

				lstrcat( url, m_pszAddress );
				lstrcat( url, STR_PHONE );
			}

			if( m_pszRemoteConfName != NULL )
			{
				lstrcat( url, STR_CONFERENCE );
				lstrcat( url, m_pszRemoteConfName );
			}

			if( IS_FLAG_SET( m_dwCallFlags, CRPCF_SECURE ) )
			{
				lstrcat( url, STR_SECURE );
			}

			if( IS_FLAG_CLEAR( m_dwCallFlags, (CRPCF_AUDIO | CRPCF_VIDEO) ) )
			{
				lstrcat( url, STR_NO_AV );
			}

			if( IS_FLAG_CLEAR( m_dwCallFlags, CRPCF_DATA) )
			{
				lstrcat( url, STR_NO_DATA );
			}

			result = shellCallto( url, IS_FLAG_SET( pclici->dwFlags, ICL_INVOKECOMMAND_FL_ALLOW_UI ) );
		}

		ASSERT( IS_VALID_STRUCT_PTR( this, CConfLink ) );

		
		DebugExitHRESULT( CConfLink::InvokeCommand, result );
	}

Cleanup:
    
       delete [] url;  

	return( result );

}	//	End of CConfLink::InvokeCommand.


//--------------------------------------------------------------------------//
//	shellCallto.															//
//--------------------------------------------------------------------------//
HRESULT
shellCallto
(
	const TCHAR * const	url,
	const bool			notifyOnError
){
	ASSERT( url != NULL );
	ASSERT( url[ 0 ] != '\0' );
	TRACE_OUT( ("shellCallto:   url:\"%s\"", url) );

	HRESULT	result;

	if( url == NULL )
	{
		result = E_POINTER;
	}
	else if( url[ 0 ] == '\0' )
	{
		result = E_INVALIDARG;
	}
	else
	{
		result = ::CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );

		if( SUCCEEDED( result ) )
		{
			IInternalConfExe *	internalConf;
			
			result = CoCreateInstance( CLSID_NmManager, NULL, CLSCTX_ALL, IID_IInternalConfExe, (LPVOID *) &internalConf );

			if( SUCCEEDED( result ) && (internalConf != NULL) )
			{
				result = internalConf->ShellCalltoProtocolHandler( CComBSTR( url ), FALSE );

				internalConf->Release();
			}

			::CoUninitialize();
		}

		if( FAILED( result ) && notifyOnError )
		{
			TCHAR	message[ MAX_PATH ];
			TCHAR	title[ MAX_PATH ];

			::LoadString(	g_hInst,						//	handle to module containing string resource
							IDS_COULD_NOT_CALL,				//	resource identifier
							message,						//	pointer to buffer for resource
							ARRAY_ELEMENTS( message ) );	//	size of buffer

			::LoadString(	g_hInst,						//	handle to module containing string resource
							IDS_LAUNCH_ERROR,				//	resource identifier
							title,							//	pointer to buffer for resource
							ARRAY_ELEMENTS( title ) );		//	size of buffer

			::MessageBox( NULL, message, title, MB_ICONERROR | MB_OK );
		}
	}

	return( result );

}	//	End of shellCallto.


ULONG STDMETHODCALLTYPE CConfLink::AddRef(void)
{
	ULONG ulcRef;

	DebugEntry(CConfLink::AddRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	ulcRef = RefCount::AddRef();

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitULONG(CConfLink::AddRef, ulcRef);

	return(ulcRef);
}


ULONG STDMETHODCALLTYPE CConfLink::Release(void)
{
	ULONG ulcRef;

	DebugEntry(CConfLink::Release);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	ulcRef = RefCount::Release();

	DebugExitULONG(CConfLink::Release, ulcRef);

	return(ulcRef);
}


HRESULT STDMETHODCALLTYPE CConfLink::QueryInterface(REFIID riid,
													PVOID *ppvObject)
{
	HRESULT hr = S_OK;

	DebugEntry(CConfLink::QueryInterface);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IsValidREFIID(riid));
	ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

	if (riid == IID_IDataObject)
	{
		*ppvObject = (PIDataObject)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IDataObject."));
	}

#if 0 // These are currently unsupported interfaces:

	else if (riid == IID_IExtractIcon)
	{
		*ppvObject = NULL;
		hr = E_NOINTERFACE;

		// *ppvObject = (PIExtractIcon)this;
		TRACE_OUT(("CConfLink::QueryInterface(): NOT Returning IExtractIcon!"));
	}
	else if (riid == IID_INewShortcutHook)
	{
		*ppvObject = NULL;
		hr = E_NOINTERFACE;

		// *ppvObject = (PINewShortcutHook)this;
		TRACE_OUT(("CConfLink::QueryInterface(): NOT Returning INewShortcutHook!"));
	}
	else if (riid == IID_IShellExecuteHook)
	{
		*ppvObject = NULL;
		hr = E_NOINTERFACE;

		// *ppvObject = (PIShellExecuteHook)this;
		TRACE_OUT(("CConfLink::QueryInterface(): NOT Returning IShellExecuteHook!"));
	}
	else if (riid == IID_IShellLink)
	{
		*ppvObject = NULL;
		hr = E_NOINTERFACE;

		// *ppvObject = (PIShellLink)this;
		TRACE_OUT(("CConfLink::QueryInterface(): NOT Returning IShellLink!"));
	}
#endif /* DEBUG */


	// Supported interfaces:
	
	else if (riid == IID_IShellExtInit)
	{
		*ppvObject = (PIShellExtInit)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IShellExtInit."));
	}
	else if (riid == IID_IShellPropSheetExt)
	{
		*ppvObject = (PIShellPropSheetExt)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IShellPropSheetExt."));
	}
	else if (riid == IID_IPersist)
	{
		*ppvObject = (PIPersist)(PIPersistStream)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IPersist."));
	}
	else if (riid == IID_IPersistFile)
	{
		*ppvObject = (PIPersistFile)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IPersistFile."));
	}
	else if (riid == IID_IPersistStream)
	{
		*ppvObject = (PIPersistStream)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IPersistStream."));
	}
	else if (riid == IID_IConferenceLink)
	{
		*ppvObject = (PIConferenceLink)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IConferenceLink."));
	}
	else if (riid == IID_IUnknown)
	{
		*ppvObject = (PIUnknown) (PIConferenceLink) this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IUnknown."));
	}
	else
	{
		TRACE_OUT(("CConfLink::QueryInterface(): Called on unknown interface."));
		*ppvObject = NULL;
		hr = E_NOINTERFACE;
	}

	if (hr == S_OK)
	{
		AddRef();
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::QueryInterface, hr);

	return(hr);
}




/*  O P E N  C O N F  L I N K  */
/*-------------------------------------------------------------------------
    %%Function: OpenConfLink
    
-------------------------------------------------------------------------*/
void WINAPI OpenConfLink(HWND hwndParent, HINSTANCE hinst,
									PSTR pszCmdLine, int nShowCmd)
{
	HRESULT hr;
	CConfLink conflink(NULL);
	// int nResult;

	DebugEntry(OpenConfLink);

	ASSERT(IS_VALID_HANDLE(hwndParent, WND));
	ASSERT(IS_VALID_HANDLE(hinst, INSTANCE));
	ASSERT(IS_VALID_STRING_PTR(pszCmdLine, STR));
	ASSERT(IsValidShowCmd(nShowCmd));

	// Assume the entire command line is a Conference Link file path.

	// TrimWhiteSpace(pszCmdLine);

	TRACE_OUT(("OpenConfLink(): Trying to open Conference Link %s.",
				pszCmdLine));

#if 0
	TCHAR szBuf[256];
	
	wsprintf(szBuf, "Launching conference link %s", pszCmdLine);
	
	::MessageBox(	NULL,
					szBuf,
					"Conference Link Extension",
					MB_ICONINFORMATION);
#endif

	hr = conflink.LoadFromFile(pszCmdLine, TRUE);

	if (hr == S_OK)
	{
		CLINVOKECOMMANDINFO clici;

		clici.dwcbSize = sizeof(clici);
		clici.hwndParent = hwndParent;
		clici.pcszVerb = NULL;
		clici.dwFlags = (	ICL_INVOKECOMMAND_FL_ALLOW_UI |
							ICL_INVOKECOMMAND_FL_USE_DEFAULT_VERB);

		hr = conflink.InvokeCommand(&clici);
	}
	else
	{
		// BUGBUG: need resource here INTL

		::MessageBox(	hwndParent,
						_TEXT("There was an error while identifying the conference"),
						_TEXT("Conference Shortcut Error"),
						MB_ICONINFORMATION);
		
		// if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
		//			MAKEINTRESOURCE(IDS_LOADFROMFILE_FAILED),
		//			(MB_OK | MB_ICONEXCLAMATION), &nResult, pszCmdLine))
		//
		// ASSERT(nResult == IDOK);
	}

	DebugExitVOID(OpenConfLink);

	return;
}


/*  A N Y  M E A T  */
/*-------------------------------------------------------------------------
    %%Function: AnyMeat

    Return TRUE if the string has any non-whitespace characters
-------------------------------------------------------------------------*/
BOOL AnyMeat(PCSTR pcsz)
{
	TCHAR ch;

	ASSERT((!pcsz) || IS_VALID_STRING_PTR(pcsz, CSTR));

	if (NULL == pcsz)
		return FALSE;

	while (0 != (ch = *pcsz++))
	{
		switch (ch)
			{
		case _T(' '):   // Space
		case _T('\t'):  // Tab
		case 0x00A0:    // Non-breaking space
			break;
		default:
			return TRUE; // found a non-whitespace character
			}
	}

	return FALSE;
}



HRESULT MyReleaseStgMedium(PSTGMEDIUM pstgmed)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM));

   if (pstgmed->pUnkForRelease)
       hr = pstgmed->pUnkForRelease->Release();
   else
   {
      switch(pstgmed->tymed)
      {
         case TYMED_HGLOBAL:
            hr = (! GlobalFree(pstgmed->hGlobal)) ? S_OK : E_HANDLE;
            break;

#if 0  /* Only TYMED_HGLOBAL is ever used */
         case TYMED_ISTREAM:
            hr = pstgmed->pstm->Release();
            break;

         case TYMED_ISTORAGE:
            hr = pstgmed->pstm->Release();
            break;

         case TYMED_FILE:
         {
            PIMalloc pMalloc = NULL;
            
            if (SUCCEEDED(SHGetMalloc(&pMalloc)))
            {
            	pMalloc->Free(pstgmed->lpszFileName);
				pMalloc->Release();
				pMalloc = NULL;
				pstgmed->lpszFileName = NULL;
			}
            hr = S_OK;
            break;
		 }

         case TYMED_GDI:
            hr = (DeleteObject(pstgmed->hBitmap)) ? S_OK : E_HANDLE;
            break;

         case TYMED_MFPICT:
            hr = (DeleteMetaFile((HMETAFILE)(pstgmed->hMetaFilePict)) &&
                  ! GlobalFree(pstgmed->hMetaFilePict)) ? S_OK : E_HANDLE;
            break;

         case TYMED_ENHMF:
            hr = (DeleteEnhMetaFile(pstgmed->hEnhMetaFile)) ? S_OK : E_HANDLE;
            break;
#endif // 0

         default:
            ASSERT(pstgmed->tymed == TYMED_NULL);
            hr = S_OK;
            break;
      }
   }

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\clcnflnk.hpp ===
#ifndef _CONFLNK_HPP_
#define _CONFLNK_HPP_

// ConfLink flags

typedef enum _conflnkflags
{
   CONFLNK_FL_DIRTY    = 0x0001,

   ALL_CONFLNK_FLAGS   = CONFLNK_FL_DIRTY
}
CONFLNKFLAGS;

class CConfLink :
		public RefCount,
		public IDataObject,
		public IPersistFile,
		public IPersistStream,
		public IShellExtInit,
		// public IShellPropSheetExt,
		public IConferenceLink
{
private:
	DWORD	m_dwFlags;
	DWORD	m_dwTransport;
	DWORD	m_dwCallFlags;
	PSTR	m_pszFile;
	PSTR	m_pszName;
	PSTR	m_pszAddress;
	PSTR	m_pszRemoteConfName;

	// Data transfer
	
	DWORD   STDMETHODCALLTYPE GetFileContentsSize(void);
	HRESULT STDMETHODCALLTYPE TransferFileContents(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed);

#if 0
	HRESULT STDMETHODCALLTYPE TransferText(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed);
	HRESULT STDMETHODCALLTYPE TransferFileGroupDescriptor(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed);
	HRESULT STDMETHODCALLTYPE TransferConfLink(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed);
#endif // 0

public:
	CConfLink(OBJECTDESTROYEDPROC);
	~CConfLink(void);

	// IDataObject methods

	HRESULT STDMETHODCALLTYPE GetData(PFORMATETC pfmtetcIn, PSTGMEDIUM pstgmed);
	HRESULT STDMETHODCALLTYPE GetDataHere(PFORMATETC pfmtetc, PSTGMEDIUM pstgpmed);
	HRESULT STDMETHODCALLTYPE QueryGetData(PFORMATETC pfmtetc);
	HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(PFORMATETC pfmtetcIn, PFORMATETC pfmtetcOut);
	HRESULT STDMETHODCALLTYPE SetData(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed, BOOL bRelease);
	HRESULT STDMETHODCALLTYPE EnumFormatEtc(DWORD dwDirection, PIEnumFORMATETC *ppienumFormatEtc);
	HRESULT STDMETHODCALLTYPE DAdvise(PFORMATETC pfmtetc, DWORD dwAdviseFlags, PIAdviseSink piadvsink, PDWORD pdwConnection);
	HRESULT STDMETHODCALLTYPE DUnadvise(DWORD dwConnection);
	HRESULT STDMETHODCALLTYPE EnumDAdvise(PIEnumSTATDATA *ppienumStatData);

	// IPersist methods

	HRESULT STDMETHODCALLTYPE GetClassID(PCLSID pclsid);

	// IPersistFile methods

	HRESULT STDMETHODCALLTYPE IsDirty(void);
	HRESULT STDMETHODCALLTYPE Save(LPCOLESTR pcwszFileName, BOOL bRemember);
	HRESULT STDMETHODCALLTYPE SaveCompleted(LPCOLESTR pcwszFileName);
	HRESULT STDMETHODCALLTYPE Load(LPCOLESTR pcwszFileName, DWORD dwMode);
	HRESULT STDMETHODCALLTYPE GetCurFile(LPOLESTR *ppwszFileName);

	// IPersistStream methods

	HRESULT STDMETHODCALLTYPE Save(PIStream pistr, BOOL bClearDirty);
	HRESULT STDMETHODCALLTYPE Load(PIStream pistr);
	HRESULT STDMETHODCALLTYPE GetSizeMax(PULARGE_INTEGER pcbSize);

	// IShellExtInit methods

	HRESULT STDMETHODCALLTYPE Initialize(LPCITEMIDLIST pcidlFolder, LPDATAOBJECT pidobj, HKEY hkeyProgID);

	// IShellPropSheetExt methods

	// HRESULT STDMETHODCALLTYPE AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
	// HRESULT STDMETHODCALLTYPE ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

	// IConferenceLink methods

	HRESULT STDMETHODCALLTYPE SetName(PCSTR pcszName);
	HRESULT STDMETHODCALLTYPE GetName(PSTR *ppszName);
	HRESULT STDMETHODCALLTYPE SetAddress(PCSTR pcszAddress);
	HRESULT STDMETHODCALLTYPE GetAddress(PSTR *ppszAddress);
	HRESULT STDMETHODCALLTYPE SetRemoteConfName(PCSTR pcszRemoteConfName);
	HRESULT STDMETHODCALLTYPE GetRemoteConfName(PSTR *ppszRemoteConfName);
	HRESULT STDMETHODCALLTYPE SetCallFlags(DWORD dwCallFlags);
	HRESULT STDMETHODCALLTYPE GetCallFlags(DWORD *pdwCallFlags);
	HRESULT STDMETHODCALLTYPE SetTransport(DWORD dwTransport);
	HRESULT STDMETHODCALLTYPE GetTransport(DWORD *pdwTransport);
	HRESULT STDMETHODCALLTYPE InvokeCommand(PCLINVOKECOMMANDINFO pclici);

	// IUnknown methods

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
	ULONG   STDMETHODCALLTYPE AddRef(void);
	ULONG   STDMETHODCALLTYPE Release(void);

	// other methods

	HRESULT STDMETHODCALLTYPE SaveToFile(PCSTR pcszFile, BOOL bRemember);
	HRESULT STDMETHODCALLTYPE LoadFromFile(PCSTR pcszFile, BOOL bRemember);
	HRESULT STDMETHODCALLTYPE GetCurFile(PSTR pszFile, UINT ucbLen);
	HRESULT STDMETHODCALLTYPE Dirty(BOOL bDirty);

#ifdef DEBUG

	void STDMETHODCALLTYPE Dump(void);

#endif

	// friends

#ifdef DEBUG

	friend BOOL IsValidPCConfLink(const CConfLink *pcConfLink);

#endif
};

HRESULT
shellCallto
(
	const TCHAR * const	url,
	const bool			notifyOnError
);

DECLARE_STANDARD_TYPES(CConfLink);

// in dataobj.cpp:
PUBLIC_CODE BOOL InitDataObjectModule(void);

// in conflnk.cpp:

PUBLIC_CODE BOOL AnyMeat(PCSTR pcsz);
PUBLIC_CODE BOOL DataCopy(PCBYTE pcbyteSrc, ULONG ulcbLen, PBYTE *ppbyteDest);
PUBLIC_CODE BOOL StringCopy(PCSTR pcszSrc, PSTR *ppszCopy);
PUBLIC_CODE void MyLStrCpyN(PSTR pszDest, PCSTR pcszSrc, int ncb);
PUBLIC_CODE BOOL GetConfLinkDefaultVerb(PSTR pszDefaultVerbBuf,
										UINT ucDefaultVerbBufLen);
PUBLIC_CODE LRESULT GetRegKeyValue(HKEY hkeyParent, PCSTR pcszSubKey,
									PCSTR pcszValue, PDWORD pdwValueType,
									PBYTE pbyteBuf, PDWORD pdwcbBufLen);
PUBLIC_CODE LRESULT GetRegKeyStringValue(	HKEY hkeyParent, PCSTR pcszSubKey,
											PCSTR pcszValue, PSTR pszBuf,
											PDWORD pdwcbBufLen);
PUBLIC_CODE LRESULT GetDefaultRegKeyValue(	HKEY hkeyParent, PCSTR pcszSubKey,
											PSTR pszBuf, PDWORD pdwcbBufLen);
PUBLIC_CODE BOOL GetClassDefaultVerb(	PCSTR pcszClass, PSTR pszDefaultVerbBuf,
										UINT ucDefaultVerbBufLen);
PUBLIC_CODE HRESULT MyReleaseStgMedium(PSTGMEDIUM pstgmed);


extern "C"
{
void WINAPI OpenConfLink(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd);
}

#endif // _CONFLNK_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\confmrsl\ps.cpp ===
#include "SDKInternal.h"
#include <atlbase.h>

#if(_WIN32_WINNT < 0x0500)
extern "C"
WINUSERAPI
BOOL
WINAPI
AllowSetForegroundWindow(
    DWORD dwProcessId);

#define ASFW_ANY    ((DWORD)-1)
#endif 


/* [local] */ HRESULT STDMETHODCALLTYPE INmObject_CallDialog_Proxy( 
    INmObject __RPC_FAR * This,
    /* [in] */ long hwnd,
    /* [in] */ int options)
{
	AllowSetForegroundWindow(ASFW_ANY);
	return INmObject_RemoteCallDialog_Proxy(This, hwnd, options);
}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmObject_CallDialog_Stub( 
    INmObject __RPC_FAR * This,
    /* [in] */ long hwnd,
    /* [in] */ int options)
{
	return This->CallDialog(hwnd, options);
}


/* [local] */ HRESULT STDMETHODCALLTYPE INmObject_ShowLocal_Proxy( 
    INmObject __RPC_FAR * This,
    /* [in] */ NM_APPID appId)
{
	AllowSetForegroundWindow(ASFW_ANY);
	return INmObject_RemoteShowLocal_Proxy(This, appId);
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE INmObject_ShowLocal_Stub( 
    INmObject __RPC_FAR * This,
    /* [in] */ NM_APPID appId)
{
	return This->ShowLocal(appId);
}



/* [local] */ HRESULT STDMETHODCALLTYPE INmManager_Initialize_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puOptions,
    /* [out][in] */ ULONG __RPC_FAR *puchCaps)
	{

		ULONG uOptions = puOptions ? *puOptions : NM_INIT_NORMAL;
		ULONG uchCaps = puchCaps ? *puchCaps : NMCH_ALL;

		HRESULT hr = INmManager_RemoteInitialize_Proxy(This, &uOptions, &uchCaps);

		if(puOptions)
		{
			*puOptions = uOptions;
		}

		if(puchCaps)
		{
			*puchCaps = uchCaps;					
		}

		return hr;
	}

/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_Initialize_Stub( 
    INmManager __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puOptions,
    /* [out][in] */ ULONG __RPC_FAR *puchCaps)
	{

		return This->Initialize(puOptions, puchCaps);
	}


/* [local] */ HRESULT STDMETHODCALLTYPE INmManager_CreateConference_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword,
    /* [in] */ ULONG uchCaps)
	{
		INmConference* pConf = ppConference ? *ppConference : NULL;

			// These may be OLECHARs and not BSTR
		CComBSTR _bstrName = bstrName;
		CComBSTR _bstrPassword = bstrPassword;
		
		HRESULT hr = INmManager_RemoteCreateConference_Proxy(This, &pConf, _bstrName, _bstrPassword, uchCaps);

		if(ppConference)
		{
			*ppConference = pConf;
		}
		else if(SUCCEEDED(hr))
		{
				// Since the client does not want this pointer, we discard it
			pConf->Release();
		}

		return hr;
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_CreateConference_Stub( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword,
    /* [in] */ ULONG uchCaps)
	{
		return This->CreateConference(ppConference, bstrName, bstrPassword, uchCaps);
	}

/* [local] */ HRESULT STDMETHODCALLTYPE INmManager_CreateCall_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ INmConference __RPC_FAR *pConference)
	{
		INmCall* pCall = NULL;

			// These may be OLECHARs and not BSTR
		CComBSTR _bstrAddr = bstrAddr;


		HRESULT hr = INmManager_RemoteCreateCall_Proxy(This, &pCall, callType, addrType, _bstrAddr, pConference);

		if(ppCall)
		{
			*ppCall = pCall;
		}
		else if(SUCCEEDED(hr))
		{
			// Since the client does not want this pointer, we discard it
			pCall->Release();
		}

		return hr;
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_CreateCall_Stub( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ INmConference __RPC_FAR *pConference)
	{
		return This->CreateCall(ppCall, callType, addrType, bstrAddr, pConference);
	}

/* [local] */ HRESULT STDMETHODCALLTYPE INmManager_CallConference_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword)
	{
		INmCall* pCall = ppCall ? *ppCall : NULL;

		CComBSTR _bstrAddr = bstrAddr;
		CComBSTR _bstrName = bstrName;
		CComBSTR _bstrPassword = bstrPassword;

		HRESULT hr = INmManager_RemoteCallConference_Proxy(This, &pCall, callType, addrType, _bstrAddr, _bstrName, _bstrPassword);

		if(ppCall)
		{
			*ppCall = pCall;
		}
		else if(SUCCEEDED(hr))
		{
			// Since the client does not want this pointer, we discard it
			pCall->Release();
		}

		return hr;
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_CallConference_Stub( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword)
	{
		return This->CallConference(ppCall, callType, addrType, bstrAddr, bstrName, bstrPassword);
	}

/* [local] */ HRESULT STDMETHODCALLTYPE INmConference_CreateDataChannel_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ INmChannelData __RPC_FAR *__RPC_FAR *ppChannel,
    /* [in] */ REFGUID rguid)
	{
		INmChannelData* pChan = ppChannel ? *ppChannel : NULL;
		HRESULT hr = INmConference_RemoteCreateDataChannel_Proxy(This, &pChan, rguid);
		if(ppChannel)
		{
			*ppChannel = pChan;
		}
		else if(SUCCEEDED(hr))
		{
			// Since the client does not want this pointer, we discard it
			pChan->Release();
		}

		return hr;
	}

/* [call_as] */ HRESULT STDMETHODCALLTYPE INmConference_CreateDataChannel_Stub( 
    INmConference __RPC_FAR * This,
    /* [out] */ INmChannelData __RPC_FAR *__RPC_FAR *ppChannel,
    /* [in] */ REFGUID rguid)
	{
		return This->CreateDataChannel(ppChannel, rguid);
	}


/* [local] */ HRESULT STDMETHODCALLTYPE INmChannelFt_SendFile_Proxy( 
    INmChannelFt __RPC_FAR * This,
    /* [out] */ INmFt __RPC_FAR *__RPC_FAR *ppFt,
    /* [in] */ INmMember __RPC_FAR *pMember,
    /* [in] */ BSTR bstrFile,
    /* [in] */ ULONG uOptions)
	{
		INmFt* pFt = ppFt ? *ppFt : NULL;
		CComBSTR _bstrFile = bstrFile;

		HRESULT hr = INmChannelFt_RemoteSendFile_Proxy(This, &pFt, pMember, _bstrFile, uOptions);
		if(ppFt)
		{
			*ppFt = pFt;
		}
		else if(SUCCEEDED(hr))
		{
			// Since the client does not want this pointer, we discard it
			pFt->Release();
		}

		return hr;
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmChannelFt_SendFile_Stub( 
    INmChannelFt __RPC_FAR * This,
    /* [out] */ INmFt __RPC_FAR *__RPC_FAR *ppFt,
    /* [in] */ INmMember __RPC_FAR *pMember,
    /* [in] */ BSTR bstrFile,
    /* [in] */ ULONG uOptions)
	{
		return This->SendFile(ppFt, pMember, bstrFile, uOptions);
	}


/* [local] */ HRESULT STDMETHODCALLTYPE INmChannelFt_SetReceiveFileDir_Proxy( 
    INmChannelFt __RPC_FAR * This,
    /* [in] */ BSTR bstrDir)
	{
		CComBSTR _bstrDir = bstrDir;
		return INmChannelFt_RemoteSetReceiveFileDir_Proxy(This, _bstrDir);
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmChannelFt_SetReceiveFileDir_Stub( 
    INmChannelFt __RPC_FAR * This,
    /* [in] */ BSTR bstrDir)
	{
		return This->SetReceiveFileDir(bstrDir);		
	}


/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmConference_Next_Proxy( 
    IEnumNmConference __RPC_FAR * This,
    /* [in] */ ULONG cConference,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *rgpConference,
    /* [out] */ ULONG __RPC_FAR *pcFetched)
	{	
		
		HRESULT hr = S_OK;

			// The user can pass NULL for rpgConference and set cConference to 0 
			// to get the number of items, but they have to BOTH be set!
		if ((0 == cConference) && (NULL == rgpConference) && (NULL != pcFetched))
		{
			INmConference *pConference = NULL;
			cConference = 1;

			// Return the number of remaining elements
			ULONG ulItems = *pcFetched = 0;

			hr = IEnumNmConference_RemoteNext_Proxy(This, cConference, &pConference, pcFetched, &ulItems, TRUE);

			*pcFetched = ulItems;

			return hr;
		}
		
		if ((NULL == rgpConference) || ((NULL == pcFetched) && (cConference != 1)))
			return E_POINTER;

		ULONG cFetched = pcFetched ? *pcFetched : 0;
		
			// This parameter is only used when we have to determine the number of elements
		ULONG ulUnused;

		hr = IEnumNmConference_RemoteNext_Proxy(This, cConference, rgpConference, &cFetched, &ulUnused, FALSE);

		if(pcFetched)
		{
			*pcFetched = cFetched;
		}

		return hr;
	}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmConference_Next_Stub( 
    IEnumNmConference __RPC_FAR * This,
    /* [in] */ ULONG cConference,
    /* [length_is][size_is][out] */ INmConference __RPC_FAR *__RPC_FAR *rgpConference,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining)
	{
		if(bGetNumberRemaining)
		{
			HRESULT hr = This->Next(0, NULL, pcFetched);

				// Store the numebr of items
			*pcItems = *pcFetched;

				// This is so the marshaller does not think that *rgpConference has valid info
			*pcFetched = 0;
			return hr;
		}

		return This->Next(cConference, rgpConference, pcFetched);

	}


/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmMember_Next_Proxy( 
    IEnumNmMember __RPC_FAR * This,
    /* [in] */ ULONG cMember,
    /* [out] */ INmMember __RPC_FAR *__RPC_FAR *rgpMember,
    /* [out] */ ULONG __RPC_FAR *pcFetched)
	{
		HRESULT hr = S_OK;

			// The user can pass NULL for rpgMember and set cMember to 0 
			// to get the number of items, but they have to BOTH be set!
		if ((0 == cMember) && (NULL == rgpMember) && (NULL != pcFetched))
		{
			INmMember *pMember = NULL;
			cMember = 1;

			// Return the number of remaining elements
			ULONG ulItems = *pcFetched = 0;

			hr = IEnumNmMember_RemoteNext_Proxy(This, cMember, &pMember, pcFetched, &ulItems, TRUE);

			*pcFetched = ulItems;

			return hr;
		}
		
		if ((NULL == rgpMember) || ((NULL == pcFetched) && (cMember != 1)))
			return E_POINTER;

		ULONG cFetched = pcFetched ? *pcFetched : 0;
		
			// This parameter is only used when we have to determine the number of elements
		ULONG ulUnused;

		hr = IEnumNmMember_RemoteNext_Proxy(This, cMember, rgpMember, &cFetched, &ulUnused, FALSE);

		if(pcFetched)
		{
			*pcFetched = cFetched;
		}

		return hr;

	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmMember_Next_Stub( 
    IEnumNmMember __RPC_FAR * This,
    /* [in] */ ULONG cMember,
    /* [length_is][size_is][out] */ INmMember __RPC_FAR *__RPC_FAR *rgpMember,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining)
	{
		if(bGetNumberRemaining)
		{
			HRESULT hr = This->Next(0, NULL, pcFetched);

				// Store the numebr of items
			*pcItems = *pcFetched;

				// This is so the marshaller does not think that *rgpMember has valid info
			*pcFetched = 0;
			return hr;
		}

		return This->Next(cMember, rgpMember, pcFetched);
	}



/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmChannel_Next_Proxy( 
    IEnumNmChannel __RPC_FAR * This,
    /* [in] */ ULONG cChannel,
    /* [out] */ INmChannel __RPC_FAR *__RPC_FAR *rgpChannel,
    /* [out] */ ULONG __RPC_FAR *pcFetched)
	{
		HRESULT hr = S_OK;

			// The user can pass NULL for rpgChannel and set cChannel to 0 
			// to get the number of items, but they have to BOTH be set!
		if ((0 == cChannel) && (NULL == rgpChannel) && (NULL != pcFetched))
		{
			INmChannel *pChannel = NULL;
			cChannel = 1;

			// Return the number of remaining elements
			ULONG ulItems = *pcFetched = 0;

			hr = IEnumNmChannel_RemoteNext_Proxy(This, cChannel, &pChannel, pcFetched, &ulItems, TRUE);

			*pcFetched = ulItems;

			return hr;
		}
		
		if ((NULL == rgpChannel) || ((NULL == pcFetched) && (cChannel != 1)))
			return E_POINTER;

		ULONG cFetched = pcFetched ? *pcFetched : 0;
		
			// This parameter is only used when we have to determine the number of elements
		ULONG ulUnused;

		hr = IEnumNmChannel_RemoteNext_Proxy(This, cChannel, rgpChannel, &cFetched, &ulUnused, FALSE);

		if(pcFetched)
		{
			*pcFetched = cFetched;
		}

		return hr;
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmChannel_Next_Stub( 
    IEnumNmChannel __RPC_FAR * This,
    /* [in] */ ULONG cChannel,
    /* [length_is][size_is][out] */ INmChannel __RPC_FAR *__RPC_FAR *rgpChannel,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining)
	{
		if(bGetNumberRemaining)
		{
			HRESULT hr = This->Next(0, NULL, pcFetched);

				// Store the numebr of items
			*pcItems = *pcFetched;

				// This is so the marshaller does not think that *rgpChannel has valid info
			*pcFetched = 0;
			return hr;
		}

		return This->Next(cChannel, rgpChannel, pcFetched);
	}


/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmCall_Next_Proxy( 
    IEnumNmCall __RPC_FAR * This,
    /* [in] */ ULONG cCall,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *rgpCall,
    /* [out] */ ULONG __RPC_FAR *pcFetched)
	{
		HRESULT hr = S_OK;

			// The user can pass NULL for rpgCall and set cCall to 0 
			// to get the number of items, but they have to BOTH be set!
		if ((0 == cCall) && (NULL == rgpCall) && (NULL != pcFetched))
		{
			INmCall *pCall = NULL;
			cCall = 1;

			// Return the number of remaining elements
			ULONG ulItems = *pcFetched = 0;

			hr = IEnumNmCall_RemoteNext_Proxy(This, cCall, &pCall, pcFetched, &ulItems, TRUE);

			*pcFetched = ulItems;

			return hr;
		}
		
		if ((NULL == rgpCall) || ((NULL == pcFetched) && (cCall != 1)))
			return E_POINTER;

		ULONG cFetched = pcFetched ? *pcFetched : 0;
		
			// This parameter is only used when we have to determine the number of elements
		ULONG ulUnused;

		hr = IEnumNmCall_RemoteNext_Proxy(This, cCall, rgpCall, &cFetched, &ulUnused, FALSE);

		if(pcFetched)
		{
			*pcFetched = cFetched;
		}

		return hr;

	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmCall_Next_Stub( 
    IEnumNmCall __RPC_FAR * This,
    /* [in] */ ULONG cCall,
    /* [length_is][size_is][out] */ INmCall __RPC_FAR *__RPC_FAR *rgpCall,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining)
	{
		if(bGetNumberRemaining)
		{
			HRESULT hr = This->Next(0, NULL, pcFetched);

				// Store the numebr of items
			*pcItems = *pcFetched;

				// This is so the marshaller does not think that *rgpCall has valid info
			*pcFetched = 0;
			return hr;
		}

		return This->Next(cCall, rgpCall, pcFetched);

	}

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmSharableApp_Next_Proxy( 
    IEnumNmSharableApp __RPC_FAR * This,
    /* [in] */ ULONG cApp,
    /* [out] */ INmSharableApp __RPC_FAR *__RPC_FAR *rgpApp,
    /* [out] */ ULONG __RPC_FAR *pcFetched)
	{
		HRESULT hr = S_OK;

			// The user can pass NULL for rpgSharableApp and set cSharableApp to 0 
			// to get the number of items, but they have to BOTH be set!
		if ((0 == cApp) && (NULL == rgpApp) && (NULL != pcFetched))
		{
			INmSharableApp *pSharableApp = NULL;
			cApp = 1;

			// Return the number of remaining elements
			ULONG ulItems = *pcFetched = 0;

			hr = IEnumNmSharableApp_RemoteNext_Proxy(This, cApp, &pSharableApp, pcFetched, &ulItems, TRUE);

			*pcFetched = ulItems;

			return hr;
		}
		
		if ((NULL == rgpApp) || ((NULL == pcFetched) && (cApp != 1)))
			return E_POINTER;

		ULONG cFetched = pcFetched ? *pcFetched : 0;
		
			// This parameter is only used when we have to determine the number of elements
		ULONG ulUnused;

		hr = IEnumNmSharableApp_RemoteNext_Proxy(This, cApp, rgpApp, &cFetched, &ulUnused, FALSE);

		if(pcFetched)
		{
			*pcFetched = cFetched;
		}

		return hr;

	}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmSharableApp_Next_Stub( 
    IEnumNmSharableApp __RPC_FAR * This,
    /* [in] */ ULONG cApp,
    /* [length_is][size_is][out] */ INmSharableApp __RPC_FAR *__RPC_FAR *rgpApp,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining)
	{
		if(bGetNumberRemaining)
		{
			HRESULT hr = This->Next(0, NULL, pcFetched);

				// Store the numebr of items
			*pcItems = *pcFetched;

				// This is so the marshaller does not think that *rgpApp has valid info
			*pcFetched = 0;
			return hr;
		}

		return This->Next(cApp, rgpApp, pcFetched);
	}



typedef HRESULT (WINAPI *VERIFYUSERINFO)(HWND hwnd, NM_VUI options);

/* [local] */ HRESULT STDMETHODCALLTYPE INmObject_VerifyUserInfo_Proxy( 
    INmObject __RPC_FAR * This,
    /* [in] */ UINT_PTR hwnd,
    /* [in] */ NM_VUI options)
	{
		HRESULT hr = E_FAIL;
		HMODULE hMod = LoadLibrary("msconf.dll");
		if (NULL != hMod)
		{
			VERIFYUSERINFO pfnVUI = (VERIFYUSERINFO)GetProcAddress(hMod, "VerifyUserInfo");
			if (NULL != pfnVUI)
			{
				hr = pfnVUI((HWND)hwnd, options);
			}
			FreeLibrary(hMod);
		}

		return hr;
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmObject_VerifyUserInfo_Stub( 
    INmObject __RPC_FAR * This,
    /* [in] */ long hwnd,
    /* [in] */ NM_VUI options)
	{
		return This->VerifyUserInfo(hwnd, options);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\cldataob.cpp ===
/*
 * DataObj.cpp - IDataObject implementation.
 *
 * Taken from URL code - very similar to DavidDi's original code
 *
 * Created: ChrisPi 9-11-95
 *
 */

#include "precomp.h"

#include "clrefcnt.hpp"
#include "clenumft.hpp"
#include "clCnfLnk.hpp"

/* Global Variables
 *******************/

/* registered clipboard formats */

UINT g_cfConfLink = 0;
UINT g_cfFileGroupDescriptor = 0;
UINT g_cfFileContents = 0;

/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

char s_szConfLinkCF[] = "ConferenceLink";
char s_szFileGroupDescriptorCF[]   = CFSTR_FILEDESCRIPTOR;
char s_szFileContentsCF[]          = CFSTR_FILECONTENTS;

#pragma data_seg()


/***************************** Private Functions *****************************/

BOOL InitDataObjectModule(void)
{
	g_cfConfLink = RegisterClipboardFormat(s_szConfLinkCF);
	g_cfFileGroupDescriptor = RegisterClipboardFormat(s_szFileGroupDescriptorCF);
	g_cfFileContents        = RegisterClipboardFormat(s_szFileContentsCF);

	return(	g_cfConfLink &&
			g_cfFileGroupDescriptor &&
			g_cfFileContents);
}

/********************************** Methods **********************************/

HRESULT STDMETHODCALLTYPE CConfLink::GetData(	PFORMATETC pfmtetc,
												PSTGMEDIUM pstgmed)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetData);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(IS_VALID_WRITE_PTR(pstgmed, STGMEDIUM));

	// Ignore pfmtetc.ptd.  All supported data formats are device-independent.

	ZeroMemory(pstgmed, sizeof(*pstgmed));

	if (pfmtetc->dwAspect == DVASPECT_CONTENT)
	{
#ifdef DEBUG
		if ((pfmtetc->lindex == -1) &&
			  ( (pfmtetc->cfFormat == g_cfConfLink) ||
				(pfmtetc->cfFormat == CF_TEXT) ||
				(pfmtetc->cfFormat == g_cfFileGroupDescriptor)) )
		{
			ERROR_OUT(("CConfLink::GetData - unsupported cfFormat"));
		}
#endif /* DEBUG */
#if 0
		if (pfmtetc->cfFormat == g_cfConfLink)
		{
			hr = (pfmtetc->lindex == -1) ? 
				TransferConfLink(pfmtetc, pstgmed) : DV_E_LINDEX;
		}
		else if (pfmtetc->cfFormat == CF_TEXT)
		{
			hr = (pfmtetc->lindex == -1) ? 
				TransferText(pfmtetc, pstgmed) : DV_E_LINDEX;
		}
		else if (pfmtetc->cfFormat == g_cfFileGroupDescriptor)
		{
			hr = (pfmtetc->lindex == -1) ? 
				TransferFileGroupDescriptor(pfmtetc, pstgmed) : DV_E_LINDEX;
		}
		else
#endif // 0

		     if (pfmtetc->cfFormat == g_cfFileContents)
		{
			hr = (! pfmtetc->lindex) ? 
				TransferFileContents(pfmtetc, pstgmed) : DV_E_LINDEX;
		}
		else
		{
			hr = DV_E_FORMATETC;
		}
	}
	else
	{
		hr = DV_E_DVASPECT;
	}

	if (hr == S_OK)
	{
		TRACE_OUT(("CConfLink::GetData(): Returning clipboard format %s.",
					GetClipboardFormatNameString(pfmtetc->cfFormat)));
	}
	else
	{
		TRACE_OUT(("CConfLink::GetData(): Failed to return clipboard format %s.",
					GetClipboardFormatNameString(pfmtetc->cfFormat)));
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(FAILED(hr) || IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM));

	DebugExitHRESULT(CConfLink::GetData, hr);

	return(hr);
}

// #pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::GetDataHere(	PFORMATETC pfmtetc,
													PSTGMEDIUM pstgpmed)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetDataHere);
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(IS_VALID_STRUCT_PTR(pstgpmed, CSTGMEDIUM));

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	TRACE_OUT(("CConfLink::GetDataHere(): Failed to return clipboard format %s.",
				GetClipboardFormatNameString(pfmtetc->cfFormat)));

	hr = DV_E_FORMATETC;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pstgpmed, CSTGMEDIUM));

	DebugExitHRESULT(CConfLink::GetDataHere, hr);

	return(hr);
}

// #pragma warning(default:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::QueryGetData(PFORMATETC pfmtetc)
{
	HRESULT hr;

	DebugEntry(CConfLink::QueryGetData);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));

	TRACE_OUT(("CConfLink::QueryGetData(): Asked for clipboard format %s.",
				GetClipboardFormatNameString(pfmtetc->cfFormat)));

	// Ignore pfmtetc.ptd.  All supported data formats are device-independent.

	if (pfmtetc->dwAspect == DVASPECT_CONTENT)
	{
		if (IS_FLAG_SET(pfmtetc->tymed, TYMED_HGLOBAL))
		{
			if (pfmtetc->cfFormat == g_cfConfLink)
				hr = (pfmtetc->lindex == -1) ? S_OK : DV_E_LINDEX;
			else if (pfmtetc->cfFormat == CF_TEXT)
				hr = (pfmtetc->lindex == -1) ? S_OK : DV_E_LINDEX;
			else if (pfmtetc->cfFormat == g_cfFileGroupDescriptor)
				hr = (pfmtetc->lindex == -1) ? S_OK : DV_E_LINDEX;
			else if (pfmtetc->cfFormat == g_cfFileContents)
				hr = (! pfmtetc->lindex) ? S_OK : DV_E_LINDEX;
			else
				hr = DV_E_FORMATETC;
		}
		else
			hr = DV_E_TYMED;
	}
	else
	{
		hr = DV_E_DVASPECT;
	}

	if (hr == S_OK)
	{
		TRACE_OUT(("CConfLink::QueryGetData(): Clipboard format %s supported.",
					GetClipboardFormatNameString(pfmtetc->cfFormat)));
	}
	else
	{
		TRACE_OUT(("CConfLink::QueryGetData(): Clipboard format %s not supported.",
					GetClipboardFormatNameString(pfmtetc->cfFormat)));
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::QueryGetData, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::GetCanonicalFormatEtc(	PFORMATETC pfmtetcIn,
															PFORMATETC pfmtetcOut)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetCanonicalFormatEtc);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetcIn, CFORMATETC));
	ASSERT(IS_VALID_WRITE_PTR(pfmtetcOut, FORMATETC));

	hr = QueryGetData(pfmtetcIn);

	if (hr == S_OK)
	{
		*pfmtetcOut = *pfmtetcIn;

		if (pfmtetcIn->ptd == NULL)
		{
			hr = DATA_S_SAMEFORMATETC;
		}
		else
		{
			pfmtetcIn->ptd = NULL;
			ASSERT(hr == S_OK);
		}
	}
	else
	{
		ZeroMemory(pfmtetcOut, sizeof(*pfmtetcOut));
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(FAILED(hr) ||
	IS_VALID_STRUCT_PTR(pfmtetcOut, CFORMATETC));

	DebugExitHRESULT(CConfLink::GetCanonicalFormatEtc, hr);

	return(hr);
}

// #pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::SetData(	PFORMATETC pfmtetc,
												PSTGMEDIUM pstgmed,
												BOOL bRelease)
{
	HRESULT hr;

	DebugEntry(CConfLink::SetData);

	// bRelease may be any value.

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM));

	hr = DV_E_FORMATETC;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::SetData, hr);

	return(hr);
}

// #pragma warning(default:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::EnumFormatEtc(	DWORD dwDirFlags,
													PIEnumFORMATETC *ppiefe)
{
	HRESULT hr;

	DebugEntry(CConfLink::EnumFormatEtc);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(FLAGS_ARE_VALID(dwDirFlags, ALL_DATADIR_FLAGS));
	ASSERT(IS_VALID_WRITE_PTR(ppiefe, PIEnumFORMATETC));

	*ppiefe = NULL;

	if (dwDirFlags == DATADIR_GET)
	{
		FORMATETC rgfmtetc[] =
		{
			{ 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
			{ 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
			{ 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
			{ 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
		};
		PEnumFormatEtc pefe;

		rgfmtetc[0].cfFormat = (CLIPFORMAT)g_cfConfLink;
		rgfmtetc[1].cfFormat = CF_TEXT;
		rgfmtetc[2].cfFormat = (CLIPFORMAT)g_cfFileGroupDescriptor;
		rgfmtetc[3].cfFormat = (CLIPFORMAT)g_cfFileContents;

		pefe = new ::EnumFormatEtc(rgfmtetc, ARRAY_ELEMENTS(rgfmtetc));

		if (pefe)
		{
			hr = pefe->Status();

			if (hr == S_OK)
			{
				*ppiefe = pefe;
			}
			else
			{
				delete pefe;
				pefe = NULL;
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// BUGBUG: Implement IDataObject::SetData() and add support for
		// DATADIR_SET here.
		hr = E_NOTIMPL;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT((hr == S_OK &&
	IS_VALID_INTERFACE_PTR(*ppiefe, IEnumFORMATETC)) || (FAILED(hr) && ! *ppiefe));

	DebugExitHRESULT(CConfLink::EnumFormatEtc, hr);

	return(hr);
}

// #pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::DAdvise(	PFORMATETC pfmtetc,
												DWORD dwAdviseFlags,
												PIAdviseSink piadvsink,
												PDWORD pdwConnection)
{
	HRESULT hr;

	DebugEntry(CConfLink::DAdvise);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(FLAGS_ARE_VALID(dwAdviseFlags, ALL_ADVISE_FLAGS));
	ASSERT(IS_VALID_INTERFACE_PTR(piadvsink, IAdviseSink));
	ASSERT(IS_VALID_WRITE_PTR(pdwConnection, DWORD));

	*pdwConnection = 0;
	hr = OLE_E_ADVISENOTSUPPORTED;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT((hr == S_OK && *pdwConnection) ||
			(FAILED(hr) && ! *pdwConnection));

	DebugExitHRESULT(CConfLink::DAdvise, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::DUnadvise(DWORD dwConnection)
{
	HRESULT hr;

	DebugEntry(CConfLink::DUnadvise);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(dwConnection);

	hr = OLE_E_ADVISENOTSUPPORTED;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::DUnadvise, hr);

	return(hr);
}

// #pragma warning(default:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::EnumDAdvise(PIEnumSTATDATA *ppiesd)
{
	HRESULT hr;

	DebugEntry(CConfLink::EnumDAdvise);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_WRITE_PTR(ppiesd, PIEnumSTATDATA));

	*ppiesd = NULL;
	hr = OLE_E_ADVISENOTSUPPORTED;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT((hr == S_OK && IS_VALID_INTERFACE_PTR(*ppiesd, IEnumSTATDATA)) ||
			(FAILED(hr) && ! *ppiesd));

	DebugExitHRESULT(CConfLink::EnumDAdvise, hr);

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\clclsfct.cpp ===
/*
 * clsfact.cpp - IClassFactory implementation.
 *
 * Taken from URL code - essentially identical to DavidDi's original code
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"

#include "CLinkID.h"
#include "clrefcnt.hpp"
#include "clenumft.hpp"
#include "clCnfLnk.hpp"

#include "clclsfct.h"

#define INITGUID
#include <initguid.h>
#include <olectlid.h>
#include <confguid.h>


// from niMgr.cpp
PIUnknown NewNmManager(OBJECTDESTROYEDPROC ObjectDestroyed);

// from imconfmg.cpp
PIUnknown NewConfMgr(OBJECTDESTROYEDPROC ObjectDestroyed);

/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

CCLASSCONSTRUCTOR s_cclscnstr[] =
{
//	{ &CLSID_ConferenceManager, &NewNmManager },
	{ &CLSID_ConfLink,			&NewConfLink },
//	{ &CLSID_NmManager,         &NewNmManager },
//   { &CLSID_MIMEFileTypesPropSheetHook,   &NewMIMEHook },
//   { &CLSID_Internet,                     &NewInternet },
};


#pragma data_seg()

/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_PER_INSTANCE)

// DLL reference count == number of class factories +
//                        number of URLs +
//                        LockServer() count

ULONG s_ulcDLLRef   = 0;

#pragma data_seg()

/***************************** Private Functions *****************************/


HRESULT GetClassConstructor(REFCLSID rclsid,
                                         PNEWOBJECTPROC pNewObject)
{
   HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
   UINT u;

   ASSERT(IsValidREFCLSID(rclsid));
   ASSERT(IS_VALID_WRITE_PTR(pNewObject, NEWOBJECTPROC));

   *pNewObject = NULL;

   for (u = 0; u < ARRAY_ELEMENTS(s_cclscnstr); u++)
   {
      if (rclsid == *(s_cclscnstr[u].pcclsid))
      {
         *pNewObject = s_cclscnstr[u].NewObject;
         hr = S_OK;
      }
   }

   ASSERT((hr == S_OK &&
           IS_VALID_CODE_PTR(*pNewObject, NEWOBJECTPROC)) ||
          (hr == CLASS_E_CLASSNOTAVAILABLE &&
           ! *pNewObject));

   return(hr);
}


VOID STDMETHODCALLTYPE DLLObjectDestroyed(void)
{
   TRACE_OUT(("DLLObjectDestroyed(): Object destroyed."));

   DllRelease();
}


PIUnknown NewConfLink(OBJECTDESTROYEDPROC ObjectDestroyed)
{
   ASSERT(! ObjectDestroyed ||
          IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

   TRACE_OUT(("NewConfLink(): Creating a new ConfLink."));

   return((PIUnknown) (PIConferenceLink) new CConfLink(ObjectDestroyed));
}

#if 0
PIUnknown NewMIMEHook(OBJECTDESTROYEDPROC ObjectDestroyed)
{
   ASSERT(! ObjectDestroyed ||
          IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

   TRACE_OUT(("NewMIMEHook(): Creating a new MIMEHook."));

   return((PIUnknown)(PIShellPropSheetExt)new(MIMEHook(ObjectDestroyed)));
}


PIUnknown NewInternet(OBJECTDESTROYEDPROC ObjectDestroyed)
{
   ASSERT(! ObjectDestroyed ||
          IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

   TRACE_OUT(("NewInternet(): Creating a new Internet."));

   return((PIUnknown)(PIShellPropSheetExt)new(Internet(ObjectDestroyed)));
}

#endif // 0

#ifdef DEBUG

BOOL IsValidPCCCLClassFactory(PCCCLClassFactory pccf)
{
   return(IS_VALID_READ_PTR(pccf, CCCLClassFactory) &&
          IS_VALID_CODE_PTR(pccf->m_NewObject, NEWOBJECTPROC) &&
          IS_VALID_STRUCT_PTR((PCRefCount)pccf, CRefCount) &&
          IS_VALID_INTERFACE_PTR((PCIClassFactory)pccf, IClassFactory));
}

#endif


/****************************** Public Functions *****************************/

ULONG DLLAddRef(void)
{
   ULONG ulcRef;

   ASSERT(s_ulcDLLRef < ULONG_MAX);

   ulcRef = ++s_ulcDLLRef;

   TRACE_OUT(("DLLAddRef(): DLL reference count is now %lu.",
              ulcRef));

   return(ulcRef);
}


ULONG DLLRelease(void)
{
   ULONG ulcRef;

   if (EVAL(s_ulcDLLRef > 0))
      s_ulcDLLRef--;

   ulcRef = s_ulcDLLRef;

   TRACE_OUT(("DLLRelease(): DLL reference count is now %lu.",
              ulcRef));

   return(ulcRef);
}


PULONG GetDLLRefCountPtr(void)
{
   return(&s_ulcDLLRef);
}


/********************************** Methods **********************************/


CCLClassFactory::CCLClassFactory(NEWOBJECTPROC NewObject,
                           OBJECTDESTROYEDPROC ObjectDestroyed) :
   RefCount(ObjectDestroyed)
{
   DebugEntry(CCLClassFactory::CCLClassFactory);

   // Don't validate this until after construction.

   ASSERT(IS_VALID_CODE_PTR(NewObject, NEWOBJECTPROC));

   m_NewObject = NewObject;

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   DebugExitVOID(CCLClassFactory::CCLClassFactory);

   return;
}


CCLClassFactory::~CCLClassFactory(void)
{
   DebugEntry(CCLClassFactory::~CCLClassFactory);

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   m_NewObject = NULL;

   // Don't validate this after destruction.

   DebugExitVOID(CCLClassFactory::~CCLClassFactory);

   return;
}


ULONG STDMETHODCALLTYPE CCLClassFactory::AddRef(void)
{
   ULONG ulcRef;

   DebugEntry(CCLClassFactory::AddRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   ulcRef = RefCount::AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   DebugExitULONG(CCLClassFactory::AddRef, ulcRef);

   return(ulcRef);
}


ULONG STDMETHODCALLTYPE CCLClassFactory::Release(void)
{
   ULONG ulcRef;

   DebugEntry(CCLClassFactory::Release);

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   ulcRef = RefCount::Release();

   DebugExitULONG(CCLClassFactory::Release, ulcRef);

   return(ulcRef);
}


HRESULT STDMETHODCALLTYPE CCLClassFactory::QueryInterface(REFIID riid,
                                                       PVOID *ppvObject)
{
   HRESULT hr = S_OK;

   DebugEntry(CCLClassFactory::QueryInterface);

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   if (riid == IID_IClassFactory)
   {
      *ppvObject = (PIClassFactory)this;
      ASSERT(IS_VALID_INTERFACE_PTR((PIClassFactory)*ppvObject, IClassFactory));
      TRACE_OUT(("CCLClassFactory::QueryInterface(): Returning IClassFactory."));
   }
   else if (riid == IID_IUnknown)
   {
      *ppvObject = (PIUnknown)this;
      ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
      TRACE_OUT(("CCLClassFactory::QueryInterface(): Returning IUnknown."));
   }
   else
   {
      *ppvObject = NULL;
      hr = E_NOINTERFACE;
      TRACE_OUT(("CCLClassFactory::QueryInterface(): Called on unknown interface."));
   }

   if (hr == S_OK)
      AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
   
   // removed by ChrisPi CINTERFACE undeclared identifier
   // ASSERT(FAILED(hr) ||
   //       IS_VALID_INTERFACE_PTR(*ppvObject, INTERFACE));

   DebugExitHRESULT(CCLClassFactory::QueryInterface, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CCLClassFactory::CreateInstance(PIUnknown piunkOuter,
                                                       REFIID riid,
                                                       PVOID *ppvObject)
{
   HRESULT hr;

   DebugEntry(CCLClassFactory::CreateInstance);

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
   ASSERT(! piunkOuter ||
          IS_VALID_INTERFACE_PTR(piunkOuter, IUnknown));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   *ppvObject = NULL;

   if (! piunkOuter)
   {
      PIUnknown piunk;

      piunk = (*m_NewObject)(  (void(__stdcall *)(void))   &DLLObjectDestroyed);

      if (piunk)
      {
         DllLock();

         hr = piunk->QueryInterface(riid, ppvObject);

         // N.b., the Release() method will destroy the object if the
         // QueryInterface() method failed.

         piunk->Release();
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
   {
      hr = CLASS_E_NOAGGREGATION;
      WARNING_OUT(("CCLClassFactory::CreateInstance(): Aggregation not supported."));
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
   
   // removed by ChrisPi - see above
   // ASSERT(FAILED(hr) ||
   //       IS_VALID_INTERFACE_PTR(*ppvObject, INTERFACE));

   DebugExitHRESULT(CCLClassFactory::CreateInstance, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CCLClassFactory::LockServer(BOOL bLock)
{
   HRESULT hr;

   DebugEntry(CCLClassFactory::LockServer);

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   // bLock may be any value.

   if (bLock)
      DllLock();
   else
      DllRelease();

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   DebugExitHRESULT(CCLClassFactory::LockServer, hr);

   return(hr);
}


/***************************** Exported Functions ****************************/


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PVOID *ppvObject)
{
   HRESULT hr = S_OK;
   NEWOBJECTPROC NewObject;

   DebugEntry(DllGetClassObject);

   ASSERT(IsValidREFCLSID(rclsid));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   *ppvObject = NULL;

   hr = GetClassConstructor(rclsid, &NewObject);

   if (hr == S_OK)
   {
      if (riid == IID_IUnknown ||
          riid == IID_IClassFactory)
      {
         PCCLClassFactory pcf;

         pcf = new CCLClassFactory(NewObject, (void(__stdcall *)(void)) &DLLObjectDestroyed);

         if (pcf)
         {
            if (riid == IID_IClassFactory)
            {
               *ppvObject = (PIClassFactory)pcf;
               ASSERT(IS_VALID_INTERFACE_PTR((PIClassFactory)*ppvObject, IClassFactory));
               TRACE_OUT(("DllGetClassObject(): Returning IClassFactory."));
            }
            else
            {
               ASSERT(riid == IID_IUnknown);
               *ppvObject = (PIUnknown)pcf;
               ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
               TRACE_OUT(("DllGetClassObject(): Returning IUnknown."));
            }

            DllLock();
            hr = S_OK;

            TRACE_OUT(("DllGetClassObject(): Created a new class factory."));
         }
         else
            hr = E_OUTOFMEMORY;
      }
      else
      {
         WARNING_OUT(("DllGetClassObject(): Called on unknown interface."));
         hr = E_NOINTERFACE;
      }
   }
   else
      WARNING_OUT(("DllGetClassObject(): Called on unknown class."));

   // removed by ChrisPi - see above
   // ASSERT(FAILED(hr) ||
   //       IS_VALID_INTERFACE_PTR(*ppvObject, INTERFACE));

   DebugExitHRESULT(DllGetClassObject, hr);

   return(hr);
}


STDAPI DllCanUnloadNow(void)
{
   HRESULT hr;

   DebugEntry(DllCanUnloadNow);

   hr = (s_ulcDLLRef > 0) ? S_FALSE : S_OK;

   TRACE_OUT(("DllCanUnloadNow(): DLL reference count is %lu.", s_ulcDLLRef));

   DebugExitHRESULT(DllCanUnloadNow, hr);

   return(hr);
}

void DllLock(void)
{
    InterlockedIncrement((LPLONG) &s_ulcDLLRef);

    DBGAPI_TRACE("Ref: DllLock count=%d", s_ulcDLLRef);
}

void DllRelease(void)
{
	LONG cRef = InterlockedDecrement((LPLONG) &s_ulcDLLRef);

#ifdef DEBUG
    DBGAPI_TRACE("Ref: DllLock count=%d", s_ulcDLLRef);
    if (0 == cRef)
		WARNING_OUT(("MSCONF.DLL Can now be unloaded"));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\clenumft.cpp ===
/*
 * enumfmte.cpp - EnumFormatEtc class implementation.
 *
 * Taken from URL code - essentially identical to DavidDi's original code
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"

#include "clrefcnt.hpp"
#include "clenumft.hpp"


/***************************** Private Functions *****************************/


#ifdef DEBUG

BOOL IsValidArrayOfFORMATETCs(CFORMATETC rgcfmtetc[],
                                           ULONG ulcFormats)
{
   BOOL bResult = TRUE;
   ULONG ul;

   for (ul = 0; ul < ulcFormats; ul++)
      bResult = (EVAL(IS_VALID_STRUCT_PTR(&(rgcfmtetc[ul]), CFORMATETC)) &&
                 bResult);

   return(bResult);
}


BOOL IsValidPCEnumFormatEtc(PCEnumFormatEtc pcefe)
{
   return(IS_VALID_READ_PTR(pcefe, CEnumFormatEtc) &&
          EVAL(IsValidArrayOfFORMATETCs(pcefe->m_pfmtetc, pcefe->m_ulcFormats)) &&
          EVAL(pcefe->m_uliCurrent <= pcefe->m_ulcFormats) &&
          IS_VALID_STRUCT_PTR((PCRefCount)pcefe, CRefCount) &&
          IS_VALID_INTERFACE_PTR((PCIEnumFORMATETC)pcefe, IEnumFORMATETC));
}

#endif


/********************************** Methods **********************************/


EnumFormatEtc::EnumFormatEtc(CFORMATETC rgcfmtetc[], ULONG ulcFormats) :
   RefCount(NULL)
{
   DebugEntry(EnumFormatEtc::EnumFormatEtc);

   // Don't validate this until after construction.

   ASSERT(IsValidArrayOfFORMATETCs(rgcfmtetc, ulcFormats));

   m_pfmtetc = new(FORMATETC[ulcFormats]);

   if (m_pfmtetc)
   {
      CopyMemory(m_pfmtetc, rgcfmtetc, ulcFormats * sizeof(rgcfmtetc[0]));
      m_ulcFormats = ulcFormats;
   }
   else
      m_ulcFormats = 0;

   m_uliCurrent = 0;

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   DebugExitVOID(EnumFormatEtc::EnumFormatEtc);

   return;
}


EnumFormatEtc::~EnumFormatEtc(void)
{
   DebugEntry(EnumFormatEtc::~EnumFormatEtc);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   if (m_pfmtetc)
   {
      delete m_pfmtetc;
      m_pfmtetc = NULL;
   }

   m_ulcFormats = 0;
   m_uliCurrent = 0;

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   DebugExitVOID(EnumFormatEtc::~EnumFormatEtc);

   return;
}


ULONG STDMETHODCALLTYPE EnumFormatEtc::AddRef(void)
{
   ULONG ulcRef;

   DebugEntry(EnumFormatEtc::AddRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   ulcRef = RefCount::AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   DebugExitULONG(EnumFormatEtc::AddRef, ulcRef);

   return(ulcRef);
}


ULONG STDMETHODCALLTYPE EnumFormatEtc::Release(void)
{
   ULONG ulcRef;

   DebugEntry(EnumFormatEtc::Release);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   ulcRef = RefCount::Release();

   DebugExitULONG(EnumFormatEtc::Release, ulcRef);

   return(ulcRef);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::QueryInterface(REFIID riid,
														PVOID *ppvObject)
{
   HRESULT hr = S_OK;

   DebugEntry(EnumFormatEtc::QueryInterface);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   if (riid == IID_IEnumFORMATETC)
   {
      *ppvObject = (PIEnumFORMATETC)this;
      ASSERT(IS_VALID_INTERFACE_PTR((PIEnumFORMATETC)*ppvObject, IEnumFORMATETC));
      TRACE_OUT(("EnumFormatEtc::QueryInterface(): Returning IEnumFORMATETC."));
   }
   else if (riid == IID_IUnknown)
   {
      *ppvObject = (PIUnknown)this;
      ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
      TRACE_OUT(("EnumFormatEtc::QueryInterface(): Returning IUnknown."));
   }
   else
   {
      *ppvObject = NULL;
      hr = E_NOINTERFACE;
      TRACE_OUT(("EnumFormatEtc::QueryInterface(): Called on unknown interface."));
   }

   if (hr == S_OK)
      AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   
   // removed by ChrisPi - CINTERFACE undeclared identifier
   //ASSERT(FAILED(hr) ||
   //       IS_VALID_INTERFACE_PTR(*ppvObject, INTERFACE));

   DebugExitHRESULT(EnumFormatEtc::QueryInterface, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Next(ULONG ulcToFetch,
                                              PFORMATETC pfmtetc,
                                              PULONG pulcFetched)
{
   HRESULT hr = S_FALSE;
   ULONG ulcFetched;

   DebugEntry(EnumFormatEtc::Next);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   if (m_uliCurrent < m_ulcFormats)
   {
      ULONG ulcCanFetch = m_ulcFormats - m_uliCurrent;

      ulcFetched = min(ulcCanFetch, ulcToFetch);

      CopyMemory(pfmtetc, &(m_pfmtetc[m_uliCurrent]),
                 ulcFetched * sizeof(*pfmtetc));

      m_uliCurrent += ulcFetched;
   }
   else
      // End of the list.
      ulcFetched = 0;

   if (pulcFetched)
      *pulcFetched = ulcFetched;
   else
      ASSERT(ulcToFetch == 1);

   if (ulcFetched < ulcToFetch)
      hr = S_FALSE;
   else
   {
      ASSERT(ulcFetched == ulcToFetch);
      hr = S_OK;
   }

   TRACE_OUT(("EnumFormatEtc::Next(): Fetched %lu FORMATETCs.",
              ulcFetched));

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT((((hr == S_OK &&
             EVAL((! pulcFetched &&
                   ulcToFetch == 1) ||
                  *pulcFetched == ulcToFetch)) ||
            (hr == S_FALSE &&
             EVAL((! pulcFetched &&
                   ulcToFetch == 1) ||
                  *pulcFetched < ulcToFetch))) &&
            EVAL((! pulcFetched &&
                  IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC)) ||
                 IsValidArrayOfFORMATETCs(pfmtetc, *pulcFetched))) ||
          (FAILED(hr) &&
           EVAL((! pulcFetched &&
                 ulcToFetch == 1) ||
                ! *pulcFetched)));

   DebugExitHRESULT(EnumFormatEtc::Next, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Skip(ULONG ulcToSkip)
{
   HRESULT hr;

   DebugEntry(EnumFormatEtc::Skip);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   if (ulcToSkip <= m_ulcFormats - m_uliCurrent)
   {
      m_uliCurrent += ulcToSkip;
      hr = S_OK;

      TRACE_OUT(("EnumFormatEtc::Skip(): Skipped %lu FORMATETCs, as requested.",
                 ulcToSkip));
   }
   else
   {
      TRACE_OUT(("EnumFormatEtc::Skip(): Skipped %lu of %lu FORMATETCs.",
                 m_ulcFormats - m_uliCurrent,
                 ulcToSkip));

      m_uliCurrent = m_ulcFormats;
      hr = S_FALSE;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT((hr == S_OK &&
           m_uliCurrent <= m_ulcFormats) ||
          (hr == S_FALSE &&
           m_uliCurrent == m_ulcFormats));

   DebugExitHRESULT(EnumFormatEtc::Skip, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Reset(void)
{
   HRESULT hr;

   DebugEntry(EnumFormatEtc::Reset);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   m_uliCurrent = 0;
   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT(hr == S_OK &&
          ! m_uliCurrent);

   DebugExitHRESULT(EnumFormatEtc::Reset, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Clone(PIEnumFORMATETC *ppiefe)
{
   HRESULT hr;
   PEnumFormatEtc pefe;

   DebugEntry(EnumFormatEtc::Clone);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   pefe = new ::EnumFormatEtc(m_pfmtetc, m_ulcFormats);

   if (pefe)
   {
      hr = pefe->Status();

      if (hr == S_OK)
      {
         hr = pefe->Skip(m_uliCurrent);

         if (hr == S_OK)
            *ppiefe = pefe;
         else
            hr = E_UNEXPECTED;
      }

      if (hr != S_OK)
      {
         delete pefe;
         pefe = NULL;
      }
   }
   else
      hr = E_OUTOFMEMORY;

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT((hr == S_OK &&
           IS_VALID_INTERFACE_PTR(*ppiefe, IEnumFORMATETC)) ||
          (FAILED(hr) &&
           ! *ppiefe));

   DebugExitHRESULT(EnumFormatEtc::Clone, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Status(void)
{
   HRESULT hr;

   DebugEntry(EnumFormatEtc::Status);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   hr = (m_pfmtetc ? S_OK : E_OUTOFMEMORY);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   DebugExitHRESULT(EnumFormatEtc::Status, hr);

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\clenumft.hpp ===
/*
 * enumfmte.hpp - EnumFormatEtc class description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _ENUMFMTE_HPP_
#define _ENUMFMTE_HPP_

/* Classes
 **********/

class EnumFormatEtc : public RefCount,
                      public IEnumFORMATETC
{
private:
   PFORMATETC m_pfmtetc;
   ULONG m_ulcFormats;   
   ULONG m_uliCurrent;

public:
   EnumFormatEtc(CFORMATETC rgcfmtetc[], ULONG ulcFormats);
   ~EnumFormatEtc(void);

   // IEnumFormatEtc methods

   HRESULT STDMETHODCALLTYPE Next(ULONG ulcToFetch, PFORMATETC pfmtetc, PULONG pulcFetched);
   HRESULT STDMETHODCALLTYPE Skip(ULONG ulcToSkip);
   HRESULT STDMETHODCALLTYPE Reset(void);
   HRESULT STDMETHODCALLTYPE Clone(PIEnumFORMATETC *ppiefe);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
   HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);

   // other methods

   HRESULT STDMETHODCALLTYPE Status(void);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCEnumFormatEtc(const EnumFormatEtc *pcefe);

#endif

};
DECLARE_STANDARD_TYPES(EnumFormatEtc);

#endif // _ENUMFMTE_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\clpersis.hpp ===
/*
 * persist.hpp - IPersist, IPersistFile, and IPersistStream implementation
 *               description.
 *
 * Taken from URL code by ChrisPi 9-12-95
 *
 */


/* Global Constants
 *******************/

// persist.cpp

extern const UINT g_ucMaxURLLen;
extern const char g_cszURLLeftDelimiter[];
extern const char g_cszURLRightDelimiter[];
extern const char g_cszURLPrefix[];
extern const UINT g_ucbURLPrefixLen;
extern const char g_cszURLExt[];
extern const char g_cszURLDefaultFileNamePrompt[];
extern const char g_cszCRLF[];


/* Prototypes
 *************/

// persist.cpp

extern HRESULT UnicodeToANSI(LPCOLESTR pcwszUnicode, PSTR *ppszANSI);
extern HRESULT ANSIToUnicode(PCSTR pcszANSI, LPOLESTR *ppwszUnicode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\clrefcnt.cpp ===
/*
 * refcount.cpp - RefCount class implementation.
 *
 * Taken from URL code - essentially identical to DavidDi's original code
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"

#include "clrefcnt.hpp"

/****************************** Public Functions *****************************/


#ifdef DEBUG

BOOL IsValidPCRefCount(PCRefCount pcrefcnt)
{
   // m_ulcRef may be any value.

   return(IS_VALID_READ_PTR(pcrefcnt, CRefCount) &&
          (! pcrefcnt->m_ObjectDestroyed ||
           IS_VALID_CODE_PTR(pcrefcnt->m_ObjectDestroyed, OBJECTDESTROYEDPROC)));
}

#endif


/********************************** Methods **********************************/


RefCount::RefCount(OBJECTDESTROYEDPROC ObjectDestroyed)
{
   DebugEntry(RefCount::RefCount);

   /* Don't validate this until after initialization. */

   ASSERT(! ObjectDestroyed ||
          IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

   m_ulcRef = 1;
   m_ObjectDestroyed = ObjectDestroyed;
   DBGAPI_REF("Ref: %08X c=%d (created)", this, m_ulcRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   DebugExitVOID(RefCount::RefCount);

   return;
}


RefCount::~RefCount(void)
{
   DebugEntry(RefCount::~RefCount);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   // m_ulcRef may be any value.
   DBGAPI_REF("Ref: %08X c=%d (destroyed)", this, m_ulcRef);

   if (m_ObjectDestroyed)
   {
      m_ObjectDestroyed();
      m_ObjectDestroyed = NULL;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   DebugExitVOID(RefCount::~RefCount);

   return;
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
   DebugEntry(RefCount::AddRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   ASSERT(m_ulcRef < ULONG_MAX);
   m_ulcRef++;
   DBGAPI_REF("Ref: %08X c=%d (AddRef)", this, m_ulcRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   DebugExitULONG(RefCount::AddRef, m_ulcRef);

   return(m_ulcRef);
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
   ULONG ulcRef;

   DebugEntry(RefCount::Release);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   if (EVAL(m_ulcRef > 0))
      m_ulcRef--;

   ulcRef = m_ulcRef;
   DBGAPI_REF("Ref: %08X c=%d (Release)", this, m_ulcRef);

   if (! ulcRef)
      delete this;

   DebugExitULONG(RefCount::Release, ulcRef);

   return(ulcRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\clrefcnt.hpp ===
/*
 * refcount.hpp - RefCount class description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _REFCOUNT_HPP_
#define _REFCOUNT_HPP_

/* Types
 ********/

// RefCount destructor callback function

typedef void (*OBJECTDESTROYEDPROC)(void);


/* Classes
 **********/

class RefCount
{
private:
   ULONG m_ulcRef;
   OBJECTDESTROYEDPROC m_ObjectDestroyed;

public:
   RefCount(OBJECTDESTROYEDPROC ObjectDestroyed);
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount(void);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCRefCount(const RefCount *pcrefcnt);

#endif

};
DECLARE_STANDARD_TYPES(RefCount);

VOID DllLock(void);
VOID DllRelease(void);
VOID STDMETHODCALLTYPE DLLObjectDestroyed(void);


#endif // _REFCOUNT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\dlginfo.h ===
// File: dlgInfo.h

#ifndef _CDLGINFO_H_
#define _CDLGINFO_H_

#include "imsconf3.h"

class CDlgInfo
{
private:
	HWND   m_hwnd;
	HWND   m_hwndCombo;

	VOID InitCtrl(NM_SYSPROP nmProp, HWND hwnd, int cchMax);
	VOID InitCategory(void);
	VOID ValidateData(void);
	BOOL FSetProperty(NM_SYSPROP nmProp, int id);
	BOOL FSaveData(void);
	BOOL FSetCategory(void);

public:
	CDlgInfo();
	~CDlgInfo();

	INT_PTR DoModal(HWND hwndParent=HWND_DESKTOP);
	
	VOID OnInitDialog(void);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif /* _CDLGINFO_H_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\clpersis.cpp ===
/*
 * persist.cpp - IPersist, IPersistFile, and IPersistStream implementations for
 *               CConfLink class.
 *
 * Taken from URL code - very similar to DavidDi's original code
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"

#include "CLinkID.h"
#include "clrefcnt.hpp"
#include "clenumft.hpp"
#include "clCnfLnk.hpp"

/* Global Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

static const UINT g_ucMaxNameLen					= MAX_DIALINFO_STRING; // (was 1024)
static const UINT g_ucMaxAddrLen					= MAX_DIALINFO_STRING; // (was 1024)
static const UINT g_ucMaxRemoteConfNameLen			= MAX_DIALINFO_STRING; // (was 1024)

static const char g_cszConfLinkExt[]                    = ".cnf";
static const char g_cszConfLinkDefaultFileNamePrompt[]  = "*.cnf";
static const char g_cszCRLF[]                      = "\r\n";

static const char g_cszEmpty[] = "";
#define EMPTY_STRING  g_cszEmpty

#pragma data_seg()




/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

// case-insensitive

const char s_cszSectionBefore[]       = "[";
const char s_cszSectionAfter[]        = "]";
const char s_cszKeyValueSep[]         = "=";

const char s_cszConferenceShortcutSection[] = "ConferenceShortcut";

const char s_cszNameKey[]             = "ConfName";
const char s_cszAddressKey[]          = "Address";
const char s_cszTransportKey[]        = "Transport";
const char s_cszRemoteConfNameKey[]   = "RemoteConfName";
const char s_cszCallFlagsKey[]        = "CallFlags";

const char s_cszIconFileKey[]         = "IconFile";
const char s_cszIconIndexKey[]        = "IconIndex";
const char s_cszHotkeyKey[]           = "Hotkey";
const char s_cszWorkingDirectoryKey[] = "WorkingDirectory";
const char s_cszShowCmdKey[]          = "ShowCommand";

const UINT s_ucMaxIconIndexLen        = 1 + 10 + 1; // -2147483647
const UINT s_ucMaxTransportLen        = 10 + 1;  //  4294967296
const UINT s_ucMaxCallFlagsLen        = 10 + 1;  //  4294967296
const UINT s_ucMaxHotkeyLen           = s_ucMaxIconIndexLen;
const UINT s_ucMaxShowCmdLen          = s_ucMaxIconIndexLen;

#pragma data_seg()


/***************************** Private Functions *****************************/


BOOL DeletePrivateProfileString(PCSTR pcszSection, PCSTR pcszKey,
                                             PCSTR pcszFile)
{
   ASSERT(IS_VALID_STRING_PTR(pcszSection, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszKey, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

   return(WritePrivateProfileString(pcszSection, pcszKey, NULL, pcszFile));
}

HRESULT ReadConfNameFromFile(PCSTR pcszFile, PSTR *ppszName)
{
   HRESULT hr;
   PSTR pszNewName;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszName, PSTR));

   *ppszName = NULL;

   pszNewName = new(char[g_ucMaxNameLen]);

   if (pszNewName)
   {
      DWORD dwcValueLen;

      dwcValueLen = GetPrivateProfileString(s_cszConferenceShortcutSection,
                                            s_cszNameKey, EMPTY_STRING,
                                            pszNewName, g_ucMaxNameLen, pcszFile);

      if (dwcValueLen > 0)
      {
         hr = S_OK;
         
         *ppszName = pszNewName;
      }
      else
      {
         hr = S_FALSE;

         WARNING_OUT(("ReadConfNameFromFile: No Name found in file %s.",
                      pcszFile));
      }
   }
   else
      hr = E_OUTOFMEMORY;

   if (FAILED(hr) ||
       hr == S_FALSE)
   {
      if (pszNewName)
      {
         delete [] pszNewName;
         pszNewName = NULL;
      }
   }

   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszName, STR)) ||
          (hr != S_OK &&
           ! *ppszName));

   return(hr);
}


HRESULT WriteConfNameToFile(PCSTR pcszFile, PCSTR pcszName)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszName ||
          IS_VALID_STRING_PTR(pcszName, CSTR));

   if (AnyMeat(pcszName))
   {
      ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
      ASSERT(IS_VALID_STRING_PTR(pcszName, PSTR));

      // (- 1) for null terminator.

      hr = (WritePrivateProfileString(s_cszConferenceShortcutSection, s_cszNameKey, 
   	                                  pcszName, pcszFile)) ? S_OK : E_FAIL;

   }
   else
      hr = (DeletePrivateProfileString(s_cszConferenceShortcutSection, s_cszNameKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}

HRESULT ReadAddressFromFile(PCSTR pcszFile, PSTR *ppszAddress)
{
   HRESULT hr;
   PSTR pszNewAddr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszAddress, PSTR));

   *ppszAddress = NULL;

   pszNewAddr = new(char[g_ucMaxAddrLen]);

   if (pszNewAddr)
   {
      DWORD dwcValueLen;

      dwcValueLen = GetPrivateProfileString(s_cszConferenceShortcutSection,
                                            s_cszAddressKey, EMPTY_STRING,
                                            pszNewAddr, g_ucMaxAddrLen, pcszFile);

      if (dwcValueLen > 0)
      {
         hr = S_OK;
         
         *ppszAddress = pszNewAddr;
      }
      else
      {
         hr = S_FALSE;

         WARNING_OUT(("ReadAddressFromFile: No Address found in file %s.",
                      pcszFile));
      }
   }
   else
      hr = E_OUTOFMEMORY;

   if (FAILED(hr) ||
       hr == S_FALSE)
   {
      if (pszNewAddr)
      {
         delete [] pszNewAddr;
         pszNewAddr = NULL;
      }
   }

   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszAddress, STR)) ||
          (hr != S_OK &&
           ! *ppszAddress));

   return(hr);
}

HRESULT WriteAddressToFile(PCSTR pcszFile, PCSTR pcszAddress)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszAddress ||
          IS_VALID_STRING_PTR(pcszAddress, CSTR));

   if (AnyMeat(pcszAddress))
   {
      ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
      ASSERT(IS_VALID_STRING_PTR(pcszAddress, PSTR));

      // (- 1) for null terminator.

      hr = (WritePrivateProfileString(s_cszConferenceShortcutSection, s_cszAddressKey, 
   	                                  pcszAddress, pcszFile)) ? S_OK : E_FAIL;

   }
   else
      hr = (DeletePrivateProfileString(s_cszConferenceShortcutSection, s_cszAddressKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}

HRESULT ReadRemoteConfNameFromFile(PCSTR pcszFile,
												PSTR *ppszRemoteConfName)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszRemoteConfName, PSTR));

   *ppszRemoteConfName = NULL;

   PSTR pszNewRemoteConfName = new(char[g_ucMaxAddrLen]);

   if (pszNewRemoteConfName)
   {
      DWORD dwcValueLen;

      dwcValueLen = GetPrivateProfileString(s_cszConferenceShortcutSection,
                                            s_cszRemoteConfNameKey, EMPTY_STRING,
                                            pszNewRemoteConfName,
											g_ucMaxRemoteConfNameLen, pcszFile);

      if (dwcValueLen > 0)
      {
         hr = S_OK;
         
         *ppszRemoteConfName = pszNewRemoteConfName;
      }
      else
      {
         hr = S_FALSE;

         TRACE_OUT(("ReadRemoteConfNameFromFile: No RemoteConfName found in file %s.",
                      pcszFile));
      }
   }
   else
      hr = E_OUTOFMEMORY;

   if (FAILED(hr) ||
       hr == S_FALSE)
   {
     delete [] pszNewRemoteConfName;
     pszNewRemoteConfName = NULL;
   }

   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszRemoteConfName, STR)) ||
          (hr != S_OK &&
           ! *ppszRemoteConfName));

   return(hr);
}

HRESULT WriteRemoteConfNameToFile(PCSTR pcszFile,
											   PCSTR pcszRemoteConfName)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszRemoteConfName ||
          IS_VALID_STRING_PTR(pcszRemoteConfName, CSTR));

   if (AnyMeat(pcszRemoteConfName))
   {
      ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
      ASSERT(IS_VALID_STRING_PTR(pcszRemoteConfName, PSTR));

      // (- 1) for null terminator.

      hr = (WritePrivateProfileString(s_cszConferenceShortcutSection, s_cszRemoteConfNameKey, 
   	                                  pcszRemoteConfName, pcszFile)) ? S_OK : E_FAIL;

   }
   else
   {
      hr = (DeletePrivateProfileString(	s_cszConferenceShortcutSection,
										s_cszRemoteConfNameKey,
										pcszFile))
           ? S_OK
           : E_FAIL;
   }

   return(hr);
}

HRESULT ReadTransportFromFile(PCSTR pcszFile, PDWORD pdwTransport)
{
   HRESULT hr;
   char rgchNewTransport[s_ucMaxTransportLen];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pdwTransport, INT));

   *pdwTransport = 0;

   dwcValueLen = GetPrivateProfileString(s_cszConferenceShortcutSection,
                                         s_cszTransportKey, EMPTY_STRING,
                                         rgchNewTransport,
                                         sizeof(rgchNewTransport), pcszFile);

   if (dwcValueLen > 0)
   {
		*pdwTransport = DecimalStringToUINT(rgchNewTransport);
		hr = S_OK;
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadTransportFromFile: No transport found in file %s.",
                 pcszFile));
   }

   ASSERT((hr == S_OK) ||
          (hr == S_FALSE &&
           EVAL(*pdwTransport == 0)));

   return(hr);
}

HRESULT WriteTransportToFile(PCSTR pcszFile, DWORD dwTransport)
{
	HRESULT hr;

	ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

	char rgchTransportRHS[s_ucMaxTransportLen];
	int ncLen;

	ncLen = wsprintf(rgchTransportRHS, "%u", dwTransport);
	ASSERT(ncLen > 0);
	ASSERT(ncLen < sizeof(rgchTransportRHS));
	ASSERT(ncLen == lstrlen(rgchTransportRHS));

	hr = (WritePrivateProfileString(s_cszConferenceShortcutSection,
									s_cszTransportKey, rgchTransportRHS,
									pcszFile))
			? S_OK
			: E_FAIL;

	return(hr);
}

HRESULT ReadCallFlagsFromFile(PCSTR pcszFile, PDWORD pdwCallFlags)
{
   HRESULT hr;
   char rgchNewCallFlags[s_ucMaxCallFlagsLen];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pdwCallFlags, INT));

   *pdwCallFlags = 0;

   dwcValueLen = GetPrivateProfileString(s_cszConferenceShortcutSection,
                                         s_cszCallFlagsKey, EMPTY_STRING,
                                         rgchNewCallFlags,
                                         sizeof(rgchNewCallFlags), pcszFile);

   if (dwcValueLen > 0)
   {
		*pdwCallFlags = DecimalStringToUINT(rgchNewCallFlags);
		hr = S_OK;
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadCallFlagsFromFile: No CallFlags found in file %s.",
                 pcszFile));
   }

   ASSERT((hr == S_OK) ||
          (hr == S_FALSE &&
           EVAL(*pdwCallFlags == 0)));

   return(hr);
}

HRESULT WriteCallFlagsToFile(PCSTR pcszFile, DWORD dwCallFlags)
{
	HRESULT hr;

	ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

	char rgchCallFlagsRHS[s_ucMaxCallFlagsLen];
	int ncLen;

	ncLen = wsprintf(rgchCallFlagsRHS, "%u", dwCallFlags);
	ASSERT(ncLen > 0);
	ASSERT(ncLen < sizeof(rgchCallFlagsRHS));
	ASSERT(ncLen == lstrlen(rgchCallFlagsRHS));

	hr = (WritePrivateProfileString(s_cszConferenceShortcutSection,
									s_cszCallFlagsKey, rgchCallFlagsRHS,
									pcszFile))
			? S_OK
			: E_FAIL;

	return(hr);
}


#if 0

HRESULT ReadIconLocationFromFile(PCSTR pcszFile,
                                              PSTR *ppszIconFile, PINT pniIcon)
{
   HRESULT hr;
   char rgchNewIconFile[MAX_PATH_LEN];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszIconFile, PSTR));
   ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

   *ppszIconFile = NULL;
   *pniIcon = 0;

   dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                         s_cszIconFileKey, EMPTY_STRING,
                                         rgchNewIconFile,
                                         sizeof(rgchNewIconFile), pcszFile);

   if (dwcValueLen > 0)
   {
      char rgchNewIconIndex[s_ucMaxIconIndexLen];

      dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                            s_cszIconIndexKey,
                                            EMPTY_STRING, rgchNewIconIndex,
                                            sizeof(rgchNewIconIndex),
                                            pcszFile);

      if (dwcValueLen > 0)
      {
		int niIcon = DecimalStringToUINT(rgchNewIconIndex);

           *ppszIconFile = new(char[lstrlen(rgchNewIconFile) + 1]);

            if (*ppszIconFile)
            {
               lstrcpy(*ppszIconFile, rgchNewIconFile);
               *pniIcon = niIcon;

               hr = S_OK;
            }
            else
               hr = E_OUTOFMEMORY;
      }
      else
      {
         hr = S_FALSE;

         WARNING_OUT(("ReadIconLocationFromFile(): No icon index found in file %s.",
                      pcszFile));
      }
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadIconLocationFromFile(): No icon file found in file %s.",
                 pcszFile));
   }

   ASSERT(IsValidIconIndex(hr, *ppszIconFile, MAX_PATH_LEN, *pniIcon));

   return(hr);
}


HRESULT WriteIconLocationToFile(PCSTR pcszFile,
                                             PCSTR pcszIconFile,
                                             int niIcon)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszIconFile ||
          IS_VALID_STRING_PTR(pcszIconFile, CSTR));
   ASSERT(IsValidIconIndex((pcszIconFile ? S_OK : S_FALSE), pcszIconFile, MAX_PATH_LEN, niIcon));

   if (AnyMeat(pcszIconFile))
   {
      char rgchIconIndexRHS[s_ucMaxIconIndexLen];
      int ncLen;

      ncLen = wsprintf(rgchIconIndexRHS, "%d", niIcon);
      ASSERT(ncLen > 0);
      ASSERT(ncLen < sizeof(rgchIconIndexRHS));
      ASSERT(ncLen == lstrlen(rgchIconIndexRHS));

      hr = (WritePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszIconFileKey, pcszIconFile,
                                      pcszFile) &&
            WritePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszIconIndexKey, rgchIconIndexRHS,
                                      pcszFile))
           ? S_OK
           : E_FAIL;
   }
   else
      hr = (DeletePrivateProfileString(s_cszInternetShortcutSection,
                                       s_cszIconFileKey, pcszFile) &&
            DeletePrivateProfileString(s_cszInternetShortcutSection,
                                       s_cszIconIndexKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}


HRESULT ReadHotkeyFromFile(PCSTR pcszFile, PWORD pwHotkey)
{
   HRESULT hr = S_FALSE;
   char rgchHotkey[s_ucMaxHotkeyLen];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pwHotkey, WORD));

   *pwHotkey = 0;

   dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                         s_cszHotkeyKey, EMPTY_STRING,
                                         rgchHotkey, sizeof(rgchHotkey),
                                         pcszFile);

   if (dwcValueLen > 0)
   {
		*pwHotkey = (WORD) DecimalStringToUINT(rgchHotkey);
		hr = S_OK;
   }
   else
      WARNING_OUT(("ReadHotkeyFromFile(): No hotkey found in file %s.",
                   pcszFile));

   ASSERT((hr == S_OK &&
           IsValidHotkey(*pwHotkey)) ||
          (hr == S_FALSE &&
           ! *pwHotkey));

   return(hr);
}


HRESULT WriteHotkeyToFile(PCSTR pcszFile, WORD wHotkey)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! wHotkey ||
          IsValidHotkey(wHotkey));

   if (wHotkey)
   {
      char rgchHotkeyRHS[s_ucMaxHotkeyLen];
      int ncLen;

      ncLen = wsprintf(rgchHotkeyRHS, "%u", (UINT)wHotkey);
      ASSERT(ncLen > 0);
      ASSERT(ncLen < sizeof(rgchHotkeyRHS));
      ASSERT(ncLen == lstrlen(rgchHotkeyRHS));

      hr = WritePrivateProfileString(s_cszInternetShortcutSection,
                                     s_cszHotkeyKey, rgchHotkeyRHS,
                                     pcszFile)
           ? S_OK
           : E_FAIL;
   }
   else
      hr = DeletePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszHotkeyKey, pcszFile)
           ? S_OK
           : E_FAIL;

   return(hr);
}


HRESULT ReadWorkingDirectoryFromFile(PCSTR pcszFile,
                                                  PSTR *ppszWorkingDirectory)
{
   HRESULT hr;
   char rgchDirValue[MAX_PATH_LEN];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszWorkingDirectory, PSTR));

   *ppszWorkingDirectory = NULL;

   dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                         s_cszWorkingDirectoryKey,
                                         EMPTY_STRING, rgchDirValue,
                                         sizeof(rgchDirValue), pcszFile);

   if (dwcValueLen > 0)
   {
      char rgchFullPath[MAX_PATH_LEN];
      PSTR pszFileName;

      if (GetFullPathName(rgchDirValue, sizeof(rgchFullPath), rgchFullPath,
                          &pszFileName) > 0)
      {
         // (+ 1) for null terminator.

         *ppszWorkingDirectory = new(char[lstrlen(rgchFullPath) + 1]);

         if (*ppszWorkingDirectory)
         {
            lstrcpy(*ppszWorkingDirectory, rgchFullPath);

            hr = S_OK;
         }
         else
            hr = E_OUTOFMEMORY;
      }
      else
         hr = E_FAIL;
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadWorkingDirectoryFromFile: No working directory found in file %s.",
                 pcszFile));
   }

   ASSERT(IsValidPathResult(hr, *ppszWorkingDirectory, MAX_PATH_LEN));

   return(hr);
}


HRESULT WriteWorkingDirectoryToFile(PCSTR pcszFile,
                                                 PCSTR pcszWorkingDirectory)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszWorkingDirectory ||
          IS_VALID_STRING_PTR(pcszWorkingDirectory, CSTR));

   if (AnyMeat(pcszWorkingDirectory))
      hr = (WritePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszWorkingDirectoryKey,
                                      pcszWorkingDirectory, pcszFile))
           ? S_OK
           : E_FAIL;
   else
      hr = (DeletePrivateProfileString(s_cszInternetShortcutSection,
                                       s_cszWorkingDirectoryKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}


HRESULT ReadShowCmdFromFile(PCSTR pcszFile, PINT pnShowCmd)
{
   HRESULT hr;
   char rgchNewShowCmd[s_ucMaxShowCmdLen];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pnShowCmd, INT));

   *pnShowCmd = g_nDefaultShowCmd;

   dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                         s_cszShowCmdKey, EMPTY_STRING,
                                         rgchNewShowCmd,
                                         sizeof(rgchNewShowCmd), pcszFile);

   if (dwcValueLen > 0)
   {
		*pnShowCmd = DecimalStringToUINT(rgchNewShowCmd);
		hr = S_OK;
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadShowCmdFromFile: No show command found in file %s.",
                 pcszFile));
   }

   ASSERT((hr == S_OK &&
           EVAL(IsValidShowCmd(*pnShowCmd))) ||
          (hr == S_FALSE &&
           EVAL(*pnShowCmd == g_nDefaultShowCmd)));

   return(hr);
}


HRESULT WriteShowCmdToFile(PCSTR pcszFile, int nShowCmd)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IsValidShowCmd(nShowCmd));

   if (nShowCmd != g_nDefaultShowCmd)
   {
      char rgchShowCmdRHS[s_ucMaxShowCmdLen];
      int ncLen;

      ncLen = wsprintf(rgchShowCmdRHS, "%d", nShowCmd);
      ASSERT(ncLen > 0);
      ASSERT(ncLen < sizeof(rgchShowCmdRHS));
      ASSERT(ncLen == lstrlen(rgchShowCmdRHS));

      hr = (WritePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszShowCmdKey, rgchShowCmdRHS,
                                      pcszFile))
           ? S_OK
           : E_FAIL;
   }
   else
      hr = (DeletePrivateProfileString(s_cszInternetShortcutSection,
                                       s_cszShowCmdKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}

#endif // 0

/****************************** Public Functions *****************************/

// BUGBUG - Isn't this already in NMUTIL?
HRESULT UnicodeToANSI(LPCOLESTR pcwszUnicode, PSTR *ppszANSI)
{
   HRESULT hr;
   int ncbLen;

   // BUGBUG: Need OLESTR validation function to validate pcwszUnicode here.
   ASSERT(IS_VALID_WRITE_PTR(ppszANSI, PSTR));

   *ppszANSI = NULL;

   // Get length of translated string.

   ncbLen = WideCharToMultiByte(CP_ACP, 0, pcwszUnicode, -1, NULL, 0, NULL,
                                NULL);

   if (ncbLen > 0)
   {
      PSTR pszNewANSI;

      // (+ 1) for null terminator.

      pszNewANSI = new(char[ncbLen]);

      if (pszNewANSI)
      {
         // Translate string.

         if (WideCharToMultiByte(CP_ACP, 0, pcwszUnicode, -1, pszNewANSI,
                                 ncbLen, NULL, NULL) > 0)
         {
            *ppszANSI = pszNewANSI;
            hr = S_OK;
         }
         else
         {
            delete [] pszNewANSI;
            pszNewANSI = NULL;

            hr = E_UNEXPECTED;

            WARNING_OUT(("UnicodeToANSI(): Failed to translate Unicode string to ANSI."));
         }
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
   {
      hr = E_UNEXPECTED;

      WARNING_OUT(("UnicodeToANSI(): Failed to get length of translated ANSI string."));
   }

   ASSERT(FAILED(hr) ||
          IS_VALID_STRING_PTR(*ppszANSI, STR));

   return(hr);
}


HRESULT ANSIToUnicode(PCSTR pcszANSI, LPOLESTR *ppwszUnicode)
{
   HRESULT hr;
   int ncbWideLen;

   ASSERT(IS_VALID_STRING_PTR(pcszANSI, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppwszUnicode, LPOLESTR));

   *ppwszUnicode = NULL;

   // Get length of translated string.

   ncbWideLen = MultiByteToWideChar(CP_ACP, 0, pcszANSI, -1, NULL, 0);

   if (ncbWideLen > 0)
   {
      PWSTR pwszNewUnicode;

      // (+ 1) for null terminator.

      pwszNewUnicode = new(WCHAR[ncbWideLen]);

      if (pwszNewUnicode)
      {
         // Translate string.

         if (MultiByteToWideChar(CP_ACP, 0, pcszANSI, -1, pwszNewUnicode,
                                 ncbWideLen) > 0)
         {
            *ppwszUnicode = pwszNewUnicode;
            hr = S_OK;
         }
         else
         {
            delete [] pwszNewUnicode;
            pwszNewUnicode = NULL;

            hr = E_UNEXPECTED;

            WARNING_OUT(("ANSIToUnicode(): Failed to translate ANSI path string to Unicode."));
         }
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
   {
      hr = E_UNEXPECTED;

      WARNING_OUT(("ANSIToUnicode(): Failed to get length of translated Unicode string."));
   }

   // BUGBUG: Need OLESTR validation function to validate *ppwszUnicode here.

   return(hr);
}


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE CConfLink::SaveToFile(PCSTR pcszFile,
												BOOL bRemember)
{
	HRESULT hr;

	DebugEntry(CConfLink::SaveToFile);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

#if 0
	PSTR pszName;
	hr = GetName(&pszName);

	if (SUCCEEDED(hr))
	{
		hr = WriteConfNameToFile(pcszFile, pszName);

		// Free the string:
		if (pszName)
		{
			LPMALLOC pMalloc = NULL;

			if (SUCCEEDED(SHGetMalloc(&pMalloc)))
			{
				pMalloc->Free(pszName);
				pMalloc->Release();
				pMalloc = NULL;
				pszName = NULL;
			}
		}
	}
#endif // 0

	hr = S_OK;
	
	if (NULL != m_pszName)
	{
		hr = WriteConfNameToFile(pcszFile, m_pszName);
	}
	
	if ((S_OK == hr) &&
		(NULL != m_pszAddress))
	{
		hr = WriteAddressToFile(pcszFile, m_pszAddress);
	}

	if ((S_OK == hr) &&
		(NULL != m_pszRemoteConfName))
	{
		hr = WriteRemoteConfNameToFile(pcszFile, m_pszRemoteConfName);
	}

	if (S_OK == hr)
	{
		hr = WriteCallFlagsToFile(pcszFile, m_dwCallFlags);
	} 

	if (S_OK == hr)
	{
		hr = WriteTransportToFile(pcszFile, m_dwTransport);
	} 

#if 0
      if (hr == S_OK)
      {
         char rgchBuf[MAX_PATH_LEN];
         int niIcon;

         hr = GetIconLocation(rgchBuf, sizeof(rgchBuf), &niIcon);

         if (SUCCEEDED(hr))
         {
            hr = WriteIconLocationToFile(pcszFile, rgchBuf, niIcon);

            if (hr == S_OK)
            {
               WORD wHotkey;

               hr = GetHotkey(&wHotkey);

               if (SUCCEEDED(hr))
               {
                  hr = WriteHotkeyToFile(pcszFile, wHotkey);

                  if (hr == S_OK)
                  {
                     hr = GetWorkingDirectory(rgchBuf, sizeof(rgchBuf));

                     if (SUCCEEDED(hr))
                     {
                        hr = WriteWorkingDirectoryToFile(pcszFile, rgchBuf);

                        if (hr == S_OK)
                        {
                           int nShowCmd;

                           GetShowCmd(&nShowCmd);

                           hr = WriteShowCmdToFile(pcszFile, nShowCmd);

                           if (hr == S_OK)
                           {
                              /* Remember file if requested. */

#endif
                              if (bRemember)
                              {
                                 // Replace existing file string, if any
                                 if (m_pszFile)
                                 {
                                     delete m_pszFile;
                                 }

                                 m_pszFile = new TCHAR[lstrlen(pcszFile)+1];
                                 if (NULL != m_pszFile)
                                 {
                                    lstrcpy(m_pszFile, pcszFile);

                                    TRACE_OUT(("CConfLink::SaveToFile(): Remembering file %s, as requested.",
                                               m_pszFile));
                                 }
                                 else
                                 {
                                    hr = E_OUTOFMEMORY;
                                 }
                              }

                              if (hr == S_OK)
                              {
                                 Dirty(FALSE);

                                 SHChangeNotify(SHCNE_UPDATEITEM,
                                                (SHCNF_PATH | SHCNF_FLUSH), pcszFile,
                                                NULL);

#ifdef DEBUG
                                 TRACE_OUT(("CConfLink::SaveToFile(): Conf Link saved to file %s:",
                                            pcszFile));
                                 Dump();
#endif // DEBUG
                              }
#if 0
                           }
                        }
                     }
                  }
               }
            }
         }
      }

   }
#endif // 0

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::SaveToFile, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::LoadFromFile(	PCSTR pcszFile,
													BOOL bRemember)
{
   HRESULT hr;
   PSTR pszName;
   PSTR pszAddr;
   PSTR pszRemoteConfName;
   DWORD dwTransport;
   DWORD dwCallFlags;

   DebugEntry(CConfLink::LoadFromFile);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

   hr = ReadConfNameFromFile(pcszFile, &pszName);

   if (S_OK == hr)
   {
	  hr = SetName(pszName);

      if (pszName)
      {
         delete pszName;
         pszName = NULL;
      }
   }
      
	if (SUCCEEDED(hr))
	{
		hr = ReadAddressFromFile(pcszFile, &pszAddr);

		if (S_OK == hr)
		{
			hr = SetAddress(pszAddr);

			if (NULL != pszAddr)
			{
				delete pszAddr;
				pszAddr = NULL;
			}
		}
	}

	  if (SUCCEEDED(hr))
	  {
		  hr = ReadTransportFromFile(pcszFile, &dwTransport);

		  if (S_OK == hr)
		  {
			  hr = SetTransport(dwTransport);
		  }
	  }

	  if (SUCCEEDED(hr))
	  {
		  hr = ReadCallFlagsFromFile(pcszFile, &dwCallFlags);

		  if (S_OK == hr)
		  {
			  hr = SetCallFlags(dwCallFlags);
		  }
	  }
	   
	if (SUCCEEDED(hr))
	{
		hr = ReadRemoteConfNameFromFile(pcszFile, &pszRemoteConfName);

		if (S_OK == hr)
		{
			hr = SetRemoteConfName(pszRemoteConfName);

			delete pszRemoteConfName;
			pszRemoteConfName = NULL;
		}
	}
#if 0
      if (hr == S_OK)
      {
         PSTR pszIconFile;
         int niIcon;

         hr = ReadIconLocationFromFile(pcszFile, &pszIconFile, &niIcon);

         if (SUCCEEDED(hr))
         {
            hr = SetIconLocation(pszIconFile, niIcon);

            if (pszIconFile)
            {
               delete pszIconFile;
               pszIconFile = NULL;
            }

            if (hr == S_OK)
            {
               WORD wHotkey;

               hr = ReadHotkeyFromFile(pcszFile, &wHotkey);

               if (SUCCEEDED(hr))
               {
                  hr = SetHotkey(wHotkey);

                  if (hr == S_OK)
                  {
                     PSTR pszWorkingDirectory;

                     hr = ReadWorkingDirectoryFromFile(pcszFile,
                                                       &pszWorkingDirectory);

                     if (SUCCEEDED(hr))
                     {
                        hr = SetWorkingDirectory(pszWorkingDirectory);

                        if (pszWorkingDirectory)
                        {
                           delete pszWorkingDirectory;
                           pszWorkingDirectory = NULL;
                        }

                        if (hr == S_OK)
                        {
                           int nShowCmd;

                           hr = ReadShowCmdFromFile(pcszFile, &nShowCmd);

 #endif // 0
                           if (SUCCEEDED(hr))
                           {
                              /* Remember file if requested. */

                              if (bRemember)
                              {
                                 // PSTR pszFileCopy;

                                 //
                                 if (NULL != m_pszFile)
								 {
								    delete m_pszFile;
								 }

								 m_pszFile = new TCHAR[lstrlen(pcszFile) + 1];
								 
								 if (NULL != m_pszFile)
								 {
								    lstrcpy(m_pszFile, pcszFile);
								 }
								 else
								 {
								    hr = E_OUTOFMEMORY;
								 }

                                 
                                 // if (StringCopy(pcszFile, &pszFileCopy))
                                 // {
                                 //    if (m_pszFile)
                                 //       delete m_pszFile;

                                 //    m_pszFile = pszFileCopy;

                                 //    TRACE_OUT(("CConfLink::LoadFromFile(): Remembering file %s, as requested.",
                                 //               m_pszFile));
                                 // }
                                 // else
                                 //    hr = E_OUTOFMEMORY;
                              }

                              if (SUCCEEDED(hr))
                              {
                                 // SetShowCmd(nShowCmd);

                                 Dirty(FALSE);

                                 hr = S_OK;

#ifdef DEBUG
                                 TRACE_OUT(("CConfLink::LoadFromFile(): Conf Link loaded from file %s:",
                                            pcszFile));
                                 Dump();
#endif
                              }
                           }
#if 0
                        }
                     }
                  }
               }
            }
         }
      }
   }
#endif // 0

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::LoadFromFile, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::GetCurFile(PSTR pszFile,
												UINT ucbLen)
{
   HRESULT hr;

   DebugEntry(CConfLink::GetCurFile);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszFile, STR, ucbLen));

   if (m_pszFile)
   {
      lstrcpyn(pszFile, m_pszFile, ucbLen);

      TRACE_OUT(("CConfLink::GetCurFile(): Current file name is %s.",
                 pszFile));

      hr = S_OK;
   }
   else
      hr = S_FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_STRING_PTR(pszFile, STR) &&
          EVAL((UINT)lstrlen(pszFile) < ucbLen));
   ASSERT(hr == S_OK ||
          hr == S_FALSE);

   DebugExitHRESULT(CConfLink::GetCurFile, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::Dirty(BOOL bDirty)
{
   HRESULT hr;

   DebugEntry(CConfLink::Dirty);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   if (bDirty)
   {
      if (IS_FLAG_CLEAR(m_dwFlags, CONFLNK_FL_DIRTY))
	  {
         TRACE_OUT(("CConfLink::Dirty(): Now dirty."));
	  }

      SET_FLAG(m_dwFlags, CONFLNK_FL_DIRTY);
   }
   else
   {
      if (IS_FLAG_SET(m_dwFlags, CONFLNK_FL_DIRTY))
	  {
         TRACE_OUT(("CConfLink::Dirty(): Now clean."));
	  }

      CLEAR_FLAG(m_dwFlags, CONFLNK_FL_DIRTY);
   }

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(hr == S_OK);

   DebugExitVOID(CConfLink::Dirty);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::GetClassID(PCLSID pclsid)
{
   HRESULT hr;

   DebugEntry(CConfLink::GetClassID);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_STRUCT_PTR(pclsid, CCLSID));

   *pclsid = CLSID_ConfLink;
   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(FAILED(hr) ||
          IS_VALID_STRUCT_PTR(pclsid, CCLSID));

   DebugExitHRESULT(CConfLink::GetClassID, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::IsDirty(void)
{
   HRESULT hr;

   DebugEntry(CConfLink::IsDirty);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   if (IS_FLAG_SET(m_dwFlags, CONFLNK_FL_DIRTY))
      hr = S_OK;
   else
      hr = S_FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::IsDirty, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::Save(	LPCOLESTR pcwszFile,
											BOOL bRemember)
{
   HRESULT hr;
   PSTR pszFile;

   DebugEntry(CConfLink::Save);

   // bRemember may be any value.

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   // BUGBUG: Need OLESTR validation function to validate pcwszFile here.

   if (pcwszFile)
   {
      hr = UnicodeToANSI(pcwszFile, &pszFile);

      if (hr == S_OK)
      {
         hr = SaveToFile(pszFile, bRemember);

         delete pszFile;
         pszFile = NULL;
      }
   }
   else if (m_pszFile)
      // Ignore bRemember.
      hr = SaveToFile(m_pszFile, FALSE);
   else
      hr = E_FAIL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::Save, hr);

   return(hr);
}


// #pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::SaveCompleted(LPCOLESTR pcwszFile)
{
   HRESULT hr;

   DebugEntry(CConfLink::SaveCompleted);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   // BUGBUG: Need OLESTR validation function to validate pcwszFile here.

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::SaveCompleted, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::Load(	LPCOLESTR pcwszFile,
											DWORD dwMode)
{
   HRESULT hr;
   PSTR pszFile;

   DebugEntry(CConfLink::Load);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   // BUGBUG: Need OLESTR validation function to validate pcwszFile here.
   // BUGBUG: Validate dwMode here.

   // BUGBUG: Implement dwMode flag support.

   hr = UnicodeToANSI(pcwszFile, &pszFile);

   if (hr == S_OK)
   {
      hr = LoadFromFile(pszFile, TRUE);

      delete pszFile;
      pszFile = NULL;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::Load, hr);

   return(hr);
}

// #pragma warning(default:4100) /* "unreferenced formal parameter" warning */


HRESULT STDMETHODCALLTYPE CConfLink::GetCurFile(LPOLESTR *ppwszFile)
{
   HRESULT hr;
   LPOLESTR pwszTempFile;

   DebugEntry(CConfLink::GetCurFile);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_WRITE_PTR(ppwszFile, LPOLESTR));

   if (m_pszFile)
   {
      hr = ANSIToUnicode(m_pszFile, &pwszTempFile);

      if (hr == S_OK)
	  {
         TRACE_OUT(("CConfLink::GetCurFile(): Current file name is %s.",
                    m_pszFile));
	  }
   }
   else
   {
      hr = ANSIToUnicode(g_cszConfLinkDefaultFileNamePrompt, &pwszTempFile);

      if (hr == S_OK)
      {
         hr = S_FALSE;

         TRACE_OUT(("CConfLink::GetCurFile(): No current file name.  Returning default file name prompt %s.",
                    g_cszConfLinkDefaultFileNamePrompt));
      }
   }

   if (SUCCEEDED(hr))
   {
      // We should really call OleGetMalloc() to get the process IMalloc here.
      // Use SHAlloc() here instead to avoid loading ole32.dll.
      // SHAlloc() / SHFree() turn in to IMalloc::Alloc() and IMalloc::Free()
      // once ole32.dll is loaded.

      // N.b., lstrlenW() returns the length of the given string in characters,
      // not bytes.

      // (+ 1) for null terminator.

	   	LPMALLOC pMalloc = NULL;
		*ppwszFile = NULL;

		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			*ppwszFile = (LPOLESTR) pMalloc->Alloc((lstrlenW(pwszTempFile) + 1) *
													sizeof(*pwszTempFile));
			pMalloc->Release();
			pMalloc = NULL;
		}


      if (*ppwszFile)
	{
         LStrCpyW(*ppwszFile, pwszTempFile);
	}
      else
         hr = E_OUTOFMEMORY;

      delete pwszTempFile;
      pwszTempFile = NULL;
   }

   // BUGBUG: Need OLESTR validation function to validate *ppwszFile here.

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::GetCurFile, hr);

   return(hr);
}


// #pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::Load(PIStream pistr)
{
   HRESULT hr;

   DebugEntry(CConfLink::Load);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_INTERFACE_PTR(pistr, IStream));

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::Load, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::Save(	PIStream pistr,
											BOOL bClearDirty)
{
   HRESULT hr;

   DebugEntry(CConfLink::Save);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_INTERFACE_PTR(pistr, IStream));

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::Save, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::GetSizeMax(PULARGE_INTEGER pcbSize)
{
   HRESULT hr;

   DebugEntry(CConfLink::GetSizeMax);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_WRITE_PTR(pcbSize, ULARGE_INTEGER));

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::GetSizeMax, hr);

   return(hr);
}

// #pragma warning(default:4100) /* "unreferenced formal parameter" warning */


DWORD STDMETHODCALLTYPE CConfLink::GetFileContentsSize(void)
{
	DWORD dwcbLen;

	DebugEntry(CConfLink::GetFileContentsSize);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	// Section length.

	// (- 1) for each null terminator.

	dwcbLen = sizeof(s_cszSectionBefore) - 1 +
				sizeof(s_cszConferenceShortcutSection) - 1 +
				sizeof(s_cszSectionAfter) - 1;
	
	if (m_pszName)
	{
		// Name length.
		dwcbLen += sizeof(g_cszCRLF) - 1 +
					sizeof(s_cszNameKey) - 1 +
					sizeof(s_cszKeyValueSep) - 1 +
					lstrlen(m_pszName);
	}

	if (m_pszAddress)
	{
		// Address length.
		dwcbLen += sizeof(g_cszCRLF) - 1 +
					sizeof(s_cszAddressKey) - 1 +
					sizeof(s_cszKeyValueSep) - 1 +
					lstrlen(m_pszAddress);
	}

	if (m_pszRemoteConfName)
	{
		// RemoteConfName length.
		dwcbLen += sizeof(g_cszCRLF) - 1 +
					sizeof(s_cszRemoteConfNameKey) - 1 +
					sizeof(s_cszKeyValueSep) - 1 +
					lstrlen(m_pszRemoteConfName);
	}

	// CallFlags length
	dwcbLen += sizeof(g_cszCRLF) - 1 +
				sizeof(s_cszCallFlagsKey) - 1 +
				sizeof(s_cszKeyValueSep) - 1 +
				s_ucMaxCallFlagsLen;

	// Transport length
	dwcbLen += sizeof(g_cszCRLF) - 1 +
				sizeof(s_cszTransportKey) - 1 +
				sizeof(s_cszKeyValueSep) - 1 +
				s_ucMaxTransportLen;
	
	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitDWORD(CConfLink::GetFileContentsSize, dwcbLen);

	return(dwcbLen);
}


#ifdef DEBUG

void STDMETHODCALLTYPE CConfLink::Dump(void)
{
   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   TRACE_OUT(("m_dwFlags = %#08lx", m_dwFlags));
   TRACE_OUT(("m_pszFile = \"%s\"", CHECK_STRING(m_pszFile)));
   TRACE_OUT(("m_pszName = \"%s\"", CHECK_STRING(m_pszName)));
#if 0
   TRACE_OUT(("m_pszIconFile = \"%s\"", CHECK_STRING(m_pszIconFile)));
   TRACE_OUT(("m_niIcon = %d", m_niIcon));
   TRACE_OUT(("m_wHotkey = %#04x", (UINT)m_wHotkey));
   TRACE_OUT(("m_pszWorkingDirectory = \"%s\"", CHECK_STRING(m_pszWorkingDirectory)));
   TRACE_OUT(("m_nShowCmd = %d", m_nShowCmd));
#endif // 0

   return;
}

#endif

#if 0
HRESULT STDMETHODCALLTYPE CConfLink::TransferConfLink(	PFORMATETC pfmtetc,
														PSTGMEDIUM pstgmed)
{
	HRESULT hr;

	DebugEntry(CConfLink::TransferConfLink);

	ASSERT(0 && "If we hit this assert, we need to implement this function");

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(IS_VALID_WRITE_PTR(pstgmed, STGMEDIUM));

	ASSERT(pfmtetc->dwAspect == DVASPECT_CONTENT);
	ASSERT(pfmtetc->lindex == -1);

	ZeroMemory(pstgmed, sizeof(*pstgmed));

	if (IS_FLAG_SET(pfmtetc->tymed, TYMED_HGLOBAL))
	{
		// BUGBUG: ChrisPi 9-15-95
		// This only transfers the conference name
		// (It does not transfer the address)
		
		if (m_pszName)
		{
			HGLOBAL hgName;

			hr = E_OUTOFMEMORY;

			// (+ 1) for null terminator.
			hgName = GlobalAlloc(0, lstrlen(m_pszName) + 1);

			if (hgName)
			{
				PSTR pszName;

				pszName = (PSTR)GlobalLock(hgName);

				if (EVAL(pszName))
				{
					lstrcpy(pszName, m_pszName);

					pstgmed->tymed = TYMED_HGLOBAL;
					pstgmed->hGlobal = hgName;
					ASSERT(! pstgmed->pUnkForRelease);

					hr = S_OK;

					GlobalUnlock(hgName);
					pszName = NULL;
				}

				if (hr != S_OK)
				{
					GlobalFree(hgName);
					hgName = NULL;
				}
			}
		}
		else
		{
			hr = DV_E_FORMATETC;
		}
	}
	else
	{
		hr = DV_E_TYMED;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT((hr == S_OK &&
			IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM)) ||
			(FAILED(hr) &&
			(EVAL(pstgmed->tymed == TYMED_NULL) &&
			EVAL(! pstgmed->hGlobal) &&
			EVAL(! pstgmed->pUnkForRelease))));

	DebugExitHRESULT(CConfLink::TransferConfLink, hr);

	return(hr);
}
#endif // 0

#if 0
HRESULT STDMETHODCALLTYPE CConfLink::TransferText(	PFORMATETC pfmtetc,
													PSTGMEDIUM pstgmed)
{
	HRESULT hr;

	DebugEntry(CConfLink::TransferText);

	// Assume CConfLink::TransferConfLink() will perform
	// input and output validation.

	hr = TransferConfLink(pfmtetc, pstgmed);

	DebugExitHRESULT(CConfLink::TransferText, hr);

	return(hr);
}
#endif // 0

#if 0
HRESULT STDMETHODCALLTYPE CConfLink::TransferFileGroupDescriptor(	PFORMATETC pfmtetc,
																	PSTGMEDIUM pstgmed)
{
	HRESULT hr;

	DebugEntry(CConfLink::TransferFileGroupDescriptor);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(IS_VALID_WRITE_PTR(pstgmed, STGMEDIUM));

	ASSERT(pfmtetc->dwAspect == DVASPECT_CONTENT);
	ASSERT(pfmtetc->lindex == -1);

	pstgmed->tymed = TYMED_NULL;
	pstgmed->hGlobal = NULL;
	pstgmed->pUnkForRelease = NULL;

	if (IS_FLAG_SET(pfmtetc->tymed, TYMED_HGLOBAL))
	{
		HGLOBAL hgFileGroupDesc;

		hr = E_OUTOFMEMORY;

		hgFileGroupDesc = GlobalAlloc(GMEM_ZEROINIT,
		                            sizeof(FILEGROUPDESCRIPTOR));

		if (hgFileGroupDesc)
		{
			PFILEGROUPDESCRIPTOR pfgd;

			pfgd = (PFILEGROUPDESCRIPTOR)GlobalLock(hgFileGroupDesc);

			if (EVAL(pfgd))
			{
				PFILEDESCRIPTOR pfd = &(pfgd->fgd[0]);

				// Do we already have a file name to use?

				if (m_pszName)
				{
					TCHAR szFileName[MAX_PATH];
					
					// copy shortcut
					// BUGBUG: needs to be a resource INTL
					lstrcpy(szFileName, _TEXT("Shortcut to "));
					
					// copy Conference Name
					lstrcat(szFileName, m_pszName);
					
					// copy extension
					lstrcat(szFileName, g_cszConfLinkExt);
										
					MyLStrCpyN(pfd->cFileName, szFileName,
								sizeof(pfd->cFileName));
					hr = S_OK;
				}
				else
				{
					// BUGBUG: need resource here! INTL
					//if (EVAL(LoadString(GetThisModulesHandle(),
					//		IDS_NEW_INTERNET_SHORTCUT, pfd->cFileName,
					//		sizeof(pfd->cFileName))))
					
					MyLStrCpyN(pfd->cFileName, "New Conference Shortcut.cnf",
								sizeof(pfd->cFileName));
					hr = S_OK;
				}

				if (hr == S_OK)
				{
					pfd->dwFlags = (FD_FILESIZE |
					               FD_LINKUI);
					pfd->nFileSizeHigh = 0;
					
					pfd->nFileSizeLow = GetFileContentsSize();

					pfgd->cItems = 1;

					pstgmed->tymed = TYMED_HGLOBAL;
					pstgmed->hGlobal = hgFileGroupDesc;
					ASSERT(! pstgmed->pUnkForRelease);
				}

				GlobalUnlock(hgFileGroupDesc);
				pfgd = NULL;
			}

			if (hr != S_OK)
			{
				GlobalFree(hgFileGroupDesc);
				hgFileGroupDesc = NULL;
			}
		}
	}
	else
	{
		hr = DV_E_TYMED;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT((hr == S_OK &&
			IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM)) ||
			(FAILED(hr) &&
				(EVAL(pstgmed->tymed == TYMED_NULL) &&
					EVAL(! pstgmed->hGlobal) &&
					EVAL(! pstgmed->pUnkForRelease))));

	DebugExitHRESULT(CConfLink::TransferFileGroupDescriptor, hr);

	return(hr);
}
#endif // 0

HRESULT STDMETHODCALLTYPE CConfLink::TransferFileContents(	PFORMATETC pfmtetc,
															PSTGMEDIUM pstgmed)
{
	HRESULT hr;

	DebugEntry(CConfLink::TransferFileContents);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(IS_VALID_WRITE_PTR(pstgmed, STGMEDIUM));

	ASSERT(pfmtetc->dwAspect == DVASPECT_CONTENT);
	ASSERT(! pfmtetc->lindex);

	pstgmed->tymed = TYMED_NULL;
	pstgmed->hGlobal = NULL;
	pstgmed->pUnkForRelease = NULL;

	if (IS_FLAG_SET(pfmtetc->tymed, TYMED_HGLOBAL))
	{
		DWORD dwcbLen;
		HGLOBAL hgFileContents;

		hr = E_OUTOFMEMORY;

		dwcbLen = GetFileContentsSize();

		hgFileContents = GlobalAlloc(0, dwcbLen);

		if (hgFileContents)
		{
			PSTR pszFileContents;

			pszFileContents = (PSTR)GlobalLock(hgFileContents);

			if (EVAL(pszFileContents))
			{
				PSTR psz = pszFileContents;

				// Copy section.

				CopyMemory(psz, s_cszSectionBefore, sizeof(s_cszSectionBefore) - 1);
				psz += sizeof(s_cszSectionBefore) - 1;

				CopyMemory(psz, s_cszConferenceShortcutSection, sizeof(s_cszConferenceShortcutSection) - 1);
				psz += sizeof(s_cszConferenceShortcutSection) - 1;

				CopyMemory(psz, s_cszSectionAfter, sizeof(s_cszSectionAfter) - 1);
				psz += sizeof(s_cszSectionAfter) - 1;

				if (m_pszName)
				{
					// Copy Name.

					CopyMemory(psz, g_cszCRLF, sizeof(g_cszCRLF) - 1);
					psz += sizeof(g_cszCRLF) - 1;

					CopyMemory(psz, s_cszNameKey, sizeof(s_cszNameKey) - 1);
					psz += sizeof(s_cszNameKey) - 1;

					CopyMemory(psz, s_cszKeyValueSep, sizeof(s_cszKeyValueSep) - 1);
					psz += sizeof(s_cszKeyValueSep) - 1;

					CopyMemory(psz, m_pszName, lstrlen(m_pszName));
					psz += lstrlen(m_pszName);
				}

				if (m_pszAddress)
				{
					// Copy Name.

					CopyMemory(psz, g_cszCRLF, sizeof(g_cszCRLF) - 1);
					psz += sizeof(g_cszCRLF) - 1;

					CopyMemory(psz, s_cszAddressKey, sizeof(s_cszAddressKey) - 1);
					psz += sizeof(s_cszAddressKey) - 1;

					CopyMemory(psz, s_cszKeyValueSep, sizeof(s_cszKeyValueSep) - 1);
					psz += sizeof(s_cszKeyValueSep) - 1;

					CopyMemory(psz, m_pszAddress, lstrlen(m_pszAddress));
					psz += lstrlen(m_pszAddress);
				}

				// Copy Transport.
				CopyMemory(psz, g_cszCRLF, sizeof(g_cszCRLF) - 1);
				psz += sizeof(g_cszCRLF) - 1;

				CopyMemory(psz, s_cszTransportKey, sizeof(s_cszTransportKey) - 1);
				psz += sizeof(s_cszTransportKey) - 1;

				CopyMemory(psz, s_cszKeyValueSep, sizeof(s_cszKeyValueSep) - 1);
				psz += sizeof(s_cszKeyValueSep) - 1;

				TCHAR szBuf[s_ucMaxTransportLen];
				wsprintf(szBuf, "%10u", m_dwTransport);
				CopyMemory(psz, szBuf, lstrlen(szBuf));
				psz += lstrlen(szBuf);

				
				
				ASSERT(psz == pszFileContents + dwcbLen);

				pstgmed->tymed = TYMED_HGLOBAL;
				pstgmed->hGlobal = hgFileContents;
				ASSERT(! pstgmed->pUnkForRelease);

				hr = S_OK;

				GlobalUnlock(hgFileContents);
			}

			if (hr != S_OK)
			{
				GlobalFree(hgFileContents);
				hgFileContents = NULL;
			}
		}
	}
	else
	{
		hr = DV_E_TYMED;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT((hr == S_OK &&
			IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM)) ||
			(FAILED(hr) &&
				(EVAL(pstgmed->tymed == TYMED_NULL) &&
					EVAL(! pstgmed->hGlobal) &&
					EVAL(! pstgmed->pUnkForRelease))));

	DebugExitHRESULT(CConfLink::TransferFileContents, hr);

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\clprpsht.cpp ===
#include "precomp.h"
#include <shellapi.h>
#include "clCnfLnk.hpp"
#include "resource.h"

#if 0

typedef struct _clps
{
   PROPSHEETPAGE psp;
   PCConfLink pconflink;
   char rgchIconFile[MAX_PATH_LEN];
}
CLPS;
DECLARE_STANDARD_TYPES(CLPS);

UINT CALLBACK CLPSCallback(HWND hwnd, UINT uMsg,
										LPPROPSHEETPAGE ppsp)
{
	UINT uResult = TRUE;
	PCLPS pclps = (PCLPS)ppsp;

	// uMsg may be any value.

	ASSERT(! hwnd ||
	      IS_VALID_HANDLE(hwnd, WND));
	ASSERT(IS_VALID_STRUCT_PTR((PCCLPS)ppsp, CCLPS));

	switch (uMsg)
	{
		case PSPCB_CREATE:
			TRACE_OUT(("CLPSCallback(): Received PSPCB_CREATE."));
			break;

		case PSPCB_RELEASE:
			TRACE_OUT(("CLPSCallback(): Received PSPCB_RELEASE."));
						pclps->pconflink->Release();
			break;

		default:
			TRACE_OUT(("CLPSCallback(): Unhandled message %u.",
						uMsg));
			break;
	}

	return(uResult);
}

void SetCLPSFileNameAndIcon(HWND hdlg)
{
	HRESULT hr;
	PCConfLink pconflink;
	char rgchFile[MAX_PATH_LEN];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pconflink = ((PCLPS)GetWindowLong(hdlg, DWL_USER))->pconflink;
	ASSERT(IS_VALID_STRUCT_PTR(pconflink, CCConfLink));

	hr = pconflink->GetCurFile(rgchFile, sizeof(rgchFile));

	if (hr == S_OK)
	{
		SHFILEINFO shfi;
		DWORD dwResult;

		dwResult = SHGetFileInfo(	rgchFile, 0, &shfi, sizeof(shfi),
									(SHGFI_DISPLAYNAME | SHGFI_ICON));

		if (dwResult)
		{
			PSTR pszFileName;

			pszFileName = (PSTR)ExtractFileName(shfi.szDisplayName);

			EVAL(SetDlgItemText(hdlg, IDC_NAME, pszFileName));

			TRACE_OUT(("SetCLPSFileNameAndIcon(): Set property sheet file name to \"%s\".",
			        pszFileName));

			ASSERT(IS_VALID_HANDLE(shfi.hIcon, ICON));

			HICON hIconOld = (HICON) SendDlgItemMessage(hdlg, 
														IDC_FILEICON,
														STM_SETICON,
														(WPARAM) shfi.hIcon,
														0);
			if (NULL != hIconOld)
			{
				DestroyIcon(hIconOld);
			}
		}
		else
		{
			hr = E_FAIL;

			TRACE_OUT(	("SetCLPSFileNameAndIcon(): SHGetFileInfo() failed, returning %lu.",
						dwResult));
		}
	}
	else
	{
		TRACE_OUT(("SetCLPSFileNameAndIcon(): GetCurFile() failed, returning %s.",
					GetHRESULTString(hr)));
	}

	if (hr != S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDC_NAME, EMPTY_STRING));
	}

	return;
}


void SetCLPSName(HWND hdlg)
{
	PCConfLink pconflink;
	HRESULT hr;
	PSTR pszName;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pconflink = ((PCLPS)GetWindowLong(hdlg, DWL_USER))->pconflink;
	ASSERT(IS_VALID_STRUCT_PTR(pconflink, CCConfLink));

	hr = pconflink->GetName(&pszName);

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDC_CONFNAME, pszName));

		TRACE_OUT(("SetCLPSURL(): Set property sheet Name to \"%s\".",
					pszName));

		PIMalloc pMalloc = NULL;
		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			pMalloc->Free(pszName);
			pMalloc->Release();
			pMalloc = NULL;
			
			pszName = NULL;
		}
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDC_CONFNAME, EMPTY_STRING));
	}

	return;
}

void SetCLPSAddress(HWND hdlg)
{
	PCConfLink pconflink;
	HRESULT hr;
	PSTR pszAddress;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pconflink = ((PCLPS)GetWindowLong(hdlg, DWL_USER))->pconflink;
	ASSERT(IS_VALID_STRUCT_PTR(pconflink, CCConfLink));

	hr = pconflink->GetAddress(&pszAddress);

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDC_CONFADDR, pszAddress));

		TRACE_OUT(("SetCLPSURL(): Set property sheet Address to \"%s\".",
					pszAddress));

		PIMalloc pMalloc = NULL;
		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			pMalloc->Free(pszAddress);
			pMalloc->Release();
			pMalloc = NULL;
			
			pszAddress = NULL;
		}
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDC_CONFADDR, EMPTY_STRING));
	}

	return;
}

BOOL CLPS_InitDialog(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
	PCConfLink pconflink;

	// wparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));
	ASSERT(IS_VALID_STRUCT_PTR((PCCLPS)lparam, CCLPS));

	SetWindowLong(hdlg, DWL_USER, lparam);

	pconflink = ((PCLPS)lparam)->pconflink;
	ASSERT(IS_VALID_STRUCT_PTR(pconflink, CCConfLink));

	// Initialize control contents.

	SetCLPSFileNameAndIcon(hdlg);
	SetCLPSName(hdlg);
	SetCLPSAddress(hdlg);

	return(TRUE);
}


BOOL CLPS_Destroy(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
	PCConfLink pconflink;

	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pconflink = ((PCLPS)GetWindowLong(hdlg, DWL_USER))->pconflink;
	ASSERT(IS_VALID_STRUCT_PTR(pconflink, CConfLink));

	SetWindowLong(hdlg, DWL_USER, NULL);

	return(TRUE);
}

INT_PTR CALLBACK CLPS_DlgProc(HWND hdlg, UINT uMsg, WPARAM wparam,
										LPARAM lparam)
{
	BOOL bMsgHandled = FALSE;

	// uMsg may be any value.
	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	switch (uMsg)
	{
		case WM_INITDIALOG:
			bMsgHandled = CLPS_InitDialog(hdlg, wparam, lparam);
			break;

		case WM_DESTROY:
			bMsgHandled = CLPS_Destroy(hdlg, wparam, lparam);
			break;

#if 0
		case WM_COMMAND:
			bMsgHandled = CLPS_Command(hdlg, wparam, lparam);
			break;

		case WM_NOTIFY:
			bMsgHandled = CLPS_Notify(hdlg, wparam, lparam);
			break;
#endif // 0

#ifdef CLPSHELP
		case WM_HELP:
			WinHelp((HWND)(((LPHELPINFO)lparam)->hItemHandle),
					ISPS_GetHelpFileFromControl((HWND)(((LPHELPINFO)lparam)->hItemHandle)),
					HELP_WM_HELP, (DWORD)(PVOID)s_rgdwHelpIDs);
			bMsgHandled = TRUE;
			break;

		case WM_CONTEXTMENU:
		{
			POINT pt;

			LPARAM_TO_POINT(lparam, pt);
			EVAL(ScreenToClient(hdlg, &pt));

			WinHelp((HWND)wparam,
					ISPS_GetHelpFileFromControl(ChildWindowFromPoint(hdlg, pt)),
					HELP_CONTEXTMENU, (DWORD)(PVOID)s_rgdwHelpIDs);
			bMsgHandled = TRUE;
			break;
		}
#endif // CLSPSHELP

		default:
			break;
	}

	return(bMsgHandled);
}

HRESULT AddCLPS(	PCConfLink pconflink,
								LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lparam)
{
	HRESULT hr;
	CLPS clps;
	HPROPSHEETPAGE hpsp;

	// lparam may be any value.

	ASSERT(IS_VALID_STRUCT_PTR(pconflink, CConfLink));
	ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));

	ZeroMemory(&clps, sizeof(clps));

	clps.psp.dwSize = sizeof(clps);
	clps.psp.dwFlags = (PSP_DEFAULT | PSP_USECALLBACK);
	clps.psp.hInstance = g_hInst;
	clps.psp.pszTemplate = MAKEINTRESOURCE(IDD_CONFLINKPROP);
	clps.psp.pfnDlgProc = CLPS_DlgProc;
	clps.psp.pfnCallback = &CLPSCallback;

	clps.pconflink = pconflink;

	ASSERT(IS_VALID_STRUCT_PTR(&clps, CCLPS));

	hpsp = CreatePropertySheetPage(&(clps.psp));

	if (hpsp)
	{
		if ((*pfnAddPage)(hpsp, lparam))
		{
			pconflink->AddRef();
			hr = S_OK;
			TRACE_OUT(("AddCLPS(): Added Conference Link property sheet."));
		}
		else
		{
			DestroyPropertySheetPage(hpsp);

			hr = E_FAIL;
			WARNING_OUT(("AddCLPS(): Callback to add property sheet failed."));
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	return(hr);
}
#endif // 0

HRESULT STDMETHODCALLTYPE CConfLink::Initialize(LPCITEMIDLIST pcidlFolder,
												LPDATAOBJECT pido,
												HKEY hkeyProgID)
{
	HRESULT hr;
	FORMATETC fmtetc = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	STGMEDIUM stgmed;

	DebugEntry(CConfLink::Initialize);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	!pcidlFolder ||
			IS_VALID_STRUCT_PTR(pcidlFolder, const ITEMIDLIST));
	ASSERT(IS_VALID_INTERFACE_PTR(pido, IDataObject));
	ASSERT(IS_VALID_HANDLE(hkeyProgID, KEY));

	hr = pido->GetData(&fmtetc, &stgmed);

	if (hr == S_OK)
	{
		UINT ucbPathLen;
		PSTR pszFile;

		// (+ 1) for null terminator.

		ucbPathLen = DragQueryFile((HDROP)(stgmed.hGlobal), 0, NULL, 0) + 1;
		ASSERT(ucbPathLen > 0);

		pszFile = new(char[ucbPathLen]);

		if (pszFile)
		{
			EVAL(DragQueryFile((HDROP)(stgmed.hGlobal), 0, pszFile, ucbPathLen) == ucbPathLen - 1);
			ASSERT(IS_VALID_STRING_PTR(pszFile, STR));
			ASSERT((UINT)lstrlen(pszFile) == ucbPathLen - 1);

			hr = LoadFromFile(pszFile, TRUE);

			delete [] pszFile;
			pszFile = NULL;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

		EVAL(MyReleaseStgMedium(&stgmed) == S_OK);
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::Initialize, hr);

	return(hr);
}

#if 0

HRESULT STDMETHODCALLTYPE CConfLink::AddPages(	LPFNADDPROPSHEETPAGE pfnAddPage,
												LPARAM lparam)
{
	HRESULT hr;

	DebugEntry(CConfLink::AddPages);

	// lparam may be any value.

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));

	hr = AddCLPS(this, pfnAddPage, lparam);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::AddPages, hr);

	return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::ReplacePage(	UINT uPageID,
													LPFNADDPROPSHEETPAGE pfnReplaceWith,
													LPARAM lparam)
{
	HRESULT hr;

	DebugEntry(CConfLink::ReplacePage);

	// lparam may be any value.
	// uPageID may be any value.

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_CODE_PTR(pfnReplaceWith, LPFNADDPROPSHEETPAGE));

	hr = E_NOTIMPL;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::ReplacePage, hr);

	return(hr);
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\dlginfo.cpp ===
// File: dlginfo.cpp

#include "precomp.h"
#include <windowsx.h>
#include "resource.h"
#include "help_ids.h"
#include "nmhelp.h"

#include "mrulist2.h"

#include "dlginfo.h"
#include "nmsysinfo.h"

extern HINSTANCE g_hInst;

const int MRU_MAX_ENTRIES = 15; // This MUST be the same as the constant in ui\conf\mrulist.h

const int CCHMAXSZ =            256;   // Maximum generic string length
const int CCHMAXSZ_EMAIL =      128;   // Maximum length of an email name
const int CCHMAXSZ_FIRSTNAME =  128;   // Maximum length of a first name
const int CCHMAXSZ_LASTNAME =   128;   // Maximum length of a last name
const int CCHMAXSZ_NAME =       256;   // Maximum user name, displayed (combined first+last name)
const int CCHMAXSZ_LOCATION =   128;   // Maximum length of a Location
const int CCHMAXSZ_SERVER =     128;   // Maximum length of an address

///////////////////////////////////////////////////////////////////////////
// Local Data

static const DWSTR _rgMruServer[] = {
	{1, DIR_MRU_KEY},
	{MRUTYPE_SZ, TEXT("Name")},
};

static const DWORD _mpIdHelpDlgInfo[] = {
	IDG_UI_MYINFO,        IDH_MYINFO_MYINFO,
	IDE_UI_FIRSTNAME,     IDH_MYINFO_FIRSTNAME,
	IDE_UI_LASTNAME,      IDH_MYINFO_LASTNAME,
	IDE_UI_EMAIL,         IDH_MYINFO_EMAIL,
	IDE_UI_LOCATION,      IDH_MYINFO_LOCATION,
	IDG_UI_DIRECTORY,     IDH_MYINFO_ULS_SERVER,
	IDE_UI_DIRECTORY,     IDH_MYINFO_ULS_SERVER,
	0, 0   // terminator
};


// Local functions
VOID FillServerComboBox(HWND hwndCombo);
BOOL FLegalEmailName(HWND hdlg, UINT id);
BOOL FLegalEmailSz(PTSTR pszName);
BOOL FLoadString(UINT id, LPTSTR lpsz, UINT cch);
BOOL FGetDefaultServer(LPTSTR pszServer, UINT cchMax);
UINT GetDlgItemTextTrimmed(HWND hdlg, int id, PTCHAR psz, int cchMax);
BOOL FEmptyDlgItem(HWND hdlg, UINT id);
VOID CombineNames(LPTSTR pszResult, int cchResult, LPCTSTR pcszFirst, LPCTSTR pcszLast);

BOOL FGetPropertySz(NM_SYSPROP nmProp, LPTSTR psz, int cchMax);
BOOL FSetPropertySz(NM_SYSPROP nmProp, LPCTSTR pcsz);
CMRUList2 * GetMruListServer(void);


/*  C  D L G  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: CDlgInfo

-------------------------------------------------------------------------*/
CDlgInfo::CDlgInfo():
	m_hwnd(NULL)
{
}

CDlgInfo::~CDlgInfo(void)
{
}

/*  D O  M O D A L  */
/*-------------------------------------------------------------------------
    %%Function: DoModal

-------------------------------------------------------------------------*/
INT_PTR CDlgInfo::DoModal(HWND hwndParent)
{
	return DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_USERINFO),
						hwndParent, CDlgInfo::DlgProc, (LPARAM) this);
}

/*  I N I T  C T R L  */
/*-------------------------------------------------------------------------
    %%Function: InitCtrl

-------------------------------------------------------------------------*/
VOID CDlgInfo::InitCtrl(NM_SYSPROP nmProp, HWND hwnd, int cchMax)
{
	::SendMessage(hwnd, WM_SETFONT, (WPARAM)(HFONT)::GetStockObject(DEFAULT_GUI_FONT), 0);
	Edit_LimitText(hwnd, cchMax);

	TCHAR sz[MAX_PATH];
	if (!FGetPropertySz(nmProp, sz, CCHMAX(sz)))
		return;

	::SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM) sz);
}

/*  F  S E T  P R O P E R T Y  */
/*-------------------------------------------------------------------------
    %%Function: FSetProperty

-------------------------------------------------------------------------*/
BOOL CDlgInfo::FSetProperty(NM_SYSPROP nmProp, int id)
{
	TCHAR sz[MAX_PATH];
	if (0 == GetDlgItemTextTrimmed(m_hwnd, id, sz, CCHMAX(sz)))
		return FALSE;

	return FSetPropertySz(nmProp, sz);
}


/*  O N  I N I T  D I A L O G  */
/*-------------------------------------------------------------------------
    %%Function: OnInitDialog

-------------------------------------------------------------------------*/
VOID CDlgInfo::OnInitDialog(void)
{
	InitCtrl(NM_SYSPROP_FIRST_NAME, GetDlgItem(m_hwnd, IDE_UI_FIRSTNAME), CCHMAXSZ_FIRSTNAME-1);
	InitCtrl(NM_SYSPROP_LAST_NAME,  GetDlgItem(m_hwnd, IDE_UI_LASTNAME), CCHMAXSZ_LASTNAME-1);
	InitCtrl(NM_SYSPROP_EMAIL_NAME, GetDlgItem(m_hwnd, IDE_UI_EMAIL), CCHMAXSZ_EMAIL-1);
	InitCtrl(NM_SYSPROP_USER_CITY, GetDlgItem(m_hwnd, IDE_UI_LOCATION), CCHMAXSZ_LOCATION-1);

	m_hwndCombo = GetDlgItem(m_hwnd, IDE_UI_DIRECTORY);
	InitCtrl(NM_SYSPROP_SERVER_NAME, m_hwndCombo, CCHMAXSZ_SERVER-1);
	FillServerComboBox(m_hwndCombo);
	ComboBox_SetCurSel( m_hwndCombo, 0 );

	ValidateData();
}


/*  D L G  P R O C  */
/*-------------------------------------------------------------------------
    %%Function: DlgProc

-------------------------------------------------------------------------*/
INT_PTR CALLBACK CDlgInfo::DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG:
	{
		ASSERT(NULL != lParam);
		::SetWindowLongPtr(hdlg, DWLP_USER, lParam);

		CDlgInfo * pDlg = (CDlgInfo*) lParam;
		pDlg->m_hwnd = hdlg;
		pDlg->OnInitDialog();
		return TRUE; // default focus is ok
	}

	case WM_COMMAND:
	{
		CDlgInfo * pDlg = (CDlgInfo*) GetWindowLongPtr(hdlg, DWLP_USER);
		if (NULL != pDlg)
		{
			pDlg->OnCommand(wParam, lParam);
		}
		break;
	}

	case WM_HELP:
		DoHelp(lParam, _mpIdHelpDlgInfo);
		break;
	case WM_CONTEXTMENU:
		DoHelpWhatsThis(wParam, _mpIdHelpDlgInfo);
		break;

	default:
		break;
	}

	return FALSE;
}


/*  O N  C O M M A N D  */
/*-------------------------------------------------------------------------
    %%Function: OnCommand

-------------------------------------------------------------------------*/
BOOL CDlgInfo::OnCommand(WPARAM wParam, LPARAM lParam)
{
	ASSERT(NULL != m_hwnd);

	WORD wCmd = GET_WM_COMMAND_ID(wParam, lParam);
	switch (wCmd)
	{
	case IDE_UI_FIRSTNAME:
	case IDE_UI_LASTNAME:
	case IDE_UI_EMAIL:
	{
		if (GET_WM_COMMAND_CMD(wParam,lParam) == EN_CHANGE)
		{
			ValidateData();
		}
		break;
	}
	case IDE_UI_DIRECTORY:
	{
		switch (GET_WM_COMMAND_CMD(wParam,lParam))
			{
		case CBN_SELCHANGE:
			// The data isn't available yet
			PostMessage(m_hwnd, WM_COMMAND, MAKELONG(IDE_UI_DIRECTORY, CBN_EDITCHANGE), lParam);
			break;
		case CBN_EDITCHANGE:
			ValidateData();
		default:
			break;
			}
		break;
	}

	case IDOK:
	{
		if (FSaveData())
		{
			::EndDialog(m_hwnd, wCmd);
		}
		return TRUE;
	}

	case IDCANCEL:
	{
		::EndDialog(m_hwnd, wCmd);
		return TRUE;
	}

	default:
		break;
	}

	return FALSE;
}

VOID CDlgInfo::ValidateData(void)
{
	BOOL fOk = !FEmptyDlgItem(m_hwnd, IDE_UI_FIRSTNAME) &&
	           !FEmptyDlgItem(m_hwnd, IDE_UI_LASTNAME) &&
	           !FEmptyDlgItem(m_hwnd, IDE_UI_EMAIL);

	if (fOk)
	{
		TCHAR sz[CCHMAXSZ_EMAIL];
		GetDlgItemTextTrimmed(m_hwnd, IDE_UI_EMAIL, sz, CCHMAX(sz));
		fOk = FLegalEmailSz(sz);
	}

	if (fOk)
	{
		TCHAR sz[CCHMAXSZ_SERVER];
		fOk = (0 != ComboBox_GetText(m_hwndCombo, sz, CCHMAX(sz)));
		if (fOk)
		{
			fOk = 0 != TrimSz(sz);
		}
	}

	Button_Enable(GetDlgItem(m_hwnd, IDOK), fOk);
}



/*  F  S A V E  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: FSaveData

-------------------------------------------------------------------------*/
BOOL CDlgInfo::FSaveData(void)
{
	if (!FSetProperty(NM_SYSPROP_FIRST_NAME,  IDE_UI_FIRSTNAME) ||
		!FSetProperty(NM_SYSPROP_LAST_NAME,   IDE_UI_LASTNAME) ||
		!FSetProperty(NM_SYSPROP_EMAIL_NAME,  IDE_UI_EMAIL) ||
		!FSetProperty(NM_SYSPROP_SERVER_NAME, IDE_UI_DIRECTORY)
	   )
	{
		return FALSE;
	}

	// The city name (can be blank)
	TCHAR sz[CCHMAXSZ];
	GetDlgItemTextTrimmed(m_hwnd, IDE_UI_LOCATION, sz, CCHMAX(sz));
	FSetPropertySz(NM_SYSPROP_USER_CITY, sz);

	// Full Name = First + Last
	TCHAR szFirst[CCHMAXSZ_FIRSTNAME];
	GetDlgItemTextTrimmed(m_hwnd, IDE_UI_FIRSTNAME, szFirst, CCHMAX(szFirst));

	TCHAR szLast[CCHMAXSZ_LASTNAME];
	GetDlgItemTextTrimmed(m_hwnd, IDE_UI_LASTNAME, szLast, CCHMAX(szLast));

	CombineNames(sz, CCHMAX(sz), szFirst, szLast);
	if (!FSetPropertySz(NM_SYSPROP_USER_NAME, sz))
		return FALSE;

	// Resolve Name = server / email
	UINT cch = GetDlgItemTextTrimmed(m_hwnd, IDE_UI_DIRECTORY, sz, CCHMAX(sz));
	GetDlgItemTextTrimmed(m_hwnd, IDE_UI_EMAIL, &sz[cch], CCHMAX(sz)-cch);
	return FSetPropertySz(NM_SYSPROP_RESOLVE_NAME, sz);
}


///////////////////////////////////////////////////////////////////////////

/*  C O M B I N E  N A M E S  */
/*-------------------------------------------------------------------------
    %%Function: CombineNames

	Combine the two names into one string.
	The result is a "First Last" (or Intl'd "Last First") string
-------------------------------------------------------------------------*/
VOID CombineNames(LPTSTR pszResult, int cchResult, LPCTSTR pcszFirst, LPCTSTR pcszLast)
{
	ASSERT(pszResult);
	TCHAR szFmt[32]; // A small value: String is "%1 %2" or "%2 %1"
	TCHAR sz[CCHMAXSZ_NAME];
	LPCTSTR argw[2];

	argw[0] = pcszFirst;
	argw[1] = pcszLast;

	*pszResult = _T('\0');

	if (!FLoadString(IDS_NAME_ORDER, szFmt, CCHMAX(szFmt)))
		return;

	if (0 == FormatMessage(FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_STRING,
			szFmt, 0, 0, sz, CCHMAX(sz), (va_list *)argw ))
		return;

	// REVIEW: Use STRCPYN or make this a utility function
	lstrcpyn(pszResult, sz, cchResult);

#ifndef _UNICODE
	// lstrcpyn() can clip a DBCS character in half at the end of the string
	// we need to walk the string with ::CharNext() and replace the last byte
	// with a NULL if the last byte is half of a DBCS char.
	PTSTR pszSource = sz;
	while (*pszSource && (pszSource - sz < cchResult))
	{
		PTSTR pszPrev = pszSource;
		pszSource = ::CharNext(pszPrev);
		// If we've reached the first character that didn't get copied into
		// the destination buffer, and the previous character was a double
		// byte character...
		if (((pszSource - sz) == cchResult) && ::IsDBCSLeadByte(*pszPrev))
		{
			// Replace the destination buffer's last character with '\0'
			// NOTE: pszResult[cchResult - 1] is '\0' thanks to lstrcpyn()
			pszResult[cchResult - 2] = _T('\0');
			break;
		}
	}
#endif // ! _UNICODE
}



/*  F  L E G A L  E M A I L  S Z  */
/*-------------------------------------------------------------------------
    %%Function: FLegalEmailSz

    A legal email name contains only ANSI characters.
	"a-z, A-Z, numbers 0-9 and some common symbols"
	It cannot include extended characters or < > ( ) /
-------------------------------------------------------------------------*/
BOOL FLegalEmailSz(PTSTR pszName)
{
    if (IS_EMPTY_STRING(pszName))
    	return FALSE;

    for ( ; ; )
    {
		UINT ch = (UINT) ((*pszName++) & 0x00FF);
		if (0 == ch)
			break;

		switch (ch)
			{
		default:
			if ((ch > (UINT) _T(' ')) && (ch <= (UINT) _T('~')) )
				break;
		// else fall thru to error code
		case '(': case ')':
		case '<': case '>':
		case '[': case ']':
		case '/': case '\\':
		case ':': case ';':
		case '+':
		case '=':
		case ',':
		case '\"':
			WARNING_OUT(("FLegalEmailSz: Invalid character '%s' (0x%02X)", &ch, ch));
			return FALSE;
			}
	}

	return TRUE;
}


/*  F  L E G A L  E M A I L  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: FLegalEmailName

-------------------------------------------------------------------------*/
BOOL FLegalEmailName(HWND hdlg, UINT id)
{
	TCHAR sz[MAX_PATH];
	
	GetDlgItemTextTrimmed(hdlg, id, sz, CCHMAX(sz));
	return FLegalEmailSz(sz);
}

#include "rend.h"
TCHAR	s_DomainDirectory[ MAX_PATH ]	= TEXT( "" );

HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr);

//--------------------------------------------------------------------------//
//	CDirectoryManager::get_DomainDirectory.									//
//--------------------------------------------------------------------------//
const TCHAR * const
get_DomainDirectory(void)
{
	static bool	bAccessAttempted	= false;	//	only read this info once... if it fails once assume it's not available and don't retry until restarted...

	if( (!bAccessAttempted) && s_DomainDirectory[ 0 ] == '\0' )
	{
		bAccessAttempted = true;

		//	Try to obtain the configured directory for this domain...
		ITRendezvous *	pRendezvous;
		HRESULT			hrResult;

		hrResult = ::CoCreateInstance( CLSID_Rendezvous, NULL, CLSCTX_ALL, IID_ITRendezvous, (void **) &pRendezvous );

		if( (hrResult == S_OK) && (pRendezvous != NULL) )
		{
			IEnumDirectory *	pEnumDirectory;

			hrResult = pRendezvous->EnumerateDefaultDirectories( &pEnumDirectory );

			if( (hrResult == S_OK) && (pEnumDirectory != NULL) )
			{
				ITDirectory *	pDirectory;
				bool			bFoundILS	= false;

				do
				{
					hrResult = pEnumDirectory->Next( 1, &pDirectory, NULL );

					if( (hrResult == S_OK) && (pDirectory != NULL) )
					{
						LPWSTR *		ppServers;
						DIRECTORY_TYPE	type;

						if( pDirectory->get_DirectoryType( &type ) == S_OK )
						{
							if( type == DT_ILS )	//	Found an ILS server configured on the DS... retrieve the name and port...
							{
								bFoundILS = true;
	
								BSTR	pName;
	
								if( pDirectory->get_DisplayName( &pName ) == S_OK )
								{
                                    LPTSTR  szName;
                                    if (SUCCEEDED(BSTR_to_LPTSTR (&szName, pName)))
                                    {    
                                        lstrcpy( s_DomainDirectory, szName );
                                        delete  (szName);
                                    }
                                    SysFreeString( pName );
								}

								ITILSConfig *	pITILSConfig;
	
								hrResult = pDirectory->QueryInterface( IID_ITILSConfig, (void **) &pITILSConfig );

								if( (hrResult == S_OK) && (pITILSConfig != NULL) )
								{
									long	lPort;
		
									if( pITILSConfig->get_Port( &lPort ) == S_OK )
									{
										TCHAR	pszPort[ 32 ];

										wsprintf( pszPort, TEXT( ":%d" ), lPort );
										lstrcat( s_DomainDirectory, pszPort );
									}
	
									pITILSConfig->Release();
								}
							}
						}

						pDirectory->Release();
					}
				}
				while( (!bFoundILS) && (hrResult == S_OK) && (pDirectory != NULL) );

				pEnumDirectory->Release();
			}

			pRendezvous->Release();
		}
	}

	return( (s_DomainDirectory[ 0 ] != '\0')? s_DomainDirectory: NULL );

}	//	End of CDirectoryManager::get_DomainDirectory.



/*  F I L L  S E R V E R  C O M B O  B O X  */
/*-------------------------------------------------------------------------
    %%Function: FillServerComboBox

-------------------------------------------------------------------------*/
VOID FillServerComboBox(HWND hwnd)
{
	CMRUList2 * pMru = GetMruListServer();
	if (NULL == pMru)
		return;

    get_DomainDirectory();
    if(s_DomainDirectory[0]!='\0')
    {
        ComboBox_AddString(hwnd, s_DomainDirectory);
    }


	int cServers = pMru->GetNumEntries();
	for (int i = 0; i < cServers; i++)
	{
		int iPos = ComboBox_AddString(hwnd, pMru->PszEntry(i));
		if (iPos < 0)
			break;
	}


	delete pMru;
}

inline VOID DwToSz(DWORD dw, LPTSTR psz)
{
	wsprintf(psz, TEXT("%d"), dw);
}

BOOL FGetPropertySz(NM_SYSPROP nmProp, LPTSTR psz, int cchMax)
{
	HKEY   hkey;
	LPTSTR pszSubKey;
	LPTSTR pszValue;
	bool   fString;

	LONG lVal;

	if (!CNmSysInfoObj::GetKeyDataForProp(nmProp, &hkey, &pszSubKey, &pszValue, &fString))
	{
		return FALSE;
	}

	RegEntry re(pszSubKey, hkey);
	if (fString)
	{
		lstrcpyn(psz, re.GetString(pszValue), cchMax);
	}
	else
	{
		lVal = re.GetNumber(pszValue, 0);
		DwToSz(lVal, psz);
		ASSERT(lstrlen(psz) < cchMax);
	}

	return TRUE;
}

BOOL FSetPropertySz(NM_SYSPROP nmProp, LPCTSTR pcsz)
{
	HKEY   hkey;
	LPTSTR pszSubKey;
	LPTSTR pszValue;
	bool   fString;

	if (!CNmSysInfoObj::GetKeyDataForProp(nmProp, &hkey, &pszSubKey, &pszValue, &fString))
	{
		return FALSE;
	}

	RegEntry re(pszSubKey, hkey);
	if (fString)
	{
		return (0 == re.SetValue(pszValue, pcsz));
	}

	DWORD dw = DecimalStringToUINT(pcsz);
	return (0 == re.SetValue(pszValue, dw));
}

CMRUList2 * GetMruListServer(void)
{
	CMRUList2 * pMruList = new CMRUList2(&_rgMruServer[0], MRU_MAX_ENTRIES, TRUE /* fReverse */);
	if (NULL != pMruList)
	{
		TCHAR sz[MAX_PATH];
		if (FGetDefaultServer(sz, CCHMAX(sz)))
		{
			pMruList->AddEntry(sz);

			TCHAR	ldapDirectory[ MAX_PATH ];

			if( FLoadString( IDS_MS_INTERNET_DIRECTORY, ldapDirectory, CCHMAX( ldapDirectory ) ) )
			{
				pMruList->DeleteEntry( ldapDirectory );
			}

			RegEntry	re( CONFERENCING_KEY, HKEY_CURRENT_USER );
			TCHAR *		webViewServer	= re.GetString( REGVAL_WEBDIR_DISPLAY_NAME );

			if( lstrlen( webViewServer ) > 0 )
			{
				pMruList->DeleteEntry( webViewServer );
			}

			pMruList->SetDirty(FALSE);
		}
	}

	return pMruList;
}

///////////////////////////////////////////////////////////////////////////

/*  F  V A L I D  U S E R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: FValidUserInfo

    Return TRUE if all of the necessary user information is available.
-------------------------------------------------------------------------*/
BOOL FValidUserInfo(void)
{
	{	// Fail if not a valid installation directory
		TCHAR sz[MAX_PATH];

		if (!GetInstallDirectory(sz) || !FDirExists(sz))
			return FALSE;
	}


	{	// Validate ULS entries
		RegEntry reUls(ISAPI_KEY "\\" REGKEY_USERDETAILS, HKEY_CURRENT_USER);

		if (FEmptySz(reUls.GetString(REGVAL_ULS_EMAIL_NAME)))
			return FALSE;
			
		if (FEmptySz(reUls.GetString(REGVAL_SERVERNAME)))
			return FALSE;

		if (FEmptySz(reUls.GetString(REGVAL_ULS_RES_NAME)))
			return FALSE;
	}

#if 0
	{	// Check Wizard key
		RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

		// check to see if the wizard has been run in UI mode
		DWORD dwVersion = reConf.GetNumber(REGVAL_WIZARD_VERSION_UI, 0);
		BOOL fForceWizard = (VER_PRODUCTVERSION_DW != dwVersion);
		if (fForceWizard)
		{
			// the wizard has not been run in UI mode, check to see if its been run in NOUI mode
			dwVersion = reConf.GetNumber(REGVAL_WIZARD_VERSION_NOUI, 0);
			fForceWizard = (VER_PRODUCTVERSION_DW != dwVersion);
		}

		if (fForceWizard)
			return FALSE;  // Wizard has never been run
	}
#endif /* 0 */

	// Everything is properly installed and the Wizard will not run
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////

/*  F  L O A D  S T R I N G */
/*----------------------------------------------------------------------------
    %%Function: FLoadString

	Load a resource string.
	Assumes the buffer is valid and can hold the resource.
----------------------------------------------------------------------------*/
BOOL FLoadString(UINT id, LPTSTR lpsz, UINT cch)
{
	ASSERT(NULL != _Module.GetModuleInstance());
	ASSERT(NULL != lpsz);

	if (0 == ::LoadString(g_hInst, id, lpsz, cch))
	{
		ERROR_OUT(("*** Resource %d does not exist", id));
		*lpsz = _T('\0');
		return FALSE;
	}

	return TRUE;
}

/*  F G E T  D E F A U L T  S E R V E R  */
/*-------------------------------------------------------------------------
    %%Function: FGetDefaultServer

-------------------------------------------------------------------------*/
BOOL FGetDefaultServer(LPTSTR pszServer, UINT cchMax)
{
	RegEntry ulsKey(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
	LPTSTR psz = ulsKey.GetString(REGVAL_SERVERNAME);
	if (FEmptySz(psz))
		return FALSE;

	lstrcpyn(pszServer, psz, cchMax);
	return TRUE;
}

/*  G E T  D L G  I T E M  T E X T  T R I M M E D  */
/*-------------------------------------------------------------------------
    %%Function: GetDlgItemTextTrimmed

-------------------------------------------------------------------------*/
UINT GetDlgItemTextTrimmed(HWND hdlg, int id, PTCHAR psz, int cchMax)
{
	UINT cch = GetDlgItemText(hdlg, id, psz, cchMax);
	if (0 != cch)
	{
		cch = TrimSz(psz);
	}

	return cch;
}

/*  F  E M P T Y  D L G  I T E M  */
/*-------------------------------------------------------------------------
    %%Function: FEmptyDlgItem

    Return TRUE if the dialog control is empty
-------------------------------------------------------------------------*/
BOOL FEmptyDlgItem(HWND hdlg, UINT id)
{
	TCHAR sz[MAX_PATH];
	return (0 == GetDlgItemTextTrimmed(hdlg, id, sz, CCHMAX(sz)) );
}



/*  V E R I F Y  U S E R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: VerifyUserInfo

    Return S_OK if the data is valid or S_FALSE if it is not.
-------------------------------------------------------------------------*/
HRESULT WINAPI VerifyUserInfo(HWND hwnd, NM_VUI options)
{
	BOOL fOk = FALSE;
	BOOL fShow = (options & NM_VUI_SHOW) || !FValidUserInfo();
	if (fShow)
	{
		CDlgInfo * pDlg = new CDlgInfo();
		if (NULL == pDlg)
			return E_OUTOFMEMORY;

		fOk = (IDOK == pDlg->DoModal(hwnd));
		delete pDlg;
	}

	if (!FValidUserInfo())
	{
		// The app should not continue with this.
		return S_FALSE;
	}

	return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\launstub.h ===
#ifndef _LAUNSTUB_H_
#define _LAUNSTUB_H_

#include "ulsapi.h"
////////////////////////////////////////////////////////
//
// CULSLaunch_Stub
//

class CULSLaunch_Stub
{
public:

    STDMETHOD  (ParseUlsHttpRespFile) ( PTSTR, ULS_HTTP_RESP * );
    STDMETHOD  (ParseUlsHttpRespBuffer) ( PTSTR, ULONG, ULS_HTTP_RESP * );
    STDMETHOD  (FreeUlsHttpResp) ( ULS_HTTP_RESP * );

private:

    HRESULT  ParseB3HttpRespBuffer ( PTSTR, ULONG, ULS_HTTP_RESP * );
    HRESULT  ParseB4HttpRespBuffer ( PTSTR, ULONG, ULS_HTTP_RESP * );

};


#endif // _LAUNSTUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\launstub.cpp ===
//--------------------------------------------------------------------------
//
// Module Name:  LaunStub.Cpp
//
// Brief Description:
//      This module contains the code that parses HTTP-based
//      response from the ULS server.
//
// Author:  Chu, Lon-Chan (lonchanc)
//
// Copyright (c) 1996 Microsoft Corporation
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include "launstub.h"


PTSTR LocalStrDup ( PTSTR pszToDup )
{
	UINT uLen;
	PTSTR psz = NULL;

	if (pszToDup)
	{
		uLen = lstrlen (pszToDup);
		psz = (PTSTR) new TCHAR[uLen + 1];
		if (psz)
		{
			lstrcpy (psz, pszToDup);
		}
	}

	return psz;
}

ULONG DecStrToInt ( PTSTR psz )
{
    ULONG ul = 0;
    WORD w;

    if (psz)
    {
        while ((w = (WORD) *psz++) != NULL)
        {
            if (TEXT ('0') <= w && w <= TEXT ('9'))
            {
                w -= TEXT ('0');
                ul = ul * 10 + w;
            }
            else
            {
                break;
            }
        }
    }

    return ul;
}


ULONG HexStrToInt ( PTSTR psz )
{
    ULONG ul = 0;
    WORD w;

    if (psz)
    {
        while ((w = (WORD) *psz++) != NULL)
        {
            if (TEXT ('0') <= w && w <= TEXT ('9'))
            {
                w -= TEXT ('0');
            }
            else
            if (TEXT ('a') <= w && w <= TEXT ('f'))
            {
                w -= (TEXT ('a') - 10);
            }
            else
            if (TEXT ('A') <= w && w <= TEXT ('F'))
            {
                w -= (TEXT ('A') - 10);
            }
            else
            {
                break;
            }

            ul = (ul << 4) + w;
        }
    }

    return ul;
}

BOOL IsWhiteSpace ( TCHAR c )
{
    return (c == TEXT (' ') || c == TEXT ('\t') || c == TEXT ('\r') || c == TEXT ('\n'));
}

enum
{
    // beta 3 strings
    ATTR_HR,
    ATTR_PORT,
    ATTR_HA,
    ATTR_HC,
    ATTR_CID,
    ATTR_UID,
    ATTR_URL,
    ATTR_IP,
    ATTR_MT,

    B3ATTR_COUNT
};


static PTSTR g_B3Attr[B3ATTR_COUNT] =
{
    // beta 3 strings
    TEXT ("HR"),
    TEXT ("PORT"),
    TEXT ("HA"),
    TEXT ("HC"),
    TEXT ("CID"),
    TEXT ("UID"),
    TEXT ("URL"),
    TEXT ("IP"),
    TEXT ("MT"),
};


enum
{
    // beta 4 strings
    ATTR_HRESULT,
    ATTR_HCLIENT,
    ATTR_HAPPLICATION,
    ATTR_NAPPS,
    ATTR_IPADDRESS,
    ATTR_PORTNUM,
    ATTR_APPID,
    ATTR_PROTID,
    ATTR_USERID,
    ATTR_MIMETYPE,
    ATTR_APPMIME,
    ATTR_PROTMIME,
    ATTR_QUERYURL,

    B4ATTR_COUNT
};

    
static PTSTR g_B4Attr[B4ATTR_COUNT] =
{
    // beta 4 strings
    TEXT ("hresult"),
    TEXT ("hclient"),
    TEXT ("happlication"),
    TEXT ("napps"),
    TEXT ("ipaddress"),
    TEXT ("portnum"),
    TEXT ("appid"),
    TEXT ("protid"),
    TEXT ("userid"),
    TEXT ("mimetype"),
    TEXT ("appmime"),
    TEXT ("protmime"),
    TEXT ("queryurl"),
};


typedef struct tagULPCMD
{
    PTSTR   pszCmd;
    ULONG   nCmdId;
}
    ULPCMD;


static ULPCMD g_B3Cmd[] =
{
    { TEXT ("ON"),    CLIENT_MESSAGE_ID_LOGON     },
    { TEXT ("OFF"),   CLIENT_MESSAGE_ID_LOGOFF    },
    { TEXT ("KA"),    CLIENT_MESSAGE_ID_KEEPALIVE },
    { TEXT ("RES"),   CLIENT_MESSAGE_ID_RESOLVE   },
};


static ULPCMD g_B4Cmd[] =
{
    { TEXT ("on"),    CLIENT_MESSAGE_ID_LOGON     },
    { TEXT ("off"),   CLIENT_MESSAGE_ID_LOGOFF    },
    { TEXT ("ka"),    CLIENT_MESSAGE_ID_KEEPALIVE },
    { TEXT ("res"),   CLIENT_MESSAGE_ID_RESOLVE   },
};


/*
    @doc    EXTERNAL    ULCLIENT
    @api    HRESULT | CULSLaunch_Stub::ParseUlsHttpRespFile |
            Parses a HTTP-based response from the ULS server.
    @parm   PTSTR | pszUlsFile | A pointer to the HTTP-based response
            file name string.
    @parm   ULS_HTTP_RESP * | pResp | A pointer to the generic 
            HTTP response structure.
    @rdesc  Returns ULS_SUCCESS if this operation succeeds.
    @comm   This method parses the responses from the commands
            defined in the g_B3Cmd array. The attributes this method
            understands are listed in the g_B3Attr array.
*/

STDMETHODIMP CULSLaunch_Stub::ParseUlsHttpRespFile
                ( PTSTR pszUlsFile, ULS_HTTP_RESP *pResp )
{
    HANDLE hf = INVALID_HANDLE_VALUE;
    HRESULT hr;
    PTSTR pszBuf = NULL;
    ULONG cbFileSize;


    // clean up the structure first
    ZeroMemory (pResp, sizeof (ULS_HTTP_RESP));
    pResp->cbSize = sizeof (ULS_HTTP_RESP);

    // open the uls file
    hf = CreateFile (pszUlsFile, GENERIC_READ, FILE_SHARE_READ, NULL,
                     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
                                    FILE_FLAG_SEQUENTIAL_SCAN |
//                                  FILE_FLAG_DELETE_ON_CLOSE, NULL);
                                    0, NULL);
    if (hf == INVALID_HANDLE_VALUE)
    {
        return ULS_E_INVALID_HANDLE;
    }

    // get the size of the uls file
    cbFileSize = GetFileSize (hf, NULL);
    if (! cbFileSize)
    {
        hr = ULS_E_INVALID_HANDLE;
        goto MyExit;
    }

    // round up to align with the paragraph boundary
    cbFileSize = ((cbFileSize + 4) & (~ 0x0F)) + 0x10;

    // allocate a buffer to hold the entire uls file
    pszBuf = (PTSTR) new TCHAR[cbFileSize];
    if (! pszBuf)
    {
        hr = ULS_E_OUTOFMEMORY;
        goto MyExit;
    }

    // read the file in
    if (! ReadFile (hf, pszBuf, cbFileSize, &cbFileSize, NULL))
    {
        hr = ULS_E_IO_ERROR;
        goto MyExit;
    }

    // parse the uls buffer
    hr = ParseUlsHttpRespBuffer (pszBuf, cbFileSize, pResp);
    if (hr != ULS_SUCCESS)
    {
        goto MyExit;
    }

MyExit:

    if (hf != INVALID_HANDLE_VALUE) CloseHandle (hf);

   delete [] pszBuf;

    if (hr != ULS_SUCCESS && pResp)
    {
        FreeUlsHttpResp (pResp);
    }

    return hr;
}


/*
    @doc    EXTERNAL    ULCLIENT
    @api    HRESULT | CULSLaunch_Stub::ParseUlsHttpRespBuffer |
            Parses a HTTP-based response from the ULS server.
    @parm   PTSTR | pszBuf | A pointer to the buffer holding
            the entire HTTP-based response data.
    @parm   ULONG | cbBufSize | The size in byte of the buffer.
    @parm   ULS_HTTP_RESP * | pResp | A pointer to the generic 
            HTTP response structure.
    @rdesc  Returns ULS_SUCCESS if this operation succeeds.
    @comm   This method parses the responses from the commands
            defined in the g_B3Cmd array. The attributes this method
            understands are listed in the g_B3Attr array.
*/

STDMETHODIMP CULSLaunch_Stub::ParseUlsHttpRespBuffer
                    ( PTSTR pszBuf, ULONG cbBufSize, ULS_HTTP_RESP *pResp )
{
    HRESULT hr;

#ifdef SANITY_CHECK
    // sanity check
    if (MyIsBadReadPtr (pszBuf, cbBufSize) ||
        MyIsBadWritePtr (pResp, sizeof (ULS_HTTP_RESP)))
    {
        return ULS_E_INVALID_POINTER;
    }
#endif

    hr = ParseB3HttpRespBuffer (pszBuf, cbBufSize, pResp);

    if (hr == ULS_E_INVALID_FORMAT)
    {
        ZeroMemory (pResp, sizeof (ULS_HTTP_RESP));
        pResp->cbSize = sizeof (ULS_HTTP_RESP);
        hr = ParseB4HttpRespBuffer (pszBuf, cbBufSize, pResp);
    }

    return hr;
}


HRESULT CULSLaunch_Stub::ParseB3HttpRespBuffer // beta 3 implementation
                    ( PTSTR pszBuf, ULONG cbBufSize, ULS_HTTP_RESP *pResp )
{
    PTSTR psz;
    int i;

    // get mime type
    psz = (LPTSTR)_StrChr (pszBuf, TEXT ('<'));
    if (! psz) return ULS_E_INVALID_FORMAT;
    pszBuf = psz + 1;
    psz = (LPTSTR)_StrChr (pszBuf, TEXT ('>'));
    if (! psz) return ULS_E_INVALID_FORMAT;
    *psz = TEXT ('\0');
    lstrcpyn (pResp->szMimeType, pszBuf, MAX_MIME_TYPE_LENGTH);

    // get to the type of response
    pszBuf = psz + 1;
    psz = (LPTSTR)_StrChr (pszBuf, TEXT ('<'));
    if (! psz) return ULS_E_INVALID_FORMAT;
    pszBuf = psz + 1;
    psz = (LPTSTR)_StrChr (pszBuf, TEXT ('['));
    if (! psz) return ULS_E_INVALID_FORMAT;
    pszBuf = psz + 1;
    psz = (LPTSTR)_StrChr (pszBuf, TEXT (']'));
    if (! psz) return ULS_E_INVALID_FORMAT;
    *psz = TEXT ('\0');
    pResp->nCmdId = (ULONG) -1;
    for (i = 0; i < sizeof (g_B3Cmd) / sizeof (g_B3Cmd[0]); i++)
    {
        if (! lstrcmpi (pszBuf, g_B3Cmd[i].pszCmd))
        {
            pResp->nCmdId = g_B3Cmd[i].nCmdId;
            break;
        }
    }
    if (pResp->nCmdId == (ULONG) -1) return ULS_E_INVALID_FORMAT;

    // skip any white space
    for (pszBuf = psz + 1; *pszBuf; pszBuf++) { if (! IsWhiteSpace (*pszBuf)) break; }

    // main loop
    while (*pszBuf && *pszBuf != TEXT ('>'))
    {
        // locate the equal sign
        psz = (LPTSTR)_StrChr (pszBuf, TEXT ('='));
        if (! psz) return ULS_E_INVALID_FORMAT;
        *psz = TEXT ('\0');

        // search for attribute
        for (i = 0; i < sizeof (g_B3Attr) / sizeof (g_B3Attr[0]); i++)
        {
            if (! lstrcmpi (pszBuf, g_B3Attr[i]))
            {
                break;
            }
        }
        if (i >= sizeof (g_B3Attr) / sizeof (g_B3Attr[0])) return ULS_E_INVALID_FORMAT;

        // locate the attribute value
        for (pszBuf = psz + 1; *pszBuf; pszBuf++) { if (! IsWhiteSpace (*pszBuf)) break; }
        for (psz = pszBuf + 1; *psz; psz++) { if (IsWhiteSpace (*psz)) break; }
        *psz = TEXT ('\0');
        // now the attribute value is a null-terminated string pointed by pszBuf

        // parse the attribute value
        switch (i)
        {
        case ATTR_HR:
            pResp->hr = HexStrToInt (pszBuf);
            break;

        case ATTR_PORT:
            pResp->nPort = DecStrToInt (pszBuf);
            break;

        case ATTR_HA:
            pResp->dwAppSession = HexStrToInt (pszBuf);
            break;

        case ATTR_HC:
            pResp->dwClientSession = HexStrToInt (pszBuf);
            break;

        case ATTR_CID:
            pResp->dwClientId = HexStrToInt (pszBuf);
            break;

        case ATTR_UID:
			ASSERT(!pResp->pszUID);
            pResp->pszUID = LocalStrDup (pszBuf);
            break;

        case ATTR_URL:
			ASSERT(!pResp->pszURL);
            pResp->pszURL = LocalStrDup (pszBuf);
            break;

        case ATTR_IP:
            lstrcpyn (pResp->szIPAddress, pszBuf, MAX_IP_ADDRESS_STRING_LENGTH);
            break;

        case ATTR_MT:
            // already got it
            break;
       }

        // skip any white space
        for (pszBuf = psz + 1; *pszBuf; pszBuf++) { if (! IsWhiteSpace (*pszBuf)) break; }
    }

    return ULS_SUCCESS;
}


HRESULT CULSLaunch_Stub::ParseB4HttpRespBuffer // beta 4 implementation
                    ( PTSTR pszBuf, ULONG cbBufSize, ULS_HTTP_RESP *pResp )
{
    PTSTR psz, pszSave;
    int i;

    // get mime type
    psz = (LPTSTR)_StrChr (pszBuf, TEXT ('['));
    if (! psz)
    {
        return ULS_E_INVALID_FORMAT;
    }
    pszBuf = psz + 1;
    psz = (LPTSTR)_StrChr (pszBuf, TEXT (']'));
    if (! psz)
    {
        return ULS_E_INVALID_FORMAT;
    }
    *psz = TEXT ('\0');

    // now pszBuf is ptr to the string inside [], such on, off, ka, res.
    pResp->nCmdId = (ULONG) -1;
    for (i = 0; i < sizeof (g_B4Cmd) / sizeof (g_B4Cmd[0]); i++)
    {
        if (! lstrcmpi (pszBuf, g_B4Cmd[i].pszCmd))
        {
            pResp->nCmdId = g_B4Cmd[i].nCmdId;
            break;
        }
    }

    // to see if this cmd is something I don't know
    if (pResp->nCmdId == (ULONG) -1)
    {
        return ULS_E_INVALID_FORMAT;
    }

    // update the buf ptr
    pszBuf = psz + 1;

    // main loop
    while (*pszBuf)
    {
        // locate a \r \n
        while (*pszBuf != TEXT ('\r') && *pszBuf != TEXT ('\n'))
        {
            pszBuf++;
        }

        // skip any white space including \r \n
        while (*pszBuf)
        {
            if (! IsWhiteSpace (*pszBuf))
            {
                break;
            }
            pszBuf++;
        }

        // end of file
        if (! *pszBuf)
        {
            return ULS_SUCCESS;
        }
        
        // locate the equal sign
        psz = (LPTSTR)_StrChr (pszBuf, TEXT ('='));
        if (! psz)
        {
            continue; // cannot goto NextLine because psz==NULL
        }

        // to make pszBuf ptr to the attr name
        *psz = TEXT ('\0');

        // search for attribute
        for (i = 0; i < sizeof (g_B4Attr) / sizeof (g_B4Attr[0]); i++)
        {
            if (! lstrcmpi (pszBuf, g_B4Attr[i]))
            {
                break;
            }
        }

        // is this attribute valid? if not, ignore it!
        if (i >= sizeof (g_B4Attr) / sizeof (g_B4Attr[0]))
        {
            goto NextLine;
        }

        // locate pszBuf now ptr to attr value
        pszBuf = psz + 1;

        // get to the end of line
        for (psz = pszBuf; *psz; psz++)
        {
            if (*psz == TEXT ('\r') || *psz == TEXT ('\n'))
            {
                break;
            }
        }        

        // deal with   attrname=\r\nEOF
        if (! *psz)
        {
            return ULS_SUCCESS;
        }

        // make the attr value is a null-terminated string pointed by pszBuf
        *psz = TEXT ('\0');

        // parse the attribute value
        switch (i)
        {
        case ATTR_HRESULT:
            pResp->hr = HexStrToInt (pszBuf);
            break;

        case ATTR_PORTNUM:
            pResp->nPort = DecStrToInt (pszBuf);
            break;

        case ATTR_HAPPLICATION:
            pResp->dwAppSession = HexStrToInt (pszBuf);
            break;

        case ATTR_HCLIENT:
            pResp->dwClientSession = HexStrToInt (pszBuf);
            break;

        case ATTR_USERID:
            pszSave = pResp->pszUID;
            pResp->pszUID = LocalStrDup (pszBuf);
            if (pResp->pszUID)
            {
                delete [] pszSave;
            }
            else
            {
                pResp->pszUID = pszSave; // restore
            }
            break;

        case ATTR_QUERYURL:
            pszSave = pResp->pszURL;
            pResp->pszURL = LocalStrDup (pszBuf);
            if (pResp->pszURL)
            {
                delete [] pszSave;
            }
            else
            {
                pResp->pszURL = pszSave; // restore
            }
            break;

        case ATTR_IPADDRESS:
            lstrcpyn (pResp->szIPAddress, pszBuf,
                sizeof (pResp->szIPAddress) / sizeof (pResp->szIPAddress[0]));
            break;

        case ATTR_MIMETYPE:
            lstrcpyn (pResp->szMimeType, pszBuf,
                sizeof (pResp->szMimeType) / sizeof (pResp->szMimeType[0]));
            break;

        case ATTR_APPMIME:
            lstrcpyn (pResp->szAppMime, pszBuf,
                sizeof (pResp->szAppMime) / sizeof (pResp->szAppMime[0]));
            break;

        case ATTR_PROTMIME:
            lstrcpyn (pResp->szProtMime, pszBuf,
                sizeof (pResp->szProtMime) / sizeof (pResp->szProtMime[0]));
            break;

        case ATTR_APPID:
            lstrcpyn (pResp->szAppId, pszBuf,
                sizeof (pResp->szAppId) / sizeof (pResp->szAppId[0]));
            break;

        case ATTR_PROTID:
            lstrcpyn (pResp->szProtId, pszBuf,
                sizeof (pResp->szProtId) / sizeof (pResp->szProtId[0]));
            break;

        case ATTR_NAPPS:
            pResp->nApps = DecStrToInt (pszBuf);
            break;

        default:
            break;
        }

    NextLine:

        // make sure we are at \r \n
        *psz = TEXT ('\r');
        pszBuf = psz;
    }

    return ULS_SUCCESS;
}


 
/*
    @doc    EXTERNAL    ULCLIENT
    @api    HRESULT | CULSLaunch_Stub::FreeUlsHttpResp |
            Frees internal resources in a generic HTTP-based
            response structure.
    @parm   ULS_HTTP_RESP * | pResp | A pointer to the generic 
            HTTP response structure.
    @rdesc  Returns ULS_SUCCESS if this operation succeeds.
    @comm   The internal resources must be created by
            the ParseUlsHttpRespFile method or
            the ParseUlsHttpRespBuffer method.
*/

STDMETHODIMP CULSLaunch_Stub::FreeUlsHttpResp ( ULS_HTTP_RESP *pResp )
{
    if (pResp->pszUID)
    {
        delete [] pResp->pszUID;
        pResp->pszUID = NULL;
    }

    if (pResp->pszURL)
    {
        delete [] pResp->pszURL;
        pResp->pszURL = NULL;
    }

    return ULS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\marshalableti.cpp ===
// MarshalableTI.cpp : Implementation of CMarshalableTI
#include "precomp.h"
#include "MarshalableTI.h"

/////////////////////////////////////////////////////////////////////////////
// CMarshalableTI methods
/////////////////////////////////////////////////////////////////////////////

HRESULT CMarshalableTI::FinalConstruct()
{
	HRESULT hr = S_OK;
	
	m_bCreated = false;

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IMarshalableTI methods
/////////////////////////////////////////////////////////////////////////////
 
STDMETHODIMP CMarshalableTI::Create(REFIID clsid, REFIID iidLib, LCID lcid, WORD dwMajorVer, WORD dwMinorVer)
{
	HRESULT hr = S_OK;
	if( !m_bCreated )
	{
		m_guid = clsid;
		m_libid = iidLib;
		m_lcid = lcid;
		
		m_TIHolder.m_pguid = &m_guid;
		m_TIHolder.m_plibid = &m_libid;
		m_TIHolder.m_wMajor = dwMajorVer;
		m_TIHolder.m_wMinor = dwMinorVer;
		m_TIHolder.m_pInfo = NULL;
		m_TIHolder.m_dwRef = 0;
		m_TIHolder.m_pMap = NULL;
		m_TIHolder.m_nCount = 0;
	}
	else
	{
		ATLASSERT(0);
		hr = E_UNEXPECTED;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IMarshal Methods
/////////////////////////////////////////////////////////////////////////////

HRESULT CMarshalableTI::GetUnmarshalClass(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID *pCid)
{
	HRESULT hr = S_OK;

	*pCid = CLSID_MarshalableTI;

    return hr;
}

HRESULT CMarshalableTI::GetMarshalSizeMax(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize)
{

	*pSize = (2 * sizeof(GUID) + 2 * sizeof(ULONG) + sizeof(LCID) );
	return S_OK;
}

HRESULT CMarshalableTI::MarshalInterface(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags)
{

	BYTE buf[(2 * sizeof(GUID) + 2 * sizeof(ULONG) + sizeof(LCID))];
    BYTE * pByte = buf;

    const GUID* pGuid = m_TIHolder.m_plibid;
	DWORD dwVer = m_TIHolder.m_wMajor;
    const DWORD* pDword = &dwVer;

	// Ugly because it is yanked from tested, shipped system code
    for (int i = 0; i < 2; i++) {

        DWORD dword = pGuid->Data1;
        *pByte++ = (BYTE)(dword);
        *pByte++ = (BYTE)(dword >> 8);
        *pByte++ = (BYTE)(dword >> 16);
        *pByte++ = (BYTE)(dword >> 24);

        WORD word = pGuid->Data2;
        *pByte++ = (BYTE)(word);
        *pByte++ = (BYTE)(word >> 8);

        word = pGuid->Data3;
        *pByte++ = (BYTE)(word);
        *pByte++ = (BYTE)(word >> 8);

        const BYTE* pData4 = pGuid->Data4;
        for (int j = 0; j < 8; j++) {
            *pByte++ = *pData4++;
        }

        dword = *pDword;
        *pByte++ = (BYTE)(dword);
        *pByte++ = (BYTE)(dword >> 8);
        *pByte++ = (BYTE)(dword >> 16);
        *pByte++ = (BYTE)(dword >> 24);

        pGuid = m_TIHolder.m_pguid;
		dwVer = m_TIHolder.m_wMinor;
    }

    *pByte++ = (BYTE)(m_lcid);
    *pByte++ = (BYTE)(m_lcid >> 8);
    *pByte++ = (BYTE)(m_lcid >> 16);
    *pByte++ = (BYTE)(m_lcid >> 24);

    HRESULT hr = pStm->Write(buf, sizeof(buf), NULL);

    return S_OK;
}

HRESULT CMarshalableTI::UnmarshalInterface(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv)
{


    // Since we don't know the endian-ness of the other side,
    // we use a private wire format for custom marshaling here.
    //
    BYTE buf[(2 * sizeof(GUID) + 2 * sizeof(ULONG) + sizeof(LCID) )];
    HRESULT hr = S_OK;

	if( !m_bCreated )
	{

		*ppv = NULL;

		hr = pStm->Read(buf, sizeof(buf), NULL);

		if(SUCCEEDED(hr))
		{
			GUID guidTypeLib;
			GUID guidTypeInfo;
			LCID lcidTypeLib;
			ULONG verMajor;
			ULONG verMinor;

			BYTE * pByte;
			GUID * pGuid;
			DWORD * pDword;

			pByte = buf;
			pGuid = &guidTypeLib;
			pDword = &verMajor;
			int i;

			// Ugly because it is yanked from tested, shipped system code
			for (i = 0; i < 2; i++) {
				DWORD dword;
				WORD word;

				dword  = (DWORD)(*pByte++);
				dword += (DWORD)(*pByte++ << 8);
				dword += (DWORD)(*pByte++ << 16);
				dword += (DWORD)(*pByte++ << 24);
				pGuid->Data1 = dword;

				word  = (WORD)(*pByte++);
				word += (WORD)(*pByte++ << 8);
				pGuid->Data2 = word;

				word  = (WORD)(*pByte++);
				word += (WORD)(*pByte++ << 8);
				pGuid->Data3 = word;

				BYTE * pData4 = pGuid->Data4;
				for (int j = 0; j < 8; j++) {
					*pData4++ = *pByte++;
				}

				dword  = (DWORD)(*pByte++);
				dword += (DWORD)(*pByte++ << 8);
				dword += (DWORD)(*pByte++ << 16);
				dword += (DWORD)(*pByte++ << 24);
				*pDword = dword;

				pGuid = &guidTypeInfo;
				pDword = &verMinor;
			}

			lcidTypeLib  = (DWORD)(*pByte++);
			lcidTypeLib += (DWORD)(*pByte++ << 8);
			lcidTypeLib += (DWORD)(*pByte++ << 16);
			lcidTypeLib += (DWORD)(*pByte++ << 24);

			hr = Create(guidTypeInfo, guidTypeLib,lcidTypeLib, static_cast<WORD>(verMajor), static_cast<WORD>(verMinor));
		}
	}

	if( SUCCEEDED(hr) )
	{
		hr = QueryInterface(riid, ppv);
	}

	return hr;
}

HRESULT CMarshalableTI::ReleaseMarshalData(
            /* [unique][in] */ IStream *pStm)
{
	return S_OK;
}

HRESULT CMarshalableTI::DisconnectObject(
            /* [in] */ DWORD dwReserved)
{
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// ITypeInfo Methods
/////////////////////////////////////////////////////////////////////////////

HRESULT CMarshalableTI::GetTypeAttr(
                TYPEATTR ** ppTypeAttr
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetTypeAttr(ppTypeAttr);
	}
	return hr; 
}

HRESULT CMarshalableTI:: GetTypeComp(
                ITypeComp ** ppTComp
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetTypeComp(ppTComp);
	}
	return hr; 
}

HRESULT CMarshalableTI:: GetFuncDesc(
                UINT index,
                FUNCDESC ** ppFuncDesc
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetFuncDesc(index, ppFuncDesc);
	}
	return hr; 
}

HRESULT CMarshalableTI:: GetVarDesc(
                UINT index,
                VARDESC ** ppVarDesc
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetVarDesc(index, ppVarDesc);
	}
	return hr; 
}

HRESULT CMarshalableTI:: GetNames(
                MEMBERID memid,
                BSTR * rgBstrNames,
                UINT cMaxNames,
                UINT * pcNames
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetNames(memid, rgBstrNames, cMaxNames, pcNames);
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetRefTypeOfImplType(
                UINT index,
                HREFTYPE * pRefType
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetRefTypeOfImplType(index, pRefType);
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetImplTypeFlags(
                UINT index,
                INT * pImplTypeFlags
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetImplTypeFlags(index, pImplTypeFlags);
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetIDsOfNames(
                LPOLESTR * rgszNames,
                UINT cNames,
                MEMBERID * pMemId
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetIDsOfNames(rgszNames, cNames, pMemId);
	}
	return hr; 
}


HRESULT CMarshalableTI:: Invoke(
                PVOID pvInstance,
                MEMBERID memid,
                WORD wFlags,
                DISPPARAMS * pDispParams,
                VARIANT * pVarResult,
                EXCEPINFO * pExcepInfo,
                UINT * puArgErr
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->Invoke(pvInstance, memid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	}
	return hr; 
}

HRESULT CMarshalableTI:: GetDocumentation(
                MEMBERID memid,
                BSTR * pBstrName,
                BSTR * pBstrDocString,
                DWORD * pdwHelpContext,
                BSTR * pBstrHelpFile
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetDocumentation(memid, pBstrName, pBstrDocString, pdwHelpContext, pBstrHelpFile);
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetDllEntry(
                MEMBERID memid,
                INVOKEKIND invKind,
                BSTR * pBstrDllName,
                BSTR * pBstrName,
                WORD * pwOrdinal
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetDllEntry(memid, invKind, pBstrDllName, pBstrName, pwOrdinal);
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetRefTypeInfo(
                HREFTYPE hRefType,
                ITypeInfo ** ppTInfo
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetRefTypeInfo(hRefType, ppTInfo);
	}
	return hr; 
}


HRESULT CMarshalableTI:: AddressOfMember(
                MEMBERID memid,
                INVOKEKIND invKind,
                PVOID * ppv
            ) 
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->AddressOfMember(memid, invKind, ppv);
	}
	return hr; 
}



HRESULT CMarshalableTI:: CreateInstance(
                IUnknown * pUnkOuter,
                REFIID riid,
                PVOID * ppvObj
            ) 
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->CreateInstance(pUnkOuter, riid, ppvObj );
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetMops(
                MEMBERID memid,
                BSTR * pBstrMops
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetMops(memid, pBstrMops);
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetContainingTypeLib(
                ITypeLib ** ppTLib,
                UINT * pIndex
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetContainingTypeLib(ppTLib, pIndex);
	}
	return hr; 
}

void CMarshalableTI::ReleaseTypeAttr(
            TYPEATTR * pTypeAttr
        )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		spTI->ReleaseTypeAttr(pTypeAttr);
	}
}

void CMarshalableTI::ReleaseFuncDesc(
            FUNCDESC * pFuncDesc
        )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		spTI->ReleaseFuncDesc(pFuncDesc);
	}
}

void CMarshalableTI::ReleaseVarDesc(
            VARDESC * pVarDesc
        ) 
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		spTI->ReleaseVarDesc(pVarDesc);
	}
}


HRESULT CMarshalableTI::_GetClassInfo(ITypeInfo** ppTI)
{
	HRESULT hr = S_OK;

	hr = m_TIHolder.GetTI(m_lcid, ppTI);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\nmapp.h ===
#ifndef __NmApp_h__
#define __NmApp_h__

#include "resource.h"       // main symbols
#include "imsconf3.h"
#include "NetMeeting.h"

/////////////////////////////////////////////////////////////////////////////
// CNetMeetingObj
class ATL_NO_VTABLE CNetMeetingObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNetMeetingObj, &CLSID_NetMeeting>
{

public:

DECLARE_REGISTRY_RESOURCEID(IDR_NMAPP)

BEGIN_COM_MAP(CNetMeetingObj)
END_COM_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CNmManagerObj
class ATL_NO_VTABLE CNmManagerObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNmManagerObj, &CLSID_NmManager>
{

public:

DECLARE_REGISTRY_RESOURCEID(IDR_NMMANAGER)

BEGIN_COM_MAP(CNmManagerObj)
END_COM_MAP()

};


#endif //__NmApp_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\mrulist2.cpp ===
// File: mrulist.cpp

#include "precomp.h"

#include "mrulist2.h"

typedef struct {
	LPTSTR psz1;
	LPTSTR psz2;
} SZSZ;
typedef SZSZ * PSZSZ;

typedef struct {
	LPTSTR psz1;
	LPTSTR psz2;
	DWORD  dw;
} SZSZDW;
typedef SZSZDW * PSZSZDW;


static LPTSTR PszAlloc(LPCTSTR pszSrc)
{
	if (NULL == pszSrc)
		return NULL;

	LPTSTR pszDest = new TCHAR[lstrlen(pszSrc) + 1];
	if (NULL != pszDest)
	{
		lstrcpy(pszDest, pszSrc);
	}
	return pszDest;
}

/*  C  M  R  U  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: CMRUList2

-------------------------------------------------------------------------*/
CMRUList2::CMRUList2(const DWSTR * prgDwStr, int cEntryMax, BOOL fReversed) :
	m_prgDwStr   (prgDwStr),
	m_cEntryMax (cEntryMax),
	m_fReversed (fReversed),
	m_cEntry    (0),
	m_rgpEntry  (NULL),
	m_fDirty    (FALSE)
{
	DBGENTRY(CMRUList2::CMRUList2);

	ASSERT(NULL != prgDwStr);
	m_cCol = m_prgDwStr[0].dw;

	int cb = m_cEntryMax * sizeof(PMRUE);
	m_rgpEntry = new PMRUE[cb];
	if (NULL == m_rgpEntry)
	{
		ERROR_OUT(("CMRUList2 - out of memory"));
		return;
	}
	ZeroMemory(m_rgpEntry, cb);

	RegEntry re(PszRegKey(), HKEY_CURRENT_USER);
	if (ERROR_SUCCESS != re.GetError())
		return;

	m_cEntry = min(re.GetNumber(REGVAL_MRU_COUNT, 0), m_cEntryMax);
	for (int i = 0; i < m_cEntry; i++)
	{
		m_rgpEntry[i] = LoadEntry(&re, i);
	}
}

CMRUList2::~CMRUList2()
{
	DBGENTRY(CMRUList2::~CMRUList2);

	if (m_fDirty)
	{
		Save();
	}

	for (int i = 0; i < m_cEntry; i++)
	{
		DeleteEntry(m_rgpEntry[i]);
	}
	delete m_rgpEntry;
}


///////////////////////////////////////////////////////////////////////////

PMRUE CMRUList2::LoadEntry(RegEntry * pre, int iItem)
{
	if (m_fReversed)
	{
		iItem = (m_cEntry - (iItem+1));
	}

	PMRUE pEntry = (PMRUE) new PVOID[m_cCol*sizeof(PVOID)];
	if (NULL != pEntry)
	{
		PVOID ** ppv = (PVOID **) pEntry;
		for (int iCol = 0; iCol < m_cCol; iCol++, ppv++)
		{
			TCHAR szKey[MAX_PATH];
			wsprintf(szKey, TEXT("%s%d"), PszPrefixForCol(iCol), iItem);
			switch (MruTypeForCol(iCol))
				{
			default:
			case MRUTYPE_SZ:
				* (LPTSTR *)ppv = PszAlloc(pre->GetString(szKey));
				break;
			case MRUTYPE_DW:
				* (DWORD *) ppv = pre->GetNumber(szKey);
				break;
				}
		}
	}

	return pEntry;
}

VOID CMRUList2::StoreEntry(RegEntry * pre, int iItem)
{
	PVOID ** ppv = (PVOID **) GetEntry(iItem);

	if (m_fReversed)
	{
		iItem = (m_cEntry - (iItem+1));
	}

	for (int iCol = 0; iCol < m_cCol; iCol++, ppv++)
	{
		TCHAR szKey[MAX_PATH];
		wsprintf(szKey, TEXT("%s%d"), PszPrefixForCol(iCol), iItem);
		switch (MruTypeForCol(iCol))
			{
		default:
		case MRUTYPE_SZ:
			pre->SetValue(szKey, * (LPCTSTR *)ppv);
			break;
		case MRUTYPE_DW:
			pre->SetValue(szKey, * (ULONG *) ppv);
			break;
			}
	}
}

VOID CMRUList2::DeleteEntry(PMRUE pEntry)
{
	PVOID ** ppv = (PVOID **) pEntry;
	for (int iCol = 0; iCol < m_cCol; iCol++, ppv++)
	{
		switch (MruTypeForCol(iCol))
			{
		default:
		case MRUTYPE_SZ:
			delete *ppv;
			break;
		case MRUTYPE_DW:
			break;
			}
	}
	delete pEntry;
}

VOID CMRUList2::DeleteEntry(int iItem)
{
	if ((iItem < 0) || (iItem >= m_cEntry))
		return; // nothing to do

	// delete the data
	DeleteEntry(m_rgpEntry[iItem]);

	// decrement the count
	m_cEntry--;

	// shift items up
	for ( ; iItem < m_cEntry; iItem++)
	{
		m_rgpEntry[iItem] = m_rgpEntry[iItem+1];
	}

	// the list has been modified
	m_fDirty = TRUE;
}


//--------------------------------------------------------------------------//
//	CMRUList2::DeleteEntry.													//
//		This DeleteEntry() deletes the first entry it finds thats primary	//
//		string matches the one passed in.									//
//--------------------------------------------------------------------------//
void
CMRUList2::DeleteEntry
(
	const TCHAR * const	primaryString
){
	int	items	= GetNumEntries();

	for( int nn = 0; nn < items; nn++ )
	{
		if( StrCmpI( primaryString, * ((const TCHAR * const * const) m_rgpEntry[ nn ]) ) == 0 )
		{
			DeleteEntry( nn );
			break;
		}
	}

}	//	End of CMRUList2::DeleteEntry.


/*  C O M P A R E  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CompareEntry

-------------------------------------------------------------------------*/
int CMRUList2::CompareEntry(int iItem, PMRUE pEntry)
{
	ASSERT(NULL != pEntry);

	int iRet = 0;

	PVOID * ppv1 = (PVOID *) GetEntry(iItem);
	PVOID * ppv2 = (PVOID *) pEntry;
	for (int iCol = 0; iCol < m_cCol; iCol++, ppv1++, ppv2++)
	{
		switch (MruTypeForCol(iCol))
			{
		default:
		case MRUTYPE_SZ:
			iRet = lstrcmpi(* (LPCTSTR *) ppv1, * (LPCTSTR *) ppv2);
			break;
		case MRUTYPE_DW:
			iRet = (* (int *) ppv1) - (* (int *) ppv2);
			break;
			}

		if (0 != iRet)
			break;
	}

	return iRet;
}


/*  F I N D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: FindEntry

     Return -1 if the item is not found.
-------------------------------------------------------------------------*/
int CMRUList2::FindEntry(PMRUE pEntry)
{
	int cItems = GetNumEntries();
	for (int i = 0; i < cItems; i++)
	{
		if (0 == CompareEntry(i, pEntry))
		{
			return i;
		}
	}

	return -1; // not found
}



		
/*  S A V E  */
/*-------------------------------------------------------------------------
    %%Function: Save

-------------------------------------------------------------------------*/
HRESULT CMRUList2::Save(void)
{
	DBGENTRY(CMRUList2::Save);

	// Retrieve the data from the registry
	RegEntry re(PszRegKey(), HKEY_CURRENT_USER);
	if (ERROR_SUCCESS != re.GetError())
		return E_FAIL;

	re.SetValue(REGVAL_MRU_COUNT, m_cEntry);
	for (int i = 0; i < m_cEntry; i++)
	{
		StoreEntry(&re, i);
	}

	return S_OK;
}


/*  S H I F T  E N T R I E S  D O W N  */
/*-------------------------------------------------------------------------
    %%Function: ShiftEntriesDown

    Shift the entires down by one slot leaving the first position open.
-------------------------------------------------------------------------*/
VOID CMRUList2::ShiftEntriesDown(int cItem)
{
	if (cItem < 1)
		return; // nothing to do

	int iItem;
	for (iItem = cItem; iItem > 0; iItem--)
	{
		m_rgpEntry[iItem] = m_rgpEntry[iItem-1];
	}

	// the list has been modified
	m_fDirty = TRUE;
}


/*  M O V E  E N T R Y  T O  T O P  */
/*-------------------------------------------------------------------------
    %%Function: MoveEntryToTop

-------------------------------------------------------------------------*/
VOID CMRUList2::MoveEntryToTop(int iItem)
{
	DBGENTRY(CMRUList2::MoveEntryToTop);

	if ((iItem < 1) || (iItem >= m_cEntry))
		return; // nothing to do

	PMRUE pEntry = GetEntry(iItem);
	ShiftEntriesDown(iItem);
	m_rgpEntry[0] = pEntry;
}


/*  A D D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: AddEntry

	Put the entry into the top of the list.
	The data is owned by the list after this.
	
    Returns:
    	S_OK    - added to the head of the list
    	S_FALSE - already in list (item is moved to top)
-------------------------------------------------------------------------*/
HRESULT CMRUList2::AddEntry(PMRUE pEntry)
{
	DBGENTRY(CMRUList2::AddEntry);

	// the list has been modified
	m_fDirty = TRUE;

	int iItem = FindEntry(pEntry);
	if (-1 != iItem)
	{
		// This entry already exists, move it to the top:
		MoveEntryToTop(iItem);
		DeleteEntry(pEntry); // don't need this data
		return S_FALSE; // Success, but already in the list
	}

	int cShift;
	if (m_cEntryMax == m_cEntry)
	{
		// drop the last item
		DeleteEntry(m_rgpEntry[m_cEntry-1]);
		cShift = m_cEntry-1;
	}
	else
	{
		cShift = m_cEntry;
		m_cEntry++;
	}
	ShiftEntriesDown(cShift);

	// add it to the head of the list
	m_rgpEntry[0] = pEntry;

	return S_OK;
}


HRESULT CMRUList2::AddEntry(LPCTSTR pcsz)
{
	LPTSTR * ppsz = new LPTSTR;
	LPTSTR psz = PszAlloc(pcsz);
	if ((NULL == ppsz) || (NULL == psz))
	{
		delete ppsz;
		delete psz;
		return E_OUTOFMEMORY;
	}

	*ppsz = psz;

	return AddEntry((PMRUE) ppsz);
}

HRESULT CMRUList2::AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2)
{
	PSZSZ pSzSz = new SZSZ;
	if (NULL == pSzSz)
		return E_OUTOFMEMORY;

	pSzSz->psz1 = PszAlloc(pcsz1);
	pSzSz->psz2 = PszAlloc(pcsz2);
	if ((NULL == pSzSz->psz1) || (NULL == pSzSz->psz1))
	{
		// something failed - don't add anything
		DeleteEntry(pSzSz);
		return E_OUTOFMEMORY;
	}
	
	return AddEntry((PMRUE) pSzSz);
}

HRESULT CMRUList2::AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2, DWORD dw3)
{
	PSZSZDW pData = new SZSZDW;
	if (NULL == pData)
		return E_OUTOFMEMORY;

	pData->psz1 = PszAlloc(pcsz1);
	pData->psz2 = PszAlloc(pcsz2);
	if ((NULL == pData->psz1) || (NULL == pData->psz1))
	{
		// something failed - don't add anything
		DeleteEntry(pData);
		return E_OUTOFMEMORY;
	}
	pData->dw = dw3;
	
	return AddEntry((PMRUE) pData);
}


/*  P S Z  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: PszEntry

    Return the main string associated with the entry
-------------------------------------------------------------------------*/
LPCTSTR CMRUList2::PszEntry(int iItem)
{
	PMRUE pEntry = GetEntry(iItem);
	return (LPCTSTR) * ((LPTSTR *)pEntry);
}

LPCTSTR CMRUList2::PszData2(int iItem)
{
	PMRUE pEntry = GetEntry(iItem);
	LPTSTR * ppsz = ((LPTSTR *)pEntry);
	return * (ppsz+1);
}

DWORD_PTR CMRUList2::PszData3(int iItem)
{
	PMRUE pEntry = GetEntry(iItem);
	LPTSTR * ppsz = ((LPTSTR *)pEntry);
	return (DWORD_PTR) * (ppsz+2);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\marshalableti.h ===
// MarshalableTI.h : Declaration of the CMarshalableTI

#ifndef __MARSHALABLETI_H_
#define __MARSHALABLETI_H_

#include "mslablti.h"
#include "resource.h"       // main symbols


// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CComTypeInfoHolder2
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;
	struct stringdispid
	{
		CComBSTR bstr;
		int nLen;
		DISPID id;
	};
	stringdispid* m_pMap;
	int m_nCount;

	CComTypeInfoHolder2()
	{
		m_pInfo = NULL;
		m_pMap = NULL;
	}

	~CComTypeInfoHolder2()
	{
		if (m_pInfo != NULL)
		{
			m_pInfo->Release();
		}
		m_pInfo = NULL;

		if(m_pMap!= NULL)
		{
			delete [] m_pMap;
			}
		m_pMap = NULL;
	}

public:
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		*ppInfo = m_pInfo;
		if (m_pInfo != NULL)
		{
			m_pInfo->AddRef();
			hr = S_OK;
		}
		return hr;
	}
	HRESULT GetTI(LCID lcid);
	HRESULT EnsureTI(LCID lcid)
	{
		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		return hr;
	}

	HRESULT GetTypeInfo(UINT /* itinfo */, LCID lcid, ITypeInfo** pptinfo)
	{
		HRESULT hRes = E_POINTER;
		if (pptinfo != NULL)
			hRes = GetTI(lcid, pptinfo);
		return hRes;
	}
	HRESULT GetIDsOfNames(REFIID /* riid */, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
		{
			for (int i=0; i<(int)cNames; i++)
			{
				int n = ocslen(rgszNames[i]);
				for (int j=m_nCount-1; j>=0; j--)
				{
					if ((n == m_pMap[j].nLen) &&
						(memcmp(m_pMap[j].bstr, rgszNames[i], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
					{
						rgdispid[i] = m_pMap[j].id;
						break;
					}
				}
				if (j < 0)
				{
					hRes = m_pInfo->GetIDsOfNames(rgszNames + i, 1, &rgdispid[i]);
					if (FAILED(hRes))
						break;
				}
			}
		}
		return hRes;
	}

	HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID /* riid */,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
			hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		return hRes;
	}
	HRESULT LoadNameCache(ITypeInfo* pTypeInfo)
	{
		TYPEATTR* pta;
		HRESULT hr = pTypeInfo->GetTypeAttr(&pta);
		if (SUCCEEDED(hr))
		{
			m_nCount = pta->cFuncs;
			m_pMap = m_nCount == 0 ? 0 : new stringdispid[m_nCount];
			for (int i=0; i<m_nCount; i++)
			{
				FUNCDESC* pfd;
				if (SUCCEEDED(pTypeInfo->GetFuncDesc(i, &pfd)))
				{
					CComBSTR bstrName;
					if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))
					{
						m_pMap[i].bstr.Attach(bstrName.Detach());
						m_pMap[i].nLen = SysStringLen(m_pMap[i].bstr);
						m_pMap[i].id = pfd->memid;
					}
					pTypeInfo->ReleaseFuncDesc(pfd);
				}
			}
			pTypeInfo->ReleaseTypeAttr(pta);
		}
		return S_OK;
	}
};


inline HRESULT CComTypeInfoHolder2::GetTI(LCID lcid)
{
	//If this assert occurs then most likely didn't initialize properly
	ATLASSERT(m_plibid != NULL && m_pguid != NULL);
	ATLASSERT(!InlineIsEqualGUID(*m_plibid, GUID_NULL) && "Did you forget to pass the LIBID to CComModule::Init?");

	if (m_pInfo != NULL)
		return S_OK;
	HRESULT hRes = E_FAIL;
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib;
		hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
		if (SUCCEEDED(hRes))
		{
			CComPtr<ITypeInfo> spTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);
			if (SUCCEEDED(hRes))
			{
				CComPtr<ITypeInfo> spInfo(spTypeInfo);
				CComPtr<ITypeInfo2> spTypeInfo2;
				if (SUCCEEDED(spTypeInfo->QueryInterface(IID_ITypeInfo2, reinterpret_cast<void**>(&spTypeInfo2))))
					spInfo = spTypeInfo2;

				LoadNameCache(spInfo);
				m_pInfo = spInfo.Detach();
			}
			pTypeLib->Release();
		}
	}
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// CMarshalableTI
class ATL_NO_VTABLE CMarshalableTI : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMarshalableTI, &CLSID_MarshalableTI>,
	public IMarshalableTI,
	public IMarshal,
	public ITypeInfo
{
private:
	CComTypeInfoHolder2	m_TIHolder;
	GUID				m_guid;
	GUID				m_libid;
	LCID				m_lcid;
	bool				m_bCreated;

public:
	

DECLARE_REGISTRY_RESOURCEID(IDR_MSLABLTI)
DECLARE_NOT_AGGREGATABLE(CMarshalableTI)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMarshalableTI)
	COM_INTERFACE_ENTRY(IMarshalableTI)
	COM_INTERFACE_ENTRY(IMarshal)
	COM_INTERFACE_ENTRY(ITypeInfo)
END_COM_MAP()

	HRESULT FinalConstruct();

/////////////////////////////////////////////////////////////////////////////////
// IMarshalableTI methods

	STDMETHOD(Create)(/*[in]*/ REFIID clsid, 
					  /*[in]*/ REFIID iidLib, 
					  /*[in]*/ LCID lcid,
					  /*[in]*/ WORD dwMajorVer, 
					  /*[in]*/ WORD dwMinorVer);

/////////////////////////////////////////////////////////////////////////////////
// IMarshal methods

    STDMETHOD(GetUnmarshalClass)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID *pCid);

    STDMETHOD(GetMarshalSizeMax)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize);

    STDMETHOD(MarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags);

    STDMETHOD(UnmarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);

    STDMETHOD(ReleaseMarshalData)(
            /* [unique][in] */ IStream *pStm);

    STDMETHOD(DisconnectObject)(
            /* [in] */ DWORD dwReserved);

/////////////////////////////////////////////////////////////////////////////////
// ITypeInfo methods

    STDMETHOD(GetTypeAttr)(
                TYPEATTR ** ppTypeAttr);

    STDMETHOD(GetTypeComp)(
                ITypeComp ** ppTComp);

    STDMETHOD(GetFuncDesc)(
                UINT index,
                FUNCDESC ** ppFuncDesc);

    STDMETHOD(GetVarDesc)(
                UINT index,
                VARDESC ** ppVarDesc);

    STDMETHOD(GetNames)(
                MEMBERID memid,
                BSTR * rgBstrNames,
                UINT cMaxNames,
                UINT * pcNames);


    STDMETHOD(GetRefTypeOfImplType)(
                UINT index,
                HREFTYPE * pRefType);

    STDMETHOD(GetImplTypeFlags)(
                UINT index,
                INT * pImplTypeFlags);


    STDMETHOD(GetIDsOfNames)(
                LPOLESTR * rgszNames,
                UINT cNames,
                MEMBERID * pMemId);

    STDMETHOD(Invoke)(
                PVOID pvInstance,
                MEMBERID memid,
                WORD wFlags,
                DISPPARAMS * pDispParams,
                VARIANT * pVarResult,
                EXCEPINFO * pExcepInfo,
                UINT * puArgErr);

    STDMETHOD(GetDocumentation)(
                MEMBERID memid,
                BSTR * pBstrName,
                BSTR * pBstrDocString,
                DWORD * pdwHelpContext,
                BSTR * pBstrHelpFile);


    STDMETHOD(GetDllEntry)(
                MEMBERID memid,
                INVOKEKIND invKind,
                BSTR * pBstrDllName,
                BSTR * pBstrName,
                WORD * pwOrdinal);


    STDMETHOD(GetRefTypeInfo)(
                HREFTYPE hRefType,
                ITypeInfo ** ppTInfo);


    STDMETHOD(AddressOfMember)(
                MEMBERID memid,
                INVOKEKIND invKind,
                PVOID * ppv);

    STDMETHOD(CreateInstance)(
                IUnknown * pUnkOuter,
                REFIID riid,
                PVOID * ppvObj);


    STDMETHOD(GetMops)(
                MEMBERID memid,
                BSTR * pBstrMops);


    STDMETHOD(GetContainingTypeLib)(
                ITypeLib ** ppTLib,
                UINT * pIndex);

    STDMETHOD_(void, ReleaseTypeAttr)(
                TYPEATTR * pTypeAttr);

    STDMETHOD_(void, ReleaseFuncDesc)(
                FUNCDESC * pFuncDesc);

    STDMETHOD_(void, ReleaseVarDesc)(
                VARDESC * pVarDesc);


private:
	HRESULT _GetClassInfo(ITypeInfo** ppTI);
};

#endif //__MARSHALABLETI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\mrulist2.h ===
// File: mrulist.h

#ifndef _MRULIST_H_
#define _MRULIST_H_

typedef struct  DWSTR
    {
    DWORD dw;
    LPTSTR psz;
    }	DWSTR;


typedef VOID * PMRUE;  // MRU Entries

enum {
	MRUTYPE_SZ = 1,
	MRUTYPE_DW = 2,
};

class CMRUList2
{
private:
	const DWSTR * m_prgDwStr;// {{cCol, pszKey}, {mruType, pszPrefix1}, {mruType, pszPrefix2},...}
	int     m_cCol;       // number of "columns" (data entries in m_prgDwStr)
	int     m_cEntryMax;  // maximum number of entries
	int	    m_cEntry;     // current number of entries
	PMRUE * m_rgpEntry;   // array of pointers to MRU data
	BOOL    m_fDirty;     // TRUE if data was changed
	BOOL    m_fReversed;  // Load/Save data reversed (old style)

	BOOL    FValidCol(int i)    {return ((i >= 0) && (i < m_cCol));}
	BOOL    FValidIndex(int i)  {return ((i >= 0) && (i < m_cEntry));}
	BOOL    FDirty()            {return m_fDirty;}
	BOOL    FReversed()         {return m_fReversed;}

	inline PMRUE GetEntry(int iItem)
	{
		ASSERT(FValidIndex(iItem));
		return m_rgpEntry[iItem];
	}

	inline int MruTypeForCol(int iCol)
	{
		ASSERT(FValidCol(iCol));
		return m_prgDwStr[1+iCol].dw;
	}

	inline LPCTSTR PszPrefixForCol(int iCol)
	{
		ASSERT(FValidCol(iCol));
		return m_prgDwStr[1+iCol].psz;
	}

	inline LPCTSTR PszRegKey(void)
	{
		return m_prgDwStr[0].psz;
	}

	VOID    ShiftEntriesDown(int cItem);

public:
	CMRUList2(const DWSTR * prgDwStr, int cEntryMax, BOOL fReverse = FALSE);
	~CMRUList2();

	int     GetNumEntries()     {return m_cEntry;}
	VOID    SetDirty(BOOL fDirty)     {m_fDirty = fDirty;}

	// Generic functions
	int     FindEntry(PMRUE pEntry);
	VOID    MoveEntryToTop(int iItem);
	int     CompareEntry(int iItem, PMRUE pEntry);
	PMRUE   LoadEntry(RegEntry * pre, int iItem);
	VOID    StoreEntry(RegEntry * pre, int iItem);
	VOID    DeleteEntry(PMRUE pEntry);
	VOID    DeleteEntry(int iItem);

	void
	DeleteEntry
	(
		const TCHAR * const	primaryString
	);
	
	HRESULT Save(void);
	LPCTSTR PszEntry(int iItem);
	LPCTSTR PszData2(int iItem);
	DWORD_PTR PszData3(int iItem);

	HRESULT AddEntry(PMRUE pEntry);
	HRESULT AddEntry(LPCTSTR pcsz);
	HRESULT AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2);
	HRESULT AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2, DWORD dw3);
};


#endif /* _MRULIST_H_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by si.rc
//
#define IDS_LAUNCH_ERROR                1
#define IDS_COULD_NOT_CALL              2
#define IDS_MSGBOX_TITLE                3
#define IDS_MS_INTERNET_DIRECTORY       4
#define IDS_NAME_ORDER                  5
#define IDI_SHORTCUT_ICON               103
#define IDI_USERINFO                    107
#define IDI_SERVER                      108
#define IDR_NMAPP                       200
#define IDR_NMMANAGER                   201
#define IDR_NMSYSINFO                   202
#define IDR_MSLABLTI					203
#define IDD_USERINFO                    300
#define IDG_UI_MYINFO                   301
#define IDE_UI_FIRSTNAME                302
#define IDE_UI_LASTNAME                 303
#define IDE_UI_EMAIL                    304
#define IDE_UI_LOCATION                 305
#define IDG_UI_DIRECTORY                306
#define IDE_UI_DIRECTORY                307

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        400
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\precomp.cpp ===
// precomp.cpp : source file that includes just the standard includes
//  precomp.pch will be the pre-compiled header
//  precomp.obj will contain the pre-compiled type information
#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
    #include <statreg.h>
    #include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\nmsysinfo.h ===
#ifndef __NmSysInfo_h__
#define __NmSysInfo_h__

#include "SDKInternal.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CNmSysInfoObj
class ATL_NO_VTABLE CNmSysInfoObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNmSysInfoObj, &CLSID_NmSysInfo>,
	public IConnectionPointContainerImpl<CNmSysInfoObj>,
	public IConnectionPointImpl<CNmSysInfoObj, &IID_INmSysInfoNotify, CComDynamicUnkArray>,
	public IMarshal,
	public INmSysInfo,
	public IInternalSysInfoObj
{

	CComPtr<IInternalConfExe> m_spConfHook;
	DWORD m_dwID;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_NMSYSINFO)
DECLARE_NOT_AGGREGATABLE(CNmSysInfoObj)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNmSysInfoObj)
	COM_INTERFACE_ENTRY(INmSysInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IMarshal)
	COM_INTERFACE_ENTRY(IInternalSysInfoObj)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CNmSysInfoObj)
	CONNECTION_POINT_ENTRY(IID_INmSysInfoNotify)
END_CONNECTION_POINT_MAP()

	HRESULT FinalConstruct();
	void FinalRelease();

///////////////////////////////////////////////
// INmSysInfo methods

	STDMETHOD(IsInstalled)(void);
	STDMETHOD(GetProperty)(NM_SYSPROP uProp, BSTR *pbstrProp);
	STDMETHOD(SetProperty)(NM_SYSPROP uProp, BSTR bstrName);
	STDMETHOD(GetUserData)(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	STDMETHOD(SetUserData)(REFGUID rguid, BYTE *pb, ULONG cb);
	STDMETHOD(GetNmApp)(REFGUID rguid,BSTR *pbstrApplication, BSTR *pbstrCommandLine, BSTR *pbstrDirectory);
	STDMETHOD(SetNmApp)(REFGUID rguid,BSTR bstrApplication, BSTR bstrCommandLine, BSTR bstrDirectory);
	STDMETHOD(GetNmchCaps)(ULONG *pchCaps);
	STDMETHOD(GetLaunchInfo)(INmConference **ppConference, INmMember **ppMember);

//--------------------------------------------------------------------------
// IInternalSysInfoObj

	STDMETHOD(SetID)(DWORD ID)	  { m_dwID = ID;   return S_OK; }

/////////////////////////////////////////////////////////////////////////////////
// IMarshal methods

    STDMETHOD(GetUnmarshalClass)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID *pCid) { *pCid = CLSID_NmSysInfo; return S_OK; };

    STDMETHOD(GetMarshalSizeMax)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize) { *pSize = sizeof(ULONG); return S_OK; }

    STDMETHOD(MarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags) 
			{ 
				// Since we don't know the endian-ness of the other side,
				// we use a private wire format for custom marshaling here.
				//
				BYTE buf[sizeof(DWORD)];
				BYTE * pByte = buf;
				*pByte++ = (BYTE)(m_dwID);
				*pByte++ = (BYTE)(m_dwID >> 8);
				*pByte++ = (BYTE)(m_dwID >> 16);
				*pByte++ = (BYTE)(m_dwID >> 24);

				pStm->Write(buf, sizeof(buf), NULL);

				return S_OK; 
			}

    STDMETHOD(UnmarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv)
			{
				// Since we don't know the endian-ness of the other side,
				// we use a private wire format for custom marshaling here.
				//
				BYTE buf[sizeof(DWORD)];
				pStm->Read(buf, sizeof(buf), NULL);

				BYTE * pByte = buf;

				m_dwID = (DWORD)(*pByte++);
				m_dwID += (DWORD)(*pByte++ << 8);
				m_dwID += (DWORD)(*pByte++ << 16);
				m_dwID += (DWORD)(*pByte++ << 24);

				return QueryInterface(riid, ppv);
			}

    STDMETHOD(ReleaseMarshalData)(
            /* [unique][in] */ IStream *pStm) { return S_OK; }

    STDMETHOD(DisconnectObject)(
            /* [in] */ DWORD dwReserved) { return S_OK; }

///////////////////////////////////////////////
// Notifications and callbacks
public:

///////////////////////////////////////////////
// Helper Fns

	HRESULT _EnsureConfHook(void);
	static bool GetKeyDataForProp(NM_SYSPROP uProp, HKEY * phkey, LPTSTR * ppszSubKey, LPTSTR * ppszValue, bool *pfString);

private:
	static void _GetSzKeyForGuid(LPTSTR psz, REFGUID rguid);
};


#endif // __NmSysInfo_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\siglobal.h ===
/* ----------------------------------------------------------------------

	Copyright (c) 1995-1996, Microsoft Corporation
	All rights reserved

	siGlobal.h

  ---------------------------------------------------------------------- */

#ifndef GLOBAL_H
#define GLOBAL_H

//-------------------------------------------------------
// Useful macros

#define ARRAY_ELEMENTS(rg)   (sizeof(rg) / sizeof((rg)[0]))
#define ARRAYSIZE(x)         (sizeof(x)/sizeof(x[0]))

//-------------------------------------------------------
// Function Prototypes


#ifdef DEBUG  /* These are only avaible for debug */
VOID InitDebug(void);
VOID DeInitDebug(void);
#endif /* DEBUG */

#ifdef DEBUG
extern HDBGZONE ghZoneApi;
#define ZONE_API_WARN_FLAG   0x01
#define ZONE_API_EVENT_FLAG  0x02
#define ZONE_API_TRACE_FLAG  0x04
#define ZONE_API_DATA_FLAG   0x08
#define ZONE_API_OBJ_FLAG    0x10
#define ZONE_API_REF_FLAG    0x20

UINT DbgApiWarn(PCSTR pszFormat,...);
UINT DbgApiEvent(PCSTR pszFormat,...);
UINT DbgApiTrace(PCSTR pszFormat,...);
UINT DbgApiData(PCSTR pszFormat,...);

#define DBGAPI_WARN   (!IS_ZONE_ENABLED(ghZoneApi, ZONE_API_WARN_FLAG))  ? 0 : DbgApiWarn
#define DBGAPI_EVENT  (!IS_ZONE_ENABLED(ghZoneApi, ZONE_API_EVENT_FLAG)) ? 0 : DbgApiEvent
#define DBGAPI_TRACE  (!IS_ZONE_ENABLED(ghZoneApi, ZONE_API_TRACE_FLAG)) ? 0 : DbgApiTrace
#define DBGAPI_DATA   (!IS_ZONE_ENABLED(ghZoneApi, ZONE_API_DATA_FLAG))  ? 0 : DbgApiData

#define DBGAPI_REF    (!IS_ZONE_ENABLED(ghZoneApi, ZONE_API_REF_FLAG))   ? 0 : DbgApiTrace
#define DBGAPI_OBJ    (!IS_ZONE_ENABLED(ghZoneApi, ZONE_API_OBJ_FLAG))   ? 0 : DbgApiTrace
#else
inline void WINAPI DbgMsgApi(LPCTSTR, ...) { }
#define DBGAPI_WARN   1 ? (void)0 : ::DbgMsgApi
#define DBGAPI_EVENT  1 ? (void)0 : ::DbgMsgApi
#define DBGAPI_TRACE  1 ? (void)0 : ::DbgMsgApi
#define DBGAPI_DATA   1 ? (void)0 : ::DbgMsgApi
#define DBGAPI_REF    1 ? (void)0 : ::DbgMsgApi
#define DBGAPI_OBJ    1 ? (void)0 : ::DbgMsgApi
#endif

/////////////////////////////////
// Global Variables


extern HINSTANCE g_hInst;

#endif /* GLOBAL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\nmsysinfo.cpp ===
#include "precomp.h"
#include "version.h"
#include "nacguids.h"
#include "RegEntry.h"
#include "ConfReg.h"
#include "NmSysInfo.h"
#include "capflags.h"

#define SZ_YES 	_T("1")
#define SZ_NO	_T("0")	


/*  B  S  T  R _ T O _  L  P  T  S  T  R  */
/*-------------------------------------------------------------------------
    %%Function: BSTR_to_LPTSTR

-------------------------------------------------------------------------*/
HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr)
{
#ifndef UNICODE
	// compute the length of the required BSTR
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
		return E_FAIL;

	// cch is the number of BYTES required, including the null terminator
	*ppsz = (LPTSTR) new char[cch];
	if (*ppsz == NULL)
		return E_OUTOFMEMORY;

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, *ppsz, cch, NULL, NULL);
	return S_OK;
#else
	return E_NOTIMPL;
#endif // UNICODE
}



//
//  Hack alert:
//  
//      The follwoing system property constant is used to inform
//  the Netmeeting Manager object that the caller is Whistler
//  RTC client so that it can take some actions for performance
//  purpose, i.e. don't poll A/V capabilities and don't do
//  ILS logon.
//
//  This value MUST NOT collide with the NM_SYSPROP_Consts defined
//  in imsconf3.idl
//
#define NM_SYSPROP_CALLERISRTC 300

///////////////////////////////////////////////
// Init and construction methods
///////////////////////////////////////////////

HRESULT CNmSysInfoObj::FinalConstruct()
{	
	DBGENTRY(CNmSysInfoObj::FinalConstruct);
	HRESULT hr = S_OK;

	m_dwID = 0;

	DBGEXIT_HR(CNmSysInfoObj::FinalConstruct,hr);
	return hr;
}


void CNmSysInfoObj::FinalRelease()
{
	DBGENTRY(CNmSysInfoObj::FinalRelease);
	
	m_spConfHook = NULL;

	DBGEXIT(CNmSysInfoObj::FinalRelease);
}

///////////////////////////////////////////////
// INmSysInfo2 methods
///////////////////////////////////////////////

STDMETHODIMP CNmSysInfoObj::IsInstalled(void)
{
	DBGENTRY(CNmSysInfoObj::IsInstalled);
	HRESULT hr = S_OK;
	TCHAR sz[MAX_PATH];

		// Fail if not a valid installation directory
	if (GetInstallDirectory(sz) && FDirExists(sz))
	{
			// Validate ULS entries
		RegEntry reUls(ISAPI_KEY "\\" REGKEY_USERDETAILS, HKEY_CURRENT_USER);
		LPTSTR psz;

		hr = NM_E_NOT_INITIALIZED;
		psz = reUls.GetString(REGVAL_ULS_EMAIL_NAME);
		if (lstrlen(psz))
		{
			psz = reUls.GetString(REGVAL_ULS_RES_NAME);
			{

				RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

				// check to see if the wizard has been run in UI mode
				DWORD dwVersion = reConf.GetNumber(REGVAL_WIZARD_VERSION_UI, 0);
				BOOL fForceWizard = (VER_PRODUCTVERSION_DW != dwVersion);
				if (fForceWizard)
				{
					// the wizard has not been run in UI mode, check to see if its been run in NOUI mode
					dwVersion = reConf.GetNumber(REGVAL_WIZARD_VERSION_NOUI, 0);
					fForceWizard = (VER_PRODUCTVERSION_DW != dwVersion);
				}

				if (fForceWizard)
				{
					hr = S_FALSE;  // Wizard has never been run
				}
				else
				{
					hr = S_OK;
				}
			}
		}
	}
	else
	{
		hr = E_FAIL;
	}

	DBGEXIT_HR(CNmSysInfoObj::IsInstalled,hr);
	return hr;
}

STDMETHODIMP CNmSysInfoObj::GetProperty(NM_SYSPROP uProp, BSTR *pbstrProp)
{
	DBGENTRY(CNmSysInfoObj::GetProperty);

	HRESULT hr = S_OK;

	if(pbstrProp)
	{
		switch (uProp)
		{
			case NM_SYSPROP_BUILD_VER:
				*pbstrProp = T2BSTR(VER_PRODUCTVERSION_STR);
				break;

			case NM_SYSPROP_LOGGED_ON:
				_EnsureConfHook();
				if(m_spConfHook)
				{
					*pbstrProp = T2BSTR((S_OK == m_spConfHook->LoggedIn()) ? SZ_YES : SZ_NO);
				}
				break;

			case NM_SYSPROP_IS_RUNNING:
				_EnsureConfHook();
				if(m_spConfHook)
				{
					*pbstrProp = T2BSTR((S_OK == m_spConfHook->IsRunning()) ? SZ_YES : SZ_NO);
				}
				break;

			case NM_SYSPROP_IN_CONFERENCE:
				_EnsureConfHook();
				if(m_spConfHook)
				{
					*pbstrProp = T2BSTR((S_OK == m_spConfHook->InConference()) ? SZ_YES : SZ_NO);
				}
				break;

			case NM_SYSPROP_USER_CITY:
			case NM_SYSPROP_USER_COUNTRY:
			case NM_SYSPROP_USER_CATEGORY:
				*pbstrProp = T2BSTR((""));
				break;

			case NM_SYSPROP_ICA_ENABLE:
				*pbstrProp = T2BSTR(("0"));
				break;

			default:
			{
				HKEY   hkey;
				LPTSTR pszSubKey;
				LPTSTR pszValue;
				bool   fString;
				TCHAR  sz[MAX_PATH];

				if(GetKeyDataForProp(uProp, &hkey, &pszSubKey, &pszValue, &fString))
				{
					RegEntry re(pszSubKey, hkey);
					if (fString)
					{
						*pbstrProp = T2BSTR(re.GetString(pszValue));
					}
					else
					{
						DWORD dw = re.GetNumber(pszValue, 0);
						wsprintf(sz, "%d", dw);
						*pbstrProp = T2BSTR(sz);
						break;
					}
				}
				else
				{
					pbstrProp = NULL;
					hr = E_INVALIDARG;
				}
			}
		}
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmSysInfoObj::GetProperty,hr);
	return hr;
}

STDMETHODIMP CNmSysInfoObj::SetProperty(NM_SYSPROP uProp, BSTR bstrName)
{
	DBGENTRY(CNmSysInfoObj::SetProperty);

	HRESULT hr = S_OK;
	LPTSTR  psz;
       LPTSTR  szName= NULL;

	if(FAILED(BSTR_to_LPTSTR (&szName, bstrName)))
	{
	    return E_FAIL;
	}

	if( bstrName )
	{
		// Special processing for new NM 2.x functions
		switch (uProp)
		{
			case NM_SYSPROP_LOGGED_ON:
			{

				_EnsureConfHook();
				if(m_spConfHook)
				{
					if(0 == lstrcmp(SZ_YES,szName))
					{
						m_spConfHook->LDAPLogon(TRUE);
					}
					else
					{
						m_spConfHook->LDAPLogon(FALSE);
					}
				}

				break;
			}
			
			case NM_SYSPROP_DISABLE_H323:
			{
				_EnsureConfHook();

				if(m_spConfHook)
				{
					hr = m_spConfHook->DisableH323(0 == lstrcmp(SZ_YES,szName));
				}
			}
				break;

			case NM_SYSPROP_DISABLE_INITIAL_ILS_LOGON:
			{
				_EnsureConfHook();

				if(m_spConfHook)
				{
					hr = m_spConfHook->DisableInitialILSLogon(0 == lstrcmp(SZ_YES,szName));
				}

			}
				break;

			case NM_SYSPROP_CALLERISRTC:
			{
				_EnsureConfHook();

				if(m_spConfHook)
				{
					hr = m_spConfHook->SetCallerIsRTC(0 == lstrcmp(SZ_YES,szName));
				}
			}
				break;

			case NM_SYSPROP_ICA_ENABLE:
			case NM_SYSPROP_USER_CITY:
			case NM_SYSPROP_USER_COUNTRY:
			case NM_SYSPROP_USER_CATEGORY:
			case NM_SYSPROP_USER_LOCATION:
				// We don't support these properties anymore
				hr = S_OK;
				break;

			case NM_SYSPROP_WB_HELPFILE:
			case NM_SYSPROP_CB_HELPFILE:
			{	
					// We don't use these anymare
				hr = S_OK;
				break;
			}

			default:
			{
				LPTSTR  pszSubKey;
				LPTSTR  pszValue;
				bool    fString;
				HKEY    hkey;

				if(GetKeyDataForProp(uProp, &hkey, &pszSubKey, &pszValue, &fString))
				{
					RegEntry re(pszSubKey, hkey);

					if (fString)
					{
						if (0 != re.SetValue(pszValue, szName))
						{
							hr = E_UNEXPECTED;
						}
					}
					else
					{
						DWORD dw = DecimalStringToUINT(szName);
						if (0 != re.SetValue(pszValue, dw))
						{
							hr = E_UNEXPECTED;
						}
					}
				}
				else
				{
					hr = E_INVALIDARG;
				}
				break;
			}
		}
	}
	else
	{
		hr = E_INVALIDARG;
	}

        delete szName;

	DBGEXIT_HR(CNmSysInfoObj::SetProperty,hr);
	return hr;
}

STDMETHODIMP CNmSysInfoObj::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	HRESULT hr = E_FAIL;

	_EnsureConfHook();

	if(m_spConfHook)
	{
		return m_spConfHook->GetUserData(rguid, ppb, pcb);
	}

	return hr;
}

STDMETHODIMP CNmSysInfoObj::SetUserData(REFGUID rguid, BYTE *pb, ULONG cb)
{
	HRESULT hr = E_FAIL;

	_EnsureConfHook();

	if(m_spConfHook)
	{
		return m_spConfHook->SetUserData(rguid, pb, cb);
	}

	return hr;
}

STDMETHODIMP CNmSysInfoObj::GetNmApp(REFGUID rguid,BSTR *pbstrApplication, BSTR *pbstrCommandLine, BSTR *pbstrDirectory)
{
	HRESULT hr = S_OK;
	DBGENTRY(CNmSysInfoObj::GetNmApp);
	bool bErr = FALSE;
	TCHAR szKey[MAX_PATH];

	// Validate parameters
	if ((!pbstrApplication) || (!IsBadWritePtr(pbstrApplication, sizeof(BSTR *))) &&
		(!pbstrCommandLine) || (!IsBadWritePtr(pbstrCommandLine, sizeof(BSTR *))) &&
		(!pbstrDirectory)   || (!IsBadWritePtr(pbstrDirectory,   sizeof(BSTR *))) )
	{
		
		_GetSzKeyForGuid(szKey, rguid);
		RegEntry re(szKey, HKEY_LOCAL_MACHINE);
		
		if(pbstrApplication)
		{
			*pbstrApplication = T2BSTR(re.GetString(REGVAL_GUID_APPNAME));
			if(NULL == *pbstrApplication)
			{
				bErr = true;
			}
		}
		if(pbstrCommandLine)
		{
			*pbstrCommandLine = T2BSTR(re.GetString(REGVAL_GUID_CMDLINE));
			if(NULL == *pbstrCommandLine)
			{
				bErr = true;
			}
		}
		if(pbstrDirectory)
		{
			*pbstrDirectory = T2BSTR(re.GetString(REGVAL_GUID_CURRDIR));
			if(NULL == *pbstrDirectory)
			{
				bErr = true;
			}
		}

		if(bErr)
		{
			if (NULL != pbstrApplication)
			{
				SysFreeString(*pbstrApplication);
				*pbstrApplication = NULL;
			}
			if (NULL != pbstrCommandLine)
			{
				SysFreeString(*pbstrCommandLine);
				*pbstrCommandLine = NULL;
			}
			if (NULL != pbstrDirectory)
			{
				SysFreeString(*pbstrDirectory);
				*pbstrDirectory = NULL;
			}
			hr = E_OUTOFMEMORY;
		}

	}
	else
	{
		hr = E_POINTER;
	}


	DBGEXIT_HR(CNmSysInfoObj::GetNmApp,hr);
	return hr;
}

STDMETHODIMP CNmSysInfoObj::SetNmApp(REFGUID rguid,BSTR bstrApplication, BSTR bstrCommandLine, BSTR bstrDirectory)
{
	HRESULT hr = S_OK;
	DBGENTRY(CNmSysInfoObj::SetNmApp);

	bool    bDeleteKey = TRUE;
	LPTSTR  psz = NULL;
	TCHAR   szKey[MAX_PATH];


       LPTSTR szApplication = NULL;
       LPTSTR szCommandLine = NULL;
       LPTSTR szDirectory = NULL;

	BSTR_to_LPTSTR (&szApplication, bstrApplication);				        
	BSTR_to_LPTSTR (&szCommandLine, bstrCommandLine);				        
	BSTR_to_LPTSTR (&szDirectory, bstrDirectory);				        

	_GetSzKeyForGuid(szKey, rguid);
	RegEntry re(szKey, HKEY_LOCAL_MACHINE);
	
	if(!bstrApplication)
	{
		re.DeleteValue(REGVAL_GUID_APPNAME);
	}
	else
	{
		if(szApplication)
		{
			re.SetValue(REGVAL_GUID_APPNAME, szApplication);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

		bDeleteKey = false;
	}
	
	if (NULL == bstrCommandLine)
	{
		re.DeleteValue(REGVAL_GUID_CMDLINE);
	}
	else
	{
		if(szCommandLine)
		{
			re.SetValue(REGVAL_GUID_CMDLINE, szCommandLine);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

		bDeleteKey = false;
	}

	if (NULL == bstrDirectory)
	{
		re.DeleteValue(REGVAL_GUID_CURRDIR);
	}
	else
	{	
		if(szDirectory)
		{
			re.SetValue(REGVAL_GUID_CURRDIR, szDirectory);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

		bDeleteKey = false;
	}

	if (bDeleteKey)
	{
		// All keys were NULL - delete the entire key
		RegEntry reApps(GUID_KEY, HKEY_LOCAL_MACHINE);
		GuidToSz((GUID *) &rguid, szKey);
		reApps.DeleteValue(szKey);
	}


       delete szApplication;
       delete szCommandLine;
       delete szDirectory;


	DBGEXIT_HR(CNmSysInfoObj::SetNmApp,hr);
	return hr;
}

STDMETHODIMP CNmSysInfoObj::GetNmchCaps(ULONG *pchCaps)
{
	DBGENTRY(CNmSysInfoObj::GetNmchCaps);
	HRESULT hr = S_OK;

	_EnsureConfHook();

	if(m_spConfHook)
	{
		if(pchCaps && !IsBadWritePtr(pchCaps, sizeof(ULONG *)))
		{
			ULONG nmch = NMCH_DATA;  // Always capable of data
			RegEntry re(POLICIES_KEY, HKEY_CURRENT_USER);

			if ((DEFAULT_POL_NO_FILETRANSFER_SEND == re.GetNumber(REGVAL_POL_NO_FILETRANSFER_SEND,
				 DEFAULT_POL_NO_FILETRANSFER_SEND)) &&
				(DEFAULT_POL_NO_FILETRANSFER_RECEIVE == re.GetNumber(REGVAL_POL_NO_FILETRANSFER_RECEIVE,
				 DEFAULT_POL_NO_FILETRANSFER_RECEIVE)) )
			{
				nmch |= NMCH_FT;
			}

			if (DEFAULT_POL_NO_APP_SHARING == re.GetNumber(REGVAL_POL_NO_APP_SHARING,
				DEFAULT_POL_NO_APP_SHARING))
			{
				nmch |= NMCH_SHARE;
			}

			if (DEFAULT_POL_NO_AUDIO == re.GetNumber(REGVAL_POL_NO_AUDIO,
				DEFAULT_POL_NO_AUDIO))
			{
				if(S_OK == m_spConfHook->IsNetMeetingRunning())
				{
					DWORD dwLocalCaps;
					if(SUCCEEDED(m_spConfHook->GetLocalCaps(&dwLocalCaps)) && (dwLocalCaps & CAPFLAG_SEND_AUDIO))
					{
						nmch |= NMCH_AUDIO;
					}
				}
			}

			if ((DEFAULT_POL_NO_VIDEO_SEND == re.GetNumber(REGVAL_POL_NO_VIDEO_SEND,
				 DEFAULT_POL_NO_VIDEO_SEND)) &&
				(DEFAULT_POL_NO_VIDEO_RECEIVE == re.GetNumber(REGVAL_POL_NO_VIDEO_RECEIVE,
				 DEFAULT_POL_NO_VIDEO_RECEIVE)) )
			{
				if(S_OK == m_spConfHook->IsNetMeetingRunning())
				{
					DWORD dwLocalCaps;
					if(SUCCEEDED(m_spConfHook->GetLocalCaps(&dwLocalCaps)) && (dwLocalCaps & CAPFLAG_SEND_VIDEO))
					{
						nmch |= NMCH_VIDEO;
					}
				}
			}

			*pchCaps = nmch;
		}
		else
		{
			hr = E_POINTER;
		}

		if(SUCCEEDED(hr))
		{
			hr = m_spConfHook->IsNetMeetingRunning();
		}
	}
	else
	{
		ERROR_OUT(("The confhook should be valid"));
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmSysInfoObj::GetNmchCaps,hr);
	return hr;
}

STDMETHODIMP CNmSysInfoObj::GetLaunchInfo(INmConference **ppConference, INmMember **ppMember)
{
	DBGENTRY(CNmSysInfoObj::GetLaunchInfo);
	HRESULT hr = S_OK;


	if(ppMember)
	{
		*ppMember = NULL;
	}

	if(ppConference)
	{
		*ppConference = NULL;
	}

	_EnsureConfHook();

	if(m_spConfHook)
	{			
		// If NetMeeting is not initialized, return NM_E_NOT_INITIALIZED
		hr = m_spConfHook->IsNetMeetingRunning();
		if(S_OK != hr) goto end;

		// If there is no default conference, return S_FALSE
		CComPtr<INmConference> spConf;
		hr = m_spConfHook->GetActiveConference(&spConf);
		if(S_OK != hr) goto end;

		// If the confID environment variable is not there, return S_FALSE
		TCHAR sz[MAX_PATH];
		if (0 == GetEnvironmentVariable(ENV_CONFID, sz, CCHMAX(sz)))
		{
			hr = S_FALSE;
			goto end;
		}

		// If the conference ID from the environment variable is not there, return S_FALSE
		DWORD dw = DecimalStringToUINT(sz);

		DWORD dwGCCConfID;

		if(SUCCEEDED(hr = spConf->GetID(&dwGCCConfID)))
		{
			if(dw != dwGCCConfID)
			{		
					// Conferenec does not exist anymore
				hr = S_FALSE;
				goto end;
			}

			// If the nodeID environment variable is note there, return S_FALSE
			if (0 == GetEnvironmentVariable(ENV_NODEID, sz, CCHMAX(sz)))
			{
				hr = S_FALSE;
				goto end;
			}

			// If ppMember is not NULL, fill it with a new SDKMember object from the nodeID
			if(ppMember)
			{	
				CComPtr<IInternalConferenceObj> spConfObj = com_cast<IInternalConferenceObj>(spConf);
				if(spConfObj)
				{
					hr = spConfObj->GetMemberFromNodeID(DecimalStringToUINT(sz), ppMember);
				}
				else
				{
					hr = E_UNEXPECTED;
					goto end;
				}
			}
	
			// If ppConferenec is not NULL, fill it with a new SDKMember object 
			if(ppConference)
			{	
				*ppConference = spConf;
				(*ppConference)->AddRef();
			}
		}
	}
	else
	{	
		hr = E_UNEXPECTED;
	}

end:

	DBGEXIT_HR(CNmSysInfoObj::GetLaunchInfo,hr);
	return hr;
}


///////////////////////////////////////////////
// Helper Fns
///////////////////////////////////////////////

/*static*/ bool CNmSysInfoObj::GetKeyDataForProp(NM_SYSPROP uProp, HKEY * phkey, LPTSTR * ppszSubKey, LPTSTR * ppszValue, bool *pfString)
{
	DBGENTRY(CNmSysInfoObj::GetKeyDataForProp);
	// Default to ULS registry key
	*phkey = HKEY_CURRENT_USER;
	*ppszSubKey = ISAPI_KEY "\\" REGKEY_USERDETAILS;
	*pfString = true;
	bool bRet = true;

	switch (uProp)
	{

		case NM_SYSPROP_EMAIL_NAME:    *ppszValue = REGVAL_ULS_EMAIL_NAME;    break;
		case NM_SYSPROP_SERVER_NAME:   *ppszValue = REGVAL_SERVERNAME;        break;
		case NM_SYSPROP_RESOLVE_NAME:  *ppszValue = REGVAL_ULS_RES_NAME;      break;
		case NM_SYSPROP_FIRST_NAME:    *ppszValue = REGVAL_ULS_FIRST_NAME;    break;
		case NM_SYSPROP_LAST_NAME:     *ppszValue = REGVAL_ULS_LAST_NAME;     break;
		case NM_SYSPROP_USER_NAME:     *ppszValue = REGVAL_ULS_NAME;          break;
		case NM_SYSPROP_USER_COMMENTS: *ppszValue = REGVAL_ULS_COMMENTS_NAME; break;
		case NM_SYSPROP_USER_CITY:     *ppszValue = REGVAL_ULS_LOCATION_NAME; break;

		case NM_SYSPROP_H323_GATEWAY:
			*ppszSubKey = AUDIO_KEY;
			*ppszValue = REGVAL_H323_GATEWAY;
			break;

		case NM_SYSPROP_H323_GATEWAY_ENABLE:
			*ppszSubKey = AUDIO_KEY;
			*ppszValue = REGVAL_USE_H323_GATEWAY;
			*pfString = FALSE;
			break;		

		case NM_SYSPROP_INSTALL_DIRECTORY:
			*phkey = HKEY_LOCAL_MACHINE;
			*ppszSubKey = CONFERENCING_KEY;
			*ppszValue = REGVAL_INSTALL_DIR;
			break;

		case NM_SYSPROP_APP_NAME:
			*phkey = HKEY_LOCAL_MACHINE;
			*ppszSubKey = CONFERENCING_KEY;
			*ppszValue = REGVAL_NC_NAME;
			break;

		default:
			WARNING_OUT(("GetKeyDataForProp - invalid argument %d", uProp));
			bRet = false;
			break;

	} /* switch (uProp) */

	DBGEXIT_BOOL(CNmSysInfoObj::GetKeyDataForProp,bRet ? TRUE : FALSE);
	return bRet;
}

/*static*/ void CNmSysInfoObj::_GetSzKeyForGuid(LPTSTR psz, REFGUID rguid)
{
	DBGENTRY(CNmSysInfoObj::_GetSzKeyForGuid);

	lstrcpy(psz, GUID_KEY "\\");
	GuidToSz((GUID *) &rguid, &psz[lstrlen(psz)]);

	DBGEXIT(CNmSysInfoObj::_GetSzKeyForGuid);
}

HRESULT CNmSysInfoObj::_EnsureConfHook(void)
{
	HRESULT hr = S_OK;

	if(!m_spConfHook)
	{
		hr = CoCreateInstance(CLSID_NmManager, NULL, CLSCTX_ALL, IID_IInternalConfExe, reinterpret_cast<void**>(&m_spConfHook));

		if(SUCCEEDED(hr))
		{
			m_spConfHook->SetSysInfoID(m_dwID);
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\precomp.h ===
// File: Precomp.h

// Standard Windows SDK includes
#include <windows.h>

#pragma warning( disable : 4786 )

    // default threading model
#define _ATL_APARTMENT_THREADED

// We should really only put this in for w2k
#define _ATL_NO_DEBUG_CRT

#define _ATL_NO_FORCE_LIBS

#if 0
	#define _ATL_DEBUG_QI
	#define _ATL_DEBUG_INTERFACES
	#define ATL_TRACE_LEVEL 4
#else
	#define ATL_TRACE_LEVEL 0
#endif

    // Our Override of ATLTRACE and other debug stuff
#include <ConfDbg.h>

// We should really only put this in for w2k
#define _ASSERTE(expr) ASSERT(expr)

    // ATLTRACE and other stuff
#include <atlbase.h>
#include <shellapi.h>


//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <limits.h>
#include <shlobj.h>
#include <shlwapi.h>

#include <debspew.h>
#include <confreg.h>
#include <oprahcom.h>
#include <regentry.h>
#include <cstring.hpp>
#include <oblist.h>
#include <dllutil.h>

// COM interfaces
//
#include <ConfCli.h>


#include "siGlobal.h"

#include "CLink.h"
#include "clRefCnt.hpp"
#include "clEnumFt.hpp"
class CConfLink;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\sidebug.cpp ===
/* ----------------------------------------------------------------------

	Copyright (c) 1996, Microsoft Corporation
	All rights reserved

	siDebug.c

  ---------------------------------------------------------------------- */

#include "precomp.h"

#ifdef DEBUG /* These functions are only available for DEBUG */


HDBGZONE ghZoneApi = NULL; // API zones
static PTCHAR _rgZonesApi[] = {
	TEXT("API"),
	TEXT("Warning"),
	TEXT("Events"),
	TEXT("Trace"),
	TEXT("Data"),
	TEXT("Objects"),
	TEXT("RefCount"),
};


VOID InitDebug(void)
{
	// Enable memory leak checking and keep freed memory blocks on the
	// heap's linked list (filled with 0xDD)
	//
	// This depends on the use of the debug c runtime library from VC++ 4.x
#if 0
	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
	tmpFlag |= (_CRTDBG_DELAY_FREE_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
	_CrtSetDbgFlag(tmpFlag);
	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW); // create a message box

//  To track down memory leaks, uncomment the following lines
	LONG cAlloc = 0; // Allocation number
	if (0 != cAlloc)
	{
		_CrtSetBreakAlloc(cAlloc);
	}
#endif // 0
	InitDebugModule(TEXT("MSCONF"));

	DBGINIT(&ghZoneApi, _rgZonesApi);
}

VOID DeInitDebug(void)
{
	DBGDEINIT(&ghZoneApi);
	ExitDebugModule();
}

UINT DbgApiWarn(PCSTR pszFormat,...)
{
	va_list v1;
	va_start(v1, pszFormat);
	DbgPrintf("API:Warning", pszFormat, v1);
	va_end(v1);
	return 0;
}

UINT DbgApiEvent(PCSTR pszFormat,...)
{
	va_list v1;
	va_start(v1, pszFormat);
	DbgPrintf("API:Event", pszFormat, v1);
	va_end(v1);
	return 0;
}

UINT DbgApiTrace(PCSTR pszFormat,...)
{
	va_list v1;
	va_start(v1, pszFormat);
	DbgPrintf("API:Trace", pszFormat, v1);
	va_end(v1);
	return 0;
}

UINT DbgApiData(PCSTR pszFormat,...)
{
	va_list v1;
	va_start(v1, pszFormat);
	DbgPrintf("API:Data", pszFormat, v1);
	va_end(v1);
	return 0;
}






#endif /* DEBUG - the whole file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\siload.cpp ===
#include "precomp.h"
#include "atlbase.h"

#include "resource.h"
#include "clcnflnk.hpp"
#include "launstub.h"

#define DISPLAYNAME_STRING _T( "+displayName=" )

void WINAPI NewMediaPhone(   HWND hwndParent,
							 HINSTANCE hinst,
							 PSTR pszCmdLine,
							 int nShowCmd)
{

	CULSLaunch_Stub MyLaunchStub;
	ULS_HTTP_RESP br;
	if(SUCCEEDED(MyLaunchStub.ParseUlsHttpRespFile(pszCmdLine, &br)))
	{
		long	l = lstrlen( br.szIPAddress ) + 1;		// We will always have an IP address

		if(br.pszUID)
		{
			l += lstrlen(DISPLAYNAME_STRING);
			l += lstrlen(br.pszUID);
		}

		LPTSTR sz = new TCHAR[l];

		if( sz != NULL )
		{
			lstrcpy( sz, br.szIPAddress );

			if(br.pszUID)
			{
				lstrcat( sz, DISPLAYNAME_STRING );
				lstrcat( sz, br.pszUID );
			}

			shellCallto(sz, true);
			delete [] sz;
		}

		MyLaunchStub.FreeUlsHttpResp(&br);
	}
}       


//--------------------------------------------------------------------------//
//	CallToProtocolHandler.													//
//--------------------------------------------------------------------------//
extern "C"
void
WINAPI
CallToProtocolHandler
(
	HWND		,//parent,
	HINSTANCE	,//instance,
	PSTR		commandLine,
	int			//cmdShow
){

	shellCallto( commandLine, true );

}	//	End of CallToProtocolHandler.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\applet.hpp ===
#ifndef _FILE_TRANSFER_APPLET_H_
#define _FILE_TRANSFER_APPLET_H_

#include <it120app.h>
#include "cntlist.h"
#include <gencontainers.h>

#define FT_SHUTDOWN_TIMEOUT         5000    // 5 seconds
#define FT_STARTUP_TIMEOUT          5000    // 5 seconds


class MBFTEngine;
class CEngineList : public CList
{
    DEFINE_CLIST(CEngineList, MBFTEngine*)
    MBFTEngine *FindByConfID(T120ConfID nConfID);
#ifdef ENABLE_HEARTBEAT_TIMER
    MBFTEngine *FindByTimerID(UINT_PTR nTimerID);
#endif
};

class CAppletWindow;
class CWindowList : public CList
{
    DEFINE_CLIST(CWindowList, CAppletWindow*)
};


class CConfList : public CList
{
    DEFINE_CLIST_(CConfList, T120ConfID)
};


class CFtHiddenWindow : public CGenWindow
{
public:
    CFtHiddenWindow() {}

    BOOL Create();

    virtual ~CFtHiddenWindow() {}

protected:
    virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
};


class CFileTransferApplet
{
public:

    CFileTransferApplet(HRESULT *);
    ~CFileTransferApplet(void);

    IT120Applet *GetAppletSAP(void) { return m_pAppletSAP; }

    void RegisterEngine(MBFTEngine *p);
    void UnregisterEngine(MBFTEngine *p);
    MBFTEngine * FindEngineWithNoIntf(void);
	MBFTEngine * FindEngineWithIntf(void);

    void RegisterWindow(CAppletWindow *pWindow);
    void UnregisterWindow(CAppletWindow *pWindow);
    CAppletWindow *GetUnattendedWindow(void);

    CWindowList *GetWindowList(void) { return &m_WindowList; }

    T120Error CreateAppletSession(IT120AppletSession **pp, T120ConfID nConfID)
    {
        return m_pAppletSAP->CreateSession(pp, nConfID);
    }

    MBFTEngine *FindEngineByTimerID(UINT_PTR nTimerID) { return m_EngineList.FindByTimerID(nTimerID); }

    void T120Callback(T120AppletMsg *);

    BOOL QueryShutdown(BOOL fGoAheadShutdown);
	CAppletWindow *GetMainUI(void) { m_WindowList.Reset();  return m_WindowList.Iterate(); }
	LRESULT BringUIToFront(void);
    BOOL    Has2xNodeInConf(void);
	BOOL	InConf(void);
	BOOL	HasSDK(void);
	HWND	GetHiddenWnd(void) { return m_pHwndHidden->GetWindow(); }

private:

    IT120Applet    *m_pAppletSAP;
    CEngineList     m_EngineList;
    CConfList       m_UnattendedConfList;
    CWindowList     m_WindowList;
	CFtHiddenWindow	*m_pHwndHidden;			// hidden window for processing MBFTMSG
};


extern CFileTransferApplet *g_pFileXferApplet;

#endif // _FILE_TRANSFER_APPLET_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\ulp.h ===
//--------------------------------------------------------------------------
//
// Module Name:  ULP.H
//
// Brief Description:  This module contains declarations for the MS Internet
//                     User Location Protocol.
//
// Author:  Kent Settle (kentse)
// Created: 22-Mar-1996
//
// Copyright (c) 1996 Microsoft Corporation
//
//--------------------------------------------------------------------------

#ifndef ULP_H
#define ULP_H

#include <pshpack1.h> /* Assume 1 byte packing throughout */

#define MAX_MIME_TYPE_LENGTH        32  // need to be changed later
#define SIZEOF_MIME_TYPE            (MAX_MIME_TYPE_LENGTH * sizeof (TCHAR))
#define MAX_NM_APP_ID				32
#define MAX_PROTOCOL_ID				32

// ULP opcodes.

#define ULP_OPCODE_CLIENT_REG		0	// register client.
#define ULP_OPCODE_CLIENT_UNREG		1	// unregister client.
#define ULP_OPCODE_APP_REG			2	// register app.
#define ULP_OPCODE_APP_UNREG		3	// unregister app.
#define ULP_OPCODE_RESOLVE			4	// resolve name.
#define ULP_OPCODE_DIRECTORY		5	// directory query.
#define ULP_OPCODE_KEEPALIVE		6	// keepalive record.
#define ULP_OPCODE_SETPROPS			7	// set properties.
#define ULP_OPCODE_RESOLVE_EX		8	// expanded resolve.
#define ULP_OPCODE_APP_REG_EX		9	// expanded register app.
#define ULP_OPCODE_DIRECTORY_EX		10	// expanded directory.

// return codes.

#define ULP_RCODE_SUCCESS				0
#define ULP_RCODE_SERVER_ERROR			1
#define ULP_RCODE_REFUSED				2
#define ULP_RCODE_CONFLICT				3
#define ULP_RCODE_NAME_NOT_FOUND		4
#define ULP_RCODE_APP_NOT_FOUND			5
#define ULP_RCODE_INCORRECT_VERSION		6
#define ULP_RCODE_CLIENT_NOT_FOUND		7
#define ULP_RCODE_CLIENT_NEED_RELOGON	8
#define ULP_RCODE_INVALID_PARAMETER		9
#define ULP_RCODE_NEED_APPLICATION_ID	10

// ULP flags.

#define ULP_FLAG_PUBLISH		0x01	// show in directory.

// default TTL value.

#define ULP_TTL_DEFAULT			10		// ten minutes.

// ULP protocol version.  the version number is in 5.3 format.  that is
// 5 bits of major version, and 3 bits of minor version.

#define ULP_VERSION					0x04		// version 1.0.
#define ULP_MAJOR_VERSION_MASK		0xF8
#define ULP_MINOR_VERSION_MASK		0x07

// version macros.

#define ULP_GET_MAJOR_VERSION(ver)	(((ver) & ULP_MAJOR_VERSION_MASK) >> 3)
#define ULP_GET_MINOR_VERSION(ver)	((ver) & ULP_MINOR_VERSION_MASK)
#define ULP_MAKE_VERSION(maj, min)	(((maj) << 3) |		\
									((min) & ULP_MINOR_VERSION_MASK))

// structures.

typedef struct _ULP_PROP
{
	DWORD		dwPropertyTag;
	BYTE		Value[1];
} ULP_PROP;

typedef struct _ULP_PROPERTY_ARRAY
{
	DWORD		dwTotalSize;
	DWORD		dwVariableSize;
	DWORD		dwPropCount;
	ULP_PROP	Properties[1];
} ULP_PROPERTY_ARRAY;

typedef struct _ULP_CLIENT_REGISTER
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	WORD		wFlags;
	WORD		wCRP;
	DWORD		dwLastClientSig;
	DWORD		dwIPAddress;
	BYTE		bData[1];
} ULP_CLIENT_REGISTER;

typedef struct _ULP_CLIENT_REG_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
	HANDLE		hClient;
	DWORD		dwClientSig;
} ULP_CLIENT_REG_RESPONSE;

typedef struct _ULP_CLIENT_UNREGISTER
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	HANDLE		hClient;
	DWORD		dwClientSig;
} ULP_CLIENT_UNREGISTER;

typedef struct _ULP_CLIENT_UNREG_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
} ULP_CLIENT_UNREG_RESPONSE;

typedef 	struct _ULP_CLIENT_KEEPALIVE
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	HANDLE		hClient;
	DWORD		dwClientSig;
	DWORD       dwIPAddress;
} ULP_CLIENT_KEEPALIVE;

typedef struct _ULP_KEEPALIVE_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
	WORD		wNewCRP;
	DWORD		dwReserved;
} ULP_KEEPALIVE_RESPONSE;
#define ULP_KA_RESERVED		((DWORD) 0xFFF98052)

typedef  struct _ULP_APP_REGISTER
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	HANDLE		hClient;
	GUID		ApplicationID;
	GUID		ProtocolID;
	WORD		wPort;
	BYTE		bData[1];
} ULP_APP_REGISTER;

typedef  struct _ULP_APP_REGISTER_EX
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	HANDLE		hClient;
	WORD		wPort;
	BYTE		bData[1];
	// appid
	// appmime
	// protid
	// protmime
	// PROPERTIES
} ULP_APP_REGISTER_EX;

typedef struct _ULP_APP_REGISTER_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
	HANDLE		hApplication;
} ULP_APP_REGISTER_RESPONSE;

typedef  struct _ULP_APP_UNREGISTER
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	HANDLE		hApplication;
	HANDLE		hClient;
	DWORD		dwClientSig;
} ULP_APP_UNREGISTER;

typedef struct _ULP_APP_UNREG_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
} ULP_APP_UNREG_RESPONSE;

typedef struct _ULP_SETPROP
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	HANDLE		hClient;
	HANDLE		hApplication;
	DWORD		dwClientSig;
	BYTE		bData[1];
} ULP_SETPROP;

typedef struct _ULP_SETPROP_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
} ULP_SETPROP_RESPONSE;

typedef  struct _ULP_RESOLVE
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	GUID		ApplicationID;
	BYTE		bData[1];
} ULP_RESOLVE;

typedef struct _ULP_RESOLVE_EX
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	BYTE		bData[1];
	// appid
	// protid
	// OTHERS
} ULP_RESOLVE_EX;

typedef struct _ULP_RESOLVE_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	DWORD		dwIPAddress;
	WORD		wPort;
	BYTE		bData[1];
} ULP_RESOLVE_RESPONSE;

typedef struct _ULP_DIRECTORY
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	GUID		ApplicationID;
	GUID		ProtocolID;
	DWORD		dwFilterSize;
	WORD		wNextNameCount;
	BYTE		bData[1];
} ULP_DIRECTORY;

typedef struct _ULP_DIRECTORY_EX
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	DWORD		dwFilterSize;
	WORD		wNextNameCount;
	BYTE		bData[1];
} ULP_DIRECTORY_EX;

typedef struct _ULP_DIRECTORY_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	DWORD		dwMatchesReturned;
	BYTE		bData[1];
} ULP_DIRECTORY_RESPONSE;

#include <poppack.h> /* End byte packing */

#endif // ULP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\ulsapi.h ===
//--------------------------------------------------------------------------
//
// Module Name:  ULSAPI.H
//
// Brief Description:
//		This module contains declarations for all COM style APIs
//		of ULS Client.
//
// Author:  Chu, Lon-Chan (lonchanc)
//
// Copyright (c) 1996 Microsoft Corporation
//
//--------------------------------------------------------------------------


#ifndef _ULSAPI_H_
#define _ULSAPI_H_

#include <winnt.h>
#include <basetyps.h>	// IUnknown & IClassFactory
#include <mapidefs.h>
#include "ulserror.h"
#include "ulstags.h"
#include "ulp.h"

#ifdef IN
#undef IN
#endif
#define IN		

#ifdef OUT
#undef OUT
#endif
#define OUT		

// client specific definitions. (in between stub and service)
#define CLIENT_MESSAGE_ID_LOGON             1
#define CLIENT_MESSAGE_ID_LOGOFF            2
#define CLIENT_MESSAGE_ID_RESOLVE           3
#define CLIENT_MESSAGE_ID_DIRECTORY         4
#define CLIENT_MESSAGE_ID_KEEPALIVE         5


// define ULS Client version
#ifndef ULS_VERSION
#define ULS_VERSION		MAKELONG (1, 1)		// version 1.1
#endif


#define ULS_MAX_GUID_LENGTH			16
#define ULS_MAX_IP_ADDR_LENGTH		20

// window messages
#define ULS_MSG_DIRECTORY_UI		0x5001
#define ULS_MSG_LAUNCH		  		0x5002


#define ULS_DEFAULT_CRP				2 // refresh period 2 minutes, Internal, BUGS BUGS


/* ----- ULS_F_* (common flags) ------ */

#define ULS_F_ASYNC					0x10000000UL
#define ULS_F_CONN_EXISTS			0x20000000UL	// use existing connection


/* ----- ULSLOGON_F_* (logon flags) ------ */

#define ULSREG_F_PUBLISH			0x00000001UL	// indicates server publishes client's name (also used in PR_ULS_MODE)
#define ULSREG_F_REGISTER			0x00000010UL	// register objects
#define ULSREG_F_UNREGISTER			0x00000020UL	// unregister objects


/* ----- ULSRESOLVE_F_* (resolve flags) ------ */


/* ----- ULSDIR_F_* (directory flags) ------ */

#define ULSDIR_F_DEF_PROPS			0x00000400UL	// indicates default properties to retrieve
#define ULSDIR_F_LAST_SERVER		0x00000800UL	// indicates using the server in registry


/* ----- ULSCONF_F_* ------ */

#define ULSCONF_F_PUBLISH			0X00000001UL
#define ULSCONF_F_SERVER_NAME		0X00000002UL
#define ULSCONF_F_FIRST_NAME		0X00000004UL
#define ULSCONF_F_EMAIL_NAME		0X00000008UL
#define ULSCONF_F_LAST_NAME			0X00000010UL
#define ULSCONF_F_CITY				0X00000020UL
#define ULSCONF_F_COUNTRY			0X00000040UL
#define ULSCONF_F_COMMENTS			0X00000080UL
#define ULSCONF_F_USER_NAME			0x00000100UL

#define ULSCONF_F_DEF_SERVER_NAME	0X00001000UL // use default uls.microsoft.com


/* ----- ULSWIZ_F_* ------ */

#define ULSWIZ_F_SHOW_BACK			0X00010000UL
#define ULSWIZ_F_NO_FINISH			0X00020000UL


/* ----- ULSQUERYPROVIDER_F_* ------ */

#define ULSQUERYPROVIDER_F_ALL		0x00000001UL
#define ULSQUERYPROVIDER_F_ENABLED	0x00000002UL
#define ULSQUERYPROVIDER_F_DISABLED	0x00000004UL


/* ------ common handle types ------ */

typedef PVOID	ULS_HCONN;			// handle of connection
typedef PVOID	ULS_HOBJECT;		// handle of object
typedef PVOID	ULS_HASYNC;			// handle of async operation
typedef WCHAR	ULS_GUID_W[ULS_MAX_GUID_LENGTH];
typedef CHAR	ULS_GUID_A[ULS_MAX_GUID_LENGTH];


/* ----- ULS_OBJECT_TYPE ------ */

typedef enum
{
	ULSOBJECT_PERSON,
	ULSOBJECT_APPLICATION,
	ULSOBJECT_PROTOCOL,
	ULSOBJECT_CONFERENCE,
	ULSOBJECT_ALIAS_TO_PERSON,
	ULSOBJECT_ALIAS_TO_CONFERENCE,
}
	ULS_OBJECT_TYPE;


/* ------ async callback procedures ------ */

typedef HRESULT (WINAPI *ULS_SIMPLE_CB) (
							IN		ULS_HASYNC hAsyncReq,
							IN		LPARAM lParamCB,
							IN		HRESULT hr,
							IN		DWORD dwResult );

/* ------ ULS_CONN ------ */

typedef struct tag_ULS_CONN_INFO_W
{
	DWORD		dwFlags;
	ULONG		nTimeout;
	PWSTR		pszServerName;
	PWSTR		pszUlsBase;		// eg. "c=US, o=Microsoft, ou=ULS"
	PWSTR		pszUserName;	// if NULL, the client puts default
	PWSTR		pszPassword;	// if NULL, the client puts default
}
	ULS_CONN_INFO_W;

typedef struct tag_ULS_CONN_INFO_A
{
	DWORD		dwFlags;
	ULONG		nTimeout;
	PSTR		pszServerName;
	PSTR		pszUlsBase;		// eg. "c=US, o=Microsoft, ou=ULS"
	PSTR		pszUserName;	// if NULL, the client puts default
	PSTR		pszPassword;	// if NULL, the client puts default
}
	ULS_CONN_INFO_A;

#ifdef UNICODE
typedef ULS_CONN_INFO_W		ULS_CONN_INFO;
#else
typedef ULS_CONN_INFO_A		ULS_CONN_INFO;
#endif


/* ------ ULS_CONN_REQ ------ */

typedef struct tag_ULS_CONN_REQ_W
{
	DWORD			dwFlags;
	ULS_CONN_INFO_W	ConnInfo;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_CONN_REQ_W;

typedef struct tag_ULS_CONN_REQ_A
{
	DWORD			dwFlags;
	ULS_CONN_INFO_A	ConnInfo;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_CONN_REQ_A;

#ifdef UNICODE
typedef ULS_CONN_REQ_W		ULS_CONN_REQ;
#else
typedef ULS_CONN_REQ_A		ULS_CONN_REQ;
#endif


/* ------ ULS_DISCONN_REQ ------ */

typedef struct tag_ULS_DISCONN_REQ_W
{
	DWORD			dwFlags;
	ULS_HCONN		hConn;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_DISCONN_REQ_W;

typedef struct tag_ULS_DISCONN_REQ_A
{
	DWORD			dwFlags;
	ULS_HCONN		hConn;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_DISCONN_REQ_A;

#ifdef UNICODE
typedef ULS_DISCONN_REQ_W		ULS_DISCONN_REQ;
#else
typedef ULS_DISCONN_REQ_A		ULS_DISCONN_REQ;
#endif


/* ------ ULS_REG_REQ ------ */

typedef struct tag_ULS_REG_REQ_W
{
	DWORD			dwFlags;	// 32-bit flags.
	ULS_HCONN		hConn;		// handle to connection to server
	ULS_CONN_INFO_W	ConnInfo;
	ULS_HOBJECT		hObject1;	// first level object
	ULS_HOBJECT		hObject2;	// second level object
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM 			lParamCB;	// 32-bit callback parameter
}
	ULS_REG_REQ_W;
	
typedef struct tag_ULS_REG_REQ_A
{
	DWORD			dwFlags;	// 32-bit flags.
	ULS_HCONN		hConnect;	// handle to connection to server
	ULS_CONN_INFO_A	ConnInfo;
	ULS_HOBJECT		hObject1;	// first level object
	ULS_HOBJECT		hObject2;	// second level object
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_REG_REQ_A;

#ifdef UNICODE
typedef ULS_REG_REQ_W		ULS_REG_REQ;
#else
typedef ULS_REG_REQ_A		ULS_REG_REQ;
#endif


/* ------ ULS_RESOLVE_REQ ------ */

typedef struct tag_ULS_RESOLVE_REQ_W
{
	DWORD			dwFlags;
	ULS_OBJECT_TYPE	ObjectType;
	PWSTR			pszObject1Uid;
	PWSTR			pszObject2Uid;
	ULONG			cPropTags;
	PDWORD			pdwPropTags;
	ULS_HCONN		hConn;
	ULS_CONN_INFO_W	ConnInfo;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_RESOLVE_REQ_W;

typedef struct tag_ULS_RESOLVE_REQ_A
{
	DWORD			dwFlags;
	ULS_OBJECT_TYPE	ObjectType;
	PSTR			pszObject1Uid;
	PSTR			pszObject2Uid;
	ULONG			cPropTags;
	PDWORD			pdwPropTags;
	ULS_HCONN		hConn;
	ULS_CONN_INFO_A	ConnInfo;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_RESOLVE_REQ_A;

#ifdef UNICODE
typedef ULS_RESOLVE_REQ_W		ULS_RESOLVE_REQ;
#else
typedef ULS_RESOLVE_REQ_A		ULS_RESOLVE_REQ;
#endif


/* ------ ULS_DIR_REQ ------ */

typedef struct tag_ULS_DIR_REQ_W
{
	DWORD			dwFlags;
	ULS_OBJECT_TYPE	ObjectType;
	PWSTR			pszFilter;
	PWSTR			pszToMatch;
	ULONG			cPropTags;
	PDWORD			pdwPropTags;
	ULS_HCONN		hConn;
	ULS_CONN_INFO_W	ConnInfo;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_DIR_REQ_W;

typedef struct tag_ULS_DIR_REQ_A
{
	DWORD			dwFlags;
	ULS_OBJECT_TYPE	ObjectType;
	PSTR			pszFilter;
	PSTR			pszToMatch;
	ULONG			cPropTags;
	PDWORD			pdwPropTags;
	ULS_HCONN		hConn;
	ULS_CONN_INFO_A	ConnInfo;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_DIR_REQ_A;

#ifdef UNICODE
typedef ULS_DIR_REQ_W		ULS_DIR_REQ;
#else
typedef ULS_DIR_REQ_A		ULS_DIR_REQ;
#endif


/* ------ ULS_DIR_UNIT ------ */

typedef struct tag_ULS_DIR_UNIT_W
{
	ULONG		cProps;
	SPropValue	*pProps;
}
	ULS_DIR_UNIT_W;

typedef ULS_DIR_UNIT_W		ULS_DIR_UNIT_A;

#ifdef UNICODE
typedef ULS_DIR_UNIT_W		ULS_DIR_UNIT;
#else
typedef ULS_DIR_UNIT_A		ULS_DIR_UNIT;
#endif


/* ------ ULS_DIR_RESULT ------ */

typedef struct tag_ULS_DIR_RESULT_W
{
	ULONG			cbSize;
	ULONG			cEntries;
	ULS_DIR_UNIT_W	audeiEntries[1];
}
	ULS_DIR_RESULT_W;

typedef ULS_DIR_RESULT_W		ULS_DIR_RESULT_A;

#ifdef UNICODE
typedef ULS_DIR_RESULT_W		ULS_DIR_RESULT;
#else
typedef ULS_DIR_RESULT_A		ULS_DIR_RESULT;
#endif


/* ------ ULS_ASYNC_DIR_RESULT ------ */

typedef struct tag_ULS_ASYNC_DIR_RESULT_W
{
	ULONG			cbSize;
	ULONG			cTotalEntries;
	ULONG			cbTotalDataSize;
	ULONG			nFirstEntry;
	ULONG			cEntriess;
	ULS_DIR_UNIT_W	audeiEntries[1];
}
	ULS_ASYNC_DIR_RESULT_W;

typedef struct tag_ULS_ASYNC_DIR_RESULT_A
{
	ULONG			cbSize;
	ULONG			nFirstEntry;
	ULONG			cEntriess;
	ULS_DIR_UNIT_A	audeiEntries[1];
}
	ULS_ASYNC_DIR_RESULT_A;

#ifdef UNICODE
typedef ULS_ASYNC_DIR_RESULT_W		ULS_ASYNC_DIR_RESULT;
#else
typedef ULS_ASYNC_DIR_RESULT_A		ULS_ASYNC_DIR_RESULT;
#endif


/* ------ ULS_CONF ------ */

// same as INTERNET_MAX_USER_NAME_LENGTH in wininet.h.
#define ULS_MAX_UID_LENGTH		  	256
#define ULS_MAX_SERVER_NAME_LENGTH	128
#define ULS_MAX_FIRST_NAME_LENGTH	128
#define ULS_MAX_LAST_NAME_LENGTH	128
#define ULS_MAX_EMAIL_NAME_LENGTH	128
#define ULS_MAX_CITY_NAME_LENGTH	128
#define ULS_MAX_COUNTRY_NAME_LENGTH	128
#define ULS_MAX_COMMENTS_LENGTH		256
#define ULS_MAX_CLNTSTRING_LENGTH	256 //max of above
//SS: username is concatenated first name with last name with space in between
#define ULS_MAX_USER_NAME_LENGTH	(ULS_MAX_FIRST_NAME_LENGTH + ULS_MAX_LAST_NAME_LENGTH)
#define	UI_COMMENTS_LENGTH			60	// ;Internal BUGS BUGS to remove

#define MAX_IP_ADDRESS_STRING_LENGTH    20

typedef struct tagULS_HTTP_RESP
{
    ULONG   cbSize;
    ULONG   nCmdId;
    HRESULT hr;
    ULONG   nPort;
    DWORD   dwAppSession;
    DWORD   dwClientSession;
    DWORD   dwClientId;
    CHAR    *pszUID;
    CHAR    *pszURL;
    CHAR    szIPAddress[MAX_IP_ADDRESS_STRING_LENGTH];
    CHAR    szMimeType[MAX_MIME_TYPE_LENGTH];
    CHAR    szAppMime[MAX_MIME_TYPE_LENGTH];
    CHAR    szProtMime[MAX_MIME_TYPE_LENGTH];
    CHAR    szAppId[MAX_NM_APP_ID];
    CHAR    szProtId[MAX_PROTOCOL_ID];
    ULONG   nApps;
}
    ULS_HTTP_RESP;

/* ------ ULS_PROVIDER_INFO ------ */

#define ULS_MAX_PROVIDER_COMPANY_NAME_LENGTH		64
#define ULS_MAX_PROVIDER_PRODUCT_NAME_LENGTH		64
#define ULS_MAX_PROVIDER_PROTOCOL_NAME_LENGTH		16

typedef struct tag_ULS_PROVIDER_INFO_W
{
	ULONG	cbSize;
	DWORD	dwVersion;	// hiword major; loword minor
	ULONG	nProviderId; // created by the uls client, valid only in this process
	WCHAR	szCompanyName[ULS_MAX_PROVIDER_COMPANY_NAME_LENGTH];
	WCHAR	szProductName[ULS_MAX_PROVIDER_PRODUCT_NAME_LENGTH];
	WCHAR	szProtocolName[ULS_MAX_PROVIDER_PROTOCOL_NAME_LENGTH];
}
	ULS_PROVIDER_INFO_W;

typedef struct tag_ULS_PROVIDER_INFO_A
{
	ULONG	cbSize;
	DWORD	dwVersion;	// hiword major; loword minor
	ULONG	nProviderId; // created by the uls client, valid only in this process
	CHAR	szCompanyName[ULS_MAX_PROVIDER_COMPANY_NAME_LENGTH];
	CHAR	szProductName[ULS_MAX_PROVIDER_PRODUCT_NAME_LENGTH];
	CHAR	szProtocolName[ULS_MAX_PROVIDER_PROTOCOL_NAME_LENGTH];
}
	ULS_PROVIDER_INFO_A;

#ifdef UNICODE
typedef ULS_PROVIDER_INFO_W		ULS_PROVIDER_INFO;
#else
typedef ULS_PROVIDER_INFO_A		ULS_PROVIDER_INFO;
#endif


#endif // _ULSAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\applet.cpp ===
#include "mbftpch.h"
#include <it120app.h>
#include <regentry.h>
#include <iappldr.h>
#include <version.h>


HINSTANCE g_hDllInst;
DWORD g_dwWorkThreadID = 0;
HANDLE g_hWorkThread = NULL;
CFileTransferApplet *g_pFileXferApplet = NULL;
CRITICAL_SECTION     g_csWorkThread;
TCHAR g_szMBFTWndClassName[32];
const TCHAR g_cszFtHiddenWndClassName[] = _TEXT("FtHiddenWindow");

extern CFtLoader *g_pFtLoader;
extern T120Error CALLBACK CreateAppletLoaderInterface(IAppletLoader**);


BOOL    g_fSendAllowed = FALSE;
BOOL    g_fRecvAllowed = FALSE;
UINT_PTR    g_cbMaxSendFileSize = 0;
BOOL    g_fShutdownByT120 = FALSE;

// Local functions
void ReadSettingsFromRegistry(void);
void BuildAppletCapabilities(void);
void BuildDefaultAppletSessionKey(void);


DWORD __stdcall FTWorkThreadProc(LPVOID lpv);


#define FT_VERSION_STR	"MS FT Version"
OSTR FT_VERSION_ID = {sizeof(FT_VERSION_STR), (unsigned char*)FT_VERSION_STR};


BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID lpv)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hDllInst = hDllInst;
        ::DisableThreadLibraryCalls(hDllInst);
        InitDebug();
        DBG_INIT_MEMORY_TRACKING(hDllInst);
        ::InitializeCriticalSection(&g_csWorkThread);
        ::wsprintf(&g_szMBFTWndClassName[0], TEXT("MBFTWnd%0X_%0X"), ::GetCurrentProcessId(), ::GetTickCount());
        ASSERT(::lstrlenA(&g_szMBFTWndClassName[0]) < sizeof(g_szMBFTWndClassName));
        ::BuildAppletCapabilities();
        ::BuildDefaultAppletSessionKey();
        TRACE_OUT(("*** MSCONFFT.DLL: Attached process thread %X", GetCurrentThreadId()));
        ::T120_AppletStatus(APPLET_ID_FT, APPLET_LIBRARY_LOADED);
        break;

    case DLL_PROCESS_DETACH:
        TRACE_OUT(("*** NMFT.DLL: Detaching process thread %X", GetCurrentThreadId()));
        if (NULL != g_hWorkThread)
        {
            ::CloseHandle(g_hWorkThread);
        }
        ::T120_AppletStatus(APPLET_ID_FT, APPLET_LIBRARY_FREED);
        ::DeleteCriticalSection(&g_csWorkThread);
        DBG_CHECK_MEMORY_TRACKING(hDllInst);
        DeInitDebugMbft();
        break;

    default:
        break;
    }
    return TRUE;
}


HRESULT WINAPI FT_CreateInterface(IMbftControl **ppMbft, IMbftEvents *pEvents)
{
    HRESULT hr;

    if (NULL != ppMbft && NULL != pEvents)
    {
        if (NULL != g_pFileXferApplet)
        {
            ReadSettingsFromRegistry();

            DBG_SAVE_FILE_LINE
            MBFTInterface *pObject = new MBFTInterface(pEvents, &hr);
            if (NULL != pObject)
            {
                if (S_OK == hr)
    			{
                    *ppMbft = (IMbftControl *) pObject;
                    return S_OK;
    			}

                ERROR_OUT(("CreateMbftObject: cannot create MBFTInterface"));
                pObject->Release();
                *ppMbft = NULL;
                return hr;
            }

            ERROR_OUT(("CreateMbftObject: cannot allocate MBFTInterface"));
            return E_OUTOFMEMORY;
        }

        WARNING_OUT(("CreateMbftObject: applet object is not created"));
    }
    else
    {
        ERROR_OUT(("CreateMbftObject: invalid pointer, ppMbft=0x%x, pEvents=0x%x", ppMbft, pEvents));
    }
    return E_POINTER;
}


void CALLBACK FileXferAppletCallback
(
    T120AppletMsg   *pMsg
)
{
    CFileTransferApplet *pThisApplet = (CFileTransferApplet *) pMsg->pAppletContext;
    if (pThisApplet == g_pFileXferApplet && NULL != g_pFileXferApplet)
    {
        pThisApplet->T120Callback(pMsg);
    }
}


BOOL CFtHiddenWindow::Create(void)
{
    return(CGenWindow::Create(NULL, NULL,
                               WS_POPUP, // not visible!
                               0,
                               0, 0, 0, 0,
                               g_hDllInst,
                               NULL,
                               g_cszFtHiddenWndClassName
                                ));
}


CFileTransferApplet::CFileTransferApplet(HRESULT *pHr)
:	m_pHwndHidden(NULL)
{
    T120Error rc = ::T120_CreateAppletSAP(&m_pAppletSAP);
	if (T120_NO_ERROR == rc)
	{
	    m_pAppletSAP->Advise(FileXferAppletCallback, this);
	    *pHr = S_OK;
	}
	else
	{
		ERROR_OUT(("CFileTransferApplet::CFileTransferApplet: cannot create app sap, rc=%u", rc));
		*pHr = E_OUTOFMEMORY;
	}

	// Create Hidden Window for processing MBFTMSG
    DBG_SAVE_FILE_LINE
	m_pHwndHidden = new CFtHiddenWindow();
	if (m_pHwndHidden)
	{
		*pHr = (m_pHwndHidden->Create())?S_OK:E_FAIL;
	}
	else
	{
		*pHr = E_OUTOFMEMORY;
	}
}


CFileTransferApplet::~CFileTransferApplet(void)
{
    m_EngineList.Clear();

    CAppletWindow *pWindow;
    while (NULL != (pWindow = m_WindowList.Get()))
    {
        pWindow->Release(); // add ref while being put to the list
        pWindow->OnExit();
    }

    if (NULL != m_pAppletSAP)
    {
        m_pAppletSAP->ReleaseInterface();
    }

	if (NULL != m_pHwndHidden)
	{
		HWND hwndHidden = m_pHwndHidden->GetWindow();
		DestroyWindow(hwndHidden);
		m_pHwndHidden->Release();
		m_pHwndHidden = NULL;
	}
}


BOOL CFileTransferApplet::QueryShutdown(BOOL fGoAheadShutdown)
{
    CAppletWindow *pWindow;
    m_WindowList.Reset();
    while (NULL != (pWindow = m_WindowList.Iterate()))
    {
        if (! pWindow->QueryShutdown(fGoAheadShutdown))
        {
            return FALSE; // do not shut down now
        }
    }
    return TRUE;
}


void CFileTransferApplet::T120Callback
(
    T120AppletMsg   *pMsg
)
{
    switch (pMsg->eMsgType)
    {
    case GCC_PERMIT_TO_ENROLL_INDICATION:
        {
            MBFTEngine *pEngine = m_EngineList.FindByConfID(pMsg->PermitToEnrollInd.nConfID);
            if (NULL == pEngine)
            {
                pEngine = m_EngineList.FindByConfID(0);
                if (NULL == pEngine)
                {
                    if (pMsg->PermitToEnrollInd.fPermissionGranted)
                    {
                        DBG_SAVE_FILE_LINE
                        pEngine = new MBFTEngine(NULL, MBFT_STATIC_MODE, _iMBFT_DEFAULT_SESSION);
                        ASSERT(NULL != pEngine);
                    }
                }
            }
            if (NULL != pEngine)
            {
                pEngine->OnPermitToEnrollIndication(&pMsg->PermitToEnrollInd);
            }

            // deal with unattended conference
            if (pMsg->PermitToEnrollInd.fPermissionGranted)
            {
                if (NULL == pEngine)
                {
                    m_UnattendedConfList.Append(pMsg->PermitToEnrollInd.nConfID);
                }
            }
            else
            {
                m_UnattendedConfList.Remove(pMsg->PermitToEnrollInd.nConfID);
            }
        }
        break;

    case T120_JOIN_SESSION_CONFIRM:
        break;

    default:
        ERROR_OUT(("CFileTransferApplet::T120Callback: unknown t120 msg type=%u", pMsg->eMsgType));
        break;
    }
}


void CFileTransferApplet::RegisterEngine(MBFTEngine *p)
{
    m_EngineList.Append(p);

    // relay any unattended conference
    if (! m_UnattendedConfList.IsEmpty())
    {
        GCCAppPermissionToEnrollInd Ind;
        Ind.nConfID = m_UnattendedConfList.Get();
        Ind.fPermissionGranted = TRUE;
        p->OnPermitToEnrollIndication(&Ind);
    }
}

void CFileTransferApplet::UnregisterEngine(MBFTEngine *p)
{
    if (m_EngineList.Remove(p))
    {
        CAppletWindow *pWindow;
        m_WindowList.Reset();
        while (NULL != (pWindow = m_WindowList.Iterate()))
        {
            if (pWindow->GetEngine() == p)
            {
                pWindow->UnregisterEngine();
                break;
            }
        }

        p->Release(); // AddRef in MBFTEngine()
    }
}


MBFTEngine * CFileTransferApplet::FindEngineWithIntf(void)
{
    MBFTEngine *pEngine;
    m_EngineList.Reset();
    while (NULL != (pEngine = m_EngineList.Iterate()))
    {
        if (pEngine->GetInterfacePointer())
        {
            break;
        }
    }
    return pEngine;
}

MBFTEngine * CFileTransferApplet::FindEngineWithNoIntf(void)
{
    MBFTEngine *pEngine;
    m_EngineList.Reset();
    while (NULL != (pEngine = m_EngineList.Iterate()))
    {
        if (! pEngine->GetInterfacePointer())
        {
            break;
        }
    }
    return pEngine;
}


void CFileTransferApplet::RegisterWindow(CAppletWindow *pWindow)
{
    pWindow->AddRef();
    m_WindowList.Append(pWindow);

    if (1 == m_WindowList.GetCount() && 1 == m_EngineList.GetCount())
    {
        MBFTEngine *pEngine = m_EngineList.PeekHead();
        pWindow->RegisterEngine(pEngine);
        pEngine->SetWindow(pWindow);
		pEngine->AddAllPeers();
    }
}

void CFileTransferApplet::UnregisterWindow(CAppletWindow *pWindow)
{
    if (m_WindowList.Remove(pWindow))
    {
        pWindow->Release();
    }

    if (m_WindowList.IsEmpty())
    {
        g_fNoUI = FALSE;

        ::T120_AppletStatus(APPLET_ID_FT, APPLET_CLOSING);

        BOOL fRet = ::PostMessage(GetHiddenWnd(), WM_QUIT, 0, 0);
        ASSERT(fRet);
    }
}


CAppletWindow *CFileTransferApplet::GetUnattendedWindow(void)
{
    CAppletWindow *pWindow;
    m_WindowList.Reset();
    while (NULL != (pWindow = m_WindowList.Iterate()))
    {
        if (! pWindow->IsInConference())
        {
            return pWindow;
        }
    }
    return NULL;
}

LRESULT CFileTransferApplet::BringUIToFront(void)
{
    CAppletWindow *pWindow;
	if (m_WindowList.IsEmpty())
    {
        // The g_pFileXferApplet was created by fNoUI == TRUE,
        // Now we need to create the UI
        HRESULT hr;
        DBG_SAVE_FILE_LINE
        pWindow = new CAppletWindow(g_fNoUI, &hr);
        if (NULL != pWindow)
        {
            if (S_OK != hr)
            {
                ERROR_OUT(("BringUIToFrong: cannot create CAppletWindow"));
                pWindow->Release();
                pWindow = NULL;
            }
            else
	     {
                g_pFileXferApplet->RegisterWindow(pWindow);
            }
            
        }
        else
        {
            ERROR_OUT(("FTBringUIToFrong: cannot allocate CAppletWindow"));
            hr = E_OUTOFMEMORY;
        }
    }
    m_WindowList.Reset();
    while (NULL != (pWindow = m_WindowList.Iterate()))
    {
		pWindow->BringToFront();
	}
	return 0;
}

BOOL CFileTransferApplet::Has2xNodeInConf(void)
{
    MBFTEngine *pEngine;
    m_EngineList.Reset();
    while (NULL != (pEngine = m_EngineList.Iterate()))
    {
        if (pEngine->Has2xNodeInConf())
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CFileTransferApplet::InConf(void)
{
    MBFTEngine *pEngine;
    m_EngineList.Reset();
    while (NULL != (pEngine = m_EngineList.Iterate()))
    {
        if (pEngine->GetPeerCount() > 1)
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CFileTransferApplet::HasSDK(void)
{
    MBFTEngine *pEngine;
    m_EngineList.Reset();
    while (NULL != (pEngine = m_EngineList.Iterate()))
    {
        if (pEngine->HasSDK())
        {
            return TRUE;
        }
    }
    return FALSE;
}

MBFTEngine * CEngineList::FindByConfID(T120ConfID nConfID)
{
    MBFTEngine *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (nConfID == p->GetConfID())
        {
            return p;
        }
    }
    return NULL;
}


#ifdef ENABLE_HEARTBEAT_TIMER
MBFTEngine * CEngineList::FindByTimerID(UINT_PTR nTimerID)
{
    MBFTEngine *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (nTimerID == p->GetTimerID())
        {
            return p;
        }
    }
    return NULL;
}
#endif


//
// File Transfer Capabilities
//

static GCCAppCap s_CapArray[4];
const GCCAppCap* g_aAppletCaps[4] = { &s_CapArray[0], &s_CapArray[1], &s_CapArray[2], &s_CapArray[3] };

static GCCNonCollCap s_NCCapArray[2];
const GCCNonCollCap* g_aAppletNonCollCaps[2] = { &s_NCCapArray[0], &s_NCCapArray[1] };

static const OSTR s_AppData[2] =
    {
        {
            sizeof(PROSHARE_STRING) + sizeof(MY_APP_STR),
            (LPBYTE) PROSHARE_STRING "\0" MY_APP_STR
        },
        {
            sizeof(PROSHARE_FILE_END_STRING),
            (LPBYTE) PROSHARE_FILE_END_STRING
        },
    };


void BuildAppletCapabilities(void)
{
    //
    // Capabilities
    //

	//Say that we can handle a max. of 4GBs...
	s_CapArray[0].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
	s_CapArray[0].capability_id.standard_capability = _MBFT_MAX_FILE_SIZE_ID;
	s_CapArray[0].capability_class.eType = GCC_UNSIGNED_MAXIMUM_CAPABILITY;
	s_CapArray[0].capability_class.nMinOrMax = _iMBFT_MAX_FILE_SIZE;
	s_CapArray[0].number_of_entities = 0;

	//And that we can handle only about 25K of data per
	//FileData PDU
	s_CapArray[1].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
	s_CapArray[1].capability_id.standard_capability = _MBFT_MAX_DATA_PAYLOAD_ID;
	s_CapArray[1].capability_class.eType = GCC_UNSIGNED_MAXIMUM_CAPABILITY;
	s_CapArray[1].capability_class.nMinOrMax = _iMBFT_MAX_FILEDATA_PDU_LENGTH;
	s_CapArray[1].number_of_entities = 0;

	//and that we don't support V.42..
	s_CapArray[2].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
	s_CapArray[2].capability_id.standard_capability = _MBFT_V42_COMPRESSION_ID;
	s_CapArray[2].capability_class.eType = GCC_LOGICAL_CAPABILITY;
	s_CapArray[2].capability_class.nMinOrMax = 0;
	s_CapArray[2].number_of_entities = 0;

	//Tell other node about this node's version number
	s_CapArray[3].capability_id.capability_id_type = GCC_NON_STANDARD_CAPABILITY;
	s_CapArray[3].capability_id.non_standard_capability.key_type = GCC_H221_NONSTANDARD_KEY;
	s_CapArray[3].capability_id.non_standard_capability.h221_non_standard_id = FT_VERSION_ID;
	//s_CapArray[3].capability_id.non_standard_capability.h221_non_standard_id.value = (unsigned char *)FT_VERSION_ID;
	s_CapArray[3].capability_class.eType = GCC_UNSIGNED_MINIMUM_CAPABILITY;
	s_CapArray[3].capability_class.nMinOrMax = VER_PRODUCTVERSION_DW;
	s_CapArray[3].number_of_entities = 0;

	//
    // Non-Collapsed Capabilities
    //

	s_NCCapArray[0].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
	s_NCCapArray[0].capability_id.standard_capability = _iMBFT_FIRST_PROSHARE_CAPABILITY_ID;
	s_NCCapArray[0].application_data = (OSTR *) &s_AppData[0];

	s_NCCapArray[1].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
	s_NCCapArray[1].capability_id.standard_capability = _iMBFT_PROSHARE_FILE_EOF_ACK_ID;
	s_NCCapArray[1].application_data = (OSTR *) &s_AppData[1];
}


GCCSessionKey g_AppletSessionKey;
static ULONG s_MBFTKeyNodes[] = {0,0,20,127,0,1};

void BuildDefaultAppletSessionKey(void)
{
    ::ZeroMemory(&g_AppletSessionKey, sizeof(g_AppletSessionKey)); // SessionID is zero
    g_AppletSessionKey.application_protocol_key.key_type = GCC_OBJECT_KEY;
    g_AppletSessionKey.application_protocol_key.object_id.long_string = s_MBFTKeyNodes;
    g_AppletSessionKey.application_protocol_key.object_id.long_string_length = sizeof(s_MBFTKeyNodes) / sizeof(s_MBFTKeyNodes[0]);
}




void ReadSettingsFromRegistry(void)
{
    static BOOL s_fReadAlready = FALSE;

    if (! s_fReadAlready)
    {
        s_fReadAlready = TRUE;

        RegEntry rePolicies(POLICIES_KEY, HKEY_CURRENT_USER);

        g_fSendAllowed = (0 == rePolicies.GetNumber(REGVAL_POL_NO_FILETRANSFER_SEND,
                                                    DEFAULT_POL_NO_FILETRANSFER_SEND));
        g_fRecvAllowed = (0 == rePolicies.GetNumber(REGVAL_POL_NO_FILETRANSFER_RECEIVE,
                                                    DEFAULT_POL_NO_FILETRANSFER_RECEIVE));
        g_cbMaxSendFileSize = rePolicies.GetNumber(REGVAL_POL_MAX_SENDFILESIZE,
                                                   DEFAULT_POL_MAX_FILE_SIZE);

        // initialize the delays
        RegEntry reFt(FILEXFER_KEY, HKEY_CURRENT_USER);
        g_nSendDisbandDelay = reFt.GetNumber(REGVAL_FILEXFER_DISBAND, g_nSendDisbandDelay);
        g_nChannelResponseDelay = reFt.GetNumber(REGVAL_FILEXFER_CH_RESPONSE, g_nChannelResponseDelay);
    }
}


/////////////////////////////////////////////////////////////////
//
//  Hidden windows procedure
//

LRESULT CFtHiddenWindow::ProcessMessage(HWND hwnd, UINT uMsg,
										WPARAM wParam, LPARAM lParam)
{
    LRESULT rc = T120_NO_ERROR;
	MBFTEngine *pEngine = (MBFTEngine *) lParam;
	MBFTMsg *pMsg = (MBFTMsg *) wParam;
	MBFTInterface *pIntf;

	switch(uMsg)
	{
	case WM_BRING_TO_FRONT:
		g_pFileXferApplet->BringUIToFront();
		break;
	
	case MBFTMSG_CREATE_ENGINE:
        pIntf = (MBFTInterface *) lParam;
        pEngine = g_pFileXferApplet->FindEngineWithNoIntf();
        if (NULL == pEngine)
        {
            DBG_SAVE_FILE_LINE
            pEngine = new MBFTEngine(NULL, MBFT_STATIC_MODE, _iMBFT_DEFAULT_SESSION);
            ASSERT(NULL != pEngine);
        }
        if (NULL != pEngine)
        {
            pIntf->SetEngine(pEngine);
            pEngine->SetInterfacePointer(pIntf);
        }
        ::SetEvent((HANDLE) wParam);
		break;

	case MBFTMSG_DELETE_ENGINE:
        ASSERT(NULL != g_pFileXferApplet);
        pIntf = pEngine->GetInterfacePointer();
        g_pFileXferApplet->UnregisterEngine(pEngine);
        break;

    case MBFTMSG_HEART_BEAT:
        pEngine->DoStateMachine(NULL);
        break;

    case MBFTMSG_BASIC:
        ASSERT(NULL != pMsg);
        if (pEngine->DoStateMachine(pMsg))
        {
            delete pMsg;
            pEngine->Release();
        }
        else
        {
            // put it back to the queue
            ::PostMessage(g_pFileXferApplet->GetHiddenWnd(), uMsg, wParam, lParam);
        }
        break;

	default:
		return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return FALSE;
}


DWORD __stdcall FTWorkThreadProc(LPVOID lpv)
{
    HRESULT hr;
	CAppletWindow *pAppletWnd;

    // allocate the applet object first
    DBG_SAVE_FILE_LINE
    g_pFileXferApplet = new CFileTransferApplet(&hr);

	::SetEvent((HANDLE) lpv); // signaling that the work hread has been started

    if (NULL != g_pFileXferApplet)
    {
        if (S_OK == hr)
        {
            // CAppletWindow's constructor will register itself to g_pFileXferApplet
            DBG_SAVE_FILE_LINE
            CAppletWindow *pWindow = new CAppletWindow(g_fNoUI, &hr);
            if (NULL != pWindow)
            {
                if (S_OK != hr)
                {
                    ERROR_OUT(("FTWorkThreadProc: cannot create CAppletWindow"));
                    pWindow->Release();
                    pWindow = NULL;
                }
                else
		 {
                    g_pFileXferApplet->RegisterWindow(pWindow);
               }
            }
            else
            {
                ERROR_OUT(("FTWorkThreadProc: cannot allocate CAppletWindow"));
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            ERROR_OUT(("FTWorkThreadProc: cannot create CFileTransferApplet"));
            delete g_pFileXferApplet;
            g_pFileXferApplet = NULL;
        }
    }
    else
    {
        ERROR_OUT(("FTWorkThreadProc: cannot allocate CFileTransferApplet"));
        hr = E_OUTOFMEMORY;
    }

    ::T120_AppletStatus(APPLET_ID_FT, APPLET_WORK_THREAD_STARTED);

    // the work thread loop
    if (S_OK == hr)
    {
		::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

        MSG msg;
        while (::GetMessage(&msg, NULL, 0, 0))
        {
            ::EnterCriticalSection(&g_csWorkThread);

			pAppletWnd = g_pFileXferApplet->GetMainUI();	
			if (!pAppletWnd || !pAppletWnd->FilterMessage(&msg))
			{
				::TranslateMessage(&msg);
				::DispatchMessage(&msg);
            }

            ::LeaveCriticalSection(&g_csWorkThread);
        }
	
		CGenWindow::DeleteStandardPalette();
		delete g_pFileXferApplet;
		g_pFileXferApplet = NULL;

		::CoUninitialize();
    }

    ::T120_AppletStatus(APPLET_ID_FT, APPLET_WORK_THREAD_EXITED);

    g_dwWorkThreadID = 0;

    if (! g_fShutdownByT120)
    {
		// Wait for other dependent threads to finish their work
		::Sleep(100);
        ::FreeLibraryAndExitThread(g_hDllInst, 0);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\ulserror.h ===
//--------------------------------------------------------------------------
//
// Module Name:  ULSERROR.H
//
// Brief Description:  This module contains declarations for the MS Internet
//                     User Location Service error codes.
//
// Author:  Kent Settle (kentse)
// Created: 27-Feb-1996
//
// Copyright (c) 1996 Microsoft Corporation
//
//--------------------------------------------------------------------------


#ifndef _ULSERROR_H_
#define _ULSERROR_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

// HRESULTS

#define FACILITY_ULS			0x321		// random, sort of.
#define ULS_HR(x)				MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ULS, x)

#define ULS_SUCCESS				NOERROR
#define ULS_E_INVALID_POINTER	E_POINTER
#define ULS_E_OUTOFMEMORY		E_OUTOFMEMORY
#define ULS_E_INVALID_HANDLE	E_HANDLE
#define ULS_E_NOINTERFACE		E_NOINTERFACE // interface not supported.
#define ULS_E_THREAD_FAILURE	ULS_HR(1)	// thread creation failed.
#define ULS_E_NO_SERVER		ULS_HR(2)	// server connection failed.
#define ULS_E_ERROR_ON_SERVER	ULS_HR(3)	// generic error on server.
#define ULS_E_INVALID_PROPERTY	ULS_HR(4)	// invalid user property.
#define ULS_E_INVALID_PARAMETER	ULS_HR(5)	// invalid parameter.
#define ULS_E_IO_ERROR			ULS_HR(6)	// device io (such as disk) failed
#define ULS_E_INVALID_FORMAT	ULS_HR(7)	// invalid format.
#define ULS_E_REGISTRY			ULS_HR(8)	// registry error.
#define ULS_E_PROCESS			ULS_HR(9)	// process creation error.
#define ULS_E_SOCKET_FAILURE	ULS_HR(10)	// socket failure.
#define ULS_E_NAME_NOT_FOUND	ULS_HR(11)	// could not resolve name.
#define ULS_E_REFUSED_BY_SERVER ULS_HR(12)	// server refused the request.
#define ULS_E_DUP_ENTRY			ULS_HR(13)	// already exists in database.
#define ULS_E_APP_NOT_FOUND		ULS_HR(14)	// specified app not found.
#define ULS_E_INVALID_VERSION	ULS_HR(15)	// client version invalid.
#define ULS_E_CLIENT_NOT_FOUND	ULS_HR(16)	// specified client not found.
#define ULS_E_UNKNOWN			ULS_HR(17)	// unknown error on client.
#define ULS_E_WIZARD			ULS_HR(18)	// wizard error.
#define ULS_E_EVENT_FAILURE		ULS_HR(19)	// CreateEvent failed.
#define ULS_E_QUEUE_CORRUPT		ULS_HR(20)	// read queue corrupted.
#define ULS_E_MUTEX			ULS_HR(21)	// mutex creation error.
#define ULS_E_OLD_TIMEOUT		ULS_HR(22)	// timeout
#define ULS_E_LOGON_CANCEL		ULS_HR(23)	// cancel in failure/retry dialog
#define ULS_E_CLIENT_NEED_RELOGON	ULS_HR(24)	// client needs to relogon (server crashes and comes up again)
#define ULS_E_NEED_SERVER_NAME  ULS_HR(25)	// missing server name in logon
#define ULS_E_NO_PROPERTY		ULS_HR(26)	// no such property
#define ULS_E_NOT_LOGON_YET		ULS_HR(27)	// save change before logon
#define ULS_E_INVALID_NAME      ULS_HR(28)  // name contains invalid characters
#define ULS_E_OUT_OF_SOCKET     ULS_HR(29)  // too many sockets used
#define ULS_E_OUT_OF_DATA       ULS_HR(30)  // data underflow
#define ULS_E_NETWORK          	ULS_HR(31)  // network is down, somehow


#define ULS_W_DATA_NOT_READY    MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ULS, 101)



#include <poppack.h> /* End byte packing */

#endif // _ULSERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\asn1hdr.h ===
#ifndef ASN1HDR
#define ASN1HDR



typedef char ossBoolean;

typedef char Nulltype;

typedef struct {
  short          year;         /* YYYY format when used for GeneralizedTime */
                               /* YY format when used for UTCTime */
  short          month;
  short          day;
  short          hour;
  short          minute;
  short          second;
  short          millisec;
  short          mindiff;          /* UTC +/- minute differential     */  
  ossBoolean        utc;              /* TRUE means UTC time             */  
} GeneralizedTime; 

typedef GeneralizedTime UTCTime;

typedef struct {
  int            pduNum;
  long           length;           /* length of encoded */
  void          *encoded;
  void          *decoded;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
  void          *userField;
#endif
} OpenType;

enum MixedReal_kind {OSS_BINARY, OSS_DECIMAL};

typedef struct {
  enum MixedReal_kind kind;
  union {
      double base2;
      char  *base10;
  } u;
} MixedReal;

typedef struct ObjectSetEntry {
  struct ObjectSetEntry *next;
  void                  *object;
} ObjectSetEntry; 

#endif     /* #ifndef ASN1HDR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\simain.cpp ===
/* ----------------------------------------------------------------------

	Copyright (c) 1995-1996, Microsoft Corporation
	All rights reserved

	siMain.cpp - main Scrapi Interface

	Routines to interface with calling application.
  ---------------------------------------------------------------------- */

#include "precomp.h"
#include "clcnflnk.hpp"
#include "version.h"


// SDK stuff
#include "NmApp.h"				// To register CLSID_NetMeeting
#include "NmSysInfo.h"			// For CNmSysInfoObj
#include "SDKInternal.h"		// For NmManager, etc.
#include "MarshalableTI.h"		// For Marshalable Type Info


// Global variable definitions (local to each instance)
HINSTANCE  g_hInst        = NULL;    // This dll's instance


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_NetMeeting, CNetMeetingObj)
	OBJECT_ENTRY(CLSID_NmSysInfo, CNmSysInfoObj)
	OBJECT_ENTRY(CLSID_NmManager, CNmManagerObj)
	OBJECT_ENTRY(CLSID_MarshalableTI, CMarshalableTI)
END_OBJECT_MAP()


/*  D L L  M A I N */
/*-------------------------------------------------------------------------
	%%Function: DllMain
-------------------------------------------------------------------------*/
BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID lpv)
{
	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
	{
#ifdef DEBUG
		InitDebug();
		DBG_INIT_MEMORY_TRACKING(hDllInst);
		TRACE_OUT(("*** MSCONF.DLL: Attached process thread %X", GetCurrentThreadId()));
#endif
		g_hInst = hDllInst;
		_Module.Init(ObjectMap, g_hInst);

		DisableThreadLibraryCalls(hDllInst);

		InitDataObjectModule();
		break;
	}

	case DLL_PROCESS_DETACH:

		_Module.Term();

#ifdef DEBUG
        DBG_CHECK_MEMORY_TRACKING(hDllInst);
		TRACE_OUT(("*** MSCONF.DLL: Detached process thread %X", GetCurrentThreadId()));
		DeInitDebug();
#endif

		break;

	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	default:
		break;
	}
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	HRESULT hr = S_OK;

	if( InlineIsEqualGUID(rclsid, CLSID_NetMeeting) || InlineIsEqualGUID(rclsid, CLSID_NmManager) )
	{	
		hr = CoGetClassObject(rclsid, CLSCTX_LOCAL_SERVER, NULL, riid, ppv);
	}
	else
	{
		hr = _Module.GetClassObject(rclsid, riid, ppv);
	}

	return hr;
}

/*  D L L  G E T  V E R S I O N  */
/*-------------------------------------------------------------------------
    %%Function: DllGetVersion

-------------------------------------------------------------------------*/
STDAPI DllGetVersion(IN OUT DLLVERSIONINFO * pinfo)
{
	HRESULT hr;

	if ((NULL == pinfo) ||
		IsBadWritePtr(pinfo, sizeof(*pinfo)) ||
		sizeof(*pinfo) != pinfo->cbSize)
	{
		hr = E_INVALIDARG;
	}
	else
	{
		pinfo->dwMajorVersion = (VER_PRODUCTVERSION_DW & 0xFF000000) >> 24;
		pinfo->dwMinorVersion = (VER_PRODUCTVERSION_DW & 0x00FF0000) >> 16;
		pinfo->dwBuildNumber  = (VER_PRODUCTVERSION_DW & 0x0000FFFF);
		pinfo->dwPlatformID   = DLLVER_PLATFORM_WINDOWS;
		hr = S_OK;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	return _Module.RegisterServer();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = S_OK;

	hr = _Module.UnregisterServer();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconf\watcher.cpp ===
#include "precomp.h"

//
// watcher.cpp
//
// This file is a big ugly hack to make sure that NetMeeting 
// will cleanup is display driver (nmndd.sys) properly. This is
// needed because it uses a mirrored driver which will prevent DX
// games from running if NetMeeting is not shut down cleanly.
//
// Copyright(c) Microsoft 1997-
//


//
// This function actually disables the "NetMeeting driver" display driver
//
BOOL DisableNetMeetingDriver()
{
    BOOL bRet = TRUE;   // assume success
    DISPLAY_DEVICE dd = {0};
    int i;

    dd.cb = sizeof(dd);
    
    for (i = 0; EnumDisplayDevices(NULL, i, &dd, 0); i++)
    {
        if ((dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) &&
            (dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) &&
            !lstrcmpi(dd.DeviceString, TEXT("NetMeeting driver")))
        {
            DEVMODE devmode = {0};

            devmode.dmSize = sizeof(devmode);
            devmode.dmFields = DM_POSITION | DM_PELSWIDTH | DM_PELSHEIGHT;

            if ((ChangeDisplaySettingsEx(dd.DeviceName,
                                         &devmode,
                                         NULL,
                                         CDS_UPDATEREGISTRY | CDS_NORESET,
                                         NULL) != DISP_CHANGE_SUCCESSFUL) ||
                (ChangeDisplaySettings(NULL, 0) != DISP_CHANGE_SUCCESSFUL))
            {
                // we failed for some unknown reason
                bRet = FALSE;
            }

            // we found the driver, no need to look further
            break;
        }
    }

    if (i == 0)
    {
        // this means that EnumDisplayDevices failed, which we consider a
        // failure case
        bRet = FALSE;
    }

    return bRet;
}


//
// Constructs the proper ""C:\windows\system32\rundll32.exe" nmasnt.dll,CleanupNetMeetingDispDriver 0"
// commandline to put into the registry in case the machine is rebooted while netmeeting is
// running.
//
BOOL GetCleanupCmdLine(LPTSTR pszCmdLine)
{
    BOOL bRet = FALSE;
    TCHAR szWindir[MAX_PATH];

    if (GetSystemDirectory(szWindir, sizeof(szWindir)/sizeof(szWindir[0])))
    {
        wsprintf(pszCmdLine, TEXT("\"%s\\rundll32.exe\" msconf.dll,CleanupNetMeetingDispDriver 0"), szWindir);
        bRet = TRUE;
    }

    return bRet;
}


//
// This will either add or remove ourself from the runonce section of the registry
//
BOOL SetCleanupInRunone(BOOL bAdd)
{
    BOOL bRet = FALSE;
    TCHAR szCleanupCmdLine[MAX_PATH * 2];

    if (GetCleanupCmdLine(szCleanupCmdLine))
    {
        HKEY hk;

        // first try HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),
                         0,
                         KEY_QUERY_VALUE | KEY_SET_VALUE,
                         &hk) == ERROR_SUCCESS)
        {
            if (bAdd)
            {
                if (RegSetValueEx(hk,
                                  TEXT("!CleanupNetMeetingDispDriver"),
                                  0,
                                  REG_SZ,
                                  (LPBYTE)szCleanupCmdLine,
                                  (lstrlen(szCleanupCmdLine) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS)
                {
                    bRet = TRUE;
                }
            }
            else
            {
                if (RegDeleteValue(hk, TEXT("!CleanupNetMeetingDispDriver")) == ERROR_SUCCESS)
                {
                    bRet = TRUE;
                }
            }

            RegCloseKey(hk);
        }

        if (!bRet)
        {
            // if we failed, then try HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
            if (RegCreateKeyEx(HKEY_CURRENT_USER,
                               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_QUERY_VALUE | KEY_SET_VALUE,
                               NULL,
                               &hk,
                               NULL) == ERROR_SUCCESS)
            {
                if (bAdd)
                {
                    if (RegSetValueEx(hk,
                                      TEXT("!CleanupNetMeetingDispDriver"),
                                      0,
                                      REG_SZ,
                                      (LPBYTE)szCleanupCmdLine,
                                      (lstrlen(szCleanupCmdLine) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS)
                    {
                        bRet = TRUE;
                    }
                }
                else
                {
                    if (RegDeleteValue(hk, TEXT("!CleanupNetMeetingDispDriver")) == ERROR_SUCCESS)
                    {
                        bRet = TRUE;
                    }
                }

                RegCloseKey(hk);
            }
        }
    }

    return bRet;
}

// on retail builds we don't have CRT's so we need this
#if 0
#ifndef DBG

int _wchartodigit(WCHAR ch)
{
#define DIGIT_RANGE_TEST(zero)  \
    if (ch < zero)              \
        return -1;              \
    if (ch < zero + 10)         \
    {                           \
        return ch - zero;       \
    }

    DIGIT_RANGE_TEST(0x0030)        // 0030;DIGIT ZERO
    if (ch < 0xFF10)                // FF10;FULLWIDTH DIGIT ZERO
    {
        DIGIT_RANGE_TEST(0x0660)    // 0660;ARABIC-INDIC DIGIT ZERO
        DIGIT_RANGE_TEST(0x06F0)    // 06F0;EXTENDED ARABIC-INDIC DIGIT ZERO
        DIGIT_RANGE_TEST(0x0966)    // 0966;DEVANAGARI DIGIT ZERO
        DIGIT_RANGE_TEST(0x09E6)    // 09E6;BENGALI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0A66)    // 0A66;GURMUKHI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0AE6)    // 0AE6;GUJARATI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0B66)    // 0B66;ORIYA DIGIT ZERO
        DIGIT_RANGE_TEST(0x0C66)    // 0C66;TELUGU DIGIT ZERO
        DIGIT_RANGE_TEST(0x0CE6)    // 0CE6;KANNADA DIGIT ZERO
        DIGIT_RANGE_TEST(0x0D66)    // 0D66;MALAYALAM DIGIT ZERO
        DIGIT_RANGE_TEST(0x0E50)    // 0E50;THAI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0ED0)    // 0ED0;LAO DIGIT ZERO
        DIGIT_RANGE_TEST(0x0F20)    // 0F20;TIBETAN DIGIT ZERO
        DIGIT_RANGE_TEST(0x1040)    // 1040;MYANMAR DIGIT ZERO
        DIGIT_RANGE_TEST(0x17E0)    // 17E0;KHMER DIGIT ZERO
        DIGIT_RANGE_TEST(0x1810)    // 1810;MONGOLIAN DIGIT ZERO


        return -1;
    }
#undef DIGIT_RANGE_TEST

    if (ch < 0xFF10 + 10) 
    { 
        return ch - 0xFF10; 
    }

    return -1;
}


__int64 __cdecl _wtoi64(const WCHAR *nptr)
{
        int c;              /* current char */
        __int64 total;      /* current total */
        int sign;           /* if '-', then negative, otherwise positive */

        if (!nptr)
            return 0i64;

        c = (int)(WCHAR)*nptr++;

        total = 0;

        while ((c = _wchartodigit((WCHAR)c)) != -1)
        {
            total = 10 * total + c;     /* accumulate digit */
            c = (WCHAR)*nptr++;    /* get next char */
        }

        return total;
}
#endif //!DBG
#endif // 0


//
// The purpose of this function is two-fold:
//
//  1. It is passed the decimal value of the NetMeeting process handle on the cmdline
//     so that it can wait for NetMeeting to terminate and make sure that the mnmdd
//     driver is disabled.
//
//  2. We also add ourselves to the runonce in case the machine is rebooted or bugchecks
//     while NetMeeting is running so we can disable the driver at next logon.
//
STDAPI_(void) CleanupNetMeetingDispDriverW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR pswszCmdLine, int nCmdShow)
{
    HANDLE hNetMeetingProcess = NULL;
    HANDLE hEvent;
    BOOL bAddedToRunOnce = FALSE;
    BOOL bNetMeetingStillRunning = FALSE;

    // the handle of the process to watch is passed to us on the cmdline as a decimal string value
    if (pswszCmdLine && *pswszCmdLine)
    {
        hNetMeetingProcess = (HANDLE)_wtoi64(pswszCmdLine);
    }

    if (hNetMeetingProcess)
    {
        // add ourselves to the runonce in case the machine bugchecks or is rebooted, we can still disable the
        // mnmdd driver at next logon
        bAddedToRunOnce = SetCleanupInRunone(TRUE);

        for (;;)
        {
            MSG msg;
            DWORD dwReturn = MsgWaitForMultipleObjects(1, &hNetMeetingProcess, FALSE, INFINITE, QS_ALLINPUT);

            if (dwReturn != (WAIT_OBJECT_0 + 1))
            {
                // something other than a message (either our event is signaled or MsgWait failed)
                break;
            }

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
    else
    {
        // If hNetMeetingProcess is NULL, this means we are running as part of RunOnce due to a reboot
        // or a bugcheck. We have to signal the "msgina: ShellReadyEvent" early so that the desktop switch
        // will take place or else our call to ChangeDisplaySettingsEx will fail becuase the input desktop
        // will still be winlogon's secure desktop
        hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("msgina: ShellReadyEvent"));
        if (hEvent)
        {
            SetEvent(hEvent);
            CloseHandle(hEvent);
        }

        // we also wait 10 seconds just to be sure that the desktop switch has taken place
        Sleep(10 * 1000);
    }
    
    // Only disable the driver if conf.exe/mnmsrvc.exe is not running. We need this extra check since the service (mnmsrvc.exe)
    // can stop and start but conf.exe might still be running, and we don't want to disable the driver while the app
    // is still using it. Conversely, we dont want to detach the driver if mnmsrvc.exe is still running.
    hEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT("CONF:Init"));
    if (hEvent)
    {
        bNetMeetingStillRunning = TRUE;
        CloseHandle(hEvent);
    }

    if (FindWindow(TEXT("MnmSrvcHiddenWindow"), NULL))
    {
        bNetMeetingStillRunning = TRUE;
    }

    if (bNetMeetingStillRunning)
    {
        // make sure we are in the runonce
        bAddedToRunOnce = SetCleanupInRunone(TRUE);
    }
    else
    {
        // this will detach the mnmdd driver from the hw, allowing DX games to run
        if (DisableNetMeetingDriver() && bAddedToRunOnce)
        {
            // remove ourselves from the runonce
            SetCleanupInRunone(FALSE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\fileio.hpp ===
#ifndef __FILEIO_HPP__
#define __FILEIO_HPP__

class CMBFTFile
{
protected:

	HANDLE 		m_FileHandle;
	DWORD		m_LastIOError;
    char        m_szFileName[_MAX_PATH];
    char        m_szTempDirectory[_MAX_PATH];

private:
	enum OpenModeFlags
	{
    	FDW_Read 	= 0x0001,
    	FDW_Write 	= 0x0002,
    	FDW_Create	= 0x0010,
    	FDW_RDeny	= 0x0100,
    	FDW_WDeny	= 0x0200
	};

public:
    enum OpenMode
    {
        OpenReadOnly 	= FDW_Read,
        OpenReadWrite 	= FDW_Read|FDW_Write,
        OpenBinary		= 0,
        CreateReadOnly	= FDW_Read|FDW_Create,
        CreateWrite		= FDW_Write|FDW_Create,
        CreateReadWrite	= FDW_Write|FDW_Read|FDW_Create,
        ShareExclusive	= FDW_RDeny|FDW_WDeny,
        ShareDenyNone	= 0,
        ShareDenyRead	= FDW_RDeny,
        ShareDenyWrite	= FDW_WDeny,
    };

    enum SeekMode
    {
        SeekFromBegin   =   0,
        SeekFromCurrent =   1,
        SeekFromEnd     =   2
    };

    CMBFTFile();
    ~CMBFTFile();

    BOOL Open(LPCSTR lpszFileName,unsigned iOpenMode);
    BOOL Close(BOOL status=TRUE);
    BOOL Create(LPCSTR lpszDirName, LPCSTR lpszFileName);
    BOOL DeleteFile(void);
    LONG Seek(LONG lOffset,int lFromWhere);
    ULONG Read(LPSTR lpszBuffer, ULONG iNumBytes);
    BOOL Write(LPCSTR lpszBuffer, ULONG iNumBytes);
    LONG GetFileSize(void);
    time_t GetFileDateTime(void);
    BOOL SetFileDateTime(time_t FileDateTime);
    LPCSTR  GetTempDirectory(void);
    LPCSTR  GetFileName(void) { return m_szFileName; }
    int     GetLastErrorCode(void);
    BOOL	GetIsEOF();
};

#endif  //__FILEIO_HPP__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\combotb.h ===
#ifndef COMBO_TOOLBAR_H
#define COMBO_TOOLBAR_H

#include <gencontrols.h>
#include <gencontainers.h>

#define RES_CH_MAX 256

extern HINSTANCE   g_hDllInst;
#define STRING_RESOURCE_MODULE g_hDllInst
#define RES2T(uID, psz ) ( Res2THelper( uID, psz, RES_CH_MAX ) )

inline TCHAR* Res2THelper( UINT uID, TCHAR* psz, int cch )
{
    if( LoadString( STRING_RESOURCE_MODULE, uID, psz, cch ) )
    {
        return psz;
    }

    return _T("");
}


// Private structure for defining a button
struct Buttons
{
    int idbStates;      // Bitmap ID for the states
    UINT nInputStates;  // Number of input states in the bitmap
    UINT nCustomStates; // Number of custom states in the bitmap
    int idCommand;      // Command ID for WM_COMMAND messages
    LPCTSTR pszTooltip; // Tooltip text
} ;

class CComboToolbar : public CToolbar
{
private:
	CComboBox		*m_Combobox;
	int				m_iCount;
	CGenWindow		**m_Buttons;
	int				m_iNumButtons;
	void			*m_pOwner;  // pointer to owner (CAppletWindow*)

public:
	CComboToolbar();
	BOOL Create(HWND	hwndParent, struct Buttons* buttons, 
				int iNumButtons, LPVOID  owner);

	virtual void OnDesiredSizeChanged();

	void OnCommand(int id) { OnCommand(GetWindow(), id, NULL, 0); }
	void HandlePeerNotification(T120ConfID confId,	// handle PeerMsg
			T120NodeID nodeID, PeerMsg *pMsg);		
	UINT GetSelectedItem(LPARAM *ItemData);			// get selected item and data
	void UpdateButton(int *iFlags);					// update button state
	
protected:
	virtual ~CComboToolbar();
	virtual LRESULT	ProcessMessage(HWND hwnd, UINT message, 
							WPARAM wParam, LPARAM lParam);

private:
	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
};

#endif /* COMBO_TOOLBAR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\combotb.cpp ===
#include "mbftpch.h"
#include "combotb.h"

const static COLORREF EditBack = RGB(255, 255, 255);
const static COLORREF EditFore = RGB(0, 0, 0 );
const static int	FtTBHMargin	= 5;
const static int	FtTBVMargin	= 5;
const static int	FtHGap		= 3;


CComboToolbar::CComboToolbar() :
	m_Combobox(NULL),
	m_iCount(0),
	m_Buttons(NULL),
	m_iNumButtons(0)
{
	m_nAlignment = Center;
}

CComboToolbar::~CComboToolbar()
{
	delete [] m_Buttons;
}


typedef CBitmapButton *		LPBITMAPBTN;

BOOL CComboToolbar::Create(HWND hwndParent, struct Buttons *buttons,
						   int iNumButtons, LPVOID  pOwner)
{
	int i;
	BOOL	fRet;

	TCHAR szRes[MAX_PATH];
	m_pOwner = pOwner;
	if (!CToolbar::Create(hwndParent))
	{
		return FALSE;
	}

	m_iNumButtons = iNumButtons;	
	m_hMargin	= FtTBHMargin;
	m_vMargin	= FtTBVMargin;
	m_gap		= FtHGap;
	m_bMinDesiredSize	= TRUE;
	m_bHasCenterChild = TRUE;
	m_uRightIndex	= m_iNumButtons + 1;

    DBG_SAVE_FILE_LINE
	m_Buttons = (CGenWindow**) new LPBITMAPBTN [m_iNumButtons];
	if (NULL != m_Buttons)
	{
		::ZeroMemory(m_Buttons, m_iNumButtons * sizeof(LPBITMAPBTN));

		for (i = 0; i < m_iNumButtons; i++)
		{
			if (buttons[i].idCommand)
			{
				DBG_SAVE_FILE_LINE
				m_Buttons[i] = new CBitmapButton();
				if (NULL != m_Buttons[i])
				{
					fRet = ((CBitmapButton*)m_Buttons[i])->Create(GetWindow(), buttons[i].idCommand,
									g_hDllInst, buttons[i].idbStates, TRUE,
									buttons[i].nInputStates, buttons[i].nCustomStates, NULL);
					m_Buttons[i]->SetTooltip(buttons[i].pszTooltip);
					m_Buttons[i]->SetWindowtext(RES2T(buttons[i].idCommand,szRes));
					ASSERT(fRet);
				}
			}
			else
			{
				DBG_SAVE_FILE_LINE
				CSeparator *pSep = new CSeparator();
				m_Buttons[i] = pSep;
				if (NULL != pSep)
				{
					fRet = pSep->Create(GetWindow(), CSeparator::Blank);
					ASSERT (fRet);
				}
			}
			m_Buttons[i]->Release();
		}
	}

    DBG_SAVE_FILE_LINE
	m_Combobox = new CComboBox();
	if (NULL != m_Combobox)
	{
		if (m_Combobox->Create(GetWindow(), 100, CBS_AUTOHSCROLL|CBS_DROPDOWNLIST,
								NULL, NULL))
		{
			m_Combobox->SetColors(CreateSolidBrush(EditBack), EditBack, EditFore);
			m_Combobox->SetTooltip((LPSTR)IDS_RECEIVER_TT);
			m_Combobox->SetWindowtext(RES2T(IDS_RECEIVER_TT,szRes));
			m_Combobox->SetFont((HFONT)::GetStockObject(DEFAULT_GUI_FONT));
			m_Combobox->Release();
		}
	}

	return TRUE;
}
	

void CComboToolbar::OnDesiredSizeChanged()
{
	ScheduleLayout();
}


LRESULT CComboToolbar::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch(message)
	{
		HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

	default:
		break;
	}
	return (CToolbar::ProcessMessage(hwnd, message, wParam, lParam));
}


void CComboToolbar::OnCommand(HWND hwnd, int wId, HWND hwndCtl, UINT codeNotify)
{
	if (m_pOwner)
	{
		CAppletWindow *pWindow = (CAppletWindow*)m_pOwner;
		pWindow->OnCommand((WORD)wId, hwndCtl, (WORD)codeNotify);
		return;
	}
	else
	{
		WARNING_OUT(("CComboToolbar::OnCommand--Received unhandlable message.\n"));
	}
}


void CComboToolbar::HandlePeerNotification(T120ConfID confID, T120NodeID nodeID,
										   PeerMsg *pMsg)
{
	int iLen, iIndex, iCount;
	char  szName[MAX_PATH];

	if (pMsg->m_NodeID != nodeID)
	{
		iLen = T120_GetNodeName(confID, pMsg->m_NodeID, szName, MAX_PATH);
		if (iLen)
		{
			ASSERT (iLen < MAX_PATH);
			MEMBER_ID nMemberID = MAKE_MEMBER_ID(pMsg->m_MBFTPeerID, pMsg->m_NodeID);

			if (pMsg->m_bPeerAdded)
			{
				if (m_iCount == 0)
				{
					char szAll[MAX_PATH];
					::LoadString(g_hDllInst, IDS_ALL_RECEIVER, szAll, MAX_PATH);
					m_Combobox->AddText(TEXT(szAll));
					WARNING_OUT(("Insert ALL"));
				}
				m_Combobox->AddText(szName, nMemberID);
				WARNING_OUT(("Insert %s.\n", szName));
				m_iCount++;
			}
			else
			{
				// Scan through the whole list to find the user
				iCount = m_Combobox->GetNumItems();
				for (iIndex = 0; iIndex < iCount; iIndex++)
				{
					if (nMemberID == (MEMBER_ID)m_Combobox->GetUserData(iIndex))
						break;
					
				}

				if (iIndex < iCount)
				{  // found
					m_Combobox->RemoveItem(iIndex);
					WARNING_OUT(("delete %s", szName));
					m_iCount--;
					if (0 == m_iCount)
					{
						ASSERT (m_Combobox->GetNumItems() == 1);
						m_Combobox->RemoveItem(0);
						WARNING_OUT(("delete ALL"));
					}
				}
				else
				{
					WARNING_OUT(("Can't find to be deleted peer, %s.\n", szName));
				}
			}
		}
		else
		{
			WARNING_OUT(("Can't find node name for nConfID=%d, nNodeID=%d.\n",
				(UINT) confID, (UINT) pMsg->m_NodeID));
		}
	}
	else
	{   // delete all items. Bacause MBFTEngine does not explicitly send PeerNotify message for every peer
		// when the node leaves message, so it is up to the host to remove all the peers during its close.
		if (!pMsg->m_bPeerAdded)
		{
			iCount = m_Combobox->GetNumItems();
			for (iIndex = iCount - 1; iIndex >= 0; iIndex--)
			{
				m_Combobox->RemoveItem(iIndex);
			}
			m_iCount = 0;
		}
	}

	if (m_iCount)
	{	
		// Default select "ALL"
		m_Combobox->SetSelectedIndex(0);
	}
	else
	{
		// Deselect
		m_Combobox->SetSelectedIndex(-1);
	}
}


//
//  Return item selected and its associated itemdata
//
UINT  CComboToolbar::GetSelectedItem(LPARAM *ItemData)
{
	int  iIndex = m_Combobox->GetSelectedIndex();
	if (iIndex >= 0)
	{
		*ItemData = m_Combobox->GetUserData(iIndex);
	}
	return iIndex;
}


static const int c_iCommands[] =
{ IDM_ADD_FILES, IDM_REMOVE_FILES, IDM_SEND_ALL, IDM_SEND_ONE, IDM_STOP_SENDING,
IDM_OPEN_RECV_FOLDER};

void CComboToolbar::UpdateButton(int *iFlags)
{
	for (int iIndex = 0; iIndex < m_iNumButtons; iIndex++)
	{
		if (NULL != m_Buttons[iIndex])
		{
			::EnableWindow(m_Buttons[iIndex]->GetWindow(), iFlags[iIndex]);
		}
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\fileio.cpp ===
/**************************************************************************
** FILENAME:
**
 *              INTEL CORPORATION PROPRIETARY INFORMATION
 *                     Copyright Intel Corporation
 *
 *  This software  is supplied under the terms  of a license agreement or
 *  non-disclosure agreement with Intel Corporation and may not be copied
 *  or disclosed in accordance with the terms of that agreement.
 *
 *
** PURPOSE:
**
** $Header:
**
**
** $Log:
*********************************************************************************/

#include "mbftpch.h"
#include "fileio.hpp"

#define STRSAFE_NO_DEPRECATE 1
#include <strsafe.h>

extern int MyLoadString(UINT, LPTSTR);
extern int MyLoadString(UINT, LPTSTR, LPTSTR);
extern int MyLoadString(UINT, LPTSTR, LPTSTR, LPTSTR);

CMBFTFile::CMBFTFile()
{
    m_FileHandle = INVALID_HANDLE_VALUE;
    m_LastIOError   = 0;
    m_szFileName[0]	= 0;
}

CMBFTFile::~CMBFTFile()
{
	/* close file if still open */
	Close ();
}

BOOL CMBFTFile::Open(LPCSTR lpszFileName,unsigned iOpenMode)
{
    lstrcpyn(m_szFileName,lpszFileName,sizeof(m_szFileName));
	DWORD fdwAccess = ((0!=(iOpenMode&FDW_Read))*GENERIC_READ)
					| ((0!=(iOpenMode&FDW_Write))*GENERIC_WRITE);
	DWORD fdwShareMode 	= ((0==(iOpenMode&FDW_RDeny))*FILE_SHARE_READ)
						| ((0==(iOpenMode&FDW_WDeny))*FILE_SHARE_WRITE);
	DWORD fdwCreate	= (iOpenMode&FDW_Create)?CREATE_ALWAYS:OPEN_EXISTING;
	
	m_LastIOError = 0;
	m_FileHandle = CreateFile(
		lpszFileName,
		fdwAccess,
		fdwShareMode,
		NULL,
		fdwCreate,
		FILE_ATTRIBUTE_NORMAL,
		NULL );

	if( INVALID_HANDLE_VALUE == m_FileHandle )
	{
		m_LastIOError = GetLastError();
	}
    return(m_LastIOError == 0);
}


BOOL CMBFTFile::Close(BOOL status)
{
	m_LastIOError = 0;

	/* nothing to do if file already closed */
	if( m_FileHandle == INVALID_HANDLE_VALUE )
		return ( m_LastIOError == 0 );

	/* close the file */
	if( !CloseHandle( m_FileHandle ) )
	{
		m_LastIOError = GetLastError();
	}

    m_FileHandle = INVALID_HANDLE_VALUE;

	/* just delete file if status==FALSE */
	if( status == FALSE )
	{
		::DeleteFile(m_szFileName);
	}

    return( m_LastIOError == 0 );
}

BOOL CMBFTFile::Create(LPCSTR lpszDirName, LPCSTR lpszFileName)
{
	DWORD dwTick;
    BOOL bCreateFile = TRUE;

    /* protect against path info embedded in received file name */
    lpszFileName = GetFileNameFromPath(lpszFileName);

    /* copy original file name */
    if(FAILED(StringCchPrintfA(m_szFileName, CCHMAX(m_szFileName), "%s\\%s", lpszDirName, lpszFileName)))
    {
        m_LastIOError = ERROR_BUFFER_OVERFLOW;
        return FALSE;
    }

    /* generate temp file name if file exists */
    if (FFileExists(m_szFileName))
    {
		// REVIEW
        //Small hack here -- if file already exists, check to see if we have write access.
        //If not, we say report an access denied error...

        if (FFileExists(m_szFileName))
        {
			TCHAR szNewFileName[_MAX_PATH];
			INT_PTR nCount = 1;
			while (1)
			{
				MyLoadString(IDS_COPY_N_OF, szNewFileName, (LPTSTR)nCount, (LPTSTR)lpszFileName);
			    if(FAILED(StringCchPrintfA(m_szFileName, CCHMAX(m_szFileName), "%s\\%s", lpszDirName, szNewFileName)))
			    {
                    m_LastIOError = ERROR_BUFFER_OVERFLOW;
                    return FALSE;
			    }
			    
				if (!FFileExists(m_szFileName))
				{
					break;
				}
				nCount++;
			}
        }
        else
        {
            bCreateFile     =   FALSE;
        }
    }

    //This flag is reset only if file already exists and is read only...

    if(bCreateFile)
    {
        /* finally, create the file */
		m_LastIOError = 0;
		m_FileHandle = CreateFile(
			m_szFileName,
			GENERIC_READ|GENERIC_WRITE,
			FILE_SHARE_READ,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL );

		if( INVALID_HANDLE_VALUE == m_FileHandle )
		{
			m_LastIOError = GetLastError();
		}
	}
    else
    {
        m_szFileName[0] = TEXT('\0'); // Clear file name
    }
    return(bCreateFile && (m_LastIOError == 0));
}

LONG CMBFTFile::Seek( LONG lOffset, int iFromWhere )
{
	DWORD MoveMethod[] = { FILE_BEGIN, FILE_CURRENT, FILE_END };
    LONG Position = (LONG)SetFilePointer( m_FileHandle, lOffset, NULL, MoveMethod[min((unsigned)iFromWhere,2)] );
	m_LastIOError = 0;

    if( Position == -1L )
    {
        m_LastIOError = GetLastError();
    }

    return( Position );
}

ULONG CMBFTFile::Read(LPSTR lpszBuffer, ULONG iNumBytes)
{
    ULONG iBytesRead = 0;

    if(iNumBytes)
    {
		m_LastIOError = 0;
		if( !ReadFile( m_FileHandle, lpszBuffer, iNumBytes, (LPDWORD)&iBytesRead, NULL ) )
		{
			m_LastIOError = GetLastError();
		}

        if(m_LastIOError != 0)
        {
            iBytesRead = (ULONG)-1;
        }
    }

    return(iBytesRead);
}

BOOL CMBFTFile::Write(LPCSTR lpszBuffer, ULONG iNumBytes)
{
    ULONG iBytesWritten = 0;

    if(iNumBytes)
    {
		if( !WriteFile( m_FileHandle, lpszBuffer, iNumBytes, (LPDWORD)&iBytesWritten, NULL ) )
		{
			m_LastIOError = GetLastError();
		}
        if(!m_LastIOError)
        {
            if(iBytesWritten != iNumBytes)
            {
                m_LastIOError = (ULONG)-1;     //Kludge for insufficient disk space...
            }
        }
    }

    return(iBytesWritten == iNumBytes);
}

LONG CMBFTFile::GetFileSize(void)
{
	return( (LONG)::GetFileSize( m_FileHandle, NULL ) );
}


BOOL CMBFTFile::DeleteFile(void)
{
    BOOL bReturn = FALSE;

	/* delete if has name */
    if(lstrlen(m_szFileName))
    {
    	/* close file before deleting */
		CloseHandle( m_FileHandle );
		bReturn = ::DeleteFile( m_szFileName );
		if( !bReturn )
		{
			m_LastIOError = GetLastError();
		}
    }

    return(bReturn);
}

time_t CMBFTFile::GetFileDateTime(void)
{
    WORD Date = 0;
    WORD Time = 0;

	BY_HANDLE_FILE_INFORMATION bhfi;
	if( !GetFileInformationByHandle( m_FileHandle, &bhfi ) )
	{
		return( 0 );
	}
	FileTimeToDosDateTime( &bhfi.ftLastWriteTime, &Date, &Time );
    return(MAKELONG(Time,Date));
}

BOOL CMBFTFile::SetFileDateTime(time_t FileDateTime)
{
    BOOL bReturn = FALSE;

	FILETIME ft;
	DosDateTimeToFileTime( HIWORD(FileDateTime), LOWORD(FileDateTime), &ft );
	bReturn = SetFileTime( m_FileHandle, NULL, NULL, &ft );
    return(bReturn);
}


int CMBFTFile::GetLastErrorCode(void)
{
    struct XLAT
    {
	    unsigned Win32ErrorCode;
	    int      MBFTErrorCode;
    };

    static XLAT MBFTXlatTable[] =
    {
      {0,iMBFT_OK},
      {ERROR_FILE_NOT_FOUND,iMBFT_FILE_NOT_FOUND},
      {ERROR_PATH_NOT_FOUND,iMBFT_INVALID_PATH},
      {ERROR_TOO_MANY_OPEN_FILES,iMBFT_TOO_MANY_OPEN_FILES},
      {ERROR_ACCESS_DENIED,iMBFT_FILE_ACCESS_DENIED},
      {ERROR_SHARING_VIOLATION,iMBFT_FILE_SHARING_VIOLATION},
      {ERROR_HANDLE_DISK_FULL,iMBFT_INSUFFICIENT_DISK_SPACE}
    };

    int Index;
    int MBFTErrorCode = iMBFT_FILE_IO_ERROR;

    for(Index = 0;Index < (sizeof(MBFTXlatTable) / sizeof(MBFTXlatTable[0]));Index++)
    {
        if(MBFTXlatTable[Index].Win32ErrorCode == m_LastIOError)
        {
            MBFTErrorCode = MBFTXlatTable[Index].MBFTErrorCode;
            break;
        }
    }
    return(MBFTErrorCode);
}

LPCSTR CMBFTFile::GetTempDirectory(void)
{
    LPSTR lpszPointer = NULL;

	TCHAR    szTempPath[MAX_PATH] = TEXT("");
    DWORD    cchTempPath = 0;
    
	// get the temp path from the system
    cchTempPath = ::GetTempPath(sizeof(szTempPath), szTempPath);
    if (cchTempPath == 0 || cchTempPath >= sizeof(szTempPath))
    {
		return NULL;
	}

    if( GetTempFileName( szTempPath, "Junk", 0, m_szTempDirectory ) ) /*Localization OK*/
    {
		::DeleteFile( m_szTempDirectory );
        lpszPointer = SzFindLastCh(m_szTempDirectory,'\\');

        if(lpszPointer)
        {
            *lpszPointer  = '\0';
        }
    }

    if(!lpszPointer)
    {
        lstrcpy(m_szTempDirectory,"");
    }

    return((LPCSTR)m_szTempDirectory);
}


BOOL CMBFTFile::GetIsEOF()
{
	BOOL fReturn = FALSE;
	if( INVALID_HANDLE_VALUE != m_FileHandle )
	{
		DWORD dwCurrentPosition = SetFilePointer( m_FileHandle, 0, NULL, FILE_CURRENT );
		DWORD dwEndPosition		= SetFilePointer( m_FileHandle, 0, NULL, FILE_END );

		fReturn = dwCurrentPosition >= dwEndPosition;

		SetFilePointer( m_FileHandle, dwCurrentPosition, NULL, FILE_BEGIN );
	}
	return( fReturn );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\cntlist.cpp ===
#include "mbftpch.h"
#include "cntlist.h"


CList::CList(ULONG cMaxItems, BOOL fQueue)
:
    m_fQueue(fQueue),
    m_cMaxEntries(cMaxItems)
{
    Init();
}


CList::CList(CList *pSrc)
:
    m_fQueue(pSrc->m_fQueue),
    m_cMaxEntries(pSrc->GetCount())
{

    Init();

    LPVOID p;
    pSrc->Reset();
    while (NULL != (p = pSrc->Iterate()))
    {
        Append(p);
    }
}


BOOL CList::Init(void)
{
    if (m_cMaxEntries < CLIST_DEFAULT_MAX_ITEMS)
    {
        m_cMaxEntries = CLIST_DEFAULT_MAX_ITEMS;
    }

    m_cEntries = 0;
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;

    // it is kind of bad here because there is no way to return an error.
    // unfortunately it won't fault here and later.
    DBG_SAVE_FILE_LINE
    m_aEntries = (LPVOID *) new char[m_cMaxEntries * sizeof(LPVOID)];
    return (BOOL) (m_aEntries != NULL);
}


CList::~CList(void)
{
    delete m_aEntries;
}


BOOL CList::Expand(void)
{
    if (NULL == m_aEntries)
    {
        // it is impossible.
        ASSERT(FALSE);
        return Init();
    }

    // the current array is full
    ASSERT(m_cEntries == m_cMaxEntries);

    // remember the old array to free or to restore
    LPVOID  *aOldEntries = m_aEntries;

    // we need to allocate a bigger array to hold more data.
    // the new array has twice the size of the old one
    ULONG cNewMaxEntries = m_cMaxEntries << 1;
    DBG_SAVE_FILE_LINE
    m_aEntries = (LPVOID *) new char[cNewMaxEntries * sizeof(LPVOID)];
    if (NULL == m_aEntries)
    {
        // we failed; we have to restore the array and return
        m_aEntries = aOldEntries;
        return FALSE;
    }

    // copy the old entries into the new array, starting from the beginning
    ULONG nIdx = m_cMaxEntries - m_nHeadOffset;
    ::CopyMemory(m_aEntries, &aOldEntries[m_nHeadOffset], nIdx * sizeof(LPVOID));
    ::CopyMemory(&m_aEntries[nIdx], aOldEntries, m_nHeadOffset * sizeof(LPVOID));

    // set the new max entries (required for the key array)
    m_cMaxEntries = cNewMaxEntries;

    // Free the old array of entries
    delete aOldEntries;

    // Set the instance variables
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;

    return TRUE;
}


BOOL CList::Append(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_aEntries[(m_nHeadOffset + (m_cEntries++)) % m_cMaxEntries] = pData;

    return TRUE;
}


BOOL CList::Prepend(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_cEntries++;
    m_nHeadOffset = (0 == m_nHeadOffset) ? m_cMaxEntries - 1 : m_nHeadOffset - 1;
    m_aEntries[m_nHeadOffset] = pData;

    return TRUE;
}


BOOL CList::Find(LPVOID pData)
{
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        if (pData == m_aEntries[(m_nHeadOffset + i) % m_cMaxEntries])
        {
            return TRUE;
        }
    }
    return FALSE;
}


BOOL CList::Remove(LPVOID pData)
{
    ULONG nIdx, nIdxSrc;
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (pData == m_aEntries[nIdx])
        {
            if (! m_fQueue)
            {
                // to remove the current, we simply move the last to here.
                nIdxSrc = (m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries;
                m_aEntries[nIdx] = m_aEntries[nIdxSrc];
            }
            else
            {
                // to preserve the ordering
                if (0 == i)
                {
                    m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
                }
                else
                {
                    for (ULONG j = i + 1; j < m_cEntries; j++)
                    {
                        nIdx = (m_nHeadOffset + j - 1) % m_cMaxEntries;
                        nIdxSrc = (m_nHeadOffset + j) % m_cMaxEntries;
                        m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                    }
                }
            }

            m_cEntries--;
            return TRUE;
        }
    }
    return FALSE;
}


LPVOID CList::Get(void)
{
    LPVOID pRet = NULL;

    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        m_cEntries--;
        m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
    }
    else
    {
        pRet = NULL;
    }
    return pRet;
}


LPVOID CList::Iterate(void)
{
    if (0 == m_cEntries)
    {
        return NULL;
    }

    if (m_nCurrOffset == CLIST_END_OF_ARRAY_MARK)
    {
        // start from the beginning
        m_nCurrOffset = 0;
    }
    else
    {
        if (++m_nCurrOffset >= m_cEntries)
        {
            // reset the iterator
            m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;
            return NULL;
        }
    }

    return m_aEntries[(m_nHeadOffset + m_nCurrOffset) % m_cMaxEntries];
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\ftdebug.cpp ===
/* ----------------------------------------------------------------------

	Copyright (c) 1994-1995, Microsoft Corporation
	All rights reserved

	ftDebug.cpp

  ---------------------------------------------------------------------- */

#include "mbftpch.h"

#ifdef DEBUG  /* THIS WHOLE FILE */


#define STRING_CASE(val)     case val: pcsz = #val; break

HDBGZONE ghZoneMbft = NULL;
static PTSTR _rgszZonesMbft[] = {
	TEXT("T.127"),
	TEXT("Send"),     // 0x0001  _TRACE_SEND    
	TEXT("Mcs"),      // 0x0002  _TRACE_MCS     
	TEXT("Receive"),  // 0x0004  _TRACE_RECEIVE 
	TEXT("State"),    // 0x0008  _TRACE_STATE   
	TEXT("Init"),     // 0x0010  _TRACE_INIT    
	TEXT("Gcc"),      // 0x0020  _TRACE_GCC     
	TEXT("Pdu"),      // 0x0040  _TRACE_PDU     
	TEXT("Delete"),   // 0x0080  _TRACE_DELETE  
	TEXT("Api"),      // 0x0100  _TRACE_API     
	TEXT("Compress"), // 0x0200  _TRACE_COMPRESS
	TEXT("Debug"),    // 0x0400  _TRACE_OTHER
};



///////////////////////////////////////////////////////////////////////////


VOID InitDebug(void)
{
	DBGINIT(&ghZoneMbft, _rgszZonesMbft);
	InitDebugModule(TEXT("FT"));
}


VOID DeInitDebugMbft(void)
{
	ExitDebugModule();
	DBGDEINIT(&ghZoneMbft);
}



void DbgMsgMbft(PCHAR pszFormat,...)    
{
	va_list arglist;

	va_start(arglist, pszFormat);
	DbgPrintf("mbft", pszFormat, arglist);
	va_end(arglist);
}


PCSTR FAR PASCAL GetMbftRcString(DWORD dwRc)
{
	PCSTR pcsz;
	static char sz[128] = {0};

	switch (dwRc)
		{
	default:
	{
		wsprintf(sz, "iMBFT err (%d)", dwRc);
		return sz;
	}
	STRING_CASE(iMBFT_OK);
	STRING_CASE(iMBFT_FIRST_ERROR);
	STRING_CASE(iMBFT_NOT_INITIALIZED);
	STRING_CASE(iMBFT_ALREADY_INITIALIZED);
	STRING_CASE(iMBFT_INVALID_SESSION_ID);
	STRING_CASE(iMBFT_INVALID_ATTACHMENT_HANDLE);
	STRING_CASE(iMBFT_NO_MORE_RECIPIENTS);
	STRING_CASE(iMBFT_NO_MORE_FILES);
	STRING_CASE(iMBFT_INVALID_EVENT_HANDLE);
	STRING_CASE(iMBFT_INVALID_FILE_HANDLE);
	STRING_CASE(iMBFT_INSUFFICIENT_DISK_SPACE);
	STRING_CASE(iMBFT_FILE_NOT_FOUND);
	STRING_CASE(iMBFT_FILE_IO_ERROR);
	STRING_CASE(iMBFT_MEMORY_ALLOCATION_ERROR);
	STRING_CASE(iMBFT_ASN1_ENCODING_ERROR);
	STRING_CASE(iMBFT_RECIPIENT_NOT_FOUND);
	STRING_CASE(iMBFT_SENDER_ABORTED);
	STRING_CASE(iMBFT_RECEIVER_ABORTED);
	STRING_CASE(iMBFT_RECEIVER_REJECTED);
	STRING_CASE(iMBFT_INVALID_PARAMETERS);
	STRING_CASE(iMBFT_COMPRESSION_ERROR);
	STRING_CASE(iMBFT_DECOMPRESSION_ERROR);
	STRING_CASE(iMBFT_INVALID_PATH);
	STRING_CASE(iMBFT_FILE_ACCESS_DENIED);
	STRING_CASE(iMBFT_FILE_HARD_IO_ERROR);
	STRING_CASE(iMBFT_FILE_SHARING_VIOLATION);
	STRING_CASE(iMBFT_DIRECTORY_FULL_ERROR);
	STRING_CASE(iMBFT_TOO_MANY_OPEN_FILES);
	STRING_CASE(iMBFT_OPERATION_IN_PROGRESS);
	STRING_CASE(iMBFT_INSUFFICIENT_PRIVILEGE);
	STRING_CASE(iMBFT_CONDUCTOR_ABORTED);
	STRING_CASE(iMBFT_PACKET_SIZE_ERROR);
	STRING_CASE(iMBFT_UNKNOWN_ERROR);
		}
	return pcsz;
}

LPCTSTR GetMcsErrorString(MCSError mcsError)
{
	LPCTSTR pcsz;
	static CHAR sz[MAX_PATH];

	switch (mcsError)
		{
	default:
		wsprintf(sz, "MCSError %d", mcsError);
		pcsz = sz;
		return pcsz;
	STRING_CASE(MCS_NO_ERROR);
	STRING_CASE(MCS_COMMAND_NOT_SUPPORTED);
	STRING_CASE(MCS_NOT_INITIALIZED);
	STRING_CASE(MCS_ALREADY_INITIALIZED);
	STRING_CASE(MCS_NO_TRANSPORT_STACKS);
	STRING_CASE(MCS_DOMAIN_ALREADY_EXISTS);
	STRING_CASE(MCS_NO_SUCH_DOMAIN);
	STRING_CASE(MCS_USER_NOT_ATTACHED);
	STRING_CASE(MCS_NO_SUCH_USER);
	STRING_CASE(MCS_TRANSMIT_BUFFER_FULL);
	STRING_CASE(MCS_NO_SUCH_CONNECTION);
	STRING_CASE(MCS_DOMAIN_NOT_HIERARCHICAL);
	STRING_CASE(MCS_INVALID_ADDRESS_PREFIX);
	STRING_CASE(MCS_ALLOCATION_FAILURE);
	STRING_CASE(MCS_INVALID_PARAMETER);
	STRING_CASE(MCS_CALLBACK_NOT_PROCESSED);
	STRING_CASE(MCS_DOMAIN_MERGING);
//	STRING_CASE(MCS_INVALID_TRANSPORT);
//	STRING_CASE(MCS_TRANSPORT_ALREADY_LOADED);
//	STRING_CASE(MCS_TRANSPORT_BUSY);
	STRING_CASE(MCS_TRANSPORT_NOT_READY);
	STRING_CASE(MCS_DOMAIN_PARAMETERS_UNACCEPTABLE);
		}
	return pcsz;
}



#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\cntlist.h ===
#ifndef _CONTAINED_LIST_H_
#define _CONTAINED_LIST_H_


#define CLIST_DEFAULT_MAX_ITEMS   4
#define CLIST_END_OF_ARRAY_MARK   ((UINT) -1)


class CList
{
public:

    CList(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS, BOOL fQueue = FALSE);
    CList(CList *pSrc);

    ~CList(void);

    BOOL Append(LPVOID pData);
    BOOL Prepend(LPVOID pData);

    BOOL Find(LPVOID pData);
    BOOL Remove(LPVOID pData);

    LPVOID Get(void);

    LPVOID Iterate(void);

    void Reset(void) { m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };
    void Clear(void) { m_cEntries = 0; m_nHeadOffset = 0; m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };

    UINT GetCount(void) { return m_cEntries; };
    BOOL IsEmpty(void) { return (m_cEntries == 0); };

    LPVOID PeekHead(void) { return (0 != m_cEntries) ? m_aEntries[m_nHeadOffset] : NULL; }

protected:

    ULONG      m_cEntries;
    ULONG      m_cMaxEntries;
    ULONG      m_nHeadOffset;
    ULONG      m_nCurrOffset;
    BOOL       m_fQueue;       // TRUE for CQueue, FALSE for CList

    LPVOID    *m_aEntries;

private:

    BOOL Expand(void);
    BOOL Init(void);
};


#define DEFINE_CLIST(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(void) : CList() { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList(cMaxItems) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_PtrItemType_ pData) { return CList::Append((LPVOID) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CList::Prepend((LPVOID) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); }

#define DEFINE_CLIST_(_NewClass_,_IntItemType_) \
            public: \
            _NewClass_(void) : CList() { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList(cMaxItems) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntItemType_ nData) { return CList::Append((LPVOID) nData); } \
            BOOL Prepend(_IntItemType_ nData) { return CList::Prepend((LPVOID) nData); } \
            BOOL Remove(_IntItemType_ nData) { return CList::Remove((LPVOID) nData); } \
            BOOL Find(_IntItemType_ nData) { return CList::Find((LPVOID) nData); } \
            _IntItemType_ Get(void) { return (_IntItemType_) (UINT_PTR) CList::Get(); } \
            _IntItemType_ PeekHead(void) { return (_IntItemType_) (UINT_PTR) CList::PeekHead(); } \
            _IntItemType_ Iterate(void) { return (_IntItemType_) (UINT_PTR) CList::Iterate(); }


class CQueue : public CList
{
public:

    CQueue(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems, TRUE) { };
    CQueue(CQueue *pSrc) : CList((CList *) pSrc) { };
};


#define DEFINE_CQUEUE(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(void) : CQueue() { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue(cMaxItems) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue((CQueue *) pSrc) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue((CQueue *) &Src) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_PtrItemType_ pData) { return CList::Append((LPVOID) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CList::Prepend((LPVOID) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); }

#define DEFINE_CQUEUE_(_NewClass_,_IntItemType_) \
            public: \
            _NewClass_(void) : CQueue() { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue(cMaxItems) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue((CQueue *) pSrc) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue((CQueue *) &Src) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntItemType_ nData) { return CList::Append((LPVOID) nData); } \
            BOOL Prepend(_IntItemType_ nData) { return CList::Prepend((LPVOID) nData); } \
            BOOL Remove(_IntItemType_ nData) { return CList::Remove((LPVOID) nData); } \
            BOOL Find(_IntItemType_ nData) { return CList::Find((LPVOID) nData); } \
            _IntItemType_ Get(void) { return (_IntItemType_) (UINT_PTR) CList::Get(); } \
            _IntItemType_ PeekHead(void) { return (_IntItemType_) (UINT_PTR) CList::PeekHead(); } \
            _IntItemType_ Iterate(void) { return (_IntItemType_) (UINT_PTR) CList::Iterate(); }



typedef LPVOID          BOOL_PTR;
#define TRUE_PTR        ((LPVOID) (UINT_PTR)  1)
#define FALSE_PTR       ((LPVOID) (UINT_PTR) -1)

#define LPVOID_NULL     ((LPVOID) (UINT_PTR) -1)


#endif // _CONTAINED_LIST_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\ftldr.cpp ===
#include "mbftpch.h"
#include "ftldr.h"
#include "ftui.h"
// #include "SDKInternal.h"

CFtLoader  *g_pFtLoader = NULL;
BOOL        g_fNoUI = FALSE;

extern void ReadSettingsFromRegistry(void);
extern void LoadDefaultStrings(void);
extern DWORD __stdcall FTWorkThreadProc(LPVOID lpv);
extern HANDLE g_hWorkThread;
extern BOOL g_fShutdownByT120;

T120Error WINAPI CreateAppletLoaderInterface
(
    IAppletLoader     **ppOutIntf
)
{
    if (NULL != ppOutIntf)
    {
        *ppOutIntf = NULL;
        if (NULL == g_pFtLoader)
        {
            ::ReadSettingsFromRegistry();
            ::LoadDefaultStrings();
            if (g_fSendAllowed || g_fRecvAllowed)
            {
                DBG_SAVE_FILE_LINE
                *ppOutIntf = (IAppletLoader *) new CFtLoader();
                return ((NULL != *ppOutIntf) ? T120_NO_ERROR : T120_ALLOCATION_FAILURE);
            }
            return T120_POLICY_PROHIBIT;
        }
        return T120_ALREADY_INITIALIZED;
    }
    return T120_INVALID_PARAMETER;
}



//
// FT Applet Loader
//

CFtLoader::CFtLoader(void)
:
    CRefCount(MAKE_STAMP_ID('F','T','L','D'))
{
    ASSERT(NULL == g_pFtLoader);

    g_pFtLoader = this;
}


CFtLoader::~CFtLoader(void)
{
    ASSERT(this == g_pFtLoader);

    g_pFtLoader = NULL;
}


//
// Create the work thread and wait for its being started.
//
APPLDR_RESULT CFtLoader::AppletStartup
(
    BOOL        fNoUI
)
{

    APPLDR_RESULT eRet = APPLDR_FAIL;
    if (0 == g_dwWorkThreadID)
    {
        g_fNoUI = fNoUI;

        ASSERT(NULL == g_pFileXferApplet);
        HANDLE hSync = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != hSync)
        {
            g_hWorkThread = ::CreateThread(NULL, 0, FTWorkThreadProc, hSync, 0, &g_dwWorkThreadID);
            if (NULL != g_hWorkThread)
            {
                DWORD dwRet = ::WaitForSingleObject(hSync, FT_STARTUP_TIMEOUT);
                // ASSERT(NULL != g_pFileXferApplet);
                eRet = APPLDR_NO_ERROR;
            }
            ::CloseHandle(hSync);
        }
    }

	TCHAR szRecvFolder[MAX_PATH];
    ::GetRecvFolder(NULL, szRecvFolder);

    return eRet;
}



APPLDR_RESULT CFtLoader::AppletCleanup
(
    DWORD           dwTimeout
)
{
	::EnterCriticalSection(&g_csWorkThread);
    if (NULL != g_pFileXferApplet)
    {
        if (! g_pFileXferApplet->QueryShutdown(TRUE))
        {
			::LeaveCriticalSection(&g_csWorkThread);
            return APPLDR_CANCEL_EXIT;
        }
    }
	::LeaveCriticalSection(&g_csWorkThread);

    //
    // shut down the worker thread now
    //
    g_fShutdownByT120 = TRUE;

    T120_AppletStatus(APPLET_ID_FT, APPLET_CLOSING);

    // shuting down the work thread
    ASSERT(::GetCurrentThreadId() != g_dwWorkThreadID);

    if (NULL != g_pFileXferApplet)
    {   // Shutdown MBFTInterface ourself to make things simpler
        MSG msg;
        MBFTEngine *pEngine = g_pFileXferApplet->FindEngineWithIntf();
        if (pEngine)
        {
            DBG_SAVE_FILE_LINE
            InitUnInitNotifyMsg *pMsg = new InitUnInitNotifyMsg(EnumInvoluntaryUnInit);
            pEngine->GetInterfacePointer()->HandleInitUninitNotification(pMsg);
            delete pMsg;
        }
    }

    // shut down by T.120
	::EnterCriticalSection(&g_csWorkThread);

    // remember the event such that the work thread can access it
    if (NULL != g_pFileXferApplet)
    {
        CAppletWindow *pWindow;
        CWindowList *pList = g_pFileXferApplet->GetWindowList();
		pList->Reset();
		while (NULL != (pWindow = pList->Iterate()))
		{
			BOOL fRet = ::PostMessage(pWindow->GetHwnd(), WM_CLOSE, 0, 0);
			ASSERT(fRet);
		}
    } // if applet ptr

    ::LeaveCriticalSection(&g_csWorkThread);

    // wait for the worker thread's going down
    DWORD dwRet = ::WaitForSingleObject(g_hWorkThread, dwTimeout);

    return APPLDR_NO_ERROR;
}


APPLDR_RESULT CFtLoader::AppletQuery(APPLET_QUERY_ID eQueryId)
{
    ::EnterCriticalSection(&g_csWorkThread);
    if (NULL != g_pFileXferApplet)
    {
        switch (eQueryId)
        {
        case APPLET_QUERY_SHUTDOWN:
			// Don't really shuts down
        if (! g_pFileXferApplet->QueryShutdown(FALSE))  
        {
            ::LeaveCriticalSection(&g_csWorkThread);
            return APPLDR_CANCEL_EXIT;
        }
        break;
        }
    }
    ::LeaveCriticalSection(&g_csWorkThread);

    return APPLDR_NO_ERROR;
}

APPLDR_RESULT CFtLoader::OnNM2xNodeJoin(void)
{
    // Do nothing here
    return APPLDR_NO_ERROR;
}

APPLDR_RESULT CFtLoader::AppletInvoke
(
		BOOL            fLocal,
		T120ConfID      nConfID,
	    LPSTR           pszCmdLine
)
{
	// fLocal == TRUE  ==> local invoke
	if (fLocal && g_pFileXferApplet)  // Only bring UI to front for local invoke
	{
		::PostMessage(g_pFileXferApplet->GetHiddenWnd(), WM_BRING_TO_FRONT, 0, 0);
	} 
    return APPLDR_NO_ERROR;
}


void CFtLoader::ReleaseInterface(void)
{
    Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\ftldr.h ===
#ifndef _FileTransfer_AppletLoader_H_
#define _FileTransfer_AppletLoader_H_

#include <iappldr.h>


class CFtLoader : public CRefCount, public IAppletLoader
{
public:

    CFtLoader(void);
    ~CFtLoader(void);

    // IAppletLoader methods
    STDMETHOD_(void,           ReleaseInterface)(void);
	STDMETHOD_(APPLDR_RESULT,  AppletStartup)(BOOL fNoUI);
	STDMETHOD_(APPLDR_RESULT,  AppletCleanup)(DWORD dwTimeout);
	STDMETHOD_(APPLDR_RESULT,  AppletInvoke)(BOOL fLocal, T120ConfID nConfID, LPSTR pszCmdLine);
	STDMETHOD_(APPLDR_RESULT,  AppletQuery)(APPLET_QUERY_ID eQueryId);
    STDMETHOD_(APPLDR_RESULT,  OnNM2xNodeJoin)(void);
};


#endif // _FileTransfer_AppletLoader_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\localver.h ===
/* Version resource specific to msconfft.exe */

#define VER_DESCRIPTION_STR  "Conferencing File Transfer Utility\0"
#define VER_INTERNALNAME_STR "MsConfFt\0"
#define VER_ORIGNAME_STR     "MsConfFt.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\ftres.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Icons
//

#define IDI_FILE_TRANSFER               100
#define IDI_INCALL                      101
#define IDI_NOT_INCALL                  102

/////////////////////////////////////////////////////////////////////////////
//
// ACCELERATOR
//

#define RECVDLGACCELTABLE               130
#define LISTVIEWACCELTABLE              131

/////////////////////////////////////////////////////////////////////////////
//
// AVI
//

#define IDA_RECVDLG_ANIMATION           150
#define IDA_RECVDLG_DONE                151

/////////////////////////////////////////////////////////////////////////////
//
//  Bitmap
//

#define  IDB_ADDFILES                   180
#define  IDB_REMOVEFILES                181
#define  IDB_SENDFILE                   182
#define  IDB_STOPSEND                   183
#define  IDB_FOLDER                     184



/////////////////////////////////////////////////////////////////////////////
//
// Menus
//

#define IDR_MENU_FT                     200


/////////////////////////////////////////////////////////////////////////////
//
// Dialogs
//

#define IDD_ABOUTBOX                    300
#define IDC_ABOUT_VERSION               301

#define IDC_FILEXFER_PATH               305


#define IDD_RECVDLG                     310
#define IDC_RECVDLG_ANIMATE             311
#define IDC_RECVDLG_PROGRESS            312
#define IDE_RECVDLG_TIME                313
#define IDE_RECVDLG_RECFILE             314
#define IDE_RECVDLG_RECDIR              315
#define IDE_RECVDLG_SENDER              316
#define IDE_RECVDLG_RECBYTES            317
#define IDC_RECVDLG_MSG                 318

#define IDM_RECVDLG_ACCEPT              320
#define IDM_RECVDLG_OPEN                321
#define IDM_RECVDLG_DELETE              322

#define IDD_MSGBOX2                     330
#define IDE_MSGBOX2_TEXT                331


/////////////////////////////////////////////////////////////////////////////
//
// Controls
//
#define IDC_TOOL_BAR                    401
#define IDC_LIST_VIEW                   402
#define IDC_STATUS_BAR                  403
#define IDC_PROGRESS_BAR                404


/////////////////////////////////////////////////////////////////////////////
//
// Commands
//

#define IDM_EXIT                        1000

#define IDM_ADD_FILES                   1001
#define IDM_REMOVE_FILES                1002
#define IDM_SEND_ALL                    1003
#define IDM_SEND_ONE					1004
#define IDM_STOP_SENDING                1005
#define IDM_OPEN_RECV_FOLDER            1006
#define IDM_CHANGE_FOLDER               1007

#define IDM_HELP                        1200
#define IDM_ABOUT                       1201

#define IDM_RECEIVER                    1210


/////////////////////////////////////////////////////////////////////////////
//
// Strings
//
#define IDS_LANGNAME                    1997
#define IDS_MSFT_NOT_IN_CALL_WINDOW_CAPTION                    1998
#define IDS_MSFT_IN_CALL_WINDOW_CAPTION                        1999

#define NUM_LIST_VIEW_COLUMNS           4
#define IDS_LV_FILE_NAME                2000
#define IDS_LV_FILE_SIZE                2001
#define IDS_LV_FILE_STATUS              2002
#define IDS_LV_FILE_MODIFIED			2003
#define IDS_LV_FILE_SENT                2010
#define IDS_LV_FILE_SENDING             2011
#define IDS_LV_FILE_CANCELED            2012
#define IDS_LV_FILE_FAILED              2013

#define IDS_FILEDLG_TITLE               2020
#define IDS_FILEDLG_FILTER              2021
#define IDS_FILEDLG_SEND                2022

#define IDS_COPY_OF                     2031
#define IDS_COPY_N_OF                   2032
#define IDS_INVALID_NAME                2033

#define IDS_STBAR_NOT_IN_CALL           2040
#define IDS_STBAR_NOT_TRANSFERING       2041
#define IDS_STBAR_SENDING_XYZ           2042
#define IDS_STBAR_IN_CONFERENCE         2043

#define IDS_BROWSETITLE                 2045

#define IDS_MENU_FILE                   2048
#define IDS_MENU_HELP                   2049
#define IDS_MENU_ADD_FILES              2050
#define IDS_MENU_REMOVE_FILES           2051
#define IDS_MENU_SEND_ALL               2052
#define IDS_MENU_SEND_ONE				2053
#define IDS_MENU_STOP_SENDING           2054
#define IDS_MENU_OPEN_RECV_FOLDER       2055
#define IDS_MENU_CHANGE_FOLDER          2056
#define IDS_MENU_EXIT                   2057
#define IDS_RECEIVER_TT                 2058
 
#define IDS_MSGBOX2_CANCELED            2060
#define IDS_MSGBOX2_SEND_FAILED         2061
#define IDS_MSGBOX2_SEND_SUCCESS        2062
#define IDS_MSGBOX2_MULT_CANCEL         2063
#define IDS_INVALID_FILENAME            2064
#define IDS_MSGBOX2_INVALID_DIRECTORY   2065
#define IDS_MSGBOX2_DIRECTORY_FULL      2066
#define IDS_MSGBOX2_FILE_CREATE_FAILED  2067

#define IDS_MSGBOX_NO_CONF              2070
#define IDS_MSGBOX_BAD_RECDIR           2071
#define IDS_MSGBOX_POL_PREVENT          2072
#define IDS_MSGBOX_SEND_BIG_FILE        2073
#define IDS_QUERY_SEND_SHUTDOWN         2074
#define IDS_QUERY_SEND_HANGUP           2075
#define IDS_QUERY_RECVING_SHUTDOWN      2076
#define IDS_QUERY_RECVING_HANGUP        2077
#define IDS_QUERY_RECV_SHUTDOWN         2078
#define IDS_QUERY_RECV_HANGUP           2079

#define IDS_RECDIR_DEFAULT              2080


#define IDS_ALL_RECEIVER                2109
#define IDS_RECVDLG_CLOSE               2100
#define IDS_RECVDLG_FAILED              2101
#define IDS_RECVDLG_CANCEL              2102
#define IDS_RECVDLG_TITLE               2103
#define IDS_RECVDLG_RECBYTES            2104
#define IDS_RECVDLG_START               2105
#define IDS_RECVDLG_SECONDS             2106
#define IDS_RECVDLG_MINUTES             2107
#define IDS_RECVDLG_COMPLETE            2108

#define IDS_RECVDLG_DIRNOEXIST          2110
#define IDS_RECVDLG_DIRTOOSMALL         2111
#define IDS_RECVDLG_SENDER_CANCEL       2112

#define IDS_FILERECV_FILEREPLACE        2120
#define IDS_RECVDLG_FILESAVE            2121


#define ID_NAV_SHIFT_TAB               0x3627
#define ID_NAV_TAB                     0x3628
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\ftui.cpp ===
// File: ftui.h
#include "mbftpch.h"
#include <commctrl.h>
#include <regentry.h>
#include "ftui.h"
#include "version.h"
#include <iappldr.h>
#include <nmhelp.h>

static ULONG s_cMsgBox2Dlg = 0; // for alignment
static ULONG s_cRecvDlg = 0; // for alignment
static ULONG s_sort = -1;
ULONG _GetPercent(ULONG cbTotalRecvSize , ULONG cbFileSize);

TCHAR s_szMSFT[64];
static TCHAR s_szScratchText[MAX_PATH*2];
static const TCHAR s_cszHtmlHelpFile[] = TEXT("conf.chm");

#define MAX_FILE_NAME_LENGTH    30

LRESULT CALLBACK FtMainWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK RecvDlgProc(HWND, UINT, WPARAM, LPARAM);
LPTSTR PathNameToFileName(LPTSTR pszPathName);
HRESULT GetRecvFolder(LPTSTR pszInFldr, LPTSTR pszOutFldr);
BOOL MsgBox2(CAppletWindow *pWindow, LPTSTR pszText);

void ShiftFocus(HWND hwndTop, BOOL bForward);

void EnsureTrailingSlash(LPTSTR);
int MyLoadString(UINT idStr);
int MyLoadString(UINT idStr, LPTSTR pszDstStr);
int MyLoadString(UINT idStr, LPTSTR pszDstStr, LPTSTR pszElement);
int MyLoadString(UINT idStr, LPTSTR pszDstStr, LPTSTR pszElement1, LPTSTR pszElement2);
__inline int MyLoadString(UINT idStr, LPTSTR pszDstStr, UINT_PTR nElement)
                { return MyLoadString(idStr, pszDstStr, (LPTSTR) nElement); }
__inline int MyLoadString(UINT idStr, LPTSTR pszDstStr, UINT_PTR nElement1, UINT_PTR nElement2)
                { return MyLoadString(idStr, pszDstStr, (LPTSTR) nElement1, (LPTSTR) nElement2); }
int MyLoadString(UINT idStr, LPTSTR pszDstStr, LPTSTR pszElement1, UINT_PTR nElement2)
                { return MyLoadString(idStr, pszDstStr, pszElement1, (LPTSTR) nElement2); }
__inline int MyLoadString(UINT idStr, LPTSTR pszDstStr, UINT_PTR nElement1, LPTSTR pszElement2)
                { return MyLoadString(idStr, pszDstStr, (LPTSTR) nElement1, pszElement2); }

#define count_of(array)    (sizeof(array) / sizeof(array[0]))

void OnChangeFolder(void);
BOOL FBrowseForFolder(LPTSTR pszFolder, UINT cchMax, LPCTSTR pszTitle);
extern BOOL g_fShutdownByT120;


void OPT_GetFTWndPosition(RECT *pRect)
{
	int   iLeft, iTop, iRight, iBottom;
	RegEntry  reWnd( FILEXFER_KEY, HKEY_CURRENT_USER);

	iLeft   = reWnd.GetNumber(REGVAL_WINDOW_XPOS, 0);
	iTop    = reWnd.GetNumber(REGVAL_WINDOW_YPOS, 0);
	iRight  = reWnd.GetNumber(REGVAL_WINDOW_WIDTH, 0) + iLeft;
	iBottom = reWnd.GetNumber(REGVAL_WINDOW_HEIGHT, 0) + iTop;

	// If it was empty, use the new rect
	if (!(iBottom || iTop || iLeft || iRight))
	{
		return;
	}

   // Make sure that the window rectangle is (at least partially) on
   // screen, and not too large.  First get the screen size
   int screenWidth  = ::GetSystemMetrics(SM_CXSCREEN);
   int screenHeight = ::GetSystemMetrics(SM_CYSCREEN);
	// Check the window size
   if ((iRight - iLeft) > screenWidth)
   {
       iRight = iLeft + screenWidth;
   }

   if ((iBottom - iTop) > screenHeight)
   {
       iTop = screenHeight;
   }

   // Check the window position
   if (iLeft >= screenWidth)
   {
       // Off screen to the right - keep the width the same
       iLeft  = screenWidth - (iRight - iLeft);
       iRight = screenWidth;
   }

   if (iRight < 0)
   {
       // Off screen to the left - keep the width the same
       iRight = iRight - iLeft;
       iLeft  = 0;
   }

   if (iTop >= screenHeight)
   {
       // Off screen to the bottom - keep the height the same
       iTop    = screenHeight - (iBottom - iTop);
       iBottom = screenHeight;
   }

   if (iBottom < 0)
   {
       // Off screen to the top - keep the height the same
       iBottom = (iBottom - iTop);
       iTop    = 0;
   }

   pRect->left = iLeft;
   pRect->top = iTop;
   pRect->right = iRight - iLeft;
   pRect->bottom = iBottom - iTop;	
}


CAppletWindow::CAppletWindow(BOOL fNoUI, HRESULT *pHr)
:
    CRefCount(MAKE_STAMP_ID('F','T','U','I')),
    m_hwndMainUI(NULL),
	m_pToolbar(NULL),
    m_hwndListView(NULL),
    m_hwndStatusBar(NULL),
    m_pEngine(NULL),
    m_fInFileOpenDialog(FALSE),
    m_pCurrSendFileInfo(NULL),
    m_nCurrSendEventHandle(0),
	m_hIconInCall(NULL),
	m_hIconNotInCall(NULL)
{	
	m_UIMode = fNoUI ? FTUIMODE_NOUI : FTUIMODE_UIHIDDEN;
	::GetCurrentDirectory(MAX_PATH, m_szDefaultDir);

    *pHr = E_FAIL; // failure, at default

	// create window class name
	::wsprintf(&m_szFtMainWndClassName[0], TEXT("FTMainWnd%0X_%0X"), ::GetCurrentProcessId(), ::GetTickCount());
	ASSERT(::lstrlenA(&m_szFtMainWndClassName[0]) < sizeof(m_szFtMainWndClassName));

    // register window class first
    WNDCLASS wc;
    ::ZeroMemory(&wc, sizeof(wc));
    //wc.style			= 0;
    wc.lpfnWndProc      = FtMainWndProc;
    // wc.cbClsExtra    = 0;
    // wc.cbWndExtra    = 0;
    wc.hInstance        = g_hDllInst;
    wc.hIcon            = ::LoadIcon(g_hDllInst, MAKEINTRESOURCE(IDI_FILE_TRANSFER));
    // wc.hbrBackground = NULL;
    // wc.hCursor       = NULL;
    wc.lpszMenuName     = MAKEINTRESOURCE(IDR_MENU_FT);
    wc.lpszClassName    = m_szFtMainWndClassName;
    if (::RegisterClass(&wc))
    {
		::MyLoadString(IDS_MSFT_NOT_IN_CALL_WINDOW_CAPTION);
        m_hwndMainUI = ::CreateWindow(
                    m_szFtMainWndClassName,
                    s_szScratchText,
                    WS_OVERLAPPEDWINDOW | WS_TABSTOP,
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    NULL,   // no parent window
                    NULL,   // use class' menu
                    g_hDllInst,
                    (LPVOID) this);  // this window is for this object
        if (NULL != m_hwndMainUI)
        {
            // success
            *pHr = S_OK;
        }
    }
	m_hAccel = ::LoadAccelerators(g_hDllInst, MAKEINTRESOURCE(RECVDLGACCELTABLE));
	m_hLVAccel = ::LoadAccelerators(g_hDllInst, MAKEINTRESOURCE(LISTVIEWACCELTABLE));
}
	


CAppletWindow::~CAppletWindow(void)
{
    ASSERT(NULL == m_hwndMainUI);

    ::UnregisterClass(m_szFtMainWndClassName, g_hDllInst);

    ClearSendInfo(FALSE);
    ClearRecvInfo();

	if (m_hIconInCall)
		::DestroyIcon(m_hIconInCall);
	if (m_hIconNotInCall)
		::DestroyIcon(m_hIconNotInCall);

    ASSERT(NULL == m_pEngine);
}


BOOL CAppletWindow::FilterMessage(MSG *pMsg)
{
	CRecvDlg *pRecvDlg;
	HWND      hwndError;
	HWND		hwndForeground = ::GetForegroundWindow();

	m_RecvDlgList.Reset();
	while (NULL != (pRecvDlg = m_RecvDlgList.Iterate()))
	{
		if (::IsDialogMessage(pRecvDlg->GetHwnd(), pMsg))
		{
			return TRUE;
		}
	}
	if (hwndForeground == m_hwndMainUI)
	{
		BOOL fRet = ::TranslateAccelerator(m_hwndMainUI, m_hLVAccel, pMsg);
		return fRet;
	}


	
	
	m_ErrorDlgList.Reset();
	while (NULL != (hwndError = m_ErrorDlgList.Iterate()))
	{
		if (::IsDialogMessage(hwndError, pMsg))
		{
			return TRUE;
		}
	}
	return FALSE;
}


BOOL CAppletWindow::QueryShutdown(BOOL fShutdown)
{
	if (m_UIMode != FTUIMODE_NOUI)
	{
		int id = 0;
		if (m_nCurrSendEventHandle)
		{
			id = (fShutdown)?IDS_QUERY_SEND_SHUTDOWN:IDS_QUERY_SEND_HANGUP;
		}
		else if (IsReceiving())
		{
			id = (fShutdown)?IDS_QUERY_RECVING_SHUTDOWN:IDS_QUERY_RECVING_HANGUP;
		}

		if (id)
		{
			// could be in any thread
			TCHAR szText[MAX_PATH];
			if (::MyLoadString(id, szText))
			{
				if (IDNO == ::MessageBox(NULL, szText, s_szMSFT, MB_TASKMODAL | MB_YESNO | MB_ICONQUESTION))
				{
					return FALSE;
				}
			}
		}
	}

	if (m_nCurrSendEventHandle)
    {
		OnStopSending();
	}
	if (IsReceiving())
	{
		CRecvDlg *pRecvDlg = NULL;
		m_RecvDlgList.Reset();
		while (NULL != (pRecvDlg = m_RecvDlgList.Iterate()))
		{
            DBG_SAVE_FILE_LINE
			GetEngine()->SafePostMessage(
                   new FileTransferControlMsg(
                                        pRecvDlg->GetEventHandle(),
                                        pRecvDlg->GetFileHandle(),
                                        NULL,
                                        NULL,
                                        FileTransferControlMsg::EnumAbortFile));
		}
	}
    return TRUE;
}


void CAppletWindow::RegisterEngine(MBFTEngine *pEngine)
{
    ASSERT(NULL == m_pEngine);
    pEngine->AddRef();
    m_pEngine = pEngine;
    UpdateUI();
}


void CAppletWindow::UnregisterEngine(void)
{
    if (NULL != m_pEngine)
    {
        m_pEngine->Release();
        m_pEngine = NULL;
        ClearSendInfo(TRUE);
        ClearRecvInfo();
    }
	if (UIHidden())
	{   // exit
		::PostMessage(m_hwndMainUI, WM_CLOSE, 0, 0);
	}
	else
	{
		UpdateUI();  // don't quit
	}
}


void CAppletWindow::RegisterRecvDlg(CRecvDlg *pDlg)
{
    m_RecvDlgList.Prepend(pDlg);
}


void CAppletWindow::UnregisterRecvDlg(CRecvDlg *pDlg)
{
    m_RecvDlgList.Remove(pDlg);
	FocusNextRecvDlg();
}


BOOL CAppletWindow::IsReceiving(void)
{
	BOOL fRet = FALSE;
	CRecvDlg *pDlg;
	CUiRecvFileInfo *pRecvFile;
	m_RecvDlgList.Reset();
    while (NULL != (pDlg = m_RecvDlgList.Iterate()))
    {
		pRecvFile = pDlg->GetRecvFileInfo();
		if (pRecvFile && (pRecvFile->GetTotalRecvSize() < pRecvFile->GetSize()))
        {
			fRet = TRUE;
            break;
        }
    }
    return fRet;
}

CRecvDlg * CAppletWindow::FindDlgByHandles(MBFTEVENTHANDLE nEventHandle, MBFTFILEHANDLE nFileHandle)
{
    CRecvDlg *pDlg;
    m_RecvDlgList.Reset();
    while (NULL != (pDlg = m_RecvDlgList.Iterate()))
    {
        if (nEventHandle == pDlg->GetEventHandle() &&
            nFileHandle == pDlg->GetFileHandle())
        {
            break;
        }
    }
    return pDlg;
}


/////////////////////////////////////////////////////////////////
//
//  WM_CREATE
//

LRESULT OnCreate(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CREATESTRUCT *p = (CREATESTRUCT *) lParam;
    CAppletWindow *pWindow = (CAppletWindow *) p->lpCreateParams;

    ASSERT(NULL != pWindow);
    ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) p->lpCreateParams);

    pWindow->SetHwnd(hwnd);

    ::InitCommonControls();

    pWindow->CreateToolBar();
    pWindow->CreateStatusBar();
    pWindow->CreateListView();

    ::DragAcceptFiles(hwnd, g_fSendAllowed);

    // resize the window
    MINMAXINFO mmi;
    ::ZeroMemory(&mmi, sizeof(mmi));
    pWindow->OnGetMinMaxInfo(&mmi);
    RECT rcUI;

    ::GetWindowRect(pWindow->GetHwnd(), &rcUI);
	rcUI.right  = mmi.ptMinTrackSize.x;
	rcUI.bottom = mmi.ptMinTrackSize.y + 30;
	OPT_GetFTWndPosition(&rcUI);

    ::MoveWindow(pWindow->GetHwnd(), rcUI.left, rcUI.top,
                 rcUI.right, rcUI.bottom, TRUE);

    pWindow->UpdateUI();

#if defined(TEST_PLUGABLE) && defined(_DEBUG)
    ::OnPluggableBegin(hwnd);
#endif
    return 0;
}


enum
{
    TB_IDX_ADD_FILES = 0,
    TB_IDX_REMOVE_FILES,
    TB_IDX_BREAK_1,
    TB_IDX_IDM_SEND_ALL,
	TB_IDX_IDM_SEND_ONE,
    TB_IDX_IDM_STOP_SENDING,
    TB_IDX_BREAK_2,
    TB_IDX_IDM_OPEN_RECV_FOLDER,
	TB_IDX_IDM_CHANGE_FOLDER,
    TB_IDX_BREAK_3,
    TB_IDX_IDM_HELP,
};


static Buttons buttons [] =
{
	{IDB_ADDFILES,		CBitmapButton::Disabled+1,	1,	IDM_ADD_FILES,          (LPCSTR)IDS_MENU_ADD_FILES,},
	{IDB_REMOVEFILES,	CBitmapButton::Disabled+1,	1,	IDM_REMOVE_FILES,       (LPCSTR)IDS_MENU_REMOVE_FILES,},
	{0,					0,							0,	0,						0,},
	{IDB_SENDFILE,		CBitmapButton::Disabled+1,	1,	IDM_SEND_ALL,           (LPCSTR)IDS_MENU_SEND_ALL,},
	{IDB_STOPSEND,		CBitmapButton::Disabled+1,	1,	IDM_STOP_SENDING,       (LPCSTR)IDS_MENU_STOP_SENDING,},
	{0,					0,							0,	0,						0,},
	{IDB_FOLDER,		CBitmapButton::Disabled+1,	1,	IDM_OPEN_RECV_FOLDER,   (LPCSTR)IDS_MENU_OPEN_RECV_FOLDER,},
	{0,					0,							0,	0,						0},
};


BOOL CAppletWindow::CreateToolBar(void)
{
    DBG_SAVE_FILE_LINE
	m_pToolbar = new CComboToolbar();
	if (m_pToolbar)
	{
		m_pToolbar->Create(m_hwndMainUI, &buttons[0], count_of(buttons), this);
		m_pToolbar->Release();
		return TRUE;
	}
    return FALSE;
}


BOOL CAppletWindow::CreateStatusBar(void)
{
    m_hwndStatusBar = ::CreateWindowEx(0,
                        STATUSCLASSNAME, // status bar class
                        TEXT(""), // no default text
                        WS_CHILD | WS_VISIBLE | SBS_SIZEGRIP,
                        0, 0, 0, 0,
                        m_hwndMainUI,
                        (HMENU) IDC_STATUS_BAR,
                        g_hDllInst,
                        NULL);
    ASSERT(NULL != m_hwndStatusBar);
    if (NULL != m_hwndStatusBar)
    {	
		// Load Call Icons
		m_hIconInCall = (HICON) ::LoadImage(g_hDllInst,
							MAKEINTRESOURCE(IDI_INCALL),
							IMAGE_ICON,
							::GetSystemMetrics(SM_CXSMICON),
							::GetSystemMetrics(SM_CYSMICON),
							LR_DEFAULTCOLOR);
		m_hIconNotInCall = (HICON) ::LoadImage(g_hDllInst,
							MAKEINTRESOURCE(IDI_NOT_INCALL),
							IMAGE_ICON,
							::GetSystemMetrics(SM_CXSMICON),
							::GetSystemMetrics(SM_CYSMICON),
							LR_DEFAULTCOLOR);
		if (CreateProgressBar())
		{
			return TRUE;
		}
    }
    return FALSE;
}


BOOL CAppletWindow::CreateProgressBar(void)
{
	RECT  rcl;

	GetClientRect(m_hwndStatusBar, &rcl);
	m_hwndProgressBar = ::CreateWindowEx(0, PROGRESS_CLASS, TEXT(""),
				WS_CHILD | WS_VISIBLE | PBS_SMOOTH,
				rcl.right/2 + 2, 2, rcl.right - rcl.right/2 - 40, rcl.bottom - 8,
				m_hwndStatusBar,  (HMENU)IDC_PROGRESS_BAR,
				g_hDllInst, NULL);
	
	if (m_hwndProgressBar)
	{
		::SendMessage(m_hwndProgressBar, PBM_SETRANGE, 0L, MAKELONG(0, 100));
		return TRUE;
	}
	return FALSE;
}


BOOL CAppletWindow::CreateListView(void)
{
    // get the size and position of the main window
    RECT rcWindow, rcToolBar, rcStatusBar;
	SIZE	szToolBar;
    ::GetClientRect(m_hwndMainUI, &rcWindow);
	m_pToolbar->GetDesiredSize(&szToolBar);
    ::GetWindowRect(m_hwndStatusBar, &rcStatusBar);

    ULONG x = 0;
    ULONG y = szToolBar.cy - 1;
    ULONG cx = rcWindow.right - rcWindow.left;
    ULONG cy = rcWindow.bottom - rcWindow.top - y - (rcStatusBar.bottom - rcStatusBar.top) + 1;

    // create the list view window
    m_hwndListView = ::CreateWindowEx(WS_EX_CLIENTEDGE,  // sunken look
                        WC_LISTVIEW , // list view class
                        TEXT(""), // no default text
                        WS_VISIBLE | WS_CHILD | WS_BORDER | LVS_REPORT |WS_TABSTOP |
                        LVS_AUTOARRANGE | WS_CLIPCHILDREN | LVS_SHOWSELALWAYS,
                        x, y, cx, cy,
                        m_hwndMainUI,
                        (HMENU) IDC_LIST_VIEW,
                        g_hDllInst,
                        NULL);
    ASSERT(NULL != m_hwndListView);
    if (NULL != m_hwndListView)
    {
        // set extended list view styles
        DWORD dwExtStyle = ListView_GetExtendedListViewStyle(m_hwndListView);
        dwExtStyle |= (LVS_EX_HEADERDRAGDROP | LVS_EX_SUBITEMIMAGES | LVS_EX_FULLROWSELECT);
        ListView_SetExtendedListViewStyle(m_hwndListView, dwExtStyle);

        // enable window only if we can send files
        ::EnableWindow(m_hwndListView, g_fSendAllowed);

        // set up the columns
        ULONG i;
        LVCOLUMN  lvc;
        LVITEM lvi;
        TCHAR szText[64];
		int iColumnSize[NUM_LIST_VIEW_COLUMNS] = {150, 80, 70, 130}; // listview column size

        // initialize the common part of the columns
        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvc.fmt = LVCFMT_LEFT; // left-aligned column
        lvc.pszText = szText;

        // initialize columns one by one
        for (i = 0; i < NUM_LIST_VIEW_COLUMNS; i++)
        {
            lvc.iSubItem = i;
            ::LoadString(g_hDllInst, IDS_LV_FILE_NAME + i, szText, count_of(szText));
			lvc.cx = iColumnSize[i];
            int iRet = ListView_InsertColumn(m_hwndListView, lvc.iSubItem, &lvc);
            ASSERT(-1 != iRet);
        }
        return TRUE;
    }
    return FALSE;
}



BOOL  CAppletWindow::DrawItem(LPDRAWITEMSTRUCT pdis)
{
    ASSERT(pdis);
    if (NULL != (pdis->itemData))
    {
        int nWidth = pdis->rcItem.right - pdis->rcItem.left;
        int nHeight = pdis->rcItem.bottom - pdis->rcItem.top;
        int nLeft = pdis->rcItem.left;
        int nTop = pdis->rcItem.top;
        int xSmIcon = ::GetSystemMetrics(SM_CXSMICON);
        int ySmIcon = ::GetSystemMetrics(SM_CYSMICON);

        if (nWidth > xSmIcon)
        {
            nLeft += (nWidth - xSmIcon) / 2 - 5;
            nWidth = xSmIcon;
        }
        if (nHeight > ySmIcon)
        {
            nTop += (nHeight - ySmIcon) / 2;
            nHeight = ySmIcon;
        }

        ::DrawIconEx(   pdis->hDC,
                        nLeft,
                        nTop,
                        (HICON) (pdis->itemData),
                        nWidth,
                        nHeight,
                        0,
                        NULL,
                        DI_NORMAL);
    }

    return TRUE;
}


void CAppletWindow::OnCommand(WORD  wId, HWND hwndCtl, WORD codeNotify)
{
	switch (wId)
	{
	case IDM_ADD_FILES:
		OnAddFiles();
		UpdateUI();
		break;

	case IDM_REMOVE_FILES:
		OnRemoveFiles();
		UpdateUI();
		break;

	case IDM_SEND_ALL:
		s_cMsgBox2Dlg = 0;
		SetSendMode(TRUE);
		OnSendAll();
		UpdateUI();
		break;

	case IDM_SEND_ONE:
		s_cMsgBox2Dlg = 0;
		SetSendMode(FALSE);
		OnSendOne();
		UpdateUI();
		break;

	case IDM_STOP_SENDING:
		OnStopSending();
		UpdateUI();
		break;

	case IDM_OPEN_RECV_FOLDER:
		OnOpenRecvFolder();
		break;

	case IDM_CHANGE_FOLDER:
		OnChangeFolder();
		break;

	case IDM_EXIT:
		OnExit();
		break;

	case IDM_HELP:
		OnHelp();
		break;

	case ID_NAV_TAB:
		ShiftFocus(m_hwndMainUI, TRUE);
		if(GetFocus() == m_hwndListView)
		{
			SetListViewFocus();
		}
		break;

	case ID_NAV_SHIFT_TAB:
		ShiftFocus(m_hwndMainUI, FALSE);
		if(GetFocus() == m_hwndListView)
		{
			SetListViewFocus();
		
		}
		break;

	case IDM_ABOUT:
		OnAbout();
		break;

	default:
		WARNING_OUT(("FT::OnCommand: unknown command ID=%u", (UINT) wId));
		break;
	}
	return;
}



/////////////////////////////////////////////////////////////////
//
//  WM_COMMAND
//

LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (NULL != pWindow)
	{
		WORD    wNotifyCode = GET_WM_COMMAND_CMD(wParam, lParam); // notification code
		WORD    wID = GET_WM_COMMAND_ID(wParam, lParam); // item, control, or accelerator identifier
		HWND    hwndCtl = (HWND) lParam; // handle of control

		pWindow->OnCommand(wID, hwndCtl, wNotifyCode);
		return 0;
	}
	else
	{
		WARNING_OUT((" CAppletWindow::OnCommand--Received unhandled window message.\n"));
	}
	return (DefWindowProc(hwnd, WM_COMMAND, wParam, lParam));
}


//
// OnAddFiles
//

UINT_PTR APIENTRY SendFileDlgHookProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (WM_INITDIALOG == uMsg)
    {
        hdlg = ::GetParent(hdlg);  // Real dialog is this window's parent

        if (::MyLoadString(IDS_FILEDLG_SEND))
        {
            ::SetDlgItemText(hdlg, IDOK, s_szScratchText);
        }
    }
    return 0;
}

void CAppletWindow::OnAddFiles(void)
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szFilter[MAX_PATH];
    TCHAR szDirSav[MAX_PATH];
    TCHAR szSendDir[MAX_PATH];

    // Load dialog title and filter strings
    if (::MyLoadString(IDS_FILEDLG_TITLE, szTitle) &&
        ::MyLoadString(IDS_FILEDLG_FILTER, szFilter))
    {
        // replace '|' to '\0'
        LPTSTR pszFltr = szFilter;
        while (TEXT('\0') != *pszFltr)
        {
            if (TEXT('|') == *pszFltr)
            {
                *pszFltr = TEXT('\0');
                pszFltr++; // cannot use CharNext
            }
            else
            {
                pszFltr = ::CharNext(pszFltr);
            }
        }

        // only allow one "Select a file to send" dialog
        if (! m_fInFileOpenDialog)
        {
            m_fInFileOpenDialog = TRUE;

            // Allocate a really large buffer to hold the file list
            ULONG cbBufSize = 8192;
            DBG_SAVE_FILE_LINE
            LPTSTR pszBuffer = new TCHAR[cbBufSize];
            if (NULL != pszBuffer)
            {
                *pszBuffer = TEXT('\0'); // start with null string

                OPENFILENAME ofn;
                ::ZeroMemory(&ofn, sizeof(ofn));
                ofn.lStructSize   = sizeof(ofn);
                ofn.hwndOwner     = m_hwndMainUI;
                ofn.hInstance     = g_hDllInst;
                ofn.lpstrFilter   = &szFilter[0];
                ofn.nFilterIndex  = 1L; // FUTURE: remember filter preference
                ofn.lpstrFile     = pszBuffer;
                ofn.nMaxFile      = cbBufSize - 1; // Number of TCHAR in pszFiles (not including NULL)
                ofn.lpstrTitle    = &szTitle[0];
                ofn.lpstrInitialDir = m_szDefaultDir;
                ofn.lpfnHook      = SendFileDlgHookProc;

                ofn.Flags = OFN_ALLOWMULTISELECT | OFN_ENABLEHOOK | // OFN_HIDEREADONLY |
                            OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_EXPLORER;

                // remember current directory
				::ZeroMemory(szSendDir, sizeof(szSendDir));
                ::GetCurrentDirectory(count_of(szDirSav), szDirSav);
                ::lstrcpyn(szSendDir, szDirSav, count_of(szSendDir));

                if (::GetOpenFileName(&ofn))
                {
                    // if there is only a single file, the first string is the full path.
                    // if there are more than one file, the first string is the directory path
                    // and followed by a list of file names. terminated by double null

                    // remember the working directory for next time
                    ULONG cchDirPath;
                    LPTSTR pszFileName;
                    ULONG cchFile = ::lstrlen(ofn.lpstrFile);
                    if (TEXT('\0') == ofn.lpstrFile[cchFile] && TEXT('\0') == ofn.lpstrFile[cchFile+1])
                    {
                        //
                        // only a single file
                        //
                        pszFileName = ::PathNameToFileName(ofn.lpstrFile);
                        cchDirPath = (ULONG)(pszFileName - ofn.lpstrFile);
                        if (cchDirPath)
                        {
                            cchDirPath--; // back to '\\'
                        }
                        ASSERT(TEXT('\\') == ofn.lpstrFile[cchDirPath]);
                        ofn.lpstrFile[cchDirPath] = TEXT('\0');
                    }
                    else
                    {
                        //
                        // multiple files
                        //
                        cchDirPath = ::lstrlen(ofn.lpstrFile);
                        pszFileName = ofn.lpstrFile + cchDirPath + 1;
                    }
					::lstrcpy(m_szDefaultDir, ofn.lpstrFile);

					EnsureTrailingSlash(m_szDefaultDir);

					::ZeroMemory(szSendDir, sizeof(szSendDir));
                    ::CopyMemory(szSendDir, ofn.lpstrFile, cchDirPath * sizeof(TCHAR));
					EnsureTrailingSlash(szSendDir);

                    // set up the common portion of list view item
                    LVITEM lvi;
                    ::ZeroMemory(&lvi, sizeof(lvi));
                    // lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
                    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;

                    // iterate the file name
                    while ('\0' != *pszFileName)
                    {
                        BOOL fRet;
                        DBG_SAVE_FILE_LINE
                        CUiSendFileInfo *pFileInfo = new CUiSendFileInfo(this, szSendDir, pszFileName, &fRet);
                        if (NULL != pFileInfo && fRet)
                        {
                            // put it to the list view
                            lvi.iItem = ListView_GetItemCount(m_hwndListView);
                            lvi.iSubItem = 0;
                            // we are responsible for storing the text to display
                            lvi.pszText = LPSTR_TEXTCALLBACK;
                            lvi.cchTextMax = MAX_PATH;
                            lvi.lParam = (LPARAM) pFileInfo;
                            int iRet = ListView_InsertItem(m_hwndListView, &lvi);
                            ASSERT(-1 != iRet);
                            // UpdateListView(pFileInfo);
                        }
                        else
                        {
                            delete pFileInfo;
                        }

                        // get to the next file name
                        pszFileName += ::lstrlen(pszFileName) + 1;
                    } // while
                }
                else
                {
                    // err code for cancel is zero, which is ok.
                    ASSERT(! ::CommDlgExtendedError());
                }

                // restore old working directory
                ::SetCurrentDirectory(szDirSav);
            }

            delete [] pszBuffer;
            m_fInFileOpenDialog = FALSE;
        }
        else
        {
            // bring the active dialog to the front
            BringToFront();
        }
    } // if LoadString
}


//
// OnRemoveFiles
//

void CAppletWindow::OnRemoveFiles(void)
{
    UINT nState;
    ULONG cItems = ListView_GetItemCount(m_hwndListView);
    LVITEM lvi;
    ::ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_SELECTED;
    ULONG i = 0;
    while (i < cItems)
    {
        lvi.iItem = i;
        BOOL fRet = ListView_GetItem(m_hwndListView, &lvi);
        if (fRet && lvi.state & LVIS_SELECTED)
        {
            CUiSendFileInfo *pFileInfo = (CUiSendFileInfo *) lvi.lParam;
            if (pFileInfo == m_pCurrSendFileInfo)
            {
                OnStopSending();
                ClearSendInfo(FALSE);
            }
            delete pFileInfo;

            fRet = ListView_DeleteItem(m_hwndListView, i);
            ASSERT(fRet);

            cItems--;
            ASSERT((ULONG) ListView_GetItemCount(m_hwndListView) == cItems);
        }
        else
        {
            i++;
        }
    }
	if (cItems > 0)  // set focus to first remaining item
	{
		SetListViewFocus();
	}
}


void CAppletWindow::OnRemoveAllFiles(void)
{
    BOOL fRet;
    CUiSendFileInfo *pFileInfo;
    ULONG cItems = ListView_GetItemCount(m_hwndListView);
    LVITEM lvi;
    ::ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM;
    for (ULONG i = 0; i < cItems; i++)
    {
        lvi.iItem = i;
        fRet = ListView_GetItem(m_hwndListView, &lvi);
        ASSERT(fRet);
        pFileInfo = (CUiSendFileInfo *) lvi.lParam;
        if (pFileInfo == m_pCurrSendFileInfo)
        {
            ClearSendInfo(FALSE);
        }
        delete pFileInfo;
    }

    fRet = ListView_DeleteAllItems(m_hwndListView);
    ASSERT(fRet);
}


void CAppletWindow::OnSendAll(void)
{
	if ((NULL == m_pCurrSendFileInfo)&&(NULL != m_pEngine))
    {
		CUiSendFileInfo *pFileInfo = ChooseFirstUnSentFile();
		SendNow(pFileInfo);
	}
}

void CAppletWindow::OnSendOne(void)
{
	if ((NULL == m_pCurrSendFileInfo)&&(NULL != m_pEngine))
    {	
		CUiSendFileInfo *pFileInfo = ChooseSelectedFile();
		if (!pFileInfo)
		{
			pFileInfo = ChooseFirstUnSentFile();
		}
		SendNow(pFileInfo);
	}
}


//
// SendNow
//

BOOL CAppletWindow::SendNow(CUiSendFileInfo *pFileInfo)
{
	BOOL fRet;

    if (NULL != pFileInfo)
    {
        // send this file now...
        m_pCurrSendFileInfo = pFileInfo;
        m_nCurrSendEventHandle = ::GetNewEventHandle();
        pFileInfo->SetFileHandle(::GetNewFileHandle());

        // duplicate full file name
        ULONG cbSize = ::lstrlen(pFileInfo->GetFullName()) + 1;
        DBG_SAVE_FILE_LINE
        LPTSTR pszFullName = new TCHAR[cbSize];
        if (NULL != pszFullName)
        {
            ::CopyMemory(pszFullName, pFileInfo->GetFullName(), cbSize);

            DBG_SAVE_FILE_LINE
            if (S_OK == m_pEngine->SafePostMessage(
                                     new CreateSessionMsg(MBFT_PRIVATE_SEND_TYPE,
                                                          m_nCurrSendEventHandle)))
            {
				int iSelect;
				MEMBER_ID nMemberID;
				iSelect = m_pToolbar->GetSelectedItem((LPARAM*)&nMemberID);
				if (0 == iSelect)
				{   // Send to All
					DBG_SAVE_FILE_LINE
					if (S_OK == m_pEngine->SafePostMessage(
										new SubmitFileSendMsg(0, 0, pszFullName,
													pFileInfo->GetFileHandle(),
													m_nCurrSendEventHandle,
													FALSE)))
					{
						return TRUE;
					}
					else
					{
						ERROR_OUT(("CAppletWindow::SendNow: cannot create SubmitFileSendMsg"));
					}
				}
				else
				{   // Send to one
					T120UserID uidRecv = GET_PEER_ID_FROM_MEMBER_ID(nMemberID);

					DBG_SAVE_FILE_LINE
					if (S_OK == m_pEngine->SafePostMessage(
										new SubmitFileSendMsg(uidRecv, 0, pszFullName,
													pFileInfo->GetFileHandle(),
													m_nCurrSendEventHandle,
													FALSE)))
					{
						return TRUE;
					}
					else
					{
						ERROR_OUT(("CAppletWindow::SendNow: cannot create SubmitFileSendMsg to 1"));
					}
				}
            }
            else
            {
                ERROR_OUT(("CAppletWindow::SendNow: cannot create CreateSessionMsg"));
            }

            delete [] pszFullName;
        }
		ClearSendInfo(TRUE);
	}
	return FALSE;
}


CUiSendFileInfo *CAppletWindow::ChooseFirstUnSentFile(void)
{
    CUiSendFileInfo *pFileInfo = NULL;
    ULONG cItems = ListView_GetItemCount(m_hwndListView);

    if (cItems > 0)
    {
        // examine each item one by one
        LVITEM lvi;
        ::ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask = LVIF_PARAM;
        for (ULONG i = 0; i < cItems; i++, pFileInfo = NULL)
        {
            lvi.iItem = i;
            BOOL fRet = ListView_GetItem(m_hwndListView, &lvi);
            ASSERT(fRet);
            pFileInfo = (CUiSendFileInfo *) lvi.lParam;
            // if file handle is not zero, then it has been sent
            if (! pFileInfo->GetFileHandle())
            {
                break;
            }
        }
	}
	return pFileInfo;
}

CUiSendFileInfo *CAppletWindow::ChooseSelectedFile(void)
{
	CUiSendFileInfo *pFileInfo = NULL;
    ULONG cItems = ListView_GetItemCount(m_hwndListView);
    LVITEM lvi;
    ::ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_SELECTED;
    ULONG i = 0;
    while (i < cItems)
    {
        lvi.iItem = i;
        BOOL fRet = ListView_GetItem(m_hwndListView, &lvi);
        if (fRet && lvi.state & LVIS_SELECTED)
        {
            pFileInfo = (CUiSendFileInfo *) lvi.lParam;
			pFileInfo->SetErrorCode(iMBFT_OK);
			break;
        }
        else
        {
            i++;
			pFileInfo = NULL;
        }
    }
	return pFileInfo;
}


//
// OnMenuSelect
//

void CAppletWindow::OnMenuSelect(UINT uiItemID, UINT uiFlags, HMENU hSysMenu)
{
    UINT   firstMenuId;
    UINT   statusId;

    //
    // Work out the help ID for the menu item.  We have to store this now
    // because when the user presses F1 from a menu item, we can't tell
    // which item it was.
    //
	
    if ((uiFlags & MF_POPUP) && (uiFlags & MF_SYSMENU))
    {
        // System menu selected
        statusId = (m_pCurrSendFileInfo)?IDS_STBAR_SENDING_XYZ:IDS_STBAR_NOT_TRANSFERING;
    }
    else if (uiFlags & MF_POPUP)
	{
        // get popup menu handle and first item
        HMENU hPopup = ::GetSubMenu( hSysMenu, uiItemID );
        firstMenuId = ::GetMenuItemID( hPopup, 0 );

		switch(firstMenuId)
		{
		case IDM_ADD_FILES:
			statusId = IDS_MENU_FILE;
			break;

		case IDM_HELP:
			statusId = IDS_MENU_HELP;
			break;

		default:
			statusId = (m_pCurrSendFileInfo)?IDS_STBAR_SENDING_XYZ:IDS_STBAR_NOT_TRANSFERING;
		}
	}
	else
    {
        // A normal menu item has been selected
        statusId   = uiItemID;
    }

    // Set the new help text
    TCHAR   szStatus[256];

    if (::LoadString(g_hDllInst, statusId, szStatus, 256))
    {
        ::SendMessage(m_hwndStatusBar, SB_SETTEXT, SBP_TRANSFER_FILE, (LPARAM)szStatus);
    }	
}


//
// OnStopSending
//

void CAppletWindow::OnStopSending(void)
{
	m_fSendALL = FALSE;
    if (m_nCurrSendEventHandle)
    {
        DBG_SAVE_FILE_LINE
        HRESULT hr = m_pEngine->SafePostMessage(
                            new FileTransferControlMsg(
                                            m_nCurrSendEventHandle,
                                            m_pCurrSendFileInfo->GetFileHandle(),
                                            NULL,
                                            NULL,
                                            FileTransferControlMsg::EnumAbortFile));
        ASSERT(hr == S_OK);
    }
}


//
// OnOpenRecvFolder
//

void CAppletWindow::OnOpenRecvFolder(void)
{
    TCHAR szRecvFolder[MAX_PATH];

	while (1)
	{
	    if (S_OK == ::GetRecvFolder(NULL, szRecvFolder))
		{
			::ShellExecute(NULL, NULL, szRecvFolder, NULL, NULL, SW_SHOWNORMAL);
			break;
		}
		else if (m_UIMode != FTUIMODE_NOUI)
		{
			::MyLoadString(IDS_RECVDLG_DIRNOEXIST, s_szScratchText, szRecvFolder);
			if (IDYES == ::MessageBox(m_hwndMainUI, s_szScratchText, s_szMSFT, MB_YESNO))
			{
				OnChangeFolder();
			}
			else
			{
				break;
			}
		}
    }
}


//
// OnChageFolder
//

void OnChangeFolder(void)
{
	BOOL rc;
	TCHAR szPath[MAX_PATH];

    ::GetRecvFolder(NULL, szPath);
    if (::lstrlen(szPath) > MAX_FILE_NAME_LENGTH)
    {
        LPTSTR psz = szPath;
        int i = MAX_FILE_NAME_LENGTH - 1;
        while (i)
        {
            psz = CharNext(psz);
            i--;
        }
        ::lstrcpy(psz, TEXT("..."));
    }
	::MyLoadString(IDS_BROWSETITLE, s_szScratchText, szPath);

	if (FBrowseForFolder(szPath, CCHMAX(szPath), s_szScratchText))
	{
		::GetRecvFolder(szPath, szPath);
	}
}


//
// OnExit
//

void CAppletWindow::OnExit(BOOL fNoQuery)
{
    if ((g_pFileXferApplet->InConf() || g_pFileXferApplet->HasSDK())
		&& ! g_fShutdownByT120)
    {
        // There 2.x node inside the conference
        // hide the window
        ::ShowWindow(m_hwndMainUI, SW_HIDE);
		m_UIMode = g_fNoUI ? FTUIMODE_NOUI : FTUIMODE_UIHIDDEN;
    }
    else
    if (fNoQuery || QueryShutdown())
    {	
#if defined(TEST_PLUGABLE) && defined(_DEBUG)
        ::OnPluggableEnd();
#endif

		MBFTEngine *pEngine = m_pEngine;

        ::T120_AppletStatus(APPLET_ID_FT, APPLET_CLOSING);

        if (NULL != m_pEngine)
        {
            GCCAppPermissionToEnrollInd Ind;
            ::ZeroMemory(&Ind, sizeof(Ind));
            Ind.nConfID = m_pEngine->GetConfID();
            Ind.fPermissionGranted = FALSE;
            m_pEngine->OnPermitToEnrollIndication(&Ind);
            UnregisterEngine();
        }

        OnRemoveAllFiles();

        ::SetWindowLongPtr(m_hwndMainUI, GWLP_USERDATA, 0);
		
		SaveWindowPosition();
        HWND hwnd = m_hwndMainUI;
        m_hwndMainUI = NULL;
        ::DestroyWindow(hwnd);

        if (NULL != g_pFileXferApplet)
        {
            g_pFileXferApplet->UnregisterWindow(this);
            g_pFileXferApplet->UnregisterEngine(pEngine);
        }

        Release();
    }
}


//
// OnHelp
//

void CAppletWindow::OnHelp(void)
{
    DebugEntry(CAppletWindow::OnHelp);
    ShowNmHelp(s_cszHtmlHelpFile);
    DebugExitVOID(CAppletWindow::OnHelp);
}


//
// OnAbout
//

INT_PTR AboutDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            TCHAR szFormat[256];
            TCHAR szVersion[512];

            ::GetDlgItemText(hdlg, IDC_ABOUT_VERSION, szFormat, count_of(szFormat));
            ::wsprintf(szVersion, szFormat, VER_PRODUCTRELEASE_STR,
                VER_PRODUCTVERSION_STR);
            ::SetDlgItemText(hdlg, IDC_ABOUT_VERSION, szVersion);

            fHandled = TRUE;
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
        case IDCANCEL:
        case IDCLOSE:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case BN_CLICKED:
                ::EndDialog(hdlg, IDCANCEL);
                break;
            }
            break;
        }

        fHandled = TRUE;
        break;
    }

    return(fHandled);
}

void CAppletWindow::OnAbout(void)
{
    ::DialogBoxParam(g_hDllInst, MAKEINTRESOURCE(IDD_ABOUTBOX), m_hwndMainUI,
        AboutDlgProc, 0);
}


BOOL FBrowseForFolder(LPTSTR pszFolder, UINT cchMax, LPCTSTR pszTitle)
{
    LPITEMIDLIST pidlRoot;
    if(FAILED(SHGetSpecialFolderLocation(HWND_DESKTOP, CSIDL_DRIVES, &pidlRoot)))
    {
        return FALSE;
    }

    BROWSEINFO bi;
    ClearStruct(&bi);
    bi.hwndOwner = NULL;
    bi.lpszTitle = pszTitle;
    bi.ulFlags = BIF_RETURNONLYFSDIRS;
    bi.pidlRoot = pidlRoot;

    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    BOOL fRet = (pidl != NULL);
    if (fRet)
    {
        ASSERT(cchMax >= MAX_PATH);
        SHGetPathFromIDList(pidl, pszFolder);
        ASSERT(lstrlen(pszFolder) < (int) cchMax);
    }

    // Get the shell's allocator to free PIDLs
    LPMALLOC lpMalloc;
    if (FAILED(SHGetMalloc(&lpMalloc)) && (NULL != lpMalloc))
    {
        if (NULL != pidlRoot)
        {
            lpMalloc->Free(pidlRoot);
        }
        if (pidl)
        {
            lpMalloc->Free(pidl);
        }
        lpMalloc->Release();
    }
    return fRet;
}


/////////////////////////////////////////////////////////////////
//
//  WM_NOTIFY
//

LRESULT OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (NULL != pWindow)
    {
        switch (wParam)
        {
        case IDC_LIST_VIEW:
            pWindow->OnNotifyListView(lParam);
            break;

        default:
            if (TTN_NEEDTEXT == ((NMHDR *) lParam)->code)
            {
                // display the tool tip text
                TOOLTIPTEXT *pToolTipText = (TOOLTIPTEXT *) lParam;
                ULONG_PTR nID;

                // get id and hwnd
                if (pToolTipText->uFlags & TTF_IDISHWND)
                {
                    // idFrom is actually the HWND of the tool
                    nID = ::GetDlgCtrlID((HWND) pToolTipText->hdr.idFrom);
                }
                else
                {
                    nID = pToolTipText->hdr.idFrom;
                }

                // give it to em
                pToolTipText->lpszText = MAKEINTRESOURCE(nID);
                pToolTipText->hinst = g_hDllInst;
            }
            break;
        }
    }

    return 0;
}


int CALLBACK ListViewCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CUiSendFileInfo *pFileInfo1 = (CUiSendFileInfo *) lParam1;
    CUiSendFileInfo *pFileInfo2 = (CUiSendFileInfo *) lParam2;
    int iResult;

    iResult = 0; // equal, at default
    switch (lParamSort)
    {
    case (IDS_LV_FILE_NAME - IDS_LV_FILE_NAME):
        iResult = lstrcmpi(pFileInfo1->GetName(), pFileInfo2->GetName());
        break;
    case (IDS_LV_FILE_SIZE - IDS_LV_FILE_NAME):
        if (pFileInfo1->GetSize() > pFileInfo2->GetSize())
        {
            iResult = 1;
        }
        else
        if (pFileInfo1->GetSize() < pFileInfo2->GetSize())
        {
            iResult = -1;
        }
        break;
    case (IDS_LV_FILE_STATUS - IDS_LV_FILE_NAME):
        if ((pFileInfo1->GetTotalSend() == pFileInfo1->GetSize()) >( pFileInfo2->GetTotalSend() == pFileInfo2->GetSize()))
        {
            iResult = 1;
        }
        else
        if ((pFileInfo1->GetTotalSend() == pFileInfo1->GetSize()) < (pFileInfo2->GetTotalSend() == pFileInfo2->GetSize()))
        {
            iResult = -1;
        }
        break;

	case (IDS_LV_FILE_MODIFIED - IDS_LV_FILE_NAME):
        	FILETIME  fTime1 = pFileInfo1->GetLastWrite();
	       FILETIME  fTime2 = pFileInfo2->GetLastWrite();
              iResult = CompareFileTime(&fTime1,&fTime2);
		break;
    }
    return iResult*s_sort;
}


void CAppletWindow::OnNotifyListView(LPARAM lParam)
{
    LV_DISPINFO *pDispInfo = (LV_DISPINFO *) lParam;
    NM_LISTVIEW *pLVN = (NM_LISTVIEW *) lParam;
	FILETIME	ftFileTime;
	SYSTEMTIME	stSystemTime;
    CUiSendFileInfo *pFileInfo;
	int iSize;
	TCHAR	szBuffer[MAX_PATH];



    switch (pLVN->hdr.code)
    {
    case LVN_GETDISPINFO:
        pFileInfo = (CUiSendFileInfo *) pDispInfo->item.lParam;
        ASSERT(NULL != pFileInfo);

        switch (pDispInfo->item.iSubItem)
        {
        case (IDS_LV_FILE_NAME - IDS_LV_FILE_NAME):
            pDispInfo->item.pszText = pFileInfo->GetName();
            break;
        case (IDS_LV_FILE_SIZE - IDS_LV_FILE_NAME):
            ::wsprintf(szBuffer, TEXT("%u"), pFileInfo->GetSize());
			iSize = GetNumberFormat(LOCALE_SYSTEM_DEFAULT, LOCALE_NOUSEROVERRIDE,
							szBuffer, NULL, s_szScratchText, MAX_PATH);	
			s_szScratchText[iSize - 4] = '\0'; // remove the trailing ".00"
            pDispInfo->item.pszText = s_szScratchText;
            break;
        case (IDS_LV_FILE_STATUS - IDS_LV_FILE_NAME):
            {
                ULONG cbTotalSend = pFileInfo->GetTotalSend();
                ULONG cbFileSize = pFileInfo->GetSize();
                s_szScratchText[0] = TEXT('\0');

                switch (pFileInfo->GetErrorCode())
                {
                case iMBFT_OK:
				case iMBFT_MULT_RECEIVER_ABORTED:
					if (!pFileInfo->GetFileHandle())
						break;   // handle == NULL, if cbTotalSend == 0, zero length file to be sent.
                    if (cbTotalSend >= cbFileSize)
                    {
                        ::MyLoadString(IDS_LV_FILE_SENT);
                    }
                    else
                    if (cbTotalSend)
                    {
						if (m_pEngine)
						{
							::MyLoadString(IDS_LV_FILE_SENDING);
						}
						else
						{
							::MyLoadString(IDS_LV_FILE_CANCELED);
						}
                    }
                    break;

                case iMBFT_SENDER_ABORTED:
                case iMBFT_RECEIVER_ABORTED:
                case iMBFT_NO_MORE_FILES:
                    ::MyLoadString(IDS_LV_FILE_CANCELED);
                    break;

                default:
                    ::MyLoadString(IDS_LV_FILE_FAILED);
                    break;
                }

                pDispInfo->item.pszText = s_szScratchText;
            }
            break;

		case (IDS_LV_FILE_MODIFIED - IDS_LV_FILE_NAME):
			ftFileTime = pFileInfo->GetLastWrite();
			FileTimeToSystemTime(&ftFileTime, &stSystemTime);
			iSize = GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &stSystemTime,
							"MM'/'dd'/'yyyy", s_szScratchText, MAX_PATH);
			GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &stSystemTime,
							"  hh':'mm tt", &s_szScratchText[iSize - 1], MAX_PATH-iSize-1);
			pDispInfo->item.pszText = s_szScratchText;
			break;
        }
        break;

    case LVN_COLUMNCLICK:
        {
			s_sort = s_sort *(-1);
            BOOL fRet = ListView_SortItems(pLVN->hdr.hwndFrom, ListViewCompareProc, (LPARAM) pLVN->iSubItem);
            ASSERT(fRet);
        }
        break;
    }
}


/////////////////////////////////////////////////////////////////
//
//  WM_DROPFILES
//

LRESULT OnDropFiles(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    if (g_fSendAllowed)
    {
        return pWindow->OnDropFiles((HANDLE) wParam);
    }
    else
    {
        ::MyLoadString(IDS_MSGBOX_POL_PREVENT);
        ::MessageBox(pWindow->GetHwnd(), s_szScratchText, s_szMSFT, MB_OK | MB_ICONSTOP);
        return 1;
    }
}


LRESULT CAppletWindow::OnDropFiles(HANDLE hDrop)
{
    if (NULL != m_pEngine && m_pEngine->GetPeerCount() > 1)
    {
        HRESULT hr;

        // get the number of dropped files
        ULONG cFiles = ::DragQueryFile((HDROP) hDrop, 0xFFFFFFFF, NULL, 0);

        // set up the common portion of list view item
        LVITEM lvi;
        ::ZeroMemory(&lvi, sizeof(lvi));
        // lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;

        // iterate on these files
        for (ULONG i = 0; i < cFiles; i++)
        {
            BOOL fRet;
            TCHAR szFile[MAX_PATH];

            if (::DragQueryFile((HDROP) hDrop, i, szFile, count_of(szFile)))
            {
                DBG_SAVE_FILE_LINE
                CUiSendFileInfo *pFileInfo = new CUiSendFileInfo(this, NULL, szFile, &fRet);
                if (NULL != pFileInfo && fRet)
                {
                    // put it to the list view
                    lvi.iItem = ListView_GetItemCount(m_hwndListView);
                    lvi.iSubItem = 0;
                    // we are responsible for storing the text to display
                    lvi.pszText = LPSTR_TEXTCALLBACK;
                    lvi.cchTextMax = MAX_PATH;
                    lvi.lParam = (LPARAM) pFileInfo;
                    int iRet = ListView_InsertItem(m_hwndListView, &lvi);
                    ASSERT(-1 != iRet);
                    // UpdateListView(pFileInfo);
                }
                else
                {
                    // BUGBUG: we should pop up some error message box here!
					::MyLoadString(IDS_INVALID_FILENAME, s_szScratchText, szFile);
					::MessageBox(m_hwndMainUI, s_szScratchText, s_szMSFT, MB_OK | MB_ICONSTOP);
                    delete pFileInfo;
                }
            }
        }

        ::DragFinish((HDROP) hDrop);
		SetForegroundWindow(m_hwndMainUI);

        UpdateUI();
        return 0;
    }

    ::MyLoadString(IDS_MSGBOX_NO_CONF);
    ::SetForegroundWindow(m_hwndMainUI);
    ::MessageBox(m_hwndMainUI, s_szScratchText, s_szMSFT, MB_OK | MB_ICONSTOP);
    return 1;
}



/////////////////////////////////////////////////////////////////
//
//  WM_CONTEXTMENU
//

LRESULT OnContextMenu(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    LRESULT rc = 0;

    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    if ((WPARAM) pWindow->GetHwnd() == wParam)
    {
        // BUGBUG use TrackPopupMenu to show context sensitive menu
        pWindow->OnContextMenuForMainUI(lParam);
    }
    else
    if ((WPARAM) pWindow->GetListView() == wParam)
    {
        // BUGBUG use TrackPopupMenu to show context sensitive menu
        pWindow->OnContextMenuForListView(lParam);
    }
    else
    {
        rc = 1;
    }

    return rc;
}


enum
{
    MENU_IDX_ADD_FILES,
    MENU_IDX_REMOVE_FILES,
    MENU_IDX_BREAK_1,
    MENU_IDX_SEND_ALL,
	MENU_IDX_SEND_ONE,
    MENU_IDX_STOP_SENDING,
    MENU_IDX_BREAK_2,
    MENU_IDX_OPEN_RECV_FOLDER,
};

static UI_MENU_INFO s_aMenuInfo[] =
{
    { IDS_MENU_ADD_FILES,           IDM_ADD_FILES,          MF_ENABLED | MF_STRING },
    { IDS_MENU_REMOVE_FILES,        IDM_REMOVE_FILES,       MF_ENABLED | MF_STRING },
    { 0,                            0,                      MF_SEPARATOR}, // menu break
    { IDS_MENU_SEND_ALL,            IDM_SEND_ALL,           MF_ENABLED | MF_STRING },
	{ IDS_MENU_SEND_ONE,			IDM_SEND_ONE,			MF_ENABLED | MF_STRING },
    { IDS_MENU_STOP_SENDING,        IDM_STOP_SENDING,       MF_ENABLED | MF_STRING },
    { 0,                            0,                      MF_SEPARATOR}, // menu break
    { IDS_MENU_OPEN_RECV_FOLDER,    IDM_OPEN_RECV_FOLDER,   MF_ENABLED | MF_STRING },
	{ IDS_MENU_CHANGE_FOLDER,		IDM_CHANGE_FOLDER,		MF_ENABLED | MF_STRING },
    { 0,                            0,                      MF_SEPARATOR }, // menu break
    { IDS_MENU_EXIT,                IDM_EXIT,               MF_ENABLED | MF_STRING },
};


void CAppletWindow::SetContextMenuStates(void)
{
    if (g_fSendAllowed)
    {
        BOOL fMoreThanOne = (NULL != m_pEngine) && (m_pEngine->GetPeerCount() > 1);
        s_aMenuInfo[MENU_IDX_ADD_FILES].nFlags = fMoreThanOne ? (MF_ENABLED | MF_STRING) : (MF_GRAYED | MF_STRING);

        ULONG cItems = ListView_GetItemCount(m_hwndListView);
        s_aMenuInfo[MENU_IDX_REMOVE_FILES].nFlags = cItems ? (MF_ENABLED | MF_STRING) : (MF_GRAYED | MF_STRING);
        s_aMenuInfo[MENU_IDX_SEND_ALL].nFlags = (fMoreThanOne && ! m_nCurrSendEventHandle && HasUnSentFiles(TRUE)) ? (MF_ENABLED | MF_STRING) : (MF_GRAYED | MF_STRING);
		s_aMenuInfo[MENU_IDX_SEND_ONE].nFlags = (fMoreThanOne && ! m_nCurrSendEventHandle && HasUnSentFiles(FALSE)) ? (MF_ENABLED | MF_STRING) : (MF_GRAYED | MF_STRING);
        s_aMenuInfo[MENU_IDX_STOP_SENDING].nFlags = m_nCurrSendEventHandle ? (MF_ENABLED | MF_STRING) : (MF_GRAYED | MF_STRING);
    }
    else
    {	
        s_aMenuInfo[MENU_IDX_ADD_FILES].nFlags =(MF_GRAYED | MF_STRING);
        s_aMenuInfo[MENU_IDX_REMOVE_FILES].nFlags =(MF_GRAYED | MF_STRING);
        s_aMenuInfo[MENU_IDX_SEND_ALL].nFlags = (MF_GRAYED | MF_STRING);
		s_aMenuInfo[MENU_IDX_SEND_ONE].nFlags = (MF_GRAYED | MF_STRING);
        s_aMenuInfo[MENU_IDX_STOP_SENDING].nFlags = (MF_GRAYED | MF_STRING);
    }
}


void CAppletWindow::OnContextMenuForMainUI(LPARAM lParam)
{
    SetContextMenuStates();
    CreateMenu(lParam, count_of(s_aMenuInfo), &s_aMenuInfo[0]);
}


void CAppletWindow::OnContextMenuForListView(LPARAM lParam)
{
    SetContextMenuStates();
    CreateMenu(lParam, 6, &s_aMenuInfo[0]);
}


void CAppletWindow::CreateMenu(LPARAM lParam, ULONG cItems, UI_MENU_INFO aMenuInfo[])
{
    HMENU hMenu = ::CreatePopupMenu();
    if (NULL != hMenu)
    {
        for (ULONG i = 0; i < cItems; i++)
        {
            if (aMenuInfo[i].idCommand)
            {
                if (::MyLoadString(aMenuInfo[i].idString))
                {
                    ::AppendMenu(hMenu, aMenuInfo[i].nFlags, aMenuInfo[i].idCommand, s_szScratchText);
                }
            }
            else
            {
                ::AppendMenu(hMenu, aMenuInfo[i].nFlags, 0, 0);
            }
        }

        ::TrackPopupMenu(hMenu, TPM_LEFTALIGN | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RIGHTBUTTON,
                         GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam),
                         0, // reserved, must be zero
                         m_hwndMainUI,
                         NULL); // ignore
    }
}


/////////////////////////////////////////////////////////////////
//
//  WM_SIZE
//

LRESULT OnSize(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    pWindow->OnSizeToolBar();
    pWindow->OnSizeStatusBar();
    pWindow->OnSizeListView();

    return 0;
}


void CAppletWindow::OnSizeToolBar(void)
{
    RECT rcWindow;
	SIZE szToolBar;

    ::GetClientRect(m_hwndMainUI, &rcWindow);
	m_pToolbar->GetDesiredSize(&szToolBar);

    ULONG cx = rcWindow.right - rcWindow.left;
    ULONG cy = szToolBar.cy;;
    ULONG x = 0;
    ULONG y = 0;

    ::MoveWindow(m_pToolbar->GetWindow(), x, y, cx, cy, TRUE);
}


void CAppletWindow::OnSizeStatusBar(void)
{
    RECT rcWindow, rcStatusBar;
    ::GetClientRect(m_hwndMainUI, &rcWindow);
    ::GetWindowRect(m_hwndStatusBar, &rcStatusBar);

    ULONG cx = rcWindow.right - rcWindow.left;
    ULONG cy = rcStatusBar.bottom - rcStatusBar.top;
    ULONG x = 0;
    ULONG y = rcWindow.bottom - cy;

    ::MoveWindow(m_hwndStatusBar, x, y, cx, cy, TRUE);
	::MoveWindow(m_hwndProgressBar, x + cx/2, y, cx/2 - 40, cy, TRUE);

    int aWidths[NUM_STATUS_BAR_PARTS];
    aWidths[0] = cx / 2;  // conference state
    aWidths[1] = cx - 40; // transfer name
    aWidths[2] = -1;  // transfer percentage
    ASSERT(3 == NUM_STATUS_BAR_PARTS);

    ::SendMessage(m_hwndStatusBar, SB_SETPARTS, NUM_STATUS_BAR_PARTS, (LPARAM) &aWidths[0]);
}


void CAppletWindow::OnSizeListView(void)
{
    // get the size and position of the main window
    RECT rcWindow, rcToolBar, rcStatusBar;
	SIZE	szToolBar;
    ::GetClientRect(m_hwndMainUI, &rcWindow);
	m_pToolbar->GetDesiredSize(&szToolBar);
    ::GetWindowRect(m_hwndStatusBar, &rcStatusBar);

    ULONG x = 0;
    ULONG y = szToolBar.cy - 1;
    ULONG cx = rcWindow.right - rcWindow.left;
    ULONG cy = rcWindow.bottom - rcWindow.top - y - (rcStatusBar.bottom - rcStatusBar.top) + 1;

    ::MoveWindow(m_hwndListView, x, y, cx, cy, TRUE);
}


/////////////////////////////////////////////////////////////////
//
//  WM_HELP
//

LRESULT OnHelp(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    pWindow->OnHelp();
    return 0;
}


/////////////////////////////////////////////////////////////////
//
//  WM_CLOSE
//

LRESULT OnClose(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    if (NULL != pWindow)
    {
        pWindow->OnExit();
    }

    return 0;
}


/////////////////////////////////////////////////////////////////
//
//  WM_INITMENUPOPUP
//
/*
LRESULT OnInitMenuPopup(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    if (0 != HIWORD(lParam)) // System menu flag
    {
        HMENU hMenu = (HMENU) wParam;         // handle of pop-up menu
        ::EnableMenuItem(hMenu, SC_MAXIMIZE, MF_GRAYED);
        ::EnableMenuItem(hMenu, SC_SIZE, MF_GRAYED);
        return 0;
    }
    return 1;
}
*/


/////////////////////////////////////////////////////////////////
//
//  WM_MENUSELECT
//

LRESULT OnMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    if (NULL != pWindow)
    {
        pWindow->OnMenuSelect(GET_WM_MENUSELECT_CMD(wParam, lParam),
							  GET_WM_MENUSELECT_FLAGS(wParam, lParam),
							  GET_WM_MENUSELECT_HMENU(wParam, lParam));
    }

    return 0;
}


/////////////////////////////////////////////////////////////////
//
//  WM_INITMENUPOPUP
//

LRESULT OnGetMinMaxInfo(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (NULL != pWindow)
    {
        pWindow->OnGetMinMaxInfo((LPMINMAXINFO) lParam);
        return 0;
    }
    return 1;
}


void CAppletWindow::OnGetMinMaxInfo(LPMINMAXINFO pMMI)
{
    static BOOL s_fEnterBefore = FALSE;

    static SIZE s_csFrame;
    static SIZE s_csSeparator;
    static SIZE s_csScrollBars;
    static SIZE s_csToolBar;
    static SIZE s_csStatusBar;
    static SIZE s_csSum;

    if (! s_fEnterBefore)
    {
        s_fEnterBefore = TRUE;

        s_csFrame.cx = ::GetSystemMetrics(SM_CXSIZEFRAME);
        s_csFrame.cy = ::GetSystemMetrics(SM_CYSIZEFRAME);

        s_csSeparator.cx = ::GetSystemMetrics(SM_CXEDGE);
        s_csSeparator.cy = ::GetSystemMetrics(SM_CYEDGE);

        s_csScrollBars.cx = ::GetSystemMetrics(SM_CXVSCROLL);
        s_csScrollBars.cy = ::GetSystemMetrics(SM_CYHSCROLL);

		m_pToolbar->GetDesiredSize(&s_csToolBar);

        RECT    rcStatusBar;
        ::GetWindowRect(m_hwndStatusBar, &rcStatusBar);
        s_csStatusBar.cx = rcStatusBar.right - rcStatusBar.left;
        s_csStatusBar.cy = rcStatusBar.bottom - rcStatusBar.top;

        s_csSum.cx = (s_csFrame.cx << 1);
        s_csSum.cy = (s_csFrame.cy << 1) + (s_csSeparator.cy << 3) +
                     s_csToolBar.cy + (rcStatusBar.bottom - rcStatusBar.top) +
                     ::GetSystemMetrics( SM_CYCAPTION ) + ::GetSystemMetrics( SM_CYMENU );
    }

    RECT    rcListViewItem;
    SIZE    csListView;
    csListView.cx = 0;
    for (ULONG i = 0; i < NUM_LIST_VIEW_COLUMNS; i++)
    {
        csListView.cx += ListView_GetColumnWidth(m_hwndListView, i);
    }
    if (ListView_GetItemRect(m_hwndListView, 0, &rcListViewItem, LVIR_BOUNDS))
    {
        csListView.cy = 20 + 3 * (rcListViewItem.bottom - rcListViewItem.top);
    }
    else
    {
        csListView.cy = 20 + 30;
    }

    // Set the minimum width and height of the window
    pMMI->ptMinTrackSize.x = s_csSum.cx + max(s_csToolBar.cx, csListView.cx);
    pMMI->ptMinTrackSize.y = s_csSum.cy + csListView.cy;

    //
    // Retrieves the size of the work area on the primary display monitor. The work
    // area is the portion of the screen not obscured by the system taskbar or by
    // application desktop toolbars
    //

    RECT    rcWorkArea;
    ::SystemParametersInfo( SPI_GETWORKAREA, 0, (&rcWorkArea), NULL );

    SIZE    csMaxSize;
    csMaxSize.cx = rcWorkArea.right - rcWorkArea.left;
    csMaxSize.cy = rcWorkArea.bottom - rcWorkArea.top;

    pMMI->ptMaxPosition.x  = 0;
    pMMI->ptMaxPosition.y  = 0;
    pMMI->ptMaxSize.x      = csMaxSize.cx;
    pMMI->ptMaxSize.y      = csMaxSize.cy;
    pMMI->ptMaxTrackSize.x = csMaxSize.cx;
    pMMI->ptMaxTrackSize.y = csMaxSize.cy;
}


/////////////////////////////////////////////////////////////////
//
//  WM_QUERYENDSESSION
//

LRESULT OnQueryEndSession(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    if (NULL != pWindow)
    {
        return pWindow->QueryShutdown(); // TRUE: ok to send session; FALSE, no.
    }
    return TRUE; // ok to end session
}


/////////////////////////////////////////////////////////////////
//
//  WM_ENDSESSION
//

LRESULT OnEndSession(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (wParam && NULL != pWindow)
    {
        pWindow->OnExit(TRUE);
    }

    return 0;
}



/////////////////////////////////////////////////////////////////
//
//  WM_DRAWITEM
//

LRESULT OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (wParam && NULL != pWindow)
    {
        pWindow->DrawItem((DRAWITEMSTRUCT *)lParam);
    }

    return 0;
}


/////////////////////////////////////////////////////////////////
//
//  WM_SEND_NEXT
//

LRESULT OnSendNext(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (NULL != pWindow)
    {
        pWindow->OnSendAll();
        pWindow->UpdateUI();
    }

    return 0;
}


/////////////////////////////////////////////////////////////////
//
//  Main windows procedure
//

LRESULT CALLBACK FtMainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT rc = 0;

    switch (uMsg)
    {
    case WM_CREATE:
        rc = ::OnCreate(hwnd, wParam, lParam);
        break;

    case WM_COMMAND:
        rc = ::OnCommand(hwnd, wParam, lParam);
        break;

    case WM_NOTIFY:
        rc = ::OnNotify(hwnd, wParam, lParam);
        break;

    case WM_DROPFILES:
        rc = ::OnDropFiles(hwnd, wParam, lParam);
        break;

    case WM_CONTEXTMENU:
        rc = ::OnContextMenu(hwnd, wParam, lParam);
        break;

    case WM_SIZE:
        rc = ::OnSize(hwnd, wParam, lParam);
        break;

    case WM_HELP:
        rc = ::OnHelp(hwnd, wParam, lParam);
        break;

	case WM_DRAWITEM:
		rc = ::OnDrawItem(hwnd, wParam, lParam);
		break;

    case WM_CLOSE:
        rc = ::OnClose(hwnd, wParam, lParam);
        break;

    case WM_INITMENUPOPUP:
        //  rc = ::OnInitMenuPopup(hwnd, wParam, lParam);
        break;

	case WM_MENUSELECT:
        rc = ::OnMenuSelect(hwnd, wParam, lParam);
        break;

    case WM_GETMINMAXINFO:
        rc = ::OnGetMinMaxInfo(hwnd, wParam, lParam);
        break;

    case WM_QUERYENDSESSION:
        rc = OnQueryEndSession(hwnd, wParam, lParam);
        break;

    case WM_ENDSESSION:
        rc = ::OnEndSession(hwnd, wParam, lParam);
        break;

    case WM_SEND_NEXT:
        rc = ::OnSendNext(hwnd, wParam, lParam);
        break;


#if defined(TEST_PLUGABLE) && defined(_DEBUG)
    case WM_PLUGABLE_SOCKET:
        rc = ::OnPluggableSocket(hwnd, wParam, lParam);
        break;
#endif

    default:
        rc = ::DefWindowProc(hwnd, uMsg, wParam, lParam);
        break;
    }

    return rc;
}


/////////////////////////////////////////////////////////////////
//
//  OnEngineNotify
//

void CAppletWindow::OnEngineNotify(MBFTMsg *pMsg)
{
    BOOL fHeartBeat = FALSE;

    switch (pMsg->GetMsgType())
    {
    case EnumFileOfferNotifyMsg:
		if (m_UIMode != FTUIMODE_NOUI)
		{
			HandleFileOfferNotify((FileOfferNotifyMsg *) pMsg);
		}
        break;

    case EnumFileTransmitMsg:
		if (m_UIMode != FTUIMODE_NOUI)
		{
			HandleProgressNotify((FileTransmitMsg *) pMsg);
		}
        fHeartBeat = TRUE;
        break;

    case EnumFileErrorMsg:
		if (m_UIMode != FTUIMODE_NOUI)
		{
			HandleErrorNotify((FileErrorMsg *) pMsg);
		}
        break;

    case EnumPeerMsg:
        HandlePeerNotification((PeerMsg *) pMsg);
        break;

    case EnumInitUnInitNotifyMsg:
        HandleInitUninitNotification((InitUnInitNotifyMsg *) pMsg);
        break;

    case EnumFileEventEndNotifyMsg:
		if (m_UIMode != FTUIMODE_NOUI)
		{
			HandleFileEventEndNotification((FileEventEndNotifyMsg *) pMsg);
		}
        break;

    default:
        ASSERT(0);
        break;
    } // switch
}


void CAppletWindow::HandleFileOfferNotify(FileOfferNotifyMsg *pMsg)
{
    HRESULT hr = S_OK;
    if (g_fRecvAllowed)
    {
        DBG_SAVE_FILE_LINE
        CUiRecvFileInfo *pRecvFileInfo = new CUiRecvFileInfo(pMsg, &hr);
        if (NULL != pRecvFileInfo && S_OK == hr)
        {
            if (NULL != m_pEngine)
            {
                DBG_SAVE_FILE_LINE
                CRecvDlg *pDlg = new CRecvDlg(this,
                                              m_pEngine->GetConfID(),
                                              pMsg->m_NodeID,
                                              pMsg->m_EventHandle,
                                              pRecvFileInfo,
                                              &hr);
                if (NULL != pDlg && S_OK == hr)
                {
                    DBG_SAVE_FILE_LINE
                    if (S_OK == m_pEngine->SafePostMessage(
                                    new FileTransferControlMsg(
                                                pMsg->m_EventHandle,
                                                pMsg->m_hFile,
                                                pRecvFileInfo->GetRecvFolder(),
                                                pMsg->m_szFileName,
                                                FileTransferControlMsg::EnumAcceptFile)))
                    {
                        return;
                    }
                    else
                    {
                        ERROR_OUT(("CAppletWindow::HandleFileOfferNotify: cannot confirm file offer"));
                    }
                }
                else
                {
                    ERROR_OUT(("CAppletWindow::HandleFileOfferNotify: cannot allocate CRecvDlg, hr=0x%x", hr));
                }
                delete pDlg;
            }
            else
            {
                ERROR_OUT(("CAppletWindow::HandleFileOfferNotify: no file transfer engine"));
            }
        }
        else
        {
            ERROR_OUT(("CAppletWindow::HandleFileOfferNotify: cannot allocate CUiRecvFileInfo, hr=0x%x", hr));
        }
        delete pRecvFileInfo;
    }
    else
    {
        DBG_SAVE_FILE_LINE
        if (S_OK != m_pEngine->SafePostMessage(
                        new FileTransferControlMsg(
                                    pMsg->m_EventHandle,
                                    pMsg->m_hFile,
                                    NULL,
                                    pMsg->m_szFileName,
                                    FileTransferControlMsg::EnumRejectFile)))
        {
            ERROR_OUT(("CAppletWindow::HandleFileOfferNotify: cannot confirm file offer"));
        }
    }
}


void CAppletWindow::HandleProgressNotify(FileTransmitMsg *pMsg)
{
    CRecvDlg *pDlg = NULL;
    MBFT_NOTIFICATION wMBFTCode = (MBFT_NOTIFICATION) pMsg->m_TransmitStatus;
	ULONG totalSent = 0;
	ULONG fileSize = 0;
	ULONG percentSent = 0;

    switch (wMBFTCode)
    {
    case iMBFT_FILE_SEND_BEGIN:
        // fall through... because the file start PDU can have data.

    case iMBFT_FILE_SEND_PROGRESS:
        if (NULL != m_pCurrSendFileInfo)
        {
            ASSERT(m_nCurrSendEventHandle == pMsg->m_EventHandle);
            ASSERT(m_pCurrSendFileInfo->GetFileHandle() == pMsg->m_hFile);
            ASSERT(m_pCurrSendFileInfo->GetSize() == pMsg->m_FileSize);
            fileSize = m_pCurrSendFileInfo->GetSize();
            totalSent = m_pCurrSendFileInfo->GetTotalSend();

            m_pCurrSendFileInfo->SetTotalSend(pMsg->m_BytesTransmitted);

            percentSent = _GetPercent(totalSent, fileSize)*10;

            if(m_pCurrSendFileInfo->GetPercentSent()!= percentSent ||  fileSize == totalSent)
            {
                    UpdateListView(m_pCurrSendFileInfo);
                    UpdateStatusBar();
                    m_pCurrSendFileInfo->SetPercentSent(percentSent);
            }
        }
        break;

        break;

    case iMBFT_FILE_SEND_END:
        if (NULL != m_pCurrSendFileInfo)
        {
            UpdateListView(m_pCurrSendFileInfo);
            UpdateStatusBar();
        }
        break;


    case iMBFT_FILE_RECEIVE_BEGIN:
        // fall through... because the file start PDU can have data.

    case iMBFT_FILE_RECEIVE_PROGRESS:
        pDlg = FindDlgByHandles(pMsg->m_EventHandle, pMsg->m_hFile);
        if (NULL != pDlg)
        {
            pDlg->OnProgressUpdate(pMsg);
        }
        break;

    case iMBFT_FILE_RECEIVE_END:
        // doing nothing...
        break;

    default:
        ASSERT(0);
        break;
    }
}


void CAppletWindow::HandleErrorNotify(FileErrorMsg *pMsg)
{
    MBFTFILEHANDLE nFileHandle = pMsg->m_hFile;
    if(LOWORD(nFileHandle) == LOWORD(_iMBFT_PROSHARE_ALL_FILES))
    {
        nFileHandle = _iMBFT_PROSHARE_ALL_FILES;
    }

    if (m_nCurrSendEventHandle == pMsg->m_EventHandle &&
        m_pCurrSendFileInfo->GetFileHandle() == nFileHandle)
    {
        m_pCurrSendFileInfo->SetErrorCode((MBFT_ERROR_CODE) pMsg->m_ErrorCode);

        UINT idString;
        switch ((MBFT_ERROR_CODE) pMsg->m_ErrorCode)
        {
        case iMBFT_OK:
            idString = 0;
            break;
        case iMBFT_SENDER_ABORTED:
        case iMBFT_RECEIVER_ABORTED:
        case iMBFT_NO_MORE_FILES:
            idString = IDS_MSGBOX2_CANCELED;
            break;
        case iMBFT_MULT_RECEIVER_ABORTED:
            idString = IDS_MSGBOX2_MULT_CANCEL;
            break;
        // case iMBFT_RECEIVER_REJECTED:
        default:
            idString = IDS_MSGBOX2_SEND_FAILED;
            break;
        }
        if (idString)
        {
            if (! m_pCurrSendFileInfo->HasShownUI())
            {
                if (::MyLoadString(idString, s_szScratchText, m_pCurrSendFileInfo->GetName()))
                {
                    m_pCurrSendFileInfo->SetShowUI();
                    ::MsgBox2(this, s_szScratchText);
                }
                else
                {
                    ASSERT(0);
                }
            }
        }

        UpdateListView(m_pCurrSendFileInfo);
        UpdateStatusBar();

        ClearSendInfo(TRUE);
        if (! idString)
        {
            // send the next one now
			if (m_fSendALL)
			{
				::PostMessage(m_hwndMainUI, WM_SEND_NEXT, 0, 0);
			}
        }
    }
    else
    {
        CRecvDlg *pDlg = FindDlgByHandles(pMsg->m_EventHandle, nFileHandle);
        if (NULL != pDlg)
        {
            switch ((MBFT_ERROR_CODE) pMsg->m_ErrorCode)
            {
            case iMBFT_RECEIVER_ABORTED:
            case iMBFT_MULT_RECEIVER_ABORTED:
                pDlg->OnCanceled();
                break;
            default:
                pDlg->OnRejectedFile();
                break;
            }
        }
        else
        {
			switch((MBFT_ERROR_CODE) pMsg->m_ErrorCode)
            {
			case iMBFT_INVALID_PATH:
				::MyLoadString(IDS_MSGBOX2_INVALID_DIRECTORY,
					s_szScratchText, pMsg->m_stFileInfo.szFileName);
				break;

			case iMBFT_DIRECTORY_FULL_ERROR:
				::MyLoadString(IDS_MSGBOX2_DIRECTORY_FULL,
					s_szScratchText, pMsg->m_stFileInfo.lFileSize,
					pMsg->m_stFileInfo.szFileName);
				break;

			case iMBFT_FILE_ACCESS_DENIED:
				::MyLoadString(IDS_MSGBOX2_FILE_CREATE_FAILED,
					s_szScratchText, pMsg->m_stFileInfo.szFileName);
				break;

			default:
				return;
			}
			::MsgBox2(this, s_szScratchText);
        }
    }
}


void CAppletWindow::HandlePeerNotification(PeerMsg *pMsg)
{
	
	m_pToolbar->HandlePeerNotification(m_pEngine->GetConfID(),
								m_pEngine->GetNodeID(), pMsg);
}


void CAppletWindow::HandleInitUninitNotification(InitUnInitNotifyMsg *pMsg)
{
    if (pMsg->m_iNotifyMessage == EnumInvoluntaryUnInit)
    {
        UnregisterEngine();
    }
}


void CAppletWindow::HandleFileEventEndNotification(FileEventEndNotifyMsg *pMsg)
{
    if (m_nCurrSendEventHandle == pMsg->m_EventHandle)
    {
        ClearSendInfo(TRUE);
        // send the next one now
		if (m_fSendALL)
		{
			::PostMessage(m_hwndMainUI, WM_SEND_NEXT, 0, 0);
		}
    }
}



/////////////////////////////////////////////////////////////////
//
//  Main UI methods
//

void CAppletWindow::BringToFront(void)
{
    if (NULL != m_hwndMainUI)
    {
        int nCmdShow = SW_SHOW;

        WINDOWPLACEMENT wp;
        ::ZeroMemory(&wp, sizeof(wp));
        wp.length = sizeof(wp);

        if (::GetWindowPlacement(m_hwndMainUI, &wp))
        {
            if (SW_MINIMIZE == wp.showCmd || SW_SHOWMINIMIZED == wp.showCmd)
            {
                // The window is minimized - restore it:
                nCmdShow = SW_RESTORE;
            }
        }

        // show the window now
        ::ShowWindow(m_hwndMainUI, nCmdShow);
		m_UIMode = FTUIMODE_SHOWUI;
        // bring it to the foreground
        ::SetForegroundWindow(m_hwndMainUI);
    }
}


void CAppletWindow::ClearSendInfo(BOOL fUpdateUI)
{
    m_pCurrSendFileInfo = NULL;
    m_nCurrSendEventHandle = NULL;

    if (fUpdateUI)
    {
        UpdateUI();
    }
}


void CAppletWindow::ClearRecvInfo(void)
{
    CRecvDlg *pDlg;
    while (NULL != (pDlg = m_RecvDlgList.Get()))
    {
        ::EndDialog(pDlg->GetHwnd(), IDCLOSE);
        pDlg->Release();
    }
}


BOOL CAppletWindow::HasUnSentFiles(BOOL fUnSentOnly)
{
	BOOL  fRc = FALSE;
	ULONG	cItems = ListView_GetItemCount(m_hwndListView);
	CUiSendFileInfo *pFileInfo;
    LVITEM lvi;

	if (!fUnSentOnly && cItems) {
		return TRUE;
	}

    ::ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM;  // examine each item one by one
    for (ULONG i = 0; i < cItems; i++, pFileInfo = NULL)
    {
		lvi.iItem = i;
        BOOL fRet = ListView_GetItem(m_hwndListView, &lvi);
        ASSERT(fRet);
        pFileInfo = (CUiSendFileInfo *) lvi.lParam;
        if (!pFileInfo->GetFileHandle())  // if file handle is not zero, then it has been sent or cancelled
        {
			fRc = TRUE;
            break;
        }
    }
    return fRc;
}


void CAppletWindow::UpdateUI(void)
{
    UpdateTitle();
    UpdateMenu();
    UpdateToolBar();
	UpdateStatusBar();
}


void CAppletWindow::UpdateTitle(void)
{
    UINT captionID;
    if ((! m_pEngine) || (m_pEngine->GetPeerCount() <= 1))
    {
        captionID = IDS_MSFT_NOT_IN_CALL_WINDOW_CAPTION;
    }
    else
    {
        captionID = IDS_MSFT_IN_CALL_WINDOW_CAPTION;
    }

    ::LoadString(g_hDllInst, captionID, s_szMSFT, sizeof(s_szMSFT));

    SetWindowText(m_hwndMainUI, s_szMSFT);
}


void CAppletWindow::UpdateMenu(void)
{
    HMENU hMenu = ::GetMenu(m_hwndMainUI);
    if (NULL != hMenu)
    {
        if (g_fSendAllowed)
        {
            BOOL fMoreThanOne = (NULL != m_pEngine) && (m_pEngine->GetPeerCount() > 1);
            ::EnableMenuItem(hMenu, IDM_ADD_FILES, fMoreThanOne ? MF_ENABLED : MF_GRAYED);

            ULONG cItems = ListView_GetItemCount(m_hwndListView);
            ::EnableMenuItem(hMenu, IDM_REMOVE_FILES, cItems ? MF_ENABLED : MF_GRAYED);
            ::EnableMenuItem(hMenu, IDM_SEND_ALL, (fMoreThanOne && ! m_nCurrSendEventHandle && HasUnSentFiles(TRUE)) ? MF_ENABLED : MF_GRAYED);
			::EnableMenuItem(hMenu, IDM_SEND_ONE, (fMoreThanOne && ! m_nCurrSendEventHandle && HasUnSentFiles(FALSE)) ? MF_ENABLED : MF_GRAYED);
            ::EnableMenuItem(hMenu, IDM_STOP_SENDING, m_nCurrSendEventHandle ? MF_ENABLED : MF_GRAYED);
        }
        else
        {
            ::EnableMenuItem(hMenu, IDM_ADD_FILES,    MF_GRAYED);
            ::EnableMenuItem(hMenu, IDM_REMOVE_FILES, MF_GRAYED);
            ::EnableMenuItem(hMenu, IDM_SEND_ALL,     MF_GRAYED);
			::EnableMenuItem(hMenu, IDM_SEND_ONE,	  MF_GRAYED);
            ::EnableMenuItem(hMenu, IDM_STOP_SENDING, MF_GRAYED);
        }
    }
}


void CAppletWindow::UpdateToolBar(void)
{
	int iFlags[count_of(buttons)];

	::ZeroMemory(iFlags, sizeof(iFlags));

	iFlags[2] = iFlags[5] = iFlags[6] = 1;  // separators
	iFlags[7] = 1;							// open recv folders

	
    if (g_fSendAllowed)
    {
		BOOL fMoreThanOne = (NULL != m_pEngine) && (m_pEngine->GetPeerCount() > 1);
        ULONG cItems = ListView_GetItemCount(m_hwndListView);
	
		iFlags[0] = fMoreThanOne ? TRUE : FALSE;		// Add files
		iFlags[1] = cItems ? TRUE : FALSE;				// Delete files
		iFlags[3] = (fMoreThanOne && ! m_nCurrSendEventHandle && HasUnSentFiles(TRUE)) ? TRUE : FALSE;	// Send file(s)
		iFlags[4] = m_nCurrSendEventHandle ? TRUE : FALSE;	// Stop sending

		m_pToolbar->UpdateButton(iFlags);
	}
    else
    {
		m_pToolbar->UpdateButton(iFlags);
    }
	
}


void CAppletWindow::UpdateStatusBar(void)
{
    int    idString, iPos = 0;
	HICON  hIcon;
	RECT	rc;

	// set the text in part 0
    s_szScratchText[0] = TEXT('\0');
    if ((NULL != m_pEngine) && (NULL != m_pCurrSendFileInfo))
    {
        idString = IDS_STBAR_SENDING_XYZ;
        ::MyLoadString(idString, s_szScratchText, m_pCurrSendFileInfo->GetName());
    }
    else if (NULL == m_pEngine)
    {
        ::MyLoadString(IDS_STBAR_NOT_IN_CALL);
    }
	else
	{
		::MyLoadString(IDS_STBAR_NOT_TRANSFERING);
	}
    ::SendMessage(m_hwndStatusBar, SB_SETTEXT, SBP_TRANSFER_FILE, (LPARAM) s_szScratchText);
	
	// set the progres bar in part 1
    if ((NULL != m_pCurrSendFileInfo)&&m_pCurrSendFileInfo->GetSize())
    {
        iPos = (int)_GetPercent(m_pCurrSendFileInfo->GetTotalSend(), m_pCurrSendFileInfo->GetSize());
    }
	::SendMessage(m_hwndStatusBar, SB_GETRECT, SBP_PROGRESS, (LPARAM)&rc);
	::MoveWindow(m_hwndProgressBar,
				rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
				FALSE);
	::SendMessage(m_hwndProgressBar, PBM_SETPOS, iPos, 0);
	
    // set the icon in part 2
	hIcon = (NULL != m_pEngine) ? m_hIconInCall : m_hIconNotInCall;
	::SendMessage(m_hwndStatusBar, SB_SETTEXT,  SBP_SBICON | SBT_OWNERDRAW,  (LPARAM)hIcon);
}


void CAppletWindow::UpdateListView(CUiSendFileInfo *pFileInfo)
{
    LVFINDINFO lvfi;
    ::ZeroMemory(&lvfi, sizeof(lvfi));
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM) pFileInfo;
    int iItem = ListView_FindItem(m_hwndListView, -1, &lvfi);

    if (-1 != iItem)
    {
		for (ULONG i = 0; i < NUM_LIST_VIEW_COLUMNS; i++)
        {
            ListView_SetItemText(m_hwndListView, iItem, i, LPSTR_TEXTCALLBACK);
        }
    }
}

////////////////////////////////////////////////////////////////////
//
//   Save window position for File Transfer
//

void CAppletWindow::SaveWindowPosition(void)
{
    RECT    rcWnd;
    RegEntry    reWnd( FILEXFER_KEY, HKEY_CURRENT_USER);

	// If we are not maximized or minimized
    if (!::IsZoomed(m_hwndMainUI) && !::IsIconic(m_hwndMainUI))
    {
		::GetWindowRect(m_hwndMainUI, &rcWnd);

		reWnd.SetValue (REGVAL_WINDOW_XPOS, rcWnd.left);
		reWnd.SetValue (REGVAL_WINDOW_YPOS, rcWnd.top);
		reWnd.SetValue (REGVAL_WINDOW_WIDTH, rcWnd.right - rcWnd.left);
		reWnd.SetValue (REGVAL_WINDOW_HEIGHT, rcWnd.bottom - rcWnd.top);
	}
}

void CAppletWindow::FocusNextRecvDlg(void)
{
	if (!m_RecvDlgList.IsEmpty())
	{
		m_RecvDlgList.Reset();
		CRecvDlg *pRecvDlg = m_RecvDlgList.Iterate();
		if (pRecvDlg)
		{
			SetFocus(pRecvDlg->GetHwnd());
		}
	}
}

void CAppletWindow::FocusNextErrorDlg(void)
{
	if (!m_ErrorDlgList.IsEmpty())
	{
		m_ErrorDlgList.Reset();
		HWND hwndErrorDlg = m_ErrorDlgList.Iterate();
		if (hwndErrorDlg)
		{
			::SetFocus(hwndErrorDlg);
		}
	}
}

/////////////////////////////////////////////////////////////////
//
//  Utilities
//

LPTSTR PathNameToFileName(LPTSTR pszPathName)
{
    LPTSTR psz = pszPathName;
    while (*psz != '\0')
    {
        BOOL fDirChar = (*psz == TEXT('\\'));
        psz = ::CharNext(psz);
        if (fDirChar)
        {
            pszPathName = psz;
        }
    }
    return pszPathName;
}


int MyLoadString(UINT idStr)
{
    s_szScratchText[0] = TEXT('\0');
    int iRet = ::LoadString(g_hDllInst, idStr, s_szScratchText, MAX_PATH);
    ASSERT(iRet);
    return iRet;
}


int MyLoadString(UINT idStr, LPTSTR pszDstStr)
{
    *pszDstStr = TEXT('\0');
    int iRet = ::LoadString(g_hDllInst, idStr, pszDstStr, MAX_PATH);
    ASSERT(iRet);
    return iRet;
}


int MyLoadString(UINT idStr, LPTSTR pszDstStr, LPTSTR pszElement)
{
    int cch;
    TCHAR szText[MAX_PATH];

    cch = ::LoadString(g_hDllInst, idStr, szText, count_of(szText));
    if (cch)
    {
        ::wsprintf(pszDstStr, szText, pszElement);
    }
    else
    {
        ASSERT(0);
        *pszDstStr = TEXT('\0');
    }
    return cch;
}


int MyLoadString(UINT idStr, LPTSTR pszDstStr, LPTSTR pszElement1, LPTSTR pszElement2)
{
    int cch;
    TCHAR szText[MAX_PATH];

    cch = ::LoadString(g_hDllInst, idStr, szText, count_of(szText));
    if (cch)
    {
        ::wsprintf(pszDstStr, szText, pszElement1, pszElement2);
    }
    else
    {
        ASSERT(0);
        *pszDstStr = TEXT('\0');
    }
    return cch;
}


void LoadDefaultStrings(void)
{
    // load file transfer name
    s_szMSFT[0] = TEXT('\0');
    ::LoadString(g_hDllInst, IDS_MSFT_NOT_IN_CALL_WINDOW_CAPTION,
                s_szMSFT, count_of(s_szMSFT));
}


/////////////////////////////////////////////////////////////////
//
//  CUiSendFileInfo
//

CUiSendFileInfo::CUiSendFileInfo(CAppletWindow *pWindow, TCHAR szDir[], TCHAR szFile[], BOOL *pfRet)
:
    m_nFileHandle(0),
    m_cbTotalSend(0),
    m_eSendErrorCode(iMBFT_OK),
    m_percentSent(-1),
    m_fAlreadyShowUI(FALSE),
    m_pszFullName(NULL)
{
    *pfRet = FALSE; // failure as default
	HANDLE hFile;

    // build a full name
	hFile = GetOpenFile(pWindow, szDir, szFile, TRUE);  // try to resolve
	if (INVALID_HANDLE_VALUE == hFile)
	{
		hFile = GetOpenFile(pWindow, szDir, szFile, FALSE);
	}
	
	if (INVALID_HANDLE_VALUE != hFile)
    {
        // get the file info
        ::ZeroMemory(&m_FileInfo, sizeof(m_FileInfo));
        BOOL rc = ::GetFileInformationByHandle(hFile, &m_FileInfo);
        ::CloseHandle(hFile);
        if (rc)
        {
            ASSERT(0 == m_FileInfo.nFileSizeHigh);

            // make sure the file size is smaller than what the policy says
            if ((! g_cbMaxSendFileSize) || GetSize() <= g_cbMaxSendFileSize * 1024)
            {
                *pfRet = TRUE;
            }
            else if (pWindow->GetUIMode() != FTUIMODE_NOUI)
            {
                ::MyLoadString(IDS_MSGBOX_SEND_BIG_FILE, s_szScratchText, (LPTSTR) g_cbMaxSendFileSize, m_pszFileName);
                ::MessageBox(pWindow->GetHwnd(), s_szScratchText, s_szMSFT, MB_OK | MB_ICONSTOP);
            }
        }
    }
}


CUiSendFileInfo::~CUiSendFileInfo(void)
{
    delete m_pszFullName;
}


HANDLE CUiSendFileInfo::GetOpenFile(CAppletWindow *pWindow, TCHAR szDir[], TCHAR szFile[], BOOL fResolve)
{
    // build a full name
    ULONG cch;
    TCHAR szName[MAX_PATH*2];
	HANDLE hFile = INVALID_HANDLE_VALUE;

    if ((NULL != szDir)&&(!_StrChr(szFile, '\\')))
    {
        cch = ::lstrlen(szDir);
        ::wsprintf(szName, (TEXT('\\') == szDir[cch-1]) ? TEXT("%s%s") : TEXT("%s\\%s"), szDir, szFile);
    }
    else
    {
        // file name is the full name
        ::lstrcpy(szName, szFile);
    }

    // resolve shortcut if necessary
    cch = ::lstrlen(szName) + 1;
    if (fResolve&&(cch >= 4))
    {
        if (! lstrcmpi(&szName[cch-5], TEXT(".lnk")))
        {
            pWindow->ResolveShortcut(szName, szName);
            cch = ::lstrlen(szName) + 1;
        }
    }

	if (m_pszFullName)
	{
		delete [] m_pszFullName;
	}

    // construct the full name
    DBG_SAVE_FILE_LINE
    m_pszFullName = new TCHAR[cch];
    if (NULL != m_pszFullName)
    {
        ::CopyMemory(m_pszFullName, szName, cch * sizeof(TCHAR));
        m_pszFileName = ::PathNameToFileName(m_pszFullName);

        // open the file
        hFile = ::CreateFile(m_pszFullName, GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,  OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL, NULL);	
	}
	return hFile;
}


/////////////////////////////////////////////////////////////////
//
//  CUiRecvFileInfo
//

CUiRecvFileInfo::CUiRecvFileInfo(FileOfferNotifyMsg *pMsg, HRESULT *pHr)
:
    m_nFileHandle(pMsg->m_hFile),
    m_FileDateTime(pMsg->m_FileDateTime),
    m_cbFileSize(pMsg->m_FileSize),
    m_cbTotalRecvSize(0),
    m_pszFullName(NULL),
    m_pszRecvFolder(NULL)
{
    *pHr = E_FAIL; // failure, at default

	ULONG cchTotal = ::lstrlen(pMsg->m_szFileName);

	// construct the full name
	DBG_SAVE_FILE_LINE
	m_pszFullName = new TCHAR[cchTotal+2];
	if (NULL != m_pszFullName)
	{
		// construct full name and file name
		strcpy(m_pszFullName, pMsg->m_szFileName);
		m_pszFileName = PathNameToFileName(m_pszFullName);
		ULONG cchFile = ::lstrlen(m_pszFileName);
		DBG_SAVE_FILE_LINE
		m_pszRecvFolder = new TCHAR[cchTotal - cchFile + 2];
		if (NULL != m_pszRecvFolder)
		{
			::CopyMemory(m_pszRecvFolder, m_pszFullName, cchTotal - cchFile);
			m_pszRecvFolder[cchTotal - cchFile - 1] = TEXT('\0');
			*pHr = S_OK;
		}
	}
}


CUiRecvFileInfo::~CUiRecvFileInfo(void)
{
    delete m_pszFullName;
    delete m_pszRecvFolder;
}


/////////////////////////////////////////////////////////////////
//
//  Receive Dialog
//

CRecvDlg::CRecvDlg
(
    CAppletWindow      *pWindow,
    T120ConfID          nConfID,
    T120NodeID          nidSender,
    MBFTEVENTHANDLE     nEventHandle,
    CUiRecvFileInfo    *pFileInfo,
    HRESULT            *pHr
)
:
    CRefCount(MAKE_STAMP_ID('F','T','R','D')),
    m_pWindow(pWindow),
    m_nConfID(nConfID),
    m_nidSender(nidSender),
    m_nEventHandle(nEventHandle),
    m_pRecvFileInfo(pFileInfo),
    m_fRecvComplete(FALSE),
    m_fShownRecvCompleteUI(FALSE),
    m_idResult(0),
    m_dwEstTimeLeft(0),
    m_dwPreviousTime(0),
    m_dwPreviousTransferred(0),
    m_dwBytesPerSec(0),
    m_dwStartTime(::GetTickCount())
{
    *pHr = E_FAIL; // failure, at default

    m_hwndRecvDlg = ::CreateDialogParam(g_hDllInst, MAKEINTRESOURCE(IDD_RECVDLG),
                            pWindow->GetHwnd(), RecvDlgProc, (LPARAM) this);
    ASSERT(NULL != m_hwndRecvDlg);
    if (NULL != m_hwndRecvDlg)
    {
        ::ShowWindow(m_hwndRecvDlg, SW_SHOWNORMAL);
        m_pWindow->RegisterRecvDlg(this);
        *pHr = S_OK;
		::SetForegroundWindow(m_hwndRecvDlg);
    }
}


CRecvDlg::~CRecvDlg(void)
{
    delete m_pRecvFileInfo;

    m_pWindow->UnregisterRecvDlg(this);

    if (NULL != m_hwndRecvDlg)
    {
        HWND hwnd = m_hwndRecvDlg;
        m_hwndRecvDlg = NULL;
        ::EndDialog(hwnd, IDCLOSE);
    }
}


/////////////////////////////////////////////////////////////////
//
//  RecvDlg_OnInitDialog
//

void RecvDlg_OnInitDialog(HWND hdlg, WPARAM wParam, LPARAM lParam)
{
    CRecvDlg *pDlg = (CRecvDlg *) ::GetWindowLongPtr(hdlg, DWLP_USER);
    ASSERT(NULL != pDlg);

    CUiRecvFileInfo *pFileInfo = (CUiRecvFileInfo *) pDlg->GetRecvFileInfo();
    ASSERT(NULL != pFileInfo);

    // move the window to proper location
    ULONG nCaptionHeight = ::GetSystemMetrics(SM_CYCAPTION);
    ULONG nShift = nCaptionHeight * (s_cRecvDlg++ % 8);
    RECT rcDlg;
    ::GetWindowRect(hdlg, &rcDlg);
    ::MoveWindow(hdlg, rcDlg.left + nShift, rcDlg.top + nShift,
                 rcDlg.right - rcDlg.left, rcDlg.bottom - rcDlg.top, FALSE);

    // Set font (for international)
    HFONT hfont = (HFONT) ::GetStockObject(DEFAULT_GUI_FONT);
    ASSERT(NULL != hfont);
    ::SendDlgItemMessage(hdlg, IDE_RECVDLG_RECFILE, WM_SETFONT, (WPARAM) hfont, 0);
    ::SendDlgItemMessage(hdlg, IDE_RECVDLG_RECDIR,  WM_SETFONT, (WPARAM) hfont, 0);
    ::SendDlgItemMessage(hdlg, IDE_RECVDLG_SENDER,  WM_SETFONT, (WPARAM) hfont, 0);

    // cache names
    LPTSTR pszFileName = pFileInfo->GetName();
    LPTSTR pszFullName = pFileInfo->GetFullName();

    // title
    TCHAR szText[MAX_PATH*2];
    if (::MyLoadString(IDS_RECVDLG_TITLE, szText, pszFileName))
    {
        ::SetWindowText(hdlg, szText);
    }

    // filename
    ::lstrcpyn(szText, pszFileName, MAX_FILE_NAME_LENGTH);
    if (::lstrlen(pszFileName) > MAX_FILE_NAME_LENGTH)
    {
		LPTSTR psz = szText;
        int i = MAX_FILE_NAME_LENGTH - 1;
        while (i)
        {
            psz = CharNext(psz);
            i--;
        }
        ::lstrcpy(psz, TEXT("..."));
    }
    ::SetDlgItemText(hdlg, IDE_RECVDLG_RECFILE, szText);

    // directory Name
    LPTSTR psz = szText;
    ::lstrcpyn(szText, pszFullName, (int)(pszFileName - pszFullName));
    HDC hdc = ::GetDC(hdlg);
    if (NULL != hdc)
    {
        SIZE size;
        if (::GetTextExtentPoint32(hdc, szText, ::lstrlen(szText), &size))
        {
            RECT rc;
            ::GetWindowRect(::GetDlgItem(hdlg, IDE_RECVDLG_RECDIR), &rc);
            if (size.cx > (rc.right - rc.left))
            {
                // Just display the folder name
                psz = (LPTSTR) ::GetFileNameFromPath(szText);
            }
        }
    }
    ::ReleaseDC(hdlg, hdc);
    ::SetDlgItemText(hdlg, IDE_RECVDLG_RECDIR, psz);

    // sender Name
    if (::T120_GetNodeName(pDlg->GetConfID(), pDlg->GetSenderID(), szText, count_of(szText)))
    {
        ::SetDlgItemText(hdlg, IDE_RECVDLG_SENDER, szText);
    }

    // update "Received xxx bytes of yyy"
    if (::MyLoadString(IDS_RECVDLG_RECBYTES, szText, pFileInfo->GetTotalRecvSize(), pFileInfo->GetSize()))
    {
        ::SetDlgItemText(hdlg, IDE_RECVDLG_RECBYTES, szText);
    }

    // progress bar
    ::SendMessage(GetDlgItem(hdlg, IDC_RECVDLG_PROGRESS), PBM_SETPOS, pDlg->GetPercent(), 0);

    // start animation
    Animate_Open(GetDlgItem(hdlg, IDC_RECVDLG_ANIMATE), MAKEINTRESOURCE(IDA_RECVDLG_ANIMATION));

    // do the animation work
    if (! pDlg->IsRecvComplete())
    {
        Animate_Play(GetDlgItem(hdlg, IDC_RECVDLG_ANIMATE), 0, -1, -1);
        if (::LoadString(g_hDllInst, IDS_RECVDLG_START, szText, count_of(szText)))
        {
            ::SetDlgItemText(hdlg, IDE_RECVDLG_TIME, szText);
        }
    }

    // show the window now
    ::ShowWindow(hdlg, SW_SHOWNORMAL);

    // UpdateProgress();
    pDlg->OnProgressUpdate();
}


/////////////////////////////////////////////////////////////////
//
//  RecvDlg_OnCommand
//

void RecvDlg_OnCommand(HWND hdlg, WPARAM wParam, LPARAM lParam)
{
    CRecvDlg *pDlg = (CRecvDlg *) ::GetWindowLongPtr(hdlg, DWLP_USER);
    ASSERT(NULL != pDlg);

    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
    case IDM_RECVDLG_DELETE:
        pDlg->OnDelete();
        break;

    case IDM_RECVDLG_OPEN:
        pDlg->OnOpen();
        break;

    case IDM_RECVDLG_ACCEPT:
    case IDOK:
    case IDCANCEL:
    case IDCLOSE:
        pDlg->OnAccept();
        break;

    default:
        return;
    }

    // dismiss the dialog
    ::EndDialog(hdlg, GET_WM_COMMAND_ID(wParam, lParam));
    pDlg->Release();
}


void CRecvDlg::OnOpen(void)
{
	// create short version of the path name
	TCHAR szDir[MAX_PATH];
	::GetShortPathName(m_pRecvFileInfo->GetRecvFolder(), szDir, count_of(szDir));

	// create short version of the full name
	TCHAR szFile[MAX_PATH];
	szFile[0] = TEXT('\0');
	::wsprintf(szFile, TEXT("%s\\%s"), szDir, m_pRecvFileInfo->GetName());

	TRACE_OUT(("FT: Opening [%s] in [%]", m_pRecvFileInfo->GetName(), szDir));

	HINSTANCE hInst = ::ShellExecute(m_pWindow->GetHwnd(),
									 NULL,
									 szFile,
									 NULL,
									 szDir,
									 SW_SHOWDEFAULT);
	if (32 >= (DWORD_PTR) hInst)
	{
		WARNING_OUT(("Unable to open [%s] - showing file", szFile));
		::ShellExecute(m_pWindow->GetHwnd(),
					   NULL,
					   szDir,
					   m_pRecvFileInfo->GetFullName(),
					   NULL,
					   SW_SHOWDEFAULT);
	}
}


void CRecvDlg::OnDelete(void)
{
	StopAnimation();

    // check if transfer has completed
    if (! m_fRecvComplete)
    {
        DBG_SAVE_FILE_LINE
        m_pWindow->GetEngine()->SafePostMessage(
                    new FileTransferControlMsg(
                                        m_nEventHandle,
                                        m_pRecvFileInfo->GetFileHandle(),
                                        NULL,
                                        NULL,
                                        FileTransferControlMsg::EnumAbortFile));
    }
    else
    {
		::DeleteFile(m_pRecvFileInfo->GetFullName());
    }
}


void CRecvDlg::OnAccept(void)
{
    StopAnimation();
}



/////////////////////////////////////////////////////////////////
//
//  RecvDlg_OnInitMenuPopup
//

void RecvDlg_OnInitMenuPopup(HWND hdlg, WPARAM wParam, LPARAM lParam)
{
    if (0 != HIWORD(lParam)) // System menu flag
    {
        HMENU hMenu = (HMENU) wParam;         // handle of pop-up menu
        ::EnableMenuItem(hMenu, SC_MAXIMIZE, MF_GRAYED);
        ::EnableMenuItem(hMenu, SC_SIZE, MF_GRAYED);
    }
}


/////////////////////////////////////////////////////////////////
//
//  RecvDlgProc
//

INT_PTR CALLBACK RecvDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = TRUE; // processed

    switch (uMsg)
    {
    case WM_INITDIALOG:
        ASSERT(NULL != lParam);
        ::SetWindowLongPtr(hdlg, DWLP_USER, lParam);
        RecvDlg_OnInitDialog(hdlg, wParam, lParam);
        break;

    case WM_COMMAND:
        RecvDlg_OnCommand(hdlg, wParam, lParam);
        break;

   case WM_INITMENUPOPUP:
        RecvDlg_OnInitMenuPopup(hdlg, wParam, lParam);
        fRet = FALSE;
        break;

		// This means user wants to delete the file.
   case WM_CLOSE:
	   RecvDlg_OnCommand(hdlg, IDCLOSE, lParam);
	   break;;

    default:
        fRet = FALSE; // not processed
        break;
    }

    return fRet;
}


/////////////////////////////////////////////////////////////////
//
//  RecvDlg Animation
//

void CRecvDlg::StopAnimation(void)
{
    HWND hwnd = ::GetDlgItem(m_hwndRecvDlg, IDC_RECVDLG_ANIMATE);
    if (NULL != hwnd)
    {
        Animate_Stop(hwnd);
        Animate_Close(hwnd);
    }
}


ULONG _GetPercent(ULONG cbTotalRecvSize , ULONG cbFileSize)
{

    if (! cbFileSize || (cbTotalRecvSize >= cbFileSize))
    {
        return 100;
    }

    // FUTURE: Consider using EnlargedUnsignedMultiply

    if (cbFileSize < 0x01000000)
    {
        return (cbTotalRecvSize * 100) / cbFileSize;
    }

    return cbTotalRecvSize / (cbFileSize / 100);
}


/////////////////////////////////////////////////////////////////
//
//  RecvDlg Progress
//

ULONG CRecvDlg::GetPercent(void)
{
    return   _GetPercent(m_pRecvFileInfo->GetTotalRecvSize(), m_pRecvFileInfo->GetSize());
}



void CRecvDlg::OnProgressUpdate(FileTransmitMsg *pMsg)
{

    if (NULL != pMsg)
    {
        ASSERT(iMBFT_FILE_RECEIVE_PROGRESS == (MBFT_NOTIFICATION) pMsg->m_TransmitStatus ||
               iMBFT_FILE_RECEIVE_BEGIN    == (MBFT_NOTIFICATION) pMsg->m_TransmitStatus);

        ASSERT(m_nEventHandle == pMsg->m_EventHandle);
        ASSERT(m_pRecvFileInfo->GetFileHandle() == pMsg->m_hFile);
        ASSERT(m_pRecvFileInfo->GetSize() == pMsg->m_FileSize);

        m_pRecvFileInfo->SetTotalRecvSize(pMsg->m_BytesTransmitted);

        if (pMsg->m_BytesTransmitted >= pMsg->m_FileSize)
        {
            m_fRecvComplete = TRUE;
            m_idResult = IDS_RECVDLG_COMPLETE;
        }
    }

    if (m_fRecvComplete && ! m_fShownRecvCompleteUI)
    {
        m_fRecvComplete = TRUE;

        TCHAR szText[MAX_PATH];
        if (::LoadString(g_hDllInst, IDS_RECVDLG_CLOSE, szText, count_of(szText)))
        {
            ::SetDlgItemText(m_hwndRecvDlg, IDM_RECVDLG_ACCEPT, szText);
        }

        if (IDS_RECVDLG_COMPLETE == m_idResult)
        {
            ::EnableWindow(::GetDlgItem(m_hwndRecvDlg, IDM_RECVDLG_OPEN), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(m_hwndRecvDlg, IDM_RECVDLG_DELETE), FALSE);
        }

        // Reset animation
        HWND hwnd = ::GetDlgItem(m_hwndRecvDlg, IDC_RECVDLG_ANIMATE);
        Animate_Stop(hwnd);
        Animate_Close(hwnd);
        Animate_Open(hwnd, MAKEINTRESOURCE(IDA_RECVDLG_DONE));
        Animate_Seek(hwnd, ((IDS_RECVDLG_COMPLETE == m_idResult) ? 0 : 1));

        m_fShownRecvCompleteUI = TRUE;
    }

    ULONG cbTotalRecvSize = m_pRecvFileInfo->GetTotalRecvSize();
    ULONG cbFileSize = m_pRecvFileInfo->GetSize();

    DWORD dwNow = ::GetTickCount();
    DWORD dwBytesPerSec;
    DWORD dwBytesRead;
    TCHAR szOut[MAX_PATH];

    if (m_dwPreviousTransferred != cbTotalRecvSize)
    {
        TCHAR szFmt[MAX_PATH];

        // Update "Received xxx bytes of yyy"
        if (::LoadString(g_hDllInst, IDS_RECVDLG_RECBYTES, szFmt, count_of(szFmt)))
        {
            ::wsprintf(szOut, szFmt, cbTotalRecvSize, cbFileSize);
            ::SetDlgItemText(m_hwndRecvDlg, IDE_RECVDLG_RECBYTES, szOut);
        }

        // Update Progress Bar
        if (cbTotalRecvSize)
        {
            ::SendMessage(GetDlgItem(m_hwndRecvDlg, IDC_RECVDLG_PROGRESS), PBM_SETPOS, GetPercent(), 0);
        }
    }

    // check if no time estimate is required
    if (m_fRecvComplete)
    {
        if (::LoadString(g_hDllInst, m_idResult, szOut, count_of(szOut)))
        {
            ::SetDlgItemText(m_hwndRecvDlg, IDE_RECVDLG_TIME, szOut);
        }
        return;
    }

    // first time we're in here for this file?
    if (! m_dwPreviousTime || ! cbTotalRecvSize)
    {
        // no data, yet
        m_dwPreviousTime = dwNow - 1000;
        ASSERT(! m_dwPreviousTransferred);
        ASSERT(! m_dwBytesPerSec);
        return;
    }

    // Has enough time elapsed to update the display?
    // We do this about every 5 seconds (note the adjustment for first time)
    if ((dwNow - m_dwPreviousTime) < 5000)
        return;

    dwBytesRead = cbTotalRecvSize - m_dwPreviousTransferred;

    // We take 10 times the number of bytes and divide by the number of
    // tenths of a second to minimize both overflow and roundoff
    dwBytesPerSec = dwBytesRead * 10 / ((dwNow - m_dwPreviousTime) / 100);
    if (! dwBytesPerSec)
    {
        // very low transmission rate!  Ignore the information?
        return;
    }
    if (m_dwBytesPerSec)
    {
        // Take the average of the current transfer rate and the
        // previously computed one, just to try to smooth out
        // some random fluctuations
        dwBytesPerSec = (dwBytesPerSec + m_dwBytesPerSec) / 2;
    }
    m_dwBytesPerSec = dwBytesPerSec;

    // Calculate time remaining (round up by adding 1)
    m_dwEstTimeLeft = ((cbFileSize - cbTotalRecvSize) / m_dwBytesPerSec) + 1;

    // Reset time and # of bytes read
    m_dwPreviousTime = dwNow;
    m_dwPreviousTransferred = cbTotalRecvSize;

    if (m_dwEstTimeLeft < 3)
    {
//        szOut[0] = _T('\0');  // don't bother updating when almost done
        return;
    }
    if (m_dwEstTimeLeft > 99)
    {
        // dwTime is about 2 mintes
        ::MyLoadString(IDS_RECVDLG_MINUTES, szOut, ((m_dwEstTimeLeft / 60) + 1));
    }
    else
    {
        // Round up to 5 seconds so it doesn't look so random
        ::MyLoadString(IDS_RECVDLG_SECONDS, szOut, (((m_dwEstTimeLeft + 4) / 5) * 5) );
    }

    ::SetDlgItemText(m_hwndRecvDlg, IDE_RECVDLG_TIME, szOut);
}


void CRecvDlg::OnCanceled(void)
{
    m_idResult = IDS_RECVDLG_CANCEL;
    m_fRecvComplete = TRUE;
    OnProgressUpdate();
}


void CRecvDlg::OnRejectedFile(void)
{
    m_idResult = IDS_RECVDLG_SENDER_CANCEL;
    m_fRecvComplete = TRUE;
    OnProgressUpdate();
}



//////////////////////////////////////////////////////////////////////
//
// Shortcut/Link Management
//

void CAppletWindow::ResolveShortcut(LPTSTR pszSrcFile, LPTSTR pszDstFile)
{
    ASSERT(NULL != pszSrcFile && '\0' != *pszSrcFile);
    ASSERT(NULL != pszDstFile);

    IShellLink *psl;
    HRESULT hr = ::CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IShellLink, (LPVOID *) &psl);
    if (SUCCEEDED(hr))
    {
        IPersistFile *ppf;
        hr = psl->QueryInterface(IID_IPersistFile, (LPVOID *) &ppf);
        if (SUCCEEDED(hr))
        {
            WCHAR wsz[MAX_PATH]; /* Buffer for unicode string */
#ifdef _UNICODE
            ::lstrcpyn(wsz, pszSrcFile, MAX_PATH);
#else
            ::MultiByteToWideChar(CP_ACP, 0, pszSrcFile, -1, wsz, MAX_PATH);
#endif

            hr = ppf->Load(wsz, STGM_READ);
            if (SUCCEEDED(hr))
            {
                /* Resolve the link, this may post UI to find the link */
                hr = psl->Resolve(m_hwndMainUI, SLR_ANY_MATCH);
                if (SUCCEEDED(hr))
                {
                    psl->GetPath(pszDstFile, MAX_PATH, NULL, 0);
                }

                TRACE_OUT(("CAppletWindow::ResolveShortcut: File resolved to [%s]", pszDstFile));
            }
            ppf->Release();
        }
        psl->Release();
    }
}


/////////////////////////////////////////////////////////////////
//
//  Non-blocking Message Box
//

INT_PTR MsgBox2DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;
	CAppletWindow *pWindow;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            // get the text to display
            LPTSTR pszText = (LPTSTR) lParam;
            ASSERT(NULL != pszText && TEXT('\0') != *pszText);

            // estimate how big the read-only edit control should be
            HDC hdc = ::GetDC(hdlg);
            if (NULL != hdc)
            {
                SIZE csEdit;
                if (::GetTextExtentPoint32(hdc, pszText, ::lstrlen(pszText), &csEdit))
                {
                    const ULONG c_nMarginX = 0;
                    const ULONG c_nMarginY = 10;

                    ULONG nCaptionHeight = ::GetSystemMetrics(SM_CYCAPTION);
                    ULONG nShift = nCaptionHeight * (s_cMsgBox2Dlg++ % 8);

                    // move the edit control
                    HWND hwndEdit = ::GetDlgItem(hdlg, IDE_MSGBOX2_TEXT);
                    POINT ptEdit;
                    ptEdit.x = c_nMarginX;
                    ptEdit.y = c_nMarginY + (c_nMarginY >> 1);
                    csEdit.cx += c_nMarginX << 1;
                    csEdit.cy += c_nMarginY << 1;
                    ::MoveWindow(hwndEdit, ptEdit.x, ptEdit.y, csEdit.cx, csEdit.cy, FALSE);

                    // move the ok button
                    HWND hwndOK = ::GetDlgItem(hdlg, IDOK);
                    RECT rcOK;
                    ::GetWindowRect(hwndOK, &rcOK);
                    SIZE csOK;
                    csOK.cx = rcOK.right - rcOK.left;
                    csOK.cy = rcOK.bottom - rcOK.top;
                    POINT ptOK;
                    ptOK.x = ptEdit.x + (csEdit.cx >> 1) - (csOK.cx >> 1);
                    ptOK.y = ptEdit.y + csEdit.cy + (c_nMarginY >> 1);
                    ::MoveWindow(hwndOK, ptOK.x, ptOK.y, csOK.cx, csOK.cy, FALSE);

                    // adjust all the windows
                    RECT rcDlg, rcClient;
                    ::GetWindowRect(hdlg, &rcDlg);
                    POINT ptDlg;
                    ptDlg.x = rcDlg.left + nShift;
                    ptDlg.y = rcDlg.top + nShift;
                    ::GetClientRect(hdlg, &rcClient);
                    SIZE csDlg;
                    csDlg.cx = (rcDlg.right - rcDlg.left) - (rcClient.right - rcClient.left);
                    csDlg.cy = (rcDlg.bottom - rcDlg.top) - (rcClient.bottom - rcClient.top);
                    csDlg.cx += ptEdit.x + csEdit.cx + c_nMarginX;
                    csDlg.cy += ptOK.y + csOK.cy + c_nMarginY;
                    ::MoveWindow(hdlg, ptDlg.x, ptDlg.y, csDlg.cx, csDlg.cy, FALSE);
                }
                ::ReleaseDC(hdlg, hdc);
            }

            ::SetDlgItemText(hdlg, IDE_MSGBOX2_TEXT, pszText);
            delete [] pszText; // free the display text
            fHandled = TRUE;
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
        case IDCANCEL:
        case IDCLOSE:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case BN_CLICKED:
				pWindow = (CAppletWindow*)::GetWindowLongPtr(hdlg, DWLP_USER);
				ASSERT (pWindow);
				if (pWindow)
				{
					pWindow->RemoveErrorDlg(hdlg);	
					pWindow->FocusNextErrorDlg();
				}
                ::EndDialog(hdlg, IDOK);
                break;
            }
            break;
        }

        fHandled = TRUE;
        break;
    }

    return(fHandled);
}


BOOL MsgBox2(CAppletWindow *pWindow, LPTSTR pszText)
{
    BOOL fRet = FALSE;
    ULONG cch = ::lstrlen(pszText) + 1;
    DBG_SAVE_FILE_LINE
    LPTSTR pszNew = new TCHAR[cch];
    if (NULL != pszNew)
    {
        ::CopyMemory(pszNew, pszText, cch);
        HWND hwndDlg = ::CreateDialogParam(g_hDllInst, MAKEINTRESOURCE(IDD_MSGBOX2),
                            pWindow->GetHwnd(), MsgBox2DlgProc, (LPARAM) pszNew);

        ASSERT(NULL != hwndDlg);
        if (NULL != hwndDlg)
        {
            ::ShowWindow(hwndDlg, SW_SHOWNORMAL);
            fRet = TRUE;
            ::SetForegroundWindow(hwndDlg);
			::SetWindowLongPtr(hwndDlg, DWLP_USER, (LPARAM)pWindow);
			pWindow->AddErrorDlg(hwndDlg);
        }
    }
    else
    {
        ERROR_OUT(("FT::MsgBox2: cannot duplicate string [%s]", pszText));
    }
    return fRet;
}


/////////////////////////////////////////////////////////////////
//
//  Receive Folder Management
//

HRESULT GetRecvFolder(LPTSTR pszInFldr, LPTSTR pszOutFldr)
{
    LPTSTR psz;
    TCHAR szPath[MAX_PATH];

    RegEntry reFileXfer(FILEXFER_KEY, HKEY_CURRENT_USER);

    if (NULL == pszInFldr)
    {
        // NULL directory specified - get info from registry or use default
        psz = reFileXfer.GetString(REGVAL_FILEXFER_PATH);
        if (NULL != psz && TEXT('\0') != *psz)
        {
            ::lstrcpyn(szPath, psz, count_of(szPath));
        }
        else
        {
            TCHAR szInstallDir[MAX_PATH];
            ::GetInstallDirectory(szInstallDir);
            ::MyLoadString(IDS_RECDIR_DEFAULT, szPath, szInstallDir);
        }

        pszInFldr = szPath;
    }

    ::lstrcpyn(pszOutFldr, pszInFldr, MAX_PATH);

    // Remove trailing backslash, if any
    for (psz = pszOutFldr; *psz; psz = CharNext(psz))
    {
        if ('\\' == *psz && '\0' == *CharNext(psz))
        {
            *psz = '\0';
            break;
        }
    }

    HRESULT hr;
    if (!FEnsureDirExists(pszOutFldr))
    {
        WARNING_OUT(("ChangeRecDir: FT directory is invalid [%s]", pszOutFldr));
        hr = E_FAIL;
    }
    else
    {
        // update the registry
        reFileXfer.SetValue(REGVAL_FILEXFER_PATH, pszOutFldr);
        hr = S_OK;
    }
    return hr;
}


void EnsureTrailingSlash(LPTSTR psz)
{
    LPTSTR psz2;

    // Make sure the directory name has a trailing '\'
    while (TEXT('\0') != *psz)
    {
        psz2 = ::CharNext(psz);
        if (TEXT('\\') == *psz && TEXT('\0') == *psz2)
        {
            // The path already ends with a backslash
            return;
        }
        psz = psz2;
    }

    // Append a trailing backslash
    *psz = TEXT('\\');
	psz = ::CharNext(psz);
	*psz = TEXT('\0');
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\mbft.hpp ===
#ifndef __MBFT_HPP__
#define __MBFT_HPP__

#include "osshelp.hpp"
#include "messages.hpp"
#include <it120app.h>

// LONCHANC: temporarily enable conductorship
// #define ENABLE_CONDUCTORSHIP    1

//Intel specific non-collapsing capabilities values....
enum NonCollapsCaps
{
	_iMBFT_FIRST_PROSHARE_CAPABILITY_ID = 0x100,
	_iMBFT_PROSHARE_VERSION_ID____NOT_USED,
	_iMBFT_PROSHARE_FILE_EOF_ACK_ID,
	_iMBFT_LAST_NON_COLLAPSING_CAPABILITIES
};


//Intel specific collapsing capabilities values....

//Note: The size of _iMBFT_MAX_FILEDATA_PDU_LENGTH actually controls the maximum number
//of bytes in the file start and data PDUs. If this is increased, the corresponding constant
//in MCSHELP.HPP (_MAX_MCS_MESSAGE_SIZE) must also be increased...

const USHORT _iMBFT_MAX_FILEDATA_PDU_LENGTH          = 25000;
const USHORT _iMBFT_DEFAULT_MAX_FILEDATA_PDU_LENGTH  = 8192;
const ULONG  _iMBFT_MAX_FILE_SIZE                    = 0xFFFFFFFFUL;
const USHORT _iMBFT_V42_NO_OF_CODEWORDS              = 512;
const USHORT _iMBFT_V42_MAX_STRING_LENGTH            = 6;
const USHORT _iMBFT_V42_COMPRESSION_SUPPORTED        = TRUE;
const USHORT _iMBFT_MAX_COLLAPSING_CAPABILITIES      = 3;

#define    _iMBFT_MAX_NON_COLLAPSING_CAPABILITIES   _iMBFT_LAST_NON_COLLAPSING_CAPABILITIES - _iMBFT_FIRST_PROSHARE_CAPABILITY_ID

//Added by Atul -- another magic number that we subtract from MCSMaxDomainPDU size
//presumably to allow for the overhead added by the lower layers...

const USHORT _iMBFT_FILEDATA_PDU_SUBTRACT            = 64;

//In our implementation we get the max pdu by a proprietary MCS api called
//GetDomainParameters.  No such liberties with MSFT stuff!!
const unsigned int _iMBFT_DEFAULT_MAX_MCS_SIZE = MAX_MCS_DATA_SIZE;

//Standard MBFT identifiers and channel IDs
const USHORT _MBFT_MAX_FILE_SIZE_ID                  = 1;
const USHORT _MBFT_MAX_DATA_PAYLOAD_ID               = 2;
const USHORT _MBFT_V42_COMPRESSION_ID                = 3;
const USHORT _MBFT_V42_NO_OF_CODEWORDS_ID            = 4;
const USHORT _MBFT_V42_MAX_STRING_LENGTH_ID          = 5;


MBFTEVENTHANDLE GetNewEventHandle(void);
MBFTFILEHANDLE GetNewFileHandle(void);


enum MBFTState
{
    IdleNotInitialized,
    IdleInitialized
};

class MBFTInterface;
class MBFTMsg;
class MBFTPDUMsg;
class CAppletWindow;

class MBFTSession;
class CSessionList : public CList
{
    DEFINE_CLIST(CSessionList, MBFTSession *)
    void Delete(MBFTSession *);
};

class CPeerData;
class CPeerList : public CList
{
    DEFINE_CLIST(CPeerList, CPeerData *)
    CPeerData *Find(T120UserID uidPeer);
    BOOL IsValidPeerID(T120UserID uidPeer) { return (NULL != Find(uidPeer)); }
    CPeerData * CPeerList::FindSamePeer(CPeerData *pPeer);
    void CPeerList::Delete(CPeerData *p);
    void DeleteAll(void);
};


//
// MBFT engine, one per conference
//

class MBFTEngine : public CRefCount
{
public:

    MBFTEngine(MBFTInterface *, MBFT_MODE, T120SessionID);
    ~MBFTEngine(void);

private:

    IT120AppletSession     *m_pAppletSession;
    T120Error               m_eLastSendDataError;
    MBFTInterface          *m_pMBFTIntf;

    T120ConfID              m_nConfID;
    MBFT_MODE               m_eMBFTMode;

    T120SessionID           m_SessionID;
    T120UserID              m_uidMyself;
    T120NodeID              m_nidMyself;
    T120EntityID            m_eidMyself;

    T120ChannelID           m_MBFTControlChannel;
    T120ChannelID           m_MBFTDataChannel;

    T120ChannelID           m_aStaticChannels[2];
#ifdef USE_MULTICAST_SESSION
    T120ResourceRequest     m_aJoinResourceReqs[1];
#endif
    T120JoinSessionRequest  m_JoinSessionReq;

    BOOL                    m_fConfAvailable;
    BOOL                    m_fJoinedConf;

    MBFTState               m_State;

    // LONCHANC: NetMeeting's Node Controller does not exercise conductorship.
#ifdef ENABLE_CONDUCTORSHIP
    BOOL                    m_bInConductedMode;
    T120NodeID              m_ConductorNodeID;
    T120UserID              m_MBFTConductorID;
    ULONG                   m_ConductedModePermission;
    BOOL                    m_bWaitingForPermission;
#endif // ENABLE_CONDUCTORSHIP

    CSessionList            m_SessionList;
    CPeerList               m_PeerList;

    ULONG                   m_nRosterInstance;

    ULONG                   m_MBFTMaxFileSize;
    ULONG                   m_MBFTMaxDataPayload;
    ULONG                   m_MBFTMaxSendDataPayload;
    BOOL                    m_bV42CompressionSupported;
    USHORT                  m_v42bisP1;
    USHORT                  m_v42bisP2;

    MBFTEVENTHANDLE         m_lEventHandle;

    CAppletWindow          *m_pWindow;

#ifdef ENABLE_HEARTBEAT_TIMER
    UINT_PTR                m_nTimerID;
#endif

public:

    //
    // Handy inline methods
    //

    T120Error GetLastSendDataError(void) { return m_eLastSendDataError; }
    CPeerList *GetPeerList(void) { return &m_PeerList; }
    ULONG GetPeerCount(void) { return m_PeerList.GetCount(); }
    T120ConfID GetConfID(void) { return m_nConfID; }
    T120UserID GetUserID(void) { return m_uidMyself; }
    T120NodeID GetNodeID(void) { return m_nidMyself; }
    T120SessionID GetSessionID(void) { return m_SessionID; }

    T120ChannelID GetDefaultControlChannel(void) { return m_MBFTControlChannel; }
    T120ChannelID GetDefaultDataChannel(void) { return m_MBFTDataChannel; }

    BOOL Has2xNodeInConf(void);
	BOOL HasSDK(void);

    void SetConferenceAvailable(BOOL fConfAvailable) { m_fConfAvailable = fConfAvailable; }

    BOOL IsValidPeerID(T120UserID uidPeer) { return m_PeerList.IsValidPeerID(uidPeer); }
    ULONG GetRosterInstance(void) { return m_nRosterInstance; }

    HRESULT SafePostMessage(MBFTMsg *p);
    HRESULT SafePostNotifyMessage(MBFTMsg *p);

    void ClearInterfacePointer(void) { m_pMBFTIntf = NULL; }
    MBFTInterface *GetInterfacePointer(void) { return m_pMBFTIntf; }
    void SetInterfacePointer(MBFTInterface *pIntf);

#ifdef ENABLE_HEARTBEAT_TIMER
    UINT_PTR GetTimerID(void) { return m_nTimerID; }
#endif

    void SetWindow(CAppletWindow *pWindow) { m_pWindow = pWindow; }

    //
    // Conducted-mode methods
    //

// LONCHANC: NetMeeting's Node Controller does not exercise conductorship.
#ifdef ENABLE_CONDUCTORSHIP
    void OnConductAssignIndication(GCCConductorAssignInd *);
    void OnConductReleaseIndication(GCCConferenceID);
    void OnConductGrantIndication(GCCConductorPermitGrantInd *);
    void AbortAllSends(void);
    void ApplyForPermission(void);
    BOOL ConductedModeOK(void);
#else
    BOOL ConductedModeOK(void) { return TRUE; }
#endif // ENABLE_CONDUCTORSHIP


    //
    // Notification for file transfer protocol
    //

    BOOL OnReceivedPrivateChannelInvitePDU(T120ChannelID, T120Priority, T120UserID,
                                       LPPRIVATECHANNELINVITEPDU lpNewPDU,
                                       BOOL IsUniformSendData);
    BOOL OnReceivedFileRequestPDU(T120ChannelID, T120Priority, T120UserID,
                              LPFILEREQUESTPDU lpNewPDU,
                              BOOL IsUniformSendData);
    BOOL OnReceivedDirectoryRequestPDU(T120ChannelID, T120Priority, T120UserID,
                                   LPDIRECTORYREQUESTPDU lpNewPDU,
                                   BOOL IsUniformSendData);
    BOOL OnReceivedPrivilegeAssignPDU(T120ChannelID, T120Priority, T120UserID,
    				 LPPRIVILEGEASSIGNPDU lpNewPDU,
    				 BOOL IsUniformSendData);
    //
    // Common public methods
    //

    BOOL HandleSessionCreation(MBFTMsg *pMsg);
    BOOL DispatchPDUMessage(MBFTSession *, MBFTPDUMsg *);
    BOOL ProcessMessage(MBFTMsg *pMsg);
    BOOL DoStateMachine(MBFTMsg *pMsg);
	void AddAllPeers(void);
	BOOL NoUIMode(void) { return (m_pWindow == NULL); }

private:

    void AddPeerNotification(T120NodeID, T120UserID, BOOL IsLocalNode, BOOL IsProshareNode, BOOL bPeerAdded, LPCSTR lpszAppKey, T120SessionID);

    BOOL SimpleChannelRequest(AppletChannelCommand, T120ChannelID);
	T120NodeID GetNodeIdByUserID(T120UserID UserID);


public:

    //
    // T120 service request
    //

    BOOL MCSChannelJoinRequest(T120ChannelID nChannelID) { return SimpleChannelRequest(APPLET_JOIN_CHANNEL, nChannelID); }
    BOOL MCSChannelLeaveRequest(T120ChannelID nChannelID) { return SimpleChannelRequest(APPLET_LEAVE_CHANNEL, nChannelID); }
    BOOL MCSChannelConveneRequest(void) { return SimpleChannelRequest(APPLET_CONVENE_CHANNEL, 0); }
    BOOL MCSChannelDisbandRequest(T120ChannelID nChannelID) { return SimpleChannelRequest(APPLET_DISBAND_CHANNEL, nChannelID); }

    BOOL MCSChannelAdmitRequest(T120ChannelID, T120UserID *, ULONG cUsers);
    BOOL SendDataRequest(T120ChannelID, T120Priority, LPBYTE lpBuffer, ULONG ulSize);


    //
    // Notification for T.120 applet
    //

    void OnPermitToEnrollIndication(GCCAppPermissionToEnrollInd *);
    void OnJoinSessionConfirm(T120JoinSessionConfirm *);
    void OnDetachUserIndication(T120UserID, T120Reason);
    void OnRosterReportIndication(ULONG cRosters, GCCAppRoster **);
    void OnChannelAdmitIndication(T120ChannelID, T120UserID uidManager);
    void OnSendDataIndication(
                BOOL                fUniformSend,
                T120UserID          nSenderID,
                T120ChannelID       nChannelID,
                T120Priority        ePriority,
                ULONG               cbBufSize,
                LPBYTE              pBufData);
};

typedef MBFTEngine * LPMBFTENGINE;


//
// Peer data
//

class CPeerData
{
private:

    T120UserID      m_NodeID;
    T120UserID      m_MBFTUserID;
    BOOL            m_bIsLocalNode;
    BOOL            m_bIsProshareNode;
    BOOL            m_bCanConduct;
    BOOL            m_bEOFAcknowledgment;
    char            m_szAppKey[MAX_APP_KEY_SIZE];
    DWORD           m_dwVersion;

public:

    CPeerData(UserID NodeID,UserID MBFTUserID,BOOL IsLocalNode,
              BOOL IsProshareNode,BOOL bCanConduct,BOOL m_bEOFAcknowledgment,
              LPCSTR lpszAppKey, DWORD dwVersion);

    ~CPeerData(void) {}

    T120UserID GetUserID(void) { return m_MBFTUserID; }
    T120NodeID GetNodeID(void) { return m_NodeID; }
    BOOL GetIsLocalNode(void) { return m_bIsLocalNode; }
    BOOL GetIsProshareNode(void) { return m_bIsProshareNode; }
    BOOL GetCanConduct(void) { return m_bCanConduct; }
    BOOL GetEOFAcknowledge(void) { return m_bEOFAcknowledgment; }
    LPCSTR GetAppKey(void) { return m_szAppKey; }
    DWORD GetVersion(void) { return m_dwVersion; }
};

typedef CPeerData * LPPEERDATA;


//
// MBFT sub session, the interface class of
//                      MBFTPrivateSend
//                      MBFTPrivateReceive
//                      MBFTBroadcastReceive
//

class MBFTSession
{
public:

    MBFTSession::MBFTSession(MBFTEngine *pEngine, MBFTEVENTHANDLE nEventHandle, MBFT_SESSION_TYPE eType)
    :
        m_lpParentEngine(pEngine),
        m_EventHandle(nEventHandle),
        m_MBFTSessionType(eType)
    {
    }
    virtual ~MBFTSession(void) = 0;

    MBFTEVENTHANDLE GetEventHandle(void) { return m_EventHandle; }
    MBFT_SESSION_TYPE GetSessionType(void) { return m_MBFTSessionType; }
    BOOL IsSendSession(void) { return (MBFT_PRIVATE_SEND_TYPE == m_MBFTSessionType); }
    BOOL IsReceiveSession(void)
    {
        return (MBFT_PRIVATE_SEND_TYPE != m_MBFTSessionType);
    }

    //
    // T120 callback
    //
    virtual BOOL OnMCSChannelJoinConfirm(T120ChannelID, BOOL bSuccess) = 0;


    //
    // File transfer protocal callback
    //
    virtual BOOL OnReceivedFileErrorPDU(T120ChannelID, T120Priority, T120UserID,
                                        LPFILEERRORPDU lpNewPDU,
                                        BOOL IsUniformSendData) = 0;
    virtual void OnPeerDeletedNotification(CPeerData * lpPeerData) = 0;
    virtual void OnControlNotification(MBFTFILEHANDLE,
                                       FileTransferControlMsg::FileTransferControl iControlCommand,
                                       LPCSTR lpszDirectory,
                                       LPCSTR lpszFileName) = 0;
    virtual void DoStateMachine(void) = 0;
    virtual void UnInitialize(BOOL bIsShutDown) = 0;

protected:

    LPMBFTENGINE            m_lpParentEngine;
    MBFTEVENTHANDLE         m_EventHandle;
    MBFT_SESSION_TYPE       m_MBFTSessionType;
};

typedef class MBFTSession * LPMBFTSESSION;


#endif  //__MBFT_HPP__


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\mbft.cpp ===
/* file: mbft.cpp */

#include "mbftpch.h"
#include <it120app.h>
#include <version.h>

#define __NO_EXTERNS__
#include "mbft.hpp"
#include "osshelp.hpp"
#include "messages.hpp"
#include "mbftrecv.hpp"
#include "mbftsend.hpp"

void CALLBACK T120Callback(T120AppletSessionMsg *);

// from mbftapi.cpp
BOOL g_fWaitingForBufferAvailable = FALSE;


#ifdef ENABLE_HEARTBEAT_TIMER

// WM_TIMER has the lowest priority among window messages
#define  IDLE_TIMER_SPEED   5000
#define  SESSION_TIMER_SPEED   5

void HeartBeatTimerProc(HWND hWnd, UINT uMsg, UINT_PTR nTimerID, DWORD dwTime)
{
    if (NULL != g_pFileXferApplet)
    {
        MBFTEngine *pEngine = g_pFileXferApplet->FindEngineByTimerID(nTimerID);
        if (NULL != pEngine)
        {
            ::PostMessage(g_pFileXferApplet->GetHiddenWnd(), MBFTMSG_HEART_BEAT, 
                                                0, (LPARAM) pEngine);
        }
    }
}
#endif





MBFTEngine::MBFTEngine
(
    MBFTInterface          *pMBFTIntf,
    MBFT_MODE               eMode,
    T120SessionID           nSessionID
)
:
    CRefCount(MAKE_STAMP_ID('F','T','E','g')),

    m_pAppletSession(NULL),
    m_eLastSendDataError(T120_NO_ERROR),

    m_pMBFTIntf(pMBFTIntf),

    m_fConfAvailable(FALSE),
    m_fJoinedConf(FALSE),

    m_uidMyself(0), // user id
    m_nidMyself(0), // node id
    m_eidMyself(0), // entity id

    m_eMBFTMode(eMode),
    m_SessionID(nSessionID),

    m_MBFTControlChannel(nSessionID),
    m_MBFTDataChannel(0),

    m_nRosterInstance(0),
 
    m_nConfID(0),

    m_MBFTMaxFileSize(_iMBFT_MAX_FILE_SIZE),
    
    m_MBFTMaxDataPayload(_iMBFT_DEFAULT_MAX_FILEDATA_PDU_LENGTH),
    m_MBFTMaxSendDataPayload(_iMBFT_DEFAULT_MAX_MCS_SIZE - _iMBFT_FILEDATA_PDU_SUBTRACT),

    m_bV42CompressionSupported(FALSE),
    m_v42bisP1(_iMBFT_V42_NO_OF_CODEWORDS),
    m_v42bisP2(_iMBFT_V42_MAX_STRING_LENGTH),
    
    // LONCHANC: NetMeeting's Node Controller does not exercise conductorship.
#ifdef ENABLE_CONDUCTORSHIP
    m_bInConductedMode(FALSE),
    m_ConductorNodeID(0),
    m_MBFTConductorID(0),
    m_ConductedModePermission(0),
    m_bWaitingForPermission(FALSE),
#endif // ENABLE_CONDUCTORSHIP

    m_pWindow(NULL),
    m_State(IdleNotInitialized)
{
    g_fWaitingForBufferAvailable = FALSE;

    switch (m_eMBFTMode)
    {
    case MBFT_STATIC_MODE:
        ASSERT(m_MBFTControlChannel == _MBFT_CONTROL_CHANNEL);
        m_MBFTDataChannel = _MBFT_DATA_CHANNEL;
        break;

#ifdef USE_MULTICAST_SESSION
    case MBFT_MULTICAST_MODE:
        break;
#endif

    default:
        ERROR_OUT(("MBFTEngine::MBFTEngine: invalid session type=%u", m_eMBFTMode));
        break;
    }

    // clear join session structures
    ::ZeroMemory(&m_aStaticChannels, sizeof(m_aStaticChannels));
#ifdef USE_MULTICAST_SESSION
    ::ZeroMemory(&m_aJoinResourceReqs, sizeof(m_aJoinResourceReqs));
#endif
    ::ZeroMemory(&m_JoinSessionReq, sizeof(m_JoinSessionReq));

    ASSERT(NULL != g_pFileXferApplet);
    g_pFileXferApplet->RegisterEngine(this);

    m_pWindow = g_pFileXferApplet->GetUnattendedWindow();
    if (NULL != m_pWindow)
    {
        m_pWindow->RegisterEngine(this);
    }

#ifdef ENABLE_HEARTBEAT_TIMER
    m_nTimerID = ::SetTimer(NULL, 0, IDLE_TIMER_SPEED, HeartBeatTimerProc);
#endif
}

MBFTEngine::~MBFTEngine(void)
{
#ifdef ENABLE_HEARTBEAT_TIMER
    // kill the timer now
    ::KillTimer(NULL, m_nTimerID);
#endif

    // the interface object is already gone
    m_pMBFTIntf = NULL;

    MBFTSession *pSession;
    while (NULL != (pSession = m_SessionList.Get()))
    {
        pSession->UnInitialize(FALSE);
        delete pSession; // LONCHANC: not sure about this delete
    }

    if (NULL != m_pAppletSession)
    {
        m_pAppletSession->ReleaseInterface();
    }

    ASSERT(! m_fJoinedConf);

    m_PeerList.DeleteAll();
}

void MBFTEngine::SetInterfacePointer( MBFTInterface *pIntf )
{ 
        CPeerData       *pPeerData;

        ASSERT (pIntf);
        m_pMBFTIntf = pIntf; 
        m_PeerList.Reset();
        while (NULL != (pPeerData = m_PeerList.Iterate()))
        {
                if (pPeerData->GetNodeID() != m_nidMyself)
                {
                        AddPeerNotification(pPeerData->GetNodeID(), 
                                                        pPeerData->GetUserID(),
                                                        pPeerData->GetIsLocalNode(), 
                                                        pPeerData->GetIsProshareNode(), TRUE,
                                                        pPeerData->GetAppKey(),
                                                        m_SessionID);
                }
        }
}

BOOL MBFTEngine::Has2xNodeInConf(void)
{
    CPeerData *pPeerData;
    m_PeerList.Reset();
    while (NULL != (pPeerData = m_PeerList.Iterate()))
    {
        // if (pPeerData->GetVersion() < HIWORD(VER_PRODUCTVERSION_DW))
        if (pPeerData->GetVersion() < 0x0404)
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL MBFTEngine::HasSDK(void)
{
        return (m_pMBFTIntf ? TRUE : FALSE);
}


HRESULT MBFTEngine::SafePostMessage
(
    MBFTMsg     *pMsg
)
{
    if (NULL != pMsg)
    {
        AddRef();
		if( 0 == ::PostMessage(g_pFileXferApplet->GetHiddenWnd(), MBFTMSG_BASIC, (WPARAM) pMsg, (LPARAM) this) )
        {
			Release();
			delete pMsg;
            pMsg = NULL;
        }

        return S_OK;
    }
    ERROR_OUT(("MBFTEngine::SafePostMessage: null msg ptr"));
    return E_OUTOFMEMORY;
}


void MBFTEngine::OnPermitToEnrollIndication
(
    GCCAppPermissionToEnrollInd     *pInd
)
{
    T120Error rc;

    TRACEGCC( " Permission to enroll in conference [%d] is %sgranted.\n",
        pInd->nConfID, pInd->fPermissionGranted?"":"not " );

    m_fConfAvailable = pInd->fPermissionGranted;

    if (pInd->fPermissionGranted)
    {
        m_nConfID = pInd->nConfID;

        // build the common part of the join session request for the base session
        ASSERT(m_SessionID == m_MBFTControlChannel);
        ::ZeroMemory(&m_JoinSessionReq, sizeof(m_JoinSessionReq));
        m_JoinSessionReq.dwAttachmentFlags = ATTACHMENT_DISCONNECT_IN_DATA_LOSS;
        m_JoinSessionReq.fConductingCapable = FALSE;
        m_JoinSessionReq.nStartupChannelType = MCS_STATIC_CHANNEL;
        m_JoinSessionReq.cNonCollapsedCaps = sizeof(g_aAppletNonCollCaps) / sizeof(g_aAppletNonCollCaps[0]);
        m_JoinSessionReq.apNonCollapsedCaps = (GCCNonCollCap **) &g_aAppletNonCollCaps[0];
        m_JoinSessionReq.cCollapsedCaps = sizeof(g_aAppletCaps) / sizeof(g_aAppletCaps[0]);
        m_JoinSessionReq.apCollapsedCaps = (GCCAppCap **) &g_aAppletCaps[0];

        // put in the session ID which is the control channel ID
        m_JoinSessionReq.SessionKey = g_AppletSessionKey;
        m_JoinSessionReq.SessionKey.session_id = m_SessionID;
        m_aStaticChannels[0] = m_MBFTControlChannel;

        // at least one static channel to join
        m_JoinSessionReq.aStaticChannels = &m_aStaticChannels[0];

        // build the complete join session request for the base session
        switch (m_eMBFTMode)
        {
        case MBFT_STATIC_MODE:
            ASSERT(m_MBFTControlChannel == _MBFT_CONTROL_CHANNEL);
            ASSERT(m_MBFTDataChannel = _MBFT_DATA_CHANNEL);
            m_aStaticChannels[1] = m_MBFTDataChannel;
            m_JoinSessionReq.cStaticChannels = 2; // control and data channels
            // m_JoinSessionReq.cResourceReqs = 0;
            break;

#ifdef USE_MULTICAST_SESSION
        case MBFT_MULTICAST_MODE:
            m_JoinSessionReq.cStaticChannels = 1; // control channel only
            ::ZeroMemory(&m_aJoinResourceReqs, sizeof(m_aJoinResourceReqs));
            m_aJoinResourceReqs[0].eCommand = APPLET_RETRIEVE_N_JOIN_CHANNEL;
            m_aJoinResourceReqs[0].RegKey.resource_id.length = sizeof(DATA_CHANNEL_RESOURCE_ID) - 1;
            m_aJoinResourceReqs[0].RegKey.resource_id.value = DATA_CHANNEL_RESOURCE_ID;
            m_aJoinResourceReqs[0].RegKey.session_key = m_JoinSessionReq.SessionKey;
            m_JoinSessionReq.cResourceReqs = sizeof(m_aJoinResourceReqs) / sizeof(m_aJoinResourceReqs[0]);
            m_JoinSessionReq.aResourceReqs = &m_aJoinResourceReqs[0];
            break;
#endif

        default:
            ERROR_OUT(("MBFTEngine::OnPermitToEnrollIndication: invalid session type=%u", m_eMBFTMode));
            break;
        }

        // now, create the applet session
        rc = g_pFileXferApplet->CreateAppletSession(&m_pAppletSession, m_nConfID);
        if (T120_NO_ERROR == rc)
        {
            ASSERT(NULL != m_pAppletSession);
            m_pAppletSession->Advise(T120Callback,          // callback function
                                     g_pFileXferApplet,     // applet context
                                     this);                 // session context

            rc = m_pAppletSession->Join(&m_JoinSessionReq);
        }

        if (T120_NO_ERROR != rc)
        {
                        WARNING_OUT(("MBFTEngine::OnPermitToEnrollIndication: CreateAppletSession failed, rc=%u", rc));
            DBG_SAVE_FILE_LINE
            SafePostNotifyMessage(new InitUnInitNotifyMsg(EnumInitFailed));
        }
    } // in conference
    else
    // leaving the conference here
    {                     
        LPMBFTSESSION pSession;
        m_SessionList.Reset();
        while (NULL != (pSession = m_SessionList.Iterate()))
        {
            pSession->UnInitialize( TRUE );
        }

        //Time to say goodbye...
        AddPeerNotification( m_nidMyself, m_uidMyself, TRUE, TRUE, FALSE, MY_APP_STR, m_SessionID );

        //Clear the peer list...                    
        m_PeerList.DeleteAll();                       
                
        //Nuke all sessions except for the first one....
        while (NULL != (pSession = m_SessionList.Get()))
        {
            delete pSession;
        }

        // leave the conference if not done so
        if (NULL != m_pAppletSession)
        {
            m_pAppletSession->Unadvise();

            // LONCHANC: I commented out the following line because we should not
            // leave the conference until we are sure that we can release the interface.
            // There are outstanding send-data-indication messages. If we leave now,
            // we will not be able to free them...
            // m_pAppletSession->Leave();

            // let the core know we left the conference
            DBG_SAVE_FILE_LINE
            SafePostNotifyMessage(new InitUnInitNotifyMsg(EnumInvoluntaryUnInit));
        }

        // we are not in the conference anymore
        m_fJoinedConf = FALSE;

        // release this engine object in the next tick
        ::PostMessage(g_pFileXferApplet->GetHiddenWnd(), MBFTMSG_DELETE_ENGINE, 0, (LPARAM) this);
    }
}


void MBFTEngine::OnJoinSessionConfirm
(
    T120JoinSessionConfirm      *pConfirm
)
{
    if (T120_RESULT_SUCCESSFUL == pConfirm->eResult)
    {
        if (pConfirm->pIAppletSession == m_pAppletSession)
        {
            m_uidMyself = pConfirm->uidMyself;
            m_eidMyself = pConfirm->eidMyself;   
            m_nidMyself = pConfirm->nidMyself;
            ASSERT(m_SessionID == pConfirm->sidMyself);

#ifdef USE_MULTICAST_SESSION
            if (MBFT_MULTICAST_MODE == m_eMBFTMode)
            {
                ASSERT(1 == pConfirm->cResourceReqs);
                ASSERT(0 == m_MBFTDataChannel);
                ASSERT(APPLET_RETRIEVE_N_JOIN_CHANNEL == pConfirm->aResourceResults[0].eCommand);
                m_MBFTDataChannel = pConfirm->aResourceResults[0].nChannelID;
                ASSERT(0 != m_MBFTDataChannel);
            }
#endif

            // we are now officially in the conference
            m_fJoinedConf = TRUE;
        }
        else
        {
            ERROR_OUT(("MBFTEngine::OnJoinSessionConfirm: not my session confirm, pConfirm->pI=0x%x, m_pI=0x%x", pConfirm->pIAppletSession, m_pAppletSession));
        }
    }
    else
    {
        WARNING_OUT(("MBFTEngine::OnJoinSessionConfirm: failed, result=%u", pConfirm->eResult));
        DBG_SAVE_FILE_LINE
        SafePostNotifyMessage(new InitUnInitNotifyMsg(EnumInitFailed));
    }
}


CPeerData::CPeerData
(
    T120NodeID          NodeID,
    T120UserID          MBFTUserID,
    BOOL                bIsLocalNode,
    BOOL                IsProshareNode,
    BOOL                bCanConduct,
    BOOL                bEOFAcknowledgment,
    LPCSTR              lpszAppKey,
    DWORD               dwVersion
)
:
    m_NodeID(NodeID),
    m_MBFTUserID(MBFTUserID),    
    m_bIsLocalNode(bIsLocalNode),
    m_bIsProshareNode(IsProshareNode),
    m_bCanConduct(bCanConduct),
    m_bEOFAcknowledgment(bEOFAcknowledgment),
    m_dwVersion(dwVersion)
{
    if (lpszAppKey)
    {
        ::lstrcpynA(m_szAppKey, lpszAppKey, sizeof(m_szAppKey));
    }
    else
    {
        m_szAppKey[0] = '\0';
    }
}
            

void MBFTEngine::AddPeerNotification
(
    T120NodeID          NodeID,
    T120UserID          MBFTUserID,
    BOOL                IsLocalNode,
    BOOL                IsProshareNode,
    BOOL                bPeerAdded,
    LPCSTR              lpszAppKey,
    T120SessionID       SessionID
)
{
    DBG_SAVE_FILE_LINE
    SafePostNotifyMessage(
        new PeerMsg(NodeID, MBFTUserID, IsLocalNode, IsProshareNode,
                    lpszAppKey, bPeerAdded, SessionID));
}


void MBFTEngine::AddAllPeers(void)
{
        T120NodeID nNodeId;
        CPeerData *pPeerData;

        m_PeerList.Reset();
        while (NULL != (pPeerData = m_PeerList.Iterate()))
        {
                nNodeId = pPeerData->GetNodeID();
                if (nNodeId != m_nidMyself)
                {
                        DBG_SAVE_FILE_LINE
                        SafePostNotifyMessage(new PeerMsg(nNodeId, pPeerData->GetUserID(),
                                                                  FALSE, pPeerData->GetIsProshareNode(), 
                                                                  pPeerData->GetAppKey(), TRUE, m_SessionID));
                }
        }
}


// LONCHANC: NetMeeting's Node Controller does not exercise conductorship.
#ifdef ENABLE_CONDUCTORSHIP
void MBFTEngine::OnConductAssignIndication(GCCConductorAssignInd *pInd)
{
    m_ConductorNodeID           =   pInd->nidConductor;
    m_MBFTConductorID           =   0;
    m_ConductedModePermission   =   0;
    m_bWaitingForPermission     =   FALSE;
    
    if (m_nidMyself == m_ConductorNodeID)
    {
        m_ConductedModePermission |= PrivilegeAssignPDU::EnumFileTransfer; 
        m_ConductedModePermission |= PrivilegeAssignPDU::EnumFileRequest;
        m_ConductedModePermission |= PrivilegeAssignPDU::EnumPriority;
        m_ConductedModePermission |= PrivilegeAssignPDU::EnumPrivateChannel; 
        m_ConductedModePermission |= PrivilegeAssignPDU::EnumAbort;
        m_ConductedModePermission |= PrivilegeAssignPDU::EnumNonStandard;
    }
    else
    {
        CPeerData *lpPeer;
        if (NULL != (lpPeer = m_PeerList.Find(m_ConductorNodeID)))
        {
            if (lpPeer->GetCanConduct())
            {
                //Now that we have found a conductor on the conducting node,
                //our search is over....
                m_MBFTConductorID = lpPeer->GetUserID();
            }
        }                

        //MBFT 8.11.1
        //If there is a change in the conductor, and there is no MBFT conductor at the
        //new conducting node, all transactions must cease....
        //The m_bInConductedMode flag tells us if we were already in the conducted mode.
        if( !m_MBFTConductorID && m_bInConductedMode )
        {
            //Abort all transactions....
            AbortAllSends();
        }
    }

    m_bInConductedMode  =  TRUE;
}                                                                  

void MBFTEngine::OnConductReleaseIndication( GCCConferenceID ConfID )
{
    m_bInConductedMode          =   FALSE;
    m_ConductorNodeID           =   0;
    m_MBFTConductorID           =   0;
    m_ConductedModePermission   =   0;
    m_bWaitingForPermission     =   FALSE;
}

void MBFTEngine::OnConductGrantIndication(GCCConductorPermitGrantInd *pInd)
{
    UINT Index;
    
    for( Index = 0; Index < pInd->Granted.cNodes; Index++ )
    {
        if (pInd->Granted.aNodeIDs[Index] == m_nidMyself)
        {
            if( pInd->fThisNodeIsGranted )
            {
                m_ConductedModePermission |= PrivilegeAssignPDU::EnumFileTransfer; 
                m_ConductedModePermission |= PrivilegeAssignPDU::EnumFileRequest;
                m_ConductedModePermission |= PrivilegeAssignPDU::EnumPriority;
                m_ConductedModePermission |= PrivilegeAssignPDU::EnumPrivateChannel; 
                m_ConductedModePermission |= PrivilegeAssignPDU::EnumAbort;
                m_ConductedModePermission |= PrivilegeAssignPDU::EnumNonStandard;
            }
            else
            {
                //TO DO:    
                //MBFT 8.11.1 and 8.12.1
                //If the MBFT provider receives a GCCConductorPermissionGrantIndication
                //with permission_flag = FALSE, all privileges are revoked and all
                //transactions should be terminated....
                m_ConductedModePermission = 0;
                AbortAllSends();
            }
            break;
        }
    }
}                                                                  

void MBFTEngine::AbortAllSends(void)
{
    if( m_bInConductedMode )
    {
        MBFTSession *pSession;
        m_SessionList.Reset();
        while (NULL != (pSession = m_SessionList.Iterate()))
        {
            if (pSession->GetSessionType() == MBFT_PRIVATE_SEND_TYPE)
            {
                pSession->OnControlNotification(
                    _iMBFT_PROSHARE_ALL_FILES,
                    FileTransferControlMsg::EnumConductorAbortFile,
                    NULL,
                    NULL );
            }
        } 
    }
}
#endif // ENABLE_CONDUCTORSHIP


void MBFTEngine::OnDetachUserIndication
(
    T120UserID          mcsUserID,
    T120Reason          eReason
)
{
    TRACEMCS(" Detach User Indication [%u]\n",mcsUserID);
    
    if (mcsUserID == m_uidMyself)
    {
        m_fJoinedConf = FALSE;
        m_pAppletSession->Unadvise();

        //Time to say goodbye...
        AddPeerNotification(m_nidMyself, m_uidMyself, TRUE, TRUE, FALSE, MY_APP_STR, m_SessionID);
    } 
}


BOOL MBFTEngine::ProcessMessage(MBFTMsg *pMsg)
{
    BOOL bWasHandled = FALSE;
    BOOL bBroadcastFileOfferHack  = FALSE;
    MBFTSession *pSession;

    // lonchanc: it is possible that the channel admit indication comes in
    // before the session is created. in this case, put the message back to the queue.
    if (m_SessionList.IsEmpty())
    {
        if (EnumMCSChannelAdmitIndicationMsg == pMsg->GetMsgType())
        {
            return FALSE; // do not delete the message and put it back to the queue
        }
    }

    m_SessionList.Reset();
    while (!bWasHandled && NULL != (pSession = m_SessionList.Iterate()))
    {
        switch (pMsg->GetMsgType())
        {
        case EnumMCSChannelAdmitIndicationMsg:
            if (pSession->IsReceiveSession())
            {
                MBFTPrivateReceive *pRecvSession = (MBFTPrivateReceive *) pSession;
                MCSChannelAdmitIndicationMsg *p = (MCSChannelAdmitIndicationMsg *) pMsg;
                //We have to make an exception in the case because we get this
                //message before the PrivateChannelInvitePDU() !!!
                bWasHandled = pRecvSession->OnMCSChannelAdmitIndication(p->m_wChannelId, p->m_ManagerID);
                if(bWasHandled)
                {
                    TRACEMCS(" Channel Admit Indication [%u], Manager [%u]\n", p->m_wChannelId, p->m_ManagerID);
                }
            }
            break;

        case EnumMCSChannelExpelIndicationMsg:
            if (pSession->IsReceiveSession())
            {
                MBFTPrivateReceive *pRecvSession = (MBFTPrivateReceive *) pSession;
                MCSChannelExpelIndicationMsg *p = (MCSChannelExpelIndicationMsg *) pMsg;
                bWasHandled = pRecvSession->OnMCSChannelExpelIndication(p->m_wChannelId, p->m_iReason);
                if(bWasHandled)
                {
                    TRACEMCS(" Channel Expel Indication [%u]\n", p->m_wChannelId);
                }
            }
            break;

        case EnumMCSChannelJoinConfirmMsg:
            {
                MCSChannelJoinConfirmMsg *p = (MCSChannelJoinConfirmMsg *) pMsg;
                bWasHandled = pSession->OnMCSChannelJoinConfirm(p->m_wChannelId, p->m_bSuccess);
                if(bWasHandled)
                {
                    TRACEMCS(" Channel Join Confirm [%u], Success = [%d]\n", p->m_wChannelId, p->m_bSuccess);
                }
            }
            break;

        case EnumMCSChannelConveneConfirmMsg:
            if (pSession->IsSendSession())
            {
                MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) pSession;
                MCSChannelConveneConfirmMsg *p = (MCSChannelConveneConfirmMsg *) pMsg;
                bWasHandled = pSendSession->OnMCSChannelConveneConfirm(p->m_wChannelId, p->m_bSuccess);  
                if(bWasHandled)
                {
                    TRACEMCS(" Channel Convene Confirm [%u], Success = [%d]\n", p->m_wChannelId, p->m_bSuccess);
                }
            }
            break;

        case EnumGenericMBFTPDUMsg:
            {
                MBFTPDUMsg *p = (MBFTPDUMsg *) pMsg;
                bWasHandled = DispatchPDUMessage(pSession, p);

                //Background on this hack:
                //In the broadcast mode, we may get a FileOfferPDU followed by a FileStart
                //PDU and may therefore not give the client application sufficient time
                //to process the File Offer. Therefore, we make sure that we stop processing
                //other messages if we get a broadcast FileOffer...
                if(bWasHandled)
                {
                    if (p->m_PDUType == EnumFileOfferPDU)
                    {
                        LPFILEOFFERPDU lpNewFileOfferPDU = (LPFILEOFFERPDU) p->m_lpNewPDU;
                        if(lpNewFileOfferPDU->GetAcknowledge() == 0)
                        {
                            bBroadcastFileOfferHack  = TRUE;
                        }
                    }
                }
            }
            break;

        case EnumPeerDeletedMsg:
            {
                PeerDeletedMsg *p = (PeerDeletedMsg *) pMsg;
                pSession->OnPeerDeletedNotification(p->m_lpPeerData);
            }
            break;

        case EnumSubmitFileSendMsg:
            {
                SubmitFileSendMsg *p = (SubmitFileSendMsg *) pMsg;
                if (p->m_EventHandle == pSession->GetEventHandle())
                {
                    if(pSession->GetSessionType() == MBFT_PRIVATE_SEND_TYPE)
                    {
                        bWasHandled = TRUE;
                        ((MBFTPrivateSend *) pSession)->SubmitFileSendRequest(p);
                    }
                }
            }
            break;

        case EnumFileTransferControlMsg:
            {
                FileTransferControlMsg *p = (FileTransferControlMsg *) pMsg;
                if (p->m_EventHandle == pSession->GetEventHandle())
                {
                    bWasHandled = TRUE;
                    pSession->OnControlNotification(
                                p->m_hFile,
                                p->m_ControlCommand,
                                p->m_szDirectory,
                                p->m_szFileName);
                }                               
            }
            break;

        default:
            ASSERT(0);
            break;
        } // switch

        if(bBroadcastFileOfferHack)
        {
            TRACE("(MBFT:) BroadcastFileOfferHack detected, aborting message processing\n");
            break;  //Out of message for loop
        }
    } //Message for loop

    return TRUE; // delete the message
}



#ifdef ENABLE_CONDUCTORSHIP
BOOL MBFTEngine::ConductedModeOK(void)
{
    BOOL bReturn = TRUE;
        
    if(m_bInConductedMode)
    {
        bReturn  = (m_ConductedModePermission & PrivilegeRequestPDU::EnumFileTransfer) && 
                   (m_ConductedModePermission & PrivilegeRequestPDU::EnumPrivateChannel); 
        
    }
    
    return(bReturn);
}
#endif // ENABLE_CONDUCTORSHIP


BOOL MBFTEngine::HandleSessionCreation(MBFTMsg *pMsg)
{
    switch (pMsg->GetMsgType())
    {
    case EnumCreateSessionMsg:
        {
            CreateSessionMsg *p = (CreateSessionMsg *) pMsg;
            MBFTSession *lpNewSession = NULL;
            MBFTEVENTHANDLE EventHandle = p->m_EventHandle;
            T120SessionID SessionID = p->m_SessionID;
#ifdef ENABLE_CONDUCTORSHIP
            BOOL bDeleteMessage = TRUE;
#endif

            switch (p->m_iSessionType)
            {
            case MBFT_PRIVATE_SEND_TYPE:
                if(m_State == IdleInitialized)
                {
                    if(ConductedModeOK())
                    {
                        TRACESTATE(" Creating new acknowledged send session\n");
                        DBG_SAVE_FILE_LINE
                        lpNewSession = new MBFTPrivateSend(this,EventHandle,
                                                        m_uidMyself,
                                                        m_MBFTMaxSendDataPayload);
                        ASSERT(NULL != lpNewSession);
                    }
#ifdef ENABLE_CONDUCTORSHIP
                    else
                    {
                        bDeleteMessage  = FALSE;
                    }
#endif
                }                                    
                else
                {
                    TRACE(" Invalid attempt to create session before initialization\n");
                }
                break;
                
            case MBFT_PRIVATE_RECV_TYPE:
                if(m_State == IdleInitialized)
                {
                    TRACESTATE(" Creating new acknowledge session\n");
                    DBG_SAVE_FILE_LINE
                    lpNewSession = new MBFTPrivateReceive(this,
                                                          EventHandle,
                                                          p->m_ControlChannel,
                                                          p->m_DataChannel);
                    ASSERT(NULL != lpNewSession);
                }
                else
                {
                    TRACE(" Invalid attempt to create session before initialization\n");
                }
                break;

            case MBFT_BROADCAST_RECV_TYPE:
#ifdef USE_BROADCAST_RECEIVE
                if(m_State == IdleInitialized)
                {
                    TRACESTATE(" Creating new broadcast receive session\n");
                    DBG_SAVE_FILE_LINE
                    lpNewSession = new MBFTBroadcastReceive(this,
                                                            EventHandle,
                                                            p->m_ControlChannel,
                                                            p->m_DataChannel,
                                                            p->m_SenderID,
                                                            p->m_FileHandle);
                    ASSERT(NULL != lpNewSession);
                }
                else
                {
                   TRACE(" Invalid attempt to create session before initialization\n");
                }
#endif    // USE_BROADCAST_RECEIVE
                break;

            default:
                ASSERT(0);
                break;
            } // switch

            if (lpNewSession)
            {
#ifdef ENABLE_HEARTBEAT_TIMER
                if (lpNewSession->IsSendSession())
                {
                    KillTimer(NULL, m_nTimerID);
                    m_nTimerID = ::SetTimer(NULL, 0, SESSION_TIMER_SPEED, HeartBeatTimerProc);
                }
#endif                
                m_SessionList.Append(lpNewSession);
            }
        } // if create session message
        break;

   case EnumDeleteSessionMsg:
        {
            DeleteSessionMsg *p = (DeleteSessionMsg *) pMsg;
#ifdef ENABLE_HEARTBEAT_TIMER
                        if (NULL != p->m_lpDeleteSession)
                        {
                                if (p->m_lpDeleteSession->IsSendSession())
                                {
                                        BOOL fSendSessExists = FALSE;
                                        MBFTSession *pSess;
                                        m_SessionList.Reset();
                                        while (NULL != (pSess = m_SessionList.Iterate()))
                                        {
                                                if (pSess->IsSendSession())
                                                {
                                                        fSendSessExists = TRUE;
                                                        break;
                                                }
                                        }
                                        if (! fSendSessExists)
                                        {
                                                ::KillTimer(NULL, m_nTimerID);
                                                m_nTimerID = ::SetTimer(NULL, 0, IDLE_TIMER_SPEED, HeartBeatTimerProc);
                                        }
                                }
                        }
#endif
            m_SessionList.Delete(p->m_lpDeleteSession);
        } // if delete session message
        break;

    default:
        return FALSE; // not handled
    }

    return TRUE; // handled
}                                


BOOL MBFTEngine::DispatchPDUMessage(MBFTSession *lpMBFTSession,MBFTPDUMsg * lpNewMessage)
{
    T120ChannelID wChannelID   = lpNewMessage->m_wChannelId;
    T120Priority iPriority     = lpNewMessage->m_iPriority;
    T120UserID SenderID        = lpNewMessage->m_SenderID;
        T120NodeID NodeID                  = GetNodeIdByUserID(SenderID);
    BOOL IsUniformSendData = lpNewMessage->m_IsUniformSendData;

    LPGENERICPDU lpNewPDU = lpNewMessage->m_lpNewPDU;
    MBFTPDUType DecodedPDUType = lpNewMessage->m_PDUType;

    BOOL bWasHandled = FALSE;

    ASSERT(NULL != lpNewPDU);
    switch(DecodedPDUType)
    {
    case EnumFileOfferPDU:
        if (lpMBFTSession->IsReceiveSession())
        {
            MBFTPrivateReceive *pRecvSession = (MBFTPrivateReceive *) lpMBFTSession;
            bWasHandled = pRecvSession->OnReceivedFileOfferPDU(wChannelID,
                                                               iPriority,
                                                               SenderID,
                                                                                                                           NodeID,
                                                               (LPFILEOFFERPDU)lpNewPDU,
                                                               IsUniformSendData);
            if(bWasHandled)
            {
                TRACEPDU(" File Offer PDU from [%u]\n",SenderID);
            }
        }
        break;            

    case EnumFileAcceptPDU:
        if (lpMBFTSession->IsSendSession())
        {
            MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
            bWasHandled = pSendSession->OnReceivedFileAcceptPDU(wChannelID,
                                                                iPriority,
                                                                SenderID,
                                                                (LPFILEACCEPTPDU)lpNewPDU,
                                                                IsUniformSendData);
            if(bWasHandled)
            {
                TRACEPDU(" File Accept PDU from [%u]\n",SenderID);
            }
        }
        break;

    case EnumFileRejectPDU:
        if (lpMBFTSession->IsSendSession())
        {
            MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
            bWasHandled = pSendSession->OnReceivedFileRejectPDU(wChannelID,
                                                                iPriority,
                                                                SenderID,
                                                                (LPFILEREJECTPDU)lpNewPDU,
                                                                IsUniformSendData);
            if(bWasHandled)
            {
                TRACEPDU(" File Reject PDU from [%u]\n",SenderID);
            }
        }
        break;

    case EnumFileAbortPDU:
#ifdef ENABLE_CONDUCTORSHIP
        if(m_bInConductedMode)
        {
            LPFILEABORTPDU lpAbortPDU  = (LPFILEABORTPDU)lpNewPDU;
            T120UserID MBFTUserID = lpAbortPDU->GetTransmitterID();

            //MBFT 8.11.2
            //If no MBFTUserID is specified, all providers must stop transmission...

            if(!MBFTUserID)
            {
                AbortAllSends();
                bWasHandled = TRUE;
            }
            else if(MBFTUserID == m_uidMyself)
            {
                //If only MBFTUserID is specified, all transmissions by that
                //MBFT provider must cease....
            
                if(!lpAbortPDU->GetFileHandle() && !lpAbortPDU->GetDataChannelID())
                {
                    AbortAllSends();
                    bWasHandled = TRUE;
                }
                else
                {
                    if (lpMBFTSession->IsSendSession())
                    {
                        MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
                        bWasHandled = pSendSession->OnReceivedFileAbortPDU(
                            wChannelID,
                            iPriority,
                            SenderID,
                            (LPFILEABORTPDU)lpNewPDU,
                            IsUniformSendData);
                    }
                }
            }
            else
            {
                //Message was not meant for us...
                bWasHandled = TRUE;
            }
        }
        else
#endif // ENABLE_CONDUCTORSHIP
        {
            bWasHandled = TRUE;
        }                

        if(bWasHandled)
        {
            TRACEPDU(" File Abort PDU from [%u]\n",SenderID);
        }                                                                
        break;

    case EnumFileStartPDU:
        if (lpMBFTSession->IsReceiveSession())
        {
            MBFTPrivateReceive *pRecvSession = (MBFTPrivateReceive *) lpMBFTSession;
            bWasHandled = pRecvSession->OnReceivedFileStartPDU(wChannelID,
                                                               iPriority,
                                                               SenderID,
                                                               (LPFILESTARTPDU)lpNewPDU,
                                                               IsUniformSendData);                
            if(bWasHandled)
            {
                TRACEPDU(" File Start PDU from [%u]\n",SenderID);
            }
        }
        break;

    case EnumFileDataPDU:
        if (lpMBFTSession->IsReceiveSession())
        {
            MBFTPrivateReceive *pRecvSession = (MBFTPrivateReceive *) lpMBFTSession;
            bWasHandled = pRecvSession->OnReceivedFileDataPDU(wChannelID,
                                                              iPriority,
                                                              SenderID,
                                                              (LPFILEDATAPDU)lpNewPDU,
                                                              IsUniformSendData);                
            if(bWasHandled)
            {
                TRACEPDU(" File Data PDU from [%u]\n",SenderID);
            }
        }
        break;

    case EnumPrivateChannelInvitePDU:
        bWasHandled    =   TRUE;                                                            
        TRACEPDU(" Private Channel Invite PDU from [%u]\n",SenderID);
        break;

    case EnumPrivateChannelResponsePDU:
        if (lpMBFTSession->IsSendSession())
        {
            MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
            bWasHandled = pSendSession->OnReceivedPrivateChannelResponsePDU(wChannelID,
                                                                            iPriority,
                                                                            SenderID,
                                                                            (LPPRIVATECHANNELRESPONSEPDU)lpNewPDU,
                                                                            IsUniformSendData);                
            if(bWasHandled)
            {
                TRACEPDU(" Private Channel Response PDU from [%u]\n",SenderID);
            }                                                                             
        }
        break;

    case EnumNonStandardPDU:
        if (lpMBFTSession->IsSendSession())
        {
            MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
            bWasHandled = pSendSession->OnReceivedNonStandardPDU(wChannelID,
                                                                 iPriority,
                                                                 SenderID,
                                                                 (LPNONSTANDARDPDU)lpNewPDU,
                                                                 IsUniformSendData);                
            if(bWasHandled)
            {
                TRACEPDU(" Non Standard PDU from [%u]\n",SenderID);
            }
        }
        break;

    case EnumFileErrorPDU:
        bWasHandled = lpMBFTSession->OnReceivedFileErrorPDU(wChannelID,
                                                            iPriority,
                                                            SenderID,
                                                            (LPFILEERRORPDU)lpNewPDU,
                                                            IsUniformSendData);                
        if(bWasHandled)
        {
            TRACEPDU(" File Error PDU from [%u]\n",SenderID);
        }
        break;

    case EnumFileRequestPDU:
        bWasHandled = OnReceivedFileRequestPDU(wChannelID,
                                            iPriority,
                                            SenderID,
                                            (LPFILEREQUESTPDU)lpNewPDU,
                                            IsUniformSendData);
        if(bWasHandled)
        {
            TRACEPDU(" File Request PDU from [%u]\n",SenderID);
        }
        break;

    case EnumFileDenyPDU:
        TRACE(" *** WARNING (MBFT): Received File Deny PDU from [%u] *** \n",SenderID);
        bWasHandled = TRUE;
        break;

    case EnumDirectoryRequestPDU:
        bWasHandled = OnReceivedDirectoryRequestPDU(wChannelID,
                                                    iPriority,
                                                    SenderID,
                                                    (LPDIRECTORYREQUESTPDU)lpNewPDU,
                                                    IsUniformSendData);
        if(bWasHandled)
        {
            TRACEPDU(" DirectoryRequest PDU from [%u]\n",SenderID);
        }
        break;

    case EnumDirectoryResponsePDU:
        TRACE(" *** WARNING (MBFT): Received Directory Response PDU from [%u] *** \n",SenderID);
        bWasHandled = TRUE;
        break;

    case EnumPrivilegeAssignPDU:
        bWasHandled = OnReceivedPrivilegeAssignPDU(wChannelID,
                                                   iPriority,
                                                   SenderID,
                                                   (LPPRIVILEGEASSIGNPDU)lpNewPDU,
                                                   IsUniformSendData);
        break;

#if     0        
//Do not delete this code...
//It may become part of the MBFT standard in the future...
    
    case EnumFileEndAcknowledgePDU:
        if (lpMBFTSession->IsSendSession())
        {
            MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
            bWasHandled = pSendSession->OnReceivedFileEndAcknowledgePDU(wChannelID,
                                                                        iPriority,
                                                                        SenderID,
                                                                        (LPFILEENDACKNOWLEDGEPDU)lpNewPDU,
                                                                        IsUniformSendData);
        }
        break;
 
    case EnumChannelLeavePDU:
        if (lpMBFTSession->IsSendSession())
        {
            MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
            bWasHandled = pSendSession->OnReceivedChannelLeavePDU(wChannelID,
                                                                  iPriority,
                                                                  SenderID,
                                                                  (LPCHANNELLEAVEPDU)lpNewPDU,
                                                                  IsUniformSendData);
        }
        break;
//Do not delete this code...
//It may become part of the MBFT standard in the future...
#endif
    
    default:
       TRACE(" *** WARNING (MBFT): Unhandled PDU from [%u] *** \n",SenderID);
       bWasHandled = TRUE; // LONCHANC: this should be false, right? why true?
       break;
    } // switch

    return(bWasHandled);
}

                                
BOOL MBFTEngine::OnReceivedPrivateChannelInvitePDU(T120ChannelID wChannelID,
                                                   T120Priority iPriority,
                                                   T120UserID SenderID,
                                                   LPPRIVATECHANNELINVITEPDU lpNewPDU,
                                                   BOOL IsUniformSendData)
{                                                   
    if(m_State == IdleInitialized)
    {
        DBG_SAVE_FILE_LINE
        MBFTMsg *pMsg = new CreateSessionMsg(MBFT_PRIVATE_RECV_TYPE,
                                             ::GetNewEventHandle(),
                                             0,
                                             lpNewPDU->GetControlChannel(),
                                             lpNewPDU->GetDataChannel());
        if (NULL != pMsg)
        {
            DoStateMachine(pMsg);
            delete pMsg;
        }
    }

    return(TRUE);
}

                                          
BOOL MBFTEngine::OnReceivedFileRequestPDU(T120ChannelID wChannelId,
                                          T120Priority iPriority,
                                          T120UserID SenderID,
                                          LPFILEREQUESTPDU lpNewPDU,
                                          BOOL IsUniformSendData)
{
    BOOL bReturn = FALSE;
    
    DBG_SAVE_FILE_LINE
    LPFILEDENYPDU lpDenyPDU = new FileDenyPDU(lpNewPDU->GetRequestHandle());
    if(lpDenyPDU)
    {
        if(lpDenyPDU->Encode())
        {
            if (SendDataRequest(SenderID, APPLET_HIGH_PRIORITY,
                                (LPBYTE)lpDenyPDU->GetBuffer(),
                                lpDenyPDU->GetBufferLength()))
            {
                bReturn = TRUE;
            }                                                 
        }
    }
    
    return(bReturn);
}

BOOL MBFTEngine::OnReceivedDirectoryRequestPDU(T120ChannelID wChannelId,
                                               T120Priority iPriority,
                                               T120UserID SenderID,
                                               LPDIRECTORYREQUESTPDU lpNewPDU,
                                               BOOL IsUniformSendData)
{
    BOOL bReturn = FALSE;

    DBG_SAVE_FILE_LINE
    LPDIRECTORYRESPONSEPDU lpDirPDU = new DirectoryResponsePDU();
    if(lpDirPDU)
    {
        if(lpDirPDU->Encode())
        {
            if (SendDataRequest(SenderID, APPLET_HIGH_PRIORITY,
                                (LPBYTE)lpDirPDU->GetBuffer(),
                                lpDirPDU->GetBufferLength()))
            {
                bReturn = TRUE;
            }                                                 
        }
    }
    
    return(bReturn);
}
                                        
BOOL MBFTEngine::OnReceivedPrivilegeAssignPDU(T120ChannelID wChannelId,
                                              T120Priority iPriority,
                                              T120UserID SenderID,
                                              LPPRIVILEGEASSIGNPDU lpNewPDU,
                                              BOOL IsUniformSendData)
{
#ifdef ENABLE_CONDUCTORSHIP
    if(m_bInConductedMode)
    {
        m_ConductedModePermission  =  lpNewPDU->GetPrivilegeWord();
    }
#endif

    return(TRUE);
}
                                                                             

#ifdef ENABLE_CONDUCTORSHIP
void MBFTEngine::ApplyForPermission(void)
{
    //m_bWaitingForPermission is set to make sure that we don't keep
    //reapplying for permission until the conductor changes...
    
    if(!m_bWaitingForPermission && m_bInConductedMode)
    {
        //MBFT 8.11.1
        //If there is a MBFT conductor at the conducting node, we send
        //a PrivilegeRequestPDU to the conductor....
        
        if(m_MBFTConductorID)
        {
            DBG_SAVE_FILE_LINE
            PrivilegeRequestPDU * lpNewPDU  =   new PrivilegeRequestPDU(PrivilegeRequestPDU::EnumFileTransfer | 
                                                                        PrivilegeRequestPDU::EnumPrivateChannel | 
                                                                        PrivilegeRequestPDU::EnumNonStandard);
            if(lpNewPDU)
            {
                if(lpNewPDU->Encode())
                {
                    if (SendDataRequest(m_MBFTConductorID, APPLET_HIGH_PRIORITY,
                                        (LPBYTE)lpNewPDU->GetBuffer(),
                                        lpNewPDU->GetBufferLength()))       
                    {
                        m_bWaitingForPermission = TRUE;
                    }
                }
                
                delete  lpNewPDU;
            }
        }
        else
        {
            //MBFT 8.11.2
            //Ask for permission via Node Controller...
        }
    }
}                                        
#endif // ENABLE_CONDUCTORSHIP

        
BOOL MBFTEngine::DoStateMachine(MBFTMsg *pMsg)
{
    BOOL fDeleteThisMessage = TRUE;
    if (m_fConfAvailable)
    {
        BOOL fHandled = (NULL != pMsg) ? HandleSessionCreation(pMsg) : FALSE;

#ifdef ENABLE_CONDUCTORSHIP
        //Logic:    If we are in the conducted mode, we check to see if
        //          we have sufficient privileges. If not, we make
        //          an attempt to secure the requisite privileges....
        if(m_bInConductedMode)
        {
            if(!ConductedModeOK())
            {
                if(!m_bWaitingForPermission)
                {
                    ApplyForPermission();
                }
            }
        }
#endif // ENABLE_CONDUCTORSHIP

        if (NULL != pMsg && ! fHandled)
        {
            fDeleteThisMessage = ProcessMessage(pMsg);
        }

        if (m_State == IdleInitialized && ! m_SessionList.IsEmpty())
        {
            CSessionList SessionListCopy(&m_SessionList);
            MBFTSession *pSession;
            while (NULL != (pSession = SessionListCopy.Get()))
            {
                pSession->DoStateMachine();
            }
        }
    }
    return fDeleteThisMessage;
}


//
//  T120 Callback
//


void MBFTEngine::OnSendDataIndication
(
    BOOL                IsUniformSendData,
    T120UserID          SenderID,
    T120ChannelID       wChannelID,
    T120Priority        iPriority,
    ULONG               ulDataLength,
    LPBYTE              lpBuffer
)
{
    GenericPDU * lpNewPDU   = NULL;
    LPCSTR lpDecodeBuffer   = NULL;        
    BOOL bAddToPendingList  = FALSE;
    
    {
        MBFTPDUType DecodedPDUType = GenericPDU::DecodePDU(
                        (LPSTR) lpBuffer,
                        ulDataLength,
                        &lpNewPDU,
                        &lpDecodeBuffer,
                        m_uidMyself,
                        m_pAppletSession);
        if(DecodedPDUType != EnumUnknownPDU)
        {
            ASSERT (m_pAppletSession != NULL);
            DBG_SAVE_FILE_LINE
            MBFTPDUMsg * lpNewMessage = new MBFTPDUMsg(wChannelID,
                                                       iPriority,
                                                       SenderID, 
                                                       lpNewPDU,               
                                                       IsUniformSendData,
                                                       DecodedPDUType,
                                                       (LPSTR)lpDecodeBuffer);
            
            //Now that we have received a valid PDU, we must make sure that
            //we know about this particular MBFT peer. If not, we add the PDU
            //message to a different list....
            
            if(IsValidPeerID(SenderID)  && m_State == IdleInitialized)
            {
                //If the FileOffer is received on the default Control channel, it
                //cannot be a private subsession send. Therefore, we create a special
                //receive session to handle this case....
#ifdef USE_BROADCAST_RECEIVE
                if(DecodedPDUType == EnumFileOfferPDU && wChannelID == m_MBFTControlChannel)
                {
                    FileOfferPDU * lpFileOffer = (FileOfferPDU *)lpNewPDU;

                    DBG_SAVE_FILE_LINE
                    MBFTMsg *pMsg = new CreateSessionMsg(MBFT_BROADCAST_RECV_TYPE,
                                                         ::GetNewEventHandle(),
                                                         0,
                                                         m_MBFTControlChannel,
                                                         lpFileOffer->GetDataChannelID(),
                                                         SenderID,
                                                         lpFileOffer->GetFileHandle());
                    if (NULL != pMsg)
                    {
                        DoStateMachine(pMsg);
                        delete pMsg;
                    }
                }            
                else
#endif    // USE_BROADCAST_RECEIVE

                if(DecodedPDUType == EnumPrivateChannelInvitePDU && wChannelID == m_uidMyself)
                {
                    //In theory, the PrivateChannelInvitePDU marks the beginning of
                    //a PrivateSubsession receive. Therefore, we create one to handle all subsequent
                    //notifications....
                    
                    OnReceivedPrivateChannelInvitePDU(wChannelID,
                                                      iPriority,
                                                      SenderID,
                                                      (LPPRIVATECHANNELINVITEPDU)lpNewPDU,
                                                      IsUniformSendData);                                
                }            

                SafePostMessage(lpNewMessage);
            }   //  if(IsValidPeerID(SenderID))
            else
            {
                WARNING_OUT((" Received PDU from unknown peer [%u], adding to pending message list\n", (UINT) SenderID));
                delete lpNewMessage;
            }
        }
        else
        {
            TRACE(" PDU Decoding Error or Invalid PDU\n");
            
        }

        // Unless this is one of the special 3 types of PDUs, we also
        // need to free the MCS buffer.  In the 3 special cases, the PDUs
        // are responsible for freeing the buffer when they are done.
        if ((DecodedPDUType != EnumFileDataPDU) &&
            (DecodedPDUType != EnumNonStandardPDU) &&
            (DecodedPDUType != EnumFileStartPDU))
        {
            m_pAppletSession->FreeSendDataBuffer((void *) lpBuffer);
        }
    }
}


void MBFTEngine::OnRosterReportIndication
(
    ULONG               cRosters,
    GCCAppRoster       *aAppRosters[] // array, size_is(cRosters)
)
{
    TRACEGCC(" RosterReport: Session count %u\n", (UINT) cRosters); 

    UINT Index, PeerIndex, CapIndex;
    LPCSTR lpszAppKey = NULL;
    BOOL fConductorFound = FALSE;

    CPeerList NewPeerList;
    CPeerData *pOldPeer;

    if (0 == cRosters) // not bloody likely
    {
        return;
    }

    for (Index = 0; Index < cRosters; Index++ )
    {
        GCCAppRoster *pRoster = aAppRosters[Index];
        if (pRoster->session_key.session_id != m_SessionID)
        {
            // this roster is not for our session...ignore it
            continue;
        }

        //Added by Atul on 7/18 to fix missing roster instance bug...
        m_nRosterInstance = pRoster->instance_number;

        TRACEGCC( " Peer count [%u]\n", (UINT) pRoster->number_of_records );
        
        for (PeerIndex = 0; PeerIndex < pRoster->number_of_records; PeerIndex++)
        {
            GCCAppRecord *pRecord = pRoster->application_record_list[PeerIndex];
            lpszAppKey = NULL;

            TRACE( "Local Entity ID [%u], Entity ID [%u], Node ID [%u], MBFTUser ID [%u]\n",
                   (UINT) m_eidMyself,
                   (UINT) pRecord->entity_id,
                   (UINT) pRecord->node_id,
                   (UINT) pRecord->application_user_id );

            BOOL IsProshareNode = FALSE;
            BOOL bEOFAcknowledgment = FALSE;

            if (0 == Index)
            {
                for (CapIndex=0; CapIndex < pRoster->number_of_capabilities; CapIndex++)
                {
                    GCCAppCap *pCap = pRoster->capabilities_list[CapIndex];
                    if (GCC_STANDARD_CAPABILITY != pCap->capability_id.capability_id_type)
                    {
                        continue;
                    }
                    switch (pCap->capability_id.standard_capability)
                    {
                    case _MBFT_MAX_FILE_SIZE_ID:
                        m_MBFTMaxFileSize = pCap->capability_class.nMinOrMax;
                        TRACEGCC( "max file size set to %u\n", (UINT) m_MBFTMaxFileSize );
                        break;

                    case _MBFT_MAX_DATA_PAYLOAD_ID:
                        m_MBFTMaxDataPayload   =  _iMBFT_DEFAULT_MAX_FILEDATA_PDU_LENGTH;
                        if (pCap->number_of_entities == pRoster->number_of_records)
                        {
                            m_MBFTMaxDataPayload = pCap->capability_class.nMinOrMax;
                        }                            
                        TRACEGCC( "max data payload set to %u\n", (UINT) m_MBFTMaxDataPayload );
                        break;

                    case _MBFT_V42_COMPRESSION_ID:
                        m_bV42CompressionSupported = (BOOL) (pCap->number_of_entities == pRoster->number_of_records);
                        TRACEGCC( "V.42bis compression is now %ssupported\n", m_bV42CompressionSupported ? "" : "not " );
                        break;
                    }
                } // for CapIndex
            } // if 0 == Index

            // TODO: only check for 'ProShare node' if this node is new to us
            for (CapIndex = 0; CapIndex < pRecord->number_of_non_collapsed_caps; CapIndex++)
            {
                GCCNonCollCap *pCap2 = pRecord->non_collapsed_caps_list[CapIndex];
                if (GCC_STANDARD_CAPABILITY == pCap2->capability_id.capability_id_type)
                {
                    if (_iMBFT_FIRST_PROSHARE_CAPABILITY_ID == pCap2->capability_id.standard_capability)
                    {
                        LPSTR pszData = (LPSTR) pCap2->application_data->value;
                        if (pCap2->application_data->length > sizeof(PROSHARE_STRING))
                        {
                            if (0 == ::memcmp(pszData, PROSHARE_STRING, sizeof(PROSHARE_STRING)))
                            {
                                IsProshareNode = TRUE;
                                lpszAppKey     = &pszData[sizeof(PROSHARE_STRING)]; 
                            }
                        }
                    } 
                    else
                    if (_iMBFT_PROSHARE_FILE_EOF_ACK_ID == pCap2->capability_id.standard_capability)
                    {
                        LPSTR pszData = (LPSTR) pCap2->application_data->value;
                        if (pCap2->application_data->length >= sizeof(PROSHARE_FILE_END_STRING) - 1)
                        {
                            if (0 == ::memcmp(pszData, PROSHARE_FILE_END_STRING, sizeof(PROSHARE_FILE_END_STRING) - 1))
                            {
                                bEOFAcknowledgment = TRUE;
                            }
                        }
                    } 
                } // if std cap
            } // for CapIndex
    
            BOOL IsLocalNode = (m_eidMyself == pRecord->entity_id) && (m_nidMyself == pRecord->node_id);
    
            if( ( IdleNotInitialized == m_State )
            &&     IsLocalNode 
            &&     pRecord->is_enrolled_actively )
            {
                m_State                 = IdleInitialized;
                // m_uidMyself             = pRecord->application_user_id;
                m_MBFTControlChannel    = m_SessionID;
            }
            
#ifdef ENABLE_CONDUCTORSHIP
            if( m_bInConductedMode )
            {
                if (pRecord->node_id == m_ConductorNodeID &&
                    pRecord->is_conducting_capable)
                {
                    //Now that we have found a conductor on the conducting node,
                    //our search is over....
                    
                    //Make sure that the previously assigned conductor is still 
                    //present in the roster report...
                    
                    if( m_MBFTConductorID )
                    {
                        if( m_MBFTConductorID == pRecord->application_user_id )
                        {
                            fConductorFound  = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        //First time conductor assignment.....
                        m_MBFTConductorID = pRecord->application_user_id;
                        fConductorFound = TRUE;
                        if(m_ConductorNodeID != m_nidMyself)
                        {
                            m_ConductedModePermission = 0;
                            m_bWaitingForPermission = FALSE;
                        }
                        break;
                    }
                }
            }
#endif // ENABLE_CONDUCTORSHIP
