 (maxk)		;an000;bgb;AN000;
						;				;an000;bgb
										;an000;bgb
										;an000;bgb
;										;an000;bgb
;**************************************************************************	;an000;bgb
; Define Positionals, Switches and Keywords					;an000;bgb
;**************************************************************************	;an000;bgb
;										;an000;bgb
;this is the new control block for both drive letters and filespecs		;an000;bgb
Public	dfControl								;an000;bgb
dfControl	 label	 byte		 ;				 ;AN000;;an000;bgb
	dw	drive_only+FileSpec+Optional		   ;			;an000;bgb	     ;AN000;
	dw	None				;				;an000;bgb;AN000;
	dw	dg:Buffer	       ;			       ;AN000;	;an000;bgb
	dw	dg:No_Value			;				;an000;bgb;AN000;
	db	None				;				;an000;bgb;AN000;
										;an000;bgb
Public	SwControl							   ;an02;an000;bgb0;bgb
SwControl	 label	 byte		 ;				 ;AN020;;an000;bgbbgb
	dw	None				;				;an000;bgb;AN000;
	dw	None				;				;an000;bgb;AN000;
	dw	dg:SwBuffer		 ;				 ;AN000;;an000;bgb
	dw	dg:No_Value							;an000;bgb   ;AN000;
	db	3				;				;an000;bgb;AN020;bgb
sw_v	db	"/V",0                          ;                               ;an000;bgb;AN020;bgb
sw_f	db	"/F",0                          ;                               ;an000;bgb;AN020;bgb
sw_?	db	"/?",0
						;				;an000;bgb
										;an000;bgb
;										;an000;bgb
;*****************************************************************************	;an000;bgb
; Value lists									;an000;bgb
;*****************************************************************************	;an000;bgb
;										;an000;bgb
										;an000;bgb
No_Value	db	0			 ;				;an000;bgb;AN000;
										;an000;bgb
										;an000;bgb
;										;an000;bgb
;************************************************************************	;an000;bgb
; PARSE Return Buffers								;an000;bgb
;************************************************************************	;an000;bgb
;										;an000;bgb
; these buffers were replaced by a single buffer due to the parser bug		;an000;bgb
;Drive_Letter_Buffer	 Drive_Letter_Return	 <>  ;Example of structure	;an000;bgb ;AN000;
;FileSpec_Buffer	 FileSpec_Return	 <>  ;				;an000;bgb
SwBuffer		Switch_Return		<>  ;				;an000;bgb;AN000;
Switch_F_Buffer 	Switch_Return		<>  ;				;an000;bgb;AN000;
buffer			single_return		<>  ; new results buffer	;an000;bgb
data	ends					;				;an000;bgb;AN000;
										;an000;bgb
;										;an000;bgb
;*****************************************************************************	;an000;bgb
; SysParse Routines								;an000;bgb
;*****************************************************************************	;an000;bgb
;										;an000;bgb
										;an000;bgb
										;an000;bgb
code	segment public	para 'CODE'                                             ;an000;bgb
										;an000;bgb
FarSW	equ	Not_Include			;				;an000;bgb;AN000; ;AN000;
DateSW	equ	Not_Include			;				;an000;bgb;AN000;
TimeSW	equ	Not_Include			;				;an000;bgb;AN000;
FileSW	equ	Do_Include			;				;an000;bgb;AN000;
CAPSW	equ	Not_Include			;				;an000;bgb;AN000;
CmpxSW	equ	Not_Include			;				;an000;bgb;AN000;
NumSW	equ	Not_Include			;				;an000;bgb;AN000;
KeySW	equ	Not_Include			;				;an000;bgb;AN000;
SwSW	equ	Do_Include			;				;an000;bgb;AN000;
Val1SW	equ	Not_Include			;				;an000;bgb;AN000;
Val2SW	equ	Not_Include			;				;an000;bgb;AN000;
Val3SW	equ	Not_Include			;				;an000;bgb;AN000;
DrvSW	equ	Do_Include			;				;an000;bgb;AN000;
QusSW	equ	Not_Include			;				;an000;bgb;AN000;
basesw	equ	1 ;use ds as the default register				;an025;bgb
incsw	equ	0 ;include psdata myself					;an028;bgb
code	ends									;an028;bgb


data	segment PUBLIC para 'DATA'                                              ;an028;bgb
include psdata.inc								;an028;bgb
data	ends									;an028;bgb

code	segment PUBLIC para 'CODE'                                              ;an028;bgb
pathlabl parser 								;an028;bgb
INCLUDE PARSE.ASM				;AN000; 			;an028;bgb
pathlabl parser 								;an028;bgb
code	ends									;an000;bgb

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\pathmac.inc ===
;***********************************************************************
; NAME: pathlabl
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; DESC: creates a public label at the spot it is placed, using the name
;       given.
; INPUT: either module name or procedure name
; OUTPUT: public label
; LOGIC: if masm is in pass1 (pass2 will gen dup labels)
;           if this label has not been gen before
;              then create the label
;                   - $$A to place at begin of map
;                   - start means first occurence
;                   - use module/proc name last
;                   define this label for creation of 'stop' label
;              else create stop label
;                   - same as start except name
;***********************************************************************
.LALL
pathlabl MACRO pnam
IF1                                     ;if pass 1
    IFNDEF LBL_&pnam                    ;switch not defined if first creation
        $$A_START_&pnam:                ;create label
        PUBLIC $$A_START_&pnam          ;make it public
        LBL_&pnam = 1                   ;set switch
    ELSE                                ;start label already created
        $$A_STOP_&pnam:                 ;create stop label
        PUBLIC $$A_STOP_&pnam           ;make it public
    ENDIF
ENDIF
ENDM


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkseg.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
PSP	segment public	para 'DUMMY'                                            ;an000;bgb
PSP	ends									;an000;bgb
										;an000;bgb
data	segment public para 'DATA'                                              ;an000;bgb
data	ends									;an000;bgb
										;an000;bgb
CONST	SEGMENT PUBLIC para 'DATA'                                              ;an000;bgb
CONST	ENDS									;an000;bgb
										;an000;bgb
code	segment public para 'CODE'                                              ;an000;bgb
code	ends									;an000;bgb
										;an000;bgb
cstack	 segment para stack 'STACK'                                             ;an000;bgb
cstack	 ends									;an000;bgb
										;an000;bgb
lastseg segment public para 'LAST_S'                                              ;an000;bgb;AN000;bgb
lastseg ends			 ;this is a pointer to the end of the pgm     ;A;an000;bgbN000;bgb
										;an000;bgb;AN000;bgb
DG	GROUP	data,const,code,CSTACK,lastseg					;an000;bgb
assume	cs:dg,ds:dg,ss:dg,es:dg 						;an000;bgb

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkproc2.asm ===
TITLE	CHKPROC2 - PART2 Procedures called from chkdsk
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
page	,132					;

	.xlist
	include chkseg.inc							;an005;bgb
	INCLUDE CHKCHNG.INC
	INCLUDE DOSSYM.INC
	INCLUDE CHKEQU.INC
	INCLUDE CHKMACRO.INC
	include pathmac.inc
	include syscall.inc
	include sysmsg.inc


CONST	SEGMENT PUBLIC PARA  'DATA'
	EXTRN	FIXMES_ARG:word 						;an049;bgb
	EXTRN	FATAL_ARG:word
	EXTRN	BADW_ARG:word,FATAL_END:word,NullMsg:byte
	EXTRN	badrw_num:word,BADRW_STR:WORD,HAVFIX:byte
	EXTRN	DIRTYFAT:byte,CROSSCNT:dword,DOFIX:byte,SECONDPASS:byte
	EXTRN	BADSIZ:word,ORPHSIZ:word,ORPHFCB:byte
	EXTRN	HECODE:byte,USERDIR:byte,FRAGMENT:byte
	EXTRN	ORPHEXT:byte,ALLDRV:byte,FIXMFLG:byte,DIRCHAR:byte
	EXTRN	EOFVAL:word,BADVAL:word
	extrn	fTrunc:BYTE
CONST	ENDS

DATA	SEGMENT PUBLIC PARA 'DATA'
	extrn	fatcnt:byte, orph_arg:word			  ;an005;bgb;an049;bgb
	EXTRN	THISDPB:dword,NUL_ARG:byte
	EXTRN	NAMBUF:byte,SRFCBPT:word,FATMAP:word
	EXTRN	MCLUS:word,CSIZE:byte,SSIZE:word
	EXTRN	DSIZE:word,ARG_BUF:byte,ERRCNT:byte
	EXTRN	USERDEV:byte,HARDCH:dword,CONTCH:dword
	EXTRN	ExitStatus:Byte,Read_Write_Relative:Byte
	extrn	bytes_per_sector:word						;an005;bgb
	extrn	fattbl_seg:word, fatsiz:word,  paras_per_fat:word		;an005;bgb
	extrn	fatmsg1:word							;an024;bgb
	extrn	fatmsg2:word							;an024;bgb
	EXTRN	dbcs_vector:byte						;an055;bgb
	EXTRN	dbcs_vector_off:word						;an055;bgb
	EXTRN	dbcs_vector_seg:word						;an055;bgb
DATA	ENDS

CODE	SEGMENT PUBLIC PARA 'CODE'
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG
	EXTRN	PRINTF_CRLF:NEAR,FCB_TO_ASCZ:NEAR
	EXTRN	PROMPTYN:NEAR,DIRPROC:NEAR
	EXTRN	DOCRLF:NEAR,UNPACK:NEAR,PACK:NEAR
	EXTRN	CHECKNOFMES:NEAR
	EXTRN	multiply_32_bits:near					     ;an047;bgb
	extrn	nowrite:near, done:near, pack:near, unpack:near
	extrn	promptrecover:near, findchain:near
	extrn	sysgetmsg:near

public RECOVER, DoAsk
public MAKORPHNAM, NAM0, NAMMADE
public GETFILSIZ, NCLUS, GOTEOF, CHKCROSS, RET8
public FATAL, hav_fatal_arg,  INT_23, RDONE
public Systime									;an005;bgb
public int_24									;an005;bgb
public CHECK_DBCS_CHARACTER							;an055;bgb
	.list



	pathlabl chkproc2
;*****************************************************************************
; RECOVER -
; free orphans or do chain recovery.  Note that if we have NOT been able to
; process the entire tree (due to inability to CHDIR), we temporarily set
; DoFix to FALSE, do the operation, and then reset it.
;
; inputs:   si - total number of clusters
;	    es - points to fatmap
;
; outputs:  orphaned clusters are converted to files
; LOGIC
;	- display dont fix msg if appropriate
;	- display number of lost clusters
;	- ask the user if he wants the chains converted to files
;***************************************************************************
RECOVER:
    mov     al,1
    xchg    al,[fixmflg]
    or	    al,al
;   $IF     Z				; where there any errors found?
    JNZ $$IF1
	cmp	[dofix],0		; yes - is the /f flag off?
;	$IF	Z			; yes - display the dont fix msg
	JNZ $$IF2
	    mov     dx,offset dg:FIXMES_arg
	    CALL    PRINTf_crlf
	    call    DoCRLF			    ;				    ;AN000;
;	$ENDIF
$$IF2:
;   $ENDIF
$$IF1:
    CALL    DOCRLF
CHAINREPORT:
;;;;mov     si,orphsiz		   ;get number of bad clusters found (recover)	;an005;bgb;an049;bgb
;;;;mov     [orph_num],si	   ; Prints "XXX lost clusters found in YYY chains.";an049;bgb
    call    findchain		   ;   On entry SI is the XXX value and the YYY value is
    mov     dx,offset dg:orph_arg  ;   in orphan-count.
    call    printf_crlf
    TEST    fTrunc,-1
;   $IF     NZ
    JZ $$IF5
	XOR	AX,AX	     ; We have truncated the scan.  Set DoFix to FALSE,
	XCHG	AL,DoFix     ; do the operation and then restore things.
	PUSH	AX
	CALL	PromptRecover
	POP	AX
	MOV	DoFix,AL
DoAsk:
;   $ELSE
    JMP SHORT $$EN5
$$IF5:
	CALL	PromptRecover
;   $ENDIF
$$EN5:
    return








;*****************************************************************************
;*****************************************************************************
MAKORPHNAM:
	PUSH	SI
	MOV	SI,OFFSET DG:ORPHEXT - 1
NAM0:
	INC	BYTE PTR [SI]
	CMP	BYTE PTR [SI],'9'
	JLE	NAMMADE
	MOV	BYTE PTR [SI],'0'
	DEC	SI
	JMP	NAM0

NAMMADE:
	POP	SI
	RET




;*****************************************************************************
; GETFILSIZ - calculate the file size based on the number of clusters.
;
; WARNING!! NOTE!! -->
;
; called by - PROCEDURE NAME
;
; inputs: AX -
;	  BX -
;	  CX -
;	  DX -
;	  SP -
;	  BP -
;	  SI - conatins the starting cluster number
;	  DI -
;	  DS -
;	  ES -
;
; output: AX - low word of the file size
;	  BX -
;	  CX -
;	  DX - hi  word of the file size
;	  SP -
;	  BP -
;	  SI -
;	  DI -
;	  DS -
;	  ES -
;
; Regs abused - none
;
;logic: 1. save bx & cx for 32 bit mul
;
;	2. zero out file size results
;
;	3. do for all clusters:
;
;	   4. get the next one and inc cluster counter
;
;	5. multiply clusters times sectors per cluster to give
;	   number of sectors in file.  This can be a 2 word value - DX:AX.
;
;	6. multiply the sectors times the number of bytes per sector.  This
;	   yields the number of bytes in the file.
;*****************************************************************************
;SI is start cluster, returns filesize as DX:AX
Procedure getfilsiz,near
    savereg <bx,cx>
	XOR	AX,AX			;zero out low word
	XOR	DX,DX			;zero out high word
	OR	SI,SI			;did we get a zero cluster?
;	$if	NZ
	JZ $$IF8
;	    $DO 			;do for all clusters
$$DO9:
NCLUS:		CALL	UNPACK		;find the next cluster
		XCHG	SI,DI		;put output into input for unpack
		INC	AX		;found another cluster
		CMP	SI,[EOFVAL]	;did we find last cluster?
;	    $leave    ae		;yes, so exit loop
	    JAE $$EN9
					;;;;;;;CMP     SI,2
					;;;;;;;JAE     NCLUS
;	    $enddo
	    JMP SHORT $$DO9
$$EN9:
GOTEOF:
	    MOV     BL,[CSIZE]		;get sectors per cluster
	    XOR     BH,BH
	    MUL     BX			;clusters * secs/cluster = sectors
	    mov     bx,dx		;get high num for 32bit mult
	    mov     cx,ssize		;cx = word to mult with
	    call    multiply_32_bits	;mul bx:ax * cx
	    mov     dx,bx		;save high word
;	$endif
$$IF8:
    restorereg <bx,cx>
  return
EndProc getfilsiz



;*****************************************************************************
;*****************************************************************************
Public Chkcross
CHKCROSS:
;Check for Crosslinks, do second pass if any to find pairs
	MOV	SI,word ptr CROSSCNT
	cmp	word ptr crosscnt,0	;if there is at least one crossed
;	$if	nz,or
	JNZ $$LL13
	cmp	word ptr crosscnt+2,0
;	$if	nz
	JZ $$IF13
$$LL13:
	    CALL    DOCRLF		;display another line
	    MOV     SecondPass,True	;	     ;				     ;AC000;
	    XOR     AX,AX		;
	    PUSH    AX
	    PUSH    AX
	    CALL    DIRPROC			    ;Do it again
;	$endif
$$IF13:
RET8:	RET



;*****************************************************************************
;/* M002 BEGIN */
;*****************************************************************************

; BX - arg1 for the fatal error message (rely on fatmsg1 than bx) 
; 	(this is a message no; so get the message from MSGSERVICES)

FATAL:
;Unrecoverable error	

; get the message for the given arg msg no
	mov	ax,bx
	cmp	[fatmsg1],0		; is there an arg ?
	lea	si, NullMsg		
	push	ds
	je 	NoFirstArg
	mov	dh,Utility_Msg_Class
	call	sysgetmsg
NoFirstArg:	
	lea	bx,fatmsg1
	mov	[bx],si			; ptr to message
	mov	[bx+2],ds		;
	pop	ds
;
	lea	si,NullMsg
	push	ds
	cmp	byte ptr [nul_arg],0
	jz	hav_fatal_arg
	mov	ax,fatmsg2
	mov	dh,Utility_Msg_Class
	call	sysgetmsg
hav_fatal_arg:	
	lea	bx,fatmsg2
	mov	[bx],si			; ptr to message
	mov	[bx+2],ds		;
	pop	ds

; go display the message
	mov	dx,offset dg:FATAL_arg
	CALL	PRINTf_crlf
	MOV	DL,[USERDEV]			;At least leave on same drive
	DOS_Call Set_Default_Drive		;

;	mov	ExitStatus,Bad_Exit		;Get return code
;	ret					;Ret Main_Init for common exit

	mov	al,Bad_Exit	
	mov	ah,4ch				; terminate here itself
	int	21h				;

;*****************************************************************************
; /* M002 END */
;*****************************************************************************

INT_24	PROC	FAR
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING
	PUSHF
	test	al,Disk_Error			;Is it a disk critical err?
;	$IF	Z				;Yes
	JNZ $$IF15
	   push    ax
	   mov	   ax,di			;Get error (DI low)		;AN000;
	   cmp	   al,Write_Protect		;Special case errors		;AN000;
;	   $IF	   E,OR 			;If write protect or		;AN000;
	   JE $$LL16
	   cmp	   al,Drive_Not_Ready		; if drive not ready		;AN000;
;	   $IF	   E				;				;AN000;
	   JNE $$IF16
$$LL16:
	      pop     ax
	      CALL    dword ptr HardCh		; let parent's handler decide what to do
;	   $ELSE				;Other error			;AN000;
	   JMP SHORT $$EN16
$$IF16:
	      pop     ax			;balance stack			;AN000;
	      pop     ax			; pop flags
	      mov     al,Critical_Error_Fail	; fail operation
;	   $ENDIF				;				;AN000;
$$EN16:
;	$ELSE					;Not disk error
	JMP SHORT $$EN15
$$IF15:
	   CALL    dword ptr HardCh		; let parent's handler decide what to do
;	$ENDIF
$$EN15:
	CMP	AL,2				;Abort? 			;AC000;
;	$IF	E				;Yes				;AC000;
	JNE $$IF21
	   STI					;Turn off Interrupts
	   CALL    DONE 			;Forget about directory, restore users drive
	   mov	   ExitStatus,Bad_Exit		;Get return code			;AN000;
;	$ENDIF					;AN000;
$$IF21:
	IRET
INT_24	ENDP




;*****************************************************************************
;*****************************************************************************
INT_23	proc	far
	STI
	LDS	DX,[HARDCH]
	mov	al,24h				;				;AC000;
	DOS_Call Set_Interrupt_Vector		;				;AC000;
	LDS	DX,cs:[CONTCH]							;ac039;bgb
	mov	al,23h				;				;AC000;
	DOS_Call Set_Interrupt_Vector		;				;AC000;
	PUSH	CS
	POP	DS
ASSUME	DS:DG
	MOV	[FRAGMENT],0
RDONE:
	CALL	NOWRITE 			;Restore users drive and directory
						;MOV	 AH,EXIT
						;MOV	 AL,0FFH
						;INT	 21H
	mov	ExitStatus,Bad_Exit		;Get return code			;AC000;
	stc
	ret					;Ret for common exit			;AN000;
int_23	endp





;*****************************************************************************
;*****************************************************************************
;
; Systime returns the current date in AX, current time in DX
;   AX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
;   DX - YYYYYYYMMMMDDDDD  years months days
;
public	Systime
Systime:
	DOS_Call Get_Time			;				;AC000;
	SHL	CL,1				;Minutes to left part of byte
	SHL	CL,1
	SHL	CX,1				;Push hours and minutes to left end
	SHL	CX,1
	SHL	CX,1
	SHR	DH,1				;Count every two seconds
	OR	CL,DH				;Combine seconds with hours and minutes
	MOV	DX,CX
	PUSH	DX				; Save time
;
; WARNING!  MONTH and YEAR must be adjacently allocated
;
	DOS_Call Get_Date			;				;AC000;
	SUB	CX, 1980
	MOV	AX, CX
	MOV	CL, 4
	SHL	AL, CL				; Push year to left for month
	OR	AL, DH				; move in month
	MOV	CL,4
	SHL	AX,CL				;Push month to left to make room for day
	SHL	AX,1
	OR	AL, DL
	POP	DX				; Restore time
	XCHG	AX, DX				; Switch time and day
	return


;*****************************************************************************	;an055;bgb
;Routine name: Check_DBCS_CharACter						;an055;bgb
;*****************************************************************************	;an055;bgb
;										;an055;bgb
;Description: Check if specified byte is in rANges of DBCS vectors		;an055;bgb
;										;an055;bgb
;Called Procedures: None							;an055;bgb
;										;an055;bgb
;ChANge History: Created	6/12/87 	MT				;an055;bgb
;										;an055;bgb
;Input: AL = CharACter to check for DBCS lead charACter 			;an055;bgb
;	DBCS_Vector = YES/NO							;an055;bgb
;										;an055;bgb
;Output: CY set if DBCS charACter						;an055;bgb
;	 DBCS_VECTOR = YES							;an055;bgb
;										;an055;bgb
;										;an055;bgb
;Psuedocode									;an055;bgb
;----------									;an055;bgb
;	Save registers								;an055;bgb
;	IF DBCS vector not found						;an055;bgb
;	   Get DBCS environmental vector (INT 21h				;an055;bgb
;	   Point at first set of vectors					;an055;bgb
;	ENDIF									;an055;bgb
;	SEARCH									;an055;bgb
;	LEAVE End of DBCS vectors						;an055;bgb
;	EXITIF CharACter > X1,AND  (X1,Y1) are environment vectors		;an055;bgb
;	EXITIF CharACter < Y1							;an055;bgb
;	  STC (DBCS charACter)							;an055;bgb
;	ORELSE									;an055;bgb
;	   Inc pointer to next set of vectors					;an055;bgb
;	ENDLOOP 								;an055;bgb
;	   CLC (Not DBCS charACter)						;an055;bgb
;	ENDSRCH 								;an055;bgb
;	Restore registers							;an055;bgb
;	ret									;an055;bgb
;*****************************************************************************	;an055;bgb
DBCS_Vector_Size	equ 2							;an055;bgb
end_of_vector		equ 0							;an055;bgb
Procedure	Check_DBCS_Character		      ; 			;an055;bgb
	push	ds				;Save registers 		;an055;bgb
	push	si				; "  "	  "  "			;an055;bgb
	push	ax				; "  "	  "  "			;an055;bgb
;;;;;;;;push	ds				; "  "	  "  "			;an055;bgb
;;;;;;;;pop	es				;Establish addressability	;an055;bgb
	cmp	byte ptr es:DBCS_VECTOR,Yes	;Have we set this yet?		;an055;bgb
;	$IF	NE				;Nope				;an055;bgb
	JE $$IF23
	   push    ax				   ;Save input charACter	   ;an055;bgb
	   mov	   al,0 			;Get DBCS environment vectors	;an055;bgb
	   DOS_Call Hongeul			;  "  "    "  " 		;an055;bgb
	   mov	   byte ptr es:DBCS_VECTOR,YES	;Indicate we've got vector      ;an055;bgb
	   mov	   es:DBCS_Vector_Off,si	;Save the vector		;an055;bgb
	   mov	   ax,ds			;				;an055;bgb
	   mov	   es:DBCS_Vector_Seg,ax	;				;an055;bgb
	   pop	   ax				   ;Restore input charACter	   ;an055;bgb
;	$ENDIF					; for next time in		;an055;bgb
$$IF23:
	mov	si,es:DBCS_Vector_Seg		;Get saved vector pointer	;an055;bgb
	mov	ds,si				;				;an055;bgb
	mov	si,es:DBCS_Vector_Off		;				;an055;bgb
;	$SEARCH 				;Check all the vectors		;an055;bgb
$$DO25:
	   cmp	   word ptr ds:[si],End_Of_Vector ;End of vector table? 	;an055;bgb
;	$LEAVE	E				;Yes, done			;an055;bgb
	JE $$EN25
	   cmp	   al,ds:[si]			;See if char is in vector	;an055;bgb
;	$EXITIF AE,AND				;If >= to lower, ANd		;an055;bgb
	JNAE $$IF25
	   cmp	   al,ds:[si+1] 		; =< thAN higher rANge		;an055;bgb
;	$EXITIF BE				; then DBCS charACter		;an055;bgb
	JNBE $$IF25
	   stc					;Set CY to indicate DBCS	;an055;bgb
;	$ORELSE 				;Not in rANge, check next	;an055;bgb
	JMP SHORT $$SR25
$$IF25:
	   add	   si,DBCS_Vector_Size		;Get next DBCS vector		;an055;bgb
;	$ENDLOOP				;We didn't find DBCS char       ;an055;bgb
	JMP SHORT $$DO25
$$EN25:
	   clc					;Clear CY for exit		;an055;bgb
;	$ENDSRCH				;				;an055;bgb
$$SR25:
	pop	ax				;Restore registers		;an055;bgb
	pop	si				; "  "	  "  "			;an055;bgb
	pop	ds				;Restore data segment		;an055;bgb
	ret					;				;an055;bgb
Check_DBCS_CharACter endp			;				;an055;bgb



	pathlabl chkproc2
CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\comequ.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)comequ.asm 1.1 85/05/14
;	SCCSID = @(#)comequ.asm 1.1 85/05/14
;*************************************
; COMMAND EQUs which are not switch dependant

		include	curdir.inc	; to get DIRSTRLEN
;		Note dossym.inc must already have been included!

GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND

EMGDEBUG = FALSE

SYM		EQU	">"

ifdef JAPAN
LINESPERPAGE	EQU	24
else					; if Not JAPAN
LINESPERPAGE	EQU	25		;AC000; default lines per page
endif
NORMPERLIN	EQU	1
WIDEPERLIN	EQU	5
COMBUFLEN	EQU	128		; Length of commmand buffer
BatLen		EQU	32		; buffer for batch files
YES_ECHO	EQU	1		; echo line
NO_ECHO 	EQU	0		; don't echo line
No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
call_in_progress EQU	1		; indicate we're in the CALL command
length_call	EQU	4		; length of CALL
max_nest	EQU    10		; max # levels of batch nesting allowed
fail_allowed	EQU    00001000b	; critical error
retry_allowed	EQU    00010000b	; critical error
Ignore_allowed	EQU    00100000b	; critical error
nullcommand	EQU    1		; no command on command line
end_of_line	EQU    -1		;AN000; end of line return from parser
end_of_line_out EQU	0		;AN000; end of line for output
end_of_line_in	EQU	0dh		;AN000; end of line for input
result_number	EQU	1		;AN000; number returned from parser
result_string	EQU	3		;AN000; string returned from parser
result_filespec EQU	5		;AN000; filespec returned from parser
result_drive	EQU	6		;AN000; drive returned from parser
result_date	EQU	7		;AN000; date returned from parser
result_time	EQU	8		;AN000; time returned from parser
result_no_error EQU	0		;AN000; no error returned from parser
no_cont_flag	EQU	0		;AN000; no control flags for message
util_msg_class	EQU	-1		;AN000; message class for utility
ext_msg_class	EQU	1		;AN000; message class for extended error
parse_msg_class EQU	2		;AN000; message class for parse error
crit_msg_class	EQU	3		;AN000; message class for critical error
ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
colon_char	EQU	":"             ;AN000; colon character
crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
text_mode	EQU	1		;AN000; text mode return from ioctl
get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
Parm_off_pos	equ	word ptr 2	;AN000; Offset from start of subst list for subst offset
parm_block_size equ	11		;AN000; size of message subst block
blank		equ	" "             ;AN000; blank character
no_subst	equ	0		;AN000; no substitutions for messages
one_subst	equ	1		;AN000; one substitution for messages
no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
res_subst	equ	2		;AN000; offset from start of message definition to number of subst
read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
capital_A	equ	'A'             ;AC000;
vbar		equ	'|'             ;AC000;
labracket	equ	'<'             ;AC000;
rabracket	equ	'>'             ;AC000;
dollar		equ	'$'             ;AC000;
lparen		equ	'('             ;AC000;
rparen		equ	')'             ;AC000;
nullrparen	equ	29h		;AC000;
in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
star		equ	'*'             ;AC000;
plus_chr	equ	'+'             ;AC000;
small_a 	equ	'a'             ;AC000;
small_z 	equ	'z'             ;AC000;
dot_chr 	equ	'.'             ;AC000;
tab_chr 	equ	9		;AN032;
equal_chr	equ	'='             ;AN032;
semicolon	equ	';'             ;AN049;
dot_qmark	equ	2e3fh		;AC000; '.?'
dot_colon	equ	2e3ah		;AC000; '.:'
capital_n	equ	0		;AC000; result from Y/N call if N entered
capital_y	equ	1		;AC000; result from Y/N call if Y entered
AppendInstall	equ	0B700H		;AN020; append install check
AppendDOS	equ	0B702H		;AN020; append DOS version check
AppendGetState	equ	0B706H		;AN020; append get current state
AppendSetState	equ	0B707H		;AN020; append set current state
AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
search_attr	equ	attr_read_only+attr_hidden+attr_directory  ;AC042;

;*************************************
;* PARSE ERROR MESSAGES
;*************************************

MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number

;*************************************
;* EQUATES FOR MESSAGE RETRIEVER
;*************************************

GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever

;*********************************
;* EQUATES FOR INT 10H
;*********************************

VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white

AltPipeChr	equ	"|"             ; alternate pipe character

FCB		EQU	5CH

VARSTRUC	STRUC
ISDIR		DB	?
SIZ		DB	?
TTAIL		DW	?
INFO		DB	?
BUF		DB	DIRSTRLEN + 20 DUP (?)
VARSTRUC	ENDS

;
; Flags for internal command parsing
;
fCheckDrive	equ	00000001b	; validate drive letter
fSwitchAllowed	equ	00000010b	; switches allowed
fLimitHelp	equ	00000100b	; /? must appear alone

;
; Test switches
;
fParse		EQU	0001h		; display results of parseline

;
; Batch segment structure
;
;   BYTE    type of segment
;   BYTE    echo state of parent on entry to batch file
;   WORD    segment of last batch file
;   WORD    segment for FOR command
;   BYTE    FOR flag state on entry to batch file
;   DWORD   offset for next line
;   10 WORD pointers to parameters.  -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;

BatchType   equ 0

BatchSegment	struc
BatType 	DB	BatchType	; signature
Batechoflag	DB	0		; G state of echo
BatchEOF		DB	0	;records if EOF reached on file
Batlast 	DW	0		; G segment of last batch file
Batforptr	DW	0		; G segment for FOR command
Batforflag	DB	0		; G state of FOR
BatSeek 	DD	?		; lseek position of next char
BatParm 	DW	10 dup (?)	; pointers to parameters
BatFile 	DB	?		; beginning of batch file name
BatchSegment	ends

ANULL		equ	0		; terminates an argv string
ARGMAX		equ	64		; max args on a command line
ARGBLEN 	equ	2*128		; 1char each plus term NUL
tplen		equ	64		; max size of one argument
arg_cnt_error	equ	1		; number of args > MAXARG
arg_buf_ovflow	equ	2		; overflowed argbuffer

argv_ele   STRUC			; elements in the argv array
    argpointer	DW	(?)		; pointer to the argstring
    argflags	DB	(?)		; cparse flags for this argstring
    argstartel	DW	(?)		; the result of cparse's [STARTEL]
    arglen	DW	(?)		; cparse's char count + one (for null)
    argsw_word	DW	(?)		; any switches after this?  what kinds?
    arg_ocomptr DW	(?)		; pointer into original command string
argv_ele   ENDS

arg_unit    STRUC
    argv	DB	(ARGMAX * SIZE argv_ele) DUP (?)
    argvcnt	DW	(?)		; number of arguments
    argswinfo	DW	(?)		; Switch information for entire line
    argbuf	DW	ARGBLEN DUP (?) ; storage for argv strings
    argforcombuf db	COMBUFLEN DUP (?) ; Original for loop command string
arg_unit    ENDS

parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1

SwitchQues 	EQU	20h
SwitchV 	EQU	10h
SwitchB 	EQU	08h
SwitchA 	EQU	04h
SwitchP 	EQU	02h
SwitchW 	EQU	01h
fSwitch 	EQU	8000h
fBadSwitch	EQU	4000h

SwitchDir	EQU	SwitchP + SwitchW + fSwitch
SwitchCopy	EQU	SwitchV + SwitchA + SwitchB + fSwitch

break <Trap:  Get the attention of MSDOS>
;   TRAP snares the operating system for a service call
; AX, as well as any other registers MS-DOS takes a fancy to, will be crunched.
trap	MACRO	dos_function,dos_info
    ifnb    <dos_info>
	mov	AX, (dos_function SHL 8) + dos_info
    else
	mov	AX, (dos_function SHL 8)
    endif
	int	21h
ENDM

;
; Equates for initialization
;
initInit	equ	01h		; initialization in progress
initSpecial	equ	02h		; in initialization time/date routine
initCtrlC	equ	04h		; already in ^C handler

;***    BetaWarnXxxx - Expiration Warning for Beta Releases
;
;       Define BETA3WARN, and the first instance of COMMAND.COM will issue
;       a warning message if the current date is on or after the first
;       day of monthBETA3WARN in in yearBETA3WARN.
;
;       Before the product is released, just comment out the line that
;       defines BETA3WARN, and this code will be disabled.
;BETA3WARN  equ     1                    ; Enable beta warning

;*  Beta Warning is displyed on the first day of this month/year
monthBETA3WARN  equ     6               ; Last month before warning
yearBETA3WARN   equ     1993            ; Year for warning


cRES_FAT_ENTRIES EQU	32		; small resident FAT buffer size
cBIG_FAT_ENTRIES EQU	256		; big FAT buffer size in TPA
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\buildmsg.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/* -------------------------------------------------------------------------- */

#include "dos.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "ctype.h"
#include "process.h"
#include "malloc.h"

/* -------------------------------------------------------------------------- */

#define FALSE		(char) (1==0)
#define TRUE		(char) !FALSE
#define NUL		(char) '\0'
#define READONLY	0
#define NAME_COMMAND	"COMMAND\0"     /* Mar 88, SWN */

#define MAXLINE 	200		/* Supposed to be used for getting the message text. */
#define MAXUTILERROR	       300
#define MAXEXTENDEDERROR       100
#define MAXPARSERERROR		20
#define MAXCOMMONERROR	       100
#define MAXLENGTH	       500
#define TOTALUTIL		45

/* -------------------------------------------------------------------------- */

#define ParseOrExtend ((!strnicmp(USEstring,"PARSE\n",5) ) || (!strnicmp(USEstring,"EXTEND\0",5) ) )
#define IsReserved(c)	( (c == '1') || (c == '2') )

/* -------------------------------------------------------------------------- */

	char	*MessageSkeletonFilePtr;


	char	*CommentLinePtr = "\x0d\x0a; ----------------------------------------------------------\x0d\x0a\x0d\x0a";

	char	EofFlags[256];

	char	ClassFlag1;
	char	ClassFlag2;
	int	ClassCount;
	int	ClassCounts[256];
	int	CurrentClass;
	int	CurrentClassIndex;
	int	CurrentMessageNumber;
	int	LineNumber;
	int	add_crlf ;

	int	Pass;

	char	Done;
	char	MessagePending;
	char	ClassPending;

	char	UtilityName[16];
	char	USEstring[16] ;
	char	Is_Utility_Command[16]; /* Mar 88, SWN */
	char	Is_Command_set[] = "12cdeCDE";
	char	CurrentClassFileName[128];

	unsigned	SkeletonHandle = 0xffff;
	unsigned	ClassHandle = 0xffff;
	unsigned	CommonMessageLines;
	unsigned	ParserMessageLines;
	unsigned	ExtendedMessageLines;
	unsigned	UtilMessageLines;
	unsigned	ContinueLine;

	char	CountryIdx[128];
	char	CountryMsg[128];
	char	CountryName[128];

	char	ReadCommonFlag = FALSE;
	char	ReadExtendFlag = FALSE;
	char	ReadParserFlag = FALSE;
	char	ReadUtilFlag   = FALSE;

	char	*ExtendedErrorText999 =  "\"Extended Error %1\"";       /* Mar 88, SWN */
	char	*ParserErrorText999 =  "\"Parse Error %1\"";    /* Mar 88, SWN */

	char	*UtilErrorTexts[MAXUTILERROR+1];
	char	*ExtendedErrorTexts[MAXEXTENDEDERROR+1];
	char	*ParserErrorTexts[MAXPARSERERROR+1];
	char	*CommonErrorTexts[MAXCOMMONERROR+1];

	char	Debugging = FALSE;

/* -------------------------------------------------------------------------- */

void	 error(union REGS *, union REGS *, struct SREGS *);

void	 LineInput( unsigned, char far * );
unsigned DosRead( unsigned, char far *, int );
unsigned DosWrite( unsigned, char far *, int );
long	 DosLSeek( unsigned, long, int );
void	 DosClose( unsigned );
unsigned DosOpen( char far *, unsigned );
unsigned DosCreate( char far *, unsigned );

unsigned LowOf(long);
unsigned HighOf(long);
long	 LongOf(unsigned, unsigned);

void	 main(int, char * []);

void	 ProcessSkeletonFile(char *);
void	 UtilRecord(char *);
void	 ClassRecord(char *);
void	 DefRecord(char *);
void	 UseRecord(char *);
void	 EndRecord(char *);
void	 DefContinue(char *);
void	 UseContinue(char *);
void	 MessageTerminate(void);
void	 ClassTerminate(void);

void	 CommentLine(void);
void	 BlankLine(void);
void	 PublicLine(void);
void	 ReadCommon(void);

char	*MyMalloc(int);

/* -------------------------------------------------------------------------- */

void	main(argc,argv)
int	argc;
char	*argv[];
{

	int		i;
	char		*s;
	unsigned	len;

	char	 far	*PspCharPtr;
	unsigned far	*PspWordPtr;
	unsigned long	ProgramSize;
	unsigned long	MemoryAllocatable;

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	/* check for assistance needed */

	if ( (argc < 3) && (*argv[1] == (char) '?') )
	      {
		printf("BUILDMSG country skeleton-file-spec\n");
		exit(1);
		}

	/* get the 1st parm is the Country name       */
	/* get the skeleton file name (2nd Parm) to be processed */

	strcpy(CountryName, argv[1]);
	strupr(CountryName);
	strcpy(CountryIdx,CountryName);
	strcat(CountryIdx, ".IDX");
	strcpy(CountryMsg,CountryName);
	strcat(CountryMsg, ".MSG");

	for (i = 0; i <= MAXUTILERROR	 ; i++) UtilErrorTexts[i]     = "";
	for (i = 0; i <= MAXEXTENDEDERROR; i++) ExtendedErrorTexts[i] = "";
	for (i = 0; i <= MAXPARSERERROR  ; i++) ParserErrorTexts[i]   = "";
	for (i = 0; i <= MAXCOMMONERROR  ; i++) CommonErrorTexts[i]   = "";

	for (i = 0; i < 256; i++)
	      {
		ClassCounts[i] = 0;
		EofFlags[i] = TRUE;
		}

	if ( (argc > 3) && (strnicmp(argv[3],"/D",2) == 0) ) Debugging = TRUE;

	InRegs.x.ax = 0x6200;
	intdos(&InRegs, &OutRegs);

	printf("BuildMsg - PSP at %04x\n",OutRegs.x.bx);
	FP_SEG(PspWordPtr) = OutRegs.x.bx;
	FP_OFF(PspWordPtr) = 0;
	FP_SEG(PspCharPtr) = OutRegs.x.bx;
	FP_OFF(PspCharPtr) = 0;
	ProgramSize = (unsigned long) *(PspWordPtr+1);
	printf("Program memory size is %ld\n",ProgramSize);

	InRegs.x.ax = 0x4800;
	InRegs.x.bx = 0xffff;
	intdos(&InRegs, &OutRegs);
	if (OutRegs.x.cflag)
	      {
		InRegs.x.bx = OutRegs.x.bx;
		}
	 else {
		SegRegs.es = OutRegs.x.ax;
		InRegs.x.ax = 0x4900;
		intdosx(&InRegs, &OutRegs, &SegRegs);
		}

	MemoryAllocatable = (unsigned long) InRegs.x.bx;
	MemoryAllocatable *= 16;
	printf("Allocatable memory size is %ld\n",MemoryAllocatable);


	ProcessSkeletonFile(argv[2]);

	exit(0);

}

/* -------------------------------------------------------------------------- */

void	ProcessSkeletonFile(FileName)
char	*FileName;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	unsigned	SkeletonHandle;

	char		*s;
	int		i;
	char		out[128];

	char		CurrentRecord[256];
	char		RecordTypeText[32];
	int		LastRecord;
	char		Processed;


	MessageSkeletonFilePtr = FileName;

	printf("Processing [%s]\n",MessageSkeletonFilePtr);

	/* Process the MESSAGE.SKL file */

	SkeletonHandle = DosOpen( (char far *) MessageSkeletonFilePtr, READONLY);

	ClassCount = 0;

	for (Pass = 1; Pass < 3; Pass++)
	      {
		if (Debugging) printf("--> Starting Pass %d <--\n",Pass);
		ClassFlag1 = FALSE;
		ClassFlag2 = FALSE;
		CurrentClassIndex = 0;
		LineNumber = 0;
		CurrentClass = 0;
		Done = FALSE;
		LastRecord = 0;
		MessagePending = FALSE;
		ClassPending = FALSE;

		InRegs.x.ax = 0x4200;
		InRegs.x.bx = SkeletonHandle;
		InRegs.x.cx = 0;
		InRegs.x.dx = 0;
		intdosx(&InRegs,&OutRegs,&SegRegs);
		if (OutRegs.x.cflag)
			error(&InRegs,&OutRegs,&SegRegs);

		while ( (!EofFlags[SkeletonHandle]) && (!Done) )
		      { CurrentRecord[0] = NUL;
			LineInput(SkeletonHandle, (char far *) &CurrentRecord[0] );
			LineNumber++;

			RecordTypeText[0] = NUL;
			sscanf(&CurrentRecord[0]," %s ",&RecordTypeText[0]);
			i = strlen(RecordTypeText);

			strupr(RecordTypeText);

			if (RecordTypeText[0] == (char) ':') Processed = FALSE;
						       else  Processed = TRUE;

			if (strcmp(RecordTypeText,":UTIL")  == 0)
			      { UtilRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 1;
				}

			if (strcmp(RecordTypeText,":CLASS") == 0)
			      { ClassRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 2;
				}

			if (strcmp(RecordTypeText,":DEF")   == 0)
			      { DefRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 3;
				}

			if (strcmp(RecordTypeText,":USE")   == 0)
			      { UseRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 4;
				}

			if (strcmp(RecordTypeText,":END")   == 0)
			      { EndRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 5;
				}

			if (!Processed)
			      { printf("Error: unrecognized record in skeleton file, line %d\n",LineNumber);
				exit(1);
				}

			}

		if (!ClassFlag1) ClassRecord(" 1 ");
		if (!ClassFlag2) ClassRecord(" 2 ");

		if (MessagePending) MessageTerminate();
		if (ClassPending) ClassTerminate();

		if (Debugging) printf("--> Ending   Pass %d <--\n",Pass);
		}

	DosClose(SkeletonHandle);

	sprintf(CurrentClassFileName,"%s.CTL",UtilityName);
	ClassHandle = DosCreate((char far *) &CurrentClassFileName[0], 0);
	i = sprintf(out,"$M_NUM_CLS  EQU %d\x0d\x0a",ClassCount-2);
	DosWrite(ClassHandle,(char far *) &out[0], i);
	DosClose(ClassHandle);

	SkeletonHandle = 0xfffe;  /*  0xfffe == -2  */

	return;

	}

/* -------------------------------------------------------------------------- */

void UtilRecord(Record)
char	*Record;
{

	sscanf(Record," %s ",UtilityName);

	strupr(UtilityName);

	if (Pass == 1)
	      {
		printf(" Utility Name = [%s]\n",UtilityName);
		ReadCommon();

		}

	return;
	}

/* -------------------------------------------------------------------------- */

void	PublicLine()
{

	int	i;
	char	out[128];

	if ( !IsReserved(CurrentClass) ) i = sprintf(out,"        PUBLIC  $M_CLS_%d\x0d\x0a",CurrentClassIndex);
				else i = sprintf(out,"        PUBLIC  $M_MSGSERV_%c\x0d\x0a",CurrentClass);

	DosWrite(ClassHandle,(char far *) &out[0], i);

	return;

	}

/* -------------------------------------------------------------------------- */

void ClassRecord(Record)
char	*Record;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	int	i;
	char	out[128];

	MessageTerminate();
	ClassTerminate();

	while ( isspace(*Record) ) Record++;

	*Record = (char) toupper(*Record);
	CurrentClass = (int) *Record;

	if ( !IsReserved(CurrentClass) ) CurrentClassIndex++;

	if (CurrentClass == '1') ClassFlag1 = TRUE;
	if (CurrentClass == '2') ClassFlag2 = TRUE;

	sprintf(CurrentClassFileName,"%s.%s%c",UtilityName,"CL",CurrentClass);

	if (Pass == 1)
	      {
		ClassHandle = DosCreate((char far *) &CurrentClassFileName[0], 0);

		printf(" Created include file [%s]\n",CurrentClassFileName);

		CommentLine();

		PublicLine();
		i = sprintf(out,"        IF1\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        %%out    ... Including message Class %c\x0d\x0a",CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        ENDIF\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);

		CommentLine();

		i = sprintf(out,"$M_CLASS_%c_STRUC LABEL BYTE\x0d\x0a",CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        $M_CLASS_ID <%03XH,EXPECTED_VERSION,Class_%c_MessageCount>\x0d\x0a",
			   ((!IsReserved(CurrentClass)) ? 255 : (CurrentClass-'0')),CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);

		CommentLine();

		ClassCount++;

		}

	if (Pass == 2)
	      {

		ClassHandle = DosOpen((char far *) &CurrentClassFileName[0], 2);

		InRegs.x.ax = 0x4202;
		InRegs.x.bx = ClassHandle;
		InRegs.x.cx = 0;
		InRegs.x.dx = 0;
		intdosx(&InRegs,&OutRegs,&SegRegs);
		if (OutRegs.x.cflag)
			error(&InRegs,&OutRegs,&SegRegs);

		}

	ClassPending = TRUE;

	return;
	}

/* -------------------------------------------------------------------------- */

void	CommentLine()
{

	DosWrite(ClassHandle,(char far *) CommentLinePtr, strlen(CommentLinePtr) );

	return;

	}

/* -------------------------------------------------------------------------- */

void	BlankLine()
{

	DosWrite(ClassHandle,(char far *) "\x0d\x0a", 2 );

	return;

	}

/* -------------------------------------------------------------------------- */

void DefRecord(Record)
char	*Record;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	int	i,m;
	char	*TextPtr;
	char	*NumberPtr;
	char	out[128];
	char	ActualMsg[256];
	int	MsgNumber;

	char	MsgStatus;
	char	MsgLevel[5];

	char	*LfPtr;

	if ( IsReserved(CurrentClass) )
	      { printf("Error: :DEF not allowed in Class 1 or Class2, line %d\n",LineNumber);
		exit(1);
		}

	MessageTerminate();

	TextPtr = Record;
	while ( (isspace(*TextPtr)) && (*TextPtr != NUL) ) TextPtr++;
	NumberPtr = TextPtr;
	while ( (!isspace(*TextPtr)) && (*TextPtr != NUL) ) TextPtr++;

	sscanf(NumberPtr," %d ",&CurrentMessageNumber);

	if (Pass == 1)
	      {
		BlankLine();

		i = sprintf(out,"$M_%c_%05XH_STRUC LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
	/*	i = sprintf(out,"        $M_ID   <%05XH,0,$M_%c_%05XH_MSG-$M_%c_%05XH_STRUC>\x0d\x0a",  */
		i = sprintf(out,"        $M_ID   <%05XH,$M_%c_%05XH_MSG-$M_%c_%05XH_STRUC>\x0d\x0a",    /* Mar 88, SWN */
				CurrentMessageNumber,CurrentClass,CurrentMessageNumber,CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		}

	if (Pass == 2)
	      {
		BlankLine();
		while ( (*TextPtr != NUL) && (isspace(*TextPtr)) ) TextPtr++;

		i = sprintf(out,"$M_%c_%05XH_MSG LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
	/*	i = sprintf(out,"        DW      $M_%c_%05XH_END-$M_%c_%05XH_MSG-2\x0d\x0a",     */
		i = sprintf(out,"        DB      $M_%c_%05XH_END-$M_%c_%05XH_MSG-1\x0d\x0a",    /* Mar 88, SWN */
				CurrentClass,CurrentMessageNumber,CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);

		for ( m=1; m <= UtilMessageLines; m++)
		      {
			sscanf(UtilErrorTexts[m], " %d %s %s ",&MsgNumber,&MsgStatus,&MsgLevel[0]);
			LfPtr = strchr(UtilErrorTexts[m], ' ');
			LfPtr = strchr(LfPtr+1, ' ');
			LfPtr = strchr(LfPtr+1, ' ');
			strcpy(ActualMsg, LfPtr+1 );
			if ( MsgNumber == CurrentMessageNumber)
			      {
				if (Debugging) printf("DefRecord() :: MsgNumber = %d, CurrentMessageNumber = %d\n",
						       MsgNumber,CurrentMessageNumber);
				i = sprintf(out,"        DB      %s\x0d\x0a",ActualMsg);
				DosWrite(ClassHandle,(char far *) &out[0], i);
				ContinueLine = m + 1;
				}
			}

		MessagePending = TRUE;
	      }


	return;
	}

/* -------------------------------------------------------------------------- */

void UseRecord(Record)
char	*Record;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	int	i,j;
	char	*TextPtr;
	char	*NumberPtr;
	int	TempNumber;
	char	out[128];

	MessageTerminate();

	NumberPtr = Record;
	while ( (isspace(*NumberPtr)) && (*NumberPtr != NUL) ) NumberPtr++;

	if ( (isdigit(*NumberPtr)) || ( (*NumberPtr == (char) '-') && (isdigit(*(NumberPtr+1))) ) )
	      { if ( IsReserved(CurrentClass) )
		      { printf("Error: :USE in CLASS 1, cannot specify a msg-number on line %d\n",LineNumber);
			exit(1);
			}

		sscanf(NumberPtr," %d ",&CurrentMessageNumber);

		TextPtr = NumberPtr;
		while ( (!isspace(*TextPtr)) && (*TextPtr != NUL) ) TextPtr++;
		while ( ( isspace(*TextPtr)) && (*TextPtr != NUL) ) TextPtr++;

		strcpy(USEstring, "empty\0");

		if (strnicmp(TextPtr,"PARSE",5) == 0)  { strcpy(USEstring, "PARSE\0");  i = 5; j = 1; }
		if (strnicmp(TextPtr,"COMMON",6) == 0) { i = 6; j = 2; }
		if (strnicmp(TextPtr,"EXTEND",6) == 0) { strcpy(USEstring, "EXTEND\0"); i = 6; j = 3; }

		NumberPtr = TextPtr + i;
		sscanf(NumberPtr," %d ",&TempNumber);

		switch(j)
		      {
			case 1: if (TempNumber <= MAXPARSERERROR)
					TextPtr = ParserErrorTexts[TempNumber];
				   else if (TempNumber == 999)
					      { TextPtr = ParserErrorText999;
						}
					   else TextPtr = "";
				break;
			case 2: if (TempNumber <= MAXCOMMONERROR)
					TextPtr = CommonErrorTexts[TempNumber];
				   else TextPtr = "";
				break;
			case 3: if (TempNumber <= MAXEXTENDEDERROR)
					TextPtr = ExtendedErrorTexts[TempNumber];
				   else if (TempNumber == 999)
					      { TextPtr = ExtendedErrorText999;
						}
					   else TextPtr = "";
				break;

			default:TextPtr = "";
				break;
			}

		if (*TextPtr == NUL)
		      { printf("Error: :USE of PARSE, COMMON or EXTENDED with invalid msg-number, line %d\n",LineNumber);
			if (Debugging) printf("then ->CurrentMessageNumber = %d, TempNumber = %d, j = %d\n",
					       CurrentMessageNumber,TempNumber,j);
			exit(1);
			}

		}

	 else {

		strcpy(USEstring, "empty\0");

		TextPtr = NumberPtr;
		if (strnicmp(TextPtr,"PARSE",5) == 0)  { strcpy(USEstring, "PARSE\0"); i = 5; j = 1; }
		if (strnicmp(TextPtr,"COMMON",6) == 0) { i = 6; j = 2; }
		if (strnicmp(TextPtr,"EXTEND",6) == 0) { strcpy(USEstring, "PARSE\0"); i = 6; j = 3; }

		NumberPtr += i;
		sscanf(NumberPtr," %d ",&CurrentMessageNumber);

		TempNumber = CurrentMessageNumber;

		if ( (CurrentClass == '1') && (j != 3) )
		      { printf("Error: :USE in CLASS 1 must be EXTENDED ERROR on line %d\n",LineNumber);
			exit(1);
			}

		if ( (CurrentClass == '2') && (j != 1) )
		      { printf("Error: :USE in CLASS 1 must be PARSE ERROR on line %d\n",LineNumber);
			exit(1);
			}

		switch(j)
		      {
			case 1: if (TempNumber <= MAXPARSERERROR)
					TextPtr = ParserErrorTexts[TempNumber];
				   else if (TempNumber == 999)
						TextPtr = ParserErrorText999;
					   else TextPtr = "";
				break;
			case 2: if (TempNumber <= MAXCOMMONERROR)
					TextPtr = CommonErrorTexts[TempNumber];
				   else TextPtr = "";
				break;
			case 3: if (TempNumber <= MAXEXTENDEDERROR)
					TextPtr = ExtendedErrorTexts[TempNumber];
				   else if (TempNumber == 999)
						TextPtr = ExtendedErrorText999;
					   else TextPtr = "";
				break;

			default:TextPtr = "";
				break;
			}

		if (*TextPtr == NUL)
		      { printf("Error: :USE of PARSE, COMMON or EXTENDED with invalid msg-number, line %d\n",LineNumber);
			if (Debugging) printf("else ->CurrentMessageNumber = %d, TempNumber = %d, j = %d\n",
					      CurrentMessageNumber,TempNumber,j);
			exit(1);
			}

		}

	if (Pass == 1)
	      {
		BlankLine();

		i = sprintf(out,"$M_%c_%05XH_STRUC LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
	/*	i = sprintf(out,"        $M_ID   <%05XH,0,$M_%c_%05XH_MSG-$M_%c_%05XH_STRUC>\x0d\x0a",   */
		i = sprintf(out,"        $M_ID   <%05XH,$M_%c_%05XH_MSG-$M_%c_%05XH_STRUC>\x0d\x0a",    /* Mar 88, SWN */
				CurrentMessageNumber,CurrentClass,CurrentMessageNumber,CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		}

	if (Pass == 2)
	  {
	  strcpy( Is_Utility_Command, NAME_COMMAND ) ;
	  if ( !ParseOrExtend )
	    {
	    add_crlf = 0 ;
	    }
	  else
	    {
	    if ( !strnicmp( Is_Utility_Command, UtilityName, 5) )
	      {
	      if ( ( CurrentClass != 67 ) && ( CurrentClass != 68 ) &&
		   ( CurrentClass != 69 ) && ( CurrentClass != '1') &&
		   ( CurrentClass != '2') )
		{
		add_crlf = 1 ;
		}
	      else
		{
		add_crlf = 0 ;
		}

	      }
	    else
	      {
	      if ( ( CurrentClass != '1') && ( CurrentClass != '2') )
		{
		add_crlf = 1 ;
		}
	      else
		{
		add_crlf = 0 ;
		}

	      }
	    }

	  BlankLine();

	  i = sprintf(out,"$M_%c_%05XH_MSG LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
	  DosWrite(ClassHandle,(char far *) &out[0], i);
  /*	  i = sprintf(out,"        DW      $M_%c_%05XH_END-$M_%c_%05XH_MSG-2\x0d\x0a",     */
	  i = sprintf(out,"        DB      $M_%c_%05XH_END-$M_%c_%05XH_MSG-1\x0d\x0a",    /* Mar 88, SWN */
			  CurrentClass,CurrentMessageNumber,CurrentClass,CurrentMessageNumber);
	  DosWrite(ClassHandle,(char far *) &out[0], i);
	  if ( add_crlf )
	    {
	    i = sprintf(out,"        DB      %s,CR,LF\x0d\x0a",TextPtr);
	    }
	  else
	    {
	    i = sprintf(out,"        DB      %s\x0d\x0a",TextPtr);
	    }
	  DosWrite(ClassHandle,(char far *) &out[0], i);

	  MessagePending = TRUE;
	  }

	return;
	}

/* -------------------------------------------------------------------------- */

void DefContinue(Record)
char	*Record;
{

	printf("Error: :DEF continue should not occur",LineNumber);
	exit(1);

	return;

}

/* -------------------------------------------------------------------------- */

void UseContinue(Record)
char	*Record;
{

	printf("Error: :USE continue should not occur",LineNumber);
	exit(1);

	}

/* -------------------------------------------------------------------------- */

void EndRecord(Record)
char	*Record;
{

	if (!ClassFlag1) ClassRecord(" 1 ");
	if (!ClassFlag2) ClassRecord(" 2 ");

	MessageTerminate();
	ClassTerminate();

	Done = TRUE;

	return;
	}

/* -------------------------------------------------------------------------- */

void MessageTerminate()
{

	char	out[128];

	if (MessagePending)
	      {
		sprintf(out,"$M_%c_%05XH_END LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0],strlen(out) );
	 /*	sprintf(out,"        DB        \"$\"\x0d\x0a");      */
		sprintf(out,"  \0",CurrentClass,CurrentMessageNumber);  /* Mar 88, SWN */
		DosWrite(ClassHandle,(char far *) &out[0],strlen(out) );

		ClassCounts[CurrentClass]++;
		}

	MessagePending = FALSE;

	return;
	}

/* -------------------------------------------------------------------------- */

void ClassTerminate()
{

	int	i;
	char	out[128];

	if ( (ClassPending) && (Pass == 1) )
	      { CommentLine();

		if (CurrentClass == '1')
		      { i = sprintf(out,"$M_1_FF_STRUC LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        $M_ID <0FFFFH,0,$M_1_FF_MSG-$M_1_FF_STRUC>\x0d\x0a");  */
			i = sprintf(out,"        $M_ID <0FFFFH,$M_1_FF_MSG-$M_1_FF_STRUC>\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
			ClassCounts[CurrentClass] ++;
			CommentLine();
			}

		if (CurrentClass == '2')
		      { i = sprintf(out,"$M_2_FF_STRUC LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        $M_ID <0FFFFH,0,$M_2_FF_MSG-$M_2_FF_STRUC>\x0d\x0a");  */
			i = sprintf(out,"        $M_ID <0FFFFH,$M_2_FF_MSG-$M_2_FF_STRUC>\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
			ClassCounts[CurrentClass] ++;
			CommentLine();
			}


		DosClose(ClassHandle);
		ClassHandle = 0xfffe;	 /* 0xfffe  ==	-2  */
		}

	if ( (ClassPending) && (Pass == 2) )
	      { CommentLine();

		if (CurrentClass == '1')
		      { i = sprintf(out,"$M_1_FF_MSG LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        DW      $M_1_FF_END-$M_1_FF_MSG-2\x0d\x0a");   */
			i = sprintf(out,"        DB      $M_1_FF_END-$M_1_FF_MSG-1\x0d\x0a");   /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			i = sprintf(out,"        DB      \"Extended Error %%1\"\x0d\x0a");      /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			i = sprintf(out,"$M_1_FF_END LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        DB      \"$\"\x0d\x0a");       */
			i = sprintf(out,"  \0");        /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			CommentLine();
			}

		if (CurrentClass == '2')
		      { i = sprintf(out,"$M_2_FF_MSG LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        DW      $M_2_FF_END-$M_2_FF_MSG-2\x0d\x0a");   */
			i = sprintf(out,"        DB      $M_2_FF_END-$M_2_FF_MSG-1\x0d\x0a");   /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			i = sprintf(out,"        DB      \"Parse Error %%1\"\x0d\x0a"); /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			i = sprintf(out,"$M_2_FF_END LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        DB      \"$\"\x0d\x0a");       */
			i = sprintf(out,"  \0");        /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			CommentLine();
			}

		i = sprintf(out,"Class_%c_MessageCount EQU     %d\x0d\x0a",CurrentClass,ClassCounts[CurrentClass]);
		DosWrite(ClassHandle,(char far *) &out[0], i );

		CommentLine();

		i = sprintf(out,"        IF      FARmsg\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		if ( !IsReserved(CurrentClass) )
		      { i = sprintf(out,"$M_CLS_%d PROC FAR\x0d\x0a",CurrentClassIndex);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		 else { i = sprintf(out,"$M_MSGSERV_%c PROC FAR\x0d\x0a",CurrentClass);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		i = sprintf(out,"        ELSE\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		if ( !IsReserved(CurrentClass) )
		      { i = sprintf(out,"$M_CLS_%d PROC NEAR\x0d\x0a",CurrentClassIndex);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		 else { i = sprintf(out,"$M_MSGSERV_%c PROC NEAR\x0d\x0a",CurrentClass);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		i = sprintf(out,"        ENDIF\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		BlankLine();
		i = sprintf(out,"        PUSH    CS\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        POP     ES\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        LEA     DI,$M_CLASS_%c_STRUC\x0d\x0a",CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        ADD     CX,$-$M_CLASS_%c_STRUC\x0d\x0a",CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        RET\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		BlankLine();
		if ( !IsReserved(CurrentClass) )
		      { i = sprintf(out,"$M_CLS_%d ENDP\x0d\x0a",CurrentClassIndex);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		 else { i = sprintf(out,"$M_MSGSERV_%c Endp\x0d\x0a",CurrentClass);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}

		CommentLine();

		DosClose(ClassHandle);
		ClassHandle = 0xfffe;	   /* 0xfffe == -2   */

		printf(" Completed [%s]\n",CurrentClassFileName);

		}

	ClassPending = FALSE;

	return;
	}

/* -------------------------------------------------------------------------- */

unsigned LowOf(LongValue)
long LongValue;
{

	return ( (unsigned) ( LongValue & 0x0000FFFFl ) );

	}

/* -------------------------------------------------------------------------- */

unsigned HighOf(LongValue)
long LongValue;
{

	return ( (unsigned) ( (LongValue & 0xFFFF0000l) >> 16 ) );

	}

/* -------------------------------------------------------------------------- */

long	 LongOf(HighValue,LowValue)
unsigned HighValue;
unsigned LowValue;
{

	long	hv;
	long	lv;

	hv = (long) HighValue;
	lv = (long) LowValue;

	return ( ( hv << 16 ) + lv );

	}

/* -------------------------------------------------------------------------- */

unsigned DosOpen(FileNamePtr,OpenType)
char far *FileNamePtr;
unsigned OpenType;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x3d00 + OpenType;
	InRegs.x.dx = FP_OFF(FileNamePtr);
	SegRegs.ds = FP_SEG(FileNamePtr);
	intdosx(&InRegs, &OutRegs, &SegRegs);
	if (OutRegs.x.cflag)
		error(&InRegs,&OutRegs,&SegRegs);

	EofFlags[OutRegs.x.ax] = FALSE;
	return(OutRegs.x.ax);

	}

/* -------------------------------------------------------------------------- */

long	 DosLSeek(Handle, ToPosition, Relative)
unsigned Handle;
long	 ToPosition;
int	 Relative;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x4200 + (Relative & 0x000f);
	InRegs.x.bx = Handle;
	InRegs.x.cx = HighOf(ToPosition);
	InRegs.x.dx = LowOf(ToPosition);
	intdosx(&InRegs, &OutRegs, &SegRegs);

	if (OutRegs.x.cflag)
		error(&InRegs,&OutRegs,&SegRegs);

	return( LongOf(OutRegs.x.dx,OutRegs.x.ax) );

	}

/* -------------------------------------------------------------------------- */

unsigned DosCreate(FileNamePtr,Attributes)
char far *FileNamePtr;
unsigned Attributes;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x3c00;
	InRegs.x.cx = Attributes;
	InRegs.x.dx = FP_OFF(FileNamePtr);
	SegRegs.ds = FP_SEG(FileNamePtr);
	intdosx(&InRegs, &OutRegs, &SegRegs);
	if (OutRegs.x.cflag)
		error(&InRegs,&OutRegs,&SegRegs);

	EofFlags[OutRegs.x.ax] = FALSE;
	return(OutRegs.x.ax);

	}

/* -------------------------------------------------------------------------- */

void	 DosClose(Handle)
unsigned Handle;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x3e00;
	InRegs.x.bx = Handle;
	intdosx(&InRegs,&OutRegs,&SegRegs);
	if (OutRegs.x.cflag) error(&InRegs,&OutRegs,&SegRegs);

	return;

	}

/* -------------------------------------------------------------------------- */

unsigned DosRead(Handle,BufferPtr,ReadLength)
unsigned Handle;
char far *BufferPtr;
int	 ReadLength;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x3f00;
	InRegs.x.bx = Handle;
	InRegs.x.cx = ReadLength;
	InRegs.x.dx = FP_OFF(BufferPtr);
	SegRegs.ds = FP_SEG(BufferPtr);
	intdosx(&InRegs,&OutRegs,&SegRegs);
	if (OutRegs.x.cflag) error(&InRegs,&OutRegs,&SegRegs);

	return(OutRegs.x.ax);

	}

/* -------------------------------------------------------------------------- */

unsigned DosWrite(Handle,BufferPtr,WriteLength)
unsigned Handle;
char far *BufferPtr;
int	 WriteLength;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	union	REGS	InRegs2;
	union	REGS	OutRegs2;
	struct	SREGS	SegRegs2;

	InRegs.x.ax = 0x4000;
	InRegs.x.bx = Handle;
	InRegs.x.cx = WriteLength;
	InRegs.x.dx = FP_OFF(BufferPtr);
	SegRegs.ds = FP_SEG(BufferPtr);
	intdosx(&InRegs,&OutRegs,&SegRegs);
	if (OutRegs.x.cflag)
	      { InRegs2.x.ax = 0x4000;
		InRegs2.x.bx = 1;
		InRegs2.x.cx = WriteLength;
		InRegs2.x.dx = FP_OFF(BufferPtr);
		SegRegs2.ds = FP_SEG(BufferPtr);
	  /*	intdosx(&InRegs2,&OutRegs2,&SegRegs2);	*/
		error(&InRegs,&OutRegs,&SegRegs);
		}

	return(OutRegs.x.ax);

	}

/* -------------------------------------------------------------------------- */

void	 LineInput(Handle,BufferPtr)
unsigned Handle;
char far *BufferPtr;
{
	char		c;
	char far	*BufferPosition;

	BufferPosition = BufferPtr;
	*BufferPosition = NUL;

	if (DosRead( Handle, (char far *) &c, 1) != 1)
		EofFlags[Handle] = TRUE;

	while ( (c != (char) '\x0a') && !EofFlags[Handle])
	      {
		*BufferPosition = c;
		if (c == (char) '\x0d') *BufferPosition = NUL;
		BufferPosition++;

		if (DosRead( Handle, (char far *) &c, 1) != 1)
			EofFlags[Handle] = TRUE;

		}

	*BufferPosition = NUL;

	return;
}

/*----------------------------------------------------------------------------*/

void	error(InRegs,OutRegs,SegRegs)
union	REGS	*InRegs;
union	REGS	*OutRegs;
struct	SREGS	*SegRegs;
{

	char	far	*s;
	char		*t;
	char	AsciizString[256];

	struct	DOSERROR ErrorInformation;

	dosexterr(&ErrorInformation);

	printf("\n Function %02X, Error %d, Class %d, Action %d, Locus %d \n",
		InRegs->h.ah,
		ErrorInformation.exterror,ErrorInformation.class,
		ErrorInformation.action,ErrorInformation.locus);

	printf("  InRegs:\n");
	printf("  AX:%04X BX:%04X CX:%04X DX:%04X SI:%04X DI:%04X DS:%04X ES:%04X\n",
		InRegs->x.ax,InRegs->x.bx,InRegs->x.cx,InRegs->x.dx,InRegs->x.si,InRegs->x.di,
		SegRegs->ds,SegRegs->es);

	switch(InRegs->h.ah)
	      {
		case 0x3d:
		case 0x3c:
		case 0x4e:
			FP_SEG(s) = SegRegs->ds;
			FP_OFF(s) = InRegs->x.dx;
			t = &AsciizString[0];
			while (*s != (char) '\0') *t++ = *s++;
			*t++ = (char) '\0';
			printf("  DS:DX -> [%s]\n",AsciizString);
			break;
		}

	printf("  OutRegs:\n");
	printf("  AX:%04X BX:%04X CX:%04X DX:%04X SI:%04X DI:%04X DS:%04X ES:%04X\n",
		OutRegs->x.ax,OutRegs->x.bx,OutRegs->x.cx,OutRegs->x.dx,OutRegs->x.si,OutRegs->x.di,
		SegRegs->ds,SegRegs->es);



	exit(1);

	}


/* -------------------------------------------------------------------------- */

char * MyMalloc(Length)
int	Length;
{
	char	*Ptr;

	Ptr = malloc(Length);

	if (Ptr == (char *) 0)
	      { printf("ERROR: insufficient memory available, line %d\n",LineNumber);
		exit(1);
		}

	return (Ptr);
	}


/* -------------------------------------------------------------------------- */

	unsigned	IdxHandle;
	unsigned	MsgHandle;

void ReadCommon()
{


	char	    IdxComponentName[16];
	long	    MsgOffset;
	int	    MsgCount;

	char		Line[MAXLENGTH];
	char		NextLine[MAXLENGTH];
	char		CurrentIdxRecord[256];
	char		CurrentMsgRecord[256];
	int		CurrentIdxLevel;
	int		CurrentMsgLevel;
	char		RcdIDXType[32];
	struct		Idx_Structure  *IdxPtr;
	int		i;
	int		NumberOfMsg;
	int		k;
	long		n;
	int		ComponentNameLen = 20;
	char		*s, *p;
	unsigned	len;
	char		ContinueMessageInfo[32];
	int		ContinueMessageInfoLen;

	/* initialize the things that need to be... */

	printf(" Loading messages from %s\n",CountryMsg);

	k = 32000;
	s = malloc(k);
	while ( (s == (char *) 0) && (k > 1) )
	      {
		k -= 1000;
		s = malloc(k);
		}
	if (s != (char *) 0) free(s);
	printf(" (Available message memory space: %d bytes)\n",k);

	IdxHandle = DosOpen( (char far *) CountryIdx, READONLY);
	MsgHandle = DosOpen( (char far *) CountryMsg, READONLY);

	LineInput(IdxHandle, (char far *) &CurrentIdxRecord[0] );
	LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );

	sscanf(CurrentIdxRecord," %d ",&CurrentIdxLevel);
	sscanf(CurrentIdxRecord," %d ",&CurrentMsgLevel);
	if ( CurrentIdxLevel != CurrentMsgLevel )
	      {
		printf("\nERROR: %s and %s levels do not match\n",CountryIdx,CountryMsg);
		exit(1);
		}

	/* find out the offset into the big message file for COMMON error */
	/*						     EXTENDED	  */
	/*						     PARSER	  */
	/*						     Utility	  */

	while ( !EofFlags[IdxHandle] )
	      {
		LineInput(IdxHandle, (char far *) &CurrentIdxRecord[0] );

		sscanf(CurrentIdxRecord, " %s %lx %d ",
			IdxComponentName, &MsgOffset, &MsgCount);
		if (Debugging) printf("---> [%s] %04lX %04d<---\n",IdxComponentName, MsgOffset, MsgCount);

		strupr(IdxComponentName);

		if (strcmp(IdxComponentName,"COMMON")  == 0)
		      {
			if ( !ReadCommonFlag )
			      {
				ReadCommonFlag = TRUE;
				DosLSeek( MsgHandle, MsgOffset, 0);
				LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );
				if (strcmp(CurrentIdxRecord, CurrentMsgRecord) != 0)
				      {
					printf("\nERROR: %s and %s COMMON headers do not match\n",CountryIdx,CountryMsg);
					exit(1);
					}
				CommonMessageLines = 1;
				ExtendedMessageLines = 1;
				LineInput(MsgHandle, (char far *) &Line[0] );
				while ( ( !isalpha(Line[0]) ) && (!EofFlags[MsgHandle]) )
				      {
					p = strchr(Line, ' ') + 1;      /* skip msg number */
					p = strchr(p, ' ') + 1;         /* skip status flag */
					p = strchr(p, ' ') + 1;         /* skip revision level */
					len = strlen(p);
					CommonErrorTexts[CommonMessageLines] = MyMalloc(len+1);
					strcpy(CommonErrorTexts[CommonMessageLines], p);
					if (Debugging) printf("CommonErrorTexts[%d] = (%s)\n",
							       CommonMessageLines,CommonErrorTexts[CommonMessageLines]);
					CommonMessageLines++;
					if (CommonMessageLines >= MAXCOMMONERROR)
					      {
						printf("\nERROR: COMMON message number too large, %d\n",CommonMessageLines);
						exit(1);
						}
					LineInput(MsgHandle, (char far *) &Line[0] );
					}
				}
			}

		else if (strcmp(IdxComponentName,"EXTEND")  == 0)
		      {
			if ( !ReadExtendFlag )
			      {
				ReadExtendFlag = TRUE;
				DosLSeek( MsgHandle, MsgOffset, 0);
				LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );
				if (strcmp(CurrentIdxRecord, CurrentMsgRecord) != 0)
				      {
					printf("\nERROR: %s and %s EXTEND headers do not match\n",CountryIdx,CountryMsg);
					exit(1);
					}
				ExtendedMessageLines = 1;
				LineInput(MsgHandle, (char far *) &Line[0] );
				while ( ( !isalpha(Line[0]) ) && (!EofFlags[MsgHandle]) )
				      {
					p = strchr(Line, ' ') + 1;      /* skip msg number */
					p = strchr(p, ' ') + 1;         /* skip status flag */
					p = strchr(p, ' ') + 1;         /* skip revision level */
					len = strlen(p);
					ExtendedErrorTexts[ExtendedMessageLines] = MyMalloc(len+1);
					strcpy(ExtendedErrorTexts[ExtendedMessageLines], p);
					if (Debugging) printf("ExtendedErrorTexts[%d] = (%s)\n",
							      ExtendedMessageLines,ExtendedErrorTexts[ExtendedMessageLines]);
					ExtendedMessageLines++;
					if (ExtendedMessageLines >= MAXEXTENDEDERROR)
					      {
						printf("\nERROR: EXTENDED message number too large, %d\n",ExtendedMessageLines);
						exit(1);
						}
					LineInput(MsgHandle, (char far *) &Line[0] );
					}
				}
			}

		else if (strcmp(IdxComponentName,"PARSE")  == 0)
		      {
			if ( !ReadParserFlag )
			      {
				ReadParserFlag = TRUE;
				DosLSeek( MsgHandle, MsgOffset, 0);
				LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );
				if (strcmp(CurrentIdxRecord, CurrentMsgRecord) != 0)
				      {
					printf("\nERROR: %s and %s PARSE headers do not match\n",CountryIdx,CountryMsg);
					exit(1);
					}
				ParserMessageLines = 1;
				LineInput(MsgHandle, (char far *) &Line[0] );
				while ( ( !isalpha(Line[0]) ) && (!EofFlags[MsgHandle]) )
				      {
					p = strchr(Line, ' ') + 1;
					p = strchr(p, ' ') + 1;
					p = strchr(p, ' ') + 1;
					len = strlen(p);
					ParserErrorTexts[ParserMessageLines] = MyMalloc(len+1);
					strcpy(ParserErrorTexts[ParserMessageLines], p);
					if (Debugging) printf("ParserErrorTexts[%d] = (%s)\n",
							       ParserMessageLines,ParserErrorTexts[ParserMessageLines]);
					ParserMessageLines++;
					if (ParserMessageLines >= MAXPARSERERROR)
					      {
						printf("\nERROR: PARSER message number too large, %d\n",ParserMessageLines);
						exit(1);
						}
					LineInput(MsgHandle, (char far *) &Line[0] );
					}
				}
			}

		else if (strcmp(IdxComponentName,UtilityName)  == 0)
		      {
			if ( !ReadUtilFlag )
			      {
				ReadUtilFlag = TRUE;
				DosLSeek( MsgHandle, MsgOffset, 0);
				LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );
				if (strcmp(CurrentIdxRecord, CurrentMsgRecord) != 0)
				      {
					printf("\nERROR: %s and %s %s headers do not match\n",
						CountryIdx,CountryMsg,UtilityName);
					exit(1);
					}
				UtilMessageLines = 1;
				LineInput(MsgHandle, (char far *) &Line[0] );
				while ( ( !isalpha(Line[0]) ) && (!EofFlags[MsgHandle]) )
				      {
					if ( !isdigit(Line[0]) )
					      {
						MsgCount++;
						/* need to fake  MsgNumber, Status, Level fields*/
						len =  strlen(Line) + strlen(ContinueMessageInfo);
						UtilErrorTexts[UtilMessageLines] = MyMalloc(len+1);
						strcpy(UtilErrorTexts[UtilMessageLines], ContinueMessageInfo);
						strcat(UtilErrorTexts[UtilMessageLines], Line);
						if (Debugging) printf("UtilErrorTexts[%d] = (%s)\n",
								       UtilMessageLines,UtilErrorTexts[UtilMessageLines]);
						}
					 else
					      {
						len = strlen(Line);
						UtilErrorTexts[UtilMessageLines] = MyMalloc(len+1);
						strcpy(UtilErrorTexts[UtilMessageLines], Line);
						if (Debugging) printf("UtilErrorTexts[%d] = (%s)\n",
								       UtilMessageLines,UtilErrorTexts[UtilMessageLines]);
						strncpy(ContinueMessageInfo,Line,12);
						ContinueMessageInfo[12] = (char) '\0';
						if (Debugging) printf(" ContinueMessageInfo = (%s)\n",
								       ContinueMessageInfo);
						}
					UtilMessageLines++;
					if (UtilMessageLines >= MAXUTILERROR)
					      {
						printf("\nERROR: Utility message number too large, %d\n",UtilMessageLines);
						exit(1);
						}
					LineInput(MsgHandle, (char far *) &Line[0] );
					}
				}
			}

		}

	DosClose(IdxHandle);
	DosClose(MsgHandle);

	UtilMessageLines--;
	CommonMessageLines--;
	ParserMessageLines--;
	ExtendedMessageLines--;

	k = 32000;
	s = malloc(k);
	while ( (s == (char *) 0) && (k > 1) )
	      {
		k -= 1000;
		s = malloc(k);
		}
	if (s != (char *) 0) free(s);
	printf(" (Still available message memory space: %d bytes)\n",k);

	if (!ReadCommonFlag)
	      { printf("\nERROR: COMMON messages not found in %s\n",CountryIdx);
		exit(1);
		}

	if (!ReadExtendFlag)
	      { printf("\nERROR: EXTEND messages not found in %s\n",CountryIdx);
		exit(1);
		}

	if (!ReadParserFlag)
	      { printf("\nERROR: PARSE messages not found in %s\n",CountryIdx);
		exit(1);
		}

	if (!ReadUtilFlag)
	      { printf("\nERROR: %s messages not found in %s\n",UtilityName,CountryIdx);
		exit(1);
		}

	return;

	}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\spawn.asm ===
TITLE	SPAWN  - procedures to spawn another program before exiting
;/*
; *                      Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1993
; *                      All Rights Reserved.
; */
page	,132

	.xlist
	include chkseg.inc
	include chkmacro.inc
	INCLUDE SYSCALL.INC
	INCLUDE PATHMAC.INC
	.list

;**************************************************************************
; Structures
;**************************************************************************

Exec_Block_Parms struc
Segment_Env	dw	0
Offset_Command	dw	0
Segment_Command dw	0
Offset_FCB1	dw	0
Segment_FCB1	dw	0
Offset_FCB2	dw	0
Segment_FCB2	dw	0
Exec_Block_Parms ends

PSP_OFFSET_FCB1 EQU	05Ch
PSP_OFFSET_FCB2 EQU	06Ch

EXEC_STACK_SIZE EQU	1024

;**************************************************************************
;**************************************************************************
										
data	segment
ASSUME	cs:DG,ds:DG,es:nothing,ss:nothing

	extrn	fatmap:word
	extrn	fattbl_seg:word

	pathlabl spawn

;**************************************************************************
; Data Area
;**************************************************************************

lclExitStatus	db	?		;hold exit status to pass to MS-DOS

Exec_Block	Exec_Block_Parms <>	;EXEC parameter block

		public	EXEC_Path, EXEC_CmdTail

EXEC_Path	db	80 dup (0)	;EXEC pathname

EXEC_CmdTail	db	20 dup (0)	;EXEC command tail


;=========================================================================
; SpawnAndExit	-	This routine spawns another program before exiting
;			CHKDSK.  When the child process terminates, this
;			routines terminates CHKDSK.
;
;			This file is linked first in the CHKDSK image so
;			this this code and data leave a very small stub
;			when Exec'ing the child process.
;
;
;	Inputs	:	AL - Exit code to use when terminating CHKDSK
;			ES - CHKDSK PSP segment
;			EXEC_Path - contains full pathname of pgm to spawn.
;			EXEC_CmdTail - contains cmd tail to pass to child.
;
;	Outputs :	Exits to MS-DOS
;=========================================================================

	assume	CS:DG,DS:DG,ES:NOTHING

	; ShrinkExecExit is actually a part of SpawnAndExit, but located
	; before SpawnAndExit so some of the code can be discarded

ShrinkExecExit	proc	near

	; Switch to local EXEC stack

	mov	ax, ds
	cli
	mov	ss, ax
	mov	sp, cx
	sti

	DOS_Call Setblock		;shrink memory image, bx has size

	; Spawn the child process

	mov	ax, ds
	mov	es, ax
	mov	bx, offset DG:Exec_Block ;es:bx -> parameter block
	mov	dx, offset DG:Exec_Path  ;ds:dx -> program specification

	xor	al, al			 ;exec pgm subfunction
	DOS_Call Exec

	; The child has completed, now terminate CHKDSK.  If lclExitStatus
	; is not 0 return that, otherwise get and return the child's exit
	; status.

	mov	al, lclExitStatus
	jc	see_exit		;Use this status if Exec failed

	or	al, al
	jnz	see_exit		;Status != 0, return it

	DOS_Call WaitProcess		;Our status is 0, get child's status

see_exit:
	DOS_Call Exit

ShrinkExecExit	endp

End_Exec	label	near		;End of code/data kept for Exec'ing
					;  child process

	public	SpawnAndExit
	assume	cs:DG,DS:DG,ES:NOTHING

SpawnAndExit	proc	near

	mov	lclExitStatus, al	;save exit status locally

	; Free other CHKDSK memory blocks to make more mem available to child

	push	es			;save PSP segment
	mov	es, fattbl_seg		;these appear to be the only
	Dos_Call Dealloc		;  other two blocks allocated
	mov	es, fatmap
	Dos_Call Dealloc
        pop     es

	; Build the EXEC call parameter block

	xor	ax, ax
	mov	Exec_Block.Segment_Env, ax

	mov	Exec_Block.Offset_Command, offset DG:EXEC_CmdTail
	mov	Exec_Block.Segment_Command, ds

	mov	Exec_Block.Offset_FCB1, PSP_OFFSET_FCB1
	mov	Exec_Block.Segment_FCB1, es

	mov	Exec_Block.Offset_FCB2, PSP_OFFSET_FCB2
	mov	Exec_Block.Segment_FCB2, es

	; Setup to shrink CHKDSK memory size to make room for child process

	mov	ax, es			;ax = PSP segment
	mov	bx, cs			;bx = data/code segment
	sub	bx, ax			;bx = # paras from psp to data seg
	mov	ax, offset DG:End_Exec
	add	ax, EXEC_STACK_SIZE + 15
	mov	cl, 4
	shr	ax, cl			;ax = siz data seg to keep in paras
	add	bx, ax			;bx = # paras to keep

	mov	cx, offset DG:End_Exec
	add	cx, EXEC_STACK_SIZE + 1
	and	cl, not 1		;cx = word offset of temp exec stack

	jmp	ShrinkExecExit		;go shrink, exec child, and exit

SpawnAndExit	endp

	pathlabl spawn

data	ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\comseg.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; The following are all of the segments used in the load order
;
;SR; We switch the order of the CODE and DATA segments since we will have to
;move the CODE segment for HIMEM COMMAND
;


DATARES 	segment public byte	; resident data
DATARES 	ends

;
;Dummy segment to align the code segment on a paragraph boundary
;
DUMMY	segment public para
DUMMY	ENDS

CODERES 	segment public byte	; resident code
CODERES 	ends

;SR;
;No environment segments
;
;;ENVARENA	segment public para	; space for DOS ALLOCATE header
;;ENVARENA	ends

;;ENVIRONMENT	segment public para	; default COMMAND environment
;;ENVIRONMENT	ends

INIT		segment public para	; initialization code
INIT		ends

TAIL		segment public para	; end of init - start of transient
TAIL		ends

TRANCODE	segment public byte	; transient code
TRANCODE	ends

TRANDATA	segment public byte	; transient data area
TRANDATA	ends

TRANSPACE	segment public byte	; transient modifiable data area
TRANSPACE	ends

TRANTAIL	segment public para	; end of transient
TRANTAIL	ends

;SR;
;  We still keep the CODE and DATA in a group. This is to make addressability
;easy during init. This will not work for COMMAND in ROM but it is fine for
;HIMEM COMMAND. However, the resident code will not refer to any data using
;RESGROUP
;

RESGROUP  	group CODERES,DATARES,INIT,TAIL
TRANGROUP 	group TRANCODE,TRANDATA,TRANSPACE,TRANTAIL

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\comsw.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)comsw.asm	1.1 85/05/14
;	SCCSID = @(#)comsw.asm	1.1 85/05/14

include version.inc

; Eliminate IBM ROM_FIND code (PC Jr ROM cartridges?).
;
; Don't count on turning this back on just by defining
; IBM_ROM_FIND TRUE.  I'm just keeping it around for
; reference, for now.  Microsoft's ROM file finding
; code and IBM's code would probably step on each other.
;
; To keep the DOS 5.0 non-ROM binary unchanged, we'll
; define IBM_ROM_FIND FALSE only for ROM DOS.
;
; BUGBUG : check with davidols
;
ifdef   ROMDOS
IBM_ROM_FIND 	equ 	NOT ROMDOS
else
IBM_ROM_FIND 	equ 	TRUE
endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\copypr1.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	.xlist
	.xcref

	include comsw.asm
	include dossym.inc
	include syscall.inc
	include sf.inc
	include comseg.asm
	include comequ.asm

	.list
	.cref


TRANDATA	segment public byte
	extrn	DevWMes_Ptr:word
	extrn	Extend_Buf_Sub:byte
	extrn	LostErr_Ptr:word
	extrn	NoSpace_Ptr:word
	extrn	Overwr_Ptr:word
TRANDATA	ends

TRANSPACE	segment public byte
	extrn	Ascii:byte
	extrn	Binary:byte
	extrn	CFlag:byte
	extrn	Concat:byte
	extrn	DestBuf:byte
	extrn	DestClosed:byte
	extrn	DestHand:word
	extrn	DestIsDev:byte
	extrn	DestSwitch:word
	extrn	Inexact:byte
	extrn	NoWrite:byte
	extrn	NxtAdd:word
	extrn	OCtrlZ:byte
	extrn	OFilePtr_Hi:word
	extrn	OFilePtr_Lo:word
	extrn	Plus_Comma:byte
	extrn	RdEof:byte
	extrn	SrcIsDev:byte
	extrn	String_Ptr_2:word
	extrn	TermRead:byte
	extrn	Tpa:word
	extrn	Written:word
TRANSPACE	ends

TRANCODE	segment public byte

	extrn	EndCopy:near

	public	FlshFil
	public	TryFlush

	assume	cs:TRANGROUP,ds:TRANGROUP,es:TRANGROUP,ss:NOTHING



;***	TryFlush - flush copy buffer, double-check for concatenation
;
;	EXIT	ZR set if concatenate flag unchanged

TryFlush:
	mov	al,Concat
	push	ax
	call	FlshFil
	pop	ax
	cmp	al,Concat
	return


;***	Flshfil - write out any data remaining in copy buffer.
;
;	Inputs:
;	  [NXTADD] = No. of bytes to write
;	  [CFLAG] <> 0 if file has been created
;	Outputs:
;	  [NXTADD] = 0

FlshFil:
	mov	TermRead,0
	cmp	CFlag,0
	je	NotExists
	jmp	Exists

NotExists:
	invoke	BuildDest		; find out all about the destination
	invoke	CompName		; source and dest. the same?
	jne	ProcDest		; if not, go ahead

	cmp	SrcIsDev,0
	jne	ProcDest		; same name on device ok

	cmp	Concat,0		; concatenation?
	mov	dx,offset TRANGROUP:Overwr_Ptr
	jne	No_Concat_Err		; concatenating

	jmp	CopErr			; not concatenating - overwrite error

No_Concat_Err:
	mov	NoWrite,1		; flag not writing (just seeking)

ProcDest:
	mov	ax,EXTOPEN shl 8		; open the file
	mov	si,offset TRANGROUP:DestBuf	; get file name
;M046
; For writes, we want to deny writes by anyone else at the same time that we
;are writing to it. For instance, on a network, 2 workstations could try
;writing to the same file. Also, because we opened the source file with
;DENY NONE, it is fine if the source and destination files are the same as
;would happen when we append to an existing file.
;
	mov	bx,DENY_WRITE or WRITE_OPEN_MODE;get open mode for copy; M046
	xor	cx,cx				; no special files
	mov	dx,WRITE_OPEN_FLAG		; set up open flags

	cmp	NoWrite,0
	jne	DoDestOpen		; don't actually create if nowrite set
	mov	dx,CREAT_OPEN_FLAG	; set up create flags

DoDestOpen:
	int	21h

;	We assume that the error is normal.
;	TriageError will correct the DX value appropriately.

	jnc	Dest_Open_Okay			;AC030;

Xa_Set_Error:					;AN030; error occurred on XA
	invoke	Set_Ext_Error_Msg		;AN030; get extended error

Ext_Err_Set:					;AN030;
	mov	String_Ptr_2,offset TRANGROUP:DestBuf ;AN000; get address of failed string
	mov	Extend_Buf_Sub,ONE_SUBST	;AN030; put number of subst in control block


CopErrJ2:					;AN030;
	jmp	CopErr				;AN030; go issue message

Dest_Open_Okay: 				;AC030
	mov	DestHand,ax			; save handle
	mov	CFlag,1				; destination now exists
	mov	bx,ax
	mov	ax,(IOCTL shl 8)
	int	21h				; get device stuff
	mov	DestIsDev,dl			; set dest info
	test	dl,DEVID_ISDEV
	jz	Exists				;AC030; Dest not a device

;	Destination is device.

	mov	al,byte ptr DestSwitch
	and	al,SWITCHA+SWITCHB
	jnz	TestBoth
	mov	al,Ascii		; neither set, use current setting
	or	al,Binary
	jz	ExSetA			; neither set, default to ascii

TestBoth:
	jpe	Exists			; both are set, ignore
	test	al,SWITCHB
	jz	Exists			; leave in cooked mode
	mov	ax,(IOCTL shl 8) or 1
	xor	dh,dh
	or	dl,DEVID_RAW
	mov	DestIsDev,dl		; new value
	int	21h			; set device to raw mode
	jmp	short Exists

CopErrJ:
	jmp	CopErr


ExSetA:

;	What we read in may have been in binary mode, flag zapped write OK

	mov	Ascii,SWITCHA 		; set ascii mode
	or	Inexact,SWITCHA		; ascii -> inexact

Exists:
	cmp	NoWrite,0
	jne	NoChecking		; if nowrite don't bother with name check
	cmp	Plus_Comma,1		;g  don't check if just doing +,,
	je	NoChecking		;g
	invoke	CompName		; source and dest. the same?
	jne	NoChecking		; if not, go ahead
	cmp	SrcIsDev,0
	jne	NoChecking		; same name on device ok

;	At this point we know in append (would have gotten overwrite error
;	on first destination create otherwise), and user trying to specify
;	destination which has been scribbled already (if dest had been named
;	first, NoWrite would be set).

	mov	dx,offset TRANGROUP:LostErr_Ptr ; tell him he's not going to get it
	invoke	Std_EprintF			;ac022;
	mov	NxtAdd,0			; set return
	inc	TermRead			; tell read to give up

Ret60:
	return


NoChecking:
	mov	bx,DestHand		; get handle
	xor	cx,cx
	xchg	cx,NxtAdd
	jcxz	Ret60			; if nothing to write, forget it
	inc	Written			; flag that we wrote something
	cmp	NoWrite,0		; if nowrite set, just seek cx bytes
	jne	SeekEnd
	xor	dx,dx
	push	ds
	mov	ds,Tpa
	assume	ds:NOTHING
	mov	ah,WRITE
	int	21h
	pop	ds
	assume	ds:TRANGROUP
	mov	dx,offset TRANGROUP:NoSpace_Ptr
	jnc	@f
	jmp	Xa_Set_Error			;AC022; failure
@@:	sub	cx,ax
	retz					; wrote all supposed to
	test	DestIsDev,DEVID_ISDEV
	jz	CopErr				; is a file, error
	test	DestIsDev,DEVID_RAW
	jnz	DevWrtErr			; is a raw device, error
	cmp	Inexact,0
	retnz					; inexact so ok
	dec	cx
	retz					; wrote one byte less (the ^z)


DevWrtErr:
	mov	dx,offset TRANGROUP:DevWMes_Ptr
	jmp	short CopErr




SeekEnd:
	xor	dx,dx			; zero high half of offset
	xchg	dx,cx			; cx:dx is seek location
	mov	ax,(LSEEK shl 8) or 1
	int	21h			; seek ahead in the file

;	Save the file pointer in DX:AX to restore the file
;	with in case the copy should fail.

	mov	OFilePtr_Lo,ax
	mov	OFilePtr_Hi,dx

	cmp	RdEof,0
	retz				; EOF not read yet

;	^Z has been read - we must set the file size to the current
;	file pointer location

	mov	ah,WRITE
	int	21h			; cx is zero, truncates file
	jc	Xa_Set_Error_Jmp	;AC022; failure

;	Make note that ^Z was removed, in case the
;	copy should fail and we need to restore the file.

	mov	OCtrlZ,1Ah

	return




	public	CopErr
CopErr:
	invoke	Std_EPrintF		;AC022;

CopErrP:
	inc	DestClosed
	cmp	CFlag,0
	je	EndCopyJ		; never actually got it open
	mov	bx,DestHand
	cmp	bx,0
	jle	NoClose

;	Check to see if we should save part of the destination file.

	mov	cx,OFilePtr_Hi		; CX = hi word of original file ptr
	mov	dx,OFilePtr_Lo		; DX = lo word of original file ptr

	mov	ax,cx
	or	ax,dx
	jz	ceClose			; null file ptr means nothing to save

;	Destination was also the first source.  Do the best we can to
;	restore it.  Truncate it back to the size we took from it (which
;	may have been due to a Ctrl-Z, so may not have included the whole
;	file).  If a Ctrl-Z was originally read, put it back.

	mov	ax,LSEEK shl 8
	int	21h

	xor	cx,cx			; CX = # bytes to write = 0
	mov	ah,WRITE
	int	21h			; truncate file

	cmp	OCtrlZ,0
	je	@f			; no ctrl-z removed from original
	inc	cx			; CX = # bytes to write = 1
	mov	dx,offset TRANGROUP:OCtrlZ  ; DS:DX = ptr to original ctrl-z
	mov	ah,WRITE
	int	21h			; write ctrl-z
@@:
	mov	ah,CLOSE
	int	21h			; close it
;;	mov	CFlag,0
	jmp	EndCopy			; and go home

ceClose:
	mov	ah,CLOSE		; close the file
	int	21h

NoClose:
	mov	dx,offset TRANGROUP:DestBuf
	mov	ah,UNLINK
	int	21h			; and delete it
	mov	CFlag,0

EndCopyJ:
	jmp	EndCopy

Xa_Set_Error_Jmp:			;AN022; go set up error message
	jmp	Xa_Set_Error		;AN022;

TRANCODE	ends
	 	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\command2.asm ===
page ,132
	title	COMMAND2 - resident code for COMMAND.COM part II
	name	COMMAND2
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
;			reserve memory by changing int 12h and then give it
;			back to DOS by changing arenas in autoexec.bat.
;			This makes command.com reload transient and this
;			cannot be done at this stage.
;
;



.xcref
.xlist
	include dossym.inc
	include pdb.inc
	include syscall.inc
	include comsw.asm
	include comequ.asm
	include resmsg.equ

	include comseg.asm
.list
.cref


DATARES 	segment public byte
		extrn	Append_State:word
		extrn	Append_Flag:byte
		extrn	BMemMes:byte
		extrn	ComBad:byte
		extrn	ComDrv:byte
		extrn	ComSpec:byte
		extrn	EnvirSeg:word
		extrn	ExtCom:byte
		extrn	FRetMes:byte
		extrn	HaltMes:byte
		extrn	Handle01:word
		extrn	InitFlag:BYTE
		extrn	Int_2e_Ret:dword
		extrn	Io_Save:word
		extrn	Loading:byte
		extrn	LTpa:word
		extrn	MemSiz:word
		extrn	NoHandMes:byte
		extrn	OldTerm:dword
		extrn	Parent:word
		extrn	PermCom:byte
		extrn	Prompt:byte
		extrn	PutBackDrv:byte
		extrn	PutBackMsg:byte
		extrn	PutBackSubst:byte
		extrn	Res_Tpa:word
		extrn	RetCode:word
		extrn	Save_Pdb:word
		extrn	SingleCom:word
		extrn	Sum:word
		extrn	Trans:dword
		extrn	TranVarEnd:byte
		extrn	TranVars:byte
		extrn	TrnSeg:word
		extrn	VerVal:word

		extrn	ResSize:word
		extrn	OldDS:word
		extrn	RStack:word

		extrn	Ctrlc_Trap:near
		extrn	CritErr_Trap:near
		extrn	LodCom_Trap:near

DATARES 	ends

;;ENVARENA 	segment public para
;;ENVARENA 	ends

;;ENVIRONMENT 	segment public para      ; default COMMAND environment
;;ENVIRONMENT 	ends

INIT		segment public para
		extrn	EnvSiz:word
		extrn	OldEnv:word
		extrn	ResetEnv:byte
		extrn	UsedEnv:word
                extrn   AllocedEnv:byte
INIT		ends


TRANDATA	segment public byte
		extrn	trandataend:byte
TRANDATA	ends

TRANSPACE	segment public byte
		extrn	transpaceend:byte
		extrn	headcall:dword
TRANSPACE	ends




CODERES segment public byte

	public	BadMemErr

	public	ChkSum
;;	public	EndInit
	public	GetComDsk2
	public	Int_2e
	public	LoadCom
	public	LodCom
	public	LodCom1
	public	RestHand
	public	SavHand
	public	SetVect
	public	THeadFix
	public	TRemCheck
	public	TJmp

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	extrn	ContC:near
	extrn	DskErr:near

	extrn	Alloc_error:near

;*	If we cannot allocate enough memory for the transient or there
;	was some other allocation error, we display a message and
;	then die.

;SR;
; We will have to make sure that at this entry point and at FatalC, 
;ds = DATARES. All jumps to these points are made from only within this file
;and so we should be able to do this

	assume	ds:DATARES
BadMemErr:
	mov	dx,offset DATARES:BMemMes	; DX = ptr to msg
FatalC:

;;	push	cs
;;	pop	ds
;;	assume	ds:ResGroup
	invoke	RPrint

;	If this is NOT a permanent (top-level) COMMAND, then we exit;
;	we can't do anything else!

	cmp	PermCom,0
	je	FatalRet

;	We are a permanent command.  If we are in the process of the
;	magic interrupt (Singlecom) then exit too.

	cmp	SingleCom,0			; if permcom and singlecom
	jne	FatalRet			; must take int_2e exit

;	Permanent command.  We can't do ANYthing except halt.

	mov	dx,offset DATARES:HaltMes	; DX = ptr to msg
	invoke	RPrint
	sti
Stall:
	jmp	Stall				; crash the system nicely

FatalRet:
	mov	dx,offset DATARES:FRetMes	; DX = ptr to msg
	invoke	RPrint
FatalRet2:
	cmp	PermCom,0			; if we get here and permcom,
	jne	Ret_2e				; must be int_2e

;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
;	were a non-permanent COMMAND that had hooked it!  (Just in 
;	case we decide to do that.)
	mov	ax,Parent
	mov	word ptr ds:Pdb_Parent_Pid,ax
	mov	ax,word ptr OldTerm
	mov	word ptr ds:Pdb_Exit,ax
	mov	ax,word ptr OldTerm+2
	mov	word ptr ds:Pdb_Exit+2,ax
	mov	ax,(EXIT shl 8) 		; return to lower level
	int	21h

Ret_2e:
;SR;
; We will ensure that ds = DATARES for all entries to this place
;

;;	push	cs
;;	pop	ds
;;	assume	ds:resgroup,es:nothing,ss:nothing
  	
	assume	ds:DATARES

	mov	SingleCom,0		; turn off singlecom
	mov	es,Res_Tpa
	mov	ah,DEALLOC
	int	21h			; free up space used by transient
	mov	bx,Save_Pdb
	mov	ah,SET_CURRENT_PDB
	int	21h			; current process is user
	mov	ax,RetCode
	cmp	ExtCom,0
	jne	GotECode
	xor	ax,ax			; internals always return 0
GotECode:
	mov	ExtCom,1		; force external

;SR; This is actually returning to the caller. However, the old code had
;ds = RESGROUP so I guess we can keep ds = DATARES for us.
;Yes, int 2eh can corrupt all registers so we are ok.
;
	jmp	Int_2e_Ret		;"iret"




;***	Int_2e, magic command executer

Int_2e:
	assume	ds:NOTHING,es:NOTHING,ss:NOTHING
;SR;
; We are going to come here from the stub with the old ds and DATARES value
;pushed on the stack in that order. Pick up this stuff off the stack
;
	pop	ds			;ds = DATARES
	assume	ds:DATARES
	pop	ax
;	pop	ds:OldDS 		;Save old value of ds

	pop	word ptr Int_2e_Ret
	pop	word ptr [Int_2e_Ret+2] ; store return address
	;pop	ax			; chuck flags
	add	sp,2

;;	push	cs
;;	pop	es

	push	ds
	pop	es			;es = DATARES
;	mov	ds,OldDS
	mov	ds,ax
	assume	ds:nothing		;ds = old value

	mov	di,80h
	mov	cx,64
;	Bugbug:	cld
	rep	movsw
	mov	ah,GET_CURRENT_PDB
	int	21h			; get user's header
	mov	es:Save_Pdb,bx
	mov	ah,SET_CURRENT_PDB

;;	mov	bx,cs
;SR;
; Set ds = DATARES because BadMemErr expects this
;
	push	es
	pop	ds
	assume	ds:DATARES

	mov	bx,ds			;es = our PSP now

	int	21h			; current process is me
	mov	SingleCom,81h
	mov	ExtCom,1		; make sure this case forced

;SR;
; We can enter LodCom directly after a command shell is terminated or we
;can fall thru from above. When we enter directly from the stub, the stack
;has the old ds value and the data seg value on the stack, so that ds can
;be properly set. To fake this, we push dummy values here.
;
	push	ds			;old value of ds
	push	ds			;data seg value, ds = DATARES

LodCom: 					; termination handler
	pop	ds			;ds = DATARES 
	assume	ds:DATARES
	add	sp,2
;	pop	OldDS			;store old ds

	cmp	ExtCom,0
	jne	@f 		; internal cmd - memory allocated
	jmp	LodCom1
@@:
	mov	bx,0FFFFh
	mov	ah,ALLOC
	int	21h
	call	SetSize
	add	ax,20h
	cmp	bx,ax
	jnc	MemOk			; > 512 byte buffer - good enough
BadMemErrJ:
	jmp BadMemErr			; not enough memory




;***	SetSize - get transient size in paragraphs

SetSize	proc
	assume	ds:NOTHING,es:NOTHING
	mov	ax,offset TRANGROUP:TranSpaceEnd + 15
	mov	cl,4
	shr	ax,cl
	ret
SetSize	endp




MemOk:
	assume	ds:DATARES		;we have set ds = DATARES 

	mov	ah,ALLOC
	int	21h
	jc	BadMemErrJ		; memory arenas probably trashed
	mov	ExtCom,0		; flag not to alloc again
	mov	Res_Tpa,ax		; save current tpa segment
	and	ax, 0F000h
	add	ax, 01000h		; round up to next 64k boundary
	jc	Bad_Tpa 		; memory wrap if carry set

;	Make sure that new boundary is within allocated range

	mov	dx,Res_Tpa
	add	dx,bx			; compute maximum address
	cmp	dx,ax			; is 64k address out of range?
	jbe	Bad_Tpa

;	Must have 64K of usable space.

	sub	dx,ax			; compute the usable space
	cmp	dx,01000h		; is space >= 64k ?
	jae	LTpaSet
Bad_Tpa:
	mov	ax,Res_Tpa
LTpaSet:
	mov	LTpa,ax			; usable tpa is 64k buffer aligned
	mov	ax,Res_Tpa		; actual tpa is buffer allocated
	add	bx,ax
	mov	MemSiz,bx
	call	SetSize
	sub	bx,ax
;
;M038; Start of changes
; Changes for Novell RPL. These guys reserve memory for themselves by
;reducing int 12h size and add this memory to the system at autoexec time by
;running a program that changes arenas. This changes the largest block that
;command.com gets and so changes the transient segment. So, command.com does
;a checksum at the wrong address and thinks that the transient is destroyed
;and tries to reload it. At this point, no Comspec is defined and so the
;reload fails, hanging the system. To get around this we just copy the
;transient from the previous address to the new address(if changed) and
;then let command.com do the checksum. So, if the transient area is not
;corrupted, there will not be any reload. In Novell's case, the transient
;is not really corrupted and so this should work.
;
	cmp	bx,TrnSeg		;Segment still the same?
	je	LodCom1		;yes, dont copy
;
;Check if the new segment is above or below the current move. If the new
;segment is above(i.e new block is larger than previous block), then we
;have to move in the reverse direction
;
	mov	cx,offset TRANGROUP:TranSpaceEnd ;cx = length to move
	ja	mov_down		;new seg > old seg, reverse move
	xor	si,si			;normal move
	mov	di,si
	cld
	jmp	short copy_trans
mov_down:
	mov	si,cx			;reverse move, start from end
	dec	si
	mov	di,si
	std
copy_trans:
	push	ds
	push	es
	mov	es,bx			;dest segment
	mov	ds,TrnSeg		;source segment
	assume	ds:nothing

	rep	movsb			;copy transient
	cld
	pop	es
	pop	ds
	assume	ds:DATARES
;
;M038; End of changes
;

	mov	TrnSeg,bx		;new location of transient
LodCom1:
;;	mov	ax,cs
;;	mov	ss,ax
;SR; At this point ds = DATARES which is where the stack is located
;
	mov	ax,ds
	mov	ss,ax
	assume	ss:DATARES
	mov	sp,offset DATARES:RStack

;;	mov	ds,ax

	assume	ds:DATARES
	call	HeadFix 		; close files, restore stdin, stdout
	xor	bp,bp			; flag command ok
	mov	ax,-1
	xchg	ax,VerVal
	cmp	ax,-1
	je	NoSetVer
	mov	ah,SET_VERIFY_ON_WRITE	; AL has correct value
	int	21h
NoSetVer:
	cmp	SingleCom,-1
	jne	NoSng
	jmp	FatalRet2		; we have finished the single command
NoSng:
	call	ChkSum			; check the transient
	cmp	dx,Sum
	je	HavCom			; transient ok
Bogus_Com:
	mov	Loading,1		; flag DskErr routine
	call	LoadCom
ChkSame:

	call	ChkSum
	cmp	dx,Sum
	jz	HavCom			; same command
Also_Bogus:
	call	WrongCom
	jmp	short ChkSame
HavCom:
	mov	Loading,0		; flag to DskErr
	mov	si,offset DATARES:TranVars
	mov	di,offset TRANGROUP:HeadCall
	mov	es,TrnSeg
	cld
	mov	cx,offset DATARES:TranVarEnd
	sub	cx,si
	rep	movsb			; transfer info to transient
	mov	ax,MemSiz
	mov	word ptr ds:Pdb_Block_Len,ax	; adjust my own header

;***	TJmp - jump-off to transient
;
;	Public label so debugger can find this spot.

TJmp:
	jmp	Trans




;***	TRemCheck - far version of RemCheck for transient

TRemCheck	proc	far

	pop	ds			;ds = DATARES
	add	sp,2			;discard old value of ds

	call	RemCheck
	ret

TRemCheck endp




;***	RemCheck
;
;	ENTRY	AL = drive (0=default, 1=A, ...)
;
;	EXIT	ZR set if removeable media
;		ZR clear if fixed media
;
;	USED	none

RemCheck:
	savereg	<ax,bx>
	mov	bx,ax
	mov	ax,(IOCTL shl 8) + 8
	int	21h
	jnc	rcCont			

;	If an error occurred, assume the media is non-removable.
;	AX contains the non-zero error code from the int 21, so
;	'or ax,ax; sets non-zero. This behavior makes network drives
;	appear to be non-removable.				
					
	or	ax,ax			
	jmp	short ResRegs
rcCont:
	and	ax,1
	not	ax
ResRegs:
	restorereg  <bx,ax>
	ret




;***	THeadFix
;
;	Far version of HeadFix, called from transient.

THeadFix	proc	far
	pop	ds			;ds = DATARES
	add	sp,2			;discard old ds value on stack

	call	HeadFix
	ret

THeadFix	endp




;***	HeadFix

HeadFix:
	call	SetVect			; set vectors to our values

;	Clean up header

;	Bugbug:	optimize:
;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes

	xor	bx,bx				; BX = handle = 0
	mov	cx,Io_Save			; CX = original stdin, stdout
	mov	dx,word ptr ds:Pdb_Jfn_Table	; DX = current stdin, stdout
	cmp	cl,dl
	je	Chk1			; stdin matches
	mov	ah,CLOSE
	int	21h			; close stdin
	mov	ds:Pdb_Jfn_Table,cl	; restore stdin
Chk1:
	inc	bx			; BX = handle = 1
	cmp	ch,dh			
	je	ChkOtherHand		; stdout matches
	mov	ah,CLOSE
	int	21h			; close stdout
	mov	ds:Pdb_Jfn_Table+1,ch	; restore stdout

ChkOtherHand:
	add	bx,4			; skip handles 2,3,4
	mov	cx,FILPERPROC - 5	; CX = # handles to close
					;   (handles 0-4 already done)
CloseLoop:
	mov	ah,CLOSE
	int	21h			; close each handle
	inc	bx			; BX = next handle
	loop	CloseLoop

;	Bugbug:	since this is for transient code, move it there

;	M012: remove this CS -> DS.  Must've been missed during
;	purification.
;;	push	ds			; save data segment
;;	push	cs			; get local segment into DS
;;	pop	ds			;
	cmp	Append_Flag,-1		; do we need to reset APPEND?
	jne	Append_Fix_End		; no - just exit
	mov	ax,AppendSetState	; set the state of Append
	mov	bx,Append_State 	;     back to the original state
	int	2Fh			;
	mov	Append_Flag,0		; set append flag to invalid
Append_Fix_End: 			;
;;	pop	ds			; get data segment back
	ret




;***	SavHand - save current program's stdin/out & set to our stderr
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Handle01 = current program's stdin,stdout JFN entries
;	  current program's stdin,stdout set to our stderr
;

;SR;
; Changed ds = DATARES. We need it to access our JFN_Table
; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
;
SavHand	proc

	assume	ds:DATARES,es:NOTHING,ss:NOTHING

	push	bx			;preserve registers
	push	ax
	push	es
	push	ds			; save DATARES value

	mov	ah,GET_CURRENT_PDB
	int	21h			; BX = user's header seg addr
	mov	ds,bx			; DS = user's header seg addr
	lds	bx,ds:PDB_JFN_POINTER	; DS:BX = ptr to JFN table
	mov	ax,word ptr ds:[bx]	; AX = stdin,stdout JFN's

	pop	es			;es = DATARES
	push	es			;save it back on stack
	mov	es:Handle01,ax		; save user's stdin, stdout

;SR;
; Use es to address Handle01 & our JFN_Table
;

	mov	al,es:[PDB_JFN_TABLE+2] ; AL = COMMAND stderr
	mov	ah,al			; AH = COMMAND stderr
	mov	word ptr ds:[bx],ax	; set user's stdin/out to our stderr

	pop	ds			; restore registers
	pop	es
	pop	ax
	pop	bx
	ret

SavHand	endp




	assume	ds:DATARES

GetComDsk2:
	call	GetComDsk
	jmp	LodCom1 		; memory already allocated

RestHand:
	push	ds
	push	bx			; restore stdin, stdout to user
	push	ax
	mov	ah,GET_CURRENT_PDB
	int	21h			; point to user's header
	mov	ax,Handle01
	mov	ds,bx
	assume ds:NOTHING
	lds	bx,ds:Pdb_Jfn_Pointer	; DS:BX = ptr to jfn table
	mov	word ptr ds:[bx],ax	; stuff his old 0 and 1
	pop	ax
	pop	bx
	pop	ds
	ret




	assume ds:DATARES,ss:DATARES

Hopeless:
	mov	dx,offset DATARES:ComBad
	jmp	FatalC

GetComDsk:
	mov	al,ComDrv
	call	RemCheck
	jnz	Hopeless			; non-removable media
GetComDsk3:
	cmp	dx,offset DATARES:ComBad
	jnz	GetComDsk4
	mov	dx,offset DATARES:ComBad	; DX = ptr to msg
	invoke	RPrint				; say COMMAND is invalid
GetComDsk4:
;	Bugbug:	there's always a drive here?  No need to check?
	cmp	PutBackDrv,0		; is there a drive in the comspec?
	jnz	Users_Drive		; yes - use it
	mov	ah,GET_DEFAULT_DRIVE	; use default drive
	int	21h
	add	al,"A"                  ; convert to ascii
	mov	PutBackDrv,al		; put in message to print out

Users_Drive:
	mov	dx,offset DATARES:PutBackMsg		; prompt for diskette
	mov	si,offset DATARES:PutBackSubst		;  containing COMMAND
	invoke	RPrint
	mov	dx,offset DATARES:Prompt		; "Press any key"
	invoke	RPrint
	call	GetRawFlushedByte
	ret




;***	GetRawFlushedByte - flush world and get raw input

GetRawFlushedByte:
	mov	ax,(STD_CON_INPUT_FLUSH shl 8) or RAW_CON_INPUT
	int	21h			; get char without testing or echo
	mov	ax,(STD_CON_INPUT_FLUSH shl 8) + 0
	int	21h
;	Bugbug:	get rid of this return and the following retz.
	return




;***	LoadCom - load in transient

LoadCom:
	assume	ds:DATARES
	inc	bp				; flag command read

ifndef	ROMDOS

	mov	dx,offset DATARES:ComSpec
	mov	ax,OPEN shl 8
	int	21h				; open command.com
	jnc	ReadCom
	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
	jnz	TryDoOpen
	mov	dx,offset DATARES:NoHandMes
	jmp	FatalC				; will never find a handle

TryDoOpen:
	call	GetComDsk
	jmp	LoadCom

ReadCom:
	mov	bx,ax				; BX = handle
	mov	dx,offset RESGROUP:TranStart
	xor	cx,cx				; CX:DX = seek loc
	mov	ax,LSEEK shl 8
	int	21h
	jc	WrongCom1
	mov	cx,offset TRANGROUP:TranSpaceEnd - 100h

	push	ds
	mov	ds,TrnSeg
	assume	ds:NOTHING
	mov	dx,100h
	mov	ah,READ
	int	21h
	pop	ds
	assume	ds:DATARES
WrongCom1:
	pushf
	push	ax
	mov	ah,CLOSE
	int	21h			; close command.com
	pop	ax
	popf
	jc	WrongCom		; error on read
	cmp	ax,cx
	retz				; size matched
WrongCom:
	mov	dx,offset DATARES:ComBad
	call	GetComDsk
	jmp	LoadCom 		; try again

else	;ROMDOS

	push	si			; preserve registers
	push	di
	push	es

	mov	si,offset RESGROUP:TranStart
					; SI = offset in image
	mov	es,TrnSeg
	mov	di,100h			; ES:DI = ptr to destination

	mov	cx,offset TRANGROUP:TranSpaceEnd-100h
					; CX = size of transient image
	invoke	LoadFromROM		; copy transient to RAM

	pop	es			; restore registers
	pop	di
	pop	si
	ret

;;	mov	dx,80h			; DS:DX = ptr to desired DTA
;;					;   Ok to use command tail buffer?
;;	mov	ah,SET_DMA		; AH = 'Set DTA Address'
;;	int	21h
;;
;;;	Bugbug:  Are we screwing anybody up by setting DTA here?
;;
;;	mov	dx,offset RESGROUP:ComSpec	; DS:DX = ptr to "COMMAND",0
;;	mov	ah,ROM_FIND_FIRST		; AH = 'ROM Find First'
;;	int	21h
;;	jc	WrongCom			; couldn't find our image
;;
;;;	Relevant DTA contents:
;;;	  Offset 15 = segment address of ROM header
;;;
;;;	We're going to be stupid right now, and just know that
;;;	the command.com image is at offset 30h in the ROM.
;;
;;	push	si			; save registers
;;	push	di
;;	push	ds
;;	push	es
;;
;;	mov	ds,ds:80h+15		; DS = ROM seg addr
;;	assume	ds:NOTHING
;;	mov	si,30h+offset RESGROUP:TranStart
;;					; DS:SI = ptr to transient in ROM
;;	mov	es,TrnSeg
;;	mov	di,100h			; ES:DI = ptr to transient destination
;;
;;	mov	cx,offset TRANGROUP:TranSpaceEnd - 100h
;;					; CX = size of transient image
;;	cld
;;	rep	movsb			; copy transient to RAM
;;
;;	pop	es			; restore registers
;;	pop	ds
;;	assume	ds:DATARES
;;	pop	di
;;	pop	si
;;	ret

WrongCom:
	mov	dx,offset DATARES:ComBad	; DX = ptr to error message
	jmp	FatalC				; print message and give up

endif	;ROMDOS



;***	ChkSum - compute transient checksum

ChkSum:
	push	ds
	mov	ds,TrnSeg
	mov	si,100h
	mov	cx,offset TRANGROUP:TranDataEnd - 100H

Check_Sum:
	cld
	shr	cx,1
	xor	dx,dx
Chk:
	lodsw
	add	dx,ax
	adc	dx,0
	loop	Chk
	pop	ds
	ret




;***	SetVect - set interrupt vectors

SetVect:
	mov	dx,offset DATARES:LodCom_Trap
	mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 22h
	mov	word ptr ds:Pdb_Exit,dx
	mov	word ptr ds:Pdb_Exit+2,ds
	int	21h
	mov	dx,offset DATARES:Ctrlc_Trap
	inc	al
	int	21h
	mov	dx,offset DATARES:CritErr_Trap
	inc	al
	int	21h
	ret

;SR;
; We have this to take care of the extra values pushed on the stack by 
;the stub before jumping to LodCom1. We set up ds here and then jump to
;Lodcom1
;
public	TrnLodCom1
TrnLodCom1:
	pop	ds			;ds = DATARES
	add	sp,2
;	pop	ds:OldDS
	jmp	LodCom1




;***	EndInit - end up initialization sequence
;
;	Move the environment to a newly allocated segment.

;;EndInit:
;;	push	ds			; save segments
;;	push	es			;
;;	push	cs			; get resident segment to DS
;;	pop	ds			;
;;	assume	ds:RESGROUP
;;	mov	cx,UsedEnv		; get number of bytes to move
;;	mov	es,EnvirSeg		; get target environment segment
;;	assume	es:NOTHING
;;
;;	mov	ds:Pdb_Environ,es	; put new environment in my header
;;	mov	ds,OldEnv		; source environment segment
;;	assume	ds:NOTHING
;;	xor	si,si			; set up offsets to start of segments
;;	xor	di,di
;;	cld
;;	rep	movsb			; move it
;;	xor	ax,ax
;;	stosb				; make sure it ends with double-null
;;
;;	cmp	ResetEnv,1		; do we need to setblock to env end?
;;	jne	NoReset 		; no - we already did it
;;	mov	bx,EnvSiz		; BX = size of environ in paragraphs
;;	push	es			; save environment - just to be sure
;;	mov	ah,SETBLOCK		;
;;	int	21h
;;	pop	es
;;
;;NoReset:
;;	mov	InitFlag,FALSE		; turn off init flag
;;	pop	es
;;	pop	ds
;;	jmp	LodCom			; allocate transient

;
;The init code has been changed to take care of the new way in which the
;environment segment is allocated.
;NB: We can use all the init variables at this point because they are all in
;RESGROUP
;Bugbug: The above approach will not work for ROMDOS
;

IF 0

EndInit:
	push	ds
	push	es			;save segments
	push	cs
	pop	ds		
	assume	ds:RESGROUP
;
; AllocedEnv flag signals whether it is a passed environment or not
;
	mov	bx,ds
	mov	es,bx			;es = RESGROUP
;
;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
; code + data for low COMMAND
;
	mov	bx,ResSize		;Total size of resident
	mov	ah,SETBLOCK
	int	21h			;Set block to resident size
;
;Allocate the correct size for the environment
;
	mov	bx,EnvSiz		;bx = env size in paras
	mov	ah,ALLOC
	int	21h			;get memory
	jc	nomem_err		;out of memory,signal error

	mov	EnvirSeg,ax		;Store new environment segment
	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
	mov	es,ax			;es = address of allocated memory
	assume	es:nothing

;
;Copy the environment to the newly allocated segment
;
	mov	cx,UsedEnv		;number of bytes to move

	push	ds
	mov	ds,OldEnv		;ds = Old environment segment
	assume	ds:nothing

	xor	si,si
	mov	di,si			;Start transfer from 0

	cld
	rep	movsb			;Do the copy

	xor	ax,ax			
	stosb				;Make it end with double-null

	pop	ds			;ds = RESGROUP
	assume	ds:RESGROUP
;
;We have to free the old environment block if it was allocated by INIT
;
        cmp     AllocedEnv,0            ;has env been allocated by INIT?
        je      no_free                 ;no, do not free it

	mov	ax,OldEnv		;Get old environment
	mov	es,ax
	mov	ah,DEALLOC	
	int	21h			;Free it
no_free:
	mov	InitFlag,FALSE		;indicate INIT is done
	
	pop	es
	pop	ds
	assume	ds:nothing
	
	jmp	LodCom			;allocate transient

nomem_err:
;
;We call the error routine which will never return. It will either exit
;with an error ( if not the first COMMAND ) or just hang after an error 
;message ( if first COMMAND )
;

	call	Alloc_error
ENDIF

CODERES ends



;	This TAIL segment is used to produce a PARA aligned label in
;	the resident group which is the location where the transient
;	segments will be loaded initial.

TAIL		segment public para

		org	0
TranStart	label	word
		public	TranStart

TAIL		ends



;	This TAIL segment is used to produce a PARA aligned label in
;	the transient group which is the location where the exec
;	segments will be loaded initial.
;
;	Bugbug:	Is TRANTAIL used anymore?

TRANTAIL	segment public para

		org	0
ExecStart   	label   word

TRANTAIL    	ends

		end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\command1.asm ===
page ,132
	title	COMMAND - resident code for COMMAND.COM
	name	COMMAND
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;*****************************************************************************
;
; MODULE:	       COMMAND.COM
;
; DESCRIPTIVE NAME:    Default DOS command interpreter
;
; FUNCTION:	       This version of COMMAND is divided into three distinct
;		       parts.  First is the resident portion, which includes
;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
;		       error), and 2EH (command line execute); it also has
;		       code to test and, if necessary, reload the transient
;		       portion. Following the resident is the init code, which
;		       is overwritten after use.  Then comes the transient
;		       portion, which includes all command processing (whether
;		       internal or external).  The transient portion loads at
;		       the end of physical memory, and it may be overlayed by
;		       programs that need as much memory as possible. When the
;		       resident portion of command regains control from a user
;		       program, a check sum is performed on the transient
;		       portion to see if it must be reloaded.  Thus programs
;		       which do not need maximum memory will save the time
;		       required to reload COMMAND when they terminate.
;
; ENTRY POINT:	       PROGSTART
;
; INPUT:	       command line at offset 81H
;
; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
;		       from a secondary command processor via the EXIT
;		       internal command.
;
; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
;		       hang the system.
;
; INTERNAL REFERENCES:
;
;     ROUTINES:        See the COMMAND Subroutine Description Document
;		       (COMMAND.DOC)
;
;     DATA AREAS:      See the COMMAND Subroutine Description Document
;		       (COMMAND.DOC)
;
; EXTERNAL REFERENCES:
;
;      ROUTINES:       none
;
;      DATA AREAS:     none
;
;*****************************************************************************
;
;			      REVISION HISTORY
;			      ----------------
;
; DOS 1.00 to DOS 3.30
; --------------------------
; SEE REVISION LOG IN COPY.ASM ALSO
;
; REV 1.17
;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
;	       resident since the EXELOAD may have overwritten the transient.
;
; REV 1.18
;    05/21/82  IBM version always looks on drive A
;	       MSVER always looks on default drive
;
; REV 1.19
;    06/03/82  Drive spec now entered in command line
;    06/07/82  Added VER command (print DOS version number) and VOL command
;	       (print volume label)
;
; REV 1.20
;    06/09/82  Prints "directory" after directories
;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
;
; REV 1.50
;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
;	       do it right.
;
; REV 1.70
;	       EXEC used to fork off new processes
;
; REV 1.80
;	       C switch for single command execution
;
; REV 1.90
;	       Batch uses XENIX
;
; Rev 2.00
;	       Lots of neato stuff
;	       IBM 2.00 level
;
; Rev 2.01
;	       'D' switch for date time suppression
;
; Rev 2.02
;	       Default userpath is NUL rather than BIN
;		       same as IBM
;	       COMMAND split into pieces
;
; Rev 2.10
;	       INTERNATIONAL SUPPORT
;
; Rev 2.50
;	       all the 2.x new stuff -MU
;
; Rev 3.30     (Ellen G)
;	       CALL internal command (TBATCH2.ASM)
;	       CHCP internal command (TCMD2B.ASM)
;	       INT 24H support of abort, retry, ignore, and fail prompt
;	       @ sign suppression of batch file line
;	       Replaceable environment value support in batch files
;	       INT 2FH calls for APPEND
;	       Lots of PTR fixes!
;
; Beyond 3.30 to forever  (Ellen G)
; ----------------------
;
; A000 DOS 4.00  -	Use SYSPARSE for internal commands
;			Use Message Retriever services
;			/MSG switch for resident extended error msg
;			Convert to new capitalization support
;			Better error recovery on CHCP command
;			Code page file tag support
;			TRUENAME internal command
;			Extended screen line support
;			/P switch on DEL/ERASE command
;			Improved file redirection error recovery
;	(removed)	Improved batch file performance
;			Unconditional DBCS support
;			Volume serial number support
;	(removed)	COMMENT=?? support
;
; A001	PTM P20 	Move system_cpage from TDATA to TSPC
;
; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
;			require delimiters.
;
; A003	PTM P5,P9,P111	Included in A000 development
;
; A004	PTM P86 	Fix IF command to turn off piping before
;			executing
;
; A005	DCR D17 	If user specifies an extension on the command
;			line search for that extension only.
;
; A006	DCR D15 	New message for MkDir - "Directory already
;			exists"
;
; A007	DCR D2		Change CTTY so that a write is done before XDUP
;
; A008	PTM P182	Change COPY to set default if invalid function
;			returned from code page call.
;
; A009	PTM P179	Add CRLF to invalid disk change message
;
; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
;			transient COMMAND.
;
; A011	DCR D130	Change redirection to overwrite an EOF mark
;			before appending to a file.
;
; A012	PTM P189	Fix redirection error recovery.
;
; A013	PTM P330	Change date format
;
; A014	PTM P455	Fix echo parsing
;
; A015	PTM P517	Fix DIR problem with * vs *.
;
; A016	PTM P354	Fix extended error message addressing
;
; A017	PTM P448	Fix appending to 0 length files
;
; A018	PTM P566,P3903	Fix parse error messages to print out parameter
;			the parser fails on. Fail on duplicate switches.
;
; A019	PTM P542	Fix device name to be printed correctly during
;			critical error
;
; A020	DCR D43 	Set append state off while in DIR
;
; A021	PTM P709	Fix CTTY printing ascii characters.
;
; A022	DCR D209	Enhanced error recovery
;
; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
;
; A024	PTM P899	Fix EXTOPEN open modes.
;
; A025	PTM P922	Fix messages and optimize PARSE switches
;
; A026	DCR D191	Change redirection error recovery support.
;
; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
;			with a carriage return.
;
; A028	PTM P1076	Print a blank line before printing invalid
;			date and invalid time messages.
;
; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
;			and TIME.
;
; A030	DCR D201	New extended attribute format.
;
; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
;
; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
;
; A033	PTM P1298	Fix problem with system crashes on ECHO >""
;
; A034	PTM P1387	Fix COPY D:fname+,, to work
;
; A035	PTM P1407	Fix so that >> (appending) to a device does
;			do a read to determine eof.
;
; A036	PTM P1406	Use 69h instead of 44h to get volume serial
;			so that ASSIGN works correctly.
;
; A037	PTM P1335	Fix COMMAND /C with FOR
;
; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
;
; A039	DCR D284	Change invalid code page tag from -1 to 0.
;
; A040	PTM P1787	Fix redirection to cause error when no file is
;			specified.
;
; A041	PTM P1705	Close redirected files after internal APPEND
;			executes.
;
; A042	PTM P1276	Fix problem of APPEND paths changes in batch
;			files causing loss of batch file.
;
; A043	PTM P2208	Make sure redirection is not set up twice for
;			CALL'ed batch files.
;
; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
;			as an end of line character
;
; A045	PTM P2560	Make sure we don't lose parse, critical error,
;			and extended message pointers when we EXIT if
;			COMMAND /P is the top level process.
;
; A046	PTM P2690	Change COPY message "fn File not found" to
;			"File not found - fn"
;
; A047	PTM P2819	Fix transient reload prompt message
;
; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
;			when DBCS code was added.
;
; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
;			on line.
;
; A050	PTM P3030	Fix TYPE to work properly on files > 64K
;
; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
;
; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
;
; A053	PTM P2865	Fix DIR to work in 40 column mode.
;
; A054	PTM P3407	Code reduction and critical error on single line
;	PTM P3672	(Change to single parser exported under P3407)
;
; A055	PTM P3282	Reset message service variables in INT 23h to fix
;			problems with breaking out of INT 24h
;
; A056	PTM P3389	Fix problem of environment overlaying transient.
;
; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
;			before the "string".  EX: COMMAND /CDIR
;
; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
;			DBCS switch.
;
; A059	PTM P3394	Change the TIME command to right align the display of
;			the time.
;
; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
;			messages to be disk based.  Only keep them if /MSG
;			is used.
;
; A061	PTM P3928	Fix so that transient doesn't reload when breaking
;			out of internal commands, due to substitution blocks
;			not being reset.
;
; A062	PTM P4079	Fix segment override for fetching address of environment
;			of parent copy of COMMAND when no COMSPEC exists in
;			secondary copy of environment.	Change default slash in
;			default comspec string to backslash.
;
; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
;			text for critical error messages.
;
; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
;	5/20/88 	with Microsoft product already shipped.
;
; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
;	 5/20/88	with Microsoft product already shipped.
;
; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
;	 5/24/88	cases; where the listing would barely fit without the
;			header and space remaining.
;
; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
;			environment was putting a "Z block" marker in the old
;			environment.  The fix is to move to the old environment
;			to the new environment before doing the SETBLOCK.
;
; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
;        09/19/88       because the check for APPEND needed to be performed
;                       before the DIR's findfirst.
;
; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
;                       loading trans w/new comspec with no user change comspec.
;
; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
;        11/05/88       Expansion of environment variables into batch line of
;                       128 chars was not being counted and "%" which should be
;                       ignored were being counted.
;
; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
;        03/02/89       used.  Comspec_flag was not in protected data file be-
;                       ing included in checksum and was being overwritten by
;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
;                       Also removed fix A069 (because flag now protected).
;
; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
;        07/25/89       version and CSD version in U.S. date format.  Files
;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
;
;***********************************************************************************

;
;	Revision History
;	================
;
;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
;				at init time (date/time prompt)
;


.xcref
.xlist
	include dossym.inc		; basic DOS symbol set
	include syscall.inc		; DOS function names
	include comsw.asm		; build version info
	include comequ.asm		; common command.com symbols
	include resmsg.equ		; resident message names

	include comseg.asm		;segment ordering
.list
.cref

CODERES segment public byte
CODERES ends

DATARES 	segment public byte
		extrn	AccDen:byte
		extrn	Batch:word
		extrn	EchoFlag:byte
		extrn	ExeBad:byte
		extrn	ExecEMes:byte
		extrn	ExecErrSubst:byte
		extrn	ExtCom:byte
		extrn	ForFlag:byte
		extrn	IfFlag:byte
		extrn	InitFlag:BYTE
		extrn	Nest:word
		extrn	PipeFlag:byte
		extrn	RBadNam:byte
		extrn	RetCode:word
		extrn	SingleCom:word
		extrn	TooBig:byte

		extrn	OldDS:word

DATARES 	ends


INIT		segment public para
		extrn	ConProc:near
		extrn	Init_Contc_SpecialCase:near
INIT		ends



;***	START OF RESIDENT PORTION

CODERES segment public byte

	public	Ext_Exec
	public	ContC
	public	Exec_Wait
	public	Exec_Ret

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	extrn	LodCom:near
	extrn	LodCom1:near

	org	0
Zero	=	$

;;	org	80h - 1
;;ResCom	label byte
;;	public	ResCom

;;	org	100h

public	StartCode
StartCode:
;;	jmp	RESGROUP:ConProc



;***	EXEC error handling
;
;	COMMAND has issued an EXEC system call and it has returned an error.
;	We examine the error code and select an appropriate message.

;	Bugbug:	optimize reg usage in following code?  Careful of DX!
;	Condense the error scan?
;	RBADNAM is checked by transient, no need here?
;	Move below Ext_Exec.

Exec_Err:
;SR;
; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
;in order here

	assume	ds:DATARES,es:DATARES

;	Bugbug:	can we use byte compares here?
;	Might be able to use byte msg#s, too.

;	Store errors in a 3 or 4 byte table.  Msg #s in another.
;	Speed not high priority here.

;	Move this to transient.

	mov	bx,offset DATARES:RBadNam
	cmp	al,ERROR_FILE_NOT_FOUND
	je	GotExecEMes		  	; bad command
	mov	bx,offset DATARES:TooBig
	cmp	al,ERROR_NOT_ENOUGH_MEMORY
	je	GotExecEMes		 	; file not found
	mov	bx,offset DATARES:ExeBad
	cmp	al,ERROR_BAD_FORMAT
	je	GotExecEMes		 	; bad exe file
	mov	bx,offset DATARES:AccDen
	cmp	al,ERROR_ACCESS_DENIED
	je	GotExecEMes		 	; access denied

Default_Message:
	mov	bx,offset DATARES:ExecEMes	; default message
	mov	si,offset DATARES:ExecErrSubst ; get address of subst block

GotExecEMes:
	mov	dx,bx				; DX = ptr to msg
	invoke	RPrint
	jmp	short NoExec



;***	EXEC call
;
;	The transient has set up everything for an EXEC system call.
;	For cleanliness, we issue the EXEC here in the resident 
;	so that we may be able to recover cleanly upon success.
;
;	CS,DS,ES,SS = DATARES seg addr

Ext_Exec:
;SR;
; The words put on the stack by the stub will be popped off when we finally
;jump to LodCom ( by LodCom).
;
;;	int	21h			; do the exec

Exec_Ret:
	jc	Exec_Err		; exec failed

;	The exec has completed.  Retrieve the exit code.

Exec_Wait:
	mov	ah,WAITPROCESS		; get errorlevel
	int	21h			; get the return code
	mov	RetCode,ax

;	See if we can reload the transient.  The external command
;	may have overwritten part of the transient.

NoExec:
;SR;
; ds = es = ss = DATARES when we jump to LodCom
;
	jmp	LodCom




;***	Int 23 (ctrl-c) handler
;
;	This is the default system INT 23 handler.  All processes
;	(including COMMAND) get it by default.  There are some
;	games that are played:  We ignore ^C during most of the
;	INIT code.  This is because we may perform an ALLOC and
;	diddle the header!  Also, if we are prompting for date/time
;	in the init code, we are to treat ^C as empty responses.


;	Bugbug:	put init ctrl-c handling in init module.

;SR;
; The stub has pushed the previous ds and DATARES onto the stack. We get
;both these values off the stack now
;
ContC	proc	far

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	pop	ds			;ds = DATARES
	assume	ds:DATARES
;	pop	OldDS			;OldDS = old ds

	test	InitFlag,INITINIT		; in initialization?
	jz	NotAtInit			; no
	test	InitFlag,INITSPECIAL		; doing special stuff?
	jz	CmdIRet 			; no, ignore ^C
	pop	ds			; restore before jumping; M021
	jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
CmdIret:
;SR;
; Restore ds to its previous value
;

;	mov	ds,OLdDS		;
	pop	ds
	iret				; yes, ignore the ^C

NotAtInit:
	test	InitFlag,INITCTRLC		; are we already in a ^C?
	jz	NotInit 			; nope too.

;*	We are interrupting ourselves in this ^C handler.  We need
;	to set carry and return to the user sans flags only if the
;	system call was a 1-12 one.  Otherwise, we ignore the ^C.

	cmp	ah,1
	jb	CmdIRet
	cmp	ah,12
	ja	CmdIRet

	pop	ds			;restore ds to old value
	add	sp,6				; remove int frame
	stc

;	mov	ds,OldDS		;restore ds to its old value
	ret	2				; remove those flags...

NotInit:

;*	We have now received a ^C for some process (maybe ourselves
;	but not at INIT).
;	
;	Note that we are running on the user's stack!!!  Bad news if
;	any of the system calls below go and issue another INT
;	24...  Massive stack overflow!  Another bad point is that
;	SavHand will save an already saved handle, thus losing a
;	possible redirection...
;	
;	All we need to do is set the flag to indicate nested ^C. 
;	The above code will correctly flag the ^C diring the
;	message output and prompting while ignoring the ^C the rest
;	of the time.
;	
;	Clean up: flush disk.  If we are in the middle of a batch
;	file, we ask if he wants to terminate it.  If he does, then
;	we turn off all internal flags and let the DOS abort.

	or	InitFlag,INITCTRLC	; nested ^c is on
	sti

;;	push	cs			; el yucko!  change the user's ds!!
;;	pop	ds
;;	assume	ds:RESGROUP

	pop	ax			;discard the old ds value

	mov	ax,SingleCom
	or	ax,ax
	jnz	NoReset
	push	ax
	mov	ah,DISK_RESET
	int	21h			; reset disks in case files were open
	pop	ax

NoReset:

;	In the generalized version of FOR, PIPE and BATCH, we would
;	walk the entire active list and free each segment.  Here,
;	we just free the single batch segment.

	test	Batch,-1
	jz	ContCTerm
	or	ax,ax
	jnz	ContCTerm
	invoke	SavHand
	invoke	AskEnd			; ask if user wants to end batch

;	If the carry flag is clear, we do NOT free up the batch file

	jnc	ContBatch
	mov	cl,EchoFlag		; get current echo flag
	push	bx

ClearBatch:
	mov	es,Batch		; get batch segment
	mov	di,BatFile		; get offset of batch file name
;	Bugbug:	verify the following shell interface still works
;;	mov	ax,MULT_SHELL_BRK	; does the SHELL want this terminated?
;;	int	2Fh			; call the SHELL
;;	cmp	al,SHELL_ACTION 	; does shell want this batch?
;;	je	Shell_Bat_Cont		; yes - keep it

	mov	bx,es:BatForPtr		; get old FOR segment
	cmp	bx,0			; is a FOR in progress
	je	no_bat_for		; no - don't deallocate
	push	es			;
	mov	es,bx			; yes - free it up...
	mov	ah,DEALLOC		;
	int	21h			;
	pop	es			; restore to batch segment

No_Bat_For:
	mov	cl,es:BatEchoFlag	; get old echo flag
	mov	bx,es:BatLast	 	; get old batch segment
	mov	ah,DEALLOC		; free it up...
	int	21h
	mov	Batch,bx		; get ready to deallocate next batch
	dec	nest			; is there another batch file?
	jnz	ClearBatch		; keep going until no batch file


;	We are terminating a batch file; restore the echo status


Shell_Bat_Cont: 			; continue batch for SHELL

	pop	bx
	mov	EchoFlag,cl		; reset echo status
	mov	PipeFlag,0		; turn off pipeflag
ContBatch:
	invoke	Crlf			; print out crlf before returning
	invoke	RestHand

;	Yes, we are terminating.  Turn off flags and allow the DOS to abort.

ContCTerm:
	xor	ax,ax			; indicate no read
	mov	bp,ax

;	The following resetting of the state flags is good for the
;	generalized batch processing.

	mov	IfFlag,al		; turn off iffing
	mov	ForFlag,al		; turn off for processing
	call	ResPipeOff
	cmp	SingleCom,ax		; see if we need to set singlecom
	jz	NoSetSing
	mov	SingleCom,-1		; cause termination on 
					;  pipe, batch, for
NoSetSing:

;	If we are doing an internal command, go through the reload process.
;	If we are doing an external, let DOS abort the process.
;	In both cases, we are now done with the ^C processing.

	and	InitFlag,not INITCTRLC
	cmp	ExtCom,al
	jnz	DoDAb				; internal ^c
	jmp	LodCom1
DoDAb:
	stc					; tell dos to abort

;SR;
;We dont need to restore ds here because we are forcing DOS to  do an abort
;by setting carry and leaving flags on the stack
;
	ret					; Leave flags on stack
ContC	endp


;SR;
; ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
;both have ds = DATARES
;

ResPipeOff:
	public	ResPipeOff

	assume	ds:DATARES,es:NOTHING

	savereg <ax>
	xor	ax,ax
	xchg	PipeFlag,al
	or	al,al
	jz	NoPipePop
	shr	EchoFlag,1
NoPipePop:
	restorereg  <ax>
	return


CODERES ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\cparse.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)cparse.asm 1.1 85/05/14
;	SCCSID = @(#)cparse.asm 1.1 85/05/14
	INCLUDE comsw.asm

.xlist
.xcref
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	INCLUDE comseg.asm
	INCLUDE comequ.asm
.list
.cref


TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADCD_PTR:WORD		;AC022;
	EXTRN	BADCPMES_ptr:word	;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	comma:byte
	EXTRN	cpyflag:byte
	EXTRN	CURDRV:BYTE
	EXTRN	ELCNT:BYTE
	EXTRN	ELPOS:BYTE
	EXTRN	EXPAND_STAR:BYTE
	EXTRN	SKPDEL:BYTE
	EXTRN	STARTEL:WORD
	EXTRN	SWITCHAR:BYTE
	EXTRN	switch_list:byte
	EXTRN	TPA:WORD
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:TRANGROUP,SS:NOTHING

	EXTRN	CERROR:NEAR

	PUBLIC	BADCDERR		;AC022;
	PUBLIC	CPARSE

SWCOUNT EQU	6			; Must agree with length of switch_list

;-----------------------------------------------------------------------;
; ENTRY:								;
;	DS:SI	Points input buffer					;
;	ES:DI	Points to the token buffer				;
;	BL	Special delimiter for this call 			;
;		    Always checked last 				;
;		    set it to space if there is no special delimiter	;
; EXIT: 								;
;	DS:SI	Points to next char in the input buffer 		;
;	ES:DI	Points to the token buffer				;
;	[STARTEL] Points to start of last element of path in token	;
;		points to a NUL for no element strings 'd:' 'd:/'       ;
;	CX	Character count 					;
;	BH	Condition Code						;
;			Bit 1H of BH set if switch character		;
;				Token buffer contains char after	;
;				switch character			;
;				BP has switch bits set (ORing only)	;
;			Bit 2H of BH set if ? or * in token		;
;				if * found element ? filled		;
;			Bit 4H of BH set if path sep in token		;
;			Bit 80H of BH set if the special delimiter	;
;			   was skipped at the start of this token	;
;		Token buffer always starts d: for non switch tokens	;
;	CARRY SET							;
;	    if CR on input						;
;		token buffer not altered				;
;									;
;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
; MODIFIES:								;
;	CX, SI, AX, BH, DX and the Carry Flag				;	;
;									;
; -----------------------------------------------------------------------;
;---------------
; Modifications to cparse:  recognition of right and left parentheses
; as integral tokens, and removal of automatic upper-case conversion code.
;
; Both modifications were installed in the course of adding a coherent
; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
; structure for command-line arguments.  This parser relies on cparse to
; recognize individual tokens.
;
; To process for-loops correctly, parentheses must therefore be
; recognized as tokens.  The upper-case conversion code was removed so
; that commands (such as for and echo) would be able to use the "original"
; text of the command line.
;
; Note also the modification to prevent the automatic conversion of colons
; into spaces WITHIN THE SOURCE TEXT!
;
; Also note that BP is also clobbered if cparse recognizes any switches
; on the command line.
;
; Alan L, OS/MSDOS				    14 August 1983
;---------------

CPARSE:
ASSUME	DS:TRANGROUP,ES:TRANGROUP

	xor	ax,ax
	mov	[STARTEL],DI			; No path element (Is DI correct?)
	mov	[ELPOS],al			; Start in 8 char prefix
	mov	[SKPDEL],al			; No skip delimiter yet
	mov	bh,al				; Init nothing
	pushf					; save flags
	push	di				; save the token buffer addrss
	xor	cx,cx				; no chars in token buffer
	mov	comma,cl			;g reset comma flag
moredelim:
	LODSB
	INVOKE	DELIM
	JNZ	SCANCDONE
	CMP	AL,' '
	JZ	moredelim
	CMP	AL,9
	JZ	moredelim
	xchg	al,[SKPDEL]
	or	al,al
	jz	moredelim			; One non space/tab delimiter allowed
	test	bh,080h 			;g  has a special char been found?
	jz	no_comma			;g  no - just exit
	mov	comma,1 			;g  set comma flag
no_comma:
	JMP	x_done				; Nul argument

SCANCDONE:

;;;;	IFNDEF	DBCS	3/3/KK
;---------------
; Mod to avoid upper-case conversion.
;	cmp	cpyflag,1		3/3/KK
;	jnz	cpcont1 		3/3/KK
;	invoke	UPCONV			3/3/KK
cpcont1:
;---------------
;;;;	ENDIF			3/3/KK

	cmp	al,bl				; Special delimiter?
	jnz	nospec
	or	bh,80H
	jmp	short moredelim

nospec:
	cmp	al,0DH				; a CR?
	jne	ncperror
	jmp	cperror

ncperror:
	cmp	al,[SWITCHAR]			; is the char the switch char?
	jne	na_switch			; yes, process...
	jmp	a_switch

na_switch:
	mov	dl,':'
	cmp	byte ptr [si],dl
	jne	anum_chard			; Drive not specified

;;;;	IFDEF	DBCS		3/3/KK
;---------------
; Mod to avoid upper-case conversion.
	cmp	cpyflag,1
	jnz	cpcont2
	invoke	UPCONV
cpcont2:
;---------------
;;;;	ENDIF			3/3/KK

	call	move_char
	lodsb					; Get the ':'
	call	move_char
	mov	[STARTEL],di
	mov	[ELCNT],0
	jmp	anum_test

anum_chard:
	mov	[STARTEL],di
	mov	[ELCNT],0			; Store of this char sets it to one
	cmp	cpyflag,1			; Was CPARSE called from COPY?
	jnz	anum_char			; No, don't add drive spec.
	invoke	PATHCHRCMP			; Starts with a pathchar?
	jnz	anum_char			; no
	push	ax
	mov	al,[CURDRV]			; Insert drive spec
	add	al,capital_A
	call	move_char
	mov	al,':'
	call	move_char
	pop	ax
	mov	[STARTEL],di
	mov	[ELCNT],0

anum_char:

;;;;	IFDEF	DBCS		3/3/KK
	invoke	TESTKANJ
	jz	NOTKANJ 			;AC048;
	call	move_char
	lodsb
	jmp	short notspecial

NOTKANJ:					;AN048; If not kanji
	cmp	cpyflag,1			;AN048; and if we're in COPY
	jnz	testdot 			;AN048;
	invoke	upconv				;AN048; upper case the char

TESTDOT:
;;;;	ENDIF			3/3/KK

	cmp	al,dot_chr
	jnz	testquest
	inc	[ELPOS] 			; flag in extension
	mov	[ELCNT],0FFH			; Store of the '.' resets it to 0

testquest:
	cmp	al,'?'
	jnz	testsplat
	or	bh,2

testsplat:
	cmp	al,star
	jnz	testpath
	or	bh,2
	cmp	byte ptr [expand_star],0
	jnz	expand_filename
	jmp	SHORT testpath

badperr2j:
	jmp	short badperr2

expand_filename:
	mov	ah,7
	cmp	[ELPOS],0
	jz	gotelcnt
	mov	ah,2

gotelcnt:
	mov	al,'?'
	sub	ah,[ELCNT]
	jc	badperr2j
	xchg	ah,cl
	jcxz	testpathx

qmove:
	xchg	ah,cl
	call	move_char
	xchg	ah,cl
	loop	qmove

testpathx:
	xchg	ah,cl

testpath:
	invoke	PATHCHRCMP
	jnz	notspecial
	or	bh,4
	cmp	byte ptr [expand_star],0
	jz	no_err_check
	test	bh,2				; If just hit a '/', cannot have ? or * yet
	jnz	badperr

no_err_check:
	mov	[STARTEL],di			; New element
	INC	[STARTEL]			; Point to char after /
	mov	[ELCNT],0FFH			; Store of '/' sets it to 0
	mov	[ELPOS],0

notspecial:
	call	move_char			; just an alphanum string
anum_test:

	lodsb

;;;;	IFNDEF	DBCS		3/3/KK
;---------------
; Mod to avoid upper-case conversion.
;	cmp	cpyflag,1		3/3/KK
;	jnz	cpcont3 		3/3/KK
;	invoke	UPCONV			3/3/KK
cpcont3:
;---------------
;;;;	ENDIF				3/3/KK

	INVOKE	DELIM
	je	x_done

	cmp	al,0DH
	je	x_done
	cmp	al,[SWITCHAR]
	je	x_done
	cmp	al,bl
	je	x_done
	cmp	al,':'                          ; ':' allowed as trailer because
						; of devices
;;;;	IFDEF	DBCS		3/3/KK
	je	FOO15
	jmp	anum_char
FOO15:
;;;	ELSE			3/3/KK
;;;	jne	anum_charj	3/3/KK
;;;	ENDIF			3/3/KK

;---------------
; Modification made for parseline.
; Why would it be necessary to change colons to spaces?  In this
; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
; but so does 'echo foo:bar' yield 'echo foo bar'.
;---------------
	cmp	cpyflag,2			; Is CPARSE parsing the 1st token from
						;  from PARSELINE?
	jnz	cpcont4 			; No, continue
	call	move_char			; Yes, save the ':' and go get another
	jmp	anum_test			;  character.

cpcont4:
	inc	si				;Skip the ':'
	jmp	short x_done

anum_charj:
	jmp	anum_char

badperr2:
	mov	dx,offset trangroup:BADCPMES_ptr
	jmp	CERROR

badperr:
BADCDERR:					;AC022; Issue "Invalid Directory"
	MOV	DX,OFFSET TRANGROUP:BADCD_ptr	;AC022;     message
	JMP	CERROR				;AC022;

cperror:
	dec	si				; adjust the pointer
	pop	di				; retrive token buffer address
	popf					; restore flags
	stc					; set the carry bit
	return

x_done:
	dec	si				; adjust for next round
;---------------
; Mod to recognize right and left parens as integral tokens.
x_done2:
;---------------
	jmp	short out_token

a_switch:
	OR	BH,1				; Indicate switch
	OR	BP,fSwitch
	INVOKE	SCANOFF
	INC	SI
	invoke	testkanj			;AN057; See if DBCS lead byte
	jz	a_switch_notkanj		;AN057; no - continue processing
	call	move_char			;AN057; DBCS - store first byte
	lodsb					;AN057; get second byte
	call	move_char			;AN057; store second byte
	or	bp,fBadSwitch			;AN057; DBCS switch is invalid
	jmp	short out_token 		;AN057; don't bother checking switch
a_switch_notkanj:				;AN057;
	cmp	al,0DH
	jne	Store_swt
	mov	al,0
	stosb					; null at the end
	OR	BP,fBadSwitch
	jmp	cperror 			; Trailing switch character error
						;   BP = fSwitch but no switch
						;   bit is set (unknown switch)
Store_swt:
	call	move_char			; store the character
;
;---------------
; This upconv call must stay.  It is used to identify copy-switches
; on the command line, and won't store anything into the output buffer.
	invoke	UPCONV
;---------------
;
	PUSH	ES
	PUSH	DI
	PUSH	CX
	PUSH	CS
	POP	ES
ASSUME	ES:TRANGROUP
	MOV	DI,OFFSET TRANGROUP:switch_list
	MOV	CX,SWCOUNT
	OR	BP,fBadSwitch
	REPNE	SCASB
	JNZ	out_tokenp
	AND	BP,NOT fBadSwitch
	MOV	AX,1
	SHL	AX,CL
	OR	BP,AX

out_tokenp:
	POP	CX
	POP	DI
	POP	ES

ASSUME	ES:NOTHING
out_token:
	mov	al,0
	stosb				; null at the end
	pop	di			; restore token buffer pointer
	popf
	clc				; clear carry flag
	return

move_char:
	stosb				; store char in token buffer
	inc	cx			; increment char count
	inc	[ELCNT] 		; increment element count for * substi
	return

TRANCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\copy.asm ===
page ,132
	title	COMMAND COPY routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

comment % -----------------------------------------------------------------

;***	COPY.ASM

Source files:  copy.asm, copypr1.asm, copypr2.asm


;***	MODIFICATION HISTORY

11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
11/02/83 EE  Commented out the code in CPARSE which added drive designators
	     to tokens which begin with path characters so that PARSELINE
	     will work correctly.
11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
	     individual tokens.  That distinction is no longer needed for
	     FOR loop processing.
11/17/83 EE  CPARSE upper case conversion is now flag dependent.  Flag is
	     1 when Cparse is called from COPY.
11/17/83 EE  Took out the comment chars around code described in 11/04/83
	     mod.  It now is conditional on flag like previous mod.
11/21/83 NP  Added printf
12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
	     be added to a token.
05/30/84 MZ  Initialize all copy variables.  Fix confusion with destclosed
	     NOTE: DestHand is the destination handle.  There are two
	     special values:  -1 meaning destination was never opened and
	     0 which means that the destination has been openned and
	     closed.
06/01/84 MZ  Above reasoning totally specious.  Returned things to normal
06/06/86 EG  Change to fix problem of source switches /a and /b getting
	     lost on large and multiple file (wildcard) copies.
06/09/86 EG  Change to use xnametrans call to verify that source and
	     destination are not equal.

06/24/90 DO  If the destination of a file concatenation is the same as
	     first source file AND we run out of disk space before
	     completing the concatenation, restore the first source
	     file as best we can.  See SeekEnd and CopErr.  Bug #859.

M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
		instead of compatibility mode. This gives lesser sharing
		violations when files are opened for read on a copy.

% -------------------------------------------------------------------------

	.xlist
	.xcref

	include comsw.asm
	include dossym.inc
	include syscall.inc
	include sf.inc
	include comseg.asm
	include comequ.asm
	.list
	.cref


DATARES 	segment public byte
	extrn	VerVal:word
DATARES 	ends

TRANDATA 	segment public byte
	extrn	BadCd_Ptr:word
	extrn	Copied_Ptr:word
	extrn	Extend_Buf_Ptr:word
	extrn	Extend_Buf_Sub:byte
	extrn	File_Name_Ptr:word
	extrn	InBDev_Ptr:word    
	extrn	Msg_Disp_Class:byte
	extrn	Overwr_Ptr:word
TRANDATA	ends

TRANSPACE	segment public byte
	extrn	AllSwitch:word
	extrn	ArgC:byte
	extrn	Ascii:byte
	extrn	Binary:byte
	extrn	BytCnt:word
	extrn	CFlag:byte
	extrn	Comma:byte
	extrn	Concat:byte
	extrn	Copy_Num:word	   
	extrn	CpDate:word
	extrn	CpTime:word
	extrn	CpyFlag:byte	   
	extrn	CurDrv:byte
	extrn	DestBuf:byte
	extrn	DestClosed:byte
	extrn	DestFcb:byte
	extrn	DestFcb2:byte
	extrn	DestHand:word
	extrn	DestInfo:byte
	extrn	DestIsDir:byte
	extrn	DestSiz:byte
	extrn	DestSwitch:word
	extrn	DestTail:word
	extrn	DestVars:byte
	extrn	DirBuf:byte
	extrn	Expand_Star:byte
	extrn	FileCnt:word
	extrn	FirstDest:byte
	extrn	FrstSrch:byte
	extrn	Inexact:byte
	extrn	MelCopy:byte
	extrn	MelStart:word
	extrn	Msg_Flag:byte	   
	extrn	NoWrite:byte
	extrn	NxtAdd:word
	extrn	ObjCnt:byte
	extrn	OCtrlZ:byte
	extrn	OFilePtr_Hi:word
	extrn	OFilePtr_Lo:word
	extrn	One_Char_Val:byte  
	extrn	Parse_Last:word    
	extrn	Plus:byte
	extrn	Plus_Comma:byte
	extrn	RdEof:byte
	extrn	ResSeg:word
	extrn	ScanBuf:byte
	extrn	SDirBuf:byte
	extrn	SrcBuf:byte
	extrn	SrcHand:word
	extrn	SrcInfo:byte
	extrn	SrcIsDev:byte
	extrn	SrcPt:word
	extrn	SrcSiz:byte
	extrn	SrcTail:word
	extrn	SrcVars:byte
	extrn	SrcXName:byte
	extrn	StartEl:word
	extrn	String_Ptr_2:word
	extrn	TermRead:byte
	extrn	Tpa:word
	extrn	UserDir1:byte
	extrn	Written:word
TRANSPACE	ends




;***	COPY CODE

TRANCODE	segment public byte

	extrn	CError:near
	extrn	CopErr:near
	extrn	TCommand:near

	public	Copy

	assume	cs:TRANGROUP,ds:TRANGROUP,es:TRANGROUP,ss:NOTHING

	break	Copy

Copy:
	assume	ds:TRANGROUP,es:TRANGROUP

; 	Initialize internal variables.

	xor	ax,ax		; AX = 0
	mov	Copy_Num,ax	; # files copied (destinations) = 0
	mov	SrcPt,ax	; cmd line ptr for source scan = 0
	mov	SrcTail,ax	; ptr to last element of source pathname = 0
	mov	CFlag,al	; 'destination file created' = false
	mov	NxtAdd,ax	; ptr into TPA buffer = 0
	mov	DestSwitch,ax	; destination switches = none
	mov	StartEl,ax	; CParse ptr to last pathname element = 0
	mov	DestTail,ax	; ptr to last element of dest pathname = 0
	mov	DestClosed,al	; 'destination file closed' = false
	mov	DestSiz,al	; length of destination pathname = 0
	mov	SrcSiz,al	; length of source pathname = 0
	mov	DestInfo,al	; destination pathname flags = none
	mov	SrcInfo,al	; source pathname flags = none
	mov	Inexact,al	; 'inexact copy' = false
	mov	DestVars,al	; 'dest pathname is directory' = false
	mov	SrcVars,al	; 'source pathname is directory' = false
	mov	UserDir1,al	; saved working directory = null
	mov	NoWrite,al	; 'no write' (source = dest) = false
	mov	RdEof,al	; 'read end of file' = false
	mov	SrcHand,ax	; source handle = 0
	mov	CpDate,ax	; copy date = 0
	mov	CpTime,ax	; copy time = 0
	mov	SrcIsDev,al	; 'source is device' = false
	mov	OCtrlZ,al	; 'Ctrl+Z removed from original' = false
	mov	OFilePtr_Lo,ax
	mov	OFilePtr_Hi,ax	; original destination file ptr = null
	mov	TermRead,al	; 'terminate read' = false
	mov	Comma,al	; '"+,," found' = false
	mov	Plus_Comma,al	; '"+,," found last time' = false (?)
	mov	Msg_Flag,al	;AN022; 'non-utility msg issued' = false
	mov	AllSwitch,ax	; all switches = none
	mov	ArgC,al		; source/dest argument count = 0
	mov	Plus,al		; '"+" in command line' = false
	mov	Binary,al	; 'binary copy' = false
	mov	Ascii,al	; 'ascii copy' = false
	mov	FileCnt,ax	; # files copied (destinations) = 0
	mov	Written,ax	; 'destination written to' = false
	mov	Concat,al	; 'concatenating' = false
	mov	MelCopy,al	; 'Mel Hallerman copy' = false
	mov	MelStart,ax	; Mel Hallerman cmd line ptr = 0

;	Initialize buffers with double-nulls.

	mov	word ptr ScanBuf,ax
	mov	word ptr DestBuf,ax
	mov	word ptr SrcBuf,ax 
	mov	word ptr SDirBuf,ax
	mov	word ptr DirBuf,ax 
	mov	word ptr DestFcb,ax

	mov	ObjCnt,al	; # CParse cmd-line objects found = 0

	dec	ax		; AX = 0FFFFh
	mov	DestHand,ax	; destination handle = 'never opened'
	mov	FrstSrch,al	; 'first search for source' = true
	mov	FirstDest,al	; 'first time for dest' = true
	mov	DestIsDir,al	; 'haven't analyzed destination'

	mov	si,81h		; SI = ptr to command line
	mov	bl,PLUS_CHR	; BL = special delimiter = "+"
	inc	Expand_Star	; CParse 'expand * to ?s' = true
	mov	CpyFlag,1	; CParse 'called from COPY' = true


;*	Scan the command line for destination information.

DestScan:
	xor	bp,bp				; BP = switch flag accumulator
	mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to pathname buf
	mov	Parse_Last,si			;AN018; save cmd line ptr
	invoke	CParse				; parse next object
	pushf					; save CParse flags
	inc	ObjCnt				; count object

	test	bh,80h
	jz	@f			; no "+" delimiter
	mov	Plus,1			; "+" delimiter occurred
@@:
	test	bh,1
	jz	TestP2			; not a switch

;	Found a switch.

	test	bp,SwitchV		;AN038; Verify requested?
	jz	Not_SlashV		;AN038; No - set the switch
	test	AllSwitch,SwitchV	;AN038; Verify already entered?
	jz	Not_SlashV		;AN038; No - set the switch
;AD018; or	AllSwitch,FBadSwitch	;AN038; Set up bad switch
	or	bp,FBadSwitch		;AN018; Set up bad switch

Not_SlashV:				;AN038;
	or	DestSwitch,bp	 	; assume destination
	or	AllSwitch,bp		; keep tabs on all switches

	test	bp,not SwitchCopy	;AN018; Bad switch?
	jz	Not_Bad_Switch		;AN018; Switches are okay
	popf				;AN018; fix up stack
	mov	ax,BadSwt_ptr		;AN018; get "Invalid switch" message number
	invoke	Setup_Parse_Error_Msg	;AN018; setup to print the message
	jmp	CError			;AC018; exit

Not_Bad_Switch: 			;AN018; switch okay
	popf				; restore CParse flags
	jc	CheckDone		; found CR
	jmp	short DestScan		; continue scanning for destination

TestP2:
	popf				; restore CParse flags
	jc	CheckDone		; found CR

	test	bh,80h
	jnz	@f	 		; found a "+pathname" argument
	inc	ArgC			; count independent pathname args
@@:
	push	si				; save cmd line ptr
	mov	ax,StartEl			; AX = ptr to last path element
	mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to path string
	sub	ax,si				; AX = offset of last element
	mov	di,offset TRANGROUP:DestBuf	; DI = ptr to destination buf
	add	ax,di				; AX = ptr to last element in
						;  destination path buffer
	mov	DestTail,ax			; save ptr to last element
	mov	DestSiz,cl			; save path string length

	inc	cx			; CX = mov length (incl null)
	rep	movsb			; DestBuf = possible destination path
	mov	DestInfo,bh		; save CParse info flags
	mov	DestSwitch,0		; clear destination switches
	pop	si			; SI = ptr into cmd line again
	jmp	DestScan		;AC018; continue scanning for dest

CheckDone:

;	We reached the CR.  The destination scan is finished.

;	Disallow "copy file1+" as file overwriting itself.
;
;	(Note that "copy file1+file2+" will be accepted, and
;	equivalent to "copy file1+file2".)

;	Bugbug:  it looks like "copy /x file1+" would slip
;	through this check, since the switch would count
;	as another object in ObjCnt.

	cmp	Plus,1			; "+" with
	jne	cdCont
	cmp	ArgC,1			; one arg,
	jne	cdCont
	cmp	ObjCnt,2		; two objects..
	jne	cdCont
	mov	dx,offset TRANGROUP:OverWr_ptr
	jmp	CopErr			; is file overwrite.

cdCont:	mov	al,Plus			; AL = '"+" occurred'
	mov	Concat,al		; if "+" occurred, we're concatenating
	shl	al,1
	shl	al,1
	mov	Inexact,al		; therefore making an inexact copy

	mov	al,ArgC			; AL = # independent arguments
	or	al,al
	jnz	Try_Too_Many		; more than 0 args; check if too many

	mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
	mov	Extend_Buf_Ptr,LessArgs_Ptr	; set msg # "param missing"
	jmp	short CError_ParseJ		; take parse error exit

Try_Too_Many:
	cmp	al,2
	jbe	ACountOk			; <= 2 arguments - ok

	mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
	mov	Extend_Buf_Ptr,MoreArgs_Ptr	; set msg # "too many params"
CError_ParseJ:
	mov	Msg_Disp_Class,PARSE_MSG_CLASS	; parse error message
CError4J:
	jmp	CError				; command error exit


ACountOk:
	mov	bp,offset TRANGROUP:DestVars	; BP = base of dest variables

;	Bugbug:  use of BP without segment override implies SS.
;	SS is implicitly assumed to point at TRANGROUP.

	cmp	al,1
	jne	Got2Args		; we have 2 arguments

;	Only one independent pathname argument on command line.
;	Set destination to d:*.*, where d: is current drive.

;	Bugbug:  but is this appropriate for "copy x:file1+x:file2"?
;	The two files would be appended as d:file1, rather than x:file1.

	mov	al,CurDrv		; AL = current drive (0 = A)
	add	al,CAPITAL_A		; AL = current drive letter
	mov	ah,':'			; AX = "d:"
	mov	[bp].siz,2		; pathname length = 2

	mov	di,offset TRANGROUP:DestBuf	; ES:DI = ptr to dest path buf
	stosw					; store "d:"

	mov	DestSwitch,0		; clear destination switches
	mov	[bp].info,2		; mark destination 'wildcard present'
	mov	[bp].isdir,0		; mark destination 'not a directory'
	invoke	SetStars		; add wildcards

Got2Args:

;	If destination pathname is "d:", add full wildcard filename

	cmp	[bp].siz,2
	jne	NotShortDest		; not two chars, can't be "d:"

	mov	al,':'
	cmp	destbuf+1,al
	jne	NotShortDest		; it's just a 2-character filename

	or	[bp].info,2		; mark destination 'wildcard present'
	mov	di,offset TRANGROUP:DestBuf+2
					; ES:DI = ptr after "d:"
	mov	[bp].isdir,0		; mark destination 'not a directory'
	invoke	SetStars		; add wildcards

NotShortDest:

;	If destination pathname ends with "\", try to make
;	sure it's "d:\".

	mov	di,[bp].ttail		; DI = ptr to last path element
	cmp	byte ptr [di],0
	jne	ChkSwtches		; not a null, so last char not "\"

	mov	dx,offset TRANGROUP:BadCD_Ptr	; DX = ptr to msg block
	mov	al,':'
	cmp	byte ptr [di-2],al
	jne	CError4J		; it's not "d:\", exit with error msg
	mov	[bp].isdir,2		; destination 'is a directory'
	or	[bp].info,6		; destination wildcarded and contains
					;  path character
	invoke	SetStars		; add wildcards

ChkSwtches:

;AD018; mov	ax,[ALLSWITCH]
;AD018; test	ax,NOT SwitchCopy
;AD018; jz	NOT_BAD_SWITCH			;AN000; Switches are okay
;AD018; MOV	DX,OFFSET TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
;AD018; mov	Extend_Buf_ptr,BadSwt_ptr	;AN000; get "Invalid switch" message number
;AD018; jmp	short CERROR_PARSEJ		;AC000; Switch specified which is not known
;AD018; NOT_BAD_SWITCH:

;	We have enough information about the destination for now.

;	Turn on verify if requested.  Save the current verify flag.

	mov	ax,AllSwitch		; AX = all switch flags
	test	ax,SwitchV
	jz	NoVerif 		; no /v, no verify

	mov	ah,GET_VERIFY_ON_WRITE	; AH = 'Get Verify Flag'
	int	21h			; call DOS

	push	ds
	mov	ds,ResSeg
	assume	ds:RESGROUP
	xor	ah,ah
	mov	VerVal,ax		; save current verify flag
	pop	ds
	assume	ds:TRANGROUP
	mov	ax,(SET_VERIFY_ON_WRITE shl 8) or 1  ; AX = 'Set Verify Flag'
	int	21h				     ; call DOS

NoVerif:

;*	Scan for first source.

	xor	bp,bp			; BP = switch flags accumulator
	mov	si,81h			; SI = ptr into command line
	mov	bl,PLUS_CHR		; BL = special CParse delimiter = "+"
ScanFSrc:
	mov	di,offset TRANGROUP:ScanBuf	; DI = ptr to pathname buf
	invoke	CParse			; parse first source pathname
	test	bh,1			; switch?
	jnz	ScanFSrc		; yes, try again
	or	DestSwitch,bp 		; include copy-wide switches on dest

;	Set ascii copying mode if concatenating, unless /b is specified.

	test	bp,SWITCHB
	jnz	NoSetCAsc		; /b - explicit binary copy
	cmp	Concat,0
	je	NoSetCAsc		; we're not concatenating
	mov	Ascii,SWITCHA		; set ascii copy
NoSetCAsc:
	call	Source_Set		; set source variables
	call	FrstSrc			; set up first source copy
	jmp	FirstEnt		; jump into the copy loop




	public	EndCopy

EndCopy:

;*	End of the road.  Close destination, display # files
;	copied (meaning # destinations), and go back to main
;	transient COMMAND code.

	call	CloseDest
EndCopy2:
	mov	dx,offset TRANGROUP:Copied_Ptr
	mov	si,FileCnt
	mov	Copy_Num,si
	invoke	Std_PrintF
	jmp	TCommand		; stack could be messed up




SrcNonexist:

;*	Source doesn't exist.  If concatenating, ignore and continue.
;	Otherwise, say 'file not found' and quit.

	cmp	Concat,0
	jne	NextSrc 		; concatenating - go on to next source

;	Set up error message.

	mov	Msg_Disp_Class,EXT_MSG_CLASS	     ; extended error msg
	mov	dx,offset TRANGROUP:Extend_Buf_Ptr   ; DX = ptr to msg block
	mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND  ; 'file not found' msg#
	mov	String_Ptr_2,offset TRANGROUP:SrcBuf ; point at bad pathname
	mov	Extend_Buf_Sub,ONE_SUBST	     ; 1 substitution

	jmp	CopErr			; print msg and clean up




SourceProc:

;*	Preparatory processing for each source file.
;	Called at FrstSrc for first source file.

	call	Source_Set		; set source variables & ascii/binary
	cmp	Concat,0
	jne	LeaveCFlag		; concatenating - leave CFlag alone
FrstSrc:
	xor	ax,ax
	mov	CFlag,al		; 'destination not created'
	mov	NxtAdd,ax		; copy buffer ptr = 0
	mov	DestClosed,al		; 'destination not closed'
LeaveCFlag:
	mov	SrcPt,si			; save cmd-line ptr
	mov	di,offset TRANGROUP:UserDir1	; DI = ptr to buf for user's 
						;   current dir
	mov	bp,offset TRANGROUP:SrcVars	; BP = base of source variables
	invoke	BuildPath			; cd to source dir, figure
						;   out stuff about source
	mov	si,SrcTail			; SI = ptr to source filename
	return




NextSrc:

;*	Next source.  Come here after handling each pathname.
;	We're done unless there are additional source pathnames
;	to be appended.
;
;	Note that all files matching an ambiguous pathname
;	are processed before coming here.

	cmp	Plus,0
	jne	MoreCp			; copying "+" sources - keep going

EndCopyJ2:
	jmp	EndCopy 		; done copying

MoreCp:
	xor	bp,bp			; BP = switch flags accumulator
	mov	si,SrcPt		; SI = ptr to current pos'n in cmd line
	mov	bl,PLUS_CHR		; BL = special delimiter = "+"

ScanSrc:
	mov	di,offset TRANGROUP:ScanBuf	; DI = ptr to pathname buf
	invoke	CParse				; parse first source name
	jc	EndCopyJ2			; CR found - we're done

	test	bh,80h
	jz	EndCopyJ2		; no "+" delimiter - we're done

	test	bh,1
	jnz	ScanSrc 		; switch found - keep looking

;	ScanBuf contains the next source pathname.

	call	SourceProc		; prepare this source
	cmp	Comma,1 		;g  was +,, found last time?
	jne	NoStamp 		;g  no - try for a file
	mov	Plus_Comma,1		;g  yes - set flag
	jmp	SrcNonexist		;g  we know we won't find it

NoStamp:				;g
	mov	Plus_Comma,0		;g  reset +,, flag

FirstEnt:
;
;M047
; The only case we need to worry about is when the source is wildcarded and
;the destination is not. For this case, ConCat is not yet set to indicate
;concatenation. We check for this case.
;
;NB: This change has been backed out and replaced by M048. This is not the
;right place to do this check.
;

;	This is where we enter the loop with the first source.

	mov	di,FCB				; DI = ptr to FCB
	mov	ax,PARSE_FILE_DESCRIPTOR shl 8	; 'Parse Filename'
	int	21h				; call DOS

	cmp	byte ptr [si],0 	; did we parse the whole thing?
	jne	SrchDone		; no, error, simulate 'not found'

	mov	ax,word ptr SrcBuf	; AX = possible "d:"
	cmp	ah,':'
	je	@f			; AX = definite "d:"
	mov	al,'@'			; AL = drive 'letter' for current drive
@@:
	or	al,20h			; AL = lowercase drive letter
	sub	al,60h			; AL = drive id (0=current,1=A,..)
	mov	ds:FCB,al		; put drive id in FCB

;	FCB contains drive and filename to search.

	mov	ah,DIR_SEARCH_FIRST	; AH = 'Find First File'
	call	Search

SrchDone:
	pushf				; save flags from Search
	invoke	RestUDir1		; restore users current directory
	popf				; restore flags from search
	jz	@f			; found the source - continue
	jmp	SrcNonexist		; didn't find the source
@@:
	xor	al,al
	xchg	al,FrstSrch
	or	al,al
	jz	NextAmbig

SetNMel:
	mov	cx,12
	mov	di,offset TRANGROUP:SDirBuf
	mov	si,offset TRANGROUP:DirBuf
	rep	movsb			; save very first source name

NextAmbig:
	xor	al,al
	mov	NoWrite,al		; turn off nowrite
	mov	di,SrcTail
	mov	si,offset TRANGROUP:DirBuf + 1
	invoke	Fcb_To_Ascz		; SrcBuf has complete name

MelDo:
	cmp	Concat,0
	jne	ShowCpNam		; concatenating - show name
	test	SrcInfo,2		; wildcard - show name
	jz	DoRead

ShowCpNam:
	mov	dx,offset TRANGROUP:File_Name_Ptr
	invoke	Std_PrintF
	invoke	CrLf2

DoRead:
	call	DoCopy
	cmp	Concat,0
	jne	NoDClose		; concatenating - don't close dest

	call	CloseDest		; close current destination
	jc	NoDClose		; concatenating - dest not closed

	mov	CFlag,0			; 'destination not created'

NoDClose:
	cmp	Concat,0
	je	NoFlush			; not concatenating - don't flush

;	Concatenating - flush output between source files so LostErr
;	stuff works correctly.

	invoke	FlshFil
	test	MelCopy,0FFh
	jz	@f
	jmp	short DoMelCopy
@@:
NoFlush:
	call	SearchNext		; try next match
	jnz	NextSrcJ		; not found - finished with 
					;   this source spec
	mov	DestClosed,0		; 'destination not closed'
	jmp	NextAmbig		; do next ambig match




DoMelCopy:
	cmp	MelCopy,0FFh
	je	ContMel
	mov	si,SrcPt
	mov	MelStart,si
	mov	MelCopy,0FFh
ContMel:
	xor	bp,bp
	mov	si,SrcPt
	mov	bl,PLUS_CHR
ScanSrc2:
	mov	di,offset TRANGROUP:ScanBuf
	invoke	CParse
	test	bh,80h
	jz	NextMel 		; no "+" - go back to start

	test	bh,1
	jnz	ScanSrc2		; switch - keep scanning

	call	SourceProc
	invoke	RestUDir1
	mov	di,offset TRANGROUP:DestFcb2
	mov	ax,PARSE_FILE_DESCRIPTOR shl 8
	int	21h
	mov	bx,offset TRANGROUP:SDirBuf + 1
	mov	si,offset TRANGROUP:DestFcb2 + 1
	mov	di,SrcTail

	invoke	BuildName

	cmp	Concat,0
	je	MelDoJ			; not concatenating - continue

;	Yes, turn off nowrite because this part of the code 
;	is only reached after the first file has been dealt with.

	mov	NoWrite,0

MelDoJ:
	jmp	MelDo

NextSrcJ:
	jmp   NextSrc

NextMel:
	call	CloseDest
	xor	ax,ax
	mov	CFlag,al
	mov	NxtAdd,ax
	mov	DestClosed,al
	mov	si,MelStart
	mov	SrcPt,si
	call	SearchNext
	jz	SetNMelJ
	jmp	EndCopy2
SetNMelJ:
	jmp	SetNMel




SearchNext:
	mov	ah,DIR_SEARCH_NEXT
	test	SrcInfo,2
	jnz	Search			; do search-next if ambig
	or	ah,ah			; reset zero flag
	return

Search:
	push	ax
	mov	ah,SET_DMA
	mov	dx,offset TRANGROUP:DirBuf
	int	21h			; put result of search in dirbuf
	pop	ax			; restore search first/next command
	mov	dx,FCB
	int	21h			; Do the search
	or	al,al
	return




DoCopy:
	mov	si,offset TRANGROUP:SrcBuf	;g do name translate of source
	mov	di,offset TRANGROUP:SrcXName	;g save for name comparison
	mov	ah,XNAMETRANS			;g
	int	21h				;g

	mov	RdEof,0				; no EOF yet

	mov	ax,EXTOPEN shl 8		; open the file
;M046
; For reads, the sharing mode should be deny none so that any process can
;open this file again in any other sharing mode. This is mainly to allow
;multiple command.com's to access the same file without getting sharing
;violations
;
	mov	bx,DENY_NONE or READ_OPEN_MODE ; open mode for COPY ;M046
	xor	cx,cx				; no special files
	mov	dx,READ_OPEN_FLAG		; set up open flags
	int	21h

	jnc	OpenOk

;	Bogosity:  IBM wants us to issue Access Denied in this case.
;	They asked for it...

	jmp	short Error_On_Source 		;AC022; clean up and exit

OpenOk:
	mov	bx,ax				; save handle
	mov	SrcHand,bx			; save handle
	mov	ax,(FILE_TIMES shl 8)
	int	21h
	jc	Error_On_Source
	mov	CpDate,dx			; save date
	mov	CpTime,cx			; save time
	jmp	short No_Copy_Xa		; (xa copy code removed)


Error_On_Source:				;AN022; we have a BAD error
	invoke	Set_Ext_Error_Msg		;AN022; set up the error message
	mov	String_Ptr_2,offset TRANGROUP:SrcBuf ;AN022; get address of failed string
	mov	Extend_Buf_Sub,ONE_SUBST	;AN022; put number of subst in control block
	invoke	Std_EprintF			;AN022; print it
	cmp	SrcHand,0			;AN022; did we open the file?
	je	No_Close_Src			;AN022; no - don't close
	call	CloseSrc			;AN022; clean up
No_Close_Src:					;AN022;
	cmp	CFlag,0				;AN022; was destination created?
	je	EndCopyJ3			;AN022; no - just cleanup and exit
	jmp	EndCopy 			;AN022; clean up concatenation and exit
EndCopyJ3:					;AN022;
	jmp	EndCopy2			;AN022;

No_Copy_Xa:
	mov	bx,SrcHand			;AN022; get handle back
	mov	ax,(IOCTL shl 8)
	int	21h				; get device stuff
	and	dl,DEVID_ISDEV
	mov	SrcIsDev,dl			; set source info
	jz	CopyLp				; source not a device
	cmp	Binary,0
	je	CopyLp				; ascii device ok
	mov	dx,offset TRANGROUP:InBDev_Ptr	; cannot do binary input
	jmp	CopErr


CopyLp:
	mov	bx,SrcHand
	mov	cx,BytCnt
	mov	dx,NxtAdd
	sub	cx,dx				; compute available space
	jnz	GotRoom
	invoke	FlshFil
	cmp	TermRead,0
	jne	CloseSrc			; give up
	mov	cx,BytCnt
GotRoom:
	push	ds
	mov	ds,Tpa
	assume	ds:NOTHING
	mov	ah,READ
	int	21h
	pop	ds
	assume	ds:TRANGROUP
	jc	Error_On_Source 		;AC022; give up if error
	mov	cx,ax				; get count
	jcxz	CloseSrc			; no more to read
	cmp	SrcIsDev,0
	jne	NoTestA 			; is a device, ascii mode
	cmp	Ascii,0
	je	BinRead
NoTestA:
	mov	dx,cx
	mov	di,NxtAdd
	mov	al,1Ah
	push	es
	mov	es,Tpa
	repne	scasb				; scan for EOF
	pop	es
	jne	UseAll
	inc	RdEof
	inc	cx
UseAll:
	sub	dx,cx
	mov	cx,dx
BinRead:
	add	cx,NxtAdd
	mov	NxtAdd,cx
	cmp	cx,BytCnt			; is buffer full?
	jb	TestDev 			; if not, we may have found eof
	invoke	FlshFil
	cmp	TermRead,0
	jne	CloseSrc			; give up
	jmp	short CopyLp

TestDev:
	cmp	SrcIsDev,0
	je	CloseSrc			; if file then EOF
	cmp	RdEof,0
	je	CopyLp				; on device, go till ^Z
CloseSrc:
	mov	bx,SrcHand
	mov	ah,CLOSE
	int	21h
	return




CloseDest:

;	We are called to close the destination.
;	We need to note whether or not there is any internal data left
;	to be flushed out.

	cmp	DestClosed,0
	retnz				; don't double close
	mov	al,byte ptr DestSwitch
	invoke	SetAsc			; check for b or a switch 
	jz	BinClos			;   on destination
	mov	bx,NxtAdd
;
;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
;^Z, let's always flush out. This way if the ConCat flag changes, we will
;just return without appending a ^Z incorrectly for the first file(since we
;are concatenating now). Also, in case it is a single file copy, we will
;anyway write the ^Z out separately. The only drawback is that there is a
;performance overhead on single ASCII file copies which now always involve
;2 writes instead of 1 before. Is this really that important?
;
;M048;	cmp	bx,BytCnt		; is memory full?
;M048;	jne	PutZ

	invoke	TryFlush		; flush (and double-check for concat)
	je	NoConc
ConChng:				; concat flag changed on us
	stc
	return
NoConc:
	xor	bx,bx
PutZ:
	push	ds
	mov	ds,Tpa
	mov	word ptr [bx],1Ah	; add EOF mark (ctrl-Z)
	pop	ds
	inc	NxtAdd
	mov	NoWrite,0		; make sure our ^z gets written
	mov	ax,Written
	add	ax,NxtAdd
	jc	BinClos 		; > 1
	cmp	ax,1
	je	ForgetItJ		; Written = 0 NxtAdd = 1 (the ^Z)
BinClos:
	invoke	TryFlush
	jnz	ConChng
	cmp	Written,0
ForgetItJ:
	jne	No_Forget		; wrote something
	jmp	ForgetIt		; never wrote nothing
No_Forget:
	mov	bx,DestHand
	mov	cx,CpTime
	mov	dx,CpDate
	cmp	Inexact,0		; copy not exact?
	je	DoDClose		; if no, copy date & time
	mov	ah,GET_TIME
	int	21h
	shl	cl,1
	shl	cl,1			; left justify min in cl
	shl	cx,1
	shl	cx,1
	shl	cx,1			; hours to high 5 bits, min to 5-10
	shr	dh,1			; divide seconds by 2 (now 5 bits)
	or	cl,dh			; and stick into low 5 bits of cx
	push	cx			; save packed time
	mov	ah,GET_DATE
	int	21h
	sub	cx,1980
	xchg	ch,cl
	shl	cx,1			; year to high 7 bits
	shl	dh,1			; month to high 3 bits
	shl	dh,1
	shl	dh,1
	shl	dh,1
	shl	dh,1			; most sig bit of month in carry
	adc	ch,0			; put that bit next to year
	or	dl,dh			; or low three of month into day
	mov	dh,ch			; get year and high bit of month
	pop	cx			; get time back
DoDClose:
	cmp	bx,0
	jle	CloseDone
	mov	ax,(FILE_TIMES shl 8) or 1
	int	21h			; set date and time
	jc	Cleanup_Err		;AN022; handle error

;	See if the destination has *anything* in it.
;	If not, just close and delete it.

	mov	ax,(LSEEK shl 8) + 2	; seek to EOF
	xor	dx,dx
	mov	cx,dx
	int	21h

;	DX:AX is file size

	or	dx,ax
	pushf
	mov	ax,(IOCTL SHL 8) + 0	; get the destination attributes
	int	21h
	push	dx			; save them away
	mov	ah,CLOSE
	int	21h
	pop	dx
	jnc	Close_Cont		;AN022; handle error on close
	popf				;AN022; get the flags back
Cleanup_Err: 				;AN022;
	call	CleanUpErr		;AN022; attempt to delete the target
	call	DestDelete		;AN022; attempt to delete the target
	jmp	short FileClosed	;AN022; close the file
Close_Cont:				;AN022; no error - continue
	popf
	jnz	CloseDone
	test	dx,80h			; is the destination a device?
	jnz	CloseDone		; yes, copy succeeded
	call	DestDelete
	jmp	short FileClosed
CloseDone:
	inc	FileCnt
FileClosed:
	inc	DestClosed
Ret50:
	clc
	return


ForgetIt:
	mov	bx,DestHand
	call	DoDClose		; close the dest
	call	DestDelete
	mov	FileCnt,0		; no files transferred
	jmp	Ret50


DestDelete:
	mov	dx,offset TRANGROUP:DestBuf
	mov	ah,UNLINK
	int	21h			; and delete it
	return




Source_Set	proc near

	push	si
	mov	ax,StartEl
	mov	si,offset TRANGROUP:ScanBuf	; adjust to copy
	sub	ax,si
	mov	di,offset TRANGROUP:SrcBuf
	add	ax,di
	mov	SrcTail,ax
	mov	SrcSiz,cl		; save its size
	inc	cx			; include the nul
	rep	movsb			; save this source
	mov	SrcInfo,bh		; save info about it
	pop	si
	mov	ax,bp			; switches so far
	invoke	SetAsc			; set a,b switches accordingly
	invoke	Switch			; get any more switches on this arg
	invoke	SetAsc			; set
	return

Source_Set	endp




;****************************************************************
;*
;* ROUTINE:	CleanupErr
;*
;* FUNCTION:	Issues extended error message for destination
;*		if not alreay issued
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	none
;*
;****************************************************************

CleanupErr	proc	near			;AN022;

	cmp	Msg_Flag,0			;AN022; have we already issued a message?
	jnz	CleanupErr_Cont 		;AN022; yes - don't issue duplicate error
	invoke	Set_Ext_Error_Msg		;AN022; set up error message
	mov	String_Ptr_2,offset TRANGROUP:DestBuf ;AN022; get address of failed string
	mov	Extend_Buf_Sub,ONE_SUBST	;AN022; put number of subst in control block
	invoke	Std_EPrintF			;AN022; issue the error message

CleanupErr_Cont:				;AN022;
	ret					;AN022; return to caller

CleanupErr	endp				;AN022;


TRANCODE	ends
		end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\copypr2.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;M031	SR 10/11/90    Bug #3069. Use deny write sharing mode to open files
;		      	instead of compatibility mode. This gives lesser
;			sharing violations when files are opened for read on
;			a copy operation.
;
;




	.xlist
	.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include sf.inc
	include comseg.asm
	include comequ.asm
	.list
	.cref


TRANDATA	segment public byte
	extrn	FulDir_Ptr:word 	;AN052;
TRANDATA ends

TRANSPACE	segment public byte
	extrn	Ascii:byte
	extrn	Binary:byte
	extrn	Concat:byte
	extrn	DestBuf:byte
	extrn	DestFcb:byte
	extrn	DestInfo:byte
	extrn	DestIsDir:byte
	extrn	DestTail:word
	extrn	DestVars:byte
	extrn	DirBuf:byte
	extrn	DirChar:byte
	extrn	FirstDest:byte
	extrn	Inexact:byte
	extrn	MelCopy:byte
	extrn	NxtAdd:word
	extrn	Plus:byte
	extrn	SDirBuf:byte
	extrn	SrcInfo:byte
	extrn	SrcXName:byte
	extrn	Tpa:word
	extrn	TrgXName:byte
	extrn	UserDir1:byte
TRANSPACE	ends

TRANCODE	segment public byte

	extrn	BadPath_Err:near	;AN022;
	extrn	CopErr:near		;AN052;
	extrn	Extend_Setup:near	;AN022;

	public	BuildPath
	public	SetStars
	public	SetAsc

ASSUME	cs:TRANGROUP,ds:TRANGROUP,es:TRANGROUP,ss:NOTHING




;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
;
;	Given switch vector in AX,
;	  Set Ascii flag if /a is set
;	  Clear Ascii flag if /b is set
;	  Binary set if /b specified
;	  Leave Ascii unchanged if neither or both are set
; 	Also sets Inexact if Ascii is ever set. 
;	AL = Ascii on exit, flags set
;

SetAsc:

	and	al,SWITCHA+SWITCHB	; AL = /a, /b flags
	jpe	LoadSw			; even parity - both or neither
	push	ax
	and	al,SWITCHB
	mov	Binary,al
	pop	ax
	and	al,SWITCHA
	mov	Ascii,al
	or	Inexact,al

LoadSw:
	mov	al,Ascii
	or	al,al
	return




;***	BuildDest

	public BuildDest

BuildDest:

	cmp	DestIsDir,-1
	jne	KnowAboutDest			; figuring already done
	mov	di,offset TRANGROUP:UserDir1
	mov	bp,offset TRANGROUP:DestVars
	call	BuildPath
	invoke	RestUDir1

;	We now know all about the destination.

KnowAboutDest:
	xor	al,al
	xchg	al,FirstDest
	or	al,al
	jnz	FirstDst
	jmp	NotFirstDest

FirstDst:

;	Create an fcb of the original dest.

	mov	si,DestTail			
	mov	di,offset TRANGROUP:DestFcb
	mov	ax,PARSE_FILE_DESCRIPTOR shl 8
	int	21h
	cmp	byte ptr [si],0
	je	GoodParse
;AD052; mov	byte ptr [di+1],"|"             ; must be illegal file name character
	mov	dx,offset TRANGROUP:FulDir_Ptr	;AN052; issue "file creation error"
	jmp	CopErr				;AN052;

GoodParse:
	mov	ax,word ptr DestBuf		; AX = possible "d:"
	cmp	ah,':'
	je	@f
	mov	al,'@'
@@:
;	AX = "d:" for following FCB drive computation

	mov	cl,Ascii		; CL = saved Ascii flag
	or	al,20h
	sub	al,60h
	mov	DestFcb,al		; store drive # in FCB

;*	Figure out what copy mode we're in.
;	Letters stand for unambiguous, * for ambiguous pathnames.
;	+n stands for additional sources delimited by +'s.
;
;	copy a b	not concatenating
;	copy a *	not concatenating
;	copy * a	concatenating
;	copy * *	not concatenating
;	copy a+n b	concatenating
;	copy *+n a	concatenating
;	copy *+n *	concatenating, Mel Hallorman style

;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file..  Why?
;		 copy a.b+*.a *.t  picks up all *.a files.

	mov	al,DestInfo		; AL = destination CParse flags
	mov	ah,SrcInfo		; AH = source CParse flags
	and	ax,0202h		; AH,AL = source,dest wildcard flags
	or	al,al
	jz	NotMelCopy		; no destination wildcard

;	Destination is wildcarded.

	cmp	al,ah
	jne	NotMelCopy		; no source wildcard

;	Source and destination are both wildcarded.

	cmp	Plus,0
	je	NotMelCopy		; no +'s in source

;	Source and destination are wildcarded, and source includes +'s.
;	It's Mel Hallorman copy time.

	inc	MelCopy			; 'Mel copy' = true
	xor	al,al
	jmp	short SetConc

NotMelCopy:
	xor	al,2		; AL=0 -> ambiguous destination, 2 otherwise
	and	al,ah
	shr	al,1		; AL=1 -> ambiguous source, unambiguous dest
				;   (implies concatenation)

SetConc:
	or	al,Plus		; "+" always infers concatenation

;	Whew.  AL = 1 if concatenating, 0 if not.

	mov	Concat,al
	shl	al,1
	shl	al,1
	mov	Inexact,al		; concatenation -> inexact copy
	cmp	Binary,0
	jne	NotFirstDest		; explicit binary copy

	mov	Ascii,al		; otherwise, concatenate in ascii mode
	or	cl,cl
	jnz	NotFirstDest		; Ascii flag set before, data read correctly
	or	al,al
	jz	NotFirstDest		; Ascii flag did not change state

;	At this point there may already be binary read data in the read
;	buffer.  We need to find the first ^Z (if there is one) and trim the
;	amount of data in the buffer correctly.

	mov	cx,NxtAdd
	jcxz	NotFirstDest		; no data, everything ok
	mov	al,1Ah
	push	es
	xor	di,di
	mov	es,Tpa
	repne	scasb			; scan for EOF
	pop	es
	jne	NotFirstDest		; no ^z in buffer, everything ok
	dec	di			; point at ^z
	mov	NxtAdd,di		; new buffer length

NOTFIRSTDEST:
	mov	bx,offset trangroup:DIRBUF+1	; Source of replacement chars
	cmp	CONCAT,0
	jz	GOTCHRSRC			; Not a concat
	mov	bx,offset trangroup:SDIRBUF+1	; Source of replacement chars

GOTCHRSRC:
	mov	si,offset trangroup:DESTFCB+1	; Original dest name
	mov	di,DESTTAIL			; Where to put result

public buildname
BUILDNAME:

ifdef DBCS					; ### if DBCS ###

	mov	cx,8
	call	make_name
	cmp	byte ptr [si],' '
	jz	@f				; if no extention
	mov	al,dot_chr
	stosb
	mov	cx,3
	call	make_name
@@:
	xor	al,al
	stosb					; nul terminate
	return

else						; ### if Not DBCS ###

	mov	cx,8

BUILDMAIN:
	lodsb
	cmp	al,'?'
	jnz	NOTAMBIG
	mov	al,byte ptr [BX]

NOTAMBIG:
	cmp	al,' '
	jz	NOSTORE
	stosb

NOSTORE:
	inc	bx
	loop	BUILDMAIN
	mov	cl,3
	mov	al,' '
	cmp	byte ptr [SI],al
	jz	ENDDEST 			; No extension
	mov	al,dot_chr
	stosb

BUILDEXT:
	lodsb
	cmp	al,'?'
	jnz	NOTAMBIGE
	mov	al,byte ptr [BX]

NOTAMBIGE:
	cmp	al,' '
	jz	NOSTOREE
	stosb

NOSTOREE:
	inc	bx
	loop	BUILDEXT
ENDDEST:
	xor	al,al
	stosb					; NUL terminate
	return

endif						; ### end if Not DBCS ###


ifdef DBCS				; ### if DBCS ###
make_name:
	mov	ah,0			; reset DBCS flag
	mov	dh,cl			; save length to do
mkname_loop:
	cmp	ah,1			; if it was lead byte
	jz	mkname_dbcs
	mov	ah,0			; reset if it was single or tail byte
	mov	al,[bx]			; get source char
	invoke	testkanj
	jz	mkname_load		; if not lead byte
mkname_dbcs:
	inc	ah			; set dbcs flag
mkname_load:
	lodsb				; get raw char
	cmp	al,'?'
	jnz	mkname_store		; if not '?'
	cmp	ah,0
	jz	mkname_conv		; if source is single
	cmp	ah,1
	jnz	mkname_pass		; if source is not lead
	cmp	cl,dh
	jnz	mkname_lead		; if this is not 1st char
	cmp	byte ptr [si],' '
	jz	mkname_double		; if this is the end
mkname_lead:
	cmp	byte ptr [si],'?'
	jnz	mkname_pass		; if no '?' for tail byte
	cmp	cx,1
	jbe	mkname_pass		; if no room for tail byte
mkname_double:
	mov	al,[bx]
	stosb
	inc	bx
	inc	si
	dec	cx
	inc	ah			; tail byte will be loaded
mkname_conv:
	mov	al,[bx]
mkname_store:
	cmp	al,' '
	jz	mkname_pass
	stosb				; store in destination
mkname_pass:
	inc	bx
	loop	mkname_loop
	return
endif					; ### end if DBCS ###

BUILDPATH:
	test	[BP.INFO],2
	jnz	NOTPFILE			; If ambig don't bother with open
	mov	dx,bp
	add	dx,BUF				; Set DX to spec

	push	di				;AN000;
	MOV	AX,EXTOPEN SHL 8		;AC000; open the file
	mov	bx,DENY_NONE or READ_OPEN_MODE	; open mode for COPY ;M046
	xor	cx,cx				;AN000; no special files
	mov	si,dx				;AN030; get file name offset
	mov	dx,read_open_flag		;AN000; set up open flags
	INT	21h
	pop	di				;AN000;
	jnc	pure_file			;AN022; is pure file
	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_file_not_found 	;AN022; if file not found - okay
	jz	notpfile			;AN022;
	cmp	ax,error_path_not_found 	;AN022; if path not found - okay
	jz	notpfile			;AN022;
	cmp	ax,error_access_denied		;AN022; if access denied - okay
	jz	notpfile			;AN022;
	jmp	extend_setup			;AN022; exit with error

pure_file:
	mov	bx,ax				; Is pure file
	mov	ax,IOCTL SHL 8
	INT	21h
	mov	ah,CLOSE
	INT	21h
	test	dl,devid_ISDEV
	jnz	ISADEV				; If device, done
	test	[BP.INFO],4
	jz	ISSIMPFILE			; If no path seps, done

NOTPFILE:
	mov	dx,word ptr [BP.BUF]
	cmp	dl,0				;AN034; If no drive specified, get
	jz	set_drive_spec			;AN034;    default drive dir
	cmp	dh,':'
	jz	DRVSPEC5

set_drive_spec: 				;AN034;
	mov	dl,'@'

DRVSPEC5:
	or	dl,20h
	sub	dl,60h				; A = 1
	invoke	SAVUDIR1
	jnc	curdir_ok			;AN022; if error - exit
	invoke	get_ext_error_number		;AN022; get the extended error
	jmp	extend_setup			;AN022; exit with error

curdir_ok:					;AN022;
	mov	dx,bp
	add	dx,BUF				; Set DX for upcomming CHDIRs
	mov	bh,[BP.INFO]
	and	bh,6
	cmp	bh,6				; Ambig and path ?
	jnz	CHECKAMB			; jmp if no
	mov	si,[BP.TTAIL]
	mov	bl,':'
	cmp	byte ptr [si-2],bl
	jnz	KNOWNOTSPEC
	mov	[BP.ISDIR],2			; Know is d:/file
	jmp	short DOPCDJ

KNOWNOTSPEC:
	mov	[BP.ISDIR],1			; Know is path/file
	dec	si				; Point to the /

DOPCDJ:
	jmp	DOPCD				;AC022; need long jump

CHECKAMB:
	cmp	bh,2
	jnz	CHECKCD

ISSIMPFILE:
ISADEV:
	mov	[BP.ISDIR],0			; Know is file since ambig but no path
	return

CHECKCD:
	invoke	SETREST1
	mov	ah,CHDIR
	INT	21h
	jc	NOTPDIR
	mov	di,dx
	xor	ax,ax
	mov	cx,ax
	dec	cx

Kloop:						;AN000;  3/3/KK
	MOV	AL,ES:[DI]			;AN000;  3/3/KK
	INC	DI				;AN000;  3/3/KK
	OR	AL,AL				;AN000;  3/3/KK
	JZ	Done				;AN000;  3/3/KK
	xor	ah,ah				;AN000;  3/3/KK
	invoke	Testkanj			;AN000;  3/3/KK
	JZ	Kloop				;AN000;  3/3/KK
	INC	DI				;AN000;  3/3/KK
	INC	AH				;AN000;  3/3/KK
	jmp	Kloop				;AN000;  3/3/KK

Done:						;AN000;  3/3/KK
	dec	di
	mov	al,DIRCHAR
	mov	[bp.ISDIR],2			; assume d:/file
	OR	AH, AH				;AN000; 3/3/KK
	JNZ	Store_pchar			;AN000; 3/3/KK	 this is the trailing byte of ECS code
	cmp	al,[di-1]
	jz	GOTSRCSLSH

Store_pchar:					;AN000; 3/3/KK
	stosb
	mov	[bp.ISDIR],1			; know path/file

GOTSRCSLSH:
	or	[bp.INFO],6
	call	SETSTARS
	return


NOTPDIR:
	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_path_not_found 	;AN022; if path not found - okay
	jz	notpdir_try			;AN022;
	cmp	ax,error_access_denied		;AN022; if access denied - okay
	jnz	extend_setupj			;AN022; otherwise - exit error

notpdir_try:					;AN022;
	mov	[bp.ISDIR],0			; assume pure file
	mov	bh,[bp.INFO]
	test	bh,4
	retz					; Know pure file, no path seps
	mov	[bp.ISDIR],2			; assume d:/file
	mov	si,[bp.TTAIL]
	cmp	byte ptr [si],0
	jz	BADCDERRJ2			; Trailing '/'
	mov	bl,dot_chr
	cmp	byte ptr [si],bl
	jz	BADCDERRJ2			; If . or .. pure cd should have worked
	mov	bl,':'
	cmp	byte ptr [si-2],bl
	jz	DOPCD				; Know d:/file
	mov	[bp.ISDIR],1			; Know path/file
	dec	si				; Point at last '/'

DOPCD:
	xor	bl,bl
	xchg	bl,[SI] 			; Stick in a NUL
	invoke	SETREST1
	CMP	DX,SI				;AN000;  3/3/KK
	JAE	LookBack			;AN000;  3/3/KK
	PUSH	SI				;AN000;  3/3/KK
	PUSH	CX				;AN000;  3/3/KK
	MOV	CX,SI				;AN000;  3/3/KK
	MOV	SI,DX				;AN000;  3/3/KK

Kloop2: 					;AN000;  3/3/KK
	LODSB					;AN000;  3/3/KK
	invoke	TestKanj			;AN000;  3/3/KK
	jz	NotKanj4			;AN000;  3/3/KK
	LODSB					;AN000;  3/3/KK
	CMP	SI,CX				;AN000;  3/3/KK
	JB	Kloop2				;AN000;  3/3/KK
	POP	CX				;AN000;  3/3/KK
	POP	SI				;AN000;  3/3/KK
	JMP	SHORT DoCdr			;AN000;  3/3/KK  Last char is ECS code, don't check for
						;		 trailing path sep
NotKanj4:					;AN000;  3/3/KK
	CMP	SI,CX				;AN000;  3/3/KK
	JB	Kloop2				;AN000;  3/3/KK
	POP	CX				;AN000;  3/3/KK
	POP	SI				;AN000;  3/3/KK

LookBack:					;AN000;  3/3/KK
	CMP	BL,[SI-1]			; if double slash, then complain.
	JZ	BadCDErrJ2

DoCdr:						;AN000;  3/3/KK
	mov	ah,CHDIR
	INT	21h
	xchg	bl,[SI]
	retnc
	invoke	get_ext_error_number		;AN022; get the extended error

EXTEND_SETUPJ:					;AN022;
	JMP	EXTEND_SETUP			;AN022; go issue the error message

BADCDERRJ2:
	jmp	badpath_err			;AC022; go issue path not found message

SETSTARS:
	mov	[bp.TTAIL],DI
	add	[bp.SIZ],12
	mov	ax,dot_qmark
	mov	cx,8
	rep	stosb
	xchg	al,ah
	stosb
	xchg	al,ah
	mov	cl,3
	rep	stosb
	xor	al,al
	stosb
	return

PUBLIC CompName
COMPNAME:

	mov	si,offset trangroup:DESTBUF	;g do name translate of target
	mov	di,offset trangroup:TRGXNAME	;g save for name comparison
	mov	ah,xnametrans			;g
	int	21h			;g

	MOV	si,offset trangroup:SRCXNAME	;g get name translate of source
	MOV	di,offset trangroup:TRGXNAME	;g get name translate of target


	invoke	STRCOMP

	return

TRANCODE ENDS
	 END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\dir.asm ===
page	,132
	title	DIR Internal Command
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;***	DIR.ASM - DIR internal command

comment	% =================================================================

This module replaces TCMD1A.ASM.  The old module was titled 
"PART4 COMMAND Transient routines".

From residual documentation, I surmise that TCMD.ASM originally
contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
VER.  The file seems to have been successively split:

  TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B

TCMD1A.ASM contained only the DIR command.

Usage:
------

DIR <filespec> /w /p /b /s /l /c /o<sortorder> /a<attriblist>

DIR /?


<filespec> may include any or none of:  drive; directory path;
           wildcarded filename.  If drive or directory path are
	   omitted, the current defaults are used.  If the
	   file name or extension is omitted, wildcards are
	   assumed.

/w	Wide listing format.  Files are displayed in compressed
	'name.ext' format.  Subdirectory files are enclosed in
	brackets, '[dirname]'.

/p	Paged, or prompted listing.  A screenful is displayed
	at a time.  The name of the directory being listed appears
	at the top of each page.

	Bugbug:  pages nead to be uniform length..?

/b	Bare listing format.  Turns off /w or /p.  Files are 
	listed in compressed 'name.ext' format, one per line,
	without additional information.  Good for making batch
	files or for piping.  When used with /s, complete
	pathnames are listed.

/s	Descend subdirectory tree.  Performs command on current
	or specified directory, then for each subdirectory below
	that directory.  Directory header and footer is displayed
	for each directory where matching files are found, unless
	used with /b.  /b suppresses headers and footers.

	Tree is explored depth first, alphabetically within the
	same level.

	Bugbug:  hidden directories aren't searched.

/l	Display file names, extensions and paths in lowercase.	;M010

/c	Display file compression ratio, if the file is on a MagicDrv
	compressed volume.

/o	Sort order.  /o alone sorts by default order (dirs-first, name,
	extension).  A sort order may be specified after /o.  Any of
	the following characters may be used: nedsgc (name, extension,
	date/time, size, group-dirs-first, compression ratio).	Placing
	a '-' before any letter causes a downward sort on that field.
	E.g., /oe-d means sort first by extension in alphabetical order,
	then within each extension sort by date and time in reverse
	chronological order.

/a	Attribute selection.  Without /a, hidden and system files
	are suppressed from the listing.  With /a alone, all files
	are listed.  An attribute list may follow /a, consisting of
	any of the following characters:  hsdar (hidden, system,
	directory, archive, read-only).  A '-' before any letter
	means 'not' that attribute.  E.g., /ar-d means files that
	are marked read-only and are not directory files.  Note
	that hidden or system files may be included in the listing.
	They are suppressed without /a but are treated like any other
	attribute with /a.

/?	Help listing.  Display DIR useage information.	;M008;Handled externally

/h has been removed.					;M008

DIRCMD	An environment variable named DIRCMD is parsed before the
	DIR command line.  Any command line options may be specified
	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
	A filespec may be specified in DIRCMD and will be used unless
	a filespec is specified on the command line.  Any switch
	specified in DIRCMD may be overridden on the command line.
	If the original DIR default action is desired for a particular
	switch, the switch letter may be preceded by a '-' on the
	command line.  E.g.,

	  /-w	use long listing format
	  /-p	don't page the listing
	  /-b	don't use bare format
	  /-s	don't descend subdirectory tree
	  /-o	display files in disk order
	  /-a	suppress hidden and system files


Notes:
------

For sorted listings, file entries are loaded into the TPA buffer, which
is usually about 64K in size.  This allows sorts of up to 3000 files at
a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
The byte after the last entry is 0FFh.  The first byte of each entry is
a flag byte which is made zero when the entry is loaded, and made one
when the entry is used.


Revision History
================
M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
				in the absence of ANSI.SYS

M007	sa	8/1/90		Allow /p/b combination

M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
				to internally handle /? message.

M010	sa	8/5/90		Add support for /l (lowercase) option.

M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
				first FCB with the drive number when the drive
				letter in the command line is preceded by a
				switch.  Now dir manually loads the drive
				number after parsing.

M018	md	8/12/90 	Increment the screen height by 1 when obtained
				from the ROM BIOS.

M023	sa	8/31/90		Prevent DIR from failing if it encounters
				a subdirectory having len(pathname)>MAXPATH.
				Just skip over that subdirectory.

M028	dbo	9/24/90		When country=US, sort by strict character
				byte value, rather than collating table.
				This to match MS-DOS Shell's sort order.

========================================================================= %




;***	SYMBOLS & MACROS

	.xlist
	.xcref

	include version.inc
	include	comsw.asm	; get COMMAND version switches
	include dossym.inc	; get DOS basic symbol set
	include syscall.inc	; get DOS call names
	include doscntry.inc	; get extended country info symbols
	include bpb.inc
	include filemode.inc
	include find.inc
	include	comseg.asm	; define segment order
	include comequ.asm	; get equates for COMMAND routines
	include ioctl.inc	; get symbols for ioctl's
	include rombios.inc	; get ROM BIOS data definition

	.list
	.cref

				;M008;NUM_DIR_SWS reduced by 2 for /h,/? not used
				;M010;NUM_DIR_SWS increased by 2 for /l,/-l
ifdef DBLSPACE_HOOKS
NUM_DIR_SWS	equ	16	; # of dir switch synonyms in Dir_Sw_Ptrs list
else
NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list
endif
				;M010;'lcase' replaces removed 'help' in OptionRec
ifdef DBLSPACE_HOOKS
OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1,cratio:1
else
OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
endif

;		on/off bit record for /l, /b, /s, /p, /w, /c options
;		(order is hard-coded; see OnOffSw)
;		Inmem is set when entries are loaded in memory.

NUM_ATTR_LTRS	equ	6	; length of attribute letter list

ifdef DBLSPACE_HOOKS
NUM_ORDER_LTRS	equ	6	; length of sort order letter list
CRATIO_ORDER	equ	6	; position of 'C' in ORDER_LTRS
else
NUM_ORDER_LTRS	equ	5	; length of sort order letter list
endif

ResultBuffer	struc		; structure of parse result buffer
ValueType	db	?
ValueTag	db	?
SynPtr		dw	?
ValuePtr	dd	?
ResultBuffer	ends

ErrorRec	record	baddir:1,dev:1
;		Error bits are:
;		  Invalid directory format
;		  File is device

EntryStruc	struc			; our private directory entry structure
used		db	?		; =0 until entry used, then =1
filename	db	8 dup (?)	; filename
fileext		db	3 dup (?)	; extension
fileattr	db	?		; file attributes
filetime	dw	?		; file time
filedate	dw	?		; file date
filesize	dd	?		; file size
ifdef DBLSPACE_HOOKS
compratio	db	?		; compression ratio
endif
EntryStruc	ends

shove	macro	val		; hose-bag 8086 doesn't push immediate
	mov	ax,val		; invisible, dangerous use of AX!
	push	ax
	endm


	
	
;***	DATA

DATARES	segment public byte

	extrn	Append_Flag:byte	; true when APPEND needs to be reset
	extrn	Append_State:word	; state to reset APPEND to

DATARES	ends


TRANDATA segment public byte

	extrn	AttrLtrs:byte		; list of attribute letters
	extrn	BadCd_Ptr:word		; "invalid directory" msg block
	extrn	Bytes_Ptr:word		; "%1 bytes" msg block
	extrn	BytMes_Ptr:word		; "%1 bytes free" msg block
	extrn	DirCont_Ptr:word	; "(continuing %1)" msg block
	extrn	DirDat_Yr:word		; year field of date msg block
	extrn	DirDat_Mo_Day:word	; month/day field of date msg block
	extrn	DirDatTim_Ptr:word	; date/time msg block
ifdef DBLSPACE_HOOKS
	extrn	DirCompRatio_Ptr:word	; compression ratio msg block
	extrn	AveCompRatio_Ptr:word	; average comp ratio msg block
endif
	extrn	DirEnvVar:byte		; DIR environment variable name
	extrn	DirHead_Ptr:word	; directory header message block
	extrn	DirMes_Ptr:word		; "%1 File(s)" msg block
	extrn	DirTim_Hr_Min:word	; time field of msg block
	extrn	Dir_Sw_Ptrs:word	; list of DIR switch synonym ptrs
	extrn	Disp_File_Size_Ptr:word	; file size message block
	extrn	DMes_Ptr:word		; <DIR> message block
	extrn	ErrParsEnv_Ptr:word	; "(Error occurred in env.." msg blk
	extrn	Extend_Buf_Ptr:word	; extended error message block
	extrn	Extend_Buf_Sub:byte	; # substitions in message block
	extrn	Msg_Disp_Class:byte	; message display class
	extrn	OrderLtrs:byte		; list of sort order letters
	extrn	Parse_Dir:byte		; DIR parse block
	extrn	String_Buf_Ptr:word	; message block ptr to string
	extrn	Tab_Ptr:word		; tab output block
	extrn	Total_Ptr:word		; "Total:" msg block

TRANDATA ends


TRANSPACE segment public byte

	extrn	AttrSelect:byte		; attribute select states -
	extrn	AttrSpecified:byte	; attribute mask -

;		Attribute conditions are recorded in two steps.  
;		AttrSpecified indicates which attributes are to be checked.
;		AttrSelect indicates which state the specified attributes
;		 must be in for a file to be included in the listing.
;		Attributes not indicated in AttrSpecified are ignored when
;		 deciding which files to include.

	extrn	Bits:word		; some option flags (see OptionRec)
	extrn	BwdBuf:byte		; 'build working dir string' buf
	extrn	BytCnt:word		; # bytes in TPA
	extrn	Bytes_Free:word		; #bytes free for BytMes_Ptr msg block
	extrn	CharBuf:byte		; character string buffer
	extrn	ComSw:word		; error bits (see ErrorRec)
	extrn	CountryPtrInfo:byte	; buffer for collating table ptr
	extrn	CountryPtrId:byte	; info ID for collating table ptr
	extrn	CountryPtr:dword	; collating table ptr
	extrn	CurDrv:byte		; current drive # (0-based)
	extrn	DestBuf:byte		; null-terminated sort codes -

;	Sort order is specified as a series of 0 to 5 sort code
;	bytes, followed by a zero byte.
;	Codes are 1=name, 2=extension, 3=date&time, 4=size, and
;	5=filetype (subdir or not).
;	Bit 7 of code is set for a downwards sort.

	extrn	DestIsDir:byte		; indicator of delim char's in path
	extrn	DestTail:word		; ptr to filename in pathname
	extrn	Dir_Num:word		; #files for DirMes_Ptr msg block
ifdef DBLSPACE_HOOKS
	extrn	Dir_CRatio_1:byte	; Compression ratio for msg block
	extrn	Dir_CRatio_2:byte	; Compression ratio for msg block
endif
	extrn	DirBuf:byte		; DTA buffer for DOS calls
	extrn	DirFlag:byte		; signal to PathCrunch routine
	extrn	Display_Ioctl:word	; display info block for IOCTL call
	extrn	EndDestBuf:byte		; end of DestBuf (sort order codes)
	extrn	File_Size_High:word	; field for file size message block
	extrn	File_Size_Low:word	; field for file size message block
	extrn	FileCnt:word		; file count in a single directory
	extrn	FileCntTotal:dword	; file count in all directories
	extrn	FileSiz:dword		; file sizes in a single directory
	extrn	FileSizTotal:dword	; file sizes in all directories
	extrn	InternatVars:byte	; buffer for international info
	extrn	LeftOnLine:byte		; entries left on current display line
	extrn	LeftOnPage:word		; lines left on page
	extrn	LinPerPag:word		; lines/page entry in Display_Ioctl
	extrn	Msg_Numb:word		; extended error code
	extrn	OldCtrlCHandler:dword	; old int 23 vector
	extrn	Parse1_Syn:word		; ptr to matched synonym
	extrn	PathCnt:word		; length of pathname (see PathPos)
	extrn	PathPos:word		; ptr to pathname buffer (see SrcBuf)
	extrn	PerLine:byte		; # entries per line
	extrn	ResSeg:word		; RESGROUP seg addr
	extrn	ScanBuf:byte		; buffer for environment value and
					;  subdirectory names
	extrn	SrcBuf:byte		; pathname buffer
	extrn	String_Ptr_2:word	; message substitution string ptr
	extrn	Tpa:word		; TPA buffer seg addr
ifdef DBLSPACE_HOOKS
	extrn	csecUsed:dword		; count of compressed sectors used-file
	extrn	csecUsedDir:dword	; count of compressed sectors used-dir
	extrn	csecUsedTotal:dword	; count of compressed sectors used-total
	extrn	ccluUsed:word		; count of DOS clusters used - file
	extrn	ccluUsedDir:word	; count of DOS clusters used - dir
	extrn	ccluUsedTotal:word	; count of DOS clusters used - total
	extrn	fUseHostSize:byte	; use host cluster size with /C
endif

TRANSPACE ends




;***	PRINCIPAL ROUTINES

TRANCODE segment public byte

	extrn	CError:near		; COMMAND error recycle point
ifdef DBLSPACE_HOOKS
	extrn	OpenCVF:near		; Open a MagicDrv compressed volume file
	extrn	CloseCVF:near		; Close a MagicDrv CVF
	extrn	CalcCompRatio:near	; Calculate Compression Ratio routine
	extrn	ComputeRatio:near	; Calculate ratio of two sector counts
endif

	public	Catalog		; our entry point

	break	<DIR (Catalog) principal routines>

	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP

;	Bugbug:	Each routine should start with it's own ASSUME.




;***	Catalog - DIR command main routine
;
;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
;		Cmd-line tail text is at 81h, terminated by 0Dh
;		CS, DS, ES, SS = TRANGROUP seg addr
;		Tpa = TPA buffer seg addr
;		BytCnt = # bytes in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX,SI,DI,BP
;
;	ERROR EXITS
;
;	  Errors are handled by setting up error message pointers
;	   for Std_EPrintf and jumping to CError.  Syntax errors in
;	   the environment variable, however, are handled by printing
;	   an error message and continuing.
;
;	EFFECTS
;
;	  Directory listing is displayed (on standard output).
;	  APPEND is disabled.  HeadFix routine is expected to
;	   restore APPEND state.
;	  Working directory may be changed.  The user's default
;	   directory is saved and flagged for restoration by RestUDir
;	   during COMMAND cycle.
;	  Lots of variables may be changed in TRANSPACE segment.
;
;	NOTES
;
;	  ES = TRANGROUP seg addr except when used to address the
;	   the TPA buffer, where directory entries are loaded from disk.

Catalog	proc

	call	SetDefaults
	call	ParseEnvironment
	call	ParseCmdLine
	jnc	@F		; no parse error
	jmp	catErr		; error msg is set up
@@:	call	SetOptions
	call	SetCollatingTable

;	Drive # to operate on has already been placed in FCB by
;	COMMAND preprocessing.  OkVolArg & PathCrunch depend on that.

	test	Bits,mask bare
	jnz	@F		; don't display volume info for /b
	invoke	OkVolArg	; find & display volume info
	sub	LeftOnPage,2	; record display lines used by volume info
	jmp	short catCrunch

;	OkVolArg side effects:
;	APPEND is disabled;
;	DTA established at DirBuf;
;	Filename fields in FCB are wildcarded.

@@:
;	OkVolArg wasn't executed, so we have to do these ourselves.

	invoke	DisAppend	; disable APPEND

	mov	dx,offset TRANGROUP:DirBuf
	mov	ah,Set_DMA
	int	21h		; set DTA

	mov	di,FCB		; ES:DI = ptr to FCB
	inc	di		; ES:DI = ptr to filename field of FCB
	mov	al,'?'		; AL = wildcard character
	mov	cx,11
	rep	stosb		; wildcard filename field

catCrunch:
	call	CrunchPath	; crunch pathname to get directory and filename
	jc	catRecErr	; handle recorded or extended error

;	User's directory has been saved, we've changed to specified directory.
;	ComSw = error bits for later use
;	FCB contains parsed filename

	cmp	ComSw,0
	jne	catRecErr	; handle recorded error

	call	InstallCtrlC	; install control-C handler
ifdef DBLSPACE_HOOKS
	test	Bits, mask cratio	; compression ratio wanted?
	jz	@f

	call	OpenCVF 		; yes, try to open CVF file
	jnc	@f			; CY clear if open worked

	and	Bits, not (mask cratio) ; failed, clear cratio option bit
@@:
endif
	call	ZeroTotals	; zero grand totals
	call	ListDir		; list main directory
	jc	catExtErr

	test	Bits,mask subd
	jz	@F		; subdirectories option not set
	call	ListSubds	; list subdirectories
	jc	catExtErr
@@:
;	Check if any files were found.

	test	Bits,mask bare
	jnz	catRet		; don't bother for bare format

	mov	ax,word ptr FileCntTotal
	or	ax,ax
	jz	catNoFiles	; no files found

	call	DisplayTotals	; display trailing grand totals
	jmp	short catRet	; all done

catRecErr:

;	ComSw may have error bit set.  If not, do extended error.

	test	ComSw,mask dev
	jnz	catNoFiles	; filename is device, respond 'file not found'

	test	ComSw,mask baddir
	jz	catExtErr	; no ComSw error bits, must be extended error
	mov	dx,offset TRANGROUP:BadCd_Ptr	; invalid directory
	jmp	short catErr

catNoFiles:

;	Display header and force 'file not found' message.

	call	DisplayHeader
	mov	ax,ERROR_FILE_NOT_FOUND
	mov	Msg_Disp_Class,EXT_MSG_CLASS
	mov	dx,offset TRANGROUP:Extend_Buf_ptr
	mov	Extend_Buf_ptr,ax
	jmp	short catErr

catExtErr:

;	DOS has returned an error status.  Get the extended error#, and
;	set up an error message, changing 'No more files' error 
;	to 'File not found' error.

	invoke	Set_Ext_Error_Msg
	cmp	Extend_Buf_Ptr,ERROR_NO_MORE_FILES
	jne	@F
	mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND
@@:

;	Error exit.  Error message information has been set up
;	for Std_EPrintf.

catErr:
ifdef DBLSPACE_HOOKS
	test	Bits, mask cratio	; close Compressed Volume File if cratio
	jz	@f
	call	CloseCVF
@@:
endif
	jmp	CError		; go to COMMAND error recycle point

catRet:
ifdef DBLSPACE_HOOKS
	test	Bits, mask cratio	; close Compressed Volume File if cratio
	jz	@f
	call	CloseCVF
@@:
endif
	ret

Catalog	endp




;***	SetDefaults - set default pathname, options
;
;	ENTRY	DS = TRANGROUP seg addr
;
;	EXIT	nothing
;
;	USED	AX,DI
;
;	EFFECTS
;	  SrcBuf = '*',EOL - default pathname
;	  PathPos = ptr to pathname
;	  PathCnt = length of pathname



SetDefaults	proc

	mov	di,offset TRANGROUP:SrcBuf	; DI = ptr to pathname buffer
	mov	PathPos,di			; PathPos = ptr to pathname
	mov	al,STAR
	stosb
	mov	al,END_OF_LINE_IN
	stosb				; SrcBuf = '*',0Dh
	mov	PathCnt,1		; PathCnt = pathname length

	xor	ax,ax			; AX = 0
	mov	ComSw,ax		; = no error
	mov	Bits,ax			; = options off
	mov	DestBuf,al		; = no sort
	mov	AttrSpecified,ATTR_HIDDEN+ATTR_SYSTEM
	mov	AttrSelect,al		; exclude hidden, system files
ifdef DBLSPACE_HOOKS
	mov	fUseHostSize, al	; use CVF cluster size, not Host
endif

	ret

SetDefaults	endp




;***	ParseEnvironment - find and parse our environment variable
;
;	Find our environment variable and parse it.  If a parse
;	error occurs, issue an error message.  The parse results
;	up to the error will still have effect.  Always leave
;	the option variables in a useable state.
;
;	ENTRY	DS = TRANGROUP seg addr
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;	  SrcBuf may contain a new default pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.
;
;	  If a parse error occurred, an error message will be issued.

ParseEnvironment	proc

	call	GetEnvValue		; get environment variable value
	jc	peRet			; name not found in environment

;	SI = ptr to value of environment variable, in TRANGROUP seg

	call	ParseLine		; parse environment value
	cmp	ax,END_OF_LINE
	je	peRet			; successful completion

;	Some kind of parse error occurred.
;	We're set up for a Std_EPrintf call.

	invoke	Std_EPrintf			; display the parse error
	mov	Msg_Disp_Class,UTIL_MSG_CLASS	; restore default msg class

	mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
	invoke	Printf_Crlf		; "(Error occurred in environment.."

					;M008;Internal handling of /? removed
;peOk:	and	Bits,not mask help	; disallow /h in environment variable

peRet:	ret

ParseEnvironment	endp




;***	ParseCmdLine - parse and record command line parameters
;
;	ENTRY	PSP offset 81h is beginning of cmd line buffer
;		DS, ES, CS = TRANGROUP seg addr
;
;	EXIT	CY = set if parse error occurred
;
;		If parse error occurred, we're set up for Std_EPrintf call:
;		AX = system parser error code
;		DX = ptr to message block
;
;	USED	AX,BX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;	  SrcBuf may contain a new default pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.
;
;	  If parse error occurred, we're set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error class
;	  Byte after last parameter in text is zeroed to make ASCIIZ string
;	  Message block (see DX) is set up for parse error message

ParseCmdLine	proc

	mov	si,81h			; SI = ptr to cmd-line tail text
	call	ParseLine		; parse cmd line tail
	cmp	AX,END_OF_LINE
	je	pcOk			; parse completed successfully

;	A parse error occurred.  We're all set up for message output.

	stc		   		; return failure
	jmp	short pcRet

pcOk:	clc				; return success

pcRet:	ret

ParseCmdLine	endp




;***	SetCollatingTable - set up character collating table for sorting
;
;	If country is other than USA, try to get a collating table
;	for character sorting.  For USA, use straight byte values.
;	This is so DIR behaves like the MS-DOS Shell, which sorts
;	by straight byte values in the USA for better performance.
;
;	ENTRY	ES = TRANGROUP seg addr
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX,DI
;
;	EFFECTS
;
;	  If collating table is set -
;	    CountryPtrId = 6.
;	    CountryPtr points to collating table.
;
;	  Otherwise -
;	    CountryPtrId = 0.

SetCollatingTable	proc

;	Begin modification M028

	mov	dx,offset TRANGROUP:InternatVars
				; DS:DX = ptr to international info buffer
	mov	ax,INTERNATIONAL shl 8
				; AX = 'Get current country info'
	int	21h		; call DOS
	jc	scNoTable	; error - so don't collate

;	BX = country code

	cmp	bx,1
	je	scNoTable	; we're in USA, don't collate

;	End modification M028

;*	Country code is other than USA.  Try to get a collating table.

	mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
				; AH = 'Get Extended Country Info'
				; AL = 'Get Pointer to Collating Table'
	mov	bx,-1		; BX = code page of interest = CON
	mov	cx,5		; CX = length of info buffer
	mov	dx,bx		; DX = country ID = default
	mov	di,offset TRANGROUP:CountryPtrInfo
				; ES:DI = ptr to info buffer
	int	21h		; call DOS
	jnc	scRet		; success

;*	Set CountryPtrId = 0 to signal no collating table.

scNoTable:			;M028
	mov	CountryPtrId,0

scRet:	ret

SetCollatingTable	endp




;***	SetOptions - check and set options
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX
;
;	EFFECTS
;
;	  Bits may contain modified option settings.
;	  Display_Ioctl table, including LinPerPag variable, is filled in.
;	  LeftOnPage is initialized to # lines till end of page is handled.
;	  PerLine is set according to /w presence.

SetOptions	proc

;	If bare listing requested, cancel wide listings.

	test	Bits,mask bare
	jz	@F
	and	Bits,not mask wide		;M007;Allow /p with /b

@@:
ifdef DBLSPACE_HOOKS
;	Cancel compression ratio if wide or bare listing

	test	Bits, (mask bare) or (mask wide)
	jz	@f
	and	Bits, not mask cratio
@@:
endif
;	Set # lines per display page.

;M01  Obtain screen height from ROM BIOS data area
;
;M01	mov	LinPerPag,LINESPERPAGE			; default value

ifndef JAPAN
	push	ds
	MOV	AX,ROMBIOS_DATA 	; Get ROM Data segment
	MOV	DS,AX			;
	Assume	DS:ROMBIOS_DATA

	MOV	al,CRT_Rows		; Get max rows
	pop	ds			;
	Assume	DS:Trangroup

	or	al,al			; If zero specified
	jnz	@F			;
endif
	MOV	al,LINESPERPAGE 	; assume 24 rows

@@:
	xor	ah,ah
ifndef JAPAN
	inc	al			; height + 1 ;M018
endif
	mov	LinPerPag,ax		; set the rows now

; Now the console driver can change the rows if it knows better (M01 end)

	mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE	; IOCTL for handles
	mov	bx,STDOUT				; handle #
	mov	ch,IOC_SC				; screen
	mov	cl,GET_GENERIC				; get display info
	mov	dx,offset TRANGROUP:Display_Ioctl	; info block
	int	21h					; call DOS

	mov	ax,LinPerPag		; AX = # lines per page
	mov	LeftOnPage,ax		; initialize # lines left on page

;	Set # entries per line.

	mov	PerLine,NORMPERLIN	; # entries per line without /w
	test	Bits,mask wide
	jz	@F
	mov	PerLine,WIDEPERLIN	; # entries per line with /w
@@:
				;M011;start;The following code checks if a drive
				;letter has been parsed into SrcBuf, and if
				;so, the correct drive number is loaded into
				;the first FCB, at offset 5C.

	cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
	jne	soRet
	mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
	and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
	sub	al,'@'				; convert to 1-based number (1=A)
	mov	ds:FCB,al 			; store in first FCB
						;M011;end
soRet:	ret

SetOptions	endp




;***	CrunchPath - analyze supplied or default pathname
;
;	ENTRY	PathPos = ptr to pathname buffer
;		PathCnt = length of pathname, not incl trailing delimiter
;		Pathname in buffer must end in delimiter (like CR) and
;		 must have space for another char after the delimiter.
;
;	EXIT	CY = clear if no error
;		We are changed to directory found in pathname
;		Previous directory ready to be restored via RestUDir
;		FCB filename fields contain filename (possibly w/ wildcards)
;
;		If error occurred,
;		CY = set
;		ComSw = error bits (see ErrorRec)
;		If ComSw not set,
;		Ready for DOS Get Extended Error call


CrunchPath	proc

	call	FileIsDevice
	jne	@F		; not a device, skip ahead
	or	ComSw,mask dev	; signal file is device
	jmp	short cpErr	; return error
@@:
	push	PathPos		; save ptr to pathname
	mov	DirFlag,-1	; tell PathCrunch not to parse file into FCB
	invoke	PathCrunch	; change to directory in pathname
	mov	DirFlag,0	; reset our little flag
	pop	si		; SI = ptr to pathname
	jc	cpNoDir		; didn't find directory path
	jz	cpRet		; found directory path w/ no filename
				;  - leave wildcard default in FCB and return

;*	We found a directory, and there was a filename attached.
;	DestTail = ptr to ASCIIZ filename

	mov	si,DestTail	; SI = ptr to filename
	jmp	short cpFile	; go parse the file into FCB

;*	PathCrunch failed to find a directory in the pathname.
;
;	Msg_Numb = error code
;	DestIsDir = nonzero if path delimiter char's occur in pathname
;	SI = ptr to pathname (now an ASCIIZ string)

cpNoDir:
	mov	ax,Msg_Numb	  ; AX = error code from PathCrunch
	or	ax,ax
	jnz	cpErr		  ; error occurred - return it
	cmp	DestIsDir,0
	je	cpMaybe		  ; no path delimiters seen, maybe it's a file
	or	ComSw,mask baddir ; signal invalid directory name
	jmp	short cpErr	  ; return error

cpMaybe:

;	SI = ptr to pathname

	cmp	byte ptr [si+1],COLON_CHAR
	jnz	@F		  ; no drive specifier, skip ahead
	lodsw			  ; SI = ptr past drive specifier "d:"
@@:	cmp	[si],".."
	jne	cpFile		  ; if not "..", treat as a file
	cmp	byte ptr [si+2],0
	jne	cpFile		  ; or if there's more after "..", treat as file
	or	ComSw,mask baddir ; signal invalid directory
	jmp	short cpErr	  ; return error

;	The preceding code was taken from the old DIR routine.
;	It's garbage, I'm afraid.  It's meant to check for ".."
;	occurring when we're at the root directory.  Too bad it
;	doesn't handle problems with "..\..", etc.


;	We're ready to parse a filename into the FCB.
;	SI = ptr to ASCIIZ filename

cpFile:	mov	di,FCB		; DI = ptr to FCB
	mov	ax,(PARSE_FILE_DESCRIPTOR shl 8) or 0Eh
				; wildcards already in FCB used as defaults
	int	21h
	clc			; return success
	jmp	short cpRet

cpErr:	stc			; return error

cpRet:	ret

CrunchPath	endp




;***	InstallCtrlC - install our private control-C handler
;
;	Put our control-c handler in front of command.com's default
;	handler, to make sure the user's default directory gets restored.
;	This shouldn't be necessary, but, for now, there are situations
;	where the TDATA segment is left in a modified state when a
;	control-c occurs.  This means that the transient will be
;	reloaded, and the user's directory cannot be restored.
;
;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX,BX,DX
;
;	EFFECTS
;
;	  CtrlCHandler address placed in int 23 vector.
;
;	NOTE
;
;	  Command.com's basic control-c handler will be restored
;	  to the int 23 vector by the HeadFix routine, after DIR finishes.

InstallCtrlC	proc

	push	es				 ; preserve ES
	mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
	int	21h
	mov	word ptr OldCtrlCHandler,bx	 ; save old int 23 vector
	mov	word ptr OldCtrlCHandler+2,es	 
	pop	es				 ; restore ES

	mov	dx,offset TRANGROUP:CtrlCHandler ; DS:DX = ptr to CtrlCHandler
	mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
	int	21h
	ret

InstallCtrlC	endp



;***	ListSubds - search and list files in subdirectories
;
;	ENTRY	Current directory (on selected drive) is top of subdir tree
;		FCB is still set up for file searches
;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
;
;	EXIT	CY = clear if no error
;		FileCnt = # files found & displayed
;		FileSiz = total size of files found
;
;		If error,
;		CY = set
;		Ready for DOS Get Extended Error call
;
;	USED	AX,BX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  FileCntTotal, FileSizTotal are updated.
;	  Subdirectories may be listed on standard output device.
;
;	NOTES
;
;	  ListSubds seeds the recursive entry point lsNode with a ptr
;	   to a buffer where we'll stack up subdirectory filenames.
;	   Each name is stored ASCIIZ.

ListSubds	proc

	invoke	SetRest1		; make sure user's dir gets restored

	mov	bx,offset TRANGROUP:ScanBuf   ; BX = ptr to child name buffer

lsNode:
	mov	byte ptr ds:[bx],0	; start with null child name
lsLoop:
	call	FindNextChild		; search for next subdirectory
	jc	lsErr			; search failed - examine error

	mov	dx,bx			; DX = ptr to child's name
	call	ChangeDir		; enter child directory

					; M023;start
	jnc	@F			; check for error
	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
	je	lsLoop			; yes, skip over this subdirectory
	jmp	SHORT lsRet		; no, other error: DIR must fail
					; M023;end

@@:	push	bx
	call	ListDir			; list the directory
	pop	bx

;	Note we're ignoring errors returned here.

	mov	di,bx			; DI = ptr to child's name
	mov	cx,13			; CX = max name length w/ null
	xor	al,al			; AL = zero byte to look for
	repne	scasb			; DI = ptr to next name pos'n in buf
	push	bx			; save ptr to child's name
	mov	bx,di			; BX = ptr to next name pos'n in buf
	call	lsNode			; recurse from new node
	pop	bx			; BX = ptr to child's name
	pushf				; save error condition
	
	shove	0
	shove	".."
	mov	dx,sp			; DX = ptr to "..",0 on stack
	call	ChangeDir		; return to parent directory
	pop	ax			; restore stack
	pop	ax

	popf				; restore error condition from child
	jc	lsRet			; return error

	jmp	lsLoop			; look for more children
lsErr:
	invoke	Get_Ext_Error_Number	; AX = extended error code
	cmp	ax,ERROR_FILE_NOT_FOUND
	je	lsRet			; file not found, we're ok
	cmp	ax,ERROR_NO_MORE_FILES
	je	lsRet			; no more files, we're ok
	stc				; return other errors

lsRet:	ret

ListSubds	endp




	break	<DIR support routines>

;***	SUPPORT ROUTINES




;***	CheckChild - check potential subdirectory name for FindNextChild
;
;	ENTRY	DirBuf contains DOS Find-buffer with potential child
;		BX = ptr to last child's name
;		BP = ptr to temp child's name
;
;	EXIT	nothing
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS
;
;	  Filename pointed to by BP may be changed.
;
;	NOTES
;
;	  Potential filename replaces temp filename if:
;	   it's a subdirectory file;
;	   it doesn't start with a '.';
;	   it's alphanumerically greater than last child's name;
;	   and it's alphanumerically less than temp name.

CheckChild	proc

	test	DirBuf.find_buf_attr,ATTR_DIRECTORY
	jz	ccRet		; not a subdirectory file- return

	cmp	DirBuf.find_buf_pname,'.'
	je	ccRet		; starts with a dot- return

	mov	si,offset TRANGROUP:DirBuf+find_buf_pname
	mov	di,bx
	call	CmpAscz		; compare candidate to last child's name
	jna	ccRet		; it's not above it- return

	mov	si,offset TRANGROUP:DirBuf+find_buf_pname
	mov	di,bp
	call	CmpAscz		; compare candidate to temp name
	jnb	ccRet		; it's not below it- return

;	New kid is alright.  Copy to temp.

	mov	si,offset TRANGROUP:DirBuf+find_buf_pname
	mov	di,bp
	mov	cx,13
	rep	movsb

ccRet:	ret

CheckChild	endp




;***	CmpEntry - compare one directory entry to another in sort order
;
;	Compare one directory entry against another according to
;	the sort codes in DestBuf.  One or more comparisons
;	may be made of file name, extension, time/date, and
;	size.  Comparisons may be made for upward or downward
;	sort order.
;
;	ENTRY	ES:BX = ptr to entry to compare
;		ES:BP = ptr to entry to be compared against
;		DestBuf contains sort codes (see DestBuf)
;		DS = TRANGROUP seg addr
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry against BP entry.
;		 'Same, above, below' translate to 'same, after, before'.
;
;	USED:	AX,CX,DX,SI,DI

CmpEntry	proc

	mov	si,offset TRANGROUP:DestBuf	; (DS:SI) = ptr to sort codes
ceLoop:
	xor	ax,ax			; AX = 0
	mov	al,[si]			; AL = sort code
	or	al,al
	jz	ceDone			; sort code is zero, we're done
	inc	si			; DS:SI = ptr to next sort code
	push	si			; save ptr to next sort code
	dec	al
	sal	al,1			; AX = index into cmp call table
					; CY set for downward sort order
	mov	si,ax			; SI = index into cmp call table
	mov	ax,cs:FieldCmps[si]	; AX = addr of compare routine
	jc	ceDn			; downwards sort - go swap entries
	call	ax 			; do upwards sort
	jmp	short @F
ceDn:
	xchg	bx,bp		; swap entry ptrs for downward sort order
	call	ax		; do sort
	xchg	bx,bp		; swap ptrs back
@@:
	pop	si		; SI = ptr to next sort code
	je	ceLoop		; compare showed no difference, keep trying

ceDone:

;	Get here either from unequal compare or sort code = 0.
;	In the latter case, condition codes indicate equality,
;	which is correct.

	ret

FieldCmps	label	word	; call table of entry comparisons
		dw	CmpName
		dw	CmpExt
		dw	CmpTime
		dw	CmpSize
		dw	CmpType
ifdef DBLSPACE_HOOKS
		dw	CmpCratio
endif

CmpEntry	endp




;***	CmpName - compare file name of two entries
;***	CmpExt - compare extension of two entries
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	AX,CX,DX,SI,DI

CmpName	proc

	mov	si,bx		; ES:SI = ptr to BX entry
	mov	di,bp		; ES:DI = ptr to BP entry
	add	si,filename	; ES:SI = ptr to BX name
	add	di,filename	; ES:DI = ptr to BP name
	mov	cx,size filename; CX = length of name
	jmp	short CmpStr

CmpExt:	mov	si,bx		; ES:SI = ptr to BX entry
	mov	di,bp		; ES:DI = ptr to BP entry
	add	si,fileext	; ES:SI = ptr to BX extension
	add	di,fileext	; ES:DI = ptr to BP extension
	mov	cx,size fileext	; CX = length of extension field

;	Bugbug:	use symbol for subfunction code.

CmpStr:	cmp	CountryPtrId,6
	jne	cnNoCollTable	; no collating table available

;*	Compare strings using collating table.
;
;	ES:SI = ptr to 1st string
;	ES:DI = ptr to 2nd string
;	CX = length

	push	bp			; preserve BP
	push	bx			; preserve BX
	push	ds			; preserve DS
	lds	bx,CountryPtr		; DS:BX = ptr to collating table
	assume	ds:NOTHING
	mov	bp,ds:[bx]		; BP = size of collating table
	inc	bx
	inc	bx			; DS:BX = ptr to collating values
					; DS:[BX]-2 = size of table
	xor	ax,ax			; AX = 0 for starters

;	Bugbug:	Investigate removing collating table length checks.

cnNextChar:
	mov	al,es:[di]		; AL = AX = char from 2nd string
	inc	di			; ES:DI = ptr to next char 2nd string
	cmp	ax,bp			; compare to collating table length
	jae	@F			; char not in table
	xlat				
@@:					; AL = AX = collating value
	mov	dx,ax			; DX = collating value from 2nd string
	lods	byte ptr es:[si]	; AL = AX = char from 1st string
					; ES:SI = ptr to next char 1st string
	cmp	ax,bp			; compare to collating table length
	jae	@F			; char not in table
	xlat				
@@:					; AL = AX = collating value
	cmp	ax,dx			; compare collating values

ifdef DBCS				; DBCS tail byte must not use
					; collating table
	jnz	cnNot_Same
	mov	al,es:[di-1]		; get previous 2nd string character
	invoke	testkanj
	jz	cnDo_Next		; if it was not DBCS lead byte
	mov	al,es:[di]		; get tail byte from 2nd string
	cmp	es:[si],al		; compare with 1st strings tail byte
	jnz	cnNot_Same
	inc	si			; pass tail byte
	inc	di
	dec	cx
cnDo_Next:
	loop	cnNextChar
cnNot_Same:

else					; Not DBCS

	loope	cnNextChar		; until unequal or no more left
endif

	pop	ds			; restore DS
	assume	ds:TRANGROUP
	pop	bx			; restore BX
	pop	bp			; restore BP
	ret

;*	If no collating table is available, simply compare raw ASCII values.
;	Don't we wish we could just do this all the time?  Sigh.

cnNoCollTable:
	rep	cmps byte ptr es:[si],[di]
	ret

CmpName	endp




;***	CmpTime - compare entries by date/time
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	CX,SI,DI
;
;	NOTE	Filetime and filedate fields in our private entry
;		structure must be adjacent and in that order.

CmpTime	proc

	mov	si,bx
	mov	di,bp
	add	si,filedate + size filedate - 1
	add	di,filedate + size filedate - 1
	mov	cx,size filetime + size filedate
	std
	repe	cmps byte ptr es:[si],[di]
	cld
	ret

CmpTime	endp




;***	CmpSize - compare entries by size
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	CX,SI,DI

CmpSize	proc

	mov	si,bx
	mov	di,bp
	add	si,filesize + size filesize - 1
	add	di,filesize + size filesize - 1
	mov	cx,size filesize
	std
	repe	cmps byte ptr es:[si],[di]
	cld
	ret

CmpSize	endp




;***	CmpType - compare entries by file type (subdirectory or not)
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	AX

CmpType	proc

	mov	al,es:[bx].fileattr
	mov	ah,es:[bp].fileattr
	and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
	cmp	ah,al
	ret

CmpType	endp


ifdef DBLSPACE_HOOKS
;***	CmpCratio - compare entries by compression ratio
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	AX

CmpCratio	proc

	mov	al, es:[bx].compratio
	cmp	al, es:[bp].compratio
	ret

CmpCratio	endp
endif

;***	DefaultAttr - set default attribute conditions
;
;	ENTRY	nothing
;
;	EXIT	CY clear
;
;	USED
;
;	EFFECTS
;
;	  AttrSpecified, AttrSelect are updated with new attribute conditions.

DefaultAttr	proc

	mov	AttrSpecified,ATTR_HIDDEN+ATTR_SYSTEM	; specify H and S
	mov	AttrSelect,0				; H and S must be off
	clc						; return success
	ret

DefaultAttr	endp




;***	DisplayTotals - display grand total stats
;
;	If we searched subdirectories, display the total # files found
;	 and total size of files found.
;	Display disk space remaining.
;
;	ENTRY	FileCntTotal, FileSizTotal contain correct values
;		Bits contains setting of /s
;		FCB contains drive #
;
;	EXIT	nothing
;
;	USES	AX,DX
;		FileSiz

DisplayTotals	proc

	test	Bits,mask subd
	jz	dtFree			; no subdirectories- do bytes free

	invoke	Crlf2			; start on new line
	call	UseLine

	mov	dx,offset TRANGROUP:Total_Ptr
	invoke	Std_Printf			; "Total:",cr,lf
	call	UseLine
ifdef DBLSPACE_HOOKS
	test	Bits, mask cratio
	jz	dtCntSize

	mov	ax, [ccluUsedTotal]	; setup compression ratio counts for
	mov	[ccluUsedDir], ax	;   display routine
	mov	si, offset TRANGROUP:csecUsedTotal
	mov	di, offset TRANGROUP:csecUsedDir
	movsw
	movsw

dtCntSize:
endif
	mov	ax,word ptr FileCntTotal	; AX = # files found mod 64K
	mov	si,offset TRANGROUP:FileSizTotal
	mov	di,offset TRANGROUP:FileSiz
	movsw
	movsw				; move total size to size variable
	call	DisplayCntSiz		; display file count & size &
dtFree: 				;   (maybe) compression ratio
	mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
	mov	dl,byte ptr ds:FCB	; DL = drive#
	int	21h			; call DOS
	cmp	ax,-1			; check 'invalid drive' return code
	jz	dtRet			; can't get drive space - return
	mul	cx
	mul	bx
	mov	Bytes_Free,ax
	mov	Bytes_Free+2,dx
	mov	dx,offset TRANGROUP:BytMes_Ptr
	invoke	Std_Printf		; "nnn bytes free",cr,lf
	call	UseLine

dtRet:	ret

DisplayTotals	endp




;***	FileIsDevice - see if file looks like a device
;
;	ENTRY	PathPos = ptr to pathname
;		PathCnt = length of pathname w/o terminating char
;		DirBuf is DOS DTA
;
;	EXIT	ZR = set if file looks like a device
;
;	USED	AX,BX,CX,DX,DI
;
;	EFFECTS
;
;	  DTA buffer holds results of Find First function
;
;	NOTES
;
;	  We try to flag devices in two ways.  First, we try
;	  the DOS Find First function.  It returns attribute bit 6
;	  set on a successful find if it identifies a device name.
;	  Unfortunately, it returns 'path not found' for a device
;	  name terminated with colon, such as "CON:".  So, we look
;	  for any colon in the pathname after the 2nd character,
;	  and flag the pathname as a device if we find one.

FileIsDevice	proc

	mov	dx,PathPos	 ; DX = ptr to pathname

	mov	di,dx
	add	di,PathCnt	 ; DI = ptr to byte after pathname
	xor	bl,bl		 ; BL = NUL to terminate pathname with
	xchg	bl,byte ptr [di] ; BL = saved pathname terminating char

	xor	cx,cx		 ; CX = attribute mask (normal search)
	mov	ah,FIND_FIRST	 ; AH = DOS Find First function code
	int	21h	 	 ; call DOS
	xchg	bl,byte ptr [di] ; restore pathname terminating char
	jc	piCol		 ; didn't find a dir entry, check for colon

;	Found a dir entry, see if Find First thinks it's a device.

	test	byte ptr DirBuf.Find_Buf_Attr,ATTR_DEVICE
	jz	piCol		 ; device attribute not set, look for colon
	xor	cx,cx		 ; it's a device, return ZR flag
	jmp	short piRet

;	Device attribute not returned by Find First function.  But
;	let's check for a colon anywhere in the pathname after the
;	second byte.
;
;	DI = ptr to byte after pathname

piCol:	dec	di		 ; DI = ptr to last char in pathname
	mov	al,COLON_CHAR	 ; AL = colon char to search for
	mov	cx,PathCnt	 ; CX = # chars to scan
	dec	cx
	dec	cx		 ; ignore 1st two chars of pathname
	or	cx,cx
	js	piRet		 ; if < 2 chars in pathname, just return
	or	di,di		 ; clear ZR in case CX = 0
	std			 ; scan downward
	repne	scasb
	cld			 ; restore default upward direction

;	After scanning, the ZR flag is set to indicate presence of a colon.

piRet:	ret

FileIsDevice	endp




;***	FindFirst - find first directory entry to display
;***	FindNext - find next directory entry to display
;
;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
;		AttrSpecified, AttrSelect are set
;
;	EXIT	CY = clear if successful
;		BX = offset in TPA buffer of directory entry found
;
;		If unsuccessful,
;		CY = set
;		AX = DOS error code
;		DOS Get Extended Error call will get error code
;
;		NOTE:  if entries were loaded into TPA, AX contains
;		ERROR_NO_MORE_FILES when no more entries are available,
;		but DOS Get Extended Error call WON'T return the correct
;		error.  That's ok, because we'll see the value in AX
;		and recognize it as a non-error condition.
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Entries in memory may be marked as output.
;	  If not sorted, entry is loaded at TPA.
;
;	NOTES
;
;	  If we don't find a qualifying file, we return after the final
;	   DOS Find File call.  A DOS Get Extended Error call will then
;	   indicate an appropriate condition.

FindFirst	proc

	mov	ax,offset TRANGROUP:GetFirst
	jmp	short ffFindEntry

FindNext:
	mov	ax,offset TRANGROUP:GetNext

;	AX = address of correct disk get routine to use.

ffFindEntry:
	push	es			; save TRANGROUP seg addr
	test	Bits,mask inmem
	jz	ffDisk			; entries not in memory, search disk

;	Entries are loaded in memory to sort out.  Find the first one.
;	There will always be one, or LoadEntries would've failed.

	call	FindInMem		; find first entry in TPA
	jmp	short ffRet		; return what TPA search returns

;	Get entry from disk.

ffDisk:
	call	ax			; get entry from disk
	jc	ffGetErr		; get & return error
	mov	es,Tpa			; ES = seg addr of TPA
	xor	di,di			; ES:DI = ptr to TPA
	mov	bx,di			; BX = offset of entry in TPA
	call	LoadEntry		; load entry to TPA
	clc				; return success
	jmp	short ffRet

ffGetErr:
	invoke	Get_Ext_Error_Number	; AX = DOS error code
	stc

ffRet:	pop	es			; ES = TRANGROUP seg addr again
	ret

FindFirst	endp




;***	FindInMem - find next directory entry in TPA buffer
;
;	ENTRY	TPA is loaded (see LoadEntries)
;
;	EXIT	BX = offset in TPA of entry found
;
;		If no more files,
;		CY = set
;		AX = DOS 'no more files' error code
;
;	USED	AX,BX,CX,DX,SI,DI,BP,ES
;
;	EFFECTS
;
;	  Entry found is flagged as 'used' (see EntryStruc).

FindInMem	proc

	mov	es,Tpa		; ES = TPA seg addr
	xor	bx,bx		; ES:BX = ptr to 1st entry in TPA
	cld			; make sure default string direction is up
	
	call	FindOneInMem	; locate an entry
	jc	fiNoMore	; none left, set up 'no more files' error

;	BX = ptr to entry in TPA

fiBest:
	mov	bp,bx		; BP = ptr to best entry so far
fiNext:
	call	FindNextInMem	; locate next entry
	jc	fiFound		; no more, best entry so far wins

;	BX = ptr to next entry

	call	CmpEntry	; compare it to best found so far (BP)
	jnb	fiNext		; it's not better, go look at next one
	jmp	fiBest		; it's better, go mark it as best so far

fiNoMore:

;	No more entries available in TPA.  Set up 'no more files' error.

	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
	stc				; return error
	jmp	short fiRet

fiFound:
	mov	bx,bp			; BX = ptr to best entry found
	mov	byte ptr es:[bx],1	; mark entry 'used'
	clc				; return success
fiRet:	ret

FindInMem	endp




;***	FindNextChild - find next subdirectory in current directory
;
;	ENTRY	BX = ptr to last child found, ASCIIZ filename
;		DirBuf is established DTA
;
;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
;
;		If failure,
;		CY = set
;		DOS Get Extended Error call will get error
;
;	USED	AX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  DirBuf is used for find first/next calls.
;
;	NOTES
;
;	  We keep on checking files until DOS returns an error.  If
;	  the error is 'no more files' and the temp filename is not
;	  the initial high tag, copy the temp to the child's name spot
;	  and return success.  Otherwise, send the error back to caller.
;
;	  This routine depends on DS,ES,CS, & SS all being equal.

FindNextChild	proc

	sub	sp,12			; make temp filename buf on stack
	shove	00FFh			; temp filename = high tag
	mov	bp,sp			; BP = ptr to temp filename buf
	shove	"*"
	shove	".*"
	call	GetDriveLtr		; AX = "d:"
	push	ax
	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack

;	See that the stack is restored properly at the end of this proc.

	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
	mov	ah,FIND_FIRST
	int	21h			; DOS- Find First matching file
	jc	fcRet			; return error

	call	CheckChild		; check child against last, temp

fcNext:	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
	mov	ah,FIND_NEXT
	int	21h			; DOS- Find Next matching file
	jc	fcErr			; examine error

	call	CheckChild		; check child against last, temp
	jmp	fcNext			; go find another child

fcErr:
	invoke	Get_Ext_Error_Number	; AX = extended error code
	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
	jne	short fcNope		; some other error- return it

;	We ran out of files.  See if we qualified at least one.

	cmp	byte ptr [bp],0FFh
	je	fcNope			; temp filename is unused- no child

;	Move temp filename to child name position.

	mov	si,bp		; SI = ptr to temp filename
	mov	di,bx		; DI = ptr to child name pos'n
fcMove:	lodsb			; AL = next byte of filename
	stosb			; store byte
	or	al,al
	jz	fcRet		; byte was zero, return success (CY clear)
	jmp	fcMove		; go move another byte

fcNope:	stc			; return error
fcRet:	lahf
	add	sp,20		; restore stack
	sahf
	ret

FindNextChild	endp





;***	FindOneInMem - find the first available entry in TPA
;***	FindNextInMem - find the next available entry in TPA
;
;	ENTRY	ES = TPA seg addr
;		BX = ptr to entry in TPA
;
;	EXIT	BX = ptr to entry found
;		CY = set if no more entries available in TPA
;
;	USED	AL

FindOneInMem	proc

	mov	al,es:[bx]	; examine 'used' byte of starting entry
	cmp	al,1
	je	FindNextInMem	; entry has already been used
	cmp	al,0FFh
	je	foNoMore	; 0FFh, we're at the end of the list

;	BX = ptr to entry that hasn't been output yet.

	clc			; return success
	ret

FindNextInMem:
	add	bx,size EntryStruc	; BX = ptr to next entry
	jmp	FindOneInMem		; go look at it

foNoMore:
	stc				; ran out of entries, return failure
	ret

FindOneInMem	endp




;***	GetEnvValue - get value of our environment variable
;
;	ENTRY	DS, ES = TRANGROUP seg addr
;
;	EXIT	CY = set if environment variable not in environment
;
;		Otherwise:
;		SI = ptr to environment variable asciiz value in TRANGROUP
;
;	USED	AX,BX,CX,DX,DI
;		(We assume the (almost) worst, since we don't know about
;		Find_Name_In_Environment.)
;
;	EFFECTS
;
;	  ScanBuf is loaded with value text

GetEnvValue proc

	push	es				; save ES
	mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
	invoke	Find_Name_In_Environment
	jc	geRet				; name not found in environment

;	ES:DI = ptr to value of environment variable
;	We're assuming DS, CS, and SS are unchanged.

	push	ds
	push	es
	pop	ds
	pop	es

	assume	ds:nothing

;	DS = seg addr of environment variable value (in environment segment)
;	ES = TRANGROUP seg addr

	mov	si,di				; DS:SI = ptr to value string
	mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
@@:	lodsb
	or	al,al
	stosb
	loopnz	@B		; move the string, including trailing null

	push	es
	pop	ds		; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP

	mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
geRet:	pop	es				; restore ES
	ret

GetEnvValue endp




;***	GetFirst - get first directory entry from disk
;
;	ENTRY	DOS DTA established at DirBuf
;		FCB contains drive # and filename
;		Current directory (on selected drive) is the one to search
;		AttrSpecified & AttrSelect masks set
;
;	EXIT	CY = clear if success
;		DirBuf contains extended FCB for file found
;
;		If unsuccessful,
;		CY = set
;		Ready for DOS Get Extended Error call
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  FCB-7 = 0FFh to mark extended FCB
;	  FCB-1 = attribute mask to find all files
;	  These fields should remain unmodified for GetNext calls.
;
;
;***	GetNext - get next directory entry from disk
;
;	ENTRY	As for GetFirst, plus
;		FCB-7 set up as extended FCB w/ find-all attribute byte
;
;	EXIT	As for GetFirst
;
;	USED	AX,DX

GetFirst	proc

	mov	byte ptr ds:FCB-7,0FFh	; signal extended FCB
	mov	byte ptr ds:FCB-1,ATTR_ALL
					; find any file
	mov	dx,FCB-7		; DX = ptr to extended FCB
	mov	ah,DIR_SEARCH_FIRST	; AH = DOS Find First function code
	int	21h			; call DOS
	shl	al,1			; CY = set if error
	jc	gfRet			; return error
	jmp	short gfFound		; go look at attr's

GetNext:
	mov	dx,FCB-7		; DX = ptr to extended FCB
	mov	ah,DIR_SEARCH_NEXT	; AH = DOS Find Next function code
	int	21h			; call DOS
	shl	al,1			; CY = set if error
	jc	gfRet			; return error

;*	Found an entry.  Check attributes.

gfFound:
	mov	al,[DirBuf+8].dir_attr	; AL = file attributes
	mov	ah,AttrSpecified	; AH = mask of pertinent attr's
	and	al,ah			; AL = pertinent attr's of file
	and	ah,AttrSelect		; AH = attr settings to match
	cmp	al,ah
	jne	GetNext			; attr's don't match, look for another

gfRet:	ret

GetFirst	endp




;***	ListDir - search for and list files in the current directory
;
;	List header, files, and trailer for current directory on selected
;	drive.  Header & trailer are listed if at least one file is found.
;	If no qualifying files are found, no display output occurs.
;
;	ENTRY	Current directory (on selected drive) is the one to be listed
;		FCB contains selected drive # and filename spec
;		Option bits, attribute masks, and sort codes set up
;
;	EXIT	CY = clear if no error
;		FileCnt = # files found & displayed
;
;		If error,
;		CY = set
;		Ready for DOS Get Extended Error call
;
;	USED	AX,BX,CX,DX,SI,DI,BP
;		FileSiz
;
;	EFFECTS
;
;	  FileCntTotal, FileSizTotal are updated.
;	  Files found are listed.  A directory header and trailer are
;	   displayed only if files are found.

ListDir	proc

	xor	ax,ax
	mov	FileCnt,ax		; zero file count
	mov	word ptr FileSiz,ax	; zero file size accumulator
	mov	word ptr FileSiz+2,ax
ifdef DBLSPACE_HOOKS
	mov	ccluUsedDir, ax 	; zero count clusters used
	mov	word ptr csecUsedDir, ax ;zero count compressed sectors used
	mov	word ptr csecUsedDir+2, ax
endif
	cmp	DestBuf,0		; check for sort code
	je	@F			; no sort
	call	LoadEntries		; load entries for sorted listing
	jnc	@F			; no error - continue
	invoke	Get_Ext_Error_Number	; AX = DOS error code
	stc
	jmp	short ldErr		; return error
@@:
	call	FindFirst		; find first file
	jc	ldErr			; not found, return error

;	BX = offset in TPA buffer of entry found

	call	DisplayHeader		; if at least one file, display header
	call	DisplayFile		; display the file entry
ldNext:
	call	FindNext		; find another file
	jc	ldErr			; not found
	call	DisplayFile		; display entry
	jmp	ldNext			; go find another one

ldErr:
	cmp	ax,ERROR_FILE_NOT_FOUND
	je	ldDone			; file not found, we're done
	cmp	ax,ERROR_NO_MORE_FILES
	je	ldDone			; no more files, we're done
	stc
	jmp	short ldRet

ldDone:
	cmp	FileCnt,0
	je	@F			; no files found, just return
	call	DisplayTrailer		; display trailing info
@@:	clc				; return success

ldRet:	ret

ListDir	endp




;***	LoadEntries - attempt to load entries from current directory
;
;	Load all qualifying directory entries from the current directory
;	into the TPA.  If an error is returned by FindFirst/FindNext calls
;	other than 'no more files', return to caller with carry flag set.
;	If we run out of buffer space, display a message that we haven't
;	enough memory to sort this directory, but return without error.
;	Other routines know whether or not entries have been loaded by
;	the 'inmem' flag bit, which we set here.
;
;	The TPA is usually 64K - 512 bytes long.  At 20 bytes per entry,
;	this allows sorting over 3000 entries in a directory.
;
;	ENTRY	Tpa = buffer seg addr
;		BytCnt = buffer length, in bytes
;		Current directory (on selected drive) is the one to load
;		FCB contains drive # and filespec
;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
;
;	EXIT	CY = set if error
;		If error, DOS Get Extended Error will get error info
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Inmem bit of Bits = set if load succeeded.
;	  Tpa buffer contains directory entries.
;	  Byte after last entry = 0FFh.

LoadEntries	proc

	push	es			; save TRANGROUP seg addr
	mov	es,Tpa			; ES = TPA seg addr
	xor	di,di			; ES:DI = destination ptr
	and	Bits,not mask inmem	; signal entries not loaded

	call	GetFirst		; look for first file
	jc	leRet			; return any error
	call	LoadEntry		; load entry into TPA

leNext:	call	GetNext			; get another file
	jc	leLoaded		; assume any error is no more files
	mov	ax,BytCnt		; AX = size of TPA
	sub	ax,di			; AX = bytes left in TPA
	cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
	jb	leOk			; not enough memory left, give up
	call	LoadEntry		; load entry into TPA
	jmp	leNext			; go get another file

leLoaded:
	mov	byte ptr es:[di],0FFh	; mark end of entry list
	or	Bits,mask inmem		; signal entries loaded in memory
leOk:	clc				; return no error

leRet:	pop	es			; ES = TRANGROUP seg addr again
	ret

LoadEntries	endp




;***	LoadEntry - load directory entry from DirBuf ext'd FCB
;
;	ENTRY	ES:DI = ptr to load point in TPA
;		DirBuf contains extended FCB of entry to load
;
;	EXIT	ES:DI = ptr to next byte available in TPA
;
;	USED	AX,CX,SI
;
;	NOTES
;
;	  I could've used symbolic offsets and sizes of fields from
;	   the dir_entry struc to do this, but this is time-critical,
;	   so I hard-wired the structure of the DOS 4.x returned FCB,
;	   as well as our private directory entry structure.
;
;	  We force a zero size for subdirectory files.  A zero size is
;	   ordinarily returned for subdirectories, but with Novell
;	   Netware 286 or 386 loaded, we can't depend on it.  Bug #1594.

LoadEntry	proc

	mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
	xor	al,al				; AL = 0
	stosb					; 'used' byte = false
	mov	cx,11
	rep	movsb				; transfer filename & extension
	lodsb					; AL = attrib byte
	stosb					; store attrib byte
	add	si,dir_time-dir_attr-1		; skip to time field
	movsw					; transfer time
	movsw					; transfer date
ifdef DBLSPACE_HOOKS
	mov	cl, al				; attrib to cl
	lodsw					; allocation unit (cluster)
else
	inc	si				; skip alloc unit
	inc	si
endif

ifdef DBLSPACE_HOOKS
	and	cl,ATTR_DIRECTORY
else
	and	al,ATTR_DIRECTORY
endif
	jnz	leSetDirSize			; force zero size for subdir

	movsw
	movsw					; transfer size

ifdef DBLSPACE_HOOKS
	test	Bits, mask cratio		; compression ratio report?
	jnz	leCalcRatio			; yup

	xor	ax, ax
	stosb					; dummy compression ratio
endif
	ret

ifdef DBLSPACE_HOOKS
leCalcRatio:
	call	CalcCompRatio			; takes cluster in AX
	or	ax, ax				;   returns ratio in AX
	jz	leNoRatio			; 0 means couldn't calculate
	dec	ah				; pack 1.0 - 16.0 comp ratio
	mov	cl, 4				;   into 2 nibbles.  Store
	shl	ah, cl				;   1-16 as 0-15 in hi nibble,
	or	al, ah				;   tenths (0-9) in low nibble
	stosb
	ret
endif

leSetDirSize:
	xor	ax,ax
	stosw
	stosw					; store zero size

ifdef DBLSPACE_HOOKS
leNoRatio:
	dec	al				; al = FFh = special invalid
	stosb					; compression ratio
endif
	ret

LoadEntry	endp




;***	NoOrder - turn sorting off
;
;	ENTRY	nothing
;
;	EXIT	CY clear
;
;	USED	AX
;
;	EFFECTS
;
;	  DestBuf is updated with sort code bytes.  See DestBuf description.

NoOrder	proc

	mov	DestBuf,0	; no sort
	clc			; no error
	ret

NoOrder	endp




;***	OnOffSw - record occurence of on/off option switch
;
;	ENTRY	DI = index into word list of switches
;
;	EXIT	CY clear
;
;	USED	AX,CX
;
;	EFFECTS
;
;	  Bits modified to indicate option state.

OnOffSw	proc

	mov	cx,di		; CX = index into word list of options
	shr	cx,1
	shr	cx,1		; CX = bit position of option
	mov	ax,1		
	shl	ax,cl		; AX = bit mask of option
	test	di,2		; check if it is a negated option
	jz	@F		; it's negated
	or	Bits,ax		; turn option on
	jmp	short ooRet

@@:	not	ax		; AX = complemented bit mask of option
	and	Bits,ax		; turn option off

ooRet:	clc			; always return success
	ret

OnOffSw	endp




;***	ParseAttr - parse and record /A option
;
;	ENTRY	BX = ptr to system parser result buffer for /A occurence
;
;	EXIT	CY = set if error occurs parsing attribute conditions
;
;		For parse error, we set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,CX,DX,DI
;
;	EFFECTS
;
;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
;	  If parse error occurs, attribute conditions parsed so far hold.
;
;	  For parse error, we set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

ParseAttr	proc

	push	si			; save SI
	mov	AttrSpecified,0		; cancel all attribute conditions

;	Each /A invocation starts by assuming all files are to be listed.

	mov	si,word ptr [bx].ValuePtr ; SI = ptr to string after /A

paLoop:	mov	dx,1			; DX = 1 (for un-negated attribute)

	lodsb				; AL = next char in string
	or	al,al
	jz	paOk			; it's terminating null, we're done
	cmp	al,'-'
	jne	@F			; not '-', go look for letter
	dec	dx			; DX = 0 (for negated attribute)
	lodsb				; AL = next char
@@:	
	mov	di,offset TRANGROUP:AttrLtrs  ; DI = ptr to attrib letter list
	mov	cx,NUM_ATTR_LTRS	; CX = length of attrib letter list
	repne	scasb			; look for our letter in the list
	jne	paErr			; not found, return error

	not	cx
	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5

;	Note that we rely on AttrLtrs to be in the attribute bit order,
;	starting from bit 0.

;	Record this attribute bit in AttrSpecified.

	mov	al,1
	shl	al,cl			; AL = mask for our bit
	or	AttrSpecified,al	; set it in the 'specified' mask

;	Record the selected state for this attribute in AttrSelect.
;	DX = 0 or 1, the selected state for this attribute.

	not	al			; AL = mask for all other bits
	and	AttrSelect,al		; clear our bit
	shl	dl,cl			; DL = our bit state in position
	or	AttrSelect,dl		; set selected attr state
	jmp	paLoop			; go look at next char

;	The attribute letter string is invalid.

paErr:	
	call	SetupParamError		; set message up for Std_EPrintf
	stc		   		; return error
	jmp	short paRet

paOk:	clc				; return success		

paRet:	pop	si			; restore SI
	ret

ParseAttr	endp




;***	ParseLine - parse a line of text
;
;	Parse text until an EOL (CR or NUL) is found, or until a parse
;	error occurs.
;
;	ENTRY	DS:SI = ptr to text
;		CS, DS, ES = TRANGROUP seg addr
;
;	EXIT	AX = last return code from system parser
;		CX = # positional parameters (pathnames) found - 0 or 1
;
;		If parse error occurred, we're set up for Std_EPrintf call:
;		DX = ptr to message block
;
;	USED	BX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;	  SrcBuf may contain a new default pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.
;
;	  If parse error occurred, we're set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error class
;	  Byte after last parameter in text is zeroed to make ASCIIZ string
;	  Message block (see DX) is set up for parse error message

ParseLine	proc

	mov	di,offset TRANGROUP:Parse_Dir	 ; ES:DI = ptr to parse block
	xor	cx,cx				 ; CX = # positionals found
plPars:
	invoke	Parse_With_Msg		; call parser
	cmp	ax,END_OF_LINE
	je	plRet			; EOL encountered, return
	cmp	ax,RESULT_NO_ERROR
	jne	plRet			; parse error occurred, return

;	Parse call succeeded.  We have a filespec or a switch.
;	DX = ptr to result buffer

	mov	bx,dx			; BX = ptr to parse result buffer
	cmp	byte ptr [bx],RESULT_FILESPEC
	je	plFil			; we have a filespec

	call	ParseSwitch		; else we have a switch
	jc	plRet			; error parsing switch, return
	jmp	plPars			; parse more

plFil:	call	CopyPathname		; copy pathname into our buffer
	jmp	plPars			; parse more

plRet:	ret

ParseLine	endp




;***	ParseOrder - parse and record /O option
;
;	ENTRY	BX = ptr to system parser result buffer for /O occurence
;
;	EXIT	CY = set if error occurs parsing order
;
;		For parse error, we set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,CX,DX,DI
;
;	EFFECTS
;
;	  DestBuf is updated with sort code bytes.  See DestBuf description.
;
;	  For parse error, we set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

ParseOrder	proc

	push	si				; save SI
	push	bx				; save ptr to result buffer

	mov	si,word ptr [bx].ValuePtr	; SI = ptr to order letters
	mov	bx,offset TRANGROUP:DestBuf	; BX = ptr to sort code buffer
	mov	al,[si]				; AL = 1st char of order string
	or	al,al
	jnz	poLtr			; not NUL, go parse letters

;	We have /O alone.  Set standard sort order.
;	Note hardwired dependency on character order in OrderLtrs.

	mov	byte ptr [bx],5		; sort 1st by group (subdirs 1st)
	inc	bx
	mov	byte ptr [bx],1		; then by name
	inc	bx
	mov	byte ptr [bx],2		; then by extension
	inc	bx
	jmp	short poOk		; return success

;	We have /O<something>.  Parse sort order letters.

poLtr:	xor	dl,dl			; DL = 0 (upward sort)
	lodsb				; AL = next sort order letter
	or	al,al
	jz	poOk			; NUL found, return success

	cmp	al,'-'
	jne	@F			; not '-', go look for letter
	mov	dl,80h			; DL = downward sort mask
	lodsb				; AL = next char
@@:
	mov	di,offset TRANGROUP:OrderLtrs  ; DI = ptr to list of letters
	mov	cx,NUM_ORDER_LTRS	; CX = length of list
	repne	scasb			; look for our letter in the list
	jne	poErr			; not found, return error

	neg	cx
	add	cx,NUM_ORDER_LTRS	; CL = sort order code, 1-6
ifdef DBLSPACE_HOOKS
	cmp	cl, CRATIO_ORDER	; force compression ratio reporting
	jne	poSet			;   on if sorting by ratio selected.
	or	Bits, mask cratio
poSet:
endif
	or	cl,dl			; CL = sort code with up/dn bit
	mov	[bx],cl			; store sort order code in buffer
	inc	bx			; BX = ptr to next spot in buffer
	cmp	bx,offset TRANGROUP:EndDestBuf
	jae	poErr			; too many letters

	jmp	poLtr			; go look at next char

;	The sort order string is invalid.  

poErr:	pop	bx			; BX = ptr to result buffer
	call	SetupParamError		; set message up for Std_EPrintf
	stc				; return failure
	jmp	short poRet

poOk:	mov	byte ptr [bx],0		; mark end of sort code list
	pop	bx			; BX = ptr to result buffer
	clc				; return success

poRet:	pop	si			; restore SI
	ret

ParseOrder	endp


ifdef DBLSPACE_HOOKS
;***	ParseRatio - parse and record /C[H] option
;
;	ENTRY	BX = ptr to system parser result buffer for /C occurence
;		DI = index into word list of switches
;
;	EXIT	CY = set if error occurs parsing order
;
;		For parse error, we set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,CX,DX,DI
;
;	EFFECTS
;
;	  Bits modified to indicate option state.
;	  fUseHostSize is set to zero for /C, non-zero for /CH.
;
;	  For parse error, we set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

ParseRatio	proc

	call	OnOffSw 	; turn on option bit

	push	si				; save SI

	mov	si,word ptr [bx].ValuePtr	; SI = ptr to possible H option
	mov	al,[si] 			; AL = null or 'H'
	or	al,al
	jz	prDone			; if null, no H option to check

	cmp	al, 'H' 		; only H is allowed, make sure that's
	je	prDone			;   what it is

	call	SetupParamError		; set message up for Std_EPrintf
	stc				; return failure
	jmp	short prRet

prDone:
	mov	fUseHostSize, al	; set Host cluster size flag
	clc

prRet:	pop	si
	ret

ParseRatio	endp
endif



;***	ParseSwitch - parse a switch
;
;	ENTRY	BX = ptr to parse result buffer after system parser processed
;		     a switch
;
;	EXIT	CY = set if parse error occurred
;
;		If parse error occurred, we're set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,BX,DX
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;
;	  If parse error occurred, we're set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error class
;	  Byte after last parameter in text is zeroed to make ASCIIZ string
;	  Message block (see DX) is set up for parse error message

ParseSwitch	proc

	push	cx			; save CX
	push	di			; save DI

	mov	ax,[bx].SynPtr		; AX = synonym ptr
	mov	di,offset TRANGROUP:Dir_Sw_Ptrs
					; ES:DI = ptr to list of synonym ptrs
	mov	cx,NUM_DIR_SWS		; CX = # of dir switches in list
	cld				; scan direction = upward
	repne	scasw			; locate synonym ptr in list
	sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2

;	DI = index into word list of synonym ptrs

	call	cs:SwHandlers[di]	; use same index into call table

	pop	di			; restore DI
	pop	cx			; restore CX

	ret

;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
;	Simple on/off switches must occur first in both lists, and must be
;	  in order of option bits in Bits, starting with bit 0.

SwHandlers	label	word
ifdef DBLSPACE_HOOKS
	dw	OnOffSw 	; /-C
	dw	ParseRatio	; /C[H]
endif
	dw	OnOffSw		; /-W
	dw	OnOffSw		; /W
	dw	OnOffSw		; /-P
	dw	OnOffSw		; /P
	dw	OnOffSw		; /-S
	dw	OnOffSw		; /S
	dw	OnOffSw		; /-B
	dw	OnOffSw		; /B
	dw	OnOffSw		; /-L	;M010
	dw	OnOffSw		; /L	;M010
	dw	NoOrder		; /-O
	dw	ParseOrder	; /O
	dw	DefaultAttr	; /-A
	dw	ParseAttr	; /A

ParseSwitch	endp



	break	<DIR utility routines>

;***	UTILITY ROUTINES




;***	ChangeDir - change directory on target drive
;
;	ENTRY	FCB contains drive #
;		DS:DX = ptr to ASCIIZ string w/o drive specifier
;
;	EXIT	Changed current directory on drive
;
;		If error,
;		CY = set
;		DOS Get Extended Error call will get error
;
;	USED	AX,DX,SI,DI
;
;	EFFECTS
;
;	  DirBuf is used to build "d:string".

ChangeDir	proc

	mov	di,offset TRANGROUP:DirBuf
	call	GetDriveLtr	; AX = "d:"
	stosw			; put drive specifier in buffer
	mov	si,dx		; SI = ptr to argument string
cdLoop:
	lodsb
	stosb			; move byte to buffer
	or	al,al
	jne	cdLoop		; continue until null transferred

	mov	dx,offset TRANGROUP:DirBuf	; DX = ptr to "d:string"
	mov	ah,CHDIR
	int	21h				; change directory
	ret					; return what CHDIR returns

ChangeDir	endp




;***	CmpAscz - compare two ASCIIZ strings alphanumerically
;
;	ENTRY	DS:SI = ptr to one ASCIIZ string
;		ES:DI = ptr to another ASCIIZ string
;
;	EXIT	flags set after REPE CMPSB
;
;	USED	AL,CX,SI,DI
;
;	NOTES
;
;	Maximum run of comparison is length of DS:SI string.
;	This ensures that two identical strings followed by
;	random characters will compare correctly.

CmpAscz	proc

	push	di

	mov	di,si
	xor	al,al
	mov	cx,0FFFFh
	repne	scasb
	not	cx

	pop	di
	repe	cmpsb
	ret

CmpAscz	endp




;***	CopyPathname - copy pathname to our buffer
;
;	ENTRY	BX = ptr to parse result buffer after system parser processed
;		     a filespec
;
;	EXIT	nothing
;
;	USED	AX
;
;	EFFECTS
;
;	  SrcBuf may contain a new pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.

CopyPathname	proc

	push	si
	lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
	invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
	pop	si
	ret

CopyPathname	endp



;***	CountFile - update counters with current file
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.

CountFile	proc

	push	es			; save TRANGROUP seg addr
	mov	es,Tpa			; ES = TPA seg addr

	inc	FileCnt			; # files this directory
	inc	word ptr FileCntTotal	; # files total
	jnz	@F
	inc	word ptr FileCntTotal+2
@@:
	mov	ax,word ptr es:[bx].filesize	; AX = low word of file size
	mov	dx,word ptr es:[bx].filesize+2	; DX = high word of file size
	add	word ptr FileSiz,ax
	adc	word ptr FileSiz+2,dx		; size of this directory
	add	word ptr FileSizTotal,ax
	adc	word ptr FileSizTotal+2,dx	; total size of files listed

	pop	es			; ES = TRANGROUP seg addr again
	ret

CountFile	endp



;***	DisplayBare - display filename in bare format
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	DX = # char's displayed, including dot
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS
;
;	  Filename is displayed in name.ext format, followed by cr/lf.
;	  If /s is on, complete pathname is displayed.
;
;	NOTE
;
;	  Directory pseudofiles . and .. and suppressed in bare listing.

DisplayBare	proc

;	Suppress . and .. files from bare listing.

	mov	cx,ds			; CX = saved TRANGROUP seg addr
	mov	ds,Tpa			; DS:BX = ptr to file entry
	assume	ds:NOTHING
	cmp	ds:[bx].filename,'.'	; check 1st char of filename
	mov	ds,cx			; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP
	je	dbRet			; it's . or .. - don't display

	test	Bits,mask subd
	jz	dbNameExt		; not /s - display filename only

	invoke	Build_Dir_String
	mov	di,offset TRANGROUP:BwdBuf	; ES:DI = ptr to dir string
   
	test	Bits,mask lcase		;M010;check for lowercase option
	jz	@F			;M010;lowercase not needed
	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
	call	LowercaseString		;M010;path string is in BwdBuf

@@:	xor	al,al			; AL = 0
	mov	cx,0FFFFh
	cld
	repne	scasb			; ES:DI = ptr to byte after null
	dec	di			; ES:DI = ptr to null byte

ifdef DBCS
	push	si
	push	di
	mov	si,offset TRANGROUP:BwdBuf
	dec	di
	call	CheckDBCSTailByte
	pop	di
	pop	si
	jz	dbTailByte		; if last char is double byte
endif

	cmp	byte ptr es:[di-1],'\'
	je	@F			; already terminated w/ '\'

ifdef DBCS
dbTailByte:
endif

	mov	ax,'\'			; AX = '\',0
	stosw				; add to dir string
@@:
	mov	String_Ptr_2,offset TRANGROUP:BwdBuf
	mov	dx,offset TRANGROUP:String_Buf_Ptr
	invoke	Std_Printf		; display device & directory path

dbNameExt:
	call	DisplayDotForm		; display name.ext
	invoke	CrLf2			; display cr/lf
	call	UseLine			;M007;Allow /p with /b
dbRet:	ret

DisplayBare	endp




;***	DisplayDotForm - display filename in compressed dot format
;
;	Display name.ext, with no cr/lf's.  Dot is displayed only
;	if the filename has a nonblank extension.
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	DX = # char's displayed, including dot
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS
;
;	  Filename is displayed in name.ext format.
;
;	NOTE
;
;	  We allow for bogus filenames that have blanks embedded
;	  in the name or extension.

;	Bugbug:	might be a good performance gain if we buffered
;	up the output and used DOS function 9.

DisplayDotForm	proc

	push	ds			; save TRANGROUP seg addr
	push	es			; save ES
	mov	ax,cs:Tpa		; AX = TPA seg addr
	mov	ds,ax			; DS:BX = ptr to entry
	assume	ds:nothing
	mov	es,ax			; ES:BX = ptr to entry

	mov	di,bx			; ES:DI = ptr to entry
	add	di,filename + size filename - 1
					; ES:DI = ptr to last char in name field
	mov	cx,size filename	; CX = length of name field
	mov	al,' '
	std				; scan down
	repe	scasb			; scan for nonblank

;	Assume file name has at least one character.

	inc	cx			; CX = # chars in name
	mov	dx,cx			; DX = # chars to be displayed

	mov	si,bx			; DS:SI = ptr to entry
	add	si,filename		; DS:SI = ptr to name

NextNameChar:
	cld
	lodsb				; AL = next char

ifdef DBCS
	invoke	testkanj
	jz	@f			; if this is not lead byte
	invoke	Print_Char		; display lead byte
	dec	cx
	jz	ExtChar			; if this is end
	lodsb				; get tail byte
	jmp	short NameChar10	; display tail byte
@@:
endif

	test	Bits,mask lcase		;M010;check for lowercase option
	jz	@F			;M010;lowercase not required
	call	LowerCase		;M010;filename char is in AL

ifdef DBCS
NameChar10:
endif

@@:	invoke	Print_Char		; display it
	loop	NextNameChar

ifdef DBCS
ExtChar:
endif

;	Now do extension.

	mov	di,bx			; ES:DI = ptr to entry
	add	di,fileext + size fileext - 1
					; ES:DI = ptr to last char in ext field
	mov	cx,size fileext		; CX = length of ext field
	mov	al,' '
	std				; scan down
	repe	scasb			; scan for nonblank
	je	ddDone			; no nonblank chars in ext

	inc	cx			; CX = # chars in ext
	add	dx,cx			; DX = total # chars to be displayed
	inc	dx			;      including dot

	mov	al,'.'
	invoke	Print_Char
	mov	si,bx			; DS:SI = ptr to entry
	add	si,fileext		; DS:SI = ptr to ext

NextExtChar:
	cld
	lodsb				; AL = next char

ifdef DBCS
	invoke	testkanj
	jz	@f			; if this is not lead byte
	invoke	Print_Char		; display lead byte
	dec	cx
	jz	ddDone			; if this is end
	lodsb				; get tail byte
	jmp	short ExtChar10		; display tail byte
@@:
endif

	test	CS:Bits,mask lcase	;M010;check for lowercase option
	jz	@F			;M010;lowercase not required
	call	LowerCase		;M010;fileext char is in AL

ifdef DBCS
ExtChar10:
endif

@@:	invoke	Print_Char		; display it
	loop	NextExtChar

ddDone:	pop	es			; restore ES
	pop	ds			; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP
	cld				; leave direction flag = up
	ret

DisplayDotForm	endp




;***	DisplayFile - display file entry, update counters
;
;	ENTRY	BX = offset of entry in TPA buffer
;		Bits contains /w, /p settings
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  Entry is displayed.  
;	  If not /b,
;	    Cursor is left at end of entry on screen.
;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
;	  If /b,
;	    Cursor is left at beginning of next line.
;	    Cnt's and Siz's aren't updated.

DisplayFile	proc

	test	Bits,mask bare
	jz	dfNorm			; not /b - do normal display

	call	DisplayBare		; display file in bare format
	jmp	short dfRet

dfNorm:	call	DisplayNext		; pos'n cursor for next entry
	test	Bits,mask wide
	jz	dfFull			; full format
	call	DisplayWide		; wide format
	jmp	short dfCnt

dfFull:	call	DisplayName		; display filename & extension
	call	DisplayTheRest		; display size, date, time
ifdef DBLSPACE_HOOKS
	test	Bits,mask cratio	; display compression ratio
	jz	dfCnt
	call	DisplayCompRatio
endif
dfCnt:	call	CountFile		; update file counters
dfRet:	ret

DisplayFile	endp




;***	DisplayHeader - display directory header of working directory
;
;	ENTRY	Current directory (on selected drive) is the one to display
;		LeftOnPage = # lines left on display page
;
;	EXIT	nothing
;
;	ERROR EXIT
;
;	  Build_Dir_String will exit through CError with "Invalid drive
;	   specification" if there's a problem obtaining the current 
;	   directory pathname.
;
;	USED	AX,DX,SI,DI
;
;	EFFECTS
;
;	  BwdBuf (which is really the same buffer as DirBuf, which
;	   we are using for the DTA) contains the directory string.
;	  LeftOnPage is adjusted.

DisplayHeader	proc

	test	Bits,mask bare
	jnz	dhRet			; /b - don't display header

	test	Bits,mask subd
	jz	dhNorm			; not /s

;	For subdirectory listings, put a blank line before the header.

	invoke	Crlf2			; start with a blank line
	call	UseLine
	jmp	short dhCom
dhNorm:
	mov	al,BLANK		; if not /s, precede by a blank
	invoke	Print_Char		; print a leading blank
dhCom:
	invoke	Build_Dir_String
	mov	dx,offset TRANGROUP:DirHead_ptr
	invoke	Std_Printf		; print header & cr/lf
	call	UseLine
	invoke	Crlf2			; another cr/lf
	call	UseLine
dhRet:	ret

DisplayHeader	endp




;***	DisplayName - display file name & extension
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Filename & extension are displayed in spread format.
;	  Cursor is left at end of extension.

DisplayName	proc

	push	ds				; save TRANGROUP seg addr
	mov	ds,Tpa				; DS:BX = ptr to entry
	assume	ds:nothing
	mov	si,bx				; DS:SI = ptr to entry
	add	si,filename			; DS:SI = ptr to filename
	mov	di,offset TRANGROUP:CharBuf	; ES:DI = ptr to CharBuf

	mov	cx,8
	cld
	rep	movsb				; move filename to CharBuf
	mov	al,' '
	stosb					; add a blank
	mov	cx,3
	rep	movsb				; add extension
	xor	al,al
	stosb					; add a NULL

	pop	ds				; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP

	test	Bits,mask lcase			;M010;check for lowercase option
	jz	@F			        ;M010;lowercase not required
	mov	si,offset TRANGROUP:CharBuf	;M010;DS:SI --> ASCIIZ string
	call	LowercaseString			;M010;filename.ext string is in CharBuf

@@:	mov	String_Ptr_2,offset TRANGROUP:CharBuf
	mov	dx,offset TRANGROUP:String_Buf_Ptr
	invoke	Std_Printf			; print filename & extension
	ret

DisplayName	endp




;***	DisplayNext - move display cursor to next entry position
;
;	ENTRY	LeftOnLine = # entries can still be printed on this line
;		LeftOnPage = # lines can still be printed for this page
;		FileCnt = # files in this dir displayed before this one
;		Bits contains /w setting
;
;	EXIT	nothing
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  LeftOnLine will be updated to reflect the entry about to be
;	   displayed.
;	  LeftOnPage may be updated.

DisplayNext	proc

	cmp	FileCnt,0
	je	dn1st			; 1st file in directory
	cmp	LeftOnLine,0
	jng	dnEol			; no more room on this line

;	We are in wide mode (LeftOnLine is always 0 otherwise) and
;	we still have room for more on this line.
;	Tab to next position.

	mov	dx,offset TRANGROUP:Tab_Ptr
	invoke	Std_Printf
	jmp	short dnDone

dnEol:	

;	Start this entry on a new line.

	invoke	Crlf2		; start on new line
	call	UseLine
dn1st:	mov	al,PerLine
	mov	LeftOnLine,al	; reset # entries left on line

dnDone:	dec	LeftOnLine	; reflect the entry about to be displayed
	ret

DisplayNext	endp




;***	DisplayTheRest - display file size/dir, date, time
;
;	ENTRY	BX = offset of entry in TPA buffer
;		Display cursor is at end of file extension
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  File size, date, & time are displayed.

DisplayTheRest	proc

	push	es			; save TRANGROUP seg addr
	mov	es,Tpa			; ES = TPA seg addr
	mov	bp,bx			; BP = offset of entry in TPA
	test	es:[bp].fileattr,ATTR_DIRECTORY
	jz	drNonDir		; not a directory file

;	For a directory file, display <DIR> instead of size.

	mov	dx,offset TRANGROUP:DMes_Ptr
	invoke	Std_Printf
	jmp	short drCom		; skip to common fields

drNonDir:

;	For a non-directory file, display file size.

	mov	dx,word ptr es:[bp].filesize
	mov	File_Size_Low,dx
	mov	dx,word ptr es:[bp].filesize+2
	mov	File_Size_High,dx
	mov	dx,offset TRANGROUP:Disp_File_Size_Ptr
	invoke	Std_Printf

drCom:

;	For all files, display date & time.

	mov	ax,es:[bp].filedate	; AX = date word
	or	ax,ax			; test for null date (DOS 1.x)
	jz	drDone			; no date, skip date/time display
	mov	bx,ax			; BX = date word
	and	ax,1Fh			; AX = day of month
	mov	dl,al			; DL = day of month
	mov	ax,bx			; AX = date word
	mov	cl,5
	shr	ax,cl			; shift day out
	and	al,0Fh			; AL = month
	mov	dh,al			; DH = month
	mov	cl,bh
	shr	cl,1			; CL = year - 1980
	xor	ch,ch			; CX = year - 1980
	add	cx,80			; CX = 2-digit year
	cmp	cl,100
	jb	@F			; not year 2000 yet, skip ahead
	sub	cl,100			; adjust for 21st century
@@:	xchg	dh,dl			; DX = month/day
	mov	DirDat_Yr,cx		; move year to msg block
	mov	DirDat_Mo_Day,dx	; move month/day to msg block
	mov	cx,es:[bp].filetime	; CX = file time
	jcxz	drPrint			; no time field - go print
	shr	cx,1
	shr	cx,1
	shr	cx,1			; CH = hours
	shr	cl,1
	shr	cl,1			; CL = minutes
	xchg	ch,cl			; CX = hr/min
	mov	DirTim_Hr_Min,cx	; move time to msg block
drPrint:mov	dx,offset TRANGROUP:DirDatTim_Ptr
	invoke	Std_Printf		; print date & time

drDone:	pop	es			; ES = TRANGROUP seg addr again	
	mov	bx,bp			; BX = offset of entry in TPA again
	ret

DisplayTheRest	endp

ifdef DBLSPACE_HOOKS
;***	DisplayCompRatio - display compression ratio
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,CX,DX
;
;	EFFECTS
;
;	  File compression ratio is displayed.


DisplayCompRatio	proc

	push	es			; save TRANGROUP seg addr
	mov	es,Tpa			; ES = TPA seg addr
	mov	al, es:[bx].compratio
	cmp	al, 0FFh		; invalid/no compression ratio?
	je	dcrRet

	mov	ah, al			; unpack compression ratio
	mov	cl, 4
	shr	ah, cl			; isolate whole number portion
	inc	ah			; 0-15 = 1-16
	and	al, 0Fh 		; isolate tenths

	mov	Dir_CRatio_1, ah
	mov	Dir_CRatio_2, al
	mov	dx, offset TRANGROUP:DirCompRatio_Ptr
	invoke	Std_Printf
dcrRet:
	pop	es

	ret

DisplayCompRatio	endp
endif

;***	DisplayTrailer - display trailing lines for directory listing
;
;	ENTRY	LeftOnPage = # lines left on display page
;		FileCnt = # files listed
;		FileSiz = total size of files listed
;
;	EXIT	nothing
;
;	USED
;
;	EFFECTS
;
;	  Trailing info lines are displayed

DisplayTrailer	proc

	test	Bits,mask bare
	jnz	dtrRet				; /b - don't display trailer

	invoke	Crlf2				; start on new line
	call	UseLine
	mov	ax,FileCnt			; AX = # files found

;	DisplayTotals uses this entry point.
;
DisplayCntSiz:
ifdef DBLSPACE_HOOKS
	test	Bits, mask cratio
	jz	dtrSize

	push	ax				; save file size

	mov	ax, [ccluUsedDir]
	or	ax, ax
	jz	dtrSkipRatio

	mov	cx, word ptr [csecUsedDir+2]
	mov	bx, word ptr [csecUsedDir] ; cx:bx = # compressed sectors used

	call	ComputeRatio		; ax=clusters used, cx:bx=sectors used

	mov	Dir_CRatio_1, ah			; 1 - 16
	mov	Dir_CRatio_2, al			; tenths
	mov	dx,offset TRANGROUP:AveCompRatio_Ptr
	invoke	Std_Printf
	call	UseLine

dtrSkipRatio:
	pop	ax				; restore file size

dtrSize:
endif
;	AX = # files
;	FileSiz = dword total size of files

	mov	Dir_Num,ax			; load # files
	mov	dx,offset TRANGROUP:DirMes_Ptr	; DX = ptr to message block
	invoke	Std_Printf			; "nnn File(s)"

	mov	dx,offset TRANGROUP:Bytes_Ptr
	invoke	Std_Printf			; "nnn bytes",cr,lf
	call	UseLine

dtrRet:	ret

DisplayTrailer	endp




;***	DisplayWide - display filename in wide format
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Name.ext is displayed.  Cursor left at end of field (padded
;	  with blanks).  Subdirectory files are displayed as [name.ext].

DisplayWide	proc

	push	ds				; save TRANGROUP seg addr
	mov	ds,Tpa				; DS:BX = ptr to entry
	assume	ds:nothing

	test	ds:[bx].fileattr,ATTR_DIRECTORY
	jz	@F				; not a subdirectory file
	mov	al,'['
	invoke	Print_Char			; prefix subdirectory

@@:	call	DisplayDotForm			; display name.ext

;	DX = # chars displayed in name.ext

	test	ds:[bx].fileattr,ATTR_DIRECTORY
	jz	@F				; not a subdirectory file
	mov	al,']'
	invoke	Print_Char			; postfix subdirectory
@@:
;	Pad field with blanks.

	mov	cx,size filename + size fileext + 1
						; CX = field size
	sub	cx,dx				; CX = # pad char's
	jcxz	dwDone
	mov	al,' '

@@:	invoke	Print_Char
	loop	@B

dwDone:	pop	ds			; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP
	ret

DisplayWide	endp




;***	EndPage - end the current display page
;
;	ENTRY	LeftOnPage = # lines left on display page
;		Current directory (on selected drive) is the one being listed
;		Bits contains /p setting
;
;	EXIT	LeftOnPage = # lines left for next page
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  Pause is invoked to display a message and wait for a keystroke.
;	  BwdBuf (same as DirBuf) used to build directory string.

EndPage	proc

	test	Bits,mask pagd
	jz	epNew			; paged display isn't enabled

	push	bx			; save BX
	push	cx			; save CX

	invoke	Pause			; "Press any key to continue..."

	invoke	Build_Dir_String
	mov	dx,offset TRANGROUP:DirCont_Ptr
	invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf

	pop	cx			; restore CX
	pop	bx			; restore BX

epNew:	mov	ax,LinPerPag		; AX = # lines per page
	dec	ax			; AX = # lines till next EndPage
	mov	LeftOnPage,ax		; LeftOnPage = countdown variable

	ret

EndPage	endp




;***	GetDriveLtr - get target drive letter
;
;	ENTRY	FCB contains drive #
;
;	EXIT	AX = "d:"
;
;	USED	nothing

GetDriveLtr	proc

	mov	al,ds:Fcb	; AL = target drive #
	or	al,al
	jnz	@F		; not current drive default, skip ahead
	mov	al,ds:CurDrv	; AL = current drive #
	inc	al		; AL = 1-based drive #
@@:	add	al,'A'-1	; AL = target drive letter
	mov	ah,':'		; AX = "d:"
	ret

GetDriveLtr	endp





;***	SetupParamError - set up for Std_EPrintf parameter parse error message
;
;	Do for our /O and /A string parsers what Parse_With_Msg does
;	for system parser calls.  Set up a message substitution block,
;	etc. for invalid value strings.  I copied the procedure from
;	Setup_Parse_Error_Msg.
;
;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
;		
;
;	EXIT	AX = system parser error return code for bad param format
;		DX = ptr to message description block for Std_EPrintf
;
;	USED	SI
;
;	EFFECTS
;
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

SetupParamError	proc

	mov	ax,9			; parse error #
	mov	Msg_Disp_Class,PARSE_MSG_CLASS
	mov	Extend_Buf_Ptr,ax
	mov	si,word ptr [bx].ValuePtr
	mov	String_Ptr_2,si
	mov	Extend_Buf_Sub,ONE_SUBST
	mov	dx,offset TRANGROUP:Extend_Buf_Ptr
	ret

SetupParamError	endp




;***	UseLine - use a display line, start a new page if none left
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	flags

UseLine	proc

	dec	LeftOnPage
	cmp	LeftOnPage,2
	ja	ulRet
	call	EndPage
ulRet:	ret

UseLine	endp




;***	ZeroTotals - zero grand total file count, size
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX
;
;	EFFECTS
;
;	  FileCntTotal & FileSizTotal are zeroed.
;
;	NOTES
;
;	  FileCntTotal throuth csecUsedTotal must be together!
ifdef DBLSPACE_HOOKS
csecSIZE	EQU	size csecUsed + size csecUsedDir + size csecUsedTotal
ccluSIZE	EQU	size ccluUsed + size ccluUsedDir + size ccluUsedTotal
endif
ZeroTotals	proc

	mov	di,offset TRANGROUP:FileCntTotal
ifdef DBLSPACE_HOOKS
	mov	cx,size FileCntTotal+size FileSizTotal+csecSIZE+ccluSIZE
else
	mov	cx,size FileCntTotal+size FileSizTotal
endif
	xor	al,al
	rep	stosb
	ret	

ZeroTotals	endp




;***	CtrlCHandler - our own control-c handler
;
;	Make sure user's default directory gets restored.  See notes
;	at InstallCtrlCHandler.
;
;	ENTRY	control-c
;
;	EXIT	to OldCtrlCHandler
;
;	USED	DS,flags
;
;	EFFECTS
;
;	  Restore user's default directory.
;
;	NOTES
;
;	  This handler is only installed after calling PathCrunch,
;	  which sets UserDir1, so the restoration will work.
;
;	  The original control-c vector will be restored, whether
;	  or not this one is invoked, in the HeadFix routine.

CtrlCHandler	proc	far

;SR;
; Save all registers used: ds, dx, ax. I know ax is being used by the 
;CtrlC handler, am not sure about ds & dx. Save them to be safe
;

	push	ds
	push	cs
	pop	ds			; DS = TRANGROUP seg addr
	push	ax
ifdef DBLSPACE_HOOKS
	push	bx
endif
	push	dx

ifdef DBLSPACE_HOOKS
	call	CloseCVF		; close CVF file if open
endif
	invoke	RestUDir		; restore user's default directory

	pop	dx
ifdef DBLSPACE_HOOKS
	pop	bx
endif
	pop	ax
	pop	ds
	jmp	cs:OldCtrlCHandler		; go to previous int 23 handler

CtrlCHandler	endp


;M010;start
;***	LowerCase - convert ASCII character in AL to lowercase
;
;	ENTRY	AL = character to be displayed
;
;	EXIT	AL is lowercase
;
;	USED	nothing

LowerCase	proc

	assume	ds:NOTHING,es:NOTHING

	cmp	al,'A'			; ensure AL is in range 'A'-'Z'
	jb	lcRet
	cmp	al,'Z'
	ja	lcRet

	or	al,20h			; convert to ASCII lowercase (UpperCase+32)-->LowerCase

lcRet:	ret

LowerCase	endp




;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
;
;	ENTRY	DS:SI points to start of ASCIIZ string
;		ES = DS
;
;	EXIT	nothing
;	
;	USED	AL,SI

LowercaseString	proc

	assume	ds:NOTHING,es:NOTHING

	push	di			; save di
	mov	di,si			; ES:DI --> ASCIIZ string
	cld

NextChar: 
	lodsb				; get character from string into al
	or	al,al			; are we at end of string?
	jz	EndOfString

ifdef DBCS
	invoke	testkanj
	jz	@f			; if this is not lead byte
	stosb				; store lead byte
	lodsb				; get tail byte
	or	al,al
	jz	EndOfString		; if end
	stosb				; store tail byte
	jmp	short NextChar
@@:
endif

	call	LowerCase		; convert character to lowercase
	stosb				; store character back into buffer
	jmp	SHORT NextChar		; repeat until end of string

EndOfString:
	pop	di			; restore di
	ret

LowercaseString	endp
;M010;end	

ifdef DBCS
;
;	Check if the character position is at Tail Byte of DBCS
;
;	input:	ds:si = start address of the string
;		ds:di = character position to check
;	output:	ZF = 1 if at Tail Byte
;
CheckDBCSTailByte	proc	near
	push	ax
	push	cx
	push	di
	mov	cx,di			; save character position
cdtb_check:
	cmp	di,si
	jz	cdtb_next		; if at the top
	dec	di			; go back
	mov	al,[di]			; get character
	invoke	testkanj
	jnz	cdtb_check		; if DBCS lead byte do next
	inc	di			; adjust
cdtb_next:
	sub	cx,di			; if the length is odd then
	xor	cl,1			; the character position is
	test	cl,1			; at the tail byte
	pop	di
	pop	cx
	pop	ax
	ret
CheckDBCSTailByte	endp
endif


TRANCODE ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\cratio.asm ===
page	,132
	title	Calculate Compression Ratio Routines
;/*
; *                      Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1992
; *                      All Rights Reserved.
; */


;***	SYMBOLS & MACROS

	.xlist
	.xcref

	include version.inc

ifdef dblspace_hooks
	include dossym.inc	; get DOS basic symbol set
	include syscall.inc	; get DOS call names
	include	comseg.asm	; define segment order
	include comequ.asm	; get equates for COMMAND routines
	include magicdrv.inc	; for MagivDrv (compression ratio) support

	.list
	.cref

Get_Drive_Data	equ	28		; Int 21h/1Ch call

;***	DATA

TRANDATA segment public byte

	extrn	sCVFRoot:byte		; root name of CVF files
	extrn	cbCVFRoot:abs		; size of CVF root name string

TRANDATA ends


TRANSPACE segment public byte

	extrn	fhCVF:word		; Compressed Volume File file handle
	extrn	szCVF:byte		; Compressed Volume File file name
	extrn	MDBPB:byte		; Extended MagicDrv BPB
	extrn	csecUsed:dword		; count of compressed sectors used-file
	extrn	csecUsedDir:dword	; count of compressed sectors used-dir
	extrn	csecUsedTotal:dword	; count of compressed sectors used-total
	extrn	ccluUsed:word		; count of DOS clusters used - file
	extrn	ccluUsedDir:word	; count of DOS clusters used - dir
	extrn	ccluUsedTotal:word	; count of DOS clusters used - total

	extrn	Tpa:word		; TPA buffer seg addr
	extrn	CurDrv:byte		; current drive # (0-based)
	extrn	BytCnt:word		; # bytes in TPA
	extrn	savBytCnt:word		; copy of BytCnt when FAT buffers in TPA

	extrn	fUseHostSize:byte	; use host cluster size with /C
	extrn	csecPerCluster:byte	; sectors/cluster for ratio calculation

; The code to calculate compression ratios requires access to the drive's
; (DOS) FAT and MagicDrv FAT regions.  Two buffers are used (one for each
; FAT type).  pbufDOSFAT and pbufMDFAT contain the offset to the buffers,
; segFATBuf contains the segment (both buffers are in the same segment).
; The buffers are of variable size: cFATEntries contains the size of the
; buffers in terms of the number of FAT entries they can contain.

	extrn	cFATEntries:word	; size of FAT buffers in entries
	extrn	entInBuf:word		; 1st FAT entry in buffers
	extrn	segFATBuf:word		; DOS & MD FAT buffer segment
	extrn	pbufDOSFAT:word 	; pointer to DOS FAT buffer
	extrn	pbufMDFAT:word		; pointer to MagicDrv FAT buffer
	extrn	bufDOSFAT:byte		; small resident DOS FAT buffer
	extrn	bufMDFAT:byte		; small resident MD FAT buffer

TRANSPACE ends


TRANCODE segment public byte

	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP


;***	OpenCVF - open Compressed Volume File for compression ratio report
;
;	ENTRY
;		FCB setup with drive for DIR
;
;	EXIT	If successful, CY clear, CVF file open, fhCVF has file handle,
;		szCVF has \0 terminated CVF file name, MDBPB loaded.
;
;		If unsuccessful, CY set
;
;	USED	AX, BX, CX, DX, SI, DI

	public	OpenCVF

OpenCVF proc

	mov	ax, -1
	mov	fhCVF, ax		;indicate CVF not open
	mov	entInBuf, ax		;  and no FAT entries in buffers

	mov	dl, ds:[FCB]		;target drive of DIR cmd
	or	dl, dl			;default drive?
	jz	ocvf_default
	dec	dl			;no, from 1=A to 0=A
	jmp	short ocvf_swap_info

ocvf_default:
	mov	dl, ds:[CurDrv] 	;0=A, 1=B, ...

ocvf_swap_info:

	mov	ax, multMagicDrv	;magicdrv Int 2Fh multiplex ID
	mov	bx, MD_DRIVE_MAP	;get drive swap info
	int	2fh

	or	ax, ax			;0 if okay
	jnz	ocvf_error

	test	bl, 80h 		;80h set if compressed volume
	jz	ocvf_error

	and	bl, 7Fh 		;bl = host drive, bh = seq #

	; The CVF may have been mounted from a swapped host drive, in which
	; case the host drive returned in BL is the original host (now
	; swapped with a CVF).	Make a second drive swap info call on the
	; returned host to see if it must be accessed by a different drive
	; letter.

	push	bx
	push	dx			;save dl, orig drive letter

	mov	ax, multMagicDrv
	mov	dl, bl
	mov	bx, MD_DRIVE_MAP
	int	2fh

	pop	dx
	pop	cx			;bx from 1st drive swap info call

	or	ax, ax			;0 if okay
	jnz	ocvf_error

	and	bl, 7Fh
	xchg	bx, cx			;bx = 1st, cx = 2nd swap results

	cmp	dl, cl			;2nd swap info call return orig drive?
	jz	ocvf_got_host		;yes, 1st swap info call returned host

	mov	bl, cl			;no, use swapped host, orig seq #

ocvf_got_host:

	; Build the filename of the Compressed Volume File

	mov	di, offset TRANGROUP:szCVF	;CVF name buffer

	mov	al, bl
	add	al, 'A'
	mov	ah, ':'
	cld
	stosw					; drive:

	mov	si, offset TRANGROUP:sCVFRoot	; \name.
	mov	cx, cbCVFRoot
	rep movsb

	add	di, 3				; point past extension
	xor	al, al
	std
	stosb					; null terminate

	mov	al, bh				; seq #
	mov	bl, 10
	mov	cx, 3				; 3 digit ext/seq #
@@:
	xor	ah, ah				; convert seq # to ascii
	div	bl				;   and store as CVF extension
	add	ah, '0'
	xchg	ah, al
	stosb
	mov	al, ah
	loop	@b

	cld

	; Now open the Compressed Volume File

	mov	ax, (OPEN shl 8) or 00h 	;compatibility mode/read access
	mov	dx, offset TRANGROUP:szCVF
	int	21h
	jc	ocvf_error

	mov	fhCVF, ax			; success, save CVF file handle

	; Read the extended MagicDrv BPB

	mov	bx, ax
	mov	ah, READ
	mov	cx, size MD_BPB
	mov	dx, offset TRANGROUP:MDBPB
	int	21h
	jc	ocvf_error1

	cmp	ax, cx			; get it all?
	je	ocvf_pick_cluster_size	; yes...

ocvf_error1:
	call	CloseCVF

ocvf_error:
	stc				;indicate failure
	jmp	short ocvf_ret


	; Determine the cluster size to use for ratio calculation

ocvf_pick_cluster_size:

	cmp	fUseHostSize, 0 	; user want Host drive cluster size?
	je	ovcf_use_CVF_size	; no, use CVF cluster size

	mov	ah, Get_Drive_Data	; get the host drive cluster size
	mov	dl, szCVF
	sub	dl, 'A' - 1		; 1 = A, 2 = B, ...
	push	ds
	int	21h
	pop	ds

	cmp	al, 0FFh		; host drive cluster size in AL if okay,
	jne	ovcf_set_size		;   failed = 0FFh

ovcf_use_CVF_size:
	mov	al, MDBPB.dos_bpb.csecPerClu	; using CVF cluster size

ovcf_set_size:
	mov	csecPerCluster, al

	; Lastly, setup the FAT buffers

ocvf_set_buf:
	mov	ax, [BytCnt]		; if >= 32k TPA space available,
	mov	[savBytCnt], ax 	;   setup larger FAT buffers
	cmp	ax, 32*1024
	jae	ocvf_big_buf

	; small TPA, use small resident buffers

	mov	[cFATEntries], cRES_FAT_ENTRIES
	mov	[segFATBuf], ds
	mov	word ptr [pbufDOSFAT], offset TRANGROUP:bufDOSFAT
	mov	word ptr [pbufMDFAT],  offset TRANGROUP:bufMDFAT
	jmp	short ocvf_success

ocvf_big_buf:

	mov	bx, cBIG_FAT_ENTRIES
	mov	[cFATEntries], bx

	shl	bx, 1		; 6 bytes per entry (2 for DOS FAT, 4 MD FAT)
	mov	cx, bx		; entries * 2
	shl	bx, 1
	add	bx, cx		; bx = # entries * 6

	sub	ax, bx		; reduce TPA size by size of FAT buffers
	and	ax, 0FE00h	; init code rounds BytCnt down to multiple of
	mov	[BytCnt], ax	;   512 bytes -- a no-op with some buf sizes.

	mov	bx, [Tpa]		; buffers in the TPA
	mov	[segFATBuf], bx
	mov	[pbufDOSFAT], ax	; DOS FAT buffer offset
	add	ax, cx			;   + DOS FAT buffer size
	mov	[pbufMDFAT], ax 	;   = MD FAT buffer offset

ocvf_success:
	clc			;indicate success

ocvf_ret:
	ret

OpenCVF endp



;***	CloseCVF - close Compressed Volume File
;
;	ENTRY	fhCVF has file handle
;
;	EXIT
;
;	USED	AX, BX, CX, DX

	public	CloseCVF

CloseCVF	proc

	mov	bx, fhCVF		; -1 unless file is open
	cmp	bx, -1
	je	ccvf_ret

	mov	ah, CLOSE
	int	21h

	mov	fhCVF, -1		; don't try to close again

	mov	ax, [savBytCnt] 	; 'deallocate' DOS & MD FAT buffers
	mov	[BytCnt], ax		;   by restoring old TPA byte count

ccvf_ret:
	ret

CloseCVF	endp




;***	CalcCompRatio - calculate file compression ratio
;
;	ENTRY	AX = starting cluster of file to get compression ratio of
;
;	EXIT	AX = compression ratio.  Example: a ratio of 2.7 to 1.0
;		     will return AH = 02h & AL = 07h
;		ccluUsed set to # DOS clusters used by file
;		csecUsed set to # compressed sectors used by file
;		ccluUsedDir, ccluUsedTotal, csecUsedDir, csecUsedTotal updated
;	USED	none

	public	CalcCompRatio

CalcCompRatio	proc

	push	bx
	push	cx
	push	dx
	push	es
	mov	es, [segFATBuf] 	; es is pointer to FAT buffers
	assume	es:nothing

	xor	bx, bx			; zero count of sectors & clusters used
	mov	[ccluUsed], bx
	mov	word ptr [csecUsed], bx
	mov	word ptr [csecUsed+2], bx

ccr_next:
	cmp	ax, 2			; sanity check the DOS FAT value
	jb	ccr_screwy

	cmp	ax, 0FFF0h		; end of file?
	jae	ccr_eof

	call	CheckFATBuffers 	; make sure buffers contain target
	jc	ccr_screwy		;   FAT entries

	call	GetMDFATEntry		; returns corresponding entry in BX:CX
	jc	ccr_screwy

	shl	bx, 1			; used bit to CY
	jnc	ccr_screwy		; better be used!

	mov	ch, bh			; save uncompressed count

	shl	bx, 1			; get count into position
	and	bx, 0F00h		; bh = count of compressed sectors used
	xchg	bh, bl			; bx = count
	inc	bx			; 0 - 15 means 1 - 16 used

	add	word ptr [csecUsed], bx
	adc	word ptr [csecUsed+2], 0

	mov	dx, ax			; save cluster # in dx

	mov	al, ch			; uncompressed count to al
	mov	cl, 3
	shr	al, cl			; get uncompressed count into position
	and	ax, 000Fh		; ax = uncompressed count (0 - 15)
	dec	bx			; bx = compressed count (0 - 15)
	cmp	ax, bx			; if the compressed cnt > uncompressed
	jae	@f			;   fudge a little and use the larger
	mov	ax, bx
@@:	mov	cl, csecPerCluster	; round up to the number of clusters
	xor	ch, ch			;   required for uncompressed
	add	ax, cx			;   sectors
	div	cl
	xor	ah, ah
	add	[ccluUsed], ax

	mov	ax, dx			; restore cluster #
	call	GetDOSFATEntry		; retuns next DOS FAT entry in AX
	jc	ccr_screwy
	jmp	short ccr_next

	; Reached the end-of-file, now calculate the ratio as the
	; number of DOS sectors used / number of compressed sectors used.

ccr_eof:
	mov	ax, [ccluUsed]
	add	[ccluUsedDir], ax	; update cluster used totals
	add	[ccluUsedTotal], ax

	mov	cx, word ptr [csecUsed+2]
	mov	bx, word ptr [csecUsed] ; cx:bx = # compressed sectors used

	add	word ptr [csecUsedDir], bx	; update sector used totals
	adc	word ptr [csecUsedDir+2], cx
	add	word ptr [csecUsedTotal], bx
	adc	word ptr [csecUsedTotal+2], cx

	call	ComputeRatio		; ax=clusters used, cx:bx=sectors used

	jmp	short ccr_ret

ccr_screwy:
	xor	ax, ax			; something screwy happened, set
					;   ratio to 0.0 and exit
ccr_ret:
	pop	es
	pop	dx
	pop	cx
	pop	bx
	ret

CalcCompRatio	endp



;***	ComputeRatio - calculate ratio of compressed sectors used to
;		       (would be) DOS sectors used
;
;	Entry
;		AX = DOS clusters used, cx:bx = compressed sectors used
;	Exit
;		ah = whole portion, al = tenths
;
;	Used	BX, CX, DX
;
	public	ComputeRatio

ComputeRatio	proc

	push	si
	push	di

	mov	si, bx
	mov	di, cx			; save cx:bx in di:si

	mov	bl, csecPerCluster
	xor	bh, bh
	mul	bx			; dx:ax = # DOS sectors used
	mov	bx, si			; restore bx

	call	Div32			; dx:ax = quotient, cx:bx = remainder

	push	ax			; save quotient

	mov	ax, bx			; if no remainder, tenths will be 0
	or	ax, cx			;   which is in AX so skip following
	jz	cr_got_tenths		;   (happens frequently)

	; Multiply the reminder by 10, add half the divisor so result is
	; rounded up, and divide again to get tenths digit

	mov	ax, cx
	xor	dx, dx
	mov	cx, bx
	mov	bx, 10
	mul	bx
	xchg	ax, cx
	mul	bx
	add	dx, cx			; dx:ax = remainder * 10

	mov	cx, di
	mov	bx, si
	shr	cx, 1
	rcr	bx, 1			; cx:bx = 1/2 divisor
	add	ax, bx
	adc	dx, cx			; dx:ax = remainder * 10 + 1/2 divisor

	mov	cx, di
	mov	bx, si

	call	Div32

cr_got_tenths:
	pop	bx			; original quotient
	mov	ah, bl

	cmp	al, 10			; if the tenths rounded up to the
	jb	cr_exit 		;   next whole number, adjust the
					;   whole number part and 0 the
	inc	ah			;   tenths  (i.e. round 1.97 to 2.0)
	xor	al, al

cr_exit:
	pop	di
	pop	si

	ret

ComputeRatio	endp



;***	Div32 - 32 bit divide for computing ratios
;
;	Entry	DX:AX = dividend, CX:BX = divisor
;
;	Exit	DX:AX = quotient, CX:BX = reminder

Div32	proc

	jcxz	d32_16bit		; differently if 16bit divisor

	push	si
	push	di

	; Brute force divide by subtraction.  This is okay because worse case
	; the dividend will only be 16 times greater, and typically about 2
	; times

	xor	si, si
	mov	di, si			; di:si is quotient
@@:
	sub	ax, bx			; subtract divisor
	sbb	dx, cx
	jc	d32_too_far

	add	si, 1			; accumulate quotient
	adc	di, 0
	jmp	short @b

d32_too_far:
	add	ax, bx			; fix the last subtraction
	adc	dx, cx

	mov	cx, di
	mov	bx, si			; dx:ax = remainder, cx:bx = quoient

	xchg	ax, bx
	xchg	dx, cx			; dx:ax = quoient, cx:bx = remainder

	pop	di
	pop	si

	ret

d32_16bit:
	div	bx			; divide dx:ax by bx

	mov	bx, dx			; remainder to cx:bx
	xor	dx, dx			; quotient to dx:ax
	mov	cx, dx
	ret

Div32	endp



;***	GetDOSFATEntry - returns next cluster in file's FAT chain
;
;	Entry	AX = current cluster number
;		ES = segment of FAT buffer
;		Entry should be in FAT buffer
;
;	Exit	AX = next cluster number
;		CY set if error
;
;	Uses	BX

GetDOSFATEntry	proc

	sub	ax, [entInBuf]		; calc entry # in buffer
	jc	gdf_ret 		; CY already set for error

	mov	bx, ax

	cmp	MDBPB.f12BitFAT, 0	; 12 or 16 bit FAT?
	jnz	gdf_12			; go do 12

	shl	bx, 1				; offset = entry * 2
	add	bx, [pbufDOSFAT]
	mov	ax, word ptr es:[bx]

gdf_success:
	clc				; success

gdf_ret:
	ret

gdf_12:
	shr	bx, 1
	add	bx, ax			; offset to entry = entry * 1.5
	add	bx, [pbufDOSFAT]

;	ES:BX points to the word containing the desired 12 bit FAT entry.
;	For odd entries, the upper 12 bits are valid, for even entries
;	the low 12 bits are valid.  odd: OOOx  even: xEEE

	test	al, 1			; is current entry odd?

	mov	ax, word ptr es:[bx]	; word with FAT entry
	jnz	gdf_odd

	and	ax, 0fffh		; keep low 12 bits for even
	jmp	short gdf_testEOF

gdf_odd:
	mov	bx, cx			; (save cx in bx)
	mov	cl, 4
	shr	ax, cl			; upper 12 bits for odd
	mov	cx, bx			; (restore cx)

gdf_testEOF:
	cmp	ax, 0FF0h		; valid entry?
	jb	gdf_success

	or	ah, 0F0h		; caller expects 16 bit special values
	jmp	short gdf_success

GetDOSFATEntry	endp



;***	GetMDFATEntry - returns requested MD FAT entry
;
;	Entry	AX = current DOS cluster number
;		ES = segment of FAT buffer
;		Entry should be in FAT buffer
;
;	Exit	BX:CX = corresponding MD FAT entry
;		CY set if error
;
;	Uses	None

GetMDFATEntry	proc

	mov	bx, ax
	sub	bx, [entInBuf]		; calc entry # in buffer
	jc	gmf_ret 		; CY already set for error return

	shl	bx, 1
	shl	bx, 1			; * 4 bytes per MDFAT entry

	add	bx, [pbufMDFAT]
	mov	cx, word ptr es:[bx]
	mov	bx, word ptr es:[bx+2]

	clc
gmf_ret:
	ret

GetMDFATEntry	endp



;***	CheckFATBuffers - check that target FAT entry is in FAT buffers.  If
;			  not, fill the buffers starting with the requested
;			  entry.
;
;	ENTRY	AX = FAT entry #
;		ES = segment of FAT buffers
;
;	EXIT	FAT buffers contain target entry, or CY set if error
;		entInBuf updated
;
;	USED	BX

CheckFATBuffers proc

	mov	bx, ax
	sub	bx, [entInBuf]
	jb	cfb_load_fat

	sub	bx, [cFATEntries]
	jae	cfb_load_fat

	clc

	ret

	; Desired entry isn't in the FAT buffers, reload the buffers to
	; include it

cfb_load_fat:

	push	ax
	push	cx
	push	dx

	; Start with the DOS FAT buffer

	xor	cx, cx			; zero high offset to FAT file position

	cmp	MDBPB.f12BitFAT, 0	; 12 or 16 bit FAT?
	jnz	cfb_12			; go do 12

	mov	[entInBuf], ax		; this entry is first

	shl	ax, 1			; 2 bytes per cluster #
	rcl	cx, 1			; cx:ax = offset to FAT entry

	jmp	short cfb_common

cfb_12:
	and	al, not 1		; start with even # entry
	mov	[entInBuf], ax

	mov	bx, ax
	shr	bx, 1
	add	ax, bx			; ax = offset to FAT entry
					;      (entry # * 1.5)
cfb_common:
	mov	bx, ax			; cx:bx = offset to FAT entry

	mov	ax, MDBPB.csecMDReserved ; # magicDrv reserved sectors
	add	ax, MDBPB.dos_bpb.csecReserved

	mul	MDBPB.dos_bpb.cbPerSec	; DX:AX = DOS FAT file origin
	add	ax, bx
	adc	dx, cx			; DX:AX = file offset to read from

	mov	cx, [cFATEntries]	; size to read
	shl	cx, 1
	mov	bx, [pbufDOSFAT]	; es:bx = location to read

	call	ReadCVFile
	jc	cfb_error

	; Now read the corresponding MagicDrv FAT entries

	mov	ax, MDBPB.secMDFATStart
	inc	ax
	mul	MDBPB.dos_bpb.cbPerSec	; DX:AX = MDFAT file offset

	mov	bx, [entInBuf]
	xor	cx, cx			; CX:BX = 32 bit cluster #
	add	bx, MDBPB.cluFirstData
	adc	cx, cx			; CX:BX = MDFAT entry #

	shl	bx, 1
	rcl	cx, 1
	shl	bx, 1
	rcl	cx, 1			; * 4 bytes per MDFAT entry

	add	ax, bx
	adc	dx, cx			; DX:AX = file offset of MDFAT entry

	mov	cx, [cFATEntries]
	shl	cx, 1
	shl	cx, 1			; size to read
	mov	bx, [pbufMDFAT] 	; es:bx = location to read into

	call	ReadCVFile
	jnc	cfb_ret

cfb_error:
	stc

cfb_ret:
	pop	dx
	pop	cx
	pop	ax
	ret

CheckFATBuffers endp



;***	ReadCVFile - read from the Compressed Volume File
;
;	Entry	DX:AX file offset, ES:BX buffer location, CX length in bytes
;
;	Exit	CY set if error, else data read
;
;	Uses	AX, BX, CX, DX

ReadCVFile	proc

	push	bx			; save buffer loc
	push	cx			; save read length

	mov	cx, dx
	mov	dx, ax			; cx:dx = file offset of fat entry
	mov	ax, (LSEEK shl 8) or 0
	mov	bx, fhCVF
	int	21h
	jc	rcf_ret 		; CY set for error return

	mov	ah, READ
	pop	cx			; read length
	pop	dx			; buffer loc offset
	push	ds
	push	es
	pop	ds			; buffer loc segment
	int	21h
	pop	ds
	jc	rcf_ret 		; CY set for error return

	cmp	ax, cx			; read it all?
	je	rcf_ret 		; yes, CY clear

	stc				; end-of-file?

rcf_ret:
	ret

ReadCVFile	endp



TRANCODE ends

endif           ;dblspace_hooks
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\iparse.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)iparse.asm 4.1 87/04/28
;	SCCSID = @(#)iparse.asm 4.1 87/04/28
TITLE	COMMAND interface to SYSPARSE

.xlist
.xcref
	INCLUDE comseg.asm		;AN000;
.list
.cref


INIT		SEGMENT PUBLIC PARA	;AN000;

ASSUME	CS:RESGROUP,DS:RESGROUP,ES:NOTHING,SS:NOTHING	;AN000;


;AD054; public	SYSPARSE		;AN000;

	DateSW	equ	0		;AN000; do not Check date format
	TimeSW	equ	0		;AN000; do not Check time format
	CmpxSW	equ	0		;AN000; do not check complex list
	KeySW	equ	0		;AN025; do not support keywords
	Val2SW	equ	0		;AN025; do not Support value definition 2
	Val3SW	equ	0		;AN000; do not Support value definition 3
	QusSW	equ	0		;AN025; do not include quoted string
	DrvSW	equ	0		;AN025; do not include drive only

.xlist
.xcref
;AD054; INCLUDE parse.asm		;AN000;
.list
.cref


INIT	    ends			;AN000;
	    end 			;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\ifequ.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;       SCCSID = @(#)ifequ.asm  1.1 85/05/14
;       SCCSID = @(#)ifequ.asm  1.1 85/05/14
;*************************************
; COMMAND EQUs which are switch dependant

IF1
    IF IBM
        %OUT DBCS Enabled IBM  version
    ELSE
        %OUT Normal version
    ENDIF

ENDIF

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\envdata.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)envdata.asm	1.1 85/05/14
;
; This file is included by init.asm and is used as the default environment.


Environment Struc                       ; Default COMMAND environment

Env_PathString 	db	"path="
Env_PathSpec    db      "c:\msdos"
                db      0
Env_PrmptString db      "prompt="
Env_PrmptSpec   db      "$p$g"
                db      0
Env_ComString   db      "comspec="
Env_ComSpec     db      "\command.com"
		db	134 dup (0)

Environment ends


MAX_COMSPEC     equ     SIZE Environment - Env_ComSpec
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\fordata.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)fordata.asm	1.1 85/05/14
;	SCCSID = @(#)fordata.asm	1.1 85/05/14
; Data structure definitions included by tfor.asm

for_info        STRUC
    for_args        DB          (SIZE arg_unit) DUP (?) ; argv[] structure
    FOR_COM_START   DB          (?)                     ; beginning of <command>
    FOR_EXPAND      DW          (?)                     ; * or ? item in <list>?
    FOR_MINARG      DW          (?)                     ; beginning of <list>
    FOR_MAXARG      DW          (?)                     ; end of <list>
    forbuf          DW          64 DUP (?)              ; temporary buffer
    fordma          DW          64 DUP (?)              ; FindFirst/Next buffer
    FOR_VAR         DB          (?)                     ; loop control variable
for_info        ENDS

; empty segment done for bogus addressing
for_segment     segment
f       LABEL   BYTE
for_segment     ends

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\init.asm ===
page ,132
	title	COMMAND Initialization
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;	M002	SR	07/15/90	Resize right at the start because
;				Carousel depends on it.
;
;	M004	SR	07/17/90	Initialization reworked so that 
;				transient is now moved at EndInit.
;				The old approach assumed that the
;				biggest block is the one currently 
;				loaded in, an assumption not true
;				for UMBs.
;
;	M005	SR	07/20/90	Numerous hacks for Carousel
;				1. Set CurrentPDB to ours at start
;				2. Normalize cs:ip of int 2fh hook
;				so that cs is different.
;
;	M013	SR	08/06/90	Fixed Setup_res_end & Move_res_code
;				to use new GetVersion call that
;				returns info about whether DOS is in
;				HMA or not.
;
;	M015	SR	08/09/90	Increased default environment size to
;				256 bytes from 160 bytes
;
;	M026	SR	9/12/90	Fixed environment trashing on second
;				Command if new comspec is given.
;
;	M030	SR	10/3/90	Before calling int 2fh 4a02h, set di
;				to 0ffffh so that we are ok if no one
;				answers this int 2fh.
;
;	M042	SR	12/13/90	Bug #4660. Changed setup_res_end to
;				take care of the dummy segment that
;				adds a para to the resident size.
;

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include pdb.inc
	include mult.inc
	include syscall.inc
	include doscntry.inc
	include comseg.asm
	include comequ.asm
	include resmsg.equ

	include envdata.asm
	include xmm.inc
.list
.cref



ENVBIG			equ	32768
ENVSML			equ	256		;Increased to 256 ; M015
KOREA_COUNTRY_CODE	equ	82


CODERES segment public byte

	extrn	ContC		:near
	extrn	DskErr		:near
	extrn	Int_2e		:near
	extrn	LodCom		:near
	extrn	MsgInt2fHandler	:far
	extrn	SetVect	:near
	extrn	ChkSum		:near
	extrn	CrLf		:near
	extrn	LoadCom	:near
	extrn	RPrint		:near

	extrn	EndCode	:byte
	extrn	StartCode	:byte

	ifdef	DBCS
	extrn	ItestKanj	:near
	endif

	extrn	BadMemErr	:near

CODERES ends

DATARES segment public byte

	extrn	Abort_Char	:byte
	extrn	AccDen		:byte
	extrn	Append_State	:word	
	extrn	Batch		:word
	extrn	Com_Fcb1	:dword
	extrn	Com_Fcb2	:dword
	extrn	Com_Ptr		:dword
	extrn	ComDrv		:byte
	extrn	ComSpec		:byte
	extrn	ComSpec_End	:word
	extrn	Crit_Msg_Off	:word	
	extrn	Crit_Msg_Seg	:word	
	extrn	DataResEnd	:byte 	
	extrn	Dbcs_Vector_Addr:word	
	extrn	EchoFlag	:byte
	extrn	EnvirSeg	:word
	extrn	ExtMsgEnd	:byte	
	extrn	fFail		:byte
	extrn	FUCase_addr	:word	
	extrn	InitFlag	:byte
	extrn	Int2fHandler	:dword
	extrn	Io_Save		:word
	extrn	LTpa		:word	
	extrn	MemSiz		:word
	extrn	MySeg		:word	
	extrn	MySeg1		:word
	extrn	MySeg2		:word
	extrn	MySeg3		:word
	extrn	Nest		:word
	extrn	OldTerm	:dword
	extrn	Parent		:word
	extrn	ParseMes_Ptr	:word	
	extrn	ParsMsgPtrs	:word
        extrn   PermCom         :byte
        extrn   SemiPermCom     :word
	extrn	PutBackDrv	:byte
	extrn	PutBackComSpec	:byte
	extrn	RDirChar	:byte
	extrn	Res_Tpa	:word
	extrn	ResMsgEnd	:word	    
	extrn	RSwitChar	:byte
	extrn	SingleCom	:word
	extrn	Sum		:word
	extrn	TrnSeg		:word
	extrn	TrnMvFlg	:byte

	extrn	ResSize	:word
	extrn	RStack		:word

	extrn	ComInHMA	:byte	;flag set if in HMA
	extrn	XMMCallAddr	:dword	;far call address to XMM

;;ifdef	ROMDOS
;;;	If LoadFromROM is in DATARES..
;;	extrn	LoadFromROM_seg	:word
;;endif

;
;All far pointers to resident routines that are to be patched
;
	extrn	Int2f_Entry	:dword
	extrn	Int2e_Entry	:dword
	extrn	Ctrlc_Entry	:dword
	extrn	CritErr_Entry	:dword

	extrn	Int2f_Trap	:near
	extrn	Int2e_Trap	:near
	extrn	Ctrlc_Trap	:near
	extrn	CritErr_Trap	:near
	extrn	LodCom_Trap	:near

	extrn	EndInit	:near

	extrn	Carousel_i2f_Hook	:byte	; M005

ifdef	BETA3WARN
	%out	Take this out before we ship
	extrn	Beta3Warned:byte
endif


DATARES ends


TAIL	segment public para

	extrn	TranStart	:word

TAIL	ends


TRANCODE	segment public byte

	extrn	DatInit	:far

TRANCODE	ends

TRANDATA	segment

	extrn	TranDataEnd	:byte

TRANDATA	ends

TRANSPACE	segment public byte

	extrn	TranSpaceEnd	:byte

TRANSPACE	ends




ifdef ROMDOS

;----------------------------------------------------------------------------
; Image of part of the BIOS data segment, named Bdata.
; Defines the following label:
;
;	BootFlags =	Boot options from CMOS RAM

include	msbdata.inc

; BootFlags bit we're concerned with:

BF_NoConfig	=	00000001b	; No config.sys processing

endif ; ROMDOS




; *******************************************************************
; START OF INIT PORTION
; This code is deallocated after initialization.

INIT	SEGMENT PUBLIC PARA

	extrn	AutoBat	:byte
	extrn	BadComAccMsg	:byte
	extrn	BadComLkMsg	:byte
	extrn	Badcspfl	:byte
	extrn	BadVerMsg	:byte
        extrn   AllocedEnv      :byte
	extrn	Command_?_syn	:byte	
	extrn	Command_c_syn	:byte	
        extrn   Command_k_syn   :byte
	extrn	Command_d_syn	:byte	
	extrn	Command_e_syn	:byte	
	extrn	Command_f_syn	:byte	
	extrn	Command_m_syn	:byte	
	extrn	Command_p_syn	:byte	
	extrn	Comnd1_syn	:word 	
	extrn	Comnd1_addr	:dword	
	extrn	ComSpect	:byte
	extrn	CopyrightMsg	:byte
	extrn	Dswitch	:byte	
	extrn	EnvMax		:word
	extrn	EnvSiz		:word
	extrn	EqualSign	:byte
	extrn	Eswitch	:byte	
	extrn	Ext_msg	:byte	
	extrn	HelpMsgs:word
	extrn	InitAdd	:dword
	extrn	InitEnd	:word
	extrn	Init_Parse	:dword	
	extrn	Internat_Info	:byte	
	extrn	KautoBat	:byte	
	extrn	Lcasea		:byte
	extrn	Lcasez		:byte
	extrn	Num_positionals	:word	
	extrn	OldEnv		:word
	extrn	Old_parse_ptr	:word	
	extrn	OutEnvMsg	:byte
	extrn	Parse_command	:byte	
	extrn	PrdAttm	:byte
	extrn	ResetEnv	:word	
	extrn	Scswitch	:byte
        extrn   Skswitch        :byte
	extrn	Space		:byte
	extrn	Triage_Add	:dword	
	extrn	TrnSize	:word
	extrn	Ucasea		:byte
	extrn	UsedEnv	:word

	extrn	PathString	:byte
        extrn   PathStrLen      :abs
        extrn   DefPathString   :byte
        extrn   DefPathStrLen   :abs
        extrn   DefPath2String  :byte
        extrn   DefPath2StrLen  :abs
        extrn   PrmptString     :byte
        extrn   PrmptStrLen     :abs
        extrn   PrmptStrLen2    :abs
        extrn   ComspOffset     :word
	extrn	ComspString	:byte
        extrn   ComspStrLen     :abs
        extrn   ComspStrLen2    :abs
	extrn	Reloc_Table	:word
	extrn	FirstCom	:byte
	extrn	ResJmpTable	:dword

	extrn	TriageError	:near

	extrn	NUM_RELOC_ENTRIES	:abs

	extrn	DevFlag	:byte
	extrn	PathFlag	:byte

	PUBLIC	ConProc
	PUBLIC	Init_ContC_SpecialCase

	assume	cs:ResGroup,ds:ResGroup,es:ResGroup,ss:ResGroup

	org	0
ZERO	=	$


ConProc:
	mov	sp,offset ResGroup:RStack	; must be first instruction
;
; We need to set the PSP to us right at start because Carousel needs
; to be lied to and it does not set PSP when it transfers control to
; us after loading us as an overlay. By setting PSP, we ensure that
; command.com is also not lied to.
;
        mov     ah,SET_CURRENT_PDB
        mov     bx,es
        int     21h

        mov     ax,GET_VERSION SHL 8
	int	21h
	cmp	ax,EXPECTED_VERSION
	je	OkDos				; DOS version is ok

	mov	dx,offset ResGroup:BadVerMsg	; DX = ptr to msg
	call	RPrint
	mov	ax,es
	cmp	es:PDB_Parent_Pid,ax		; if COMMAND is own parent,
Here:	jz	Here				;  loop forever
	
	int	20h				; otherwise, exit
okdos:

;
;  Calculate and save the end of the INIT segment (which is also
;  the beginning of TRANGROUP).
;

        mov     dx,offset resgroup:TranStart+15 ; get end of init code
        mov     cl,4                            ; change to paragraphs
        shr     dx,cl                           ;
        mov     ax,cs                           ; get current segment
        add     ax,dx                           ; calculate segment of end of init
        mov     InitEnd,ax                      ; save this

;
;  Check for /? on the command line.  If found, display help text
;  and exit.
;
;  NOTE:  this routine may terminate the program, never returning.
;
	call	CheckHelp

;
; We have to patch the segment values for the various interrupt entry points.
; This is because we need to have the default addresses of the handlers in our
; stub before the relocation is done. These values will then be changed once
; the resident is relocated
;
	call	patch_segs

;
;  Turn APPEND off during initialization processing
;
        mov     ax,APPENDINSTALL                ; see if append installed
	int	2fh				;
	cmp	al,0				; append installed?
	je	set_msg_addr			; no - continue
	mov	ax,APPENDDOS			; see if append DOS version right
	int	2fh				;
	cmp	ax,-1				; append version correct?
	jne	set_msg_addr			; no - continue
        mov     ax,APPENDGETSTATE               ; Get the state of Append
	int	2fh				;
        mov     Append_State,bx                 ; save append state
        xor     bx,bx                           ; clear out state
        mov     ax,APPENDSETSTATE               ; Set the state of Append
	int	2fh				; set everything off

set_msg_addr:
	mov	di,offset resgroup:DataresEnd 	; get address of resident end
	mov	ResMsgEnd,di			; save it


        call    get_XMMAddr                     ; get XMM call address
;
; Check if this is the first instance of command.com. If not, we just exit
; this routine without moving any code.
; After the int 2fh, ds:si points at the resident jump table in the previous
; stub. We just have to copy this over
;
	
ifndef ROMDOS
	mov	ax,GET_COMMAND_STATE	
else
	mov	ax,GET_ROMCOMMAND_STATE	
endif ; ROMDOS

	int	2fh
	assume	ds:nothing

	or	ax,ax
	jnz	first_com			;this is the first instance

ifdef	BETA3WARN
	%out	Take this out before we ship
	mov	es:Beta3Warned, 0ffh
endif

	mov	word ptr es:ResJmpTable,si		;save old stub jump table
	mov	word ptr es:ResJmpTable+2,ds
	jmp	short init_cntry

first_com:
	mov	es:FirstCom,1			;indicate first command.com

init_cntry:
	push	es
	pop	ds
	assume	ds:RESGROUP


	mov	ah,GETEXTCNTRY			; get extended country info
	mov	al,4				; get file ucase table
	mov	dx,-1				;
	mov	bx,-1				;
	mov	cx,5				; number of bytes we want
	mov	di,offset resgroup:Fucase_addr	; buffer for address
	int	21h				;

;	Bugbug:	conditionalize dbcs_vector stuff?
	push	ds				;
	mov	ax, (ECS_CALL shl 8) or GETLEADBTBL ;
	int	21h				;
	mov	bx,ds				; get segment to bx
	pop	ds				;
	mov	Dbcs_vector_addr,si			; save address of
	mov	Dbcs_vector_addr+2,bx			; dbcs vector


	mov	ax,word ptr ds:PDB_Parent_Pid 	; Init PARENT so we can exit
	mov	Parent,ax			;  correctly.
	mov	ax,word ptr ds:Pdb_Exit
	mov	word ptr OldTerm,ax
	mov	ax,word ptr ds:Pdb_Exit+2
	mov	word ptr Oldterm+2,ax


	mov	ax,offset ResGroup:EndCode + 15
	mov	cl,4				; ax = size of resident part of
	shr	ax,cl				;  command in paragraphs.  Add
	mov	cx,cs				;  this to CS and you get the
	add	ax,cx				;  segment of the TPA.

	mov	Res_tpa, ax			; Temporarily save the TPA segment
	and	ax, 0f000h
	add	ax, 01000h			; Round up to next 64K boundary
	jnc	TpaSet				; Memory wrap if carry set
	mov	ax, Res_tpa
TpaSet:
	mov	Ltpa,ax			; Good enough for the moment
	mov	ax,word ptr ds:PDB_Block_Len	; ax = # of paras given to command

	mov	Myseg1,ds			; These 3 variables are used as part of
	mov	Myseg2,ds			;  3 long ptrs that the transient will
	mov	Myseg,ds			;  use to call resident routines.
	mov	Myseg3,ds			; segment of msg retriever routine

	mov	Memsiz,ax			; Needed for execing other programs

;
; First reallocate the COMMAND size to its memory image
;
        push    ax                              ;
        mov     bx,offset RESGROUP:TranStart    ;
        add     bx,offset TRANGROUP:TranSpaceEnd;
        add     bx,15                           ; round up the size

        mov     cl,4                            ;
        shr     bx,cl                           ; size of command.com

        mov     ah,SETBLOCK                     ; free all memory above pgm
        int     21h                             ;
        pop     ax                              ;


;
; Compute maximum size of environment
;
        mov     EnvMax,(SIZE Environment + 15) / 16 + (EnvMaximum-zero + 15)/16 - 1
;
; Compute minimum size of environment
;

	mov	EnvSiz, ENVSML / 16

	mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
	mov	cl,4				;  in paragraphs.
	shr	dx,cl
        mov     Trnsize,dx                      ; save size of transient in paragraphs

	sub	ax,dx				; max seg addr - # para's needed for transient
	mov	Trnseg,ax			;  = seg addr to load the transient at.
	mov	ax,ds:PDB_Environ			; ax = environment segment
        mov     EnvirSeg,ax                     ;
        or      ax,ax                           ; if there is no environment segment,
        jz      buildenv                        ; make one

        cmp     FirstCom,0                      ; if this is the first command.com,
        je      environpassed                   ; do a merge job (make sure COMSPEC exists)
;
; We allocate a buffer here just large enough to hold the 'PATH=' and
; the COMSPEC. After parsing, we will allocate an environment of the right
; size and free this buffer. We need this buffer because we no longer have an
; ENVIRONMENT segment but need a place to store the COMSPEC which can be
; given on the command line before we know the environment size. This routine
; will not return in case of an allocation error. It will either exit or hang
; depending on whether or not this is the first COMMAND.COM or not.
;
buildenv:
        call    alloc_env                       ; try to allocate buffer

environpassed:
        mov     es,ax                           ; and it load into es.
	assume	es:nothing

gottheenvir:
;
; Initialize the command drive
;
	mov	ah,GET_DEFAULT_DRIVE
	int	21h
	inc	al
	mov	Comdrv,al

        mov     al,byte ptr ds:Fcb              ; al = default drive number for command
	or	al,al
	jz	nocomdrv			; no drive specified

	mov	ah,':'
	mov	Comdrv,al
	add	al,40h				; convert number to uppercase character

ifndef	ROMDOS

;	(Don't add drive specifier to ROM COMMAND COMSPEC.)

	std
        cmp     AllocedEnv,0                    ; if a new environment is being built,
        je      notwidenv                       ;  move the default comspec string in it

        mov     di,ComspOffset
        cmp     byte ptr es:[di+1],':'          ; drive specifier already exist?
        je      notwidenv                       ; yes, must have been inherited that way
	push	ds				;  2 bytes to make room for a drivespec.
	push	es				;  the drivespec is in ax and is copied
	pop	ds				;  on to the front of the string.

        lea     si,[di+MAX_COMSPEC-3]
        lea     di,[di+MAX_COMSPEC-1]
        mov     cx,MAX_COMSPEC - 2
	rep	movsb
	pop	ds
        mov     word ptr es:[di-1],ax

endif	;ROMDOS

notwidenv:
	cld					; add the drivespec to the string
        mov     word ptr AutoBat,ax             ; used to reference autoexec.bat
        mov     word ptr KautoBat,ax            ; used to reference kautoexe.bat 3/3/kk

nocomdrv:
	call	setvect 			; set interrupt vectors 22h, 23h, & 24h

;*********************************
; parsing starts here
;*********************************

	push	cs				; get local segment
	push	cs				; into ds,es
	pop	ds				;
	pop	es				;

assume  ds:ResGroup,es:ResGroup

	mov	si,80h				; get command line
	lodsb					; get length of line
	mov	di,si				; get line position in di
	xor	ah,ah				; ax = length of command line
;
; insure that the command line correctly ends with a cr
;
	add	di,ax				; go to end of command line
        mov     byte ptr [di],0dh               ; insert a carriage return
	xor	cx,cx				; clear cx
        mov     Num_positionals,cx              ; initialize positionals
;
; Scan the command line looking for the parameters
;

Parse_command_line:
        mov     di,offset ResGroup:Parse_Command; Get address of parse_command
        mov     cx,Num_positionals              ; Get number of positionals
	xor	dx,dx				; clear dx
        mov     Old_parse_ptr,si                ; save position before calling parser
	call	init_parse			; call parser
        mov     Num_positionals,cx              ; Save number of positionals
	cmp	ax,END_OF_LINE			; are we at end of line?
        jne     t1
        jmp     ArgsDone                        ; yes - exit
t1:     cmp     ax,RESULT_NO_ERROR              ; did an error occur
	jz	parse_cont			; no - continue

;
; Before issuing error message - make sure switch is not /C
;

parse_line_error:
	push	si				; save line position
	push	ax				; save error number
	cmp	ax,BADSWT_PTR			; Was error invalid switch?
        jnz     parse_line_error_disp           ; No - just issue message
	mov	di,si				; Get terminating pointer in DI
        mov     si,Old_parse_ptr                ; Get starting pointer in SI

init_chk_delim:
	cmp	si,di				; at end of parsed parameter?
        jz      parse_line_error_disp           ; Yes - just display message
	lodsb					;
	cmp	al,Space			; Skip blank spaces
	jz	init_chk_delim			;
	cmp	al,TAB_CHR			; Skip tab characters
	jz	init_chk_delim			;

	cmp	al,Rswitchar			; Switch?
        jnz     parse_line_error_disp           ; No - just issue message
	lodsb					; Get the char after the switch

	ifdef	DBCS
	call	ItestKanj			; Is it DBCS?
        jnz     parse_line_error_disp           ; Yes - can't be /C or /K
	endif

	call	iupconv 			; upper case it
	cmp	al,Scswitch			; it is /C?
        jnz     check_k_too                     ;
	pop	dx				; even up stack
	pop	dx				; even up stack
	jmp	setSSwitch			; Yes - go set COMMAND /C

check_k_too:
        cmp     al,Skswitch                     ; it is /K?
        jnz     parse_line_error_disp           ;
	pop	dx				; even up stack
	pop	dx				; even up stack
        jmp     setKSwitch                      ; Yes - go set COMMAND /K

parse_line_error_disp:
	pop	ax				; restore error number
	pop	si				; restore line position
	mov	dx,ax				; get message number
	call	RPrintParse
	call	CrLf
        jmp     short Parse_command_line        ; continue parsing

parse_cont:
;
; See if a switch was entered
;
; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare

	cmp	Comnd1_Syn,offset ResGroup:Command_f_syn ; was /F entered?
	jz	SetFSwitch				 ; yes go set fail switch
	cmp	Comnd1_Syn,offset resgroup:Command_p_syn ; was /P entered?
	Jz	SetPSwitch				 ; yes go set up PERMCOM
	cmp	Comnd1_Syn,offset resgroup:Command_d_syn ; was /D entered?
	jz	SetDSwitch				 ; yes go set date switch
	cmp	Comnd1_Syn,offset resgroup:Command_c_syn ; was /C entered?
	jz	SetSSwitch				 ; yes go set up SINGLECOM
        cmp     Comnd1_Syn,offset resgroup:Command_k_syn ; was /K entered?
        jz      SetKSwitch                               ; yes go set up SINGLECOM
	cmp	Comnd1_Syn,offset resgroup:Command_e_syn ; was /E entered?
	jz	SetESwitch				 ; yes go set up environment
	cmp	Comnd1_Syn,offset resgroup:Command_m_syn ; was /MSG entered?
	jz	SetMSwitchjmp				 ; yes go set up message flag
	jmp	ChkOtherArgs				 ; Must be something else

SetMSwitchjmp:					; long jump needed
	jmp	SetMswitch			;

SetFSwitch:
	cmp	fFail,-1			; has fail switch been set?
	jnz	failok				; no - set it
        mov     ax,Moreargs_ptr                 ; set up too many arguments
        jmp     parse_line_error                ; go issue error message

failok:
	mov	fFail,-1			; fail all INT 24s.
        jmp     Parse_command_line              ;

SetPSwitch:
;
; We have a permanent COMMAND switch /P.  Flag this and stash the
; termination address.
;
	cmp	PermCom,0			; has /p switch been set?
	jz	permcomok			; no - set it
        mov     ax,moreargs_ptr                 ; set up too many arguments
        jmp     parse_line_error                ; go issue error message

permcomok:
	inc	PermCom
	mov	word ptr OldTerm,offset DATARES:LodCom_Trap
	mov	word ptr OldTerm+2,ds
;
; make sure that we display the date and time.	if the flag was not
; initialized, set it to indicate yes, do prompt.
;
	cmp	byte ptr PrdAttm,-1
	jnz	Parse_command_line_jmp		; keep parsing
        mov     byte ptr PrdAttm,0              ; if not set explicit, set to prompt

Parse_command_line_jmp: 			;
        jmp     parse_command_line              ; keep parsing

SetDSwitch:
;
; Flag no date/time prompting.
;
	cmp	Dswitch,0			; has /D switch been set?
	jz	setdateok			; no - set it
        mov     ax,Moreargs_ptr                 ; set up too many arguments
        jmp     parse_line_error                ; go issue error message

setdateok:
	inc	Dswitch 			; indicate /D entered
        mov     byte ptr PrdAttm,1              ; user explicitly says no date time
        jmp     Parse_command_line              ; continue parsing

SetKSwitch:
        mov     SemiPermCom,0
        jmp     short SetSorKSwitch

SetSSwitch:
;
; Set up pointer to command line, flag no date/time and turn off singlecom.
;
	mov	Permcom,0			; a singlecom must not be a permcom
SetSorKSwitch:
	mov	SingleCom,si			; point to the rest of the command line
        mov     byte ptr PrdAttm,1              ; no date or time either, explicit
	jmp	ArgsDone
;
; Look for environment-size setting switch
;
; The environment size is represented in decimal bytes and is
; converted into pargraphs (rounded up to the next paragraph).
;

SetESwitch:
	cmp	Eswitch,0			; has fail switch been set?
	jz	eswitchok			; no - set it
        mov     ax,Moreargs_ptr                 ; set up too many arguments
        jmp     Parse_line_error                ; go issue error message

eswitchok:
	inc	Eswitch 			; indicate /E entered
	mov	di,offset ResGroup:Comnd1_Addr	; get number returned
        mov     bx,word ptr [di]                ; into bx

	add	bx, 0fh 			; Round up to next paragraph
	mov	cl,4				; convert to pargraphs
	shr	bx, cl				; by right 4

	mov	EnvSiz,BX			; EnvSiz is in paragraphs
        jmp     Parse_command_line              ; continue parsing command line

SetMSwitch:
        cmp     Ext_msg,SET_EXTENDED_MSG        ; has /MSG switch been set?
	jnz	setMswitchok			; no - set it
        mov     ax,Moreargs_ptr                 ; set up too many arguments
        jmp     Parse_line_error                ; go issue error message
setMswitchok:
        mov     Ext_msg,SET_EXTENDED_MSG        ; set /MSG switch
        jmp     Parse_command_line              ; keep parsing

ArgsDoneJ:
	jmp  ArgsDone

;
; We have a non-switch character here.
;
ChkOtherArgs:
	push	ds				;
	push	si				; save place in command line
	lds	si,Comnd1_Addr			; get address of filespec
	assume	ds:nothing			;

	mov	dx,si				; put in dx also
        mov     ax,(OPEN shl 8) or 2            ; Read and write
	int	21h
	jc	ChkSrchSpec			; Wasn't a file
	mov	bx,ax
	mov	ax,IOCTL shl 8
	int	21h
	test	dl,80h
	jnz	IsaDevice

BadSetCon:					;
	mov	ah,CLOSE			; Close initial handle, wasn't a device
	int	21h
	jmp	short ChkSrchSpec

IsaDevice:
	xor	dh,dh
	or	dl,3				; Make sure has CON attributes
	mov	ax,(IOCTL shl 8) or 1
	int	21h
	jc	BadSetCon			; Can't set attributes - quit
	mov	dx,bx				; Save new handle

	cmp	es:DevFlag,1
	jz	DevErr

	push	cx
	mov	cx,3
	xor	bx,bx

rcclloop:					; Close 0,1 and 2
	mov	ah,CLOSE
	int	21h
	inc	bx
	loop	rcclloop

	mov	bx,dx				; New device handle
	mov	ah,XDUP
	int	21h				; Dup to 0
	mov	ah,XDUP
	int	21h				; Dup to 1
	mov	ah,XDUP
	int	21h				; Dup to 2
	mov	ah,CLOSE
	int	21h				; Close initial handle
	pop	cx
	pop	si				; restore position of command line
	pop	ds				;
;
; Register the fact that we already have redirected the output and cannot do
; it again
;
	inc	es:DevFlag			;
        jmp     Parse_command_line              ; continue parsing

DevErr:
	pop	si
	pop	ds
	mov	dx,1
        call    RPrintParse                     ; "Too many parameters"
        call    CrLf
	jmp	Parse_command_line

ChkSrchSpec:					; Not a device, so must be directory spec

        cmp     es:PathFlag,1                   ; already set COMSPEC?
        jz      DevErr                          ; yes, error

        inc     es:PathFlag                     ; mark that we have a path
;
; We have to override the passed environment. Allocate a buffer for use now.
; This buffer will later be replaced by a proper environment
;
        call    alloc_env                       ; environment buffer
	mov	es,ax
	assume	es:nothing
	push	si				; remember location of file
	xor	cx,cx				; clear cx for counting

countloop:
	lodsb					; get a character
	inc	cx				; increment counter
        cmp     al,END_OF_LINE_OUT              ; are we at end of line?
	jnz	countloop			; no - keep counting

	mov	al,Space
	dec	si				; move back one
        mov     byte ptr [si],al                ; put a space at end of line
;
; We now know how long the new pathspec for command.com is.  Time to
; figure out how long the current COMSPEC setting is, and then to move
; all the environment data up, throwing that COMSPEC setting away, and
; preparing to append the new COMSPEC.  ComspOffset (the offset of
; where the filespec exists in the environment) is updated as well.
;
        push    cx                              ;
        mov     cx,ENVBIG                       ;
        mov     di,ComspOffset                  ; get location of COMSPEC
        mov     al,0                            ;
        repne   scasb                           ; find the end of COMSPEC
        mov     si,di                           ;
comp_endenv:                                    ;
        scasb                                   ; end of env?
        je      got_endenv                      ; yes
        repne   scasb                           ;
        jmp     comp_endenv                     ;
got_endenv:                                     ;
        mov     cx,di                           ;
        sub     cx,si                           ;
        mov     di,ComspOffset                  ;
        sub     di,ComspStrLen                  ;
        push    ds                              ;
        push    es                              ;
        pop     ds                              ;
        rep     movsb                           ;
        dec     di                              ; copy in new COMSPEC=
        push    cs                              ;
        pop     ds                              ;
        assume  ds:ResGroup                     ;
        mov     si,offset RESGROUP:ComspString  ;
        mov     cx,ComspStrLen                  ;
        rep     movsb                           ;
        mov     ComspOffset,di                  ;
        pop     ds                              ;
        assume  ds:nothing                      ;
        pop     cx                              ;

        pop     si                              ; get new comspec location back

ComtrLoop:
	lodsb
	dec	cx
	cmp	al,Space
	jz	SetComsr
	stosb

	ifdef	DBCS
	xor	ah,ah
	endif

	jcxz	setcomsr

	ifdef	DBCS

	push	ds				; Make sure we have
	push	cs				;  local DS for
	pop	ds				;  ItestKanj
	call	ItestKanj
	pop	ds				; restore parser ds
	jz	ComtrLoop
	dec	cx
	movsb
	inc	ah
	jcxz	setcomsr

	endif

	jmp	short comtrloop

setcomsr:
	push	cx

	push	cs				; Get local segment
	pop	ds				;
	assume	ds:ResGroup			;

	push	ds
	mov	si,offset ResGroup:ComSpect
	mov	cx,14

	mov	al,es:[di-1]

	ifdef	DBCS
	or	ah,ah
	jnz	iNotRoot			; Last char was KANJI second byte, might be '\'
	endif

	cmp	al,RDirChar
	jnz	iNotRoot
	inc	si				; Don't make a double /
	dec	cx

iNotRoot:
	rep	movsb

        mov     dx,ComspOffset                  ; Now lets make sure its good!
	push	es
	pop	ds

	mov	ax,OPEN shl 8
	int	21h				; Open COMMAND.COM
	pop	ds
	jc	SetComsrBad			; No COMMAND.COM here
	mov	bx,ax				; Handle
	mov	ah,CLOSE
	int	21h				; Close COMMAND.COM

SetComsrRet:
	pop	cx
	pop	si
	pop	ds				;
	assume	ds:ResGroup			;

	push	cs				; Make sure local ES is
	pop	es				;  restored
	jmp	Parse_command_line			; continue parsing command line

SetComsrBad:
	mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg

;	Note:  we're about to make a near call to TriageError, which
;	lives in a different segment and group.  Some linkers will
;	generate a warning like "Possible fix-up overflow".  We're
;	ok, though, because we all fit in 64 KB and, at init time,
;	we're still all together.

	call	triageError
	cmp	ax, 65
	jnz	doprt
	mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
DoPrt:
	call	RPrint
	mov	si,offset ResGroup:ComSpect
        mov     di,ComspOffset
	mov	cx,14
	rep	movsb				; get my default back

	jmp	short SetComsrRet

;*********************************
; Parsing Ends Here
;*********************************

ArgsDone:

	mov	es,EnvirSeg			; get environment back
	assume	es:nothing			;

	cmp	PermCom,0
	jz	ComReturns

	push	es				; Save environment pointer
	mov	ah,SET_CURRENT_PDB
	mov	bx,ds
	mov	es,bx
	int	21h				; current process is me
	mov	di,PDB_EXIT			; Diddle the addresses in my header
	mov	ax,offset DATARES:LodCom_Trap
	stosw
	mov	ax,ds
	stosw
	mov	ax,offset DATARES:Ctrlc_Trap
	stosw
	mov	ax,ds
	stosw
	mov	ax,offset DATARES:CritErr_Trap
	stosw
	mov	ax,ds
	stosw
	mov	word ptr ds:PDB_Parent_Pid,ds 	; Parent is me forever

	mov	dx,offset DATARES:Int2e_Trap
	mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 02eh
	int	21h				;set magic interrupt
	pop	es				;Remember environment

ComReturns:
	mov	ax,word ptr ds:PDB_Parent_Pid
	mov	Parent,ax			; Save parent
	mov	word ptr ds:PDB_Parent_Pid,ds 	; Parent is me
	mov	ax,word ptr ds:PDB_Jfn_Table
	mov	Io_save,ax			; Get the default stdin and out
	mov	word ptr Com_ptr+2,ds		 	; set all these to resident
	mov	word ptr Com_fcb1+2,ds
	mov	word ptr Com_fcb2+2,ds
	mov	di,offset ResGroup:ComSpec

        mov     si,ComspOffset
        cmp     AllocedEnv,0

	mov	ax,ds				; Xchg es,ds
	push	es
	pop	ds
	mov	es,ax

        jne     CopyComsp                       ; All set up for copy

	push	cs
	pop	ds

	mov	si,offset ResGroup:ComspString
	push	es
	push	di
	call	IfindE
	mov	si,di
	push	es
	pop	ds
	pop	di
	pop	es
	jnc	CopyComsp

ComSpecNofnd:
        mov     si,offset ResGroup:ComspString
        add     si,ComspStrLen
	push	cs
	pop	ds

	assume	es:ResGroup

CopyComsp:
	mov	es:PutBackComSpec.SubstPtr,di	; Save ptr to beginning of comspec path
	cmp	byte ptr [si+1],':'             ; Is there a drive specifier in comspec
	jnz	CopyComspLoop			; If not, do not skip over first 2 bytes
	add	es:PutBackComSpec.SubstPtr,2

CopyComspLoop:
	lodsb
	stosb
	or	al,al
	jnz	CopyComspLoop
	mov	es:Comspec_end,di			; Save ptr to end of comspec path
	dec	es:Comspec_end
	mov	ah,es:comdrv
	add	ah,'A'-1
	mov	es:PutBackDrv,ah			; save drive letter


	call	setup_for_messages			; set up parse and extended error messages
;
; The routine below sets up the exact resident size of COMMAND. If this is not
; the first COMMAND, then the resident code is not duplicated and the resident
; size is just the data. If we are the first COMMAND, it checks if we are to
; be loaded into HIMEM. If not, then the resident size includes the code and
; the data otherwise it is just the data.
; 
	call	Setup_res_end			;put resident size in ResSize

	push	cs
	pop	ds
	assume	ds:RESGROUP


Public EnvMaximum
EnvMaximum:

;
; Compute checksum right now before we can get corrupted and save it
;

	mov	si,offset RESGROUP:TranStart
	add	si,100h
	mov	cx,offset TRANGROUP:TranDataEnd - 100H

	cld
	shr	cx,1
	xor	dx,dx
Ichksum:
	lodsw
	add	dx,ax
	adc	dx,0
	loop	Ichksum

        mov     Sum,dx                          ; store checksum

        cmp     byte ptr PrdAttm,0              ;
        jnz     NoBatchSeg                      ; don't do autoexec or date time
;
; Allocate batch segment for d:/autoexec.bat + no arguments
;
	mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16 ;eg
        mov     ah,ALLOC                        ;
        int     21h                             ;
        jc      NoBatchSeg                      ; didn't allocate - pretend no batch
        mov     Batch,ax                        ; save batch segment

nobatchseg:
        mov     bx,EnvirSeg                     ; get old environment segment
        mov     OldEnv,bx                       ; save it

        mov     UsedEnv,0                       ; initialize env size counter
	mov	ds,bx
	assume	ds:nothing

	xor	si,si
	mov	di,si
;
; This is the maximum allowed size for the environment
;
	mov	bx,4096 - 1 			; max. allowed env. size
	mov	EnvMax,bx
				 
	shl	bx,1
	shl	bx,1
	shl	bx,1
	shl	bx,1
	mov	EnvMax, bx			; convert envmax to bytes
	dec	bx				; dec by one to leave room for double 0
	xor	dx,dx				; use dx to indicate that there was
						; no environment size error.
public NxtStr
NxtStr:
	call	GetStrLen			; get the size of the current env string

;Bugbug: Can use ss here to address UsedEnv

        push    ds                              ; get addressability to environment
        push    cs                              ;                       counter
        pop     ds                              ;
        assume  ds:ResGroup
        add     UsedEnv,cx                      ; add the string length to env size
        pop     ds                              ;
	assume	ds:nothing
	cmp	cx,1				; end of environment was encountered.
	jz	EnvExit
	sub	bx,cx
	jae	OkCpyStr			; can't fit in all of enviroment.
	inc	dx				; out of env space msg must be displayed
	jmp	short EnvExit
OkCpyStr:
	jmp	NxtStr
EnvExit:

	push	cs
	pop	ds
	assume	ds:ResGroup
	or	dx,dx				; dx will be non-zero if error
	jz	EnvNoErr
	mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
	call 	RPrint

EnvNoErr:
	mov	ax,EnvSiz			;env size previously set
	mov	cl,4
	shl	ax,cl				;get size in bytes
	cmp	ax,UsedEnv			;is it a new env?
	ja	st_envsize			;yes, store the size

	mov	ax,UsedEnv
	add	ax,15				;round up
st_envsize:	
	shr	ax,cl
	mov	EnvSiz,ax			;store env size needed(paras)

if MSVER
	cmp	SingleCom,0
	jnz	nophead 			; don't print header if singlecom
	mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
	call	RPrint
nophead:
endif

	cmp	Batch,0			;eg did we set up a batch segment?
	jnz	DoDate				;eg yes - go initialize it
	jmp	NoDttm				; don't do autoexec or date time
;
; allocate batch segment for d:/autoexec.bat + no arguments
;
DoDate:
	mov	ax,Batch			;eg get batch segment
	mov	EchoFlag,3			; set batch echo
	mov	Nest,1				; g set nest flag to 1 batch
	mov	es,ax
;
; initialize the segment
;
	xor	di,di
	mov	al,BATCHTYPE
	stosb
	mov	al,1				; g initialize echo for batch exit
	stosb					; g
;
; Hosebag! This guy does not use the struct fields to init the BatchSegment
;
	xor	ax,ax				; initialize to zero
	stosb					; clear out BatchEOF

	stosw					; g batch segment of last job - batlast
	stosw					; g segment for for
	stosb					; g for flag
	stosw					; position in file - batseek
	stosw
;
; clean out the parameters
;
	mov	ax,-1				; initialize to no parameters
	mov	cx,10
	rep	stosw
;
; decide whether we should grab the default drive
;
	cmp	byte ptr AutoBat,0
	jnz	NoAutSet
	mov	ah,GET_DEFAULT_DRIVE
	int	21h
	add	al,Ucasea

	mov	AutoBat,al
	mov	KautoBat,al			; 3/3/kk

NoAutSet:
;
; copy in the batch file name (including nul)
;
	mov	si,offset ResGroup:AutoBat
	mov	cx,8
	rep	movsw
	movsb					; move in carriage return to terminate string

ifdef ROMDOS

; Check to see if the Boot Options indicate that startup processing
; should be omitted.  If so, skip the open, and pretend that there is
; no autoexec.bat.

	push	es			; save current ES
	mov	ax,BDATA
	mov	es,ax
	assume	es:BDATA
	mov	ax,es:BootFlags		; get boot options from BIOS
	pop	es			; restore previous ES
	assume	es:RESGROUP
	test	al,BF_NoConfig		; flag set to supress processing?
	jnz	NOABAT			; if so, skip autoexec processing

endif ; ROMDOS

	mov	dx,offset ResGroup:AutoBat
	mov	ax,OPEN shl 8
	int	21h				; see if autoexec.bat exists
	jc	NoAbat
	mov	bx,ax
	mov	ah,CLOSE
	int	21h
	jmp	Drv0				; go process autoexec

noabat:
	push	ax
	call	Setup_Seg
	mov	word ptr Triage_Add+2,ax
	pop	ax
	call	Triage_Add
	cmp	ax, 65
	jz	AccDenErr			; was network access denied


; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT.  Changed
; by Ellen to check only when in Korea.  The country information
; returned will overlay the old parse data area, but we don't care
; since we won't need the parse information or country information.
; We only care about the country code returned in BX.

	mov	dx,offset ResGroup:Internat_Info ; set up internat vars
	mov	ax,INTERNATIONAL shl 8		; get country dependent info
	int	21h				;
	jc	NoKabat 			; error - don't bother with it
	cmp	bx,KOREA_COUNTRY_CODE			; are we speaking korean?
	jnz	OpenErr 			; no, don't check for kautoexe

	mov	di,BatFile			; 3/3/kk
	mov	si,offset ResGroup:KautoBat	; another trial to do	3/3/kk
	mov	cx,8				; auto execution for the 3/3/kk
	rep	movsw				; non-english country	3/3/kk
	movsb					; move in carraige return to terminate string
	mov	dx,offset ResGroup:KautoBat	; 3/3/kk
	mov	ax,OPEN shl 8			; 3/3/kk
	int	21h				; see if kautoexe.bat exists    3/3/kk
	jc	NoKabat 			; 3/3/kk
	mov	bx,ax				; 3/3/kk
	mov	ah,CLOSE			; 3/3/kk
	int	21h				; 3/3/kk
	jmp	short Drv0			; 3/3/kk

NoKabat:						; 3/3/kk
	call	Triage_Add			; get extended error
	cmp	ax, 65				; network access denied?
	jnz	OpenErr 			; no - go deallocate batch

AccDenErr:					; yes - put out message
	mov	dx,offset ResGroup:AccDen		; dx = ptr to msg
	call	RPrint

OpenErr:
	mov	es,Batch			; not found--turn off batch job
	mov	ah,DEALLOC
	int	21h
	mov	Batch,0			; after dealloc in case of ^c
	mov	EchoFlag,1
	mov	Nest,0				;g indicate no batch in progress

DoDttm:
	mov	ax,offset TranGroup:Datinit
	mov	word ptr InitAdd,ax
;;;M004	mov	ax,TrnSeg	
;
; M004; We cant use TrnSeg now because it is not initialized. We now that
; M004; the transient starts on a para boundary at the label TranStart.
; M004; We use TranStart to get the start of the transient segment.
;
	mov	ax,offset RESGROUP:TranStart	; M004
	mov	cl,4				; M004
	shr	ax,cl				; get relative seg ; M004
	mov	cx,cs
	add	ax,cx				; ax = transient seg ; M004

	mov	word ptr InitAdd+2,ax
	call	dword ptr InitAdd

NoDttm:

Copyright:
	public	Copyright
;	Bugbug:	remove Copyright label.

if IBMVER
	cmp	SingleCom,0
	jnz	Drv0				; don't print header if singlecom
	mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
	call	RPrint
endif

Drv0:						; Reset APPEND state
	push	ds				; save data segment
	push	cs				; Get local segment into DS
	pop	ds				;
	mov	ax,APPENDSETSTATE			; Set the state of Append
	mov	bx,Append_State 			;  back to the original state
	int	2fh				;
	pop	ds				; get data segment back
;
;Check FirstCom set previously to see if this is the first instance of
;command.com. If not, we do not move command.com. Instead, we copy over the
;jump table from the previous stub to the current stub.
;
	cmp	FirstCom,1			;first command.com?
	jz	move_code			;yes, move it

	push	es
	push	ds

	push	ds
	pop	es
	mov	di,offset DATARES:Int2f_Entry

	mov	ds,word ptr es:ResJmpTable+2	;get segment address
	mov	si,word ptr es:ResJmpTable		;get offset address

	mov 	cx,NUM_RELOC_ENTRIES 			;number of dword ptrs
	shl	cx,1
	shl	cx,1				;size of table in bytes

	cld
	rep	movsb				;copy the jump table
;
;Check if the resident code is in HMA. We assume that it is in HMA if its 
;code segment > 0f000h. If in HMA, we set the ComInHMA flag
;
	cmp	es:[di-2],0f000h			;is resident code in HMA?
	jb	res_low			;no, dont set flag

	mov	es:ComInHMA,1			;indicate code in HMA

res_low:
	pop	ds
	pop	es
	jmp	short finish_init
;
;Now, we can move the resident code to its final location, either to HIMEM
;or to overlay the messages in the data segment if the user has not used the
;/msg switch.
;
move_code:
	call	Move_res_code			;move the code

finish_init:
	jmp	RESGROUP:EndInit 			;g finish initializing

;
;	Get length of string pointed to by DS:SI.  Length includes NULL.
;	Length is returned in CX
;
GetStrLen:
	xor	cx,cx
NxtChar:
	lodsb
	inc	cx
	or	al,al
	jnz	NxtChar
	ret
;
; If the transient has been loaded in TranSeg, then we need to use that
; segment for calls to routines in the transient area. Otherwise, the current
; code segment is used
; Segment returned in AX.
;
Setup_Seg:
	mov	ax,TrnSeg
	cmp	TrnMvFlg, 1			; Has transient portion been moved
	jz	setup_end
	push	bx
	mov	bx,cs
	mov	ax,offset ResGroup:TranStart
	shr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	add	ax,bx
	pop	bx
setup_end:
	ret


;***	RPrintParse - display parse error message
;
;	ENTRY	DX = parse error #
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Message is displayed on stdout.

RPrintParse	proc

	assume	ds:ResGroup,ss:ResGroup

	push	dx				; preserve DX
	xchg	bx,dx				; bx = parse error #
						; dx = saved BX
	dec	bx				; bx = parse error index, from 0
	shl	bx,1				; bx = offset in word table
	mov	bx,ParsMsgPtrs[bx]			; bx = ptr to error msg
	xchg	bx,dx				; dx = ptr to error msg
						; bx = restored
	call	RPrint				; print the message
	pop	dx				; restore DX
	ret

RPrintParse	endp



IfindE:
	call	ifind				; find the name
	jc	ifind2				; carry means not found
	jmp	short Iscasb1 			; scan for = sign
;
; on return of find1, es:di points to beginning of name
;
ifind:
	cld
	call	Icount0 			; cx = length of name
	mov	es,EnvirSeg
	xor	di,di

ifind1:
	push	cx
	push	si
	push	di

Ifind11:
	lodsb

	ifdef	DBCS

	call	ItestKanj
	jz	NotKanj4
	dec	si
	lodsw
	inc	di
	inc	di
	cmp	ax,es:[di-2]
	jnz	Ifind12
	dec	cx
	loop	Ifind11
	jmp	short Ifind12
NotKanj4:

	endif

	call	IupConv
	inc	di
	cmp	al,es:[di-1]
	jnz	Ifind12
	loop	Ifind11

Ifind12:
	pop	di
	pop	si
	pop	cx
	jz	Ifind2
	push	cx
	call	Iscasb2 			; scan for a nul
	pop	cx
	cmp	byte ptr es:[di],0
	jnz	Ifind1
	stc					; indicate not found

Ifind2:
	ret

Icount0:
	push	ds
	pop	es
	mov	di,si

	push	di				; count number of chars until "="
	call	Iscasb1
	jmp	short Icountx
	push	di				; count number of chars until nul
	call	Iscasb2

Icountx:
	pop	cx
	sub	di,cx
	xchg	di,cx
	ret

Iscasb1:
	mov	al,Equalsign			; scan for an =
	jmp	short Iscasbx

Iscasb2:
	xor	al,al				; scan for a nul

Iscasbx:
	mov	cx,100h
	repnz	scasb
	ret


; ****************************************************************
; *
; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
; *
; * FUNCTION:	 This routine returns the upper case equivalent of
; *		 the character in AL from the file upper case table
; *		 in DOS if character if above  ascii 128, else
; *		 subtracts 20H if between "a" and "z".
; *
; * INPUT:	 DS	      set to resident
; *		 AL	      char to be upper cased
; *		 FUCASE_ADDR  set to the file upper case table
; *
; * OUTPUT:	 AL	      upper cased character
; *
; ****************************************************************


IupConv proc	near				
	assume	ds:ResGroup			;

	cmp	al,80h				; see if char is > ascii 128
	jb	other_fucase			; no - upper case math
	sub	al,80h				; only upper 128 chars in table
	push	ds				;
	push	bx				;
	lds	bx,dword ptr fucase_addr+1		; get table address
	add	bx,2				; skip over first word
	xlat	ds:byte ptr [bx]			; convert to upper case
	pop	bx				;
	pop	ds				;
	jmp	short iupconv_end			; we finished - exit

other_fucase:					;
	cmp	al,Lcasea			; if between "a" and "z",
	jb	iupconv_end			;     subtract 20h to get
	cmp	al,Lcasez			; upper case equivalent.
	ja	iupconv_end			;
	sub	al,20h				; Change lower-case to upper

iupconv_end:					;
	ret

IupConv endp					;


init_contc_specialcase:
						; This routine is called if control-C
	add	sp,6				;  is type during the date/time prompt
	push	si				;  at initialization time.  The desired
	mov	si,dx				;  response is to make it look like the
	mov	word ptr [si+1],0d00h			;  user typed <CR> by "popping" the
	pop	si				;  INT 21h stuff off the stack, putting
	iret					;  a <CR> in the user's buffer, and
						;  returning directly to the user.
						; In this case the user is TCODE.


; ****************************************************************
; *
; * ROUTINE:	 Setup_for_messages
; *
; * FUNCTION:	 Sets up system for PARSE and EXTENDED ERROR
; *		 messages as follows:
; *
; *		 IF /P and /MSG are entered
; *		    keep PARSE and EXTENDED ERRORS in memory
; *		 ELSE IF /P is entered
; *		    use PARSE and EXTENDED ERRORS on disk
; *		    remove PARSE ERRORS from memory
; *		 ELSE
; *		    remove PARSE ERRORS from memory
; *		 ENDIF
; *
; * INPUT:	 PERMCOM	Set up with user input
; *		 EXT_MSG	Set up with user input
; *		 System set up to retain PARSE ERRORS
; *
; * OUTPUT:	 registers unchanged
; *
; ****************************************************************


setup_for_messages	proc	near		

	push	bx
	push	ds				; save data segment
	push	es				; save environment segment
	push	ax				;
	push	dx				;
	push	di				;
	mov	ax,cs				; get local segment to ES and DS
	mov	ds,ax				;
	mov	es,ax				;

	cmp	PermCom,0			; was permcom set?
	jz	no_permcom			; No - don't worry about messages

;*	We're permanent.  Install our message services int 2f handler.

	push	es
	mov	ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
	int	21h
	mov	word ptr Int2fHandler,bx
	mov	word ptr Int2fHandler+2,es
	pop	es

;	DS = RESGROUP seg addr

;
; M005; We will not hook int 2fh on any command.com other than the first.
; M005; Carousel loads as a permanent command.com and when we exit Carousel,
; M005; it just wipes our arena out. So, int 2fh is still hooked and the
; M005; first int 2fh call after exit from Carousel (from the DOS terminate
; M005; call) goes off into space.
;
	cmp	FirstCom,0			; M005
	je	no_msg_hook			; M005
;
; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
; M005; Carousel plays around with the interrupt vector tables. He saves it
; M005; before loading a new command.com. Then, it takes hold of the current
; M005; command.com's PSP and then looks at all interrupt vectors whose
; M005; segment matches the command.com PSP and then updates these segments
; M005; to the new command.com's PSP in his saved vector table. Whenever we
; M005; we pop into his menu, he puts this saved table into the vector table.
; M005; If we now quit, Carousel just wipes out command.com's arena and then
; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
; M005; the command.com that was wiped out and so the next int 2fh call will
; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
; M005; renormalize our int 2fh pointer so that its cs is not the same as the
; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
; M005; remains nice and happy. The renormalized pointer points at a far 
; M005; jump to the actual int 2fh entry point.
;
	push	ds				; M005
	mov	dx,offset DATARES:Carousel_i2f_Hook ; M005
	sub	dx,10h				; renormalize offset; M005
	mov	ax,ds				; M005
	inc	ax				; Relocated cs ; M005
	mov	ds,ax				; M005
	mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
	int	21h
	pop	ds				; M005
	mov	word ptr Carousel_i2f_Hook+3,ds	; M005
						; patch in the cs for jump
no_msg_hook:					; M005

	cmp	Ext_Msg,SET_EXTENDED_MSG
	jne	short permcom_end			; no /msg - exit

permcom_slash_msg:				; Keep messages in memory
	mov	di,offset ResGroup:ExtMsgEnd 	; get address of resident end
	mov	ResMsgEnd,di			; save it
	jmp	short permcom_end			; exit

no_permcom:					
	cmp	Ext_msg,SET_EXTENDED_MSG		; was /msg specified?
	jnz	permcom_end			; no - no error
	mov	dx,LessArgs_Ptr 			; get message number for "Required parameter missing"
	call	RPrintParse

permcom_end:
	pop	di				;
	pop	dx				;
	pop	ax				;
	pop	es				; get environment back
	pop	ds				;
	pop	bx

	ret					;

setup_for_messages	endp




;***	CheckHelp - print help text and exit if /? is on command line
;
;	ENTRY	command-line tail at 81h
;
;	EXIT	return if /? not found
;		terminate if /? found
;
;	USED	AX,BX,CX,DX,SI,DI
;
;	EFFECTS	Help text displayed if /? found on command line

CheckHelp	proc

	assume	cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP

	mov	si,81h			; DS:SI = ptr to command-line tail
	mov	di,offset RESGROUP:Parse_Command
					; ES:DI = ptr to primary parse block
	xor	cx,cx			; CX = # positional param's found
	xor	dx,dx			; DX will be ptr to result buffer

chParse:
	call	Init_Parse		; call system parser

	cmp	ax,END_OF_LINE
	je	chRet			; end of command line, no /? found
	cmp	ax,RESULT_NO_ERROR
	je	chWhich			; valid syntax element found
	jmp	chParse			; go parse more

chWhich:
	cmp	Comnd1_Syn,offset RESGROUP:Command_?_Syn
	je	chHelp			; /? found - display help & exit
	cmp	Comnd1_Syn,offset RESGROUP:Command_C_Syn
	je	chRet			; /c found - ignore rest of line
        cmp     Comnd1_Syn,offset RESGROUP:Command_K_Syn
        je      chRet                   ; /k found - ignore rest of line
	jmp	chParse			; anything else - ignore, keep looking

chHelp:
	mov	si,offset RESGROUP:HelpMsgs	; SI = ptr to msg ptr list
chHelpNext:
	lodsw					; AX = ptr to msg
	or	ax,ax
	jz	chHelpDone			; end of list - all done
	mov	dx,ax				; DX = ptr to msg
	call	RPrint				; display msg
	jmp	chHelpNext			; go do next msg
chHelpDone:
	int	20h				; terminate program

chRet:	ret

CheckHelp	endp




;***** Setup_res_end -- This routine determines the resident size of COMMAND.
; It determines based on 2 factors:
;	1. Is this is the first COMMAND?
;	2. Is COMMAND to be loaded into HIMEM?
;   The strategy works as follows:
;
;	if ( First COMMAND)
;	then if (COMMAND in HIMEM)
;		ResSize = resident_data;
;	     else
;		ResSize = resident_data + resident_code;
;	else
;	   ResSize = resident_data;
;
; Int 2fh calls have been added to determine whether or not we are the first
;COMMAND and whether DOS is in HIMEM.
;
;	ENTRY: ResMsgEnd = resident size of data in paras
;
;	EXIT:  ResSize = resident size in low memory
;
;	REGISTERS AFFECTED: ax,cx,dx
;

GET_HMA_ADDR		equ	4a02h

Setup_res_end	proc	near
	
	push	ds
	mov	ax,cs
	mov	ds,ax				;ds = RESGROUP
	assume	ds:RESGROUP

	mov	cx,ResMsgEnd			;set resident size = data

ifndef	ROMDOS

;M042 -- Begin changes
;If messages are to be kept behind, we need to round up the messages to
;the next para boundary. This is because we have a dummy segment between the
;data and the resident code segment so that the code segment starts on a
;para boundary
;
	cmp	cx,offset RESGROUP: ExtMsgEnd	;messages to be resident?
	jne	calc_res			;no, continue
	add	cx,15				;round up
	and	cx,0fff0h
calc_res:
;
;M042 -- End changes
;
	xor	ax,ax
       	cmp	FirstCom,1			;is it first command.com?
	jnz	not_first			;no, do not keep code
;
;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
;bit 4 of dh is set
;
	push	bx
	push	cx
	mov	ax,(SET_CTRL_C_TRAPPING shl 8) or 06h ;is DOS in HIMEM? ;M013
	int	21h
	pop	cx
;bugbug: remove version check after testing
	cmp	bl,5				;bl has true version ; M013
	jb	oldver

	xor	ax,ax
	and	dh,10h				;is DOS in HMA ; M013
	pop	bx
	jnz	not_first			;DOS in HIMEM, code not
						;	resident

	mov	ax,offset CODERES: EndCode		;size of code in bytes
not_first:
;
;Note that ax = 0(side effect of int 2fh), if the code is not to be retained
;
	add	cx,ax

endif	;not ROMDOS

	add	cx,15				;round up to next para
	shr	cx,1
	shr	cx,1
	shr	cx,1
	shr	cx,1				;ax = para size of res code
	mov	ResSize,cx			;store resident size

	pop	ds
	assume	ds:nothing
	ret

ifndef	ROMDOS

;bugbug: remove this code (for version independent COMMAND) after testing
oldver:
	pop	bx
	mov	ax,offset CODERES: EndCode		;size of code in bytes
       	jmp	short not_first

endif	;not ROMDOS

setup_res_end	endp


ifndef	ROMDOS

;*** Move_res_code -- This routine moves the resident code to its final 
; location. We check if DOS is in HIMEM. If so, we try to load ourselves
; in HIMEM. If we fail, then we remain low and update ResSize to reflect
; the correct resident size. When remaining low, we have to check if we 
; need to overlay the messages part of the data segment which is determined
; by the /msg switch.
;
;	ENTRY: ResMsgEnd = end of resident data
;
;	EXIT:  The resident code is either up high or in its final location
;		down low.
;
;	REGISTERS AFFECTED: ax,bx,cx,dx,si,di
;
	
Move_res_code	proc	near

	push	ds
	push	es

	mov	ax,cs
	mov	ds,ax
	assume	ds:RESGROUP

	mov	ax,(SET_CTRL_C_TRAPPING shl 8) or 06h ; M013
	int	21h				;DOS in HIMEM?

	and	dh,10h				; M013
	jnz	move_high			;yes, move code high

;
;Check if messages have been discarded or not
;
load_low:
	push	ds
	pop	es				;es = RESGROUP
	mov	di,ResMsgEnd			;end offset in DATARES
	mov	bx,offset RESGROUP: ExtMsgEnd	;end offset of messages

	cmp	di,bx				;are messages to be kept?
	jz	no_move			;yes, dont move code

	jmp	short setup_move			;es:di points at dest.

move_high:

;
;We have to call DOS to get the load address in HIMEM for COMMAND
;We pass in bx the number of bytes we need
;
	mov	bx,offset CODERES: EndCode

;M030;
; Set di=0ffffh so that we load low in case no one answers this int 2fh
;
	mov	di,0ffffh			;DT - in case no-one handles
						;this ; M030
	mov	ax,GET_HMA_ADDR
	int	2fh

;
;If the offset = 0xffff, then no HMA available
;
	cmp	di,0ffffh			;HMA available?
	mov	ComInHMA,1			;assume command.com in HMA
	jnz	setup_move			;no error, es:di = memory

	mov	ComInHMA,0			;could not load in HMA
;
;Zero means that we do not have enough HIMEM. Remain low and update
;ResSize to reflect this
;
	mov	cx,ResMsgEnd			;size of data in bytes
	mov	ax,offset CODERES: EndCode		;size of code in bytes

	add	cx,ax
	add	cx,15				;round up to next para
	shr	cx,1
	shr	cx,1
	shr	cx,1
	shr	cx,1				;ax = para size of res code
	mov	ResSize,cx			;store resident size
	jmp	short load_low			;let code remain low

no_move:
	mov	cl,4
	add	di,0fh
	and	di,0fff0h			;round it to a para offset
	jmp	short patch_up

setup_move:
	mov	si,offset RESGROUP: StartCode
	mov	cx,offset CODERES: EndCode		;cx = bytes to move

	cld
	push	di				;need di for patching offset
	rep	movsb
	pop	di

patch_up:
	call	patch_stub
	pop	es
	pop	ds
	assume	ds:nothing
	ret

Move_res_code	endp

else	;ROMDOS

;***	Move_res_code - ROMDOS version - locate ROM resident

Move_res_code	proc

	push	es

	invoke	FindROMRes		; ES:DI = ptr to ROM resident code
	call	patch_stub

	pop	es
	ret

Move_res_code	endp

	assume	ds:NOTHING		; to match ending assume above

endif	;ROMDOS


;*** Alloc_env -- This routine allocates the temporary environment for the
; Init code to initialize the COMSPEC. This is not a complete environment. 
; Later on, at EndInit time, a proper sized environment is allocated and
; the contents of this temporary environment are copied to it. This routine
; will not be called in case a valid environment is passed to command.com
;
;       ENTRY:  FirstCom and initial EnvirSeg set
;
;       EXIT:   ax = EnvirSeg = segment of newly allocated environment segment
;
;       REGISTERS AFFECTED: ax,bx,cx,dx
;

Alloc_env	proc	near
        assume  ds:nothing
	
        push    ds
	push	es
	push	si
	push	di

        push    ss
        pop     ds
        assume  ds:RESGROUP

        mov     ax,EnvirSeg

        cmp     AllocedEnv,0
        je      alloc_cont
        jmp     alloc_done

alloc_cont:
        sub     di,di                           ; default start
        mov     bx,SIZE Environment             ; default size needed

        cmp     FirstCom,0                      ; first COMMAND.COM?
        je      alloc_seg                       ; no
;
;   Check EnvirSeg;  if non-zero, then scan it for PATH and COMSPEC;
;   Record their respective locations and do not add the default vars.
;
        or      ax,ax
        jz      alloc_new                       ; no previous environment

        mov     es,ax
        assume  es:nothing

find_path:
        mov     al,0
        sub     di,di
comp_path:
        scasb                                   ; end of env?
        je      find_prompt                     ; yes
        dec     di
        mov     cx,PathStrLen
        mov     si,offset RESGROUP:PathString
        repe    cmpsb
        je      got_path
        mov     cx,256
        repne   scasb                           ; find next NULL
        jmp     comp_path

got_path:
        mov     PathString,0                    ; don't add it

find_prompt:
        sub     di,di
comp_prompt:
        scasb                                   ; end of env?
        je      find_comspec                    ; yes
        dec     di
        mov     cx,PrmptStrLen2
        mov     si,offset RESGROUP:PrmptString
        repe    cmpsb
        je      got_prompt
        mov     cx,256
        repne   scasb                           ; find next NULL
        jmp     comp_prompt

got_prompt:
        mov     PrmptString,0                   ; don't add it

find_comspec:
        sub     di,di
comp_comspec:
        scasb                                   ; end of env?
        je      got_envend                      ; yes
        dec     di
        mov     cx,ComspStrLen
        mov     si,offset RESGROUP:ComspString
        repe    cmpsb
        je      got_comspec
        mov     cx,256
        repne   scasb                           ; find next NULL
        jmp     comp_comspec

got_comspec:
        mov     ComspOffset,di

find_envend:
        sub     di,di
        mov     cx,ENVBIG                       ; max env size
comp_envend:
        dec     cx                              ;
        scasb                                   ; end of env?
        je      got_envend                      ; yes
        repne   scasb
        jmp     comp_envend

got_envend:
        dec     di
        lea     bx,[di+SIZE Environment]        ; add room for the basics
;
;   We want to fall through to alloc_new and set up default
;   path and prompt ONLY IF this is the first process;  in all other
;   cases, we assume it is a bad idea to try editing the user's environment
;
        push    ds
        mov     ds,ds:[PDB_Parent_Pid]
        cmp     ds:[PDB_Parent_Pid],0           ; is parent's parent pid field 0?
        pop     ds
        jne     alloc_seg                       ; no, we're not the first process
                                                ; so don't muck with the env.
alloc_new:
        inc     AllocedEnv                      ; note we have virgin env.

alloc_seg:
;
; Allocate default environment size
;
        mov     cx,bx                           ; save byte-granular size in CX
        add     bx,15
        shr     bx,1
        shr     bx,1
        shr     bx,1
        shr     bx,1                            ; BX = # paras
	mov	ah,ALLOC
	int	21h
        jnc     init_ok
        jmp     init_nomem                      ; insufficient memory, error
;
; If a previous environment existed (ie, DI != 0), then copy it into
; the new buffer
;
init_ok:
	mov	es,ax
        assume  es:nothing                      ; es = temp env segment

        or      di,di
        jz      copy_path

        push    cx
        push    ds
        mov     ds,EnvirSeg
        assume  ds:nothing
        sub     si,si
        mov     cx,di
        sub     di,di
        rep     movsb
        pop     ds
        assume  ds:RESGROUP
        pop     cx
        sub     cx,di

copy_path:
;
; First clear out (the rest of) the buffer
;
        push    di
        sub     ax,ax
        rep     stosb
        pop     di
;
; Initialize the path string (PATH=) first
;
        mov     si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
        cmp     byte ptr [si],al                ; add it?
        je      init_prompt                     ; no
        mov     cx,PathStrLen+1                 ;
        rep     movsb                           ;
        cmp     AllocedEnv,al                   ; virgin env?
        je      init_prompt                     ; no
;
; Establish a more reasonable default for the PATH
;
	mov	ah,GET_DEFAULT_DRIVE
	int	21h
        add     al,'A'                          ; convert to letter
        mov     [DefPathString],al              ;
        mov     [DefPath2String],al             ; now our default paths are complete

        mov     dl,0                            ; get dir for default drive
        push    ds                              ;
        push    es                              ;
        pop     ds                              ;
        mov     byte ptr [di],'\'               ;
        lea     si,[di+1]                       ; set DS:SI -> available space
        mov     ah,Current_Dir                  ;
        int     21h                             ;
        pop     ds                              ;

        mov     cx,DefPathStrLen+1              ;
        mov     dx,offset RESGROUP:DefPathString
        mov     si,dx                           ;
        mov     ah,CHDir                        ;
        int     21h                             ;
        jnc     init_setpath                    ; DefPathString exists!

        mov     cx,DefPath2StrLen+1             ;
        mov     dx,offset RESGROUP:DefPath2String
        mov     si,dx                           ;
        mov     ah,CHDir                        ;
        int     21h                             ;
        jc      init_prompt                     ; DefPath2String doesn't exist

init_setpath:
        mov     dx,di                           ; success
        push    ds                              ; so restore prev dir
        push    es                              ;
        pop     ds                              ; DS:DX -> prev dir
        mov     ah,CHDir                        ;
        int     21h                             ;
        pop     ds                              ;

        dec     di                              ; then copy in DefPathString
        rep     movsb                           ; DS:SI -> "C:\\DOS\0"
;
; Initialize the default prompt
;
init_prompt:
        push    di                              ;
        sub     ax,ax                           ;
        mov     cx,64                           ; insure any data read in
        rep     stosb                           ; from Current_Dir is zapped
        pop     di                              ;

        cmp     AllocedEnv,al                   ; virgin env?
        je      init_comspec                    ; no
        mov     si,offset RESGROUP:PrmptString  ; DS:SI -> "PROMPT=$P$G\0"
        cmp     byte ptr [si],al                ; add it?
        je      init_comspec                    ; no
        mov     cx,PrmptStrLen+1                ;
        rep     movsb                           ;
;
; Initialize the Comspec string
;
init_comspec:
        cmp     ComspOffset,ax                  ; add it?
        jne     init_done                       ; no
        lea     ax,[di+ComspStrLen]             ;
        mov     ComspOffset,ax                  ;
        mov     si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
        mov     cx,ComspStrLen2+1               ;
        rep     movsb                           ;

init_done:
        mov     ax,es                           ; return env seg in ax
        mov     EnvirSeg,ax                     ; save env seg
        inc     AllocedEnv                      ; remember that *we* alloced it

alloc_done:
	pop	di
	pop	si
	pop	es
        pop     ds
        assume  ds:nothing
	ret

init_nomem:
;
;We call the error routine from here. This routine never returns. It either
;terminates COMMAND with error( if it is not the first invocation ) or hangs
;the system ( if it is the first COMMAND.COM ).
;
	call	alloc_error

Alloc_env	endp


;*** Alloc_error: This routine just jumps to the actual label where we 
; check if this is a permanent or secondary command.com and take the 
; appropriate action.
;
;	ENTRY:	ds = RESGROUP = DATARES
;
;	EXIT:	None - does not return
;
;	REGISTERS AFFECTED: Does not matter
;

public Alloc_error
Alloc_error	proc	near

	jmp	RESGROUP:BadMemErr

Alloc_error	endp

;*** Patch_stub -- This routine patches in the segment and offset values in
; the stub table of the various entry points in the resident code segment.
; Some of them are interrupt entry points and some of them are entries from
; the transient to the resident code segment.
;
;	ENTRY:	ds = RESGROUP
;		es:di = segment:offset of final location of resident code
;
;	EXIT:	All segments and offsets patched into the stub table
;
;	REGISTERS AFFECTED: ax, bx, cx, dx, si, di
; 
;
Patch_stub	proc	near

	assume	ds:RESGROUP
	
	push	es

	mov	bx,es			;bx = resident code segment
	mov	dx,di
	mov	di,offset DATARES:Int2f_Entry
	mov	si,offset RESGROUP:Reloc_Table
	push	ds
	pop	es			;es = RESGROUP = DATARES
;
;bx:dx = segment:offset of resident code segment
;es:di = entry point table in stub
;ds:si = offset table in INIT segment -- offsets of code entry points now
;
	mov	cx,NUM_RELOC_ENTRIES		;number of entry points
patchlp:
	lodsw				;get current offset
	add	ax,dx			;offset it by code seg location 
	stosw				;store offset
	mov	ax,bx			
	stosw				;store segment 
	loop	patchlp

	pop	es
	ret

Patch_stub	endp

;*** Patch_segs -- This routine patches the segment values in the dword 
; pointers that the stub uses to jump to the actual handler. These values 
; are temporarily needed to handle these interrupts if they occur before
; the resident is relocated to its final position and all the addresses of
; the handlers have been updated.
;
;	ENTRY:	es = PSP segment = code segment
;
;	EXIT:	Current segment values patched into the jump table in the
;		stub.
;
;	REGISTERS AFFECTED: ax, cx, di
;

Patch_segs	proc	near

	mov	di,offset RESGROUP:Int2f_Entry
	mov	cx,4			;we have to patch 4 handlers
	add	di,2
	mov	ax,es

pseglp:
	stosw				;store the segment value
	add	di,2			;skip the next offset value
	loop	pseglp

	ret

Patch_segs	endp


;*** get_XMMAddr -- This routine gets the call address for the XMM driver
; by issuing the appropriate int 2fh. This is stored in a stub variable 
; and is used by the stub when we have to jump to the resident in HMA
;
;	ENTRY:	ds = RESGROUP
;
;	EXIT:	XMMCallAddr = XMM driver far call address
;
;	REGISTERS AFFECTED:
;

get_XMMAddr	proc	near
	assume	ds:RESGROUP

	push	es

	mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
	int	2Fh
	cmp	al,80h			; Q: installed
	jne	short cXMMexit	;   N: set error, quit
;
; get the XMM control functions entry point, save it, we
; need to call it later.
;
	mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
	int	2Fh

	mov	word ptr [XMMCallAddr], bx
	mov	word ptr [XMMCallAddr+2],es

cXMMexit:
	pop	es
	ret				; done

get_XMMAddr	endp


INIT	ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\parse2.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)parse.asm	1.1 85/05/14
;	SCCSID = @(#)parse.asm	1.1 85/05/14
.sall
.xlist
.xcref
    INCLUDE DOSSYM.INC
    INCLUDE DEVSYM.INC
    include comsw.asm
    include comseg.asm
    include comequ.asm
.list
.cref


break <Parse.Asm>
;----------------------------------------------------------------------------
;    PARSE.ASM contains the routines to perform command line parsing.
;    Parse and Path share a buffer and argv[] definitions.
;   Invoking <Parseline> maps the unparsed command line in COMBUF into an
;   array of pointers to the parsed tokens.  The resulting array, argv[],
;   also contains extra information provided by cparse about each token
;   <Parseline> should be executed prior to <Path_Search>
;
; Alan L, OS/MSDOS				    August 15, 1983
;
;
; ENTRY:
;   <Parseline>:	    command line in COMTAB.
; EXIT:
;   <Parseline>:	    success flag, argcnt (number of args), argv[].
; NOTE(S):
;   *	<Argv_calc> handily turns an array index into an absolute pointer.
;	The computation depends on the size of an argv[] element (arg_ele).
;   *	<Parseline> calls <cparse> for chunks of the command line.  <Cparse>
;	does not function as specified; see <Parseline> for more details.
;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
;	need to know about.  This extra information is stored in a switch_flag
;	word with each command-line argument; the switches themselves will not
;	appear in the resulting arg structure.
;   *	With the exception of CARRY, flags are generally preserved across calls.
;---------------
; CONSTANTS:
;---------------
    DEBUGx	equ	    FALSE	; prints out debug info
;---------------
; DATA:
;---------------

DATARES 	SEGMENT PUBLIC BYTE
	EXTRN	FORFLAG:BYTE
DATARES     ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	combuf:byte
	EXTRN	cpyflag:byte
	EXTRN	expand_star:byte
	EXTRN	RESSEG:word
	EXTRN	STARTEL:word
TRANSPACE   ENDS

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;
	PUBLIC	argv_calc		; convert array index into address
	PUBLIC	parseline


assume cs:trangroup, ds:trangroup, es:trangroup, ss:nothing


break <Parseline:  Munch on the command line>
;----------------------------------------------------------------------------
;    PARSELINE takes an MSDOS command line and maps it into a UNIX-style
; argv[argvcnt] array.	The most important difference between this array and
; the tradition UNIX format is the extra cparse information included with
; each argument element.
;---------------
; ENTRY:
;	(BL	     special delimiter for cparse -- not implemented)
;---------------
; EXIT:
;	CF	    set if error
;	AL	    error code (carry set).  Note AH clobbered in any event.
;	argv[]	    array of cparse flags and pointers to arguments
;	argvcnt     argument count
;---------------
; NOTE(S):
;	*   BL (special delimiter) is ignored, for now (set to space).
;	*   Parseflags record contains cparse flags, as follows:
;		sw_flag 	--	was this arg a switch?
;		wildcard	--	whether or not it contained a * or ?
;		path_sep	--	maybe it was a pathname
;		unused		--	for future expansion
;		special_delim	--	was there an initial special delimiter?
;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
;	*   Relationship between input, cparse output, and comtail can be
;	    found in the following chart.  Despite the claim of the cparse
;	    documentation that, "Token buffer always starts d:  for non switch
;	    tokens", such is not the case (see column two, row two).
;	    Similarly, [STARTEL] is not null when the command line is one of
;	    the forms, "d:", "d:\", or "d:/".  In fact, *STARTEL (i.e., what
;	    STARTEL addresses) will be null.  This is clearly just a
;	    documentation error.
;	*   cparse also returns a switch code in BP for each switch it
;	    recognizes on the command line.
;	*   arglen for each token does NOT include the terminating null.
;	*   Finally, note that interesting constructions like 'foodir/*.exe'
;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
;	    echo 'foodir', then '*', then '.exe'.  Using cparse for command-
;	    line parsing may result in slightly different behavior than
;	    previously observed with the old COMMAND.COM command-line parser.
;
;	    Input		    Cparse		Command Line (80H)
;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
;	alan\foo.bat		alan\foo.bat		alan\foo.bat
;	foo.bat 		foo.bat 		foo.bat
;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
;	c:foo.bat		c:foo.bat		c:foo.bat
;---------------
; CONSTANTS:
;---------------
;---------------
; DATA:
;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte
	EXTRN	argbufptr:word
	EXTRN	comptr:word
	EXTRN	last_arg:word
	EXTRN	tpbuf:byte
TRANSPACE	ENDS

;---------------
parseline:
;---------------

	push	AX				; most of these are clobbered
	push	BX				; by cparse...
	push	CX
	push	DX
	push	DI
	push	SI
	pushf
	mov	cpyflag,0			; Turn "CPARSE called from COPY flag" off

	mov	[LAST_ARG], -1			; last argument at which to accumulate
	xor	ax,ax
	mov	cx,SIZE arg_unit
	mov	di,offset trangroup:arg
	rep	stosb
	mov	argbufptr,offset trangroup:arg.argbuf
	mov	arg.argswinfo, 0		; switch information, and info to date
	mov	arg.argvcnt, 0			; initialize argvcnt/argv[]
	mov	SI, OFFSET TRANGROUP:combuf+2	; prescan leaves cooked input in combuf

; This next section of code (up to pcont:)  makes sure that si is set up for
; parsing.  It should point at COMBUF if FORFLAG is set and arg.argforcombuf
; otherwise.  This is done so that commands can get arg pointers into their
; original command line (or an exact copy of it) in arg_ocomptr.
; Arg.argforcombuf is used so that the for loop processor will always be able
; to get a hold of its original command line; even after COMBUF is blasted by
; the command to be repeated or the transient part of command has been
; reloaded.

	push	ds
	mov	ds,[RESSEG]
	assume	ds:resgroup
	cmp	FORFLAG,0
	pop	ds
	assume	ds:trangroup
	jnz	pcont
	mov	di,OFFSET TRANGROUP:arg.argforcombuf
	xor	ch,ch
	mov	cl,[COMBUF+1]
	inc	cl
	rep	movsb
	mov	si,OFFSET TRANGROUP:arg.argforcombuf

pcont:
	mov	DI, OFFSET TRANGROUP:tpbuf	; destination is temporary token buffer
	mov	BL, ' '                         ; no special delimiter, for now

parseloop:
	mov	comptr,si			; save ptr into original command buffer
	xor	BP, BP				; switch information put here by cparse
	mov	byte ptr [expand_star],0	; don't expand *'s to ?'s
	invoke	scanoff 			; skip leading blanks...
	invoke	cparse				; byte off a token (args in SI, DI, BL)
	jnc	More_prse
	or	BP,BP				; Check for trailing switch character
	jz	parsedone
	call	newarg				; We hit CR but BP is non-zero. The
						;   typical cause of this is that a
						;   switch char IMMEDIATELY preceeds
						;   the CR. We have an argument, but it
						;   is sort of an error.
	jmp	short parsedone 		; We're done (found the CR).

More_prse:
	mov	cpyflag,2			; tell CPARSE that 1st token is done
	call	newarg				; add to argv array (CX has char count)
	jnc	parseloop			; was everything OK?
	jmp	short parse_error		; NO, it wasn't -- bug out (CF set)

parsedone:					; successful completion of parseline
	popf
	clc
	jmp	short parse_exit

parse_error:					; error entry (er, exit) point
	popf
	stc
parse_exit:					; depend on not changing CF
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	ret

;---------------
; parseline ends
;----------------------------------------------------------------------------


break <NewArg>
;----------------------------------------------------------------------------
;   NEWARG adds the supplied argstring and cparse data to arg.argv[].
; ENTRY:
;   BH			argflags
;   CX			character count in argstring
;   DI			pointer to argstring
;   comptr		ptr to starting loc of current token in original command
;   [STARTEL]		cparse's answer to where the last element starts
; EXIT:
;   argbufptr		points to next free section of argbuffer
;   arg.argbuf		contains null-terminated argument strings
;   arg.argvcnt 	argument count
;   arg.argv[]		array of flags and pointers
;   arg.arg_ocomptr	ptr to starting loc of current token in original command
;   CF			set if error
;   AL			carry set:  error code; otherwise, zero
;---------------
newarg:
;---------------

	push	BX
	push	CX
	push	DX				; one never knows, do one?
	push	DI
	push	SI
	pushf
	call	arg_switch			; if it's a switch, record switch info
						; LEAVE SWITCH ON COMMAND LINE!!
;;;	jc	newarg_done			; previous arg's switches -- and leave

	cmp	arg.argvcnt, ARGMAX		; check to ensure we've not
	jge	too_many_args			; exceeded array limits
	mov	DH, BH				; save argflags
	mov	BX, arg.argvcnt 		; argv[argvcnt++] = arg data
	inc	arg.argvcnt
	mov	AX, OFFSET TRANGROUP:arg.argv
	call	argv_calc			; convert offset to pointer
	mov	[BX].argsw_word, 0		; no switch information, yet...
	mov	[BX].arglen, CX 		; argv[argvcnt].arglen = arg length
	mov	[BX].argflags, DH		; argv[argvcnt].argflags = cparse flags
	mov	SI, argbufptr
	mov	[BX].argpointer, SI		; argv[argvcnt].argpointer = [argbufptr]
	add	SI, [STARTEL]			; save startel from new location
	sub	SI, DI				; form pointer into argbuf
	mov	[BX].argstartel, SI		; argv[argvcnt].argstartel = new [STARTEL]
	mov	si,[comptr]
	mov	[BX].arg_ocomptr,si		; arg_ocomptr=ptr into original com line

	mov	SI, DI				; now save argstring in argbuffer
	mov	DI, argbufptr			; load the argbuf pointer and make
	add	DI, CX				; sure we're not about to run off
	cmp	DI, OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
	jge	buf_ovflow			; the end of the buffer (plus null byte)
	sub	DI, CX				; adjust the pointer
	cld
	rep	movsb				; and save the string in argbuffer
	mov	AL, ANULL			; tack a null byte on the end
	stosb
	mov	argbufptr, DI			; update argbufptr after copy

newarg_done:
	popf
	clc
	jmp	short newarg_exit

too_many_args:
	mov	AX, arg_cnt_error
	jmp	short newarg_error

buf_ovflow:
	mov	AX, arg_buf_ovflow

newarg_error:
	popf
	stc

newarg_exit:
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	ret

;---------------
; NewArg ends
;----------------------------------------------------------------------------


break <Arg_Switch>
;----------------------------------------------------------------------------
;   ARG_SWITCH decides if an argument might really be a switch.  In the
; event that it is, and we can recognize
; ENTRY:
;   As in <newarg>.
; EXIT:
;   CF	    --	    clear (wasn't a switch); set (was a switch)
; NOTE(S):
;   *	The mechanism mapping a switch into a bit-value depends entirely
;	on the order of definition in the <switch_list> variable and the
;	values chosen to define the bits in CMDT:COMEQU.ASM.  Change either
;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
;	this mechanism.  This code taken from CMDT:TCODE.ASM.
;   *	The <switch_list> declared below is redundant to one declared in
;	TDATA.ASM, and used in TCODE.ASM.
;   *	An ugly routine.
;---------------
; CONSTANTS:
;---------------
;   Constants come from the definitions in CMDT:COMEQU.ASM.
;---------------
; DATA:
;---------------

TRANSPACE	SEGMENT PUBLIC BYTE		;AC000;
    extrn   switch_list:byte
    switch_count    EQU     $-switch_list
transpace   ends

;---------------
Arg_Switch:
;---------------

	push	AX
	push	BX
	push	CX
	push	DI
	pushf
	test	BH, MASK sw_flag		; is it a switch? (preserve flag word)
	jz	arg_no_switch0
	cmp	[LAST_ARG], -1			; have we encountered any REAL args yet?
	je	arg_no_switch1			; no, so leading switches don't matter
	mov	BX, [LAST_ARG]			; yes, add switch info to last REAL arg
	mov	AX, OFFSET TRANGROUP:arg.argv
	call	argv_calc
	or	[BX].argsw_word, BP
	or	arg.argswinfo, BP

arg_yes_switch: 				; ah, sweet success...
	popf
	stc
	jmp	short arg_switch_exit

arg_no_switch0:
	mov	AX, arg.argvcnt 		; future switches should then affect
	mov	[LAST_ARG], AX			; this argument

arg_no_switch1: 				; wasn't a switch, or we're pretending
	popf
	clc

arg_switch_exit:
	pop	DI
	pop	CX
	pop	BX
	pop	AX
	ret

;---------------
; Arg_Switch ends
;----------------------------------------------------------------------------


break <Argv_calc>
;----------------------------------------------------------------------------
;   ARGV_CALC maps an array index into a byte-offset from the base of
; the supplied array.  Method used for computing the address is:
;	Array Index * Array Elt Size + Base Addr = Elt Addr
; ENTRY:
;   AX	    --	    base of array
;   BX	    --	    array index
; EXIT:
;   BX	    --	    byte offset
;---------------

argv_calc:
	push	ax				; Save base
	mov	al,bl				; al = array index
	mov	bl,SIZE argv_ele		; bl = size of an argv element
	mul	bl				; ax = base offset
	pop	bx				; Get base
	add	ax,bx				; Add in base offset
	xchg	ax,bx				; Restore ax and put byte offset in bx
	ret

;---------------
; argv_calc ends
;----------------------------------------------------------------------------



trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\loadhi.asm ===
page	,132
	title	LOADHIGH Internal Command
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;************ LOADHIGH command -- loads programs into UMBs.
;
comment %==================================================================

This is a new module added to support loading programs into UMBs provided
by DOS 5.0. 

Usage:

LOADHIGH [/L:umb[,size][;umb[,size]]*] <filespec>

<filespec> has to be a filename that is not wildcarded.


==========================================================================%

;
;	Revision History
;	================
;
;	M009	SR	08/01/90	Set flags to indicate that we are
;				loading and high and also remember
;				current UMB state.
;
;	M016	SR	08/09/90	Give special error message on attempt
;				to loadhigh batch files and invalid
;				filename on Loadhigh command line.
;
;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
;				after the program name also as part
;				of the command line being passed to
;				the program to be invoked.
;


;*** INCLUDE FILES


	.xlist
	.xcref

	include	dossym.inc
	include	comequ.asm
	include	syscall.inc
	include arena.inc
	include	comseg.asm

	.list
	.cref

;*** EQUATES AND STRUCTURES

NUM_LH_SWS	equ	5	;number of valid switches

ResultBuffer	struc		; structure of parse result buffer

ValueType	db	?
ValueTag	db	?
SynPtr		dw	?
ValuePtr	dd	?

ResultBuffer	ends

;
; -----------------------------------------------------------------------------
;

DATARES		segment

HV_Extern	equ	1
HV_LoadHigh	equ	1
	include highvar.inc	; Includes high-variables here, as external

DATARES		ends
;
; -----------------------------------------------------------------------------
;


TRANDATA		segment

	extrn	ComExt		:BYTE
	extrn	ExeExt		:BYTE
	extrn	Extend_Buf_Ptr	:WORD
	extrn	Msg_Disp_Class	:BYTE
	extrn	Parse_LoadHi	:BYTE
	extrn	NoExecBat_Ptr	:WORD	; M016
	extrn	LhInvFil_Ptr	:WORD	; M016
	extrn	LhInvArg_Ptr	:WORD	; Richid
	extrn	ReqParmMiss	:WORD	; Richid
	extrn	LhInvSwt_Ptr	:WORD	; Richid
	extrn	LhBadUMB_Ptr	:WORD	; Richid

TRANDATA		ends

TRANSPACE	segment

	extrn	ResSeg		:WORD
	extrn	ExecPath	:BYTE
	extrn	Comsw		:WORD
	extrn	Arg		:BYTE
	extrn	SwitChar	:BYTE	; M039

TRANSPACE	ends

TRANCODE		segment

	extrn	Cerror:near
	extrn	Parse_With_Msg:near
	extrn	Lh_Execute:near			;new execute label; M051
	extrn	Path_Search:near

	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP

;
; -----------------------------------------------------------------------------
;
	include highload.inc		; Grab code for ParseVar and such

iCmdLine	equ	81h		; PSP:81h points to command-line

;
; -----------------------------------------------------------------------------
;

;****	LoadHigh -- Main routine for Loadhigh command
;
;	ENTRY	Command line tail is at PSP:iCmdLine terminated by 0dh
;		CS = DS = SS = TRANGROUP
;
;	EXIT	None
;
;	USED	ax, bx, cx, dx, si, di, es
;
;	ERROR EXITS
;		Message pointers are setup at the error locations and then
;	we jump back to CERROR which is the transient error recycle point.
;	Apart from parse errors, the other errors handled are too many
;	switches anf invalid filenames.
;
;	EFFECTS
;		The allocation strategy and the state of the arena chain are
;	put in the requested state according to the given options. If a 
;	filename is also given, it is executed as well.
;
;

	public	LoadHigh

LoadHigh		proc	near

	push	ds
	pop	es
	assume	es:TRANGROUP

;
;Get command tail to be passed to the program. This includes any whitespace
;chars between the program name and its parameters as well.
;On return, ds:si points at the start of the command tail.
;

	call	ParseLhCmd		;parse the command line
	jc	LhErr			;error parsing, abort

	call	SetupCmdLine		;setup pgm's command line

	call	SetupPath		;setup path for file
	jc	LhErr			;file not found

;
;Set allocation strategy to HighFirst and link in UMBs for exec. This will
;be reset after return from the Exec
;We will also set a resident flag to indicate that UMBs were activated for
;the Exec. On return from the Exec, this flag will be used to deactivate UMBs
;

	call	HideUMBs		;prepare upper-memory for load

	jmp	Lh_Execute		;go and exec file ;M051

LhErr:
;
;The error message has been setup at this stage
;
	jmp	Cerror			;print error message and recycle 
					
LoadHigh		endp


;*** 	ParseLhCmd - parses any command-line options
;
;	ENTRY	None
;
;	EXIT	Carry clear -- command line parsed successfully
;		Carry set -- appropriate error message setup
;
;	USED	ax, si
;
;	EFFECTS
;		Options set up (see highvar.inc)
;		Filename to be executed setup
;
;	ParseLhCmd calls InitVar to initialize data filled in by ParseVar,
;	then calls ParseVar itself to actually parse the commmand-line.  On
;	return from ParseVar, DS:SI will point to the beginning of the child
;	module's name on the command-line; thus it calls LhCopyFilename to
;	prepare the command-line for that program.
;

ParseLhCmd	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	mov	si,iCmdLine	;ds:si points at command line

	push	es		;Store ES 'cause we're gonna change it:

	push	ds
	pop	es		;Make sure es:si points to cmd line as well

	call	InitVar		;Initialize data for ParseVar
	call	ParseVar	;And parse the command line

	pop	es		;Restore ES now; we're done with it.

	jnc	plcC		;If no error, continue on our way.

	cmp	ax, PV_BadUMB	;Bad UMB passed?
	jnz	plc10
	mov	dx,offset TRANGROUP:LhBadUMB_Ptr
	stc
	ret

plc10:	mov	dx,offset TRANGROUP:LhInvSwt_Ptr
	cmp	ax, PV_InvSwt		;Unrecognized switch passed?
	jz	plc20
	mov	dx,offset TRANGROUP:LhInvArg_Ptr
plc20:	stc
	ret

plcC:	call	LhCopyFilename		;copy filename into our buffer
	ret				;Return-- carry=status
ParseLhCmd	endp

;***	LhCopyFilename -- copy filename from command line to buffer
;
;	ENTRY	ds:si points at primary argument (filename)
;
;	EXIT	Carry set -- filename has wildcards.  In this event, DX will
;				already contain an appropriate error number.
;		Carry clear -- filename has been copied as needed; DS:SI
;				points to first character (most likely space)
;				after filename.
;
;	USED	ax, si
;
;	EFFECTS
;		ExecPath contains the filename
;
;If there are any wildcards in the filename, then we have an error
;

LhCopyFilename	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	mov	di, offset TRANGROUP:ExecPath

	mov	cx, 0	; Copied zero characters
@@:
	lodsb
	cmp	al, '*'			;wildcard?
	je	lhfilerr		;yes, error
	cmp	al, '?'			;wildcard?
	je	lhfilerr		;yes, error

	cmp	al,0dh			;carriage return?
	jz	@f
	cmp	al, SwitChar		;'/'?
	jz	@f
	or	al, al			;EOS?
	jz	@f
	cmp	al, ' '			;Space?
	jz	@f
	or	al, al
	jz	@f

	stosb				;store char
	inc	cx			;And remember that we did one more
	jmp short	@b
@@:
	xor	al,al			;Indicate EOS reached
	stosb				;store char

	or	cx, cx		; If we didn't copy any characters,
	jz	lhmissing	; they didn't give a filename.

	dec	si	; Move back to the delimiting character
	clc		; And indicate no error occurred
	ret

lhfilerr:
	mov	dx,offset TRANGROUP:LhInvFil_Ptr ; "Invalid Filename" ; M016
	stc
	ret

lhmissing:
	mov	dx,offset TRANGROUP:ReqParmMiss	; "Required parm missing"
	stc
	ret

LhCopyFilename	endp

;***	SetupCmdLine -- prepare command line for the program
;
;	ENTRY	{es/ds}:si = points just after the end of the child program
;
;	EXIT	None
;
;	USED
;
;	EFFECTS		
;		The rest of the command line following the pgm name is 
;	moved to the top of the command line buffer (at TRANGROUP:81h)
;	and a new command line length is put in
;

SetupCmdLine	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	mov	di,iCmdLine
	xor	cl,cl
	dec	cl			;just CR means count = 0
@@:
	lodsb
	stosb

	inc	cl			;update count

	or	al, al
	jz	@f
	cmp	al,0dh			;carriage return?
	jnz	@b			;no, continue storing
@@:
	mov	es:[80h],cl		;store new cmd line length

	ret
SetupCmdLine	endp


;***	LhSetupErrMsg -- Sets up error messages
;
;	ENTRY	ax = error message number
;
;	EXIT	None
;
;	USED	dx
;
;	EFFECTS
;		Everything setup to display error message
;

LhSetupErrMsg	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	mov	msg_disp_class,EXT_MSG_CLASS
	mov	dx,offset TranGroup:Extend_Buf_ptr
	mov	Extend_Buf_ptr,ax

	ret

LhSetupErrMsg	endp

;***	SetupPath -- Do path search for the file to be executed
;
;	ENTRY	None
;
;	EXIT	Carry set if file not found or not executable file
;
;	EFFECTS
;		ExecPath contains the full path of the file to be executed
;

SetupPath	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

;
;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
;because the path search routine that we are about to invoke expects the
;filename to search for to be argv[0].
;
;If our new argv[0] starts with a switcharacter, it's an option... skip right
;over it by doing the whole move again (smaller, of course, this time).
;

	mov	ax,arg.argvcnt		;total number of arguments
	dec	ax			;less one - skip "LoadHigh"
	mov	bx,SIZE Argv_ele
	mul	bx			;dx:ax = size of argument lists

	getdata	cl, fm_argc		;CL = number of arguments to skip
	inc	cl			;Skip one arg, to get over "lh"

;
;Move argv[1]..argv[n] to argv[0]..argv[n-1].  Here, AX == the overall size
;of the argument lists.
;

argloop:
	jcxz	argdone			;If we've finished copying args, leave.

	dec	cx			;One less time we'll go through this.

	push	ax			;Copy ( size of remaining list ) bytes
	push	cx			;And remember how many args there were

	mov	cx,ax			;size to move

	mov	di,offset TRANGROUP:Arg	;Copy TO argv[0]
	mov	si,di			;
	add	si,SIZE Argv_ele	;Copy FROM argv[1]

	cld
	rep	movsb			;Move the argument list
	dec	arg.argvcnt		;Fake one less argument, and
	sub	ax, SIZE Argv_ele	;there's one argument we don't copy.

	pop	cx
	pop	ax			;Restore the size of the arg list

	jmp short argloop

;
; Done moving... argv[0] is now the child program's name, and [1] its first arg
;

argdone:
	call	path_search		;look in the path
;
;ax = 0, no file found
;ax < 4, batch file found -- cant be executed
;ax = 4,8 => .com or .exe file found
;
	or	ax,ax			;any file found?
	jz	no_exec_file		;no, error

	cmp	ax,4			;executable file?
	jl	no_exec_bat		;no, indicate fail ; M016

	clc
	ret

no_exec_bat:				; M016
	mov	dx,offset TRANGROUP:NoExecBat_Ptr ;Setup message ptr ; M016
	jmp	short lhsp_errret		;return error; M016

no_exec_file:
	mov	ax,ERROR_FILE_NOT_FOUND
	call	LhSetupErrMsg		;setup error message

lhsp_errret:				; M016
	stc
	ret

SetupPath	endp


TRANCODE		ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\path1.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)path1.asm	1.1 85/05/14
;	SCCSID = @(#)path1.asm	1.1 85/05/14
.sall
.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include comsw.asm
	include comseg.asm
	include comequ.asm
.list
.cref

break <Path.Asm>
;----------------------------------------------------------------------------
;    PATH.ASM contains the routines to perform pathname incovation.  Path and
;    Parse share a temporary buffer and argv[] definitions.  <Path_Search>,
;    given a pathname, attempts to find a corresponding executable or batch
;    file on disk.  Directories specified in the user's search path will be
;    searched for a matching file, if a match is not found in the current
;    directory and if the pathname is actually only an MSDOS filename.
;    <Path_Search> assumes that the parsed command name can be found in
;    argv[0] -- in other words, <Parseline> should be executed prior to
;    <Path_Search>.  Alternatively, the command name and appropriate
;    information could be placed in argv[0], or <Path_Search> could be
;    (easily) modified to make no assumptions about where its input is found.
;    Please find enclosed yet another important routine, <Save_Args>, which
;    places the entire arg/argv[]/argbuf structure on a piece of newly
;    allocated memory.	This is handy for for-loop processing, and anything
;    else that wants to save the whole shebang and then process other command
;    lines.
;
; Alan L, OS/MSDOS				    August 15, 1983
;
; ENTRY:
;   <Path_Search>:	    argv[0].
;   <Save_Args>:	    bytes to allocate in addition to arg structure
; EXIT:
;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
;   <Save_Args>:	    success flag, segment address of new memory
; NOTE(S):
;   *	<Argv_calc> handily turns an array index into an absolute pointer.
;	The computation depends on the size of an argv[] element (arg_ele).
;   *	<Parseline> calls <cparse> for chunks of the command line.  <Cparse>
;	does not function as specified; see <Parseline> for more details.
;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
;	need to know about.  This extra information is stored in a switch_flag
;	word with each command-line argument; the switches themselves will not
;	appear in the resulting arg structure.
;   *	With the exception of CARRY, flags are generally preserved across calls.
;---------------
; CONSTANTS:
;---------------
    DEBUGx	equ	    FALSE	; prints out debug info
;---------------
; DATA:
;---------------

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	baddrv_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte
	EXTRN	BADPMES_ptr:word
	EXTRN	curdrv:byte
	EXTRN	EXECPATH:byte
	EXTRN	search_best_buf:byte
	EXTRN	search_error:word
	EXTRN	string_ptr_2:word
	EXTRN	tpbuf:byte
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;

assume cs:trangroup, ds:trangroup, es:trangroup, ss:nothing

break <Path_Search>
;------------------------------------------------------------------------------
;   PATH_SEARCH tries to find the file it's given, somewhere.  An initial value
; of *argv[0].argstartel == 0 implies that there is no command (empty line
; or 'd:'  or 'd:/').  This check is done in strip; otherwise, strip formats
; the filename/pathname into tpbuf.  Search(tpbuf) is executed to see if we
; have a match, either in the current working directory if we were handed
; a filename, or in the specified directory, given a pathname.	If this call
; fails, and we were given a pathname, then Path_Search fails.	Otherwise,
; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
; prefix, we want to skip it) for each pathstring in userpath.	Success on
; either the first invocation of search or on one of the succeeding calls
; sets up the appropriate information for copying the successful pathname
; prefix (if any) into the result buffer, followed by the successful filename
; match (from [search_best_buf]).  The result is returned in in EXECPATH.
; ENTRY:
;   argv[0]		--	command name and associated information
; EXIT:
;   AX			--	non-zero indicates type of file found
;   EXECPATH		--	successful pathname (AX non-zero)
; NOTE(S):
;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
;   2)	Some files are more equal than others.	See search: for rankings.
;   3)	Path_Search terminates as soon as a call to search succeeds, even
;	if search returns an .exe or .bat.
;   5)	Clobbers dma address.

pbuflen 	equ	128		; length of EXECPATH
path_sep_char	equ	';'

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	fbuf:byte
	EXTRN	pathinfo:word
	EXTRN	psep_char:byte
TRANSPACE	ENDS

Procedure   Path_Search,NEAR
	assume	ds:trangroup, es:trangroup

	push	BX
	push	CX
	push	DX				; could use a "stack 'em" instruction
	push	SI
	push	DI
	push	BP
	pushf
	test	DS:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
	jz	path_search_ok

path_failure_jmp:
	jmp	path_failure			; ambiguous commands not allowed

path_search_ok:
	call	store_pchar			; figure out the pathname separator
	mov	DX, OFFSET TRANGROUP:fbuf	; clobber old dma value with
	trap	set_dma 			; a pointer to our dma buffer
	push	ES
	invoke	find_path			; get a handle (ES:DI) on user path
	mov	DS:pathinfo[0], ES		; and squirrel it away
	mov	DS:pathinfo[2], DI		; "old" pathstring pointer
	mov	DS:pathinfo[4], DI		; "new" pathstring pointer
	pop	ES

	mov	BX, pbuflen			; copy/format argv[0] into temp buffer
	mov	SI, OFFSET TRANGROUP:EXECPATH
	invoke	strip
	jc	path_failure_jmp		; if possible, of course

	mov	DX, SI				; search(EXECPATH, error_message)
	mov	[search_error], OFFSET TRANGROUP:BADDRV_ptr
	invoke	search				; must do at least one search
	or	AX, AX				; find anything?
	jz	path_noinit			; failure ... search farther

	mov	BP, AX				; success... save filetype code
	mov	DI, OFFSET TRANGROUP:EXECPATH
	mov	SI, DS:arg.argv[0].argpointer
	mov	CX, DS:arg.argv[0].argstartel
	sub	CX, SI				; compute prefix bytes to copy
;
; We have the number of bytes in the prefix (up to the final component).
; We need to form the complete pathname including leading drive and current
; directory.
;
; Is there a drive letter present?
;

	mov	ah,':'
	cmp	cx,2				; room for drive letter?
	jb	AddDrive			; no, stick it in
	cmp	[si+1],ah			; colon present?
	jz	MoveDrive			; yes, just move it

AddDrive:
	mov	al,curdrv			; get current drive
	add	al,"A"                          ; convert to uppercase letter
	stosw					; store d:
	jmp	short CheckPath

MoveDrive:
	lodsw					; move d:
	stosw
	sub	cx,2				; 2 bytes less to move

CheckPath:
	or	al,20h
	mov	dl,al
	sub	dl,"a"-1                        ; convert to 1-based for current dir
;
; Stick in beginning path char
;
	mov	al,psep_char
	stosb
;
; Is there a leading /?  If so, then no current dir copy is necessary.
; Otherwise, get current dir for DL.
;
	cmp	cx,1				; is there room for path char?
	jb	AddPath 			; no, go add path
	lodsb
	dec	cx
	cmp	al,psep_char			; is there a path separator?
	jz	MovePath			; yes, go move remainder of path
	inc	cx
	dec	si				; undo the lodsb

AddPath:
	SaveReg <SI>
	mov	si,di				; remainder of buffer
	trap	Current_dir
;
; The previous current dir will succeed a previous find_first already worked.
;
; Find end of string.
;
	mov	di,si
	RestoreReg  <SI>
	mov	al,psep_char
	cmp	byte ptr [di],0 		; root (empty dir string)?
	jz	MovePath			; yes, no need for path char

ScanEnd:
	cmp	byte ptr [dI],0 		; end of string?
	jz	FoundEnd
	inc	di
	jmp	ScanEnd
;
; Stick in a trailing path char
;
FoundEnd:
	stosb
;
; Move remaining part of path.	Skip leading path char if present.
;
MovePath:
	cmp	[si],al 			; first char a path char?
	jnz	CopyPath
	inc	si				; move past leading char
	dec	cx				; drop from count

CopyPath:
	jcxz	CopyDone			; no chars to move!
	rep	movsb

CopyDone:
	jmp	path_success			; run off and form complete pathname

path_noinit:
	test	DS:arg.argv[0].argflags, MASK path_sep
	jnz	path_failure			; complete pathname specified ==> fail

	mov	BH, path_sep_char		; semicolon terminates pathstring
	mov	DX, DS:arg.argv[0].argstartel	; this is where the last element starts
	sub	DX, DS:arg.argv[0].argpointer	; form pointer into EXECPATH,
	add	DX, OFFSET TRANGROUP:EXECPATH	; skipping over drive spec, if any

path_loop:
	call	path_crunch			; pcrunch(EXECPATH, pathinfo)
	mov	BP, AX				; save filetype code

	lahf					; save flags, just in case
	or	BP, BP				; did path_crunch find anything?
	jne	path_found
	sahf					; see?	needed those flags, after all!
	jnc	path_loop			; is there anything left to the path?

path_failure:
	xor	AX, AX
;;	jmp	short path_exit 		; 3/3/KK
	jmp	path_exit			;AC000;  3/3/KK

path_found:					; pathinfo[] points to winner
	mov	DI, OFFSET TRANGROUP:EXECPATH
	mov	CX, pathinfo[4] 		; "new" pointer -- end of string
	mov	SI, pathinfo[2] 		; "old" pointer -- beginning of string

;
;	BAS Nov 20/84
;   Look at the pathname and expand . and .. if they are the first element
;   in the pathname (after the drive letter)
;
	push	ES
	push	pathinfo[0]
	pop	ES
;SR;
; Oops! Gets fooled if path= \;..
; We should also check if a drive letter is really present
;
	cmp	Byte Ptr ES:[SI+2],'.'          ; Look for Current dir at start of path
	jnz	path_cpy

	cmp	byte ptr es:[si+1],':'		;does path have drive letter?
	jnz	path_cpy			;no, copy the path string

	push	CX				; Save pointer to end of string
	mov	AL, ES:[SI]
	mov	[DI],AL 			; Copy drive letter, :, and root char
	mov	AL, ES:[SI+1]			; to EXECPATH
	mov	[DI+1],AL
	mov	AL,psep_char
	mov	[DI+2],AL
	push	SI				; Save pointer to begining of string
	mov	DL,ES:[SI]			; Convert device letter for cur dir
	or	DL,20h
	sub	DL,"a"-1
	mov	SI,DI				; pointer to EXECPATH
	add	SI, 3				; Don't wipe out drive and root info
	trap	Current_dir
	invoke	DStrlen 			; Determine length of present info
	add	SI,CX				; Don't copy over drive and root info
	dec	SI
	mov	DI,SI				; Point to end of target string
	pop	SI				; Restore pointer to begining of string
	add	SI, 3				; Point past drive letter, :, .
	pop	CX				; Restore pointer to end of string

path_cpy:
	pop	ES
	sub	CX, SI				; yields character count
	push	DS				; time to switch segments
	push	pathinfo[0]			; string lives in this segment
	pop	DS
	cld
;;	rep	movsb	    3/3/KK		; copy the prefix path into EXECPATH

Kloop:						;AN000;  3/3/KK
	lodsb					;AN000;  3/3/KK
	stosb					;AN000;  3/3/KK
	invoke	testkanj			;AN000;  3/3/KK
	jz	NotKanj1			;AN000;  3/3/KK
	dec	cx				;AN000;  3/3/KK
	JCXZ	PopDone 			;AN000;  Ignore boundary error	 3/3/KK
	movsb					;AN000;  3/3/KK
	dec	cx				;AN000;  3/3/KK
	cmp	cx,1				;AN000;  One char (the terminator) left ? 3/3/KK
	ja	Kloop				;AN000;  no.			 3/3/KK

PopDone:					;AN000;  3/3/KK
	POP	DS				;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
	mov	AL, psep_char			;AN000;       KANJI		  3/3/KK
	jmp	Short path_store		;AN000;  3/3/KK

NotKanj1:
	loop	Kloop
	pop	DS				; return to our segment
	dec	DI				; overwrite terminator
	mov	AL, psep_char			; with a pathname separator
	cmp	al,byte ptr [di-1]
	jz	path_success

path_store:					;AN000;  3/3/KK
	stosb

path_success:
	mov	SI, OFFSET TRANGROUP:search_best_buf
	xor	CX, CX

path_succ_loop:
	lodsb					; append winning filename to path
	stosb					; (including terminating null)
	or	al,al
	jnz	path_succ_loop
	mov	AX, BP				; retrieve filetype code

path_exit:
	popf
	pop	BP
	pop	DI
	pop	SI				; chill out...
	pop	DX
	pop	CX
	pop	BX
	ret
EndProc Path_Search

break <Store_Pchar>
;----------------------------------------------------------------------------
;   STORE_PCHAR determines the pathname-element separator and squirrels
; it away.  In other words, must we say '/bin/ls' or '\bin\ls'?
; ENTRY:
; EXIT:
; NOTE(S):
;   *	Uses <psep_char>, defined in <path_search>.
;---------------
;---------------
Procedure   Store_PChar,NEAR
;---------------
	assume	ds:trangroup, es:trangroup

	push	AX
	mov	AL, '/'                         ; is the pathname-element separator
	invoke	pathchrcmp			; a regular slash?
	jz	store_slash			; if yes, remember slash
	mov	al,'\'
	mov	[psep_char], al 		; otherwise, remember back-slash
	pop	ax
	ret

store_slash:
	mov	[psep_char], al
	pop	ax
	return
;---------------
EndProc Store_Pchar
;----------------------------------------------------------------------------

break <Path_Crunch>
;----------------------------------------------------------------------------
; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
; EXECPATH, and smooshes them into tpbuf.  The caller may supply an
; additional separator to use for breaking up the path-string.	Null is the
; default.  Once the user-string has been formed, search is invoked to see
; what's out there.
; ENTRY:
;   BH			--	additional terminator character
;   SI			--	pointer into pathstring to be dissected
;   DX			--	pointer to stripped filename
; EXIT:
;   AX			--	non-zero (file type), zero (nothing found)
;   SI			--	moves along pathstring from call to call
;   [search_best_buf]	--	name of best file (AX non-zero)
;   [tpbuf]		--	clobbered
; NOTE(S):
;   *	Implicit in this code is the ability to specify when to search
;	the current directory (if at all) through the PATH defined by
;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
;	current directory before the bin and etc directories of drive c).
;---------------
Procedure   Path_Crunch,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	BX
	push	CX
	push	DX
	push	DI
	push	SI
	pushf
	call	store_pchar			; figure out pathname separator
	mov	DI, OFFSET TRANGROUP:tpbuf	; destination of concatenated string
	mov	SI, pathinfo[4] 		; "new" pointer to start with
	mov	pathinfo[2], SI 		; becomes "old" pointer
	push	DS				; save old segment pointer
	push	pathinfo[0]			; replace with pointer to userpath's
	pop	DS				; segment
	xor	cl,cl				;AN000;  clear flag for later use 3/3/KK

path_cr_copy:
	lodsb					; get a pathname byte
	or	al,al				; check for terminator(s)
	jz	path_seg			; null terminates segment & pathstring
	cmp	AL, BH
	jz	path_seg			; BH terminates a pathstring segment
	invoke	testkanj			;AN000;  3/3/KK
	jz	NotKanj2			;AN000;  3/3/KK
	stosb					;AN000;  3/3/KK
	movsb					;AN000;  3/3/KK
	MOV	CL,1				;AN000;  CL=1 means latest stored char is DBCS 3/3/KK
	jmp	path_cr_copy			;AN000;  3/3/KK

NotKanj2:					;AN000;  3/3/KK
	xor	cl,cl				;AN000;  CL=0 means latest stored char is SBCS 3/3/KK
	stosb					; save byte in concat buffer
	jmp	path_cr_copy			; loop until we see a terminator

path_seg:
	pop	DS				; restore old data segment
	mov	pathinfo[4], SI 		; save "new" pointer for next time
	mov	BL, AL				; remember if we saw null or not...
						;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
	xor	AX, AX				; in case nothing in pathstr...
	cmp	DI, OFFSET TRANGROUP:tpbuf	; was there really anything in pathstr?
	je	path_cr_leave			; if nothing was copied, pathstr empty

path_cr_look:					; form complete pathname
	mov	al, psep_char			; add pathname separator for suffix
	or	cl,cl				;AN000;  3/3/KK
	jnz	path_cr_store			;AN000;  this is a trailing byte of ECS code 3/3/KK
	cmp	al,byte ptr [di-1]
	jz	path_cr_l1

path_cr_store:					;AN000;  3/3/KK
	stosb

path_cr_l1:
	mov	SI, DX

path_cr_l2:
	lodsb					; tack the stripped filename onto
	stosb					; the end of the path, up to and
	or	AL, AL				; including the terminating null
	jnz	path_cr_l2
	mov	DX, OFFSET TRANGROUP:tpbuf	; and look for an appropriate file...
	mov	[search_error], OFFSET TRANGROUP:BADPMES_ptr
	invoke	search				; results are in AX & search_best_buf

path_cr_leave:
	or	BL, BL				; did we finish off the pathstring?
	jz	path_cr_empty			; null in BL means all gone...
	popf					; otherwise, plenty left
	clc
	jmp	short path_cr_exit

path_cr_empty:
	popf
	stc

path_cr_exit:
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	ret
;---------------
EndProc Path_Crunch
;----------------------------------------------------------------------------


trancode    ends
END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\rdata.asm ===
page ,132
	title	COMMAND Resident DATA
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;	M003	SR	07/16/90	Added LoadHiFlg for LoadHigh support
;
;	M004	SR	07/17/90	Transient is now moved to its final
;				location at EndInit time by allocating
;				the largest available block, moving 
;				the transient to the top of the block
;				and then freeing up the block.
;
;	M027	SR	9/20/90	Fixed bug #2827. EndInit was using
;				INIT seg variables after INIT seg
;				had been freed.
;
;	M036	SR	11/1/90	Free up environment segment passed
;				by Exec always.
;
;	t-richj		5-20-92 Removed LoadHiFlg

.xlist
.xcref
	include dossym.inc
	include pdb.inc
	include syscall.inc
	include comsw.asm
	include comseg.asm
	include	resmsg.equ
	include comequ.asm
.list
.cref

;	Equates for initialization (from COMEQU)
;
;	Bugbug:  Toss these after putting ctrl-c handler in init module.

INITINIT    equ     01h 		; initialization in progress
INITSPECIAL equ     02h 		; in initialization time/date routine
INITCTRLC   equ     04h 		; already in ^C handler


CODERES segment public byte
	extrn	Ext_Exec:near
	extrn	MsgRetriever:far
	extrn	TRemCheck:near

;SR;
; The stack has no right to be in the code segment. Moved it to DATARES
;
;	bugbug:	Why this odd stack size?  And what should stack size be?
;;	db	(80h - 3) dup (?)
;;RStack	label	word
;;	public	RStack
CODERES ends

INIT	segment

	extrn	ConProc:near
        extrn   AllocedEnv:byte
	extrn	UsedEnv:word
	extrn	OldEnv:word
	extrn	EnvSiz:word
	extrn	TrnSize:word		; M004

INIT	ends

TAIL	segment

	extrn	TranStart	:word

TAIL	ends

TRANCODE	segment public byte
	extrn	Command:near
TRANCODE	ends

TRANSPACE	segment

	extrn	TranSpaceEnd	:byte

TRANSPACE	ends

;SR;
; All the routines below are entry points into the stub from the transient.
;The stub will then transfer control to the appropriate routines in the
;resident code segment, wherever it is present.
;

DATARES	segment

	extrn	Exec_Trap	:near
	extrn	RemCheck_Trap	:near
	extrn	MsgRetrv_Trap	:near
	extrn	HeadFix_Trap	:near
	extrn	Issue_Exec_Call	:near

DATARES	ends


DATARES segment public byte
	assume	cs:DATARES
	Org	0
ZERO	=	$

;;	Org	100h
;;ProgStart:
;;	jmp	RESGROUP:ConProc

	public	Abort_Char
	public	Append_Flag
	public	Append_State
	public	BadFatSubst
	public	Batch
	public	Batch_Abort
	public	BlkDevErrRw
	public	BlkDevErrSubst
	public	Call_Batch_Flag
	public	Call_Flag
	public	CDevAt
	public	CharDevErrSubst
	public	CharDevErrRw
	public	Com_Fcb1
	public	Com_Fcb2
	public	Com_Ptr
	public	ComDrv
	public	ComSpec
	public	ComSpec_End
	public	Crit_Err_Info
	public	Crit_Msg_Off
	public	Crit_Msg_Seg
	public	CritMsgPtrs
	public	DataResEnd
	public	Dbcs_Vector_Addr
	public	DevName
	public	DrvLet
	public	EchoFlag
	public	EnvirSeg
	public	ErrCd_24
	public	ErrType
	public	Exec_block
	public	ExecErrSubst
	public	Extcom
	public	ExtMsgEnd
	public	Fail_Char
	public	fFail
	public	ForFlag
	public	ForPtr
	public	FUCase_Addr
	public	Handle01
	public	IfFlag
	public	Ignore_Char
	public	In_Batch
	public	InitFlag
	public	InPipePtr
	public	Int_2e_Ret
	public	Int2fHandler
	public	Io_Save
	public	LenMsgOrPathBuf
	public	Loading
	public	LTpa
	public	MemSiz
	public	MsgBuffer
	public	MsgPtrLists
	public	MySeg
	public	MySeg1
	public	MySeg2
	public	MySeg3
	public	NeedVol
	public	NeedVolSubst
	public	Nest
	public	Next_Batch
	public	No_Char
	public	NullFlag
	public	NUMEXTMSGS
	public	NUMPARSMSGS
	public	OldErrNo
	public	OldTerm
	public	OutPipePtr
	public	Parent
	public	ParsMsgPtrs
	public	PermCom
        public  SemiPermCom
	public	Pipe1
;;;	public	Pipe1T
	public	Pipe2
;;;	public	Pipe2T
	public	PipeFiles
	public	PipeFlag
	public	PipePtr
	public	PipeStr
	public	PutBackComSpec
	public	PutBackDrv
	public	PutBackSubst
	public	RDirChar
	public	Re_Out_App
	public	Re_OutStr
	public	ResMsgEnd
	public	Res_Tpa
	public	RestDir
	public	ResTest
	public	RetCode
	public	Retry_Char
	public	RSwitChar
	public	SafePathBuffer		; MSKK01 07/14/89
	public	Save_Pdb
	public	SingleCom
	public	Sum
	public	Suppress
	public	Trans
	public	TranVarEnd
	public	TranVars
	public	TrnSeg
	public	TrnMvFlg
	public	VerVal
	public	VolName
	public	VolSer
	public	Yes_Char

	public	ResSize
	public	RStack
	public	OldDS

;	public	LoadHiFlg		;For LoadHigh support ; M003

	extrn	LodCom_Trap:near
	extrn	Alloc_error:near

ifdef ROMDOS

	include	command.loc

ifdef COMMAND_LO

;	COMMAND image is in extended address space.

;	Global Descriptor Table (GDT) for use with int 15h block move

Int15GDT	db	10h dup (0)		; reserved zero
gdtSrcLen	dw	COMMAND_SIZ		; src segment length
gdtSrcLo	dw	COMMAND_LO		; low 16 bits of src address
gdtSrcHi	db	COMMAND_HI		; high 8 bits of src address
		db	93h			; access rights byte
		db	2 dup (0)		; reserved zero
gdtDstLen	dw	COMMAND_SIZ		; dst segment length
gdtDstLo	dw	?			; low 16 bits of dst address
gdtDstHi	db	?			; high 8 bits of dst address
		db	93h			; access rights byte
		db	12h dup (0)		; reserved zero

	public	Int15GDT,gdtSrcLen,gdtSrcLo,gdtSrcHi
	public	gdtDstLen,gdtDstLo,gdtDstHi

endif
endif ; ROMDOS



;***	Message substitution blocks


BlkDevErrSubst	label	byte
BlkDevErrRw	subst	<STRING,>		; "reading" or "writing"
		subst	<CHAR,DATARES:DrvLet>	; block device drive letter

DrvLet		db	'A'			; drive letter


CharDevErrSubst	label	byte
CharDevErrRw	subst	<STRING,>		  ; "reading" or "writing"
CharDevErrDev	subst	<STRING,DATARES:DevName> ; character device name

DevName		db	8 dup (?),0		  ; device name, asciiz


NeedVolSubst	label	byte
		subst	<STRING,DATARES:VolName>	; volume name
		subst	<HEX,DATARES:VolSer+2>		; hi word of serial #
		subst	<HEX,DATARES:VolSer>		; lo word of serial #

;		NOTE:	VolName and VolSer must be adjacent
VolName		db	11 dup (?),0		; volume name
VolSer		dd	0			; volume serial #


CDevAt		db	?


BadFatSubst	label	byte
		subst	<CHAR,DATARES:DrvLet>	; drive letter


PutBackSubst	label	byte
PutBackComSpec	subst	<STRING,>			; comspec string
		subst	<CHAR,DATARES:PutBackDrv>	; drive to put it in

PutBackDrv	db	' '			; drive letter


ExecErrSubst	subst	<STRING,DATARES:SafePathBuffer>


NeedVol		dd	?	; ptr to volume name from get ext err
ErrType 	db	?	; critical error message style, 0=old, 1=new

Int_2e_Ret	dd	?	; magic command executer return address
Save_Pdb	dw	?
Parent		dw	?
OldTerm 	dd	?
ErrCd_24	dw	?
Handle01	dw	?
Loading 	db	0
Batch		dw	0	; assume no batch mode initially

;;;;SR;
;;;; This flag has been added for a gross hack introduced in batch processing. 
;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
;;;;we need to fake the CR-LF for the line to be properly processed
;;;;
;;;BatchEOF		db	0

;		Bugbug:	ComSpec should be 64+3+12+1?
;		What's this comspec_end about?
ComSpec 	db	64 dup (0)
ComSpec_End	dw	?

Trans		label	dword
		dw	TRANGROUP:Command
TrnSeg		dw	?

TrnMvFlg	db	0	; set if transient portion has been moved

In_Batch	db	0	; set if we are in batch processing mode
Batch_Abort	db	0	; set if user wants to abort from batch mode

ComDrv		db	?	; drive spec to load autoexec and command
MemSiz		dw	?
Sum		dw	?
ExtCom		db	1	; for init, pretend just did an external
RetCode 	dw	?
Crit_Err_Info	db	?	; hold critical error flags for r,i,f


; The echo flag needs to be pushed and popped around pipes and batch files.
; We implement this as a bit queue that is shr/shl for push and pop.

EchoFlag	db	00000001b	; low bit true => echo commands
Suppress	db	1		; used for echo, 1=echo line
Io_Save 	dw	?
RestDir 	db	0
PermCom 	db	0		; true => permanent command
SemiPermCom     dw      -1              ; true => semi-permanent command (/K)
SingleCom	dw	0		; true => single command version
VerVal		dw	-1
fFail		db	0		; true => fail all int 24s
IfFlag		db	0		; true => IF statement in progress

ForFlag 	db	0		; true => FOR statement in progress
ForPtr		dw	0

Nest		dw	0		; nested batch file counter
Call_Flag	db	0		; no CALL (batch command) in progress
Call_Batch_Flag db	0
Next_Batch	dw	0		; address of next batch segment
NullFlag	db	0		; flag if no command on command line
FUCase_Addr	db	5 dup (0)	; buffer for file ucase address
; Bugbug: don't need crit_msg_ anymore?
Crit_Msg_Off	dw	0		; saved critical error message offset
Crit_Msg_Seg	dw	0		; saved critical error message segment
Dbcs_Vector_Addr dw	0		; DBCS vector offset
		 dw	0		; DBCS vector segment

Append_State	dw	0		; current state of append
					;  (if Append_Flag is set)
Append_Flag	db	0		; set if append state is valid

Re_Out_App	db	0
Re_OutStr	db	64+3+13 dup (?)


; We flag the state of COMMAND in order to correctly handle the ^Cs at
; various times.  Here is the breakdown:
;
;   INITINIT	We are in the init code.
;   INITSPECIAL We are in the date/time prompt
;   INITCTRLC	We are handling a ^C already.
;
; If we get a ^C in the initialization but not in the date/time prompt, we
; ignore the ^C.  This is so the system calls work on nested commands.
;
; If we are in the date/time prompt at initialization, we stuff the user's
; input buffer with a CR to pretend an empty response.
;
; If we are already handling a ^C, we set the carry bit and return to the user
; (ourselves).	We can then detect the carry set and properly retry the
; operation.

InitFlag	db	INITINIT

; Note:  these two bytes are referenced as a word
PipeFlag	db	0
PipeFiles	db	0

;--- 2.x data for piping
;
; All the "_" are substituted later, the one before the : is substituted
; by the current drive, and the others by the CreateTemp call with the
; unique file name. Note that the first 0 is the first char of the pipe
; name. -MU
;
;--- Order-dependent, do not change

;;;Pipe1		db	"_:/"
;;;Pipe1T		db	0
;;;		db	"_______.___",0
;;;Pipe2		db	"_:/"
;;;Pipe2T		db	0
;;;		db	"_______.___",0

;SR
; Pipe1 & Pipe2 now need to store full-fledged pathnames
;

; Bugbug:  can we find any way around maintaining these
; large buffers?

Pipe1		db	67+12 dup (?)
Pipe2		db	67+12 dup (?)

PipePtr 	dw	?

PipeStr 	db	129 dup (?)

EndPipe	label	byte			; marks end of buffers; M004

;SR;
; We can move our EndInit code into above buffers. This way, the code will
;automatically be discarded after init.
;
; M004; We overlap our code with the Pipe buffers located above by changing
; M004; the origin.
;
	ORG	Pipe1			; M004

; Bugbug:  really need a procedure header for EndInit, describing
; what it expects, what it does.

Public	EndInit
EndInit:
	push	ds
	push	es			;save segments
	push	cs
	pop	ds		
	assume	ds:RESGROUP

;
; M004; Save size of transient here before INIT segment is deallocated
;
	mov	dx,TrnSize		; M004
;M027
; These variables are also defined in the INIT segment and need to be saved
;before we resize
;
	mov	ax,OldEnv		; Old Environment seg ;M027
	mov	bx,EnvSiz		; Size of new environment ;M027
	mov	cx,UsedEnv		; Size of old environment ;M027
	push	ax			; Save all these values ;M027
	push	bx			; M027
	push	cx			; M027


; Bugbug:  push ds, pop es here.
	mov	bx,ds
	mov	es,bx			;es = RESGROUP
;
;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
; code + data for low COMMAND
;
	mov	bx,ResSize		;Total size of resident
	mov	ah,SETBLOCK
	int	21h			;Set block to resident size
;
;We check if this is for autoexec.bat (PermCom = 1). If so, we then
;allocate a new batch segment, copy the old one into new batchseg and free
;the old batchseg. Remember that the old batchseg was allocated on top of the
;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
;
; Bugbug:  also describe why we alloc & copy batch seg BEFORE environment.
	cmp	PermCom,1 		;permanent command.com?
	jne	adjust_env		;no, do not free batchseg

	cmp	Batch,0   		;was there a valid batchseg?
	je	adjust_env		;no, dont juggle

	mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16 ;batchseg size
	mov	ah,ALLOC
	int	21h
; Bugbug:  I just had a thought.  If DOS or SHARE or somebody leaves
; a hole, the batch segment COULD already be in the ideal place.  We
; could be making it worse!  We're second-guessing where memory
; allocations go, which might not be such a great idea.  Is there
; a strategy, short of doing something even worse like diddling
; arena headers, where we can minimize the possibility of fragmentation
; under all cases?  Hmm..
	jc	adjust_env		;no memory, use old batchseg
	mov	es,ax			;es = New batch segment
	xor	di,di
	xor	si,si

	push	ds
	mov	ds,Batch		;ds = Old Batch Segment
	assume	ds:nothing
	mov	cx,SIZE BatchSegment
	add	cx,16			;for the filename
	; Bugbug: 16?  Shouldn't this be a common equate or something?
	; It's sure be bad if we copied more bytes than the batch segment
	; holds!
	cld
	rep	movsb
	pop	ds
	assume	ds:RESGROUP

	mov	cx,es			;save new batch segment 
	mov	es,Batch
	mov	ah,DEALLOC
	int	21h			;free the old batch segment
	; Bugbug:  should we check for error?

	mov	Batch,cx		;store new batch segment address

adjust_env:
	pop	cx			;cx = size of old env ;M027
	pop	bx			;bx = size of new env needed ;M027
	pop	bp			;bp = old env seg ;M027
;
;Allocate the correct size for the environment
;

	mov	ah,ALLOC
	int	21h			;get memory
	jc	nomem_err		;out of memory,signal error
	; Bugbug:  why not continue, leaving environment where it is?

	mov	EnvirSeg,ax		;Store new environment segment
	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
	mov	es,ax			;es = address of allocated memory
	assume	es:nothing

;
;Copy the environment to the newly allocated segment
;
	push	ds
	mov	ds,bp			;ds = Old environment segment
	assume	ds:nothing

	xor	si,si
	mov	di,si			;Start transfer from 0

	cld
	rep	movsb			;Do the copy

	pop	ds			;ds = RESGROUP
	assume	ds:RESGROUP
;
; We have to free the old environment block if it was allocated by INIT
;
; Bugbug:  is this only for the case when we were NOT passed an environment,
; or does it also apply to passed environments?
;
;M036
; Free up old env segment always because this is a copy passed by Exec and
; takes up memory that is never used
;
;M044
; Go back to the old strategy of not freeing the environment. Freeing it leaves
; a hole behind that Ventura does not like. Basically, Ventura gives strange
; errors if it gets a memory alloc that it is below its load segment. The
; freed environment creates a large enough hole for some of its allocs to fit
; in
;
        cmp     AllocedEnv,0            ;has env been allocated by INIT?
        je      no_free                 ;no, do not free it

	mov	es,bp
	mov	ah,DEALLOC	
	int	21h			;Free it
no_free:

;
; M004; Start of changes 
;

;
; Move the transient now. We will allocate the biggest block available
; now and move the transient to the top of the block. We will then
; deallocate this block. When the resident starts executing, it will
; hopefully allocate this block again and find the transient intact.
;
	MOV	TrnMvFlg, 1			; Indicate that transient has been moved
	push	es
	mov	si,offset ResGroup:TranStart
	mov	di,0
	mov	cx,offset TranGroup:TranSpaceEnd ;size to move
;
; Find the largest block available
;
	mov	bx,0ffffh
	mov	ah,ALLOC
	int	21h

;
; dx = size of transient saved previously 
;
	cmp	bx,dx			;enough memory?
	jb	nomem_err		;not enough memory for transient

	mov	ah,ALLOC
	int	21h			;get the largest block
	jc	nomem_err		;something is really screwed up

	push	ax			;save memory address
	add	ax,bx			;ax = top of my memory block
	sub	ax,dx			;less size of transient
	mov	TrnSeg,ax		;save transient segment
	mov	es,ax			;
	pop	ax			;restore our seg addr

;
; Everything is set for a move. We need to move in the reverse direction to
; make sure we dont overwrite ourselves while copying
;
	add	si,cx
	dec	si
	add	di,cx
	dec	di
	std
	rep	movsb
	cld
;
; Now we have to free up this block so that resident can get hold of it
;
	mov	es,ax
	mov	ah,DEALLOC
	int	21h			;release the memory block

;
; M004; End of changes
;

	mov	InitFlag,FALSE		;indicate INIT is done
	
	pop	es
	pop	ds
	; Bugbug:  did we need to save & restore seg reg's during EndInit?
	assume	ds:nothing
	
	jmp	LodCom_Trap		;allocate transient

nomem_err:
;
;We call the error routine which will never return. It will either exit
;with an error ( if not the first COMMAND ) or just hang after an error 
;message ( if first COMMAND )
;

	jmp	Alloc_error

public EndCodeInit			; M004
EndCodeInit	label	byte		; M004

;
; M004; Check if the EndInit code will fit into the Pipe buffers above.
; M004; If not, we signal an assembly error
;
IF2
	IF ($ GT EndPipe)
		.err
		%out	"ENDINIT CODE TOO BIG"
	ENDIF
ENDIF
;
; M004; Set the origin back to what it was at the end of the buffers
;
		ORG	EndPipe		; M004



InPipePtr	dw	offset DATARES:Pipe1
OutPipePtr	dw	offset DATARES:Pipe2

Exec_Block	label	byte		; the data block for exec calls
EnvirSeg        dw      ?
Com_Ptr 	label	dword
		dw	80h		; point at unformatted parameters
		dw	?
Com_Fcb1	label	dword
		dw	5Ch
		dw	?
Com_Fcb2	label	dword
		dw	6Ch
		dw	?

;		variables passed to transient
TranVars	label	byte			
		dw	offset DATARES:HeadFix_Trap
MySeg		dw	0		; put our own segment here
LTpa		dw	0		; will store tpa segment here
RSwitChar	db	"/"
RDirChar	db	"\"
		dw	offset DATARES:Issue_Exec_Call
MySeg1		dw	?
		dw	offset DATARES:RemCheck_Trap
MySeg2		dw	0
ResTest 	dw	0
Res_Tpa 	dw	0		; original tpa (not rounded to 64k)
TranVarEnd	label	byte

OldErrNo	dw	?


;*		NOTE:  MsgBuffer and SafePathBuffer use the same
;		memory.  MsgBuffer is only used while a command
;		is being executed.  SafePathBuffer is no longer
;		needed, since it is used for unsuccessful program
;		launches.

MsgBuffer	label	byte		; buffer for messages from disk
SafePathBuffer	label	byte		; resident pathname for EXEC
;		Bugbug:	Why so big a buffer?
		db	64+3+13 dup (0)	; path + 'd:\' 'file.ext' + null
LenMsgOrPathBuf	equ	$ - MsgBuffer


Int2fHandler	dd	?	; address of next int 2f handler
ResMsgEnd	dw	0	; holds offset of msg end (end of resident)

;SR;
; The three vars below have been added for a pure COMMAND.COM
;

ResSize		dw	?

;SR;
; Moved the stack here from the code segment
;
;	bugbug:	Why this odd stack size?  And what should stack size be?
	db	(80h - 3) dup (?)
RStack	label	word

OldDS		dw	?	;keeps old ds value when jumping to
				;resident code segments

;LoadHiFlg	db	0	;Flag set to 1 if UMB loading enabled ; M003

ifdef	BETA3WARN
	%out	Take this out before we ship
public	Beta3Warned
Beta3Warned	db	0
endif

;
; -----------------------------------------------------------------------------
;
include highvar.inc		;Add variables for 6.0 loadhigh functionality
;
; -----------------------------------------------------------------------------
;

;***	MESSAGES
;	and other translatable text

	include	comrmsg.inc	;M00

DATARES ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\romldr.asm ===
page	,132
	title	ROM COMMAND Image Loader

comment	%

LoadFromROM loads all or any piece of the ROM COMMAND image into RAM.

This source module, along with romhead.asm and romres.asm, are OEM
replaceable, depending on what kind of ROM storage and layouts
are used.  The supplied routines handle ROM images in the first
Mbyte of address space as well as transient images loaded from
extended address space ROM.  The correct routines are selected
at build time by the symbols defined in command.loc and rescom.loc.  
name_SEG implies that 'name' will reside within the first Mbyte.
name_LO or name_HI implies that 'name' will reside in extended
address space.  Location files (*.loc) are generated during the
build and depend on sizes of code granules as well as the ROM
image description file (in romimg directory).

If other storage options are used, the OEM will replace loader
routines with code that fetches or locates code in the storage
actually used.  If the storage option uses a linear address space
(such as port-accessed ROM), the name_LO/name_HI location symbols may
still be used (ROMnTYPE=BASE in the ROM image description file). 
Otherwise, the loader may ignore the location files, and be
hard-coded to retrieve the desired code.

LoadFromROM is normally part of the resident code segment.  If banked
ROM's are used such that the resident code will be switched out when
copying from the ROM COMMAND image, this routine should be moved to
the resident data segment.  To do this, change CODERES to DATARES
and, in rom.lnk, move romldr.obj to between stub.obj and rdata.obj. 
Then uncomment the dword pointer at the end of this module and the
code in init.asm that initializes LoadFromROM_seg. Finally, rename
the procedure itself LoadFromROM_Proc and make it FAR.  Make sure
that any references to LoadFromROM reference it as a dword extrn and
have a segment register pointing at DATARES.  Note that all calls to
LoadFromROM are from resident code.

%



;***	CONSTANTS

	include	command.loc		; location of ROM COMMAND image
	include	comseg.asm		; all COMMAND segment definitions




;***	DATA

ifdef COMMAND_LO

;	ROM COMMAND image is in extended address space
;	We'll need access to our GDT in DATARES.

DATARES segment public byte		; resident data

	extrn	Int15GDT:byte,gdtSrcLen:word,gdtSrcLo:word,gdtSrcHi:byte
	extrn	gdtDstLen:word,gdtDstLo:word,gdtDstHi:byte

DATARES ends

endif ; COMMAND_LO




;***	CODE

CODERES	segment public byte

	public	LoadFromROM

	assume	cs:CODERES,ds:DATARES,es:NOTHING,ss:NOTHING




;***	LoadFromROM - load all or any piece of ROM COMMAND image into RAM
;
;	ENTRY	SI = offset into image
;		CX = number bytes to load
;		ES:DI = ptr to destination buffer
;		DS = DATARES seg addr
;
;	EXIT	nothing
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS -
;
;	CX bytes are copied from SI offset in image to buffer at ES:DI.
;	Caller's stack is used.
;
;	NOTES -
;
;	We assume enough room in the destination segment above ES:DI.
;	ES:DI is not normalized.

LoadFromROM	proc

ifdef COMMAND_SEG

;	ROM COMMAND image is below 1M.  Easy street.

	push	ds			; preserve DS

	mov	ax,COMMAND_SEG
	mov	ds,ax			; DS:SI = ptr into image

	cld
	rep	movsb

	pop	ds
	ret

else
ifdef COMMAND_LO

;	ROM COMMAND image is in extended address space.
;	Copy it via int 15h block move.

	push	bx			; preserve registers
	push	dx

	mov	gdtSrcLen,cx		; set segment lengths
	mov	gdtDstLen,cx

;	Compute 24-bit linear source address from SI and image address.

	mov	ax,COMMAND_LO		; AX = lo 16 bits of image address
	add	ax,si			; AX = lo 16 bits of source address
					; Preserve CY!
	mov	gdtSrcLo,ax
	mov	al,COMMAND_HI
	adc	al,0			; AL = hi 8 bits of source address
	mov	gdtSrcHi,al

;	Compute 24-bit linear destination address from ES:DI.

	mov	ax,es
	mov	bx,10h
	mul	bx			; DX:AX contains linear equiv of ES
	add	ax,di
	adc	dx,0			; DX:AX contains linear equiv of ES:DI
	mov	gdtDstLo,ax		; store 24-bit dest addr
	mov	gdtDstHi,dl

	mov	si,offset DATARES:Int15GDT
	push	es			; preserve ES
	push	ds
	pop	es			; ES:DI = ptr to GDT

	add	cx,1
	shr	cx,1			; CX = # words to xfr
	mov	ah,87h			; AH = 'Move Extended Memory Block'
	int	15h			; call I/O subsystem extensions
	pop	es			; restore ES
	jnc	moved			; it worked

;	Block move failed.

;	Need to issue "Cannot access ROM COMMAND" message.

moved:
	pop	dx			; restore some registers
	pop	bx
	ret

endif
endif

LoadFromROM	endp




;;;***	Far Call Vectors (in resident data segment)
;;
;;LoadFromROM	label	dword
;;		dw	LoadFromROM_Proc
;;LoadFromROM_seg	dw	?


CODERES ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\romres.asm ===
page	,132
	title	Find ROM Resident Code

comment %

FindROMRes locates COMMAND's ROM-resident code during initialization.

The supplied code handles the cases

  o  complete COMMAND image below 1 MB

  o  COMMAND resident code below 1 MB, rest of image somewhere else

The cases are identified by the symbols defined in romimg\command.loc.

%



;***	CONSTANTS

	include	command.loc		; location of ROM COMMAND image




;***	EXTERNALS

	.xlist
	include	comseg.asm		; COMMAND segment definitions
	.list

CODERES	segment

	extrn	StartCode:byte		; beginning of resident code

CODERES	ends




;***	CODE

INIT	segment public para	; initialization code

	public	FindROMRes

	assume	cs:RESGROUP




;***	FindROMRes - locate resident code
;
;	ENTRY	nothing
;
;	EXIT	ES:DI = ptr to resident code
;
;	USES	AX

FindROMRes	proc

ifdef COMMAND_SEG

;	ROM COMMAND image is below 1M, locate resident within image

	mov	ax,COMMAND_SEG
	mov	es,ax
	mov	di,offset RESGROUP:StartCode-100h
	ret

else

;	ROM COMMAND image isn't directly addressable.
;	Resident COMMAND code must be in its own granule.

	include	rescom.loc

	mov	ax,RESCOM_SEG
	mov	es,ax
	xor	di,di
	ret

endif

FindROMRes	endp


INIT	ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\rucode.asm ===
page ,132
	title	Localizable code for resident COMMAND
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;	M003	SR	07/16/90	Added routines Lh_Off, Lh_Unlink &
;				Lh_OffUnlink for UMB support
;
;	M009	SR	08/01/90	Rewrote Lh_OffUnlink to restore the
;				initial UMB state. Removed Lh_off
;				and Lh_Unlink.
;

.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include filemode.inc
	include pdb.inc
	include mult.inc
	include doscntry.inc
	include devsym.inc
	include comsw.asm
	include comseg.asm
	include comequ.asm
	include resmsg.equ
	include	arena.inc		; M003
.list
.cref


DATARES segment public byte
	extrn	Abort_Char:byte
	extrn	BadFatMsg:byte
	extrn	BadFatSubst:byte
	extrn	Batch_Abort:byte
	extrn	BlkDevErr:byte
	extrn	BlkDevErrRw:byte
	extrn	BlkDevErrSubst:byte
	extrn	CDevAt:byte
	extrn	CharDevErr:byte
	extrn	CharDevErrRw:byte
	extrn	CharDevErrSubst:byte
	extrn	ComSpec:byte
	extrn	Crit_Err_Info:byte
	extrn	Crit_Msg_Off:word
	extrn	Crit_Msg_Seg:word
	extrn	CritMsgPtrs:word
	extrn	Dbcs_Vector_Addr:dword
	extrn	DevName:byte
	extrn	DrvLet:byte
	extrn	EndBatMes:byte
	extrn	ErrCd_24:word
	extrn	ErrType:byte
	extrn	Fail_Char:byte
	extrn	fFail:byte
	extrn	ForFlag:byte
	extrn	Ignore_Char:byte
	extrn	InitFlag:byte
	extrn	In_Batch:byte
	extrn	Int2fHandler:dword
	extrn	Loading:byte
	extrn	MsgBuffer:byte
	extrn	MsgPtrLists:dword
	extrn	MRead:byte
	extrn	MWrite:byte
	extrn	NeedVol:dword
	extrn	NeedVolMsg:byte
	extrn	NeedVolSubst:byte
	extrn	Newlin:byte
	extrn	No_Char:byte
	extrn	NUMEXTMSGS:abs
	extrn	NUMPARSMSGS:abs
	extrn	OldErrNo:word
	extrn	Parent:word
	extrn	ParsMsgPtrs:word
	extrn	Patricide:byte
	extrn	PermCom:byte
	extrn	Retry_Char:byte
	extrn	Req_Abort:byte
	extrn	Req_End:byte
	extrn	Req_Fail:byte
	extrn	Req_Ignore:byte
	extrn	Req_Retry:byte
	extrn	ResMsgEnd:word
	extrn	PipeFlag:byte
	extrn	SingleCom:word
	extrn	VolName:byte
	extrn	Yes_Char:byte

	extrn	OldDS:word
	extrn	Int2f_Entry:dword

DATARES ends


CODERES segment public byte

	extrn	GetComDsk2:near

	public	AskEnd
	public	Crlf
	public	DskErr
	public	MsgInt2fHandler
	public	MsgRetriever
	public	RPrint

	ifdef	DBCS
	public	ITestKanj
	endif

;	Bugbug:	Move rest of PUBLIC declarations up here.

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING



;***	AskEnd - ask user to confirm batch file termination
;
;	Confirm with user before freeing batch ...
;
;	ENTRY	nothing
;
;	EXIT	CY = set if batch termination is confirmed
;
;		CY = clear if batch should continue
;
;	USED	AX,DX,...

;	Bugbug:	move this to transient, copy to batch segment.
;	Bugbug:	or move it to command1 1st.

;	Bugbug: No_Char and Yes_Char should be constants.

AskEnd	proc

	assume	ds:DATARES

	mov	dx,offset DATARES:EndBatMes	; DX = message #
	call	RPrint
	mov	ax,(STD_CON_INPUT_FLUSH shl 8) + STD_CON_INPUT
	int	21h
	call	CharToUpper			; change to upper case
	cmp	al,No_Char
	je	aeRet				; answer is no (CY is clear)
	cmp	al,Yes_Char
	jne	AskEnd				; invalid response, try again
	stc					; answer is yes
aeRet:	ret

AskEnd	endp




;***	DskErr - critical error handler
;
;	Default critical error handler unless user intercepts int 24h.
;
;	ENTRY	int 24h
;
;	EXIT
;
;	USED
;
;	EFFECTS

;
;SR; 
; The stub is going to push the old ds value and the resident data segment
;onto the stack in that order. Get it off the stack
;

DskErr	proc	far

	assume	ds:NOTHING,es:NOTHING,ss:NOTHING

	pop	ds			;ds = DATARES
	assume 	ds:DATARES
	pop	OldDS			;save old ds value

	sti
	push	es
	push	si
	push	cx
	push	di
	push	cx
	push	ax

	push	ds			;save our data segment
	pop	es			;es = DATARES

	mov	ds,bp
	assume	ds:nothing

	mov	ax,[si].SDEVATT
	mov	es:CDevAt,ah

;;	push	cs
;;	pop	es

	mov	di,offset DATARES:DevName
	mov	cx,8
	add	si,SDEVNAME	; save device name (even for block device)

	cld
	rep	movsb
	pop	ax
	pop	cx
	pop	di

;	Stack still contains DS and ES.

;SR;
; We need ds = DATARES for SavHand
;
	push	es
	pop	ds
	assume	ds:DATARES

	invoke	SavHand		; save user's stdin/out, set to our stderr

;;	push	cs
;;	pop	ds		; set up local data segment
;;	assume	ds:resgroup

	push	dx
	call	Crlf
	pop	dx

;	Bugbug:	rename Crit_Err_Info to CritErrAH?

	mov	Crit_Err_Info,ah	; save critical error flags

;	Compute and save ASCII drive letter (nonsense for char devices)

	add	al,'A'
	mov	DrvLet,al

;	Bugbug:	These labels are awful.  Change, especially 'NoHardE'.

	test	ah,80h
	jz	NoHardE			; it's a disk-device error
	test	CDevAt,DEVTYP shr 8
	jnz	NoHardE			; it's a character device
	jmp	FatErr			; it's a FAT error

NoHardE:
	mov	si,offset DATARES:MRead  ; SI = "read" msg #
	test	ah,1
	jz	SavMes			  ; it's a read error
	mov	si,offset DATARES:MWrite ; SI = "write" msg #

SavMes:
	mov	OldErrNo,di		; save critical error code

;	Bugbug:	don't need to save/restore all here?
	push	es
	push	ds			; GetExtendedError likes to STOMP
	push	bp
	push	si
	push	dx
	push	cx
	push	bx
	mov	ah,GetExtendedError	; get extended error info
	int	21h
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	bp
	pop	ds
	mov	word ptr NeedVol,di 	; save possible ptr to volume label
	mov	word ptr NeedVol+2,es
	pop	es

;	Bugbug:	AX has extended error code, so no need to zero AH?

	xor	ah,ah
	mov	di,ax			; DI = error code

; Bugbug:  somewhat obsolete documentation?
;
; DI is now the correct error code.  Classify things to see what we are
; allowed to report.  We convert DI into a 0-based index into a message table.
; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
; the like) are contiguous.
;

;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
;	Check use of ErrCd_24, though.

	sub	di,ERROR_WRITE_PROTECT
	jae	HavCod

;	Bugbug	wouldn't it be better to display the original error msg,
;	even though it's not a critical error?

	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT
;
; DI now has the mapped error code.  Old style errors are:
;   FOOBAR <read|writ>ing drive ZZ.
; New style errors are:
;   FOOBAR
; We need to figure out which the particular error belongs to.
;

HavCod:
	mov	ErrType,0		; assume old style
	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT
	je	SetStyle
	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT
	jne	GotStyle

SetStyle:
;	Bugbug:	use INC
	mov	ErrType,1		; must be new type

GotStyle:
	mov	[ErrCd_24],di
	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT
						; If the error message is unknown
	jbe	NormalError			;  redirector, continue.  Otherwise,
;
; We do not know how to handle this error.  Ask IFSFUNC if she knows
; how to handle things
;

;input to IFSFUNC:    AL=1
;		      BX=extended error number
;
;output from IFSFUNC: AL=error type (0 or 1)
;			 0=<message> error (read/writ)ing (drive/device) xxx
;			   Abort, Retry, Ignore
;			 1=<message>
;			   Abort, Retry, Ignore
;		      ES:DI=pointer to message text
;		      carry set=>no message

	mov	di,ax			; retrieve correct extended error...
	mov	ax,0500h		; is the redir there?
	int	2fh
	cmp	al,0ffh
	jne	NoHandler		; no, go to NoHandler
	push	bx
	mov	bx,di			; get ErrType and ptr to error msg
	mov	ax,0501h
	int	2fh
	pop	bx 
	jc	NoHandler

;	Bugbug:	need to record error type?
	mov	ErrType,al
	push	ds
	push	es
	pop	ds
	mov	dx,di
	mov	cx,-1			; find end of msg
	xor	al,al

	cld
	repnz	scasb

;	Bugbug:	we can do better than this.

	mov	byte ptr [di-1],'$'
	mov	ah,STD_CON_STRING_OUTPUT	; print the message
	int	21h
	mov	byte ptr [di-1],0		; restore terminal byte

	pop	ds				; clean up and continue
	jmp	short CheckErrType

;*	Redir isn't available or doesn't recognize the error.
;	Restore regs to unextended error.

NoHandler:
	mov	ErrType,0
;	Bugbug:	won't this break, since we add error_write_protect back in?
	mov	di,OldErrNo
	mov	ErrCd_24,di

NormalError:
	add	di,ERROR_WRITE_PROTECT
	xchg	di,dx			; may need dx later
	call	RPrintCrit		; print error type

CheckErrType:
	cmp	ErrType,0		; Check error style...
	je	ContOld
	call	CrLf			; if new style then done printing
	jmp	short Ask

ContOld:
	inc	si			; DS:SI = ptr to asciiz string

;	Bugbug:	combine some of the following two sections?

	test	[CDevAt],DEVTYP shr 8
	jz	BlkErr
	mov	dx,offset DATARES:CharDevErr	  ; DX = ptr to device message
	mov	CharDevErrRw.SubstPtr,si	  ; point to read/write string
	mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block

	call	RPrint				; print the message
	jmp	short Ask			; don't ralph on command

BlkErr:
	mov	dx,offset DATARES:BlkDevErr	  ; DX = error msg #
	mov	BlkDevErrRw.SubstPtr,si		  ; "reading","writing" ptr
	mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
	call	RPrint

	cmp	Loading,0
	jz	Ask
	invoke	RestHand
	jmp	GetComDsk2		; if error loading COMMAND, re-prompt

Ask:
	cmp	[ErrCd_24],15		; error 15 has an extra message
	jne	Not15			; not error 15

;*	For error 15, tell the user which volume/serial # are needed.

	push	cx

;	Bugbug:	does this push/pop need to be done?
	push	ds
	pop	es
	lds	si,NeedVol
	assume	ds:NOTHING
	push	di
	mov	di,offset DATARES:VolName
	mov	cx,16			; copy volume name & serial #
	cld
	rep	movsb
	pop	di
	push	es
	pop	ds
	pop	cx
	assume	ds:DATARES
	mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
	mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
	call	RPrint
Not15:

;*	Print abort, retry, ignore, fail message.
;	Print only options that are valid.

;	Bugbug:	sizzle this.

	mov	dx,offset DATARES:Req_Abort
	call	RPrint
	test	Crit_Err_Info,RETRY_ALLOWED
	jz	Try_Ignore
	mov	dx,offset DATARES:Req_Retry
	call	RPrint

Try_Ignore:
	test	Crit_Err_Info,IGNORE_ALLOWED
	jz	Try_Fail
	mov	dx,offset DATARES:Req_Ignore
	call	RPrint

Try_Fail:
	test	Crit_Err_Info,FAIL_ALLOWED
	jz	Term_Question
	mov	dx,offset DATARES:Req_Fail
	call	RPrint

Term_Question:
	mov	dx,offset DATARES:Req_End
	call	RPrint

;	If the /f switch was given, we fail all requests.

	test	fFail,-1
	jz	DoPrompt
	mov	ah,3				; signal fail
	jmp	EExit

DoPrompt:
	mov	ax,(STD_CON_INPUT_FLUSH shl 8) + STD_CON_INPUT
	int	21h				; get response


;	Bugbug:	can Kanji code be conditional?

	ifdef	DBCS

	invoke	TestKanjR			; 3/3/KK
	jz	NotKanj 			; 3/3/KK
	mov	ax,(STD_CON_INPUT shl 8)	; eat the 2nd byte of ECS code  3/3/KK
	int	21h				; 3/3/KK
	call	Crlf				; 3/3/KK
	jmp	Ask				; 3/3/KK
NotKanj:					; 3/3/KK

	endif

	call	Crlf
	call	CharToUpper			; convert to upper case
	mov	ah,0				; return code for ignore
	test	Crit_Err_Info,IGNORE_ALLOWED	; is ignore allowed?
	jz	user_retry
	cmp	al,Ignore_Char			; ignore?
	jz	EExitJ

;	Bugbug:	optimize following code.

User_Retry:
	inc	ah				; return code for retry
	test	Crit_Err_Info,RETRY_ALLOWED	; is retry allowed?
	jz	User_Abort
	cmp	al,Retry_Char			; retry?
	jz	EExitJ

User_Abort:
	inc	ah				; return code for abort
						;  (abort always allowed)
	cmp	al,Abort_Char			; abort?
	jz	Abort_Process			; exit user program
	inc	ah				; return code for fail
	test	Crit_Err_Info,FAIL_ALLOWED	; is fail allowed?
	jz	AskJ
	cmp	al,Fail_Char			; fail?
	jz	EExitJ

AskJ:
	jmp	Ask

EExitJ:
	jmp short EExit

Abort_Process:
	test	InitFlag,INITINIT		; COMMAND init interrupted?
	jz	AbortCont			; no, handle it normally
	cmp	PermCom,0			; are we top level process?
	jz	JustExit			; yes, just exit

IFDEF	ROMDOS
	test	Crit_Err_Info,FAIL_ALLOWED
	jz	No_Hope
	mov	ah, 3
	jmp	short EExit
No_Hope:
ENDIF
	mov	dx,offset DATARES:Patricide	; no, load ptr to error msg
	call	RPrint				; print it

DeadInTheWater:
	jmp	DeadInTheWater			; loop until the user reboots

JustExit:
	assume	ds:DATARES
	mov	ax,Parent			; load real parent pid
	mov	word ptr ds:Pdb_Parent_Pid,ax 	; put it back where it belongs
	mov	ax,(EXIT shl 8) or 255
	int	21h

AbortCont:
	test	byte ptr In_Batch,-1	; Are we accessing a batch file?
	jz	Not_Batch_Abort
	mov	byte ptr Batch_Abort,1	; set flag for abort

Not_Batch_Abort:
	mov	dl,PipeFlag
	invoke	ResPipeOff
	or	dl,dl
	je	CheckForA
	cmp	SingleCom,0
	je	CheckForA
	mov	SingleCom,-1			; make sure singlecom exits

CheckForA:
	cmp	ErrCd_24,0			; write protect?
	je	AbortFor
	cmp	ErrCd_24,2			; drive not ready?
	jne	EExit				; don't abort the FOR

abortfor:
	mov	ForFlag,0			; abort a FOR in progress
	cmp	SingleCom,0
	je	EExit
	mov	SingleCom,-1			; make sure singlecom exits

EExit:
	mov	al,ah
	mov	dx,di

RestHd:
	invoke	RestHand
	pop	cx
	pop	si				; restore registers
	pop	es

;;	pop	ds
;SR;
; ds has to be got from the variable we saved it in
;

 	mov	ds,OldDS			;restore old value of ds
;	pop	ds
	assume	ds:nothing

	iret

FatErr:
	mov	dx,offset DATARES:BadFatMsg
	mov	si,offset DATARES:BadFatSubst
	call	RPrint

	mov	al,2				; abort
	jmp	RestHd

DskErr	endp




;***	RPrint - print message
;***	Crlf - display cr/lf
;
;	ENTRY	DS:DX = ptr to count byte, followed by message text
;		DS:SI = ptr to 1st substitution block for this msg, if any
;		variable fields related to substitution blocks are set
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Message is displayed on stdout.
;
;	NOTE
;	  Number of substitutions (%1, %2,...) in message text must not
;	    be greater than number of substition blocks present.


Crlf: 
	mov	dx,offset DATARES:Newlin	; cheap newline

RPrint	proc

	assume	ds:DATARES,ss:DATARES

;	Bugbug:	do we need to save all reg's?

	push	si			; preserve registers
	push	ax
	push	bx
	push	cx
	push	dx

	mov	bx,si			; DS:BX = ptr to subst block
	mov	si,dx			; DS:SI = ptr to count byte
	lodsb				; AL = message length
					; DS:SI = ptr to message text
	xor	cx,cx
	mov	cl,al			; CX = message length
	jcxz	rpRet

	call	RDispMsg

rpRet:	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	si
	ret

RPrint	endp




;***	RPrintCrit - print critical error message
;
;	ENTRY	DX = extended error # (19-39)
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Message is displayed on stdout

RPrintCrit	proc

	assume	ds:DATARES,ss:DATARES

	push	dx			; preserve DX
	xchg	bx,dx			; BX = extended error #
					; DX = saved BX
	sub	bx,19			; BX = critical error index, from 0
	shl	bx,1			; BX = offset in word table
	mov	bx,CritMsgPtrs[bx]	; BX = ptr to error msg
	xchg	bx,dx			; DX = ptr to error msg
					; BX = restored
	call	RPrint			; print the message
	pop	dx			; restore DX
	ret

RPrintCrit	endp




;***	RDispMsg - display message
;
;	Display message, with substitutions, for RPrint.
;
;	ENTRY	DS:SI = ptr to message text
;		CX = message length
;		DS:BX = ptr to substitution block, if any
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI

RDispMsg	proc

	assume	ds:DATARES,ss:DATARES

rdNextChar:
	lodsb				; AL = next char
	cmp	al,'%'
	jne	rdOutChar		; not a substitution
	mov	dl,ds:[si]		; DL = possible '1' - '9'
	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
	cmp	dl,9
	jae	rdOutChar		; not a substitution

;*	A substitution code %1 - %9 has been encountered.
;	DL = 0-8, indicating %1-%9
;	DS:BX = ptr to substitution block

	call	SubstMsg		; display the substitution
	inc	si			; SI = ptr past %n
	dec	cx			; count extra character in %n
	jmp	short rdCharDone

;*	Normal character output.

rdOutChar:
	mov	dl,al			; DL = char
	mov	ah,2			; AH = DOS Character Output code
	int	21h			; call DOS
rdCharDone:
	loop	rdNextChar
	ret

RDispMsg	endp




;***	SubstMsg - display message substitution
;
;	Display a substitution string within a message.
;	Substitution can be a char, an ASCIIZ string, or
;	a word to be displayed as hex digits.
;
;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
;		DS:BX = ptr to substitution block
;
;	EXIT	nothing
;
;	USED	AX,DX

SubstMsg	proc

	assume	ds:DATARES,ss:DATARES

	push	bx			; preserve BX
	push	cx			; preserve CX

	mov	al,size SUBST		; AL = size of substitution block
	mul	dl			; AX = offset of desired subst block
	add	bx,ax			; DS:BX = ptr to desired subst block

	mov	al,[bx].SubstType	; AX = substitution type flag
	mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value

;	AL = 1, 2, or 3 for char, string, or hex type

	dec	al
	jz	smChar
	dec	al
	jz	smStr

;*	Hex number substitution.

	mov	ax,ds:[bx]		; AX = word value
	mov	cx,4			; CX = # digits to display
smDigit:
	rol	ax,1
	rol	ax,1
	rol	ax,1
	rol	ax,1			; AL<3:0> = next digit

	push	ax			; save other digits
	and	al,0Fh			; AL = binary digit
	add	al,'0'			; AL = ascii digit if 0-9
	cmp	al,'9'
	jbe	@F			; it's 0-9
	add	al,'A' - '0' - 10	; AL = ascii digit A-F
@@:
	mov	dl,al			; DL = ascii digit
	mov	ah,2
	int	21h			; output the ascii digit
	pop	ax			; restore all digits

	loop	smDigit
	jmp	short smRet

;*	Char substitution.

smChar:
	mov	dl,ds:[bx]		; DL = char to output
	mov	ah,2
	int	21h
	jmp	short smRet

;*	String substitution.

smStr:
	mov	dl,ds:[bx]		; DL = next char
	or	dl,dl
	jz	smRet			; null char - we're done
	mov	ah,2
	int	21h			; display char
	inc	bx			; DS:BX = ptr to next char
	jmp	smStr

smRet:	pop	cx
	pop	bx
	ret

SubstMsg	endp




;***	CharToUpper - convert character to uppercase
;
;	ENTRY	AL = char
;
;	EXIT	AL = uppercase char
;
;	USED	AX

CharToUpper	proc

	assume	ds:DATARES

	push	ax		; put char on stack as arg to int 2F
	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
	int	2Fh
	inc	sp		; throw away old char on stack
	inc	sp
	ret

CharToUpper	endp





	ifdef	DBCS

;***	ITestKanj - DBCS lead byte check

ITestKanj:
TestKanjR:				; 3/3/KK
	push	ds
	push	si
	push	ax
	lds	si,Dbcs_Vector_Addr

ktLop:
	cmp	word ptr ds:[si],0	; end of Lead Byte Table
	je	NotLead
	pop	ax
	push	ax
	cmp	al, byte ptr ds:[si]
	jb	NotLead
	inc	si
	cmp	al, byte ptr ds:[si]
	jbe	IsLead
	inc	si
	jmp	short ktLop		; try another range

NotLead:
	xor	ax,ax			; set zero
	jmp	short ktRet

Islead:
	xor	ax,ax			; reset zero
	inc	ax

ktRet:
	pop	ax
	pop	si
	pop	ds
	ret

	endif




;***	MsgInt2fHandler - int 2f handler for message retrieval
;
;	ENTRY	If we handle it -
;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
;		  DL = operation =
;		     0 = get extended error messages
;		     1 = set extended error messages
;		     2 = get parse error messages
;		     3 = set parse error messages
;		     4 = get critical error messages
;		     5 = set critical error messages
;		     6 = get file system error messages
;		     7 = set file system error messages
;		     8 = get disk retriever routine
;		     9 = set disk retriever routine
;		  ES:DI = address for 'set' operations
;
;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
;
;	NOTE
;	  This handler replaces the one that used to reside in DOS.
;	  'Set' operations are ignored.
;	  'File system error messages' are not supported.

;SR;
; At the int 2fh entry point we push the old ds value and the resident data
;segment address. Get them off the stack
;

MsgInt2fHandler	proc	far

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	pop	ds			;ds = DATARES
	assume	ds:DATARES
;	pop	OldDS			;save old value of ds

	cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
	je	miOurs			; it's ours

	ifndef 	ROMDOS
	cmp	ax,GET_COMMAND_STATE	;is it first COMMAND query?
	else
	cmp	ax,GET_ROMCOMMAND_STATE	;is it first ROM COMMAND query?
	endif	;ROMDOS

	je	fcOurs

;SR;
; We cannot do a far jump any more because cs cannot be used. Push the cs:ip
;onto the stack and do a far return to jump to the next 2fh handler. 
;Our old ds is on the stack. We need to restore it but we cannot lose the
;current value of ds as it points at the data segment. So we do some kinky
;stack manipulations.
;
	push	ax
	push	ax			;create 2 words on stack for retf

	push	bp
	push	ax

	mov	bp,sp			;bp can be used to address stack
;
;Swap the old ds value with the second dummy word on the stack. Now, we can
;do a 'pop ds' at the end to restore our ds
;
	mov	ax,[bp+8]		;ax = old ds value
	mov	[bp+4],ax
	
	mov	ax,word ptr ds:Int2fHandler+2
	mov	[bp+8],ax		;put segment address
	mov	ax,word ptr ds:Int2fHandler
	mov	[bp+6],ax		;put offset address


	pop	ax
	pop	bp
	pop	ds

	retf				;chain on to next handler

;;	jmp	Int2fHandler		; hand off to next 2f handler

fcOurs:
;
;We have to clear ax, and return in ds:si a pointer to the stub jump table
;
	pop	ax			;discard ds currently on stack
	push	ds			;store our data segment

	mov	si,offset DATARES:Int2f_Entry ;start of table

	xor	ax,ax			;indicate COMMAND present
	jmp	short miRet		;return to caller


miOurs:
	test	dl,1
	jnz	miRet			; ignore 'set' operations

	push	bx			; preserve BX
	mov	bx,dx
	xor	bh,bh			; BX = index in word table
	shl	bx,1			; BX = index in dword table
	les	di,MsgPtrLists[bx]		; ES:DI = ptr to msg ptr list
	pop	bx			; restore BX

miRet:
;	mov	ds,OldDS		;restore ds
	pop	ds
	assume	ds:nothing

	iret

MsgInt2fHandler	endp




;***	MsgRetriever - message retrieval routine for utilities
;
;	Address of this routine is passed to utility programs via 
;	message services int 2f.  We try to find the desired message
;	in memory or in our disk image.
;
;	ENTRY	AX = message #
;		DI = offset in RESGROUP of msg ptr list
;		ComSpec = asciiz pathname to our disk image
;
;	EXIT	CY clear for success
;		ES:DI = ptr to count byte, followed by message text
;
;		CY set for failure
;		ES,DI undefined
;
;	USED	flags
;
;	NOTE
;	  The message # in AX is used to compute an offset into
;	  the message ptr list pointed to by DI.  The lists must
;	  start with message # 1 and proceed through consecutive
;	  message #'s.  
;
;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
;	  ExtMsgPtrs.  We use NUMPARSEMSGS and NUMEXTMSGS to check for
;	  valid message #.  ;M033
;
;	  List positions with no corresponding message text are
;	  indicated by null pointers, which this routine detects.

;SR; This routine will be called directly by the utilities. So, we have
; trap for it in the stub. The stub pushes the old value of ds and the 
; DATARES value on the stack. We get them off the stack to setup ds here
;

MsgRetriever	proc	far

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	pop	ds			;ds = DATARES
	assume	ds:DATARES
;	pop	OldDS			;save old ds

	push	ax			; preserve registers
	push	bx
	push	cx
	push	dx
	push	si

;;	push	ds
;;	push	cs
;;	pop	ds			; DS = DATARES seg addr
;;	assume	ds:RESGROUP
;;	push	cs

	push	ds			; get es from ds
	pop	es			; ES = DATARES seg addr

;	Begin modification M033.

;	Make sure msg # is valid.
;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.

	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
	cmp	di,offset DATARES:ParsMsgPtrs
	je	@f			; it's ParsMsgPtrs
	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
@@:	cmp	bx,ax
	jc	mrRet			; msg # too high, return carry

;	Msg # is valid.

;	End modification M033.

	dec	ax
	shl	ax,1			; AX = offset into msg ptr list
	add	di,ax			; DI = ptr to msg ptr

	cmp	di,ResMsgEnd
	jb	mrInMem			; ptr (and message) in memory

;*	Retrieve message from disk (or ROM) image.
;	Read once to get the ptr to the message, then again for the message.

ifndef	ROMDOS

	mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
	mov	dx,EXT_EXISTS_OPEN		; DX = 'open existing file'
	mov	bx,INT_24_ERROR			; BX = 'fail on crit error'
	mov	ax,EXTOPEN shl 8		; AX = 'Extended Open File'
	int	21h				; call DOS
	jc	mrRet				; return failure

	mov	bx,ax				; BX = file handle
	mov	dx,di				; DX = ptr to msg ptr
	xor	si,si				; SI = read count
mrRead:
	sub	dx,100h				; DX = LSW of file offset
	xor	cx,cx				; CX = MSW of file offset
	mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
	int	21h				; call DOS
	jc	mrCloseFile			; handle error

	mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
	mov	cx,64				; CX = # bytes to read
	mov	ah,READ				; AH = 'Read File'
	int	21h				; call DOS
	jc	mrCloseFile			; handle error

	or	si,si				; (CY cleared)
	jnz	mrCloseFile			; 2nd time thru - we're done
	inc	si				; mark one read done
	mov	dx,word ptr MsgBuffer		; DX = ptr to message
	or	dx,dx
	jnz	mrRead				; go read the message
	stc					; null ptr found- no msg

mrCloseFile:
	pushf				; save success/failure (CY)
	mov	ah,CLOSE		; AH = 'Close File'
	int	21h			; call DOS
;	Bugbug: should we avoid this popf?
	popf				; CY = success/failure
	mov	di,dx			; ES:DI = ptr to msg, if successful
	jmp	short mrRet		; we're done

else	;ROMDOS

;	DI = ptr to msg ptr

	mov	si,di			; SI = ptr to msg ptr
	sub	si,100h			; SI = offset into image of msg ptr
	mov	cx,2			; CX = # bytes to copy from image

;	ASSUME ES:NOTHING is still in effect.

	push	ds
	pop	es				; ES = DATARES seg addr
	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to buffer
	invoke	LoadFromROM			; copy msg ptr from ROM
	mov	si,word ptr MsgBuffer		; SI = ptr to message
	or	si,si
	jz	mrNoMsg			; null ptr- no message text

	sub	si,100h			; SI = offset into image of msg
	mov	cx,64			; CX = # bytes to copy from image
	mov	di,offset DATARES:MsgBuffer
	invoke	LoadFromROM
	clc					; success
	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to msg
	jmp	short mrRet

mrNoMsg:
	stc
	jmp	short mrRet

;;	mov	ax,COMMAND_SEG-10h	; AX = seg addr of COMMAND image
;;	mov	es,ax			; ES:DI = ptr to msg ptr in image
	assume	es:NOTHING

endif	;ROMDOS


;*	Message ptr is in memory.
;	If ptr is in memory, assume message is in memory (/msg).

mrInMem:
	mov	di,es:[di]		; ES:DI = ptr to msg
	or	di,di			; (CY cleared)
	jnz	mrRet			; found message
	stc				; null ptr found- no message

mrRet:	
	pop	si			;restore all registers
	pop	dx
	pop	cx
	pop	bx
	pop	ax

;	mov	ds,OldDS		;restore ds
	pop	ds
	assume	ds:nothing

	ret

MsgRetriever	endp

;
; M003; Start of changes for UMB support
;


;***	Lh_OffUnlink -- Restore allocation strat and link state
;
;	ENTRY	al = Saved alloc strat and link state
;			b0 = 1 if alloc strat to restore is HighFirst
;			b1 = 1 if link state to restore is Linked
;
;	EXIT	None
;
;	USED	ax, bx, cx
;
;

public	Lh_OffUnlink
Lh_OffUnlink	proc	far

	mov	ch,al
	mov	cl,al
	mov	ax,(ALLOCOPER shl 8) OR 0
	int	21h
	mov	bx,ax
	ror	cl,1				;b7 = HighFirst bit
	and	cl,80h				;mask off b6-b0
	and	bl,7fh				;mask off HighFirst bit
	or	bl,cl				;set HighFirst bit state
	mov	ax,(ALLOCOPER shl 8) OR 1
	int	21h				;set alloc strat

	mov	bl,ch
	shr	bl,1
	xor	bh,bh				;bx = linkstate
	mov	ax,(ALLOCOPER shl 8) OR 3
	int	21h				;set linkstate

	ret

Lh_OffUnlink	endp

;
; M003; End of changes for UMB support
;

public	EndCode
EndCode	label	byte

CODERES ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\path2.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)path2.asm	1.1 85/05/14
;	SCCSID = @(#)path2.asm	1.1 85/05/14
.sall
.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include find.inc
	include comsw.asm
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES SEGMENT PUBLIC BYTE
	EXTRN	FORFLAG:BYTE
DATARES ENDS


break <Path.Asm>
;----------------------------------------------------------------------------
;    PATH.ASM contains the routines to perform pathname incovation.  Path and
;    Parse share a temporary buffer and argv[] definitions.  <Path_Search>,
;    given a pathname, attempts to find a corresponding executable or batch
;    file on disk.  Directories specified in the user's search path will be
;    searched for a matching file, if a match is not found in the current
;    directory and if the pathname is actually only an MSDOS filename.
;    <Path_Search> assumes that the parsed command name can be found in
;    argv[0] -- in other words, <Parseline> should be executed prior to
;    <Path_Search>.  Alternatively, the command name and appropriate
;    information could be placed in argv[0], or <Path_Search> could be
;    (easily) modified to make no assumptions about where its input is found.
;    Please find enclosed yet another important routine, <Save_Args>, which
;    places the entire arg/argv[]/argbuf structure on a piece of newly
;    allocated memory.	This is handy for for-loop processing, and anything
;    else that wants to save the whole shebang and then process other command
;    lines.
;
; Alan L, OS/MSDOS				    August 15, 1983
;
; ENTRY:
;   <Path_Search>:	    argv[0].
;   <Save_Args>:	    bytes to allocate in addition to arg structure
; EXIT:
;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
;   <Save_Args>:	    success flag, segment address of new memory
; NOTE(S):
;   *	<Argv_calc> handily turns an array index into an absolute pointer.
;	The computation depends on the size of an argv[] element (arg_ele).
;   *	<Parseline> calls <cparse> for chunks of the command line.  <Cparse>
;	does not function as specified; see <Parseline> for more details.
;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
;	need to know about.  This extra information is stored in a switch_flag
;	word with each command-line argument; the switches themselves will not
;	appear in the resulting arg structure.
;   *	With the exception of CARRY, flags are generally preserved across calls.
;---------------
; CONSTANTS:
;---------------
    DEBUGx	equ	    FALSE	; prints out debug info
;---------------
; DATA:
;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte
	EXTRN	BADPMES_ptr:word
	EXTRN	curdrv:byte
	EXTRN	EXECPATH:byte
	EXTRN	ext_entered:byte	;AN005;
	EXTRN	fbuf:byte
	EXTRN	pathinfo:word
	EXTRN	psep_char:byte
	EXTRN	string_ptr_2:word
	EXTRN	tpbuf:byte
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;

assume cs:trangroup, ds:trangroup, es:trangroup, ss:nothing

break <Search>
;----------------------------------------------------------------------------
;   SEARCH, when given a pathname, attempts to find a file with
; one of the following extensions:  .com, .exe, .bat (highest to
; lowest priority).  Where conflicts arise, the extension with
; the highest priority is favored.
; ENTRY:
;   DX		--	pointer to null-terminated pathname
;   fbuf	--	dma buffer for findfirst/next
; EXIT:
;   AX		--	8)  file found with .com extension
;			4)  file found with .exe extension
;			2)  file found with .bat extension
;			0)  no such file to be found
;   (if AX is non-zero:)
;   [search_best]	identical to AX
;   [search_best_buf]	null-terminated filename
; NOTES:
;   1)	Requires caller to have allocated a dma buffer and executed a setdma.
;---------------
; CONSTANTS:
;---------------
search_file_not_found	    equ 	0
search_com		    equ 	8
search_exe		    equ 	4
search_bat		    equ 	2
fname_len		    equ 	8
fname_max_len		    equ 	13
dot			    equ 	'.'
wildchar		    equ 	'?'

;---------------
; DATA:
;---------------
TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	search_best:byte
	EXTRN	search_best_buf:byte
	EXTRN	search_curdir_buf:byte
	EXTRN	search_error:word
TRANSPACE	ENDS

;---------------
Procedure   Search,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	CX
	push	DX
	push	DI
	push	SI
	pushf

	push	DX				; check drivespec (save pname ptr)
	mov	DI, DX				; working copy of pathname
	mov	SI, OFFSET TRANGROUP:search_curdir_buf
	xor	DX, DX				; zero means current drive
	cmp	BYTE PTR [DI+1],':'             ; is there a drive spec?
	jne	search_dir_check
	mov	DL, [DI]			; get the drive byte
	and	DL, NOT 20H			; uppercase the sucker
	sub	DL, '@'                         ; and convert to drive number

search_dir_check:
	trap	Current_Dir			; can we get the drive's current
	pop	DX				; directory?  If we can't we'll
	jc	search_invalid_drive		; assume it's a bad drive...

	mov	CX, search_attr 		; filetypes to search for
	trap	Find_First			; request first match, if any
	jc	search_no_file
	mov	search_best, search_file_not_found
	mov	[search_best_buf], ANULL	; nothing's been found, yet

search_loop:
	call	search_ftype			; determine if .com, &c...
	cmp	AL, search_best 		; better than what we've found so far?
	jle	search_next			; no, look for another
	mov	search_best, AL 		; found something... save its code
	mov	SI, OFFSET TRANGROUP:fbuf.find_buf_pname
	mov	DI, OFFSET TRANGROUP:search_best_buf
	mov	CX, fname_max_len
	cld
	rep	movsb				; save complete pathname representation
	cmp	AL, search_com			; have we found the best of all?
	je	search_done

search_next:					; keep on looking
	mov	CX, search_attr
	trap	Find_Next			; next match
	jnc	search_loop

search_done:					; it's all over with...
	mov	AL, search_best 		; pick best to return with
	cmp	ext_entered,1			;AN005; Did user request a specific ext?
	jz	search_exit			;AN005; no - exit
	mov	al,ext_entered			;AN005; yes - get the real file type back
	mov	search_best,al			;AN005; save the real file type
	jmp	short search_exit

search_invalid_drive:				; Tell the user path/drive
	mov	DX, [search_error]		; appropriate error message
	invoke	std_printf			; and pretend no file found

search_no_file: 				; couldn't find a match
	mov	AX, search_file_not_found

search_exit:
	popf
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	ret
;---------------
EndProc Search
;----------------------------------------------------------------------------


break <Search_Ftype>
;----------------------------------------------------------------------------
;   SEARCH_FTYPE determines the type of a file by examining its extension.
; ENTRY:
;   fbuf    --	    dma buffer containing filename
; EXIT:
;   AX	    --	    file code, as given in search header
; NOTE(S):
;   *	Implicit assumption that NULL == search_file_not_found
;---------------
; DATA:
;---------------
TRANDATA	SEGMENT PUBLIC BYTE		;AC000;
	extrn	comext:byte,exeext:byte,batext:byte
trandata     ends
;---------------
Procedure   Search_Ftype,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	DI
	push	si
	mov	AX, ANULL			; find the end of the filename
	mov	DI, OFFSET TRANGROUP:fbuf.find_buf_pname
	mov	CX, fname_max_len
	cld
	repnz	scasb				; search for the terminating null
	jnz	ftype_exit			; weird... no null byte at end
	sub	di,5				; . + E + X + T + NULL
;
; Compare .COM
;
	mov	si,offset trangroup:comext
	mov	ax,di
	cmpsw
	jnz	ftype_exe
	cmpsw
	jnz	ftype_exe
	mov	AX, search_com			; success!
	jmp	short ftype_exit
;
; Compare .EXE
;

ftype_exe:					; still looking... now for '.exe'
	mov	di,ax
	mov	si,offset trangroup:exeext
	cmpsw
	jnz	ftype_bat
	cmpsw
	jnz	ftype_bat
	mov	AX, search_exe			; success!
	jmp	short ftype_exit
;
; Compare .BAT
;

ftype_bat:					; still looking... now for '.bat'
	mov	di,ax
	mov	si,offset trangroup:batext
	cmpsw
	jnz	ftype_fail
	cmpsw
	jnz	ftype_fail
	mov	AX, search_bat			; success!
	jmp	short ftype_exit

ftype_fail:					; file doesn't match what we need
	mov	ax,ANULL

ftype_exit:
	cmp	ext_entered,1			;AN005; was an extension entered?
	jz	ftype_done			;AN005; no - exit
	cmp	ax,ANULL			;AN005; was any match found
	jz	ftype_done			;AN005; no - exit
	mov	ext_entered,al			;AN005; save the match type found
	mov	AX, search_com			;AN005; send back best was found to stop search

ftype_done:					;AN005;
	pop	SI
	pop	DI
	ret

;---------------
EndProc Search_Ftype
;----------------------------------------------------------------------------


break <Strip>
;----------------------------------------------------------------------------
;    STRIP copies the source string (argv[0]) into the destination buffer,
; replacing any extension with wildcards.
; ENTRY:
;	BX		--		maximum length of destination buffer
;	DS:SI		--		address of destination buffer
;	argv[0] 	--		command name to be stripped
; EXIT:
;	CF		--		set if failure, clear if successful
; NOTE(S):
;---------------
Procedure   Strip,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	AX
	push	BX
	push	CX
	push	DX
	push	DI
	push	SI
	pushf

	mov	ext_entered,1			;AN005; assume no extension on file name
	mov	DX, DS:arg.argv[0].argpointer	; save pointer to beginning of argstring
	mov	DI, DS:arg.argv[0].argstartel	; beginning of last pathname element
	cmp	BYTE PTR [DI], 0		; *STARTEL == NULL means no command
	jz	strip_error
	mov	CX, DX				; compute where end of argstring lies
	add	CX, DS:arg.argv[0].arglen
	sub	CX, DI				; and then find length of last element
	inc	CX				; include null as well
	mov	AL, dot 			; let's find the filetype extension
	cld
	repnz	scasb				; wind up pointing to either null or dot
	jcxz	process_ext			;AN005; if no extension found, just continue
	mov	ext_entered,0			;AN005; we found an extension
	mov	al,ANULL			;AN005; continue scanning until the
	repnz	scasb				;AN005;    end of line is reached.

process_ext:					;AN005;
	mov	CX, DI				; pointer to end of argstring yields
	sub	CX, DX				; number of bytes to be copied
	sub	BX, 4				; can argstring fit into dest. buffer?
	cmp	CX, BX
	jg	strip_error			; if not, we must have a bad pathname
	mov	DI, SI				; destination buffer
	mov	SI, DX				; source is beginning of pathname
	cld
	rep	movsb				; SI=arg,DI=buffer,CX=argend-argbeg
	cmp	ext_entered,1			;AN005; if an extension was entered
	jnz	skip_wilds			;AN005;    don't set up wildcard ext.

	dec	DI				; overwrite null or dot
	stosb					; with a dot
	mov	AL, wildchar			; now add wildcards
	stosb
	stosb
	stosb
	mov	AL, ANULL			; and a terminating null
	stosb

skip_wilds:					;AN005;
	popf
	clc					; chill out...
	jmp	short strip_exit

strip_error:
	popf
	stc

strip_exit:
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	ret
;---------------
EndProc Strip
;----------------------------------------------------------------------------


break <Save_Args>
;----------------------------------------------------------------------------
;   SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
; structure in newly allocated memory.	The argv[] structure is found at the
; beginning of this area.  The caller indicates how much extra space is
; needed in the resulting structure; Save_Args returns a segment number and
; an offset into that area, indicating where the caller may preserve its own
; data.  Note that <argvcnt> can be found at <offset-2>.
; ENTRY:
;   BX	    --	    size (in bytes) of extra area to allocate
; EXIT:
;   AX	    --	    segment of new area.
;   CF	    --	    set if unable to save a copy.
; NOTE(S):
;   1)	The allocated area will be AT LEAST the size requested -- since
;	the underlying MSDOS call, <alloc> returns an integral number of
;	paragraphs.
;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
;	as the caller of Save_Args requests.
;   3)	AX is undefined if CF indicates an error.
;---------------
Procedure   Save_Args,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	BX
	push	CX
	push	DX
	push	DI
	push	SI
	push	BP
	pushf
	add	BX, SIZE arg_unit + 0FH 	; space for arg structure, round up
	mov	CL, 4				; to paragraph size and convert
	shr	BX, CL				; size in bytes to size in paragraphs
	trap	Alloc
	jc	save_error
	mov	BP, AX				; save segment id
	push	ES				; save TRANGROUP address
	mov	ES, AX				; switch to new memory segment
assume	ES:nothing
	mov	CX, SIZE arg_unit		; get back structure size
	xor	DI, DI				; destination is new memory area
	mov	SI, OFFSET TRANGROUP:arg	; source is arg structure
	rep	movsb				; move that sucker!
	mov	CX, arg.argvcnt 		; adjust argv pointers
	xor	AX, AX				; base address for argv_calc
;	Bugbug:	What did they mean by this?
;	Note that the replacement line produces exactly the same code.
;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
	mov	SI, OFFSET TRANGROUP:arg

save_ptr_loop:
	dec	CX				; exhausted all args?
	jl	save_done
	mov	BX, CX				; get arg index and
	invoke	argv_calc			; convert to a pointer
	mov	DX, DS:arg.argv[BX].argpointer
	sub	DX, SI				; adjust argpointer
	mov	ES:argv[BX].argpointer, DX
	mov	DX, DS:arg.argv[BX].argstartel
	sub	DX, SI				; and adjust argstartel
	mov	ES:argv[BX].argstartel, DX
	mov	DX, DS:arg.argv[BX].arg_ocomptr
	sub	DX, SI				; and adjust arg_ocomptr
	mov	ES:argv[BX].arg_ocomptr, DX
	jmp	save_ptr_loop

save_done:
	pop	ES				; back we go to TRANGROUP
assume	ES:trangroup
	mov	AX, BP				; restore segment id
	jmp	short save_ok

save_error:
	popf
	stc
	jmp	short save_exit

save_ok:
	popf
	clc
save_exit:
	pop	BP
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	ret
;---------------
EndProc Save_Args
;----------------------------------------------------------------------------

trancode    ends
END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\romhead.asm ===
page    ,132
	title   ROM COMMAND Resident ROM Header

comment %------------------------------------------------------------------

This module provides a standard ROM header for ROM COMMAND as
described in the IBM System BIOS technical reference.

MS-DOS ROM $Exec header is also supplied, as described in the
MS-DOS 5.0 ROM Version technical specification.  ROM program
names for the command interpreter are supplied.

This code must appear on a 2K boundary within I/O adapter address
space.

%--------------------------------------------------------------------------



ROMHEADER	segment


;***	Adapter ROM module signature and size
;
;	The signature must be aligned on a 2K address boundary.
;	A checksum of bytes in the specified range must be zero
;	for the ROM module to be valid.

	db      55h,0AAh                ; ROM signature
	db      70h			; ROM size (56K) in 512-byte pages

	; Note that size field is usually set automatically when ROM images
	; are put together.  The zero checksum is handled at that point, too.

	assume  cs:ROMHEADER

;*	POST Initialization (POST makes far call to here).

	jmp     near ptr POSTInit       ; POST initialization

;*	ROM file header for DOS $ROMFindFirst, $ROMFindNext, $Exec.

ROMFile	macro	name,entry
	local	nambeg,namend
	db	namend-nambeg	;; file name length
nambeg	db	"&name"		;; file name
namend	label	byte
	jmp	near ptr entry	;; exec entry point
	endm

	ROMFile	COMMAND,Launch		; COMMAND launch
	ROMFile	COMMAND.COM, Launch	; one more name fore command

	db      0               	; end of file names




;***    POST initialization - no action needed

POSTInit:
	retf




;***    COMMAND launch

	include	command.loc		; COMMAND image location

Launch:

;       CS = ROMHEADER segment
;       DS,ES,SS = segment of PSP

;*      Copy COMMAND image to RAM.
;
;	We supply to routines, one to copy the COMMAND image from
;	ROM below 1 MB, the other to copy the image from extended
;	address space.  We choose between the two routines by
;	determining whether command.loc, the COMMAND location file,
;	defines COMMAND_SEG (meaning COMMAND is below 1 MB) or
;	COMMAND_LO (meaning COMMAND is in extended address space).
;
;	The OEM may replace this whole IFDEF structure with their
;	own loader routine.  For example, if the COMMAND image is
;	in port-accessed ROM, I would use ROMnTYPE=BASE in the ROM
;	image description file.  This would generate COMMAND_LO and
;	COMMAND_HI address symbols in command.loc.  I'd replace
;	the following IFDEF structure with code to use COMMAND_LO
;	(and COMMAND_HI, if necessary) along with COMMAND_SIZ to
;	copy the COMMAND image from port-accessed ROM.

;	------------------------------------------------------------
	ifdef	COMMAND_SEG
;	COMMAND image is in first megabyte.  Cool.
	
	mov	ax,COMMAND_SEG		; AX = COMMAND image seg addr
	mov	ds,ax
	xor	si,si			; DS:SI = ptr to COMMAND image

	mov     di,100h                 ; ES:DI = ptr to byte after PSP
	mov     cx,COMMAND_SIZ		; CX = # bytes to copy
	cld
	rep     movsb                   ; copy COMMAND image to RAM

	else
;	------------------------------------------------------------
	ifdef	COMMAND_LO

;	COMMAND image is in extended address space.
;	Copy via int 15h block move.

	jmp	short setupGDT		; jump over data

;	Global Descriptor Table (GDT)

GDT	db	10h dup (0)		; reserved zero
	dw	COMMAND_SIZ		; segment length
	dw	COMMAND_LO		; low 16 bits of source address
	db	COMMAND_HI		; high 8 bits of source address
	db	93h			; access rights byte
	db	2 dup (0)		; reserved zero
	dw	COMMAND_SIZ		; segment length
	db	3 dup (?)		; 24-bit dest addr (to be filled in)
	db	93h			; access rights byte
	db	12h dup (0)		; reserved zero

;	Set up Global Descriptor Table at PSP+100h+COMMAND_SIZ.

setupGDT:

GDT_OFF	equ	100h+COMMAND_SIZ	; offset of GDT location in RAM

	cld

	mov	ax,cs
	mov	ds,ax			; DS = ROMHEADER seg addr
	mov	si,offset GDT		; DS:SI = ptr to GDT template
	mov	cx,30h			; CX = size of template
	mov	di,GDT_OFF		; ES:DI = ptr to GDT RAM location
	rep	movsb			; copy template to RAM

	mov	ax,es			; AX = PSP seg addr
	mov	ds,ax			; DS = PSP seg addr again

;	Compute 24-bit linear destination address.

	mov	bx,10h
	add	ax,bx			; AX = seg addr of PSP+100h
	mul	bx			; DX:AX = linear addr of PSP+100h
	mov	ds:GDT_OFF+1Ah,ax	; put 24-bit addr in the GDT
	mov	byte ptr ds:GDT_OFF+1Ch,dl

	mov	si,GDT_OFF		; ES:DI = ptr to GDT
	mov	cx,(COMMAND_SIZ+1)/2	; CX = # words to xfr
	mov	ah,87h			; AH = 'Move Extended Memory Block'
	int	15h			; call I/O subsystem extensions
	jnc	moved			; it worked

;	Block move failed.

;	Need to issue "Cannot load ROM COMMAND" message.

	mov	ax,4C01h		; AX = 'Terminate', exit code 1
	int	21h			; call DOS

moved:

;	------------------------------------------------------------
	endif
	endif

;*      Transfer control to COMMAND in RAM.

	mov     ax,es                   ; AX = PSP segment
	mov     ds,ax                   ; DS = PSP segment

	push    ax
	mov     ax,100h                 ; AX = offset of COMMAND start addr
	push    ax                      ; stack = CS:IP for COMMAND start
	retf                            ; transfer to COMMAND in RAM



EndOfHeader	label	byte

ROMHEADER	ends

	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tbatch.asm ===
page ,132
;	SCCSID = @(#)tbatch.asm 4.5 85/10/01
;	SCCSID = @(#)tbatch.asm 4.5 85/10/01
TITLE	Batch processing routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M006	SR	07/20/90	Changed BatCom to understand batch
;				segments in UMBs. Check only for 
;				overlap.
;	M017	MD	08/10/90	Eliminate extra DEC, to fix bug #1
;
;	M037	SR	11/1/90	Bug #1745 & #3438 fixed. Fixed ReadBat
;				to check if we have hit EOF on
;				batchfile and if so, just clear everything
;				and return finishing batch processing.
;

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include comseg.asm
	include comequ.asm
	include doscntry.inc		;an000;
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BATCH:WORD
	EXTRN	Batch_Abort:byte
	EXTRN	call_batch_flag:byte
	EXTRN	ECHOFLAG:BYTE
	EXTRN	forflag:byte
	EXTRN	forptr:word
	EXTRN	IFFlag:BYTE
	EXTRN	In_Batch:byte
	EXTRN	LTPA:WORD
	EXTRN	Nest:word
	EXTRN	next_batch:word
	EXTRN	nullflag:byte
	EXTRN	PIPEFLAG:BYTE
	EXTRN	RES_TPA:WORD
	EXTRN	SINGLECOM:WORD
	EXTRN	SUPPRESS:BYTE		;AC000;
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADBAT_PTR:WORD
	EXTRN	Extend_buf_ptr:word	;AC000;
	EXTRN	Extend_buf_sub:byte	;AN022;
	EXTRN	msg_disp_class:byte	;AC000;
	EXTRN	NEEDBAT_PTR:WORD
	EXTRN	pausemes_ptr:word	;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BatBufPos:WORD
	EXTRN	BATHAND:WORD
	EXTRN	bwdbuf:byte		;AN022;
	EXTRN	BYTCNT:WORD
	EXTRN	COMBUF:BYTE
	EXTRN	EXECPATH:BYTE
	EXTRN	ID:BYTE
	EXTRN	RCH_ADDR:DWORD
	EXTRN	RESSEG:WORD
	EXTRN	string_ptr_2:word	;AC000;
	EXTRN	TPA:WORD
	EXTRN	TRAN_TPA:WORD

	extrn	TranSpaceEnd:byte	; M006
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near
	EXTRN	tcommand:near

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
    extrn   arg:byte			; the arg structure!
transpace   ends
;---------------

Break	<PromptBat - Open or wait for batch file>

;
; Open the batch file.	If we cannot find the batch file.  If the media is
; changeable, we prompt for the change.  Otherwise, we terminate the batch
; file.  Leave segment registers alone.
;

Procedure   PromptBat,NEAR
	ASSUME	DS:ResGroup,ES:NOTHING
	invoke	BATOPEN 			; attempt to open batch file
	retnc
	cmp	dx,error_file_not_found 	;AN022; Ask for diskette if file not found
	jz	Bat_Remcheck			;AN022;
	cmp	dx,error_path_not_found 	;AN022; Ask for diskette if path not found
	jz	Bat_Remcheck			;AN022;    Otherwise, issue message and exit
	invoke	output_batch_name		;AN022; set up batch name in bwdbuf
	jmp	short BatDie			;AN022;

Bat_Remcheck:					;AN022; Go see if media is removable
	CALL	[RCH_ADDR]			; DX has error number
	JZ	AskForBat			; Media is removable
;
; The media is not changeable.	Turn everything off.
;
	invoke	ForOff
	invoke	PipeOff
	MOV	IfFlag,AL			; No If in progress.
	MOV	DX,OFFSET TRANGROUP:BADBAT_ptr

BatDie:
	call	BatchOff
	PUSH	CS
	POP	DS
	ASSUME	DS:TranGroup
	invoke	std_eprintf			;AC022; display message

;
; TCOMMAND resets the stack.  This is the equivalent of a non-local goto.
;
	JMP	TCOMMAND			; he cleans off stack

;
; Ask the user to reinsert the batch file
;
ASKFORBAT:
	ASSUME	DS:ResGroup
	PUSH	DS
	PUSH	CS
	POP	DS
	ASSUME	DS:TranGroup
	MOV	DX,OFFSET TRANGROUP:NEEDBAT_ptr  ;AN022;
	invoke	std_eprintf			 ;Prompt for batch file on stderr
	mov	dx,offset trangroup:pausemes_ptr ;AN000; get second part of message
	invoke	std_eprintf			 ;AN000; print it to stderr
	CALL	GetKeystroke
	POP	DS
	ASSUME	DS:ResGroup
	jmp	PromptBat
EndProc PromptBat

;****************************************************************
;*
;* ROUTINE:	Output_batch_name
;*
;* FUNCTION:	Sets up batch name to be printed on extended error
;*
;* INPUT:	DX - extended error number
;*
;* OUTPUT:	Ready to call print routine
;*
;****************************************************************

public	output_batch_name			;AN022;

Output_batch_name    proc near			;AN022;

	push	ds				;AN022; save resident segment
	mov	ds,[batch]			;AN022; get batch file segment
assume	DS:nothing				;AN022;
	mov	SI,BatFile			;AN022; get offset of batch file
	invoke	dstrlen 			;AN022; get length of string
	mov	di,offset Trangroup:bwdbuf	;AN022; target for batch name
	rep	movsb				;AN022; move the name

	push	cs				;AN022; get local segment
	pop	ds				;AN022;
assume	DS:trangroup				;AN022;
	mov	extend_buf_ptr,dx		;AN022; put message number in block
	mov	msg_disp_class,ext_msg_class	;AN022; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr   ;AN022; get extended message pointer
	mov	string_ptr_2,offset trangroup:bwdbuf ;AN022; point to substitution
	mov	extend_buf_sub,one_subst	;AN022; set up for one subst
	pop	ds				;AN022; restore data segment

	ret					;AN022; return

Output_batch_name    endp			;AN022;

Break	<GetKeystroke - get a keystroke and flush queue>

;
; read the next keystroke.  Since there may be several characters in the queue
; after the one we ask for (function keys/Kanji), we need to flush the queue
; AFTER waiting.
;
Procedure   GetKeyStroke,NEAR
;
; read any character at any mode, interim mode or not.
;
	assume	ds:trangroup

	PUSH	DX					;AN000;  3/3/KK
	MOV	AX,(ECS_call SHL 8) OR GetInterimMode	;AN000;  3/3/KK
	INT	21h				;AN000;  3/3/KK
	PUSH	DX					;AN000;  save interim state 3/3/KK
	MOV	AX,(ECS_call SHL 8) OR SetInterimMode	;AN000;  3/3/KK
	MOV	DL,InterimMode				;AN000;  3/3/KK
	INT	21h				;AN000;  3/3/KK

	MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
	INT	21h		; Get character with KB buffer flush
	MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
	INT	21h

	MOV	AX,(ECS_call SHL 8) OR SetInterimMode	;AN000;  3/3/KK
	POP	DX					;AN000;  restore interim state 3/3/KK
	INT	21h				;AN000;  3/3/KK
	POP	DX					;AN000;  3/3/KK

	return
EndProc GetKeyStroke

Break	<ReadBat - read 1 line from batch file>

;
; ReadBat - read a single line from the batch file.  Perform all substitutions
; as appropriate
;

Procedure   ReadBat,NEAR
	ASSUME	DS:ResGroup,ES:TranGroup
	mov	suppress,yes_echo		;g initialize line suppress status
	test	byte ptr [Batch_Abort],-1
	jnz	Trying_To_Abort
	mov	byte ptr [In_Batch],1		; set flag to indicate batch job
;
;M037; Start of changes
; We check here if we have set the flag indicating that the batchfile is at
;EOF. In this case, we do not want to continue with the normal processing.
;We call GetBatByt once more so that the batch segment gets freed up, the
;batch file gets closed etc. and then return as if everything is done.
;
	push	ds
	mov	ds,Batch
	cmp	ds:BatchEOF,0		; are we at EOF in batchfile
	pop	ds
	jz	contbat		; no, continue normal processing
	invoke	GetBatByt		; frees up batchseg
	mov	es:ComBuf+2,al		; stuff CR into command buffer
					; as a dummy command
	invoke 	CrLf2			; print a CR-LF
	return				; done batch processing
contbat:
;
;M037; End of changes
;

	CALL	PromptBat

Trying_To_Abort:
	MOV	DI,OFFSET TRANGROUP:COMBUF+2

;
; Save position and try to scan for first non delimiter.
;

TESTNOP:
	MOV	AX,DS
	MOV	DS,Batch
	ASSUME	DS:NOTHING
	PUSH	WORD PTR DS:[BatSeek]
	PUSH	WORD PTR DS:[BatSeek+2] 	; save current location.
	MOV	DS,AX
	ASSUME	DS:ResGroup
	invoke	SkipDelim			; skip to first non-delim
;
; If the first non-delimiter is not a :  (label), we reseek back to the
; beginning and read the line.
;
	CMP	AL,':'                          ; is it a label?
	POP	CX
	POP	DX				; restore position in bat file
	JZ	NopLine 			; yes, resync everything.
	TEST	[BATCH],-1			; are we done with the batch file?
	JZ	RdBat

	CMP	AL, NO_ECHO_CHAR		;g see if user wants to suppress line
	JNZ	SET_BAT_POS			;g no - go and set batch file position
	MOV	SUPPRESS, NO_ECHO		;g yes set flag to indicate
	jmp	short Rdbat			;g go read batch file

SET_BAT_POS:					;g
	PUSH	DS
	MOV	DS,Batch
	ASSUME	DS:NOTHING
	MOV	WORD PTR DS:[BatSeek],DX	; reseek back to beginning
	MOV	WORD PTR DS:[BatSeek+2],CX
	POP	DS
	ASSUME	DS:ResGroup
	MOV	AX,(LSEEK SHL 8) + 0		; seek back
	INT	21h
	MOV	BatBufPos,-1			; nuke batch buffer position
	xor	cx,cx				; Initialize line length to zero
	JMP	SHORT RdBat
;
; The first non-delimiter is a :.  This line is not echoed and is ignored.
; We eat characters until a CR is seen.
;

NOPLINE:
	CALL	SkipToEOL
	invoke	GetBatByt			; eat trailing LF
	TEST	[BATCH],-1			; are we done with the batch file?
	JNZ	TESTNOP 			; no, go get another line
	return					; Hit EOF

;
; Read a line into the buffer pointed to by ES:DI.  If any %s are seen in the
; input, we are to consider two special cases:
;
;   %0 to %9	These represent replaceable parameters from the batch segment
;   %sym%	This is a symbol from the environment
;

RDBAT:
	invoke	GetBatByt
	inc	cx				; Inc the line length

	invoke	testkanj		; MSKK04 07/14/89
	jz	rdbat1			;
	cmp	cx, COMBUFLEN-1		;
	jae	TooLong			; can't start DBCS char at last pos'n
	stosb				;
	invoke	GetBatByt		;
	inc	cx			;
	jmp	short SAVBATBYT		;
rdbat1:					;

	cmp	cx,COMBUFLEN			; Is it too long?
	jae	TooLong 			; Yes - handle it, handle it
;
; See if we have a parameter character.
;
	CMP	AL,'%'                          ; Check for parameter
	JZ	NEEDPARM
;
; no parameter character.  Store it as usual and see if we are done.
;

SAVBATBYT:
	STOSB
	CMP	AL,0DH				; End of line found?
	JNZ	RDBAT				; no, go for more
;
; We have read in an entire line.  Decide whether we should echo the command
; line or not.
;

Found_EOL:
	SUB	DI,OFFSET TRANGROUP:COMBUF+3
	MOV	AX,DI				; remember that we've not counted the CR
	MOV	ES:[COMBUF+1],AL		; Set length of line
	invoke	GetBatByt			; Eat linefeed
	invoke	BATCLOSE
	CMP	SUPPRESS, NO_ECHO		;G
	JZ	Reset				;G
	test	[echoflag],1			; To echo or not to echo, that is the
	jnz	try_nextflag

Reset:
	PUSH	CS				;  question.  (Profound, huh?)
	POP	DS				; Go back to local segment
	retz					; no echoing here...
;
; Echo the command line with appropriate CRLF...
;


try_nextflag:
	cmp	nullflag,nullcommand		;G was there a command last time?
	jz	No_crlf_print			;G no - don't print crlf
	invoke	CRLF2				;G  Print out prompt

no_crlf_print:
	invoke	PRINT_PROMPT			;G
	PUSH	CS				;G change data segment
	POP	DS				;G

ASSUME DS:TRANGROUP
	mov	dx,OFFSET TRANGROUP:COMBUF+2	; get command line for echoing
	invoke	CRPRINT
	invoke	CRLF2
	return
;
; The line was too long.  Eat remainder of input text up until the CR
;
TooLong:
	ASSUME	DS:ResGroup
	cmp	al,0dh				; Has the end of the line been reached?
	jz	Ltlcont 			; Yes, continue
	CALL	SkipToEOL			; Eat remainder of line

Ltlcont:
	stosb					; Terminate the command
	jmp	Found_EOL			; Go process the valid part of the line
;
; We have found a parameter lead-in character.	Check for the 0-9 case first
;

NEEDPARM:
	invoke	GetBatByt			; get next character
	CMP	AL,'%'                          ; Check for two consecutive %
	JZ	SAVBATBYT			; if so, replace with a single %
	CMP	AL,0Dh				; Check for end-of-line
	JZ	SAVBATBYT			; yes, treat it normally
;
; We have found %<something>.  If the <something> is in the range 0-9, we
; retrieve the appropriate parameter from the batch segment.  Otherwise we
; see if the <something> has a terminating % and then look up the contents
; in the environment
;
PAROK:
	SUB	AL,'0'
	JB	NEEDENV 			; look for parameter in the environment
	CMP	AL,9
	JA	NEEDENV
;
; We have found %<number>.  This is taken from the parameters in the
; allocated batch area.
;
	CBW
	MOV	BX,AX				; move index into AX
	SHL	BX,1				; convert word index into byte ptr
	SaveReg <ES>
	MOV	ES,Batch
;
; The structure of the batch area is:
;
;   BYTE    type of segment
;   DWORD   offset for next line
;   10 WORD pointers to parameters.  -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;
; Get pointer to BX'th argument
;
	MOV	SI,ES:BatParm[BX]
	RestoreReg  <ES>
;
; Is there a parameter here?
;
	CMP	SI,-1				; Check if parameter exists
	JNZ	Yes_there_is			;G Yes go get it
	JMP	RDBAT				; Ignore if it doesn't
;
; Copy in the found parameter from batch segment
;

Yes_there_is:
	PUSH	DS
	MOV	DS,Batch
	ASSUME	DS:NOTHING
	dec	cx				; Don't count '%' in line length

CopyParm:
	LODSB					; From resident segment
	CMP	AL,0DH				; Check for end of parameter
	JZ	EndParam
	inc	cx				; Inc the line length
	cmp	cx,COMBUFLEN			; Is it too long?
	jae	LineTooL			; Yes - handle it, handle it
	STOSB
	JMP	CopyParm
;
; We have copied up to the limit.  Stop copying and eat remainder of batch
; line.  We need to make sure that the tooLong code isn't fooled into
; believing that we are at EOL.  Clobber AL too.
;

LineTooL:
	XOR	AL,AL
	POP	DS
	ASSUME	DS:RESGROUP
	JMP	TooLong
;
; We have copied in an entire parameter.  Go back for more
;

EndParam:
	POP	DS
	JMP	RDBat
;
; We have found % followed by something other than 0-9.  We presume that there
; will be a following % character.  In between is an environment variable that
; we will fetch and replace in the batch line with its value.
;

NEEDENV:
        dec     cx                              ;AN070; Don't count "%"
	SaveReg <DS,DI>
	MOV	DI,OFFSET TRANGROUP:ID		; temp spot for name
	ADD	AL,'0'                          ; reconvert character
	STOSB					; store it in appropriate place
;
; loop getting characters until the next % is found or until EOL
;

GETENV1:
	invoke	GetBatByt			; get the byte
	STOSB					; store it
	CMP	AL,0Dh				; EOL?
	JNZ	GETENV15			; no, see if it the term char
;
; The user entered a string with a % but no trailing %.  We copy the string.
;
	mov	byte ptr es:[di-1],0		; nul terminate the string
	mov	si,offset TranGroup:ID		; point to buffer
	pop	di				; point to line buffer
	push	cs
	pop	ds
	call	StrCpy
	jc	LineTooL
	pop	ds
	jmp	SavBatByt

GETENV15:
	CMP	AL,'%'                          ; terminating %?
	JNZ	GETENV1 			; no, go suck out more characters

; M017 - following DEC is wrong, because we replace the % with a = here.
; This was the source of bug #1.
;	dec	cx				;AN070; Don't count "%"

	mov	al,'='                          ; terminate  with =
	MOV	ES:[DI-1],al
;
; ID now either has a =-terminated string which we are to find in the
; environment or a non =-terminated string which will not be found in the
; environment.
;
GETENV2:
	MOV	SI,OFFSET TRANGROUP:ID
	PUSH	CS
	POP	DS				; DS:SI POINTS TO NAME
	ASSUME DS:TRANGROUP
	PUSH	CX
	INVOKE	FIND_NAME_IN_environment
	ASSUME ES:RESGROUP
	POP	CX
	PUSH	ES
	POP	DS
	assume ds:resgroup
	PUSH	CS
	POP	ES
	ASSUME ES:TRANGROUP
	MOV	SI,DI
	POP	DI				; get back pointer to command line
;
; If the parameter was not found,  there is no need to perform any replacement.
; We merely pretend that we've copied the parameter.
;
	JC	GETENV6
;
; ES:DI points to command line being built
; DS:SI points either to nul-terminated environment object AFTER =
;

	ASSUME	ES:NOTHING
	call	StrCpy				; (let RdBat handle overflow)
GETENV6:
	pop	ds
	JMP	RDBAT				; no, go back to batch file

EndProc ReadBat

;
;   SkipToEOL - read from batch file until end of line
;

Procedure   SkipToEOL,NEAR

	ASSUME	DS:ResGroup,ES:NOTHING

	TEST	Batch,-1
	retz					; no batch file in effect
	invoke	GetBatByt
	CMP	AL,0Dh				; eol character?
	JNZ	SkipToEOL			; no, go eat another
	return

EndProc SkipToEOL

Break	<Allocate and deallocate the transient portion>

;
; Free Transient.  Modify ES,AX,flags
;

Procedure   Free_TPA,NEAR

ASSUME	DS:TRANGROUP,ES:RESGROUP

	PUSH	ES
	MOV	ES,[RESSEG]
	MOV	ES,[RES_TPA]
	MOV	AH,DEALLOC
	INT	21h			; Make lots of free memory
	POP	ES

	return

EndProc Free_TPA

;
; Allocate transient.  Modify AX,BX,DX,flags
;

Procedure   Alloc_TPA,NEAR

ASSUME DS:TRANGROUP,ES:RESGROUP

	PUSH	ES
	MOV	ES,[RESSEG]
	MOV	BX,0FFFFH			; Re-allocate the transient
	MOV	AH,ALLOC
	INT	21h
	PUSH	BX				; Save size of block
	MOV	AH,ALLOC
	INT	21h
;
; Attempt to align TPA on 64K boundary
;
	POP	BX				; Restore size of block
	MOV	[RES_TPA], AX			; Save segment to beginning of block
	MOV	[TRAN_TPA], AX
;
; Is the segment already aligned on a 64K boundary
;
	MOV	DX, AX				; Save segment
	AND	AX, 0FFFH			; Test if above boundary
	JNZ	Calc_TPA
	MOV	AX, DX
	AND	AX, 0F000H			; Test if multiple of 64K
	JNZ	NOROUND

Calc_TPA:
	MOV	AX, DX
	AND	AX, 0F000H
	ADD	AX, 01000H			; Round up to next 64K boundary
	JC	NOROUND 			; Memory wrap if carry set
;
; Make sure that new boundary is within allocated range
;
	MOV	DX, [RES_TPA]
	ADD	DX, BX				; Compute maximum address
	CMP	DX, AX				; Is 64K address out of range?
	JB	NOROUND
;
; Make sure that we won't overwrite the transient
;
	MOV	BX, CS				; CS is beginning of transient
	CMP	BX, AX
	JB	NOROUND
;
; The area from the 64K boundary to the beginning of the transient must
; be at least 64K.
;
	SUB	BX, AX
	CMP	BX, 4096			; Size greater than 64K?
	JAE	ROUNDDONE

NOROUND:
	MOV	AX, [RES_TPA]

ROUNDDONE:
	MOV	[LTPA],AX			; Re-compute everything
	MOV	[TPA],AX
	MOV	BX,AX
	MOV	AX,CS
	SUB	AX,BX
	PUSH	BX
	MOV	BX,16
	MUL	BX
	POP	BX
	OR	DX,DX
	JZ	SAVSIZ2
	MOV	AX,-1

SAVSIZ2:
;
; AX is the number of bytes free in the buffer between the resident and the
; transient with a maximum of 64K-1.  We round this down to a multiple of 512.
;
	CMP	AX,512
	JBE	GotSize
	AND	AX,0FE00h			; NOT 511 = NOT 1FF

GotSize:
	MOV	[BYTCNT],AX
	POP	ES

	return

EndProc Alloc_TPA

Break	<BatCom - enter a batch file>

;
; The exec search has determined that the user has requested a batch file for
; execution.  We parse the arguments, create the batch segment, and signal
; batch processing.
;
Procedure   BatCom,NEAR

ASSUME	DS:TRANGROUP, ES:NOTHING

;
; Batch parameters are read with ES set to segment of resident part
;

	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	cmp	es:[call_batch_flag],call_in_progress ;AN043; If in CALL,
	jz	skip_ioset			;AN043;   redirection was already set up
	invoke	IOSET				; Set up any redirection

skip_ioset:					;AN043;
	CALL	FREE_TPA			; G
	cmp	es:[call_batch_flag],call_in_progress ;G
	jz	getecho 			; G if we're in a call, don't execute
;
; Since BATCH has lower precedence than PIPE or FOR.  If a new BATCH file is
; being started it MUST be true that no FOR or PIPE is currently in progress.
; Don't execute if in call
;
	invoke	ForOff

getecho:
	invoke	PipeOff
	mov	al,EchoFlag			; preserve echo state for chaining

	and	al, 1				; Save current echo state
	push	ax

	xor	ax,ax				;G
	test	es:[batch],-1			;G  Are we in a batch file?
	jz	leavebat			;G  No, nothing to save
	mov	ax,es:[batch]			;G get current batch segment
	cmp	es:[call_batch_flag],call_in_progress  ;G
	jz	leavebat			;G
;
;  We are in a chained batch file, save batlast from previous batch segment
;  so that if we're in a CALL, we will return to the correct batch file.
;
	push	es				;G
	mov	es,ax				;G get current batch segment
	mov	ax,es:[batlast] 		;G get previous batch segment
	pop	es				;G

leavebat:					;G
	push	ax				;G keep segment until new one created
	cmp	es:[call_batch_flag],call_in_progress  ;G are we in a CALL?
	jz	startbat			;G Yes, keep current batch segment
	call	BatchOff			;G No, deallocate old batch segment

;
; Find length of batch file
;

startbat:					;G
	ASSUME	ES:RESGROUP
	MOV	es:[CALL_BATCH_FLAG], 0 	;G  reset call flag
	mov	SI, OFFSET TRANGROUP:EXECPATH

	mov	ax,AppendTruename		;AN042; Get the real path where the batch file
	int	2fh				;AN042;    was found with APPEND
	mov	ah,Find_First			;AN042; The find_first will return it
	mov	dx,si				;AN042; Get the string
	mov	cx,search_attr			;AN042; filetypes to search for
	int	21h			;AN042;

	invoke	DStrLen
;
; Allocate batch area:
;   BYTE    type of segment
;   WORD    segment of last batch file
;   WORD    segment for FOR command
;   BYTE    FOR flag state on entry to batch file
;   DWORD   offset for next line
;   10 WORD pointers to parameters.  -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;
; We allocate the maximum size for the command line and use setblock to shrink
; later when we've squeezed out the extra
;

	MOV	BX,CX				; length of file name.
	ADD	BX,0Fh + (SIZE BatchSegment) + COMBUFLEN + 0Fh
						; structure + max len + round up
	SaveReg <CX>
	MOV	CL,4
	SHR	BX,CL				; convert to paragraphs
	PUSH	BX				;G save size of batch segment
	MOV	AH,ALLOC
	INT	21h			; Allocate batch segment
	POP	BX				;G get size of batch segment
;
; This should *NEVER* return an error.	The transient is MUCH bigger than
; the batch segment.  This may not be true, however, in a multitasking system.
; G This error will occur with nesting of batch files.	We also need to
; G make sure that we don't overlay the transient.
;
	jc	mem_error			;G not enough memory - exit
	push	ax				;G save batch segment
	add	ax,bx				;G get end of batch segment
	add	ax,20h				;G add some tpa work area
	mov	bx,cs				;G get the transient segment
;
; M006; We cant check just for above. If the batchseg goes into a UMB, the
; M006; batchseg is always above the transient. We need to change this code
; M006; to only check for an overlap
;
	mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
	add	dx,15				;round up para; M006
	shr	dx,cl				;para size of transient; M006
	add	dx,bx				;dx = top of transient; M006

	cmp	ax,bx				; M006
	jb	enough_mem			; Batchseg below transient
						; enough memory ; M006
	cmp	ax,dx				; M006
	ja	enough_mem			; Batchseg above transient
						; enough memory ; M006
;
; M006; Batchseg overlaps transient -- insufficient memory
;
	pop	ax				; restore ax; M006

;M006;	cmp	ax,bx				;G do we end before the transient
;M006;	pop	ax				;G get batch segment back
;M006;	jb	enough_mem			;G we have enough memory - continue

	push	es				;G no we're hitting the transient
	mov	es,ax
	mov	ax,DEALLOC SHL 8		;G deallocate the batch segment
	int	21h
	pop	es

mem_error:
	jmp	no_memory			;G Set up for message and exit

enough_mem:
	pop	ax				; restore ax; M006

	MOV	[BATCH],AX
	CALL	ALLOC_TPA
;
; Initialize batch segment
;
	RestoreReg  <DX>			; length of name
	POP	AX				;G  get saved batch segment back
	inc	es:nest 			;G increment # batch files in progress
	PUSH	ES
	MOV	ES,[BATCH]
ASSUME	ES:NOTHING
	MOV	ES:[BatType],BatchType		; signal batch file type
	MOV	ES:[batlast],ax 		;G save segment of last batch file
	push	DS				;G
	mov	DS,[resseg]			;G set to resident data
ASSUME	DS:RESGROUP
	xor	ax,ax				;G
	mov	bl,forflag			;G get the current FOR state
	mov	ES:[batforflag],bl		;G save it in the batch segment
	test	bl,-1				;G are we in a FOR?
	jz	for_not_on			;G no, for segment set to 0
	mov	ax,forptr			;G yes, get current FOR segment
	mov	forflag,0			;G reset forflag

for_not_on:
	mov	ES:[batforptr],ax		;G save FOR segment in batch segment
	XOR	AX,AX
	mov	forptr,ax			;G make sure for segment is not active
	mov	bl,echoflag			;G
	pop	DS				;G

	mov	byte ptr es:[Batechoflag],bl	;G save echo state of parent
;SR;
; Initialize the new BatchEOF flag we have added to 0
;
	mov	es:BatchEOF,0

	MOV	WORD PTR ES:[BatSeek],AX	; point to beginning of file
	MOV	WORD PTR ES:[BatSeek+2],AX
;
; Initialize pointers
;
	DEC	AX				; put -1 into AX
	MOV	DI,BatParm			; point to parm area
	MOV	BX,DI
	MOV	CX,10
	REP	STOSW				; Init to no parms
;
; Move in batch file name
;
	MOV	CX,DX
	rep	movsb				; including NUL.
;
; Now copy the command line into batch segment, parsing the arguments along
; the way.  Segment will look like this:
;
;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
;
; or, in the case of fewer arguments:
;
;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
;
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	MOV	CX,10				; at most 10 arguments
;
; Look for beginning of next argument
;
EACHPARM:
	invoke	SCANOFF 			; skip to argument
;
; AL is first non-delimiter.  DS:SI points to char = AL
;
	CMP	AL,0DH				; end of road?
	JZ	HAVPARM 			; yes, no more arguments
;
; If CX = 0 then we have stored the most parm we can.  Skip store
;
	JCXZ	MOVPARM 			; Only first 10 parms get pointers
;
; Go into allocated piece and stick in new argument pointer.
;
	MOV	ES:[BX],DI			; store batch pointer
	ADD	BX,2				; advance arg counter
;
; Move the parameter into batch segment
;
MOVPARM:
	LODSB					; get byte
	INVOKE	DELIM				; if delimiter
	JZ	ENDPARM 			; then done with parm
	STOSB					; store byte
	CMP	AL,0DH				; if CR then not delimiter
	JZ	HAVPARM 			; but end of parm list, finish
	JMP	SHORT MOVPARM
;
; We have copied a parameter up until the first separator.  Terminate it with
; CR
;

ENDPARM:
	MOV	AL,0DH
	STOSB
	JCXZ	EACHPARM			; if no parameters, don't dec
	DEC	CX				; remember that we've seen one.
	JMP	SHORT EACHPARM
;
; We have parsed the entire line. Terminate the arg list
;

HAVPARM:
	XOR	AL,AL
	STOSB					; Nul terminate the parms
;
; Now we know EXACTLY how big the BATCH segment is.  Round up size (from DI)
; into paragraphs and setblock to the appropriate size
;
	LEA	BX,[DI+15]
	MOV	CL,4
	SHR	BX,CL
	MOV	AH,SetBlock
	INT	21h

	POP	ES
ASSUME	ES:RESGROUP
	PUSH	ES
	POP	DS				; Simply batch FCB setup
ASSUME	DS:RESGROUP
	CMP	[SINGLECOM],-1
	JNZ	NOBATSING
	MOV	[SINGLECOM],0FFF0H		; Flag single command BATCH job

NOBATSING:
;
; Enter the batch file with the current echo state
;
	pop	ax				; Get original echo state
	mov	echoflag,al			;g restore it
	JMP	TCOMMAND

;
; The following is executed if there isn't enough memory for batch segment
;

NO_MEMORY:
	assume ds:trangroup,es:resgroup
	pop	dx				;g even up our stack
	pop	ax				;g
	pop	ax				;g
	call	Alloc_tpa			;g reallocate memory
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr     ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,error_not_enough_memory ;AN000; get message number in control block
	jmp	cerror				;g print error message and go...

EndProc BatCom

Procedure   BatchOff

	ASSUME	DS:NOTHING,ES:NOTHING

	SaveReg <AX,ES>
	PUSH	DS				;G
	PUSH	BX				;G
	MOV	ES,ResSeg
	MOV	DS,ResSeg			;G
	ASSUME	ES:ResGroup,DS:Resgroup 	;G
	MOV	AX,Batch			; Free the batch segment
	OR	AX,AX
	JZ	nofree

	PUSH	ES
	MOV	ES,AX
	test	[echoflag],1			;G Is echo on?
	jnz	echo_last_line			;G Yes - echo last line in file
	mov	suppress,no_echo		;G no - don't echo last line in file

echo_last_line:
	MOV	BL,ES:[BATECHOFLAG]		;G  Get echo state
	mov	[echoflag],bl			;G     and restore it
	MOV	BX,ES:[BATFORPTR]		;G  Get FOR segment
	MOV	FORPTR,BX			;G     and restore it
	MOV	BL,ES:[BATFORFLAG]		;G  Get FOR flag
	MOV	FORFLAG,BL			;G     and restore it
	MOV	BX,es:[batlast] 		;G  get old batch segment
	MOV	AH,DEALLOC
	INT	21h
	POP	ES
	MOV	Next_BATCH,BX			;G  reset batch segment
	DEC	es:NEST 			;G

	XOR	AX,AX
	MOV	Batch,AX			; No batch in progress

NoFree:
	POP	BX				;G
	pop	ds				;G
	RestoreReg  <ES,AX>

	return

EndProc BatchOff


; StrCpy - copy string, checking count in CX against COMBUFLEN
;	Entry : DS:SI ==> source string
;		ES:DI ==> destination string
;		CX = current length of destination string
;	Exit  : string copied, CX updated, Carry set if length limit exceeded
Procedure StrCpy,NEAR
	push	ax
ccycle:
	lodsb
	inc	cx
	cmp	cx,COMBUFLEN
	jb	ccopy
	stc				; set carry to signal error
	jmp	short ccend
ccopy:
	stosb
	or	al,al
	jnz	ccycle

ccend:
	dec	cx			; discount extra byte
	dec	di			; back up pointer
	pop	ax
	return				; return carry clear
EndProc StrCpy

TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tcmd1a.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
************************************************************
************************************************************
**							  **
**  THIS FILE IS OBSOLETE, NO LONGER USED, DEFUNCT,	  **
**  AND, IN FACT, DOESN'T EVEN EXIST.  YOU ARE NOT	  **
**  HERE.  YOU MAY NOT BE ANYWHERE AT ALL.  THIS	  **
**  WHOLE THING COULDN'T POSSIBLY BE HAPPENING.		  **
**							  **
**  See DIR.ASM for a reality check.			  **
**							  **
************************************************************
************************************************************

 page 80,132
;	SCCSID = @(#)tcmd1a.asm 1.1 85/05/14
;	SCCSID = @(#)tcmd1a.asm 1.1 85/05/14
TITLE	PART4 COMMAND Transient routines.

;	Internal commands DIR,PAUSE,ERASE,TYPE,VOL,VER

	INCLUDE comsw.asm
.xlist
.xcref
	INCLUDE DOSSYM.INC
	INCLUDE comseg.asm
	INCLUDE comequ.asm		;AC000;
	include ioctl.inc		;AN000;
.list
.cref

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BadCD_ptr:word
	EXTRN	bits:word
	EXTRN	Bytmes_ptr:word
	EXTRN	comsw:word
	EXTRN	dir_w_syn:word		;AC000;
	EXTRN	dirdat_mo_day:word	;AC000;
	EXTRN	dirdat_yr:word		;AC000;
	EXTRN	dirdattim_ptr:word
	EXTRN	dirhead_ptr:word
	EXTRN	dirtim_hr_min:word	;AC000;
	EXTRN	Dirmes_ptr:word
	EXTRN	disp_file_size_ptr:word
	EXTRN	Dmes_ptr:word
	EXTRN	Extend_buf_ptr:word	;AN000;
	EXTRN	msg_disp_class:byte	;AN000;
	EXTRN	parse_dir:byte		;AC000;
	EXTRN	slash_p_syn:word	;AC000;
	EXTRN	string_buf_ptr:word
	EXTRN	tab_ptr:word		;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	bytes_free:word
	EXTRN	charbuf:byte
	EXTRN	COM:byte
	EXTRN	Destisdir:byte
	EXTRN	Desttail:word
	EXTRN	dir_num:word
	EXTRN	Dirbuf:byte
	EXTRN	dirflag:byte		;AN015;
	EXTRN	display_ioctl:word	;AC000;
	EXTRN	display_mode:byte	;AC000;
	EXTRN	filecnt:word
	EXTRN	file_size_high:word
	EXTRN	file_size_low:word
	EXTRN	fullscr:word
	EXTRN	ID:byte
	EXTRN	lincnt:byte		;AC000;
	EXTRN	linlen:byte
	EXTRN	linperpag:word		;AC000;
	EXTRN	msg_numb:word		;AN022;
	EXTRN	parse1_addr:dword	;AC000;
	EXTRN	parse1_syn:word 	;AC000;
	EXTRN	parse1_type:byte	;AC000;
	EXTRN	pathcnt:word		;AN000;
	EXTRN	pathpos:word		;AN000;
	EXTRN	srcbuf:byte		;AC000;
	EXTRN	string_ptr_2:word
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
TRANSPACE	ENDS
;---------------

	EXTRN	cerror:near
	EXTRN	std_printf:near


	PUBLIC	catalog


	break	Catalog - Directory command
assume	ds:trangroup,es:trangroup

;
; The DIR command displays the contents of a directory.
;
; ****************************************************************
; *
; * ROUTINE:	 CATALOG - display file(s) in directory
; *
; * FUNCTION:	 PARSE command line for drive, file, or path name.
; *		 DIR allows two switches, /P (pause) and /W (wide).
; *		 If an error occurs issue and error message and
; *		 transfer control to CERROR.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

CATALOG:

;
; Set up DTA for dir search firsts
;
	mov	dx,offset trangroup:Dirbuf	;AC000; Set Disk transfer address
	mov	ah,Set_DMA			;AC000;
	int	int_command			;AC000;
;
; Set up defaults for switches and parse the command line.
;
	mov	msg_numb,0			;AN022; initialize message flag
	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf
	mov	[pathpos],di			;AN000; this is start of path
	mov	[pathcnt],1			;AN000; initialize length to 1 char
	mov	al,star 			;AN000; initialize srcbuf to *,0d
	stosb					;AN000;
	mov	al,end_of_line_in		;AN000;
	stosb					;AN000;
	mov	si,81H				;AN000; Get command line
	mov	di,offset trangroup:parse_dir	;AN000; Get adderss of PARSE_DIR
	xor	cx,cx				;AC000; clear counter for positionals
	mov	ComSw,cx			;AC000; initialize flags
	mov	bits,cx 			;AC000; initialize switches
	mov	linperpag,linesperpage		;AC000; Set default for lines per page
	mov	linlen,normperlin		;AC000; Set number of entries per line
	mov	lincnt,normperlin		;AC000;

dirscan:
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?
	jne	dirscan_cont			;AN000; No - continue parsing
	jmp	scandone			;AN000; yes - go process

dirscan_cont:
	cmp	ax,result_no_error		;AN000; did we have an error?
	jz	dirscan_cont2			;AN000; No - continue parsing
	jmp	badparm 			;AN000; yes - exit

dirscan_cont2:
	cmp	parse1_syn,offset trangroup:dir_w_syn ;AN000; was /W entered?
	je	set_dir_width			;AN000; yes - go set wide lines
	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
	je	set_dir_pause			;AN000; yes - go set pause at end of screen
;
; Must be filespec since no other matches occurred. move filename to srcbuf
;
	push	si				;AC000; save position in line
	lds	si,parse1_addr			;AC000; get address of filespec
	push	si				;AN000; save address
	invoke	move_to_srcbuf			;AC000; move to srcbuf
	pop	dx				;AC000; get address in DX

;
; The user may have specified a device.  Search for the path and see if the
; attributes indicate a device.
;
	mov	ah,Find_First			;AC000; find the file
	int	int_command			;AC000;
	jnc	Dir_check_device		;AN022; if no error - check device
	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_no_more_files		;AN022; was error no file found
	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
	cmp	ax,error_path_not_found 	;AN022; was error no file found
	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
	jmp	dir_err_setup			;AN022; otherwise - go issue error message

dir_check_device:				;AN022;
	test	byte ptr (DirBuf+find_buf_attr),attr_device ;AC000;
	jz	Dir_fspec_end			;AC000; no, go do normal operation
	mov	ComSw,-2			;AC000; signal device

dir_fspec_end:
	pop	si				;AC000; restore position in line
	jmp	short dirscan			;AC000; keep parsing

set_dir_width:
	test	byte ptr[bits],SwitchW		;AN018; /W already set?
	jz	ok_set_width			;AN018; no - okay to set width
	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
	invoke	setup_parse_error_msg		;AN018; set up an error message
	jmp	badparm 			;AN018; exit

ok_set_width:
	or	bits,switchw			;AC000; indicate /w was selected
	mov	linlen,wideperlin		;AC000; Set number of entries per line
	mov	lincnt,wideperlin		;AC000;
	jmp	short dirscan			;AC000; keep parsing

set_dir_pause:
	test	byte ptr[bits],SwitchP		;AN018; /p already set?
	jz	ok_set_pause			;AN018; no - okay to set width
	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
	invoke	setup_parse_error_msg		;AN018; set up an error message
	jmp	badparm 			;AN018; exit

ok_set_pause:
	or	bits,switchp			;AC000; indicate /p was selected
	push	cx				;AN000; save necessary registers
	push	si				;AN000;
	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
	mov	bx,stdout			;AN000; lines for stdout
	mov	ch,ioc_sc			;AN000; type is display
	mov	cl,get_generic			;AN000; get information
	mov	dx,offset trangroup:display_ioctl ;AN000;
	int	int_command			;AN000;

lines_set:
	dec	linperpag			;AN000; lines per actual page should
	dec	linperpag			;AN000;     two less than the max
	mov	ax,linperpag			;AN000; get number of lines into
	mov	[fullscr],ax			;AC000;    screen line counter
	pop	si				;AN000; restore registers
	pop	cx				;AN000;
	jmp	dirscan 			;AC000; keep parsing

;
; The syntax is incorrect.  Report only message we can.
;
BadParm:
	jmp	cerror				;AC000; invalid switches get displayed

ScanDone:

;
; Find and display the volume ID on the drive.
;

	invoke	okvolarg			;AC000;
;
; OkVolArg also disables APPEND, which will be re-enabled
; in the HeadFix routine, after we're done.
;
	mov	[filecnt],0			;AC000; Keep track of how many files found
	cmp	comsw,0 			;AC000; did an error occur?
	jnz	doheader			;AC000; yes - don't bother to fix path

	mov	dirflag,-1			;AN015; set pathcrunch called from DIR
	invoke	pathcrunch			;AC000; set up FCB for dir
	mov	dirflag,0			;AN015; reset dirflag
	jc	DirCheckPath			;AC015; no CHDIRs worked.
	jz	doheader			;AC015; chdirs worked - path\*.*
	mov	si,[desttail]			;AN015; get filename back
	jmp	short DoRealParse		;AN015; go parse it

DirCheckPath:
	mov	ax,[msg_numb]			;AN022; get message number
	cmp	ax,0				;AN022; Is there a message?
	jnz	dir_err_setup			;AN022; yes - there's an error
	cmp	[destisdir],0			;AC000; Were pathchars found?
	jz	doparse 			;AC000; no - no problem
	inc	comsw				;AC000; indicate error
	jmp	short doheader			;AC000; go print header

DirNF:
	mov	ax,error_file_not_found 	;AN022; get message number in control block

dir_err_setup:
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
	mov	extend_buf_ptr,ax		;AN022;

DirError:
	jmp	Cerror

;
; We have changed to something.  We also have a file.  Parse it into a
; reasonable form, leaving drive alone, leaving extention alone and leaving
; filename alone.  We need to special case ...	If we are at the root, the
; parse will fail and it will give us a file not found instead of file not
; found.
;
DoParse:
	mov	si,offset trangroup:srcbuf	;AN000; Get address of source
	cmp	byte ptr [si+1],colon_char	;AN000; Is there a drive?
	jnz	dir_no_drive			;AN000; no - keep going
	lodsw					;AN000; bypass drive

dir_no_drive:
	cmp	[si],".."
	jnz	DoRealParse
	cmp	byte ptr [si+2],0
	jnz	DoRealParse
	inc	ComSw
	jmp	short DoHeader

DoRealParse:
	mov	di,FCB			; where to put the file name
	mov	ax,(Parse_File_Descriptor SHL 8) OR 0EH
	int	int_command

;
; Check to see if APPEND installed.  If it is installed, set all flags
; off.	This will be reset in the HEADFIX routine
;

DoHeader:
; ORIGINAL APPEND CHECK CODE LOCATION ******************************

;
; Display the header
;

DoHeaderCont:
	mov	al,blank			;AN051; Print out a blank
	invoke	print_char			;AN051;   before DIR header
	invoke	build_dir_string		; get current dir string
	mov	dx,offset trangroup:Dirhead_ptr
	invoke	printf_crlf			; bang!

;
; If there were chars left after parse or device, then invalid file name
;
	cmp	ComSw,0
	jz	DoSearch			; nothing left; good parse
	jl	DirNFFix			; not .. => error file not found
	invoke	RestUDir
	mov	dx,offset TranGroup:BadCD_ptr
	jmp	Cerror				; was .. => error directory not found
DirNFFix:
	invoke	RestUDir
	jmp	DirNF
;
; We are assured that everything is correct.  Let's go and search.  Use
; attributes that will include finding directories.  perform the first search
; and reset our directory afterward.
;
DoSearch:
	mov	byte ptr DS:[FCB-7],0FFH
	mov	byte ptr DS:[FCB-1],010H
;
; Caution!  Since we are using an extended FCB, we will *also* be returning
; the directory information as an extended FCB.  We must bias all fetches into
; DIRBUF by 8 (Extended FCB part + drive)
;
	mov	ah,Dir_Search_First
	mov	dx,FCB-7
	int	int_command

	push	ax				;AN022; save return state
	inc	al				;AN022; did an error occur?
	pop	ax				;AN022; get return state back
	jnz	found_first_file		;AN022; no error - start dir
	invoke	set_ext_error_msg		;AN022; yes - set up error message
	push	dx				;AN022; save message
	invoke	restudir			;AN022; restore user's dir
	pop	dx				;AN022; restore message
	cmp	word ptr Extend_Buf_Ptr,Error_No_More_Files ;AN022; convert no more files to
	jnz	DirCerrorJ			;AN022; 	file not found
	mov	Extend_Buf_Ptr,Error_File_Not_Found  ;AN022;

DirCerrorJ:					;AN022;
	jmp	Cerror				;AN022; exit

;
; Restore the user's directory.  We preserve, though, the return from the
; previous system call for later checking.
;

found_first_file:
	push	ax
	invoke	restudir
	pop	ax
;
; Main scanning loop.  Entry has AL = Search first/next error code.  Test for
; no more.
;
DIRSTART:
	inc	al				; FF = file not found
	jnz	Display
	jmp	DirDone 			; Either an error or we are finished
;
; Note that we've seen a file and display the found file.
;

Display:
	inc	[filecnt]			; Keep track of how many we find
	mov	si,offset trangroup:dirbuf+8	; SI -> information returned by sys call
	call	shoname
;
; If we are displaying in wide mode, do not output the file info
;
	test	byte ptr[bits],SwitchW		; W switch set?
	jz	DirTest
	jmp	nexent				; If so, no size, date, or time

;
; Test for directory.
;
DirTest:
	test	[dirbuf+8].dir_attr,attr_directory
	jz	fileent
;
; We have a directory.	Display the <DIR> field in place of the file size
;
	mov	dx,offset trangroup:Dmes_ptr
	call	std_printf
	jmp	short nofsiz
;
; We have a file.  Display the file size
;
fileent:
	mov	dx,[DirBuf+8].dir_size_l
	mov	file_size_low,dx
	mov	dx,[DirBuf+8].dir_size_h
	mov	file_size_high,dx
	mov	dx,offset trangroup:disp_file_size_ptr
	call	std_printf
;
; Display time and date of last modification
;
nofsiz:
	mov	ax,[DirBuf+8].dir_date		; Get date
;
; If the date is 0, then we have found a 1.x level diskette.  We skip the
; date/time fields as 1.x did not have them.
;
	or	ax,ax
	jz	nexent				; Skip if no date
	mov	bx,ax
	and	ax,1FH				; get day
	mov	dl,al
	mov	ax,bx
	mov	cl,5
	shr	ax,cl				; Align month
	and	al,0FH				; Get month
	mov	dh,al
	mov	cl,bh
	shr	cl,1				; Align year
	xor	ch,ch
	add	cx,80				; Relative 1980
	cmp	cl,100
	jb	millenium
	sub	cl,100

millenium:
	xchg	dh,dl				;AN000; switch month & day
	mov	DirDat_yr,cx			;AC000; put year into message control block
	mov	DirDat_mo_day,dx		;AC000; put month and day into message control block
	mov	cx,[DirBuf+8].dir_time		; Get time
	jcxz	prbuf				; Time field present?
	shr	cx,1
	shr	cx,1
	shr	cx,1
	shr	cl,1
	shr	cl,1				; Hours in CH, minutes in CL
	xchg	ch,cl				;AN000; switch hours & minutes
	mov	DirTim_hr_min,cx		;AC000; put hours and minutes into message subst block

prbuf:
	mov	dx,offset trangroup:DirDatTim_ptr
	call	std_printf
	invoke	crlf2				;AC066;end the line
	dec	byte ptr [fullscr]		;AC066;count the line
	jnz	endif04 			;AN066;IF the last on the screen THEN
	   call    check_for_P			;AN066;   pause if /P requested
	endif04:				;AN066;
	jmp	scroll				; If not, just continue
;AD061; mov	DirDat_yr,0			;AC000; reset year, month and day
;AD061; mov	DirDat_mo_day,0 		;AC000;     in control block
;AD061; mov	DirTim_hr_min,0 		;AC000; reset hour & minute in control block
;
; We are done displaying an entry.  The code between "noexent:" and "scroll:"
; is only for /W case.
;
nexent:
	mov	bl,[lincnt]			;AN066;save for check for first entry on line
	dec	[lincnt]			      ;count this entry on the line
	jnz	else01				;AX066;IF last entry on line THEN
	   mov	   al,[linlen]
	   mov	   [lincnt],al
	   invoke  crlf2
	   cmp	   [fullscr],0			;AC066;IF have filled the screen THEN
	   jnz	   endif02			;AN066;
	      call    check_for_P		;AN066;   reinitialize fullscr,
	   endif02:				;AN066;   IF P requested THEN pause
	   jmp	   short endif01		;AN066;
	else01: 				;AN066;ELSE since screen not full
	   cmp	   bl,[linlen]			;AN066;   IF starting new line THEN
	   jne	   endif03			;	     count the line
	      dec     byte ptr [fullscr]	;AN066;   ENDIF
	   endif03:				;AC066;We are outputting on the same line, between fields, we tab.
	   mov	   dx,offset trangroup:tab_ptr	;Output a tab
	   call    std_printf
	endif01:				;AX066;
;
; All we need to do now is to get the next directory entry.
;
scroll:
	mov	ah,Dir_Search_Next
	mov	dx,FCB-7			; DX -> Unopened FCB
	int	int_command			; Search for a file to match FCB
	jmp	DirStart
;
; If no files have been found, display a not-found message
;
DirDone:
	invoke	get_ext_error_number		;AN022; get the extended error number
	cmp	ax,error_no_more_files		;AN022; was error file not found?
	jnz	dir_err_setup_jmp		;AN022; no - setup error message
	test	[filecnt],-1
	jnz	Trailer
	mov	ax,error_file_not_found 	;AN022;

dir_err_setup_jmp:				;AN022;
	jmp	dir_err_setup			;AN022; go setup error msg & print it
;
; If we have printed the maximum number of files per line, terminate it with
; CRLF.
;
Trailer:
	mov	al,[linlen]
	cmp	al,[lincnt]			; Will be equal if just had CR/LF
	jz	mmessage
	invoke	crlf2
	cmp	[fullscr],0			;AN066;IF on last line of screen THEN
	jnz	endif06 			;AN066;   pause before going on
	   call    check_for_P			;AN066;   to number and freespace
	endif06:				;AN066;   displays

mmessage:
	mov	dx,offset trangroup:Dirmes_ptr
	mov	si,[filecnt]
	mov	dir_num,si
	call	std_printf
	mov	ah,Get_Drive_Freespace
	mov	dl,byte ptr DS:[FCB]
	int	int_command
	cmp	ax,-1
	retz
	mul	cx				; AX is bytes per cluster
	mul	bx
	mov	bytes_free,ax			;AC000;
	mov	bytes_free+2,dx 		;AC000;
	MOV	DX,OFFSET TRANGROUP:BYTMES_ptr
	jmp	std_printf

shoname:
	mov	di,offset trangroup:charbuf
	mov	cx,8
	rep	movsb
	mov	al,' '
	stosb
	mov	cx,3
	rep	movsb
	xor	ax,ax
	stosb
	push	dx
	mov	dx,offset trangroup:charbuf
	mov	string_ptr_2,dx
	mov	dx,offset trangroup:string_buf_ptr
	call	std_printf
	pop	DX
	return

check_for_P    PROC  NEAR			;AN066;

test	byte ptr[bits],SwitchP	     ;P switch present?
jz	endif05 				;AN066;
   mov	   ax,linperpag 		   ;AN000;  transfer lines per page
   mov	   [fullscr],ax 		   ;AC000;	to fullscr
   invoke  Pause
endif05:
ret						;AN066;

check_for_P    ENDP				;AN066;

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tcmd1b.asm ===
page ,132
;	SCCSID = @(#)tcmd1b.asm 1.1 85/05/14
;	SCCSID = @(#)tcmd1b.asm 1.1 85/05/14
TITLE	PART4 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	Internal commands DIR,PAUSE,ERASE,TYPE,VOL,VER

.xlist
.xcref
	include dossym.inc
	include bpb.inc
	include syscall.inc
	include filemode.inc
	include sf.inc
	include comseg.asm
	include comsw.asm		;ac000;
	include comequ.asm
	include ioctl.inc		;an000;
.list
.cref

DATARES SEGMENT PUBLIC BYTE             ;AN020;AC068;
        EXTRN   append_flag:byte        ;AN020;AC068;
        EXTRN   append_state:word       ;AN020;AC068;
DATARES ENDS                            ;AN020;AC068;

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	badcpmes_ptr:word	;AC022;
	EXTRN	Extend_buf_ptr:word	;AC000;
	EXTRN	Extend_buf_sub:byte	;AN000;
	EXTRN	inornot_ptr:word
	EXTRN	msg_disp_class:byte	;AC000;
	EXTRN	parse_erase:byte	;AC000;
	EXTRN	parse_mrdir:byte	;AC000;
	EXTRN	parse_rename:byte	;AC000;
	EXTRN	parse_vol:byte		;AC000;
	EXTRN	PauseMes_ptr:word
	EXTRN	renerr_ptr:word
	EXTRN	slash_p_syn:word	;AC000;
	EXTRN	volmes_ptr:word 	;AC000;
	EXTRN	volmes_ptr_2:word	;AC000;
	EXTRN	volsermes_ptr:word	;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	bytcnt:word
	EXTRN	charbuf:byte
	EXTRN	comsw:word
	EXTRN	curdrv:byte
	EXTRN	destinfo:byte
	EXTRN	destisdir:byte
	EXTRN	dirbuf:byte
	EXTRN	msg_numb:word		;AN022;
	EXTRN	one_char_val:byte
	EXTRN	parse1_addr:dword	;AN000;
	EXTRN	parse1_syn:word 	;AN000;
        EXTRN   resseg:word             ;AN020;AC068;
	EXTRN	srcbuf:byte		;AN000;
	EXTRN	string_ptr_2:word	;AN000;
	EXTRN	TPA:word
	EXTRN	vol_drv:byte
	EXTRN	vol_ioctl_buf:byte	;AC000;
	EXTRN	vol_label:byte		;AC000;
	EXTRN	vol_serial:dword	;AC000;
	EXTRN	zflag:byte

	extrn	TypeFilSiz:dword
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
transpace   ends
;---------------

	EXTRN	cerror:near
	EXTRN	error_output:near
	EXTRN	notest2:near
	EXTRN	slashp_erase:near	;AN000;
	EXTRN	std_printf:near
	EXTRN	tcommand:near

	PUBLIC	badpath_err		;AN022;
	PUBLIC	crename
	PUBLIC	DisAppend
	PUBLIC	erase
	PUBLIC	extend_setup		;AN022;
	PUBLIC	Get_ext_error_number	;AN022;
	PUBLIC	pause
	PUBLIC	Set_ext_error_msg	;AN000;
	PUBLIC	typefil
	PUBLIC	volume


assume	ds:trangroup,es:trangroup

	break	Pause
assume	ds:trangroup,es:trangroup

PAUSE:
	mov	dx,offset trangroup:pausemes_ptr
	call	std_printf
	invoke	GetKeystroke
	invoke	crlf2
	return

	break	Erase

;****************************************************************
;*
;* ROUTINE:	DEL/ERASE - erase file(s)
;*
;* FUNCTION:	PARSE command line for file or path name and /P
;*		and invoke PATHCRUNCH.	If an error occurs, set
;*		up an error message and transfer control to CERROR.
;*		Otherwise, transfer control to NOTEST2 if /P not
;*		entered or SLASHP_ERASE if /P entered.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	if no error:
;*		FCB at 5ch set up with filename(s) entered
;*		Current directory set to entered directory
;*
;****************************************************************

assume	ds:trangroup,es:trangroup

ERASE:
	mov	si,81H				;AC000; get command line
	mov	comsw,0 			;AN000; clear switch indicator
	mov	di,offset trangroup:parse_erase ;AN000; Get adderss of PARSE_erase
	xor	cx,cx				;AN000; clear cx,dx

erase_scan:
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?
	jz	good_line			;AN000; yes - done parsing
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	errj2				;AC000; yes exit

	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
	je	set_erase_prompt		;AN000; yes - go set prompt

;
; Must be filespec since no other matches occurred. move filename to srcbuf
;
	push	si				;AC000; save position in line
	lds	si,parse1_addr			;AC000; get address of filespec
	cmp	byte ptr[si+1],colon_char	;AC000; drive specified?
	jnz	Erase_drive_ok			;AC000; no - continue
	cmp	byte ptr[si+2],end_of_line_out	;AC000; was only drive entered?
	jnz	erase_drive_ok			;AC000; no - continue
	mov	ax,error_file_not_found 	;AN022; get message number in control block
	jmp	short extend_setup		;AC000; exit

erase_drive_ok:
	invoke	move_to_srcbuf			;AC000; move to srcbuf
	pop	si				;AC000; get position back
	jmp	short erase_scan		;AN000; continue parsing

set_erase_prompt:
	cmp	comsw,0 			;AN018; was /P already entered?
	jz	ok_to_set_erase_prompt		;AN018; no go set switch
	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
	invoke	setup_parse_error_msg		;AN018; set up an error message
	jmp	short errj2			;AN018; exit

ok_to_set_erase_prompt: 			;AN018;
	inc	comsw				;AN000; indicate /p specified
	jmp	short erase_scan		;AN000; continue parsing

good_line:					;G  We know line is good
	invoke	pathcrunch
	jnc	checkdr
	mov	ax,[msg_numb]			;AN022; get message number
	cmp	ax,0				;AN022; was message flag set?
	jnz	extend_setup			;AN022; yes - print out message
	cmp	[destisdir],0			; No CHDIRs worked
	jnz	badpath_err			;AC022; see if they should have

checkdr:
	cmp	comsw,0 			;AN000; was /p specified
	jz	notest2j			;AN000; no - go to notest2
	jmp	slashp_erase			;AN000; yes - go to slashp_erase

notest2j:
	jmp	notest2

badpath_err:					;AN022; "Path not found" message
	mov	ax,error_path_not_found 	;AN022; set up error number

extend_setup:					;AN022;
	mov	msg_disp_class,ext_msg_class	;AN022; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AC022; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN022; get message number in control block
errj2:						;AC022; exit jump
	jmp	Cerror				;AN022;

	break	Rename

; ****************************************************************
; *
; * ROUTINE:	 CRENAME - rename file(s)
; *
; * FUNCTION:	 PARSE command line for one full filespec and one
; *		 filename.  Invoke PATHCRUNCH on the full filespec.
; *		 Make sure the second filespec only contains a
; *		 filename.  If both openands are valid, attempt
; *		 to rename the file.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

CRENAME:

	mov	si,81H				;AC000; Point to command line
	mov	di,offset trangroup:parse_rename;AN000; Get adderss of PARSE_RENAME
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,result_no_error		;AC000; did we have an error?
;;	jz	crename_no_parse_error		;AC000; no - continue
	jnz	crename_parse_error		;AC000; Yes, fail. (need long jump)

;
;  Get first file name returned from parse into our buffer
;
crename_no_parse_error:
	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of filespec
	invoke	move_to_srcbuf			;AN000; move to srcbuf
	pop	si				;AN000; restore position in line

	xor	dx,dx				;AN000; clear dx
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,result_no_error		;AN000; did we have an error?
	JNZ	crename_parse_error		;AN000; Yes, fail.

;
;  Check the second file name for drive letter colon
;
	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AC000; get address of path

	mov	al,':'                          ;AC000;
	cmp	[si+1],al			;AC000; Does the 2nd parm have a drive spec?
	jnz	ren_no_drive			;AN000; Yes, error
	mov	msg_disp_class,parse_msg_class	;AN000; set up parse error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,BadParm_ptr	;AN000; get "Invalid parameter" message number

	pop	si				;AN000;
crename_parse_error:				;AC022;
	jmp	short errj			;AC000;

;
;  Get second file name returned from parse into the fCB.  Save
;  character after file name so we can later check to make sure it
;  isn't a path character.
;

ren_no_drive:
	mov	di,FCB+10H			;AC000; set up to parse second file name
	mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
	int	21h			;AC000; do the function
	lodsb					;AC000; Load char after filename
	mov	one_char_val,al 		;AN000; save char after filename
	pop	si				;AN000; get line position back

;
; We have source and target.  See if any args beyond.
;

	mov	di,offset trangroup:parse_rename;AC000; get address of parse_rename
	invoke	parse_check_eol 		;AC000; are we at end of line?
	jnz	crename_parse_error		;AN000; no, fail.

	invoke	pathcrunch
	mov	dx,offset trangroup:badcpmes_ptr
	jz	errj2				; If 1st parm a dir, print error msg
	jnc	notest3
	mov	ax,[msg_numb]			;AN022; get message number
	cmp	ax,0				;AN022; was message flag set?
	jnz	extend_setup			;AN022; yes - print out message
	cmp	[destisdir],0			; No CHDIRs worked
	jz	notest3 			; see if they should have
	Jmp	badpath_err			;AC022; set up error

notest3:
	mov	al,one_char_val 		;AN000; move char into AX
	mov	dx,offset trangroup:inornot_ptr ; Load invalid fname error ptr
	invoke	pathchrcmp			; Is the char in al a path sep?
	jz	errj				; Yes, error - 2nd arg must be
						;  filename only.

	mov	ah,FCB_Rename
	mov	dx,FCB
	int	21h
	cmp	al, 0FFH			; Did an error occur??
	jnz	renameok

	invoke	get_ext_error_number		;AN022; get extended error
	SaveReg <AX>				;AC022; Save results
	mov	al, 0FFH			; Restore original error state

renameok:
	push	ax
	invoke	restudir
	pop	ax
	inc	al
	retnz

	RestoreReg  <AX>			;AC022; get the error number back
	cmp	ax,error_file_not_found 	;AN022; error file not found?
	jz	use_renerr			;AN022; yes - use generic error message
	cmp	ax,error_access_denied		;AN022; error file not found?
	jz	use_renerr			;AN022; yes - use generic error message
	jmp	extend_setup			;AN022; need long jump - use extended error

use_renerr:
	mov	dx,offset trangroup:RenErr_ptr	;AC022;

ERRJ:
	jmp	Cerror

ret56:	ret

	break	Type

;****************************************************************
;*
;* ROUTINE:	TYPEFIL - Display the contents of a file to the
;*		standard output device
;*
;* SYNTAX:	TYPE filespec
;*
;* FUNCTION:	If a valid filespec is found, read the file until
;*		1Ah and display the contents to STDOUT.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	none
;*
;****************************************************************

assume	ds:trangroup,es:trangroup

TYPEFIL:
	mov	si,81H
	mov	di,offset trangroup:parse_mrdir ;AN000; Get adderss of PARSE_MRDIR
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	typefil_parse_error		;AN000; yes - issue error message

	push	si				;AC000; save position in line
	lds	si,parse1_addr			;AC000; get address of filespec
	invoke	move_to_srcbuf			;AC000; move to srcbuf
	pop	si				;AC000; get position back
	mov	di,offset trangroup:parse_mrdir ;AC000; get address of parse_mrdir
	invoke	parse_check_eol 		;AC000; are we at end of line?
	jz	gottarg 			;AC000; yes - continue

typefil_parse_error:				;AN000; no - set up error message and exit
	jmp	Cerror

gottarg:
	invoke	setpath
	test	[destinfo],00000010b		; Does the filespec contain wildcards
	jz	nowilds 			; No, continue processing
	mov	dx,offset trangroup:inornot_ptr ; Yes, report error
	jmp	Cerror
nowilds:
	mov	ax,ExtOpen SHL 8		;AC000; open the file
	mov	bx,read_open_mode		;AN000; get open mode for TYPE
	xor	cx,cx				;AN000; no special files
	mov	dx,read_open_flag		;AN000; set up open flags
	mov	si,offset trangroup:srcbuf	;AN030; get file name
	int	21h
	jnc	typecont			; If open worked, continue. Otherwise load

Typerr: 					;AN022;
	push	cs				;AN022; make sure we have local segment
	pop	ds				;AN022;
	invoke	set_ext_error_msg		;AN022;
	mov	string_ptr_2,offset trangroup:srcbuf ;AC022; get address of failed string
	mov	Extend_buf_sub,one_subst	;AC022; put number of subst in control block
	jmp	cerror				;AC022; exit

typecont:
	mov	bx,ax				;AC000; get  Handle
;M043
; We should do the LSEEK for filesize only if this handle belongs to a file
;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
;indicate it is a device.
;
	mov	ax,(IOCTL shl 8) or 0
	int	21h

	test	dl,80h				;is it a device?
	jz	not_device			;no, a file

	mov	word ptr TypeFilSiz+2,-1 		;indicate it is a device
	jmp	short dotype
not_device:

;SR;
; Find the filesize by seeking to the end and then reset file pointer to
;start of file
;
	mov	ax,(LSEEK shl 8) or 2
	xor	dx,dx
	mov	cx,dx				;seek  to end of file
	int	21h

	mov	word ptr TypeFilSiz,ax
	mov	word ptr TypeFilSiz+2,dx		;store filesize

	mov	ax,(LSEEK shl 8) or 0
	xor	dx,dx
	int	21h	              			;reset file pointer to start
dotype:						;M043
	mov	zflag,0 			; Reset ^Z flag
	mov	ds,[TPA]
	xor	dx,dx
ASSUME	DS:NOTHING

typelp:
	cmp	cs:[zflag],0			;AC050; Is the ^Z flag set?
	retnz					; Yes, return
	mov	cx,cs:[bytcnt]			;AC056; No, continue
;
;Update the filesize left to read
;
	cmp	word ptr cs:TypeFilSiz+2,-1	;is it a device? M043
	je	typ_read			;yes, just read from it; M043

	cmp	word ptr cs:TypeFilSiz+2,0		;more than 64K left?
	jz	lt64k				;no, do word subtraction
	sub	word ptr cs:TypeFilSiz, cx
	sbb	word ptr cs:TypeFilSiz+2, 0 	;update filesize
      	jmp	short typ_read			;do the read
lt64k:
	cmp	cx,word ptr cs:TypeFilSiz		;readsize <= buffer?
	jbe	gtbuf				;yes, just update readsize
;
;Buffer size is larger than bytes to read
;
	mov	cx,word ptr cs:TypeFilSiz
	jcxz	typelp_ret
	mov	word ptr cs:TypeFilSiz,0
	jmp	short typ_read
gtbuf:
	sub	word ptr cs:TypeFilSiz,cx	   	;update filesize remaining
typ_read:
	mov	ah,read
	int	21h
	jnc	@f				;M043
	jmp	typerr				;M043
@@:						;M043
;M043;	jc	typerr				;AN022; Exit if error

	mov	cx,ax
	jcxz	typelp_ret			;AC000; exit if nothing read
	push	ds
	pop	es				; Check to see if a ^Z was read.
assume es:nothing
	xor	di,di
	push	ax
	mov	al,1ah
	repnz	scasb
	pop	ax
	xchg	ax,cx
	cmp	ax,0
	jnz	foundz				; Yes, handle it
	cmp	byte ptr [di-1],1ah		; No, double check
	jnz	typecont2			; No ^Z, continue

foundz:
	sub	cx,ax				; Otherwise change cx so that only those
	dec	cx				;  bytes up to but NOT including the ^Z
	push	cs				;  will be typed.
	pop	es
assume es:trangroup
	not	zflag				; Turn on ^Z flag so that the routine

typecont2:					;  will quit after this write.
	push	bx
	mov	bx,1
	mov	ah,write
	int	21h
	pop	bx
	jc	Error_outputj
	cmp	ax,cx
	jnz	@f				;M043
	jmp	typelp				;M043
@@:						;M043
;M043;	jz	typelp
	dec	cx
	cmp	ax,cx
	retz					; One less byte OK (^Z)

Error_outputj:
	mov	bx,1
	mov	ax,IOCTL SHL 8
	int	21h
	test	dl,devid_ISDEV
	retnz					; If device, no error message
	jmp	error_output

typelp_ret:
	ret

	break	Volume
assume	ds:trangroup,es:trangroup

;
; VOLUME command displays the volume ID on the specified drive
;
VOLUME:

	mov	si,81H
	mov	di,offset trangroup:parse_vol	;AN000; Get adderss of PARSE_VOL
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	OkVolArg			;AC000; Yes, display default volume ID
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	BadVolArg			;AC000; Yes, fail.
;
; We have parsed off the drive.  See if there are any more chars left
;

	mov	di,offset trangroup:parse_vol	;AC000; get address of parse_vol
	xor	dx,dx				;AC000;
	invoke	parse_check_eol 		;AC000; call parser
	jz	OkVolArg			;AC000; yes, end of road
;
; The line was not interpretable.  Report an error.
;
badvolarg:
	jmp	Cerror




;***	DisAppend - disable APPEND
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX,BX
;
;	EFFECTS
;
;	  APPEND is disabled.  If it was active, it will be re-enabled
;	  after the command finishes, by the HeadFix routine.
;
;	NOTE
;
;	  This routine must not be called more than once during a single
;	  command cycle.  The second call would permanently disable APPEND.

DisAppend	proc

	assume	ds:TRANGROUP,es:NOTHING

	push	ds			; save DS
	push	es			; save ES
	push	di

	mov	ax,APPENDINSTALL	; AX = Append Installed Check code
	int	2Fh			; talk to APPEND via multiplex
	or	al,al
	jz	daRet			; APPEND not installed, return

	mov	ax,APPENDDOS		; AX = Get Append Version code
	int	2Fh			; talk to APPEND via multiplex
	cmp	ax,0FFFFh
	jne	daRet			; it's not a local version, return

	mov	ax,APPENDGETSTATE	; AX = Get Function State code
	int	2Fh			; talk to APPEND via multiplex

	mov	ds,ResSeg		; DS = resident seg addr

	assume	ds:RESGROUP

	mov	Append_State,bx		; Append_State = saved APPEND state
	mov	Append_Flag,-1		; Append_Flag = true, restore state

	xor	bx,bx			; BX = APPEND state = off
	mov	AX,APPENDSETSTATE	; AX = Set Append State code
	int	2Fh			; talk to APPEND via multiplex

daRet:	pop	di
	pop	es			; restore ES
	pop	ds			; restore DS

	assume	ds:TRANGROUP

	ret

DisAppend	endp



;
; Find the Volume ID on the disk.
;
PUBLIC	OkVolArg
OKVOLARG:
	assume	ds:TRANGROUP,es:TRANGROUP

	call	DisAppend			; disable APPEND
	invoke	crlf2
	mov	al,blank			;AN051; Print out a blank
	invoke	print_char			;AN051;   before volume message
	push	ds
	pop	es
;
; Volume IDs are only findable via extended FCBs or find_first with attributes
; of volume_id ONLY.
;

	mov	di,FCB-7			; Point to extended FCB beginning
	mov	al,-1				; Tag to indicate Extention
	stosb
	xor	ax,ax				; Zero padding to volume label
	stosw
	stosw
	stosb
	mov	al,attr_volume_ID		; Look for volume label
	stosb
	inc	di				; Skip drive byte; it is already set
	mov	cx,11				; fill in remainder of file
	mov	al,'?'
	rep	stosb
;
; Set up transfer address (destination of search first information)
;
	mov	dx,offset trangroup:dirbuf
	mov	ah,set_DMA
	int	21h
;
; Do the search
;
	mov	dx,FCB-7
	mov	ah,Dir_Search_First
	int	21h

;********************************
; Print volume ID info

	push	ax				;AC000; AX return from SEARCH_FIRST for VOL ID
	mov	al,DS:[FCB]			;AC000; get drive letter
	add	al,'@'
	cmp	al,'@'
	jnz	drvok
	mov	al,[curdrv]
	add	al,capital_A
drvok:
	mov	vol_drv,al			;AC000; get drive letter into argument
	pop	ax				;AC000; get return code back
	or	al,al				;AC000; volume label found?
	jz	Get_vol_name			;AC000; volume label exists - go get it
	mov	dx,offset trangroup:VolMes_ptr_2 ;AC000; set up no volume message
	jmp	short print_serial		;AC000; go print it

Get_vol_name:
	mov	di,offset trangroup:charbuf
	mov	dx,di
	mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
	mov	cx,11				;AN000;  3/3/KK
	rep	movsb				;AN000;  3/3/KK

	xor	al,al				;AC000; store a zero to terminate the string
	stosb
	mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message

PRINT_SERIAL:

;
; Attempt to get the volume serial number from the disk.  If an error
; occurs, do not print volume serial number.
;

	push	dx				;AN000; save message offset
	mov	ax,(GetSetMediaID SHL 8)	;AC036; Get the volume serial info
	mov	bl,DS:[FCB]			;AN000; get drive number from FCB
	mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
	int	21h			;AN000; do the call
	pop	dx				;AN000; get message offset back
	jc	printvol_end			;AN000; if error, just go print label
	call	std_printf			;AC000; go print volume message
	mov	al,blank			;AN051; Print out a blank
	invoke	print_char			;AN051;   before volume message
	mov	dx,offset trangroup:VolSerMes_ptr ;AN000; get serial number message

printvol_end:
	jmp	std_printf			;AC000; go print and exit


;****************************************************************
;*
;* ROUTINE:	Set_ext_error_msg
;*
;* FUNCTION:	Sets up extended error message for printing
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	extended error message set up in extended error
;*		buffer.
;*
;****************************************************************

Set_ext_error_msg proc near			;AN000;

	call	get_ext_error_number		;AC022; get the extended error
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN000; get message number in control block
	stc					;AN000; make sure carry is set

	ret					;AN000; return

Set_ext_error_msg endp				;AN000;

;****************************************************************
;*
;* ROUTINE:	Get_ext_error_number
;*
;* FUNCTION:	Does get extended error function call
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	AX - extended error number
;*
;****************************************************************

Get_ext_error_number proc near			;AN022;

	SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>	;AN022; save registers
	mov	ah,GetExtendedError		;AN022; get extended error
	xor	bx,bx				;AN022; clear BX
	int	21h			;AN022;
	RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>	;AN022; restore registers

	ret					;AN022; return

Get_ext_error_number endp			;AN022;

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\stub.asm ===
page ,132
	title	Command Stub 
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M003	SR	07/16/90	Check if UMB loading enabled and if so
;				turn it off on return from Exec
;
;	M005	SR	07/20/90	Carousel hack. Added a hard-coded far
;				jump to the actual int 2fh entry 
;				point to fix Carousel problems.
;
;	M009	SR	08/01/90	Restore the UMB state before the Exec
;				from the saved state in LoadHiFlg.
;
;	M035	SR	10/27/90	Enable interrupts at the start of
;				the dispatch code. Otherwise interrupts
;				remain disabled through a whole
;				shitload of code which is not good.
;
;	M049	SR	1/16/91	Bug #5075. Reworked the scheduling
;				strategy. There is no common
;				dispatcher now. Each entry point
;				now checks A20 and then does a far
;				jump to the appropriate code. This
;				added about 15 bytes of code but the
;				speed increase and reentrancy are
;				well worth the price.
;



;
;This file contains the low memory stub for command.com which hooks all the
;entry points into the resident command.com and directs the calls to the
;appropriate routines in the resident code which may be located in HIMEM. 
;	The stub has been made part of the resident data and will always
;be duplicated on every invocation of command.com. However, the only stubs
;that actually hook the interrupt vectors belong to either the first 
;command.com or to any other command.com executed with the /p switch. 
;	The stub also keeps track of the current active data segment. The 
;INIT code of each command.com updates this variable via an int 2fh mechanism
;with its own data segment. The INIT code also updates a pointer in its data
;segment to the previous resident data segment. Whenever a command.com exits,
;the exit code picks up the previous data segment pointer from the current
;data segment and patches it into the CurResDataSeg variable in the stub.
;	Right now the stub does not bother about A20 switching. We assume
;A20 is always on. It just does a far jump to the resident code with the 
;value of the current data segment in one of the registers. A20 toggle 
;support maybe added as a future enhancement, if the need is felt.
;


        include versiona.inc
	include comseg.asm
	include xmm.inc

INIT	segment

	extrn	ConProc:near

INIT	ends

CODERES	segment

	extrn	MsgInt2fHandler	:near
	extrn	Int_2e		:near
	extrn	Contc		:near
	extrn	DskErr		:near

CODERES	ends

DATARES	segment
	assume	cs:DATARES,ds:nothing,es:nothing,ss:nothing
	Org	0
ZERO	=	$

	Org	100h
ProgStart:
	jmp	RESGROUP:ConProc

;
; Make following table word-aligned, and at the same time, provide a
; signature that sysinit can use to (attempt to) validate the interpreter
;
        db      ((major_version AND 0Fh) SHL 4) OR (minor_version AND 0Fh)

;
;All the entry points declared below are patched in at INIT time with the
;proper segment and offset values after the resident code segment has been
;moved to its final location
;
public	Int2f_Entry, Int2e_Entry, Ctrlc_Entry, CritErr_Entry, Lodcom_Entry
public	Exec_Entry, RemCheck_Entry, TrnLodCom1_Entry, MsgRetrv_Entry
public	HeadFix_Entry
public	XMMCallAddr, ComInHMA

;!!!WARNING!!!
; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
;in the correct segments and offsets
;

Int2f_Entry 	label 	dword
		dw	offset RESGROUP:MsgInt2fHandler	;Address of int 2fh handler
		dw	0

Int2e_Entry 	label	dword
		dw	offset RESGROUP:Int_2e ;Address of int 2eh handler
		dw	0

Ctrlc_Entry	label	dword
		dw	offset RESGROUP:ContC ;Address of Ctrl-C handler
		dw	0

CritErr_Entry	label	dword
		dw	offset RESGROUP:DskErr ;Address of critical error handler
		dw	0

Exec_Entry	dd	?	;Entry from transient to Ext_Exec
RemCheck_Entry	dd	?	;Entry from transient to TRemCheck
TrnLodCom1_Entry	dd	?	;Entry from transient to LodCom1
LodCom_Entry	dd	?	;Entry after exit from command.com
MsgRetrv_Entry	dd	?	;Entry from external to MsgRetriever
HeadFix_Entry	dd	?	;Entry from trans to HeadFix

UMBOff_Entry	dd	?	;Entry from here to UMBOff routine; M003

XMMCallAddr	dd	?	;Call address for XMM functions
ComInHMA		db	0	;Flags if command.com in HMA

public	Int2f_Trap, Int2e_Trap, Ctrlc_Trap, CritErr_Trap
public	Exec_Trap, RemCheck_Trap, LodCom_Trap, MsgRetrv_Trap, TrnLodcom1_Trap
public	HeadFix_Trap


Int2f_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	Int2f_Entry

Int2e_Trap:
	sti
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	Int2e_Entry

Ctrlc_Trap:
	sti
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	Ctrlc_Entry

CritErr_Trap:
	sti
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	CritErr_Entry

Exec_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	Exec_Entry

RemCheck_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	RemCheck_Entry

TrnLodCom1_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	TrnLodCom1_Entry

LodCom_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	LodCom_Entry

MsgRetrv_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	MsgRetrv_Entry

HeadFix_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	HeadFix_Entry

CheckA20	proc

	pushf				;save current flags
	cmp	cs:ComInHMA,0		;is resident in HMA?
	jz	A20_on			;no, jump to resident

	call	QueryA20
	jnc	A20_on			;A20 is on, jump to resident

	call	EnableA20		;turn A20 on
A20_on:
	popf				;flags have to be unchanged
	ret

CheckA20	endp


;
; M005; This is a far jump to the actual int 2fh entry point. The renormalized
; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
; M005; handler. Note that we have to hardcode a jump and we cannot use any
; M005; pointers because our cs is going to be different. The segment to
; M005; jump to is patched in at init time. (in init.asm)
;

public Carousel_i2f_Hook		; M005
Carousel_i2f_Hook:			; M005
	db	0eah			; far jump opcode; M005
	dw	offset DATARES:Int2f_Trap	; int 2fh offset ; M005
	dw	?			; int 2fh segment; M005


QueryA20	proc	near

	push	bx
	push	ax
	mov	ah, XMM_QUERY_A20
	call	cs:XMMCallAddr
	or	ax, ax
	pop	ax
	pop	bx
	jnz	short QA20_ON			; AX = 1 => ON

	stc					; OFF
	ret
QA20_ON:
	clc					; ON
	ret

QueryA20	endp



EnableA20	proc	near

	push	bx
	push	ax
	mov	ah, XMM_LOCAL_ENABLE_A20
	call	cs:XMMCallAddr
	or	ax, ax
	jz	XMMerror		; AX = 0 fatal error
	pop	ax
	pop	bx
	ret
;
;If we get an error, we just loop forever
;
XMMerror:
	jmp	short XMMerror
	
EnableA20	endp

;
; -----------------------------------------------------------------------------
;
HV_Extern	equ	1
HV_LoadHigh	equ	1
HV_Stub		equ	1
	include	highvar.inc	; Make high-memory variables external here
	include	highexit.inc	; And add code for UnHideUMBs
;
; -----------------------------------------------------------------------------
;

;
;The Exec call has to be issued from the data segment. The reason for this 
;is TSRs. When a TSR does a call to terminate and stay resident, the call
;returns with all registers preserved and so all our segment registers are
;still set up. However, if the TSR unloads itself later on, it still 
;comes back here. In this case the segment registers and the stack are
;not set up and random things can happen. The only way to setup all the 
;registers is to use the cs value and this can only be done when we are in
;the data segment ourselves. So, this piece of code had to be moved from
;the code segment to the data segment.
;

	extrn	RStack:WORD

public 	Issue_Exec_Call
Issue_Exec_Call:
	int 	21h
;
;We disable interrupts while changing the stack because there is a bug in 
;some old 8088 processors where interrupts are let through while ss & sp
;are being changed.
;
	cli
	push	cs
	pop	ss
	mov	sp,offset DATARES:RStack	;stack is set up
	sti
	push	cs
	pop	ds			;ds = DATARES

; M009; Restore UMB state to that before Exec

	pushf				;    This call frees HIDDEN umb's,
	call	UnHideUMBs		; <- restores the memory-allocation
	popf				;    strategy and link state, as app.

;We now jump to the stub trap which returns us to the resident code. All
;flags are preserved by the stub code.
;
	jmp	Exec_Trap


DATARES	ends
	end	ProgStart



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tcode.asm ===
page ,132
;	SCCSID = @(#)tcode.asm	1.1 85/05/14
;	SCCSID = @(#)tcode.asm	1.1 85/05/14
TITLE	Part1 COMMAND Transient Routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M025	SR	9/12/90	Removed calls to SetStdInOn,SetStdInOff
;				SetStdOutOn & SetStdOutOff.
;


.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include comseg.asm
	include comequ.asm
.list
.cref


CODERES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	EXEC_WAIT:NEAR
CODERES ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BATCH:WORD
	EXTRN	CALL_BATCH_FLAG:byte
	EXTRN	CALL_FLAG:BYTE
	EXTRN	ECHOFLAG:BYTE
	EXTRN	envirseg:word
	EXTRN	EXTCOM:BYTE
	EXTRN	FORFLAG:BYTE
	EXTRN	IFFLAG:BYTE
	EXTRN	next_batch:word
	EXTRN	nullflag:byte
	EXTRN	PIPEFILES:BYTE
	EXTRN	PIPEFLAG:BYTE
	EXTRN	RE_OUT_APP:BYTE
	EXTRN	RE_OUTSTR:BYTE
	EXTRN	RESTDIR:BYTE
        EXTRN   SINGLECOM:WORD
        EXTRN   SEMIPERMCOM:WORD
	EXTRN	VERVAL:WORD
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BadNam_Ptr:word 	;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	APPEND_EXEC:BYTE	;AN041;
	EXTRN	ARG1S:WORD
	EXTRN	ARG2S:WORD
	EXTRN	ARGTS:WORD
	EXTRN	BYTCNT:WORD
	EXTRN	COMBUF:BYTE
	EXTRN	COMSW:WORD
	EXTRN	CURDRV:BYTE
	EXTRN	HEADCALL:DWORD
	EXTRN	IDLEN:BYTE
	EXTRN	INTERNATVARS:BYTE
	EXTRN	PARM1:BYTE
	EXTRN	PARM2:BYTE
	EXTRN	RE_INSTR:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	SPECDRV:BYTE
	EXTRN	STACK:WORD
	EXTRN	SWITCHAR:BYTE
	EXTRN	TPA:WORD
	EXTRN	UCOMBUF:BYTE
	EXTRN	USERDIR1:BYTE
	IF  IBM_ROM_FIND
	EXTRN	ROM_CALL:BYTE
	EXTRN	ROM_CS:WORD
	EXTRN	ROM_IP:WORD
	ENDIF

TRANSPACE	ENDS

; ********************************************************************
; START OF TRANSIENT PORTION
; This code is loaded at the end of memory and may be overwritten by
; memory-intensive user programs.

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	$EXIT:NEAR
	EXTRN	DRVBAD:NEAR
	EXTRN	EXTERNAL:NEAR
	EXTRN	FNDCOM:NEAR
	EXTRN	FORPROC:NEAR
	EXTRN	PIPEPROC:NEAR
	EXTRN	PIPEPROCSTRT:NEAR

	PUBLIC	COMMAND
	PUBLIC	DOCOM
	PUBLIC	DOCOM1
	PUBLIC	NOPIPEPROC
	PUBLIC	TCOMMAND

	IF  IBM_ROM_FIND
	PUBLIC	ROM_EXEC
	PUBLIC	ROM_SCAN
	ENDIF

	ORG	0
ZERO	=	$

	ORG	100H				; Allow for 100H parameter area

SETDRV:
	MOV	AH,SET_DEFAULT_DRIVE
	INT	21h
;
; TCOMMAND is the recycle point in COMMAND.  Nothing is known here.
; No registers (CS:IP) no flags, nothing.
;

TCOMMAND:
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	AX,-1
	XCHG	AX,[VERVAL]
	CMP	AX,-1
	JZ	NOSETVER2
	MOV	AH,SET_VERIFY_ON_WRITE		; AL has correct value
	INT	21h

NOSETVER2:
	CALL	[HEADCALL]			; Make sure header fixed
	XOR	BP,BP				; Flag transient not read
	CMP	[SINGLECOM],-1
	JNZ	COMMAND

$EXITPREP:
	PUSH	CS
	POP	DS
	JMP	$EXIT				; Have finished the single command
ASSUME	DS:NOTHING
;
; Main entry point from resident portion.
;
;   If BP <> 0, then we have just loaded transient portion otherwise we are
;   just beginning the processing of another command.
;

COMMAND:

;
; We are not always sure of the state of the world at this time.  We presume
; worst case and initialize the relevant registers: segments and stack.
;
	ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
	CLD
	MOV	AX,CS
	CLI
	MOV	SS,AX
ASSUME	SS:TRANGROUP
	MOV	SP,OFFSET TRANGROUP:STACK
	STI
	MOV	ES,AX
	MOV	DS,AX				;AN000; set DS to transient
ASSUME	ES:TRANGROUP,DS:TRANGROUP		;AC000;
	invoke	TSYSLOADMSG			;AN000; preload messages
	mov	append_exec,0			;AN041; set internal append state off

	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP

	MOV	[UCOMBUF],COMBUFLEN		; Init UCOMBUF
	MOV	[COMBUF],COMBUFLEN		; Init COMBUF (Autoexec doing DATE)
;
; If we have just loaded the transient, then we do NOT need to initialize the
; command buffer.  ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????  I
; guess not:  the only circumstances in which we reload the command processor
; is after a transient program execution.  In this case, we let the current
; directory lie where it may.
;
	OR	BP,BP				; See if just read
	JZ	TESTRDIR			; Not read, check user directory
	MOV	WORD PTR [UCOMBUF+1],0D01H	; Reset buffer
	JMP	SHORT NOSETBUF

TESTRDIR:
	CMP	[RESTDIR],0
	JZ	NOSETBUF			; User directory OK
	PUSH	DS
;
; We have an unusual situation to handle.  The user *may* have changed his
; directory as a result of an internal command that got aborted.  Restoring it
; twice may not help us:  the problem may never go away.  We just attempt it
; once and give up.
;
	MOV	[RESTDIR],0			; Flag users dirs OK
	PUSH	CS
	POP	DS
ASSUME	DS:TRANGROUP
	MOV	DX,OFFSET TRANGROUP:USERDIR1
	MOV	AH,CHDIR
	INT	21h			; Restore users directory
	POP	DS
ASSUME	DS:RESGROUP

NOSETBUF:
	CMP	[PIPEFILES],0
	JZ	NOPCLOSE			; Don't bother if they don't exist
	CMP	[PIPEFLAG],0
	JNZ	NOPCLOSE			; Don't del if still piping
	INVOKE	PIPEDEL

NOPCLOSE:
	MOV	[EXTCOM],0			; Flag internal command
	MOV	AX,CS				; Get segment we're in
	MOV	DS,AX
ASSUME	DS:TRANGROUP

	PUSH	AX
	MOV	DX,OFFSET TRANGROUP:INTERNATVARS
	MOV	AX,INTERNATIONAL SHL 8
	INT	21H
	POP	AX
	SUB	AX,[TPA]			; AX=size of TPA in paragraphs
	PUSH	BX
	MOV	BX,16
	MUL	BX				; DX:AX=size of TPA in bytes
	POP	BX
	OR	DX,DX				; See if over 64K
	JZ	SAVSIZ				; OK if not
	MOV	AX,-1				; If so, limit to 65535 bytes

SAVSIZ:
;
; AX is the number of bytes free in the buffer between the resident and the
; transient with a maximum of 64K-1.  We round this down to a multiple of 512.
;
	CMP	AX,512
	JBE	GotSize
	AND	AX,0FE00h			; NOT 511 = NOT 1FF

GotSize:
	MOV	[BYTCNT],AX			; Max no. of bytes that can be buffered
	MOV	DS,[RESSEG]			; All batch work must use resident seg.
ASSUME	DS:RESGROUP

	TEST	[ECHOFLAG],1
	JZ	GETCOM				; Don't do the CRLF
	INVOKE	SINGLETEST
	JB	GETCOM
	TEST	[PIPEFLAG],-1
	JNZ	GETCOM
	TEST	[FORFLAG],-1			; G  Don't print prompt in FOR
	JNZ	GETCOM				; G
	TEST	[BATCH], -1			; G  Don't print prompt if in batch
	JNZ	GETCOM				; G
	INVOKE	CRLF2

GETCOM:
	MOV	CALL_FLAG,0			; G Reset call flags
	MOV	CALL_BATCH_FLAG,0		; G
	MOV	AH,GET_DEFAULT_DRIVE
	INT	21h
	MOV	[CURDRV],AL
	TEST	[PIPEFLAG],-1			; Pipe has highest presedence
	JZ	NOPIPE
	JMP	PIPEPROC			; Continue the pipeline

NOPIPE:
	TEST	[ECHOFLAG],1
	JZ	NOPDRV				; No prompt if echo off
	INVOKE	SINGLETEST
	JB	NOPDRV
	TEST	[FORFLAG],-1			; G  Don't print prompt in FOR
	JNZ	NOPDRV				; G
	TEST	[BATCH], -1			; G  Don't print prompt if in batch
	JNZ	TESTFORBAT			; G
	INVOKE	PRINT_PROMPT			; Prompt the user

NOPDRV:
	TEST	[FORFLAG],-1			; FOR has next highest precedence
	JZ	TESTFORbat
	JMP	FORPROC 			; Continue the FOR

TESTFORBAT:
	MOV	[RE_INSTR],0			; Turn redirection back off
	MOV	[RE_OUTSTR],0
	MOV	[RE_OUT_APP],0
	MOV	IFFlag,0			; no more ifs...
	TEST	[BATCH],-1			; Batch has lowest precedence
	JZ	ISNOBAT

;	Bugbug:	MULT_SHELL_GET no longer used?
	push	es				;AN000; save ES
	push	ds				;AN000; save DS
	mov	ax,mult_shell_get		;AN000; check to see if SHELL has command
	mov	es,[batch]			;AN000; get batch segment
	mov	di,batfile			;AN000; get batch file name
	push	cs				;AN000; get local segment to DS
	pop	ds				;AN000;
	mov	dx,offset trangroup:combuf	;AN000; pass communications buffer
	int	2fh				;AN000; call the shell
	cmp	al,shell_action 		;AN000; does shell have a commmand?
	pop	ds				;AN000; restore DS
	pop	es				;AN000; restore ES
	jz	jdocom1 			;AN000; yes - go process command

	PUSH	DS				;G
	INVOKE	READBAT 			; Continue BATCH
	POP	DS				;G
	mov	nullflag,0			;G reset no command flag
	TEST	[BATCH],-1			;G
	JNZ	JDOCOM1 			;G if batch still in progress continue
	MOV	BX,NEXT_BATCH			;G
	CMP	BX,0				;G see if there is a new batch file
	JZ	JDOCOM1 			;G no - go do command
	MOV	BATCH,BX			;G get segment of next batch file
	MOV	NEXT_BATCH,0			;G reset next batch
JDOCOM1:
	PUSH	CS				;G
	POP	DS				;G
	JMP SHORT DoCom1			; echoing already done

ISNOBAT:
	CMP	[SINGLECOM],0
	JZ	REGCOM
        MOV     SI,[SEMIPERMCOM]
	XCHG	SI,[SINGLECOM]
	MOV	DI,OFFSET TRANGROUP:COMBUF + 2
	XOR	CX,CX

SINGLELOOP:
	LODSB
	STOSB
	INC	CX
	CMP	AL,0DH
	JNZ	SINGLELOOP
	DEC	CX
	PUSH	CS
	POP	DS
ASSUME	DS:TRANGROUP
	MOV	[COMBUF + 1],CL
;
; do NOT issue a trailing CRLF...
;
	JMP	SHORT DOCOM1

;
; We have a normal command.  
; Printers are a bizarre quantity.  Sometimes they are a stream and
; sometimes they aren't.  At this point, we automatically close all spool
; files and turn on truncation mode.
;

REGCOM:
	MOV	AX,(ServerCall SHL 8) + 9
	INT	21h
	MOV	AX,(ServerCall SHL 8) + 8
	MOV	DL,1
	INT	21h

	PUSH	CS
	POP	DS				; Need local segment to point to buffer
	MOV	DX,OFFSET TRANGROUP:UCOMBUF

;	Try to read interactive command line via DOSKey.
;	If that fails, use DOS Buffered Keyboard Input.

	mov	ax,4810h		; AX = DOSKey Read Line function
	int	2fh
	or	ax,ax
	jz	GotCom			; DOSKey gave us a command line

	mov	ah,STD_CON_STRING_INPUT	; AH = DOS Buffered Keyboard Input
	int	21h			; call DOS

GotCom:
	MOV	CL,[UCOMBUF]
	XOR	CH,CH
	ADD	CX,3
	MOV	SI,OFFSET TRANGROUP:UCOMBUF
	MOV	DI,OFFSET TRANGROUP:COMBUF
	REP	MOVSB				; Transfer it to the cooked buffer

;---------------

transpace   segment
    extrn   arg:byte				; the arg structure!
transpace   ends
;---------------


DOCOM:
	INVOKE	CRLF2

DOCOM1:
	INVOKE	PRESCAN 			; Cook the input buffer
	JZ	NOPIPEPROC
	JMP	PIPEPROCSTRT			; Fire up the pipe

nullcomj:
	jmp	nullcom

NOPIPEPROC:
	invoke	parseline
	jnc	OkParse 			; user error?  or maybe we goofed?

BadParse:
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET TRANGROUP:BADNAM_ptr
	INVOKE	std_eprintf
	JMP	TCOMMAND

OkParse:
	test	arg.argv[0].argflags, MASK wildcard
	jnz	BadParse			; ambiguous commands not allowed
	cmp	arg.argvcnt, 0			; there WAS a command, wasn't there?
	jz	nullcomj
	cmp	arg.argv[0].arglen, 0		; probably an unnecessary check...
	jz	nullcomj			; guarantees argv[0] at least x<NULL>

	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	MOV	DI,OFFSET TRANGROUP:IDLEN
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H ; Make FCB with blank scan-off
	INT	21h
	mov	BX, arg.argv[0].argpointer
	cmp	BYTE PTR [BX+1],':'             ; was a drive specified?
	jne	short drvgd			; no, use default of zero...

	mov	DL, BYTE PTR [BX]		; pick-up drive letter
	and	DL, NOT 20H			; uppercase the sucker
	sub	DL, capital_A			; convert it to a drive number, A=0

	CMP	AL,-1				; See what PARSE said about our drive letter.
	JZ	drvbadj2			; It was invalid.

	mov	DI, arg.argv[0].argstartel
	cmp	BYTE PTR [DI], 0		; is there actually a command there?
	jnz	drvgd				; if not, we have:  "d:", "d:\", "d:/"
	jmp	setdrv				; and set drive to new drive spec

drvbadj2:
	jmp	drvbad

DRVGD:
	MOV	AL,[DI]
	MOV	[SPECDRV],AL
	MOV	AL,' '
	MOV	CX,9
	INC	DI
	REPNE	SCASB				; Count no. of letters in command name
	MOV	AL,8
	SUB	AL,CL
	MOV	[IDLEN],AL			; IDLEN is truly the length
	MOV	DI,81H
	PUSH	SI

	mov	si, OFFSET TRANGROUP:COMBUF+2	; Skip over all leading delims
	invoke	scanoff
;SR;
; We are going to skip over the first char always. The logic is that the
;command tail can never start from the first character. The code below is 
;trying to figure out the command tail and copy it to the command line 
;buffer in the PSP. However, if the first character happens to be a switch
;character and the user given command line is a full 128 bytes, we try to
;copy 128 bytes to the PSP while it can take only 127 chars. This extra
;char overwrites the code and leads to a crash on future commands.
;

	inc	si

do_skipcom:
	lodsb					; move command line pointer over
	invoke	delim				; pathname -- have to do it ourselves
	jz	do_skipped			; 'cause parse_file_descriptor is dumb
	cmp	AL, 0DH 			; can't always depend on argv[0].arglen
	jz	do_skipped			; to be the same length as the user-
	cmp	AL, [SWITCHAR]			; specified command string
	jnz	do_skipcom

do_skipped:
	dec	SI
	XOR	CX,CX

COMTAIL:
	LODSB
	STOSB					; Move command tail to 80H
	CMP	AL,13
	LOOPNZ	COMTAIL
	DEC	DI
	MOV	BP,DI
	NOT	CL
	MOV	BYTE PTR DS:[80H],CL
	POP	SI

;-----
; Some of these comments are sadly at odds with this brave new code.
;-----
; If the command has 0 parameters must check here for
; any switches that might be present.
; SI -> first character after the command.

	mov	DI, arg.argv[0].argsw_word
	mov	[COMSW], DI			; ah yes, the old addressing mode problem...
	mov	SI, arg.argv[1 * SIZE argv_ele].argpointer  ; s = argv[1];
	OR	SI,SI				;   if (s == NULL)
	JNZ	DoParse
	MOV	SI,BP				;	s = bp; (buffer end)

DoParse:
	MOV	DI,FCB
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
	INT	21h
	MOV	[PARM1],AL			; Save result of parse

	mov	DI, arg.argv[1*SIZE argv_ele].argsw_word
	mov	[ARG1S], DI
	mov	SI, arg.argv[2*SIZE argv_ele].argpointer    ; s = argv[2];
	OR	SI,SI				;   if (s == NULL)
	JNZ	DoParse2
	MOV	SI,BP				;	s = bp; (bufend)1

DoParse2:
	MOV	DI,FCB+10H
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
	INT	21h			; Parse file name
	MOV	[PARM2],AL			; Save result

	mov	DI, arg.argv[2*SIZE argv_ele].argsw_word
	mov	[ARG2S], DI
	mov	DI, arg.argv[0].argsw_word
	not	DI				; ARGTS doesn't include the flags
	and	DI, arg.argswinfo		; from COMSW...
	mov	[ARGTS], DI

	MOV	AL,[IDLEN]
	MOV	DL,[SPECDRV]
	or	DL, DL				; if a drive was specified...
	jnz	externalj1			; it MUST be external, by this time
	dec	al				; (I don't know why -- old code did it)
	jmp	fndcom				; otherwise, check internal com table

externalj1:
	jmp	external

nullcom:
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	TEST	[BATCH], -1			;G Are we in a batch file?
	JZ	nosetflag			;G only set flag if in batch
	mov	nullflag,nullcommand		;G set flag to indicate no command

nosetflag:
	CMP	[SINGLECOM],-1
	JZ	EXITJ
	JMP	GETCOM

EXITJ:
	JMP	$EXITPREP

IF IBM_ROM_FIND
	include vector.inc
	include pdb.inc
	include arena.inc
	include mshalo.asm
ENDIF

TRANCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tcmd2b.asm ===
page ,132
;	SCCSID = @(#)tcmd2b.asm 4.1 85/09/22
;	SCCSID = @(#)tcmd2b.asm 4.1 85/09/22
TITLE	PART5 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include pdb.inc
	include mult.inc
	include comseg.asm
	include comequ.asm
.list
.cref


;;CODERES 	SEGMENT PUBLIC BYTE	;AC000;
;;	EXTRN	LODCOM1:NEAR
;;CODERES ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	crit_msg_off:word	;AC000;
	EXTRN	crit_msg_seg:word	;AC000;
	EXTRN	IO_SAVE:WORD
	EXTRN	OldTerm:DWORD
	EXTRN	PARENT:WORD
;AD060; EXTRN	pars_msg_off:word	;AC000;
;AD060; EXTRN	pars_msg_seg:word	;AC000;
	EXTRN	PERMCOM:BYTE		;AN045;
	EXTRN	RetCode:WORD
	EXTRN	SingleCom:word

	extrn	TrnLodCom1_Trap:far

DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	ACRLF_PTR:WORD		;AN007;
	EXTRN	baddev_ptr:word
	EXTRN	CP_active_Ptr:word
	EXTRN	CP_not_all_Ptr:word
	EXTRN	CP_not_set_Ptr:word
	EXTRN	Extend_buf_ptr:word	;AN000;
	EXTRN	Extend_buf_sub:byte	;AN000;
	EXTRN	inv_code_page:word	;AC000;
	EXTRN	msg_disp_class:byte	;AN000;
	EXTRN	NLSFUNC_Ptr:word	;AC000;
	EXTRN	parse_chcp:byte 	;AC000;
	EXTRN	parse_chdir:byte	;AC000;
	EXTRN	parse_ctty:byte 	;AC000;
	EXTRN	string_buf_ptr:word	;AC000;

	extrn	NoCntry_Ptr:word	;M045

TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	COMBUF:BYTE
	EXTRN	parse_last:word 	;AN018;
	EXTRN	parse1_addr:dword	;AC000;
	EXTRN	parse1_type:byte	;AC000;
	EXTRN	RESSEG:WORD
	EXTRN	srcbuf:byte
	EXTRN	srcxname:byte		;AC000;
	EXTRN	string_ptr_2:word
	EXTRN	system_cpage:word
	EXTRN	TRAN_TPA:WORD
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
TRANSPACE	ENDS
;---------------

	EXTRN	cerror:near
	extrn	TCommand:near

	PUBLIC	$exit
	PUBLIC	chcp
	PUBLIC	ctty
	PUBLIC	parse_check_eol 	;AN000;
	PUBLIC	parse_with_msg		;AN018;
	PUBLIC	setup_parse_error_msg	;AN018;
	PUBLIC	truename		;AN000;

	break	Ctty
assume	ds:trangroup,es:trangroup

; ****************************************************************
; *
; * ROUTINE:	 CTTY - Change console
; *
; * SYNTAX:	 CTTY device
; *
; * FUNCTION:	 If a valid console device is specified, CTTY will
; *		 duplicate the device handle to STDIN, STDOUT and
; *		 STDERR.  This routine returns to LODCOM1.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

CTTY:
	push	ds				;AN000; Get local ES
	pop	es				;AN000;
	mov	si,81H				;AC000; Get command argument for CTTY

	mov	di,offset trangroup:parse_ctty	;AC000; Get adderss of PARSE_CTTY
	xor	cx,cx				;AC000; clear cx,dx
	xor	dx,dx				;AC000;
	invoke	cmd_parse			;AC000; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?
	jz	ctty_error			;AN000; yes - error
	cmp	ax,result_no_error		;AN000; did an error occur
	jnz	ctty_error			;AN000; YES -ERROR

	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of filespec
	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf

ctty_move_filename:				;AN000; put filespec in srcbuf
	lodsb					;AN000; get a char from buffer
	stosb					;AN000; store in srcbuf
	cmp	al,end_of_line_out		;AN000; it char a terminator?
	jnz	ctty_move_filename		;AN000; no - keep moving
	pop	si				;AN000; get line position back
	mov	di,offset trangroup:parse_ctty	;AC000; Get adderss of PARSE_CTTY
	call	parse_check_eol 		;AN000; are we at end of line?
	jz	nocolon 			;AN000; yes - continue

ctty_error:
	jmp	short isbaddev			;AC000; yes - exit

nocolon:
	mov	dx,offset trangroup:srcbuf	;AN000; get address of srcbuf
	MOV	AX,(OPEN SHL 8) OR 2		; Read and write
	INT	21h			; Open new device
	JC	ISBADDEV
	MOV	BX,AX
	MOV	AX,IOCTL SHL 8
	INT	21h
	TEST	DL,80H
	JNZ	DEVISOK

CLOSEDEV:					;AN007;
	MOV	AH,CLOSE			; Close initial handle
	INT	21h

ISBADDEV:
	MOV	DX,OFFSET TRANGROUP:BADDEV_ptr
	invoke	std_printf
	JMP	SHORT RESRET

DEVISOK:
	push	dx				;AN007; save device info
	mov	ax,acrlf_ptr			;AN021; get message number for 0d, 0a
	mov	dh,util_msg_class		;AN021; this is a utility message
	push	bx				;AN021; save handle
	invoke	Tsysgetmsg			;AN021; get the address of the message
	mov	dx,si				;AN021; get address into dx
	mov	ax,(write shl 8)		;AN007; write to device
	mov	cx,2				;AN007; write two bytes
	int	21h			;AN007;
	pop	bx				;AN021; get back handle
	pop	dx				;AN007; get back device info
	jc	closedev			;AN007; if error, quit
	XOR	DH,DH
	OR	DL,3				; Make sure has CON attributes
	MOV	AX,(IOCTL SHL 8) OR 1
	INT	21h
	PUSH	BX				; Save handle
	MOV	CX,3
	XOR	BX,BX

ICLLOOP:					; Close basic handles
	MOV	AH,CLOSE
	INT	21h
	INC	BX
	LOOP	ICLLOOP
	POP	BX				; Get handle
	MOV	AH,XDUP
	INT	21h			; Dup it to 0
	MOV	AH,XDUP
	INT	21h			; Dup to 1
	MOV	AH,XDUP
	INT	21h			; Dup to 2
	MOV	AH,CLOSE			; Close initial handle
	INT	21h

RESRET:
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	PUSH	DS
	MOV	AX,WORD PTR DS:[PDB_JFN_Table]	; Get new 0 and 1
	MOV	[IO_SAVE],AX
	MOV	AX,OFFSET DATARES:TrnLodCom1_Trap
	PUSH	AX

ZMMMM	PROC FAR
	RET					; Force header to be checked
ZMMMM	ENDP

	break	Chcp

;****************************************************************
;*
;* ROUTINE:	CHCP - Change code page internal command
;*		(added DOS 3.30 07/21/86)
;*
;* SYNTAX:	CHCP [xxx]
;*		where xxx is a valid code page
;*
;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
;*		6402H to set the code page to xxxx. If no parameters
;*		are specified, CHCP will use INT 21H function 6401H
;*		to get global code page and display it to the user.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	none
;*
;****************************************************************

NLSFUNC_installed	equ    0ffh
set_global_cp		equ    2
get_global_cp		equ    1

assume	ds:trangroup,es:trangroup

CHCP:
	push	ds				;AN000; Get local ES
	pop	es				;AN000;
	mov	si,81H				;AC000; Get command argument for CHCP

	mov	di,offset trangroup:parse_chcp	;AN000; Get adderss of PARSE_CHCP
	xor	cx,cx				;AC000; clear cx,dx
	xor	dx,dx				;AC000;
	call	parse_with_msg			;AC018; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?

;;	jnz	setcp				;AC000; no go get number & set code page
	jz	getcp				;AC000; yes - no parm - get code page

setcp:
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	cp_error			;AC018; yes - go issue message

	push	cx				;AN000; save positional count
	mov	bx,offset trangroup:parse1_addr ;AN000; get number returned
	mov	cx,word ptr [bx]		;AN000;     into cx
	mov	system_cpage,cx 		;AN000; save user input number
	pop	cx				;AC000; restore positional count
	mov	di,offset trangroup:parse_chcp	;AN000; Get adderss of PARSE_CHCP
	call	parse_check_eol 		;AN000; are we at end of line?
	jnz	cp_error			;AC000; no - exit

okset:
	mov	ah,NLSFUNC			;AN000; see if NLSFUNC installed
	mov	al,0				;AN000;
	int	2fh				;AN000;
	cmp	al,NLSFUNC_installed		;AN000;
	jz	got_NLS 			;AN000; Yes - continue
	mov	dx,offset trangroup:NLSFUNC_ptr ;AN000; no - set up error message
	jmp	short cp_error			;AN000; error exit

got_NLS:
	mov	bx,system_cpage 		;AN000; get user input code page
	mov	ah,getsetcdpg			;get/set global code page function
	mov	al,set_global_cp		;minor - set
	int	21h
	jnc	chcp_return			;no error - exit
;
;added for p716
;
	cmp	ax,error_file_not_found 	;p716 was the error file not found?
	jnz	chcp_other_error		;no - country.sys was found

	mov	ah,GetExtendedError		;p850 see if error is invalid data
	xor	bx,bx				;  which is file was found but CP
	int	21h			;  information was not found.
	cmp	ax,error_invalid_data		;AC000; invalid code page
	jnz	no_countrysys			;no - use file not found
	mov	dx,offset trangroup:inv_code_page ;AN000; get message
	jmp	short cp_error			;AC000; error exit

no_countrysys:
;M045;	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
;M045;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
;M045;	mov	Extend_Buf_ptr,error_file_not_found ;AN000; get message number in control block
	
	mov	dx,offset TRANGROUP:NoCntry_Ptr	;M045

	jmp	short cp_error			;AC000; error exit

chcp_other_error:
;
; end of p716
;
	mov	ah,GetExtendedError		;error - see what it is
	xor	bx,bx
	int	21h
	cmp	ax,65				;was it access denied?
	jnz	none_set			;no - assume all failed
	mov	dx,offset trangroup:cp_not_all_ptr ;set up message
	jmp	short cp_error			;AC000; error exit

none_set:
	mov	dx,offset trangroup:cp_not_set_ptr ;set up message
cp_error:					;AN000;
	jmp	cerror				;exit

getcp:
	mov	ah,getsetcdpg			;get/set global code page function
	mov	al,get_global_cp		;minor - get
	int	21h
	mov	system_cpage,bx 		;get active cp for output
	mov	dx,offset trangroup:cp_active_ptr
	invoke	std_printf			;print it out

chcp_return:

	RET

	break	TRUENAME			;AN000;


; ****************************************************************
; *
; * ROUTINE:	 TRUENAME
; *
; * FUNCTION:	 Entry point for the internal TRUENAME command.
; *		 Parses the command line. If a path is found, set
; *		 SRCXNAME to path.  If only a drive letter is
; *		 found, set SRCXNAME to the drive letter.  If
; *		 no path is found, set the path of SRCXNAME to
; *		 dot (.) for current directory.  Use the NAME
; *		 TRANSLATE system call to get the real name and
; *		 then display the real name.  If an error occurs
; *		 issue an error message and transfer control to
; *		 CERROR.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup		;AN000;

TRUENAME:					;AN000; TRUENAME entry point
	push	ds				;AN000; Get local ES
	pop	es				;AN000;
	mov	si,81H				;AN000; Get command line
	mov	di,offset trangroup:parse_chdir ;AN000; Get adderss of PARSE_CHDIR
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	call	parse_with_msg			;AC018; call parser

	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
	cmp	ax,end_of_line			;AN000; are we at end of line?
	je	tn_eol				;AN000; yes - go process
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	tn_parse_error			;AN000; yes - go issue message
	cmp	parse1_type,result_drive	;AN000; was a drive entered?
	je	tn_drive			;AN000; yes - go process
	jmp	short tn_filespec		;AN000; nothing else - must be filespec

tn_eol: 					;AN000; no parameters on line
	mov	ah,end_of_line_out		;AN000; set buffer to .
	mov	al,dot_chr			;AN000;     for current dir
	stosw					;AN000; store in srcxname
	jmp	short tn_doit			;AN000; go do command

tn_drive:					;AN000; a drive was entered
	push	si				;AN000; save position in line
	mov	si,offset trangroup:parse1_addr ;AN000; get address of drive
	lodsb					;AN000; get the drive number
	add	al,"A"-1                        ;AN000; convert it to char
	stosb					;AN000; store it in srcxname
	mov	ax,dot_colon			;AN000; get colon and . and
	stosw					;AN000;    store in srcxname
	mov	al,end_of_line_out		;AN000; put a terminator char
	stosb					;AN000;
	pop	si				;AN000; get line position back
	jmp	short tn_check_eol		;AN000; check to make sure eol

tn_filespec:					;AN000; a filespec was entered
	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of filespec

tn_move_filename:				;AN000; put filespec in srcxname
	lodsb					;AN000; get a char from buffer
	stosb					;AN000; store in srcxname
	cmp	al,end_of_line_out		;AN000; it char a terminator?
	jnz	tn_move_filename		;AN000; no - keep moving
	pop	si				;AN000; get line position back

tn_check_eol:					;AN000; make sure no extra parms
	mov	di,offset trangroup:parse_chdir ;AN000; get address of parse_chdir
	call	parse_check_eol 		;AN000; are we at end of line?
	je	tn_doit 			;AN000; Yes - do the command

tn_parse_error: 				;AN000; A parse error occurred
	jmp	cerror				;AN000; Go to error routine

tn_doit:					;AN000;
	mov	si,offset trangroup:srcxname	;AN000; set up srcxname as source
	mov	di,offset trangroup:combuf	;AN000; set up combuf as target (need big target)
	mov	ah,xnametrans			;AN000; do name translate call
	int	21h			;AN000;
	jnc	tn_print_xname			;AN000; If no error - print result

	invoke	Set_ext_error_msg		;AN000; get extended message
	mov	string_ptr_2,offset trangroup:srcxname ;AN000; get address of failed string
	mov	Extend_buf_sub,one_subst	;AN000; put number of subst in control block
	jmp	cerror				;AN000; Go to error routine

tn_print_xname: 				;AN000;
	mov	string_ptr_2,offset Trangroup:combuf ;AN000; Set up address of combuf
	mov	dx,offset trangroup:string_buf_ptr   ;AN000; Set up address of print control block
	invoke	crlf2				;AN000; print a crlf
	invoke	printf_crlf			;AN000; print it out

	ret					;AN000;

	break	$Exit

assume	ds:trangroup,es:trangroup

$EXIT:
	push	ds				;AN000; save data segment
	mov	ds,[resseg]			;AN000; get resident data segment

assume	ds:resgroup				;AN000;

	cmp	[permcom],0			;AN045; is this a permanent COMMAND?
	jz	free_com			;AN045; no - free everything

;	We're a permanent command.
;	Unless this is a singlecom (int 2Eh), don't deallocate transient.

	cmp	[singlecom],-1		;M034
	je	no_reset		;M034	;exit singlecom

	jmp	TCommand			;permanent command, recycle

;AD060; mov	ah,multdos			;AN000; reset parse message pointers
;AD060; mov	al,message_2f			;AN000; call for message retriever
;AD060; mov	dl,set_parse_msg		;AN000; set up parse message address
;AD060; mov	di,pars_msg_off 		;AN000; old offset of parse messages
;AD060; mov	es,pars_msg_seg 		;AN000; old segment of parse messages
;AD060; int	2fh				;AN000; go set it

;AD060; mov	ah,multdos			;AN000; set up to call DOS through int 2fh
;AD060; mov	al,message_2f			;AN000; call for message retriever

free_com:
	mov	ax,(multdos shl 8 or message_2f);AN060; reset parse message pointers
	mov	dl,set_critical_msg		;AN000; set up critical error message address
	mov	di,crit_msg_off 		;AN000; old offset of critical messages
	mov	es,crit_msg_seg 		;AN000; old segment of critical messages
	int	2fh				;AN000; go set it
no_reset:					;AN045;
	pop	ds				;AN000; restore local data segment

assume	ds:trangroup				;AN000;
;
;M040
; Restore user directory if the restore flag is set. RestUDir1 checks for
;this, restores user dir if flag is set and resets the flag.
;
	invoke	RestUDir1		;restore user dir if needed ;M040
	MOV	ES,[RESSEG]

assume	es:resgroup

	MOV	AX,[PARENT]
	MOV	WORD PTR ES:[PDB_Parent_PID],AX
	MOV	AX,WORD PTR OldTerm
	MOV	WORD PTR ES:[PDB_Exit],AX
	MOV	AX,WORD PTR OldTerm+2
	MOV	WORD PTR ES:[PDB_Exit+2],AX

	PUSH	ES
	MOV	ES,[TRAN_TPA]
	MOV	AH,DEALLOC
	INT	21h			; Now running in "free" space
	POP	ES

	MOV	AH,Exit
	MOV	AL,BYTE PTR RetCode
	INT	21h


; ****************************************************************
; *
; * ROUTINE:	 PARSE_CHECK_EOL
; *
; * FUNCTION:	 Calls parser to see if end of line occurred.
; *		 If not end of line, set up to print parse
; *		 error message.  ASSUMES NO MORE PARAMETERS ARE
; *		 EXPECTED!
; *
; * INPUT:	 DS:SI	  last output from parser
; *		 ES:DI	  points to parse block
; *		 CX	  last output from parser
; *
; * OUTPUT:	 AX	  parser return code
; *
; *		 if end of line found
; *		     zero flag set
; *		 else
; *		     MSG_DISPLAY_CLASS set to parse error
; *
; ****************************************************************

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN000;

parse_check_eol Proc near			;AN000;

	xor	dx,dx				;AN000;
	mov	[parse_last],si 		;AN018; save start of parameter
	invoke	cmd_parse			;AN000; call parser
	cmp	al,end_of_line			;AN000; Are we at end of line?
	jz	parse_good_eol			;AN000; yes - no problem

	cmp	ax,result_no_error		;AN018; was any error found?
	jnz	ok_to_setup_pmsg		;AN018; yes - continue
	inc	ax				;AN018; set AX to 1 and turn off zero flag

ok_to_setup_pmsg:
	call	setup_parse_error_msg		;AN018; go set up error message

parse_good_eol:
	ret					;AN000;

parse_check_eol endp				;AN000;

; ****************************************************************
; *
; * ROUTINE:	 PARSE_WITH_MSG
; *
; * FUNCTION:	 Calls parser.	If an error occurred, the error
; *		 message is set up.
; *
; * INPUT:	 DS:SI	  last output from parser
; *		 ES:DI	  points to parse block
; *		 CX	  last output from parser
; *
; * OUTPUT:	 AX	  parser return code
; *
; *		 if no error
; *		     outputs from parser
; *		 else
; *		     MSG_DISPLAY_CLASS set to parse error
; *		     error message set up for STD_PRINTF
; *
; ****************************************************************

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;

parse_with_msg	Proc near			;AN018;

	mov	[parse_last],si 		;AN018; save start of parameter
	invoke	cmd_parse			;AN018; call parser
	cmp	al,end_of_line			;AN018; Are we at end of line?
	jz	parse_msg_good			;AN018; yes - no problem
	cmp	ax,result_no_error		;AN018; did an error occur
	jz	parse_msg_good			;AN018; yes - no problem

	call	setup_parse_error_msg		;AN018; go set up error message

parse_msg_good:
	ret					;AN018;

parse_with_msg endp				;AN018;

; ****************************************************************
; *
; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
; *
; * FUNCTION:	 Calls parser.	If an error occurred, the error
; *		 message is set up.
; *
; * INPUT:	 AX	     Parse error number
; *		 SI	     Set to past last parameter
; *		 Parse_last  Set to start of last parameter
; *
; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
; *		 error message set up for STD_PRINTF
; *
; ****************************************************************

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;

SETUP_PARSE_ERROR_MSG	Proc near		;AN018;

	mov	msg_disp_class,parse_msg_class	;AC018; Set up parse message class
	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC018; get extended message pointer
	mov	byte ptr [si],end_of_line_out	;AC018; terminate the parameter string
	mov	Extend_Buf_ptr,ax		;AC018; get message number in control block
	cmp	ax,lessargs_ptr 		;AC018; if required parameter missing
	jz	Setup_parse_msg_ret		;AN018;    no subst
	mov	si,[parse_last] 		;AC018; get start of parameter
	mov	string_ptr_2,si 		;AC018; get address of failed string
	mov	Extend_buf_sub,one_subst	;AC018; put number of subst in control block

setup_parse_msg_ret:
	inc	si				;AN018; make sure zero flag not set

	ret					;AC018;

SETUP_PARSE_ERROR_MSG	Endp			;AN018;

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tbatch2.asm ===
page ,132
;	SCCSID = @(#)tbatch2.asm	4.2 85/07/22
;	SCCSID = @(#)tbatch2.asm	4.2 85/07/22
TITLE	Batch processing routines part II
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M020	SR	08/20/89	Changed GetBatByt to check if we
;				already reached EOF before trying
;				to read from batchfile. Also fixed
;				old bug of ds not being setup on an 
;				error while reading the batchfile.
;
;	M037	SR	11/1/90	Bug #1745 & #3438 fixed. On a GOTO, we
;				reseek to the beginning of the
;				batchfile. Clear the BatchEOF flag
;				to indicate that we are no longer at
;				EOF.
;

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BATCH:WORD
	EXTRN	Batch_Abort:byte
	EXTRN	call_batch_flag:byte
	EXTRN	call_flag:byte
	EXTRN	IFFlag:BYTE
	EXTRN	In_Batch:byte
	EXTRN	Nest:word
	EXTRN	PIPEFILES:BYTE
	EXTRN	RETCODE:WORD
	EXTRN	SINGLECOM:WORD

;;;	extrn	BatchEOF:byte
	extrn	EchoFlag:byte
	extrn	Next_Batch:word
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADLAB_PTR:WORD
	EXTRN	BatBufLen:WORD
	EXTRN	IFTAB:BYTE
	EXTRN	SYNTMES_PTR:WORD
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
	EXTRN	BatBuf:BYTE
	EXTRN	BatBufEnd:WORD
	EXTRN	BatBufPos:WORD
	EXTRN	BATHAND:WORD
	EXTRN	COMBUF:BYTE
	EXTRN	DIRBUF:BYTE
	EXTRN	GOTOLEN:WORD
	EXTRN	if_not_count:word
	EXTRN	IFNOTFLAG:BYTE
	EXTRN	RESSEG:WORD
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near
	EXTRN	docom1:near
	EXTRN	tcommand:near

	public	$if,iferlev,goto,shift,ifexists,ifnot,forerror,$call


Break	<GetBatByt - retrieve a byte from the batch file>

; Get one byte from the batch file and return it in AL.  End-of-file returns
; <CR> and ends batch mode.  DS must be set to resident segment.
; AH, DX destroyed.

Procedure   GETBATBYT,NEAR

ASSUME	DS:RESGROUP

	SaveReg <BX,CX,DS>
	test	byte ptr [Batch_Abort],-1
	jz	@f
	jmp	BatEOF
@@:
	TEST	Batch,-1
	JnZ	@f
	jmp	BatEOF
@@:
	PUSH	ES
	MOV	ES,Batch
	ASSUME	ES:NOTHING

;M020;
;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
;try to read from the batchfile again.
;
	cmp	es:BatchEOF,0			;already reached EOF? ;M020
	jz	not_eof			;no, read batch file ;M020
	jmp	At_EOF				;yes, no more reads ;M020
not_eof:						;M020

	ADD	WORD PTR ES:[BatSeek],1
	ADC	WORD PTR ES:[BatSeek+2],0
	POP	ES
;
; See if we have bytes buffered...
;
	MOV	AX,CS
	MOV	DS,AX
	ASSUME	DS:TranGroup
	MOV	BX,BatBufPos
	CMP	BX,-1
	JNZ	UnBuf
;
; There are no bytes in the buffer.  Let's try to fill it up.
;
	MOV	DX,OFFSET TranGROUP:BatBuf
	MOV	CX,BatBufLen			; max to read.
	MOV	BX,BatHand
	MOV	AH,READ
	INT	21h			; Get one more byte from batch file
	jnc	bat_read_ok			;AN022; if no error - continue
	invoke	get_ext_error_number		;AN022; get the error
	push	ds				;AN022; save local segment
	mov	ds,[resseg]			;AN022; get resident segment
assume	ds:resgroup				;AN022;
	mov	dx,ax				;AN022; put error in DX
	invoke	output_batch_name		;AN022; set up to print the error
	pop	ds				;AN022;
assume	ds:trangroup				;AN022;
	invoke	std_eprintf			;AN022; print out the error
	mov	byte ptr combuf+2,end_of_line_in;AN022; terminate the batch line for parsing
	mov	byte ptr combuf+3,end_of_line_out ;AN022; terminate the batch line for output
;M020;
;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
;error is never hit (and it shouldn't be)
;
	mov	ds,ResSeg			; ds = RESGROUP ; M020

	jmp	short bateof			;AN022; terminate the batch file

bat_read_ok:					;AN022;
	MOV	CX,AX
	JCXZ	BATEOFDS
	MOV	BatBufEnd,CX
	XOR	BX,BX
	MOV	BatBufPos,BX
;
; Buffered bytes!
;
UnBuf:
	MOV	AL,BatBuf[BX]			; get next byte
	INC	BX
	CMP	BX,BatBufEnd			; beyond end of buffer?
	JB	SetBufPos
	MOV	BX,-1

SetBufPos:
	MOV	BatBufPos,BX
	CMP	AL,1AH				; ^Z for termination?
	jnz	GetByteDone
;
;We get here only when we hit an EOF
;
BatEOFDS:
;SR;
; HACK!!! A massive hack being put in here to get batch processing to work
;properly on EOF. Previously, a CR was returned and batch processing turned
;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
;batch processing is turned off before the last line is processed and so 
;this line would never be executed. 
;   	To fix this, a new flag BatchEOF has been introduced. This flag is
;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
;at the buffer contents. If there is no LF ( we assume that presence of LF
;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
;fake CR to the caller. This decrements BatchEOF. On the next call to this
;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
;third call, BatchEOF becomes zero and batch processing is turned off,
;now that the last line has been processed. If the EOF is the first char read into the buffer 
;during this call, and there was a CR-LF previously, we are going to fake
;another redundant CR-LF. There is no work-around I can think of.
; 	I would love to restructure this entire routine and its caller to
;make the flow really easy to understand but I guess this will have to wait.
;
	push	es
	mov	es,ResSeg
;SR;
; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
;or BatchEOF == 1 now), then do not do the LF check.
;
	mov	es,es:Batch
	cmp	es:BatchEOF,0
	jnz	crpresent

	inc	es:BatchEOF			;match the dec following
	mov	bx,BatBufEnd
	cmp	BatBuf[bx-1],0ah			;was a LF present?
	je	crpresent			;yes, no need to fake it

	add	es:BatchEOF,3			;BatchEOF == 4 to fake CR-LF

crpresent:
;;;	pop	es

	ASSUME	DS:TranGroup
	MOV	DS,ResSeg
	ASSUME	DS:ResGroup

;SR;
; The shift operation is done here to replace the decrement. This is because
;we can jump to this label directly from above when bogus calls are made to
;this routine even after batch processing is turned off. The shift ensures
;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
;it is used as a decrement and also as a NOP to just fall through on bogus 
;calls.
;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
;turning batch processing off.
;
At_EOF:						;new label added ;M020
	shr	es:BatchEOF,1			;decrement the flag
	jz	turn_off			;zero,turn batch off
	cmp	es:BatchEOF,1				
	jz	ret_lf				;BatchEOF was 2, return LF
;
;BatchEOF == 4, indicates return fake CR now and fake LF next.
;
	mov	al,0dh				;return fake CR.
	pop	es
	jmp	short GetByteDone
ret_lf:
	mov	al,0ah				;return fake LF
	pop	es
	jmp	short	GetByteDone			
turn_off:
	pop	es

BATEOF:
	invoke	BatchOff			;turn batch processing off
	CALL	BATCLOSE
;;;	mov	BatchEOF,0			;make sure BatchEOF = 0

;SR; BugBug
; There is a good reason why this carriage return is being returned here. 
;This was part of the old code, thanks to some brain-damaged coding. Because,
;of the way the caller is structured, a fake CR has to be returned again on
;EOF to ensure the termination of the caller's loop. If echo is on, this
;results in an extra linefeed after the batchfile is run if the last line of
;the batchfile already had a CR-LF. 
;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
;the end-of-line. This CR is to mark the end-of-file.
;
	MOV	AL,0dH				; If end-of-file, then end of line

	test	byte ptr [Batch_Abort],-1
	mov	byte ptr [Batch_Abort],0
	jz	Cont_Get_Byt
	mov	di,offset TRANGROUP:COMBUF+2	; reset pointer to beginning of buffer
	xor	cx,cx				; zero line length
	jmp	short GetByteDone

Cont_Get_Byt:
	CMP	[SINGLECOM],0FFF0H		; See if we need to set SINGLECOM
	JNZ	GetByteDone
	CMP	NEST,0				;G See if we have nested batch files
	JNZ	GETBYTEDONE			;G Yes - don't exit just yet
	MOV	[SINGLECOM],-1			; Cause termination

GetByteDone:
	RestoreReg  <DS,CX,BX>

	return

EndProc GetBatByt

	break	<$If - conditional execution>
assume	ds:trangroup,es:trangroup

IFERRORP:
	POP	AX
IFERROR:
FORERROR:
	MOV	DX,OFFSET TRANGROUP:SYNTMES_ptr
	JMP	CERROR

$IF:
;
; Turn off any pipes in progress.
;
	push	ds				;AN004; save local DS
	mov	ds,[resseg]			;AN004; get resident segment
	assume	ds:resgroup			;AN004;
	cmp	[PIPEFILES],0			;AN004; Only turn off if present.
	jz	IFNoPipe			;AN004; no pipe - continue
	invoke	PipeDel 			;AN004; turn off piping

IFNoPipe:					;AN004;
	pop	ds				;AN004; get local DS back
	assume	ds:trangroup			;AN004;
	MOV	[IFNOTFLAG],0
	mov	[if_not_count], 0
	MOV	SI,81H

IFREENT:
	invoke	SCANOFF
	CMP	AL,0DH
	JZ	IFERROR
	MOV	BP,SI
	MOV	DI,OFFSET TRANGROUP:IFTAB	; Prepare to search if table
	MOV	CH,0

IFINDCOM:
	MOV	SI,BP
	MOV	CL,[DI]
	INC	DI
	JCXZ	IFSTRING
	JMP	SHORT FIRSTCOMP

IFCOMP:
	JNZ	IF_DIF				;AC000;

FIRSTCOMP:
	LODSB
	MOV	AH,ES:[DI]
	INC	DI
	CMP	AL,AH
	JZ	IFLP
	OR	AH,20H				; Try lower case
	CMP	AL,AH

IFLP:
	LOOP	IFCOMP

IF_DIF: 					;AC000;
	LAHF
	ADD	DI,CX				; Bump to next position without affecting flags
	MOV	BX,[DI] 			; Get handler address
	INC	DI
	INC	DI
	SAHF
	JNZ	IFINDCOM
	LODSB
	CMP	AL,0DH

IFERRORJ:
	JZ	IFERROR
	invoke	DELIM
	JNZ	IFINDCOM
	invoke	SCANOFF
	JMP	BX

IFNOT:
	NOT	[IFNOTFLAG]
	inc	[if_not_count]
	JMP	IFREENT

;
; We are comparing two strings for equality.  First, find the end of the
; first string.
;

IFSTRING:
	PUSH	SI				; save away pointer for later compare
	XOR	CX,CX				; count of chars in first string

FIRST_STRING:
	LODSB					; get character
	CMP	AL,0DH				; end of line?
	JZ	IFERRORP			; yes => error
	invoke	DELIM				; is it a delimiter?
	JZ	EQUAL_CHECK			; yes, go find equal sign
	INC	CX				; remember 1 byte for the length
	JMP	FIRST_STRING			; go back for more
;
; We have found the end of the first string.  Unfortunately, we CANNOT use
; scanoff to find the next token; = is a valid separator and will be skipped
; over.
;

EQUAL_CHECK:
	CMP	AL,'='                          ; is char we have an = sign?
	JZ	EQUAL_CHECK2			; yes, go find second one.
	CMP	AL,0DH				; end of line?
	JZ	IFERRORPj			;AC004; yes, syntax error
	LODSB					; get next char
	JMP	EQUAL_CHECK
;
; The first = has been found.  The next char had better be an = too.
;

EQUAL_CHECK2:
	LODSB					; get potential = char
	CMP	AL,'='                          ; is it good?
	jnz	iferrorpj			; no, error
;
; Find beginning of second string.
;
	invoke	SCANOFF
	CMP	AL,0DH
	jz	iferrorpj
	POP	DI
;
; DS:SI points to second string
; CX has number of chars in first string
; ES:DI points to first string
;
; Perform compare to elicit match
;
	REPE	CMPSB
	JZ	MATCH				; match found!
;
; No match.  Let's find out what was wrong.  The character that did not match
; has been advanced over.  Let's back up to it.
;
	DEC	SI
;
; If it is EOL, then syntax error
;
	CMP	BYTE PTR [SI],0DH
	JZ	IFERRORJ
;
; Advance pointer over remainder of unmatched text to next delimiter
;

SKIPSTRINGEND:
	LODSB

NOTMATCH:
	CMP	AL,0DH

IFERRORJ2:
	JZ	IFERRORJ
	invoke	DELIM
	JNZ	SKIPSTRINGEND
;
; Signal that we did NOT have a match
;
	MOV	AL,-1
	JMP	SHORT IFRET

iferrorpj:
	jmp	iferrorp
;
; The compare succeeded.  Was the second string longer than the first?	We
; do this by seeing if the next char is a delimiter.
;

MATCH:
	LODSB
	invoke	DELIM
	JNZ	NOTMATCH			; not same.
	XOR	AL,AL
	JMP	SHORT IFRET

IFEXISTS:
ifexist_attr	    EQU     attr_hidden+attr_system

moredelim:
	lodsb					; move command line pointer over
	invoke	delim				; pathname -- have to do it ourselves
	jnz	moredelim			; 'cause parse_file_descriptor is dumb
	mov	DX, OFFSET TRANGROUP:dirbuf
	trap	set_dma
	mov	BX, 2				; if(0) [|not](|1) exist[1|2] file(2|3)
	add	BX, [if_not_count]
	mov	AX, OFFSET TRANGROUP:arg.argv
	invoke	argv_calc			; convert arg index to pointer
	mov	DX, [BX].argpointer		; get pointer to supposed filename
	mov	CX, ifexist_attr		; filetypes to search for
	trap	Find_First			; request first match, if any
	jc	if_ex_c 			; carry is how to determine error
	xor	AL, AL
	jmp	short ifret

if_ex_c:
	mov	AL, -1				; false 'n' fall through...

IFRET:
	TEST	[IFNOTFLAG],-1
	JZ	REALTEST
	NOT	AL

REALTEST:
	OR	AL,AL
	JZ	IFTRUE
	JMP	TCOMMAND

IFTRUE:
	invoke	SCANOFF
	MOV	CX,SI
	SUB	CX,81H
	SUB	DS:[80H],CL
	MOV	CL,DS:[80H]
	MOV	[COMBUF+1],CL
	MOV	DI,OFFSET TRANGROUP:COMBUF+2
	CLD
	REP	MOVSB
	MOV	AL,0DH
	STOSB
;
; Signal that an IF was done.  This prevents the redirections from getting
; lost.
;
	PUSH	DS
	MOV	DS,ResSeg
	ASSUME	DS:RESGROUP
	MOV	IFFlag,-1
	POP	DS
	ASSUME	DS:TRANGROUP
;
; Go do the command
;
	JMP	DOCOM1

iferrorj3:
	jmp	iferrorj2

IFERLEV:
	MOV	BH,10
	XOR	BL,BL

GETNUMLP:
	LODSB
	CMP	AL,0DH
	jz	iferrorj3
	invoke	DELIM
	JZ	GOTNUM
	SUB	AL,'0'
	XCHG	AL,BL
	MUL	BH
	ADD	AL,BL
	XCHG	AL,BL
	JMP	SHORT GETNUMLP

GOTNUM:
	PUSH	DS
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	AH,BYTE PTR [RETCODE]
	POP	DS
ASSUME	DS:TRANGROUP
	XOR	AL,AL
	CMP	AH,BL
	JAE	IFRET
	DEC	AL
	JMP	SHORT IFRET


	break	<Shift - advance arguments>

;
; Shift the parameters in the batch structure by 1 and set up the new argument.
; This is a NOP if no batch in progress.
;

Procedure   Shift,NEAR

assume	ds:trangroup,es:trangroup

	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	AX,[BATCH]			; get batch pointer
	OR	AX,AX				; in batch mode?
	retz					; no, done.
	MOV	ES,AX				; operate in batch segment
	MOV	DS,AX

ASSUME	DS:NOTHING,ES:NOTHING

;
; Now move the batch args down by 1 word
;
	MOV	DI,BatParm			; point to parm table
	LEA	SI,[DI+2]			; make source = dest + 2
	MOV	CX,9				; move 9 parameters
	REP	MOVSW				; SHIFT down
;
; If the last parameter (the one not moved) is empty (= -1) then we are done.
; We have copied it into the previous position
;
	CMP	WORD PTR [DI],-1		; if last one was not in use then
	retz					; No new parm
;
; This last pointer is NOT nul.  Get it and scan to find the next argument.
; Assume, first, that there is no next argument
;
	MOV	SI,[DI]
	MOV	WORD PTR [DI],-1		; Assume no parm
;
; The parameters are CR separated.  Scan for end of this parm
;
SKIPCRLP:
	LODSB
	CMP	AL,0DH
	JNZ	SKIPCRLP
;
; We are now pointing at next arg.  If it is 0 (end of original line) then we
; are finished.  There ARE no more parms and the pointer has been previously
; initialized to indicate it.
;
	CMP	BYTE PTR [SI],0
	retz					; End of parms
	MOV	[DI],SI 			; Pointer to next parm as %9

	return

EndProc Shift

;
; Skip delim reads bytes from the batch file until a non-delimiter is seen.
; returns char in AL, carry set -> eof
;

Procedure   SkipDelim,NEAR

	ASSUME	DS:ResGroup,ES:NOTHING
	TEST	Batch,-1
	JZ	SkipErr 			; batch file empty.  OOPS!
	CALL	GetBatByt			; get a char
	invoke	Delim				; check for ignoreable chars
	JZ	SkipDelim			; ignore this char.
	clc
	return

SkipErr:
	stc
	return

EndProc SkipDelim

	break  $Call

;  CALL is an internal command that transfers control to a .bat, .exe, or
;  .com file.  This routine strips the CALL off the command line,  sets
;  the CALL_FLAG to indicate a call in progress, and returns control to
;  DOCOM1 in TCODE to reprocess the command line and execute the file
;  being CALLed.

$CALL:

;  strip off CALL from command line

	ASSUME DS:trangroup,ES:trangroup
	push	si
	push	di
	push	ax
	push	cx
	mov	si,offset trangroup:combuf+2
	invoke	scanoff 			;get to first non-delimeter
	add	si,length_call			;point to char past CALL
	mov	di,offset trangroup:combuf+2
	mov	cx,combuflen-length_call	;get length of buffer
	rep	movsb				;move it
	pop	cx
	pop	ax
	pop	di
	pop	si


;  set call flag to indicate call in progress

	push	ds
	mov	ds,[resseg]
	ASSUME DS:resgroup,ES:resgroup
	mov	call_flag, call_in_progress
	mov	call_batch_flag, call_in_progress
;
; Turn off any pipes in progress.
;
	cmp	[PIPEFILES],0			; Only turn off if present.
	jz	NoPipe
	invoke	PipeDel
NoPipe:
	pop	ds

	ret

	break	Goto

GOTO:

	assume	ds:trangroup,es:trangroup
	MOV	DS,[RESSEG]
	assume	ds:resgroup
	TEST	[BATCH],-1
	retz					; If not in batch mode, a nop
	XOR	DX,DX
	PUSH	DS
	MOV	DS,Batch
	MOV	WORD PTR DS:[BatSeek],DX	; Back to start
	MOV	WORD PTR DS:[BatSeek+2],DX	; Back to start
;M037
; Clear EOF indicator because we have reseeked to the beginning of the file.
;
	mov	ds:BatchEOF,0		; clear eof indicator ;M037

	POP	DS

GotoOpen:
	invoke	promptBat
	MOV	DI,FCB+1			; Get the label
	MOV	CX,11
	MOV	AL,' '
	REPNE	SCASB
	JNZ	NOINC
	INC	CX

NOINC:
	SUB	CX,11
	NEG	CX
	MOV	[GOTOLEN],CX
;
; At beginning of file.  Skip to first non-delimiter char
;
	CALL	SkipDelim
	JC	BadGoto
	CMP	AL,':'
	JZ	CHKLABEL

LABLKLP:					; Look for the label
	CALL	GETBATBYT
	CMP	AL,0AH
	JNZ	LABLKTST
;
; At beginning of line.  Skip to first non-delimiter char
;
	CALL	SkipDelim
	JC	BadGoto
	CMP	AL,':'
	JZ	CHKLABEL

LABLKTST:
	TEST	[BATCH],-1
	JNZ	LABLKLP

BadGoto:
	CALL	BATCLOSE
;SR;
; At this point we are terminating without freeing up any nested batch 
;segments i.e if the error occurred within a called batch file. This routine
;will traverse the linked list of batch segments and free all of them.
;
	call	free_batch		;free up nested batch segments

	PUSH	CS
	POP	DS
	MOV	DX,OFFSET TRANGROUP:BADLAB_ptr
	JMP	CERROR

;
; Found the :.	Skip to first non-delimiter char
;

CHKLABEL:
	CALL	SkipDelim
	JC	BadGoto
	MOV	DI,FCB+1
	MOV	CX,[GOTOLEN]
	JMP	SHORT GotByte

NEXTCHRLP:
	PUSH	CX
	CALL	GETBATBYT
	POP	CX

GotByte:
	INVOKE	TESTKANJ			;AN000;  3/3/KK
	JZ	NOTKANJ1			;AN000;  3/3/KK
	CMP	AL, ES:[DI]			;AN000;  3/3/KK
	JNZ	LABLKTST			;AN000;  3/3/KK
	INC	DI				;AN000;  3/3/KK
	DEC	CX				;AN000;  3/3/KK
	JCXZ	LABLKTST			;AN000;  3/3/KK
	PUSH	CX				;AN000;  3/3/KK
	CALL	GETBATBYT			;AN000;  3/3/KK
	POP	CX				;AN000;  3/3/KK
	CMP	AL, ES:[DI]			;AN000;  3/3/KK
	JMP	SHORT KNEXTLABCHR		;AN000;  3/3/KK

NOTKANJ1:					;AN000;  3/3/KK
	OR	AL,20H
	CMP	AL,ES:[DI]
	JNZ	TRYUPPER
	JMP	SHORT NEXTLABCHR

TRYUPPER:
	SUB	AL,20H
	CMP	AL,ES:[DI]

KNEXTLABCHR:					;AN000;  3/3/KK
	JNZ	LABLKTST

NEXTLABCHR:
	INC	DI
	LOOP	NEXTCHRLP
	CALL	GETBATBYT
	cmp	[GOTOLEN],8			; Is the label atleast 8 chars long?
	jge	gotocont			; Yes, then the next char doesn't matter
	CMP	AL,' '
	JA	LABLKTST

gotocont:
	CMP	AL,0DH
	JZ	SKIPLFEED

TONEXTBATLIN:
	CALL	GETBATBYT
	CMP	AL,0DH
	JNZ	TONEXTBATLIN

SKIPLFEED:
	CALL	GETBATBYT

;SR;
; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
;CR-LF for the last line. On a goto, this flag has to be cleared, because
;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
;to get the EOF has not been made yet because we encountered the Goto. On
;all other cases, EOF will be hit while trying to read the next line and
;we are fine. I know, I know, what a massive hack from hell!! God help us!!
;
	push	es
	mov	es,Batch
	mov	es:BatchEOF,0			;invalidate fake CR-LF flag
	pop	es
	CALL	BatClose

	return

Procedure   BatClose,NEAR
	assume	ds:resgroup

	MOV	BX,CS:[BATHAND]
	CMP	BX,5
	JB	CloseReturn
	MOV	AH,CLOSE
	INT	21h

CloseReturn:
	mov	byte ptr [In_Batch],0		; reset flag
	return

EndProc BatClose

;
; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
; Also, fills internal batch buffer.  If access denied, then AX = -1
;

Procedure   BatOpen,NEAR

ASSUME	DS:RESGROUP,ES:TRANGROUP

	PUSH	DS
	MOV	DS,[BATCH]
ASSUME	DS:NOTHING

	MOV	DX,BatFile
	MOV	AX,OPEN SHL 8
	INT	21h			; Open the batch file
	JC	SETERRDL
	MOV	DX,WORD PTR DS:[BatSeek]
	MOV	CX,WORD PTR DS:[BatSeek+2]
	POP	DS
ASSUME	DS:RESGROUP

	MOV	[BATHAND],AX
	MOV	BX,AX
	MOV	AX,LSEEK SHL 8			; Go to the right spot
	INT	21h
	MOV	BatBufPos,-1			; nuke batch buffer position

	return

SETERRDL:
	MOV	BX,DX
	invoke	get_ext_error_number		;AN022; get the extended error
	mov	dx,ax				;AN022; save extended error in DX
	MOV	AL,[BX] 			; Get drive spec
	SUB	AL,'@'                          ; A = 1
	POP	DS
	STC					; SUB mucked over carry

	return

EndProc BatOpen


;
;Free_batch : This routine traverses the linked batch segments freeing all
;the batch and FOR segments until all of them are freed. It also restores
;the old state of the EchoFlag.
;
;	ENTRY:	ds = RESGROUP
;
;	EXIT: 	All batch & FOR segments freed.
;		EchoFlag restored to old state before batch process.
;
;	REGISTERS AFFECTED: bx, cx


free_batch	proc	near
	assume	ds:RESGROUP,es:nothing

	push	es
	mov	bx,Next_Batch
	or	bx,bx
	jz	fb_ret

ClearBatch:
	mov	es,bx			; get batch segment

	mov	bx,es:BatForPtr		; get old FOR segment
	cmp	bx,0			; is a FOR in progress
	je	no_bat_for		; no - don't deallocate
	push	es			;
	mov	es,bx			; yes - free it up...
	mov	ah,DEALLOC		;
	int	21h			;
	pop	es			; restore to batch segment

No_Bat_For:
	mov	cl,es:BatEchoFlag	; get old echo flag
	mov	bx,es:BatLast	 	; get old batch segment
	mov	ah,DEALLOC		; free it up...
	int	21h
	mov	Batch,bx		; get ready to deallocate next batch
	dec	nest			; is there another batch file?
	jnz	ClearBatch		; keep going until no batch file
	
	mov	EchoFlag,cl		;restore echo status
	mov	Batch,0		;no batch process in progress

fb_ret:
	pop	es
	ret

free_batch	endp


TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tcmd2a.asm ===
page ,132
;	SCCSID = @(#)tcmd2a.asm 4.1 85/06/25
;	SCCSID = @(#)tcmd2a.asm 4.1 85/06/25
TITLE	PART5 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	Revision History
;	================
;	M01	md 7/13/90	Changed CLS to access ROM BIOS data directly
;
;	M013	SR	08/06/90	Changed Version to use new call to
;				get info about DOS in HMA or ROM.
;	M018	md	08/12/90	Increment screen height by 1 when
;					obtained from ROM BIOS.
;	M022	md	08/29/80	Set correct video page in REG_CLS

	INCLUDE comsw.asm

.xlist
.xcref
	include dossym.inc
	include bpb.inc
	include syscall.inc
	include filemode.inc
	include sf.inc
	include comequ.asm
	include comseg.asm
	include ioctl.inc
	include rombios.inc		;M01
.list
.cref


CODERES 	SEGMENT PUBLIC BYTE	;AC000;
CODERES 	ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
DATARES 	ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg_buf_ptr:word
	EXTRN	BadCurDrv:byte		;AC000;
	EXTRN	clsstring:byte
	EXTRN	dback_ptr:word
	EXTRN	display_ioctl:word	;AN000;
	EXTRN	display_width:word	;AN000;
	EXTRN	DosHma_Ptr:word
	EXTRN	DosLow_Ptr:word
	EXTRN	DosRev_Ptr:word
	EXTRN	DosRom_Ptr:word
	EXTRN	Extend_buf_ptr:word	;AN049;
	EXTRN	linperpag:word		;AN000;
	EXTRN	msg_disp_class:byte	;AN049;
	EXTRN	nulpath_ptr:word
	EXTRN	Parse_Ver:byte
	EXTRN	prompt_table:word
	EXTRN	string_buf_ptr:word	;AC000;
	EXTRN	vermes_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	Arg_Buf:byte
	EXTRN	bwdbuf:byte
	EXTRN	curdrv:byte
	EXTRN	dirchar:byte
	EXTRN	major_ver_num:word
	EXTRN	minor_ver_num:word
	EXTRN	One_Char_Val:byte
	EXTRN	srcxname:byte		;AN049;
	EXTRN	string_ptr_2:word
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
transpace	ends
;---------------

	EXTRN	cerror:near		;AN049;
	EXTRN	crlf2:near
	EXTRN	drvbad:near
	EXTRN	std_printf:near

	PUBLIC	build_dir_for_chdir
	PUBLIC	build_dir_for_prompt
	PUBLIC	build_dir_string
	PUBLIC	cls
	PUBLIC	path
	PUBLIC	print_char
	PUBLIC	print_drive
	PUBLIC	print_version
	PUBLIC	print_b
	PUBLIC	print_back
	PUBLIC	print_eq
	PUBLIC	print_esc
	PUBLIC	print_g
	PUBLIC	print_l
	PUBLIC	print_prompt
	PUBLIC	version


	break	Version

;***	Version - display DOS version
;
;	SYNTAX	ver [/debug]
;
;		/debug - display additional DOS configuration info
;
;	ENTRY	command-line tail is in PSP
;
;	EXIT	if successful, nothing
;		if parse fails,
;		  parse error message is set up (for Std_EPrintf)
;		    AX = system parser error code
;		    DX = ptr to message block
;		  we jump to CError
;
;	EFFECTS
;	  If parse fails, a parse error message is displayed.
;	  Otherwise, version message is displayed.
;	  If /debug is specified, additional DOS info is displayed.

Version:
	assume	ds:TRANGROUP,es:TRANGROUP

;	Parse command line for /debug switch.

	mov	si,81h				; DS:SI = ptr to command tail
	mov	di,offset TRANGROUP:Parse_Ver	; ES:DI = ptr to parse block
	xor	cx,cx				; CX = # positional param's found
	invoke	Parse_With_Msg

	mov	bl,1			; BL = flag = /debug present
	cmp	ax,RESULT_NO_ERROR
	je	verPrintVer		; something parsed - must be /debug
	dec	bl			; BL = flag = no /debug present
	cmp	ax,END_OF_LINE
	je	verPrintVer		; reached end of line - ok

;	The parse failed.  Error message has been set up.

	jmp	CError

verPrintVer:
	push	bx			; save /debug flag
	call	Crlf2
	call	Print_Version
	call	Crlf2
	pop	bx   			; BL = /debug flag
	or	bl,bl
	jz	verDone			; /debug is false - we're done

;*	For /debug, display DOS internal revision and DOS location
;	(low memory, HMA, or ROM).

;	Bugbug:	use symbols for bitmasks below.

	mov	ax,(SET_CTRL_C_TRAPPING shl 8) + 6 ; M013
	int	21h
	mov	al,dl			;revision number in dl; M013
	mov	bh,dh			;flags in dh now; M013
;M032	and	al,7			; AL = DOS internal revision
	cmp	al,'Z'-'A'	;M032	; revision in A-to-Z range?
	jbe	@f		;M032	; A-to-Z revision ok
	mov	al,'*'-'A'	;M032	; beyond Z, just say revision *
@@:	add	al,'A'			; AL = DOS internal rev letter
	mov	One_Char_Val,al
	mov	dx,offset TRANGROUP:DosRev_Ptr
	invoke	Std_Printf		; print DOS internal revision

	mov	cl,4
	shr	bh,cl			; CY = DOS in ROM
	jc	verRom
	shr	bh,1			; CY = DOS in HMA
	jc	verHma

;	DOS isn't in ROM or HMA, so it must be in lower memory.

	mov	dx,offset TRANGROUP:DosLow_Ptr
	jmp	short verPrintLoc
verRom:	mov	dx,offset TRANGROUP:DosRom_Ptr
	jmp	short verPrintLoc
verHma:	mov	dx,offset TRANGROUP:DosHma_Ptr
verPrintLoc:
	invoke	Std_Printf
verDone:
	jmp	Crlf2

Print_Version:
	mov	ah,GET_VERSION
	int	21h
	push	ax
	xor	ah,ah
	mov	Major_Ver_Num,ax
	pop	ax
	xchg	ah,al
	xor	ah,ah
	mov	Minor_Ver_Num,ax
	mov	dx,offset TRANGROUP:VerMes_Ptr
	jmp	Std_Printf




	assume	ds:TRANGROUP,es:TRANGROUP
print_prompt:
	push	ds
	push	cs
	pop	ds				; MAKE SURE DS IS IN TRANGROUP
	push	es
	invoke	find_prompt			; LOOK FOR PROMPT STRING
	jc	PP0				; CAN'T FIND ONE
	cmp	byte ptr es:[di],0
	jnz	PP1
PP0:
	call	print_drive			; USE DEFAULT PROMPT
	mov	al,sym
	call	print_char
	jmp	short PP5

PP1:
	mov	al,es:[di]			; GET A CHAR
	inc	di
	or	al,al
	jz	PP5				; NUL TERMINATED
	cmp	al,dollar			; META CHARACTER?
	jz	PP2				; NOPE
PPP1:
	call	print_char
	jmp	PP1

PP2:
	mov	al,es:[di]
	inc	di
	mov	bx,offset trangroup:prompt_table-3
	or	al,al
	jz	PP5

PP3:
	add	bx,3
	invoke	upconv
	cmp	al,[bx]
	jz	PP4
	cmp	byte ptr [bx],0
	jnz	PP3
	jmp	PP1

PP4:
	push	es
	push	di
	push	cs
	pop	es
	call	[bx+1]
	pop	di
	pop	es
	jmp	PP1

PP5:
	pop	es				; RESTORE SEGMENTS
	pop	ds
	return


print_back:
	mov	dx,offset trangroup:dback_ptr
	jmp	std_printf

print_EQ:
	mov	al,'='
	jmp	short print_char

print_esc:
	mov	al,1BH
	jmp	short print_char

print_G:
	mov	al,rabracket
	jmp	short print_char

print_L:
	mov	al,labracket
	jmp	short print_char

print_B:
	mov	al,vbar

print_char:

;	Bugbug:	Why bother with ds,es here?

	push	es
	push	ds
	pop	es
	push	di
	push	dx
	mov	dl,al				;AC000; Get char into al
	mov	ah,Std_CON_output		;AC000; print the char to stdout
	int	21h			;AC000;
	pop	dx
	pop	di
	pop	es
	ret

print_drive:
	mov	ah,Get_Default_drive
	int	21h
	add	al,capital_A
	call	print_char
	ret

ASSUME	DS:TRANGROUP,ES:TRANGROUP

build_dir_for_prompt:
	xor	dl,dl
	mov	si,offset trangroup:bwdbuf
	mov	di,SI
	mov	al,CurDrv
	add	al,'A'
	mov	ah,':'
	stosw
	mov	al,[dirchar]
	stosb
	xchg	si,di
	mov	string_ptr_2,di
	mov	ah,Current_dir
	int	21h
	mov	dx,offset trangroup:string_buf_ptr
	jnc	DoPrint
	mov	dx,offset trangroup:BadCurDrv
DoPrint:
	call	std_printf

	ret

build_dir_for_chdir:
	call	build_dir_string
	mov	dx,offset trangroup:bwdbuf
	mov	string_ptr_2,dx
	mov	dx,offset trangroup:string_buf_ptr
	call	std_printf
	ret

build_dir_string:
	mov	dl,ds:[FCB]
	mov	al,DL
	add	al,'@'
	cmp	al,'@'
	jnz	gotdrive
	add	al,[CURDRV]
	inc	al

gotdrive:
	push	ax
	mov	si,offset trangroup:bwdbuf+3
	mov	ah,Current_dir
	int	21h
	jnc	dpbisok
	push	cs
	pop	ds
	jmp	drvbad

dpbisok:
	mov	di,offset trangroup:bwdbuf
	mov	dx,di
	pop	ax
	mov	ah,':'
	stosw
	mov	al,[dirchar]
	stosb

	ret

	break	Path
assume	ds:trangroup,es:trangroup

PATH:
	xor	al,al				;AN049; Set up holding buffer
	mov	di,offset Trangroup:srcxname	;AN049;   for PATH while parsing
	stosb					;AN049; Initialize PATH to null
	dec	di				;AN049; point to the start of buffer
	invoke	PGetarg 			; Pre scan for arguments
	jz	disppath			; Print the current path
	cmp	al,semicolon			;AC049; NUL path argument?
	jnz	pathslp 			;AC049;
	inc	si				;AN049; point past semicolon
	jmp	short scan_white		;AC049; Yes - make sure nothing else on line

pathslp:					; Get the user specified path
	lodsb					; Get a character
	cmp	al,end_of_line_in		;AC049; Is it end of line?
	jz	path_eol			;AC049; yes - end of command

	invoke	testkanj			;See if DBCS
	jz	notkanj2			;No - continue
	stosb					;AC049; Yes - store the first byte
	lodsb					;skip second byte of DBCS

path_hold:					;AN049;
	stosb					;AC049; Store a byte in the PATH buffer
	jmp	short pathslp			;continue parsing

notkanj2:
	invoke	upconv				;upper case the character
	cmp	al,semicolon			;AC049; ';' not a delimiter on PATH
	jz	path_hold			;AC049; go store it
	invoke	delim				;delimiter?
	jnz	path_hold			;AC049; no - go store character

scan_white:					;AN049; make sure were at EOL
	lodsb					;AN049; get a character
	cmp	al,end_of_line_in		;AN049; end of line?
	jz	path_eol			;AN049; yes - go set path
	cmp	al,blank			;AN049; whitespace?
	jz	scan_white			;AN049; yes - continue scanning
	cmp	al,tab_chr			;AN049; whitespace?
	jz	scan_white			;AN049; yes - continue scanning

	mov	dx,offset TranGroup:Extend_Buf_ptr ;AN049; no - set up error message
	mov	Extend_Buf_ptr,MoreArgs_ptr	;AN049; get "Too many parameters" message number
	mov	msg_disp_class,parse_msg_class	;AN049; set up parse error msg class
	jmp	cerror				;AN049;

path_eol:					;AN049; Parsing was clean
	xor	al,al				;AN049; null terminate the PATH
	stosb					;AN049;    buffer
	invoke	find_path			;AN049; Find PATH in environment
	invoke	delete_path			;AC049; Delete any offending name
	invoke	scan_double_null		;AC049; Scan to end of environment
	invoke	move_name			;AC049; move in PATH=
	mov	si,offset Trangroup:srcxname	;AN049; Set up source as PATH buffer

store_path:					;AN049; Store the PATH in the environment
	lodsb					;AN049; Get a character
	cmp	al,end_of_line_out		;AN049; null character?
	jz	got_paths			;AN049; yes - exit
	invoke	store_char			;AN049; no - store character
	jmp	short store_path		;AN049; continue

got_paths:					;AN049; we're finished
	xor	ax,ax				;null terminate the PATH in
	stosw					;    the environment
	return

disppath:
	invoke	find_path			;AN049;
	call	print_path
	call	crlf2
	return

print_path:
	cmp	byte ptr es:[di],0
	jnz	path1

path0:
	mov	dx,offset trangroup:nulpath_ptr
	push	cs
	pop	es
	push	cs
	pop	ds
	jmp	std_printf

path1:
	push	es
	pop	ds
	sub	di,5
	mov	si,di
ASSUME	DS:RESGROUP
	invoke	scasb2				; LOOK FOR NUL
	cmp	cx,0FFH
	jz	path0
	push	cs
	pop	es
	mov	di,offset trangroup:arg_buf
	mov	dx,100h
	sub	dx,cx
	xchg	dx,cx
	rep	movsb
	mov	dx,offset trangroup:arg_buf_ptr
	push	cs
	pop	ds
	jmp	std_printf

ASSUME	DS:TRANGROUP

	break	Cls

; ****************************************************************
; *
; * ROUTINE:	 CLS
; *
; * FUNCTION:	 Clear the screen using INT 10h.  If ANSI.SYS is
; *		 installed, send a control string to clear the
; *		 screen.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

ANSI_installed		equ    0ffh

CLS:
	mov	ah,Mult_ANSI			;AN000; see if ANSI.SYS installed
	mov	al,0				;AN000;
	int	2fh				;AN000;
	cmp	al,ANSI_installed		;AN000;
	jz	ansicls 			;AN000; installed - go do ANSI CLS

check_lines:
	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
	mov	bx,stdout			;AN000; lines for stdout
	mov	ch,ioc_sc			;AN000; type is display
	mov	cl,get_generic			;AN000; get information
	mov	dx,offset trangroup:display_ioctl ;AN000;
	int	21h			;AN000;
	jc	no_variable			;AN000; function had error, use default
	mov	ax,linperpag			;AN000; get number of rows returned
	mov	dh,al				;AN000; set number of rows
	mov	ax,display_width		;AN000; get number of columns returned
	mov	dl,al				;AN000; set number of columns
	jmp	short regcls			;AN000; go do cls

no_variable:
	mov	bx,stdout			;AC000; set handle as stdout
	mov	ax,IOCTL SHL 8			;AC000; do ioctl - get device
	int	21h			;AC000;    info
	test	dl,devid_ISDEV			;AC000; is handle a device
	jz	ANSICLS 			;AC000; If a file put out ANSI
	test	dl,devid_SPECIAL		;AC000;
	jnz	cls_normal			;AC000; If not special CON, do ANSI

ansicls:
	call	ansi_cls			;AN000; clear the screen
	jmp	short cls_ret			;AN000; exit

;
; Get video mode
;

cls_normal:					;AC000;

	mov	ah,get_video_state		;AC000; set up to get video state
	int	video_io_int			;AC000; do int 10h - BIOS video IO
	cmp	al,video_alpha			;AC000; see if in text mode
	jbe	DoAlpha
	cmp	al,video_bw			;AC000; see if black & white card
	jz	DoAlpha
;
; We are in graphics mode.  Bogus IBM ROM does not scroll correctly.  We will
; be just as bogus and set the mode that we just got.  This will blank the
; screen too.
;
	mov	ah,set_video_mode		;AC000; set video mode call
	int	video_io_int			;AC000; do int 10h - BIOS video IO
	jmp	short cls_ret			;AC000; exit

DoAlpha:
;
; Get video mode and number of columns to scroll
;

;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
;M01   adaptors.  We circumvent this by reaching directly into the BIOS data
;M01   area
;M01   Commented out code here is the original
;M01	mov	ah,get_video_state		;AC000; set up to get current video state
;M01	int	video_io_int			;AC000; do int 10h - BIOS video IO
;M01	mov	dl,ah
;M01	mov	dh,linesperpage 		;AC000; have 25 rows on the screen

;M01   Following code lifted from a fix Compaq applied to ANSI

	push	ds
	MOV	AX,ROMBIOS_DATA 	; GET ROM Data segment	M01
	MOV	DS,AX			;  *			M01
	Assume	DS:ROMBIOS_DATA

	mov	dx,CRT_Cols		; Get Columns - assume < 256 M01
	MOV	dh,CRT_Rows		; GET MAX NUM OF ROWS	M01
	pop	ds			;			M01
	Assume	DS:Trangroup

	or	dh,dh			; Q:ZERO		M01
	jnz	regcls			;  *JMP IF NO		M01

	MOV	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01

regcls:
	inc	dh			; height+1		M018
	call	reg_cls 			; go clear the screen

cls_ret:
	ret					; exit

; ****************************************************************
; *
; * ROUTINE:	 REG_CLS
; *
; * FUNCTION:	 Clear the screen using INT 10H.
; *
; * INPUT:	 DL = NUMBER OF COLUMNS
; *		 DH = NUMBER OF ROWS
; *
; * OUTPUT:	 none
; *
; ****************************************************************

reg_cls proc	near

;
; Set overscan to black.
;

	dec	dh				;  decrement rows and columns
	dec	dl				;     to zero base
	push	dx				;  save rows,columns
	mov	ah,set_color_palette		;  set up to set the color to blank
	xor	bx,bx
	int	video_io_int			; do int 10h - BIOS video IO
	pop	dx				;  retore rows,colums

	xor	ax,ax				;  zero out ax
	mov	CX,ax				;     an cx
;
; Scroll active page
;
	mov	ah,scroll_video_page		; set up to scroll page up
	mov	bh,video_attribute		; attribute for blank line
	xor	bl,bl				; set BL to 0
	int	video_io_int			; do int 10h - BIOS video IO
;
; Seek to cursor to 0,0
;
;M022 following two lines added
	mov	ah,get_video_state		; get current video page in BH
	int	video_io_int
	mov	ah,set_cursor_position		; set up to set cursor position
	xor	dx,dx				; row and column 0
;M022	mov	bh.0
	int	video_io_int			; do into 10h - BIOS video IO

	ret

reg_cls endp



; ****************************************************************
; *
; * ROUTINE:	 ANSI_CLS
; *
; * FUNCTION:	 Clear the screen using by writing a control code
; *		 to STDOUT.
; *
; * INPUT:	 none
; *
; * OUTPUT:	 none
; *
; ****************************************************************

ansi_cls proc	near				;AC000;

	mov	si,offset trangroup:clsstring
	lodsb
	mov	cl,al
	xor	ch,ch
	mov	ah,Raw_CON_IO
clrloop:
	lodsb
	mov	DL,al
	int	21h
	loop	clrloop
	return

ansi_cls	endp				;AC000;

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tenv2.asm ===
page ,132
;	SCCSID = @(#)tenv2.asm	1.1 85/05/14
;	SCCSID = @(#)tenv2.asm	1.1 85/05/14
TITLE	Part6 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	Environment utilities and misc. routines

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include find.inc
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES SEGMENT PUBLIC BYTE		;AC000;
	EXTRN	pipeflag:byte
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	ACRLF_PTR:WORD
	EXTRN	BadCD_Ptr:WORD
	EXTRN	Badmkd_ptr:word
	EXTRN	BADRMD_PTR:WORD
	EXTRN	Extend_buf_ptr:word	;AN000;
	EXTRN	Extend_buf_sub:byte	;AN022;
	EXTRN	MD_exists_ptr:word	;AN006;
	EXTRN	msg_disp_class:byte	;AC000;
	EXTRN	NOSPACE_PTR:WORD
	EXTRN	parse_chdir:byte	;AC000;
	EXTRN	parse_mrdir:byte	;AC000;
	EXTRN	PIPEEMES_PTR:WORD
	EXTRN	string_buf_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	CURDRV:BYTE
	EXTRN	DESTINFO:BYTE
	EXTRN	DESTTAIL:WORD
	EXTRN	DIRCHAR:BYTE
	EXTRN	dirflag:byte		;AN015;
	EXTRN	KPARSE:BYTE		;AC000;  3/3/KK
	EXTRN	msg_numb:word		;AN022;
	EXTRN	parse1_addr:dword	;AC000;
	EXTRN	parse1_type:byte	;AC000;
	EXTRN	PATHPOS:WORD
	EXTRN	RESSEG:WORD
	EXTRN	srcxname:byte		;AC000;
	EXTRN	string_ptr_2:word
	EXTRN	SWITCHAR:BYTE
	EXTRN	USERDIR1:BYTE
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC byte

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near

	PUBLIC	$chdir
	PUBLIC	$mkdir
	PUBLIC	$rmdir
	PUBLIC	crlf2
	PUBLIC	crprint
	PUBLIC	delim
	PUBLIC	error_output
	PUBLIC	fcb_to_ascz
	PUBLIC	pathchrcmp
	PUBLIC	pathcrunch
	PUBLIC	savudir
	PUBLIC	savudir1
	PUBLIC	scanoff
	PUBLIC	strcomp

break	$Chdir

; ****************************************************************
; *
; * ROUTINE:	 $CHDIR
; *
; * FUNCTION:	 Entry point for CHDIR command. Parse the command
; *		 line. If path is found, CHDIR to path. If a drive
; *		 letter is found, get and display the current dir
; *		 of the specified drive. If nothing is found, get
; *		 and display the current dir of the default drive.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

$CHDIR:

	mov	si,81H
	mov	di,offset trangroup:parse_chdir ;AN000; Get adderss of PARSE_CHDIR
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser

	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	bwdJ				; No args
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	ChDirErr			;AC018; yes - exit

	cmp	parse1_type,result_drive	;AC000; was a drive entered?
	jnz	REALCD				; no
;
; D: was found.  See if there is anything more.
;
	mov	di,offset trangroup:parse_chdir ;AC000; get address of parse_chdir
	xor	dx,dx				;AC000;
	invoke	parse_check_eol 		;AC000; call parser
	jnz	ChDirErr			;AC000;

bwdJ:
	invoke	build_dir_for_chdir		; Drive only specified
	call	crlf2
	return

REALCD:

	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of filespec
	invoke	move_to_srcbuf			;AN000; move to srcbuf
	pop	si				;AN000; restore position in line
	mov	di,offset trangroup:parse_chdir ;AC000; get address of parse_chdir
	xor	dx,dx				;AC000;
	invoke	parse_check_eol 		;AC000; call parser
	jnz	ChDirErr			;AC000;

	invoke	SETPATH
	TEST	[DESTINFO],2
	JNZ	BadChdir
	MOV	AH,CHDIR
	INT	21h
	retnc

	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_path_not_found 	;AN022; see if path not found
	jz	BadChDir			;AN022; yes - issue old message
;SR;
; We want to issue "Invalid Directory" message even if the path is valid
;but is not a directory. The extended error returns "Access denied" which
;is kind of confusing. Issue the old message if access denied error is 
;returned
;
	cmp	ax,error_access_denied
	jz	BadChDir

	call	Set_Ext_Error_Subst		;AN022;
	jmp	short  chdirerr 		;AN022;

BadChDir:
	MOV	DX,OFFSET TRANGROUP:BADCD_ptr

ChDirErr:
	invoke	Std_Eprintf
	return

break	$Mkdir

assume	ds:trangroup,es:trangroup

$MKDIR:
	CALL	SETRMMK
	JC	MkDirErr
	MOV	AH,MKDIR
	INT	21h
	retnc

	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_path_not_found 	;AN022; see if path not found
	jz	MD_other_err			;AN022; yes - issue old message
	cmp	ax,error_access_denied		;AN022; access denied?
	jz	badmderr			;AN022; yes - see if file exists

	call	Set_Ext_Error_Subst		;AN022;
	jmp	short MkDirerr			;AC022; yes - go print it

BADMDERR:
	mov	dx,offset trangroup:srcxname	;AN006; Set Disk transfer address
	mov	ah,Set_DMA			;AN006;
	int	21h			;AN006;
	MOV	AH,Find_First			;AN006; see if file/dir exists
	mov	cx,attr_directory		;AN006;   search for directory
	INT	21h			;AN006;
	jc	MD_other_err			;AN006; doesn't exist - must be something else
	mov	dl,srcxname.find_buf_attr	;AN006; we found a file/dir
	test	dl,attr_directory		;AN006; was it a directory?
	jz	MD_other_err			;AN006; no - must have been a file
	mov	dx,offset trangroup:MD_exists_ptr ;AN006; set up already exists error
	jmp	short MkDirErr			;AN006; make sure we didn't have network error
MD_other_err:					;AN006;
	MOV	DX,OFFSET TRANGROUP:BADMKD_ptr
MkDirErr:
	invoke	Std_Eprintf
	return

Break	<Common MkDir/RmDir set up code>

;****************************************************************
;*
;* ROUTINE:	SETRMMK
;*
;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
;*		commands. Parses the command line for a required
;*		filespec.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	carry clear
;*		    DS:DX points to ASCIIZ argument
;*		carry set
;*		    DS:DX has error message pointer
;*
;****************************************************************

SETRMMK:
	mov	si,81H
	mov	di,offset trangroup:parse_mrdir ;AN000; Get adderss of PARSE_MRDIR
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC000; call parser
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	 NOARGERR			;AC000; yes - exit

	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
	push	di				;AN000; save address
	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of path

mrdir_move_filename:				;AN000; put filespec in srcxname
	lodsb					;get a char from buffer
	stosb					;AN000; store in srcxname
	cmp	al,end_of_line_out		;AC000; it char a terminator?
	jnz	mrdir_move_filename		;AC000; no - keep moving
	pop	si				;AN000; get line position back

;
; we have scanned an argument.	See if any args beyond.
;

	mov	di,offset trangroup:parse_mrdir ;AC000; get address of parse_mrdir
	invoke	parse_check_eol 		;AC000; are we at end of line?
	pop	dx				;AC000; get address of SRCXNAME
	retz					;yes - return no error
NOARGERR:
	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
	XOR	AX,AX
	STC
	return

break	$Rmdir

assume	ds:trangroup,es:trangroup

$RMDIR:
	CALL	SETRMMK
	JC	RmDirErr
	JNZ	BADRDERR
	MOV	AH,RMDIR
	INT	21h
	retnc

	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_path_not_found 	;AN022; see if path not found
	jz	badrderr			;AN022; yes - issue old message
	cmp	ax,error_access_denied		;AN022; access denied?
	jz	badrderr			;AN022; yes - issue old message

	call	Set_Ext_Error_Subst		;AN022;
	jmp	short RmDirerr			;AC022; yes - go print it

BADRDERR:
	MOV	DX,OFFSET TRANGROUP:BADRMD_ptr

RmDirErr:
	invoke	STD_Eprintf
	return

;****************************************************************
;*
;* ROUTINE:	Set_ext_error_subst
;*
;* FUNCTION:	Sets up substitution for extended error
;*
;* INPUT:	AX - extended error number
;*		DX - offset of string
;*
;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
;*
;****************************************************************

Set_ext_error_subst  proc near			;AN022;

	mov	msg_disp_class,ext_msg_class	;AN022; set up extended error msg class
	mov	string_ptr_2,dx 		;AN022; get address of failed string
	mov	Extend_buf_sub,one_subst	;AN022; put number of subst in control block
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AN022; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN022; get message number in control block

	ret					;AN022; return

Set_ext_error_subst  endp			;AN022;





Break	<SavUDir - preserve the users current directory on a particular drive>

;
; SavUDir - move the user's current directory on a drive into UserDir1
; SavUDir1 - move the user's current directory on a drive into a specified
;   buffer
;
;   Inputs:	DL has 1-based drive number
;		ES:DI has destination buffer (SavUDir1 only)
;   Outputs:	Carry Clear
;		    DS = TranGroup
;		Carry Set
;		    AX has error code
;   Registers Modified: AX, SI
;

SAVUDIR:
	MOV	DI,OFFSET TRANGROUP:USERDIR1

SAVUDIR1:
	MOV	AL,DL
	ADD	AL,'@'
	CMP	AL,'@'
	JNZ	GOTUDRV
	ADD	AL,[CURDRV]
	INC	AL				; A = 1

GOTUDRV:
	STOSB
	MOV	AH,[DIRCHAR]
	MOV	AL,':'
	STOSW
	PUSH	ES
	POP	DS
ASSUME	DS:NOTHING

	MOV	SI,DI
	MOV	AH,CURRENT_DIR			; Get the Directory Text
	INT	21h
	retc
	PUSH	CS
	POP	DS
ASSUME	DS:TRANGROUP

	return


CRLF2:
	PUSH	DX
	MOV	DX,OFFSET TRANGROUP:ACRLF_ptr

PR:
	PUSH	DS
	PUSH	CS
	POP	DS
	invoke	std_printf
	POP	DS
	POP	DX

	return

;
; These routines (SCANOFF, DELIM) are called in batch processing when DS
; may NOT be TRANGROUP
;
ASSUME	DS:NOTHING,ES:NOTHING

SCANOFF:
	LODSB
	CALL	DELIM
	JZ	SCANOFF
	DEC	SI				; Point to first non-delimiter
	return

;
; Input:    AL is character to classify
; Output:   Z set if delimiter
;	    NZ set otherwise
; Registers modified: none
;

DELIM:
	CMP	AL,' '
	retz
	CMP	AL,'='
	retz
	CMP	AL,','
	retz
	CMP	AL,';'
	retz
	CMP	AL,9				; Check for TAB character
	retz
	CMP	AL,0ah				; Check for line feed character - BAS
	return


ASSUME	DS:TRANGROUP,ES:TRANGROUP


FCB_TO_ASCZ:					; Convert DS:SI to ASCIZ ES:DI
	MOV	CX,8

MAINNAME:
	LODSB
	CMP	AL,' '
	JZ	SKIPSPC
	STOSB

SKIPSPC:
	LOOP	MAINNAME
	LODSB
	CMP	AL,' '
	JZ	GOTNAME
	MOV	AH,AL
	MOV	AL,dot_chr
	STOSB
	XCHG	AL,AH
	STOSB
	MOV	CL,2

EXTNAME:
	LODSB
	CMP	AL,' '
	JZ	GOTNAME
	STOSB
	LOOP	EXTNAME

GOTNAME:
	XOR	AL,AL
	STOSB
	return

STRCOMP:
;
; Compare ASCIZ DS:SI with ES:DI.
; SI,DI destroyed.
;
	CMPSB
	retnz					; Strings not equal
	cmp	byte ptr [SI-1],0		; Hit NUL terminator?
	retz					; Yes, strings equal
	jmp	short STRCOMP			; Equal so far, keep going


CRPRINT:
	PUSH	AX
	MOV	AL,13
	PUSH	CX
	PUSH	DI
	MOV	DI,DX
	MOV	CX,-1
	PUSH	ES
	PUSH	DS
	POP	ES

	REPNZ	SCASB				; LOOK FOR TERMINATOR
	mov	byte ptr [di-1],0		; nul terminate the string
	POP	ES
	mov	string_ptr_2,dx
	mov	dx,offset trangroup:string_buf_ptr
	invoke	std_printf
	mov	ds:byte ptr [di-1],13		; now put the CR back
	JC	ERROR_OUTPUT

	POP	DI
	POP	CX
	POP	AX

	return

ERROR_OUTPUT:
	PUSH	CS
	POP	DS
ASSUME	DS:TRANGROUP
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP

	MOV	DX,OFFSET TRANGROUP:NOSPACE_ptr
	CMP	[PIPEFLAG],0
	JZ	GO_TO_ERROR

	invoke	PipeOff
	MOV	DX,OFFSET TRANGROUP:PIPEEMES_ptr
GO_TO_ERROR:
	JMP	CERROR

ASSUME	DS:TRANGROUP,ES:TRANGROUP

PATHCHRCMP:
;---- Mod for path invocation ----
PUBLIC pathchrcmp
;----

	push	ax
	mov	ah,'/'
	CMP	[SWITCHAR],ah
	JZ	NOSLASHT
	CMP	AL,'/'
	jz	pccont

NOSLASHT:
	CMP	AL,'\'
pccont:
	pop	ax

	return

;
; PATHCRUNCH -
;
; ENTRY FCB (in PSP) contains drive # to crunch on
;       PathPos = ptr to string with pathname in it
;       PathCnt = length of string
;
; EXIT  PathPos = ptr after pathname (w/ NULL) in string
;       PathCnt = length left in string
;       DestIsDir = nonzero if pathname delimiter char's found in pathname
;       DestInfo<bit1> = set if wildcard char's found in pathname
;       If path crunched successfully,
;         CY = clear
;         Current directory is changed to directory in pathname
;         UserDir1 contains previous directory for use by RestUDir
;         RestDir = nonzero to flag later restoration of user's dir
;         DestTail = ptr to beginning of filename
;         If filename found in pathname,
;           ZR = clear
;           FCB filename fields contain filename
;         If filename not found (pure directory path),
;           ZR = set
;           FCB filename fields are wildcarded with ?'s
;       If pathcrunch failed (no ChDir's worked),
;         CY = set
;         Msg_Numb = extended error code
;
; NOTE  DIR asks PathCrunch to forego parsing the filename into the
;       FCB by setting DirFlag.  In this case, the FCB is returned
;       with the filename wildcarded.
;
PATHCRUNCH:
        mov     [msg_numb],0            ;AN022; Set up message flag
        MOV     DL,DS:[FCB]             ; DL = drive # (1 = A)
        CALL    SAVUDIR                 ; save current directory in UserDir1
        jc      pcrunch_cderrJ           ;AN022; if error on current dir - report

        invoke  SETPATH                 ; scan past switches, whitespace

;       DX = ptr to pathname, NULL-terminated
;       PathPos = ptr to byte after NULL at end of pathname

        TEST    [DESTINFO],2            ; test if wildcards (? or *) seen
        JNZ     TRYPEEL                 ; wildcard seen, peel filename

        MOV     AH,CHDIR                ; AH = DOS ChDir function code
        INT     21h             ; call DOS
        jnc     chdir_worked            ;AN022; no error - continue

        invoke  get_ext_error_number    ;AN022; get the extended error
        cmp     ax,error_path_not_found ;AN022; if path not found
        jz      trypeel                 ;AC022;     keep trying
        cmp     ax,error_access_denied  ;AN022; if access denied
        jz      trypeel                 ;AC022;     keep trying
        mov     [msg_numb],ax           ;AN022; set up message flag
        jmp     peelfail                ;AN022; exit with other error

chdir_worked:
        invoke  SETREST1                ; set 'Restore Directory' flag true
        MOV     AL,'?'                  ; if pure dir, wildcard filename in FCB
        MOV     DI,5DH
	MOV	CX,11
        REP     STOSB
        XOR     AL,AL                   ; return carry clear, zero set
        return

pcrunch_cderrj: 				;AN022; need this for long jmp
	jmp	pcrunch_cderr			;AN022;

TRYPEEL:
        MOV     SI,[PATHPOS]
        DEC     SI                      ; SI = ptr to NULL at end of pathname
        MOV     AL,[SI-1]               ; AL = last char of pathname

	CMP	[KPARSE],0
	JNZ	DELSTRT 			; Last char is second KANJI byte, might be '\'

	CALL	PATHCHRCMP
	JZ	PEELFAIL			; Trailing '/'

DELSTRT:
        MOV     CX,SI                   ; CX = ptr to NULL at end of pathname
        MOV     SI,DX                   ; SI = ptr to start of pathname
        PUSH    DX                      ; save ptr to pathname
DELLOOP:
        CMP     SI,CX
        JZ      GOTDELE                 ; no char's left, we have what we have
        LODSB                           ; AL = next char of pathname
        invoke  TESTKANJ
        JZ      NOTKANJ8                ; not Kanji, move along
        INC     SI
	JMP	DELLOOP

NOTKANJ8:
        CALL    PATHCHRCMP
        JNZ     DELLOOP                 ; not a path delimiter, keep looking
        MOV     DX,SI
        DEC     DX                      ; DX = ptr to last delimiter found
        JMP     DELLOOP                 ; go look for more

GOTDELE:
        MOV     SI,DX                   ; SI = ptr to pathname or last delim
        POP     DX                      ; DX = ptr to pathname
        CMP     SI,DX
        JZ      BADRET                  ; didn't find path delim
        MOV     CX,SI                   ; CX = ptr to last path delimiter
        MOV     SI,DX                   ; SI = ptr to pathname

DELLOOP2:                               ; Set value of KPARSE
        CMP     SI,CX
        JZ      TRYCD                   ; roll up till SI meets CX
        MOV     [KPARSE],0
	LODSB
	INVOKE	TESTKANJ
	JZ	DELLOOP2
	INC	SI
	INC	[KPARSE]
	JMP	DELLOOP2

TRYCD:
        push    ax
        mov     al,dot_chr              ; AL = '.'
        CMP     BYTE PTR [SI+1],al      ; check for '.' after path delim
					;M019; allow continuation if '. ' or 
					;M019; '..' is not found.
	jnz	@F			;M019; '.' not found
	cmp	BYTE PTR [SI+2],al	;M019; check for '..'
	jz	@F			;M019; found '..'
	cmp	BYTE PTR [SI+2],0	;M019; check for '. ' (null terminated)
@@:     pop     ax
        JZ      PEELFAIL                ; if . or .., pure cd should have worked
        mov     al,[si-1]
        CMP     al,':'                  ; Special case d:\file
        JZ      BADRET

	CMP	[KPARSE],0
	JNZ	NOTDOUBLESL			; Last char is second KANJI byte, might be '\'

	CALL	PATHCHRCMP
	JNZ	NOTDOUBLESL
PEELFAIL:
	STC					; //
	return
NOTDOUBLESL:
	MOV	BYTE PTR [SI],0
	MOV	AH,CHDIR
	INT	21h
	JNC	CDSUCC
pcrunch_cderr:
	invoke	get_ext_error_number		;AN022; get the extended error
	mov	[msg_numb],ax			;AN022; set up message flag
	or	si,si				;AN022; set up zero flag to not zero
	stc					;AN022; set up carry flag
	return

BADRET:
	MOV	AL,[SI]
	CALL	PATHCHRCMP			; Special case 'DIRCHAR'file
	STC
	retnz
	XOR	BL,BL
	XCHG	BL,[SI+1]
	MOV	AH,CHDIR
	INT	21h
	jc	pcrunch_cderr			;AN022; go to error exit
	MOV	[SI+1],BL
CDSUCC:
	invoke	SETREST1
	INC	SI				; Reset zero
	MOV	[DESTTAIL],SI
	pushf					;AN015; save flags
	cmp	dirflag,-1			;AN015; don't do parse if in DIR
	jz	pcrunch_end			;AN015;
	MOV	DI,FCB
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 02H ; Parse with default drive
	INT	21h
pcrunch_end:
	popf					;AN015; get flags back
	return

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tfor.asm ===
page ,132
;	SCCSID = @(#)tfor.asm	4.1 85/09/17
;	SCCSID = @(#)tfor.asm	4.1 85/09/17
TITLE	Part3 COMMAND Transient Routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;     For loop processing routines


.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include find.inc
	include devsym.inc
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BATCH:WORD
	EXTRN	ECHOFLAG:BYTE
	EXTRN	FORFLAG:BYTE
	EXTRN	FORPTR:WORD
	EXTRN	NEST:WORD
	EXTRN	NULLFLAG:BYTE
	EXTRN	PIPEFILES:BYTE
	EXTRN	SINGLECOM:WORD
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	Extend_buf_ptr:word	;AN000;
	extrn	fornestmes_ptr:word
	EXTRN	msg_disp_class:byte	;AN000;
	extrn	string_buf_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	extrn	arg:byte		; the arg structure!
	EXTRN	COMBUF:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	string_ptr_2:word
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near
	EXTRN	docom:near
	EXTRN	docom1:near
	EXTRN	forerror:near
	EXTRN	tcommand:near

	PUBLIC	$for
	PUBLIC	forproc


; All batch proccessing has DS set to segment of resident portion
ASSUME	DS:RESGROUP,ES:TRANGROUP


FORTERM:
	push	cs				;AN037; Get local segment into
	pop	ds				;AN037;    DS, ES
	push	cs				;AN037;
	pop	es				;AN037;
	call	ForOff
	mov	ds,ResSeg
ASSUME	DS:RESGROUP
	CMP	[SINGLECOM],0FF00H
	JNZ	BATCRLF
	CMP	NEST,0				;G See if we have nested batch files
	JNZ	BATCRLF 			;G Yes - don't exit just yet
	MOV	[SINGLECOM],-1			; Cause a terminate
	JMP	SHORT NOFORP2

BATCRLF:
	test	[ECHOFLAG],1			;G  Is echo on?
	JZ	NOFORP2 			;G  no - exit
	TEST	[BATCH], -1			;G  print CRLF if in batch
	JZ	NOFORP2 			;G
	invoke	CRLF2

NOFORP2:
	JMP	TCOMMAND


;------
;   For-loop processing.  For loops are of the form:
;	    for %<loop-variable> in (<list>) do <command>
; where <command> may contain references of the form %<variable>, which are
; later substituted with the items in <list>.  The for-loop structure is
; set-up by the procedure '$for'; successive calls to 'forproc' execute
; <command> once for each item in <list>.  All of the information needed for
; loop processing is stored on a piece of memory gotten from 'alloc'.  This
; structure is actually fairly large, on the order of 700 bytes, and includes
; a complete copy of the original command-line structure as parsed by
; 'parseline', loop control variables, and a dma buffer for the
; 'FindFirst/FindNext' expansion of wildcard filenames in <list>.  When loop
; processing has completed, this chunk of memory is returned to the system.
;
;   All of the previously defined variables, in 'datares', used for loop
; processing may be erased.  Only one, (DW) ForPtr, need be allocated.
;
;   The error message, 'for_alloc_mes', should be moved into the file
; containing all of the other error messages.
;
;   Referencing the allocated for-loop structure is a little tricky.
; At the moment, a byte is defined as part of a new segment, 'for_segment'.
; When 'forproc' actually runs, ES and DS are set to point to the base of the
; new chunk of memory.	References to this byte, 'f', thus assemble correctly
; as offsets of ES or DS.  'f' would not be necessary, except that the
; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
; immediate move of the offset of 'for_minarg' into AX.  In other words, in
; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
;	mov	AX, #for_minarg 	; AX := 02CA (for example)
; instead of
;	mov	AX, for_minarg		; AX := [02CA] (contents of 02CA)
; By using 'f', we pretend that we are actually referencing an allocated
; structure, and the assembler coughs up the code we want.  Notice that it
; doesn't matter whether we put brackets around the location or not -- the
; assembler is "smart" enough to know that we want an address instead of the
; contents of that location.
;
;   Finally, there now exists the potential to easily implement nested loops.
; One method would be to have a link field in each for-structure pointing to
; its parent.  Variable references that couldn't be resolved in the local
; frame would cause a search of prior frames.  For-structures would still be
; allocated and released in exactly the same fashion.  The only limit on the
; number of nested loops would be memory size (although at 700 bytes a pop,
; memory wouldn't last THAT long).  Alternately, a small structure could be
; maintained in the resident data area.  This structure would be an array of
; control-variable names and pointers to for-structure blocks.	This would
; greatly speed up the resolution of non-local variable references.  However,
; since space in the resident is precious, we would have to compromise on a
; "reasonable" level of nesting -- 10, 16, 32 levels, whatever.  For-structure
; allocation and de-allocation would have to be modified slightly to take this
; new structure into account.
;
;   Oops, just one more thing.	Forbuf need not be a part of the for-structure.
; It could just as well be one structure allocated in 'transpace'.  Actually,
; it may be easier to allocate it as part of 'for_segment'.
;------

	include fordata.asm

$for_exit:
	jmp	forterm 			; exceeding maxarg means all done

forproc:
assume	DS:resgroup
	mov	AX, [ForPtr]
	mov	DS, AX
	mov	ES, AX				; operate in for-info area
assume	DS:for_segment, ES:for_segment

	mov	DX, fordma
	trap	Set_Dma
for_begin:
	cmp	f.for_expand, 0 		; non-zero for_expand equals FALSE
	je	for_begin1
	inc	f.for_minarg
for_begin1:
	mov	BX, f.for_minarg		; current item in <list> to examine
	cmp	BX, f.for_maxarg
	jg	$for_exit			; exceeding maxarg means all done
	mov	AX, for_args.argv
	invoke	argv_calc			; compute argv[x] address

	mov	CX, [BX].argstartel
	mov	DX, [BX].argpointer
	test	[bx].argflags,00000100b 	; Is there a path separator in this arg?
	jnz	forsub				; Yes, argstartel should be correct
	mov	si, [BX].argpointer
	mov	al,lparen
	cmp	byte ptr [si-1],al		; If the current token is the first
	jnz	forsub				;  one in the list and originally had
	inc	cx				;  the opening paren as its first char,
						;  the argstartel ptr needs to be
						;  advanced passed it before the prefix
						;  length is computed.
	mov	al,':'
	cmp	byte ptr [si+1],al		; If the token begins with "(d:",
	jnz	forsub				;  argstartel has to be moved over the
	add	cx,2				;  rest of the prefix as well.

forsub:
	sub	CX, DX				; compute length of pathname prefix
	cmp	f.for_expand, 0 		; are we still expanding a name?
	je	for_find_next			; if so, get next matching filename

	test	[BX].argflags, MASK wildcard
	jnz	for_find_first			; should we expand THIS (new) arg?
	mov	CX, [BX].arglen 		; else, just copy all of it directly
	jmp	short for_smoosh

for_find_first:
	PUSH	CX
	XOR	CX,CX
	trap	Find_First			; and search for first filename match
	POP	CX
	jmp	short for_result
for_find_next:
	trap	Find_Next			; search for next filename match

for_result:
	mov	AX, -1				; assume worst case
	jc	forCheck
	mov	ax,0
forCheck:					; Find* returns 0 for SUCCESS
	mov	f.FOR_EXPAND, AX		; record success of findfirst/next
	or	AX, AX				; anything out there?
	jnz	for_begin			; if not, try next arg

for_smoosh:
	mov	SI, [BX].argpointer		; copy argv[arg][0,CX] into destbuf
	mov	DI, forbuf			; some days this will be the entire
	rep	movsb				; arg, some days just the path prefix

	cmp	f.FOR_EXPAND, 0 		; if we're not expanding, we can
	jnz	for_make_com			; skip the following

	mov	SI, fordma.find_buf_pname
for_more:					; tack on matching filename
	cmp	BYTE PTR [SI], 0
	je	for_make_com
	movsb
	jnz	for_more

for_make_com:
	xor	AL, AL				; tack a null byte onto the end
	stosb					; of the substitute string

	xor	CX, CX				; character count for command line
	not	CX				; negate it -- take advantage of loopnz
	xor	BX, BX				; argpointer
	mov	DI, OFFSET TRANGROUP:COMBUF+2
	mov	bl, f.FOR_COM_START		; argindex
	mov	DH, f.FOR_VAR			; %<for-var> is replaced by [forbuf]
						; time to form the <command> string
	push	CS
	pop	ES
assume	ES:trangroup

	mov	AX, for_args			; translate offset to pointer
	invoke	argv_calc
	mov	si,[bx].arg_ocomptr
	inc	si				; mov ptr passed beginning space

for_make_loop:
	mov	al,[si] 			; the <command> arg, byte by byte
	inc	si
	cmp	AL,'%'                          ; looking for %<control-variable>
	jne	for_stosb			; no % ... add byte to string
	cmp	BYTE PTR [SI], DH		; got the right <variable>?
	jne	for_stosb			; got a %, but wrong <variable>
	inc	SI				; skip over <for-variable>

	push	SI
	mov	SI, forbuf			; substitute the <item> for <variable>
						; to make a final <command> to execute
sloop:
	lodsb					; grab all those <item> bytes, and
	stosb					; add 'em to the <command> string,
	or	AL, AL				; until we run into a null
	loopnz	sloop
	dec	DI				; adjust length and <command> pointer
	inc	CX				; so we can overwrite the null

	pop	SI
	jmp	for_make_loop			; got back for more <command> bytes
for_stosb:
	stosb					; take a byte from the <command> arg
	dec	CX				; and put it into the <command> to be
						; executed (and note length, too)
	cmp	al,0dh				; If not done, loop.
	jne	for_make_loop

for_made_com:					; finished all the <command> args
	not	CL				; compute and record command length
	mov	[COMBUF+1], CL

	mov	DS, [RESSEG]
assume	DS:resgroup

	test	[ECHOFLAG],1			; shall we echo this <command>, dearie?
	jz	noecho3
	cmp	nullflag,nullcommand		;G was there a command last time?
	jz	No_crlf_pr			;G no - don't print crlf
	invoke	CRLF2				;G  Print out prompt

no_crlf_pr:
	mov	nullflag,0			;G reset no command flag
	push	CS
	pop	DS
	assume	DS:trangroup
	push	di
	invoke	PRINT_PROMPT			;G Prompt the user
	pop	di
	mov	BYTE PTR ES:[DI-1],0		; yeah, PRINT it out...
	mov	string_ptr_2,OFFSET TRANGROUP:COMBUF+2
	mov	dx,offset trangroup:string_buf_ptr
	invoke	std_printf
	mov	BYTE PTR ES:[DI-1], 0DH
	jmp	DoCom
noecho3:					; run silent, run deep...
	assume	DS:resgroup
	mov	nullflag,0			;G reset no command flag
	push	CS
	pop	DS
	assume	DS:trangroup
	jmp	docom1


fornesterrj:					; no multi-loop processing... yet!
assume	ES:resgroup
	call	ForOff
	jmp	fornesterr

forerrorj:
	jmp	forerror

	break	$For
assume	ds:trangroup,es:trangroup

$for:
	mov	ES, [RESSEG]
assume	ES:resgroup

	cmp	ForFlag,0			; is another one already running?
	jnz	fornesterrj			; if flag is set.... boom!

;
; Turn off any pipes in progress.
;
	cmp	[PIPEFILES],0			; Only turn off if present.
	jz	NoPipe
	invoke	PipeDel
NoPipe:
	xor	DX, DX				; counter (0 <= DX < argvcnt)
	call	nextarg 			; move to next argv[n]
	jc	forerrorj			; no more args -- bad forloop
	cmp	AL,'%'                          ; next arg MUST start with '%'...
	jne	forerrorj
	mov	BP, AX				; save forloop variable
	lodsb
	or	AL, AL				; and MUST end immediately...
	jne	forerrorj

	call	nextarg 			; let's make sure the next arg is 'in'
	jc	forerrorj
	and	AX, NOT 2020H			; uppercase the letters
	cmp	AX, in_word
	jne	forerrorj
	lodsb
	or	AL, AL				; it, too, must end right away

; Compaq bug fix -- exit from this loop on error

	jne	forerrorj			; jump on error

;;	je	CheckLParen
;
; Not null.  Perhaps there are no spaces between this and the (:
;   FOR %i in(foo bar...
; Check for the Lparen here
;
;;	CMP	AL,lparen
;;	JNZ	forerrorj
;
; The token was in(...	We strip off the "in" part to simulate a separator
; being there in the first place.
;
;;	ADD	[BX].argpointer,2		; advance source pointer
;;	ADD	[BX].arg_ocomptr,2		; advance original string
;;	SUB	[BX].arglen,2			; decrement the appropriate length
;
; SI now points past the in(.  Simulate a nextarg call that results in the
; current value.
;
;;	MOV	ax,[si-1]			; get lparen and next char
;;	jmp	short lpcheck
;
;; end of Compaq bug fix

CheckLParen:
	call	nextarg 			; lparen delimits beginning of <list>
	jc	forerrorj
lpcheck:
	cmp	al, lparen
	jne	forerrorj
	cmp	ah,0
	je	for_paren_token

	cmp	ah, rparen			; special case:  null list
	jne	for_list_not_empty
	jmp	forterm

for_list_not_empty:
	inc	[bx].argpointer 		; Advance ptr past "("
						; Adjust the rest of this argv entry
	dec	[bx].arglen			;  to agree.
	inc	si				; Inc si so check for ")" works
	jmp	short for_list

for_paren_token:
	call	nextarg 			; what have we in our <list>?
	jc	forerrorj
	cmp	ax, nullrparen			; special case:  null list
	jne	for_list
	jmp	forterm

forerrorjj:
	jmp	forerror

for_list:					; skip over rest of <list>
	mov	CX, DX				; first arg of <list>
skip_list:
	add	si,[bx].arglen
	sub	si,3				; si = ptr to last char of token
	mov	al,rparen
	cmp	byte ptr [si],al		; Is this the last element in <list>
	je	for_end_list			; Yes, exit loop.
	call	nextarg 			; No, get next arg <list>
	jc	forerrorjj			; If no more and no rparen, error.
	jmp	skip_list
for_end_list:
	mov	DI, DX				; record position of last arg in <list>
	mov	byte ptr [si],0 		; Zap the rparen
	cmp	ax,nullrparen			; Was this token only a rparen
	jz	for_do				; Yes, continue
	inc	di				; No, inc position of last arg

for_do:
	call	nextarg 			; now we had BETTER find a 'do'...
	jc	forerrorjj
	and	AX, NOT 2020H			; uppercase the letters
	cmp	AX, do_word
	jne	forerrorjj
	lodsb
	or	AL, AL				; and it had BETTER be ONLY a 'do'...
	jne	forerrorjj

	call	nextarg 			; on to the beginning of <command>
	jc	forerrorjj			; null <command> not legal

	push	AX
	push	BX
	push	CX
	push	DX				; preserve registers against disaster
	push	DI
	push	SI
	push	BP
	invoke	FREE_TPA			; need to make free memory, first
ASSUME	ES:RESGROUP
	call	ForOff
	mov	BX, SIZE for_info - SIZE arg_unit
	invoke	Save_Args			; extra bytes needed for for-info
	pushf
	mov	[ForPtr], AX
	invoke	ALLOC_TPA			; ALLOC_TPA clobbers registers...
	popf
	pop	BP
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	jc	for_alloc_err

	push	ES				; save resgroup seg...
	push	[ForPtr]
	pop	ES
assume	ES:for_segment				; make references to for-info segment

	dec	CX				; forproc wants min pointing before
	dec	DI				; first arg, max right at last one
	mov	f.for_minarg, CX
	mov	f.for_maxarg, DI
	mov	f.for_com_start, DL
	mov	f.for_expand, -1		; non-zero means FALSE
	mov	AX, BP
	mov	f.for_var, AH
	pop	ES
assume	ES:resgroup

	inc	[FORFLAG]
	cmp	[SINGLECOM], -1
	jnz	for_ret
	mov	[SINGLECOM], 0FF00H
for_ret:
	ret

for_alloc_err:
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr     ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,error_not_enough_memory ;AN000; get message number in control block
	jmp	cerror

nextarg:
	inc	DX				; next argv[n]
	cmp	DX, arg.argvcnt 		; make sure we don't run off end
	jge	nextarg_err			; of argv[]...
	mov	BX, DX
	mov	AX, OFFSET TRANGROUP:arg.argv
	invoke	argv_calc			; convert array index to pointer
	mov	SI, [BX].argpointer		; load pointer to argstring
	lodsw					; and load first two chars
	clc
	ret
nextarg_err:
	stc
	ret


ASSUME	DS:TRANGROUP,ES:TRANGROUP

FORNESTERR:
	PUSH	DS
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	DX,OFFSET TRANGROUP:FORNESTMES_ptr
	CMP	[SINGLECOM],0FF00H
	JNZ	NOFORP3
	MOV	[SINGLECOM],-1			; Cause termination
NOFORP3:
	POP	DS
ASSUME	DS:TRANGROUP
	JMP	CERROR
;
; General routine called to free the for segment.  We also clear the forflag
; too.	Change no registers.
;
PUBLIC ForOff
ForOff:
	assume DS:NOTHING,ES:NOTHING
	SaveReg <AX,ES>
	mov	es,ResSeg
	assume	es:ResGroup
	mov	AX,ForPtr
	or	ax,ax
	jz	FreeDone
	push	es
	mov	es,ax
	mov	ah,dealloc
	int	21h
	pop	es
FreeDone:
	mov	ForPtr,0
	mov	ForFlag,0
	RestoreReg  <ES,AX>
	return

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tenv.asm ===
page ,132
;	SCCSID = @(#)tenv.asm	4.2 85/08/16
;	SCCSID = @(#)tenv.asm	4.2 85/08/16
TITLE	Part6 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	Environment utilities and misc. routines
;
;	Revision History
;	================
;
;	M024	SR	9/5/90	Zero out comspec_flag to fix bug
;				#710 about comspec getting trashed.
;



	INCLUDE comsw.asm

.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include arena.inc
	include comseg.asm
	include comequ.asm
	include doscntry.inc		;an000;
	include	resmsg.equ
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	comdrv:byte
	EXTRN	comspec_end:word
	EXTRN	dbcs_vector_addr:dword	;AN000;
	EXTRN	ENVIRSEG:WORD
	EXTRN	fucase_addr:word	;AC000;
	EXTRN	PutBackDrv:byte
	EXTRN	PutBackComSpec:byte
	EXTRN	RESTDIR:BYTE
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg_buf_ptr:word
	EXTRN	comspec:byte
	EXTRN	comspec_flag:byte
	EXTRN	comspecstr:byte
	EXTRN	ENVERR_PTR:WORD
	EXTRN	PATH_TEXT:byte
	EXTRN	PROMPT_TEXT:byte
	EXTRN	SYNTMES_PTR:WORD
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	Arg_Buf:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	USERDIR1:BYTE
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC byte

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near

	PUBLIC	add_name_to_environment
	PUBLIC	add_prompt
	PUBLIC	delete_path
	PUBLIC	find_name_in_environment
	PUBLIC	find_path
	PUBLIC	find_prompt
	PUBLIC	move_name
	PUBLIC	restudir
	PUBLIC	restudir1
	PUBLIC	scan_double_null
	PUBLIC	scasb2
	PUBLIC	store_char
	PUBLIC	Testkanj		;AN000;  3/3/KK
	PUBLIC	upconv

BREAK	<Environment utilities>
ASSUME DS:TRANGROUP

	break	Prompt command
assume	ds:trangroup,es:trangroup

ADD_PROMPT:
	CALL	DELETE_PROMPT			; DELETE ANY EXISTING PROMPT
	CALL	SCAN_DOUBLE_NULL

ADD_PROMPT2:
	PUSH	SI
	CALL	GETARG
	POP	SI
	retz					; PRE SCAN FOR ARGUMENTS
	CALL	MOVE_NAME			; MOVE IN NAME
	CALL	GETARG
	PUSH	SI
	JMP	SHORT ADD_NAME


	break	The SET command
assume	ds:trangroup,es:trangroup

;
; Input: DS:SI points to a CR terminated string
; Output: carry flag is set if no room
;	  otherwise name is added to environment
;

DISP_ENVj:
	jmp	DISP_ENV

ADD_NAME_TO_ENVIRONMENT:
	CALL	GETARG
	JZ	DISP_ENVj
;
; check if line contains exactly one equals sign
;
	XOR	BX,BX				;= COUNT IS 0
	PUSH	SI				;SAVE POINTER TO BEGINNING OF LINE

EQLP:
	LODSB					;GET A CHAR
	CMP	AL,13				;IF CR WE'RE ALL DONE
	JZ	QUEQ
	CMP	AL,'='                          ;LOOK FOR = SIGN
	JNZ	EQLP				;NOT THERE, GET NEXT CHAR
	INC	BL				;OTHERWISE INCREMENT EQ COUNT
	CMP	BYTE PTR [SI],13		;LOOK FOR CR FOLLOWING = SIGN
	JNZ	EQLP
	INC	BH				;SET BH=1 MEANS NO PARAMETERS
	JMP	EQLP				;AND LOOK FOR MORE

QUEQ:
	POP	SI				;RESTORE BEGINNING OF LINE
	DEC	BL				;ZERO FLAG MEANS ONLY ONE EQ
	JZ	ONEQ				;GOOD LINE
	MOV	DX,OFFSET TRANGROUP:SYNTMES_ptr
	JMP	CERROR

ONEQ:
	PUSH	BX
	CALL	DELETE_NAME_IN_ENVIRONMENT
	POP	BX
	DEC	BH
	retz

	CALL	SCAN_DOUBLE_NULL
	mov	bx,di				; Save ptr to beginning of env var name
	CALL	MOVE_NAME
	push	si
	xchg	bx,di				; Switch ptrs to beginning and end of
						;  env var name
;
; We want to special-case COMSPEC.  This is to reduce the amount of code
; necessary in the resident for re-reading the transient.  Let's look for
; COMSPEC=
;
	mov	comspec_flag,0			; clear flag ; M024
	mov	si,offset trangroup:comspecstr	; Load ptr to string "COMSPEC"
	mov	cx,4				; If the new env var is comspec, set
	repz	cmpsw				;  the comspec_flag
;
; Zero set => exact match
;
	jnz	not_comspec
	inc	comspec_flag			; comspec is changing ; M024

not_comspec:
	mov	di,bx				; Load ptr to end of env var name

ADD_NAME:					; Add the value of the new env var
	pop	si				;  to the environment.
	push	si

add_name1:
	LODSB
	CMP	AL,13
	jz	add_name_ret
	CALL	STORE_CHAR
	JMP	ADD_NAME1

add_name_ret:
	pop	si
	cmp	comspec_flag,0			; If the new env var is comspec,
	retz					;  copy the value into the
;
; We have changed the COMSPEC variable.  We need to update the resident
; pieces necessary to reread in the info.  First, skip all delimiters
;
	invoke	ScanOff
	mov	es,[resseg]			;  comspec var in the resident
	assume	es:resgroup
;
; Make sure that the printer knows where the beginning of the string is
;
	mov	di,offset resgroup:comspec
	mov	bx,di
;
; Generate drive letter for display
;
	xor	ax,ax				;g assume no drive first
	mov	comdrv,al			;g
	push	ax				;AN000;  3/3/KK
	mov	al,[si] 			;AN000;  3/3/KK
	call	testkanj			;AN000;  3/3/KK
	pop	ax				;AN000;  3/3/KK
	jnz	GotDrive
	cmp	byte ptr [si+1],':'             ; drive specified?
	jnz	GotDrive
	mov	al,[si] 			; get his specified drive
	call	UpConv				; convert to uppercase
	sub	al,'A'                          ; convert to 0-based
	add	di,2
	inc	al				; convert to 1-based number
	mov	comdrv,al
;
; Stick the drive letter in the prompt message.  Nothing special needs to be
; done here..
;

	add	al,'A'-1

GotDrive:					;g
	mov	PutBackComSpec.SubstPtr,di	;g point to beginning of name after drive
	mov	es:PutBackDrv,al
;
; Copy chars until delim
;

	mov	di,bx

copy_comspec:
	lodsb
	invoke	Delim
	jz	CopyDone
	cmp	al,13
	jz	CopyDone
	stosb
	jmp	short copy_comspec

CopyDone:
	xor	al,al				; Null terminate the string and quit
	stosb
	mov	comspec_flag,0
	dec	di
	mov	comspec_end,di

	ret

DISP_ENV:
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	DS,[ENVIRSEG]
ASSUME	DS:NOTHING
	XOR	SI,SI

PENVLP:
	CMP	BYTE PTR [SI],0
	retz
	mov	di,offset trangroup:arg_buf

PENVLP2:
	LODSB
	stosb
	OR	AL,AL
	JNZ	PENVLP2
	mov	dx,offset trangroup:arg_buf_ptr
	push	ds
	push	es
	pop	ds
	invoke	printf_crlf
	pop	ds
	JMP	PENVLP

ASSUME	DS:TRANGROUP

DELETE_PATH:
	MOV	SI,OFFSET TRANGROUP:PATH_TEXT
	JMP	SHORT DELETE_NAME_IN_environment

DELETE_PROMPT:
	MOV	SI,OFFSET TRANGROUP:PROMPT_TEXT

DELETE_NAME_IN_environment:
;
; Input: DS:SI points to a "=" terminated string
; Output: carry flag is set if name not found
;	  otherwise name is deleted
;
	PUSH	SI
	PUSH	DS
	CALL	FIND				; ES:DI POINTS TO NAME
	JC	DEL1
	MOV	SI,DI				; SAVE IT
	CALL	SCASB2				; SCAN FOR THE NUL
	XCHG	SI,DI
;SR;
; If we have only one env string, then the double null is lost when the last
;string is deleted and we have an invalid empty environment with only a 
;single null. To avoid this, we will look for the double null case and then
;move an extra null char.
; Bugbug: The only possible problem is that the last pathstring 
;will be followed by a triple null. Is this really a problem?
;
	cmp	byte ptr es:[si],0			;null char?
	jnz	not_dnull			;no, we are at a double null
	dec	si				;point at the double null
not_dnull:

	CALL	GETENVSIZ
	SUB	CX,SI
	PUSH	ES
	POP	DS				; ES:DI POINTS TO NAME, DS:SI POINTS TO NEXT NAME
	REP	MOVSB				; DELETE THE NAME

DEL1:
	POP	DS
	POP	SI
	return

FIND_PATH:
	MOV	SI,OFFSET TRANGROUP:PATH_TEXT
	JMP	SHORT FIND_NAME_IN_environment

FIND_PROMPT:
	MOV	SI,OFFSET TRANGROUP:PROMPT_TEXT

FIND_NAME_IN_environment:
;
; Input: DS:SI points to a "=" terminated string
; Output: ES:DI points to the arguments in the environment
;	  zero is set if name not found
;	  carry flag is set if name not valid format
;
	CALL	FIND				; FIND THE NAME
	retc					; CARRY MEANS NOT FOUND
	JMP	SCASB1				; SCAN FOR = SIGN
;
; On return of FIND1, ES:DI points to beginning of name
;
FIND:
	CLD
	CALL	COUNT0				; CX = LENGTH OF NAME
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	MOV	ES,[ENVIRSEG]
ASSUME	ES:NOTHING
	XOR	DI,DI

FIND1:
	PUSH	CX
	PUSH	SI
	PUSH	DI

FIND11:
	LODSB
	CALL	TESTKANJ
	JZ	NOTKANJ3
	DEC	SI
	LODSW
	INC	DI
	INC	DI
	CMP	AX,ES:[DI-2]
	JNZ	FIND12
	DEC	CX
	LOOP	FIND11
	JMP	SHORT FIND12

NOTKANJ3:
	CALL	UPCONV
	INC	DI
	CMP	AL,ES:[DI-1]
	JNZ	FIND12
	LOOP	FIND11

FIND12:
	POP	DI
	POP	SI
	POP	CX
	retz
	PUSH	CX
	CALL	SCASB2				; SCAN FOR A NUL
	POP	CX
	CMP	BYTE PTR ES:[DI],0
	JNZ	FIND1
	STC					; INDICATE NOT FOUND
	return

COUNT0:
	PUSH	DS
	POP	ES
	MOV	DI,SI

COUNT1:
	PUSH	DI				; COUNT NUMBER OF CHARS UNTIL "="
	CALL	SCASB1
	JMP	SHORT COUNTX

COUNT2:
	PUSH	DI				; COUNT NUMBER OF CHARS UNTIL NUL
	CALL	SCASB2

COUNTX:
	POP	CX
	SUB	DI,CX
	XCHG	DI,CX
	return

MOVE_NAME:
	CMP	BYTE PTR DS:[SI],13
	retz
	LODSB

;;;;	IFDEF	DBCS			3/3/KK
	CALL	TESTKANJ
	JZ	NOTKANJ1
	CALL	STORE_CHAR
	LODSB
	CALL	STORE_CHAR
	JMP	SHORT MOVE_NAME

NOTKANJ1:
;;;;	ENDIF				3/3/KK

	CALL	UPCONV
	CALL	STORE_CHAR
	CMP	AL,'='
	JNZ	MOVE_NAME
	return

GETARG:
	MOV	SI,80H
	LODSB
	OR	AL,AL
	retz
	invoke	SCANOFF
	CMP	AL,13
	return

;
; Point ES:DI to the final NULL string.  Note that in an empty environment,
; there is NO double NULL, merely a string that is empty.
;
SCAN_DOUBLE_NULL:
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	MOV	ES,[ENVIRSEG]
ASSUME	ES:NOTHING
	XOR	DI,DI
;
; Top cycle-point.  If the string here is empty, then we are done
;
SDN1:
	cmp	byte ptr es:[di],0		; nul string?
	retz					; yep, all done
	CALL	SCASB2
	JMP	SDN1

SCASB1:
	MOV	AL,'='                          ; SCAN FOR AN =
	JMP	SHORT SCASBX
SCASB2:
	XOR	AL,AL				; SCAN FOR A NUL
SCASBX:
	MOV	CX,100H
	REPNZ	SCASB
	return
;Bugbug: This is Kanji stuff - put it in conditionals

TESTKANJ:
	push	ds				;AN000;  3/3/KK
	push	si				;AN000;  3/3/KK
	push	ax				;AN000;  3/3/KK
	mov	ds,cs:[resseg]			;AN000;  Get resident segment
	assume	ds:resgroup			;AN000;
	lds	si,dbcs_vector_addr		;AN000;  get DBCS vector
ktlop:						;AN000;  3/3/KK
	cmp	word ptr ds:[si],0		;AN000;  end of Table	3/3/KK
	je	notlead 			;AN000;  3/3/KK
	pop	ax				;AN000;  3/3/KK
	push	ax				;AN000;  3/3/KK
	cmp	al, byte ptr ds:[si]		;AN000;  3/3/KK
	jb	notlead 			;AN000;  3/3/KK
	inc	si				;AN000;  3/3/KK
	cmp	al, byte ptr ds:[si]		;AN000;  3/3/KK
	jbe	islead				;AN000;  3/3/KK
	inc	si				;AN000;  3/3/KK
	jmp	short ktlop			;AN000;  try another range ; 3/3/KK
Notlead:					;AN000;  3/3/KK
	xor	ax,ax				;AN000;  set zero 3/3/KK
	jmp	short ktret			;AN000;  3/3/KK
Islead: 					;AN000;  3/3/KK
	xor	ax,ax				;AN000;  reset zero  3/3/KK
	inc	ax				;AN000;  3/3/KK
ktret:						;AN000;  3/3/KK
	pop	ax				;AN000;  3/3/KK
	pop	si				;AN000;  3/3/KK
	pop	ds				;AN000;  3/3/KK
	return					;AN000;  3/3/KK
;-------------------------------------		;3/3/KK


; ****************************************************************
; *
; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
; *
; * FUNCTION:	 This routine returns the upper case equivalent of
; *		 the character in AL from the file upper case table
; *		 in DOS if character if above  ascii 128, else
; *		 subtracts 20H if between "a" and "z".
; *
; * INPUT:	 AL	      char to be upper cased
; *		 FUCASE_ADDR  set to the file upper case table
; *
; * OUTPUT:	 AL	      upper cased character
; *
; ****************************************************************

assume	ds:trangroup				;AN000;

upconv	proc	near				;AN000;

	cmp	al,80h				;AN000;  see if char is > ascii 128
	jb	oth_fucase			;AN000;  no - upper case math
	sub	al,80h				;AN000;  only upper 128 chars in table
	push	ds				;AN000;
	push	bx				;AN000;
	mov	ds,[resseg]			;AN000;  get resident data segment
assume	ds:resgroup				;AN000;
	lds	bx,dword ptr fucase_addr+1	;AN000;  get table address
	add	bx,2				;AN000;  skip over first word
	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
	pop	bx				;AN000;
	pop	ds				;AN000;
assume	ds:trangroup				;AN000;
	jmp	short upconv_end		;AN000;  we finished - exit

oth_fucase:					;AN000;
	cmp	al,small_a			;AC000; if between "a" and "z",
	jb	upconv_end			;AC000;     subtract 20h to get
	cmp	al,small_z			;AC000;    upper case equivalent.
	ja	upconv_end			;AC000;
	sub	al,20h				;AC000; Change lower-case to upper

upconv_end:					;AN000;
	ret

upconv	endp					;AN000;


;
; STORE A CHAR IN environment, GROWING IT IF NECESSARY
;
STORE_CHAR:
	PUSH	CX
	PUSH	BX
	PUSH	ES				;AN056;
	PUSH	DS				;AN056; Save local DS
	MOV	DS,[RESSEG]			;AN056; Get resident segment
	ASSUME	DS:RESGROUP			;AN056;
	MOV	ES,[ENVIRSEG]			;AN056; Get environment segment
	ASSUME	ES:NOTHING			;AN056;
	POP	DS				;AN056; Get local segment back
	ASSUME	DS:TRANGROUP			;AN056;
	CALL	GETENVSIZ
	MOV	BX,CX
	SUB	BX,2				; SAVE ROOM FOR DOUBLE NULL
	CMP	DI,BX
	JB	STORE1

	PUSH	AX
	PUSH	CX
	PUSH	BX				; Save Size of environment
	invoke	FREE_TPA
	POP	BX
	ADD	BX,2				; Recover true environment size

	CMP	BX, 8000H			; Don't let environment grow > 32K
	JB	ENVSIZ_OK
BAD_ENV_SIZE:					;AN056;
	STC
	JMP	SHORT ENVNOSET
ENVSIZ_OK:

	MOV	CL,4
	SHR	BX,CL				; Convert back to paragraphs
	INC	BX				; Try to grow environment by one para
	MOV	CX,ES				;AN056; Get environment segment
	ADD	CX,BX				;AN056; Add in size of environment
	ADD	CX,020H 			;AN056; Add in some TPA
	MOV	AX,CS				;AN056; Get the transient segment
	CMP	CX,AX				;AN056; Are we hitting the transient?
	JNB	BAD_ENV_SIZE			;AN056; Yes - don't do it!!!
	MOV	AH,SETBLOCK
	INT	21h
ENVNOSET:
	PUSHF
	PUSH	ES
	MOV	ES,[RESSEG]
	invoke	ALLOC_TPA
	POP	ES
	POPF
	POP	CX
	POP	AX
	JNC	STORE1
	POP	ES				;AN056;
	MOV	DX,OFFSET TRANGROUP:ENVERR_ptr
	JMP	CERROR
STORE1:
	STOSB
	MOV	WORD PTR ES:[DI],0		; NULL IS AT END
	POP	ES				;AN056;
	POP	BX
	POP	CX
	return

GETENVSIZ:
;Get size of environment in bytes, rounded up to paragraph boundry
;ES has environment segment
;Size returned in CX, all other registers preserved

	PUSH	ES
	PUSH	AX
	MOV	AX,ES
	DEC	AX				;Point at arena
	MOV	ES,AX
	MOV	AX,ES:[arena_size]
	MOV	CL,4
	SHL	AX,CL				;Convert to bytes
	MOV	CX,AX
	POP	AX
	POP	ES
	return


ASSUME	DS:TRANGROUP


RESTUDIR1:
	PUSH	DS
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	CMP	[RESTDIR],0
	POP	DS
ASSUME	DS:TRANGROUP
	retz

RESTUDIR:
	MOV	DX,OFFSET TRANGROUP:USERDIR1
	MOV	AH,CHDIR
	INT	21h			; Restore users DIR
	XOR	AL,AL
	invoke	SETREST
RET56:
	return

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tdata.asm ===
page ,132
;	SCCSID = @(#)tdata.asm	4.3 85/05/17
;	SCCSID = @(#)tdata.asm	4.3 85/05/17
TITLE	COMMAND Transient Initialized DATA
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

; MODIFICATION HISTORY
;
;	EE 10-20-83	Changed the drive check indicator bytes (DCIB's) in
;			COMTAB to be a flag byte in which bit 0 is now the
;			DCIB(bit) and bit 1 is on if the command can take
;			switches.
;
;	M003	SR	07/16/90 	Added LoadHigh to command table, added
;					parse control block for LoadHigh
;
;	M008	SA	8/1/90		Remove /h parameter. Eliminate code to
;					internally handle /? message.
;
;	M010	SA	8/5/90		Add support for /l (lowercase) option.
;
;	M016	SR	08/09/90	Added public statements for new error
;				messages for LoadHigh.
;



comment %

The TRANDATA segment contains data that is assumed to have predefined
initial values at the beginning of each command cycle.  It is
included in the transient checksum area.  If values in TRANDATA
change, the transient will be reloaded for the next command cycle.

Modification History
--------------------

8/12/89         DBO     History resumes after six years.

8/12/89         DBO     Added for new DIR:
-8/14/89                DirEnvVar, AttrLtrs, OrderLtrs;
                        New PARSE_DIR and subordinate parse blocks
                        (called PARSE_DIR_E for now);

%




fmt macro   name,string,args
	local	a
a	db  string
PUBLIC	name
name	dw  offset trangroup:a
irp val,<args>
	dw  offset trangroup:val
endm
endm

btab	macro	b,sym
    db	b
    dw	    offset trangroup:sym
    endm

.xlist
.xcref
	INCLUDE version.inc
	INCLUDE comsw.asm				;AC000;
	INCLUDE comseg.asm
	INCLUDE dirent.inc				;AN042;
.list
.cref

BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
ENDM

;
; WARNING: DO NOT INCLUDE DOSSYM.INC BECAUSE IT DESTROYS THE MACRO 'FMT' THAT
; has been defined above - RS.
;
	INCLUDE ERROR.INC
	INCLUDE ifequ.asm
	INCLUDE comequ.asm
;	Note curdir.inc is included by comequ.asm

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg_buf:BYTE
	EXTRN	bwdbuf:byte
	EXTRN	bytes_free:WORD
	EXTRN	charbuf:byte
	EXTRN	copy_Num:WORD
	EXTRN	DATE_OUTPUT:BYTE	;AC000;
	EXTRN	Dir_Num:WORD
ifdef DBLSPACE_HOOKS
	EXTRN	Dir_CRatio_1:BYTE
	EXTRN	Dir_CRatio_2:BYTE
endif
	EXTRN	DRIVE_OUTPUT:BYTE	;AC000;
	EXTRN	file_size_high:WORD
	EXTRN	file_size_low:WORD
        EXTRN   FileSiz:DWORD           ; accumulated file size for DIR
	EXTRN	major_ver_num:WORD
	EXTRN	minor_ver_num:WORD
	EXTRN	one_char_val:BYTE
	EXTRN	PARSE1_OUTPUT:BYTE	;AC000;
	EXTRN	srcbuf:byte
	EXTRN	string_ptr_2:WORD
	EXTRN	system_cpage:word
	EXTRN	TIME_OUTPUT:BYTE	;AC000;
	EXTRN	vol_drv:BYTE
	EXTRN	vol_serial:dword	;AN000;
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	$CALL:NEAR
	EXTRN	$CHDIR:NEAR
	EXTRN	$EXIT:NEAR
	EXTRN	$FOR:NEAR
	EXTRN	$IF:NEAR
	EXTRN	$MKDIR:NEAR
	EXTRN	$RMDIR:NEAR
	EXTRN	ADD_NAME_TO_ENVIRONMENT:NEAR
	EXTRN	ADD_PROMPT:NEAR
	EXTRN	build_dir_for_prompt:near
	EXTRN	CATALOG:NEAR
	EXTRN	CHCP:NEAR
	EXTRN	CLS:NEAR
	EXTRN	CNTRLC:NEAR
	EXTRN	COPY:NEAR
	EXTRN	CRENAME:NEAR
	EXTRN	CRLF2:NEAR
	EXTRN	CTIME:NEAR
	EXTRN	CTTY:NEAR
	EXTRN	DATE:NEAR
	EXTRN	ECHO:NEAR
	EXTRN	ERASE:NEAR
	EXTRN	GOTO:NEAR
	EXTRN	IFERLEV:NEAR
	EXTRN	IFEXISTS:NEAR
	EXTRN	IFNOT:NEAR
	EXTRN	PATH:NEAR
	EXTRN	PAUSE:NEAR
	EXTRN	PRINT_B:NEAR
	EXTRN	PRINT_BACK:NEAR
	EXTRN	PRINT_DATE:NEAR
	EXTRN	PRINT_CHAR:NEAR
	EXTRN	PRINT_DRIVE:NEAR
	EXTRN	PRINT_EQ:NEAR
	EXTRN	PRINT_ESC:NEAR
	EXTRN	PRINT_G:NEAR
	EXTRN	PRINT_L:NEAR
	EXTRN	PRINT_TIME:NEAR
	EXTRN	PRINT_VERSION:NEAR
	EXTRN	SHIFT:NEAR
	EXTRN	TCOMMAND:NEAR
	EXTRN	TRUENAME:NEAR		;AN000;
	EXTRN	TYPEFIL:NEAR
	EXTRN	VERSION:NEAR
	EXTRN	VOLUME:NEAR
	EXTRN	VERIFY:NEAR

	extrn	LoadHigh:NEAR		; M003
;
; WARNING!!! No code may appear after this label!!!!
;
;
; Bugbug:
;   8/12/89 Looks like somebody ignored/missed this warning.  TRANCODE
;           is added to at the end of this file.  Fortunately, it looks
;           like no modules refer to this label.
;
PUBLIC	TranCodeLast
TranCodeLast	LABEL	BYTE
TRANCODE	ENDS

; Data for transient portion

TRANDATA	SEGMENT PUBLIC BYTE

	PUBLIC	accden_ptr		;AN000;
	PUBLIC	acrlf_ptr		;AN000;
	PUBLIC	arg_buf_ptr		;AN000;
        PUBLIC  AttrLtrs
	PUBLIC	badbat_ptr		;AN000;
	PUBLIC	badcd_ptr		;AN000;
	PUBLIC	badCPmes_ptr		;AN000;
	PUBLIC	badcurdrv		;AN000;
	PUBLIC	baddat_ptr		;AN000;
	PUBLIC	baddev_ptr		;AN000;
	PUBLIC	baddrv_ptr		;AN000;
	PUBLIC	badlab_ptr		;AN000;
	PUBLIC	badmkd_ptr		;AN000;
	PUBLIC	badnam_ptr		;AN000;
	PUBLIC	bad_on_off_ptr		;AN000;
	PUBLIC	badPmes_ptr		;AN000;
	PUBLIC	badrmd_ptr		;AN000;
	PUBLIC	badtim_ptr		;AN000;
	PUBLIC	batext
        PUBLIC  bytes_ptr
	PUBLIC	bytmes_ptr		;AN000;
	PUBLIC	CLSSTRING
	PUBLIC	comext
        PUBLIC  comspec_flag            ;AN071;
	PUBLIC	COMSPECSTR
	PUBLIC	COMTAB
	PUBLIC	copied_ptr		;AN000;
	PUBLIC	cp_active_ptr		;AN000;
	PUBLIC	cp_not_all_ptr		;AN000;
	PUBLIC	cp_not_set_ptr		;AN000;
	PUBLIC	ctrlcmes_ptr		;AN000;
	PUBLIC	curdat_mo_day		;AN000;
	PUBLIC	curdat_ptr		;AN000;
	PUBLIC	curdat_yr		;AN000;
	PUBLIC	curtim_hr_min		;AN000;
	PUBLIC	curtim_ptr		;AN000;
	PUBLIC	curtim_sec_hn		;AN000;
	PUBLIC	dback_ptr		;AN000;
	PUBLIC	del_Y_N_ptr		;AN000;
	PUBLIC	devwmes_ptr		;AN000;
        PUBLIC  dircont_ptr
	PUBLIC	dirdattim_ptr		;AN000;
ifdef DBLSPACE_HOOKS
	PUBLIC	DirCompRatio_Ptr
	PUBLIC	AveCompRatio_Ptr
endif
	PUBLIC	dirdat_mo_day		;AN000;
	PUBLIC	dirdat_yr		;AN000;
        PUBLIC  DirEnvVar
	PUBLIC	dirhead_ptr		;AN000;
	PUBLIC	dirmes_ptr		;AN000;
	PUBLIC	dirtim_hr_min		;AN000;
	PUBLIC	dirtim_sec_hn		;AN000;
        PUBLIC  DIR_SW_PTRS
	PUBLIC	disp_file_size_ptr	;AN000;
	PUBLIC	DosHma_Ptr
	PUBLIC	DosLow_Ptr
	PUBLIC	DosRev_Ptr
	PUBLIC	DosRom_Ptr
	PUBLIC	dmes_ptr		;AN000;
	PUBLIC	echomes_ptr		;AN000;
	PUBLIC	enverr_ptr		;AN000;
        PUBLIC  errparsenv_ptr
	PUBLIC	eurdat_ptr		;AN000;
	PUBLIC	exeext
	PUBLIC	extend_buf_off		;AN000;
	PUBLIC	extend_buf_ptr		;AN000;
	PUBLIC	extend_buf_seg		;AN000;
	PUBLIC	extend_buf_sub		;AN000;
	PUBLIC	file_name_ptr		;AN000;
	PUBLIC	fornestmes_ptr		;AN000;
	PUBLIC	fuldir_ptr		;AN000;
	PUBLIC	IFTAB
	PUBLIC	inBdev_ptr		;AN000;
	PUBLIC	inornot_ptr		;AN000;
	PUBLIC	Inv_code_page		;AN000;
	PUBLIC	inval_path_ptr		;AN000;
	PUBLIC	japdat_ptr		;AN000;
	PUBLIC	Losterr_ptr		;AN000;
	PUBLIC	md_exists_ptr		;AN006;
	PUBLIC	msg_cont_flag		;AN000;
	PUBLIC	msg_disp_class		;AN000;
	PUBLIC	needbat_ptr		;AN000;
	PUBLIC	newdat_format		;AN000;
	PUBLIC	newdat_ptr		;AN000;
	PUBLIC	newtim_ptr		;AN000;
	PUBLIC	NLSFUNC_ptr		;AN000;
	PUBLIC	nospace_ptr		;AN000;
	PUBLIC	no_values		;AN000;
	PUBLIC	nulpath_ptr		;AN000;
	PUBLIC	offmes_ptr		;AN000;
	PUBLIC	onmes_ptr		;AN000;
        PUBLIC  OrderLtrs               ; list of sort order letters for DIR
	PUBLIC	overwr_ptr		;AN000;
	PUBLIC	PARSE_BREAK		;AN000;
	PUBLIC	PARSE_CHCP		;AN000;
	PUBLIC	PARSE_CHDIR		;AN000;
	PUBLIC	PARSE_CTTY		;AN000;
	PUBLIC	PARSE_DATE		;AN000;
	PUBLIC	PARSE_DIR		;AN000;
	PUBLIC	PARSE_ERASE		;AN000;
	PUBLIC	PARSE_MRDIR		;AN000;
	PUBLIC	PARSE_RENAME		;AN000;
	PUBLIC	PARSE_TIME		;AN000;
	PUBLIC	PARSE_VER
	PUBLIC	PARSE_VOL		;AN000;

	public	Parse_LoadHi		; Parse block for LoadHigh; M003

	PUBLIC	PATH_TEXT
	PUBLIC	pausemes_ptr		;AN000;
	PUBLIC	pipeEmes_ptr		;AN000;
	PUBLIC	promptdat_moday 	;AN000;
	PUBLIC	promptdat_ptr		;AN000;
	PUBLIC	promptdat_yr		;AN000;
	PUBLIC	PROMPT_TABLE
	PUBLIC	PROMPT_TEXT
	PUBLIC	promtim_hr_min		;AN000;
	PUBLIC	promtim_ptr		;AN000;
	PUBLIC	promtim_sec_hn		;AN000;
	PUBLIC	renerr_ptr		;AN000;
	PUBLIC	SLASH_P_SYN		;AN000;
	PUBLIC	string_buf_ptr		;AN000;
	PUBLIC	suremes_ptr		;AN000;
	PUBLIC	switch_list
	PUBLIC	syntmes_ptr		;AN000;
	PUBLIC	tab_ptr 		;AN000;
        PUBLIC  total_ptr
	PUBLIC	TRANDATAEND
	PUBLIC	usadat_ptr		;AN000;
	PUBLIC	verimes_ptr		;AN000;
	PUBLIC	vermes_ptr		;AN000;
	PUBLIC	volmes_ptr		;AN000;
	PUBLIC	volmes_ptr_2		;AN000;
	PUBLIC	volsermes_ptr		;AN000;
	PUBLIC	WEEKTAB

	public	NoExecBat_Ptr		; M016
	public	LhInvFil_Ptr		; M016
	public	NoCntry_Ptr		; M045
	public	LhInvArg_Ptr
	public	ReqParmMiss
	public	LhInvSwt_Ptr
	public	LhBadUMB_Ptr

INCLUDE tranmsg.asm

; Lists of help message numbers for internal commands and /?

;;NoHelpMsgs	dw	1200,0		;M014
BreakHelpMsgs	dw	1300,0
ChcpHelpMsgs	dw	1320,1321,0
CdHelpMsgs	dw	1340,1341,1342,0
ClsHelpMsgs	dw	1360,0
CopyHelpMsgs	dw	1400,1401,1402,1403,1404,0
CttyHelpMsgs	dw	1420,0
DateHelpMsgs	dw	1440,1441,0
DelHelpMsgs	dw	1460,1461,1462,0
ifdef DBLSPACE_HOOKS
DirHelpMsgs	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,0
else
DirHelpMsgs	dw	1480,1493,1482,1483,1484,1485,1486,1487,1489,1494,1492,0
endif
ExitHelpMsgs	dw	1500,0
MdHelpMsgs	dw	1520,0
PathHelpMsgs	dw	1540,1541,1542,0
PromptHelpMsgs	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
RdHelpMsgs	dw	1580,0
RenHelpMsgs	dw	1600,1601,1602,0
SetHelpMsgs	dw	1620,1621,1622,0
TimeHelpMsgs	dw	1640,1641,0
TypeHelpMsgs	dw	1660,0
VerHelpMsgs	dw	1680,0
VerifyHelpMsgs	dw	1700,0
VolHelpMsgs	dw	1720,0

CallHelpMsgs	dw	1740,1741,0	;M014
RemHelpMsgs	dw	1760,0		;M014
PauseHelpMsgs	dw	1780,0		;M014
EchoHelpMsgs	dw	1800,1801,0	;M014
GotoHelpMsgs	dw	1820,1821,0	;M014
ShiftHelpMsgs	dw	1840,0		;M014
IfHelpMsgs	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
ForHelpMsgs	dw	1880,1881,1882,1883,0	;M014
TruenameHelpMsgs dw	1900,0			;M014
LoadhighHelpMsgs dw	1920,1921,1922,1923,1924,1925,1926,1927,0	;M014


CLSSTRING DB	4,01BH,"[2J"            ; ANSI Clear screen

PROMPT_TABLE LABEL BYTE
	btab	"B",Print_B
	btab	"D",PRINT_DATE
	btab	"E",PRINT_ESC
	btab	"G",PRINT_G
	btab	"H",PRINT_BACK
	btab	"L",PRINT_L
	btab	"N",PRINT_DRIVE
	btab	"P",build_dir_for_prompt
	btab	"Q",PRINT_EQ
	btab	"T",PRINT_TIME
	btab	"V",PRINT_VERSION
	btab	"_",CRLF2
	btab	"$",PRINT_CHAR
	DB	0				; NUL TERMINATED

IFTAB	LABEL	BYTE				; Table of IF conditionals
	DB	3,"NOT"                         ; First byte is count
	DW	OFFSET TRANGROUP:IFNOT
	DB	10,"ERRORLEVEL"
	DW	OFFSET TRANGROUP:IFERLEV
	DB	5,"EXIST"
	DW	OFFSET TRANGROUP:IFEXISTS
	DB	0

; Table for internal command names
COMTAB	DB	3,"DIR",fSwitchAllowed+fCheckDrive
	DW	OFFSET TRANGROUP:CATALOG	; In TCMD1.ASM
	DW	TRANGROUP:DirHelpMsgs
	DB	4,"CALL",fSwitchAllowed
	DW	OFFSET TRANGROUP:$CALL		; In TBATCH2.ASM
	DW	TRANGROUP:CallHelpMsgs
	DB	4,"CHCP",fSwitchAllowed
	DW	OFFSET TRANGROUP:CHCP		; In TCMD2B.ASM
	DW	TRANGROUP:ChcpHelpMsgs
	DB	6,"RENAME",fSwitchAllowed+fCheckDrive  ;AC018; P3903
	DW	OFFSET TRANGROUP:CRENAME	; In TCMD1.ASM
	DW	TRANGROUP:RenHelpMsgs
	DB	3,"REN",fSwitchAllowed+fCheckDrive     ;AC018; P3903
	DW	OFFSET TRANGROUP:CRENAME	; In TCMD1.ASM
	DW	TRANGROUP:RenHelpMsgs
	DB	5,"ERASE",fSwitchAllowed+fCheckDrive
	DW	OFFSET TRANGROUP:ERASE		; In TCMD1.ASM
	DW	TRANGROUP:DelHelpMsgs
	DB	3,"DEL",fSwitchAllowed+fCheckDrive
	DW	OFFSET TRANGROUP:ERASE		; In TCMD1.ASM
	DW	TRANGROUP:DelHelpMsgs
	DB	4,"TYPE",fSwitchAllowed+fCheckDrive  ;AC018; P3903
	DW	OFFSET TRANGROUP:TYPEFIL	; In TCMD1.ASM
	DW	TRANGROUP:TypeHelpMsgs
	DB	3,"REM",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:TCOMMAND	; In TCODE.ASM
	DW	TRANGROUP:RemHelpMsgs
	DB	4,"COPY",fSwitchAllowed+fCheckDrive
	DW	OFFSET TRANGROUP:COPY		; In COPY.ASM
	DW	TRANGROUP:CopyHelpMsgs
	DB	5,"PAUSE",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:PAUSE		; In TCMD1.ASM
	DW	TRANGROUP:PauseHelpMsgs
	DB	4,"DATE",fSwitchAllowed
	DW	OFFSET TRANGROUP:DATE		; In TPIPE.ASM
	DW	TRANGROUP:DateHelpMsgs
	DB	4,"TIME",fSwitchAllowed         ;AC018; P3903
	DW	OFFSET TRANGROUP:CTIME		; In TPIPE.ASM
	DW	TRANGROUP:TimeHelpMsgs
	DB	3,"VER",fSwitchAllowed
	DW	OFFSET TRANGROUP:VERSION	; In TCMD2.ASM
	DW	TRANGROUP:VerHelpMsgs
	DB	3,"VOL",fSwitchAllowed+fCheckDrive   ;AC018; P3903
	DW	OFFSET TRANGROUP:VOLUME 	; In TCMD1.ASM
	DW	TRANGROUP:VolHelpMsgs
	DB	2,"CD",fSwitchAllowed+fCheckDrive    ;AC018; P3903
	DW	OFFSET TRANGROUP:$CHDIR 	; In TENV.ASM
	DW	TRANGROUP:CdHelpMsgs
	DB	5,"CHDIR",fSwitchAllowed+fCheckDrive ;AC018; P3903
	DW	OFFSET TRANGROUP:$CHDIR 	; In TENV.ASM
	DW	TRANGROUP:CdHelpMsgs
	DB	2,"MD",fSwitchAllowed+fCheckDrive    ;AC018; P3903
	DW	OFFSET TRANGROUP:$MKDIR 	; In TENV.ASM
	DW	TRANGROUP:MdHelpMsgs
	DB	5,"MKDIR",fSwitchAllowed+fCheckDrive ;AC018; P3903
	DW	OFFSET TRANGROUP:$MKDIR 	; In TENV.ASM
	DW	TRANGROUP:MdHelpMsgs
	DB	2,"RD",fSwitchAllowed+fCheckDrive    ;AC018; P3903
	DW	OFFSET TRANGROUP:$RMDIR 	; In TENV.ASM
	DW	TRANGROUP:RdHelpMsgs
	DB	5,"RMDIR",fSwitchAllowed+fCheckDrive ;AC018; P3903
	DW	OFFSET TRANGROUP:$RMDIR 	; In TENV.ASM
	DW	TRANGROUP:RdHelpMsgs
	DB	5,"BREAK",fSwitchAllowed        ;AC018; P3903
	DW	OFFSET TRANGROUP:CNTRLC 	; In TUCODE.ASM
	DW	TRANGROUP:BreakHelpMsgs
	DB	6,"VERIFY",fSwitchAllowed       ;AC018; P3903
	DW	OFFSET TRANGROUP:VERIFY 	; In TUCODE.ASM
	DW	TRANGROUP:VerifyHelpMsgs
	DB	3,"SET",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:ADD_NAME_TO_ENVIRONMENT; In TENV.ASM
	DW	TRANGROUP:SetHelpMsgs
	DB	6,"PROMPT",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:ADD_PROMPT	; In TENV.ASM
	DW	TRANGROUP:PromptHelpMsgs
	DB	4,"PATH",fSwitchAllowed
	DW	OFFSET TRANGROUP:PATH		; In TCMD2.ASM
	DW	TRANGROUP:PathHelpMsgs
	DB	4,"EXIT",0
	DW	OFFSET TRANGROUP:$EXIT		; In TCMD2.ASM
	DW	TRANGROUP:ExitHelpMsgs
	DB	4,"CTTY",fCheckDrive+fSwitchAllowed
	DW	OFFSET TRANGROUP:CTTY		; In TCMD2.ASM
	DW	TRANGROUP:CttyHelpMsgs
	DB	4,"ECHO",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:ECHO		; In TUCODE.ASM
	DW	TRANGROUP:EchoHelpMsgs
	DB	4,"GOTO",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:GOTO		; In TBATCH.ASM
	DW	TRANGROUP:GotoHelpMsgs
	DB	5,"SHIFT",fSwitchAllowed
	DW	OFFSET TRANGROUP:SHIFT		; In TBATCH.ASM
	DW	TRANGROUP:ShiftHelpMsgs
	DB	2,"IF",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:$IF		; In TBATCH.ASM
	DW	TRANGROUP:IfHelpMsgs
	DB	3,"FOR",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:$FOR		; In TBATCH.ASM
	DW	TRANGROUP:ForHelpMsgs
	DB	3,"CLS",0
	DW	OFFSET TRANGROUP:CLS		; In TCMD2.ASM
	DW	TRANGROUP:ClsHelpMsgs
	DB	8,"TRUENAME",fSwitchAllowed+fCheckDrive  ;AN000; P3903 changed
	DW	OFFSET TRANGROUP:TRUENAME	;AN000;
	DW	TRANGROUP:TruenameHelpMsgs
	DB	8,"LOADHIGH",fSwitchAllowed	; M003
	DW	OFFSET TRANGROUP:LoadHigh		; In loadhi.asm ; M003
	DW	TRANGROUP:LoadhighHelpMsgs	; M003
	DB	2,"LH",fSwitchAllowed			; Short form; M003
	DW	OFFSET TRANGROUP:LoadHigh		; In loadhi.asm ; M003
	DW	TRANGROUP:LoadhighHelpMsgs	; M003
	DB	0				; Terminate command table


comext	dB	".COM"
exeext	dB	".EXE"
batext	dB	".BAT"

switch_list	DB	"?VBAPW"                ; flags we can recognize

AttrLtrs        DB      "RHSvDA"                ; attribute letters for DIR

;               Attribute letters in AttrLtrs must appear in the order that
;               attribute bits occur in the attribute byte returned by
;               directory searches, starting with bit 0.
;               The volume label attribute is lowercased to keep it from
;               being matched (by an uppercase comparison).

ifdef DBLSPACE_HOOKS
OrderLtrs	DB	"NEDSGC"		; sort order letters for DIR
else
OrderLtrs	DB	"NEDSG" 		; sort order letters for DIR
endif
;               Sort order letters stand for file name, extension,
;		date/time, size, grouped (directory files before others),
;		and compression ratio.	DIR routines rely on the specific
;		order of the letters in this list.

comspec_flag    db      0                       ;AN071;



PUBLIC	BatBufLen
BatBufLen   DW	BatLen

; *****************************************************
; EMG 4.00
; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
; *****************************************************

;
; COMMON PARSE BLOCKS
;

;
; Indicates no value list for PARSE.
;

NO_VALUES	DW	0			;AN000;  no values

NULL_VALUE_LIST LABEL   BYTE                    ; for unvalidated value
                DB      0                       ; no value lists

;
; PARSE control block for a required file specification (upper cased)
;

FILE_REQUIRED	LABEL	BYTE			;AN000;
		DW	0200H			;AN000;  filespec - required
		DW	1			;AN000;  capitalize - file table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE control block for an optional file specification (upper cased)
; or drive number
;

FILE_OPTIONAL	LABEL	BYTE			;AN000;
		DW	0301H			;AN000;  filespec or drive number
						;	 optional
		DW	1			;AN000;  capitalize - file table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE control block for an optional file specification (upper cased)
;

FILE_OPTIONAL2  LABEL   BYTE                    ;AN000;
                DW      0201H                   ;AN000;  filespec optional
                DW      1                       ;AN000;  capitalize - file table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE control block for an optional /P switch
;

SLASH_P_SWITCH	LABEL	BYTE			;AN000;
		DW	0			;AN000;  no match flags
		DW	2			;AN000;  capitalize - char table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	1			;AN000;  1 keyword
SLASH_P_SYN	DB	"/P",0                  ;AN000;  /P switch



; PARSE BLOCK FOR BREAK, VERIFY, ECHO

;
; The following parse control block can be used for any command which
; needs only the optional "ON" and "OFF" keywords as operands.  Allows
; the equal sign as an additional delimiter.  Returns verified result
; in PARSE1_OUTPUT.  Currently used for the BREAK, VERIFY, and	ECHO
; internal commands.
;

PARSE_BREAK	LABEL	BYTE			;AN000;
		DW	TRANGROUP:BREAK_PARMS	;AN000;
		DB	0			;AN032; no extra delimiter

BREAK_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:BREAK_CONTROL1;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

BREAK_CONTROL1	LABEL	BYTE			;AN000;
		DW	2001H			;AN000;  string value - optional
		DW	2			;AN000;  capitalize - char table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:BREAK_VALUES	;AN000;
		DB	0			;AN000;  no keywords

BREAK_VALUES	LABEL	BYTE			;AN000;
		DB	3			;AN000;
		DB	0			;AN000;  no ranges
		DB	0			;AN000;  no numeric values
		DB	2			;AN000;  2 string values
		DB	0			;AN000;  returned if ON
		DW	TRANGROUP:BREAK_ON	;AN000;  point to ON string
		DB	'f'                     ;AN000;  returned if OFF
		DW	TRANGROUP:BREAK_OFF	;AN000;  point to OFF string

BREAK_ON	DB	"ON",0                  ;AN000;
BREAK_OFF	DB	"OFF",0                 ;AN000;

;
; PARSE BLOCK FOR CHCP
;

;
; The following parse control block can be used for any command which
; needs only one optional three digit decimal parameter for operands.
; Returns verified result in PARSE1_OUTPUT.  Currently used for the
; CHCP internal command.
;
CHCP_MINVAL	EQU	100			;AN000;
CHCP_MAXVAL	EQU	999			;AN000;

PARSE_CHCP	LABEL	BYTE			;AN000;
		DW	TRANGROUP:CHCP_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

CHCP_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:CHCP_CONTROL1 ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

CHCP_CONTROL1	LABEL	BYTE			;AN000;
		DW	8001H			;AN000;  numeric value - optional
		DW	0			;AN000;  no function flags
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:CHCP_VALUES	;AN000;
		DB	0			;AN000;  no keywords

CHCP_VALUES	LABEL	BYTE			;AN000;
		DB	1			;AN000;
		DB	1			;AN000;  1 range
		DB	1			;AN000;  returned if result
		DD	CHCP_MINVAL,CHCP_MAXVAL ;AN000;  minimum & maximum value
		DB	0			;AN000;  no numeric values
		DB	0			;AN000;  no string values


;
; PARSE BLOCK FOR DATE
;

;
; The following parse control block can be used for any command which
; needs only an optional date string as an operand.  Returns unverified
; result in DATE_OUTPUT.  Currently used for the DATE internal command.
;

PARSE_DATE	LABEL	BYTE			;AN000;
		DW	TRANGROUP:DATE_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

DATE_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:DATE_CONTROL1 ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

DATE_CONTROL1	LABEL	BYTE			;AN000;
		DW	1001H			;AN000;  date - optional
		DW	0			;AN000;  no function flags
		DW	TRANGROUP:DATE_OUTPUT	;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR TIME
;

;
; The following parse control block can be used for any command which
; needs only an optional time string as an operand.  Returns unverified
; result in TIME_OUTPUT.  Currently used for the TIME internal command.
;

PARSE_TIME	LABEL	BYTE			;AN000;
		DW	TRANGROUP:TIME_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

TIME_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:TIME_CONTROL1 ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

TIME_CONTROL1	LABEL	BYTE			;AN000;
		DW	0801H			;AN000;  TIME - optional
		DW	0			;AN000;  no function flags
		DW	TRANGROUP:TIME_OUTPUT	;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords


;
; PARSE BLOCK FOR VOL
;

;
; The following parse control block can be used for any command which
; needs only an optional drive letter as an operand.  Returns unverified
; drive number (one based) in DRIVE_OUTPUT.  Currently used for the VOL
; internal command.
;

PARSE_VOL	LABEL	BYTE			;AN000;
		DW	TRANGROUP:VOL_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

VOL_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:DRIVE_CONTROL1;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

DRIVE_CONTROL1	LABEL	BYTE			;AN000;
		DW	0101H			;AN000;  DRIVE - optional
		DW	1			;AN000;  capitalize - file table
		DW	TRANGROUP:DRIVE_OUTPUT	;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords


;
; PARSE BLOCK FOR MKDIR, RMDIR, TYPE
;

;
; The following parse control block can be used for any command which
; needs only one required file specification as an operand.  Returns a
; pointer to the unverified string in PARSE1_OUTPUT.  Currently used
; for the MKDIR, RMDIR, and TYPE internal commands.
;

PARSE_MRDIR	LABEL	BYTE			;AN000;
		DW	TRANGROUP:MRDIR_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

MRDIR_PARMS	LABEL	BYTE			;AN000;
		DB	1,1			;AN000;  1 positional parm
		DW	TRANGROUP:FILE_REQUIRED ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR CHDIR, TRUENAME
;

;
; The following parse control block can be used for any command which
; needs only one optional file specification an operand.  Returns a
; pointer to the unverified string in PARSE1_OUTPUT.  Currently used
; for the CHDIR and TRUENAME internal commands.
;

PARSE_CHDIR	LABEL	BYTE			;AN000;
		DW	TRANGROUP:CHDIR_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

CHDIR_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:FILE_OPTIONAL ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR ERASE
;

;
; The following parse control block is used for the DEL/ERASE internal
; commands.  This command has one required file specification and an
; optional switch (/p) as operands. The verified switch or unverified
; file specification is returned in PARSE1_OUTPUT.
;

PARSE_ERASE	LABEL	BYTE			;AN000;
		DW	TRANGROUP:ERASE_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

ERASE_PARMS	LABEL	BYTE			;AN000;
		DB	1,1			;AN000;  1 positional parm
		DW	TRANGROUP:FILE_REQUIRED ;AN000;
		DB	1			;AN000;  1 switch
		DW	TRANGROUP:SLASH_P_SWITCH;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR DIR
;

;
; The following parse control block is used for the DIR internal command.
; This command has one optional file specification and several optional
; switches.  Switches, switch values, and the filespec are returned in 
; PARSE1_OUTPUT.
;
; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
; /w, /-w, /p, and /-p.  The string values for /a and /o are optional,
; do not require colons, and are not checked against a value list.
;
; Switch /h has been removed from the DIR command	;M008
; Switch /? is no longer handled internally		;M008
;
; A list of pointers to all the switch synonyms is provided here to
; help identify which switch has been matched.
;

PARSE_DIR	LABEL	BYTE
		DW	TRANGROUP:DIR_PARMS
		DB	0			; no extra delimiters

DIR_PARMS	LABEL	BYTE
		DB	0,1			; 1 optional positional param
		DW	TRANGROUP:FILE_OPTIONAL2
		DB	2			; 2 kinds of switches
		DW	TRANGROUP:DIR_SW_VALUED
		DW	TRANGROUP:DIR_SW_UNVALUED
		DB	0			; no keywords

DIR_SW_VALUED	LABEL	BYTE
		DW	2001H			  ; optional string value
		DW	21H			  ; optional colon; capitalize 
		DW	TRANGROUP:PARSE1_OUTPUT   ; result buffer
		DW	TRANGROUP:NULL_VALUE_LIST ; don't validate value
ifdef DBLSPACE_HOOKS
		DB	3			  ; 3 'synonyms'
else
		DB	2			  ; 2 'synonyms'
endif
DIR_SW_A	DB	"/A",0
DIR_SW_O	DB	"/O",0
ifdef DBLSPACE_HOOKS
DIR_SW_C	DB	"/C",0
endif

DIR_SW_UNVALUED	LABEL	BYTE
		DW	0			  ; no value
		DW	0			  ; no format functions
		DW	TRANGROUP:PARSE1_OUTPUT   ; result buffer
		DW	TRANGROUP:NO_VALUES
ifdef DBLSPACE_HOOKS
		DB	13			  ; 13 'synonyms'
else
		DB	12			  ; 12 'synonyms'
endif
DIR_SW_NEG_A	DB	"/-A",0
DIR_SW_NEG_O	DB	"/-O",0
DIR_SW_S	DB	"/S",0
DIR_SW_NEG_S	DB	"/-S",0
DIR_SW_B	DB	"/B",0
DIR_SW_NEG_B	DB	"/-B",0
DIR_SW_W	DB	"/W",0
DIR_SW_NEG_W	DB	"/-W",0
DIR_SW_P	DB	"/P",0
DIR_SW_NEG_P	DB	"/-P",0
DIR_SW_L	DB	"/L",0			;M010
DIR_SW_NEG_L	DB	"/-L",0 		;M010
ifdef DBLSPACE_HOOKS
DIR_SW_NEG_C	DB	"/-C",0
endif
;
; Here's a list of pointers to DIR's switch synonyms, for easier
; identification.  Order is critical - DIR routines rely on the
; specific order in this list.  Negated options appear at odd 
; positions in the list, and simple on/off options appear first.
;

DIR_SW_PTRS	LABEL	WORD		; list of ptrs to switch synonyms
ifdef DBLSPACE_HOOKS
		DW	TRANGROUP:DIR_SW_NEG_C
		DW	TRANGROUP:DIR_SW_C
endif
		DW	TRANGROUP:DIR_SW_NEG_W
		DW	TRANGROUP:DIR_SW_W
		DW	TRANGROUP:DIR_SW_NEG_P
		DW	TRANGROUP:DIR_SW_P
		DW	TRANGROUP:DIR_SW_NEG_S
		DW	TRANGROUP:DIR_SW_S
		DW	TRANGROUP:DIR_SW_NEG_B
		DW	TRANGROUP:DIR_SW_B
		DW	TRANGROUP:DIR_SW_NEG_L	;M010
		DW	TRANGROUP:DIR_SW_L	;M010
		DW	TRANGROUP:DIR_SW_NEG_O
		DW	TRANGROUP:DIR_SW_O
		DW	TRANGROUP:DIR_SW_NEG_A
		DW	TRANGROUP:DIR_SW_A

;
; PARSE BLOCK FOR RENAME
;

;
; The following parse control block can be used for any command which
; needs only two required file specifications as operands.  Returns
; pointers to the unverified string in PARSE1_OUTPUT.
; Currently used for the RENAME internal command.
;

PARSE_RENAME	LABEL	BYTE			;AN000;
		DW	TRANGROUP:RENAME_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

RENAME_PARMS	LABEL	BYTE			;AN000;
		DB	2,2			;AN000;  2 positional parms
		DW	TRANGROUP:FILE_REQUIRED ;AN000;
		DW	TRANGROUP:FILE_REQUIRED ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR CTTY
;

;
; The following parse control block can be used for any command which
; needs one required device name as an operand.  Returns a pointer to
; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
; internal command.
;

PARSE_CTTY	LABEL	BYTE			;AN000;
		DW	TRANGROUP:CTTY_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

CTTY_PARMS	LABEL	BYTE			;AN000;
		DB	1,1			;AN000;  1 positional parm
		DW	TRANGROUP:CTTY_CONTROL1 ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

CTTY_CONTROL1	LABEL	BYTE			;AN000;
		DW	2000H			;AN000;  string value - required
		DW	11H			;AN000;  capitalize - file table
						;AN000;  remove colon at end
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR VER
;

;
; The following parse control block can be used for any command which
; needs an optional switch "/debug".  Currently used for the VER command.
;

PARSE_VER	LABEL	BYTE
		DW	TRANGROUP:VER_PARMS
		DB	0			; no extra delimiters

VER_PARMS	LABEL	BYTE
		DB	0,0			; no positional parameters
		DB	1			; one switch
		DW	TRANGROUP:SLASH_R
		DB	0			; no keywords

SLASH_R		LABEL	BYTE
		DW	0			; no values
		DW	2			; capitalize by filename table
		DW	TRANGROUP:PARSE1_OUTPUT	; result buffer
		DW	TRANGROUP:NO_VALUES	; no values
		DB	1			; one synonym
SLASH_R_SYN	DB	"/R",0

;
; M003 ; Start of changes for LoadHigh support
;

;
;Parse Control Block for LOADHIGH command
;

Parse_LoadHi	label	byte
	dw	TRANGROUP:LoadHi_Parms	;extended parm table
	db	0			;no extra delimiters

LoadHi_Parms	label	byte
	db	1,1			;min. 1 parm, max. 1 parm
	dw	TRANGROUP:File_Required	;control struc for filename
	db	0			;no switches
	db	0			;no keywords
;
; M003 ; End of changes for LoadHigh support
;

public TempVarName
TempVarName	db	"TEMP=",0

ifdef DBLSPACE_HOOKS
public	sCVFRoot, cbCVFRoot
sCVFRoot	db	"\DBLSPACE."	;Compressed Volume File root file name
cbCVFRoot	equ	$-sCVFRoot
endif

ifdef	BETA3WARN
%out	Take this out before we ship
public Beta3WarnMsg
Beta3WarnMsg	label	byte

  db      '+------------------- WARNING! ------------------+', 0dh, 0ah
  db      '|                                               |', 0dh, 0ah
  db      '|                                               |', 0dh, 0ah
  db      '|  This pre-release version of MS-DOS 6 is out  |', 0dh, 0ah
  db      '|  of date.  Please replace it with an updated  |', 0dh, 0ah
  db      '|  version of MS-DOS 6.                         |', 0dh, 0ah
  db      '|                                               |', 0dh, 0ah
  db      '|                                               |', 0dh, 0ah
  db      '|          <Press any key to continue>          |', 0dh, 0ah
  db      '|                                               |', 0dh, 0ah
  db      '+-----------------------------------------------+', 0dh, 0ah
  db	  '$'
endif


TRANDATA	ENDS

TRANCODE	SEGMENT PUBLIC BYTE		;AN000;

.xlist
.xcref

INCLUDE SYSMSG.INC				;AN000;

.list
.cref

ASSUME DS:TRANGROUP,ES:TRANGROUP,CS:TRANGROUP

MSG_UTILNAME <COMMAND>				;AN000; define utility name

MSG_SERVICES <COMT,COMMAND.CLF,COMMAND.CL1,COMMAND.CL2> ;AN000; The transient messages

include msgdcl.inc

TRANCODE	ENDS				;AN000;

TRANDATA	SEGMENT PUBLIC BYTE

TRANDATAEND	LABEL	BYTE

TRANDATA	ENDS				;AN000;

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tparse.asm ===
page ,132
;	SCCSID = @(#)tparse.asm 4.1 87/04/28
;	SCCSID = @(#)tparse.asm 4.1 87/04/28
TITLE	COMMAND interface to SYSPARSE
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

.xlist
.xcref
	include comsw.asm
	include comseg.asm		;an000;
.list
.cref

TRANSPACE	SEGMENT PUBLIC BYTE	;AN000;

	CmpxSW	equ	0		;AN000; do not check complex list
	KeySW	equ	0		;AN000; do not support keywords
	Val2SW	equ	0		;AN000; do not Support value definition 2
	IncSW	equ	0		;AN000; do not include psdata.inc
	QusSW	equ	0		;AN025; do not include quoted string
	LFEOLSW equ	0		;AN044; do not use 0ah as line terminator

.xlist
.xcref

include psdata.inc			;AN000;

.list
.cref

TRANSPACE	ENDS			;AN000;

TRANCODE	SEGMENT PUBLIC BYTE	;AN000;

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING	 ;AN054;

; ****************************************************************
; *
; * ROUTINE:	 CMD_PARSE
; *
; * FUNCTION:	 Interface for transient COMMAND to invoke
; *		 SYSPARSE.
; *
; * INPUT:	 inputs to SYSPARSE
; *
; * OUTPUT:	 outputs from SYSPARSE
; *
; ****************************************************************

	public	Cmd_parse		;AN000;

.xlist
.xcref
	INCLUDE parse.asm		;AN000;
.list
.cref

Cmd_parse	Proc  near		;AN000;

	call	sysparse		;AN000;

	ret				;AN000;

Cmd_parse	endp			;AN000;

	public	Append_parse		;AN010;

Append_parse	Proc  Far		;AN010;

	call	sysparse		;AN010;

	ret				;AN010;

Append_parse	endp			;AN010;

trancode    ends			;AN000;
	    end 			;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tmisc1.asm ===
page ,132
;	SCCSID = @(#)tmisc1.asm 4.1 85/09/22
;	SCCSID = @(#)tmisc1.asm 4.1 85/09/22
TITLE	Part7 COMMAND Transient Routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;	M003	SR	07/16/90	Made Execute public to jump to it for
;				LoadHigh support
;
;	M025	SR	9/12/90	Removed calls to SetStdInOn,SetStdInOff
;				SetStdOutOn & SetStdOutOff.
;


;	More misc routines

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include comseg.asm
	include comequ.asm
.list
.cref



CODERES 	SEGMENT PUBLIC BYTE	;AC000;
;;	EXTRN	RSTACK:BYTE
CodeRes 	ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	CALL_FLAG:BYTE
	EXTRN	EchoFlag:BYTE
	EXTRN	EXEC_BLOCK:BYTE
	EXTRN	EXTCOM:BYTE
	EXTRN	LenMsgOrPathBuf:ABS
	EXTRN	PIPEFLAG:BYTE
	EXTRN	PIPEPTR:WORD
	EXTRN	PIPESTR:BYTE
	EXTRN	RESTDIR:BYTE
	EXTRN	RE_OUT_APP:BYTE
	EXTRN	RE_OUTSTR:BYTE
	EXTRN	SAFEPATHBUFFER:BYTE

	extrn	RStack:word

ifdef	BETA3WARN
        %out    BETA WARNING: Take this out before we ship retail product
	EXTRN	Beta3Warned:byte
	EXTRN	TrnSeg:word
endif


DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADDRV_PTR:WORD
	EXTRN	BADNAM_PTR:WORD
	EXTRN	COMTAB:BYTE		;AC000;
	EXTRN	extend_buf_ptr:word	;AN000;
	EXTRN	msg_disp_class:byte	;AN000;

ifdef	BETA3WARN
        %out    BETA WARNING: Take this out before we ship retail product
	EXTRN	Beta3WarnMsg:byte
endif

TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
	EXTRN	ALLSWITCH:WORD
	EXTRN	APPEND_EXEC:BYTE	;AN041;
	EXTRN	CHKDRV:BYTE
	EXTRN	COMBUF:BYTE
	EXTRN	COMSW:WORD
	EXTRN	EXECPATH:BYTE
	EXTRN	EXEC_ADDR:DWORD
	EXTRN	FILTYP:BYTE
	EXTRN	IDLEN:BYTE
	EXTRN	KPARSE:BYTE		;AC000;
	EXTRN	PARM1:BYTE
	EXTRN	PARM2:BYTE
	EXTRN	PathPos:word
	EXTRN	RESSEG:WORD
	EXTRN	RE_INSTR:BYTE
	EXTRN	SPECDRV:BYTE
	EXTRN	SWITCHAR:BYTE
	EXTRN	switch_list:byte
	EXTRN	TRAN_TPA:WORD

IFDEF ROMEXEC
	EXTRN	ExecFromROM:byte
	EXTRN	fbuf:byte
ENDIF

	IF  IBM_ROM_FIND
	EXTRN	ROM_CALL:BYTE
	EXTRN	ROM_CS:WORD
	EXTRN	ROM_IP:WORD
	ENDIF

TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC byte

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	APPEND_PARSE:NEAR	;AN010;
	EXTRN	BATCOM:NEAR
	EXTRN	DOCOM1:NEAR
	EXTRN	PIPEERRSYN:NEAR
	EXTRN	TCOMMAND:NEAR

	IF	IBM_ROM_FIND
	EXTRN	ROM_EXEC:NEAR
	EXTRN	ROM_SCAN:NEAR
	ENDIF

	PUBLIC	CERROR
	PUBLIC	DRVBAD
	PUBLIC	EXTERNAL
	PUBLIC	FNDCOM
	PUBLIC	PRESCAN
	PUBLIC	SWITCH

	public	Lh_Execute			; M051


ASSUME	DS:TRANGROUP

;---------------------------
; We can get rid of this switch processing code if we can take
; care of the remaining two calls to switch, later in the file.
; However, I have not checked whether or not any other files use
; switch -- after all, it IS public!
;---------------------------

SWCOUNT EQU	6				; Length of switch_list

RETSW:
	XCHG	AX,BX				; Put switches in AX
	return

SWITCH:
	XOR	BX,BX				; Initialize - no switches set
SWLOOP:
	INVOKE	SCANOFF 			; Skip any delimiters
	CMP	AL,[SWITCHAR]			; Is it a switch specifier?
	JNZ	RETSW				; No -- we're finished
	OR	BX,fSwitch			; Indicate there is a switch specified
	INC	SI				; Skip over the switch character
	INVOKE	SCANOFF
	CMP	AL,0DH
	JZ	RETSW				; Oops
	INC	SI
; Convert lower case input to upper case
	INVOKE	UPCONV
	MOV	DI,OFFSET TRANGROUP:switch_list
	MOV	CX,SWCOUNT
	REPNE	SCASB				; Look for matching switch
	JNZ	BADSW
	MOV	AX,1
	SHL	AX,CL				; Set a bit for the switch
	OR	BX,AX
	JMP	SHORT SWLOOP

BADSW:
	JMP	SHORT SWLOOP

DRVBAD:
	MOV	DX,OFFSET TRANGROUP:BADDRV_ptr
	JMP	CERROR

externalj:
	jmp	EXTERNAL

fndcom: 					; search the internal command table
    OR	    AL,AL				; Get real length of first arg
    jz	    externalj				; If 0, it must begin with "\" so has
						;  to be external.
; barryf code starts here

	IF	IBM
	call	test_append			; see if APPEND installed
	je	contcom 			; not loaded

append_internal:
	mov	cl,TRANGROUP:IDLEN
	mov	ch,0
	mov	pathpos,cx
	inc	append_exec			;AN041; set APPEND to ON

	invoke	ioset				; re-direct the o'l io

	mov	SI, offset TRANGROUP:IDLEN	; address command name, DS already set
	mov	DX,-1				; set invoke function
	mov	di,offset TRANGROUP:APPEND_PARSE;AN010; Get the entry point for PARSE for APPEND
	mov	AX,0AE01H
	int	2FH				; execute command
	cmp	TRANGROUP:IDLEN,0		; execute requested
;;	je	Cmd_done
	jne	contcom
	jmp	Cmd_done

contcom:					; continue with internal scan
	ENDIF

; barryf code ends here

    mov     DI, OFFSET TRANGROUP:COMTAB
    XOR     CX,CX

findcom:
    mov     SI, offset TRANGROUP:IDLEN+1	; pointer to command argument
    mov     CL, [DI]				; load length of internal command
    inc     di					; advance past length
    jcxz    externalj				; if it's zero, we're out of internals
    cmp     CL, IDLEN				; that of the command argument
    jnz     abcd				; lengths not equal ==> strings not eq
    MOV     PathPos,CX				; store length of command
    repz    cmpsb

abcd:
    lahf					; save the good ol' flags
    add     DI, CX				; skip over remaining internal, if any
    mov     AL, BYTE PTR [DI]			; load drive-check indicator byte (DCIB)
    mov     [CHKDRV], AL			; save command flag byte in chkdrv
    inc     DI					; increment DI (OK, OK, I'll stop)
    mov     BX, WORD PTR [DI]			; load internal command address
    inc     DI					; skip over the puppy
    inc     DI
    mov     DX, WORD PTR [DI]			; load ptr to help msg #s
    inc     DI
    inc     DI
    sahf					; remember those flags?
    jnz     findcom				; well, if all the cmps worked...
;
; All messages get redirected.
;
    cmp     append_exec,0			;AN041; APPEND just executed?
    jnz     dont_set_io 			;AN041; Yes - this junk is already set
    invoke  ioset				; re-direct the ol' i/o

dont_set_io:					;AN041;
;
; Check for /?.  Certain commands, flagged fLimitHelp,
; respond to /? only if it is the only command-line argument.
;
    mov     ax,[COMSW]				; AX = switches after command
    or      ax,[ALLSWITCH]			; AX = all switches
    and     ax,SwitchQues
    jz      drive_check				; /? not in command line

    test    [CHKDRV],fLimitHelp
    jz      do_help				; /? allowed in combination
;
; Make sure /? is the only argument on the command line.
;
    cmp     [arg.argvcnt],2
    jne     drive_check				; /? not only arg - ignore
;
; Note:  this is all the check we need, even against things like /??.
; Our argv parser breaks /?? into two args, /? and ?.
;

do_help:

; DX = ptr to word list of msg #s, terminated by zero word

    mov     si,dx				; SI = ptr to list of msg #s
    mov     ax,NO_SUBST				; AL = no subst's code
    push    ax					; build subst block on stack

next_help_msg:
    lodsw					; AX = help msg # or zero
    or      ax,ax
    jz      help_done
    push    ax					; SS:SP = ptr to subst block
						;  (msg # and no_subst byte)
; We assume DS = SS.

    mov     dx,sp				; DS:DX = ptr to subst block
    invoke  Std_PrintF				; display help message
    pop     ax					; remove msg # from stack
    jmp     next_help_msg

help_done:
    pop     ax					; clean up stack
    jmp     TCommand

drive_check:
    test    [CHKDRV], fCheckDrive		; did we wanna check those drives?
    jz	    nocheck
    mov     AL, [PARM1] 			; parse_file_descriptor results tell
    or	    AL, [PARM2] 			; us whether those drives were OK
    cmp     AL, -1
    jnz     nocheck
    jmp     drvbad


;
; The user may have omitted the space between the command and its arguments.
; We need to copy the remainder of the user's command line into the buffer.
; Note that thisdoes not screw up the arg structure; it points into COMBUF not
; into the command line at 80.
;
nocheck:
    call    cmd_copy

switcheck:
    test    [CHKDRV], fSwitchAllowed		; Does the command take switches
    jnz     realwork				; Yes, process the command
    call    noswit				; No, check to see if any switches
    jnz     realwork				; None, process the command
    mov     msg_disp_class,parse_msg_class	;AN000; set up parse error msg class
    MOV     DX,OFFSET TranGroup:Extend_Buf_ptr	;AC000; get extended message pointer
    mov     Extend_Buf_ptr,BadSwt_ptr		;AN000; get "Invalid switch" message number
    jmp     CERROR				; Print error and chill out...
realwork:
    call    BX					; do some real work, at last

; See if we're in a batch CALL command. If we are, reprocess the command line,
; otherwise, go get another command.

Cmd_done:
    push    cs					; g  restore data segment
    pop     ds					; g
    push    ds					; g  save data segment
    mov     ds,[resseg] 			; g  get segment containing call flag
    ASSUME  ds:resgroup
    cmp     call_flag, call_in_progress 	; G  Is a call in progress?
    mov     call_flag, 0			; G  Either way, reset flag
    pop     ds					; g  get data segment back
    jz	    incall				; G
    jmp     tcommand				; chill out...

incall:
    JMP     DOCOM1

noswit:
    push    di					; Save di
    mov     di,81h				; di = ptr to command args
    mov     si,80h				; Get address of length of command args
    lodsb					; Load length
    mov     cl,al				; Move length to cl
    xor     ch,ch				; Zero ch
    mov     al,[SWITCHAR]			; al = switch character
    cmp     al,0				; Turn off ZF
    repnz   scasb				; Scan for a switch character and return
    pop     di					;  with ZF set if one was found
    ret

EXTERNAL:

IF IBM
	call	test_append			; check to see if append installed
	je	not_barryf			; no - truly external command
	jmp	append_internal 		; yes - go to Barryf code

not_barryf:

ENDIF

	MOV	[FILTYP],0
	MOV	DL,[SPECDRV]
	MOV	[IDLEN],DL

IFDEF ROMEXEC

;*	Check for ROM executable.

	mov	ExecFromROM,0		; ExecFromROM = no
	push	ax
	push	dx

	mov	dx, offset TRANGROUP:fbuf	; set up DTA before
	mov	ah, SET_DMA			;  doing a find first
	int	21h

	mov	dx,arg.argv[0].argpointer	; DX = ptr to command
	mov	ah,ROM_FIND_FIRST		; AH = "Find First ROM File"
	stc
	int	21h				; call DOS
	jc	NotInROM
	inc	ExecFromROM		; ExecFromROM = yes
NotInROM:
	pop	dx
	pop	ax

ENDIF ; ROMEXEC

IF IBM_ROM_FIND
	MOV	[ROM_CALL],0
	PUSH	DX
	MOV	DX,OFFSET TRANGROUP:IDLEN
	CALL	ROM_SCAN
	POP	DX
	JNC	DO_SCAN
	INC	[ROM_CALL]
	JMP	short PostSave
DO_SCAN:
PostSave:
ENDIF

IFDEF ROMEXEC

;*	No additional searching needed for ROM file.  Just execute
;	with int 21h Exec function.

	cmp	ExecFromROM,0
	je	NonROMFile
	push	si
	push	di
	push	cx
	mov	si,arg.argv[0].argpointer
	mov	di,offset TRANGROUP:ExecPath
	mov	cx,arg.argv[0].arglen
	cld
	rep	movsb			; copy command to ExecPath
	mov	word ptr es:[di],0	; and terminate with null
	pop	cx
	pop	di
	pop	si
	jmp	NeoExecute		; go do Exec

NonROMFile:

ENDIF ; ROMEXEC

	MOV	DI,OFFSET TRANGROUP:EXECPATH
	MOV	BYTE PTR [DI],0 		; Initialize to current directory

IF IBM_ROM_FIND
	CMP	[ROM_CALL],0
	JNZ	NeoExecute
ENDIF

RESEARCH:
	invoke	path_search			; find the mother (result in execpath)
	or	AX, AX				; did we find anything?
	je	badcomj45			; null means no (sob)
	cmp	AX, 04H 			; 04H and 08H are .exe and .com
						; fuckin' sixteen-bit machine ought
	jnl	execute 			; to be able to handle a SIXTEEN-BIT
						; DISPLACEMENT!!
	jmp	batcom				; 02H is .bat
BADCOMJ45:
ifdef	BETA3WARN
	JMP	BADCOM
else
	JMP	short BADCOM
endif

ASSUME	DS:TRANGROUP,ES:TRANGROUP

EXECUTE:
NeoExecute:
	invoke	IOSET
;M051
; Previously LoadHigh was jumping to the execute label above. This was wrong
;because IOSET was getting invoked twice resulting in 2 sets of redirections.
;After a close, this would still leave one open active resulting in sharing
;errors on subsequent opens of the redirected file.
;
Lh_Execute:				;M051

	MOV	ES,[TRAN_TPA]
	MOV	AH,DEALLOC
	INT	21h			; Now running in "free" space
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	INC	[EXTCOM]		; Indicate external command
	MOV	[RESTDIR],0		; Since USERDIR1 is in transient, insure
					;  this flag value for re-entry to COMMAND
	MOV	SI,OFFSET TRANGROUP:EXECPATH
	MOV	DI,OFFSET RESGROUP:SAFEPATHBUFFER
	MOV	CX,LenMsgOrPathBuf
	CLD
	REP	MOVSB			; copy program pathname to resident

	MOV	DI,FCB
	MOV	SI,DI
	MOV	CX,052H 		; moving (100h-5Ch)/2 = 80h-2Eh
	REP	MOVSW			; Transfer parameters to resident header
	MOV	DX,OFFSET RESGROUP:SAFEPATHBUFFER
	PUSH	ES
	POP	DS
	ASSUME	DS:RESGROUP
	MOV	BX,OFFSET RESGROUP:EXEC_BLOCK
	MOV	AX,EXEC SHL 8
IF IBM_ROM_FIND
	TEST	[ROM_CALL],-1
	JZ	OK_EXEC
	JMP	ROM_EXEC
OK_EXEC:
ENDIF
;
; we are now running in free space.  anything we do from here on may get
; trashed.  Move the stack (also in free space) to allocated space because
; since EXEC restores the stack, somebody may trash what is on the stack.
;
	MOV	CX,ES
	MOV	SS,CX
	MOV	SP,OFFSET DATARES:RStack

ifdef	BETA3WARN
        %out    BETA WARNING: Take this out before we ship retail product

	cmp	Beta3Warned, 0
	jne	NoWarning
	mov	Beta3Warned, 0ffh
	push	ax
	push	cx
	push	dx
	push	ds

	mov	ah, 2ah				; get date
	int	21h
        cmp     cx, yearBETA3WARN
	jb	nwx
	ja	bwarn

        cmp     dh, monthBETA3WARN
	jb	nwx
bwarn:
	mov	ds, trnseg
	assume	ds:trangroup
	mov	dx, offset trangroup:Beta3WarnMsg
	mov	ah, 9
	int	21h

;	wait till a key is hit

@@:
	mov	ah, 6				; console I/O
	mov	dl, 0ffh			; Read
	int	21h
	jz	@b
nwx:
	pop	ds
	assume	ds:resgroup
	pop	dx
	pop	cx
	pop	ax
NoWarning:
endif ; BETA3WARN
	JMP	[EXEC_ADDR]			; Jmp to the EXEC in the resident

	ASSUME	DS:TRANGROUP
BADCOM:
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET TRANGROUP:BADNAM_ptr

CERROR:
	INVOKE	std_eprintf
	JMP	TCOMMAND

;
; Prescan converts the input buffer into a canonicalized form.	All
; redirections and pipes are removed.
;
PRESCAN:					; Cook the input buffer

ASSUME	DS:TRANGROUP,ES:TRANGROUP

	XOR	CX,CX
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	MOV	DI,SI

CountQuotes:
	LODSB					; get a byte
	CMP	AL,22h				; is it a quote?
	JNZ	CountEnd			; no, try for end of road
	INC	CH				; bump count
	JMP	CountQuotes			; go get next char

CountEnd:
	CMP	AL,13				; end of road?
	JNZ	CountQuotes			; no, go back for next char

;;;;	IFDEF	DBCS		3/3/KK
	PUSH	CX				; save count
	MOV	SI,DI				; get back beginning of buffer

KanjiScan:
	LODSB					; get a byte
	INVOKE	TestKanj			; is it a leadin byte
	JZ	KanjiQuote			; no, check for quotes
	MOV	AH,AL				; save leadin
	LODSB					; get trailing byte
	CMP	AX,DB_SPACE			; is it Kanji space
	JNZ	KanjiScan			; no, go get next
	MOV	[SI-2],2020h			; replace with spaces
	JMP	KanjiScan			; go get next char

KanjiQuote:
	CMP	AL,22h				; beginning of quoted string
	JNZ	KanjiEnd			; no, check for end
	DEC	CH				; drop count
	JZ	KanjiScan			; if count is zero, no quoting

KanjiQuoteLoop:
	LODSB					; get next byte
	CMP	AL,22h				; is it another quote
	JNZ	KanjiQuoteLoop			; no, get another
	DEC	CH				; yes, drop count
	JMP	KanjiScan			; go get next char

KanjiEnd:
	CMP	AL,13				; end of line character?
	JNZ	KanjiScan			; go back to beginning
	POP	CX				; get back original count
;;;;	ENDIF		3/3/KK

	MOV	SI,DI				; restore pointer to begining

PRESCANLP:
	LODSB

;;;;	IFDEF	DBCS		3/3/KK
	INVOKE	TESTKANJ
	JZ	NOTKANJ6
	MOV	[DI],AL
	INC	DI				; fake STOSB into DS
	LODSB					; grab second byte
	MOV	[DI],AL 			; fake stosb into DS
	INC	DI
	INC	CL
	INC	CL
	JMP	PRESCANLP

NOTKANJ6:
;;;;	ENDIF			3/3/KK

	CMP	AL,'"'                          ; " character
	JNZ	TRYGREATER
	DEC	CH
	JZ	TRYGREATER

QLOOP:
	MOV	[DI],AL
	INC	DI
	INC	CL
	LODSB
	CMP	AL,'"'                          ; " character
	JNZ	QLOOP
	DEC	CH

TRYGREATER:
	CMP	AL,rabracket
	JNZ	NOOUT
;
; We have found a ">" char.  We need to see if there is another ">"
; following it.
;
	CMP	BYTE PTR [SI],al
	JNZ	NOAPPND
	LODSB
	INC	[RE_OUT_APP]			; Flag >>

NOAPPND:
;
; Now we attempt to find the file name.  First, scan off all whitespace
;
	INVOKE	SCANOFF
	CMP	AL,labracket			;AN040; was there no filename?
	JZ	REOUT_ERRSET			;AN040; yes - set up error
	CMP	AL,0DH
	JNZ	GOTREOFIL
;
; There was no file present.  Set us up at end-of-line.
;
REOUT_ERRSET:					;AN040; set up for an error
	mov	byte ptr [di], 0dh		; Clobber first ">"
	MOV	WORD PTR [RE_OUTSTR],09H	; Cause an error later
	JMP	PRESCANEND

GOTREOFIL:
	PUSH	DI
	MOV	DI,OFFSET RESGROUP:RE_OUTSTR
	MOV	BX,DI
	PUSH	ES

SETREOUTSTR:					; Get the output redirection name

						; MSKK06 07/14/89
	push	cx				; save cx
	mov	cx,64+13			; CX = max string length

SETREOUTSTR_LOOP:

	LODSB
	CMP	AL,0DH
	JZ	GOTRESTR_J
	INVOKE	DELIM
	JZ	GOTRESTR_J
	CMP	AL,[SWITCHAR]
	JZ	GOTRESTR_J
	CMP	AL,'"'                          ;AN033; Is the character a quote?
	JZ	PIPEERRSYNJ5_J			;AN033; Yes - get out quick - or system crashes
	CMP	AL,labracket			;AN002; Is char for input redirection
	JZ	ABRACKET_TERM			;AN002; yes - end of string
	CMP	AL,rabracket			;AN002; Is char for output redirection
	JNZ	NO_ABRACKET			;AN002; no - not end of string

ABRACKET_TERM:					;AN002; have end of string by < or >
	DEC	SI				;AN002; back up over symbol
	MOV	AL,BLANK			;AN002; show delimiter as char
GOTRESTR_J:
	pop	cx				; MSKK06 07/14/89
	JMP	SHORT GOTRESTR			;AN002; go process it

NO_ABRACKET:					;AN002; NOT AT END OF STRING
	STOSB					; store it into resgroup

ifdef DBCS
	invoke	testkanj
	jz	@f				; if not lead byte of DBCS
	jcxz	gotrestr_j			; if no tail byte
	lodsb
	cmp	al,0dh
	jz	gotrestr_j			; if tail byte does't come and ends
	stosb					; copy tail byte
	dec	cx
@@:
endif

	LOOP	SETREOUTSTR_LOOP		; MSKK06 07/14/89
	jmp	GOTRESTR_j

PIPEERRSYNJ5_J:
	pop	cx				; recover CX
	jmp	short PIPEERRSYNJ5

NOOUT:
	CMP	AL,labracket
	JNZ	CHKPIPE
	mov	bx,si				; Save loc of "<"
	INVOKE	SCANOFF
	CMP	AL,rabracket			;AN040; was there no filename?
	JZ	REIN_ERRSET			;AN040; yes - set up error
	CMP	AL,0DH
	JNZ	GOTREIFIL

REIN_ERRSET:					;AN040; set up for error
	mov	byte ptr [di],0dh		; Clobber "<"
	MOV	WORD PTR [RE_INSTR],09H 	; Cause an error later
	JMP	SHORT PRESCANEND

GOTREIFIL:
	PUSH	DI
	MOV	DI,OFFSET TranGROUP:RE_INSTR
	MOV	BX,DI
	PUSH	ES
	PUSH	CS
	POP	ES				; store in TRANGROUP
	JMP	SHORT SETREOUTSTR		; Get the input redirection name

CHKPIPE:
	MOV	AH,AL
	CMP	AH,AltPipeChr
	JZ	IsPipe3
	CMP	AH,vbar
	JNZ	CONTPRESCAN

IsPipe3:
;
; Only push the echo flag if we are entering the pipe for the first time.
;
	CMP	PipeFlag,0
	JNZ	NoEchoPush
	SHL	EchoFlag,1			; push echo state and turn it off
NoEchoPush:
	INC	[PIPEFLAG]
	INVOKE	SCANOFF
	CMP	AL,0DH
	JZ	PIPEERRSYNJ5
	CMP	AL,AltPipeChr
	JZ	PIPEERRSYNJ5
	CMP	AL,vbar 			; Double '|'?
	JNZ	CONTPRESCAN

PIPEERRSYNJ5:
	PUSH	ES
	POP	DS				; DS->RESGROUP
	JMP	PIPEERRSYN

;
; Trailing :s are allowed on devices.  Check to be sure that there is more
; than just a :  in the redir string.
;
GOTRESTR:
	XCHG	AH,AL
	mov	al,':'
	SUB	BX,DI				; compute negatinve of number of chars
	CMP	BX,-1				; is there just a :?
	JZ	NotTrailCol			; yep, don't change
	CMP	BYTE PTR ES:[DI-1],al		; Trailing ':' OK on devices
	JNZ	NOTTRAILCOL
	DEC	DI				; Back up over trailing ':'

NOTTRAILCOL:
	XOR	AL,AL
	STOSB					; NUL terminate the string
	POP	ES
	POP	DI				; Remember the start

CONTPRESCAN:
	MOV	[DI],AH 			; "delete" the redirection string
	INC	DI
	CMP	AH,0DH
	JZ	PRESCANEND
	INC	CL
	JMP	PRESCANLP

PRESCANEND:
	CMP	[PIPEFLAG],0
	JZ	ISNOPIPE
	MOV	DI,OFFSET RESGROUP:PIPESTR
	MOV	[PIPEPTR],DI
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	INVOKE	SCANOFF

PIPESETLP:					; Transfer the pipe into the resident
	LODSB					; pipe buffer
	STOSB
	CMP	AL,0DH
	JNZ	PIPESETLP

ISNOPIPE:
	MOV	[COMBUF+1],CL
	CMP	[PIPEFLAG],0
	PUSH	CS
	POP	ES
	return

cmd_copy  proc near

	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	INVOKE	Scanoff 			; advance past separators...
	add	si,PathPos
	mov	di,81h
	xor	cx,cx

CmdCopy:
	lodsb
	stosb
	cmp	al,0dh
	jz	CopyDone
	inc	cx
	jmp	CmdCopy

CopyDone:
	 mov	 byte ptr ds:[80h],cl		; Store count

	 ret
cmd_copy  endp


test_append	proc near

	mov	BX,offset TRANGROUP:COMBUF	;   barry can address
	mov	SI, offset TRANGROUP:IDLEN	; address command name, DS already set
	mov	DX,-1				; set install check function
	mov	AX,0AE00H
	int	2FH				; see if loaded
	cmp	AL,00H

	ret

test_append	endp

TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tmisc2.asm ===
page ,132
;	SCCSID = @(#)tmisc2.asm 4.3 85/06/25
;	SCCSID = @(#)tmisc2.asm 4.3 85/06/25
TITLE	Part7 COMMAND Transient Routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	More misc routines


.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include pdb.inc
	include bpb.inc
	include sf.inc
	include comseg.asm
	include comequ.asm
	include ioctl.inc
.list
.cref


CODERES 	SEGMENT PUBLIC BYTE	;AC000;
CodeRes 	ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	IFFlag:BYTE
	EXTRN	PIPEFLAG:BYTE
	EXTRN	RE_OUTSTR:BYTE
	EXTRN	RE_OUT_APP:BYTE
DATARES 	ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	AccDen_PTR:WORD
	EXTRN	Extend_buf_ptr:word	;AN000;
	EXTRN	FULDIR_PTR:WORD
	EXTRN	msg_disp_class:byte	;AN000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	DESTINFO:BYTE
	EXTRN	DESTISDIR:BYTE
	EXTRN	KPARSE:BYTE		;AC000;
	EXTRN	ONE_CHAR_VAL:BYTE	;AN011;
	EXTRN	PATHCNT:WORD
	EXTRN	PATHPOS:WORD
	EXTRN	PATHSW:WORD
	EXTRN	RE_INSTR:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	SRCBUF:BYTE
	EXTRN	SWITCHAR:BYTE

	IF  IBM_ROM_FIND
	EXTRN	ROM_CALL:BYTE
	EXTRN	ROM_CS:WORD
	EXTRN	ROM_IP:WORD
	ENDIF

TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC byte

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	CERROR:NEAR

	IF	IBM_ROM_FIND
	EXTRN	ROM_EXEC:NEAR
	EXTRN	ROM_SCAN:NEAR
	ENDIF

	PUBLIC	IOSET
	PUBLIC	MOVE_TO_SRCBUF		;AN000;
	PUBLIC	PGETARG
	PUBLIC	SETPATH
	PUBLIC	TESTDOREIN
	PUBLIC	TESTDOREOUT


ASSUME	DS:TRANGROUP

SETPATH:
;
; ENTRY PathPos = ptr to string
;       PathCnt = length of string
;
; EXIT  PathPos = ptr to string after pathname
;       PathCnt = length of rest of string
;       DX = ptr to pathname in string, made ASCIIZ
;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
;
;       A null character is dropped at the end of the pathname.  If the
;       character in that spot previously was CR, it is copied into the
;       following byte.  So there must be at least two two character 
;       positions in the buffer following the pathname.
;
        MOV     AX,[PATHCNT]            ;AC000; get length of string
        MOV     SI,[PATHPOS]            ;AC000; get start of source buffer

GETPATH:
	MOV	[DESTINFO],0
        MOV     [DESTISDIR],0
        MOV     SI,[PATHPOS]            ; SI = ptr to string
        MOV     CX,[PATHCNT]            ; CX = string length
        MOV     DX,SI                   ; DX = ptr to string
        JCXZ    PATHDONE                ; string length is zero, we're done
        PUSH    CX                      ; save string length
        PUSH    SI                      ; save ptr to string
        INVOKE  SWITCH

;       After Switch, SI has been scanned past any switches, and
;       switches that COMMAND intrinsically recognizes are recorded in AX.

        MOV     [PATHSW],AX             ; PathSw = switch occurrence mask
        POP     BX                      ; BX = ptr to original string
        SUB     BX,SI                   ; BX = -(# chars scanned by Switch)
        POP     CX                      ; CX = string length
        ADD     CX,BX                   ; CX = string length from current SI
        MOV     DX,SI                   ; DX = ptr to current string

SKIPPATH:

;;;;	IFDEF	DBCS	3/3/KK
	MOV	[KPARSE],0

SKIPPATH2:
;;;;	ENDIF		3/3/KK

        JCXZ    PATHDONE                ; string length is zero, we're done
        DEC     CX                      ; CX = length left after next char
        LODSB                           ; AL = next char of string
                                        ; SI = ptr to char after this one

;;;;	IFDEF	DBCS	3/3/KK
	INVOKE	TESTKANJ
        JZ      TESTPPSEP               ; no Kanji, move along
	DEC	CX
	INC	SI
	INC	[KPARSE]
	JMP	SKIPPATH2

TESTPPSEP:
;;;;	ENDIF		3/3/KK

        INVOKE  PATHCHRCMP              ; compare AL to path delimiter char
        JNZ     TESTPMETA               ; it's not a path delim
        INC     [DESTISDIR]             ; DestIsDir = 1, signalling path char

TESTPMETA:
        CMP     AL,'?'
        JNZ     TESTPSTAR               ; char is not '?'
        OR      [DESTINFO],2            ; DestInfo = 2, signalling wildcard

TESTPSTAR:
        CMP     AL,star
        JNZ     TESTPDELIM              ; char is not '*'
        OR      [DESTINFO],2            ; DestInfo = 2, signalling wildcard

TESTPDELIM:
        INVOKE  DELIM                   ; compare AL to all delimiters
        JZ      PATHDONEDEC             ; delimiter found, back up & leave
        CMP     AL,[SWITCHAR]
        JNZ     SKIPPATH                ; char isn't switch, go get next char

PATHDONEDEC:
        DEC     SI                      ; SI = ptr to char after pathname

PATHDONE:
        XOR     AL,AL                   ; AL = NULL
        XCHG    AL,[SI]                 ; place NULL after pathname
        INC     SI                      ; SI = ptr to byte after NULL
        CMP     AL,0DH                  ; were we at end of line?
        JNZ     NOPSTORE                ; not EOL, finish up
        MOV     [SI],AL                 ; save EOL after NULL

NOPSTORE:
        MOV     [PATHPOS],SI            ; PathPos = ptr to char after NULL
        MOV     [PATHCNT],CX            ; PathCnt = length of string left
        return

PGETARG:
	MOV	SI,80H
	LODSB
	OR	AL,AL
	retz
	CALL	PSCANOFF
	CMP	AL,13
	return

PSCANOFF:
	LODSB
	INVOKE	DELIM
	JNZ	PSCANOFFD
	CMP	AL,';'
	JNZ	PSCANOFF			; ';' is not a delimiter

PSCANOFFD:
	DEC	SI				; Point to first non-delimiter
	return

IOSET:
;
; ALL REGISTERS PRESERVED
;
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	PUSH	DS
	PUSH	DX
	PUSH	AX
	PUSH	BX
	PUSH	CX
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP

	CMP	[PIPEFLAG],0
	JNZ	NOREDIR 			; Don't muck up the pipe
	TEST	IFFlag,-1
	JNZ	NoRedir
	CALL	TESTDOREIN
	CALL	TESTDOREOUT

NOREDIR:
	POP	CX
	POP	BX
	POP	AX
	POP	DX
	POP	DS
ASSUME	DS:NOTHING
	return

TESTDOREIN:

ASSUME	DS:RESGROUP

	CMP	[RE_INSTR],0
	retz
	PUSH	DS
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET tranGROUP:RE_INSTR
	MOV	AX,(OPEN SHL 8)
	MOV	BX,AX
	INT	21h
	POP	DS
	JC	REDIRERR
	MOV	BX,AX
	MOV	AL,0FFH
;
; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
; spot.  We invalidate the new JFN we got.
;
	XCHG	AL,[BX.PDB_JFN_Table]
	MOV	DS:[PDB_JFN_Table],AL

	return
;
; We had some kind of error on the redirection.  Figure out what the
; appropriate message should be; BX has the system call that failed
;
REDIRERR:
	PUSH	CS
	POP	DS
	Call	TriageError
;
; At this point, we have recognized the network-generated access denied error.
; The correct message is in DX
;
	CMP	AX,65
	JZ	CERRORJ 			;AC000; just issue message returned
	CMP	BH,OPEN
	JZ	OpenError
;
; The error was for a create operation.  Report the error as a creation error.
;
	MOV	DX,OFFSET TranGroup:FULDIR_PTR

CERRORJ:
	JMP	CERROR
;
; The system call was an OPEN.	Report either file not found or path not found.
;

OpenError:
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN000; get message number in control block
	JMP	CERROR

TESTDOREOUT:

ASSUME	DS:RESGROUP

	CMP	[RE_OUTSTR],0
	JNZ	REOUTEXISTS			;AN017; need long jump
	JMP	NOREOUT 			;AN017;

REOUTEXISTS:
	CMP	[RE_OUT_APP],0
	JZ	REOUTCRT
;
; The output redirection was for append.  We open for write and seek to the
; end.
;
	MOV	DX,OFFSET RESGROUP:RE_OUTSTR
	MOV	AX,(OPEN SHL 8) OR 2		;AC011; Open for read/write
	PUSH	AX
	INT	21h
	POP	BX
	JC	OpenWriteError

	MOV	BX,AX
	MOV	AX,IOCTL SHL 8			;AN035; Get attributes of handle
	INT	21h			;AN035;
	TEST	DL,devid_ISDEV			;AN035; Is it a device?
	JNZ	SET_REOUT			;AN035; Yes, don't read from it

	MOV	AX,(LSEEK SHL 8) OR 2
	MOV	CX,-1				;AC011; MOVE TO EOF -1
	MOV	DX,CX				;AC011;
	INT	21h
	PUSH	CS				;AN011; Get transient seg to DS
	POP	DS				;AN011;
	assume	DS:Trangroup			;AN011;
	MOV	AX,(READ SHL 8) 		;AN011; Read one byte from the
	MOV	CX,1				;AN011;   file into one_char_val
	MOV	DX,OFFSET Trangroup:ONE_CHAR_VAL;AN011;
	INT	21h			;AN011;
	JC	OpenWriteError			;AN011; If error, exit
	cmp	ax,cx				;AN017; Did we read 1 byte?
	jnz	reout_0_length			;AN017; No - file must be 0 length

	cmp	one_char_val,01ah		;AN011; Was char an eof mark?
	mov	DS,[resseg]			;AN011; Get resident segment back
	assume	DS:Resgroup			;AN011;
	JNZ	SET_REOUT			;AN011; No, just continue
	MOV	AX,(LSEEK SHL 8) OR 1		;AN011; EOF mark found
	MOV	CX,-1				;AN011; LSEEK back one byte
	MOV	DX,CX				;AN011;
	INT	21h			;AN011;
	JMP	SHORT SET_REOUT

reout_0_length: 				;AN017; We have a 0 length file
	mov	DS,[resseg]			;AN017; Get resident segment back
	assume	DS:Resgroup			;AN017;
	MOV	AX,(LSEEK SHL 8)		;AN017; Move to beginning of file
	XOR	CX,CX				;AN017; Offset is 0
	MOV	DX,CX				;AN017;
	INT	21h			;AN017;
	JMP	SHORT SET_REOUT 		;AN017; now finish setting up redirection

OpenWriteError:
	CMP	AX,error_access_denied
	STC					; preserve error
	JNZ	REOUTCRT			;AN017; need long jump
	JMP	REDIRERR			;AN017;

REOUTCRT:
	MOV	DX,OFFSET RESGROUP:RE_OUTSTR
	XOR	CX,CX
	MOV	AH,CREAT
	PUSH	AX
	INT	21h
	POP	BX
	JNC	NOREDIRERR			;AC011;
	JMP	REDIRERR			;AC011;

NOREDIRERR:					;AN011;
	MOV	BX,AX

SET_REOUT:
;
; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
; spot.  We invalidate the new JFN we got.
;
	MOV	AL,0FFH
	XCHG	AL,[BX.PDB_JFN_Table]
	MOV	DS:[PDB_JFN_Table+1],AL

NOREOUT:
	return

;
; Compute length of string (including NUL) in DS:SI into CX.  Change no other
; registers
;
Procedure   DSTRLEN,NEAR

	SaveReg <AX>
	XOR	CX,CX
	CLD

DLoop:	LODSB
	INC	CX
	OR	AL,AL
	JNZ	DLoop
	SUB	SI,CX
	RestoreReg  <AX>
	return

EndProc DSTRLEN

Break	<Extended error support>

;
; TriageError will examine the return from a carry-set system call and
; return the correct error if applicable.
;
;   Inputs:	outputs from a carry-settable system call
;		No system calls may be done in the interrim
;   Outputs:	If carry was set on input
;		    carry set on output
;		    DX contains trangroup offset to printf message
;		else
;		    No registers changed
;

Procedure TriageError,NEAR

	retnc					; no carry => do nothing...
	PUSHF
	SaveReg <BX,CX,SI,DI,BP,ES,DS,AX,DX>
	MOV	AH,GetExtendedError
	INT	21h
	RestoreReg  <CX,BX>			; restore original AX
	MOV	DX,OFFSET TranGroup:AccDen_PTR
	CMP	AX,65				; network access denied?
	JZ	NoMove				; Yes, return it.
	MOV	AX,BX
	MOV	DX,CX

NoMove:
	RestoreReg  <DS,ES,BP,DI,SI,CX,BX>
	popf
	return

EndProc TriageError

PUBLIC Triage_Init
Triage_Init proc FAR
	call	TriageError
	ret
Triage_Init endp


; ****************************************************************
; *
; * ROUTINE:	 MOVE_TO_SRCBUF
; *
; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
; *		 terminating 0 to 0dH.	Set PATHCNT to length of
; *		 string.  Set PATHPOS to start of SRCBUF.
; *
; * INPUT:	 DS:SI points to ASCIIZ string
; *		 ES    points to TRANGROUP
; *
; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
; *		 PATHCNT set to length of string
; *		 PATHPOS set to start of SRCBUF
; *		 CX,AX	 changed
; *
; ****************************************************************

assume	es:trangroup,ds:nothing 		;AN000;

MOVE_TO_SRCBUF	PROC	NEAR			;AN000;

	push	si				;AN000;  save si,di
	push	di				;AN000;
	push	cx				;AN000;
	mov	di,offset TRANGROUP:srcbuf	;AN000;  set ES:DI to srcbuf
	xor	cx,cx				;AN000; clear cx for counint
	mov	ax,cx				;AN000; clear ax
	push	di				;AN000; save start of srcbuf
	lodsb					;AN000; get a character from DS:SI

mts_get_chars:					;AN000;
	cmp	al,0				;AN000; was it a null char?
	jz	mts_end_string			;AN000; yes - exit
	stosb					;AN000; no - store it in srcbuf
	inc	cx				;AN000; increment length count
	lodsb					;AN000; get a character from DS:SI
	jmp	short mts_get_chars		;AN000; go check it

mts_end_string: 				;AN000; we've reached the end of line
	mov	al,end_of_line_in		;AN000; store 0dH in srcbuf
	stosb					;AN000;
	pop	di				;AN000; restore start of srcbuf

	push	cs				;AN000; set DS to local segment
	pop	ds				;AN000;
assume	ds:trangroup				;AN000;
	mov	[pathcnt],cx			;AN000; set patchcnt to length count
	mov	[pathpos],di			;AN000; set pathpos to start of srcbuf
	pop	cx				;AN000; restore cx,di,si
	pop	di				;AN000;
	pop	si				;AN000;

	RET					;AN000; exit

MOVE_TO_SRCBUF	ENDP				;AN000;

TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tpipe.asm ===
page ,132
;	SCCSID = @(#)tpipe.asm	1.1 85/05/14
;	SCCSID = @(#)tpipe.asm	1.1 85/05/14
TITLE	PART8 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M025	SR	9/12/90	Removed calls to SetStdInOn,SetStdInOff
;				SetStdOutOn & SetStdOutOff.
;

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include pdb.inc
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	ECHOFLAG:BYTE
	EXTRN	InitFlag:byte
	EXTRN	INPIPEPTR:WORD
	EXTRN	OUTPIPEPTR:WORD
	EXTRN	PIPE1:BYTE
;;;	EXTRN	PIPE1T:BYTE
	EXTRN	PIPE2:BYTE
;;;	EXTRN	PIPE2T:BYTE
	EXTRN	PIPEFILES:BYTE
	EXTRN	PIPEFLAG:BYTE
	EXTRN	PIPEPTR:WORD
	EXTRN	RESTDIR:BYTE
	EXTRN	SINGLECOM:WORD

DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADDAT_PTR:WORD
	EXTRN	BADTIM_PTR:WORD
	EXTRN	curdat_mo_day:word	;AN000;
	EXTRN	CURDAT_PTR:WORD
	EXTRN	curdat_yr:word		;AN000;
	EXTRN	curtim_hr_min:word	;AN000;
	EXTRN	CURTIM_PTR:WORD
	EXTRN	curtim_sec_hn:word	;AN000;
	EXTRN	eurdat_ptr:word
	EXTRN	japdat_ptr:word
	EXTRN	newdat_format:word	;AN000;
	EXTRN	NEWDAT_PTR:WORD
	EXTRN	NEWTIM_PTR:WORD
	EXTRN	parse_date:byte 	;AN000;
	EXTRN	parse_time:byte 	;AN000;
	EXTRN	PIPEEMES_PTR:WORD
	EXTRN	promtim_hr_min:word	;AN000;
	EXTRN	promtim_ptr:word	;AN000;
	EXTRN	promtim_sec_hn:word	;AN000;
	EXTRN	STRING_BUF_PTR:WORD	;AC000;
	EXTRN	SYNTMES_PTR:WORD
	EXTRN	usadat_ptr:word

	extrn	TempVarName:byte

TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	COMBUF:BYTE
	EXTRN	date_day:byte		;AN000;
	EXTRN	date_month:byte 	;AN000;
	EXTRN	date_year:word		;AN000;
	EXTRN	INTERNATVARS:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	time_fraction:byte	;AN000;
	EXTRN	time_hour:byte		;AN000;
	EXTRN	time_minutes:byte	;AN000;
	EXTRN	time_seconds:byte	;AN000;
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE
ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	CERROR:NEAR
	EXTRN	NOPIPEPROC:NEAR
	EXTRN	STD_PRINTF:NEAR
	EXTRN	TCOMMAND:NEAR
	EXTRN	TESTDOREIN:NEAR
	EXTRN	TESTDOREOUT:NEAR
	EXTRN	TESTKANJ:NEAR		;AN000;3/3/KK
	EXTRN	TSYSGETMSG:NEAR 	;AN000;

	extrn	Find_Name_In_Environment:near

	PUBLIC	CTIME
	PUBLIC	DATE
	PUBLIC	DATINIT
	PUBLIC	PIPEDEL
	PUBLIC	PIPEERRSYN
	PUBLIC	PIPEPROC
	PUBLIC	PIPEPROCSTRT
	PUBLIC	PRINT_TIME
	PUBLIC	SETREST
	PUBLIC	SETREST1
	PUBLIC	SINGLETEST

SINGLETEST:
	ASSUME	DS:NOTHING
	push	ds
	MOV	DS,ResSeg
	ASSUME	DS:ResGroup
	CMP	[SINGLECOM],0
	JZ	TestDone
	CMP	[SINGLECOM],0EFFFH
TestDone:
	pop	ds
	return


ASSUME	DS:TRANGROUP
SETREST1:
	MOV	AL,1
SETREST:
	PUSH	DS
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	[RESTDIR],AL
	POP	DS
ASSUME	DS:TRANGROUP
	return

ASSUME	DS:RESGROUP

;
; Note that we need to handle the same thing that RestDir handles:  the
; requirement that we try only once to restore the user's environment after
; and INT 24 or the like.  If the condition that causes the INT 24 does not
; disappear, we just give up.
;

PIPEDEL:
	assume	ds:nothing
	push	ds
	PUSH	DX
	mov	ds,ResSeg
	assume	ds:ResGroup
	mov	DX,OFFSET RESGROUP:PIPE1	; Clean up in case ^C
	MOV	AH,UNLINK
	INT	21h
	MOV	DX,OFFSET RESGROUP:PIPE2
	MOV	AH,UNLINK
	INT	21h
	POP	DX
	call	PipeOff
	mov	PipeFiles,0
	pop	ds
	return

PIPEERRSYN:
	MOV	DX,OFFSET TRANGROUP:SYNTMES_ptr
	CALL	PIPEDEL
	PUSH	CS
	POP	DS
	JMP	CERROR
PIPEERR:
	pushf
	invoke	triageError
	SaveReg    <AX,DX>			; Save results from TriageError
	MOV	DX,OFFSET TRANGROUP:PIPEEMES_ptr
	CALL	PIPEDEL
	PUSH	CS
	POP	DS
	invoke	std_eprintf
	RestoreReg <DX,AX>			; Restore results from TriageError
	popf
	cmp	ax, 65
	jnz	tcommandj
	JMP	CERROR
tcommandj:
	jmp	tcommand

PIPEPROCSTRT:
ASSUME	DS:TRANGROUP,ES:TRANGROUP
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	INC	[PIPEFILES]			; Flag that the pipe files exist

	push	es
	push	di
	push	ds
	push	si

	push	ds
	push	es
	pop	ds				;ds = TRANGROUP
	mov	si,offset TRANGROUP:TempVarName	;ds:si = "TEMP="
;
;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
;so the routine is not really general
;
	call	Find_Name_In_Environment		;es:di points at path
	pop	ds				;ds = DATARES again
	jc	no_temp_path

	push	ds
	push	es
	pop	ds
	pop	es				;swap ds and es
	mov	si,di				;ds:si points at path

	call	skip_white			;skip white space chars
;
;This copies the path into both buffers -- Pipe1 & Pipe2
;
	call	copy_pipe_path			;copy the pipe path


;
;Check if the TEMP path is valid
;
	push	es
	pop	ds				;ds = DATARES
	mov	dx,offset DATARES:Pipe1		;ds:dx = path to look for
	mov	ax, (CHMOD shl 8) or 0
	int	21h
	jc	no_temp_path

	test	cx,10h				;is it a directory?
	jnz	no_temp_path			;yes, continue (carry clear)

	stc					;no, indicate fail

no_temp_path:
	pop	si
	pop	ds
	pop	di
	pop	es
	jnc	crt_temp			;path found, create tempfiles
;;;;
;;;;Invalid or no TEMP path, default to root of current drive
;;;;

;;;	MOV	AH,Get_Default_Drive		; Get current drive
;;;	INT	21h
;;;	ADD	AL,capital_A
;;;	MOV	PIPE2,AL			; Make pipe files in root of def drv
;;;	MOV	Pipe1,AL
;;;	mov	al,':'
;;;	mov	ah,'\'
;;;	mov	word ptr Pipe1+1,ax
;;;	mov	word ptr Pipe2+1,ax			;store ':\'
;;;
;;;	xor	ah,ah				; nul terminate path names
;;;	mov	Pipe1+3,ah
;;;	mov	Pipe2+3,ah

;SR;
; We want to create temp files in the current directory rather than in the 
;root of the drive. This is because the number of files that can be present
;in the root directory is fixed, whereas it is not so in subdirectories.
;
	mov	ah,'.'
	mov	Pipe1,ah
	mov	Pipe2,ah
	xor	ah,ah
	mov	Pipe1+1,ah
	mov	Pipe2+1,ah			;create files in current dir

crt_temp:
	MOV	DX,offset DATARES:Pipe1
	XOR	CX,CX
	mov	ah,CreateTempFile		; the CreateTemp call
	INT	21h
	JnC	@f
	jmp	PIPEERR 			; Couldn't create
@@:
	MOV	BX,AX
	MOV	AH,CLOSE			; Don't proliferate handles
	INT	21h

	MOV	DX,OFFSET RESGROUP:PIPE2
	mov	ah,createTempFile		; the CreateTemp call
	INT	21h
	JnC	@f
	jmp	PIPEERR
@@:
	MOV	BX,AX
	MOV	AH,CLOSE
	INT	21h

	CALL	TESTDOREIN			; Set up a redirection if specified
	MOV	SI,[PIPEPTR]
	CMP	[SINGLECOM],-1
	JNZ	NOSINGP
	MOV	[SINGLECOM],0F000H		; Flag single command pipe
NOSINGP:
	JMP	SHORT FIRSTPIPE

PIPEPROC:
ASSUME	DS:RESGROUP
	AND	[ECHOFLAG],0FEh 		; force current echo to be off
	MOV	SI,[PIPEPTR]
	LODSB
	CMP	AL,AltPipeChr			; Alternate pipe char?
	JZ	IsPipe1 			; Yes
	CMP	AL,vbar
	jz	IsPipe1
	jmp	PIPEEND 			; Pipe done
IsPipe1:
	MOV	DX,[INPIPEPTR]			; Get the input file name
	MOV	AX,(OPEN SHL 8)
	INT	21h
PIPEERRJ:
	jnc	no_pipeerr
	JMP	PIPEERR 			; Lost the pipe file
no_pipeerr:
	MOV	BX,AX
	MOV	AL,0FFH
	XCHG	AL,[BX.PDB_JFN_Table]
	MOV	DS:[PDB_JFN_Table],AL		; Redirect

FIRSTPIPE:
	MOV	DI,OFFSET TRANGROUP:COMBUF + 2
	XOR	CX,CX
	CMP	BYTE PTR [SI],0DH		; '|<CR>'
	JNZ	PIPEOK1
PIPEERRSYNJ:
	JMP	PIPEERRSYN
PIPEOK1:
	mov	al,vbar
	CMP	BYTE PTR [SI],al		; '||'
	JZ	PIPEERRSYNJ
	CMP	BYTE PTR [SI],AltPipeChr	; '##' or '|#'?
	JZ	PipeErrSynJ			; Yes, Error
PIPECOMLP:
	LODSB
	STOSB

;;;;	IFDEF	DBCS		3/3/KK
	CALL	TESTKANJ
	JZ	NOTKANJ5
	MOVSB
;
;  Added following 2 commands to the fix pipe bug.
;
	inc	cx				;AN000;  3/3/KK
	inc	cx				;AN000;  3/3/KK
;
	JMP	PIPECOMLP

NOTKANJ5:
;;;;	ENDIF			; 3/3/KK

	CMP	AL,0DH
	JZ	LASTPIPE
	INC	CX
	CMP	AL,AltPipeChr
	JZ	IsPipe2
	CMP	AL,vbar
	JNZ	PIPECOMLP
IsPipe2:
	MOV	BYTE PTR ES:[DI-1],0DH
	DEC	CX
	MOV	[COMBUF+1],CL
	DEC	SI
	MOV	[PIPEPTR],SI			; On to next pipe element
	MOV	DX,[OUTPIPEPTR]
	PUSH	CX
	XOR	CX,CX
	MOV	AX,(CREAT SHL 8)
	INT	21h
	POP	CX
	JC	PIPEERRJ			; Lost the file
	MOV	BX,AX
	MOV	AL,0FFH
	XCHG	AL,[BX.PDB_JFN_Table]
	MOV	DS:[PDB_JFN_Table+1],AL
	XCHG	DX,[INPIPEPTR]			; Swap for next element of pipe
	MOV	[OUTPIPEPTR],DX
	JMP	SHORT PIPECOM

LASTPIPE:
	MOV	[COMBUF+1],CL
	DEC	SI
	MOV	[PIPEPTR],SI			; Point at the CR (anything not '|' will do)
	CALL	TESTDOREOUT			; Set up the redirection if specified
PIPECOM:
	PUSH	CS
	POP	DS
	JMP	NOPIPEPROC			; Process the pipe element

PIPEEND:
	CALL	PIPEDEL
	CMP	[SINGLECOM],0F000H
	JNZ	NOSINGP2
	MOV	[SINGLECOM],-1			; Make it return
NOSINGP2:
	JMP	TCOMMAND

ASSUME	DS:TRANGROUP,ES:TRANGROUP

; Date and time are set during initialization and use
; this routines since they need to do a long return

DATINIT PROC	FAR
	mov	cs:[resseg],ds			; SetInitFlag needs resseg initialized
	PUSH	ES
	PUSH	DS				; Going to use the previous stack
	MOV	AX,CS				; Set up the appropriate segment registers
	MOV	ES,AX
	MOV	DS,AX
	invoke	TSYSLOADMSG			;AN000; preload messages
	MOV	DX,OFFSET TRANGROUP:INTERNATVARS;Set up internat vars
	MOV	AX,INTERNATIONAL SHL 8
	INT	21H
	MOV	WORD PTR DS:[81H],13		; Want to prompt for date during initialization
	MOV	[COMBUF],COMBUFLEN		; Init COMBUF
	MOV	WORD PTR [COMBUF+1],0D01H
	CALL	DATE
	CALL	CTIME
	POP	DS
	POP	ES
	RET
DATINIT ENDP

; DATE - Gets and sets the time


	break	Date


; ****************************************************************
; *
; * ROUTINE:	 DATE - Set system date
; *
; * FUNCTION:	 If a date is specified, set the system date,
; *		 otherwise display the current system date and
; *		 prompt the user for a new date.  If an invalid
; *		 date is specified, issue an error message and
; *		 prompt for a new date.  If the user enters
; *		 nothing when prompted for a date, terminate.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

DATE:
	MOV	SI,81H				; Accepting argument for date inline
	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
	xor	cx,cx				;AN000; clear counter for positionals
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser
	cmp	ax,end_of_line			;AC000; are we at end of line?
	JZ	PRMTDAT 			;AC000; yes - go ask for date
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	daterr				;AN000; yes - go issue message
	JMP	short COMDAT			;AC000; we have a date

PRMTDAT:
	; Print "Current date is

	invoke	GetDate 			;AN000; get date  for output
	xchg	dh,dl				;AN000; switch month & day
	mov	CurDat_yr,cx			;AC000; put year into message control block
	mov	CurDat_mo_day,dx		;AC000; put month and day into message control block
	mov	dx,offset trangroup:CurDat_ptr	;AC000; set up message for output
	invoke	std_printf
;AD061; mov	CurDat_yr,0			;AC000; reset year, month and day
;AD061; mov	CurDat_mo_day,0 		;AC000;     pointers in control block

GET_NEW_DATE:					;AN000;
	call	getdat				;AC000; prompt user for date
	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	date_end			;AC000; yes - exit
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	daterr				;AN000; yes - go issue message
COMDAT:
	mov	cx,date_year			;AC000; get parts of date in
	mov	dh,date_month			;AC000;    cx and dx for set
	mov	dl,date_day			;AC000;    date function call.
	push	cx				;AC000; save date
	push	dx				;AC000;
	mov	cx,1				;AC000; set 1 positional entered
	xor	dx,dx				;AN029;
	invoke	cmd_parse			;AN029; call parser
	cmp	al,end_of_line			;AN029; Are we at end of line?
	pop	dx				;AC000; retrieve date
	pop	cx				;AC000;
	jnz	daterr				;AC000; extra stuff on line - try again
	MOV	AH,SET_DATE			;yes - set date
	INT	21h
	OR	AL,AL
	JNZ	DATERR
date_end:
	ret

DATERR:
	invoke	crlf2				;AN028; print out a blank line
	MOV	DX,OFFSET TRANGROUP:BADDAT_ptr
	invoke	std_printf
	JMP	GET_NEW_DATE			;AC000; get date again


; TIME gets and sets the time

	break	Time

; ****************************************************************
; *
; * ROUTINE:	 TIME - Set system time
; *
; * FUNCTION:	 If a time is specified, set the system time,
; *		 otherwise display the current system time and
; *		 prompt the user for a new time.  If an invalid
; *		 time is specified, issue an error message and
; *		 prompt for a new time.  If the user enters
; *		 nothing when prompted for a time, terminate.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

CTIME:
	MOV	SI,81H				; Accepting argument for time inline
	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_time
	xor	cx,cx				;AN000; clear counter for positionals
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser
	cmp	ax,end_of_line			;AC000; are we at end of line?
	JZ	PRMTTIM 			;AC000; yes - prompt for time
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	timerr				;AN000; yes - go issue message
	JMP	short COMTIM			;AC000; we have a time

PRMTTIM:
	;Printf "Current time is ... "

	MOV	AH,GET_TIME			;AC000; get the current time
	INT	21h			;AC000;    Get time in CX:DX
	xchg	ch,cl				;AN000; switch hours & minutes
	xchg	dh,dl				;AN000; switch seconds & hundredths
	mov	CurTim_hr_min,cx		;AC000; put hours and minutes into message subst block
	mov	CurTim_sec_hn,dx		;AC000; put seconds and hundredths into message subst block
	mov	dx,offset trangroup:CurTim_ptr	;AC000; set up message for output
	invoke	std_printf
;AD061; mov	CurTim_hr_min,0 		;AC000; reset hour, minutes, seconds, and hundredths
;AD061; mov	CurTim_sec_hn,0 		;AC000;     pointers in control block

GET_NEW_TIME:
	call	gettim				;AC000;
	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	time_end			;AC000;
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	timerr				;AN000; yes - go issue message

COMTIM:
	mov	ch,time_hour			;AC000; get parts of time in
	mov	cl,time_minutes 		;AC000;    cx and dx for set
	mov	dh,time_seconds 		;AC000;    time function call
	mov	dl,time_fraction		;AC000;
	push	cx				;AC000; save time
	push	dx				;AC000;
	mov	cx,1				;AC000; set 1 positional parm entered
	xor	dx,dx				;AN029;
	invoke	cmd_parse			;AN029; call parser
	cmp	al,end_of_line			;AN029; Are we at end of line?
	pop	dx				;AC000; retieve time
	pop	cx				;AC000;
	jnz	timerr				;AC000; extra stuff on line - try again

SAVTIM:
	MOV	AH,SET_TIME
	INT	21h
	OR	AL,AL
	JNZ	TIMERR				;AC000; if an error occured, try again

TIME_END:

	ret

TIMERR:
	invoke	crlf2				;AN028; print out a blank line
	MOV	DX,OFFSET TRANGROUP:BADTIM_ptr
	invoke	std_printf			; Print error message
	JMP	GET_NEW_TIME			;AC000; Try again


;
; Set the special flag in the INIT flag to the value in CX.
;
SetInitFlag:
	mov	ds,[RESSEG]
assume ds:resgroup
	and	InitFlag,NOT initSpecial
	or	InitFlag,cL
	push	cs
	pop	ds
	return

Public	PipeOff
PipeOff:
	ASSUME	DS:NOTHING,ES:NOTHING
	SaveReg <DS,AX>
	MOV	DS,ResSeg
	ASSUME	DS:RESGroup
	XOR	AL,AL
	XCHG	PipeFlag,AL
	OR	AL,AL
	JZ	PipeOffDone
	SHR	EchoFlag,1
PipeOffDone:
	RestoreReg  <AX,DS>
	return


PRINT_TIME:

	MOV	AH,GET_TIME
	INT	21h			; Get time in CX:DX

	PUSH	ES
	PUSH	CS
	POP	ES
	xchg	ch,cl				;AN000; switch hours & minutes
	xchg	dh,dl				;AN000; switch seconds & hundredths
	mov	promTim_hr_min,cx		;AC000; put hours and minutes into message subst block
	mov	promTim_sec_hn,dx		;AC000; put seconds and hundredths into message subst block
	mov	dx,offset trangroup:promTim_ptr ;AC000; set up message for output
	invoke	std_printf
;AD061; mov	promTim_hr_min,0		;AC000; reset hour, minutes, seconds, and hundredths
;AD061; mov	promTim_sec_hn,0		;AC000;     pointers in control block

	POP	ES
	return


; ****************************************************************
; *
; * ROUTINE:	 GETDAT - Prompt user for date
; *
; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
; *		 INFORMATION and issues the "Enter new date"
; *		 message with the proper date format.  COMBUF
; *		 is reset to get a date from the command line.
; *		 The PARSE_DATE blocks are then reset and the
; *		 PARSE function call is issued.
; *
; * INPUT:	 NONE
; *
; * OUTPUT:	 COMBUF
; *		 PARSER RETURN CODES
; *
; ****************************************************************


GETDAT	proc	near				;AC000;

	mov	ax,(International SHL 8)	; Determine what format the date
	mov	dx,5ch				;  should be entered in and
	int	21h			;  print a message describing it
	mov	si,dx
	lodsw
	mov	dx,usadat_ptr			;AC000; get mm-dd-yy
	dec	ax
	js	printformat
	mov	dx,eurdat_ptr			;AC000; get dd-mm-yy
	jz	printformat
	mov	dx,japdat_ptr			;AC000; get yy-mm-dd
printformat:
	mov	ax,dx				;AN000; get message number of format
	mov	dh,util_msg_class		;AN000; this is a utility message
	call	Tsysgetmsg			;AN000; get the address of the message
	mov	newdat_format,si		;AN000; put the address in subst block
	MOV	DX,OFFSET TRANGROUP:NEWDAT_ptr	;AC000; get address of message to print
	invoke	std_printf
	mov	newdat_format,no_subst		;AN000; reset subst block

	MOV	AH,STD_CON_STRING_INPUT
	MOV	DX,OFFSET TRANGROUP:COMBUF
	mov	cx,initSpecial			; Set bit in InitFlag that indicates
	call	SetInitFlag			;  prompting for date.
	INT	21h			; Get input line
	xor	cx,cx				; Reset bit in InitFlag that indicates
	call	SetInitFlag			;  prompting for date.
	invoke	CRLF2
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
	xor	cx,cx				;AN000; clear counter for positionals
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser

	ret

GETDAT	endp					;AC000;


; ****************************************************************
; *
; * ROUTINE:	 GETTIME - Prompt user for time
; *
; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
; *		 INFORMATION and issues the "Enter new time"
; *		 message. COMBUF is reset to get a time from the
; *		 command line.	The PARSE_TIME blocks are then
; *		 reset and the PARSE function call is issued.
; *
; * INPUT:	 NONE
; *
; * OUTPUT:	 COMBUF
; *		 PARSER RETURN CODES
; *
; ****************************************************************


GETTIM	proc	near				;AC000;

	XOR	CX,CX				; Initialize hours and minutes to zero
	MOV	DX,OFFSET TRANGROUP:NEWTIM_ptr
	invoke	std_printf
	MOV	AH,STD_CON_STRING_INPUT
	MOV	DX,OFFSET TRANGROUP:COMBUF
	mov	cx,initSpecial			; Set bit in InitFlag that indicates
	call	SetInitFlag			;  prompting for time.
	INT	21h			; Get input line
	xor	cx,cx				; Reset bit in InitFlag that indicates
	call	SetInitFlag			;  prompting for time.
	invoke	CRLF2
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_TIME
	xor	cx,cx				;AN000; clear counter for positionals
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser

	ret

GETTIM	endp					;AC000;

;
;Skip_white: Skips over the whitespace chars that could be present after
;the '=' sign in the environment variable before the actual path.
;
;	ENTRY:	ds:si = arguments of the environment variable
;
;	EXIT:	ds:si = start of the path
;
;	REGISTERS AFFECTED: ax
;

Skip_white	proc	near

	cld
skw_lp:
	lodsb
	cmp	al,' '				;blank char?
	jz	skw_lp				;yes, skip it
	cmp	al,09				;tab char?
	jz	skw_lp				;yes, skip it

	dec	si				;point at first non-white

	ret

Skip_white	endp

;
;Copy_pipe_path:	This routine copies the path from the TEMP environment
;variable into the path buffers Pipe1 & Pipe2.
;
;	ENTRY:	ds:si = path to be copied
;		es = RESGROUP
;
;	EXIT:	Path copied into Pipe1 and Pipe2.
;
;	REGISTERS AFFECTED: si, di, cx, ax
;

Copy_pipe_path	proc	near

	mov	cx,0ffffh
	xor	al,al

	mov	di,si
	push	es			;save es
	push	ds
	pop	es			;es:di = path to be copied
	
	cld
	push	di
	repnz	scasb			;look for the null char
	pop	di

	pop	es			;es = RESGROUP again

	not	cx			;length including the null

	mov	di,offset DATARES:Pipe1	
	push	di
	push	cx			
	rep	movsb			;copy path into Pipe1
	pop	cx
	pop	di

	push	ds
	push	es
	pop	ds			;ds:si = Pipe1
	mov	si,di
	mov	di,offset DATARES:Pipe2	;es:di = Pipe2
	rep	movsb			;copy path into Pipe2
	pop	ds

	ret				;

Copy_pipe_path	endp


TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tranmsg.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
include version.inc

;
;	Revision History
;	================
;
;	M016	SR 	08/09/90	Added 2 error messages for LoadHigh
;
;



;****************************************************
;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
;****************************************************

msg_disp_class	db	Util_msg_class
msg_cont_flag	db	No_cont_flag

;  extended error string output
;
Extend_Buf_ptr	dw	0				;AN000;set to no message
Extend_Buf_sub	db	0				;AN000;set to no substitutions
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
Extend_Buf_off	dw	OFFSET	TranGroup:String_ptr_2	;AN000;offset of arg
Extend_Buf_seg	dw	0				;AN000;segment of arg
		db	0				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Duplicate file name or file not found"
;
Renerr_Ptr	dw	1002				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid path or file name"
;
BadCPMes_Ptr	dw	1003				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Insufficient disk space"
;
NoSpace_Ptr	dw	1004				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Out of environment space"
;
EnvErr_Ptr	dw	1007				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "File creation error"
;
FulDir_Ptr	dw	1008				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Batch file missing",13,10
;
BadBat_Ptr	dw	1009				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Insert disk with batch file",13,10
;
NeedBat_Ptr	dw	1010				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Bad command or file name",13,10
;
BadNam_Ptr	dw	1011				;AN000;message number
		db	no_subst			;AN000;number of subst


;  "Access denied",13,10
;
AccDen_Ptr	dw	1014				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "File cannot be copied onto itself",13,10
;
OverWr_Ptr	dw	1015				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Content of destination lost before copy",13,10
;
LostErr_Ptr	dw	1016				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid filename or file not found",13,10
;
InOrNot_Ptr	dw	1017				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "%1 File(s) copied",13,10
;
Copied_Ptr	dw	1018				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Copy_num	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	9				;AN000;maximum width
		db	9				;AN000;minimum width
		db	blank				;AN000;pad character

;  "%1 File(s) "
;
DirMes_Ptr	dw	1019				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Dir_num	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	9				;AN000;maximum width
		db	9				;AN000;minimum width
		db	blank				;AN000;pad character

;  "%1 bytes free",13,10
;
BytMes_Ptr	dw	1020				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Bytes_Free	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_DWord	;AN000;long binary to decimal
ifdef   KOREA
                db      11                              ; <MSCH>
                db      11                              ; <MSCH>
else
		db	28				;AN000;maximum width
		db	28				;AN000;minimum width
endif   ; KOREA
		db	blank				;AN000;pad character

;  "Invalid drive specification",13,10
;
BadDrv_Ptr	dw	1021				;AN000;message number
		db	no_subst			;AN000;number of subst


;  "Code page %1 not prepared for system",13,10
;
CP_not_set_Ptr	dw	1022				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:System_cpage	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	5				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Code page %1 not prepared for all devices",13,10
;
CP_not_all_Ptr	dw	1023				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:System_cpage	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	5				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Active code page: %1",13,10
;
CP_active_Ptr	dw	1024				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:System_cpage	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	5				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "NLSFUNC not installed",13,10
;
NLSFUNC_Ptr	dw	1025				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid code page",13,10
;
Inv_Code_Page	dw	1026				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Current drive is no longer valid"
;
BadCurDrv	dw	1027				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Press any key to continue"
;
PauseMes_Ptr	dw	1028				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Label not found",13,10
;
BadLab_Ptr	dw	1029				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Syntax error",13,10
;
SyntMes_Ptr	dw	1030				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid date",13,10
;
BadDat_Ptr	dw	1031				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Current date is %1 %2",13,10
;
CurDat_Ptr	dw	1032				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Arg_Buf	;AN000;offset of arg
		dw	0				;AN000;segment of arg
IFNDEF DBCS						; MSKK03 07/14/89
		db	1				;AN000;first subst
  ELSE
    IFDEF JAPAN
		db	2				;AN000;first subst
    ELSE
		db	1				;AN000;first subst
    ENDIF
ENDIF
		db	Char_field_ASCIIZ		;AN000;character string
IFNDEF DBCS
		db	3				;AN000;maximum width
		db	3				;AN000;minimum width
  ELSE
    IFDEF JAPAN						; MSKK02 07/14/89
		db	4				;AN000;maximum width
		db	4				;AN000;minimum width
    ENDIF
    IFDEF TAIWAN
		db	6				;AN000;maximum width
		db	6				;AN000;minimum width
    ENDIF
    IFDEF KOREA
                db      2               ;3 Keyl               ;AN000;maximum width
                db      2               ;3 Keyl               ;AN000;minimum width
    ENDIF
ENDIF
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
CurDat_yr	dw	0				;AN000;year
CurDat_mo_day	dw	0				;AN000;month,day
IFNDEF DBCS						; MSKK03 07/14/89
		db	2				;AN000;second subst
  ELSE
    IFDEF JAPAN
		db	1				;AN000;second subst
    ELSE
		db	2				;AN000;second subst
    ENDIF
ENDIF

		db	DATE_MDY_4			;AN000;date
		db	10				;AN000;maximum width
		db	10				;AN000;minimum width
		db	blank				;AN000;pad character


;  "SunMonTueWedThuFriSat"
;
WeekTab 	dw	1033				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Enter new date (%1):"
;
NewDat_Ptr	dw	1034				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
NewDat_Format	dw	0				;AN000;offset of replacement
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	8				;AN000;maximum width
		db	8				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Invalid time",13,10
;
BadTim_Ptr	dw	1035				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Current time is %1",13,10
;
CurTim_Ptr	dw	1036				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
CurTim_hr_min	dw	0				;AN000;hours,minutes
CurTim_Sec_hn	dw	0				;AN000;seconds,hundredths
		db	1				;AN000;first subst
		db	Right_Align+TIME_HHMMSSHH_Cty	;AC059;time
		db	12				;AC059;maximum width
		db	12				;AC059;minimum width
		db	blank				;AN000;pad character

;  "Enter new time:"
;
NewTim_Ptr	dw	1037				;AN000;message number
		db	no_subst			;AN000;number of subst

;  ",    Delete (Y/N)?",13,10
;
Del_Y_N_Ptr	dw	1038				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "All files in directory will be deleted!",13,10
;  "Are you sure (Y/N)?",13,10
;
SureMes_Ptr	dw	1039				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Microsoft DOS Version %1.%2",13,10
;
VerMes_Ptr	dw	1040				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Major_Ver_Num ;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	1				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Minor_Ver_Num ;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	2				;AN000;second subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	2				;AN000;maximum width
		db	2				;AN000;minimum width
		db	"0"                             ;AN000;pad character

;  "Volume in drive %1 has no label",13,10
;
VolMes_Ptr_2	dw	1041				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:vol_drv	;AN000;offset of drive
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_Char 		;AN000;character
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Volume in drive %1 is %2",13,10
;
VolMes_Ptr	dw	1042				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:vol_drv	;AN000;offset of drive
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	00000000b			;AN000;character
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:CHARBUF	;AN000;offset of string
		dw	0				;AN000;segment of arg
		db	2				;AN000;second subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Volume Serial Number is %1-%2",13,10
;
VolSerMes_Ptr	dw	1043				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:vol_serial+2	;AN000;offset of serial
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Bin_Hex_Word	;AN000;binary to hex
		db	4				;AN000;maximum width
		db	4				;AN000;minimum width
		db	"0"                             ;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:vol_serial	;AN000;offset of serial
		dw	0				;AN000;segment of arg
		db	2				;AN000;second subst
		db	Right_Align+Bin_Hex_Word	;AN000;binary to hex
		db	4				;AN000;maximum width
		db	4				;AN000;minimum width
		db	"0"                             ;AN000;pad character

;  "Invalid directory",13,10
;
BadCD_Ptr	dw	1044				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Unable to create directory",13,10
;
BadMkD_Ptr	dw	1045				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid path, not directory,",13,10
;  "or directory not empty",13,10
;
BadRmD_Ptr	dw	1046				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Must specify ON or OFF",13,10
;
Bad_ON_OFF_Ptr	dw	1047				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Directory of %1",13,10
;
DirHead_Ptr	dw	1048				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:BWDBUF	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character

;  "No Path",13,10
;
NulPath_Ptr	dw	1049				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid drive in search path",13,10
;
BadPMes_Ptr	dw	1050				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid device",13,10
;
BadDev_Ptr	dw	1051				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "FOR cannot be nested",13,10
;
ForNestMes_Ptr	dw	1052				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Intermediate file error during pipe",13,10
;
PipeEMes_Ptr	dw	1053				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Cannot do binary reads from a device",13,10
;
InBDev_Ptr	dw	1054				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "BREAK is %1",13,10
;
CtrlcMes_Ptr	dw	1055				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	0				;AN000;offset of on/off (new)
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "VERIFY is %1",13,10
;
VeriMes_Ptr	dw	1056				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	0				;AN000;offset of on/off (new)
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "ECHO is %1",13,10
;
EchoMes_Ptr	dw	1057				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	0				;AN000;offset of on/off (new)
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "off"
;
OffMes_Ptr	dw	1059				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "on"
;
OnMes_Ptr	dw	1060				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Error writing to device",13,10
;
DevWMes_Ptr	dw	1061				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid path",13,10
;
Inval_Path_Ptr	dw	1062				;AN000;message number
		db	no_subst			;AN000;number of subst

;  unformatted string output
;
arg_Buf_Ptr	dw	1063				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Arg_Buf	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character

;  file name output
;
File_Name_Ptr	dw	1064				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:SRCBUF	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character

;  file size output for dir
;
Disp_File_Size_Ptr dw	1065				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:File_size_low ;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_DWord	;AN000;long binary to decimal
		db	10				;AN000;maximum width
		db	10				;AN000;minimum width
		db	blank				;AN000;pad character

;  unformatted string output
; %s
String_Buf_Ptr	dw	1066				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:String_ptr_2	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character
		db	0				;AN000;

;  tab character
;
Tab_ptr 	dw	1067				;AN000;message number
		db	no_subst			;AN000;number of subst

;  " <DIR>   "
;
DMes_Ptr	dw	1068				;AN000;message number
		db	no_subst			;AN000;number of subst

;  destructive back space
;
Dback_Ptr	dw	1069				;AN000;message number
		db	no_subst			;AN000;number of subst

;  carriage return / line feed
;
ACRLF_Ptr	dw	1070				;AN000;message number
		db	no_subst			;AN000;number of subst

;  output a single character
;
;One_Char_Buf_Ptr dw	 1071				 ;AN000;message number
;		 db	 1				 ;AN000;number of subst
;		 db	 parm_block_size		 ;AN000;size of sublist
;		 db	 0				 ;AN000;reserved
;		 dw	 OFFSET  TranGroup:One_Char_Val  ;AN000;offset of charcacter
;		 dw	 0				 ;AN000;segment of arg
;		 db	 1				 ;AN000;first subst
;		 db	 Char_field_Char		 ;AN000;character
;		 db	 1				 ;AN000;maximum width
;		 db	 1				 ;AN000;minimum width
;		 db	 blank				 ;AN000;pad character

;  "mm-dd-yy"
;
USADat_Ptr	dw	1072				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "dd-mm-yy"
;
EurDat_Ptr	dw	1073				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "yy-mm-dd"
;
JapDat_Ptr	dw	1074				;AN000;message number
		db	no_subst			;AN000;number of subst

;  date string for prompt
;
promptDat_Ptr	dw	1075				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Arg_Buf	;AN000;offset of arg
		dw	0				;AN000;segment of arg
IFNDEF DBCS						; MSKK03 07/14/89
		db	1				;AN000;first subst
  ELSE
    IFDEF JAPAN
		db	2				;AN000;first subst
    ELSE
		db	1				;AN000;first subst
    ENDIF
ENDIF

		db	Char_field_ASCIIZ		;AN000;character string
IFNDEF DBCS
		db	3				;AN000;maximum width
		db	3				;AN000;minimum width
  ELSE
    IFDEF JAPAN						; MSKK02 07/14/89
		db	4				;AN000;maximum width
		db	4				;AN000;minimum width
    ENDIF
    IFDEF TAIWAN
		db	6				;AN000;maximum width
		db	6				;AN000;minimum width
    ENDIF
    IFDEF KOREA
                db      2               ;3 Keyl                ;AN000;maximum width
                db      2               ;3 Keyl                ;AN000;minimum width
    ENDIF
ENDIF
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
promptDat_yr	dw	0				;AN000;year
promptDat_moday dw	0				;AN000;month,day
IFNDEF DBCS						; MSKK03 07/14/89
		db	2				;AN000;second subst
  ELSE
    IFDEF JAPAN
		db	1				;AN000;second subst
    ELSE
		db	2				;AN000;second subst
    ENDIF
ENDIF
		db	DATE_MDY_4			;AN000;date
		db	10				;AN000;maximum width
		db	8				;AN000;minimum width
		db	blank				;AN000;pad character


;  Time for prompt
;
promTim_Ptr	dw	1076				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
PromTim_hr_min	dw	0				;AN000;hours,minutes
PromTim_Sec_hn	dw	0				;AN000;seconds,hundredths
		db	1				;AN000;first subst
		db	Right_Align+TIME_HHMMSSHH_24	;AC013;time
		db	11				;AN000;maximum width
		db	11				;AC013;minimum width
		db	blank				;AN000;pad character

;  Date and time for DIR
;
DirDatTim_Ptr	dw	1077				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
DirDat_yr	dw	0				;AN000;year
DirDat_mo_day	dw	0				;AN000;month,day
		db	1				;AN000;first subst
		db	Right_Align+DATE_MDY_2		;AN000;date
		db	10				;AN000;maximum width
		db	8				;AN000;minimum width
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
DirTim_hr_min	dw	0				;AN000;hours,minutes
DirTim_Sec_hn	dw	0				;AN000;seconds,hundredths
		db	2				;AN000;second subst
		db	Right_align+TIME_HHMM_Cty	;AN000;time
		db	6				;AN000;maximum width
		db	6				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Directory already exists"
;
MD_exists_ptr	dw	1078				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "%1 bytes",13,10
;
Bytes_Ptr       dw      1079                            ; message number
                db      1                               ; number of subst
                db      parm_block_size                 ; size of sublist
                db      0                               ; reserved
                dw      OFFSET  TranGroup:FileSiz       ; offset of arg
                dw      0                               ; segment of arg
                db      1                               ; first subst
                db      Right_Align+Unsgn_Bin_DWord     ; long binary to decimal
                db      10                              ; maximum width
                db      10                              ; minimum width
                db      blank                           ; pad character

;  "Total:",13,10
;
Total_ptr       dw      1080                            ; message number
                db      no_subst                        ; number of subst

;  "Error parsing environment variable:",13,10
;
ErrParsEnv_ptr  dw      1081                            ; message number
                db      no_subst                        ; number of subst

;  "(continuing %1)",13,10
;
DirCont_Ptr     dw      1084                            ;AN000;message number
                db      1                               ;AN000;number of subst
                db      parm_block_size                 ;AN000;size of sublist
                db      0                               ;AN000;reserved
                dw      OFFSET  TranGroup:BWDBUF        ;AN000;offset of arg
                dw      0                               ;AN000;segment of arg
                db      1                               ;AN000;first subst
                db      Char_field_ASCIIZ               ;AN000;character string
                db      128                             ;AN000;maximum width
                db      0                               ;AN000;minimum width
                db      blank                           ;AN000;pad character

;  "Revision %1",CR,LF
;
DosRev_Ptr	dw	1090
		db	1				; one substitution
		db	PARM_BLOCK_SIZE
		db	0
		dw	offset TRANGROUP:One_Char_Val	; ptr to char
		dw	0				; segment addr?
		db	1				; 1st substitution
		db	CHAR_FIELD_CHAR			; character
		db	1				; max width
		db	1				; min width
		db	BLANK				; pad char

;  "DOS is in ROM"
;
DosRom_Ptr	dw	1091
		db	NO_SUBST

;  "DOS is in HMA"
;
DosHma_Ptr	dw	1092
		db	NO_SUBST

;  "DOS is in low memory"
;
DosLow_Ptr	dw	1093
		db	NO_SUBST

;  "Cannot Loadhigh batch file" ;M016
;
NoExecBat_Ptr	dw	1094			; M016
		db	NO_SUBST		; M016

;  "LoadHigh: Invalid filename" ; M016
;
LhInvFil_Ptr	dw	1095			; M016
		db	NO_SUBST		; M016

;  "Could not open specified country information file" ;M045
;
NoCntry_Ptr	dw	1096			;M045
		db	NO_SUBST		;M045

;* The next four errors emulate those reported by the normal parse
;  mechanism, with a little more accurate wording; that parser has been
;  replaced with a custom routine (ParseVar) for LoadHigh and DeviceHigh.
;  These errors aren't normally generated by LoadHigh except by the normal
;  parser, so they've been added here.
;

;  "LoadHigh: Invalid argument"
;
LhInvArg_Ptr	dw	1097
		db	NO_SUBST

;  "Required parameter missing"
;
ReqParmMiss	dw	1098
		db	NO_SUBST

;  "Unrecognized switch"
;
LhInvSwt_Ptr	dw	1099
		db	NO_SUBST

;  "A bad UMB number has been specified"
;
LhBadUMB_Ptr	dw	1100
		db	NO_SUBST

ifdef DBLSPACE_HOOKS
;  Compression ratio for DIR
;
DirCompRatio_Ptr dw	1101				; message number
		db	2				; number of subst
		db	parm_block_size 		; size of sublist
		db	0				; reserved
		dw	OFFSET	TranGroup:Dir_CRatio_1	; offset of arg
		dw	0				; segment of arg
		db	1				; first subst
		db	Right_Align+Unsgn_Bin_Byte	; binary to decimal
		db	2				; maximum width
		db	2				; minimum width
		db	blank				; pad character
		db	parm_block_size 		; size of sublist
		db	0				; reserved
		dw	OFFSET	TranGroup:Dir_CRatio_2	; offset of arg
		dw	0				; segment of arg
		db	2				; second subst
		db	Unsgn_Bin_Byte			; binary to decimal
		db	1				; maximum width
		db	1				; minimum width
		db	blank				; pad character

;  Average compression ratio for DIR
;
AveCompRatio_Ptr dw	1102
		db	2				; number of subst
		db	parm_block_size 		; size of sublist
		db	0				; reserved
		dw	OFFSET	TranGroup:Dir_CRatio_1	; offset of arg
		dw	0				; segment of arg
		db	1				; first subst
		db	Right_Align+Unsgn_Bin_Byte	; binary to decimal
		db	2				; maximum width
		db	2				; minimum width
		db	blank				; pad character
		db	parm_block_size 		; size of sublist
		db	0				; reserved
		dw	OFFSET	TranGroup:Dir_CRatio_2	; offset of arg
		dw	0				; segment of arg
		db	2				; second subst
		db	Unsgn_Bin_Byte			; binary to decimal
		db	1				; maximum width
		db	1				; minimum width
		db	blank				; pad character
endif

PATH_TEXT       DB      "PATH="
PROMPT_TEXT     DB      "PROMPT="
COMSPECSTR      DB      "COMSPEC="
DirEnvVar       DB      "DIRCMD="               ; DIR's environment variable
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tprintf.asm ===
page ,132
;	SCCSID = @(#)tprintf.asm	4.3 85/07/02
;	SCCSID = @(#)tprintf.asm	4.3 85/07/02
TITLE	COMMAND Transient Printf routine
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M025	SR	9/12/90	Removed calls to SetStdInOn,SetStdInOff
;				SetStdOutOn & SetStdOutOff.
;


;****************************************************************
;*
;* ROUTINE:	STD_PRINTF/STD_EPRINTF
;*
;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
;*		Set up substitutions if utility message.  Make
;*		sure any changes to message variables in TDATA
;*		are reset to avoid reloading the transient.
;*
;* INPUT:	Msg_Disp_Class	-  set to message class
;*		Msg_Cont_Flag	-  set to control flags
;*		DS	points to transient segment
;*
;*		if utility message:
;*		DX	points to a block with message number
;*			(word), number of substitutions (byte),
;*			followed by substitution list if there
;*			are substitutions.  If substitutions
;*			are not in transient segment they must
;*			be set.
;*		else
;*		AX	set to message number
;*
;* OUTPUT:	none
;*
;****************************************************************

.xlist
.xcref
	INCLUDE comsw.asm		;AC000;
	INCLUDE DOSSYM.INC
	INCLUDE comseg.asm
	INCLUDE comequ.asm		;AN000;
	INCLUDE SYSMSG.INC		;AN000;
.list
.cref

datares segment public
	extrn	pipeflag:byte
datares ends

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	extend_buf_off:word	;AN000;
	EXTRN	Extend_Buf_ptr:word	;AN000;
	EXTRN	Extend_Buf_seg:word	;AN000;
	EXTRN	Msg_Cont_Flag:byte	;AN000;
	EXTRN	Msg_disp_Class:byte	;AN000;
	EXTRN	pipeemes_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	msg_flag:byte		;AN022;
	EXTRN	print_err_flag:word	;AN000;
	EXTRN	RESSEG:WORD
	EXTRN	String_ptr_2:word	;AC000;
	EXTRN	Subst_buffer:byte	;AN061;
;AD061; EXTRN	String_ptr_2_sb:word	;AN000;

	; include data area for message services

	MSG_UTILNAME <COMMAND>		;AN000; define utility name

	MSG_SERVICES <MSGDATA>		;AN000;

PRINTF_HANDLE	DW  ?			;AC000;

TRANSPACE	ENDS			;AC000;

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;

	EXTRN	cerror:near
	EXTRN	crlf2:near
	EXTRN	tcommand:near		;AN026;

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING,SS:NOTHING ;AC000;

	PUBLIC	TSYSGETMSG		;AN000;
	PUBLIC	TSYSLOADMSG		;AN000;

PUBLIC Printf_Init
printf_init proc far
	call	std_printf
	ret
printf_init endp

Public	Printf_Crlf
PRINTF_CRLF:
	CALL	STD_PRINTF
	CALL	CRLF2
	RET

PUBLIC	Std_EPrintf
STD_EPRINTF:
	mov	Printf_Handle,2 		;AC000;Print to STDERR
	jmp	short NEW_PRINTF		;AC000;
PUBLIC	Std_Printf
STD_PRINTF:
	mov	Printf_Handle,1 		;AC000;Print to STDOUT

NEW_PRINTF:
	push	ax				;AN000;save registers
	push	bx				;AN000;
	push	cx				;AN000;
	push	es				;AN000;get local ES
	push	ds				;AN000;
	pop	es				;AN000;
	push	di				;AN000;
	push	si				;AN000;
	push	dx				;AN000;
	assume	es:trangroup			;AN000;
;AD061; mov	string_ptr_2_sb,0		;AN000;initialize
	mov	print_err_flag,0		;AN000;

UTILITY_SETUP:
	mov	si,dx				;AN000;Get offset of message number
	lodsw					;AN000;load message number
	push	ax				;AN000;save it
	lodsb					;AN000;get number of substitutions
	mov	cl,al				;AN000;set up CX as # of subst
	xor	ch,ch				;AN000;   SI now points to subst list
	pop	ax				;AN000;get message number back
	cmp	cx,0				;AN000;Any substitutions?
	jz	READY_TO_PRINT			;AN000;No - continue

;AD061;  add	 dx,Ptr_Seg_Pos 		 ;AN000;Point to position of first segment
;AD061;  push	 cx				 ;AN000;save substitution count

;AD061;SET_SUBST:
;AD061;  mov	 bx,dx				 ;AN000;get dx into base register
;AD061;  cmp	 word ptr [bx],0		 ;AN000;has segment been set?
;AD061;  jnz	 SUBST_SEG_SET			 ;AN000;if not 0, don't replace it
;AD061;  test	 word ptr [bx+3],date_type	 ;AN000;if date or time - don't set segment
;AD061;  jnz	 subst_seg_set			 ;AN000;yes - skip it
;AD061;  mov	 word ptr [bx],cs		 ;AN000;put segment of subst parm in list

;AD061;SUBST_SEG_SET:
;AD061;  add	 dx,Parm_Block_Size		 ;AN000;point to position of next segment
;AD061;  loop	 SET_SUBST			 ;AN000;keep replacing until complete
;AD061;  pop	 cx				 ;AN000;

;AD061;NO_REPLACEMENT:
;AD061;  mov	 bx,parm_off_pos [si]		 ;AN000;get subst offset
;AD061;  cmp	 bx,offset trangroup:string_ptr_2 ;AN000;this is used for double indirection
;AD061;  jnz	 ready_to_print 		 ;AN000;we already have address
;AD061;  mov	 dx,string_ptr_2		 ;AN000;get address in string_ptr_2
;AD061;  mov	 parm_off_pos [si],dx		 ;AN000;put proper address in table
;AD061;  mov	 string_ptr_2_sb,si		 ;AN000;save block changed

	mov	di,offset trangroup:subst_buffer;AN061; Get address of message subst buffer
	push	di				;AN061; save it
	push	cx				;AN061; save number of subst

MOVE_SUBST:
	push	cx				;AN061;save number of subst
	mov	bx,si				;AN061;save start of sublist
	mov	cx,parm_block_size		;AN061;get size of sublist
	rep	movsb				;AN061;move sublist
	test	byte ptr [bx.$M_S_FLAG],date_type ;AN061;are we doing date/time?
	jz	move_subst_cont 		;AN061;no - no need to reset
	mov	word ptr [bx.$M_S_VALUE],0	;AN061;reset original date or time to 0
	mov	word ptr [bx.$M_S_VALUE+2],0	;AN061;

MOVE_SUBST_CONT:				;AN061;
	pop	cx				;AN061;get number of subst back
	loop	move_subst			;AN061;move cx sublists

	pop	cx				;AN061;get number of subst
	push	ax				;AN061;save message number
	cmp	Msg_Disp_Class,Util_Msg_Class	;AN061;Is this a utility message
	jz	CHECK_FIX			;AN061;YES - go see if substitutions
	mov	msg_flag,ext_msg_class		;AN061;set message flag
	mov	di,offset trangroup:extend_buf_ptr ;AN061; Get address of extended message block
	xor	ax,ax				;AN061;clear ax register
	stosw					;AN061;clear out message number
	stosb					;AN061;clear out subst count

CHECK_FIX:					;AN061;
	pop	ax				;AN061;get message number back
	pop	di				;AN061;get start of sublists
	mov	si,di				;AN061;get into SI for msgserv
	mov	bx,si				;AN061;get into BX for addressing
	push	cx				;AN061;save number of subst

SET_SUBST:					;AN061;store the segment of the subst
	cmp	word ptr [bx.$M_S_VALUE+2],0	;AN061;was it set already?
	jnz	subst_seg_set			;AN061;if not 0, don't replace it
	test	byte ptr [bx.$M_S_FLAG],date_type ;AN061;don't replace if date or time
	jnz	subst_seg_set			;AN061;yes - skip it
	mov	word ptr [bx.$M_S_VALUE+2],cs	;AN061;set segment value

SUBST_SEG_SET:					;AN061;
	add	bx,parm_block_size		;AN061;go to next sublist
	loop	set_subst			;AN061;loop CX times
	pop	cx				;AN061;get number of subst back

	mov	bx,si				;AN061;get start of sublist to BX
	cmp	word ptr [bx.$M_S_VALUE],offset trangroup:string_ptr_2 ;AN061;are we using double indirection?
	jnz	ready_to_print			;AN061;no - we already have address
	mov	dx,string_ptr_2 		;AN061;get address in string_ptr_2
	mov	word ptr [bx.$M_S_VALUE],dx	;AN061;put it into the subst block

READY_TO_PRINT:
	mov	bx,Printf_Handle		;AN000;get print handle
	mov	dl,Msg_Cont_Flag		;AN000;set up control flag
	mov	dh,Msg_Disp_Class		;AN000;set up display class
	mov	Msg_Cont_Flag,No_Cont_Flag	;AN061;reset flags to avoid
	mov	Msg_Disp_Class,Util_Msg_Class	;AN061;   transient reload

;AD061; push	bx				;AN026; save registers
;AD061; push	cx				;AN026;
;AD061; push	dx				;AN026;
;AD061; push	si				;AN026;
;AD061; push	di				;AN026;
	push	ds				;AN026;
	push	es				;AN026;


	call	SYSDISPMSG			;AN000;call Rod

	pop	es				;AN026; restore registers
	pop	ds				;AN026;
;AD061; pop	di				;AN026;
;AD061; pop	si				;AN026;
;AD061; pop	dx				;AN026;
;AD061; pop	cx				;AN026;
;AD061; pop	bx				;AN026;

	jnc	Print_success			;AN000; everything went okay
	mov	print_err_flag,ax		;AN000;

print_success:
;AD061; cmp	Msg_Disp_Class,Util_Msg_Class	;AN000;Is this a utility message
;AD061; jz	CHECK_FIX			;AN000;YES - go see if substitutions
;AD061; mov	msg_flag,ext_msg_class		;AN022;set message flag
;AD061; mov	di,offset trangroup:extend_buf_ptr ;AN000; Get address of extended message block
;AD061; xor	ax,ax				;AN000;clear ax register
;AD061; stosw					;AN000;clear out message number
;AD061; stosb					;AN000;clear out subst count

;AD061;  CHECK_FIX:
;AD061;  pop	 dx				 ;AN000;restore dx
;AD061;  cmp	 cx,0				 ;AN000;Any substitutions?
;AD061;  jz	 NO_FIXUP			 ;AN000;No - leave

;AD061;  mov	 si,dx				 ;AN000;Reset changes so transient won't reload
;AD061;  add	 si,Ptr_Seg_Pos 		 ;AN000;Point to position of first segment

;AD061;FIX_SUBST:
;AD061;  mov	 word ptr [si],0		 ;AN000;reset segment to 0
;AD061;  add	 si,Parm_Block_Size		 ;AN000;point to position of next segment
;AD061;  loop	 FIX_SUBST			 ;AN000;keep replacing until complete
;AD061;  cmp	 string_ptr_2_sb,no_subst	 ;AN000;was double indirection used?
;AD061;  jz	 no_fixup			 ;AN000;no - we're finished
;AD061;  mov	 si,string_ptr_2_sb		 ;AN000;get offset changed
;AD061;  mov	 parm_off_pos [si],offset trangroup:string_ptr_2 ;AN000; set address back to string_ptr_2

;AD061;NO_FIXUP:
;AD061; mov	Msg_Cont_Flag,No_Cont_Flag	;AN000;reset flags to avoid
;AD061; mov	Msg_Disp_Class,Util_Msg_Class	;AN000;   transient reload
	pop	dx				;AN061;restore dx
	pop	si				;AN000;restore registers
	pop	di				;AN000;
	pop	es				;AN000;restore registers
	pop	cx				;AN000;
	pop	bx				;AN000;
	pop	ax				;AN000;
	cmp	print_err_flag,0		;AN000; if an error occurred - handle it
	jnz	print_err			;AN000;

	ret					;AC000;

print_err:
	push	cs
	pop	es
	cmp	Printf_Handle,2 		;AN026;Print to STDERR?
	jnz	not_stderr			;AN026;no - continue
	jmp	tcommand			;AN026;Yes - hopless - just exit

not_stderr:
	mov	ax,print_err_flag		;AN026;get extended error number back
	mov	es,[resseg]			; No, set up for error, load the
assume	es:resgroup				;  right error msg, and jmp to cerror.
	test	PipeFlag,-1
	jz	go_to_error
	invoke	PipeOff
	mov	dx,offset trangroup:pipeemes_ptr
	jmp	short print_err_exit			;AC000;

go_to_error:
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN000; get message number in control block

PRINT_ERR_EXIT: 				;AC000;
	push	cs
	pop	es
	JMP	CERROR

;****************************************************************
;*
;* ROUTINE:	TSYSLOADMSG
;*
;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
;*		names since these routines are also used in the
;*		resident.
;*
;* INPUT:	Inputs to SYSLOADMSG
;*
;* OUTPUT:	Outputs from SYSLOADMSG
;*
;****************************************************************


TSYSLOADMSG	PROC	NEAR			;AN000;

	push	bx				;AN000;
	call sysloadmsg 			;AN000; call routine
	pop	bx				;AN000;
	ret					;AN000; exit

TSYSLOADMSG	ENDP				;AN000;

;****************************************************************
;*
;* ROUTINE:	TSYSGETMSG
;*
;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
;*		names since these routines are also used in the
;*		resident.
;*
;* INPUT:	Inputs to SYSGETMSG
;*
;* OUTPUT:	Outputs from SYSGETMSG
;*
;****************************************************************


TSYSGETMSG	PROC	NEAR			;AN000;

	push	cx				;AN000;
	call sysgetmsg				;AN000; call routine
	pop	cx				;AN000;
	ret					;AN000; exit

TSYSGETMSG	ENDP				;AN000;

MSG_SERVICES <COMT,NOVERCHECKmsg,NEARmsg,LOADmsg,NOCHECKSTDIN,NOCHECKSTDOUT,GETmsg> ;AC026; The message services
MSG_SERVICES <COMT,NEARmsg,SETSTDIO,DISPLAYmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg>	    ;AC026; The message services

PRINTF_LAST LABEL   WORD

include msgdcl.inc


TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tucode.asm ===
page ,132
;	SCCSID = @(#)tucode.asm 4.2 85/05/31
;	SCCSID = @(#)tucode.asm 4.2 85/05/31
Title	COMMAND Language midifiable Code Transient
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include comsw.asm
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	ECHOFLAG:BYTE
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BAD_ON_OFF_ptr:word
	EXTRN	ctrlcmes_ptr:word
	EXTRN	DEL_Y_N_PTR:WORD
	EXTRN	ECHOMES_ptr:word
	EXTRN	extend_buf_ptr:word	;AC000;
	EXTRN	offmes_ptr:word
	EXTRN	onmes_ptr:word
	EXTRN	PARSE_BREAK:BYTE	;AN000;
	EXTRN	promptdat_moday:word	;AC000;
	EXTRN	promptdat_ptr:word	;AC000;
	EXTRN	promptdat_yr:word	;AC000;
	EXTRN	string_buf_ptr:word
	EXTRN	SUREMES_ptr:word
	EXTRN	VERIMES_ptr:BYTE
	EXTRN	WeekTab:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg_buf:byte
	EXTRN	BWDBUF:BYTE
	EXTRN	DEST:BYTE
	EXTRN	destdir:byte
	EXTRN	dirchar:byte
	EXTRN	PARSE1_CODE:BYTE	;AN000;
	EXTRN	RESSEG:WORD
	EXTRN	string_ptr_2:word

TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

	EXTRN	CERROR:NEAR
	EXTRN	CRLF2:NEAR
	EXTRN	extend_setup:near	;AN022;

	PUBLIC	CNTRLC
	PUBLIC	ECHO
	PUBLIC	GetDate
	PUBLIC	NOTEST2
	PUBLIC	PRINT_DATE
	PUBLIC	SLASHP_ERASE		;AN000;
	PUBLIC	VERIFY

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:TRANGROUP,SS:NOTHING

; ****************************************************************
; *
; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
; *
; * FUNCTION:	 Delete files based on user parsed input.  Prompt
; *		 user for Y/N if necessary.  If an error occurs,
; *		 set up an error message and go to CERROR.
; *
; * INPUT:	 FCB at 5ch set up with filename(s) entered
; *		 Current directory set to entered directory
; *
; * OUTPUT:	 none
; *
; ****************************************************************
;
; ARE YOU SURE prompt when deleting *.*

NOTEST2:
	MOV	CX,11
	MOV	SI,FCB+1

AMBSPEC:
	LODSB
	CMP	AL,'?'
	JNZ	ALLFIL
	LOOP	AMBSPEC

ALLFIL:
	CMP	CX,0
	JNZ	NOPRMPT

ASKAGN:
	MOV	DX,OFFSET TRANGROUP:SUREMES_ptr ; "Are you sure (Y/N)?"
	invoke	std_printf
	MOV	SI,80H
	MOV	DX,SI
	MOV	WORD PTR [SI],120		; zero length
	MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_STRING_INPUT
	INT	21H
	LODSW
	OR	AH,AH
	JZ	ASKAGN
	INVOKE	SCANOFF
	call	char_in_xlat			;G Convert to upper case
	retc					;AN000; return if function not supported
	CMP	AL,CAPITAL_N			;G
	retz
	CMP	AL,CAPITAL_Y			;G
	PUSHF
	CALL	CRLF2
	POPF
	JNZ	ASKAGN

NOPRMPT:
	MOV	AH,FCB_DELETE
	MOV	DX,FCB
	INT	21H
	INC	AL
	jz	eraerr
	invoke	RESTUDIR
	ret					; If no error, return

eraerr:
	invoke	set_ext_error_msg		;AN022; set up the extended error
	push	dx				;AN022; save message
	invoke	RESTUDIR
	pop	dx				;AN022; restore message

	cmp	word ptr extend_buf_ptr,error_no_more_files ;AN022; convert no more files to
	jnz	cerrorj2			;AN022; 	file not found
	mov	Extend_Buf_ptr,error_file_not_found  ;AN000; get message number in control block

cerrorj2:
	jmp	cerror


; ****************************************************************
; *
; * ROUTINE:	 SLASHP_ERASE  - execution of DEL/ERASE /P
; *
; * FUNCTION:	 Delete files based on user parsed input.  Prompt
; *		 user for Y/N where necessary.	If an error occurs
; *		 set up and error message and transfer control
; *		 to CERROR.
; *
; * INPUT:	 FCB at 5ch set up with filename(s) entered
; *		 Current directory set to entered directory
; *
; * OUTPUT:	 none
; *
; ****************************************************************

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:TRANGROUP,SS:NOTHING

SLASHP_ERASE:					;AN000; entry point
	invoke	build_dir_string		;AN000; set up current directory string for output
	mov	ah,Set_DMA			;AN000; issue set dta int 21h
	mov	dx,offset trangroup:destdir	;AN000; use Destdir for target
	int	21H				;AN000;
	mov	ah,Dir_Search_First		;AN000; do dir search first int 21h
	mov	dx,FCB				;AN000; use FCB at 5Ch for target
	int	21H				;AN000;
	inc	al				;AN000; did an error occur
	jz	eraerr				;AN022; go to error exit

delete_prompt_loop:				;AN000;
	mov	si,offset trangroup:destdir+1	;AN000; set up FCB as source
	mov	di,offset trangroup:dest	;AN000; set up dest as target
	mov	al,dirchar			;AN000; store a "\" in the first char
	stosb					;AN000;     of DEST
	invoke	fcb_to_ascz			;AN000; convert filename from FCB to ASCIIZ string

slashp_askagn:					;AN000;
	call	crlf2				;AN000; print out carriage return, line feed
	mov	dx,offset trangroup:bwdbuf	;AN000; print out current directory string
	mov	bx,dx				;AN000; get string pointer in bx
	cmp	byte ptr [bx+3],end_of_line_out ;AN000; see if only D:\,0
	jnz	not_del_root			;AN000; no continue
	mov	byte ptr [bx+2],end_of_line_out ;AN000; yes, get rid of \

Not_del_root:					;AN000;
	mov	string_ptr_2,dx 		;AN000;
	mov	dx,offset trangroup:string_buf_ptr ;AN000;
	invoke	std_printf			;AN000;
	mov	dx,offset trangroup:dest	;AN000; print out file name string
	mov	string_ptr_2,dx 		;AN000;
	mov	dx,offset trangroup:string_buf_ptr ;AN000;
	invoke	std_printf			;AN000;
	mov	dx,offset trangroup:Del_Y_N_Ptr ;AN000; issue ",    Delete (Y/N)?" message
	invoke	std_printf			;AN000;
;;M029	mov	si,80H				;AN000; set up buffer for input
;;M029	mov	dx,si				;AN000;
;;M029	mov	word ptr [si],combuflen 	;AN000;
;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	 ;AN000;
;;M029	int	21h			;AN000; get input from the user
;;M029	lodsw					;AN000;
;;M029	or	ah,ah				;AN000; was a character entered?
;;M029	jz	slashp_askagn			;AN000; no - ask again
;;M029	invoke	scanoff 			;AN000; scan off leading delimiters

;	Get a single character input.

	mov	ax,(std_con_input_flush shl 8) or std_con_input	;M029
	int	21h						;M029

	call	char_in_xlat			;AN000; yes - upper case it
	retc					;AN000; return if function not supported
	cmp	al,capital_n			;AN000; was it no?
	jz	next_del_file			;AN000; yes - don't delete file
	cmp	al,capital_y			;AN000; was it yes?
	jz	delete_this_file		;AN000; yes - delete the file
	jmp	short slashp_askagn		;AN000; it was neither - ask again

delete_this_file:				;AN000;
	mov	ah,fcb_delete			;AN000; delete the file
	mov	dx,offset trangroup:destdir	;AN000; use Destdir for target
	int	21h			;AN000;
	inc	al				;AN000; did an error occur?
	jnz	next_del_file			;AN000; no - get next file
;
;M041; Begin changes
; We got an error deleting the file. If this is access denied, we can go on
;to the next file after printing an error message.
;
	invoke	Get_ext_error_number			;see what error we got
	cmp	ax,error_access_denied		;is it access denied?
	jne	stop_del			;no, some other error
	invoke	CrLf2				;print a CR-LF
	invoke 	set_ext_error_msg			;error message
	invoke	std_eprintf			;"Access denied"
	jmp	short next_del_file			;try next file
stop_del:
;
;M041; End changes
;
	jmp	eraerr				;AN022; go to error exit - need long jmp

next_del_file:					;AN000;
;
; M050 - begin
; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
;       with /protect+ and /light+ makes it intercept all
;       deletes. This hook does not save and restore the DTA correctly.
;       They save the DWORD in a WORD by mistake! They save both the
;       segment and the offset in the SAME variable (WORD)!!!
;
	mov	ah,Set_DMA
	mov	dx,offset trangroup:destdir
	int	21H
;
; M050 - end

	mov	ah,dir_search_next		;AN000; search for another file
	mov	dx,FCB				;AN000;
	int	21h			;AN000;
	inc	al				;AN000; was a file found?
	jz	slash_p_exit			;AN000; no - exit
	jmp	delete_prompt_loop		;AN000; yes - continue (need long jump)

slash_p_exit:
	invoke	get_ext_error_number		;AN022; get the extended error number
	cmp	ax,error_no_more_files		;AN022; was error file not found?
	jz	good_erase_exit 		;AN022; yes - clean exit
	jmp	extend_setup			;AN022; go issue error message

good_erase_exit:
	invoke	restudir			;AN000; we're finished - restore user's dir
	call	crlf2				;AN000; print out carriage return, line feed
	ret					;AN000; exit


;************************************************
; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"

	break	Echo

assume	ds:trangroup,es:trangroup

ECHO:
	CALL	ON_OFF
	JC	DOEMES
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	JNZ	ECH_OFF
	OR	[ECHOFLAG],1
	RET
ECH_OFF:
	AND	[ECHOFLAG],NOT 1
	RET


CERRORJ:
	JMP	CERROR

;
; There was no discrenable ON or OFF after the ECHO.  If there is nothing but
; delimiters on the command line, we issue the ECHO is ON/OFF message.
;

ASSUME	DS:TRANGROUP

DOEMES:
	cmp	cl,0				;AC000; was anything on the line?
	jz	PEcho				; just display current state.
	MOV	DX,82H				; Skip one char after "ECHO"
	invoke	CRPRINT
	JMP	CRLF2

PECHO:
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	BL,[ECHOFLAG]
	PUSH	CS
	POP	DS
ASSUME	DS:TRANGROUP
	AND	BL,1
	MOV	DX,OFFSET TRANGROUP:ECHOMES_ptr
	JMP	SHORT PYN

	break	Break
assume	ds:trangroup,es:trangroup

CNTRLC:
	CALL	ON_OFF
	MOV	AX,(SET_CTRL_C_TRAPPING SHL 8) OR 1
	JC	PCNTRLC
	JNZ	CNTRLC_OFF
	MOV	DL,1
	INT	21H				; Set ^C
	RET

CNTRLC_OFF:
	XOR	DL,DL
	INT	21H				; Turn off ^C check
	RET

PCNTRLC:
	CMP	CL,0				;AC000; rest of line blank?
	JNZ	CERRORJ 			; no, oops!

pccont:
	XOR	AL,AL
	INT	21H
	MOV	BL,DL
	MOV	DX,OFFSET TRANGROUP:CTRLCMES_ptr

PYN:
	mov	si,offset trangroup:onmes_ptr	;AC000; get ON pointer
	OR	BL,BL
	JNZ	PRINTVAL
	mov	si,offset trangroup:offmes_ptr	;AC000; get OFF pointer

PRINTVAL:
	push	dx				;AN000; save offset of message block
	mov	bx,dx				;AN000; save offset value
	lodsw					;AN000; get message number of on or off
	mov	dh,util_msg_class		;AN000; this is a utility message
	invoke	Tsysgetmsg			;AN000; get the address of the message
	add	bx,ptr_off_pos			;AN000; point to offset of ON/OFF
	mov	word ptr [bx],si		;AN000; put the offset in the message block
	pop	dx				;AN000; get message back
	invoke	std_printf			;AC000; go print message
	mov	word ptr [bx],0 		;AN000; zero out message pointer

	ret					;AN000; exit

	break	Verify
assume	ds:trangroup,es:trangroup

VERIFY:
	CALL	ON_OFF
	MOV	AX,(SET_VERIFY_ON_WRITE SHL 8) OR 1
	JC	PVERIFY
	JNZ	VER_OFF
	INT	21H				; Set verify
	RET

VER_OFF:
	DEC	AL
	INT	21H				; Turn off verify after write
	RET

PVERIFY:
	CMP	CL,0				;AC000; is rest of line blank?
	JNZ	CERRORJ 			; nope...
	MOV	AH,GET_VERIFY_ON_WRITE
	INT	21H
	MOV	BL,AL
	MOV	DX,OFFSET TRANGROUP:VERIMES_ptr
	JMP	PYN

; ****************************************************************
; *
; * ROUTINE:	 ON_OFF
; *
; * FUNCTION:	 Parse the command line for an optional ON or
; *		 OFF string for the BREAK, VERIFY, and ECHO
; *		 routines.
; *
; * INPUT:	 command line at offset 81H
; *		 PARSE_BREAK control block
; *
; * OUTPUT:	 If carry is clear
; *		    If ON is found
; *		       Zero flag set
; *		    If OFF is found
; *		       Zero flag clear
; *		 If carry set
; *		    If nothing on command line
; *		       CL set to zero
; *		    If error
; *		       CL contains error value from parse
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

ON_OFF:
	MOV	SI,81h

scan_on_off:					;AN032; scan off leading blanks & equal
	lodsb					;AN032; get a char
	cmp	al,blank			;AN032; if whitespace
	jz	scan_on_off			;AN032;    keep scanning
	cmp	al,tab_chr			;AN032; if tab
	jz	scan_on_off			;AN032;    keep scanning
	cmp	al,equal_chr			;AN032; if equal char
	jz	parse_on_off			;AN032;    start parsing
	dec	si				;AN032; if none of above - back up

parse_on_off:					;AN032;    and start parsing
	mov	di,offset trangroup:parse_break ;AN000; Get adderss of PARSE_BREAK
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser
	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	BADONF				;AC000; yes, return error
	cmp	ax,result_no_error		;AN000; did an error occur
	jz	on_off_there			;AN000; no - continue
	mov	cx,ax				;AN000; yes - set cl to error code
	jmp	short BADONF			;AN000; return error

on_off_there:
	cmp	parse1_code,-1			;AN014; was a valid positional present?
	jnz	good_on_off			;AN014; yes - continue
	mov	cx,badparm_ptr			;AN014; something other than ON/OFF
	jmp	short BADONF			;AN014; return error

good_on_off:					;AN014;
	xor	ax,ax				;AC000; set up return code for
	or	al,parse1_code			;AC000;    ON or OFF in AX
	pushf					;AN000; save flags
	mov	di,offset trangroup:parse_break ;AN000; Get adderss of PARSE_BREAK
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AN000; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?
	jnz	BADONF_flags			;AN000; NO, return error
	popf					;AN000; restore flags
	clc					;AC000; no error
	jmp	short on_off_end		;AN000; return to caller

BADONF_flags:
	mov	cx,ax
	popf

;
; No discernable ON or OFF has been found. Put an error message pointer in DX
; and return the error
;
BADONF:
	MOV	DX,OFFSET TRANGROUP:BAD_ON_OFF_ptr
	STC

ON_OFF_END:

	RET



;*************************************************************************
; print date

PRINT_DATE:
	PUSH	ES
	PUSH	DI
	PUSH	CS
	POP	ES
	CALL	GetDate 			; get date
	xchg	dh,dl				;AN000; switch month & day
	mov	promptDat_yr,cx 		;AC000; put year into message control block
	mov	promptDat_moday,dx		;AC000; put month and day into message control block
	mov	dx,offset trangroup:promptDat_ptr ;AC000; set up message for output
	invoke	std_printf
;AD061; mov	promptDat_yr,0			;AC000; reset year, month and day
;AD061; mov	promptDat_moday,0		;AC000;     pointers in control block
	POP	DI				;AC000; restore di,es
	POP	ES				;AC000;
	return
;
; Do GET DATE system call and set up 3 character day of week in ARG_BUF
; for output.  Date will be returned in CX,DX.
;

GetDate:
	mov	di,offset trangroup:arg_buf	;AC000; target for day of week
	MOV	AH,GET_DATE			;AC000; get current date
	INT	21h			;AC000; Get date in CX:DX
	CBW					;AC000;

	push	cx				;AN000; save date returned in
	push	dx				;AN000;      CX:DX
	MOV	SI,AX
IFNDEF DBCS
	SHL	SI,1
	ADD	SI,AX				; SI=AX*3
  ELSE
    ifdef JAPAN					; MSKK01 07/14/89
	shl	si,1
	shl	si,1				; SI=AX*4
    endif
    IFDEF TAIWAN
	SHL	SI,1
	ADD	SI,AX
	SHL	SI,1				; SI=AX*6
    ENDIF
    ifdef KOREA
        shl     si,1
    endif
ENDIF
	mov	cx,si				;AN000; save si
	mov	ax,weektab			;AN000; get message number of weektab
	mov	dh,util_msg_class		;AN000; this is a utility message
	push	di				;AN000; save argument buffer
	invoke	Tsysgetmsg			;AN000; get the address of the message
	pop	di				;AN000; retrieve argument buffer
	add	si,cx				;AC000; get day of week
IFNDEF DBCS
	MOV	CX,3
  ELSE
    ifdef JAPAN					; MSKK01 07/14/89
	mov	cx,4
    endif
    IFDEF TAIWAN
	MOV	CX,6
    ENDIF
    ifdef KOREA
        mov     cx,2                            ; MSCH 90/9/6
    endif
ENDIF
	REP	MOVSB
	mov	al,end_of_line_out		;AC000; terminate the string
	stosb
	pop	dx				;AN000; get back date
	pop	cx				;AN000;

	return
;g
;g   This routine determines whether the character in AL is a
;g   Yes or No character.  On return, if AL=0, the character is
;g   No, if AL=1, the character is Yes.
;g

assume	ds:trangroup

char_in_xlat	proc	near

	mov	dl,al				;AC000; get character into DX
	xor	dh,dh				;AC000;
	mov	ax,(getextcntry SHL 8) + 35	;AC000; Yes/No char call
	int	21h			;AC000;

	ret

char_in_xlat	endp

TRANCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\minicmd\minicmd.asm ===
; ************************************************************************
;
; This file is contains the guts of "minicmd.com." It has all the functions
; to handle the intrinsic commands like SET, ECHO, IF, GOTO, LABEL.
; It also allows extrinsic commands (.COM, .EXE) to be launched but
; a full path must be specified or the file should be on the current
; working directory. Note that it also has a Control-C and critical error
; handler. The main motivation for "minicmd.com" is to have a program
; launcher for dedicated ROM based systems where the full functionality
; of our normal "command.com" is not needed. Note that we only handle
; subsets of the internal commands too! For example, we do not handle
; replaceable arguments like "%ABC", etc in our "SET" command!
; Since it is very small in size, we can have a bootable and use-able
; system that fits in a single 64K ROM!
;
; ************************************************************************
;
; Scope for future modifications/enhancements:
;
; Make it so that there is a generic GET_LINE proceudre that will get
;   a line from the BAT file or STDIN to a local buffer in our DATASEG
;   We can then manipulate the contents of this buffer. This will save 
;   us the head-ache of DS not being DSEG when processing the BAT file
;   at INIT time.
;
; It would be nice to handle the '@' char/cmd in the BAT file.
;
;
;			Revision History
;			-----------------
;
; M002	SHK	B#2518. Make sure that there is a WORD 0 at the end of
;		the ENV (to be compatible with COMMAND.COM).
;
; M004	SHK	Removed almost all BUG BUGs from this file and added
;		better comments.
;
; M006	SHK	Changed a JZ to a JBE in function fn process_initfile.
;


CSEG	SEGMENT	PARA PUBLIC 'CODE'
CSEG	ENDS

INITIALIZED_DATASEG	SEGMENT PARA PUBLIC 'DATA'
INITIALIZED_DATASEG 	ENDS

UN_INITIALIZED_DATASEG	SEGMENT BYTE PUBLIC 'DATA'
UN_INITIALIZED_DATASEG	ENDS

	; include all the constants used in this file.
	INCLUDE minicmd.inc

	; include the data used in the program (initialized and un-initialized).
	INCLUDE dataseg.asm

IFNDEF RAM_VERSION

; BootFlag bit we're concerned with:
BF_NoConfig	EQU	00000001b	; No INIT file processing.

	INCLUDE msbdata.inc
ENDIF


CSEG	SEGMENT	PARA PUBLIC 'CODE'

	assume cs:CSEG,es:nothing,ds:nothing,ss:nothing

start:
IFDEF RAM_VERSION
start_ram PROC FAR
	mov	ax, cs
	add	ax, 10h
	mov	ds, ax		; make DS so that offsets are 0 based!
	mov	ax, offset main_shell

	push	cs		; this will be made ES in main_shell

	push	ds		; push SEG:OFF of
	push	ax		; routine main_shell and
	ret			; transfer control to it.
start_ram ENDP
ENDIF

; number of PARAs for the code in CSEG alone!
;
CODE_NUM_PARAS	EQU ((((offset last_code) - (offset start)) + 0fh)/16)

; number of PARAs for the code in CSEG + that for the PSP! PSP needs
; 10h PARAs = (CODE_NUM_PARAS + 10h)!
;
SEG_TRUNC_SIZE 	EQU ((((offset last_code) - (offset start)) + 10fh)/16)

; number of PARAs needed for the initialized data.
;
INITIALIZED_DATA_NUM_PARAS EQU ((((offset end_initialized_data) - \
			         (offset begin_initialized_data))+ 0fh)/16)

; number of PARAs needed for the un-initialized data.
;
UN_INITIALIZED_DATA_NUM_PARAS EQU ((((offset end_un_initialized_data) - \
				 (offset begin_un_initialized_data))+ 0fh)/16)

; number of PARAs for DATA in DSEG -- this includes some code sitting there
; the INITIALIZED data and the un-initialized data!
;
DATA_NUM_PARAS	EQU (INITIALIZED_DATA_NUM_PARAS + \
						UN_INITIALIZED_DATA_NUM_PARAS)

; number of bytes needed for the STACK. This may be reduced appropriately
; as such a big stack may not be needed.
;
MYSTACK_SIZE	EQU 1024

; number of PARAs needed for the stack
;
MYSTACK_PARAS	EQU ((MYSTACK_SIZE + 0fh)/16)

; number of bytes needed for the environment. This may be reduced appropriately
; as such a big senvironment is usually not needed by an user/application.
ENV_SIZE	EQU 4096	; ENV size in bytes.

; number of PARAs needed for the environment
;
ENV_PARAS	EQU ((ENV_SIZE + 0fh)/16)

; Note that the 10h below is the num. of paras for the PSP!
; number of PARAs needed in RAM to run the program. Memory is dynamically
; allocated for processing the INIT file.
;
ROM_NUM_PARAS	EQU (10h + MYSTACK_PARAS + DATA_NUM_PARAS + ENV_PARAS)



;****************************************************************************
;*
;* ROUTINE:	main_shell
;*		
;*
;* FUNCTION: 	This is the main routine that processes the INITFILE and
;*		reads lines from stdin and processes user commands!
;*		
;*
;* INPUT:	In RAM_VERSION stack has the PSP segment, else NONE.
;*		INIT file if present is read in at start up. Reads commands
;*		from stdin after processing INIT file.
;*
;* OUTPUT:	Processes the user commands from the INIT file or stdin.
;*		Sends output to stdout.
;*
;* REGISTERS:	ALL destroyed.
;****************************************************************************

main_shell PROC NEAR

IFDEF RAM_VERSION
	pop	es	; ES is the PSP segment!
ENDIF

	; now re-size and free up un-used memory!
	;
IFDEF RAM_VERSION
	mov	bx, SEG_TRUNC_SIZE
	mov	ah, 4ah
	int	21h
ELSE
	mov	bx, ROM_NUM_PARAS
	mov	ah, 4ah
	int	21h
ENDIF	

IFNDEF RAM_VERSION
	mov	bp, es	; BP is the TEMP which at all times points to
			; the next free area in the resized block!
	add	bp, 10h ; Initially point right past the PSP!
ENDIF

IFDEF RAM_VERSION
	; allocate a decent size STACK now!
	;
	mov	ah, 48h
	mov	bx, (MYSTACK_SIZE + 0fh)/16
	int	21h

	; Can be more graceful by putting up an out of mem message! But since
	; we are the command shell, we can't exit to anyone else. So, it
	; I guess it is OK to hang! BTW we don't expect to run out of mem!
	;
inf_loop:jc	inf_loop

ELSE

	; Note that we can save a few bytes for the ROM version if we used BP 
	; directly wherever we wanted instead of putting it in AX and 
	; then using it.
	;
	mov	ax, bp
	add	bp, MYSTACK_PARAS ; BP now points right past the STACK!
ENDIF

	cli
	mov	ss, ax
	mov	sp, MYSTACK_SIZE
	sti

IFDEF RAM_VERSION
	; allocate the memory needed for the DATA now!
	;
	mov	ah, 48h
	mov	bx, DATA_NUM_PARAS
	int	21h

	; Can be more graceful by putting up an out of mem message! But since
	; we are the command shell, we can't exit to anyone else. So, it
	; I guess it is OK to hang! BTW we don't expect to run out of mem!
	;
	jc	inf_loop
ELSE
	mov	ax, bp
	add	bp, DATA_NUM_PARAS ; BP now points right past the DATA!
ENDIF

	cld		; clear direction flag for all block move, etc.
			; Note that I assume that this will remain clear
			; during subsequent move/cmp, etc.

	; now block copy the DATA from ROM/Current area in RAM for the
	; RAM_VERSION into our new DSEG!
	;
	mov	es, ax		; ES now is the segment of allocated block!
	xor	di, di		; ES:DI points to beginning of this block.
				; This is our dynamically set up DSEG!
	mov	ax, cs
	add	ax, CODE_NUM_PARAS
	mov	ds, ax		; DS now points to end of code. This is the
				; same as the beginning of data!

	mov	si, di		; note that DI is still 0!

	mov	cx, (INITIALIZED_DATA_NUM_PARAS * 16)
	rep	movsb

	push	es
	pop	ds		; DS = ES now!

	assume es:DSEG,ds:DSEG

	; get and store our PSP. We use this later to decide during critical
	; errors whether we can "Abort" the process or not!
	;
	mov	ah, 51h
	int	21h
	mov	MyPSP, bx
	
IFDEF RAM_VERSION
	; allocate the environment space now!
	;
	mov	ah, 48h
	mov	bx, (ENV_SIZE + 0fh)/16
	int	21h

	; Can be more graceful by putting up an out of mem message! But since
	; we are the command shell, we can't exit to anyone else. So, it
	; I guess it is OK to hang! BTW we don't expect to run out of mem!
	;
	jc	inf_loop
ELSE
	mov	ax, bp		; BP is already pointing to ENV seg!
ENDIF

	mov	env_seg, ax	; Store the segment addr of this ENV block
				; for future use and for the EXEC call!

	; M002 Initialize the environment as being NULL! A 0 byte at the start
	; M002 of the ENV signifies this! However, to be compatible with
	; M002 command.com, put in a WORD 0!
	;
	push	es
	mov	es, ax
	assume	es:nothing
	mov	word ptr es:[0], 0	; M002
	pop	es
	assume	es:DSEG

	; now initialize some of the fields of the environment block's
	; that will be used for the EXEC call later. ES:BX will be pointing
	; to this block at that time.
	;
	mov	cmd_seg-2, offset DSEG:cmd_tail
	mov	cmd_seg, ds

	mov	fcb1_seg-2, offset DSEG:fcb1
	mov	fcb1_seg, ds

	mov	fcb2_seg-2, offset DSEG:fcb2
	mov	fcb2_seg, ds


	; Install Ctrl+C/Ctrl+Break handler.
	;
	push	ds
	push	cs
	pop	ds				; make DS = CS
	assume	ds:nothing
	mov	dx, offset CSEG:CtrlCHandler	; DS:DX = Int. handler addr.
	mov	ax, 2523h
	int	21h
	pop	ds
	assume	ds:DSEG

	; The critical error stub handler which is in DSEG will use this
	; FAR pointer to call this real critical error handler!
	;
	mov	word ptr CSCritErrHandlerAddr, offset CSEG:CritErrHandler
	mov	word ptr CSCritErrHandlerAddr+2, cs

	mov	word ptr DSExecHandlerAddr, offset DSEG:DSExechandler
	mov	word ptr DSExecHandlerAddr+2, es

	; Install Critical Error handler.
	; Note that the critical error handler stub is in the
	; data segment! We need this as that way we can get our DSEG
	; value and access variables like MyPSP, etc!
	;
	mov	dx, offset DSEG:CritErrorStub
	mov	ax, 2524h
	int	21h

	; Initialize the max. number of characters we read from stdin
	; when we are in interactive mode.
	;
	mov	pgm_blk, MAX_INP_LENGTH

	mov	last_pgm_exit_code, INIT_ERRLVL	; Init. last pgm exit code.
	mov	is_echo_on?, 1			; ECHO initially ON!

IFNDEF RAM_VERSION
	;
	; Check to see if the Boot Options indicate that startup processing
	; should be omitted.  If so, skip the open, and pretend that there
	; no INIT file.
	;
	push	es			; save current ES
	mov	ax,BDATA
	mov	es,ax
	assume	es:BDATA
	mov	ax,es:BootFlags		; get boot options from BIOS
	pop	es			; restore previous ES
	assume	es:DSEG
	test	al,BF_NoConfig		; flag set to supress processing?
	jnz	main_loop		; if so, skip autoexec processing
ENDIF

	call	process_initfile

main_loop:

	call	print_prompt		; that fn will take care of echo ON stuff!

	mov	dx, offset DSEG:pgm_blk	; DS:DX = buffer for user input
	mov	ah, 0ah
	int	21h			; get buffered input

	; We just read user input, so put out a CR-LF!
	call	print_CR_LF

	mov	si, offset DSEG:pgm_name

input_in_buffer:

	; DS:SI is the input from user - passed on to process_cmd!
	call	process_cmd

	jc	error_in_cmd

	; Actually we don't have to do the following check as we process
	; the full line of an IF cmd inside the if_proc itself using
	; recursion. It is there as a safety precaution.
	cmp	byte ptr [si-1], CR
	jne	input_in_buffer

	jmp	short	main_loop

error_in_cmd:

	; If we are here it means that it was not an intrinsic command
	; and also a program could not be launched succesfully!
	;
	mov	dx, offset DSEG:LOAD_MSG
	mov	cx, LOAD_MSG_LEN
	call	print_str_stderr

IFNDEF RAM_VERSION
	jmp	short main_loop
ELSE
	; This is just a method to get out of minicmd when using the RAM
	; version -- useful for debugging. A line with just q\r will
	; cause us to exit minicmd.
	;
	mov	si, offset DSEG:pgm_name
	lodsb
	cmp	al, 'q'
	jne	main_loop
	
	mov	ax, 4c01h
	int	21h
ENDIF

main_shell ENDP


;****************************************************************************
;*
;* ROUTINE:	process_initfile
;*
;* FUNCTION: 	Reads in commands from the INIT BAT file and processes them
;*		If the file is not present does nothing.
;*		
;*
;* INPUT:	DS, ES pointing to DSEG and a INIT file (optional).
;*		
;*
;* OUTPUT:	process INIT file and sends output to stdout.
;*
;* REGISTERS:	ALL except the segment registers destroyed (caller beware).
;****************************************************************************

process_initfile PROC NEAR

	assume	ds:DSEG
	push	ds

	mov	in_bat_file, 1	; mark that we are processing the BAT file!

	mov	ax, 3d00h	; OPEN file for read access!
	mov	dx, offset DSEG:INIT_BAT_NAME
	int	21h
	jnc	PIInitFileFound	; Short jump out of range!!!
	jmp	PINoInitFile

PIInitFileFound:
	mov	fhandle, ax	; store file handle for future use.

	; Seek to END of file to find out file size!
	mov	bx, ax
	mov	ax, 4202h
	xor	cx, cx
	mov	dx, cx
	int	21h

	jc	PIJumpErrInit

	or	dx, dx			; Is file size > 64K?
	jz	PIFileSizeUnder64K	; No! Too bad short jmp out of range!

PIJumpErrInit:
	jmp	PIErrorInitFIle	; file size >= 64K -- can't handle it :-(

PIFileSizeUnder64K:

	; store file size for future use.
	mov	fsize, ax

	; Seek to BEG of file - to start reading!
	mov	ax, 4200h	; BX still has file handle.
	mov	cx, dx		; Note that DX = 0 now as file size < 64K!
	int	21h		

	jc	PIJumpErrInit

	; If we are here, it means that we know the size of the INIT file
	; (It has been opened succesfully) and that it is < 64Kbytes!

	; Convert file size into num. of PARAs rounded up!
	mov	ax, fsize
	or	ax, ax
	jz	PIZeroSizeFile

	; assertion: DX = 0 now!
	mov	cx, 16
	div	cx
	or	dx, dx		; Is remainder 0?
	jz	PIExactNumParas ; Yes.
	
	inc	ax		; move number of PARAs up by 1 (round UP!)

PIExactNumParas:
	push	es
	push	ax		; save num paras reqd. for BAT file!


	; Now, try to allocate the necessary number of paragraphs to read in
	; the file (value in AX). Do this allocation at the top end of
	; memory, so that when we free this memory, no fragmentation of
	; occurs even if any TSRs have been launched from the INIT file.
	;
	; This is done in 3 steps:
	;   1) find out biggest free block available and allocate it.
	;   2) resize it so that we leave free a block needed for the INIT
	;	at the top end of memory.
	;   3) now allocate that free block we just created. I suppose it is
	;	possible to grab a different block if it matches this request!
	;   4) free the block we had re-sized!

	; Do step 1.
	;
	mov	bx, 0ffffh
	mov	ah, 48h
	int	21h

	; The above call should generate an error and BX will have the avail
	; amount of memory in PARAS!
	;
	mov	ah, 48h
	int	21h


	; Do step 2.
	;
	pop	cx		; get num paras reqd. for BAT file into CX
	sub	bx, cx

PIInfLoop:
	jbe	PIInfLoop	; M006 Make sure we have enough memory for
				; BAT file.

	dec	bx		; Subtract 1 for the arena header.
	mov	es, ax
	assume	es:nothing
	mov	ah, 4ah
	int	21h

	; Do step 3.
	;
	mov	bx, cx		; CX has number of PARAs to be allocated!
	mov	ah, 48h
	int	21h		; Note that this alloc cannot fail!!

	; Do step 4.
	;
	push	ax
	mov	ah, 49h
	int	21h		; ES stil has the re-sized block's segment!
	pop	ax
	pop	es
	assume	es:DSEG
	
	mov	cx, fsize
	mov	bx, fhandle

	; READ in whole file into the block we just allocated!
	;
	mov	ds, ax
	assume	ds:nothing
	mov	ah, 3fh
	xor	dx, dx
	int	21h		
	jc	PIErrorReading

	mov	si, es:fsize
	mov	al, [si-1]
	call	is_CR_LF?		; see if file has a CR/LF at EOF!
	je	PIProperlyTerminatedFile

	mov	byte ptr [si-1], CR	; replace last char with CR. This is
					; done to prevent us from overflowing
					; buffer when processing!

PIProperlyTerminatedFile:
	xor	si, si

	; DS:SI now points to beginning of BAT file in buffer!

PIBatFileLoop:
	cmp	si, es:fsize	; has whole file been processed?
	jge	PIBatFileDone	; Yes!

	call	echo_cmd	; echo cmd seen in INIT file if option ON!

	; process the command in buffer pointed to by DS:SI. Note that DS:SI
	; after this processing points to the next cmd in buffer.
	;
	call	process_cmd	

	jnc	PIBatFileLoop	; If no error, continue processing next cmd.

	; error in executing command in INIT file,print msg and continue!
	;
	mov	dx, offset DSEG:LOAD_MSG
	mov	cx, LOAD_MSG_LEN
	call	print_str_stderr

	jmp	short	PIBatFileLoop

PIBatFileDone:
PIErrorreading:
	; Free the buffer that was used for the BAT file
	mov	ah, 49h
	push	es
	push	ds
	pop	es
	assume	es:nothing
	int	21h		; Free block specified by ES (our buffer)

	pop	es
	assume	es:DSEG	

PIErrorInitFile:
PIZeroSizeFile:
	; CLOSE file
	;
	mov	ah, 3eh
	mov	bx, es:fhandle
	int	21h		

	; Note that we are ignoring errors on this call. It shouldn't matter.

PINoInitFile:
	pop	ds
	assume	ds:DSEG

	mov	in_bat_file, 0	; mark that we are done processing the BAT file!
	ret
process_initfile ENDP



	; Note that the following functions will be called
	; when inside process_initfile and at that time DS is not DSEG!
	; Hence the following 'assume'. However, if we implemented that
	; modular GET_LINE proc as suggested earlier, this will not
	; be needed.
	;
    	assume	ds:nothing

;****************************************************************************
;*
;* ROUTINE:	CtrlChandler
;*
;* FUNCTION: 	Does nothing but listens to Ctrl+C and Ctrl+Break and
;*		lets the current process continue un-interrupted.
;*
;* INPUT:	CARRY  clear.
;*
;* OUTPUT:	Nothing.
;*
;* REGISTERS:	None affected.
;****************************************************************************

CtrlCHandler PROC NEAR
	; We always let the program continue!
	; By default, at entry to this routine, CARRY is clear!
	;
	iret
CtrlCHandler ENDP



;****************************************************************************
;*
;* ROUTINE:	print_str_stderr
;*
;* FUNCTION: 	Prints a string to stderr.
;*
;* INPUT:	ES:DX = pointer points to string to be printed
;*		CX    = length of string to be printed
;*
;* OUTPUT:	Prints CR, LF, string, CR, LF to stderr
;*
;* REGISTERS:	AX, BX destroyed.
;****************************************************************************

print_str_stderr PROC NEAR

	call	print_CR_LF

	push	ds		; save DS

	push	es
	pop	ds
	assume	ds:DSEG		; make DS:DX point to string

	mov	ah, 40h		; AH = write to file
	mov	bx, STDERR	; BX = file handle
	int	21h

	pop	ds
	assume	ds:nothing	; for rest of the functions in file!

	call	print_CR_LF
	ret
print_str_stderr ENDP



;****************************************************************************
;*
;* ROUTINE:	print_char
;*
;* FUNCTION: 	Prints character to stdout. Can be called even from within
;*		the critical error handler.
;*		
;* INPUT:	DL = char to be printed.
;*
;* OUTPUT:	character printed to stdout.
;*
;* REGISTERS:	AX destroyed.
;****************************************************************************

print_char PROC NEAR
	mov	ah, 02h		; AH = print char to stdout
	int	21h
	ret
print_char ENDP



;****************************************************************************
;*
;* ROUTINE:	print_$str
;*
;* FUNCTION: 	Prints a string that is terminated by a '$'. Can be called
;*		even from within the critical error handler.
;*
;* INPUT:	DS:DX = pointer to '$' terminated string 
;*
;* OUTPUT:	string printed out to stdout. '$' is not printed!
;*
;* REGISTERS:	AX destroyed.
;****************************************************************************
	
print_$str PROC NEAR
	mov	ah, 09h
	int	21h
	ret
print_$str ENDP


;****************************************************************************
;*
;* ROUTINE:	print_crit_sep
;*
;* FUNCTION: 	Prints the critical error seperator string i.e., ", "
;*
;* INPUT:	CX = 0 implies don't print seperator, else print the string!
;*		DS = DSEG.
;*
;* OUTPUT:	string printed to stdout if CX not 0.
;*
;* REGISTERS:	AX,DX, destroyed.
;****************************************************************************

; Note that there could be some internationalization problems to the routine
; calling this function!
;
print_crit_sep PROC NEAR

	or	cx, cx		; Has a critical error option been printed?
	jz	PCSRet		; NO! Then don't print seperator!

	; Note that the crit error message should go to stderr
	; and not stdout as done here. But for minicmd.com there is not
	; redirection ('>' operator) hence not an issue!?
	;
	mov	dx, offset DSEG:CRIT_SEP_STR	 ; print string terminated by a '$'
	call	print_$str

PCSRet:
	ret
print_crit_sep ENDP



;****************************************************************************
;*
;* ROUTINE:	print_crit_err_msg
;*
;* FUNCTION: 	Prints out the appropriate critical error message based
;*		on whether it is a block device, character device, etc.
;*		The message is of the following form:
;*		"<CrMsg-N> [READ|WRIT]ING [DRIVE <drive-letter>:|DEVICE <device-name>"
;*		See dataseg.asm for CrMsg0 thru CrMag15!
;*
;* INPUT:	The same input that is passed by DOS on a critical error
;*		except that DS and ES = DSEG, Also in AH bit
;*		6 (ABORT_BIT_MASK) is zero-ed out!
;*		'CritErrAX' has the value of AX (with bit 6 zeroed as
;*		mentioned above) as passed to the Crit Err Handler.
;*
;* OUTPUT:	The appropriate crit error is printed out.
;*
;* REGISTERS:	ALL destroyed, except ES, DS, BP
;****************************************************************************

; Note that error 15 (Invalid disk change is not handled
;   thoroughly -- we don't specify the Vol #, Ser # of disk to put back!
;
; There is potential for sizzling this function.
;
; Note that the crit error message should go to stderr
;   and not stdout as done here! But in our case we assume
;   that both are the same as we don't support re-direction!!
;   Anyway, the necessary code to do this is in command2.asm in COMMAND dir!
;

print_crit_err_msg PROC NEAR

	assume	ds:DSEG, es:DSEG

	test	ah, 80h		; Is it a block device error?
	jz	PCEMBlkDevErr	; Yes!

	push	ds
	mov	ds, bp		; DS:SI now points to device header!
	assume	ds:nothing

	mov	ax, ds:[si+OFFSET_DEV_ATTR] ; get dev attr word in AX
	pop	ds			    ; Bit 15 in this word (Bit 7)	
	assume	ds:DSEG			    ; in the high word if set to 1
	test	ah, 80h			    ; it is a character device
	jz	PCEMFatErr		    ; else it is a FAT image in
					    ; memory corrupted error.

PCEMBlkDevErr:
	mov	bx, di		; BL now has the Driver Error code.

	cmp	bl, MAX_DRIVER_ERR_CODE	; Is error code < max # we can handle?
	jle	PCEMValidCode		; Yes, don't have to ask IFS!

	; The error code is greater than the numbers we can handle 
	; without calling IFS, extended error information, etc. 
	; Change it into a code for the general critical error message.
	; 
	mov	bl, UNKNOWN_MSG_ERR_CODE
					

	; All the CritMsgs are '$" terminated and BL is now a value from
	; 0 thru MAX_DRIVER_ERR_CODE (15 now). Get to message N (in BL)
	; by looking for '$' to find the beginning of the next message!
	;
PCEMValidCode:
	mov	di, offset DSEG:FIRST_CRIT_ERR_MSG

PCEMGetErrMsg:
	or	bl, bl		; Have we got start of message N?
	jz	PCEMGotMsg	; Yes!

	mov	al, '$'		; No, scan for '$', dec BL and check BL again!
	mov	cx, 0FFFFh
	repne	scasb

	dec	bl
	jmp	PCEMGetErrMsg

PCEMGotMsg:
	
	call	print_CR_LF

	mov	dx, di		
	;
	; DS:DX now points to the crit err msg - print it!
	;
	call	print_$str

	mov	dl, SPACE
	call	print_char

	; print the string READING or WRITING now. Bit 8 (or Bit 0 in the
	; high byte) of CritErrAX specifies this.
	;
	mov	dx, offset DSEG:READING_STR		; set DS:DX to READING str!

	test	byte ptr CritErrAX+1, 01h	; Is it a reading op?
	jz	PCEMReadingOp			; Yes!

	mov	dx, offset DSEG:WRITING_STR		; No, set DS:DX to WRITING str!

PCEMReadingOp:
	call	print_$str		; print word READING or WRITING.

	mov	dl, SPACE
	call	print_char

	; So far we have printed "<error msg> <READ|WRIT>ING "
	; Now print the phrase "DRIVE <drive-letter>:" for block device
	; or the phrase	       "DEVICE <device-name> for character device
	; Bit 15 (or bit 7 in high byte) of CritErrAX specifies this.
	;
	mov	dx, offset DSEG:DRIVE_STR	  ; point DS:DX to DRIVE str

	test	byte ptr CritErrAX+1, 80h ; Is it a BLOCK device?
	jz	PCEMDriveStr		  ; Yes.

	mov	dx, offset DSEG:DEVICE_STR	  ; No, point DS:DX to DEVICE str

PCEMDriveStr:
	call	print_$str		; print word DRIVE or DEVICE

	mov	dl, SPACE
	call	print_char

	; So far we have printed "<error msg> <READ|WRIT>ING <DRIVE|DEVICE> "


	; Now print <drive-letter>: for BLOCK devices
	; or	    <device-name> for character devices.
	;
	test	byte ptr CritErrAX+1, 80h ; This is tested too many times!
					  ; scope for optimization.
	jnz	PCEMPrintDeviceName

	mov	dl, byte ptr CritErrAX	; Get the drive letter index. 0 = A,
	add	dl, 'A'			; 1 = B, etc. convert to character
	call	print_char		; and print.

	mov	dl, COLON
	call	print_char
	jmp	short PCEMDone

PCEMPrintDeviceName:
	push	ds
	mov	ds, bp		; DS:SI points to device header
	assume	ds:nothing

	; We know it is a character device. Print device-name by looking at
	; the device header.
	;
	mov	cx, DEV_NAME_LEN
	add	si, OFFSET_DEV_NAME

PCEMDevNameLoop:
	lodsb
	mov	dl, al
	call	print_char

	loop	PCEMDevNameLoop

	pop	ds
	assume	ds:DSEG

	jmp	short PCEMDone

PCEMFatErr:
	; FAT error is a special critical error message -- a very rare
	; occurence!
	;
	mov	dx, offset DSEG:FAT_ERR_MSG
	call	print_$str

PCEMDone:
	call	print_CR_LF
	
	ret

print_crit_err_msg ENDP


;****************************************************************************
;*
;* ROUTINE:	CritErrHandler
;*
;* FUNCTION: 	Prints the appr. critical error message and also prompts
;*		the user for appropriate action (Abort, Retry, Ignore,
;*		Fail options).
;*
;* INPUT:	DS = DSEG and rest of registers as passed in by DOS
;*		when critical error happens. BP:SI, AX, DI have input!
;*
;* OUTPUT:	Handles critical error: Prints out critical error message,
;*		gives user choices, reads in user input, validates it
;*		and passes back appropriate code in AL.
;*
;* REGISTERS:	AX affected! AL has return value to DOS.
;****************************************************************************

CritErrHandler PROC FAR
	assume	ds:DSEG

	push	bx
	push	cx
	push	dx
	push	di
	push	si
	push	ds
	push	es

	push	ds
	pop	es
	assume	es:DSEG

	and	ah, NOT ABORT_BIT_MASK	; set the ABORT_BIT_MASK to zero!
	mov	CritErrAX, AX	; store the AX register, has bit fields
				; that indicate valid options, etc!

	call	print_crit_err_msg

CEHPrintCritErr:
	mov	ah, 51h		; AH = Get PSP.
	int	21h

	; ABORT is not allowed if MyPSP is same as the person who caused
	; the critical error. 
	; Note that we need to do this only if it is the top level process.
	; For simplicity sake, it was not done.

	cmp	bx, MyPSP
	je	@F

	or	byte ptr CritErrAX+1, ABORT_BIT_MASK
@@:

	; Note that there is scope to sizzle following code.

	xor	cx, cx		; CX used as temp var indicating whether
				; we need to print CRIT_SEP_STR or not!

	mov	di, offset DSEG:CritErrInpKeys
	mov	si, offset DSEG:CritErrKeyCodes
	push	di		; save for future scasb!

	; depending on which options are available (Abort, Retry,
	; Ignore and Fail) print the choices to the user in the
	; form of a question.
	;
	test	byte ptr CritErrAX+1, ABORT_BIT_MASK
	jz	CEHNoAbort

	mov	dx, offset DSEG:ABORT_STR
	call	print_$str

	mov	al, ABORT_KEY
	stosb
	mov	al, ABORT_KEY_CODE
	mov	[si], al
	inc	si
	inc	cx

CEHNoABort:
	test	byte ptr CritErrAX+1, RETRY_BIT_MASK
	jz	CEHNoRetry

	call	print_crit_sep

	mov	dx, offset DSEG:RETRY_STR
	call	print_$str

	mov	al, RETRY_KEY
	stosb
	mov	al, RETRY_KEY_CODE
	mov	[si], al
	inc	si
	inc	cx

CEHNoRetry:
	test	byte ptr CritErrAX+1, IGNORE_BIT_MASK
	jz	CEHNoIgnore

	call	print_crit_sep

	mov	dx, offset DSEG:IGNORE_STR
	call	print_$str

	mov	al, IGNORE_KEY
	stosb
	mov	al, IGNORE_KEY_CODE
	mov	[si], al
	inc	si
	inc	cx

CEHNoIgnore:
	test	byte ptr CritErrAX+1, FAIL_BIT_MASK
	jz	CEHNoFail

	call	print_crit_sep

	mov	dx, offset DSEG:FAIL_STR
	call	print_$str

	mov	al, FAIL_KEY
	stosb
	mov	al, FAIL_KEY_CODE
	mov	[si], al
	inc	si
	inc	cx

CEHNoFail:

	; Now print the question marker, as the message has been printed!
	mov	dx, offset DSEG:CRIT_Q_STR
	call	print_$str

	; The critical error message has been completely printed out.
	; Now flush stdin and then read 1 character!
	mov	ax, 0c01h
	int	21h		

	push	ax		; save AL the char user typed in!
	call	print_CR_LF
	pop	ax		; get back AL (user typed in character)

	call	upper_case

	pop	di	; ES:DI now points to first valid crit err char.
			; CX has number of valid user input keys!

	repne	scasb		; check if user entered a valid key

	je	CEHValidCharGot	; Too bad short jmp out of range!
	jmp	CEHPrintCritErr	; prompt again for bad response!

CEHValidCharGot:
	; Set AL = action code for MS-DOS according to key entered:
	; 0 = Ignore, 1 = Retry, 2 = Abort, 3 = Fail
	mov	al, [di+NUM_CRIT_KEYS-1]

CEHPopAndRet:
	pop	es
	pop	ds
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx

	assume	ds:nothing	; For rest of the routines in this file!
	ret			; return to STUB in data seg!
CritErrHandler ENDP



;****************************************************************************
;*
;* ROUTINE:	process_cmd
;*
;* FUNCTION: 	processes commands - both intrinsic and extrinsic
;*
;* INPUT:	DS:SI points to command. There could be leading white
;*		space (TABS, SPACE). The command should be terminated
;*		either by CR or LF.
;*
;* OUTPUT:	processes the command and on completion DS:SI points to
;*		the next command - after the CR or LF!
;*
;* REGISTERS:	ALL destroyed.
;****************************************************************************

process_cmd PROC NEAR

	mov	cx, si			; store for future reference

	call	intrinsic		; check for intrinsic command
	jnc	PCRet			; Yes, handled intrinsic cmd!

	; num_readin is not initialized if we are processing
	; BAT file. Initialize it now as it is referenced later.
	; BTW, if we had read in stdin, we un-necessarily re-compute it
	; here. No big deal as speed is not an issue. It is fast anyway!
	push	si
	mov	bl, CR
	call	scan_for_char
	mov	dx, si
	sub	dx, cx
	dec	dx			; don't include CR in count!
	mov	es:num_readin, dl	; Note that we assume line len < 256!
	pop	si

	; If we are here it was not an intrinsic cmd -- Launch it!!

	call	skip_white_space	; skip leading blanks before command.

	call	is_CR_LF?		; Empty command?
	jne	PCNotEmptyCmd		; No!

	inc	si			; DS:SI points to next cmd (after this CR)!
	clc				; Empty cmd succesfully executed :-)\

PCRet:
	ret

PCNotEmptyCmd:
	mov	dx, si			; DS:DX now points to command name.
					; This is requied by EXEC call below!
	call	get_to_white_space

	push	ax			; save character (SPACE, TAB, CR or LF)
					; for future use.

	mov	bx, si			; store SI for future reference. This
					; is the end of the command string!

	mov	ax, 2901h		; ParseFileName into FCB function
					; skipping leading separators.
	mov	di, offset DSEG:fcb1		; ES:DI = FCB to parse into
					; DS:SI already points to source.
	int	21h

	; Now DS:SI is ready for the next file name to be parsed!
	mov	al, 01			; AH still has 29H!?, AL = 1 implies
					; skip leading seperators.
	mov	di, offset DSEG:fcb2		; ES:DI = FCB to parse into
	int	21h

	sub	cx, bx			; Note that CL is as good as CX now
					; as the value in cx >= -128
	add	cl, es:num_readin
	mov	es:cmd_tail, cl		; init cmd_tail length.
	
	xor	ch, ch
	inc	cx			; to include CR also in count to copy

	mov	si, bx
	mov	di, offset DSEG:cmd_tail + 1
	rep	movsb			; copy cmd_tail from buffer.

	mov	BYTE PTR [bx], 0	; Make cmd string NULL terminated!
					; the character at this pos. is on
					; the stack (when we did the PUSH AX)
	push	bx			; save offset for future!
	push	dx

	call	dword ptr es:[DSExecHandlerAddr] ; launch program in DS:SI

	pop	si			; Get DX into SI, so that DS:SI
					; now has start of cmd!
	pop	bx
	pop	ax	
	mov	BYTE PTR [bx], al	; Put back original character!

	pushf				; Save CARRY flag from EXEC call!

	jc	PCDone

	; Note that our code is quite general and we can now check if it
	; is a BAT file and if so process it here! The only problem is
	; is that we can't process NESTED BAT files!
	;

	; program was succesfully executed and it terminated!
	mov	ah, 4dh
	int	21h			; Get return code of child process.
	mov	byte ptr es:last_pgm_exit_code, al ; store for future use in IF stmts!

PCDone:
	mov	bl, CR
	call	scan_for_char		; make DS:SI just past end of Cmd!

	popf				; Restore CARRY flag for caller!

	; DS:SI set up for next command in buffer!
	ret
process_cmd ENDP



;****************************************************************************
;*
;* ROUTINE:	is_CR_LF?
;*
;* FUNCTION: 	checks to see if the character in AL is a CR or LF
;*
;* INPUT:	AL has character to be tested
;*
;* OUTPUT:	ZERO flag set if char is CR or LF else it is cleared.
;*
;* REGISTERS:	NONE destroyed, FLAGS modified.
;****************************************************************************

is_CR_LF? PROC	NEAR
	cmp	al, CR
	je	ICLEnd
	
	cmp	al, LF
ICLEnd:
	ret	
is_CR_LF? ENDP



;****************************************************************************
;*
;* ROUTINE:	is_SP_TAB?
;*
;* FUNCTION: 	checks to see if the character is a SPACE/TAB (white space)
;*
;* INPUT:	AL has character to be tested
;*
;* OUTPUT:	ZERO flag set if char is SPACE or TAb, else it is cleared.
;*
;* REGISTERS:	NONE destroyed, FLAGS modified.
;****************************************************************************

is_SP_TAB? PROC	NEAR
	cmp	al, SPACE
	je	ISTEnd
	
	cmp	al, TAB
ISTEnd:
	ret	
is_SP_TAB? ENDP



;****************************************************************************
;*
;* ROUTINE:	get_to_white_space
;*
;* FUNCTION: 	Seeks to the first SPACE, TAB, CR or LF in the buffer. If the
;*		first character in the buffer is such a character, the pointer
;*		is not even advanced.
;*
;* INPUT:	DS:SI = buffer that has a line terminated by CR or LF.
;*
;* OUTPUT:	DS:SI points to character in buffer that is 1 of the 4 above.
;*		AL = 1 of the 4 characters mentioned above.
;*
;* REGISTERS:	NONE affected but the result registers.
;****************************************************************************

get_to_white_space PROC NEAR
	lodsb

	call	is_SP_TAB?
	je	gtws_ws_found

	call	is_CR_LF?
	jne	get_to_white_space

gtws_cr_found:
gtws_ws_found:
	dec	si
	ret
get_to_white_space ENDP


;****************************************************************************
;*
;* ROUTINE:	skip_white_space
;*
;* FUNCTION: 	Seeks past SPACE, TAB. If the first character in the 
;*		buffer is such a character, the pointer is not even advanced.
;*
;* INPUT:	DS:SI = buffer that has a line terminated by CR or LF.
;*
;* OUTPUT:	DS:SI points to character in buffer that is not SPACE or TAB.
;*		AL = 1st non-white space character (could be CR or LF also).
;*
;* REGISTERS:	NONE affected but the result registers.
;****************************************************************************

skip_white_space PROC NEAR
	lodsb

	call	is_SP_TAB?
	je	skip_white_space

	dec	si
	ret
skip_white_space	ENDP


;****************************************************************************
;*
;* ROUTINE:	upper_case
;*
;* FUNCTION: 	converts characters in range 'a' thru 'z' to 'A' thru 'Z'
;*
;* INPUT:	AL has character to be upper-cased!
;*
;* OUTPUT:	AL has the upper-cased character if it was 'a' thru 'z' else
;*		it is left un-changed!
;*
;* REGISTERS:	NONE but the result register (AL).
;****************************************************************************

upper_case PROC NEAR
	cmp	al, 'a'
	jb	UCDone
	cmp	al, 'z'
	ja	UCDone
	sub	al, 'a' - 'A'
UCDone:
	ret
upper_case ENDP


	; Note that it might be possible to write a general function
	; to combine the functionality of functions like:
	; print_str_stderr, print_$str, echo_line, etc and save space!

;****************************************************************************
;*
;* ROUTINE:	echo_line
;*
;* FUNCTION: 	prints a string terminated by CR or LF to stdout.
;*
;* INPUT:	DS:SI points to string to be printed.
;*
;* OUTPUT:	string is printed to stdout.
;*		DS:SI points to character right after the first CR, LF in
;*		buffer.
;*
;* REGISTERS:	AX destroyed. SI changed.
;****************************************************************************

echo_line PROC NEAR
	push	dx

echo_loop:
	mov	dl, [si]
	call	print_char
	
	inc	si

	call	is_CR_LF?
	jne	echo_loop

	; Note that CR is echoed as CR-LF, but LF is also echoed as LF-LF!
	; AH is still 02!
	mov	dl, LF
	int	21h

	pop	dx
	ret
echo_line ENDP


;****************************************************************************
;*
;* ROUTINE:	echo_cmd
;*
;* FUNCTION: 	If echo turned ON:
;*		Echoes to stdout the prompt followed by
;*		   command pointed to by DS:SI
;*		It doesn't echo labels or empty commands (commands
;*		   with CR or LF at the beginning).
;*		The commands could have leading white space.
;*		
;*
;* INPUT:	DS:SI points to command to be echo-ed.
;*		ES = DSEG.
;*		is_echo_on? in DSEG specifies whether to echo or not.
;*
;* OUTPUT:	string echo-ed to stdout.
;*
;* REGISTERS:	AX destroyed.
;****************************************************************************

echo_cmd PROC NEAR
	cmp	es:is_echo_on?, 1
	jne	ECRet

	push	si

	call	skip_white_space

	call	is_CR_LF?
	je	ECPopAndRet	; Don't echo empty commands!

	cmp	al, COLON
	je	ECPopAndRet	; Don't echo LABELs

	pop	si
	push	si

	call	print_prompt
	call	echo_line

ECPopAndRet:
	pop	si

ECRet:
	ret
echo_cmd ENDP


;****************************************************************************
;*
;* ROUTINE:	print_prompt
;*
;* FUNCTION: 	If echo turned ON:
;*		Prints the prompt string to stdout (right now, the COLON!)
;*
;* INPUT:	ES = DSEG
;*		is_echo_on? in DSEG specifies whether to echo or not.
;*
;* OUTPUT:	prompt printed to stdout.
;*
;* REGISTERS:	AX destroyed.
;****************************************************************************

print_prompt PROC NEAR
	cmp	es:is_echo_on?, 1
	jne	PPRet
	
	mov	dl, PROMPT_CHAR
	call	print_char

PPRet:
	ret
print_prompt ENDP


;****************************************************************************
;*
;* ROUTINE:	print_CR_LF
;*
;* FUNCTION: 	Prints to stdout CR followed by LF.
;*
;* INPUT:	NONE.
;*
;* OUTPUT:	see functionality.
;*
;* REGISTERS:	AX destroyed.
;****************************************************************************

print_CR_LF PROC NEAR

	push	dx		; save DX

	mov	dl, CR
	call	print_char

	mov	dl, LF
	call	print_char

	pop	dx		; restore DX

	ret

print_CR_LF ENDP


;****************************************************************************
;*
;* ROUTINE:	print_str
;*
;* FUNCTION: 	prints a string to stdout, also echoes a CR-LF after it.
;*
;* INPUT:	ES = DSEG.
;*		ES:DX points to string to be printed.
;*
;* OUTPUT:	see functionality.
;*
;* REGISTERS:	AX, BX destroyed.
;****************************************************************************

print_str PROC NEAR
	push	ds

	push	es
	pop	ds
	assume	ds:DSEG

	mov	bx, STDOUT
	mov	ah, 40h
	int	21h		; print str

	call	print_CR_LF

	pop	ds
	assume	ds:nothing

	ret
print_str ENDP



;****************************************************************************
;*
;* ROUTINE:	scan_for_char
;*
;* FUNCTION: 	scans for a character in a buffer that is terminated by
;*		a CR or LF.
;*
;* INPUT:	DS:SI = pointer to buffer terminated by CR or LF.
;*		BL = character to be scanned for in buffer.
;*
;* OUTPUT:	DS:SI points to the character after the found character.
;*		AL = character that caused termination of the func.
;*		   If (AL != BL) character was not found and DS:SI points
;*		      immediately after the CR or LF at the end of the line.
;*		      In this case AL = CR or LF.
;*
;* REGISTERS:	NONE except the output registers.
;****************************************************************************

scan_for_char PROC NEAR
	lodsb

	call	is_CR_LF?
	je	SFCNotFound

	cmp	al, bl
	jne	scan_for_char

SFCNotFound:
	ret	
scan_for_char ENDP


;****************************************************************************
;*
;* ROUTINE:	strcpy_till
;*
;* FUNCTION: 	copies from source to destination the characters in a buffer
;*		until a certain character is found.
;*
;* INPUT:	DS:SI = source buffer that has the character specified in
;*		        it or is terminated by CR or LF.
;*		BL    = char to copy till (including it too!).
;*		ES:DI = destination buffer.
;*
;* OUTPUT:	DS:SI points to character after the last one copied in source.
;*		ES:DI points to character after the last one copied in dest.
;*
;* REGISTERS:	None but DI and SI.
;****************************************************************************

strcpy_till PROC NEAR
	lodsb
	stosb
	cmp	al, bl
	je	strcpy_done

	call	is_CR_LF?
	jne	strcpy_till

strcpy_done:
	ret
strcpy_till ENDP


;****************************************************************************
;*
;* ROUTINE:	strcpyupper_till
;*
;* FUNCTION: 	Does the same as strcpy_till except that the alphabet ('a'
;*		thru 'z') are upper cased in destination.
;*
;* INPUT:	see fn strcpy_till -- same as that.
;*		
;* OUTPUT:	see functionality.
;*
;* REGISTERS:	None but DI and SI.
;****************************************************************************

strcpyupper_till PROC NEAR
	lodsb
	call	upper_case	
	stosb
	cmp	al, bl
	je	strcpyupper_done

	call	is_CR_LF?
	jne	strcpyupper_till

strcpyupper_done:
	ret
strcpyupper_till ENDP


;****************************************************************************
;*
;* ROUTINE:	atoi
;*
;* FUNCTION: 	converts an un-signed numerical string to a number
;*
;* INPUT:	DS:SI = points to 1st character in un-signed numerical str.
;*		Note that any character other than '0' thru '9' stops the
;*		   processing and value till that point is used.
;*
;* OUTPUT:	DS:SI points to first non numeric character from start.
;*		AX has numerical value of string.
;*
;* REGISTERS:	BX destroyed.
;****************************************************************************

atoi PROC NEAR
	xor	ax, ax
	mov	bh, ah		; same as mov bh, 0 but faster!
	mov	cl, 10

atoiLoop:
	mov	bl, [si]
	sub	bl, '0'

	jb	atoiDone

	cmp	bl, 9
	ja	atoiDone

	mul	cl
	add	ax, bx
	inc	si

	jmp	short atoiLoop

atoiDone:
	ret
atoi ENDP


;****************************************************************************
;*
;* ROUTINE:	check_for_kw
;*
;* FUNCTION: 	checks to see if a certain string is present in a buffer.
;*		It basically does a strncmpi() but if match succesfull the
;*		the next character in buffer should be a SPACE, TAB, CR
;*		or LF as these are the characters that are known to be
;*		delimiters!
;*
;* INPUT:	DS:SI points to location in buffer where the string is
;*		      expected to be present. buffer is expected to
;*		      to be terminated by CR or LF.
;*		ES:DI points to the keyword/string to be searched for.
;*		CX has length of keyword/string.
;*
;* OUTPUT:	If match found, DS:SI points to the next word after this
;*		string, or to CR/LF if no word present after this string.
;*		If match not found, DS:SI is left un-changed.
;*
;*		ZERO flag set is string/kw found, else clear.
;*
;* REGISTERS:	AX, CX, DI destroyed. SI appropriately changed.
;****************************************************************************

check_for_kw PROC NEAR
	push	dx
	push	si

CFKLoop:
	; The following few instr. until jnz CFKLoop is the REPE CMPSB
	; instruction but we need to do a case insensitive compare!
	; Note that both source and dest can be in upper/lower case!
	; especially when called from the goto_proc!
	; Note that we could have a fn that first converts input
	; to upper case and then uses the REPE instr! We can't do an
	; upper case translation in-place in the buffer because the F3
	; key etc won't echo back the same chars to user!

	lodsb
	call	upper_case		; get char from buffer
	mov	dl, al

	mov	al, es:[di]		; get char from keyword/string
	call	upper_case

	cmp	al, dl			; compare the two (case in-sensitive)
	jne	CFKNoMatch		; No match, sorry!

	inc	di
	dec	cx
	or	cx, cx			; have we compared upto strlen?
	jnz	CFKLoop			; No, check next chars

	; The string was found in the buffer, see if the next char is a
	; delimiter -- SPACE, TAB, CR, or LF.
	; This way we are sure that we don't mistake a string like
	; SETTLE in buffer to be the SET keyword!
	;
	lodsb
	call	is_SP_TAB?
	je	CFKMatched

	call	is_CR_LF?
	jne	CFKNoMatch

	dec	si		; bring DS:SI back to point to the CR or LF!

CFKMatched:
	pop	ax		; dummy pop SP <- SP + 2
	call	skip_white_space;point to the next keyword if present or EOL!
	push	si		; for the POP which will be done later anyway!
	xor	ax, ax		; set ZERO flag set to return to caller.

CFKNoMatch:
	pop	si
	pop	dx
	ret			; Note that ZERO flag is passed back correctly.

check_for_kw ENDP



;****************************************************************************
;*
;* ROUTINE:	intrinsic
;*
;* FUNCTION: 	Checks to see if the (DS:SI) buffer contains an intrinsic
;*		command like SET, ECHO, IF, GOTO or label (':') and if so
;*		processes it. Note that there could be leading white space
;*		and that the line is expected to be terminated by a CR or LF.
;*
;* INPUT:	DS:SI = buffer that has a command (possibly intrinsic)
;*
;* OUTPUT:	If it is an intrinsic command it is processed/executed
;*		and DS:SI points after the CR or LF that ends this cmd
;*		and CARRY is clear.
;*
;*		If not intrinsic, DS:SI is left un-changed and CARRY set.
;*
;* REGISTERS:	All except CX, segment registers destroyed.
;****************************************************************************

	; Note that one can use the generalized form of this matcher but that is
	; takes a few bytes more including the data it needs!

intrinsic PROC NEAR
	push	si
	push	cx

	call	skip_white_space	; skip leading white space

	; Is it a LABEL command?
	;
	cmp	byte ptr [si], COLON
	jne	IntrNotLabel

	call	label_proc
	jmp	short IntrSuccess

IntrNotLabel:

	; Is it a SET command?
	;
	mov	di, offset DSEG:SET_STR
	mov	cx, SET_STR_LEN
	call	check_for_kw
	jne	IntrNotSETCmd

	call	set_proc
	jmp	short IntrSuccess

IntrnotSETCmd:
	; Is it an ECHO command?
	;
	mov	di, offset DSEG:ECHO_STR
	mov	cx, ECHO_STR_LEN
	call	check_for_kw
	jne	IntrNotECHOCmd
	
	call	echo_proc
	jmp	short IntrSuccess

IntrNotECHOCmd:
	; Is it an IF command?
	;
	mov	di, offset DSEG:IF_STR
	mov	cx, IF_STR_LEN
	call	check_for_kw
	jne	IntrNotIFCmd
	
	call	if_proc
	jmp	short IntrSuccess

IntrNotIFCmd:
	; Is it a GOTO command?
	;
	mov	di, offset DSEG:GOTO_STR
	mov	cx, GOTO_STR_LEN
	call	check_for_kw
	jne	IntrFailure
	
	call	goto_proc

IntrSuccess:
	clc		; intrinsic cmd processed, clear CARRY for caller.
	pop	cx	
	pop	ax	; clean up stack (get SI into AX), leave SI unchanged!

	; DS:SI should now be pointing correctly past EOL for next cmd!
	ret

IntrFailure:
	stc		; not intrinsic cmd, set CARRY for caller.

IntrPopRegs:
	pop	cx
	pop	si
	ret			
intrinsic ENDP


; Note that in current command.com type ECHO.BAT and have a batch file
; by the name ECHO.BAT, it doen't launch the BAT file!!!

; Note that this fn does not print the white space between ECHO and the string
; as that is not passed in! It has already been stripped! Is this a problem?
;

;****************************************************************************
;*
;* ROUTINE:	echo_proc
;*
;* FUNCTION: 	This routine handles the "ECHO" intrinsic cmd. It handles
;*		ECHO [ON | OFF] and ECHO <string>. It checks if echo-ing
;*		is turned on or not before printing the string to stdout.
;*
;* INPUT:	DS:SI points to the string to be echo-ed or to the keywords
;*		    ON or OFF (there is no leading white space).
;*		The line is expected to be terminated by a CR or LF
;*
;* OUTPUT:	see functionality. DS:SI points after the CR or LF at end.
;*
;* REGISTERS:	ALL general purpose registers destroyed.
;****************************************************************************

echo_proc PROC NEAR

	; DS:SI points to the string to be echo-ed!
	push	si		; Save in case we need to backtrack
				; example: "ECHO ON schedule" should print
				; out "ON schedule" and not turn echo-ing ON!!

	mov	di, offset DSEG:ON_STR
	mov	cx, ON_STR_LEN
	call	check_for_kw
	je	EPONFound

	mov	di, offset DSEG:OFF_STR
	mov	cx, OFF_STR_LEN
	call	check_for_kw
	jne	EPCheckForPlainECHO

	xor	ah, ah			; ECHO OFF value!

	; Note that check_for_kw has already skipped the white space after
	; the OFF keyword!

EPCheckForBackTrack:
	mov	al, [si]
	call	is_CR_LF?
	jne	EPEchoStr

	mov	es:is_echo_on?, ah	; mark echo turned OFF!

EPPopAndRet:
	inc	si			; skip past the EOL char!
	pop	ax			; get rid of SI from stack!
	ret

EPONfound:
	; Note that check_for_kw has already skipped the white space after
	; the ON keyword!
	mov	ah, 1			; ECHO ON value!
	jmp	short	EPCheckForBackTrack

EPCheckForPlainECHO:
	mov	al, [si]
	call	is_CR_LF?
	jne	EPEchoStr

	cmp	es:is_echo_on?, 1
	jne	EPPrintEchoIsOff

	mov	dx, offset DSEG:ECHOISON_STR
	mov	cx, ECHOISON_STR_LEN

EPPrintStr:
	; print ECHO is on/off.
	;
	call	print_str
	jmp	short EPPopAndRet

EPPrintEchoIsOff:
	mov	dx, offset DSEG:ECHOISOFF_STR
	mov	cx, ECHOISOFF_STR_LEN

	jmp	short EPPrintStr
	
EPEchoStr:
	pop	si
	call	echo_line

	; NOTE: DS:SI now points just after the CR or LF in buffer!
	ret

echo_proc ENDP



;****************************************************************************
;*
;* ROUTINE:	get_env
;*
;* FUNCTION: 	Checks to see if a certain NAME has a value associated
;*		with it in the environment. It does a case insensitive
;*		check knowing that the ENV has NAMEs stored in upper case!
;*
;* INPUT:	ES:0  = pointer to environment we created.
;*		DS:SI = pointer to NULL terminated string NAME=
;*
;* OUTPUT:	CARRY clear, if variable found and ES:DI points to the 
;*		    start of it (NAME) in the ENV, i.e, to NAME=STRING
;*		CARRY set, if variable not found and ES:DI points to end of
;*		    ENV (the very last 0 byte).
;*
;* REGISTERS:	AX destroyed.
;****************************************************************************

get_env PROC NEAR
	assume	es:nothing

	push	cx
	push	bx

	xor	di, di			; initialize ENV offset.

GEMainLoop:
	mov	bx, si
	mov	cx, di			; store DI in CX for returning if
					; match found. ES:DI now points to
					; NAME=STRING in ENV!

	cmp	byte ptr es:[di], 0	; end of environment?
	je	GENotInENV

GEMatchName:
	mov	al, [bx]
	or	al, al			; end of NAME?
	jz	GEMatchFound

	call	upper_case		; it is stored in ENV in upper case!
	cmp	al, es:[di]		; compare to environment char
	jne	GEMatchFailed

	inc	bx
	inc	di
	jmp	short GEMatchName

GEMatchFound:
	mov	di, cx
	pop	bx
	pop	cx
	ret				; Note that CARRY is clear now!

GEMatchFailed:
	xor	al, al			; scan forward in ENV
	mov	cx, -1			; for 0 byte
	repnz	scasb

	jmp	short GEMainLoop

GENotInENV:
	pop	bx
	pop	cx
	stc				; NAME not in ENV -- set CARRY!
	ret

get_env ENDP



;****************************************************************************
;*
;* ROUTINE:	set_proc
;*
;* FUNCTION: 	This routine handles the "SET" intrinsic command. It handles
;*		the plain vanilla command "set NAME=STRING". It does not
;*		do any de-referencing like %NAME%, etc!
;*
;* INPUT:	DS:SI = pointer to the beginning of NAME in the line
;*						set NAME=STRING
;*			i.e., DS:SI now points to   ^
;*		The line is expected to be terminated by a CR or LF
;*
;* OUTPUT:	see functionality. DS:SI points after the CR or LF at end.
;*
;* REGISTERS:	AX, BX, DI destroyed.
;****************************************************************************

set_proc PROC NEAR

	assume	es:DSEG
	push	es	; ES is DSEG, save it so that we can restore on exit!
	mov	es, es:env_seg
	assume	es:nothing

	push	si		
	mov	bl, EQUALS
	call	scan_for_char	; look for '=' in this buffer (DS:SI)
				; user input:		set NAME=STRING
	mov	bx, si		; DS:BX now points to		 ^

	call	is_CR_LF?	; did we not find an EQUALS sign?
	je	SPNoEquals	; Yes, no '=' sign in user input!

	pop	si		; DS:SI is back where it was (beginning)!

	mov	cl, [bx]	; store the character after the '=' sign!
	mov	byte ptr [bx], 0; and replace it with a NULL character.

	call	get_env
	mov	byte ptr [bx], cl; put back the character in buffer!

	jnc	SPFoundEnvString ; the variable NAME has a value already set!

SPCopyThisStringToEnv:
	mov	al, cl
	call	is_CR_LF?	; Is the value for variable (STRING) empty?
				; i.e., is it CR? CL has char after the '='
	je	SPDontAddStr	; Yes, don't have to add it after all!

	; ES:DI is now at the end of ENV -- the 0 terminating byte!

	; Note that we currently do not check to see if we overflow
	; the statically allocated ENV buffer. It may be done here!
	mov	bl, EQUALS
	call	strcpyupper_till

	; copy till EOL (CR or LF)!
	mov	bl, CR
	call	strcpy_till
	dec	di		; make ES:DI point to the CR character
	xor	al, al		; Replace this CR with NULL!
	stosb

SPDone:
	mov	byte ptr es:[di], 0 ; put in ENV terminating NULL byte!

	cmp	byte ptr es:[0], 0  ; M002 Is it an empty environment?
	jne	SPPopAndRet	    ; M002 No, we already have a WORD 0 at end!

	mov	byte ptr es:[1], 0  ; M002 Add an extra 0 -- so that we have a
				    ; M002 WORD 0 -- This is done to be compatible
				    ; M002 with command.com!!! I don't like it as
				    ; M002 it is not elegant/appealing to me!

SPPopAndRet:
	pop	es
	assume es:DSEG

	; NOTE: DS:SI now points just after the CR or LF in buffer!
	ret

SPDontAddStr:
	; Need to leave SI just past the CR or LF at end of this line!
	mov	al, CR
	call	scan_for_char
	jmp	short SPDone

SPFoundEnvString:
	push	ds
	push	si	; DS:SI points to the beginning of NAME=STRING

	push	es
	pop	ds	; DS = ES = env_seg
	
	push	di
	pop	si	; DS:SI now points to the NAME=STRING in the ENV!
	
	mov	bl, 0
	call	scan_for_char	; look for the null terminator of this string

SPScootEnvLeft:
	cmp	byte ptr ds:[si], 0
	je	SPEnvEndFound

				; Note that BL = 0 for fn strcpy_till below to
	call	strcpy_till	; to do a "normal" strcpy!
	jmp	short SPScootEnvLeft

SPEnvEndFound:
	pop	si
	pop	ds
	jmp	short SPCopyThisStringToEnv

SPNoEquals:
	pop	ax	; Get rid of the SI on stack!
	pop	es
	assume	es:DSEG

	; NOTE: DS:SI now points just after the CR or LF in buffer!
	ret

set_proc ENDP


;****************************************************************************
;*
;* ROUTINE:	if_proc
;*
;* FUNCTION: 	This routine handles the "IF" intrinsic command. It handles
;*		the following commands:
;*              IF [NOT] [EXIST|ERRORLEVEL] ...
;*
;* INPUT:	DS:SI = pointer to the beginning of the word after the 'IF'
;*			keyword.
;*						if  ERRORLEVEL 3 ...
;*			i.e., DS:SI now points to   ^
;*		The line is expected to be terminated by a CR or LF.
;*
;*		Note that this function recurses -- we could have IFs
;*		within IFs!
;*
;* OUTPUT:	see functionality. DS:SI points after the CR or LF at end.
;*
;* REGISTERS:	ALL destroyed.
;****************************************************************************

if_proc PROC NEAR

	; Note that we can allow this command even in normal interactive mode!
	; The code is set up to handle it anyway!

	mov	es:kw_NOT_present, 0

	mov	di, offset DSEG:NOT_STR
	mov	cx, NOT_STR_LEN
	call	check_for_kw		; Do we have the NOT keyword?
	jne	IPNoNOTKeyword		; No!

	mov	es:kw_NOT_present, 1

IPNoNOTkeyword:
	mov	di,offset DSEG:ERRLVL_STR
	mov	cx, ERRLVL_STR_LEN
	call	check_for_kw		; Do we have ERRORLEVEL keyword?
	je	IPYupERRLVLFound	; Yes!

	mov	di, offset DSEG:EXIST_STR
	mov	cx, EXIST_STR_LEN
	call	check_for_kw		; Do we have EXIST keyword?
	jne	IPErrorIncorrectSyntax	; No, implies incorrect syntax

	;; If we are here it means we have syntax: IF [NOT] EXIST ...

	; Set up the DTA.
	;
	mov	ah, 1ah
	push	ds
	push	es
	pop	ds		; DS=ES=DSEG for the DTA!
	mov	dx, offset DSEG:DTA_Buffer
	int	21h		; Set DTA!
	pop	ds

	mov	dx, si		; DS:DX now points to first char of filename
	call	get_to_white_space
	push	ax		; AL has the character terminating filename!
				; save it for future use!
	mov	byte ptr [si], 0; NULL terminate filename!

	; Do the Find First.
	mov	ah, 4eh
	xor	cx, cx		; CX = attribs - find just normal files!
				; DS:DX already set up to point to filename.
	int	21h
	pop	ax		; get back AL -- char that was replaced by NULL!
	mov	[si], al	; and put it back in buffer!
	jc	IPExprIsFALSE
	jmp	short IPExprIsTRUE

IPYupERRLVLFound:
	;; If we are here it means we have syntax: IF [NOT] ERRORLEVEL ...
	call	atoi

	push	ax			; store the ATOI value!
	call	get_to_white_space
	call	skip_white_space	; DS:SI points to THEN command now!
	pop	ax			; get the ATOI value.

	cmp	ax, es:last_pgm_exit_code
	jbe	IPExprIsTRUE

IPExprIsFALSE:
	cmp	es:kw_NOT_present, 0
	je	IPDontExecThenCommand

IPExecThenCommand:
	
	; Note that even if I did not make this indirect recursive
	; call, everything will work fine -- the looping pump in batch
	; file processing or the main_loop would have handled it. But, then
	; echo-ing the command would be a problem as we would see the
	; THEN part of the command as another command to be echo-ed!
	call	process_cmd

	ret

IPExprIsTRUE:
	cmp	es:kw_NOT_present, 0
	je	IPExecThenCommand

IPDontExecThenCommand:
IPErrorIncorrectSyntax:
	mov	bl, CR
	call	scan_for_char

	; DS:SI now points past the cmd that forms the THEN part!
	ret

if_proc ENDP


; Note that no error is given out if user does this in non-BAT file
; processing mode! This is the way he can type stuff equivalent to the
; REM cmd!

;****************************************************************************
;*
;* ROUTINE:	label_proc
;*
;* FUNCTION: 	This routine handles the ":" intrinsic command. All it does
;*		is ignore this line. Note that the GOTO command is when we
;*		re-scan the buffer for this label!
;*
;* INPUT:	DS:SI = pointer to the ':' in the line that is expected
;*			to end in a CR or LF.
;*
;* OUTPUT:	see functionality. DS:SI points after the CR or LF at end.
;*
;* REGISTERS:	AX, BX destroyed.
;****************************************************************************

label_proc PROC NEAR

	; Note that we could just jump to appr label in prev function and
	; save a few bytes!
	mov	bl, CR
	call	scan_for_char
	
	; DS:SI points just after the CR or LF ready for next command!
	ret
label_proc ENDP



;****************************************************************************
;*
;* ROUTINE:	goto_proc
;*
;* FUNCTION: 	This routine handles the "GOTO" intrinsic command.
;*
;* INPUT:	DS:SI = pointer to the label in the GOTO cmd.
;*						goto label-name
;*			i.e., DS:SI now points to    ^
;*
;*		The variable 'in_bat_file' in DSEG specifies whether we
;*		   we are processing the INIT BAT file. If we are processing
;*		   the BAT file, DS:0 is where the BAT file has been loaded
;*                 in memory.
;*
;*		The line is expected to be terminated by a CR or LF.
;*
;* OUTPUT:	see functionality. DS:SI points after the CR or LF in the
;*		   line that has the label-name, so that execution can proceed
;*		   from there. If we are not processing the INIT BAT file and
;*		   say the user typed it in from the command line, DS:SI
;*		   points after the CR or LF in this line. If the label is
;*                 not found in the buffer DS:SI points past the end of the
;*		   buffer that stores the INIT file.
;*
;* REGISTERS:	ALL destroyed, including BP.
;****************************************************************************

goto_proc PROC NEAR

	cmp	es:in_bat_file, 1	; Are we processing BAT file?
	jne	GPNotInBatFile		; No, in that case do nothing!

	; DS:SI now points to the label-name in the GOTO cmd!

	mov	bp, es:fsize	; store file size, later on we screw up
				; ES also and so we won't have DSEG in it!
	mov	cx, si		; store for future use

	call	get_to_white_space

	xchg	cx, si	; Si is now back to start of LABEL!
	sub	cx, si	; CX has length of the label in the GOTO cmd!
	or	cx, cx
	jz	GPNoLabel

	push	es	; save ES = DSEG, will be restored at RET time!

	push	ds
	pop	es
	assume es:nothing
	mov	di, si	; ES:DI (same as DS:SI) points to label in GOTO cmd!

	xor	si, si	; DS:0 is where the BAT file has been loaded in mem.

GPLoop:
	call	skip_white_space
	cmp	al, COLON
	je	GPColonFound

GPSkipPastEOL:
	mov	bl, CR
	call	scan_for_char
	cmp	si, bp		; compare with file size!
	jb	GPLoop

	; If we are here, we have traversed thru whole file but not seen the
	; label!
	pop	es
	assume es:DSEG

GPNoLabel:

	mov	dx, offset DSEG:NO_LABEL_MSG
	mov	cx, NO_LABEL_MSG_LEN
	call	print_str_stderr

	mov	si, bp	; Set SI to the size of the Init file! This would
			; mean that the processing of the file is over!
	ret

GPColonFound:
	inc	si	; get past the COLON
	call	skip_white_space; There could be white space between 
				;the COLON and the label
	; ES:DI has the label after the GOTO cmd and CX has the label length!
	call	check_for_kw
	jne	GPSkipPastEOL
	
	pop	es
	assume	es:DSEG

GPNotInBatFile:
	mov	bl, CR
	call	scan_for_char
	; DS:SI points to command after the label -- we have done the GOTO!
	
	ret

goto_proc ENDP


last_code	EQU	$

CSEG	ENDS


	end	start

;;; ******************* Cool generalized function...
IF 0
;  INTRINSIC : FUNCTION
;	INPUT: 	DS:SI buffer that has input from user terminated by CR or LF
;	OUTPUT:	CARRY flag set if it is not an intrinsic command.
;		else, command is carried out and CARRY clear.
;	Destroys: AX, BX, DI
intrinsic PROC NEAR
	push	si
	push	cx		; used as temp space to save and restore SI

	call	skip_white_space

	cmp	byte ptr [si], COLON

	;; BUG BUG Actually label_proc needs to be called!
	je	IntrSuccess

	mov	cx, si		; save for future use
	mov	di, offset DSEG:Intr_Cmds	; DS:DI points to intrinsic cmd table!

IntrMainLoop:
	mov	si, cx		; resore DS:SI to point to user cmd.

	cmp	byte ptr[di], 0	; Are we at end of Intrinsic Cmd table?
	je	IntrNotIntrCmd

IntrNextTableCharLoop:	
	mov	bl, [di]	; Load next char from table.	
	or	bl, bl
	jz	IntrFullMatchFound

	mov	al, [si]
	call	upper_case

	cmp	al, bl
	jnz	IntrMisMatch

	inc	si
	inc	di
	jmp	short IntrNextTableCharLoop

IntrFullMatchFound:
	; Make sure user's entry has same length of characters in cmd!
	mov	al, [si]

	call	is_SP_TAB?
	je	IntrExecuteCmd

	call	is_CR_LF?
	jne	IntrMisMatch

IntrExecuteCmd:
	call	skip_white_space
	call	word ptr ds:[di+1]

IntrSuccess:
	clc
	jmp	short IntrPopRegs

IntrMisMatch:
	mov	al, [di]
	inc	di
	or	al, al
	jnz	IntrMisMatch

	add	di, 2
	jmp	short IntrMainLoop

IntrNotIntrCmd:
	stc

IntrPopRegs:
	pop	cx
	pop	si
	ret
intrinsic ENDP

;;;; *************** Used to be part of INITIALIZED DATA!
Intr_Cmds	EQU	$

		db	'SET',0
set_proc_off	dw	offset CSEG:set_proc

		db	'ECHO',0
echo_proc_off	dw	offset CSEG:echo_proc

		db	'IF',0
if_proc_off	dw	offset CSEG:if_proc

		db	'GOTO',0
goto_proc_off	dw	offset CSEG:goto_proc
		
		db	0		; End of Intrinsic Command marker!

ENDIF

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\minicmd\dataseg.inc ===
;
; M003 -- created this file -- moved strings here from dataseg.asm
;
; This file contains all the strings that need to be translated by
; internationalization folks. Leave the lines which have an EQU alone!
; Just work on the strings that are in single quotes.
;
;

; The following message is printed out when our exec fails. That is when
; minicmd determines that it is not an intrinsic command, it tries
; to launch it as an extrinsic one. Most likely cause is that the user
; did not specify a valid FULL path name!
;
LOAD_MSG	db	'Cannot load program'
LOAD_MSG_LEN	EQU	$ - LOAD_MSG


; The following message is printed out when there is a "goto" command in
; the initialization batch file but the label is not to be found.
;
NO_LABEL_MSG	db	'Cannot find label'
NO_LABEL_MSG_LEN EQU	$ - NO_LABEL_MSG


INIT_BAT_NAME	db	'\ROMINIT.BAT', 0	; INITIALIZATION file name!

;
; Following are the KEYWORDS used in the INTRINSIC commands!
;
SET_STR		db	'SET'
SET_STR_LEN	EQU	$ - SET_STR

ECHO_STR	db	'ECHO'
ECHO_STR_LEN	EQU	$ - ECHO_STR

IF_STR		db	'IF'
IF_STR_LEN	EQU	$ - IF_STR

GOTO_STR	db	'GOTO'
GOTO_STR_LEN	EQU	$ - GOTO_STR

NOT_STR		db	'NOT'
NOT_STR_LEN	EQU	$ - NOT_STR

ERRLVL_STR	db	'ERRORLEVEL'
ERRLVL_STR_LEN	EQU	$ - ERRLVL_STR

EXIST_STR	db	'EXIST'
EXIST_STR_LEN	EQU	$ - EXIST_STR

ON_STR		db	'ON'
ON_STR_LEN	EQU	$ - ON_STR

OFF_STR		db	'OFF'
OFF_STR_LEN	EQU	$ - OFF_STR

;
; Message strings printed out when user types ECHO\r to figure out whether
; ECHO is ON or OFF.
;
ECHOISON_STR	db	'ECHO is on'
ECHOISON_STR_LEN EQU	$ - ECHOISON_STR

ECHOISOFF_STR	db	'ECHO is off'
ECHOISOFF_STR_LEN EQU	$ - ECHOISOFF_STR

;
; These are the strings used to create the Critical Error Query of the form:
; "Abort, Retry, Fail?"
; Note that these should be terminated by a '$'!
;
ABORT_STR	db	'Abort',  '$'
RETRY_STR	db	'Retry',  '$'
IGNORE_STR	db	'Ignore', '$'
FAIL_STR	db	'Fail',   '$'
CRIT_SEP_STR	db	', ',     '$'
CRIT_Q_STR	db	'?',      '$'

; Note that these have to be terminated by '$' as I use fn 09 and also
; scan for the '$' to find the start of the next message!
;
; The various critical errror messages. Note that they are terminated by
; '$' This is used to signify the end of 1 message and the start of
; the next. Luckily, the error codes are contiguous and except for
; 13 and 14 all have valid specific messages. To save code/data size
; I decided to have the code scan for the Nth message (for error code N)
; and print it out rather than having a table of offsets to the strings!
;
; A critical error displayed is of the form:
;
; <CrMsg-N> [READ|WRIT]ING [DRIVE <drive-letter>:| DEVICE <dev-name>]
;
; or it is the FAT_ERR_MSG
;
UNKNOWN_MSG_ERR_CODE	EQU	13 ; This is the general crit. err. msg!
MAX_DRIVER_ERR_CODE	EQU	15
FIRST_CRIT_ERR_MSG	LABEL	BYTE
CrMsg0		db	'Write protect error', '$'
CrMsg1		db	'Invalid unit', '$'
CrMsg2		db	'Not ready', '$'
CrMsg3		db	'Invalid device request', '$'
CrMsg4		db	'Data error', '$'
CrMsg5		db	'Invalid device request parameters', '$'
CrMsg6		db	'Seek error', '$'
CrMsg7		db	'Invalid media type', '$'
CrMsg8		db	'Sector not found', '$'
CrMsg9		db	'Printer out of paper error', '$'
CrMsg10		db	'Write fault error', '$'
CrMsg11		db	'Read fault error', '$'
CrMsg12		db	'General failure', '$'
CrMsg13		db	'Critical error occured', '$' ; un-assigned error 
CrMsg14		db	'Critical error occured', '$' ; numbers.
CrMsg15		db	'Invalid disk change', '$'

READING_STR	db	'reading', '$'
WRITING_STR	db	'writing', '$'
DRIVE_STR	db	'drive', '$'
DEVICE_STR	db	'device', '$'

; This is a special critical error message!
FAT_ERR_MSG	db	'FAT image in memory corrupted', '$'


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\minicmd\dataseg.asm ===
; ************************************************************************
;
; This file contains the data segment used by MINICMD.COM. This has both
; the initialized and un-initialized data. Note that all the INITIALIZED
; DATA is placed at the very beginning of this segment and the un-initialized
; stuff follows it. This is because when we put it in ROM, we have the
; code put in first (CSEG) followed by the data (DSEG). We need to only
; store in ROM the code and initialized data. Thus if the un-initialized
; data follows these, there is no problem in throwing it out.
;
;
; Note that this segment also contains some CODE!!! This is because
; we don't have access to our data segment (DSEG) in a few cases and
; by putting code in the data segment, when we get control here, we
; know that our CS can be used as the DSEG! After getting the value
; of DSEG, we pass control to our code in CSEG!
;
; The two cases when this happens is in the Critical Error Handler and
; in EXEC. Obviously, in the former case, when we get control we can't
; assume anything about ES, DS, etc. In the latter case, it was noticed
; that DS, ES, SS, etc were getting trashed after the EXEC call
; int 21h, fn 4Bh in certain cases (like if a critical error happened
; during EXEC, etc).
;
; ************************************************************************
;
;			Revision History
;			-----------------
;
; M003	SHK	moved strings out to dataseg.inc to help international.
;
; M005	SHK	Added an STI instruction at the	beginning of Crit. Err. 
;		Handler.
;
;

DSEG GROUP INITIALIZED_DATASEG, UN_INITIALIZED_DATASEG

INITIALIZED_DATASEG SEGMENT PARA PUBLIC 'DATA'

begin_initialized_data	EQU	$

; Since we are a COM program, we are allocated all of the memory.
; One of the first things we do is re-size! When we do that
; in the RAM version, we free up everything after our code and allocate
; a new block of memory for DSEG and then copy the data after the CODE into
; that block. When we do this re-sizing, the first 16 bytes of the INITIALIZED
; data will be modified (ARENA header) and so we have some dummy data sitting
; there! Anyway, this is no nig deal as the RAM version is just used for
; debugging purposes! In the ROM version we don't have any such problem,
; we don't dynamically allocate memory for DATA, STACK, ENV. We just take
; up whatever memory we need after the PSP before the re-sizing!
;
IFDEF	RAM_VERSION
dummy_arena_head	db	16 DUP (?)
ENDIF

; M003 moved this block (these 2 strings) a little later and put it 
;      in file dataseg.inc to help internationalization.
;
IF 0

LOAD_MSG	db	'Cannot load program'
LOAD_MSG_LEN	EQU	$ - LOAD_MSG

NO_LABEL_MSG	db	'Cannot find label'
NO_LABEL_MSG_LEN EQU	$ - NO_LABEL_MSG

ENDIF

;****************************************************************************
;*
;* ROUTINE:	CritErrStub
;*
;* FUNCTION: 	This is the entry point for DOS to pass control to when a 
;*		critical error happens (INT 24h). The main handler is 
;*		CritErrHandler in CSEG! Look at that function.
;*
;* INPUT:	The way DOS sets up the registers for INT 24!
;*		These valuse are in AX, BP:SI, DI
;*
;* OUTPUT:	Action code in AL (to signify ABORT, RETRY, IGNORE, or FAIL)
;*
;* RESISTERS:	No registers destroyed.
;****************************************************************************

CritErrorStub PROC FAR

	assume	ds:nothing

	sti			; M005 enable interrupts.

	push	ds

	push	cs
	pop	ds
	assume	ds:DSEG

	call	dword ptr [CSCritErrHandlerAddr]

	pop	ds

	assume	ds:nothing
	iret
CritErrorStub ENDP


;****************************************************************************
;*
;* ROUTINE:	DSExecHandler
;*
;* FUNCTION: 	This is the routine that does the EXEC by calling DOS.
;*
;* INPUT:    DS:DX = Null terminated program name to be launched. This
;*		routine does not search the PATH. So, you need to specify
;*		a full path name or it should be in the CWD!
;*	     ES:BX = Pointer to the environment block	
;*
;* OUTPUT:	CY set if error in launch, else clear!
;*
;* RESISTERS:	Saves DS, Sets up ES to DSEG, SS, SP restored.
;*		The rest of the registers could be destroyed by the EXEC!
;****************************************************************************

DSExecHandler PROC FAR
	assume	es:DSEG, cs:DSEG

	; DS could be destroyed by EXEC in some cases -- see below!
	push	ds

	mov	es:stack_seg, ss
	mov	es:stack_off, sp

	; int 21, EXEC call below does not seem to save and
	; restore registers!! Especially when there is a critical error
	; during EXEC etc, SS, SP are screwed up!!! harishn & mohans have
	; seen this bizarre behaviour!

	mov	bx, offset DSEG:par_blk	; ES:BX pointer to parameter block

	; folowing EXEC call screws up DX and BX on exit!!!!!
	; DOC is incorrect!!!
	;
	mov	ax, 4b00h
	int	21h

	; ES, DS, etc seem to be destroyed if crit. error happens
	; on an EXEC!
	assume	es:nothing

	cli
	mov	ss, cs:stack_seg
	mov	sp, cs:stack_off
	sti

	pop	ds

	push	cs
	pop	es
	assume	es:DSEG

   	ret
DSExecHandler ENDP


	; M003 -- moved strings to dataseg.inc
	; Include all the strings/messages used in program.
	; They are in a separate file so that international finds it easier
	; to localize it that way. If they don't see more than the
	; bare minimum they are happy
	;
	INCLUDE dataseg.inc

end_initialized_data	EQU	$

INITIALIZED_DATASEG ENDS

;;;; **** END OF INITIALIZED DATA -- to be part of ROM Image ****


;;;; **** BEG OF UN_INITIALIZED DATA ****
UN_INITIALIZED_DATASEG SEGMENT BYTE PUBLIC 'DATA'

begin_un_initialized_data	EQU	$

pgm_blk		db	?		; MAX_INP_LENGTH will be filled in
					; here at run-time.
num_readin	db	?		; actual length of input
pgm_name	db	MAX_INP_LENGTH dup (?)	; actual input placed here

par_blk		label 	WORD
env_seg		dw	?		; will be filled in at init time

		dw	?		; cmd_tail's offset/segment filled in
cmd_seg		dw	?		; at init time!

		dw	?		; fcb1's offset/segment filled in
fcb1_seg	dw	?		; at init time!

		dw	?		; fcb2's offset/segment filled in
fcb2_seg	dw	?		; at init time!

cmd_tail	db	128 dup ( ? )	; 1st byte will have count!
fcb1		db	?
		db	11 dup ( ? )
		db	25 dup ( ? )
fcb2		db	?
		db	11 dup ( ? )
		db	25 dup ( ? )

DTA_Buffer	db	43 dup ( ? )

last_pgm_exit_code	dw	?
kw_NOT_present		db	?
is_echo_on?		db	?

in_bat_file		db	?
fhandle		dw	?
fsize		dw	?

stack_seg	dw	?
stack_off	dw	?

MyPSP		dw	?
CritErrAX	dw	?


CritErrInpKeys		db	4 DUP ( ? )
NUM_CRIT_KEYS		EQU	$ - CritErrInpKeys

; Note that the storage for CritErrKeyCodes is assumed to be right after 
; CritErrInpKeys in fn CritErrHandler!

CritErrKeyCodes	db	4 DUP ( ? )

CSCritErrHandlerAddr	dd	?
DSExecHandlerAddr	dd	?

end_un_initialized_data	EQU	$

UN_INITIALIZED_DATASEG ENDS



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\tspc.asm ===
page ,132
;	SCCSID = @(#)tspc.asm	4.1 85/09/22
;	SCCSID = @(#)tspc.asm	4.1 85/09/22
TITLE	COMMAND Transient Uninitialized DATA
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

comment %

The TRANSPACE segment contains variable data that is considered
volatile between command cycles, and therefore is not included in the
transient checksum area.  Contents of these variables MUST be
initialized before use, and must not be relied upon from command
cycle to command cycle.

No constant data values should be stored here.

%
        



.xlist
.xcref
	include version.inc
	include comsw.asm
	include dossym.inc
	include find.inc
	include intnat.inc
	include comequ.asm
	include comseg.asm
ifdef DBLSPACE_HOOKS
	include magicdrv.inc
endif
.list
.cref

; Uninitialized transient data
TRANSPACE	SEGMENT PUBLIC BYTE

	PUBLIC	ALLSWITCH
	PUBLIC	append_exec		;AN041;
	PUBLIC	arg
	PUBLIC	argbufptr
	PUBLIC	ARGC
	PUBLIC	ARG1S
	PUBLIC	ARG2S
	PUBLIC	ARGTS
	PUBLIC	arg_buf
	PUBLIC	ASCII
        PUBLIC  AttrSelect
        PUBLIC  AttrSpecified
	PUBLIC	BatBuf
	PUBLIC	BatBufEnd
	PUBLIC	BatBufPos
	PUBLIC	BATHAND
	PUBLIC	BINARY
	PUBLIC	BITS
	PUBLIC	BWDBUF
	PUBLIC	BYTCNT
	PUBLIC	bytes_free
	PUBLIC	CFLAG
	PUBLIC	CHARBUF
	PUBLIC	CHKDRV
	PUBLIC	COM
	PUBLIC	COMBUF
	PUBLIC	comma
	PUBLIC	comptr
	PUBLIC	COMSW
	PUBLIC	CONCAT
	PUBLIC	copy_Num
	PUBLIC	CountryPtrInfo
	PUBLIC	CountryPtrId
	PUBLIC	CountryPtr
	PUBLIC	CPDATE
	PUBLIC	CPTIME
	PUBLIC	cpyflag
	PUBLIC	CURDRV
	PUBLIC	DATE_DAY		;AN000;
	PUBLIC	DATE_MONTH		;AN000;
	PUBLIC	DATE_OUTPUT		;AN000;
	PUBLIC	DATE_TYPE		;AN000;
	PUBLIC	DATE_YEAR		;AN000;
	PUBLIC	DEST
	PUBLIC	DESTBUF
	PUBLIC	DestClosed
	PUBLIC	DESTDIR
	PUBLIC	DESTFCB
	PUBLIC	DESTFCB2
	PUBLIC	DESTHAND
	PUBLIC	DESTINFO
	PUBLIC	DESTISDEV
	PUBLIC	DESTISDIR
	PUBLIC	DESTNAME
	PUBLIC	DESTSIZ
	PUBLIC	DESTSWITCH
	PUBLIC	DESTTAIL
	PUBLIC	DESTVARS
	PUBLIC	DIRBUF
	PUBLIC	DIRCHAR
	PUBLIC	dirflag 		;AN015;
	PUBLIC	Dir_Num
ifdef DBLSPACE_HOOKS
	PUBLIC	Dir_CRatio_1
	PUBLIC	Dir_CRatio_2
endif
	PUBLIC	display_ioctl		;AN000;
	PUBLIC	display_mode		;AN000;
	PUBLIC	display_width		;AN000;
	PUBLIC	DRIVE_NUMBER		;AN000;
	PUBLIC	DRIVE_OUTPUT		;AN000;
	PUBLIC	DRIVE_TYPE		;AN000;
	PUBLIC	DRIVE_VALUE		;AN000;
	PUBLIC	ELCNT
	PUBLIC	ELPOS
	PUBLIC	ENDDESTBUF
	PUBLIC	EXECPATH
	PUBLIC	EXEC_ADDR
	PUBLIC	EXEFCB
	PUBLIC	expand_star
	PUBLIC	ext_entered		;AN005;
	PUBLIC	FBUF
        PUBLIC  FileCnt
        PUBLIC  FileCntTotal
        PUBLIC  FileSiz
        PUBLIC  FileSizTotal
	PUBLIC	file_size_high
	PUBLIC	file_size_low
	PUBLIC	FILTYP
	PUBLIC	FIRSTDEST
	PUBLIC	FRSTSRCH
	PUBLIC	GOTOLEN
	PUBLIC	HEADCALL
	PUBLIC	ID
	PUBLIC	IDLEN
	PUBLIC	IFNOTFLAG
	PUBLIC	if_not_count
	PUBLIC	INEXACT
	PUBLIC	INTERNATVARS
	PUBLIC	KPARSE
	PUBLIC	last_arg
        PUBLIC  PerLine
        PUBLIC  LeftOnLine
        PUBLIC  LeftOnPage
	PUBLIC	linperpag		;AN000;
	PUBLIC	major_ver_num
	PUBLIC	MELCOPY
	PUBLIC	MELSTART
	PUBLIC	minor_ver_num
	PUBLIC	msg_flag		;AN022;
	PUBLIC	msg_numb		;AN022;
	PUBLIC	NOWRITE
	PUBLIC	NXTADD
	PUBLIC	objcnt
	PUBLIC	OCtrlZ
	PUBLIC	OFilePtr_Hi
	PUBLIC	OFilePtr_Lo
	PUBLIC	OldCtrlCHandler
	PUBLIC	one_char_val
	PUBLIC	PARM1
	PUBLIC	PARM2
	PUBLIC	parse_last		;AN018;
	PUBLIC	PARSE1_ADDR		;AN000;
	PUBLIC	PARSE1_CODE		;AN000;
	PUBLIC	PARSE1_OUTPUT		;AN000;
	PUBLIC	PARSE1_SYN		;AN000;
	PUBLIC	PARSE1_TYPE		;AN000;
	PUBLIC	PATHCNT
	PUBLIC	pathinfo
	PUBLIC	PATHPOS
	PUBLIC	PATHSW
	PUBLIC	PLUS
	PUBLIC	plus_comma
	PUBLIC	print_err_flag		;AN000;
	PUBLIC	psep_char
	PUBLIC	RCH_ADDR
	PUBLIC	RDEOF
	PUBLIC	RE_INSTR
	PUBLIC	RESSEG
	PUBLIC	SCANBUF
	PUBLIC	SDIRBUF
	PUBLIC	search_best
	PUBLIC	search_best_buf
	PUBLIC	search_curdir_buf
	PUBLIC	search_error
	PUBLIC	SKPDEL
	PUBLIC	SOURCE
	PUBLIC	SPECDRV
	PUBLIC	SRCBUF
	PUBLIC	SRCHAND
	PUBLIC	SRCINFO
	PUBLIC	SRCISDEV
	PUBLIC	SRCISDIR
	PUBLIC	SRCPT
	PUBLIC	SRCSIZ
	PUBLIC	SRCTAIL
	PUBLIC	SRCVARS
	PUBLIC	srcxname
	PUBLIC	STACK
	PUBLIC	STARTEL
	PUBLIC	string_ptr_2
;AD061; PUBLIC	string_ptr_2_sb 	;AN000;
	PUBLIC	subst_buffer		;AN061;
	PUBLIC	SWITCHAR
	PUBLIC	system_cpage
	PUBLIC	TERMREAD
	PUBLIC	TIME_FRACTION		;AN000;
	PUBLIC	TIME_HOUR		;AN000;
	PUBLIC	TIME_MINUTES		;AN000;
	PUBLIC	TIME_OUTPUT		;AN000;
	PUBLIC	TIME_SECONDS		;AN000;
	PUBLIC	TIME_TYPE		;AN000;
	PUBLIC	TPA
	PUBLIC	tpbuf
	PUBLIC	TRANSPACEEND
	PUBLIC	TRAN_TPA
	PUBLIC	trgxname
	PUBLIC	UCOMBUF
	PUBLIC	USERDIR1
	PUBLIC	vol_drv
	PUBLIC	vol_ioctl_buf		;AC030;
	PUBLIC	vol_serial		;AC030;
	PUBLIC	vol_label		;AC030;
	PUBLIC	WRITTEN
	PUBLIC	zflag

	Public	TypeFilSiz		;stores size of file to be typed

ifdef DBLSPACE_HOOKS
	PUBLIC	fhCVF, szCVF, MDBPB
	PUBLIC	ccluUsed, ccluUsedDir, ccluUsedTotal
	PUBLIC	csecUsed, csecUsedDir, csecUsedTotal
	PUBLIC	cFATEntries, entInBuf, bufDOSFAT, bufMDFAT
	PUBLIC	pbufDOSFAT, pbufMDFAT, segFATBUF, savBytCnt
	PUBLIC	csecPerCluster, fUseHostSize
endif

	IF  IBM_ROM_FIND
	PUBLIC	ROM_CALL
	PUBLIC	ROM_CS
	PUBLIC	ROM_IP
	ENDIF


	ORG	0
ZERO	=	$
SRCXNAME	DB	DIRSTRLEN + 20 DUP (?)	;g buffer for name translate
TRGXNAME	DB	DIRSTRLEN + 20 DUP (?)	;g buffer for name translate
UCOMBUF 	DB	COMBUFLEN+3 DUP(?)	; Raw console buffer
COMBUF		DB	COMBUFLEN+3 DUP(?)	; Cooked console buffer
USERDIR1	DB	DIRSTRLEN+3 DUP(?)	; Storage for users current directory
EXECPATH	DB	COMBUFLEN+3 DUP(?)	; Path for external command
RE_INSTR	DB	DIRSTRLEN+3+13 DUP (?)	; path for input to redirection

; Variables passed up from resident
HEADCALL	LABEL	DWORD
		DW	?
RESSEG		DW	?
TPA		DW	?
SWITCHAR	DB	?
DIRCHAR 	DB	?
EXEC_ADDR	DD	?
RCH_ADDR	DD	?
fTest		DW	?
TRAN_TPA	DW	?

CHKDRV		DB	?
RDEOF		LABEL	BYTE			; Misc flags
IFNOTFLAG	LABEL	BYTE
FILTYP		DB	?
CURDRV		DB	?
CONCAT		LABEL	BYTE
PARM1		DB	?
ARGC		LABEL	BYTE
PARM2		DB	?
COMSW		DW	?			; Switches between command and 1st arg
ARG1S		DW	?			; Switches between 1st and 2nd arg
DESTSWITCH	LABEL	WORD
ARG2S		DW	?			; Switches after 2nd arg
ALLSWITCH	LABEL	WORD
ARGTS		DW	?			; ALL switches except for COMSW
CFLAG		DB	?
DESTCLOSED	LABEL	BYTE
SPECDRV 	DB	?
BYTCNT		DW	?			; Size of buffer between RES and TRANS
ifdef DBLSPACE_HOOKS
SAVBYTCNT	DW	?
endif
NXTADD		DW	?
FRSTSRCH	DB	?
LeftOnLine      DB      ?                       ; entries left on line u.b. DIR
PerLine         DB      ?                       ; entries/line u.b. DIR
LeftOnPage      DW      ?                       ; lines left on page u.b. DIR
FileCnt         DW      ?                       ; file count u.b. DIR
FileSiz         DD      ?                       ; file size u.b. DIR

;		Note:  keep FileCntTotal through csecUsedTotal together!

FileCntTotal    DD      ?                       ; total file count u.b. DIR
FileSizTotal	DD	?			; total file size u.b. DIR

ifdef DBLSPACE_HOOKS
ccluUsed	DW	?			; count of DOS clusters used
ccluUsedDir	DW	?
ccluUsedTotal	DW	?
csecUsed	DD	?			; count of comp sectors used
csecUsedDir	DD	?
csecUsedTotal	DD	?

;		Note:  keep FileCntTotal through csecUsedTotal together!

fhCVF		DW	?			; Compressed Volume File handle
szCVF		DB	16 DUP (?)		; "X:\\12345678.123\0"
MDBPB		MD_BPB	<>			; Extended MagicDrv BPB

csecPerCluster	DB	?			; sectors/cluster for ratio calc
fUseHostSize	DB	?			; NZ if using host cluster size

cFATEntries	DW	?			; # FAT entries in buffers
entInBuf	DW	?			; 1st entry # in FAT buffers
segFATBUF	DW	?			; seg of DOS & MD FAT buffers
pbufDOSFAT	DW	?			; off of DOS FAT buffer
pbufMDFAT	DW	?			; off of MD FAT buffer
bufDOSFAT	DB	(cRES_FAT_ENTRIES * 2) DUP (?)	; small DOS FAT buffer
bufMDFAT	DB	(cRES_FAT_ENTRIES * 4) DUP (?)	; small MD FAT buffer
endif

CHARBUF 	DB	80 DUP (?)		;line byte character buffer for xenix write
DESTFCB2	LABEL	BYTE
IDLEN		DB	?
ID		DB	8 DUP(?)
COM		DB	3 DUP(?)
DEST		DB	37 DUP(?)
DESTNAME	DB	11 DUP(?)
DESTFCB 	LABEL	BYTE
DESTDIR 	DB	DIRSTRLEN DUP(?)	; Directory for PATH searches
GOTOLEN 	LABEL	WORD
BWDBUF		LABEL	BYTE
EXEFCB		LABEL	WORD
DIRBUF		DB	DIRSTRLEN+3 DUP(?)
SDIRBUF 	DB	12 DUP(?)
BITS		DW	?
PATHCNT 	DW	?
PATHPOS 	DW	?
PATHSW		DW	?
AttrSpecified   db      ?                       ; attribute bits u.b. DIR
AttrSelect      db      ?                       ; attribute bits u.b. DIR
comma		db	0			;g flag set if +,, occurs
plus_comma	db	0			;g flag set if +,, occurs
dirflag 	db	0			;AN015; set when pathcrunch called from DIR
parse_last	dw	0			;AN018; used to hold parsing position

system_cpage	DW	0			;AC001; used for CHCP variable



arg_buf 	db	128 dup (?)
file_size_low	dw	?			;AC000;
file_size_high	dw	?			;AC000;
string_ptr_2	dw	?
;AD061;string_ptr_2_sb dw      ?
copy_Num	dw	?
cpyflag 	db	?
Dir_Num 	DW	?
ifdef DBLSPACE_HOOKS
Dir_CRatio_1	db	?
Dir_CRatio_2	db	?
endif
bytes_free	dw	?
		dw	?
major_ver_num	dw	?
minor_ver_num	dw	?
one_char_val	db	?,0
vol_drv 	db	?

IFDEF ROMEXEC

	PUBLIC  ExecFromROM
ExecFromROM	db	?		; flag for ROM executable commands

ENDIF ; ROMEXEC

IF  IBM_ROM_FIND
ROM_CALL	DB	?			; flag for rom function
ROM_IP		DW	?
ROM_CS		DW	?
ENDIF

DESTVARS	LABEL	BYTE
DESTISDIR	DB	?
DESTSIZ 	DB	?
DESTTAIL	DW	?
DESTINFO	DB	?
DESTBUF 	DB	DIRSTRLEN + 20 DUP (?)
ENDDESTBUF	LABEL	BYTE

DESTHAND	DW	?
DESTISDEV	DB	?
FIRSTDEST	DB	?
MELCOPY 	DB	?
MELSTART	DW	?

SRCVARS 	LABEL	BYTE
SRCISDIR	DB	?
SRCSIZ		DB	?
SRCTAIL 	DW	?
SRCINFO 	DB	?
SRCBUF		DB	DIRSTRLEN + 20 DUP (?)

SRCHAND 	DW	?
SRCISDEV	DB	?

SCANBUF 	DB	DIRSTRLEN + 20 DUP (?)

SRCPT		DW	?
INEXACT 	DB	?
NOWRITE 	DB	?
BINARY		DB	?
WRITTEN 	DW	?
TERMREAD	DB	?
ASCII		DB	?
PLUS		DB	?
objcnt		db	?		; Used in copy
CPDATE		DW	?
CPTIME		DW	?

OFilePtr_Lo	DW	?		; original file ptr for COPY when
OFilePtr_Hi	DW	?		; 1st source is also destination
OCtrlZ		DB	?		; original ctrl+Z for COPY when ditto

BATHAND 	DW	?		; Batch handle
STARTEL 	DW	?
ELCNT		DB	?
ELPOS		DB	?
SKPDEL		DB	?
SOURCE		DB	11 DUP(?)

ext_entered	db	0			;AN005;

display_ioctl	db	0			;AN000; info level
		db	0			;AN000; reserved
		dw	crt_ioctl_ln		;AN000; length of data
		dw	?			;AN000; control flags
display_mode	db	?			;AN000; display mode, colors
		db	0			;AN000; reserved
		dw	?			;AN023; colors
		dw	?			;AN000; display width (PELS)
		dw	?			;AN000; display length (PELS)
display_width	dw	?			;AN000; display width
linperpag	dw	linesperpage		;AN000; display length (default to linesperpage)

vol_ioctl_buf	label	byte			;AN000; buffer for ioctl volume label/serial call
		dw	0			;AN000; info level
vol_serial	dd	0			;AN000; volume serial number
vol_label	db	11 dup (" ")            ;AN000; volume label - init to blanks
		db	8  dup (" ")            ;AN000; file system type

expand_star	db	?
msg_flag	db	?			;AN022; flag set if non-utility message issued
msg_numb	dw	0			;AN022; set with extended error message issued
append_exec	db	0			;AN041; set if internal append executed
print_err_flag	dw	0			;AN000; flag set if error during sysdispmsg
subst_buffer	db	parm_block_size*2 dup (0);AN061;

;;;;	IFDEF	DBCS		3/3/KK
KPARSE		DB	?
;;;;	ENDIF			3/3/KK

; Data declarations taken out of parse.asm

arg	arg_unit	<>			; pointers, arg count, string buffer
argbufptr	DW	?			; index for argv[].argpointer
tpbuf		DB	128   DUP (?)		; temporary buffer
LAST_ARG	DW	?			; point at which to accumulate switch info
comptr		dw	?			; ptr into combuf

; Data declarations taken out of path.asm
fbuf	find_buf	<>			; dma buffer for findfirst/findnext
pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
psep_char	DB	?			; '/' or '\'
search_best	DB	(?)			; best code, best filename so far
fname_max_len	equ	13
search_best_buf DB	fname_max_len DUP (?)
search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
search_error	DW	(?)			; address of error message to be printed

; Data declarations taken out of tbatch.asm
if_not_count	DW	?

zflag		db	?			; Used by typefil to indicate ^Z's

		DW	80H DUP(0)		; Init to 0 to make sure the linker is not fooled
STACK		LABEL	WORD

INTERNATVARS	internat_block <>
		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)

;		Buffer for DOS function 64h (Get extended country information)
;		subfunctions 2, 4, 6, or 7:

CountryPtrInfo	label	byte
CountryPtrId	db	?
CountryPtr	dd	?
		.erre	(($ - CountryPtrInfo) GE 5)

OldCtrlCHandler	dd	?			; previous int 23 vector


BatBufPos	DW	?			; integer position in buffer of next byte
BatBuf		DB	BatLen DUP (?)
BatBufEnd	DW	?

TypeFilSiz	dd	?		;stores size of file to be typed

; *****************************************************
; EMG 4.00
; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
; *****************************************************
;
; COMMON PARSE OUTPUT BLOCKS
;


;
; Common output blocks for PARSE number, complex, or string values.
;

PARSE1_OUTPUT	LABEL	BYTE			;AN000;
PARSE1_TYPE	DB	0			;AN000;  type
PARSE1_CODE	DB	0			;AN000;  return value
PARSE1_SYN	DW	0			;AN000;  es offset of synonym
PARSE1_ADDR	DD	0			;AN000;  numeric value / address
						;	 of string value

;
;  Common output block for PARSE date strings.
;

DATE_OUTPUT	LABEL	BYTE			;AN000;
DATE_TYPE	DB	0			;AN000;  type
		DB	0			;AN000;  return value
		DW	0			;AN000;  es offset of synonym
DATE_YEAR	DW	0			;AN000;  year
DATE_MONTH	DB	0			;AN000;  month
DATE_DAY	DB	0			;AN000;  day

;
;  Common output block for PARSE time strings.
;

TIME_OUTPUT	LABEL	BYTE			;AN000;
TIME_TYPE	DB	0			;AN000;  type
		DB	0			;AN000;  return value
		DW	0			;AN000;  es offset of synonym
TIME_HOUR	DB	0			;AN000;  hour
TIME_MINUTES	DB	0			;AN000;  minutes
TIME_SECONDS	DB	0			;AN000;  seconds
TIME_FRACTION	DB	0			;AN000;  hundredths

;
;  Common output block for PARSE drive specifier (one based drive number).
;

DRIVE_OUTPUT	LABEL	BYTE			;AN000;
DRIVE_TYPE	DB	0			;AN000;  type
DRIVE_VALUE	DB	0			;AN000;  return value
		DW	0			;AN000;  es offset of synonym
DRIVE_NUMBER	DB	0			;AN000;  drive number
		DB	0,0,0			;AN000;  reserved

TRANSPACEEND	LABEL	BYTE

TRANSPACE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\uinit.asm ===
page ,132
;	SCCSID = @(#)uinit.asm	4.5 85/12/04
;	SCCSID = @(#)uinit.asm	4.5 85/12/04
TITLE	COMMAND Initialization messages
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;	M003	SR	07/16/90	Added Lh_OffUnlink to the offset
;				patch table (Reloc_Table) for UMB
;				support
;

.XCREF
.XLIST
include comsw.asm
include comseg.asm
include ifequ.asm
.LIST
.CREF

addr macro sym,name
     public name
     ifidn <name>,<>

	    dw offset resgroup:sym
     else

name	    dw	offset resgroup:sym
     endif
     endm

CODERES	segment

	extrn	ContC		:near
	extrn	DskErr		:near
	extrn	Int_2e		:near
	extrn	MsgInt2fHandler	:near
	extrn	Exec_Ret	:near
	extrn	TRemCheck	:far
	extrn	TrnLodCom1	:near
	extrn	MsgRetriever	:near
	extrn	LodCom		:near
	extrn	THeadFix	:far
	extrn	Lh_OffUnlink	:far	; M003

CODERES	ends


;;ENVIRONMENT	SEGMENT PUBLIC PARA		;AC000;
;;	EXTRN	ECOMSPEC:BYTE
;;ENVIRONMENT ENDS

TRANCODE	SEGMENT PUBLIC BYTE		;AC000;
	extrn	Printf_init:FAR
	extrn	Triage_Init:FAR
	extrn	append_parse:FAR		;AN054;
TranCode    ENDS

INIT		SEGMENT PUBLIC PARA		;AC000;


	public	icondev
	public	BADCSPFL
	public	COMSPECT
	public	AUTOBAT
	public	space
	public	PRDATTM
	public	INITADD
	public	print_add
        public  AllocedEnv
	public	scswitch
        public  skswitch
	public	ucasea
;;	public	ECOMLOC
	public	equalsign
	public	lcasea
	public	lcasez
        public  ComspOffset
        public  ComspString
        public  ComspStrLen
        public  ComspStrLen2
	public	EnvSiz
	public	EnvMax
	public	initend
	public	trnsize
	public	resetenv			;AC000;
	public	ext_msg 			;AC000;
	public	num_positionals
	public	internat_info
	public	parsemes_ptr

	PUBLIC	triage_add
	PUBLIC	oldenv
	PUBLIC	usedenv
	PUBLIC	KAUTOBAT			;AN000;  3/3/KK
	public	eswitch 			;AN018;
	public	dswitch 			;AN018;
	public	init_parse			;AN054;
	public	old_parse_ptr			;AN057;
	PUBLIC	pars_msg_off			;AN060;
	PUBLIC	pars_msg_seg			;AN060;

	public	PathString
        public  PathStrLen
        public  DefPathString
        public  DefPathStrLen
        public  DefPath2String
        public  DefPath2StrLen
        public  PrmptString
        public  PrmptStrLen
        public  PrmptStrLen2
	public	Reloc_Table
	public	ResJmpTable
	public	FirstCom

	public	DevFlag
	public	PathFlag


include resmsg.equ				;AC000;


ICONDEV LABEL BYTE
		DB	"/DEV/"
		DB	"CON",0,0,0,0,0,0               ; Room for 8 char device
BADCSPFL	DB	0
COMSPECT	DB	"\COMMAND.COM",0,0
AUTOBAT 	DB	0,":\AUTOEXEC.BAT",0,0DH        ;AC027;
KAUTOBAT	DB	0,":\KAUTOEXE.BAT",0,0DH        ;AC027;  3/3/KK

PRDATTM 	DB	-1				;Init not to prompt for date time
INITADD 	DD	?
print_add	LABEL	DWORD
		DW	OFFSET TranGroup:Printf_INIT
		DW	0
triage_add	LABEL	DWORD
		DW	OFFSET TranGroup:Triage_Init
		DW	0

AllocedEnv      DB      0

PathString	db	"PATH=",0
PathStrLen      equ     $-PathString-1
DefPathString   db      "C:\MSDOS",0
DefPathStrLen   equ     $-DefPathString-1
DefPath2String  db      "C:\DOS",0
DefPath2StrLen  equ     $-DefPath2String-1
PrmptString     db      "PROMPT=$P$G",0
PrmptStrLen     equ     $-PrmptString-1
PrmptStrLen2    equ     7                               ; length of PROMPT=
ComspOffset     dw      0
ifndef		ROMDOS
ComspString	db	"COMSPEC=\COMMAND.COM",0
else
ComspString	db	"COMSPEC=COMMAND",0
endif
ComspStrLen     equ     8                               ; length of COMSPEC=
ComspStrLen2    equ     $-ComspString-1                 ; length of full COMSPEC

;;COMSPSTRING	DB	"COMSPEC="

equalsign	db	"="
lcasea		db	"a"
lcasez		db	"z"
space		db	" "
scswitch	db	"C"                             ; Single command
skswitch        db      "K"
ucasea		db	"A"

EnvSiz		DW	0				; size user wants to allocate
EnvMax		DW	0				; maximum size allowed.
oldenv		DW	0				; envirseg at initialization
usedenv 	DW	0				; amount of envirseg used
PARS_MSG_OFF	DW	0				;AN060;  SAVED PARSE ERROR MESSAGE OFFSET
PARS_MSG_SEG	DW	0				;AN060;  SAVED PARSE ERROR MESSAGE SEGMENT

;Do not separate the following two words.  Used to call transient PARSE routine

init_parse	label	dword				;AN054;
init_p		DW	TRANGROUP:APPEND_PARSE		;AN054;
initend 	DW	0				;eg segment address of end of init

;End of data that shouldn't be separated.

trnsize 	DW	0				;eg size of transient in paragraphs
resetenv	DB	0				;eg set if we need to setblck env at endinit
ext_msg 	DB	0				;AN000; set if /MSG switch entered
eswitch 	db	0				;AN018; set if /e was entered
dswitch 	db	0				;AN018; set if /d was entered
parsemes_ptr	dw	0			;AN000; word to store parse error number

;
; PARSE BLOCK FOR COMMAND
;
PUBLIC	PARSE_COMMAND				;AN000;
PUBLIC	COMND1_OUTPUT				;AN000;
PUBLIC	COMND1_TYPE				;AN000;
PUBLIC	COMND1_CODE				;AN000;
PUBLIC	COMND1_SYN				;AN000;
PUBLIC	COMND1_ADDR				;AN000;
PUBLIC	COMMAND_F_SYN				;AN000;
PUBLIC	COMMAND_P_SYN				;AN000;
PUBLIC	COMMAND_C_SYN				;AN000;
PUBLIC  COMMAND_K_SYN                           ;AN000;
PUBLIC	COMMAND_D_SYN				;AN000;
PUBLIC	COMMAND_E_SYN				;AN000;
PUBLIC	COMMAND_M_SYN				;AN000;
PUBLIC	COMMAND_?_SYN

;
;  The following parse control block is used for COMMAND.  This block is
;  used for parsing during initialization.  The sytax for COMMAND is:
;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable]
;
;  Anything on the command line after the /C switch will be passed to the
;  executable command, so if /C is used, it must be specified last. The
;  /MSG switch can only be specified if the /P switch is specified.
;
;  The /? switch causes help text to be displayed.  Any other options
;  on the command line are ignored.  Command.com will not load if /?
;  is specified.
;

ENVBIG	EQU	32768				;AN000; maximum environment size
ENVSML	EQU	160				;AN000; minimum environment size

INTERNAT_INFO	LABEL	BYTE			;AN000; used for country info after parsing is completed
PARSE_COMMAND	LABEL	BYTE			;AN000;
		DW	RESGROUP:COMMAND_PARMS	;AN000;
		DB	0			;AN000; no extra delimiter

COMMAND_PARMS	LABEL	BYTE			;AN000;
		DB	0,2			;AN000; 1 positional parm
		DW	RESGROUP:COMMAND_FILE	;AN000;
		dw	RESGROUP:Command_File
                DB      8                        ;AN000; 8 switches
		DW	RESGROUP:COMMAND_SWITCH1 ;AN000;
		DW	RESGROUP:COMMAND_SWITCH2 ;AN000;
		DW	RESGROUP:COMMAND_SWITCH3 ;AN000;
		DW	RESGROUP:COMMAND_SWITCH4 ;AN000;
		DW	RESGROUP:COMMAND_SWITCH5 ;AN000;
		DW	RESGROUP:COMMAND_SWITCH6 ;AN000;
		DW	RESGROUP:COMMAND_SWITCH7
                DW      RESGROUP:COMMAND_SWITCH8
		DB	0			;AN000; no keywords

COMMAND_FILE	LABEL	BYTE			;AN000;
		DW	0201H			;AN000; filespec - optional
		DW	1			;AN000; capitalize - file table
		DW	RESGROUP:COMND1_OUTPUT	;AN000; result buffer
		DW	RESGROUP:NO_VAL 	;AN000;
		DB	0			;AN000; no keywords

COMMAND_SWITCH1 LABEL	BYTE			;AN000;
		DW	0			;AN000; no match flags
		DW	2			;AN000; capitalize by char table
		DW	RESGROUP:COMND1_OUTPUT	;AN000; result buffer
		DW	RESGROUP:NO_VAL 	;AN000;
		DB	1			;AN000; 1 keyword
COMMAND_P_SYN	DB	"/P",0                  ;AN000; /P switch

COMMAND_SWITCH2 LABEL	BYTE			;AN000;
		DW	0			;AN000; no match flags
		DW	2			;AN000; capitalize by char table
		DW	RESGROUP:COMND1_OUTPUT	;AN000; result buffer
		DW	RESGROUP:NO_VAL 	;AN000;
		DB	1			;AN000; 1 keyword
COMMAND_F_SYN	DB	"/F",0                  ;AN000; /F switch

COMMAND_SWITCH3 LABEL	BYTE			;AN000;
		DW	0			;AN000; no match flags
		DW	2			;AN000; capitalize by char table
		DW	RESGROUP:COMND1_OUTPUT	;AN000; result buffer
		DW	RESGROUP:NO_VAL 	;AN000;
		DB	1			;AN000; 1 keyword
COMMAND_D_SYN	DB	"/D",0                  ;AN000; /D switch

COMMAND_SWITCH4 LABEL	BYTE			;AN000;
		DW	8000H			;AN000; numeric value - required
		DW	0			;AN000; no function flags
		DW	RESGROUP:COMND1_OUTPUT	;AN000; result buffer
		DW	RESGROUP:COMMAND_E_VAL	;AN000; pointer to value list
		DB	1			;AN000; 1 keyword
COMMAND_E_SYN	DB	"/E",0                  ;AN000; /E switch

COMMAND_E_VAL	LABEL	BYTE			;AN000;
		DB	1			;AN000;
		DB	1			;AN000; 1 range
		DB	1			;AN000; returned if result
		DD	ENVSML,ENVBIG		;AN000; minimum & maximum value
		DB	0			;AN000; no numeric values
		DB	0			;AN000; no string values

COMMAND_SWITCH5 LABEL	BYTE			;AN000;
		DW	0			;AN000; no match flags
		DW	2			;AN000; capitalize by char table
		DW	RESGROUP:COMND1_OUTPUT	;AN000; result buffer
		DW	RESGROUP:NO_VAL 	;AN000;
		DB	1			;AN000; 1 keyword
COMMAND_C_SYN	DB	"/C",0                  ;AN000; /C switch

COMMAND_SWITCH6 LABEL	BYTE			;AN000;
		DW	0			;AN000; no match flags
		DW	2			;AN000; capitalize by char table
		DW	RESGROUP:COMND1_OUTPUT	;AN000; result buffer
		DW	RESGROUP:NO_VAL 	;AN000;
		DB	1			;AN000; 1 keyword
COMMAND_M_SYN	DB	"/MSG",0                ;AN000; /MSG switch

COMMAND_SWITCH7 LABEL	BYTE			;AN000;
		DW	0			;AN000; no match flags
		DW	2			;AN000; capitalize by char table
		DW	RESGROUP:COMND1_OUTPUT	;AN000; result buffer
		DW	RESGROUP:NO_VAL 	;AN000;
		DB	1			;AN000; 1 keyword
COMMAND_?_SYN	DB	"/?",0                  ;AN000; /? switch

COMMAND_SWITCH8 LABEL   BYTE                    ;AN000;
		DW	0			;AN000; no match flags
		DW	2			;AN000; capitalize by char table
		DW	RESGROUP:COMND1_OUTPUT	;AN000; result buffer
		DW	RESGROUP:NO_VAL 	;AN000;
		DB	1			;AN000; 1 keyword
COMMAND_K_SYN   DB      "/K",0                  ;AN000; /K switch

COMND1_OUTPUT	LABEL	BYTE			;AN000;
COMND1_TYPE	DB	0			;AN000; type
COMND1_CODE	DB	0			;AN000; return value
COMND1_SYN	DW	0			;AN000; synonym pointer
COMND1_ADDR	DD	0			;AN000; numeric value / address
						;	of string value

NO_VAL		DB	0			;AN000; no values
num_positionals DW	0			;AN000; counter for positionals
old_parse_ptr	DW	0			;AN057; SI position before calling parser



;***	INITIALIZATION MESSAGES

	include	comimsg.inc		;M00


;SR;
; This table of offsets is used by the init code to calculate the new offsets
;for these labels after the resident code has been relocated
;

Reloc_Table	dw	offset CODERES:MsgInt2fHandler
		dw	offset CODERES:Int_2e
		dw	offset CODERES:ContC
		dw	offset CODERES:DskErr
		dw	offset CODERES:Exec_Ret
		dw	offset CODERES:TRemCheck
		dw	offset CODERES:TrnLodCom1
		dw	offset CODERES:LodCom
		dw	offset CODERES:MsgRetriever
		dw	offset CODERES:THeadFix
		dw	offset CODERES:Lh_OffUnlink	; M003

NUM_RELOC_ENTRIES	equ  ($ - Reloc_Table) / 2
public	NUM_RELOC_ENTRIES

ResJmpTable	dd	?		;stores prev stub jump table addr
FirstCom		db	0		;flag set if first command.com

DevFlag		db	0
PathFlag		db	0

INIT	ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\minicmd\romhead.asm ===
page    ,132
	title   ROM COMMAND Resident ROM Header

comment %------------------------------------------------------------------

This module provides a standard ROM header for ROM COMMAND as
described in the IBM System BIOS technical reference.

MS-DOS ROM $Exec header is also supplied for COMMAND launch.

The size field and checksum of the BIOS-compatible ROM module are set
when putting this object code together with other code granules to
make the ROM module.

%--------------------------------------------------------------------------



ROMHEADER	segment


;***	Adapter ROM module signature and size
;
;	The signature must be aligned on a 2K address boundary.
;	A checksum of bytes in the specified range must be zero
;	for the ROM module to be valid.

	db      55h,0AAh                ; ROM signature
	db      08h			; ROM size in 512-byte pages
	assume  cs:ROMHEADER

;*	POST Initialization (POST makes far call to here).

	jmp     near ptr POSTInit       ; POST initialization

;*	ROM file header for DOS $ROMFindFirst, $ROMFindNext, $Exec.

ROMFile	macro	name,entry
	local	nambeg,namend
	db	namend-nambeg	;; file name length
nambeg	db	"&name"		;; file name
namend	label	byte
	jmp	near ptr entry	;; exec entry point
	endm

	ROMFile	COMMAND,Launch		; COMMAND launch
	ROMFile	COMMAND.COM, Launch	; COMMAND.COM alias for command.com

	db      0               	; end of file names




;***    POST initialization - no action needed

POSTInit:
	retf




;***    COMMAND launch

	include	command.loc		; COMMAND image location

Launch:

;       CS = ROMHEADER segment
;       DS,ES,SS = segment of PSP

;*      Copy COMMAND image to RAM.

;	------------------------------------------------------------
	ifdef	COMMAND_SEG
;	COMMAND image is in first megabyte.  Cool.
	
	mov	ax,COMMAND_SEG		; AX = COMMAND image seg addr
	push	ax
	xor	ax, ax
	push	ax
	retf

	else
	%out MINICOMMAND should be below 1 megabyte
	.err
	endif

ROMHEADER	ends

	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\romstub\command.asm ===
page	,132
	title	Command.com stub for ROM COMMAND

comment	%

This command.com lies around on disk in a ROM DOS system, in case
someone needs to find and/or EXEC command.com from disk.  We find ROM
COMMAND and jump to it's entry point, with all registers set as for
the original EXEC.  ROM COMMAND will use the same PSP, etc. as this
program.

Bugbug:  Need to make sure there's enough space for the full COMMAND.

%


	.xlist
	.xcref

	include version.inc		; build version (ROMDOS, etc.)
	include versiona.inc		; DOS version number
	include	syscall.inc		; DOS function names

	.cref
	.list


ifdef      JAPAN                      ; YI 09/05/89
ROMSTARTSEG     EQU     0008H
ROMENDSEG       EQU     000AH
else
	include	oemconf.inc
endif



_TEXT	segment

	assume	cs:_TEXT,ds:_TEXT,es:_TEXT,ss:_TEXT

	org	100h
Entry:

;*	Check that we're running ROM DOS, our version.

	mov	ax,GET_VERSION shl 8
	int	21h
	cmp	ax,EXPECTED_VERSION
	jne	NoCanDo			; incorrect DOS version

	mov	ax,3306h		; AX = "Get real version info"
	int	21h
	test	dh,8			; is DOS in ROM?
	jz	DoItOurself		; no, try searching in ROM space

;*	Set DTA to somewhere besides the command tail buffer, to
;	preserve the command tail.

	mov	dx,offset TempDTA	; DS:DX = ptr to temporary DTA
	mov	ah,SET_DMA		; AH = 'Set DTA Address'
	int	21h

;*	Find the ROM COMMAND file

	mov	dx,offset ROMName	; DS:DX = ptr to ROM COMMAND name
	mov	ah,ROM_FIND_FIRST	; AH = 'Find First ROM File'
	int	21h

;*	Restore original DTA.

	pushf				; preserve search results
	mov	dx,80h			; DS:DX = ptr to normal default DTA
	mov	ah,SET_DMA		; AH = 'Set DTA Address'
	int	21h

	popf				; restore search results
	jc	NoCanDo			; search failed - give up


;*	Transfer to ROM COMMAND with original EXEC segment registers, et al.
;
;	See ROM_FIND_FIRST documentation (in dos\romfind.asm).

	push	word ptr TempDTA.15	; put segment of ROM COMMAND on stack
	sub	word ptr TempDTA.13,3
	push	word ptr TempDTA.13	; put offset of COMMAND jump-off
					;   on stack
Xfer:
	xor	ax,ax			; zero general-purpose registers
	xor	bx,bx
	xor	cx,cx
	xor	dx,dx
	retf				; transfer to ROM COMMAND


DoItOurself:

	push	es

ifdef      JAPAN                                   ; YI 09/05/89
        push    ds
	mov	ax, 70h
	mov	ds, ax
        mov     ax, ds:[ROMSTARTSEG]
        pop     ds
else
	mov	ax,ROMEXEC_SEG
endif

        mov     es,ax
	xor	ax,ax				;es:ax points to ROM scan addr	

	push	si
	mov	si, offset ROMName
	call	Check_ROM
	jc	NoCanDo

	mov	Temp, ax
	mov	Temp+2, es
	pop	si

	pop	es

	push	Temp+2
	push	Temp

	jmp	xfer

Temp	dw	?
	dw	?

NoCanDo:
	mov	ax,4C00h
	int	21h


;
;Procedure : Check_ROM
;	Inputs: ds:si points to string
;		ax=0 --- start scan from beginning
;		ax>0 --- start scan from given address
;		         es:ax points to address to start scan
;	Function:
;		Check if string matches ROM name
;	Outputs:
;		Carry set if no match found
;		Carry clear if match found and
;		   es:ax contains address of jmp to program in ROM
;		   dx contains offset address of matched string	
;		   cx contains length of matched string	
;

ROMSIG	EQU	0AA55H

Check_ROM	PROC	NEAR

;	SaveReg	<bx, si, di>

	push	bx
	push	si
	push	di

	xor	di,di			; DI is offset to ROM header
	or	ax,ax
	jz	check_sig

; restart search at location specified in AX
	add	di,ax
	jmp	short restart_search

;
;es:di contains start addr for ROM header.  check for valid ROM.
;	
check_sig:	
	cmp	WORD PTR es:[di],ROMSIG		
	jz	valid_sig
	mov	bx,es
	add	bx,80h
        mov     es,bx   ;next 2K block
ifdef      JAPAN
        jc      rom_done        ; jump if avobe 100000H
        push    ds
        mov     ds, cs:[BioDataSeg]
        cmp     bx, ds:[ROMENDSEG]
        pop     ds
        jc      check_sig
else
	jnc	check_sig
endif

rom_done:
	pop	di
	pop	si
	pop	bx

;	RestoreReg <di, si, bx>
	stc		;No match found
	ret

valid_sig:
	add	di,6			; advance past header to cmd table
restart_search:
	xor	cx, cx			; set max number of searches
valid_lp:
	mov	bx, cx			; save max number of searches in BX
	mov	cl,es:[di]		; get length byte
	or	cl,cl			; is it zero?
	jz	next_ROM		; end of header
	inc	di			; start of name
	xor	ch,ch			; clear upper byte of length
	mov	dx, di			; save pointer to cmd name in dx
	push	si			; preserve pointer to name
	call	scan
	pop	si			; restore pointer to name
	jnc	rom_match		; matched,get address
	mov	di,dx			; restore pointer to cmd name
cont_chk_nam:
	add	di,cx			; skip over name
	add	di,3			; skip over jmp
	mov	cx, bx			; get max number of searches from BX
	loop	valid_lp

next_ROM:
	xor	di, di			; get offset of ROM header
	mov	al,es:[di+2]		; get no. of pages
;
;Round off to 2K boundary
;
	xor	ah, ah			; clear upper byte
	add	ax, 011B		; to round up to fourth page
	and	ax, not 011B		; this rounds off to fourth
	mov	cl, 5			; to mult by 512 bytes per page and...
	shl	ax, cl			; ...divide by 16 bytes per paragraph
	mov	bx,es
	add	bx,ax
	mov	es,bx
	jc	rom_done		; All segments done

ifdef      JAPAN                           ; YI 09/05/89
        push    ds
        mov     ds, cs:[BioDataSeg]
        cmp     bx, ds:[ROMENDSEG]
        pop     ds
        jnc     rom_done
        jmp     check_sig
else
        jmp     check_sig
endif

rom_match:
	add	di,cx			;point di to the jump instrn.
	mov	ax,di			;address of jmp in ROM

	pop	di
	pop	si
	pop	bx

;	RestoreReg <di, si, bx>
	clc
	ret
Check_ROM	ENDP

;
;	input parameters: DS:SI -> user string
;			  ES:DI -> rom string
;			  CX	=  length of rom string
;
;	output:
;			Carry clear
;			DTA contains matching ROM string
;
;			if error Carry Set
;
;
scan 	proc	near

	push	cx
	push	ax
	push	es
	push	ds
	push	si
	push	di

	mov	ax, cx		; length of ROM string in AX

	cld

next:	cmp	byte ptr [si], '?'
	jz	skip
	cmp	byte ptr [si], '*'
	jz	found
	call	cmpi			;do case insensitive compare
	jne	no_match
	dec 	cx
	jcxz	is_match
	jmp	next

skip:	cmp	byte ptr es:[di], '.'
	je	no_match
	call 	cmpi			;do case insensitive compare
	jmp	next


found:
;
;	inc si till '.' or NULL
;	if NULL
;		matched
;	else
;		inc di till '.' or CX Z
;		if CX Z
;			no match
;		else
;			goto next
;		endif
;     	endif

	cmp	byte ptr [si], '.'
	jz	src_ext
	cmp	byte ptr [si], 0
	jz	match
	inc	si
	jmp	found

src_ext:inc	si			; point to extension of source string

do_dst:	cmp	byte ptr es:[di], '.'
	jz	chk_ext
	dec 	cx
	jcxz	no_match
	inc	di
	jmp	do_dst

chk_ext:inc 	di
	jmp	next

is_match:
	cmp	byte ptr [si],0
	jnz	no_match
match:
	clc
	jmp	short scan_done

no_match:
	stc

scan_done:	pop	di
	pop	si
	pop	ds
	pop	es
	pop	ax
	pop	cx
	ret

scan	endp

;
;Procedure : Cmpi
;
;		Input: ds:si and es:di point to the chars to be compared
;
;		Output: Zero flag set if match
;			Both di and si advanced
;
cmpi	PROC	NEAR
	push	ax
	lodsb	  		;get one char
	cmp	al,byte ptr es:[di]
	jz	cmp_match
	xor	al,20h		;get opposite case
	cmp	al,byte ptr es:[di]
cmp_match:
	lea	di,[di+1]		;Increment without changing flags
	pop	ax
	ret
cmpi	ENDP



ROMName	db	"COMMAND",0		; ROM COMMAND name

TempDTA	db	128 dup (?)		; DTA for ROM COMMAND search


_TEXT	ends
	end	Entry

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\minicmd\minicmd.inc ===
; This file contains the constants used in minicmd.com.

STDERR	EQU	2
STDOUT	EQU	1
CR	EQU	0dh
LF	EQU	0ah
SPACE	EQU	' '
TAB	EQU	09h
COLON	EQU	':'
EQUALS	EQU	'='

; This is the prompt character used by the minicmd.com to prompt the user
; for input (provided ECHO is ON)
;
PROMPT_CHAR	EQU	':'

; The initial value for last_pgm_exit_code -- used in the ERRORLEVEL stuff
; of IFs.
;
INIT_ERRLVL	EQU	0

; Maximum allowable input from user including the CR!
;
MAX_INP_LENGTH	EQU	128


; In the critical error handler DOS passes in AH the following information:
; Bit 3:	0 = FAIL response not allowed
;		1 = FAIL response allowed
; Bit 4:	0 = RETRY response not allowed
;		1 = RETRY response allowed
; Bit 5:	0 = IGNORE response not allowed
;		1 = IGNORE response allowed
; Bit 6:	? = reserved. I am using this to signify, if ABORT is
;		    allowed or not. Note that we cannot ABORT the minicmd.com
;		    if it generated the critical error, so we don't have any
;		    one to return to if we abort ourselves!!!


FAIL_BIT_MASK	EQU	00001000b
RETRY_BIT_MASK	EQU	00010000b
IGNORE_BIT_MASK	EQU	00100000b

ABORT_BIT_MASK	EQU	01000000b



; offset in char dev header where the DEV attr word is located.
;
OFFSET_DEV_ATTR	EQU	04h

; offset in char dev header where the DEV name (LPT1, PRN, etc) is.
;
OFFSET_DEV_NAME	EQU	0AH

; the length of the device name in the char device header -- if it is
; only 3 chars long like in PRN, the remaining 5 are padded with blanks!
DEV_NAME_LEN	EQU	8


; The following are the keys user is allowed to input to the Critical Error
; Action query and the code that is returned by the handler to DOS.

ABORT_KEY	EQU	'A'
ABORT_KEY_CODE	EQU	2

RETRY_KEY	EQU	'R'
RETRY_KEY_CODE	EQU	1

IGNORE_KEY	EQU	'I'
IGNORE_KEY_CODE	EQU	0

FAIL_KEY	EQU	'F'
FAIL_KEY_CODE	EQU	3

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\comp\comp.h ===
/*************************************************************************/
/*                                                                       */
/*  FILE:    Comp.H                                                      */
/*                                                                       */
/*  PURPOSE: This file contains the constants, globals, structure        */
/*           definitions, and function declarations for the comp         */
/*           utility.                                                    */
/*                                                                       */
/*  LABEL:   Microsoft Confidential                                      */
/*           Copyright (c) Microsoft Corporation 1991                    */
/*           All Rights Reserved.                                        */
/*                                                                       */
/*************************************************************************/


/* Definitions relating to the pathname */
#define  MAXPATH  67
#define  FLNAM    12
#define  MAXFLNM  MAXPATH + FLNAM + 1       /* Add 1 for EOL char ! */

typedef  char  Pathname[MAXFLNM];
typedef  int   Flag;
typedef  int   Boolean;
typedef  int   Index;


/* Random definitions */
#define  TRUE               1
#define  FALSE              0
#define  CASE_DIFFERENCE    32
#define  MAX_PARAMS         8
#define  OPT_SIZE           10
#define  MAX_OPTIONS        5
#define  MAX_NUM_DIFF       10
#define  NO_MEMORY          0
#define  NULLPTR            0
#define  ENOUGH_EXTRA       5
#define  VERSION_NUM        0x30
#define  MAJ_VER_NUM        5
#define  MIN_VER_NUM        0
#define  APPEND_INT         0x2f
#define  GET_APPEND_STATUS  0xb706
#define  SET_APPEND_STATUS  0xb707

#define  EOFCHAR	    0x1a
#define  BACKSPACE          '\b'
#define  RETURNCHAR         '\r'
#define  NEWLINE            '\n'
#define  SPACEBAR           ' '
#define  BEEPCHAR           '\a'


/*
 *  Global Variables
 */
unsigned limit = 0;                    /* # of lines to comp, if specified */
Flag decimal = FALSE,                  /* mismatched bytes displayed as decimal */
     asci = FALSE,                     /* mismatched bytes display as chars */
     no_case = FALSE,                  /* do case-insensitive compare */
     count_lines = FALSE;              /* count CR characters */
char *buf1,  *buf2,                    /* buffers to read the 2 files into */
     fmt[] = "%s%u\n%s%?\n%s%!\n",     /* the one used by printf */
     fmt_str[] = "%s%u\n%s%?\n%s%!\n", /* a copy we might need to reset to */
     lfmt[] = "%s%lX\n%s%?\n%s%!\n",   /* the one used by printf */
     lfmt_str[] = "%s%lX\n%s%?\n%s%!\n";    /* a copy */
unsigned int bufsiz; 
unsigned int append_stat;              /* current status of append */
char getsbuf[128];		       /* buffer for all gets's in comp */
unsigned char input_redir;             /* TRUE if input redirected */

char crlfstr[] = "\r\n$";


/*
 *  Forward Declarations
 */
int main(int, char **);
int CheckOptionsHelp(int, char **);
unsigned comp(char *, char *);
unsigned open_file(char *, int *);
unsigned read_file(int, void far *, unsigned, unsigned *, char *);
int getmem(char **, char **);
void getoneopt(char *);
unsigned ppargs(char **, int *, char **);
int dronly(char *);
void setfmt(char *, char);
char *extend_length(char *);
Boolean has_extension(char *);
void compgets(char *, int);
void GetInput(int *);
char ReadStdin(void);                            /* M012 */
void WriteStderr(char);
void ParseFileNames(char *, char *);
char *FindFileName(char *);
Boolean HasWildcard(char *);
void CheckWildcard(char *, char *);
int ExpandFile2(char *, char *);                 /* M008 */
void ExitComp(void);


#ifdef DBCS
int IsDBCSLeadByte(unsigned char);
int CheckDBCSTailByte(unsigned char *, unsigned char *);
#endif



/*
 *   Macro Definitions
 */

/*********************************************************************/ 
/* Routine:   Beep                                                   */
/*                                                                   */
/* Function:  Sounds a beep to stderr.  Sending the beep to stderr   */
/*            allows the beep to be heard when the output is         */
/*            redirected.                                            */
/*                                                                   */
/* DEFINED AS A MACRO                                                */
/*********************************************************************/

#define Beep()                                                        \
{                                                                     \
  WriteStderr(BEEPCHAR);                                              \
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\mirror\mir_dtrk.asm ===
; Copyright (c) 1987-1991 Central Point Software, Inc.
; All rights reserved

         PAGE  61,131

         TITLE  PC Tools 6 - Delete Tracking


;  ***  With new Unload-option support.  Feb 1990, GWD.
;  ***  INT 19h & 2Fh hooks.
;
; 03-20-90 GWD  Added 3 checks to ignore attempted delete of READ_ONLY files.
; 03-20-90 GWD  Fixed up all four INT 21h exit paths, better handling of flags.
; 04-23-90 GWD  Fix CHK_DTRK_RESIDENT.  Skip check of segment=CS for res.
; 04-26-90 GWD  Fix CHK_DTRK_RESIDENT again.  Correctly check for last MCB.
; 04-27-90 GWD  Global proc UPPERCASE relocated to resident part.
; ??-??-90 ?	Various non-documented changes for MSoft.
; 12-05-90 GWD	Removed "include datetime.inc", and some unused extrn's.
; 12-18-90 MD   Cleaned up some short jumps
; 1/30/91  SR	M001 -- Check for /1 switch, bug #4999
; 2/1/91   SR	M003 -- Fix lh mirror, bug #4828
; 2/11/91  DLB  M006 -- Added explicit tests for ASSIGN'd, Net, SUBST'd and
;			JOIN'd drives during initialization.
; 2/21/91  DLB  M008 -- Changed DOS_VERSION to be EXTRN.
; 08-12-91 JAH  m012 -- Fixed problem with exiting with interrupts disabled.

        INCLUDE dossym.inc              ;M006
        INCLUDE syscall.inc             ;M006
	INCLUDE sysvar.inc		;M006
        INCLUDE curdir.inc              ;M006


DOSEXEC  MACRO
         INT   21H
         ENDM

DOSFAKE  MACRO
         PUSHF
         CALL  DOS_VECTOR
         ENDM

IVE_TABLE STRUC
IVE_NUMBER            DB ?
IVE_SECTOR_SIZE       DW ?
IVE_SECTORS_PER_CLU   DB ?
IVE_FIRST_FAT_SECTOR  DW ?
IVE_FIRST_ROOT_SECTOR DW ?
IVE_FIRST_DATA_SECTOR DW ?
IVE_SWITCH            DW ?
IVE_CTL_FILE_ENTRIES  DW ?
IVE_TABLE ENDS

FAT_IZ_16_BITS        EQU 8000H

CODE     SEGMENT PARA PUBLIC 'CODE'

         ASSUME CS:CODE
        PUBLIC  start
        PUBLIC  maybe_patch, hook_int_25_26
        PUBLIC  int25_patch, int26_patch, dos_intercept
        PUBLIC  chk_dtrk_resident, saved25, saved26, dos_vector
        PUBLIC  saved19, int19_service
        PUBLIC  saved2F, int2F_service          ;02-23-90 GWD.
        PUBLIC  UPPERCASE

        EXTRN   SAVE_PARTITION:NEAR
        EXTRN   $entry:near             	;M006
        EXTRN   org_id_length:abs  		;In _ORG the module.
        EXTRN   org_id2:byte, org_id2_length:abs
        EXTRN   end_prog:near           	;In MIR_LAST module.
        EXTRN   check_network_drive:near        ;M006
        EXTRN   DOS_VERSION:word                ;M008



DOS_VECTOR LABEL DWORD          ;The saved original INT 21h vector.
DOS_OFF  DW    0
DOS_SEG  DW    0

IN_DOS_DWORD LABEL DWORD
IN_DOS_OFFSET  DW 0
IN_DOS_SEGMENT DW 0

DOS_VERSION_BH DB 0

OLD_DTA_SEG DW    0
OLD_DTA_OFF DW    0

SWITCH                 DW   0
ACTIVE                 EQU  8000H
DELETE_OLD_WAY         EQU  4000H
DELETE_NEW_WAY         EQU  2000H
GIVE_IT_TO_DOS         EQU  1000H
KOULDNT_PROTECT        EQU  0800H
FORCED_TO_ROOT         EQU  0400H
EXTENDED_FCB           EQU  0200H
NO_CLUSTERS_ALLOCATED  EQU  0100H
DELETE_SUB_DIR         EQU  0080H
WE_FOUND_US            EQU  0040H

SAVE_FCB_DRIVE   DB 0

DRIVE_INFO    DB  0
ABOVE_32_MEG  EQU 80H

ABS25_PARM_BLOCK LABEL BYTE
ABS25_SECTOR_LOW     DW  0
ABS25_SECTOR_HIGH    DW  0
ABS25_SECTOR_COUNT   DW  0
ABS25_XFER_ADDR_OFF  DW  0
ABS25_XFER_ADDR_SEG  DW  0

OUR_CTL_ASCIIZ  DB  'x:\PCTRACKR.DEL',0
OUR_CTL_FCBNAME DB  'PCTRACKRDEL'
OUR_CTL_FCBNAME_LEN EQU $-OUR_CTL_FCBNAME

ASCIIZ      DB   73 DUP(0)
ASCIIZ_LEN  EQU  $-ASCIIZ

FIND_FIRST_DTA  DB  50 DUP (0)
         ORG   FIND_FIRST_DTA

;----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R        ;
;                                                                     ;
_FIND_FIRST_30_DRIVE   DB ?             ; drive of search
_FIND_FIRST_30_NAME    DB  11 DUP (?)   ; formatted name
_FIND_FIRST_30_SATTR   DB ?             ; attribute of search
FIND_FIRST_30_LASTENT  DW ?             ; LastEnt
FIND_FIRST_30_DIRSTART DW ?             ; DirStart
_FIND_FIRST_30_NETID   DB 4 DUP (?)     ; Reserved for NET
;         ORG   FIND_FIRST_DTA+13
;FIND_FIRST_20_LASTENT  DW ?             ; LastEnt
         ORG   FIND_FIRST_DTA+19
FIND_FIRST_20_DIRSTART DW ?             ; DirStart
;                                                                     ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R        ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----;

FIND_FIRST_ATTRIBUTE DB  0
FIND_FIRST_TIME      DW  0
FIND_FIRST_DATE      DW  0
FIND_FIRST_SIZE_LOW  DW  0
FIND_FIRST_SIZE_HIGH DW  0
FIND_FIRST_FILE_EXT  DB  13 DUP (0)
         ORG   FIND_FIRST_DTA+50


SAVE_AX     DW   0
SAVE_BX     DW   0
SAVE_CX     DW   0
SAVE_DX     DW   0
SAVE_BP     DW   0
SAVE_SI     DW   0
SAVE_DI     DW   0
SAVE_DS     DW   0
SAVE_ES     DW   0
SAVE_FLAGS  DW   0
CARRY_FLAG  DW   0		; m012


TEMP_FLAGS DW 0

CS_SAVE    DW 0
TWO        DW 2
THIRTY_TWO DW 32

; directory attributes

READ_ONLY EQU  01H
HIDDEN    EQU  02H
SYSTEM    EQU  04H
SUB_DIR   EQU  10H

CTL_HEADER LABEL BYTE
CTL_HEADER_NUM_ENTRIES  DW 0
CTL_HEADER_OLDEST_ENTRY DW 0
CTL_HEADER_LEN EQU $-CTL_HEADER

CTL_FILE_HANDLE  DW 0
CTL_FILE_ASCIIZ_OFFSET DW CTL_FILE_ASCIIZ+3
CLUSTERS_STORED_END    DW 0

CTL_FILE_ENTRY LABEL BYTE
CTL_FILE_IND   DB 0
CTL_FIRST      EQU 80H
CTL_LAST       EQU 40H
CTL_EMPTY      EQU 20H
CTL_CLEAR      EQU NOT CTL_FIRST+CTL_LAST+CTL_EMPTY
CTL_SUB_DIR    EQU 10H
CTL_ATTR       DB 0
CTL_TIME       DW 0
CTL_DATE       DW 0
CTL_SIZE_LO    DW 0
CTL_SIZE_HI    DW 0
CTL_TIME_DEL   DW 0
CTL_DATE_DEL   DW 0
CTL_INFO_CONT EQU $
CTL_FILE_ASCIIZ DB 128 DUP (0)
CTL_INFO       DW 20 DUP(0)
CTL_FILE_END   EQU $
CTL_FILE_ENTRY_LEN EQU $-CTL_FILE_ENTRY


FAT_SECTOR       DW 0
FAT_AREA_PTR     DW 0
IO_AREA_PTR      DW DOS_INTERCEPT_END
LARGEST_SECTOR   DW 512

INSTALL_SWITCH   DB 0
GOT_SUMTHIN_TO_TRACK EQU 80H
WINDOWS_PRESENT      EQU 40H
ASSIGN_RESIDENT      EQU 20H
GOT_SLASH_TEE        EQU 10H
DO_IT_THE_SLOW_WAY   EQU 08H

DRIVES_GIVEN_TABLE DW 26 DUP(0FFFFH)
;        One word for each drive letter. If FFFF, ignore the drive.
;        If zero, use Delete Tracker file if found as iz. Otherwise,
;        ignore. If a value is specified, use this as the number of
;        entries for the file when creating.
;

DR       IVE_TABLE <>

DIR_ENT_ATTR EQU 11
DIR_ENT_TIME EQU 22
DIR_ENT_DATE EQU 24
DIR_ENT_CLU  EQU 26
DIR_ENT_SZLO EQU 28
DIR_ENT_SZHI EQU 30



DOS_INTERCEPT PROC FAR
         CLI

         PUSHF                          ;3-20-90 GWD.
         POP   TEMP_FLAGS               ;Saved flags have IF=0 (disabled).

         TEST  SWITCH,ACTIVE
         JNZ   DOS_INTERCEPT_BAILOUT

         CMP   AH,41H                   ; new style delete request?
         JE    NEW_WAY_TO_DELETE        ; yep
         CMP   AH,13H                   ; old style?
         JE    OLD_WAY_TO_DELETE        ; yep
         CMP   AH,3AH                   ; remove a sub-directory?
         JE    REMOVE_SUB_DIR           ; yep

DOS_INTERCEPT_BAILOUT:
         PUSH  TEMP_FLAGS
         POPF
         JMP   DWORD PTR DOS_VECTOR     ; on to DOS (or other trappeurs)

REMOVE_SUB_DIR:
         CALL  ENTERING_CRITICAL_SECTION

         MOV   SWITCH,DELETE_SUB_DIR+ACTIVE ; show how to dew it
         JMP   SHORT DEW_IT

OLD_WAY_TO_DELETE:
         CALL  ENTERING_CRITICAL_SECTION

         MOV   SWITCH,DELETE_OLD_WAY+ACTIVE ; show how to dew it
         JMP   SHORT DEW_IT

NEW_WAY_TO_DELETE:
         CALL  ENTERING_CRITICAL_SECTION

         MOV   SWITCH,DELETE_NEW_WAY+ACTIVE ; show how to dew it

DEW_IT:
         TEST  INSTALL_SWITCH,ASSIGN_RESIDENT
         JNZ   ASSIGN_ALREADY_RESIDENT
         CALL  HAS_ASSIGN_BEEN_INSTALLED
         JNE   ASSIGN_ALREADY_RESIDENT
;         CALL  BEEP                    ;M006: Disable useless feedback.
         MOV   SWITCH,0

         CALL  LEAVING_CRITICAL_SECTION

         JMP   DOS_INTERCEPT_BAILOUT

ASSIGN_ALREADY_RESIDENT:
         MOV   CTL_FILE_HANDLE,0        ;
         MOV   SAVE_AX,AX
         MOV   SAVE_BX,BX
         MOV   SAVE_CX,CX
         MOV   SAVE_DX,DX
         MOV   SAVE_SI,SI
         MOV   SAVE_BP,BP
         MOV   SAVE_DI,DI
         MOV   SAVE_DS,DS
         MOV   SAVE_ES,ES
         MOV   AX,TEMP_FLAGS
         MOV   SAVE_FLAGS,AX

         STI
         CLD

; save current DTA

         MOV   AH,2FH                   ; get curr DTA
         DOSFAKE
         MOV   OLD_DTA_SEG,ES           ; save segment
         MOV   OLD_DTA_OFF,BX           ; save offset

         MOV   DS,CS_SAVE               ; prime
         MOV   ES,CS_SAVE               ;  'em

         TEST  SWITCH,DELETE_OLD_WAY    ; dewin' a 13H delete?
         JNZ   DEW_IT_OLD_WAY           ; yup
         JMP   DEW_IT_NEW_WAY           ; nope

DEW_IT_OLD_WAY:
         CALL  CHECK_IF_WE_SHOULD_HANDLE_OLD
         JNC   HANDLE_IT_OLD            ; keep goin'
         OR    SWITCH,GIVE_IT_TO_DOS    ; sew that we'll exit rite
         JMP   CLEAN_UP_AND_LEAVE

HANDLE_IT_OLD:
         CALL  SEE_IF_FILE_EXISTS_OLD   ; see ifin it's out there
         JNC   GET_US_OLD               ; keep goin'

         TEST  SWITCH,WE_FOUND_US       ; were we the only one?
         JNZ   GET_US_OLD_BYPASS        ; yup, forget it
         OR    SWITCH,GIVE_IT_TO_DOS    ; sew that we'll exit rite

GET_US_OLD_BYPASS:
         JMP   CLEAN_UP_AND_LEAVE

GET_US_OLD:
         CALL  MAKE_SURE_OUR_FILE_IZ_THERE ; verify/create our dir
         JNC   GET_CLU_OLD             ; all's well

         OR    SWITCH,GIVE_IT_TO_DOS    ; sew that we'll exit rite
         OR    SWITCH,KOULDNT_PROTECT   ; can't protect!
         JMP   CLEAN_UP_AND_LEAVE

GET_CLU_OLD:
         CALL  GET_CLUSTERS_OLD         ; get our ctl file set
         JNC   DELETE_OLD

         OR    SWITCH,GIVE_IT_TO_DOS    ; sew that we'll exit rite
         OR    SWITCH,KOULDNT_PROTECT   ; can't protect!
         JMP   SHORT CHECK_FOR_OTHERS

DELETE_OLD:
         TEST  INSTALL_SWITCH,DO_IT_THE_SLOW_WAY
         JNZ   DELETE_OLD_SLOW

         CALL  GET_TIME_STAMP
         JMP   SHORT UPDATE_CTL_OLD

DELETE_OLD_SLOW:
         CALL  DELETE_IT_OLD            ; dew sum shuckin' & jivin'
         JNC   UPDATE_CTL_OLD           ; all's well

         OR    SWITCH,GIVE_IT_TO_DOS    ; sew that we'll exit rite
         OR    SWITCH,KOULDNT_PROTECT   ; can't protect!
         JMP   SHORT CHECK_FOR_OTHERS

UPDATE_CTL_OLD:
         CALL  UPDATE_CTL_FILE          ; update fur next time
         JNC   CHECK_FOR_OTHERS
         OR    SWITCH,KOULDNT_PROTECT   ; can't protect!

CHECK_FOR_OTHERS:
         CALL  SEE_IF_THERE_ARE_OTHERS  ; go see if wildcard wuz used
         JNC   GET_CLU_OLD              ; there's more!

         TEST  INSTALL_SWITCH,DO_IT_THE_SLOW_WAY
         JNZ   DELETE_OLD_SLOW_THRU
         OR    SWITCH,GIVE_IT_TO_DOS    ; sew that we'll exit rite

DELETE_OLD_SLOW_THRU:
         JMP   SHORT CLEAN_UP_AND_LEAVE



DEW_IT_NEW_WAY:
         CALL  CHECK_IF_WE_SHOULD_HANDLE_NEW
         JNC   HANDLE_IT_NEW            ; keep goin'
         OR    SWITCH,GIVE_IT_TO_DOS    ; sew that we'll exit rite
         JMP   SHORT CLEAN_UP_AND_LEAVE

HANDLE_IT_NEW:
         CALL  SEE_IF_FILE_EXISTS_NEW   ; see ifin it's out there
         JNC   GET_US_NEW               ; keep goin'
         TEST  SWITCH,WE_FOUND_US       ; were we the only one?
         JNZ   GET_US_NEW_BYPASS        ; yup, forget it
         OR    SWITCH,GIVE_IT_TO_DOS    ; sew that we'll exit rite
         JMP   SHORT CLEAN_UP_AND_LEAVE

GET_US_NEW:
         CALL  MAKE_SURE_OUR_FILE_IZ_THERE ; verify/create our dir
         JNC   GET_CLU_NEW              ; all's well
         OR    SWITCH,GIVE_IT_TO_DOS    ; sew that we'll exit rite
         OR    SWITCH,KOULDNT_PROTECT   ; can't protect!

GET_US_NEW_BYPASS:
         JMP   SHORT CLEAN_UP_AND_LEAVE

GET_CLU_NEW:
         CALL  GET_CLUSTERS_NEW
         JNC   DEW_DELETE_NEW
         OR    SWITCH,KOULDNT_PROTECT   ; can't protect!
         OR    SWITCH,GIVE_IT_TO_DOS    ; sew that we'll exit rite
         JMP   SHORT CLEAN_UP_AND_LEAVE

DEW_DELETE_NEW:
         CALL  DELETE_IT_NEW
         JNC   UPDATE_CTL_NEW

         TEST  SWITCH,DELETE_SUB_DIR    ; is for a sub_dir?
         JNZ   DEL_DELETE_NEW_CONT      ; yes, forget honking
         OR    SWITCH,KOULDNT_PROTECT   ; no, gotta honk

DEL_DELETE_NEW_CONT:
         OR    SWITCH,GIVE_IT_TO_DOS    ; sew that we'll exit rite
         JMP   SHORT CLEAN_UP_AND_LEAVE ; didn't work

UPDATE_CTL_NEW:
         CALL  UPDATE_CTL_FILE
         JNC   CLEAN_UP_AND_LEAVE
         OR    SWITCH,KOULDNT_PROTECT   ; can't protect!



CLEAN_UP_AND_LEAVE:
         CMP   CTL_FILE_HANDLE,0        ; file closed?
         JE    SHOULD_WE_BEEP

         MOV   BX,CTL_FILE_HANDLE       ; grab handle
         MOV   AH,3EH                   ; close
         DOSFAKE
         MOV   CTL_FILE_HANDLE,0        ;

SHOULD_WE_BEEP:
         TEST  SWITCH,KOULDNT_PROTECT   ; couldn't protect?
         JZ    NO_BEEP                  ; nope, all wuz well
         TEST  SWITCH,NO_CLUSTERS_ALLOCATED ; couldn't protect but
         JNZ   NO_BEEP                  ; who cares

;         CALL  BEEP                    ;M006: Disable useless feedback.

NO_BEEP:

; restore DTA where it wuz when we started this mess

         MOV   DS,OLD_DTA_SEG           ; saved segment
         MOV   DX,OLD_DTA_OFF           ; saved offset
         MOV   AH,1AH                   ; set DTA
         DOSFAKE

         MOV   AH,0DH                   ; flush buffers
         DOSFAKE

         MOV   AX,SAVE_AX
         MOV   BX,SAVE_BX
         MOV   CX,SAVE_CX
         MOV   DX,SAVE_DX
         MOV   BP,SAVE_BP
         MOV   SI,SAVE_SI
         MOV   DI,SAVE_DI
         MOV   DS,SAVE_DS
         MOV   ES,SAVE_ES

; There are three possible exit paths -
; (1) Pass onward to DOS, (2) return with AL=0 or (3) return with CF=0.

         CLI
         TEST  SWITCH,GIVE_IT_TO_DOS    ; sew that we'll exit rite
;;* GWD  MOV   SWITCH,0                 ;Shut off re-entrancy protection.
         JNZ   GO_TO_DOS                ; let DOS handle missing file

         test  switch,delete_old_way   ;3-20-90 GWD.
         jnz   go_back_to_caller_old

; Function was new delete (41h) or RMDIR (3Ah).

         MOV   SWITCH,0         ;Shut off re-entrancy protection.

         CALL  LEAVING_CRITICAL_SECTION

         push  bp              ;3-20-90 GWD.
         mov   bp,sp           ;On stack - BP, IP, CS, Flags.
         and   word ptr [bp+6], NOT 1  ;Clear carry flag bit image.
         pop   bp
         iret

go_back_to_caller_old:          ;Function was old delete (13h).
         mov   al,0             ;Return AL = 0 (success).
         MOV   SWITCH,0         ;Shut off re-entrancy protection.

         CALL  LEAVING_CRITICAL_SECTION

         iret

; removed, 3-20-90 GWD
;        MOV   AX,0                     ; sew return code iz clean
;        PUSH  SAVE_FLAGS               ; saved frags onto stack
;        POPF                           ; pop 'em
;        CLC                            ; assure no carry set
;        STI
;        RET   2                        ; return to interuptee


GO_TO_DOS:
         PUSH  SAVE_FLAGS
         POPF
         MOV   SWITCH,0                 ;Shut off re-entrancy protection.

;	M007 -- note: The old code here left a nasty hole in the
;			critical section handling that would allow a file
;			to be lost if another process was undeleting it
;			while we're deleting it.

;M007         CALL  LEAVING_CRITICAL_SECTION
;M007
;M007         JMP   DWORD PTR DOS_VECTOR     ; on to DOS

	dosfake				; call through to DOS
	pushf				; save those flags
	call	LEAVING_CRITICAL_SECTION ; then restore crit section

		; m012 Fixed bug with leaving interrupts disabled
		; m012 when do "ret 02" by setting the carry bit in the
		; m012 int 21h caller's original flags on the stack
;m012	popf				; get DOS's return flags back
;m012	ret	2			; and return to caller

	pop	CARRY_FLAG		; m012 Get return flags from DOS call
					; m012
	push	BP			; m012 Address int 21h caller's flags
	mov	BP,SP			; m012

	push	AX			; m012 
	mov	AX,CARRY_FLAG		; m012 Get flags from int 21h call
	and	AX,1			; m012 Mask off the carry flag

	and	[BP+6], NOT 1		; m012 Clear carry in caller's flags
	or	[BP+6],AX		; m012 Now to carry from int 21h call
	pop	AX			; m012

	pop	BP			; m012
	iret				; m012 

;	M007 -- end modifications


DOS_INTERCEPT ENDP



ENTERING_CRITICAL_SECTION PROC NEAR
         PUSH  AX
         TEST  INSTALL_SWITCH,WINDOWS_PRESENT
         JZ    E_C_S_EXIT

         MOV   AX,1681H
         INT   2FH
         TEST  AL,AL
         JZ    E_C_S_EXIT

         PUSH  ES
         PUSH  BX
         LES   BX,IN_DOS_DWORD
         INC   BYTE PTR ES:[BX]
         POP   BX
         POP   ES

E_C_S_EXIT:

	mov	ah,0dh		; M007	; Force disk reset to synchronize!
	dosfake			; M007

         POP   AX
         RET

ENTERING_CRITICAL_SECTION ENDP



LEAVING_CRITICAL_SECTION PROC NEAR
         PUSH  AX

	mov	ah,0dh		; M007	; Force disk reset to syncrhonize!
	dosfake			; M007

         TEST  INSTALL_SWITCH,WINDOWS_PRESENT
         JZ    L_C_S_EXIT

         MOV   AX,1682H
         INT   2FH
         TEST  AL,AL
         JZ    L_C_S_EXIT

         PUSH  ES
         PUSH  BX
         LES   BX,IN_DOS_DWORD
         CMP   BYTE PTR ES:[BX],0
         JE    L_C_S_NO_DEC

         DEC   BYTE PTR ES:[BX]

L_C_S_NO_DEC:
         POP   BX
         POP   ES

L_C_S_EXIT:
         POP   AX
         RET

LEAVING_CRITICAL_SECTION ENDP



HAS_ASSIGN_BEEN_INSTALLED PROC NEAR
         PUSH  AX
         PUSH  DS
         MOV   AX,0
         CMP   DOS_VERSION,0300H
         JB    HAS_BEEN_FOUND
         MOV   DS,AX
         CMP   WORD PTR DS:[2FH*4],0
         JNE   HAS_BEEN_CHK
         CMP   WORD PTR DS:[2FH*4]+2,0
         JNE   HAS_BEEN_CHK
         JMP   SHORT HAS_BEEN_FOUND

HAS_BEEN_CHK:
         MOV   AX,0600H
         INT   2FH                      ; iz ASSIGN resident?

HAS_BEEN_FOUND:
         CMP   AL,0FFH
         POP   DS
         POP   AX
         RET

HAS_ASSIGN_BEEN_INSTALLED ENDP


IF 0 ;M006: Extraneous.
BEEP     PROC  NEAR
         PUSH  AX
         PUSH  BX
         PUSH  CX
         PUSH  DX
         PUSH  SI
         PUSH  DI
         PUSH  BP
         MOV   BX,0
         MOV   AX,0E07H
         INT   10H
         MOV   BX,0
         MOV   AX,0E07H
         INT   10H
         POP   BP
         POP   DI
         POP   SI
         POP   DX
         POP   CX
         POP   BX
         POP   AX
         RET

BEEP     ENDP
ENDIF ;M006



CHECK_IF_WE_SHOULD_HANDLE_NEW PROC NEAR
         PUSH  ES
         PUSH  DS
         PUSH  SI
         MOV   DS,SAVE_DS               ; get his DS
         MOV   SI,SAVE_DX               ; get his DX
         CMP   BYTE PTR [SI+1],':'      ; drive given?
         JNE   CHECK_IF_DEFAULT_DRIVE
         MOV   AL,[SI]                  ; get drive letter
         CALL  UPPERCASE
         CMP   AL,'A'
         JB    CHECK_IF_WE_SHOULD_HANDLE_STC_JMP
         CMP   AL,'Z'
         JA    CHECK_IF_WE_SHOULD_HANDLE_STC_JMP
         CMP   BYTE PTR [SI+2],'\'      ; root forced?
         JE    CHECK_SETUP_GOTTA_SLASH
         CMP   BYTE PTR [SI+2],'/'      ; root forced?
         JNE   CHECK_SETUP_DRIVE

CHECK_SETUP_GOTTA_SLASH:
         OR    SWITCH,FORCED_TO_ROOT
         JMP   SHORT CHECK_SETUP_DRIVE

CHECK_IF_WE_SHOULD_HANDLE_STC_JMP:
         JMP   SHORT CHECK_IF_WE_SHOULD_HANDLE_NEW_STC

CHECK_IF_DEFAULT_DRIVE:
         MOV   AH,19H
         DOSFAKE
         ADD   AL,41H
         CMP   BYTE PTR [SI],'\'        ; forced to root?
         JE    CHECK_SETUP_GOTTA_SLASH_1
         CMP   BYTE PTR [SI],'/'        ; forced to root?
         JNE   CHECK_SETUP_DRIVE

CHECK_SETUP_GOTTA_SLASH_1:
         OR    SWITCH,FORCED_TO_ROOT

CHECK_SETUP_DRIVE:
         CALL  SETUP_DRIVE
         JC    CHECK_IF_WE_SHOULD_HANDLE_NEW_STC

         TEST  SWITCH,FORCED_TO_ROOT
         JNZ   CHECK_IF_CLC
         MOV   DS,CS_SAVE
         MOV   SI,CTL_FILE_ASCIIZ_OFFSET
         MOV   DL,DR.IVE_NUMBER
         INC   DL
         MOV   AH,47H
         DOSFAKE
         MOV   AL,0
         MOV   DI,CTL_FILE_ASCIIZ_OFFSET
         MOV   ES,CS_SAVE

         CMP   AL,ES:[DI]               ; at root?
         JE    CHECK_IF_CLC

         MOV   CX,125
         REPNE SCASB
         JNE   CHECK_IF_WE_SHOULD_HANDLE_NEW_STC
         MOV   BYTE PTR ES:[DI-1],'\'
         MOV   CTL_FILE_ASCIIZ_OFFSET,DI

CHECK_IF_CLC:
         CLC
         JMP   SHORT CHECK_NEW_EXIT

CHECK_IF_WE_SHOULD_HANDLE_NEW_STC:
         STC

CHECK_NEW_EXIT:
         POP   SI
         POP   DS
         POP   ES
         RET

CHECK_IF_WE_SHOULD_HANDLE_NEW ENDP



CHECK_IF_WE_SHOULD_HANDLE_OLD PROC NEAR
         PUSH  ES
         PUSH  DS
         PUSH  SI
         MOV   DS,SAVE_DS               ; get his DS
         MOV   SI,SAVE_DX               ; get his DX
         CMP   BYTE PTR [SI],0FFH       ; extended FCB?
         JNE   CHECK_OLD_NON_EXTENDED
         OR    SWITCH,EXTENDED_FCB
         MOV   AL,[SI]+7                ; get drive
         JMP   SHORT CHECK_OLD_DRIVE

CHECK_OLD_NON_EXTENDED:
         MOV   AL,[SI]                  ; get drive

CHECK_OLD_DRIVE:
         CMP   AL,0
         JNE   CHECK_OLD_GOT_DRIVE
         MOV   AH,19H
         DOSFAKE
         INC   AL

CHECK_OLD_GOT_DRIVE:
         ADD   AL,40H

         CALL  SETUP_DRIVE
         JC    CHECK_IF_WE_SHOULD_HANDLE_OLD_STC

         MOV   DS,CS_SAVE
         MOV   SI,CTL_FILE_ASCIIZ_OFFSET
         MOV   DL,DR.IVE_NUMBER
         INC   DL
         MOV   AH,47H
         DOSFAKE
         MOV   AL,0
         MOV   DI,CTL_FILE_ASCIIZ_OFFSET
         MOV   ES,CS_SAVE

         CMP   AL,ES:[DI]               ; at root?
         JE    CHECK_OLD_IF_CLC

         MOV   CX,125
         REPNE SCASB
         JNE   CHECK_IF_WE_SHOULD_HANDLE_OLD_STC
         MOV   BYTE PTR ES:[DI-1],'\'
         MOV   CTL_FILE_ASCIIZ_OFFSET,DI

CHECK_OLD_IF_CLC:
         CLC
         JMP   SHORT CHECK_OLD_EXIT

CHECK_IF_WE_SHOULD_HANDLE_OLD_STC:
         STC

CHECK_OLD_EXIT:
         POP   SI
         POP   DS
         POP   ES
         RET

CHECK_IF_WE_SHOULD_HANDLE_OLD ENDP



CLEAR_CTL_FILE_ENTRY PROC NEAR
         PUSH  ES
         PUSH  DI
         PUSH  CX
         MOV   ES,CS_SAVE
         LEA   DI,CTL_FILE_ENTRY
         MOV   CX,CTL_FILE_ENTRY_LEN
         PUSH  AX
         MOV   AL,0
         REP   STOSB
         POP   AX

         MOV   OUR_CTL_ASCIIZ,AL
         MOV   CTL_FILE_ASCIIZ,AL
         MOV   WORD PTR CTL_FILE_ASCIIZ+1,'\:'
         MOV   CTL_FILE_ASCIIZ_OFFSET,OFFSET CTL_FILE_ASCIIZ+3

         POP   CX
         POP   DI
         POP   ES
         RET

CLEAR_CTL_FILE_ENTRY ENDP



SETUP_DRIVE PROC NEAR
         PUSH  DS
         PUSH  BX

         SUB   AL,40H
         MOV   DL,AL
         MOV   AH,32H
         DOSFAKE
         CMP   AL,0FFH
         JE    SETUP_DRIVE_STC_JMP

         MOV   AL,[BX]                  ; This will cure assigning
         MOV   DR.IVE_NUMBER,AL
         ADD   AL,41H

         CALL  DRIVE_SUPPORTED
         JNC   SETUP_DRIVE_SUPPORTED

SETUP_DRIVE_STC_JMP:
         JMP   SETUP_DRIVE_STC

SETUP_DRIVE_SUPPORTED:
         CALL  CLEAR_CTL_FILE_ENTRY

         CALL  CHECK_FOR_BIG_HARD_DRIVE

         CMP   DR.IVE_CTL_FILE_ENTRIES,0
         JNE   SETUP_DRIVE_CONT

         MOV   AX,[BX+13]               ; get total clu count +1
         DEC   AX
         MOV   CH,0
         MOV   CL,[BX+4]                ; get sectors/clu -1
         INC   CX
         MUL   CX                       ; get # sectors

         MOV   DR.IVE_CTL_FILE_ENTRIES,303
         CMP   DX,0                     ; already too big?
         JNE   SETUP_DRIVE_CONT

         MOV   DX,WORD PTR [BX+2]       ; get bytes per sector
         MOV   CL,9
         SHR   DX,CL
         MUL   DX

; for 360K or less       25             4K  LE   2D0H 512 byte sectors
;     720K               50             8K  GT   2D0H 512 byte sectors
;     1.2Meg             75            12K  GT   5A0H 512 byte sectors
;     1.44Meg            75            12K
;     less than 20Meg   101            16K  GT   B40H 512 byte sectors
;     up to 32M         202            32K  GT  A000H 512 byte sectors
;     Over 32M          303            48K  GT 10000H 512 byte sectors

         CMP   DX,0
         JNE   SETUP_DRIVE_CONT
         MOV   DR.IVE_CTL_FILE_ENTRIES,202
         CMP   AX,0A000H
         JA    SETUP_DRIVE_CONT
         MOV   DR.IVE_CTL_FILE_ENTRIES,101
         CMP   AX,0B40H
         JA    SETUP_DRIVE_CONT
         MOV   DR.IVE_CTL_FILE_ENTRIES,75
         CMP   AX,05A0H
         JA    SETUP_DRIVE_CONT
         MOV   DR.IVE_CTL_FILE_ENTRIES,50
         CMP   AX,02D0H
         JA    SETUP_DRIVE_CONT
         MOV   DR.IVE_CTL_FILE_ENTRIES,25

SETUP_DRIVE_CONT:
         MOV   AX,[BX+2]                ; get sector size
         CMP   LARGEST_SECTOR,AX        ; can't support
         JB    SETUP_DRIVE_STC          ; if too large
         MOV   DR.IVE_SECTOR_SIZE,AX

         MOV   AL,[BX+4]                ; get sectors per clu minus one
         INC   AL
         MOV   DR.IVE_SECTORS_PER_CLU,AL

         MOV   AX,[BX+6]                ; get number reserved (boot +)
         MOV   DR.IVE_FIRST_FAT_SECTOR,AX
         MOV   FAT_SECTOR,0FFFFH        ; invalidate in-memory sector #

         MOV   AX,[BX+11]               ; get first data sector
         MOV   DR.IVE_FIRST_DATA_SECTOR,AX

         MOV   DR.IVE_SWITCH,0
         MOV   AX,[BX+13]               ; get total clu count + 1
         CMP   AX,4086
         JNA   SETUP_DRIVE_12_BITS
         OR    DR.IVE_SWITCH,FAT_IZ_16_BITS

SETUP_DRIVE_12_BITS:
         CMP   DOS_VERSION,0400H        ; DOS 4.00 or greater?
         JAE   SETUP_DRIVE_DOS_40       ; NO
         MOV   AX,[BX+16]               ; get first root dir sector
         MOV   DR.IVE_FIRST_ROOT_SECTOR,AX
         JMP   SHORT SETUP_DRIVE_CLC

SETUP_DRIVE_DOS_40:
         MOV   AX,[BX+17]               ; get first root dir sector
         MOV   DR.IVE_FIRST_ROOT_SECTOR,AX

SETUP_DRIVE_CLC:
         CLC
         JMP   SHORT SETUP_DRIVE_EXIT

SETUP_DRIVE_STC:
         STC

SETUP_DRIVE_EXIT:
         POP   BX
         POP   ES
         RET

SETUP_DRIVE ENDP



DRIVE_SUPPORTED PROC NEAR
         PUSH  DS
         PUSH  SI
         PUSH  AX
         PUSH  BX
         PUSH  DX
         MOV   DS,CS_SAVE
         MOV   BX,AX
         SUB   AL,41H
         MOV   AH,0
         SHL   AL,1
         LEA   SI,DRIVES_GIVEN_TABLE
         ADD   SI,AX

         MOV   AX,[SI]
         MOV   DR.IVE_CTL_FILE_ENTRIES,AX
         CMP   AX,0FFFFH                ; forget it?
         JE    DRIVE_SUPP_STC

         CMP   DOS_VERSION,030AH        ; DOS 3.10 or higher?
         JB    DRIVE_SUPP_CLC           ; no, branch
         MOV   AX,4409H                 ; see if NETWORK drive
         SUB   BL,40H
         MOV   DX,0
         DOSFAKE
         TEST  DX,1200H                 ; iz drive remote or network?
         JNZ   DRIVE_SUPP_NO_SUPP       ; yes, don't support it
         TEST  DX,8000H                 ; iz drive SUBSTed?
         JZ    DRIVE_SUPP_CLC           ; yes, don't support it

DRIVE_SUPP_NO_SUPP:
         OR    SWITCH,KOULDNT_PROTECT   ; couldn't protect?
         JMP   SHORT DRIVE_SUPP_STC     ; yes, don't support it

DRIVE_SUPP_CLC:
         CLC
         JMP   SHORT DRIVE_SUPP_EXIT

DRIVE_SUPP_STC:
         STC

DRIVE_SUPP_EXIT:
         POP   DX
         POP   BX
         POP   AX
         POP   SI
         POP   DS
         RET
DRIVE_SUPPORTED ENDP



MAKE_SURE_OUR_FILE_IZ_THERE PROC NEAR
         LEA   DX,OUR_CTL_ASCIIZ        ; to ASCIIZ string for dir
         MOV   AX,4301H                 ; open read/write
         MOV   CX,SYSTEM
         DOSFAKE                        ;
         JC    MAKE_SURE_FILE_OPEN_NO_FILE
         JMP   MAKE_SURE_FILE_OPEN

MAKE_SURE_FILE_OPEN_NO_FILE:
         MOV   BP,DR.IVE_CTL_FILE_ENTRIES
         CALL  ROUND_COUNT_TO_CLU

         LEA   DX,OUR_CTL_ASCIIZ        ; to ASCIIZ string for dir
         MOV   AX,3C00H                 ; open read/write
         MOV   CX,SYSTEM
         DOSFAKE                        ;
         JC    MAKE_SURE_BUILD_CLOSE
         MOV   BX,AX

         MOV   AX,DR.IVE_CTL_FILE_ENTRIES
         MOV   CTL_HEADER_NUM_ENTRIES,AX
         MOV   CTL_HEADER_OLDEST_ENTRY,0
         MOV   AH,40H
         MOV   CX,CTL_HEADER_LEN
         LEA   DX,CTL_HEADER
         MOV   DS,CS_SAVE
         DOSFAKE
         JC    MAKE_SURE_BUILD_CLOSE
         CMP   AX,CX
         JNE   MAKE_SURE_BUILD_CLOSE
         OR    CTL_FILE_IND,CTL_EMPTY

MAKE_SURE_BUILD_LOOP:
         MOV   AH,40H
         MOV   CX,CTL_FILE_ENTRY_LEN
         LEA   DX,CTL_FILE_ENTRY
         DOSFAKE
         JC    MAKE_SURE_BUILD_CLOSE
         CMP   AX,CX
         JNE   MAKE_SURE_BUILD_CLOSE
         DEC   BP
         JNZ   MAKE_SURE_BUILD_LOOP

MAKE_SURE_BUILD_CLOSE:
         MOV   CTL_FILE_IND,0
         MOV   AH,3EH
         DOSFAKE
         CMP   BP,0
         JE    MAKE_SURE_FILE_OPEN

         MOV   AH,41H
         LEA   DX,OUR_CTL_ASCIIZ
         DOSFAKE                        ; delete the control file

MAKE_SURE_BUILD_STC:
         STC
         JMP   SHORT MAKE_SURE_EXIT


MAKE_SURE_FILE_OPEN:
         LEA   DX,OUR_CTL_ASCIIZ        ; to ASCIIZ string for dir
         MOV   AX,3D02H                 ; open read/write
         DOSFAKE                        ;
         JC    MAKE_SURE_EXIT
         MOV   CTL_FILE_HANDLE,AX

         MOV   BX,AX
         MOV   AH,3FH
         MOV   CX,CTL_HEADER_LEN
         LEA   DX,CTL_HEADER
         DOSFAKE
         JC    MAKE_SURE_BUILD_STC
         CMP   AX,CX
         JE    MAKE_SURE_CLC
         JMP   MAKE_SURE_FILE_OPEN_NO_FILE      ;per Jim, GWD 01-05-89.

MAKE_SURE_CLC:
         CLC

MAKE_SURE_EXIT:
         RET

MAKE_SURE_OUR_FILE_IZ_THERE ENDP



ROUND_COUNT_TO_CLU PROC NEAR
         PUSH  DS
         PUSH  AX
         PUSH  BX
         PUSH  CX
         PUSH  DX

         MOV   AX,CTL_FILE_ENTRY_LEN
         MUL   BP
         ADD   AX,4
         ADC   DX,0
         PUSH  AX
         PUSH  DX

         MOV   DL,OUR_CTL_ASCIIZ
         SUB   DL,40H
         MOV   AH,1CH
         DOSFAKE
         MOV   AH,0
         MUL   CX
         MOV   BX,AX
         CMP   BX,0
         POP   DX
         POP   AX
         JE    R_C_T_C_EXIT

         DIV   BX
         MOV   AX,DX                    ; get remainder
         MOV   DX,0
         MOV   BX,CTL_FILE_ENTRY_LEN
         DIV   BX

R_C_T_C_EXIT:
         POP   DX
         POP   CX
         POP   BX
         POP   AX
         POP   DS
         RET

ROUND_COUNT_TO_CLU ENDP



SEE_IF_FILE_EXISTS_NEW PROC NEAR
         LEA   DI,ASCIIZ                ; we'll copy his ASCIIZ there
         MOV   DS,SAVE_DS               ; get his DS
         MOV   SI,SAVE_DX               ; get his DX
         MOV   CX,ASCIIZ_LEN            ;
         REP   MOVSB                    ; copy to our area

         MOV   DS,CS_SAVE               ; over here
         LEA   DX,FIND_FIRST_DTA        ; area FIND FIRST will use
         MOV   AH,1AH                   ; set DTA
         DOSFAKE

         LEA   DX,ASCIIZ                ; to ASCIIZ string for file
         MOV   CX,HIDDEN+SYSTEM         ; wanna see 'em all
         TEST  SWITCH,DELETE_SUB_DIR
         JZ    SEE_IF_FILE_EXISTS_NOT_SUB_DIR
         OR    CX,SUB_DIR               ; wanna see 'em all

SEE_IF_FILE_EXISTS_NOT_SUB_DIR:
         MOV   AH,4EH                   ; find first
         DOSFAKE
         JNC   SEE_IF_EXISTS_NEW_AGAIN
         JMP   SEE_IF_EXISTS_EXIT

SEE_IF_EXISTS_NEW_AGAIN:
         TEST  SWITCH,DELETE_SUB_DIR
         JZ    SEE_IF_FILE_EXISTS_IZNT_SUB_DIR
         TEST  FIND_FIRST_ATTRIBUTE,SUB_DIR
         JZ    SEE_IF_EXISTS_NEXT
         JMP   SHORT SEE_IF_FILE_EXISTS_CONT

SEE_IF_FILE_EXISTS_IZNT_SUB_DIR:
         TEST  FIND_FIRST_ATTRIBUTE,SUB_DIR
         JZ    SEE_IF_FILE_EXISTS_CONT

SEE_IF_EXISTS_NEXT:
         MOV   AH,4FH                   ; find next
         DOSFAKE
         JC    SEE_IF_EXISTS_EXIT
         JMP   SEE_IF_EXISTS_NEW_AGAIN

SEE_IF_FILE_EXISTS_CONT:
         CALL  IZ_IT_US_NEW
         JC    SEE_IF_EXISTS_NEXT
         CALL  IZ_IT_IGNORED_NEW
         JC    SEE_IF_EXISTS_NEXT
         MOV   AL,FIND_FIRST_ATTRIBUTE
         TEST  AL,READ_ONLY             ;GWD 03-20-90.  Per Jim.
         JNZ   SEE_IF_EXISTS_NEXT

         MOV   CTL_ATTR,AL
         MOV   AX,FIND_FIRST_TIME
         MOV   CTL_TIME,AX
         MOV   AX,FIND_FIRST_DATE
         MOV   CTL_DATE,AX
         MOV   AX,FIND_FIRST_SIZE_LOW
         MOV   CTL_SIZE_LO,AX
         MOV   AX,FIND_FIRST_SIZE_HIGH
         MOV   CTL_SIZE_HI,AX

         MOV   ES,CS_SAVE
         LEA   DI,ASCIIZ
         MOV   AL,0
         CMP   ASCIIZ+1,':'
         JNE   SEE_IF_SKIP_DRIVE
         ADD   DI,2

SEE_IF_SKIP_DRIVE:
         PUSH  DI
         MOV   CX,ASCIIZ_LEN
         REPNE SCASB
         POP   CX
         JNE   SEE_IF_EXISTS_EXIT
         XCHG  DI,CX
         SUB   CX,DI
         MOV   SI,DI
         MOV   DI,CTL_FILE_ASCIIZ_OFFSET

         TEST  SWITCH,FORCED_TO_ROOT
         JZ    SEE_IF_NOT_FORCED
         LEA   DI,CTL_FILE_ASCIIZ+2

SEE_IF_NOT_FORCED:
         REP   MOVSB
         CLC

SEE_IF_EXISTS_EXIT:
         RET

SEE_IF_FILE_EXISTS_NEW ENDP



;--------------------------------------------------
; This is a kluge to overcome a bug in DOS 2.x
; Function call # 11h (& probably 12h) corrupt
; the caller's FCB.  So we prevent that.  GWD 02-05-89.
;
; On entry: AH=11h or 12h, DS:DX points to an FCB.
;
; On exit: AX = whatever DOS returned.
;
; Only AX is changed.
;
FIXED_FCB_SEARCH PROC NEAR
         cmp   ah,12h
         je    fix_fs2         ;Func 12h (search for next) re-uses the FCB.
         push  cx
         push  si
         push  di
         push  es
         mov   di,cs
         mov   es,di
         mov   si,dx
         lea   di,fcb_copy
         cld
         mov   cx,44/2         ;37 for normal FCB, + 7 for extended FCB.
         rep   movsw           ;Copy it.
         pop   es
         pop   di
         pop   si
         pop   cx

fix_fs2:
         push  dx
         push  ds
         push  cs
         pop   ds
         nop
         lea   dx,fcb_copy     ;Let DOS use our local copy of the FCB.
         DOSFAKE
         pop   ds
         pop   dx
         ret

FCB_COPY DB    44 DUP(0),0

FIXED_FCB_SEARCH ENDP



SEE_IF_FILE_EXISTS_OLD PROC NEAR
         MOV   DS,CS_SAVE               ; over here
         LEA   DX,FIND_FIRST_DTA        ; area FIND FIRST will use
         MOV   AH,1AH                   ; set DTA
         DOSFAKE

         PUSH  DS
         PUSH  DX
         MOV   DS,SAVE_DS
         MOV   DX,SAVE_DX
         MOV   AH,11H
         CALL  FIXED_FCB_SEARCH
         CMP   AL,0
         JE    SEE_IF_EXISTS_OLD_CLC
         STC
         JMP   SHORT SEE_IF_EXISTS_OLD_EXIT

SEE_IF_EXISTS_OLD_IZ_SUB_DIR:
         CALL  SEE_IF_THERE_ARE_OTHERS
         JMP   SHORT SEE_IF_EXISTS_OLD_EXIT

SEE_IF_EXISTS_OLD_CLC:
         MOV   DS,CS_SAVE               ; over here
         LEA   SI,FIND_FIRST_DTA+1      ; area FIND FIRST will use
         TEST  SWITCH,EXTENDED_FCB      ; extended FCB?
         JZ    SEE_IF_EXISTS_OLD_NOT_EXTENDED
         ADD   SI,7                     ; point to start of good part

SEE_IF_EXISTS_OLD_NOT_EXTENDED:
         MOV   AL,[SI+DIR_ENT_ATTR]
         TEST  AL,SUB_DIR + READ_ONLY   ;Added 'read-only' 3-20-90 GWD.
         JNZ   SEE_IF_EXISTS_OLD_IZ_SUB_DIR
         CALL  IZ_IT_US_OLD
         JC    SEE_IF_EXISTS_OLD_IZ_SUB_DIR
         CALL  IZ_IT_IGNORED_OLD
         JC    SEE_IF_EXISTS_OLD_IZ_SUB_DIR

         CALL  ADD_OLD_NAME_TO_CTL

SEE_IF_EXISTS_OLD_EXIT:
         POP   DX
         POP   DS
         RET

SEE_IF_FILE_EXISTS_OLD ENDP



SEE_IF_THERE_ARE_OTHERS PROC NEAR
         PUSH  DS
         PUSH  DX

SEE_IF_THERE_IZ_SUB_DIR:
         MOV   DS,SAVE_DS
         MOV   DX,SAVE_DX
         MOV   AH,12H                   ; find next
         CALL  FIXED_FCB_SEARCH
         CMP   AL,0
         JE    SEE_IF_THERE_CLC
         STC
         JMP   SHORT SEE_IF_THERE_EXIT

SEE_IF_THERE_CLC:
         MOV   DS,CS_SAVE               ; over here
         LEA   SI,FIND_FIRST_DTA+1      ; area FIND FIRST will use
         TEST  SWITCH,EXTENDED_FCB      ; extended FCB?
         JZ    SEE_IF_THERE_NOT_EXTENDED
         ADD   SI,7                     ; point to start of good part

SEE_IF_THERE_NOT_EXTENDED:
         MOV   AL,[SI+DIR_ENT_ATTR]
         TEST  AL,SUB_DIR + READ_ONLY   ;Added 'read-only' 3-20-90 GWD.
         JNZ   SEE_IF_THERE_IZ_SUB_DIR
         CALL  IZ_IT_US_OLD
         JC    SEE_IF_THERE_IZ_SUB_DIR
         CALL  IZ_IT_IGNORED_OLD
         JC    SEE_IF_THERE_IZ_SUB_DIR

         CALL  ADD_OLD_NAME_TO_CTL

SEE_IF_THERE_EXIT:
         POP   DX
         POP   DS
         RET

SEE_IF_THERE_ARE_OTHERS ENDP



IZ_IT_US_OLD PROC NEAR
         PUSH  SI
         PUSH  DI
         PUSH  CX
         PUSH  ES
         CMP   CTL_FILE_ASCIIZ_OFFSET,OFFSET CTL_FILE_ASCIIZ+3
         JNE   IZ_IT_US_OLD_CLC
         LEA   DI,OUR_CTL_FCBNAME
         MOV   CX,OUR_CTL_FCBNAME_LEN
         MOV   ES,CS_SAVE
         REPE  CMPSB
         JNE   IZ_IT_US_OLD_CLC
         OR    SWITCH,WE_FOUND_US
         STC
         JMP   SHORT IZ_IT_US_OLD_EXIT

IZ_IT_US_OLD_CLC:
         CLC

IZ_IT_US_OLD_EXIT:
         POP   ES
         POP   CX
         POP   DI
         POP   SI
         RET

IZ_IT_US_OLD ENDP



IZ_IT_IGNORED_OLD PROC NEAR     ;Returns CF=true=ignore the file.
         PUSH  DI
         LEA   DI,[SI+8]
         CALL  CHECK_EXT
         POP   DI
         RET

IZ_IT_IGNORED_OLD ENDP



IZ_IT_US_NEW PROC NEAR
         PUSH  SI
         PUSH  DI
         PUSH  CX
         PUSH  ES
         PUSH  DS
         TEST  FIND_FIRST_ATTRIBUTE,SUB_DIR
         JNZ   IZ_IT_US_NEW_CLC
         CMP   CTL_FILE_ASCIIZ_OFFSET,OFFSET CTL_FILE_ASCIIZ+3
         JA    IZ_IT_US_NEW_CLC

         LEA   DI,ASCIIZ
         LEA   SI,OUR_CTL_ASCIIZ+3

         CMP   ASCIIZ+1,':'
         JNE   IZ_IT_US_NEW_SKIP_DRIVE
         ADD   DI,2
         CMP   BYTE PTR [DI],'\'
         JE    IZ_IT_US_NEW_GOTTA_SLASH
         CMP   BYTE PTR [DI],'/'
         JNE   IZ_IT_US_NEW_SKIP_DRIVE

IZ_IT_US_NEW_GOTTA_SLASH:
         INC   DI

IZ_IT_US_NEW_SKIP_DRIVE:
         MOV   CX,13
         MOV   ES,CS_SAVE
         MOV   DS,CS_SAVE
         REPE  CMPSB
         JNE   IZ_IT_US_NEW_CLC
         OR    SWITCH,WE_FOUND_US
         STC
         JMP   SHORT IZ_IT_US_NEW_EXIT

IZ_IT_US_NEW_CLC:
         CLC

IZ_IT_US_NEW_EXIT:
         POP   DS
         POP   ES
         POP   CX
         POP   DI
         POP   SI
         RET

IZ_IT_US_NEW ENDP



IZ_IT_IGNORED_NEW PROC NEAR
         PUSH  DI
         PUSH  CX
         PUSH  ES
         TEST  FIND_FIRST_ATTRIBUTE,SUB_DIR
         JNZ   IZ_IT_IGNORED_NEW_CLC

         MOV   ES,CS_SAVE
         LEA   DI,FIND_FIRST_FILE_EXT
         MOV   CX,13
         MOV   AL,'.'
         REPNE SCASB
         JNE   IZ_IT_IGNORED_NEW_CLC

         CALL  CHECK_EXT
         JMP   SHORT IZ_IT_IGNORED_NEW_EXIT

IZ_IT_IGNORED_NEW_CLC:
         CLC

IZ_IT_IGNORED_NEW_EXIT:
         POP   ES
         POP   CX
         POP   DI
         RET

IZ_IT_IGNORED_NEW ENDP



;--------------------------------------------------------
; Check a file extension for special values.  GWD.
; On entry: CS:DI points at the three-byte extension.
; On exit: if it matches any, then CF=true.  Else CF=false.
; All regs are preserved.

CHECK_EXT PROC NEAR
         push  ax
         push  dx
         push  di
         mov   al,cs:[di+2]
         call  uppercase
         mov   dl,al
         mov   al,cs:[di+1]
         call  uppercase
         mov   ah,al
         mov   al,cs:[di]
         call  uppercase               ;Sequential bytes are in AL,AH,DL.
         mov   dh,0
         lea   di,ext_ignore_list

chext_lp:
         cmp   dh,cs:[di]
         jz    chext_no                ;End of list.
         cmp   ax,cs:[di]
         jne   chext_next
         cmp   dl,cs:[di+2]
         jne   chext_next
         stc                           ;Indicate a match.
         jmp   short chext_done

chext_next:
         lea   di,[di+3]
         jmp   chext_lp

chext_no:
         clc                           ;No match.

chext_done:
         pop   di
         pop   dx
         pop   ax
         ret

CHECK_EXT ENDP


EXT_IGNORE_LIST LABEL byte
        DB      "$$$"
        DB      "TMP"
        DB      "IMG"           ; PC Shell
        DB      "THM"           ;    files
        DB      "IMX"           ;      to ignore
        DB      0               ;Zero marks the end of the list.



ADD_OLD_NAME_TO_CTL PROC NEAR
         MOV   DS,CS_SAVE               ; over here
         LEA   SI,FIND_FIRST_DTA+1      ; area FIND FIRST will use
         TEST  SWITCH,EXTENDED_FCB      ; extended FCB?
         JZ    ADD_OLD_SHORT
         ADD   SI,7                     ; point to start of good part

ADD_OLD_SHORT:

; now, move in the file name and extenshun from FCB

         PUSH  SI
         MOV   DI,CTL_FILE_ASCIIZ_OFFSET
         MOV   CX,8                     ; length of name
         REP   MOVSB                    ; move filename

         MOV   BYTE PTR ES:[DI],'.'     ; separate name frum ext
         INC   DI                       ; to next spot
         MOV   CX,3                     ; length of EXT
         REP   MOVSB                    ; move extenshun

         MOV   BYTE PTR ES:[DI],0       ; ternimate wit a binzer
         POP   SI

         MOV   AL,[SI+DIR_ENT_ATTR]
         MOV   CTL_ATTR,AL
         MOV   AX,[SI+DIR_ENT_TIME]
         MOV   CTL_TIME,AX
         MOV   AX,[SI+DIR_ENT_DATE]
         MOV   CTL_DATE,AX
         MOV   AX,[SI+DIR_ENT_SZLO]
         MOV   CTL_SIZE_LO,AX
         MOV   AX,[SI+DIR_ENT_SZHI]
         MOV   CTL_SIZE_HI,AX

         MOV   AX,[SI+DIR_ENT_CLU]
         MOV   CTL_INFO,AX

         CLC
         RET

ADD_OLD_NAME_TO_CTL ENDP



GET_CLUSTERS_OLD PROC NEAR
         AND   SWITCH,NOT NO_CLUSTERS_ALLOCATED
         MOV   AX,CTL_INFO              ; get starting_cluster #
         JMP   SHORT GET_CLUSTERS_CHECK

GET_CLUSTERS_NEW:
         AND   SWITCH,NOT NO_CLUSTERS_ALLOCATED
         CALL  GET_STARTING_CLU
         JC    GET_CLUSTERS_STC

;        AX has the starting clu. Go track chain.

GET_CLUSTERS_CHECK:
         CMP   AX,0                     ; not a real file?
         JE    GET_CLUSTERS_NOT_ALLOC

         CALL  FOLLOW_CHAIN
         JC    GET_CLUSTERS_STC
         CLC
         RET

GET_CLUSTERS_NOT_ALLOC:
         OR    SWITCH,NO_CLUSTERS_ALLOCATED

GET_CLUSTERS_STC:
         STC
         RET

GET_CLUSTERS_OLD ENDP



GET_STARTING_CLU PROC NEAR
         MOV   AX,FIND_FIRST_30_LASTENT

         MUL   THIRTY_TWO               ; get directory entry offset
         DIV   DR.IVE_SECTOR_SIZE       ; get which rel sector
         MOV   DI,AX                    ; save rel sector
         MOV   BX,DX                    ; save offset
         MOV   AX,FIND_FIRST_20_DIRSTART
         CMP   DOS_VERSION,0300H
         JB    G_S_C_2
         MOV   AX,FIND_FIRST_30_DIRSTART

G_S_C_2:
         CMP   AX,0
         JE    GET_STARTING_OUTTA_ROOT

         CALL  FIND_LOG_SECTOR
         JC    GET_STARTING_CLU_STC
         JMP   SHORT GET_STARTING_DIR_ENTRY

GET_STARTING_OUTTA_ROOT:
         ADD   DI,DR.IVE_FIRST_ROOT_SECTOR
         MOV   AX,DI
         MOV   DX,0

GET_STARTING_DIR_ENTRY:
         PUSH  BX
         MOV   BX,IO_AREA_PTR
         MOV   ABS25_SECTOR_LOW,AX      ; set up
         MOV   ABS25_SECTOR_HIGH,DX     ;  sector num
         MOV   CX,1
         MOV   ABS25_SECTOR_COUNT,CX    ;  (read jus wun)
         CALL  ABS_25
         POP   BX
         JC    GET_STARTING_CLU_STC

         ADD   BX,IO_AREA_PTR
         MOV   AL,[BX+DIR_ENT_ATTR]
         CMP   CTL_ATTR,AL
         JNE   GET_STARTING_CLU_STC
         MOV   AX,WORD PTR [BX+DIR_ENT_TIME]
         CMP   CTL_TIME,AX
         JNE   GET_STARTING_CLU_STC
         MOV   AX,WORD PTR [BX+DIR_ENT_DATE]
         CMP   CTL_DATE,AX
         JNE   GET_STARTING_CLU_STC
         MOV   AX,WORD PTR [BX+DIR_ENT_SZLO]
         CMP   CTL_SIZE_LO,AX
         JNE   GET_STARTING_CLU_STC
         MOV   AX,WORD PTR [BX+DIR_ENT_SZHI]
         CMP   CTL_SIZE_HI,AX
         JNE   GET_STARTING_CLU_STC

         MOV   AX,WORD PTR [BX+DIR_ENT_CLU]
         CLC
         RET

GET_STARTING_CLU_STC:
         STC
         RET
GET_STARTING_CLU ENDP



FOLLOW_CHAIN PROC NEAR
         MOV   DI,IO_AREA_PTR
         MOV   ES,CS_SAVE
         CMP   AX,2
         JB    FOLLOW_CHAIN_STC
         CMP   AX,0FFF7H
         JNB   FOLLOW_CHAIN_STC
         STOSW                          ; starting clu #

FOLLOW_CHAIN_LOOP:
         MOV   SI,AX                    ; save current clu #
         CALL  GET_FAT
         CMP   AX,2
         JB    FOLLOW_CHAIN_STC
         CMP   AX,0FFF7H
         JE    FOLLOW_CHAIN_STC
         JA    FOLLOW_CHAIN_END
         CALL  STOSW_CLU                ; go see if wrap around
         JC    FOLLOW_CHAIN_STC

         INC   SI                       ; increment last clu
         CMP   SI,AX                    ; do we have a progression?
         JNE   FOLLOW_CHAIN_LOOP        ; no, branch

         CALL  GET_FAT                  ; yes, get next one
         CMP   AX,2
         JB    FOLLOW_CHAIN_STC
         CMP   AX,0FFF7H
         JE    FOLLOW_CHAIN_STC
         JA    FOLLOW_CHAIN_END
         CALL  STOSW_CLU                ; go see if wrap around
         JC    FOLLOW_CHAIN_STC

         INC   SI                       ; increment last one
         CMP   SI,AX                    ; do we have three in a row?
         JNE   FOLLOW_CHAIN_LOOP
         MOV   WORD PTR ES:[DI-4],0     ; indicate a range

FOLLOW_CHAIN_RANGE:
         CALL  GET_FAT                  ; yes, get next one
         CMP   AX,2
         JB    FOLLOW_CHAIN_STC
         CMP   AX,0FFF7H
         JE    FOLLOW_CHAIN_STC
         JA    FOLLOW_CHAIN_END
         INC   SI                       ; increment last one
         CMP   SI,AX                    ; do we have three in a row?
         JNE   FOLLOW_CHAIN_STOSW
         MOV   ES:[DI-2],AX             ; extend a range
         JMP   FOLLOW_CHAIN_RANGE


FOLLOW_CHAIN_STOSW:
         CALL  STOSW_CLU                ; go see if wrap around
         JC    FOLLOW_CHAIN_STC
         JMP   FOLLOW_CHAIN_LOOP

FOLLOW_CHAIN_END:
         STOSW
         MOV   CLUSTERS_STORED_END,DI
         CLC
         RET

FOLLOW_CHAIN_STC:
         STC
         RET

FOLLOW_CHAIN ENDP



STOSW_CLU PROC NEAR
         PUSH  SI
         MOV   SI,IO_AREA_PTR

STOSW_CLU_LOOP:
         CMP   SI,DI
         JNB   STOSW_CLU_CLC
         CMP   WORD PTR ES:[SI],0       ; a range?
         JNE   STOSW_CLU_NOT_RANGE      ; no, branch
         CMP   WORD PTR ES:[SI-2],AX    ; below low part of range?
         JB    STOSW_CLU_INC_RANGE      ; yes, branch
         CMP   WORD PTR ES:[SI+2],AX    ; above high part of range?
         JNA   STOSW_CLU_STC            ; no, error, branch

STOSW_CLU_INC_RANGE:
         ADD   SI,2
         JMP   SHORT STOSW_CLU_INC

STOSW_CLU_NOT_RANGE:
         CMP   WORD PTR ES:[SI],AX      ; a match?
         JE    STOSW_CLU_STC            ; yes, oops

STOSW_CLU_INC:
         ADD   SI,2
         JMP   STOSW_CLU_LOOP

STOSW_CLU_CLC:
         STOSW

         MOV   SI,IO_AREA_PTR
         ADD   SI,LARGEST_SECTOR
         CMP   SI,DI                    ; blown buffer space?
         JBE   STOSW_CLU_STC            ; yup, ferget it

         POP   SI
         CLC
         RET

STOSW_CLU_STC:
         POP   SI
         STC
         RET

STOSW_CLU ENDP



DELETE_IT_NEW PROC NEAR
         MOV   DS,SAVE_DS
         MOV   DX,SAVE_DX
         MOV   AH,41H
         TEST  SWITCH,DELETE_SUB_DIR
         JZ    DELETE_IT_NEW_CONT
         MOV   AH,3AH

DELETE_IT_NEW_CONT:
         DOSFAKE
         CALL  GET_TIME_STAMP
         RET

DELETE_IT_NEW ENDP



DELETE_IT_OLD PROC NEAR
         MOV   DS,CS_SAVE
         MOV   ES,CS_SAVE
         LEA   SI,FIND_FIRST_DTA        ; point to unopened FCB
         LEA   DI,ASCIIZ                ; unused during old way
         MOV   CX,50
         REP   MOVSB
         LEA   DX,ASCIIZ
         MOV   AH,13H
         DOSFAKE
         CMP   AL,0
         JNE   DELETE_IT_OLD_STC
         CALL  GET_TIME_STAMP
         CLC
         RET

DELETE_IT_OLD_STC:
         STC
         RET

DELETE_IT_OLD ENDP



GET_TIME_STAMP PROC NEAR
         PUSHF
         PUSH  AX
         PUSH  BX
         PUSH  CX
         PUSH  DX

         MOV   AH,2CH
         DOSFAKE

         MOV   AX,CX
         MOV   CL,2
         SHL   AL,CL
         MOV   CL,3
         SHL   AX,CL
         MOV   CTL_TIME_DEL,AX

         MOV   AH,2AH
         DOSFAKE

         SUB   CX,1980
         MOV   AX,CX
         MOV   CL,9
         SHL   AX,CL
         MOV   CL,3
         SHL   DL,CL
         SHR   DX,CL
         OR    AX,DX
         MOV   CTL_DATE_DEL,AX

         POP   DX
         POP   CX
         POP   BX
         POP   AX
         POPF
         RET

GET_TIME_STAMP ENDP



ABS_25   PROC NEAR

;        DX    = logical sector num to read

         PUSH  DS
         PUSH  BX
         PUSH  CX
         PUSH  DX
         PUSH  SI
         PUSH  DI
         PUSH  BP

         TEST  DRIVE_INFO,ABOVE_32_MEG  ; in this mode?
         JZ    ABS_25_OLD_WAY           ; nope

         MOV   ABS25_XFER_ADDR_SEG,DS
         MOV   ABS25_XFER_ADDR_OFF,BX
         LEA   BX,ABS25_PARM_BLOCK
         MOV   CX,0FFFFH
         JMP   SHORT ABS_25_DEWIT

ABS_25_OLD_WAY:
         MOV   DX,ABS25_SECTOR_LOW

ABS_25_DEWIT:
         MOV   DS,CS_SAVE
         MOV   AL,DR.IVE_NUMBER
         INT   25H
         JC    ABS_25_ERROR
         POPF
         CLC

ABS_25_EXIT:
         POP   BP
         POP   DI
         POP   SI
         POP   DX
         POP   CX
         POP   BX
         POP   DS
         RET

ABS_25_ERROR:
         POPF
         STC
         JMP   ABS_25_EXIT

ABS_25   ENDP



UPDATE_CTL_FILE PROC NEAR
         MOV   ES,CS_SAVE
         MOV   DS,CS_SAVE
         MOV   CTL_FILE_IND,CTL_FIRST
         TEST  SWITCH,DELETE_SUB_DIR
         JZ    UPDATE_CTL_FILE_CONT
         OR    CTL_FILE_IND,CTL_SUB_DIR

UPDATE_CTL_FILE_CONT:
         CALL  BUILD_CTL_INFO

UPDATE_NOT_LAST:
         MOV   AX,CTL_HEADER_OLDEST_ENTRY

         MOV   BX,CTL_FILE_ENTRY_LEN
         MUL   BX
         ADD   AX,CTL_HEADER_LEN
         ADC   DX,0
         MOV   CX,DX
         MOV   DX,AX

         MOV   BX,CTL_FILE_HANDLE
         MOV   AX,4200H
         DOSFAKE
         JNC   UPDATE_CTL_POSITIONED
         JMP   SHORT UPDATE_CTL_STC

UPDATE_CTL_POSITIONED:
         INC   CTL_HEADER_OLDEST_ENTRY
         MOV   AX,CTL_HEADER_OLDEST_ENTRY
         CMP   AX,CTL_HEADER_NUM_ENTRIES
         JB    UPDATE_CTL_WRITE
         MOV   CTL_HEADER_OLDEST_ENTRY,0

UPDATE_CTL_WRITE:
         CALL  FORCE_UPPER_CASE
         MOV   AH,40H
         LEA   DX,CTL_FILE_ENTRY
         MOV   CX,CTL_FILE_ENTRY_LEN
         DOSFAKE
         JC    UPDATE_CTL_STC
         CMP   AX,CX
         JNE   UPDATE_CTL_STC

         TEST  CTL_FILE_IND,CTL_LAST
         JNZ   UPDATE_CTL_CLC

         AND   CTL_FILE_IND,CTL_CLEAR
         CALL  BUILD_CTL_INFO
         JMP   UPDATE_NOT_LAST

UPDATE_CTL_CLC:
         MOV   CX,0
         MOV   DX,0
         MOV   BX,CTL_FILE_HANDLE
         MOV   AX,4200H
         DOSFAKE
         JC    UPDATE_CTL_STC
         MOV   AH,40H
         MOV   CX,CTL_HEADER_LEN
         LEA   DX,CTL_HEADER
         DOSFAKE
         JC    UPDATE_CTL_STC
         CMP   AX,CX
         JNE   UPDATE_CTL_STC
         CLC
         RET

UPDATE_CTL_STC:
         STC
         RET

UPDATE_CTL_FILE ENDP



FORCE_UPPER_CASE PROC NEAR
         TEST  CTL_FILE_IND,CTL_FIRST
         JZ    F_U_C_RET
         PUSH  DS
         PUSH  SI
         PUSH  CX
         PUSH  AX
         MOV   CX,128
         LEA   SI,CTL_FILE_ASCIIZ
         MOV   DS,CS_SAVE

F_U_C_LOOP:
         MOV   AL,[SI]
         CALL  UPPERCASE
         MOV   [SI],AL
         INC   SI
         LOOP  F_U_C_LOOP

         POP   AX
         POP   CX
         POP   SI
         POP   DS

F_U_C_RET:
         RET

FORCE_UPPER_CASE ENDP



BUILD_CTL_INFO PROC NEAR
         MOV   CX,CTL_FILE_END-CTL_INFO
         LEA   DI,CTL_INFO
         TEST  CTL_FILE_IND,CTL_FIRST
         JNZ   B_C_I_1
         MOV   CX,CTL_FILE_END-CTL_INFO_CONT
         LEA   DI,CTL_INFO_CONT

B_C_I_1:
         MOV   AX,CLUSTERS_STORED_END
         SUB   AX,IO_AREA_PTR
         CMP   AX,CX
         JA    B_C_I_2
         OR    CTL_FILE_IND,CTL_LAST
         MOV   CX,AX

B_C_I_2:
         MOV   SI,IO_AREA_PTR
         REP   MOVSB
         MOV   CX,CLUSTERS_STORED_END
         SUB   CX,SI
         JZ    B_C_I_3
         PUSH  DI
         MOV   DI,IO_AREA_PTR
         REP   MOVSB
         MOV   CLUSTERS_STORED_END,DI
         POP   DI

B_C_I_3:
         LEA   CX,CTL_FILE_END
         SUB   CX,DI
         JZ    B_C_I_EXIT
         MOV   AL,0
         REP   STOSB

B_C_I_EXIT:
         RET

BUILD_CTL_INFO ENDP



START_CLU        DW 0
START_CLU_CONT   DW 0
REL_SECTOR       DW 0
REL_CLUSTER      DW 0
START_CLU_LAST   DW 0
REL_CLUSTER_LAST DW 0

FIND_LOG_SECTOR PROC NEAR
         PUSH  DS
         PUSH  BX
         PUSH  CX
         PUSH  DI
         PUSH  SI
         MOV   DS,CS_SAVE
         MOV   START_CLU,AX

;        First, we will find out which relative Cluster in the file
;        is involved and we will also have the relative sector in the
;        cluster.

F_L_S_1:
         MOV   AX,DI                    ; get relative clu/sec in file
         MOV   DX,0
         MOV   BL,DR.IVE_SECTORS_PER_CLU
         MOV   BH,0
         DIV   BX

;        If the starting cluster # is the same we may not need to
;        scan thru the entire FAT, just take off from where we were
;        before.

         MOV   BX,START_CLU
         CMP   START_CLU_LAST,BX       ; might this be a continuation?
         JE    FIND_LOG_SECTOR_CONTINUE ; yes, branch
         MOV   START_CLU_LAST,BX       ; no, save starting clu#
         JMP   SHORT FIND_LOG_SECTOR_OLD_WAY

FIND_LOG_SECTOR_CONTINUE:

;        Now, if the relative cluster is equal or greater than the
;        last, we can start from the last.

         CMP   AX,REL_CLUSTER_LAST     ; are we in range?
         JB    FIND_LOG_SECTOR_OLD_WAY ; no, branch

         PUSH  AX
         SUB   AX,REL_CLUSTER_LAST     ; get amount to go
         POP   REL_CLUSTER_LAST
         MOV   REL_CLUSTER,AX          ; set it up
         MOV   AX,START_CLU_CONT       ; get associated cluster #
         MOV   START_CLU,AX            ; and save it
         MOV   REL_SECTOR,DX           ; save relative sector #
         MOV   BX,FAT_AREA_PTR
         JMP   SHORT CHECK_NEXT_CLUSTER

;        Now, AX has the relative cluster in the file and DX has the
;        relative sector in the cluster

FIND_LOG_SECTOR_OLD_WAY:
         MOV   REL_SECTOR,DX           ; save relative sector in clus
         MOV   REL_CLUSTER,AX          ; save relative cluster in fil
         MOV   REL_CLUSTER_LAST,AX     ; save relative cluster in fil
         MOV   BX,FAT_AREA_PTR         ; point to FAT

CHECK_NEXT_CLUSTER:
         CMP   REL_CLUSTER,0              ; are we at the right cluster
         JE    AT_RIGHT_CLUSTER

;        Now we will determine move to the next cluster in the chain.

         TEST  DR.IVE_SWITCH,FAT_IZ_16_BITS
         JNZ   PROCESS_16_BIT_FAT

;        This will follow the chain thru the 12 bit FAT.

         DEC   REL_CLUSTER
         MOV   DI,START_CLU       ; pick up relative sector number
         SHR   DI,1               ; divide by 2
         ADD   DI,START_CLU       ; equals times 1.5

         MOV   DX,0
         MOV   AX,DI

         CALL  GET_RIGHT_SECTOR
         MOV   AX,[BX+DI]         ; pick up next

         TEST  START_CLU,1        ; is the sector number odd?
         JZ    ADJUST_FAT         ; no, branch
         MOV   CL,4
         SHR   AX,CL

ADJUST_FAT:
         AND   AX,0FFFH           ; clear hi-order byte
         MOV   START_CLU,AX
         CMP   AX,0FF7H            ; at end or error?
         JE    FAT_ERROR_JMP
         JA    AT_RIGHT_CLUSTER
         JMP   CHECK_NEXT_CLUSTER

FAT_ERROR_JMP:
         JMP   SHORT FAT_ERROR

PROCESS_16_BIT_FAT:
         DEC   REL_CLUSTER
         MOV   AX,START_CLU
         MUL   TWO

         CALL  GET_RIGHT_SECTOR
         MOV   AX,[BX+DI]               ; get next cluster #
         MOV   START_CLU,AX             ; save it
         CMP   START_CLU,0FFF7H         ; at end or error?
         JE    FAT_ERROR
         JA    AT_RIGHT_CLUSTER         ; at EOF
         JMP   CHECK_NEXT_CLUSTER

;        Now, if all is cool, compute logical sector # of INT 25H.

AT_RIGHT_CLUSTER:
         MOV   AX,START_CLU
         MOV   START_CLU_CONT,AX
         MOV   AX,REL_CLUSTER
         SUB   REL_CLUSTER_LAST,AX
         CMP   AX,0
         JNE   BEYOND_EOF

         TEST  DR.IVE_SWITCH,FAT_IZ_16_BITS
         JNZ   CHECK_FOR_16_BIT_EOF

         CMP   START_CLU,0FF7H
         JE    FAT_ERROR
         JA    BEYOND_EOF
         JMP   SHORT NOT_EOF

CHECK_FOR_16_BIT_EOF:
         CMP   START_CLU,0FFF7H
         JE    FAT_ERROR
         JA    BEYOND_EOF

NOT_EOF:
         SUB   START_CLU,2                ; sub 2
         MOV   AX,START_CLU
         MOV   BH,0
         MOV   BL,DR.IVE_SECTORS_PER_CLU
         MUL   BX
         ADD   AX,REL_SECTOR              ; rel sect # in cluster
         ADD   AX,DR.IVE_FIRST_DATA_SECTOR ; bump past FAT and DIR

         CLC

FIND_LOG_EXIT:
         POP   SI
         POP   DI
         POP   CX
         POP   BX
         POP   DS
         RET

FAT_ERROR:
         MOV   START_CLU_LAST,0FFFFH
         MOV   AX,0FFF7H
         STC
         JMP   FIND_LOG_EXIT

BEYOND_EOF:
         MOV   AX,0FFFFH
         STC
         JMP   FIND_LOG_EXIT

FIND_LOG_SECTOR ENDP



GET_RIGHT_SECTOR PROC NEAR
         PUSH  AX
         PUSH  CX
         PUSH  DX

         DIV   DR.IVE_SECTOR_SIZE
         MOV   DI,DX

         CMP   AX,FAT_SECTOR           ; got it in memory?
         JE    GET_RIGHT_OUT           ; yes, branch
         JB    GET_NEW_SECTORS         ; no, gotta read more
         MOV   CX,AX                   ; may be in second half
         DEC   CX

         CMP   CX,FAT_SECTOR           ; do they need second half?
         JNE   GET_NEW_SECTORS         ; no, forget it

         MOV   CX,DI                   ; but do they need very last byte
         INC   CX

         CMP   CX,DR.IVE_SECTOR_SIZE   ; spanning across last byte
         JNB   GET_NEW_SECTORS         ; yes, go read anyway

         ADD   DI,DR.IVE_SECTOR_SIZE   ; no, just adjust offset
         JMP   SHORT GET_RIGHT_OUT     ; and get out

GET_NEW_SECTORS:
         MOV   DX,AX
         MOV   FAT_SECTOR,AX
         ADD   DX,DR.IVE_FIRST_FAT_SECTOR
         MOV   ABS25_SECTOR_LOW,DX      ;  sector
         MOV   ABS25_SECTOR_HIGH,0      ;
         MOV   CX,2
         MOV   ABS25_SECTOR_COUNT,CX    ;  (read jus wun)
         CALL  ABS_25

GET_RIGHT_OUT:
         POP   DX
         POP   CX
         POP   AX
         RET

GET_RIGHT_SECTOR ENDP



GET_FAT  PROC  NEAR
         PUSH  BX
         PUSH  CX
         PUSH  DI
         MOV   BX,FAT_AREA_PTR
         MOV   START_CLU,AX
         MOV   DI,AX              ; pick up cluster number
         TEST  DR.IVE_SWITCH,FAT_IZ_16_BITS
         JNZ   GET_FAT_16
         SHR   DI,1               ; divide by 2
         ADD   DI,AX              ; equals times 1.5

         MOV   DX,0
         MOV   AX,DI

         CALL  GET_RIGHT_SECTOR
         MOV   AX,[BX+DI]         ; pick up next
         TEST  START_CLU,1        ; is the sector number odd?
         JZ    GF_1               ; no, branch
         MOV   CL,4
         SHR   AX,CL
GF_1:
         AND   AX,0FFFH           ; clear hi-order byte
         CMP   AX,0FF7H
         JB    GF_EXIT
         OR    AX,0F000H

GF_EXIT:
         POP   DI
         POP   CX
         POP   BX
         RET

GET_FAT_16:
         MOV   AX,DI
         MUL   TWO

         CALL  GET_RIGHT_SECTOR
         MOV   AX,[BX+DI]
         JMP   GF_EXIT

GET_FAT  ENDP



CHECK_FOR_BIG_HARD_DRIVE PROC NEAR

; see if we have over 32 meg hard drive support (like COMPAQ DOS 3.31)

         PUSH  DS
         AND   DRIVE_INFO,NOT ABOVE_32_MEG
         CMP   DOS_VERSION,031FH        ; less than 3.31?
         JAE   CFBHD_CONT_1             ; nope, branch
         CMP   DOS_VERSION,031EH        ; equal to 3.30?
         JB    CFBHD_EXIT               ; no, branch
         CMP   DOS_VERSION_BH,5         ; ZENITH DOS 3.30?
         JE    CFBHD_CONT_1             ; yup, branch

         JMP   SHORT CFBHD_EXIT

CFBHD_CONT_1:
         MOV   AX,[BX]+13              ; get highest valid clu #
         DEC   AX                      ; -1 since 1st is clu 2
         MOV   CH,0
         MOV   CL,[BX]+4               ; get sectors/clu -1
         INC   CX
         MUL   CX
         ADD   AX,[BX]+11              ; add first data sector #
         ADC   DX,0

         CMP   DX,0
         JE    CFBHD_EXIT

         OR    DRIVE_INFO,ABOVE_32_MEG  ; so note

CFBHD_EXIT:
         POP   DS

         RET

CHECK_FOR_BIG_HARD_DRIVE ENDP



UPPERCASE PROC NEAR     ;Convert AL to upper case.
         CMP   AL,'a'
         JB    UC
         CMP   AL,'z'
         JA    UC
         SUB   AL,20H

UC:
         RET

UPPERCASE ENDP



;----------------------------------------------------------------
; This proc is here really only because we hook INT 19h to help
; prevent dangerous attempts to improperly Unload the tracker.
; Since many programs hook INT 19h, this helps enforce
; the 'First-intalled, Last-removed' pseudo-rule.
; Added 02-21-90 GWD, v6.   Restore old vector 02-23-90.

INT19_SERVICE PROC FAR          ;Bootstrap.
         cli
         mov   ax,cs
         mov   ds,ax
         xor   ax,ax
         mov   es,ax           ;ES=0.
         cld
         mov   di,4*19h
         lea   si,saved19
         movsw                 ; Restore 19h (the only Bios vector we hook).
         movsw
         mov   di,4*2Fh
         lea   si,saved2F
         cmp   word ptr ds:[si+2],-1   ;Vector 2F was hooked?
         je    int19_x                 ;No.
         movsw                           ;Restore old vector 2Fh.
         movsw

int19_x:
         DB    0EAh            ; JMP FAR xxxx:xxxx (to old handler).
saved19  DW    0,-1

INT19_SERVICE ENDP



;----------------------------------------------------------------
; This dummy hooks INT 2Fh for reasons similar to int19_service.
; 02-23-90 GWD.

INT2F_SERVICE PROC FAR
         PUSHF
         PUSH  AX

         CMP   AX,1605H                 ; Windows coming up?
         JNE   INT2F_CONT

         MOV   AX,0
         CMP   BX,AX
         JNE   INT2F_EXIT
         CMP   CX,AX
         JNE   INT2F_EXIT
         CMP   SI,AX
         JNE   INT2F_EXIT
         MOV   AX,ES
         CMP   AX,0
         JNE   INT2F_EXIT
         MOV   AX,DS
         CMP   AX,0
         JNE   INT2F_EXIT

         OR    INSTALL_SWITCH,WINDOWS_PRESENT
         JMP   SHORT INT2F_EXIT

INT2F_CONT:
         CMP   AX,1606H                 ; Windows going down?
         JNE   INT2F_EXIT

         AND   INSTALL_SWITCH,NOT WINDOWS_PRESENT

INT2F_EXIT:
         POP   AX
         POPF
         DB    0EAh            ; JMP FAR xxxx:xxxx
saved2F  DW    0,-1            ;Seg = -1 means not hooked yet.

INT2F_SERVICE ENDP



;---------------------------------------------------------
; Fix the age-old problem with DOS INT 25h/26h.
;
; DOS saves the user's stack pointer into an
; internal DWORD variable upon entry at INT 25h or 26h.
; However, DOS uses that same DWORD to save the user's
; stack pointer during INT 21h fct# 00 - 0Ch !
; This can cause bad problems for TSR's which
; wake-up during DOS console input.
;
; So, we hook INT 25h to save & restore that DWORD.
;
; Added by GWD, 12-2-88, to MIRROR v5.00
;
;----------------------------------------------------------
; Note that the special value of SAVED_25+2 = -1 prevents
; the hookup procedure from modifying the vectors.

        EVEN
saved25         DW      0,-1    ;Saved vectors.
saved26         DW      0,-1

;----------------------------------------------------------
; Addresses of the DWORDS where DOS saves the user's SS:SP.
; Segments will always be the same.

dos_var1_addr   DW      0,-1
dos_var2_addr   DW      0,-1

;----------------------------------------------------------
saved_dos_var   DW      ?,?

black_hole      DW      ?

;----------------------------------------------------------
; Our resident patch-fixes for INT 25h and INT 26h.

INT25_PATCH PROC FAR
         nop
         call  swap_dos_var
         pushf
         call  dword ptr cs:saved25 ;Note - returns with flags still stacked.
         jmp   short int_25_26_back

INT26_PATCH PROC FAR
         nop
         call  swap_dos_var
         pushf
         call  dword ptr cs:saved26

int_25_26_back:
         pop   cs:black_hole   ;Discard unpopped flags.
         call  swap_dos_var
         ret                   ;Leave flag word on stack, like DOS does.
INT26_PATCH ENDP
INT25_PATCH ENDP



;---------------------------------------------------------
; Written as Swap, rather than Save/Restore, so
; that only a single procedure is needed (smaller code).
;
; All regs & flags are preserved.

SWAP_DOS_VAR PROC NEAR
         pushf
         cli
         push  ax
         push  bx
         push  ds
         lds   bx,dword ptr cs:dos_var1_addr
         mov   ax,ds:[bx]
         xchg  ax,cs:saved_dos_var
         mov   ds:[bx],ax
         lds   bx,dword ptr cs:dos_var2_addr
         mov   ax,ds:[bx]
         xchg  ax,cs:saved_dos_var+2
         mov   ds:[bx],ax
         pop   ds
         pop   bx
         pop   ax
         popf
         ret

SWAP_DOS_VAR ENDP

        DB      0

; =======  This is the end of the resident code for Delete-Tracking.  ======

DOS_INTERCEPT_END LABEL BYTE


;------------------------------------------------------------
; These are the first few bytes of DOS INT 25h/26h
; service routines.  We will compare these.

pattern1 DB    0FAh                    ;CLI
pattern2 DB    2Eh, 8Ch, 16h, 0,0      ;MOV CS:xxxx,SS
pattern3 DB    2Eh, 89h, 26h, 0,0      ;MOV CS:yyyy,SP

; The following four bytes are at offset +1 of the INT 25h
; pre-handler for Compaq DOS 3.31 and Zenith 3.30+.

pattern4 DB    83h, 0F9h, 0FFh, 74h    ;CMP CX,-1 then a JZ xx (pattern5).
         DB    0

; The following three bytes are where the JZ xx above point to.
; These do not immediately follow pattern4 in DOS.

pattern5 DB    2Eh, 0FFh, 2Eh          ;JMP DWORD PTR CS:[xxxx]
         DB    0,0


dos_code STRUC
dos_1   DB      ?
dos_2   DB      3 DUP (?)
dos_offset1 DW  ?
dos_3   DB      3 DUP (?)
dos_offset2 DW  ?
dos_code ENDS

        ASSUME  DS:CODE         ;This is the way Glen's code works.

;-----------------------------------------------------------
; Input: ES:BX contain the original 25h or 26h vector.  DS=CS.
;
; If patch is possible then CF=false and
; ES:SI and ES:DI point at the two DOS words.
;
; Otherwise, CF=true.
;
; Destroys AX,BX,CX,SI,DI,ES.

CHECK_25_26 PROC NEAR
         cld
         lea   si,pattern4
         lea   di,[bx+1]
         mov   cx,4
         repe  cmpsb
         jne   chk_first       ;It's not a kluge Compaq DOS 3.31, et al.
         mov   al,es:[di]      ;The offset byte of the JZ opcode.
         inc   di
         cbw
         add   di,ax           ;Compute the target of the JZ opcode.
         lea   si,pattern5
         mov   cl,3
         repe  cmpsb
         jne   chk_cannot_patch
         mov   di,es:[di]      ;Fetch offset from JMP opcode.
         les   bx,es:[di]      ;Fetch DWORD.

chk_first:
         mov   di,bx
         lea   si,pattern1
         cmpsb
         jne   chk_cannot_patch
         push  di
         mov   cx,3            ;Pattern2 follows #1, so SI & DI are OK.
         repe  cmpsb
         pop   di              ;Recover DI, since compare may have failed.
         je    chk_third       ;Matched!  Now see if other is OK, too.
         lea   si,pattern3     ;No match, try alternate.
         mov   cl,3
         repe  cmpsb
         je    chk_third
         jmp   SHORT chk_cannot_patch

chk_third:
         lea   si,pattern2
         lea   di,[bx].dos_3
         push  di
         mov   cl,3
         repe  cmpsb
         pop   di
         je    chk_can_patch
         lea   si,pattern3
         mov   cl,3
         repe  cmpsb
         je    chk_can_patch

chk_cannot_patch:
         stc
         jmp   short chk_exit

chk_can_patch:
         mov   si,es:[bx].dos_offset1
         mov   di,es:[bx].dos_offset2
         clc

chk_exit:
         ret

CHECK_25_26 ENDP



;----------------------------------------------------------
; See if we can (or should) patch INT 25h & 26h.  GWD.
;
; On exit:
;       If yes, then the current vectors are saved and CF=false.
;       If they cannot be patched, then CF=true.
;
; All regs preserved, only flags are changed.

MAYBE_PATCH PROC NEAR
         push  ax
         push  bx
         push  cx
         push  dx
         push  si
         push  di
         push  ds
         push  es
         mov   ax,cs
         mov   ds,ax           ;Set DS=CS.
         nop
         mov   ax,3525h        ;Ask DOS for the current vector.
         int   21h             ;Returns ES:BX.
         mov   saved25,bx
         mov   saved25+2,es    ;Save it, even though we might not hook it.
         call  check_25_26
         jc    maybe_not
         mov   dos_var1_addr,si
         mov   dos_var1_addr+2,es
         mov   dos_var2_addr,di
         mov   dos_var2_addr+2,es
         mov   ax,3526h        ;Ask DOS for the current vector.
         int   21h             ;Returns ES:BX.
         mov   saved26,bx
         mov   saved26+2,es
         call  check_25_26
         jc    maybe_not
         mov   ax,es
         cmp   ax,dos_var1_addr+2
         jne   maybe_not
         clc
         jmp   short maybe_end

maybe_not:
         stc

maybe_end:
         pop   es
         pop   ds
         pop   di
         pop   si
         pop   dx
         pop   cx
         pop   bx
         pop   ax
         ret

MAYBE_PATCH ENDP



;-------------------------------------------------
; Substitute our handlers on INT 25h & 26h.
; Destroys AX,DX.

HOOK_INT_25_26 PROC NEAR
         push  ds
         push  cs
         pop   ds
         nop
         cmp   saved25+2,-1    ;Have the vectors been saved?
         je    hook_i25_end    ;No.  We're skipping the hook.
         lea   dx,int25_patch
         mov   ax,2525h        ;Ask DOS to change the vector.
         int   21h
         lea   dx,int26_patch
         mov   ax,2526h
         int   21h

hook_i25_end:
         pop   ds
         ret

HOOK_INT_25_26 ENDP

         ASSUME DS:nothing      ;Put it back the way Jim likes it.

INCL_DELTRACK EQU $
         INCLUDE MIR_MSG.INC

COMMAND_LINE_CHECK_SWITCH DB 0
GOTTA_DRIVE_LETTER        EQU 80H
GOTTA_UNLOAD_LETTER       EQU 40H
GOTTA_PARTN_LETTER        EQU 20H
GOTTA_TRACK_LETTER        EQU 10H

GOTTA_ONE_LETTER		  EQU 01H		;for /1 switch ;M001
TRACK_DIGIT_COUNT DB 0

PHYS_DRV DW    0

C_E_H_DWORD DD 0
         ORG   $-4
C_E_H_OFF   DW 0
C_E_H_SEG   DW 0

STACK_SEGMENT_SAVE DW 0
STACK_POINTER_SAVE DW 0
ALLOC_STRAT        DB 0
UMB_LINK_STAT      DB 0
UMB_SWITCH         DB 0
OK_TO_SEARCH_UMBS  EQU 80H

PARAMETER DW   0
          DW   80H
PARM_CS1  DW   0
          DW   PARM_FCB
PARM_CS2  DW   0
          DW   PARM_FCB
PARM_CS3  DW   0

PARM_FCB  DB   0FFH,35 DUP(0)



INIT_RES PROC  FAR
         EXTRN STAK_END:BYTE
         EXTRN MIRROR:NEAR

; *** This is the installation code for Delete Tracking. ***

        nop
        nop
        nop

START:
         LEA   SP,STAK_END
         PUSH  DS                       ; DS to stack
         SUB   AX,AX
         PUSH  AX                       ; zero return

         CALL  GET_DOS_VERSION

         MOV   CS_SAVE,CS
         CMP   CS_SAVE,0A000H
         JB    START_CONT
;M003
; If we are loaded in UMBs and this field is set, then just install the
;tracker, otherwise do everything. This field is set when Mirror tries to
;do an automatic load into UMBs. The way Mirror does an automatic load into
;UMBs is by execing mirror again and setting this field to 0ffh.
;
	cmp	byte ptr cs:[5ch],0ffh	;M003
	jne	start_cont_1		;M003

         JMP   SHORT JUST_INSTALL

START_CONT:
         CMP   BYTE PTR CS:[5CH],0FFH   ; trying to load hi?
         JE    INIT_EXIT                ; forget all about it!

start_cont_1:				;M003
         LEA   DX,MSG_MAIN_TITLE
         MOV   AH,9
         DOSEXEC

         CALL  VALIFY_COMMAND_LINE
         JNC   START_PARMS_OK
         JMP   BAD_PARMS

START_PARMS_OK:
         PUSH  DS
         CALL  SAVE_PARTITION           ;Returns here, or TERMINATES to DOS!
         POP   DS

         CALL  FIRE_UP_MIRROR

         CALL  FIND_SLASH_TEE
         TEST  INSTALL_SWITCH,GOT_SLASH_TEE
         JZ    INIT_EXIT

         LEA   DX,MSG_TRACKER_TITLE
         MOV   AH,9
         DOSEXEC

         CALL  CHK_DTRK_RESIDENT
         JNC   SETUP_DRIVES

         LEA   DX,ALREADY_MSG           ; give 'em
         MOV   AH,9                     ;  bad
         DOSEXEC                        ;   news

INIT_EXIT:
         RET

SETUP_DRIVES:

; New residency checking method, requested by Jim 12-8-88.  GWD.

         xor   bx,bx           ;Function = residency test.
         xor   cx,cx           ;Pre-clear CX.
         mov   ax,0FFA3h       ; check for our new program
         int   16h
         cmp   cx,5555h
         jne   test_for_shell
         cmp   dx,cx
         je    tools_is_resident

test_for_shell:
         xor   bx,bx           ;Function = residency test.
         xor   cx,cx           ;Pre-clear CX.
         mov   ax,0FFDDh       ;Tom's method of checking PCSHELL residency.
         int   16h
         cmp   cx,5555h
         jne   test_for_desktop
         cmp   dx,cx
         je    tools_is_resident

test_for_desktop:
         xor   cx,cx
         mov   ax,0FFEFh       ;Tom's method of checking DESKTOP residency.
         int   16h
         cld
         sti
         cmp   cx,0ABCDh
         jne   tools_not_resident

tools_is_resident:
         LEA   DX,TOOLS_ALREADY_MSG     ; give 'em
         MOV   AH,9                     ;  bad
         DOSEXEC                        ;   news
         RET                            ;Terminate.

TOOLS_NOT_RESIDENT:
JUST_INSTALL:
         CMP   DOS_VERSION,0300H
         JB    NOT_ASSIGNED
         MOV   AX,0
         MOV   DS,AX
         CMP   WORD PTR DS:[2FH*4],0
         JNE   ASSIGNED_CHK
         CMP   WORD PTR DS:[2FH*4]+2,0
         JNE   ASSIGNED_CHK
         JMP   SHORT NOT_ASSIGNED

ASSIGNED_CHK:
         MOV   AX,0600H
         INT   2FH                      ; iz ASSIGN resident?
         CMP   AL,0FFH
         JNE   NOT_ASSIGNED
         OR    INSTALL_SWITCH,ASSIGN_RESIDENT

NOT_ASSIGNED:
         MOV   DS,CS_SAVE               ; DS=CS.  Good!
         INT   11H
         AND   AX,00C0H                 ; turn off all but # drives
         MOV   CL,6
         SHR   AX,CL
         CMP   AX,0
         JNE   GOT_AT_LEAST_TWO_PHYSICAL
         MOV   AX,1

GOT_AT_LEAST_TWO_PHYSICAL:
         MOV   PHYS_DRV,AX

         CALL  HOOK_UP_CRITICAL_ERROR
         CALL  PARSE_PARMS

         PUSHF
         CALL  UNHOOK_UP_CRITICAL_ERROR
         POPF

         JNC   SET_HOOKS

BAD_PARMS:
         LEA   DX,INVALID_PARMS         ; give 'em
         MOV   AH,9                     ;  bad
         DOSEXEC                        ;   news

INIT_NOTHIN_TEW_DEW:
         JMP   INIT_EXIT

SET_HOOKS:
         MOV   AX,IO_AREA_PTR
         ADD   AX,LARGEST_SECTOR
         MOV   FAT_AREA_PTR,AX

         CALL  TRY_TO_LOAD_US_HIGH
         JNC   INIT_NOTHIN_TEW_DEW

         CMP   DOS_VERSION,0500H
         JNB   NO_HOOKING_ALLOWED

         call  maybe_patch     ;Checks if we can do the INT 25h/26h fix.
         jnc   no_hook25_err   ;Yes we can.

         lea   dx,msg_nohook_25 ;"WARNING - can't hook INT 25h.  TSR danger."
         mov   ah,9
         int   21h

NO_HOOKING_ALLOWED:
         mov   ax,-1
         mov   saved25+2,ax    ;Set segments to FFFF to prevent hooking.
         mov   saved26+2,ax

no_hook25_err:
         TEST  INSTALL_SWITCH,GOT_SUMTHIN_TO_TRACK
         JZ    INIT_NOTHIN_TEW_DEW

         CALL  DISPLAY_RESULTS

         lea   dx,iret_for_23           ; GWD 2-19-90.
         mov   ax,2523h                 ; Take Ctrl-C vector to ignore it.
         dosexec

         MOV   AX,3521H                 ;  get vector of DOS int handler
         DOSEXEC
         MOV   DOS_SEG,ES               ; save
         MOV   DOS_OFF,BX               ; save


         LEA   DX,DOS_INTERCEPT         ;
         MOV   AX,2521H                 ; set vector of DOS INT 21h handler
         DOSEXEC

         call  hook_int_25_26          ;Conditionally, this hooks them.

 ; Added INT 19h stuff 02-21-90, GWD.  v6.
         mov   ax,3519h                ;Fetch INT 19h (bootstrap) vector.
         dosexec
         mov   saved19,bx
         mov   saved19+2,es
         lea   dx,int19_service
         mov   ax,2519h                ;Hook it.
         dosexec

 ; Added INT 2Fh  02-23-90 GWD.  v6
         cmp   dos_version,300h
         jb    skip_2F_hook
         mov   ax,352Fh                ;Fetch INT 2Fh DOS multiplex vector.
         dosexec
         mov   saved2F,bx
         mov   saved2F+2,es
         lea   dx,int2F_service
         mov   ax,252Fh                ;Hook it.
         dosexec

         MOV   AH,34H
         DOSEXEC
         MOV   IN_DOS_OFFSET,BX
         MOV   IN_DOS_SEGMENT,ES

skip_2F_hook:
         LEA   DX,INSTALLED_MSG         ; show 'em we are installed.
         MOV   AH,9
         DOSEXEC

	cmp	dos_version,400h	;Old DOS?
	jb	skip_env_free		;Leave it, so mem map shows TSR name.
         MOV   AH,62H			;Get PSP.
         DOSEXEC
         MOV   ES,BX
         MOV   ES,ES:[2CH]
         MOV   AH,49H
         DOSEXEC                        ; free enviroment
skip_env_free:

         MOV   DX,FAT_AREA_PTR
         ADD   DX,LARGEST_SECTOR
         ADD   DX,LARGEST_SECTOR
         ADD   DX,15
         MOV   CL,4
         SHR   DX,CL
         MOV   AX,3100H                 ; to termimate and stay resident
         DOSEXEC

INIT_RES ENDP



GET_DOS_VERSION PROC NEAR
        MOV     AX,3306H                ; get true DOS version
        MOV     BX,0                    ;   ala DOS 5.0
        INT     21H
        CMP     BL,5                    ; function supported?
        JB      VERSION_OLD_WAY
        MOV     AX,BX
        JMP     SHORT STORE_DOSVER

VERSION_OLD_WAY:
         MOV   AH,30H
         DOSEXEC

STORE_DOSVER:
         XCHG  AH,AL
         MOV   DOS_VERSION,AX
         MOV   DOS_VERSION_BH,BH
         RET

GET_DOS_VERSION ENDP



TRY_TO_LOAD_US_HIGH PROC NEAR
         CMP   DOS_VERSION,500H
         JB    T_T_L_U_H_STC_JMP
         CMP   CS_SAVE,0A000H
         JB    T_T_L_U_H_CONT

T_T_L_U_H_STC_JMP:
         JMP   T_T_L_U_H_STC

         ; Save original values

T_T_L_U_H_CONT:
         MOV   AX,5800H
         DOSEXEC                        ; get allocation strategy
         MOV   ALLOC_STRAT,AL

         MOV   AX,5802H
         DOSEXEC                        ; get UMB status
         MOV   UMB_LINK_STAT,AL

         ; Install new values

         MOV   AX,5803H
         MOV   BX,1                     ; link UMBs
         DOSEXEC
         JC    NO_UMBS_JMP

         MOV   AX,5801H
         MOV   BL,80H                   ; request high first, first fit
         DOSEXEC
         JNC   GOT_UMBS_LINKED

NO_UMBS_JMP:
         JMP   NO_UMBS

         ; Get an area and free it

GOT_UMBS_LINKED:
         MOV   BX,FAT_AREA_PTR
         ADD   BX,LARGEST_SECTOR
         ADD   BX,LARGEST_SECTOR
         ADD   BX,15
         MOV   CL,4                     ; get # paras needed for
         SHR   BX,CL                    ; resident portion of del track
         INC   BX                       ; include arena header
         MOV   ES,CS_SAVE
         MOV   CX,ES:[2CH]              ;
         DEC   CX                       ; point to environment arena
         MOV   ES,CX
         ADD   BX,ES:[0].MCB_PARAS      ; add size of environment

         MOV   AH,48H                   ; get worse case amount
         DOSEXEC
         JC    NO_UMBS

         MOV   ES,AX
         MOV   AH,49H
         DOSEXEC

         MOV   AX,ES
         CMP   AX,0A000H
         JB    NO_UMBS

         ; Attempt to load it high

         MOV   BX,0
         MOV   DS,BX
         PUSH  DS:[21H*4]+2              ; save current INT 21 vector

         MOV   STACK_SEGMENT_SAVE,SS
         MOV   STACK_POINTER_SAVE,SP

         MOV   PARM_CS1,CS
         MOV   PARM_CS2,CS
         MOV   PARM_CS3,CS

         MOV   AX,4B00H
         MOV   DS,CS_SAVE
         CALL  POINT_DS_DX_TO_ASCIIZ
         JB    NO_UMBS

         MOV   ES,CS_SAVE
         LEA   BX,PARAMETER
         DOSEXEC

         CLI
         MOV   SS,STACK_SEGMENT_SAVE
         MOV   SP,STACK_POINTER_SAVE
         STI
         POP   AX                       ; recover saved vector

         JC    NO_UMBS

         MOV   BX,0
         MOV   DS,BX
         CMP   DS:[21H*4]+2,AX           ; if changed, we loaded
         JE    DIDNT_LOAD
         CLC
         JMP   SHORT NO_UMBS

DIDNT_LOAD:
         STC


         ; Restore original values

NO_UMBS:
         MOV   DS,CS_SAVE
         PUSHF
         MOV   AX,5803H
         MOV   BH,0
         MOV   BL,UMB_LINK_STAT
         DOSEXEC

         MOV   AX,5801H
         MOV   BL,ALLOC_STRAT
         DOSEXEC

         POPF
         RET

T_T_L_U_H_STC:
         STC
         RET

TRY_TO_LOAD_US_HIGH ENDP



POINT_DS_DX_TO_ASCIIZ PROC NEAR
         PUSH  AX
         PUSH  CX
         PUSH  DI
         PUSH  ES

         MOV   ES,CS_SAVE
         MOV   DS,ES:[2CH]
         MOV   ES,ES:[2CH]
         SUB   AX,AX
         SUB   DI,DI
         MOV   CX,32767

P_D_T_A_LOOP:
         JCXZ  P_D_T_A_STC
         REPNE SCASB                    ; SCAN FOR A BYTE OF ZEROS
         CMP   ES:[DI][-1],AX           ; WAS IT A WORD OF ZEROS
         JNE   P_D_T_A_LOOP             ; NO - SCAN MORE ENVIRONMENT

         ADD   DI,3                     ; bump past werd and binzer
         MOV   DX,DI
         CLC
         JMP   SHORT P_D_T_A_EXIT

P_D_T_A_STC:
         STC

P_D_T_A_EXIT:
         POP   ES
         POP   DI
         POP   CX
         POP   AX
         RET

POINT_DS_DX_TO_ASCIIZ ENDP



FIRE_UP_MIRROR PROC NEAR
         MOV   ES,CS_SAVE
         LEA   BX,END_PROG
         ADD   BX,15
         MOV   CL,4
         SHR   BX,CL                    ; shrink our allocated
         MOV   AH,4AH                   ; memory so MIRROR can
         INT   21H                      ; allocate ala DOS

         MOV   AX,0FFFFH                ; so MIRROR will know its
                                        ; coming from DTRK instead
                                        ; of MSDOS FORMAT which uses
                                        ; 5050H in AX and the zero based
                                        ; drive letter in BL
         CALL  MIRROR

         MOV   BX,0FFFFH
         MOV   AH,4AH
         INT   21H                      ; we expect this to fail and
         JNC   F_U_M_RET                ; BX will have the max size

         MOV   AH,4AH                   ; reclaim all our space
         INT   21H

F_U_M_RET:
         RET

FIRE_UP_MIRROR ENDP



IRET_FOR_23:
         IRET



;-------------------------------------
; New method in v6.0, 02-16-90 GWD.
; Improved 04-26-90 GWD.
;
; On exit: if Mirror Delete-tracking is already resident then
;          CF=true and AX = the resident code segment.
;          If it's not resident then CF=false and AX=0.
;          But if we can't determine which, then CF=true and AX=0.
;
;          Therefore, CF=false means we can install resident.
;          AX > 0 means we maybe can unload the resident module.
;
; Only AX is modified.

mcb_struc STRUC
mcb_signature   DB      ?       ;4Dh or 5Ah (last).
mcb_owner       DW      ?       ;Segment of owner block (1 + that MCB).
mcb_paras       DW      ?       ;Paragraphs in the block (excluding the MCB).
                DB      3 DUP(?)
MCB_NAME        DW      4 DUP(?)
mcb_struc ENDS

CHK_DTRK_RESIDENT PROC NEAR
         push  bx
         push  cx
         push  dx
         push  si
         push  di
         push  ds
         push  es

         MOV   UMB_SWITCH,0
         CMP   DOS_VERSION,500H
         JB    C_D_R_INIT

         MOV   UMB_LINK_STAT,0FFH
         MOV   AX,5802H
         DOSEXEC
         JC    C_D_R_INIT

         MOV   UMB_LINK_STAT,AL
         OR    UMB_SWITCH,OK_TO_SEARCH_UMBS

C_D_R_INIT:
         mov   bx,-1
         mov   ah,52h          ;'Undoc' call: Get ptr to DOS internal vars.
         int   21h
         cmp   bx,-1           ;This should never happen, but
         JE    CHK_DTRK_ERR_JMP ;if it does, we'll refuse to install.

         mov   dx,es:[bx-2]    ;Fetch segment of first Memory Control Block.
         push  cs
         pop   ds
         cld
         sti                   ;In case we hang, allow warm boot.
         xor   bx,bx
         jmp   SHORT chk_dtrk_next

CHK_DTRK_ERR_JMP:
         JMP   SHORT CHK_DTRK_ERR

chk_dtrk_lp:
         mov   es,dx           ;Seg of the MCB.
         cld
         mov   cx, es:[bx].mcb_owner
         mov   ax,dx
         inc   ax
         cmp   ax,cx           ;Owner = Self?  (Is this a PSP segment?)
         jne   chk_dtrk_next   ;No.
         mov   es,ax           ;Segment of block itself (MCB+1).
         cmp   word ptr es:[bx+0], 20CDh       ;1st word of a PSP = 'INT 20h'.
         jne   chk_dtrk_next
         mov   cx,cs
         cmp   ax,cx           ;Is the segment = our CS ?
         je    chk_dtrk_next   ;No point in comparing against ourself!

; Found a resident program.  Check if it is MIRROR.

         mov   cx,org_id_length
         lea   si,$entry       ;M006; Start of COM file.
         mov   di,si
         repe  cmpsb
         je    chk_dtrk_found  ;Yes, resident delete-tracker & same version!

; Not an exact match, but maybe an old version?

         mov   cx,org_id2_length
         lea   si,org_id2
         mov   di,si
         repe  cmpsb
         je    chk_dtrk_err    ;An old version!  Cannot load or unload.

chk_dtrk_next:
         mov   es,dx
         cld
         mov   al, es:[bx].mcb_signature
         cmp   al,5Ah
         je    chk_dtrk_no     ;Last block.
         cmp   al,4Dh
         jne   chk_dtrk_err    ;Bad sig.
         inc   dx
         add   dx, es:[bx].mcb_paras   ;Calculate the next MCB.
         jmp   chk_dtrk_lp

chk_dtrk_found:
         mov   ax,dx
         inc   ax              ;Return segment of resident module.
         stc                     ;Prevent installation.
         jmp   short chk_dtrk_99

chk_dtrk_no:
         TEST  UMB_SWITCH,OK_TO_SEARCH_UMBS
         JZ    CHK_DTRK_NONE

         AND   UMB_SWITCH,NOT OK_TO_SEARCH_UMBS
         INC   DX
         ADD   DX,ES:[BX].MCB_PARAS    ;Calculate the next MCB.
         MOV   ES,DX
         CMP   ES:[BX].MCB_OWNER,8      ; is it UMB start?
         JNE   CHK_DTRK_NONE
         CMP   ES:[BX].MCB_NAME,'CS'    ; is it UMB start?
         JE    CHK_DTRK_LP

chk_dtrk_NONE:
         xor   ax,ax           ;AX=0 (not resident), CF=false (OK to install).
         jmp   short chk_dtrk_99

chk_dtrk_err:
         xor   ax,ax           ;Unknown resident location (cannot unload).
         stc                     ;Prevent installation, too.

chk_dtrk_99:
         PUSH  AX
         PUSHF

         CMP   DOS_VERSION,500H
         JB    C_D_R_EXIT

         CMP   UMB_LINK_STAT,0FFH
         JB    C_D_R_EXIT

         MOV   AX,5803H
         MOV   BH,0
         MOV   BL,UMB_LINK_STAT
         DOSEXEC

C_D_R_EXIT:
         POPF
         POP   AX
         pop   es
         pop   ds
         pop   di
         pop   si
         pop   dx
         pop   cx
         pop   bx
         ret

CHK_DTRK_RESIDENT ENDP



VALIFY_COMMAND_LINE PROC NEAR
         MOV   DS,CS_SAVE
         MOV   SI,81H                   ; point to command line
         MOV   CL,[SI-1]                ; get character count
         MOV   CH,0
         JCXZ  V_C_L_CLC_JMP_1          ; if none, exit

         MOV   AL,'?'
         MOV   DI,SI
         CLD
         REPNE SCASB
         MOV   CL,[SI-1]                ; get character count
         JNE   V_C_L_LOOP
         JMP   V_C_L_CLC

V_C_L_LOOP:
         CALL  FIND_NEXT_NON_BLANK
         JC    V_C_L_CLC_JMP_1          ; nothing but blanks, etc

         CMP   AL,'/'                   ; slash parm?
         JE    V_C_L_CHK_SLASH

V_C_L_FIND_COLON:
         JCXZ  V_C_L_STC_JMP_1          ; if no colon, error
;M006
         CALL  CheckDrive               ; Valid drive?
	 JC    V_C_L_STC_JMP_1	        ;  -no, jump.
;M006
         LODSB                          ; get next character
         DEC   CX
         CMP   AL,':'                   ; is it a colon?
         JNE   V_C_L_STC_JMP_1
         OR    COMMAND_LINE_CHECK_SWITCH,GOTTA_DRIVE_LETTER

         JCXZ  V_C_L_CLC_JMP_1
         LODSB                          ; get next character
         DEC   CX
         CMP   AL,'/'                   ; if slash, branch
         JE    V_C_L_CHK_SLASH          ;
         CMP   AL,' '                   ;*
         JE    V_C_L_LOOP               ;
         CMP   AL,13                    ; bypass white space
         JE    V_C_L_LOOP               ;
         CMP   AL,9                     ;
         JE    V_C_L_LOOP               ;*

V_C_L_STC_JMP_1:
         JMP   V_C_L_STC

V_C_L_CLC_JMP_1:
         JMP   V_C_L_CLC

V_C_L_CHK_SLASH:
         JCXZ  V_C_L_STC_JMP_1

         LODSB                          ; get parameter itself
         DEC   CX
;M001
; We do not check for the /1 switch. Do the check before we change to
;uppercase
;
	cmp	al, '1'	; is it /1? ;M001
	je	v_c_l_one	; yes ;M001

         AND   AL,NOT 20H
         CMP   AL,'U'
         JE    V_C_L_UNLOAD
         CMP   AL,'T'
         JE    V_C_L_TRACK
         CMP   AL,'P'
         JE    V_C_L_PARTN
         JMP   V_C_L_STC

;M001 -- Begin changes
; We have found a /1. Do some validity checking on it. It is not valid if a
;/partn or /u switch has been detected
; 
v_c_l_one:
	test	command_line_check_switch,GOTTA_UNLOAD_LETTER+GOTTA_PARTN_LETTER
	jnz	v_c_l_stc_jmp_1

	or	command_line_check_switch,GOTTA_ONE_LETTER
	jmp	v_c_l_loop
;
;M001 -- End changes
;

V_C_L_UNLOAD:
         CMP   COMMAND_LINE_CHECK_SWITCH,0
         JNE   V_C_L_STC_JMP_1
         OR    COMMAND_LINE_CHECK_SWITCH,GOTTA_UNLOAD_LETTER

         CALL  FIND_NEXT_NON_BLANK
         JC    V_C_L_CLC_JMP_1          ; nothing but blanks, etc
         JMP   V_C_L_STC

V_C_L_PARTN:
         CMP   COMMAND_LINE_CHECK_SWITCH,0
         JNE   V_C_L_STC_JMP_1
         OR    COMMAND_LINE_CHECK_SWITCH,GOTTA_PARTN_LETTER

         CMP   CX,4                     ; gotta have 4 more for ARTN
         JB    V_C_L_STC_JMP_1

         LODSW
         AND   AX,NOT 2020H
         CMP   AX,'RA'
         JNE   V_C_L_STC_JMP_1
         LODSW
         AND   AX,NOT 2020H
         CMP   AX,'NT'
         JNE   V_C_L_STC_JMP_1

         SUB   CX,4

         CALL  FIND_NEXT_NON_BLANK
         JC    V_C_L_CLC_JMP_1          ; nothing but blanks, etc
         JMP   V_C_L_STC

V_C_L_TRACK:
         TEST  COMMAND_LINE_CHECK_SWITCH,GOTTA_UNLOAD_LETTER+GOTTA_PARTN_LETTER
         JNZ   V_C_L_STC_JMP_1

         OR    COMMAND_LINE_CHECK_SWITCH,GOTTA_TRACK_LETTER

         JCXZ  V_C_L_STC
         LODSB
         DEC   CX
;M006
         CALL  CheckDrive               ; Valid drive?
	 JC    V_C_L_STC	        ;  -no, jump.
;M006
         JCXZ  V_C_L_CLC
         LODSB
         DEC   CX

         MOV   TRACK_DIGIT_COUNT,0
         CMP   AL,'-'                   ; is it a continuation of the /Td
         JE    V_C_L_TRACK_CONT         ; yes, branch

         CMP   AL,'/'
         JE    V_C_L_CHK_SLASH_JMP      ; if another parm, branch
         CMP   AL,' '                   ;
         JE    V_C_L_TRACK_OUT          ; otherwise, we better find
         CMP   AL,13                    ; some white space
         JE    V_C_L_TRACK_OUT          ;
         CMP   AL,9                     ;
         JE    V_C_L_TRACK_OUT          ;
         JMP   SHORT V_C_L_STC

V_C_L_CHK_SLASH_JMP:
         JMP   V_C_L_CHK_SLASH

V_C_L_TRACK_OUT:
         CALL  FIND_NEXT_NON_BLANK
         JC    V_C_L_CLC                ; nothing but blanks, etc
         CMP   AL,'/'                   ; next thing we find better be

;         JE    V_C_L_CHK_SLASH_JMP      ; a slash
;         JMP   V_C_L_STC

         JNE   V_C_L_STC                ; invert the check to avoid jmp to jmp
         JMP   V_C_L_CHK_SLASH

V_C_L_TRACK_CONT:
         JCXZ  V_C_L_STC
         LODSB                          ; after a dash, we need at
         DEC   CX                       ; least one digit

V_C_L_CHK_NUM:
         CMP   AL,'0'
         JB    V_C_L_STC
         CMP   AL,'9'
         JA    V_C_L_STC
         INC   TRACK_DIGIT_COUNT
         CMP   TRACK_DIGIT_COUNT,3
         JA    V_C_L_STC

         JCXZ  V_C_L_CLC
         LODSB
         DEC   CX
         CMP   AL,'/'
         JE    V_C_L_CHK_SLASH_JMP
         CMP   AL,' '
         JE    V_C_L_TRACK_OUT
         CMP   AL,13
         JE    V_C_L_TRACK_OUT
         CMP   AL,9
         JE    V_C_L_TRACK_OUT
         JMP   V_C_L_CHK_NUM

V_C_L_CLC:
;M006: If didn't find Drive Letter or /U or /PARTN, check Default Drive.

	test	command_line_check_switch,GOTTA_DRIVE_LETTER OR GOTTA_UNLOAD_LETTER OR GOTTA_PARTN_LETTER
	jnz	vclx            ;TEST sets C=0.

        mov     ah,19h
        int     21h             ;AL = drive code (0-25).
        add     al,'A'
        call    CheckDrive      ;Default drive valid?
        jnc     vclx            ; -yes, jump.
;M006
V_C_L_STC:
         STC
vclx:    RET                    ;M006.

VALIFY_COMMAND_LINE ENDP



FIND_NEXT_NON_BLANK PROC NEAR
         JCXZ  F_N_N_B_STC              ; ain't got nomore

         LODSB
         DEC   CX
         CMP   AL,' '                   ; blank
         JE    FIND_NEXT_NON_BLANK
         CMP   AL,13                    ; carriage return
         JE    FIND_NEXT_NON_BLANK
         CMP   AL,09                    ; tab
         JE    FIND_NEXT_NON_BLANK
         CLC
         RET

F_N_N_B_STC:
         STC
         RET

FIND_NEXT_NON_BLANK ENDP



PARSE_PARMS PROC NEAR
         MOV   DS,CS_SAVE
         MOV   ES,CS_SAVE
         MOV   DI,81H
         MOV   CL,[DI-1]
         MOV   CH,0
         JCXZ  P_P_CLC

P_P_LOOP:
         CLD
         MOV   AL,'/'
         REPNE SCASB
         JNE   P_P_CLC
         JCXZ  P_P_CLC

; changed 04-26-90 to use Uppercase Proc.  GWD.
         push  ax
         mov   al,[di]
         call  uppercase
         cmp   al,"T"
         pop   ax
         JE    P_P_PROCESS

         push  ax
         mov   al,[di]
         call  uppercase
         cmp   al,'S'
         pop   ax
         JNE   P_P_LOOP

         OR    INSTALL_SWITCH,DO_IT_THE_SLOW_WAY
         JMP   P_P_LOOP

P_P_PROCESS:
         CALL  VALIFY_PARM
         JC    P_P_STC
         JMP   P_P_LOOP

P_P_CLC:
         CLC
         RET

P_P_STC:
         STC
         RET

PARSE_PARMS ENDP



FIND_SLASH_TEE PROC NEAR
         MOV   DI,81H
         MOV   CH,0
         MOV   CL,[DI-1]
         JCXZ  FIND_ST_EXIT

FIND_ST_REPEAT:
         MOV   AL,'/'
         REPNE SCASB
         JCXZ  FIND_ST_EXIT
         JNE   FIND_ST_EXIT
         MOV   AL,[DI]
         CALL  UPPERCASE
         CMP   AL,'T'
         JNE   FIND_ST_REPEAT
         OR    INSTALL_SWITCH,GOT_SLASH_TEE

FIND_ST_EXIT:
         RET

FIND_SLASH_TEE ENDP



VALIFY_PARM PROC NEAR
         OR    BYTE PTR [DI],20H        ; makr parm lower case
         MOV   AL,[DI]+1                ; get drive letter
         OR    AL,20H                   ; lower case
         CMP   AL,'a'
         JB    V_P_STC
         CMP   AL,'z'
         JA    V_P_STC
         CMP   BYTE PTR [DI+2],'-'
         JE    V_P_COUNT
         MOV   AL,[DI+2]
         CALL  CHECK_FOR_TERMINATOR
         JNC   V_P_STC

         MOV   AX,0

V_P_FORCE_AUTO:
	 CALL  CONVERT_TO_DISP
         MOV   DRIVES_GIVEN_TABLE[BX],AX ; stuff it in
         OR    INSTALL_SWITCH,GOT_SUMTHIN_TO_TRACK
         CALL  FIND_SECTOR_SIZE
         JMP   SHORT V_P_CLC

V_P_COUNT:
         LEA   SI,[DI+3]
         CALL  CHECK_COUNT
         JC    V_P_STC
         JMP   V_P_FORCE_AUTO

V_P_CLC:
         CLC
         RET

V_P_STC:
         STC
         RET

VALIFY_PARM ENDP



FIND_SECTOR_SIZE PROC NEAR
         PUSH  DS
         MOV   DH,0
         CMP   AX,0FFFFH
         JE    F_S_EXIT
         MOV   AH,0
         MOV   AL,[DI+1]
         OR    AL,20H
         SUB   AL,61H
         CMP   PHYS_DRV,AX
         JNB   F_S_EXIT

         MOV   DL,AL
         INC   DL
         MOV   BL,DL

         MOV   AX,440EH
         DOSEXEC
         JC    F_S_BYPASS
         MOV   DH,AL

         MOV   AX,440FH
         DOSEXEC

F_S_BYPASS:
         MOV   AH,32H
         DOSEXEC
         CMP   AL,0FFH
         JE    F_S_EXIT

         MOV   AX,[BX+2]                ; get sector size
         CMP   AX,LARGEST_SECTOR
         JB    F_S_EXIT
         MOV   LARGEST_SECTOR,AX

F_S_EXIT:
         CMP   DH,0
         JE    F_S_LEAVE
         MOV   BL,DH
         MOV   AX,440FH
         DOSEXEC

F_S_LEAVE:
         POP   DS
         RET

FIND_SECTOR_SIZE ENDP



CHECK_FOR_TERMINATOR PROC NEAR
         CMP   AL,'/'                   ; nuther parm
         JE    C_F_T_STC
         CMP   AL,' '                   ; blank
         JE    C_F_T_STC
         CMP   AL,13                    ; carriage return
         JE    C_F_T_STC
         CMP   AL,09                    ; tab
         JE    C_F_T_STC
         CLC
         RET

C_F_T_STC:
         STC
         RET

CHECK_FOR_TERMINATOR ENDP



CONVERT_TO_DISP PROC NEAR
         PUSH  AX
         MOV   AL,[DI+1]
         OR    AL,20H
         SUB   AL,61H
         MOV   BL,AL
         MOV   BH,0
         SHL   BX,1
         POP   AX
         RET

CONVERT_TO_DISP ENDP



CHECK_COUNT PROC NEAR
         PUSH  DX
         PUSH  CX
         PUSH  BX
         MOV   CX,3
         MOV   BX,0

C_C_LOOP:
         MOV   AL,[SI]
         CALL  CHECK_FOR_TERMINATOR
         JC    C_C_TERM
         CMP   AL,'0'
         JB    C_C_STC
         CMP   AL,'9'
         JA    C_C_STC
         MOV   AX,BX
         MOV   BX,10
         MUL   BX
         MOV   BX,AX
         MOV   AL,[SI]
         SUB   AL,30H
         MOV   AH,0
         ADD   BX,AX
         INC   SI
         LOOP  C_C_LOOP
         MOV   AL,[SI]
         CALL  CHECK_FOR_TERMINATOR     ; better be a terminator
         JNC   C_C_STC

C_C_TERM:
         CMP   BX,0
         JE    C_C_STC
         MOV   AX,BX
         CLC
         JMP   SHORT C_C_EXIT

C_C_STC:
         STC

C_C_EXIT:
         POP   BX
         POP   CX
         POP   DX
         RET

CHECK_COUNT ENDP



DISPLAY_RESULTS PROC NEAR
         LEA   DX,RESULTS_PREFIX
         MOV   AH,9
         DOSEXEC

         MOV   CX,26
         MOV   BX,0

D_R_LOOP:
         CMP   DRIVES_GIVEN_TABLE[BX],0FFFFH
         JE    D_R_INC
         MOV   AX,DRIVES_GIVEN_TABLE[BX]
         CMP   AX,0
         JE    D_R_AUTO
         CALL  HEX_TO_ASCII
         LEA   DX,RESULTS_NUMBER
         JMP   SHORT D_R_PRINT

D_R_AUTO:
         LEA   DX,RESULTS_AUTO

D_R_PRINT:
         PUSH  DX
         LEA   DX,RESULTS_DRIVE
         MOV   AH,9
         DOSEXEC
         POP   DX
         DOSEXEC

D_R_INC:
         INC   RESULTS_DRIVE_NUM
         ADD   BX,2
         LOOP  D_R_LOOP
         RET

DISPLAY_RESULTS ENDP



HEX_TO_ASCII PROC NEAR
         PUSH  AX
         PUSH  BX
         PUSH  CX
         PUSH  DX
         PUSH  DI

         MOV   CX,3
         MOV   DX,0
         MOV   WORD PTR RESULTS_NUMBER,'  '

         LEA   DI,RESULTS_NUMBER+2
         MOV   BX,10

HEX_TO_ASCIIZ_DIV:
         DIV   BX                 ;PERFORM DIVISION
;        AX = QUOTIENT
;        DX = REMAINDER
         ADD   DL,30H             ;MAKE RELATIVE TO ASCII ZERO
         MOV   BYTE PTR [DI],DL   ;MOVE VALUE TO OUTPUT AREA
         DEC   DI                 ;DECREMENT OUTPUT POINTER
         MOV   DX,0               ;ADJUST AX BACK TO 32 BIT NUMBER
         CMP   AX,0
         JE    HEX_TO_ASCIIZ_EXIT
         LOOP  HEX_TO_ASCIIZ_DIV

HEX_TO_ASCIIZ_EXIT:
         POP   DI
         POP   DX
         POP   CX
         POP   BX
         POP   AX
         RET

HEX_TO_ASCII ENDP



HOOK_UP_CRITICAL_ERROR PROC NEAR
         PUSH  ES
         MOV   AX,3524H
         DOSEXEC
         MOV   C_E_H_SEG,ES
         MOV   C_E_H_OFF,BX
         POP   ES

         LEA   DX,C_E_HANDLER
         MOV   AX,2524H
         DOSEXEC
         RET

HOOK_UP_CRITICAL_ERROR ENDP



UNHOOK_UP_CRITICAL_ERROR PROC NEAR
         PUSH  DS
         LDS   BX,C_E_H_DWORD
         MOV   AX,2524H
         DOSEXEC
         POP   DS
         RET

UNHOOK_UP_CRITICAL_ERROR ENDP



C_E_HANDLER PROC FAR
         MOV   AL,0                     ; ignore all errors
         IRET

C_E_HANDLER ENDP

	BREAK <CheckDrive>

;Routine name:  CheckDrive
;
;Description:   Verifies that input drive letter is valid, checks
;		if drive is ASSIGN'd, and checks the drive's Current Directory
;		Structure (CDS) flags to determine if it is In Use, and
;		whether it is a Net, SUBST'd, or JOIN'd drive.
;
;Called Procedures:
;               INT 21H, function 52H ($GET_IN_VARS)
;
;Input:         AL = drive letter (upper or lower case)
;
;Output:        C=1 if a drive letter invalid or unused, or if drive is a
;		ASSIGN'd, NET, SUBST'd, or JOIN'd drive; otherwise C=0.
;
;Uses:          BX,DX
;
;Change History: Created  02/11/91  M006

public CheckDrive

CheckDrive PROC NEAR

ASSUME  ES:NOTHING

        SaveReg <es,ax,cx,si,di>

        call	UPPERCASE		;Convert drive letter to upper case.
        cmp     al,'A'
        jb      cd5
        cmp     al,'Z'
        ja      cd5

        call    check_network_drive     ;Net drive?
        jc      cd5                     ; -yes, jump.

        sub     al,'A'-1
        mov	ah,0			;AX = drive # (1-26).
        push    ax                      ;Save it.

        mov     ax,0601h                ;Get ASSIGN state and Segment.
        int     2fh
        cmp     al,0ffh                 ;ASSIGN installed?
        jne     cd2                     ; -no, jump.
                                        ; -yes: ES:103h -> ASSIGN drive map.

        pop     bx                      ;BX = drive # (1-26).
        mov     al,es:[bx].102h         ;AL = mapped drive # (1-26).
        cmp     bl,al                   ;Drive ASSIGN'd?
        jne     cd5                     ; -yes, jump.
        push    bx

cd2:    mov     ah,Get_In_Vars
        int     21h                     ;ES:BX -> SysInitVars structure.

        pop     ax                      ;AL = drive # (1-26).

        cmp     al,es:[bx].SYSI_NCDS    ;Drive in CDS?
        ja      cd5	                ; -No, jump.

        les     bx,es:[bx].SYSI_CDS     ;ES:BX -> Head of CDS list.
        mov     dl,curdirLen            ;DL = size of CDS entry.
        dec     al                      ;AL = drive code (0-25).
        mul     dl                      ;AX = offset of drive's CDS entry.
        add     bx,ax                   ;ES:BX -> CDS entry for drive.

; Invalid if not in use.

	test    es:[bx].CURDIR_FLAGS,CURDIR_inuse
        jz      cd5

; Invalid if Net, SUBST'd, or JOIN'd drive.

        test    es:[bx].CURDIR_FLAGS,(CURDIR_isnet OR CURDIR_local OR CURDIR_splice)
        jz	cdx                   	;TEST sets C=0.

cd5:	stc                             ;Invalid drive.
cdx:    RestoreReg <di,si,cx,ax,es>
	ret

CheckDrive ENDP


CODE     ENDS
         END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\mirror\mir_main.asm ===
; Copyright (c) 1990-1991 Central Point Software, Inc. 
; All rights reserved.
;--------------------------------------------------------
; MIRROR   10-25-88.
;
; (this does not include the Delete Tracking module)
; (the messages are in an INCLUDE-file)
;
; Added CALL to save the hard disk partition info
; to a floppy disk (in MIR_PRTN module).  v5.0	GWD.
;
; Version # is now EQUated, banner messages automatically follow it.
;
; Added code to recognize Zenith 3.30 DOS & support huge partns. 11-18-88 GWD.
;
; Reworked network checking.  5-1-89 GWD.
;
; If FAT>64k, program screws up.  Too hard to fix Jim's kluged code, so
; only added a check for sector_count>128 and fake an error.  5-1-89 GWD.
;
; Added /N option to suppress mirror.fil, etc, writing.  04-26-90 GWD.
; Removed display of main title & version (done in _DTRK).  04-26-90 GWD.
; /N is assumed (& not required) when LOADHI (et al) is used.  05-25-90 GWD.
;
;--------------------------------------------------------
;
; 01/30/91 SR	M002 -- Bug #5298 -- made message length independent
; ??/??/?? ??   M005
; 02/12/91 DLB  M006 -- Made check_network PUBLIC; changed DOS_VERSION to be
;                       EXTRN.
; 02/21/90 DLB  M008 -- Changed DOS_VERSION to be PUBLIC.
; 02/24/90 DLB  M009 -- MIRORSAV.FIL was over-writing existing files under
;                       certain conditions.  Also fixed detection of pre-
;                       existing sectors which contain MIRORSAV.FIL signature.

	PAGE  66,131



DRIVE		EQU BYTE PTR DS:[SI]+1

NUM_HEADS	EQU	WORD PTR DS:[SI]+2

LIST_COUNT	EQU	WORD PTR DS:[SI]+18
XLAT_TABLE	EQU	WORD PTR DS:[SI]+20
ENTRY_LEN	EQU	22

; used to build the sector table
FROM_LSN	EQU	WORD PTR DS:[BX]
FROM_LSN_HI	EQU	WORD PTR DS:[BX]+2
TO_LSN		EQU   WORD PTR DS:[BX]+4
TO_LSN_HI	EQU	WORD PTR DS:[BX]+6


CODE	SEGMENT PARA PUBLIC 'CODE'

INCL_MIRROR EQU $
	INCLUDE MIR_MSG.INC


	ASSUME	CS:CODE, DS:nothing

	PUBLIC  MIRROR
        PUBLIC  check_network_drive             	;M006
        PUBLIC  DOS_VERSION				;M008

K_ESCAPE	EQU	27

DOS_VERSION DW 0       			;M008: High byte is major ver. #.

RETURN_CODE DB 0
PASSED_DRIVE DB 0
BYTES_PER_CLUSTER_SHIFT_COUNT DW 0

CS_SAVE DW	0
START_OF_ROOT_OFFSET  DW 0
START_OF_ROOT_SEGMENT DW 0

SWITCH		  DB  0
ONE_FILE_ONLY	  EQU 80H
QUIET_MODE	  EQU 40H
GOTTA_PRE_CONTROL EQU 20H
GOTTA_PRE_IMAGE   EQU 10H

OLD_1BH_DWORD LABEL DWORD
OLD_1BH_OFF DW 0
OLD_1BH_SEG DW 0

OLD_23H_DWORD LABEL DWORD
OLD_23H_OFF DW 0
OLD_23H_SEG DW 0

BREAK_SWITCH DB 0
BEEN_BROKE   EQU 80H

OUR_THREE_SECTOR_SEGMENT DW 0
USE_AREA_PARAS DW 0

USE_DWORD	DD	0
	ORG	USE_DWORD
USE_POINTER	DW	0
USE_SEGMENT	DW	0
FAILURE_TYPE	DB	0		; M005;

;------------------------------------------------------


MIRROR	PROC
	PUSH   DS
	PUSH   ES
	CLD
	MOV	CS:CS_SAVE,CS
	MOV	DS,CS_SAVE
	MOV	ES,CS_SAVE
	MOV	RETURN_CODE,0
	MOV	FAILURE_TYPE,0		; M005; 
	MOV	PASSED_DRIVE,0

	CMP	AX,5050H	; is it MS-DOS FORMAT?
	JNE	MIRROR_PREP	; no, branch

	OR	SWITCH,QUIET_MODE	; yes, remember it
	ADD	BL,41H	; and save
	MOV	PASSED_DRIVE,BL 	;   the passed drive

MIRROR_PREP:
	MOV	AL,DS:[80H]	; get parm length
	MOV	AH,0
	MOV	cs:PARM_COUNT,AX

	MOV	AX,3306H	; get true DOS version
	MOV	BX,0	;   ala DOS 5.0
	INT	21H
	CMP	BL,5	; function supported?
	JB	VERSION_OLD_WAY
	MOV	AX,BX
	XCHG	AH,AL
	JMP	SHORT STORE_DOSVER

VERSION_OLD_WAY:
	mov	ah,30h	;Get DOS version.
	INT	21H
	xchg	al,ah
	cmp	ax,(3*256)+30
	jne	store_dosver
	cmp	bh,5	;Zenith DOS?
	jne	store_dosver
	mov	al,31	;Treat Zenith 3.30 like Compaq 3.31.

STORE_DOSVER:
	mov	cs:dos_version,ax

	TEST	SWITCH,QUIET_MODE	; are we in MSDOS FORMAT?
	JNZ	NO_SLASH_ONE	; yes, branch

	push	ds
	pop	es
	cld
	mov	al,"/"
	mov	di,81h
	mov	cl,ds:[di-1]
	mov	ch,0

find_slash_n:
	jcxz	no_slash_n
	repne scasb
	jne	no_slash_n
	jcxz	no_slash_n
	mov	al,es:[di]
;	call	uppercase
	and	al,not 20h
	cmp	al,"N"
	jne	find_slash_n

got_slash_n:
	clc
	jmp	mirror_return	;Write no mirror.fil, etc.

no_slash_n:
	CALL	FIND_SLASH_ONE	;May set ONE_FILE_ONLY bit in SWITCH.

NO_SLASH_ONE:
	MOV	byte ptr cs:OUR_SIGNATURE,'A'

	TEST	SWITCH,QUIET_MODE	; are we in MSDOS FORMAT?
	JNZ	DONT_ISSUE_CRIGHT       ; yes, branch

	LEA	DX,COPYRIGHT_3	;lf,cr,"Creates image of system area.."
	mov	ah,9
	INT	21H

DONT_ISSUE_CRIGHT:
	cmp	cs:dos_version,200h
	jae	proceed
	LEA	DX,BAD_VERSION
	MOV	RETURN_CODE,5
	MOV	AH,9
	INT	21H
	JMP	SHORT cant_process

PROCEED:
;	MOV	byte ptr cs:OUR_SIGNATURE,'A'
;	CALL	FIND_SLASH_ONE	;May set ONE_FILE_ONLY bit in SWITCH.
         CALL  SETUP_CTRL_BRK_INTERCEPTS

GET_DRIVE_LOOP:
	MOV	AL,PASSED_DRIVE
	TEST	SWITCH,QUIET_MODE
	JNZ	ANOTHER_DRIVE  ; if from MS-DOS FORMAT, drive in AL

	CALL	GET_NEXT_DRIVE	;Returns ASCII drive letter.
	jnc	another_drive
	 JMP   SHORT PROCESS_CHECK	;No more drives were requested.

ANOTHER_DRIVE:
	CALL	VALIFY_EACH_DRIVE	;Does it all.
	jnc	made_it_ok
	 JMP   SHORT  FORGET_PROCESS	;Error.

made_it_ok:
	TEST	SWITCH,QUIET_MODE
	JNZ	PROCESS_CHECK  ; if from MS-DOS FORMAT, don't loop
	jmp	get_drive_loop

PROCESS_CHECK:
	TEST	SWITCH,QUIET_MODE
	JNZ	MIRROR_RETURN

	MOV	DS,cs:CS_SAVE
	LEA	DX,MSG	; "MIRROR successful"
	MOV	AH,9
	INT	21H
	CLC
	jmp	short mirror_return

FORGET_PROCESS:
	TEST	SWITCH,QUIET_MODE
	JNZ	CANT_PROCESS

	MOV	DS,cs:CS_SAVE
	LEA	DX,FAIL_MSG	; "MIRROR unsuccessful"
	MOV	AH,9
	INT	21H

CANT_PROCESS:
	STC

MIRROR_RETURN:
         CALL  RESTORE_CTRL_BRK_INTERCEPTS

	CMP   OUR_THREE_SECTOR_SEGMENT,0
	JE    M_R_1

	MOV   ES,OUR_THREE_SECTOR_SEGMENT
	MOV   AH,49H
	INT   21H
	MOV   OUR_THREE_SECTOR_SEGMENT,0

M_R_1:
	CMP   USE_SEGMENT,0
	JE    M_R_2

	MOV   ES,USE_SEGMENT
	MOV   AH,49H
	INT   21H
	MOV   USE_SEGMENT,0

M_R_2:
	MOV   AL,RETURN_CODE
	MOV   AH,FAILURE_TYPE			; M005;
	POP   ES
	POP   DS
	RET

MIRROR	ENDP



SETUP_CTRL_BRK_INTERCEPTS PROC NEAR
         MOV   AX,351BH
         INT   21H
         MOV   OLD_1BH_SEG,ES
         MOV   OLD_1BH_OFF,BX

         MOV   AX,3523H
         INT   21H
         MOV   OLD_23H_SEG,ES
         MOV   OLD_23H_OFF,BX

         PUSH  CS
         POP   DS
         LEA   DX,OUR_1B_ROUTINE
         MOV   AX,251BH
         INT   21H

         LEA   DX,OUR_23_ROUTINE
         MOV   AX,2523H
         INT   21H

         RET

SETUP_CTRL_BRK_INTERCEPTS ENDP



RESTORE_CTRL_BRK_INTERCEPTS PROC NEAR
         CMP   OLD_1BH_SEG,0
         JE    R_C_B_I_RET

         LDS   DX,OLD_1BH_DWORD  
         MOV   AX,251BH
         INT   21H

         LDS   DX,OLD_23H_DWORD  
         MOV   AX,2523H
         INT   21H

R_C_B_I_RET:
         RET

RESTORE_CTRL_BRK_INTERCEPTS ENDP



OUR_1B_ROUTINE PROC NEAR
         OR    BREAK_SWITCH,BEEN_BROKE
         IRET

OUR_1B_ROUTINE ENDP



OUR_23_ROUTINE PROC NEAR
         OR    BREAK_SWITCH,BEEN_BROKE 
         IRET

OUR_23_ROUTINE ENDP



HEX_TO_ASCII PROC NEAR
	COMMENT *
	THE	PURPOSE OF THIS ROUTINE IS TO TAKE A HEX VALUE AND
	CONVERT IT TO decimal ASCII SO IT CAN BE DISPLAYED.

	INPUT:
		 CX - CONTAINS THE NUMBER OF OUTPUT ASCII CHARACTERS
		 BX - CONTAINS THE OFFSET INTO DS OF THE OUTPUT FIELD
		 DX:AX - CONTAINS THE NUMBER TO BE CONVERTED
	*

	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	DI
	PUSH	SI
	PUSH	BP

	MOV	DI,BX	;USE DI AS FLOATING POINTER
	ADD	DI,CX	;POINT TO BYTE BEYOND FIELD
	DEC	DI	;BACKUP TO LAST BYTE
	MOV	BX,10000	;DIVIDE BY 10000
	DIV	BX	; BREAK INTO 2 PARTS
	MOV	BP,AX	; SAVE HI PART
	MOV	AX,DX	; WORK ON LOW PART FIRST
	MOV	DX,0
	MOV	SI,0
	CMP	CX,4
	JNA	PRE_CONV2
	MOV	SI,CX
	SUB	SI,4
	MOV	CX,4
; THE PURPOSE OF THE ABOVE INSTRUCTIONS IS BECAUSE THE OUTPUT FIELD IS
; CREATED RIGHT TO LEFT.
PRE_CONV2:
	MOV	BX,10
CONV2:
	DIV	BX	;PERFORM DIVISION
;	 AX = QUOTIENT
;	 DX = REMAINDER
	ADD	DL,30H	;MAKE RELATIVE TO ASCII ZERO
	MOV	BYTE PTR [DI],DL   ;MOVE VALUE TO OUTPUT AREA
	DEC	DI	;DECREMENT OUTPUT POINTER
	MOV	DX,0	;ADJUST AX BACK TO 32 BIT NUMBER
	LOOP	CONV2
	MOV	AX,BP
	MOV	DX,0
	MOV	CX,SI
	MOV	SI,0
	MOV	BP,0
	JCXZ	CONV2_OUT
	JMP	CONV2

CONV2_OUT:
	POP	BP
	POP	SI
	POP	DI
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	RET

HEX_TO_ASCII ENDP



;BOOT_FAT_OR_DIR DB 0
;DIRECTORY	  EQU 80H
;MEMORY_SET	  EQU 40H

ABS_25_LIST	LABEL BYTE
ABS_25_SEC_LO	DW    0
ABS_25_SEC_HI	DW    0
ABS_25_COUNT	DW    0
ABS_25_OFF	DW    0
ABS_25_SEG	DW    0

NUM_SECTORS_PER_64K   DW 0
TOTAL_SECTORS_TO_READ DW 0

HANDLE		DW  0
HANDLE_CTL	DW  0

PARM_OFFSET	DW  81H
PARM_COUNT	DW  0

IO_AREA_DWORD	DD  0
	ORG	IO_AREA_DWORD
IO_AREA_OFFSET	DW  0
IO_AREA_SEGMENT DW 0

NUM_BOOT_SECTORS DW 0
OFFSET_TO_FAT	 DW 0

XLAT_POINTER	DW  0
XLAT_END	DW	0

BACKUP_IND_BYTE DB 0FFH

ASCIIZ_BACKUP	DB  'x:\MIRROR.BAK',0
ASCIIZ_TEMP	DB  'x:\MIRROR.$$$',0

ASCIIZ		DB  'x:\MIRROR.FIL',0

		DB  8 DUP(0)

MIRROR_SWITCH	DB   0
ABS_25_HARD_WAY EQU 80H

BACKUP_LSEEK	EQU $-ASCIIZ
BACKUP_IND	DB  0
BACKUP_LSN	DW  0
	ORG	ASCIIZ+26


CTL1_LSN	DW	0
CTL1_LSN_HI	DW  0

CTL2_LSN	DW	0
CTL2_LSN_HI	DW  0

SECTOR_SIZE	DW 0
NUM_SECTORS_TO_HANDLE DW 0
NUM_BOOT_FAT_SECTORS  DW 0
NUM_DIR_SECTORS       DW 0
FIRST_DIRECTORY_SECTOR DW 0
HEADS		       DW 0
NUM_FATS		DB 0
NUM_RESERVED	 DW 0
SECTORS_PER_CLU DB 0
SECTORS_PER_TRACK DW 0
NUM_HIDDEN	 DW 0
NUM_CTL_SECTORS DW 0
ALT_SECTOR_SIZE DW 0

	DB	16 DUP(0)
	ORG	ASCIIZ+64
CTL_LEN EQU	$-ASCIIZ

DIR_ENTRY_LEN	        EQU 32
TRYIN_CLUSTERS	        DW  0
NUM_FAT_SECTORS        DW  0
HIGHEST_CLUSTER        DW  0
FIRST_DATA_SECTOR      DW  0
CLUSTERS_WEVE_TRIED    DW  0
OUR_SPOTS_FAT_SECTOR_DISP  DW 0
OUR_SPOTS_DIR_SECTORS_LEFT DW 0
OUR_SPOTS_FAT_SECTOR       DW 0
CONTROL_FILE_START_CLU     DW 0
FAT_NEXT_CLUSTER           DW 0

SECTORS_LEFT_TO_WRITE      DW 0
SECTORS_MAX_AT_A_TIME      DW 0
MAX_WRITE_UPDATE_DS        DW 0

OUR_SPOTS_DIR_ENTRY DB 'MIRORSAVFIL'
		     DB  27H   	; archive+hidden+sys+read-only
		     DB  10 DUP(0)
		     DW  0     	; time
		     DW  0     	; date
OUR_SPOTS_START_CLU DW  0
		     DW  OUR_SPOTS_NEW_LEN ; size (lo)
		     DW  0    	; size (hi)

FAT_INFO		DB   0
FAT_EQU_16_BITS EQU 80H
CLU_IS_A_BADDIE EQU 40H

START_CLU	     DW  0
START_CLU_LAST	     DW  0
START_CLU_CONT	     DW  0
REL_SECTOR	     DW  0
REL_CLUSTER	     DW  0
REL_CLUSTER_LAST    DW  0

OUR_SPOT_ASCIIZ DB  'x:\'
		 DB  'MIRORSAV.FIL',0

OUR_SPOTS_FILE_NAME DB 'MIRORSAVFIL'

OUR_SPOTS_CTL_FILE_NAME DB 'MIRROR  FIL'

;M009: ********** START CONTIGUOUS BLOCK ***********************************

OUR_SPOTS_IO_AREA DW 0,0
OUR_SIGNATURE_OFFSET EQU $-OUR_SPOTS_IO_AREA  ;M009: SIGNATURE offset in block.
OUR_SIGNATURE	   DB 'aMSESLIFVASRORIMESAEP'
OUR_SIGNATURE_LEN EQU $-OUR_SIGNATURE
OUR_SPOTS_YEAR	   DW 0
OUR_SPOTS_MODAY   DW 0
OUR_SPOTS_TIME	   DW 0
OUR_SPOTS_OLD	DW 5 DUP(0)
OUR_SPOTS_NEW_LEN EQU $-OUR_SPOTS_IO_AREA

;M009: ********** END CONTIGUOUS BLOCK *************************************

OUR_SPOTS_DIR_OFFSET DW 0

OUR_SPOTS_FAT_OFFSET DW 0



FIND_SLASH_ONE PROC NEAR
	MOV	DI,81H
	MOV	CH,0
	MOV	CL,[DI-1]
	JCXZ	FIND_S1_EXIT

FIND_S1_REPEAT:
	MOV	AL,'/'
	REPNE	SCASB
	JCXZ	FIND_S1_EXIT
	JNE	FIND_S1_EXIT

	CMP	BYTE PTR [DI],'1'
	JNE	FIND_S1_REPEAT
	OR	SWITCH,ONE_FILE_ONLY

FIND_S1_EXIT:
	RET

FIND_SLASH_ONE ENDP

;------------------------------------------------------
; If CF=false, then AL = ascii drive letter.
; If CF=true, then there are no more requested drives.

GET_NEXT_DRIVE PROC NEAR
	MOV	DS,CS_SAVE
	MOV	SI,PARM_OFFSET
	MOV	CX,PARM_COUNT
	MOV	MIRROR_SWITCH,0

GET_NEXT_DRIVE_LOOP:
	JCXZ	NO_MORE_DRIVES
	LODSB
	DEC	CX
	CMP	AL,'/'
	JE	NO_MORE_DRIVES
;	call	uppercase
; 04-26-90 GWD	AND	AL,NOT 20H
	AND	AL,NOT 20H
	CMP	AL,'A'
	JB	GET_NEXT_DRIVE_LOOP
	CMP	AL,'Z'
	JA	GET_NEXT_DRIVE_LOOP

GOT_NEXT_DRIVE:
	MOV	PARM_OFFSET,SI
	MOV	PARM_COUNT,CX
	CLC
	RET

NO_MORE_DRIVES:
	CMP	PARM_OFFSET,81H
	JNE	NO_MORE_DRIVES_REALLY
	MOV	AH,19H
	INT	21H
	ADD	AL,41H
	INC	SI
	MOV	CX,0
	JMP	GOT_NEXT_DRIVE

NO_MORE_DRIVES_REALLY:
	STC
	RET

GET_NEXT_DRIVE ENDP



VALIFY_EACH_DRIVE PROC NEAR
	MOV	ASCIIZ,AL
	MOV	ASCIIZ_BACKUP,AL
	MOV	ASCIIZ_TEMP,AL
	MOV	OUR_SPOT_ASCIIZ,AL

	MOV	DRIVE_MSG+DRV_NAME_LEN,AL ;Use length equate ;M002

	AND	SWITCH,NOT GOTTA_PRE_CONTROL+GOTTA_PRE_IMAGE
	MOV	DS,CS_SAVE

	TEST	SWITCH,QUIET_MODE
	JNZ	V_E_D_NO_MSG

	LEA	DX,DRIVE_MSG
	MOV	AH,9
	INT	21H
	LEA	DX,PROCESSING_MSG
	INT	21H

V_E_D_NO_MSG:
	mov	al,asciiz
	call	check_network_drive	;Added 5-1-89 GWD.
	jnc	not_network
	lea	dx,network_installed
	JMP	VALIFY_ERR_5

NOT_NETWORK:
	CALL	GET_DRIVE_SPECS
	JNC	VALIFY_E_D_CTL_FILE
	JMP	VALIFY_ERR_5

VALIFY_ERR_5_JMP:
	JMP	VALIFY_ERR_5

VALIFY_E_D_CTL_FILE:
         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   VALIFY_ERR_5_JMP

	CALL  CHECK_ON_PREEXISTING_FILES
	LEA   DX,FULL_MSG
	JC    VALIFY_ERR_5_JMP

	CALL	GET_OLD_INFO

         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   VALIFY_ERR_5_JMP

	CALL	CHECK_FOR_OUR_SPOT
	JNC	VALIFY_E_D_0
	CMP	RETURN_CODE,4
	JNE	VALIFY_ERR_5_JMP

VALIFY_ERR_4_JMP:
	JMP	VALIFY_ERR_4

VALIFY_E_D_0:
	CALL	HANDLE_TWO_FILES
	MOV	DS,CS_SAVE
	LEA	DX,ASCIIZ
	MOV	AX,4301H
	MOV	CX,21H	; archive,read-only
	INT	21H
	JNC	VALIFY_E_D_1
	JMP	CREATE_FILE_FIRST

VALIFY_E_D_1:
         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   VALIFY_ERR_5_JMP

	MOV	AX,3D00H
	INT	21H
	JNC	VALIFY_E_D_2

CREATE_FILE_FIRST_JMP:
	JMP	CREATE_FILE_FIRST

VALIFY_E_D_2:
	MOV	HANDLE,AX	       ; get handle

	MOV	BX,HANDLE
	MOV	CX,0
	MOV	DX,0
	MOV	AX,4202H	       ; point to EOF
	INT	21H
	JC	CREATE_FILE_FIRST_JMP	; just go create it again

	DIV	SECTOR_SIZE	       ; get # of sectors it'll take
	MOV	DX,NUM_SECTORS_TO_HANDLE ; get our need
	ADD	DX,2	; don't forget control recs
	CMP	AX,DX	; got enuf room
	JB	CREATE_FILE_FIRST_JMP	; no, just go recreate it

	MOV	BX,HANDLE
	MOV	AH,3EH
	INT	21H
	LEA	DX,CLOSE_MSG
	JC	VALIFY_ERR_5_JMP_1

	MOV	AH,0DH
	INT	21H

;	MOV	CL,4
;	MOV	AX,SECTOR_SIZE
;	SHR	AX,CL
;	MUL	NUM_SECTORS_TO_HANDLE
;	ADD	AX,USE_SEGMENT
;	JC	VALIFY_NO_MEM
;
;	MOV	BX,USE_POINTER
;	SHR	BX,CL
;	ADD	AX,BX
;	JC	VALIFY_NO_MEM
;	CMP	AX,CS:[2]
;	JNA	VALIFY_GOT_MEM
;
;VALIFY_NO_MEM:
;	LEA	DX,NO_MEM_MSG
;	JMP	VALIFY_ERR_5
;
;VALIFY_GOT_MEM:
	LDS	SI,USE_DWORD
	MOV	CX,NUM_BOOT_FAT_SECTORS
	MOV	ABS_25_SEC_LO,0
	MOV	ABS_25_SEC_HI,0
	LDS	BX,IO_AREA_DWORD
	CALL	ABS_25	; read boot and FAT
	LEA	DX,READ_ERROR_MSG
	JC	VALIFY_ERR_4_JMP_1

         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   VALIFY_ERR_5_JMP_1

	MOV	AX,NUM_BOOT_FAT_SECTORS  ;
	MUL	SECTOR_SIZE	;
	PUSH	AX	;   Adjust DS:BX
	MOV	CX,4	;
	SHL	DX,CL	;   to point to the next
	SHR	AX,CL	;
	OR	AH,DL	;   logical spot
	MOV	DX,DS	;
	ADD	DX,AX	;
	MOV	DS,DX	;
	POP	AX	;
	AND	AX,0FH	;
	ADD	BX,AX	;

	MOV	START_OF_ROOT_OFFSET,BX
	MOV	START_OF_ROOT_SEGMENT,DS

	MOV	AX,FIRST_DIRECTORY_SECTOR
	MOV	ABS_25_SEC_LO,AX
	MOV	CX,NUM_DIR_SECTORS
	CALL	ABS_25	; read root
	LEA	DX,READ_ERROR_MSG
	JNC	VALIFY_E_D_3

VALIFY_ERR_4_JMP_1:
	JMP	VALIFY_ERR_4

VALIFY_ERR_5_JMP_1:
	JMP	VALIFY_ERR_5

VALIFY_E_D_3:
         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   VALIFY_ERR_5_JMP_1

	CALL	CHECK_RE_DEFINITION
	JC	VALIFY_ERR_5_JMP_1

	; If in QUIET mode and the files wern't preexisting,
	; gotta delete them out of our root image.
	CALL	MIGHT_NEED_TO_DELETE_FILES

	MOV	DS,CS_SAVE
	LEA	DX,ASCIIZ
	MOV	AX,4301H
	MOV	CX,0
	INT	21H

	MOV	AX,3D02H
	INT	21H
	LEA	DX,OPEN_MSG
	JC	VALIFY_ERR_5_JMP_1
	MOV	HANDLE,AX

	LDS	DX,IO_AREA_DWORD
	MOV	BP,NUM_SECTORS_TO_HANDLE
	CALL	WRITE_FILE
	LEA	DX,WRITE_ERROR_MSG
	JC	VALIFY_ERR_4_JMP_1

; One last thing.  Find the starting cluster number of the control
;  file and stuff it into our little teenie file out at the end.

	MOV	AH,0DH	; no bufferin' DOS
	INT	21H

	MOV	AX,FIRST_DIRECTORY_SECTOR
	MOV	ABS_25_SEC_LO,AX
	MOV	ABS_25_SEC_HI,0
	MOV	AX,NUM_DIR_SECTORS
	MOV	OUR_SPOTS_DIR_SECTORS_LEFT,AX

V_E_D_READ_DIR_LOOP:
         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   VALIFY_ERR_5_JMP_1

;	MOV	DS,CS_SAVE
	MOV	DS,OUR_THREE_SECTOR_SEGMENT
	MOV	BX,OUR_SPOTS_DIR_OFFSET
	MOV	CX,1
	CALL	ABS_25
	LEA	DX,READ_ERROR_MSG
	JNC	V_E_D_CHECK_DIR
	JMP	VALIFY_ERR_4

V_E_D_CHECK_DIR:
	MOV	CL,5
	MOV	AX,SECTOR_SIZE
	SHR	AX,CL
	MOV	CX,AX

V_E_D_CHECK_DIR_LOOP:
	PUSH	CX
	MOV	ES,CS_SAVE
	LEA	DI,OUR_SPOTS_CTL_FILE_NAME
	MOV	CX,11
	MOV	SI,BX
	REPE	CMPSB
	POP	CX
	JE	V_E_D_GOT_OUR_DIR
	ADD	BX,DIR_ENTRY_LEN	; tew next wun
	LOOP	V_E_D_CHECK_DIR_LOOP

	DEC	OUR_SPOTS_DIR_SECTORS_LEFT   ; minus wun
	JZ	V_E_D_NO_DIRS	; oops, none left
	ADD	ABS_25_SEC_LO,1
	ADC	ABS_25_SEC_HI,0
	JMP	V_E_D_READ_DIR_LOOP

V_E_D_NO_DIRS:
	JMP	CREATE_FILE_FIRST

V_E_D_GOT_OUR_DIR:
	MOV	AX,WORD PTR DS:[BX+26]
	MOV	CONTROL_FILE_START_CLU,AX

	MOV	DS,CS_SAVE
	LEA	DX,OUR_SPOT_ASCIIZ
	MOV	AX,4301H
	MOV	CX,0
	INT	21H
	LEA	DX,UPDATE_OURS_ERROR_MSG
	JNC	V_E_D_OPEN_OURS
	JMP	VALIFY_ERR_5

V_E_D_OPEN_OURS:
	LEA	DX,OUR_SPOT_ASCIIZ
	MOV	AX,3D01H	; open for write
	INT	21H	; izit there?
	LEA	DX,UPDATE_OURS_ERROR_MSG
	JNC	V_E_D_GOT_MIRORSAV
	JMP	VALIFY_ERR_5

V_E_D_GOT_MIRORSAV:
	MOV	HANDLE_CTL,AX

	MOV	AX,CONTROL_FILE_START_CLU
	CALL	CONVERT_CLU_TO_LOG_SECTOR
	MOV	AX,ABS_25_SEC_LO
	MOV	OUR_SPOTS_IO_AREA,AX
	MOV	AX,ABS_25_SEC_HI
	MOV	OUR_SPOTS_IO_AREA+2,AX

	MOV	AH,2AH	; get date
	INT	21H
	MOV	OUR_SPOTS_YEAR,CX
	MOV	OUR_SPOTS_MODAY,DX

	MOV	AH,2CH	; get time
	INT	21H
	MOV	OUR_SPOTS_TIME,CX

	MOV	BX,HANDLE_CTL
	MOV	CX,OUR_SPOTS_NEW_LEN
	LEA	DX,OUR_SPOTS_IO_AREA
	MOV	AH,40H	; write
	INT	21H

	LEA	DX,UPDATE_OURS_ERROR_MSG
	CMP	AX,CX
	JE	V_E_D_WROTE_MIRORSAV
	JMP	SHORT VALIFY_ERR_5

V_E_D_WROTE_MIRORSAV:
	MOV	AH,3EH	; close mirorsav.fil
	INT	21H
	LEA	DX,UPDATE_OURS_ERROR_MSG
	JNC	V_E_D_CHANGE_OUR_ATTRS
	JMP	SHORT VALIFY_ERR_5

V_E_D_CHANGE_OUR_ATTRS:
	LEA	DX,OUR_SPOT_ASCIIZ
	MOV	AX,4301H
	MOV	CX,27H	; archive+hidden+sys+read-only
	INT	21H
	LEA	DX,UPDATE_OURS_ERROR_MSG
	JC	VALIFY_ERR_5

	CALL	UPDATE_BACKUP_FILE
	CALL	BUILD_CONTROL_RECORD
	JC	VALIFY_ERR_5
	RET

VALIFY_ERR_4:
	MOV	RETURN_CODE,4
         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   VALIFY_ERR_5  
	JMP	SHORT VALIFY_ERR_STC

VALIFY_ERR_5:
	MOV	RETURN_CODE,5
         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   VALIFY_ERR_BYP

VALIFY_ERR_STC:
	MOV	DS,CS_SAVE
	PUSH	DX
	LEA	DX,DRIVE_MSG
	MOV	AH,9
	INT	21H
	POP	DX
	MOV	AH,9
	INT	21H

; if any trubbles at all, delete the MIRORSAV.FIL

VALIFY_ERR_BYP:
	CALL	MIRORSAV_DELETE

VALIFY_STC_EXIT:
	STC
	RET

CREATE_FILE_FIRST:
	MOV	DS,CS_SAVE
	LEA	DX,ASCIIZ
	MOV	AX,4301H
	MOV	CX,0
	INT	21H	; if file exists, make it
			; deletable
	MOV	AH,41H
	INT	21H	; delete it

	MOV	AH,3CH
	MOV	CX,21H
	INT	21H
	LEA	DX,OPEN_MSG
	JC	VALIFY_ERR_5

	MOV	BX,AX
	MOV	AX,NUM_SECTORS_TO_HANDLE
	ADD	AX,NUM_CTL_SECTORS	; don't forget control records
	MOV	SECTORS_LEFT_TO_WRITE,AX
	MOV	DS,CS_SAVE

RE_CREATE_FILE:
	MOV	AX,SECTORS_MAX_AT_A_TIME
	CMP	AX,SECTORS_LEFT_TO_WRITE
	JNA	RE_CREATE_FILE_1
	MOV	AX,SECTORS_LEFT_TO_WRITE

RE_CREATE_FILE_1:
	SUB	SECTORS_LEFT_TO_WRITE,AX
	MUL	SECTOR_SIZE
	MOV	CX,AX
	MOV	AH,40H
	INT	21H
	LEA	DX,FULL_MSG
	JC	V_E_D_STC_JMP
	CMP	AX,CX
	JNE	V_E_D_STC_JMP
	CMP	SECTORS_LEFT_TO_WRITE,0
	JNE	RE_CREATE_FILE

	MOV	AH,3EH
	INT	21H
	LEA	DX,CLOSE_MSG
	JNC	V_E_D_OPEN

V_E_D_STC_JMP:
	JMP	VALIFY_ERR_5

V_E_D_OPEN:
	MOV	DS,CS_SAVE
	LEA	DX,ASCIIZ
	MOV	AX,3D00H
	INT	21H
	LEA	DX,OPEN_MSG
	JC	V_E_D_STC_JMP
	JMP	VALIFY_E_D_2

VALIFY_EACH_DRIVE ENDP



CHECK_ON_PREEXISTING_FILES PROC NEAR
	 PUSH  DS
	 PUSH  BP

; Calculate # bits to shift to fake a divide by bytes per cluster

	 MOV   AX,SECTOR_SIZE
	 XOR   CH,CH
	 MOV   CL,SECTORS_PER_CLU
	 MUL   CX	; gets bytes per cluster
	 MOV   CX,AX
	 XOR   AX,AX

C_O_P_R_COUNT_BITS:
	 SHR   CX,1
	 JC    C_O_P_R_END
	 INC   AX	;  count bits we shifted
	 JMP   C_O_P_R_COUNT_BITS

C_O_P_R_END:
	 MOV   BYTES_PER_CLUSTER_SHIFT_COUNT,AX ;  save result

; Calculate # clusters needed for our files

	 MOV   AX,NUM_SECTORS_TO_HANDLE
	 ADD   AX,NUM_CTL_SECTORS
	 MOV   DX,0
	 MOV   BL,SECTORS_PER_CLU	; for MIRORSAV.FIL
	 MOV   BH,0
	 DIV   BX
	 CMP   DX,0
	 JE    C_O_P_R_NO_ROUND
	 INC   AX	; # clusters for MIRROR.FIL

C_O_P_R_NO_ROUND:
	 INC   AX	; # clusters both MIRROR.FIL
			; and MIRORSAV.FIL
	 MOV   BP,AX

; Calculate space currently occupied by MIRROR.FIL

	 MOV   DS,CS_SAVE
	 LEA   DX,ASCIIZ
	 MOV   AX,4300H
	 INT   21H	; does it exist?
	 JC    C_O_P_F_NEXT	; no, branch

	 OR    SWITCH,GOTTA_PRE_IMAGE
	 MOV   AX,3D00H
	 INT   21H	; open file
	 JC    C_O_P_F_NEXT

	 MOV   BX,AX
	 MOV   AX,4202H
	 XOR   CX,CX
	 XOR   DX,DX
	 INT   21H	; get size
	 JC    C_O_P_F_CLOSE_1

	 CALL  FAKE_DIVIDE	; calc # clusters
	 CMP   BP,AX	; got enuf?
	 JBE   C_O_P_F_CLC	; more than enuf, exit

	 SUB   BP,AX	; decrement amt needed

C_O_P_F_CLOSE_1:
	 MOV   AH,3EH	; close file
	 INT   21H

C_O_P_F_NEXT:

; Calculate space currently occupied by MIRORSAV.FIL

	 LEA   DX,OUR_SPOT_ASCIIZ
	 MOV   AX,4300H
	 INT   21H	; does it exist?
	 JC    C_O_P_F_CALC

	 OR    SWITCH,GOTTA_PRE_CONTROL
	 MOV   AX,3D00H
	 INT   21H	; open file
	 JC    C_O_P_F_CALC

	 MOV   BX,AX
	 MOV   AX,4202H
	 XOR   CX,CX
	 XOR   DX,DX
	 INT   21H	; get size
	 JC    C_O_P_F_CLOSE_2

	 CALL  FAKE_DIVIDE	; calc # clusters
	 CMP   BP,AX	; got enuf
	 JBE   C_O_P_F_CLC

	 SUB   BP,AX	; decrement amt needed

C_O_P_F_CLOSE_2:
	 MOV   AH,3EH	; close file
	 INT   21H

C_O_P_F_CALC:
	 CMP   BP,0	; need anymore?
	 JE    C_O_P_F_CLC	; no, exit

	 MOV   DL,ASCIIZ
	 SUB   DL,40H
	 MOV   AH,36H	; get free space
	 INT   21H
	 JC    C_O_P_F_CLC	; don't know, so try anyway

	 CMP   BX,BP	; got enuf clus?
	 JB    C_O_P_F_STC	; no, branch

C_O_P_F_CLC:
	 CLC
	 JMP   SHORT C_O_P_F_EXIT

C_O_P_F_STC:
	 STC

C_O_P_F_EXIT:
	 POP   BP
	 POP   DS
	 RET

CHECK_ON_PREEXISTING_FILES ENDP



FAKE_DIVIDE PROC NEAR
	 PUSH  BX
	 MOV   BX,0
	 MOV   CX,BYTES_PER_CLUSTER_SHIFT_COUNT
	 JCXZ  FAKE_DIVIDE_RET

FAKE_DIVIDE_LOOP:
	 SHR   DX,1
	 RCR   AX,1
	 RCR   BX,1	; for remainder
	 LOOP  FAKE_DIVIDE_LOOP 	; fakes the divide

FAKE_DIVIDE_RET:
	 CMP   BX,0
	 JE    FAKE_DIVIDE_EXIT
	 INC   AX	; round to next cluster

FAKE_DIVIDE_EXIT:
	 POP   BX
	 RET

FAKE_DIVIDE ENDP



MIGHT_NEED_TO_DELETE_FILES PROC NEAR
	 TEST  SWITCH,QUIET_MODE	; are we in MSDOS FORMAT?
	 JNZ   M_N_T_D_F_CONT	; yes, branch
	 RET

M_N_T_D_F_CONT:
	 TEST  SWITCH,GOTTA_PRE_IMAGE
	 JNZ   M_N_T_D_F_NEXT

	 LEA   SI,OUR_SPOTS_CTL_FILE_NAME
	 CALL  TRY_TO_DELETE_IT

M_N_T_D_F_NEXT:
	 TEST  SWITCH,GOTTA_PRE_CONTROL
	 JNZ   M_N_T_D_F_EXIT

	 LEA   SI,OUR_SPOTS_FILE_NAME
	 CALL  TRY_TO_DELETE_IT

M_N_T_D_F_EXIT:
	 RET

MIGHT_NEED_TO_DELETE_FILES ENDP



TRY_TO_DELETE_IT PROC NEAR
	 PUSH  DS
	 PUSH  ES
	 PUSH  AX
	 PUSH  BX
	 PUSH  CX
	 PUSH  BP

	 MOV   AX,NUM_DIR_SECTORS
	 MUL   SECTOR_SIZE
	 MOV   BX,32
	 DIV   BX
	 MOV   CX,AX
	 MOV   BX,START_OF_ROOT_OFFSET
	 MOV   ES,START_OF_ROOT_SEGMENT
	 MOV   BP,SI
	 MOV   DS,CS_SAVE

T_T_D_I_LOOP:
	 MOV   SI,BP
	 MOV   DI,BX
	 PUSH  CX
	 MOV   CX,11
	 REPE  CMPSB
	 POP   CX
	 JE    T_T_D_I_HIT
	 ADD   BX,32
	 LOOP  T_T_D_I_LOOP
	 JMP   SHORT T_T_D_I_EXIT

T_T_D_I_HIT:
	 MOV   BYTE PTR ES:[BX],0E5H
	 MOV   AX,ES:[BX+26]	; get starting cluster #
	 CALL  CLEAR_FILE_FROM_FAT

T_T_D_I_EXIT:
	 POP   BP
	 POP   CX
	 POP   BX
	 POP   AX
	 POP   ES
	 POP   DS
	 RET

TRY_TO_DELETE_IT ENDP



CLEAR_FILE_FROM_FAT PROC NEAR
	PUSH	DS
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	DI
	PUSH	SI
	PUSH	BP
	MOV	BP,AX
	CMP	AX,2	; invalid?
	JB	C_F_F_F_EXIT

	MOV	AX,NUM_BOOT_SECTORS
	MUL	SECTOR_SIZE
	MOV	OFFSET_TO_FAT,AX

C_F_F_F_NEXT_CLUSTER:
	TEST	FAT_INFO,FAT_EQU_16_BITS
	JNZ	C_F_F_F_PROCESS_16_BIT_FAT

;	 This will follow the chain thru the 12 bit FAT.

	MOV	DX,0
	MOV	AX,BP	; pick up next cluster number
	SHR	AX,1	; divide by 2
	ADD	AX,BP	; equals times 1.5

	CALL	POINT_TO_CLUSTER_CELL

	MOV	AX,[BX] 	; pick up next
	TEST	BP,1	; is the cluster number odd?
	JZ	C_F_F_F_1	; no, branch
	MOV	CL,4
	SHR	AX,CL	; shift to right 4 bits
	AND	WORD PTR [BX],0000FH	; clear cell
	JMP	SHORT C_F_F_F_2

C_F_F_F_1:
	AND	WORD PTR [BX],0F000H	; clear cell

C_F_F_F_2:
	AND	AX,0FFFH	; clear hi-order byte
	MOV	BP,AX
	CMP	AX,2	; invalid?
	JB	C_F_F_F_EXIT
	CMP	AX,0FF7H	; at end or error?
	JAE	C_F_F_F_EXIT
	JMP	C_F_F_F_NEXT_CLUSTER

C_F_F_F_PROCESS_16_BIT_FAT:
	MOV	DX,0
	MOV	AX,BP	; get cluster #
	ADD	AX,AX	; times 2
	ADC	DX,0

	CALL	POINT_TO_CLUSTER_CELL

	MOV	AX,[BX] 	; get next cluster #
	MOV	BP,AX	; save it
	MOV	WORD PTR [BX],0 	; clear cluster cell
	CMP	AX,2	; invalid?
	JB	C_F_F_F_EXIT
	CMP	BP,0FFF7H	; at end or error?
	JAE	C_F_F_F_EXIT
	JMP	C_F_F_F_NEXT_CLUSTER

C_F_F_F_EXIT:
	POP	BP
	POP	SI
	POP	DI
	POP	DX
	POP	CX
	POP	BX
	POP	DS
	RET

CLEAR_FILE_FROM_FAT ENDP



POINT_TO_CLUSTER_CELL PROC NEAR
	 ADD   AX,OFFSET_TO_FAT
	 ADC   DX,0
	 MOV   BX,AX
	 AND   BX,0FH
	 MOV   CX,4

P_T_C_C_LOOP:
	 SHR   DX,1
	 RCR   AX,1
	 LOOP  P_T_C_C_LOOP

	 ADD   AX,IO_AREA_SEGMENT
	 MOV   DS,AX
	 RET

POINT_TO_CLUSTER_CELL ENDP



BUILD_CONTROL_RECORD PROC NEAR
	MOV	AH,0DH
	INT	21H
	MOV	OUR_SPOTS_FAT_SECTOR,0FFFFH
	MOV	START_CLU,0
	MOV	START_CLU_LAST,0
	MOV	START_CLU_CONT,0
	MOV	REL_SECTOR,0
	MOV	REL_CLUSTER,0
	MOV	REL_CLUSTER_LAST,0

	LDS	SI,USE_DWORD
	MOV	DI,0
	CALL	GET_NEXT_LSN
	JC	B_C_R_ERR
	MOV	AX,ABS_25_SEC_LO
	MOV	CTL1_LSN,AX
	MOV	AX,ABS_25_SEC_HI
	MOV	CTL1_LSN_HI,AX

	MOV	DI,1
	MOV	AH,0
	MOV	AL,SECTORS_PER_CLU
	CMP	AX,NUM_CTL_SECTORS
	JA	B_C_R_OLD_STYLE
	MOV	DI,AX

B_C_R_OLD_STYLE:
	CALL	GET_NEXT_LSN
	JC	B_C_R_ERR
	MOV	AX,ABS_25_SEC_LO
	MOV	CTL2_LSN,AX
	MOV	AX,ABS_25_SEC_HI
	MOV	CTL2_LSN_HI,AX

	LEA	BX,XLAT_TABLE
	MOV	CX,NUM_SECTORS_TO_HANDLE
	MOV	LIST_COUNT,CX

	MOV	DI,NUM_CTL_SECTORS
	MOV	BP,0
	MOV	CX,NUM_BOOT_FAT_SECTORS

B_C_R_LOOP_1:
	CALL	GET_NEXT_LSN
	JC	B_C_R_ERR
	MOV	FROM_LSN,BP
	MOV	FROM_LSN_HI,0
	MOV	AX,ABS_25_SEC_LO
	MOV	TO_LSN,AX
	MOV	AX,ABS_25_SEC_HI
	MOV	TO_LSN_HI,AX
	ADD	BX,8
	INC	DI
	INC	BP
	LOOP	B_C_R_LOOP_1
	JMP	SHORT B_C_R_CHK_DIR

B_C_R_ERR:
	LEA	DX,TRACK_ERROR_MSG
	JMP	B_C_R_STC

B_C_R_CHK_DIR:
	MOV	BP,FIRST_DIRECTORY_SECTOR
	MOV	CX,NUM_DIR_SECTORS

B_C_R_LOOP_2:
	CALL	GET_NEXT_LSN
	JC	B_C_R_ERR
	MOV	FROM_LSN,BP
	MOV	FROM_LSN_HI,0
	MOV	AX,ABS_25_SEC_LO
	MOV	TO_LSN,AX
	MOV	AX,ABS_25_SEC_HI
	MOV	TO_LSN_HI,AX
	ADD	BX,8
	INC	DI
	INC	BP
	LOOP	B_C_R_LOOP_2

;	 Write control record

	CMP	NUM_CTL_SECTORS,2
	JNA	B_C_R_OLD_STYLE_A
	MOV	SECTOR_SIZE,0

	;     This will throw the old REBUILD if it encounters this
	;     new scheme. Normally, CTL_1 and CTL_2 are the LSNs of
	;     the first two control sectors. If SECTOR_SIZE is zero,
	;     the CTL_1 and CTL_2 are the LSNs of the first two
	;     clusters. This will handle multi-megabyte hard drives
	;     with more than 120 or so FAT and ROOT sectors.

B_C_R_OLD_STYLE_A:
	MOV	BX,HANDLE
	MOV	CX,0
	MOV	DX,0
	MOV	AX,4200H	; point to start
	INT	21H
	MOV	BX,DX
	LEA	DX,FULL_MSG
	JNC	B_C_R_CHECK_PTRS
	JMP	SHORT B_C_R_STC

B_C_R_CHECK_PTRS:
	CMP	AX,0
	JE	B_C_R_WRITE_CTL
	CMP	BX,0
	JE	B_C_R_WRITE_CTL
	JMP	SHORT B_C_R_STC

B_C_R_WRITE_CTL:
	MOV	BX,HANDLE
	MOV	AH,40H
	MOV	DS,CS_SAVE
	MOV	CX,CTL_LEN
	LEA	DX,ASCIIZ
	INT	21H

	LDS	DX,USE_DWORD
	MOV	SI,DX
	MOV	CX,LIST_COUNT
	SHL	CX,1
	SHL	CX,1
	SHL	CX,1
	ADD	CX,ENTRY_LEN
	ADD	CX,CTL_LEN
	MOV	AX,SECTOR_SIZE
	SHL	AX,1
	SUB	CX,CTL_LEN
	MOV	AH,40H
	INT	21H
	LEA	DX,FULL_MSG
	JNC	B_C_R_WRITE_OK
	JMP	SHORT B_C_R_STC

B_C_R_WRITE_OK:
;	 MOV   AX,5700H 	; get the files date and time
;	 INT	21H
;
;	 MOV   AX,5701H 	; set the files date and time
;	 INT	21H

	MOV	AH,3EH
	INT	21H
	LEA	DX,CLOSE_MSG
	JNC	B_C_R_SET_ATTRS
	JMP	SHORT B_C_R_STC

B_C_R_SET_ATTRS:
	MOV	DS,CS_SAVE
	LEA	DX,ASCIIZ
	MOV	AX,4301H
	MOV	CX,21H	; read only, arch
	INT	21H
	CLC
	RET

;B_C_R_CONTROL_PROB:
;	  LEA	DX,CONTROL_TOO_SMALL

B_C_R_STC:
	STC
	RET

BUILD_CONTROL_RECORD ENDP
;
;------------------------------------------------------



GET_NEXT_LSN PROC NEAR
	MOV	AX,CONTROL_FILE_START_CLU
	CALL	FIND_LOG_SECTOR
	RET

GET_NEXT_LSN ENDP
;
;------------------------------------------------------



MIRORSAV_DELETE PROC NEAR
	PUSH	CX
	PUSH	DS
	PUSH	DX
	MOV	DS,CS_SAVE
	LEA	DX,OUR_SPOT_ASCIIZ
	MOV	AX,4301H
	MOV	CX,0	; change attrs
	INT	21H
	JC	MIRORSAV_DELETE_EXIT

	LEA	DX,OUR_SPOT_ASCIIZ
	MOV	AH,41H	; delete
	INT	21H

MIRORSAV_DELETE_EXIT:
	POP	DX
	POP	DS
	POP	CX
	RET

MIRORSAV_DELETE ENDP
;
;------------------------------------------------------



ISSUE_MSG_TO_SCREEN PROC NEAR
	PUSH	DS
	PUSH	DX
	MOV	DS,CS_SAVE
	PUSH	DX
	LEA	DX,DRIVE_MSG
	MOV	AH,9
	INT	21H
	POP	DX
	MOV	AH,9
	INT	21H
	POP	DX
	POP	DS
	RET
ISSUE_MSG_TO_SCREEN ENDP
;
;------------------------------------------------------



CHECK_RE_DEFINITION PROC NEAR
	PUSH	DS
	PUSH	SI
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX

	LDS	BX,IO_AREA_DWORD	; point to BOOT record
	MOV	AX,[BX]+11
	CMP	AX,SECTOR_SIZE	; same sector size?
	JNE	C_R_D_BAD_BOOT
	MOV	AL,[BX]+13
	CMP	AL,SECTORS_PER_CLU	; same allocation size?
	JNE	C_R_D_BAD_BOOT
	MOV	AX,[BX]+14
	CMP	AX,NUM_RESERVED        ; same # of BOOT records?
	JNE	C_R_D_BAD_BOOT
	MOV	AL,[BX]+16
	CMP	AL,NUM_FATS	; same # of FATs?
	JNE	C_R_D_BAD_BOOT
	MOV	AX,[BX]+22	; get # sectors per FAT
	ADD	AX,[BX]+14	; add # of BOOT records
	CMP	AX,NUM_BOOT_FAT_SECTORS ; same # of records?
	JNE	C_R_D_BAD_BOOT
	MOV	AX,[BX]+24
	MOV	SECTORS_PER_TRACK,AX	; get sectors per track
	MOV	AX,[BX]+28
	MOV	NUM_HIDDEN,AX	; get # of hidden sectors
	MOV	AX,[BX]+26
	MOV	HEADS,AX	; get # of heads
	LDS	SI,USE_DWORD	; point to current table
	MOV	NUM_HEADS,AX
	POP	DX
	CLC		; no redefinition
	JMP	SHORT C_R_D_EXIT	; exit

C_R_D_BAD_BOOT:
	POP	DX
	LEA	DX,BOOT_BAD	; oops, point to msg
	STC		; tellum bad

C_R_D_EXIT:
	POP	CX
	POP	BX
	POP	AX
	POP	SI
	POP	DS
	RET

CHECK_RE_DEFINITION ENDP
;
;------------------------------------------------------



;READ_FILE PROC NEAR
;	 MOV   CX,1
;	 CALL  ABS_25
;	 JC    READ_FILE_EXIT
;
;	 ADD   ABS_25_SEC_LO,1	; inc sector #
;	 ADC   ABS_25_SEC_HI,0
;	 ADD   BX,SECTOR_SIZE	; bump I/O area pointer
;	 JNC   READ_FILE_DEC	; if no carry, don't adjust DS
;	 MOV   AX,DS	; get DS
;	 ADD   AX,1000H 	; add 64K
;	 MOV   DS,AX	; reset DS
;
;READ_FILE_DEC:
;	 DEC   BP	; dec sectors to read
;	 JNZ   READ_FILE
;	 CLC
;
;READ_FILE_EXIT:
;	 RET
;
;READ_FILE ENDP
;
;------------------------------------------------------



WRITE_FILE PROC NEAR
	MOV	SECTORS_LEFT_TO_WRITE,BP

;	 Write the equivalent of the control record

         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   WRITE_FILE_STC       

	PUSH	DX
	MOV	AX,SECTOR_SIZE
	MUL	NUM_CTL_SECTORS
	POP	DX
	MOV	CX,AX
	MOV	BX,HANDLE
	MOV	AH,40H
	INT	21H	; write ctl recs
	JC	WRITE_FILE_STC
	CMP	AX,CX	; write it all?
	JNE	WRITE_FILE_STC

WRITE_FILE_AGAIN:
         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   WRITE_FILE_STC       

	PUSH	DX
	MOV	AX,SECTORS_MAX_AT_A_TIME
	CMP	AX,SECTORS_LEFT_TO_WRITE
	JNA	WRITE_FILE_AGAIN_1
	MOV	AX,SECTORS_LEFT_TO_WRITE

WRITE_FILE_AGAIN_1:
	SUB	SECTORS_LEFT_TO_WRITE,AX
	MUL	SECTOR_SIZE
	POP	DX

	MOV	CX,AX
	MOV	BX,HANDLE
	MOV	AH,40H
	INT	21H
	JC	WRITE_FILE_STC

	CMP	AX,CX	; write it all?
	JNE	WRITE_FILE_STC

	CMP	SECTORS_LEFT_TO_WRITE,0 ; point to next sector
	JE	WRITE_FILE_CLC	; if no carry, don't adjust DS

	MOV	AX,DS	; oops, get DS
	ADD	AX,MAX_WRITE_UPDATE_DS	; add 64K
	MOV	DS,AX	; reset DS
	JMP	WRITE_FILE_AGAIN

WRITE_FILE_CLC:
	CLC
	RET

WRITE_FILE_STC:
	MOV	DS,CS_SAVE
	LEA	DX,DRIVE_MSG
	MOV	AH,9
	INT	21H
	LEA	DX,FULL_MSG
	MOV	AH,9
	INT	21H
	STC
	RET

WRITE_FILE ENDP
;
;-------------------------------------------------------
; On entry: AL = drive letter ("A" thru "Z").
; On exit: if it's a network drive then CF=true.
;
; Added 05-01-89, GWD.
;
; All regs are unchanged.
;
check_network_drive PROC NEAR
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	push	es
;
	push	cs
	pop	ds
	cld
	mov	cs:net_string,al
	cmp	cs:dos_version,300h
	jb	chknet_not_ibm
	xor	ax,ax
	INT	2Ah	;Is network installed?
	or	ah,ah
	jz	chknet_not_ibm	;No.
	mov	bl,cs:net_string
	sub	bl,"A"
	mov	bh,0
	inc	bx
	mov	ax,4409h	;Is this drive remote?
	INT	21H
	jc	chknet_not_ibm
	test	dx,1000h
	jnz	chknet_error	;It's remote.
	lea	si,net_string
	mov	ax,0300h
	INT	2Ah	;Returns CF=true when INT25h is illegal.
	jmp	short chknet_done
chknet_not_ibm: 	;Look for Novell network.
	mov	cx,-1
	mov	ax,0DC00h	;'Request Novell connection #'.
	INT	21H
	jc	chknet_ok	;Novell is not there.
	cmp	cx,-1
	je	chknet_ok
	mov	si,-1
	mov	ax,0EF01h	;'Get Novell drive table'.
	INT	21H
	jc	chknet_ok
	cmp	si,-1
	je	chknet_ok
	mov	bl,cs:net_string ;M006
	sub	al,"A"
	mov	bh,0
	test	byte ptr es:[bx+si],80h ;Is it a local drive?
	jz	chknet_error	;No - cannot process it.
chknet_ok:
	clc
	jmp	short chknet_done
chknet_error:
	stc
chknet_done:
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	cld
	sti
	ret
check_network_drive ENDP

net_string DB	"x:\",0



;------------------------------------------------------
GET_DRIVE_SPECS PROC NEAR
	CMP    OUR_THREE_SECTOR_SEGMENT,0
	JE     G_D_1

	MOV    ES,OUR_THREE_SECTOR_SEGMENT
	MOV    AH,49H
	INT    21H
	MOV    OUR_THREE_SECTOR_SEGMENT,0

G_D_1:
	CMP    USE_SEGMENT,0
	JE     G_D_2

	MOV    ES,USE_SEGMENT
	MOV    AH,49H
	INT    21H
	MOV    USE_SEGMENT,0

G_D_2:
	MOV	MIRROR_SWITCH,0
	MOV	AH,32H	; that funny undocumented one
	MOV	DL,ASCIIZ
	SUB	DL,40H
	INT	21H
	CMP	AL,0FFH
	JNE	GET_DRIVE_1
	JMP	SPEC_ERROR	; should not occur if drive ok

GET_DRIVE_1:
	MOV	AX,[BX]+2	; get sector size
	MOV	SECTOR_SIZE,AX
	MOV	ALT_SECTOR_SIZE,AX

	 PUSH  DX
	 MOV   DX,1
	 MOV   AX,0
	 DIV   SECTOR_SIZE
	 MOV   NUM_SECTORS_PER_64K,AX
	 POP   DX

	MOV	AL,[BX]+8	; get number of FATs
	MOV	NUM_FATS,AL

	MOV	AX,[BX]+6	; get number of reserved sectors
	MOV	NUM_RESERVED,AX

	MOV	AL,[BX]+4	; get number of sectors per clus
	INC	AL
	MOV	SECTORS_PER_CLU,AL

	MOV	AX,[BX]+13	       ; total cluster count + 1
	MOV	HIGHEST_CLUSTER,AX	; equals highest valid cluster #
 	SHR	AX,1	;******
 	SHR	AX,1	;   changed for MS DOS 5.0
 	MOV	TRYIN_CLUSTERS,AX	;   to allow placement of the
;       MOV	TRYIN_CLUSTERS,AX	;   control file anywhere on the
;       SUB	TRYIN_CLUSTERS,2	;   disk. 8/22/90 Jim Sesma
                                        ;
                                        ;   changed back for perf. reasons         
			;******

	AND	FAT_INFO,NOT FAT_EQU_16_BITS
	MOV	AX,HIGHEST_CLUSTER
	CMP	AX,4086
	JNA	GET_DRIVE_2
	OR	FAT_INFO,FAT_EQU_16_BITS

GET_DRIVE_2:
	CMP	cs:dos_version,400h
	JAE	GET_DRIVE_ALA_DOS_40

	MOV	CX,[BX]+11	; get first usable sector
	MOV	FIRST_DATA_SECTOR,CX

	SUB	CX,[BX]+16	; minus first directory sector
	MOV	NUM_DIR_SECTORS,CX

	MOV	AX,0
	MOV	AL,[BX]+15	; get sectors per FAT
	MOV	NUM_FAT_SECTORS,AX

	ADD	AX,[BX]+6	; dont forget reserved (BOOT)
	MOV	NUM_BOOT_FAT_SECTORS,AX

	ADD	CX,AX
	MOV	NUM_SECTORS_TO_HANDLE,CX
	MOV	AX,[BX]+16	; get 1st directory sector
	MOV	FIRST_DIRECTORY_SECTOR,AX
	JMP	SHORT GET_DRIVE_3

GET_DRIVE_ALA_DOS_40:
	MOV	CX,[BX]+11	; get first usable sector
	MOV	FIRST_DATA_SECTOR,CX

	SUB	CX,[BX]+17	; minus first directory sector
	MOV	NUM_DIR_SECTORS,CX

	MOV	AX,[BX]+15	; get sectors per FAT
	MOV	NUM_FAT_SECTORS,AX

	ADD	AX,[BX]+6	; dont forget reserved (BOOT)
	MOV	NUM_BOOT_FAT_SECTORS,AX

	ADD	CX,AX
	MOV	NUM_SECTORS_TO_HANDLE,CX
	MOV	AX,[BX]+17	; get 1st directory sector
	MOV	FIRST_DIRECTORY_SECTOR,AX

GET_DRIVE_3:
	MOV	AX,[BX]+6	; dont forget reserved (BOOT)
	MOV	NUM_BOOT_SECTORS,AX

	MOV	DX,0
	MOV	AX,0FFFFH
	DIV	SECTOR_SIZE	; get # sectors in 64K-1
	MOV	SECTORS_MAX_AT_A_TIME,AX
	MUL	SECTOR_SIZE
	MOV	CX,4
	SHR	AX,CL
	MOV	MAX_WRITE_UPDATE_DS,AX

;	LEA	SI,END_PROG
;	MOV	OUR_SPOTS_DIR_OFFSET,SI
;	ADD	SI,SECTOR_SIZE
;	MOV	OUR_SPOTS_FAT_OFFSET,SI
;	ADD	SI,SECTOR_SIZE
;	ADD	SI,SECTOR_SIZE
;	MOV	USE_POINTER,SI
;	MOV	USE_SEGMENT,CS
	MOV	OUR_SPOTS_DIR_OFFSET,0
	MOV	BX,SECTOR_SIZE
	MOV	OUR_SPOTS_FAT_OFFSET,BX
	ADD	BX,SECTOR_SIZE
	ADD	BX,SECTOR_SIZE
	MOV	CX,4
	SHR	BX,CL
	MOV	AH,48H
	INT	21H
	JC	GET_DRIVE_NO_MEM_JMP
	MOV	OUR_THREE_SECTOR_SEGMENT,AX

	MOV	BX,0FFFFH
	MOV	USE_AREA_PARAS,BX
	MOV	AH,48H
	INT	21H
	JNC	GOT_ALL_MEM
	MOV	USE_AREA_PARAS,BX

	MOV	AH,48H
	INT	21H
	JNC	GOT_ALL_MEM

GET_DRIVE_NO_MEM_JMP:
	JMP	GET_DRIVE_NO_MEM

GOT_ALL_MEM:
	MOV	USE_SEGMENT,AX
	MOV	USE_POINTER,0

	CMP	USE_AREA_PARAS,512*10/16 ; at least room for 10 sectors?
	JB	GET_DRIVE_NO_MEM_JMP	 ; no, fail

	MOV	ES,USE_SEGMENT
	MOV	DI,USE_POINTER
	MOV	CX,NUM_SECTORS_TO_HANDLE
	SHL	CX,1
	SHL	CX,1
	SHL	CX,1
	ADD	CX,ENTRY_LEN
	PUSH	CX
	MOV	AL,0
	REP	STOSB	; clear table

	POP	AX
	ADD	AX,CTL_LEN
	MOV	DX,0
	DIV	SECTOR_SIZE
	CMP	DX,0
	JE	GET_DRIVE_NUM_CTL_SECTORS
	INC	AX

GET_DRIVE_NUM_CTL_SECTORS:
	CMP	AX,2
	JA	GET_DRIVE_NUM_CTL_SECTORS_1
	MOV	AX,2

GET_DRIVE_NUM_CTL_SECTORS_1:
	MOV	NUM_CTL_SECTORS,AX

	LDS	SI,USE_DWORD
	LEA	AX,XLAT_TABLE
	MOV	XLAT_POINTER,AX
	MOV	CL,3
	MOV	AX,NUM_SECTORS_TO_HANDLE
	MOV	LIST_COUNT,AX
	SHL	AX,CL
	ADD	AX,XLAT_POINTER
	MOV	XLAT_END,AX

	MOV	AL,ASCIIZ
	MOV	DRIVE,AL

	MOV	AX,NUM_SECTORS_TO_HANDLE
	ADD	AX,NUM_CTL_SECTORS
	MUL	SECTOR_SIZE
	MOV	CX,16
	DIV	CX
	CMP	AX,USE_AREA_PARAS
	JA	GET_DRIVE_NO_MEM

	MOV	AX,ES
	ADD	DI,15
	MOV	CL,4
	SHR	DI,CL
	ADD	AX,DI
	MOV	IO_AREA_OFFSET,0
	MOV	IO_AREA_SEGMENT,AX

	cmp	cs:dos_version,031Fh	;Version 3.31 ?
	jb	get_drive_thru

get_drive_zenith:
	MOV	AL,SECTORS_PER_CLU
	MOV	AH,0
	MUL	HIGHEST_CLUSTER
	ADD	AX,FIRST_DATA_SECTOR
	ADC	DX,0
	CMP	DX,0
	JE	GET_DRIVE_THRU
	OR	MIRROR_SWITCH,ABS_25_HARD_WAY

GET_DRIVE_THRU:
	CLC
	RET

GET_DRIVE_NO_MEM:
	LEA	DX,NO_MEM_MSG
	STC
	RET

SPEC_ERROR:
	LEA	DX,DRIVE_SPEC_ERROR
	STC
	RET

GET_DRIVE_SPECS ENDP



CHECK_FOR_OUR_SPOT PROC NEAR

; The intent here is to see if there's a spot big enuf in the last
;  part of the hard drive for our control file.  If so,
;  allocate it the hard way, otherwise tell 'em we kant go on (meeting
;  like this).	If we're allocating in other than the last cluster,
;  we gotta check to make sure one or more of the file(s) that's in
;  the way ain't one of our old ones (with a new name of course).

; Afore we do this, check to see if there's one there. If so, we don't
;  need to go tew all the trubble, UNLESS, of course, that it ain't in
;  the last cluster. Ifin it is, that's OK, but if not, we gotta quit.

	MOV	AH,0DH	; no bufferin' DOS
	INT	21H

	MOV	AX,FIRST_DIRECTORY_SECTOR
	MOV	ABS_25_SEC_LO,AX
	MOV	ABS_25_SEC_HI,0
;	 MOV   OUR_SPOTS_CURR_DIR_SECTOR,DX
	MOV	AX,NUM_DIR_SECTORS
	MOV	OUR_SPOTS_DIR_SECTORS_LEFT,AX

C_F_O_S_READ_DIR_LOOP1:
         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   C_F_O_S_BROKE        

;	MOV	DS,CS_SAVE
	MOV	DS,OUR_THREE_SECTOR_SEGMENT
	MOV	BX,OUR_SPOTS_DIR_OFFSET
	MOV	CX,1
	CALL	ABS_25
	LEA	DX,READ_ERROR_MSG
	JNC	C_F_O_S_CHECK_DIR1

C_F_O_S_BROKE:
	MOV	RETURN_CODE,4
	JMP	C_F_O_S_STC

C_F_O_S_CHECK_DIR1:
	MOV	CL,5
	MOV	AX,SECTOR_SIZE
	SHR	AX,CL
	MOV	CX,AX

C_F_O_S_CHECK_DIR_LOOP1:
	MOV	ES,CS_SAVE
	LEA	DI,OUR_SPOTS_FILE_NAME
	MOV	SI,BX

	CMP	BYTE PTR [SI],0 	; anymore entries?
	JE	C_F_O_S_NO_DIRS1	; no, branch

	PUSH	CX
	MOV	CX,11
	REPE	CMPSB
	POP	CX
	JE	C_F_O_S_GOT_OUR_DIR1
	ADD	BX,DIR_ENTRY_LEN	; tew next wun
	LOOP	C_F_O_S_CHECK_DIR_LOOP1

	DEC	OUR_SPOTS_DIR_SECTORS_LEFT   ; minus wun
	JZ	C_F_O_S_NO_DIRS1	    ; oops, none left
	ADD	ABS_25_SEC_LO,1
	ADC	ABS_25_SEC_HI,0
	JMP	C_F_O_S_READ_DIR_LOOP1

C_F_O_S_NO_DIRS1:
	JMP	SHORT C_F_O_S_CREATE_WUN

C_F_O_S_GOT_OUR_DIR1:
	MOV	AX,WORD PTR DS:[BX+26]	; grab starting cluster
	MOV	BX,HIGHEST_CLUSTER	; grab highest possible cluster
	CMP	AX,BX	; in the highest?
	JE	C_F_O_S_RE_USE_HIGHEST	; yep, that's kool
	SUB	BX,TRYIN_CLUSTERS	; gets first clu it can't be
	CMP	AX,BX	; are we above that?
	JA	C_F_O_S_RE_USE_OK	; yep

        TEST    SWITCH,QUIET_MODE       ; are we in MSDOS FORMAT?
        JNZ     C_F_O_S_RE_USE_OK       ; yes, branch

        LEA     DX,CANT_REUSE_ERROR_MSG
        CALL    ISSUE_MSG_TO_SCREEN

C_F_O_S_RE_USE_OK:
	CALL	MIRORSAV_DELETE
	JMP	SHORT C_F_O_S_CREATE_WUN

C_F_O_S_RE_USE_HIGHEST:
	JMP	C_F_O_S_CLC

C_F_O_S_CREATE_WUN:

; Ain't wun thar, sew, let's check things out from the back

	MOV	AH,0DH	; no bufferin' DOS
	INT	21H
	MOV	OUR_SPOTS_FAT_SECTOR,0FFFFH
	MOV	START_CLU,0
	MOV	START_CLU_LAST,0
	MOV	START_CLU_CONT,0
	MOV	REL_SECTOR,0
	MOV	REL_CLUSTER,0
	MOV	REL_CLUSTER_LAST,0

	MOV	AX,HIGHEST_CLUSTER
	MOV	OUR_SPOTS_START_CLU,AX

C_F_O_S_CHECK_NEXT_CLUSTER:
	MOV	DX,0
	MOV	AX,OUR_SPOTS_START_CLU
	TEST	FAT_INFO,FAT_EQU_16_BITS
	JZ	C_F_O_S_FAT_EQU_12_BITS
	ADD	AX,AX	; gets rel byte disp in FAT
	ADC	DX,0
	JMP	SHORT C_F_O_S_GET_FAT

C_F_O_S_FAT_EQU_12_BITS:
	MOV	BX,AX	; highest cluster
	SHR	AX,1	; times 1.5 gets
	ADD	AX,BX	;  rel byte disp in FAT
	ADC	DX,0

C_F_O_S_GET_FAT:
	DIV	SECTOR_SIZE	; bytes in FATs except last two
	MOV	OUR_SPOTS_FAT_SECTOR_DISP,DX ; save it

	CMP	OUR_SPOTS_FAT_SECTOR,AX ; got the right sector already?
	JE	C_F_O_S_GOT_FAT 	; yes, don't get it again

	MOV	OUR_SPOTS_FAT_SECTOR,AX ; save
	CMP	AX,0
	JE	C_F_O_S_READ_FAT
	MOV	AX,SECTOR_SIZE
	DEC	AX
	CMP	AX,DX
	JA	C_F_O_S_READ_FAT
	DEC	OUR_SPOTS_FAT_SECTOR
	ADD	DX,SECTOR_SIZE
	MOV	OUR_SPOTS_FAT_SECTOR_DISP,DX ; save it

C_F_O_S_READ_FAT:
         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   C_F_O_S_BROKE_1

;	MOV	DS,CS_SAVE
	MOV	DS,OUR_THREE_SECTOR_SEGMENT
	MOV	BX,OUR_SPOTS_FAT_OFFSET
	MOV	CX,2
	MOV	AX,OUR_SPOTS_FAT_SECTOR
	ADD	AX,NUM_RESERVED
	MOV	ABS_25_SEC_LO,AX
	MOV	ABS_25_SEC_HI,0
	CALL	ABS_25	; read FAT sector(s)
	LEA	DX,READ_ERROR_MSG
	JNC	C_F_O_S_GOT_FAT

C_F_O_S_BROKE_1:
	MOV	RETURN_CODE,4
	JMP	C_F_O_S_STC

C_F_O_S_GOT_FAT:
	MOV	SI,OUR_SPOTS_FAT_SECTOR_DISP
	MOV	BX,OUR_SPOTS_FAT_OFFSET         ;M009

	MOV	AX,WORD PTR DS:[BX+SI]	; get value out of FAT
	TEST	FAT_INFO,FAT_EQU_16_BITS ; 12 bit FAT?
	JNZ	C_F_O_S_CHECK_IF_AVAILABLE


; following should tell whether to throw away upper or lower 4 nibbles

	MOV	CL,4

	TEST	OUR_SPOTS_START_CLU,1
	JNZ	C_F_O_S_ODD	; nope

	AND	AX,0FFFH	; clear out hi-order 4 nibbles
	JMP	SHORT C_F_O_S_CHECK_IF_AVAILABLE

C_F_O_S_ODD:
	SHR	AX,CL	;  4 bits

C_F_O_S_CHECK_IF_AVAILABLE:
	CMP	AX,0	; available?
	JE	C_F_O_S_AVAIL	; yep

C_F_O_S_TRY_NEXT:
	MOV	FAT_NEXT_CLUSTER,AX
	CALL	C_F_O_S_CHECK_IT_OUT	; be sure a phony doesn't exist
	JC	C_F_O_S_STC_JMP

	INC	CLUSTERS_WEVE_TRIED
	MOV	AX,TRYIN_CLUSTERS
	CMP	CLUSTERS_WEVE_TRIED,AX
	JAE	C_F_O_S_NOT_AVAIL
	DEC	OUR_SPOTS_START_CLU
	JMP	C_F_O_S_CHECK_NEXT_CLUSTER

C_F_O_S_NOT_AVAIL:
	LEA	DX,NO_SPOTS_ERROR_MSG

C_F_O_S_STC_JMP:
	JMP	C_F_O_S_STC

C_F_O_S_AVAIL:

; Now read the directory to find a spot to create a directory entry
; for our little quile.

	MOV	AH,0DH	; no bufferin' DOS
	INT	21H

	MOV	AX,FIRST_DIRECTORY_SECTOR
	MOV	ABS_25_SEC_LO,AX
	MOV	ABS_25_SEC_HI,0
	MOV	AX,NUM_DIR_SECTORS
	MOV	OUR_SPOTS_DIR_SECTORS_LEFT,AX

C_F_O_S_READ_DIR_LOOP:
         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   C_F_O_S_BROKE_2

;	MOV	DS,CS_SAVE
	MOV	DS,OUR_THREE_SECTOR_SEGMENT
	MOV	BX,OUR_SPOTS_DIR_OFFSET
	MOV	CX,1
	CALL	ABS_25
	LEA	DX,READ_ERROR_MSG
	JNC	C_F_O_S_CHECK_DIR

C_F_O_S_BROKE_2:
	MOV	RETURN_CODE,4
	JMP	C_F_O_S_STC

C_F_O_S_CHECK_DIR:
	MOV	CL,5
	MOV	AX,SECTOR_SIZE
	SHR	AX,CL
	MOV	CX,AX	; calc # dir entries per sector

C_F_O_S_CHECK_DIR_LOOP:
	CMP	BYTE PTR DS:[BX],0E5H	; erased?
	JE	C_F_O_S_GOT_A_DIR	; yup
	CMP	BYTE PTR DS:[BX],0	; new wun?
	JE	C_F_O_S_GOT_A_DIR	; yup
	ADD	BX,DIR_ENTRY_LEN	; tew next wun
	LOOP	C_F_O_S_CHECK_DIR_LOOP

	DEC	OUR_SPOTS_DIR_SECTORS_LEFT   ; minus wun
	JZ	C_F_O_S_NO_DIRS 	    ; oops, none left
	ADD	ABS_25_SEC_LO,1
	ADC	ABS_25_SEC_HI,0
	JMP	C_F_O_S_READ_DIR_LOOP

C_F_O_S_NO_DIRS:
	LEA	DX,NO_DIRS_ERROR_MSG
	JMP	C_F_O_S_STC

C_F_O_S_GOT_A_DIR:
;	MOV	ES,CS_SAVE
	MOV	ES,OUR_THREE_SECTOR_SEGMENT
	MOV	DI,BX
	MOV	DS,CS_SAVE
	LEA	SI,OUR_SPOTS_DIR_ENTRY
	MOV	CX,DIR_ENTRY_LEN
	REP	MOVSB

; Now, update directory and FAT (GULP!)

	MOV	AH,0DH	; no bufferin' DOS
	INT	21H

         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   C_F_O_S_BROKE_3

	MOV	DS,OUR_THREE_SECTOR_SEGMENT
	MOV	BX,OUR_SPOTS_DIR_OFFSET
	MOV	CX,1
	CALL	ABS_26
	LEA	DX,WRITE_SYS_ERROR_MSG
	JNC	C_F_O_S_UPDATE_FAT

C_F_O_S_BROKE_3:
	MOV	RETURN_CODE,4
	JMP	C_F_O_S_STC

C_F_O_S_UPDATE_FAT:
;	MOV	DS,CS_SAVE
	MOV	BX,OUR_SPOTS_FAT_OFFSET
	MOV	SI,OUR_SPOTS_FAT_SECTOR_DISP

	TEST	FAT_INFO,FAT_EQU_16_BITS ; 12 bit FAT?
	JNZ	C_F_O_S_U_F_16	; nope

	MOV	AX,0FFFH
	TEST	OUR_SPOTS_START_CLU,1	; clu # odd?
	JZ	C_F_O_S_U_F_12	; nope

	MOV	CL,4
	SHL	AX,CL	; shift left about fore

C_F_O_S_U_F_12:
	OR	WORD PTR DS:[BX+SI],AX	; new FAT value
	JMP	SHORT C_F_O_S_WRITE_NEW_FAT

C_F_O_S_U_F_16:
	MOV	AX,0FFFFH
	MOV	WORD PTR DS:[BX+SI],AX	; new FAT value

C_F_O_S_WRITE_NEW_FAT:
	MOV	CH,0
	MOV	CL,NUM_FATS
	MOV	AX,OUR_SPOTS_FAT_SECTOR
	ADD	AX,NUM_RESERVED
	MOV	ABS_25_SEC_LO,AX
	MOV	ABS_25_SEC_HI,0

C_F_O_S_WRITE_NEW_FAT_LOOP:
	PUSH	CX
	MOV	CX,2

	MOV	AX,SECTOR_SIZE
	DEC	AX
	CMP	OUR_SPOTS_FAT_SECTOR_DISP,AX
	JNB	C_F_O_S_WRITE_FAT_ABS

	MOV	CX,1

C_F_O_S_WRITE_FAT_ABS:
	CALL	ABS_26
	POP	CX
	JC	C_F_O_S_UPDATE_FAT_ERROR

	MOV	AX,NUM_FAT_SECTORS
	ADD	ABS_25_SEC_LO,AX	; for second copy of FAT
	ADC	ABS_25_SEC_HI,0 	; for second copy of FAT
	LOOP	C_F_O_S_WRITE_NEW_FAT_LOOP

	JMP	SHORT C_F_O_S_CLC

C_F_O_S_UPDATE_FAT_ERROR:
	LEA	DX,WRITE_SYS_ERROR_MSG
	MOV	RETURN_CODE,4
	JMP	SHORT C_F_O_S_STC

C_F_O_S_CLC:
	CLC

C_F_O_S_EXIT:
	RET

C_F_O_S_STC:
	STC
	JMP	C_F_O_S_EXIT

CHECK_FOR_OUR_SPOT ENDP
;
;------------------------------------------------------



C_F_O_S_CHECK_IT_OUT PROC NEAR

; This cluster is allocated above our little file. Make sure it isn't
;  an old one of ours.

	AND	FAT_INFO,NOT CLU_IS_A_BADDIE
	MOV	AX,0FF7H
	TEST	FAT_INFO,FAT_EQU_16_BITS
	JZ	C_F_O_S_CIO_IZIT_MARKED

	MOV	AX,0FFF7H

C_F_O_S_CIO_IZIT_MARKED:
	CMP	FAT_NEXT_CLUSTER,AX	; a baddie?
	JNE	C_F_O_S_CIO_READ_IT	; nope
	OR	FAT_INFO,CLU_IS_A_BADDIE

C_F_O_S_CIO_READ_IT:
         TEST  BREAK_SWITCH,BEEN_BROKE
         JNZ   C_F_O_S_CIO_STC

	MOV	AX,OUR_SPOTS_START_CLU	 ; get clu #
	CALL	CONVERT_CLU_TO_LOG_SECTOR ; get log sector
	MOV	CX,1
;	MOV	DS,CS_SAVE
	MOV	DS,OUR_THREE_SECTOR_SEGMENT
	MOV	BX,OUR_SPOTS_DIR_OFFSET
	CALL	ABS_25
	JNC	C_F_O_S_CIO_READ_OK
	JMP	SHORT C_F_O_S_CIO_CLC	; ifin it can't be read,
			;  no need to worry about it

C_F_O_S_CIO_READ_OK:
	PUSH	ES
	MOV	ES,CS_SAVE
	LEA	DI,OUR_SIGNATURE
	MOV	SI,BX	; point to sector
	ADD	SI,OUR_SIGNATURE_OFFSET ;M009: Sig. offset within Control file.
	MOV	CX,OUR_SIGNATURE_LEN
	REPE	CMPSB
	POP	ES
	JNE	C_F_O_S_CIO_CLC

	TEST	FAT_INFO,CLU_IS_A_BADDIE
	JZ	C_F_O_S_CIO_NORMAL

; We were able to read the furst sector of a bad cluster. And,
;  below and mahold, we matched. Sew, write sum binzers into it.

	PUSH	ES
;	MOV	ES,CS_SAVE
	MOV	ES,OUR_THREE_SECTOR_SEGMENT
	MOV	DI,OUR_SPOTS_DIR_OFFSET
	MOV	AL,0
	MOV	CX,SECTOR_SIZE
	REP	STOSB
	POP	ES

	MOV	CX,1
;	MOV	DS,CS_SAVE
	MOV	BX,OUR_SPOTS_DIR_OFFSET
	CALL	ABS_26
	JNC	C_F_O_S_CIO_CLC 	; OK, if write worked

C_F_O_S_CIO_NORMAL:
	LEA	DX,FOUND_ONE_LIKE_US_MSG
	JMP	SHORT C_F_O_S_CIO_STC

C_F_O_S_CIO_CLC:
	CLC
	JMP	SHORT C_F_O_S_CIO_EXIT

C_F_O_S_CIO_STC:
	STC

C_F_O_S_CIO_EXIT:
	RET

C_F_O_S_CHECK_IT_OUT ENDP
;
;------------------------------------------------------



CONVERT_CLU_TO_LOG_SECTOR PROC NEAR

; To convert clu # to a logical sector #:

;  (clu#-2) * sectors per cluster + first data sector

	PUSH	BX
	SUB	AX,2	; minus tew
	MOV	BH,0
	MOV	BL,SECTORS_PER_CLU
	MUL	BX	; times sectors per clu
	ADD	AX,FIRST_DATA_SECTOR	; that shud be about it
	ADC	DX,0
	MOV	ABS_25_SEC_LO,AX
	MOV	ABS_25_SEC_HI,DX
	POP	BX
	RET

CONVERT_CLU_TO_LOG_SECTOR ENDP
;
;------------------------------------------------------




;   Given the starting cluster # (out of the directory) and the relative
;   sector # in the file desired, return the logical sector # on the
;   media.

;	 AX = starting cluster #
;	 DI = relative sector #
;    Returned,
;	 With carry clear,
;	     ABS_25_SEC_LO and ABS_25_SEC_HI have logical sector number
;	 With carry set,
;	 AX = FFF7 for bad cluster or FFFF for EOF.

;	 Remember, if AX returns with FFFF, we're already at
;	 EOF. If AX contains a FFF7, something in wrong for
;	 this is a BAD sector.

FIND_LOG_SECTOR PROC NEAR
	PUSH	DS
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	DI
	PUSH	SI
;	MOV	DS,CS_SAVE
	MOV	DS,OUR_THREE_SECTOR_SEGMENT
	MOV	START_CLU,AX


;	 First, we will find out which relative Cluster in the file
;	 is involved and we will also have the relative sector in the
;	 cluster.

F_L_S_1:
	MOV	AX,DI	; get relative clu/sec in file
	MOV	DX,0
	MOV	BL,SECTORS_PER_CLU
	MOV	BH,0
	DIV	BX

;	 If the starting cluster # is the same we may not need to
;	 scan thru the entire FAT, just take off from where we were
;	 before.

	MOV	BX,START_CLU
	CMP	START_CLU_LAST,BX	; might this be a continuation?
	JE	FIND_LOG_SECTOR_CONTINUE ; yes, branch
	MOV	START_CLU_LAST,BX	; no, save starting clu#
	JMP	SHORT FIND_LOG_SECTOR_OLD_WAY

FIND_LOG_SECTOR_CONTINUE:

;	 Now, if the relative cluster is equal or greater than the
;	 last, we can start from the last.

	CMP	AX,REL_CLUSTER_LAST	; are we in range?
	JB	FIND_LOG_SECTOR_OLD_WAY  ; no, branch
	PUSH	AX
	SUB	AX,REL_CLUSTER_LAST	; get amount to go
	POP	REL_CLUSTER_LAST
	MOV	REL_CLUSTER,AX	; set it up
	MOV	AX,START_CLU_CONT	; get associated cluster #
	MOV	START_CLU,AX	; and save it
	MOV	REL_SECTOR,DX	; save relative sector #
	MOV	BX,OUR_SPOTS_FAT_OFFSET  ; point to FAT
	JMP	SHORT CHECK_NEXT_CLUSTER

;	 Now, AX has the relative cluster in the file and DX has the
;	 relative sector in the cluster

FIND_LOG_SECTOR_OLD_WAY:
	MOV	REL_SECTOR,DX	; save relative sector in clus
	MOV	REL_CLUSTER,AX	; save relative cluster in fil
	MOV	REL_CLUSTER_LAST,AX	; save relative cluster in fil
	MOV	BX,OUR_SPOTS_FAT_OFFSET  ; point to FAT

CHECK_NEXT_CLUSTER:
	CMP	REL_CLUSTER,0	; are we at the right cluster
	JE	AT_RIGHT_CLUSTER

;	 Now we will move to the next cluster in the chain.

	TEST	FAT_INFO,FAT_EQU_16_BITS
	JNZ	PROCESS_16_BIT_FAT

;	 This will follow the chain thru the 12 bit FAT.

	DEC	REL_CLUSTER

	MOV	DX,0
	MOV	AX,START_CLU	; pick up relative sector number
	SHR	AX,1	; divide by 2
	ADD	AX,START_CLU	; equals times 1.5

	CALL	GET_RIGHT_SECTOR

	MOV	AX,[BX+DI]	; pick up next
	TEST	START_CLU,1	; is the sector number odd?
	JZ	GF_1	; no, branch
	SHR	AX,1
	SHR	AX,1
	SHR	AX,1
	SHR	AX,1	; shift to right 4 bits

GF_1:
	AND	AX,0FFFH	; clear hi-order byte
	MOV	START_CLU,AX
	CMP	AX,0FF7H	; at end or error?
	JE	FAT_ERROR_JMP
	JA	AT_RIGHT_CLUSTER
	JMP	CHECK_NEXT_CLUSTER

FAT_ERROR_JMP:
	JMP	FAT_ERROR

PROCESS_16_BIT_FAT:
	DEC	REL_CLUSTER

	MOV	DX,0
	MOV	AX,START_CLU	; get cluster #
	ADD	AX,AX	; times 2
	ADC	DX,0

	CALL	GET_RIGHT_SECTOR

	MOV	AX,[BX+DI]	; get next cluster #
	MOV	START_CLU,AX	; save it
	CMP	START_CLU,0FFF7H	; at end or error?
	JE	FAT_ERROR
	JA	AT_RIGHT_CLUSTER	; at EOF
	JMP	CHECK_NEXT_CLUSTER

;	 Now, if all is cool, compute logical sector # of INT 25H.

AT_RIGHT_CLUSTER:
	MOV	AX,START_CLU
	MOV	START_CLU_CONT,AX
	MOV	AX,REL_CLUSTER
	SUB	REL_CLUSTER_LAST,AX

	CMP	AX,0
	JNE	BEYOND_EOF

	TEST	FAT_INFO,FAT_EQU_16_BITS
	JNZ	CHECK_FOR_16_BIT_EOF

	CMP	START_CLU,0FF7H
	JE	FAT_ERROR
	JA	BEYOND_EOF
	JMP	SHORT NOT_EOF

CHECK_FOR_16_BIT_EOF:
	CMP	START_CLU,0FFF7H
	JE	FAT_ERROR
	JA	BEYOND_EOF

NOT_EOF:
	SUB	START_CLU,2	; sub 2
	MOV	AX,START_CLU
	MOV	BH,0
	MOV	BL,SECTORS_PER_CLU
	MUL	BX
	ADD	AX,REL_SECTOR	; rel sect # in cluster
	ADC	DX,0
	ADD	AX,FIRST_DATA_SECTOR	; bump past FAT and DIR
	ADC	DX,0
	MOV	ABS_25_SEC_LO,AX
	MOV	ABS_25_SEC_HI,DX
	CLC

FIND_LOG_EXIT:
	POP	SI
	POP	DI
	POP	DX
	POP	CX
	POP	BX
	POP	DS
	RET

FAT_ERROR:
	MOV	START_CLU_LAST,0FFFFH
	MOV	AX,0FFF7H
	STC
	JMP	FIND_LOG_EXIT

BEYOND_EOF:
	STC
	MOV	AX,0FFFFH
	JMP	FIND_LOG_EXIT

FIND_LOG_SECTOR ENDP
;
;------------------------------------------------------



GET_RIGHT_SECTOR PROC NEAR
	PUSH	AX
	PUSH	CX
	PUSH	DX

	DIV	SECTOR_SIZE
	MOV	DI,DX
	CMP	AX,OUR_SPOTS_FAT_SECTOR  ; got it in memory?
	JE	GET_RIGHT_OUT	; yes, branch
	JB	GET_NEW_SECTORS          ; no, gotta read more
	MOV	CX,AX	; may be in second half
	DEC	CX
	CMP	CX,OUR_SPOTS_FAT_SECTOR  ; do they need second half?
	JNE	GET_NEW_SECTORS          ; no, forget it
	MOV	CX,DI	; but do they need very last byte
	INC	CX
	CMP	CX,SECTOR_SIZE	; spanning across last byte
	JNB	GET_NEW_SECTORS          ; yes, go read anyway
	ADD	DI,SECTOR_SIZE	; no, just adjust offset
	JMP	SHORT GET_RIGHT_OUT	; and get out

GET_NEW_SECTORS:
	MOV	OUR_SPOTS_FAT_SECTOR,AX
	ADD	AX,NUM_RESERVED
	MOV	ABS_25_SEC_LO,AX
	MOV	ABS_25_SEC_HI,0
	MOV	CX,2
	CALL	ABS_25

GET_RIGHT_OUT:
	POP	DX
	POP	CX
	POP	AX
	RET
GET_RIGHT_SECTOR ENDP
;
;------------------------------------------------------



GET_OLD_INFO PROC NEAR
	PUSH	DS
	PUSH	ES
	MOV	ES,CS_SAVE
	MOV	DS,CS_SAVE
	LEA	DI,OUR_SPOTS_OLD
	MOV	AX,0
	MOV	CX,4
	REP	STOSW

	TEST	SWITCH,ONE_FILE_ONLY
	JNZ	G_O_I_EXIT

	MOV	AX,3D00H
	LEA	DX,OUR_SPOT_ASCIIZ
	INT	21H
	JC	G_O_I_EXIT

	MOV	BX,AX
	MOV	CX,OUR_SPOTS_NEW_LEN
	MOV	AH,3FH
	MOV	DS,OUR_THREE_SECTOR_SEGMENT
	MOV	DX,OUR_SPOTS_DIR_OFFSET
	INT	21H
	JC	G_O_I_EXIT_CLOSE

	CMP	AX,CX
	JB	G_O_I_EXIT_CLOSE

	LEA	DI,OUR_SPOTS_OLD
	MOV	SI,OUR_SPOTS_DIR_OFFSET
	MOVSW
	MOVSW
	MOV	SI,OUR_SPOTS_DIR_OFFSET
	ADD	SI,OUR_SPOTS_YEAR-OUR_SPOTS_IO_AREA
	MOV	CX,3
	REP	MOVSW

G_O_I_EXIT_CLOSE:
	MOV	AH,3EH
	INT	21H

G_O_I_EXIT:
	POP	ES
	POP	DS
	RET

GET_OLD_INFO ENDP
;
;------------------------------------------------------



HANDLE_TWO_FILES PROC NEAR
	PUSH	DS
	PUSH	ES
	MOV	DS,CS_SAVE
	MOV	ES,CS_SAVE

	TEST	SWITCH,ONE_FILE_ONLY	; one file only?
	JZ	H_T_F_1 	; no, branch

	MOV	AX,4301H
	MOV	CX,0
	LEA	DX,ASCIIZ_BACKUP	; unprotect old backup file
	INT	21H
	JC	H_T_F_EXIT	; no, branch

	MOV	AH,41H
	LEA	DX,ASCIIZ_BACKUP	; delete old backup file
	INT	21H

	JMP	SHORT H_T_F_EXIT	; no, branch

H_T_F_1:
	MOV	AX,4301H
	MOV	CX,0
	LEA	DX,ASCIIZ_BACKUP	; unprotect old backup file
	INT	21H
	JC	H_T_F_2

	LEA	DI,ASCIIZ_TEMP
	MOV	AH,56H	; make it temporary
	INT	21H

H_T_F_2:
	MOV	AX,4301H
	MOV	CX,0
	LEA	DX,ASCIIZ	; unprotect current file
	INT	21H

	LEA	DI,ASCIIZ_BACKUP
	MOV	AH,56H	; make it the backup file
	INT	21H

	MOV	AX,3D02H
	LEA	DX,ASCIIZ_BACKUP
	INT	21H	; open backup file
	JC	H_T_F_3 	; no, branch

	MOV	BX,AX
	MOV	AX,4200H
	MOV	CX,0
	MOV	DX,BACKUP_LSEEK 	; point to a spot
	INT	21H

	LEA	DX,BACKUP_IND_BYTE
	MOV	CX,1
	MOV	AH,40H	; remember it is a backup
	INT	21H

	MOV	AX,5700H
	INT	21H
	MOV	AX,5701H
	INT	21H

	MOV	AH,3EH	; close it
	INT	21H

H_T_F_3:
	MOV	AX,4301H
	MOV	CX,21H	; archive+read-only
	LEA	DX,ASCIIZ_BACKUP	; protect it
	INT	21H

	LEA	DI,ASCIIZ	; rename temporary
	LEA	DX,ASCIIZ_TEMP	; to current
	MOV	AH,56H
	INT	21H

H_T_F_EXIT:
	POP	ES
	POP	DS
	RET

HANDLE_TWO_FILES ENDP
;
;------------------------------------------------------



UPDATE_BACKUP_FILE PROC NEAR
	MOV	AX,4301H
	MOV	CX,0
	LEA	DX,ASCIIZ_BACKUP	; unprotect old backup file
	INT	21H

	MOV	AX,3D02H
	LEA	DX,ASCIIZ_BACKUP
	INT	21H	; open backup file
	JC	U_B_F_EXIT

	MOV	BX,AX
	MOV	AX,4200H
	MOV	CX,0
	MOV	DX,BACKUP_LSEEK+1	; point to a spot
	INT	21H

	LEA	DX,OUR_SPOTS_IO_AREA
	MOV	CX,2
	MOV	AH,40H	; store current LSN
	INT	21H

	MOV	AX,5700H	; get the files date and time
	INT	21H

	MOV	AX,5701H	; set the files date and time
	INT	21H


	MOV	AH,3EH	; close it
	INT	21H

	MOV	AX,4301H
	MOV	CX,21H	; archive+read-only
	LEA	DX,ASCIIZ_BACKUP	; protect it
	INT	21H

U_B_F_EXIT:
	RET

UPDATE_BACKUP_FILE ENDP




ABS_25	 PROC NEAR

;	 CX    = num of sectors to read
;	 DS:BX = transfer (read into) address
;	 ABS_25_LIST will contain the sector number

	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	SI
	PUSH	DI
	PUSH	BP
	PUSH	DS
	 PUSH  ABS_25_SEC_LO
	 PUSH  ABS_25_SEC_HI

	 CALL  NORMALIZE_DS_BX

	MOV	ABS_25_OFF,BX
	MOV	ABS_25_SEG,DS
	 MOV   TOTAL_SECTORS_TO_READ,CX

ABS_25_LOOP:
	 MOV   CX,TOTAL_SECTORS_TO_READ
	 JCXZ  ABS_25_THRU

	 CMP   CX,NUM_SECTORS_PER_64K
	 JBE   ABS_25_CONT
	 MOV   CX,NUM_SECTORS_PER_64K

ABS_25_CONT:
	MOV    ABS_25_COUNT,CX
	SUB    TOTAL_SECTORS_TO_READ,CX

; 5-1-89 GWD.  At least now we'll definitely return an error.
;	mov	ax,040Ch	;Sector-not-found + General error.
;	mov	dx,128
;	cmp	dx,cx	;Trying more than 128 sectors?
;	jb	abs_25_exit	;Yes.  Return the error.

	MOV	AL,ASCIIZ
	SUB	AL,41H
	MOV	DX,ABS_25_SEC_LO
	TEST	MIRROR_SWITCH,ABS_25_HARD_WAY
	JZ	ABS_25_READ
	MOV	CX,-1
	MOV	DS,CS_SAVE
	LEA	BX,ABS_25_LIST

ABS_25_READ:
	INT	25H
	JC	ABS_25_ERROR
	POPF
	 ADD   ABS_25_SEG,1000H
	 MOV   AX,NUM_SECTORS_PER_64K
	 ADD   ABS_25_SEC_LO,AX
	 ADC   ABS_25_SEC_HI,0
	 JMP   ABS_25_LOOP

ABS_25_THRU:
	CLC

ABS_25_EXIT:
	 POP   ABS_25_SEC_HI
	 POP   ABS_25_SEC_LO
	POP	DS
	POP	BP
	POP	DI
	POP	SI
	POP	DX
	POP	CX
	POP	BX
	RET

ABS_25_ERROR:
	POPF
	STC
	JMP	ABS_25_EXIT

ABS_25	 ENDP



NORMALIZE_DS_BX PROC NEAR
	 PUSH  AX
	 PUSH  CX
	 PUSH  BX
	 MOV   AX,DS
	 MOV   CL,4
	 SHR   BX,CL
	 ADD   AX,BX
	 MOV   DS,AX
	 POP   BX
	 AND   BX,0FH
	 POP   CX
	 POP   AX
	 RET

NORMALIZE_DS_BX ENDP



ABS_26	 PROC NEAR

;	 CX    = num of sectors to write
;	 DS:BX = transfer (write from) address
;	 ABS_25_LIST will contain the sector number

	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	SI
	PUSH	DI
	PUSH	BP
	PUSH	DS

	MOV	ABS_25_OFF,BX
	MOV	ABS_25_SEG,DS
	MOV	ABS_25_COUNT,CX

; 5-1-89 GWD.  At least now we'll definitely return an error.
	mov	ax,040Ch	;Sector-not-found + General error.
	mov	dx,128
	cmp	dx,cx	;Trying more than 128 sectors?
	jb	abs_26_exit	;Yes.  Return the fake error.

	MOV	AL,ASCIIZ
	SUB	AL,41H
	MOV	DX,ABS_25_SEC_LO
	TEST	MIRROR_SWITCH,ABS_25_HARD_WAY
	JZ	ABS_26_WRITE
	MOV	CX,-1
	MOV	DS,CS_SAVE
	LEA	BX,ABS_25_LIST

ABS_26_WRITE:
	INT	26H
	JC	ABS_26_ERROR
	POPF
	CLC

ABS_26_EXIT:
	POP	DS
	POP	BP
	POP	DI
	POP	SI
	POP	DX
	POP	CX
	POP	BX
	RET

ABS_26_ERROR:
	POPF
	STC
	MOV	FAILURE_TYPE,AH		; M005;
	JMP	ABS_26_EXIT

ABS_26	 ENDP
;
;------------------------------------
CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\mirror\mir_last.asm ===
; Copyright 1987-1991 Central Point Software, Inc. All rights reserved.
;------------------------------------------------------
; This is the last module for CPS 5.0 MIRROR.COM
; When linking, this must be the last OBJ file.
;
; Stack reduced from 512 to 320 bytes (we use only 80).  v6.0  02-16-90.
;------------------------------------------------------
;
CODE	SEGMENT para public 'CODE'
	ASSUME	CS:CODE
	PUBLIC	stak_end, end_prog
		DB	320/13 DUP ("Mirror Stack ")	;Non-resident stack.
		EVEN
STAK_END	LABEL near		;That's the way Jim defined it.
END_PROG	DB	0FFH
CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\mirror\mir_org.asm ===
; Copyright (c) 1990-1991 Central Point Software, Inc. 
; All rights reserved
;
; This is the 1st module of MIRROR.COM
;
;  Change Log:
;
;    Date    Who   #			  Description
;  --------  ---  ----  -----------------------------------------------------
;  02/11/91  DLB  M006  Changed "entry" symbol to "$entry"


CODE	SEGMENT PARA PUBLIC 'CODE'
	ASSUME	CS:CODE, DS:nothing, ES:nothing

major_ver EQU	6
minor_ver EQU	6
;
major_digit EQU major_ver + "0"
minor_digit EQU minor_ver + "0"
;
	EXTRN	start:near		;In the _DTRK module.
	EXTRN	end_prog:byte		;In the _LAST module.
;
	PUBLIC	major_digit, minor_digit
	PUBLIC	$entry, org_id_length   ;M006
	PUBLIC	org_id2, org_id2_length
;
asm_message MACRO x1,x2,x3,x4,x5,x6,x7
	%OUT	*MSG: x1&x2&x3&x4&x5&x6&x7
	ENDM
;
IF2
	asm_message <Mirror version >,%major_ver,<.>,%minor_ver
ENDIF
;
	ORG	100h
$entry:	jmp	start           ;M006
;
	ORG	$entry + 3      ;M006
org_id2 LABEL byte
	DB	" Mirror "
org_id2_length EQU ($ - org_id2)
;
version_text LABEL byte
	DB	major_digit
	DB	"."
	DB	minor_digit
	DB	"m "
	DB	1Ah
;
	DW	end_prog	;Changes with program size.
;
org_id_length EQU ($ - $entry)  ;M006
;
CODE	ENDS
	END	$entry


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\comp\comp.c ===
/*************************************************************************/
/*                                                                       */
/*  FILE:    Comp.C                                                      */
/*                                                                       */
/*  SYNTAX:  comp <filespec1> <filespec2> </d> </a> </l> </n=xxxx> </c>  */
/*                                                                       */
/*  PURPOSE: Compares two files and displays the first 10 differences    */
/*           between them.  The parameters filespec1 and filespec2 can   */
/*           each have wildcards, in which case comp will compare sets   */
/*           of files, two at a time.  Normally the differences print    */
/*           out as hex bytes; options affect them as follows:           */
/*              /d  -  print out as decimal (ints)                       */
/*              /a  -  as (ascii) characters                             */
/*              /l  -  print the line number of the mismatch             */
/*                     (rather than the byte offset)                     */
/*              /n with number  -  only the first arg # of lines         */
/*                                 get compared                          */
/*              /c  -  do a case-insensitive compare.                    */
/*                                                                       */
/*  LABEL:   Microsoft Confidential                                      */
/*           Copyright (c) Microsoft Corporation 1991                    */
/*           All Rights Reserved.                                        */
/*                                                                       */
/*************************************************************************/


#include <dos.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <ctype.h>
#include <string.h>
#include <io.h>
#include "version.h"
#include "comp.h"
#include "messages.h"


/**************************************************************************/
/* First check if the user wanted help; if so, print out help text and    */
/* quit, even if parameters other than '?' were passed to comp.  Next we  */
/* call getmem to retrieve enough memory for the two buffers which will   */
/* hold the two files being compared.  Now we call ppargs, passing it the */
/* argument vector (and count.)  Ppargs insures that both file            */
/* specifications are legitimate, by checking  to see that they are not   */
/* empty (if they are, prompt the user) & that they contain a full file   */
/* specification (i.e. not just a drive letter, or directory designation.)*/
/* If file specifications needed to be gotten interactively, ppargs also  */
/* asks the user for options.  PPargs also checks the given switches one  */
/* one as it encounters them. If no switches are given and when the user  */
/* didn't give both file names, then ppargs also request for options and  */
/* processes them. Upon returning it remains only to expand any      	  */
/* wildcards in the two filespecs.  Wildcards do not play an equivalent   */
/* role in both filespecs.  A wildcard in the spec for file1 has the      */
/* standard use of a wildcard, i.e. "find all files matching this         */
/* specification," a la FindFirst and FindNext.  A wildcard in the spec   */
/* for file2 specifies pattern matching WITH RESPECT TO FILE1, so that    */
/* the wildcard character in the spec for file2 gets replaced with as     */
/* many characters from file1 as needed to flesh out the spec in a way    */
/* that "matches" file1.  If no such expansion is possible, this is       */
/* considered a failure and comp returns an error code. Finally, we call  */
/* the compare routine which compares the two files in a manner dependent */
/* upon the options which have been specified.                            */
/**************************************************************************/

int main(int argc, char *argv[])
{
  char *locargv[MAX_PARAMS];      /* another (local) argument vector */
  char answer[2];	          /* answer to "Compare more files (Y/N) ? */
  int ret;                        /* return value */
  Index i;                        /* loop counter */
  union REGS reg;                 /* structure for doing int21's */

  /* set up exit routine */
  atexit(ExitComp);

  /* Do DOS version check */
  reg.h.ah = VERSION_NUM;
  reg.h.al = 0x0;
  intdos(&reg, &reg);
  if ( (reg.h.al < MAJ_VER_NUM) || 
       ((reg.h.al == MAJ_VER_NUM) && (reg.h.ah < MIN_VER_NUM)) )
  {
    Beep();
    printf("%s\n", msg_tbl[INCORRECT_DOS_VER]);
    return (INCORRECT_DOS_VER);
  }

  /*
   *  Check for "/?" on the command line. If found, output the options
   *  help message, and then exit.
   */
  if (CheckOptionsHelp(argc, argv))
    return (SUCCESS);             /* not an error to ask for help */

  reg.h.ah = 0x44;
  reg.h.al = 0x0;                       /* get device info */
  reg.x.bx = 0x0;                       /* for STDIN */
  intdos(&reg, &reg);
  if (reg.x.dx & 0x80)
    input_redir = 0;
  else
    input_redir = 1;

  /* Get space for the two buffers */
  if ((bufsiz = getmem(&buf1, &buf2)) == NO_MEMORY)
  {
    Beep();
    printf("%s\n", msg_tbl[NO_MEM_AVAIL]);
    return (NO_MEM_AVAIL);
  }

  /* get the current append status */
  reg.x.ax = GET_APPEND_STATUS;
  int86(APPEND_INT,&reg, &reg);
  append_stat = reg.x.bx;

  do
  {
    /* Initialize possible storage space for command line parameters */
    for (i = 0; i < MAX_PARAMS; i++)
      locargv[i] = NULLPTR;

    /* Make sure filespecs are valid */
    if (ret = ppargs(argv, &argc, locargv))
    {
      if (ret != NO_MEM_AVAIL)
        continue;
      else
        exit(NO_MEM_AVAIL);
    }

    /* Parse the two filenames and compare the two files */
    ParseFileNames(locargv[1], locargv[2]);

    /* Free the memory used for storing command line arguments */
    for (i = 0; i < MAX_PARAMS; i++)
    {
      if (locargv[i] != NULLPTR)
        free((void *)locargv[i]);
    }

    /*
     *  The routine getche used to be used here.  However, when the input is
     *  redirected,  getche still uses int21 - fn 1 instead of using file
     *  read on handle 0.  Problems with compiler, probably, so changed
     *  getche to gets.
     */
    while (TRUE)
    {
      fprintf(stderr, "%s", msg_tbl[COMPARE_MORE]);
      compgets(answer,2);
      *answer = toupper(*answer);
      if ((*answer == YES) || (*answer == NO))             /* M007 */
        break;
    }
    argc = 1;

  } while (*answer == YES);                                /* M007 */

  exit(SUCCESS);
}


/*********************************************************************/
/* Routine:   CheckOptionsHelp                                       */
/*                                                                   */
/* Function:  Checks for "/?" on the command line (any of the argv   */
/*            except argv[0]).  If found, display the options help   */
/*            message, and returns TRUE, so main() will know it      */
/*            should exit.                                           */
/*                                                                   */
/* Arguments: Receives argc and argv from main().                    */
/*            put the answer.                                        */
/*                                                                   */
/* Returns:   TRUE if /? found, FALSE otherwise.                     */
/*********************************************************************/

int CheckOptionsHelp(int c, char *v[])
{
  int i;

  for (c--, v++; c; c--, v++)
  {
    if (v[0][0] == '/' && v[0][1] == '?')
    {
      /* print out the help message */
      for (i=0; i < USER_HELP_LINES; i++)
        printf("%s\n", msg_tbl[USER_HELP1 + i]);
      return (TRUE);                        /* /? found, message printed */
    }
  }
  /* M003 - move this return out of the FOR loop */
  return (FALSE);                         /* /? not found, no message */
}


/*********************************************************************/
/* Routine:   comp                                                   */
/*                                                                   */
/* Function:  Compare the two files.                                 */
/*********************************************************************/

unsigned comp(Pathname file1, Pathname file2)  
{
  unsigned char *ptr1, *ptr2;        /* ptrs to move along the buffers */
  int  handle1, handle2;             /* handles for the two files */
  unsigned mismatch = 0;             /* count of the number of mismatches */
  unsigned char_cnt,                 /* # of buffer chars compared so far */
	   cr_count1 = 1,            /* # of Carr. Ret. seen in first file */
           cr_count2 = 1,            /* # of Carr. Ret. seen in second file */
	   read1, read2;             /* # of chars read into buf1, buf2 */
  unsigned long total_cnt = 0;       /* # of file chars compared so far */


  /* Tell user we are comparing the files */
  printf("%s%s%s%s%s\n", msg_tbl[COMPARING], file1, msg_tbl[AND], file2,
                         msg_tbl[ELLIPSES]);

  /* Open the two files */
  if ((open_file(file1, &handle1)) || (open_file(file2, &handle2)))
  {
    _dos_close(handle1);
    return (CANT_OPEN_FILE);
  }

  /* If the user did not ask to compare only a certain number of lines, */
  /* make sure the file sizes are the same before doing the compare     */
  if (!limit)
  {
    if (filelength(handle1) != filelength(handle2))
    {
      Beep();
      printf("%s\n", msg_tbl[DIFFERENT_SIZES]);
      _dos_close(handle1);                       /* M006 */
      _dos_close(handle2);                       /* M006 */
      return (DIFFERENT_SIZES);
    }
  }

  /* Repeatedly read one bufferful from each file and compare the bytes */
  do
  {
    if ((read_file(handle1, (void far *)buf1, bufsiz, &read1, file1)) ||
        (read_file(handle2, (void far *)buf2, bufsiz, &read2, file2)))
    {
      _dos_close(handle1);
      _dos_close(handle2);
      return (CANT_READ_FILE);
    }

    /* (Re)initialize data */
    char_cnt = 0;
    ptr1 = buf1;
    ptr2 = buf2;

    /*
     *  Run through the buffers and compare bytes.
     *
     *  If the user either asked to have the line count (rather than byte    
     *  offset) of the mismatches reported, or wanted only the first n lines 
     *  to be compared, we need to count Carriage Returns, which is how we   
     *  determine the line number.  Note that this is not an extremely       
     *  accurate method, i.e. the two files may differ at a character which  
     *  happens to be a CR, but for the purposes of this program, counting   
     *  Carriage Returns in the first file is a sufficient means of getting  
     *  the line count.
     */
    if (count_lines || limit)
    {
      while ((char_cnt++ <= read1) && (char_cnt <= read2) &&
             (mismatch < MAX_NUM_DIFF))                    /* M011 */
      {

#ifdef DBCS
	if (IsDBCSLeadByte(*ptr1) &&
            (char_cnt < read1) && (char_cnt < read2))      /* M011 */
        {
	  if (ptr1[0] != ptr2[0] || ptr1[1] != ptr2[1])
	  {
            if (asci)
            {
	      printf("%s%u\n%s%c%c\n%s%c%c\n", msg_tbl[COMP2_ERR], cr_count1,
                      msg_tbl[FILE1], ptr1[0], ptr1[1], msg_tbl[FILE2],
                      ptr2[0], ptr2[1]);
            }
	    else
            {
	      printf("%s%u\n%s%X%X\n%s%X%X\n", msg_tbl[COMP2_ERR], cr_count1,
                      msg_tbl[FILE1], ptr1[0], ptr1[1], msg_tbl[FILE2],
                      ptr2[0], ptr2[1]);
            }
	    mismatch++;
	  }
          char_cnt++;
          ptr1++;
          ptr2++;
	}
        else
        {
#endif

	  if (*ptr1 != *ptr2)
          {
            if ( (!no_case) || ((abs(*ptr1 - *ptr2)) != CASE_DIFFERENCE) )
            {
              printf(fmt, msg_tbl[COMP2_ERR], cr_count1, msg_tbl[FILE1],
                     *ptr1, msg_tbl[FILE2], *ptr2); 
              mismatch++;
            }
	  }

#ifdef DBCS
        }
#endif

        /* Count carriage returns */                       /* M011 Start */
        if (*ptr1 == NEWLINE)                         
        {
          cr_count1++;
          if (limit && (cr_count1 > limit))
            goto gtho;
        }
        if (*ptr2 == NEWLINE)
        {
          cr_count2++;
          if (limit && (cr_count2 > limit))
            goto gtho;
        }

        /*
         *  Make sure we haven't reached the end of one file before
         *  reaching the end of the other file (before reaching limit).
         */
        if (((char_cnt == read1) && (char_cnt < read2)) ||
            ((char_cnt > read1) && (char_cnt == read2)))
        {
          Beep();
          printf(msg_tbl[FILE1_LINES], cr_count1 - 1);
          mismatch++;
          goto gtho;
        }
        if (((char_cnt == read2) && (char_cnt < read1)) ||
            ((char_cnt > read2) && (char_cnt == read1)))
        {
          Beep();
          printf(msg_tbl[FILE2_LINES], cr_count2 - 1);
          mismatch++;
          goto gtho;
        }                                                  /* M011 End */

        ptr1++;
        ptr2++;                                            
      }
    }

    /*
     *  If we don't need to know the line count, there is no need to take
     *  the hit of checking each character to see whether it is a CR, so we
     *  have a separate loop here which does the same thing but excludes the
     *  check.
     */
    else
    {
      while ((char_cnt < read1) && (mismatch < MAX_NUM_DIFF))
      {
#ifdef DBCS
        if (IsDBCSLeadByte(*ptr1) && char_cnt+1 < read1)
	{
	  if (ptr1[0] != ptr2[0] || ptr1[1] != ptr2[1])
	  {
	    if (asci)
            {
	      printf("%s%lX\n%s%c%c\n%s%c%c\n", msg_tbl[COMP_ERR],
                      total_cnt + char_cnt, msg_tbl[FILE1], ptr1[0], ptr1[1],
                      msg_tbl[FILE2], ptr2[0], ptr2[1]);
            }
            else
            {
	      printf("%s%lX\n%s%X%X\n%s%X%X\n", msg_tbl[COMP_ERR],
                      total_cnt + char_cnt, msg_tbl[FILE1], ptr1[0], ptr1[1],
                      msg_tbl[FILE2], ptr2[0], ptr2[1]);
            }
            mismatch++;
          }
          char_cnt++;
          ptr1++;
          ptr2++;
	}
        else
        {
#endif
	  if (*ptr1 != *ptr2)
          {
	    if ( (!no_case) || ((abs(*ptr1 - *ptr2)) != CASE_DIFFERENCE) )
            {
	      printf(lfmt, msg_tbl[COMP_ERR], total_cnt + char_cnt,  
	             msg_tbl[FILE1], *ptr1, msg_tbl[FILE2], *ptr2);
	      mismatch++;
	    }
	  }
#ifdef DBCS
        }
#endif
        char_cnt++;
        ptr1++;
        ptr2++;
      }
    }

    total_cnt += char_cnt;

    if (mismatch > 9)
    {
      Beep();
      printf("\r\n%s\n", msg_tbl[TEN_MISM]);
      break;
    }

  } while ( (read1 == bufsiz) || (read2 == bufsiz) );      /* M011 */

gtho:                                /* get out */
  _dos_close(handle1);
  _dos_close(handle2);

  if (!mismatch)
  {
    printf("%s\n", msg_tbl[SUCCESS]);
    return (SUCCESS);
  }
  else                               /* M005 */
    printf("\r\n");                  /* print final carriage return */
} 


/*********************************************************************/
/* Routine:   open_file                                              */
/*                                                                   */
/* Function:  Open file specified by fname and return handle in      */
/*            location handleptr.                                    */
/*********************************************************************/

unsigned open_file(Pathname fname, int *handleptr)
{
  int retcode;
  union REGS reg;                 /* structure for doing intDos's */

  /*
   *  We must turn off APPEND before we start searching, otherwise
   *  we may end up comparing a file to itself.
   *  Turning APPEND off before FindFirst and Restoring it immediately
   *  after is much better than
   *    -  i) using FCB searching  as in 3.31
   *    - ii) turning off in the beginning and restoring at the
   *          end; this entails trapping Ctrl-C vector for
   *          cleanup
   *  Turn off APPEND
   */
  if (append_stat & 0xFF)
  {
    reg.x.ax = SET_APPEND_STATUS;
    reg.x.bx = append_stat & 0xFF00;        /* turn off APPEND */
    int86(APPEND_INT,&reg, &reg);
  }

  retcode = _dos_open(fname, O_RDONLY, handleptr); 

  /* restore the original append status */
  if (append_stat & 0xFF)
  {
    reg.x.ax = SET_APPEND_STATUS;
    reg.x.bx = append_stat; /* restore old value */
    int86(APPEND_INT,&reg, &reg);
  }
  /* end of append changes */
  if (retcode)
  {
    Beep();
    printf("%s%s\n", msg_tbl[CANT_OPEN_FILE], fname);          
    return (CANT_OPEN_FILE);                 
  }
  else
    return (SUCCESS);
}


/*********************************************************************/
/* Routine:   read_file                                              */
/*                                                                   */
/* Function:  Read file specified by fname.                          */
/*********************************************************************/
unsigned read_file(int handle, void far *location, unsigned int limit,
                   unsigned *num_read, Pathname fname)
{
  if (_dos_read(handle, location, limit, num_read))
  {
    Beep();
    printf("%s%s\n", msg_tbl[CANT_READ_FILE], fname);
    return (CANT_READ_FILE);
  }
  return (SUCCESS);
}


/*********************************************************************/
/* Routine:   getmem                                                 */
/*                                                                   */
/* Function:  Try to get 60K worth of memory, split between the two  */
/*            buffers. If not, repeatedly decrease the request by    */
/*            10K each time until we get some.                       */
/*********************************************************************/

int getmem(char **p1, char **p2)
{
  unsigned  bufsize;

  bufsize = 60000;
  while ( (*p1 = (char *)malloc(bufsize)) == NULL)
  {
    if (bufsize)
      bufsize -= 10000;
  }
  *p2 = *p1 + (bufsize / 2);      
  return (bufsize / 2);            
}


/*********************************************************************/
/* Routine:   getoneopt                                              */
/*                                                                   */
/* Function:  Set various control flags depending on which options   */
/*            the user has specified.                                */
/*              d = print out differing bytes as decimal numbers.    */
/*              a = print out differing bytes as characters (ascii). */
/*              n = only compare the first n lines of a file         */
/*                  (determined by counting Carriage Returns in the  */
/*                  the first file, - its a crude count because the  */
/*                  second file may not have same number of CR's).   */
/*              c = do a case insensitive comparison.                */
/*              l = tell them on which LINE there was a byte         */
/*                  mismatch as well as the byte number itself.      */
/*********************************************************************/

void getoneopt(char *av)
{
  char *temptr,*curopt,curchr;    /* to process switches in the same arg */

  if ((*av != SWITCH_CHAR_1) && (*av != SWITCH_CHAR_2))
  {
    Beep();
    printf("%s\n", msg_tbl[SYNT_ERR]);
    exit(SYNT_ERR);
  }

  curopt = av;
  while (TRUE)
  {
    switch (toupper(*(curopt + 1)))
    {
      case DECIMAL_SWITCH :
          decimal = TRUE;
	  if (asci)                    /* reset asci if set previously */
            asci = FALSE;
	  strcpy(lfmt, lfmt_str);
	  strcpy(fmt, fmt_str);
	  setfmt(lfmt, 'd');
	  setfmt(fmt, 'd');
	  break;
      case ASCII_SWITCH :
          asci = TRUE;
	  if (decimal)                 /* reset decimal if set previously */
            decimal = FALSE;
	  strcpy(lfmt, lfmt_str);
	  strcpy(fmt, fmt_str);
	  setfmt(lfmt, 'c');
	  setfmt(fmt, 'c');
	  break;
      case LIMIT_SWITCH :
          if ( *(curopt+2) != '=')
          {
            Beep();
	    printf("%s\n", msg_tbl[NEED_DELIM_CHAR]);
	    break;                     /* ignore limit_switch */
	  }
	  temptr = curopt + 3;
	  while ((curchr = *temptr) != '\0')
          {
	    if (!( (curchr >= '0') && (curchr <= '9') ))
            {
	      if ((curchr == SWITCH_CHAR_1) || (curchr == SWITCH_CHAR_2))
	      	break;
              Beep();
	      printf("%s\n%s\n", msg_tbl[BAD_NUMERIC_ARG], av);
	      exit(BAD_NUMERIC_ARG);
	    }
	    limit = (10 * limit) + (*temptr - '0');
	    temptr++;
	  }
	  curopt = temptr - 2;         /* to make up for the +2 later */
	  break;
      case NO_CASE_SWITCH :
          no_case = TRUE;
	  break;
      case LINE_CT_SWITCH :
          count_lines = TRUE;
	  break;
      default:
          Beep();
	  printf("%s %s\n",msg_tbl[INV_SWITCH],curopt);
	  exit(SYNT_ERR);
	  break;
    }
    curopt += 2;                       /* skip switch char and option char */
    if ((*curopt == SWITCH_CHAR_1) || (*curopt == SWITCH_CHAR_2))
      continue;
    else
      break;
  }
}


/*********************************************************************/ 
/* Routine:   ppargs                                                 */
/*                                                                   */
/* Function:  Pre-process command line : make sure the two filespecs */
/*            have legitimate filenames, query for options if        */
/*            original command line was incomplete.                  */
/*********************************************************************/

unsigned ppargs(char *argv[], int *argc, char *locargv[])
{
  int i, nooffiles, noofopts;
  unsigned att;                        /* storage for file attribute */
  char lastchr;

  /* Check to make sure user didn't pass too many arguments */
  if (*argc > MAX_PARAMS)
  {
    Beep();
    printf("%s\n", msg_tbl[TOO_MANY_ARGS]);
    return (TOO_MANY_ARGS);
  }

  /* Initialize variables */
  nooffiles = noofopts = 0;
  limit = 0;                                     /* M010 */
  
  /* Set local argument vector to point at the command line args given */
  for (i = 1; i < *argc; i++)
  {
    if ( (*argv[i] == SWITCH_CHAR_1) || (*argv[i] == SWITCH_CHAR_2))
    {
      noofopts++;
      locargv[noofopts+2] = argv[i];
      getoneopt(argv[i]);              /* process this option */
    }
    else if (*argv[i])                 /* treat this as a file spec */
    {
      nooffiles++;
      if (nooffiles > 2 )
      {
        Beep();
        printf("%s\n", msg_tbl[SYNT_ERR]);
        exit(SYNT_ERR);
      }
      locargv[nooffiles] = argv[i];    /* process the file name later */
    }
  }

  /* If any of the filename arguments were not given on the command line,  */
  /* get them now.  The following depends on the assumption that the first */
  /* two arguments are the filespecs, and any subsequent arguments are     */
  /* options.                                                              */
  for (i = nooffiles + 1; i <= 2; i++)
  {
    fprintf(stderr, "%s", msg_tbl[i + PPARG_MSG_OFF]);
    locargv[i] = (char *)malloc(MAXFLNM);
    if (locargv[i] == NULL)
    {
      Beep();
      printf("%s\n", msg_tbl[NO_MEM_AVAIL]);
      return (NO_MEM_AVAIL);
    }
    compgets(locargv[i],MAXFLNM+1);
  }

  /* Check whether the filespec was a drive designation or a partial       */
  /* filespec, i.e. directory specification only.  If so, tack on a "*.*"  */
  for (i = 1; i <= 2; i++)
  {
    if (dronly(locargv[i]))
    {
      locargv[i] = extend_length(locargv[i]);
      strcat(locargv[i],"*.*");
    }
    else if (!_dos_getfileattr(locargv[i], &att))
    {
      if (att & _A_SUBDIR)
      {
        lastchr = locargv[i][strlen(locargv[i]) -1];
        if (lastchr == '/')
          lastchr = '\\';

#ifdef DBCS
        if (lastchr != '\\' ||
            CheckDBCSTailByte(locargv[i],&locargv[i][strlen(locargv[i]) - 1]))
#else
        if (lastchr != '\\')
#endif
        { 
          locargv[i] = extend_length(locargv[i]);
	  strcat(locargv[i],"\\*.*");
	}
	else
        {
          locargv[i] = extend_length(locargv[i]);
          strcat(locargv[i],"*.*");
        }
      }
    }
  }

  /* Now we query for options, but only if the original command line  */
  /* was incomplete, i.e. even file(s) were not specified.  Otherwise */
  /* either user already specified options or doesn't want them.      */
  if ((nooffiles < 2) && !noofopts)
  {
    /*
     *  Really want ot start at 3, but need to increment at start of loop,
     *  so compensate.
     */
    i = noofopts + 2;
    do
    {
      i++;
      locargv[i] = (char *)malloc(OPT_SIZE); 
      if (locargv[i] == NULL)
      {
        Beep();
        printf("%s\n", msg_tbl[NO_MEM_AVAIL]);
        return (NO_MEM_AVAIL);
      }
      fprintf(stderr, "%s", msg_tbl[OPTION_REQUEST]);
      compgets(locargv[i],OPT_SIZE+1);
      if (*locargv[i] != '\0')
      { 
        noofopts++;
        getoneopt(locargv[i]);          /* process this option */
      }
      if (noofopts >= MAX_OPTIONS) 
        break;
    } while (*locargv[i] != '\0');
  }

  /* cleanup code for processing options */
  if ((!decimal) && (!asci))
  {
    setfmt(lfmt, 'X');
    setfmt(fmt, 'X');
  }
  return (SUCCESS);
}


/*********************************************************************/
/* Routine:   dronly                                                 */
/*                                                                   */
/* Function:  Determine whether the string in question designates a  */
/*            drive.                                                 */
/*********************************************************************/

int dronly(char *s)
{ 
  return ( (*(s + 1) == ':') && (*(s + 2) == '\0') );
}


/**************************************************************************/
/* Routine:   set_fmt                                                     */
/* Function:  Replace the characters '?' and '!' in the format string     */
/*            with the character specified.                               */
/* Arguments: A string containing format information for printf in which  */
/*            output specification information is missing (with           */
/*            placeholders ? and ! present instead), and the character    */
/*            with which to replace them.                                 */
/* Side effects: none                                                     */
/**************************************************************************/

void setfmt(char *fmtstr, char c)
{
  char *replace;

  if ((replace = strchr(fmtstr, '?')) != NULL)
    *replace = c;
  if ((replace = strchr(fmtstr, '!')) != NULL)
    *replace = c;
}


/**************************************************************************/
/* Routine:  extend_length                                                */
/* Function: make the string sufficiently long to add "\*.*" or "*.*" or  */
/*           "*" to it.                                                   */
/* Arguments: an arbitrary string                                         */
/**************************************************************************/

char *extend_length(char *s)
{
  char *news;

  news = (char *)malloc(strlen(s) + ENOUGH_EXTRA);
  strcpy(news, s);
  return (news);
}


/**************************************************************************/
/* Routine:  has_extension                                                */
/* Function: check for extensions in the string.                          */
/* Arguments: an arbitrary string                                         */
/**************************************************************************/

Boolean has_extension(char *s)
{
  int i;
  char *p1, *p2;

  p1 = s + strlen(s) - 1;
  for (i = 1; i <= 4; i++)
  {
    if (*p1 == '.')
      break;
    p1--;
  }
  p2 = strrchr(s, '\\');
  if (!p2) 
    p2 = strrchr(s,'/');
  if ((*p1 == '.') && !(p2 && (p2 > p1)))
    return (TRUE);
  else
    return (FALSE);
}

	
/*********************************************************************/ 
/* Routine:   compgets                                               */
/*                                                                   */
/* Function:  Simulate a fgets() to take care of buffer overflow.    */
/*********************************************************************/

void compgets(char *buff, int length)
{
  char *sptr;
  int i;
  union REGS reg;                      /* structure for doing int21's */

  if (input_redir)
  {
    reg.h.ah = 0xb;                    /* check input status */
    intdos(&reg,&reg);
    if (reg.h.al == 0)                 /* EOF ? */
    {
      Beep();
      printf("%s\n", msg_tbl[UNEXP_EOF]);
      exit(UNEXP_EOF);
    }
  }

  /* else  - NOT EOF; go get input */
  GetInput(&length);

  sptr = getsbuf;
  if (*sptr == EOFCHAR)
  {
    Beep();
    printf("%s\n", msg_tbl[UNEXP_EOF]);
    exit(UNEXP_EOF);
  }
  for (i = 0; i < length; i++)
    *buff++ = *sptr++;
  *buff = '\0';                        /* null terminate the string */
}


/*********************************************************************/ 
/* Routine:   GetInput                                               */
/*                                                                   */
/* Function:  Gets the input from stdin and outputs it to stderr.    */
/*            The number of characters read is returned.             */
/*            Outputing the input to stderr allows the input to be   */
/*            echoed to the screen when the output is redirected.    */
/*                                                                   */
/* Note:      This routine uses the global getsbuf buffer to save    */
/*            the input.  It assumes that the caller sends in a      */
/*            length that is LESS THAN the size of getsbuf.          */
/*********************************************************************/

void GetInput(int *length)
{
  register int NumRead = 0;            /* number of bytes read */
  register char c;                     /* character read in */


  /* read a character from stdin without echoing it */
  c = ReadStdin();                          /* M012 */

  /*  M012
   *  If the input has been redirected and the first character read in
   *  is a newline, then ignore the newline and read the next character.
   *  The reason for this is that when command.com redirects stdin to a
   *  file containing the comp command, the newline after the carriage
   *  return is NOT read when using int 21 function 08h.
   */
  if ((input_redir) && (c == NEWLINE))
    c = ReadStdin();
  
  while (TRUE)
  {
    /* don't allow user to type more than needed */
    if (c == BACKSPACE)
    {
      if (NumRead > 0)
      {
        /* write the backspace to stderr */
        WriteStderr(c);

        /* decrement count of number of bytes read */
        NumRead--;

        /* delete the character from the screen */
        WriteStderr(SPACEBAR);
        WriteStderr(BACKSPACE);
      }
      else
        Beep();                        /* sound beep for error */
    }
    else if (c == RETURNCHAR)
    {
      /* write the return character to stderr */
      WriteStderr(c);

      /* if stdin redirected, read new line character */
      if (input_redir)                      /* M009 - Start */
      {
        /* read the new line character from stdin */
        ReadStdin();                        /* M012 */
      }
      /* echo newline character */
      WriteStderr(NEWLINE);                 /* M009 - End */

      /* break out of loop, done */
      break;
    }
    else if (c == EOFCHAR)                  /* M009 - Start */
    {
      Beep();
      printf("\n%s\n", msg_tbl[UNEXP_EOF]);
      exit(UNEXP_EOF);
    }                                       /* M009 - End */
    else if (NumRead < (*length - 1)) 
    {
      /* write the character to stderr */
      WriteStderr(c);

      /* save the character in getsbuf and increment counter */
      getsbuf[NumRead] = c;
      NumRead++;
    }
    else
      Beep();                               /* sound beep for error */

    /* read the next character from stdin without echoing it */
    c = ReadStdin();                        /* M012 */
  }

  /* return the number of bytes read from stdin */
  *length = NumRead;
}


/*********************************************************************/ 
/* Routine:   ReadStdin                                              */
/*                                                                   */
/* Function:  Read a character from stdin without echoing the        */
/*            character and return the character to the calling      */
/*            routine.                                               */
/* M012                                                              */
/*********************************************************************/

char ReadStdin()
{
  union REGS reg;                      /* structure for doing int21's */
    
  reg.h.ah = 0x08;                     /* read character without echo */
  intdos(&reg, &reg);
  return (reg.h.al);                   /* return the character */
}


/*********************************************************************/ 
/* Routine:   WriteStderr                                            */
/*                                                                   */
/* Function:  Writes a character to stderr.                          */
/*********************************************************************/

void WriteStderr(char ch)
{
  union REGS reg;                      /* structure for doing int21's */
    
  reg.h.ah = 0x40;                     /* write to a device */
  reg.x.bx = 0x2;                      /* stderr */
  reg.x.cx = 0x1;                      /* write 1 byte */
  reg.x.dx = (unsigned) &ch;           /* character to write */
  intdos(&reg,&reg);
}


/*********************************************************************/ 
/* Routine:   ParseFileNames                                         */
/*                                                                   */
/* Function:  Parses the two given filenames and then compares the   */
/*            appropriate filenames.  This routine handles wildcard  */
/*            characters in both filenames.                          */
/*********************************************************************/

void ParseFileNames(char *file1, char *file2)
{
  struct find_t struct1;                  /* for findfirst/findnext */
  Pathname final1, final2;                /* final path and filename */
  Pathname inter2;                        /* intermediate filename for file2 */
  char *fname1, *fname2;                  /* filename begins here */
  int Wildcard2;                          /* if file2 contains a wildcard */


  /* Convert filenames to uppercase. */
  strupr(file1);
  strupr(file2);

  /* Copy current pathnames to final destination holders */
  strcpy(final1, file1);
  strcpy(final2, file2);

  /* Find position of filename for both pathnames */
  fname1 = FindFileName(final1);
  fname2 = FindFileName(final2);

  /*
   *  If a "*" is found by itself, make it "*.*".  The reason for this is
   *  that dos_findfirst treats "*" as "*." instead of "*.*".
   */
  CheckWildcard(final1, fname1);
  CheckWildcard(final2, fname2);

  /*
   *  Copy final2 filename to intermediate holder (contains wildcards).
   *  This is needed because final2 will be overwritten for each
   *  iteration through the loop.
   */
  strcpy(inter2, final2);

  /* Get name of first file1 to compare (handles wildcards). */
  if (_dos_findfirst(final1, _A_RDONLY, &struct1))
  {
    /* dos_findfirst failed, so print message */
    Beep();
    printf("%s%s\n", msg_tbl[CANT_OPEN_FILE], file1);
    return;
  }

  /* Set flag for whether or not file2 has a wildcard */
  Wildcard2 = HasWildcard(inter2);

  do
  {
    /*
     *  Create full pathname for file 1 with original path and new file name.
     *  This assumes that dos_findfirst returns an uppercase filename.
     */
    strcpy(fname1, struct1.name);

    if ( Wildcard2 )
    {
      /* Expand wildcards in file2 and compare the two files. */
      if (ExpandFile2(fname1, fname2))           /* M008 */
      {                                /* expansion of file2 failed */
        Beep();
        printf("%s     %s\n%s\n\n\n", final1, file2, msg_tbl[COULD_NOT_EXP]);
      }
      else
        comp(final1, final2);          /* compare the two files */
      
      strcpy(final2, inter2);          /* recopy original with wildcards */
    }                                            /* M008 */
    else
    {
      /* no wildcards in file2, so just compare final1 and final2 */
      comp(final1, final2);
    }
  } while (!_dos_findnext(&struct1));
}


/*********************************************************************/ 
/* Routine:   FindFileName                                           */
/*                                                                   */
/* Function:  Returns the pointer to the start of the filename in    */
/*            the given pathname.                                    */
/*********************************************************************/

char *FindFileName(char *pathname)
{
  int len1;
  char *ptr;

  
  len1 = strlen(pathname);
  ptr = pathname + len1 - 1;           /* position ptr at end of string */

#ifdef DBCS
  while ( ((len1-- && (*ptr != '\\')) && (*ptr != ':') && (*ptr != '/')) ||
          (len1 > 0 && CheckDBCSTailByte(pathname, ptr)) )
#else
  while ( (len1-- && (*ptr != '\\')) && (*ptr != ':') && (*ptr != '/') )
#endif
    ptr--;

    return (ptr + 1);
}


/*********************************************************************/ 
/* Routine:   HasWildcard                                            */
/*                                                                   */
/* Function:  Returns TRUE if string has a wildcard character.       */
/*            Otherwise, it returns FALSE.                           */
/*********************************************************************/

Boolean HasWildcard(char *file)
{
  if ( strchr(file, '?') || strchr(file, '*') )
    return (TRUE);
  return (FALSE);
}


/*********************************************************************/ 
/* Routine:   CheckWildcard                                          */
/*                                                                   */
/* Function:  If a "*" is found by itself in the filename, then it   */
/*            is changed to "*.*".  The reason for this is that      */
/*            dos_findfirst treats "*" as "*." instead of "*.*".     */
/*********************************************************************/

void CheckWildcard(char *path, char *file)
{
  char *ptr;                  /* ptr to wildcard in filename */
  
  if ( (!strchr(file, '.')) && (ptr = strchr(file, '*')) )
  {
    if (strlen(path) <= (MAXFLNM - 3))
    {
      /* change the '*' to '*.*' */
      *(ptr+1) = '.';
      *(ptr+2) = '*';
      *(ptr+3) = 0;                    /* end of string marker */
    }
  }
}


/*********************************************************************/ 
/* Routine:   ExpandFile2                                            */
/*                                                                   */
/* Function:  Expands the wildcards found in File2 to match File1.   */
/*            This routine is ONLY called if wildcards exist in      */
/*            File2.                                                 */
/* M008                                                              */
/*********************************************************************/

int ExpandFile2(char *File1, char *File2)
{
  char *Ptr1, *Ptr2;                   /* temp ptrs to filenames */
  char *Dot1, *Dot2;                   /* ptrs to dots in filenames */
  char *End1, *End2;                   /* ptrs to ends of filenames */
  char Storage[5];                     /* temp storage for file extension */
  char *TempFile2;                     /* temp pointer to File2 */

  /*
   *  Initialize pointers to filename sections.
   *  If a filename does not contain an extension, then Dot = End.
   */
  End1 = File1 + strlen(File1);
  End2 = File2 + strlen(File2);
  if (!(Dot1 = strrchr(File1, '.')))
    Dot1 = End1;
  if (!(Dot2 = strrchr(File2, '.')))
    Dot2 = End2;

  /*
   *  Expand '*' wildcard inside File2 by copying characters from
   *  File1 to File2.
   */
  if (Ptr2 = strchr(File2, '*'))
  {
    if (Ptr2 < Dot2)                   /* in first 8 of 8.3 for File2 */
    {
      strcpy(Storage, Dot2);           /* save extension of File2 */
      Ptr1 = File1 + (Ptr2 - File2);
      for (; Ptr1 < Dot1; Ptr1++, Ptr2++)
        *Ptr2 = *Ptr1;
      *Ptr2 = 0;
      End2 = End2 + (Ptr2 - Dot2);     /* reset End2 to new location */
      Dot2 = Ptr2;                     /* reset Dot2 to new location */
      strcat(File2, Storage);          /* recopy saved extension to File2 */
    }
    if (Ptr2 = strchr(File2, '*'))     /* in extension of 8.3 for File2 */
    {
      Ptr1 = Dot1 + (Ptr2 - Dot2);
      for (; Ptr1 < End1; Ptr1++, Ptr2++)
        *Ptr2 = *Ptr1;
      *Ptr2 = 0;                       /* null terminate string */
      End2 = Ptr2;                     /* reset End2 to new location */
    }
  }

  /*
   *  Expand '?' wildcard inside File2 by copying a character from
   *  File1 to File2.
   */
  TempFile2 = File2;
  while (Ptr2 = strchr(TempFile2, '?'))
  {
    if (Ptr2 < Dot2)                   /* in first 8 of 8.3 for File2 */
    {
      Ptr1 = File1 + (Ptr2 - File2);
      if (Ptr1 < Dot1)
        *Ptr2 = *Ptr1;
      else                             /* nothing in File1 matches '?' in File2 */
        return (FAILURE);              /*   return error */
    }
    else                               /* in extension of 8.3 for File2 */
    {
      Ptr1 = Dot1 + (Ptr2 - Dot2);
      if (Ptr1 < End1)
        *Ptr2 = *Ptr1;
      else                             /* nothing in File1 matches '?' in File2 */
        return (FAILURE);              /*   return error */
    }
    TempFile2 = Ptr2 + 1;              /* TempFile2 is now 1 after current '?' */
  }

  /* If the dot is the last character in the string, remove it. */
  if ((Ptr2 = strrchr(File2, '.')) == (End2 - 1))
    *Ptr2 = 0;

  return (SUCCESS);
}


/*********************************************************************/ 
/* Routine:   ExitComp                                               */
/*                                                                   */
/* Function:  Frees the allocated buffer whenever exit is used.      */
/* M006                                                              */
/*********************************************************************/

void ExitComp()
{
  free((void *)buf1);
}



#ifdef DBCS

/*********************************************************************/ 
/* Routine:   IsDBCSLeadByte                                         */
/*                                                                   */
/* Function:  Test if the character is DBCS lead byte.               */
/*                                                                   */
/*      input:  c = character to test                                */
/*      output: TRUE if leadbyte                                     */
/*********************************************************************/

int IsDBCSLeadByte(unsigned char c)
{
  static unsigned char far *DBCSLeadByteTable = NULL;
  union REGS inregs,outregs;
  struct SREGS segregs;
  unsigned char far *p;

  if (DBCSLeadByteTable == NULL)
  {
    inregs.x.ax = 0x6300;           /* get DBCS lead byte table */
    intdosx(&inregs, &outregs, &segregs);
    FP_OFF(DBCSLeadByteTable) = outregs.x.si;
    FP_SEG(DBCSLeadByteTable) = segregs.ds;
  }

  p = DBCSLeadByteTable;
  while (p[0] || p[1])
  {
    if (c >= p[0] && c <= p[1])
      return (TRUE);
    p += 2;
  }
  return (FALSE);
}


/*********************************************************************/ 
/* Routine:   CheckDBCSTailByte                                      */
/*                                                                   */
/* Function:  Check if the character point is at tail byte.          */
/*                                                                   */
/*      input:  *str = strart pointer of the string                  */
/*              *point = character pointer to check                  */
/*      output: TRUE if at the tail byte                             */
/*********************************************************************/

int CheckDBCSTailByte(unsigned char *str, unsigned char *point)
{
  unsigned char *p;

  p = point;
  while (p != str)
  {
    p--;
    if (!IsDBCSLeadByte(*p))
    {
      p++;
      break;
    }
  }
  return ( (point - p) & 1 ? TRUE : FALSE );
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\rebuild\uf_io.asm ===
; Copyright 1990 Central Point Software, Inc. 
; All rights reserved.
;--------------------------------------------------------------------
; These are the console I/O procedures for the UnFormat program.
; Written by GWD, 1987-1988.
;
; International support added 5-23-89 GWD.
; Fixed DOS bug (time separator = "." ?!)  5-24-89 GWD.
; Added ALT or SHIFT key pause in PRINTC.  02-16-90  6.0
;
;--------------------------------------------------------------------
;
prog	SEGMENT public
	ASSUME	CS:prog, DS:prog

        include uf_incl.inc
;
	PUBLIC	display, dis_word
	PUBLIC	tab, printc, pr_text, crout, getkey, flushkey
	PUBLIC	getline, uppercase, pr_hex_word, pr_hex_byte
	PUBLIC	pr_dec, red_pointer, ask_for_yes, skipb, ask_trunc
	PUBLIC	pr_decl
	PUBLIC	print_flags, pf_allowed, pf_con_pe, pf_ptime
	PUBLIC	show_progress, show_dir_info, pr_dec2
	PUBLIC	show_date, show_time, show_month, show_year, show_day
	PUBLIC	display_options, look_for_parms, parse_item
	PUBLIC	copy_fname
	PUBLIC	get_country_info, date_control, date_separator
;
	EXTRN	cluster_index:word, cluster_cnt_plus_1:word
	EXTRN	progress:word, hsub_count:word
	EXTRN	curr_fname:byte, options:word, option_table:byte
;
	EXTRN	text_yes:byte, text_yes_length:abs
	EXTRN	delete_char:abs, truncate_char:abs, all_char:abs
	EXTRN	msg_sure:byte
	EXTRN	msg_ask_trunc:byte
	EXTRN	msg_fat_prot:byte, msg_root_prot:byte
	EXTRN	msg_erase_fat:byte, msg_erase_root:byte
	EXTRN	msg_arrow:byte, msg_write_fake:byte
	EXTRN	msg_dir:byte, msg_vol:byte

;	M005 -- made the following into two separate messages

	EXTRN	msg_progress_sing:byte, msg_progress_plural:byte

;
cr	EQU	13
lf	EQU	10
;
;------------------------------------------------------------------
; These control the country-dependant display of dates & times.
; The main module must initialized these by calling
; GET_COUNTRY_INFO (only once!).
;
country_buffer LABEL byte			;A buffer for DOS fct # 38h.
		DB	0,0, 27 DUP (-1)	;Init to -1 to detect DOS 2.x
		DB	0,0,0				;Just in case.
;
country_code	DW	0
date_control	DW	0	;0='m-d-y',  1='d-m-y',  2='y-m-d'.
date_separator	DB	"-"
time_separator	DB	":"
time_in_24hr	DB	0	;0 = 12-hour.  1 = 24-hour.
;
;------------------------------------------------------------------
; On exit: country-dependant info is filled in and AX=country_code.
;
; Only AX is changed.
;
get_country_info PROC NEAR
	push	bx
	push	dx
	cmp	country_code,0
	jnz	gci_end 		;Already got the info.
	xor	bx,bx
	lea	dx,country_buffer
	mov	ax,3800h		;Get country-dependant info from DOS.
	int	21h
	mov	country_code,bx
	mov	ax,word ptr country_buffer+0	;Date/Time format code.
	mov	date_control,ax
	mov	al,country_buffer+11h	;Clock 12hr/24hr control.
	cmp	al,-1			;DOS 3.0+ would change it from -1.
	je	gci_end 		;It's DOS 2.x, so that's all.
	mov	time_in_24hr,al
	mov	al,country_buffer+0Bh
	mov	date_separator,al
	mov	al,country_buffer+0Dh
	cmp	al,"."
	je	gci_end 		;Don't beleive ".", use default colon.
	mov	time_separator,al
gci_end:
	mov	ax,country_code
	pop	dx
	pop	bx
	ret
get_country_info ENDP
;
;------------------------------------------------------------------
tab	PROC NEAR	;Move to column AL on the current line.
	push	ax
	cmp	al,79
	jbe	tab1
	mov	al,79
tab1:	sub	al,column	;(Requested_column - current_column)
	jbe	tab_done	;Already there or beyond.  Do nothing.
	mov	ah,al
	mov	al," "
tab_lp: call	printc
	dec	ah
	jnz	tab_lp
tab_done:
	pop	ax
	ret
tab	ENDP
;
column	DB	0
;
;------------------------------------------------------------------
; Output the character in AL.	On exit: all regs unchanged.
;
; If PRINT_FLAGS contains the proper value, chars are echoed to LPT1.
;
print_flags DB	0	;Bit flags,  definitions are below.
;
	DB	0	;Extra 0 byte - option parser expects a Word var.
;
pf_allowed EQU	1	;Printing is possible (cmd line option).
pf_con_pe EQU	2	;Console has toggled printing ON.
pf_ptime EQU	80h	;Printable output is now occuring.
;
; Note - printing will actually occur only when PRINT_FLAGS = PF_ACTIVE.
;
pf_active EQU	pf_allowed + pf_con_pe + pf_ptime
;
;
; If RED_POINTER is NZ, PRINTC will write the char to CS:[RED_POINTER],
; But while RED_POINTER is 0, characters are sent to the screen.
;
red_pointer DW	0	;Redirection pointer.
;
printc	PROC NEAR
	cmp	cs:red_pointer,0	;Are we redirected to memory?
	jnz	prc_redirect		;Yes.  Display/print nothing.
	cmp	al," "
	jb	prc_ctrl

prc_inc:
	inc	cs:column

prc_go: push	ax
	PUSH	DX
;	push	bx
;	mov	bx,7
;	mov	ah,0Eh
	MOV	AH,2
	MOV	DL,AL
	INT	21H
;	int	10h		;Video BIOS 'teletype' output.
;	pop	bx
	POP	DX
	pop	ax
	cmp	cs:print_flags, pf_active
	je	prc_printer

prc_done:
	ret
;
prc_ctrl:
	cmp	al,7
	je	prc_go
	cmp	al,lf
	je	prc_go
	cmp	al,cr
	je	prc_cr
	cmp	al,8
	jne	prc_inc
	sub	cs:column,1
	jae	prc_go

prc_cr: mov	cs:column,0
	push	ax

prc_wait:
	sti
	mov	ah,2		;Get Bios keyboard shift states.
	int	16h
	sti
	test	al,0100B	;Ctrl is pressed?
	jnz	prc_end_wait
	test	al,1011B	;Alt or Shift is pressed?
	jnz	prc_wait

prc_end_wait:
	pop	ax
	jmp	prc_go

prc_printer:
	push	ax
	push	dx
	cmp	al,7
	je	prc_px		;Don't send Bell to LPT1.
	xor	dx,dx		;Select LPT1.
	push	bx		;Cover bug in stupid spooler.
	mov	ah,0		;Command = print.
	int	17h
	pop	bx
	test	ah,1			;Any error printing?
	jz	prc_px			;No.
	and	cs:print_flags, NOT pf_con_pe	;Error.  Shut printing off.

prc_px: pop	dx
	pop	ax
	jmp	prc_done
;
prc_redirect:
	xchg	di,cs:red_pointer
	mov	cs:[di],al		;Write character to memory.
	inc	di
	xchg	cs:red_pointer,di
	jmp	prc_done

printc	ENDP
;
;-------------------------------------------------------------
; Display the asciiz string at CS:DX.
;
; On exit: all regs unchanged.
;
pr_text PROC NEAR
	push	ax
	push	si
	mov	si,dx

prx_lp: mov	al,cs:[si]
	inc	si
	cmp	al,0
	jz	prx_done
	call	printc
	jmp	prx_lp

prx_done:
	pop	si
	pop	ax
	ret
pr_text ENDP
;
;----------------------------------------------------------
crout	PROC NEAR
	push	ax
	mov	al,cr
	call	printc
	mov	al,lf
	call	printc
	pop	ax
	ret
crout	ENDP
;
;--------------------------------------------------------------------
;  GET ONE KEY.
;
; On exit: CF=true for ESC, Ctrl-C, Ctrl-Brk.  Otherwise CF=false.
;
getkey	PROC NEAR
	mov	ah,0		;Get one key, wait if none ready.
	int	16h
	cmp	ax,011Bh	;Esc key?
	je	getk_brk
	cmp	al,3		;Ctrl-C ?
	je	getk_brk
	or	ax,ax		;Ctrl-Break ?
	jnz	getk_exit	;No, CF=false.
getk_brk:
	mov	ah,1
	int	16h		;Flush.
	jz	getk_brk2
	mov	ah,0
	int	16h
	jmp	getk_brk
getk_brk2:
	xor	ax,ax
	stc
	jmp	short getk_exit
getk_exit:
	ret
getkey	ENDP
;
;------------------------------------------------------------------------
; Flush the keyboard buffer.
; Ctrl-S causes a pause until a different key is pressed.
;
; On exit: If ESC, Ctrl-C or Break pressed, then CF=true.
;
;
flushkey PROC NEAR	;If Break/Esc/Ctrl-C then CF=true, else CF=false.
	push	ax	;Only flags are changed.
	push	bx
	xor	bx,bx
flush_lp:
	mov	ah,1
	int	16h
	jz	flush_exit	;No keys in the buffer.
flush2: call	getkey
	lahf			;Save flags into AH.
	or	bl,ah		;Accumulate CF image.
	cmp	al,13h		;Ctrl-S ?
	je	flush_s
	cmp	al,10h		;Ctrl-P ?
	je	flush_p
	cmp	ax,7200h	;Ctrl-PrtSc ?
	je	flush_p
	jmp	flush_lp	;Repeat until empty.
flush_s:
	mov	ah,1		;Wait for another key.
	int	16h
	jz	flush_s
	cmp	al,13h		;Another Ctrl-S ?
	jne	flush2		;No.
	mov	ah,0		;Eat it.
	int	16h
	jmp	flush_s 	;Wait for a different key.
flush_p:
	test	cs:print_flags, pf_allowed	;Printout option enabled?
	jz	flush_lp			;No - ignore it.
	xor	cs:print_flags, pf_con_pe	;Toggle state.
	jmp	flush_lp
flush_exit:
	mov	ah,bl
	sahf			;Return CF according to results.
	pop	bx
	pop	ax
	ret
flushkey ENDP
;
;------------------------------------------------------------------------
;  Get a line from the console.
;
; Characters accepted are echoed onto the screen via PRINTC.
; Special keys: backspace key works;
; Ctrl-Brk, ^C or ESC will return CF=true.  ^P toggles printing (if enabled).
;
; On entry: nothing.
;
; On exit: SI points at 1st character of line,
;	  line_length (excluding CR) is at byte ptr [SI-1] and in AH reg,
;	  and AL=1st character (in uppercase, 0 if empty).
;	  ZF=true for empty buffer, unless carry is set by ESC or Ctrl-Break.
;
; Only AX and SI are modified.
;
getline PROC NEAR
	push	bx
	lea	si,getline_buffer
	xor	bx,bx
getl_top:
	call	getkey
	jnc	getl_not_break	;Break or ESC?
getl_break:
	xor	bx,bx		;Esc/Ctrl-Break returns with empty buffer.
	mov	[si-1],bx
	push	dx
	lea	dx,msg_break	;"^c",13,10
	call	pr_text
	pop	dx
	stc
	jmp	short getl_exit
getl_p: test	print_flags, pf_allowed ;Printing allowed?
	jz	getl_beep		;No.
	xor	print_flags, pf_con_pe
	jmp	getl_top
getl_not_break:
	cmp	al,10h		;Ctrl-P ?
	je	getl_p
	cmp	ax,7200h	;Ctrl-PrtSc ?
	je	getl_p
	or	al,al
	jnz	getl3		;If not valid ASCII, beep and discard it.
getl_beep:
	mov	al,7		;'Bell' char.
	call	printc
	call	flushkey
	jc	getl_break
	jmp	getl_top	;Try again.
getl3:	cmp	ax,1C0Dh	;Enter key?
	je	getl_cr
	cmp	ah,0Eh		;Backspace key?
	je	getl_bs
	cmp	al," "
	jl	getl_beep	;Reject other control chars and any AL > 127.
	cmp	bx,18		;Buffer nearly full?
	jae	getl_beep
	mov	[bx+si],al	;Put the character into the buffer.
	inc	bx		;Increment line length counter.
	call	printc		;Echo the typed key onto the screen.
	cmp	bx,1		;1st char entered?
	jne	no_cleol
	push	dx
	lea	dx,msg_cleol	;Just 5 blanks, not really to end-of-line.
	call	pr_text
	pop	dx
no_cleol:
	jmp	getl_top	;Get another char.
getl_bs:
	or	bx,bx		;Is buffer already empty?
	jz	getl_top	;Buffer is empty, ignore Backspace key.
	dec	bx
	mov	al,8		;Back up the cursor.
	call	printc
	mov	al," "
	call	printc		;Blank the deleted character on the screen.
	mov	al,8		;Back up again.
	call	printc
	jmp	getl_top
getl_cr:
	call	crout
	mov	[bx+si],bh	;Put 0 into buffer without incr BX.
	mov	[si-1],bl	;Store line length.
	mov	ah,bl
	mov	al,[si]
	call	uppercase
	or	ah,ah		;Set/clear ZF, always clear CF.
getl_exit:
	pop	bx
	ret
getline ENDP
;
msg_cleol DB	"     ",8,8,8,8,8,0	;5 blanks, 5 backspaces.
msg_break DB	"^c",13,10,0
	DB	0
getline_buffer DB "  GETLINE BUFFER   ",0
;
;----------------------------------------------------------------------
uppercase PROC NEAR
	cmp	al,"a"
	jb	uc
	cmp	al,"z"
	ja	uc
	sub	al,20h
uc:	ret
uppercase ENDP
;
;------------------------------------------------------------------
; Scan a string, skipping over blanks to the next non-blank char.
;
; On entry: DS:SI points to the string to be scanned.
; On exit: SI points at 1st nonblank char found,
;	   AL=[SI] (converted to uppercase).
;	   If AL contains a contrl char, then CF=true.
;
; AL is always altered, SI is usually altered.
;
skipb	PROC NEAR
	mov	al,[si]
	call	uppercase
	cmp	al," "
	jne	skipb_done
	inc	si
	jmp	skipb
skipb_done:
	ret
skipb	ENDP
;
;------------------------------------------------------------------
; This routine displays a hexadecimal string from AX.
; Exactly four digits are always printed.  'PRINTC' is called.
; on entry: AX=value to be converted.
; on exit: all regs preserved.
;
pr_hex_word PROC NEAR
	xchg	ah,al
	call	pr_hex_byte
	xchg	al,ah
	call	pr_hex_byte
	ret
pr_hex_word ENDP
;
;------------------------------------------------------------------
; This routine displays a hexadecimal string from AL.
; Exactly two digits are always displayed.  'PRINTC' is called.
; on entry: AL=value to be converted.
; on exit: all regs preserved.
;
pr_hex_byte PROC NEAR
	push	cx
	mov	cx,0204h	;CH=digit count, CL=shift count.
	push	ax
prhxb:	pop	ax
	rol	al,cl		;Bring high nibble into lower half of AL.
	push	ax		;Save rotated version.
	and	al,0Fh		;Leave only lowest 4 bits.
	cmp	al,9		;If 9 or less, it's easy.
	jbe	prhxb_ok9
	add	al,7		;Otherwise we must add 7 to make it A-F
prhxb_ok9:
	add	al,30h		;ASCII offset.
	call	printc		;Display the character in AL.
	dec	ch
	jnz	prhxb
	pop	ax		;After 8 rotations AL is restored.
	pop	cx
	ret
pr_hex_byte ENDP
;
;-------------------------------------------------------------
;  PRINT A DECIMAL NUMBER
; This converts the binary value in AX to a decimal string.
; The string will be at least one digit, with leading zeros supressed.
; The string is built on the stack.  The routine 'PRINTC' is called.
; 'PRINTC' must display the char in AL and preserve all registers.
; On entry: AX=value to be converted.  On exit: all regs preserved.
;
pr_dec	PROC NEAR
	push	ax
	push	bx
	push	dx
	push	di
	push	bp
	sub	sp,8	;Eight bytes.
	mov	bp,sp
	mov	di,6
	mov	byte ptr [bp+di],0	;String terminator.
	mov	bx,000Ah		;we're going to be dividing by ten.
ddigit: xor	dx,dx
	div	bx		;Remainder = the rightmost digit.
	xchg	al,dl
	add	al,30h		;Convert to ASCII numeric char.
	dec	di
	mov	[bp+di],al	;Store the character.
	mov	al,dl		;Restore AX to be the quotient.
	or	ax,ax
	jnz	ddigit		;If quotient is not yet zero, then repeat.
ddlp:	mov	al,[bp+di]
	inc	di
	cmp	al,0
	jz	dd_done
	call	printc
	jmp	ddlp
dd_done:
	add	sp,8		;Discard stack frame.
	pop	bp
	pop	di
	pop	dx
	pop	bx
	pop	ax
	ret
pr_dec	ENDP
;
;--------------------------------------------------------------------
; Display a 32-bit number as a right-justified,
; nine-character decimal string.
;
; On entry: DX,AX = number (DX = high part).  Max value = 655 million.
;
; On exit: all regs preserved.
;
pr_decl PROC NEAR
	push	ax
	push	bx
	push	cx
	push	dx
	mov	cx,10000
	cmp	dx,cx
	jb	prdl_ok
	mov	ax,999
	call	pr_dec		;Display 999999999 (nine of 'em).
	call	pr_dec
	jmp	short prdl_3
prdl_ok:
	div	cx		;Would overflow if nmbr > 655 Million.
	or	ax,ax		;AX = quotient, DX = remainder (<10,000).
	jnz	prdl_big
	mov	bl," "
	call	prefix_dec
	jmp	short prdl_lo
prdl_big:
	mov	bl," "
	call	prefix_dec
	call	pr_dec		;Print the high part.
	mov	bl,"0"
prdl_lo:
	mov	ax,dx		;Get low part.
	call	prefix_dec
prdl_3: call	pr_dec
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
pr_decl ENDP
;
;------------------------------------------------------------
; Generate enough leading characters to keep
; a decimal number string right-justified.
;
; On entry: BL="0" and AX<10000 for a field width of 4.
;	    BL=" " and AX=anything for a field width of 5.
;
; All regs perserved.
;
prefix_dec PROC NEAR
	push	ax
	push	cx
	xor	cx,cx
	cmp	bl," "
	jne	pref_2
	cmp	ax,10000	;Number might be as large as 65535.
	adc	cl,ch
pref_2: cmp	ax,1000 	;CF=true if AX is below 1000.
	adc	cl,ch		;CH=0.
	cmp	ax,100
	adc	cl,ch
	cmp	ax,10
	adc	cl,ch		;CX = # of leading zeros needed.
	jcxz	pref_end
	mov	al,bl
pref_lp:
	call	printc
	loop	pref_lp
pref_end:
	pop	cx
	pop	ax
	ret
prefix_dec ENDP
;
;------------------------------------------------------------------
;  DISPLAY A COMPLEX MESSAGE.
;
; On entry: [DX]= ASCIIZ message text (ends with a 00h byte).
; On exit: all regs preserved.
;
; Some special command 'macros' are allowed inside the text:
;   @vf
; where v selects the source variable and f selects the format.
;
; Possible values for 'v' are:
;
; 0		value is taken from the input AX register.
; 1 thru 9	takes value from DIS_WORD + (2*number).
;
; Supported 'f' format selectors (must be lower case) are marked * below:
;
; *	b	2 hexadecimal digits from low Byte of variable.
; *	w	4 hex digits from Word.
; *	a	Ascii character from low byte (except byte=0 is discarded).
; *	d	Decimal (word, 1 to 5 columns).
; *	r	Right-justified decimal word (5 columns, leading blanks).
; *	l	right-justified Long (dword) decimal (9 columns).
;M005  delete "s" option
; *	s	pluralize.  I.e., output an 's', unless variable=1.
; *	t	pointer to asciiz Text string (no macros).
;
; To display an @-sign, use "@@".  Bad or unsupported 'macros'
; will appear verbatim in the line, so everyone can see the mistake.
;
; Special cases: @0l takes low word from AX, high word from var #1.
;		 @9l will not work right.
;
; Example:	"There were @1d file@1s found on drive @2a:",cr,lf,0
;
; Assuming that variable #1 contains 7, and var #2 contains "B" (XX42h),
; the displayed message will look like this:
;
;		There were 7 files found on drive B:
;
;
	EVEN
dis_word LABEL word
	DW	0		;Input AX is saved here.
	DW	9 DUP (0)	;Other input variables.
;
; Caution!  Do not attempt to store into DIS_WORD+20 !
;
display PROC NEAR
	push	ax
	push	bx
	push	si
	mov	dis_word,ax		;Save input AX into item #0.
	mov	si,dx
dsp_lp: mov	al,[si]
	inc	si
	cmp	al,"@"
	je	dsp_special
	cmp	al,0
	je	dsp_done
dsp_1:	call	printc
dsp_more:
	jmp	dsp_lp
dsp_done:
	pop	si
	pop	bx
	pop	ax
	ret
dsp_special:
	mov	ah,[si] 	;Fetch char after the "@".
	or	ah,ah
	jz	dsp_1		;Print "@", let the 0 end this proc.
	inc	si
	cmp	ah,al		;Double @-sign?
	je	dsp_1		;Just display the desired single "@".
	mov	al,[si] 	;Fetch 2nd char after "@".
	cmp	al,0
	jz	dsp_err 	;Show error and let 0 end.
	inc	si
	mov	bl,ah		;Now BL holds 1st char after "@".
	mov	bh,0
	sub	bl,"0"
	jb	dsp_err
	cmp	bl,9
	ja	dsp_err
	shl	bx,1
	mov	bx, dis_word [bx]
dsp_fmt:
	cmp	al,"b"
	je	dsp_byte
	cmp	al,"w"
	je	dsp_word
	cmp	al,"a"
	je	dsp_ascii
;M005	cmp	al,"s"
;M005	je	dsp_plural
	cmp	al,"t"
	je	dsp_text
	cmp	al,"d"
	je	dsp_decimal
	cmp	al,"r"
	je	dsp_decimal_rj
	cmp	al,"l"
	je	dsp_long
dsp_err:
	push	ax		;Save the bad character(s) of the macro.
	mov	al,"@"
	call	printc		;Display the usually invisible "@".
	pop	ax
	xchg	al,ah		;Show first character after the "@".
	call	printc
	xchg	ah,al
	jmp	dsp_1		;Display 2nd char and continue.
;
dsp_byte:
	xchg	ax,bx		;Use XCHG, not MOV, to save space.
	call	pr_hex_byte
	jmp	dsp_more
;
dsp_word:
	xchg	ax,bx
	call	pr_hex_word
	jmp	dsp_more
;
dsp_ascii:
	xchg	ax,bx
	cmp	al,0
	jz	dsp_more_stp	;Ignore null bytes.
	call	printc
dsp_more_stp:
	jmp	dsp_more
;
;M005dsp_plural:
;M005	cmp	bx,1		;Exactly one?
;M005	je	dsp_more_stp	;If so, it's singular.  Do nothing.
;M005	mov	al,"s"
;M005	jmp	dsp_1
;
dsp_text:
	push	dx
	lea	dx,[bx]
	inc	bx
	cmp	bx,2		;Pointer is FFFFh or 0?
	jb	dsp_text0	;Impossible value.  Print nothing.
	call	pr_text
dsp_text0:
	pop	dx
	jmp	dsp_more_stp
;
dsp_decimal:
	xchg	ax,bx
	call	pr_dec
	jmp	dsp_more_stp
;
dsp_decimal_rj:
	xchg	ax,bx
	mov	bl," "
	call	prefix_dec
	call	pr_dec
	jmp	dsp_more_stp
;
dsp_long:
	push	dx
	mov	al,ah
	mov	ah,0
	sub	al,"0"
	shl	ax,1
	xchg	ax,bx
	mov	dx,dis_word [bx+2]	;Must fetch the second word.
	call	pr_decl
	pop	dx
	jmp	dsp_more_stp
display ENDP
;
;--------------------------------------------------------------------
; On entry: nothing.
; On exit: If user types in "YES" or "yes", then ZF=true, else ZF=false.
;	   SI always returns address of getline buffer.
;
; Only SI is changed.
;
ask_for_yes PROC NEAR
	push	ax
	push	cx
	push	dx
	push	es
	push	di
	lea	dx,msg_sure	;"Are you SURE?  Type in YES."
	call	pr_text
	call	flushkey
	jc	askfy_esc
	call	getline
	jc	askfy_esc
	push	cs
	pop	es		;Make darn sure ES=CS.
	cld
	lea	di,text_yes
	mov	cx,text_yes_length
askfy_cmp:
	lodsb
	call	uppercase	;Accept either upper or lowercase.
	scasb
	loope	askfy_cmp
	clc
askfy_done:
	lea	si,getline_buffer
	pop	es
	pop	di
	pop	dx
	pop	cx
	pop	ax
	ret
askfy_esc:
	or	al,-1
	stc
	jmp	askfy_done
ask_for_yes ENDP
;
;----------------------------------------------------------------
; Ask user "Delete (or Truncate) this one (or All)?"
; The initials of the first one or two words entered
; will be examined.  First word: only "D" or "T" are allowed.
; Second word (if present) must begin with "A".  If improper
; text (or null) is entered, the user will be prompted again.
; Correct examples:
;	delete
;	d
;	truncate
;	delete all
;	d a
;	TRUNCATE ALL
;	 txxx	  ayyy
;
; ** Note: the "D", "T" and "A" above can all be translated now.
;
; On entry: nothing.
;
; On exit: AL will contain (never translated)
;	"D" = delete this one file, ask again for next.
;	"d" = delete all such files, don't ask again.
;	"T" = truncate (shorten) this file, ask again.
;	"t" = truncate all such files, don't ask again.
;	But if ESC or ctrl-C are pressed, CF=true and AX=?
;
; The intent is that our variable FRAG_OPT should initially be "?".
; The above chioce of values allows quick tests elsewhere:
; Ascii value < "d" means we must ask the question.
;
; Only AX is changed.
;
ask_trunc PROC NEAR
	push	bx
	push	dx
	push	si
askt_1: lea	dx,msg_ask_trunc	;External.
	call	pr_text
	call	getline
	jc	askt_exit
	jz	askt_1		;Null line is not allowed.  Ask again.
	call	skipb		;Returns 1st nonblank in AL (uppercase).
	jc	askt_1		;Found only final 0 - ask again.
	mov	bl,"D"
	cmp	al,delete_char
	je	askt_next_wd
	mov	bl,"T"
	cmp	al,truncate_char
	je	askt_next_wd
	jmp	askt_1
askt_next_wd:			;Find the 2nd text word (if any).
	inc	si
	mov	al,[si]
	cmp	al," "
	jb	askt_done	;No more.
	jne	askt_next_wd	;It's not a blank.  Get next char.
	call	skipb		;Skip blanks to next word.
	jc	askt_done
	call	uppercase
	cmp	al,all_char	;"A" for 'all'?
	jne	askt_1		;Invalid, ask again.
	add	bl,20h		;Convert to lowercase (do it for ALL files).
askt_done:
	mov	al,bl
	clc
askt_exit:
	pop	si
	pop	dx
	pop	bx
	ret
ask_trunc ENDP
;
;----------------------------------------------------------
; Display (screen only) the percentage scanned.
; Destroys AX,BX,DX.
;
show_progress PROC NEAR
	mov	ax,hsub_count
	mov	dis_word+(2*1),ax
	mov	ax,100
	mul	cluster_index
	mov	bx,cluster_cnt_plus_1
	dec	bx
	div	bx		;AX = 100 * index / total.
	cmp	ax,progress	;Any change in the percentage completed?
	jbe	no_progress	;No change.  Don't display.
	mov	progress,ax
	mov	dl,pf_ptime
	not	dl
	and	print_flags, dl ;Make sure this doesn't go to LPT1.

;	M005 -- made the following use two separate messages for
;	        singular/plural

	lea	dx,msg_progress_sing ;"@0d% searched, @1d subdir found.",cr
	cmp	hsub_count,1
	jz	show_prog_sing
	lea	dx,msg_progress_plural ; same message, but plural subdirs
show_prog_sing:

;	M005 -- end changes

	call	display
	or	print_flags, pf_ptime
no_progress:
	ret
show_progress ENDP
;
;----------------------------------------------------------------------
; Display info from a directory entry: Name, Size, Date, Time.
; FILENAME.EXT 123456789 mm-dd-yy HH:MMpm   (+ two blanks, no CRLF).
; VOLUME_N.AME	<VOL>	 mm-dd-yy HH:MMam
;
; On entry: ES:DI points to a directory entry.
; On exit: all regs preserved.
;
show_dir_info PROC NEAR
	push	ax
	push	bx
	push	cx
	push	dx
	lea	bx,curr_fname
	call	copy_fname	;From ES:DI to CS:BX.
	lea	dx,[bx]
	call	pr_text
	mov	al,13
	call	tab
	mov	al, es:[di].file_attr
	test	al, dir_attr OR vol_attr
	jz	shdi_size
	lea	dx,msg_dir	;"<DIR>" instead of size.
	test	al, vol_attr
	jz	shdi_attr
	lea	dx,msg_vol	;"<VOL>".
shdi_attr:
	call	pr_text
	jmp	short shdi_date
shdi_size:
	mov	ax,es:[di].file_size
	mov	dx,es:[di].file_size+2
	call	pr_decl
shdi_date:
	mov	al," "
	call	printc
	mov	ax,es:[di].date 	;Date into AX.
	call	show_date
	mov	al," "
	call	printc
	mov	ax,es:[di].time 	;Time into AX.
	call	show_time
	mov	al," "
	call	printc
	call	printc
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
show_dir_info ENDP
;
;------------------------------------------------------------
; Display a date & time like this (US format): "mm-dd-yy"
; Exactly eight characters are output.
;
; On entry: AX = date (in DOS dir format).
;
; Destroys AX,BX,CX,DX.
;
show_date PROC NEAR
	mov	dx,ax		;Date into DX (sub-procs expect it there).
	mov	bh,date_separator
	mov	ax,date_control
	cmp	ax,1
	je	shdate_europe
	cmp	ax,2
	je	shdate_japan
	mov	bl," "
	call	show_month	;US format.
	mov	al,bh
	call	printc
	mov	bl,"0"
	call	show_day
	mov	al,bh
	call	printc
	call	show_year
	jmp	short shdate_end
shdate_europe:
	mov	bl," "
	call	show_day
	mov	al,bh
	call	printc
	mov	bl,"0"
	call	show_month
	mov	al,bh
	call	printc
	call	show_year
	jmp	short shdate_end
shdate_japan:
	call	show_year
	mov	al,bh
	call	printc
	mov	bl,"0"
	call	show_month
	mov	al,bh
	call	printc
	call	show_day
shdate_end:
	ret
show_date ENDP
;
;------------------------------
show_month PROC NEAR		;Input: DX=date, BL=prefix.
	mov	ax,dx
	and	ax,0000000111100000B	;Extract the month.
	mov	cl,5
	shr	ax,cl
	call	pr_dec2
	ret
show_month ENDP
;
;------------------------------
show_day PROC NEAR
	mov	ax,dx
	and	ax,0011111B		;Day.
	call	pr_dec2
	ret
show_day ENDP
;
;------------------------------
show_year PROC NEAR
	mov	ax,dx
	mov	cl,9
	shr	ax,cl			;AX= 0-199 (for 1980-2099).
	add	ax,80
	cmp	ax,100			;Beyond 1999?
	jb	sh_yr2
	sub	ax,100			;For year 2000-2099, show 00-99.
sh_yr2: mov	bl,"0"
	call	pr_dec2 		;Year.
	ret
show_year ENDP
;
;----------------------------------------------------
; Display time like this (US format):	"HH:MMam"
; In 24-hour format it looks like this: " HH:MM "
; Exactly seven characters are output.
;
; On entry: AX = time (in DOS 16-bit format).
;
; Destroys AX,BX,CX,DX.
;
show_time PROC NEAR
	mov	dx,ax			;Save time into DX.
	mov	cl,11
	mov	ax,dx
	shr	ax,cl			;Extract hours.
	mov	ch," "			;Assume 24-hr format.
	test	time_in_24hr,1
	jz	shtime12		;12-hour format.
	xchg	bx,ax			;Save AX.
	mov	al," "
	call	printc			;One leading blank in 24-hour format.
	xchg	ax,bx			;Recover AX.
	jmp	short shtime_hrs2	;Leave it in 24-hour format.
shtime12:
	mov	ch,"a"			;Assume AM.
	or	ax,ax
	jnz	shtime_hrs
	mov	al,12			;0 = midnight = 12am.
	jmp	short shtime_hrs2
shtime_hrs:
	cmp	al,12
	jb	shtime_hrs2
	mov	ch,"p"			;PM.
	je	shtime_hrs2		;Exactly 12pm.
	sub	al,12			;Adjust for 1pm to 11pm.
shtime_hrs2:
	mov	bl," "
	call	pr_dec2
	mov	al,time_separator
	call	printc
	mov	ax,dx
	and	ax,0000011111100000B	;Extract minutes.
	mov	cl,5
	shr	ax,cl
	mov	bl,"0"
	call	pr_dec2
	mov	al,ch			;" " or "a" or "p".
	call	printc
	cmp	al," "			;In 24-hour format?
	je	shtime_end		;Yes.
	mov	al,"m"			;Add an M after the A or P.
	call	printc
shtime_end:
	ret
show_time ENDP
;
;----------------------------------------------------------------
; Display a decimal number.  If # digits < 2, then prefix the
; number with one character taken from BL (usually "0" or " ").
; This right-justifies numbers less than 100.
;
; On entry: AX=number, BL=char to prefix.
;
; On exit: All regs preserved.
;
pr_dec2 PROC NEAR
	cmp	ax,10
	jae	prd2
	xchg	ax,bx
	call	printc	;Prefix a "0" or " " to a single digit number.
	xchg	bx,ax
prd2:	call	pr_dec
	ret
pr_dec2 ENDP
;
;---------------------------------------------------------------
; Display the options (if any).  /ER /EF /KR /KF /TEST
; AX,DX destroyed.
;
display_options PROC NEAR
	mov	ax,options
	test	options, opt_wrfake + opt_k + opt_erase_fat + opt_erase_root
	jz	disp99
	call	crout
	test	ax,opt_wrfake
	jz	disp_keep
	lea	dx,msg_write_fake
	call	pr_text
disp_keep:
	test	ax,opt_keep_fat OR opt_keep_root
	jz	disp_erase
	lea	dx,msg_fat_prot
	test	ax,opt_keep_fat
	jnz	dispk2
	lea	dx,msg_root_prot
dispk2: call	pr_text
disp_erase:
	test	ax,opt_erase_root OR opt_erase_fat
	jz	disp99
	lea	dx,msg_erase_fat
	test	ax,opt_erase_fat
	jnz	dispe2
	lea	dx,msg_erase_root
dispe2: call	pr_text
disp99: ret
display_options ENDP
;
;--------------------------------------------------------------------------
; EVALUATE THE COMMAND LINE FOR PARMS & OPTIONS.
;
; On entry: [SI]=text line.
; On exit: if all OK then CF=false and variables are updated.
;	   If error then messages are displayed and CF=true.
;
; AX,BX,CX,DX,SI,DI destroyed.
;
look_for_parms PROC NEAR
	lea	dx,[si] 	;Save ptr to line.
lookfp_lp:
	mov	al,[si]
	inc	si
	cmp	al," "
	jb	lookfp_end	;Quit at first control char.
	cmp	al,"/"		;A parm must begin with a slash.
	jne	lookfp_lp
	dec	si		;Point at the slash.
	lea	bx,option_table
	call	parse_item	;Returns AX,BX,SI changed.
	jc	lookfp_err
	mov	di,[bx].optdef_var_ptr
	cmp	di,1		;Valid offset?
	jle	lookfp_err
	test	byte ptr [bx].optdef_action, action_switch
	jnz	lookfp_sw	;Switch, not numeric parm.
	xchg	ax,[di]
	or	ax,ax
	jz	lookfp_lp	;Was not previously defined.  Get more.
	jmp	short lookfp_err
lookfp_sw:
	test	[di],ax 	;Was that bit already set?
	jnz	lookfp_err	;Yes - duplicate parm!
	or	[di],ax
	jmp	lookfp_lp	;Get more.
lookfp_err:
	call	crout
	call	pr_text 	;Echo the entire parm line.
	call	crout
	mov	cx,si
	sub	cx,dx		;How far into the line was the error?
	jbe	lookfp_arrow
lookfp_blnk:
	mov	al," "
	call	printc
	loop	lookfp_blnk
lookfp_arrow:
	lea	dx,msg_arrow	;"^ Error",cr,lf.
	call	pr_text
	stc
	jmp	short lookfp_exit
lookfp_end:
	clc
lookfp_exit:
	ret
look_for_parms ENDP
;
;--------------------------------------------------------------------
; Check a slash parm item against a table of possible parameters.
;
; On entry: [SI]=item to be examined,
;	    [BX]=table of opt_def's (see STRUC definition).
;
;   Parms can take the following forms:
;	Text		examples:  /auto    /V	 /1  /80
;
; On exit:
;  If it's good then CF=false and SI is advanced just past the item.
;  BX will point at the matching table entry.  AX=parm value.
;
;  But if CF=true then item was bad and SI will point to
;  the offending item.	AX and BX are undefined.
;
;  Registers: only AX, BX, SI and flags are changed.
;
parse_item PROC NEAR
	push	cx
	push	dx
	push	di
	push	bp
	mov	bp,si			;Save address of input item.
p_hunt: cmp	byte ptr [bx].optdef_action, 0
	jz	p_err			;End of list - no match.
	lea	di,[bx].optdef_text	;Point DI to text in table.
	mov	cl,[bx].optdef_length
	mov	ch,0
	jcxz	p_fail
p_huntlp:
	mov	al,[si] 		;Fetch char from input line.
	inc	si
	call	uppercase
	cmp	al,[di] 		;Compare against table.
	lea	di,[di+1]
	loope	p_huntlp		;Still equal?  Continue checking.
	je	p_match
p_fail: lea	bx,[bx].optdef_text+max_optdef_text
	mov	si,bp			;Reset SI to the input item.
	jmp	p_hunt			;Try the next table entry.
p_match:
	mov	bp,si			;Save ptr to just past the text.
	mov	al,[bx].optdef_action
;	test	al,action_dec		;Numeric parm needed?
;	jnz	pnum			;Yes.
	test	al,action_switch
	jz	p_err			;No action!?  Illegal.
	mov	ax,[bx].optdef_mask	;Switch returns a bit mask in AX.
	jmp	short got_value
p_err:	jmp	short p_error
;pnum:	mov	dx,ax			;Save 'action' into DL.
;	call	rd_dec
;	jc	p_err
;	test	dl,action_k
;	jz	got_value		;Is trailing K allowed?
;	mov	dx,ax			;Save decimal value into DX.
;	mov	al,[si]
;	call	uppercase
;	xchg	ax,dx			;Decimal value into AX, char into DL.
;	cmp	dl,"K"			;Is next char a "K"?
;	jne	got_value
;	inc	si			;Accept & skip over the K.
got_value:
	mov	dx,ax		;Save value.
	mov	al,[si] 	;Examine the next character.
	cmp	al," "
	jbe	p_done		;We expect some kind of delimiter.
	cmp	al,","
	je	p_done
	cmp	al,"/"
	je	p_done
p_error:
	mov	si,bp		;Return ptr to offending item.
	stc
	jmp	short p_exit
p_done: mov	ax,dx		;Result into AX.
	clc
p_exit: pop	bp
	pop	di
	pop	dx
	pop	cx
	ret
parse_item ENDP
;
;--------------------------------------------------------------
; Copy a file/subdir name from a directory
; entry, making an ASCIIZ string.  "NAME.EXT",0
;
; On entry: ES:DI point at the directory entry,
;	    CS:BX point at the target memory area (13 bytes).
;
; On exit: CS:AX points at the 0 byte following the name.
;	   Only AX is changed.
;
copy_fname PROC NEAR
	push	bx
	push	cx
	push	si
	push	di
	push	ds
	push	es
;
	push	es
	pop	ds
	push	cs
	pop	es		;DS=yonder, ES=CS.
	cld
	xchg	bx,di
	lea	si,[bx] 	;[SI]=[BX]=dir entry, ES:DI=target memory.
	test	byte ptr [bx].file_attr, vol_attr
	jz	copyf0
	mov	cx,11		;For vol label, copy all 11 chars exactly.
	rep movsb
	jmp	short copyf4
copyf0: mov	cx,8		;8 chars max in name.
copyf1: lodsb
	cmp	al," "
	je	copyf2
	stosb
	loop	copyf1
copyf2: lea	si,[bx+8]
	cmp	byte ptr [si]," "
	je	copyf4		;No file extension.
	mov	al,"."
	stosb
	mov	cl,3		;3 chars max in extension.
copyf3: lodsb
	cmp	al," "
	je	copyf4
	stosb
	loop	copyf3
copyf4: mov	al,0		;End ASCIIZ string.
	stosb
	lea	ax,[di-1]
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	cx
	pop	bx
	ret
copy_fname ENDP
;
;--------------------------------------------
prog	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\rebuild\uf_jmsg.asm ===
; Copyright 1990 Central Point Software, Inc.
; All rights reserved.
;-----------------------------------------------------------------------------
; Modified April 19, 1988.  Removed dumb 'stand_alone' stuff.  GWD.
; Modified main warning msg to recommend DISKFIX.  6.0 BETA 02-14-90  GWD.
; Tiny changes for easier translation.  v6 03-05-90  GWD.
;
; These are the messages for Jim's half of REBUILD.COM
; They are now in the form of an INCLUDE-file (not public/externals).
;
; All of the messages in Jim's stuff are displayed using DOS fct #9.
; The dollar signs ($) mark the end of strings.
;
;       M000    MD      9/23/90         Cleaned up signon message
;       M001    MD     10/14/90         More message cleanup 
;
;-----------------------------------------------------------------------------
; These symbols define the single character responses to the questions.
; Make sure these match the text of the prompts.
;
yes_char	EQU	"Y"	;Answer is Yes.
no_char		EQU	"N"	;Answer is No.
prior_char	EQU	"P"	;Answer is use the Prior file.
last_char	EQU	"L"	;Answer is use the Last (later) file.
;
abort_char	EQU	"A"	;Answer is Abort after the error.
retry_char	EQU	"R"	;Answer is Retry (try the operation again).
ignore_char	EQU	"I"	;Answer is Ignore the error.
;
;-----------------------------------------------------------------------------
; These messages can be generated by typing the command REBUILD and pressing
; enter.  Since no drive was specified the command is aborted.
;
;

REBUILD_MAIN_MSG LABEL byte

;	DB    "Unauthorized duplication prohibited."    M000
;	DB    13,10                                     M000

  		DB  13,10,"Restores the system area of your disk by using the image file created"
; The text in this line cannot exceed 80 chars in length

		  DB  13,10,"by the MIRROR command.",13,10
; The text in this line cannot exceed 80 chars in length


  DB	13,10
  DB	"    WARNING !!        WARNING !!"
  DB	13,10
  DB	13,10
  DB	"This command should be used only to recover from the inadvertent use of"
  DB	13,10
  DB	"the FORMAT command or the RECOVER command.  Any other use of the UNFORMAT"
  DB	13,10
  DB	"command may cause you to lose data!  Files modified since the MIRROR image"
  DB	13,10
  DB	"file was created may be lost."
  db	13,10,13,10				; M003
  db	"Searching disk for MIRROR image."	; M003
;;   Every one of the above lines must be less than 80 characters long.

;M001 - some text deleted above

	COMMENT @
;  **  All the following lines are ignored, up to the next 'At-sign'.
		  DB  13,10,'  WARNING !!'
		  DB  13,10,'REBUILD SHOULD ONLY BE USED TO RECOVER FROM THE'
		  DB  13,10,'INADVERTENT USE OF THE DOS FORMAT COMMAND OR'
		  DB  13,10,'THE DOS RECOVER COMMAND. ANY OTHER USE OF REBUILD'
		  DB  13,10,'MAY CAUSE YOU TO LOSE DATA! ANY MODIFICATIONS'
		  DB  13,10,'MADE SINCE THE LAST USE OF MIRROR MAY BE LOST.'
	COMMENT @ END



		  DB  13,10,"$"
; This line cannot be changed



PROBLEMS  DB   13,10,"UNFORMAT aborted."
; The text in this line cannot exceed 80 chars in length

LINE_DOWN DB   13,10,"$"

;-----------------------------------------------------------------------------
; This messages can be generated by inserting a DOS formatted diskette that
; was not used with MIRROR.  Type REBUILD A: and press enter. Takes about
; 45 seconds.


NO_FILE  DB    13,10,"MIRROR image file not found.",13,10,"$"
; The text in this line cannot exceed 80 chars in length

;------------------------------------------------------------------------------
; This message is generated if you are using a version of DOS less than 2.0


BAD_VERSION DB 13,10,"Need DOS version 2.x or higher",13,10,"$"
; The text in this line cannot exceed 80 chars

;------------------------------------------------------------------------------
; This message is generated if IBM PC-NET is installed and you try to run the
; REBUILD program.

; This message is no longer needed.  Glen's module checks it & reports.  v5.5
;* NETWORK_INSTALLED DB 13,10,'Network installed. UNFORMAT must'
; The text in this line cannot exceed 80 chars
;
; *		  DB 13,10,'be run without the network.',13,10,7,'$'
; The text in this line cannot exceed 80 chars

;------------------------------------------------------------------------------
; If you install Mirror on a drive that does not exist, this message will be
; generated.

DRIVE_MSG DB 13,10,"Drive "
drive_msg_patch	DB "x ","$"


DRIVE_SPEC_ERROR DB "could not be processed.",13,10,"$"
; This text in this message cannot exceed 71 chars in length
;

;------------------------------------------------------------------------------
; If you insert a diskette with a bad sector into the A: drive and run the
; REBUILD A: program, this message will be generated.


BAD_SECTOR_MSG DB 13,10,"Bad sector being bypassed.",13,10,"$"
; The text in this message cannot exceed 80 chars in length

;------------------------------------------------------------------------------
; This message can be issued by editing the mirror file MIRORSAV.FIL and
; adding bad information.


BAD_FILE DB    13,10,"The MIRROR image file found has inconsistent"
; The text in this message cannot exceed 80 chars

	 DB    13,10,"information. It cannot be used.",13,10,"$"
; The text in this message cannot exceed 80 chars

;------------------------------------------------------------------------------
; If you terminate the REBUILD process this message will be generated.


USER_CANCELLED DB 13,10,"Cancelled by user.",13,10,"$"
; The text in this message cannot exceed 80 chars in length

;-------------------------------------------------------------------------------
; If REBUILD is executed on a diskette that has a valid Mirror file , these
; messages will be generated.


LOOKS_GOOD   DB 13,10,"The MIRROR image file has been validated.",13,10,"$"
; The text in this messages cannot exceed 80 chars in length




LAST_MSG    DB 13,10,"The last$"
PRIOR_MSG   DB "The prior$"
DATE_MSG    DB " time the MIRROR or FORMAT command was used was at "
;
; The following item will be patched at run-time with the time text.
; The ':' may be replaced by another character.  Leave the XX's unchanged.
TIME_MSG    DB "XX:XX"
	    DB " on "
MODAY_MSG   DB "MM/DD/YY."  ;Date is patched at run-time for current country.
	    DB 13,10,"$"
; The total text length of these messages cannot exceed 80 chars



WANNA_CONT  DB 13,10,"Are you sure you want to update the system area of your drive "
; This message cannot exceed 80 chars in length.

WANNA_DRIVE DB "x "		; This line cannot be changed.
	    DB "(Y/N)? "
	    DB "$"


JUST_CHECKING_MSG DB 10,13,'Just checking this time.  No changes written to disk.'
		  DB 10,13,'$'                        


SUCC	   DB  13,10,"The system area of drive "
SUCC_DRIVE DB  "x has been rebuilt.",13,10
; The text in the above two lines cannot exceed 80 chars in length

	   DB  13,10,"You may need to restart the system.",13,10,"$"
; This text in this message cannot exceed 80 chars in length


SUCC_ALT   DB	 13,10,"The system area of drive "
SUCC_ALT_D DB  "x "
	   DB  "has been verified"
; The total length of the text in the above two lines cannot exceed 80
; chars in length, the first char of SUCC_ALT_D cannot be changed

	   DB	 13,10,"to agree with the MIRROR image file.",13,10,"$"
; The text in this line cannot exceed 80 chars in length



FAILED_CHK DB 13,10,"The system area does not agree with the"
; The length of the text in this line cannot exceed 80 chars in length

	   DB 13,10,"MIRROR image file.",13,10,"$"
; The length of the text in this line cannot exceed 80 chars in length

;------------------------------------------------------------------------------
; This message is generated by running Mirror twice on the same drive.	You
; will then get a Last and a Prior Mirror file to choose from.


WITCH_MSG DB   13,10,"If you wish to use the last file as indicated"
; This text in this message cannot exceed 80 chars in length

	  DB   13,10,"above, press L. If you wish to use the prior"
; This text in this message cannot exceed 80 chars in length

	  DB   13,10,"file as indicated above, press P. Press ESC"
; This text in this message cannot exceed 80 chars in length

	  DB   13,10,"to cancel UNFORMAT.",13,10,"$"
; This text in this message cannot exceed 80 chars in length

;------------------------------------------------------------------------------
; This message is generated when the Mirror control files cannot be found when
; you are doing the REBUILD C: operation.


CANT_FIND_MIRROR_MSG  DB 13,10,"Unable to find the MIRROR"
; This text in this message cannot exceed 80 chars in length

	 DB       " control file. If you want to search for the"
; This text in this message cannot exceed 80 chars in length

	 DB 13,10,"MIRROR image file through the entire hard drive,"
; This text in this message cannot exceed 80 chars in length

	 DB 13,10,"press Y, or press N to cancel the UNFORMAT command.",13,10,"$"
; This text in this message cannot exceed 80 chars in length

;------------------------------------------------------------------------------
; If an error occurs during the reading or writing of sectors these messages
; will be generated.


ERROR_READ DB 13,10,"Error reading logical sector ","$"
; This text in this message cannot exceed 80 chars in length



ERROR_WRITE DB 13,10,"Error writing logical sector ","$"
; This text in this message cannot exceed 80 chars in length
;------------------------------------------------------------------------------

;------------------------------------------------------------------------------
; This message occurs after a severe error, you will be asked if you want to
; abort, retry, or ignore.
;
; Make sure the symbols for the response letters match this text.

H_E_QUESTION DB 13,10,"A=Abort, R=Retry, I=Ignore",13,10,"$"
; The text in this message cannot exceed 80 chars in length

;------------------------------------------------------------------------------
; These messages are generated when there are no mirror control files to use
; and the search of the hard drive is being performed.


HARD_WAY_MSG DB 13,10,"A suspected MIRROR file starting at sector "
HARD_WAY_NUM DB "xxxxxxx "		;Do not change this line.
	     DB "has been found.$"
; The total text for these two lines cannot exceed 80 chars in length



HARD_WAY_BACKUP_BAD DB 13,10,"The suspected MIRROR file is invalid. Continuing search.",13,10,"$"
; The text for this message cannot exceed 80 chars in length


HARD_WAY_BACKUP_MSG DB 13,10,"The file is a backup to a more recent MIRROR image file.$"
; The text for this message cannot exceed 80 chars in length


HARD_WAY_ASK_MSG DB 10,13,10,"Do you want to use this file for unformatting or continue searching?"
; The text for this message cannot exceed 80 chars in length

		 DB 13,10,"Press Y to use this file, or N to keep searching.",13,10,"$"
; The text for this message cannot exceed 80 chars in length
;
;------------------  End of Jim's messages include-file  --------------------
;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\mirror\mir_prtn.asm ===
; Copyright 1990-1991 Central Point Software, Inc. 
; All rights reserved.
;----------------------------------------------------------
; This module is part of the CPS 5.0 MIRROR.COM file.
; If option /PARTN is used, this saves the partition
; tables from the BIOS hard drives to a floppy file and
; terminates (does not return to caller).
;
; Created & written by GWD 10-27-88.
;
;
; Modifications:
;
; 11-29-88 GWD
; For ESDI drives ( #heads>16 ), don't bother checking if the
; ending head # of partn is exactly in range.  FDISK bug (?).
;
; 02-01-89 GWD
; Delete previous 'end_head # kluge' (11-29-88), replace with:
; For a partn table entry of type=Extended, don't check partn_end_head.
; IBM 3.30 FDISK writes silly values there.  Since Disk Manager (et al)
; won't have an extended partn, it's OK to ignore that end_head #.
;
; 02-15-90 GWD	6.0 BETA
; Adding handling for non-standard sys_id types in master partn sector.
; Added support for cylinders > 1023 (bits 7,6 of head byte).
;
; 02-16-90 GWD	6.0 Beta
; /U - new option to unload resident Delete-Tracking module.
; (Located here because it's much easier to modify my code than Jim's.)
;
; 02-19-90 GWD	6.0 Beta
; During 'unload' operation, Ctrl-C is disabled by taking INT 23h.
;
; 02-21-90 GWD	6.0 Beta
; Now hook INT 19h, too.  Helps prevent Unloading when maybe unsafe.
;
; 02-23-90 GWD 6.0 beta
; Now put dummy hook on INT 2Fh for same reasons as for INT 19h.
;
; 04-27-90 GWD
; Relocated global proc 'uppercase' into _DTRK module.
;
; ??-??-90 Who knows?
; Various non-documented hacked mods for MSoft.
;
; 12-04-90 GWD (after hack mods by both Jim S. & MSoft)
; Support for hard drives 80h - 87h (new in DOS 5.0).
; This requires the file PARTNSAV.FIL to have a different structure.
;
;----------------------------------------------------------
;
;
CODE	SEGMENT para public 'CODE'	;(Just like Jim's modules)
	ASSUME	CS:CODE, DS:CODE
;
IFDEF	publics
%	INCLUDE	@FileName&.pub
ENDIF
;
	PUBLIC	save_partition
;
	EXTRN	major_digit:abs, minor_digit:abs	;In ORG module.
;
	EXTRN	chk_dtrk_resident:near			;In DTRK module.
	EXTRN	dos_intercept:far
	EXTRN	int25_patch:far, int26_patch:far
	EXTRN	saved25:word, saved26:word
	EXTRN	saved19:word, int19_service:far
	EXTRN	saved2F:word, int2F_service:far
	EXTRN	dos_vector:dword
	EXTRN	uppercase:near
;
	EXTRN	end_prog:byte				;In LAST module.
;
	EXTRN	msg_ps_null:byte, msg_ps_banner:byte, msg_ps_readerr:byte
	EXTRN	msg_ps_bad_partn:byte, msg_ps_too_many:byte
	EXTRN	msg_ps_success:byte, msg_ps_file_err:byte
	EXTRN	msg_ps_small_mem:byte, msg_ps_floppy:byte
	EXTRN	msg_ps_drv_query:byte, msg_ps_bad_parm:byte
	EXTRN	msg_mir_help:byte, msg_crlf:byte
	EXTRN	msg_unloaded:byte, msg_cannot_unload:byte
	EXTRN	msg_not_resident:byte
;
cr	EQU	13
lf	EQU	10
;
max_drvs EQU	8
;
;---------------------------------------------------------------------
; The partition table is located at offset 1BEh in the sector.
; The signature is located at offset 1FEh (= 55h, AAh or word AA55h).
;
; This is the structure of a single element of a partition table.
;
partn_struc STRUC
partn_boot	DB	?	;80h means it's bootable.
partn_head	DB	?	;Starting head.
partn_cx	DW	?	;Starting cylinder & sector.
partn_sys	DB	?	;0=none, 1=FAT12, 4=FAT16, 5=Extended, 6=Huge.
partn_end_head	DB	?
partn_end_cx	DW	?	;Cylinder & sector # combined.
		DW	?,?	;Relative sector.
partn_size	DW	?,?	;Count of sectors.
partn_struc ENDS
;
;--------------------------------------------------------------------
; This is the format in which we store the hard-drive parameters
; (in this program's variables and also in the saved file).
;
drive_parm_str STRUC
drive_number	DB	0
drive_max_head	DB	0
drive_max_cyl	DW	0	;Pure cylinder number.
drive_max_sector DB	0
		DB	?	;Not used.
drive_parm_str ENDS
;
;--------------------------------------------------------------------
; Version number of the structure in the PARTNSAV.FIL file.
; This MUST be updated if the file structure is changed!
; This number must match the one defined inside REBUILD (UF_PARTN.ASM).
;
;; file_struc_ver EQU	0	;0 is original version.
file_struc_ver	EQU	1	;1 is the first revision.  12-4-90 GWD.
;
;--------------------------------------------------------------------
; This header is placed at the beginning of the saved file.
;
header_structure STRUC
h_id		DB	0,0		;Should be CDh,20h (INT 20h).
h_name		DB	"MIRROR "
		DB	?		;Major version number.
		DB	"."
		DB	?		;Minor version #.
h_struc_ver	DB	file_struc_ver
		DB	" saved partitions",1Ah
h_control	DB	0		;See bit flag definitions.
h_file_size	DW	0		;Size of PARTNSAV.FIL, in bytes.
h_drives	DW	0		;Number of physical hard drives.
h_parm_ptr	DW	0		;File offset.
;
; The following two pointers are valid only in the rev 0 structure.
; In newer revisions, use the H_LIST_POINTERS instead.  12-04-90 GWD.
h_list80_ptr_old DW	0	;File offset of start of List_structures.
h_list81_ptr_old DW	0	;File offset of list_structures for drv 81h.
;
h_min		DB	0		;Date & time of the save.
h_hour		DB	0
h_day		DB	0
h_month 	DB	0
h_year		DW	0
h_dos_ver	DW	0	;DOS ver# used during save (hi byte = major).
h_list_pointers	DW  max_drvs DUP (0)	;Ptrs to lists for drives 80h - 87h.
;
header_structure ENDS
;
IF	(SIZE header_structure) GT 400
	.ERR	; Header structure too big!  No room for list of drive parms.
ENDIF
;
;--------------------------------------------------------------------
; The general structure of the PARTNSAV.FIL
;
offset_of_header =	0
offset_of_drv_parms =	(SIZE header_structure)	;List of drive_parm_str's.
offset_of_lists =	1*200h	;Lists are in the second sector of the file.
offset_of_data	=	2*200h	;Data (sector copies) start at third sector.
;
;--------------------------------------------------------------------
; One of these will be present for each sector of data.  Each non-zero
; H_LIST_POINTER in the header points to a sequence of these items.
;
list_structure STRUC
l_dx		DW	0	;Bios location - drive & head.	0= list end.
l_cx		DW	0	;Bios location - cylinder & sector.
l_offset	DW	0	;File offset of the saved data.
l_ext_l 	DW	0	;File offset of list item for extended partn.
list_structure ENDS
;
;---------------------------------------------------------
; Bit flags inside H_CONTROL.
;
bit_has_boot	EQU	1	;DOS 4 logical boot record follows each partn.
bit_ps2_machine EQU	2	;Probably.  Look for drive parms in 2nd sect.
;
;---------------------------------------------------------
; Bit flags for command-line options we recognize in this module.
;
opt_partn	EQU	1	;Partition save, not regular Mirror operation.
opt_unload	EQU	2	;Try to remove resident Delete-Tracking module.
opt_help	EQU	4	;Display help text & terminate.
;
	EVEN
dma_addr EQU this dword 	;Points to our DTA (buffer).
dma_offset	DW	?	;Offset to next item to be written.
dma_seg 	DW	?	;Segment of free memory beyond end of program.
;
list_pointer	DW	?	;Offset in DTA of current processed list item.
handle		DW	?	;Handle of open target file we created.
partn_count	DW	0
parm_ptr	DW	drive_parms	;Offset of parms to use.
last_p_rec_ptr	DW	-1	;File offset of recent partn list item.
;
;----------------------------------------------------------
; Offsets into our buffer of the table entries for the
; normal DOS partition & the extended partition (if any).
;
dos_entry_ptr	DW	?	;0 means no such partn in the table.
ext_entry_ptr	DW	?	;0 means none.
;
;----------------------------------------------------------
; Logical drive to save file on (0=A, 1=B).  Usually a floppy drive.
;
floppy		DB	0
;
;----------------------------------------------------------
; These are used to remember the location of the next partition record.
;
drive	DB	80h
head	DB	0
cx0	DW	0
;
phys_drives DB	0	;Actual number of physical drives to be processed.
master_flag DB	0	;NZ= last sector read was trk0, h0, s1 (master partn).
;
;---------------------------------------------------------
	EVEN
header	LABEL word
	header_structure <,,major_digit,,"M",,,,,,(offset_of_drv_parms)>
;
;---------------------------------------------------------
	EVEN
drive_parms LABEL byte
	drive_parm_str	max_drvs DUP ( <> )
;
;---------------------------------------------------------
ibm_parm_id DB	"IBM HARDFILE TYP"
ibm_parm_length EQU $-ibm_parm_id
;
line_input DB	8 DUP (0)	;Input buffer used for INT 21h, AH=0Ah.
;
filename DB	"x:\PARTNSAV.FIL",0
;
;---------------------------------------------------------
;
save_partition PROC NEAR
	push	ds
	push	es
;
	push	cs
	pop	ds			;DS = CS for this .COM file.
	cld
	sti
	nop
	call	look_for_option 	;Returns result in flags.
	jz	ret_to_mirror		;Nothing for us to do.
	test	al,(opt_help)
	jnz	show_help
	test	al,(opt_unload)
	jnz	unload_req
	lea	dx,msg_ps_banner
	call	pr_text
	call	calculate_dma_addr
	jc	exit
	mov	dma_seg,ax
	call	do_partn_save
exit:	int	20h		;Do not return.  Terminate to DOS.
show_help:
	lea	dx,msg_mir_help
	call	pr_text
	jmp	exit
unload_req:
	call	unload_tracker
	jmp	exit
ret_to_mirror:
	pop	es
	pop	ds
	cld
	sti
	ret
save_partition ENDP
;
dummy_iret:
	iret
;
;------------------------------------------------------------------
unload_tracker PROC NEAR
	lea	dx,msg_crlf
	call	pr_text
	lea	dx,dummy_iret
	mov	ax,2523h		;Take Ctrl-C vector, to disable it.
	int	21h
	call	chk_dtrk_resident
	or	ax,ax
	jnz	unload2 		;It is resident.
	lea	dx,msg_not_resident
	jmp	unload_done
unload_cannot:
	lea	dx,msg_cannot_unload
	jmp	unload_done
unload2:
	mov	bx,ax			;Save resident segment.
;
	mov	es,bx
	cld
	lea	di,saved25
	call	fetch_saved_vector
	lea	di,saved26
	call	fetch_saved_vector
	lea	di,dos_vector
	call	fetch_saved_vector
	lea	di,saved19
	call	fetch_saved_vector
	lea	di,saved2F
	call	fetch_saved_vector
;
	lea	si,int19_service
	mov	di,19h
	call	compare_vector
	jnz	unload_cannot
	lea	si,int2F_service
	mov	di,2Fh
	call	compare_vector
	jnz	unload_cannot
	lea	si,dos_intercept
	mov	di,21h
	call	compare_vector
	jnz	unload_cannot
	cmp	saved25+2,-1
	je	unload_21	;We didn't hook 25h & 26h, so don't check.
	lea	si,int25_patch
	mov	di,25h
	call	compare_vector
	jnz	unload_cannot
	lea	si,int26_patch
	mov	di,26h
	call	compare_vector
	jnz	unload_cannot
	lea	si,saved25
	mov	di,25h
	call	restore_vector
	lea	si,saved26
	mov	di,26h
	call	restore_vector
unload_21:
	lea	si,dos_vector
	mov	di,21h
	call	restore_vector
	lea	si,saved19
	mov	di,19h
	call	restore_vector
	lea	si,saved2F
	mov	di,2Fh
	call	restore_vector
	mov	es,bx
	mov	ax,es:2Ch		;Segment of resident environment.
	or	ax,ax
	jz	unload_free_prog
	dec	ax
	mov	es,ax			;MCB of that environment seg.
	inc	ax
	cmp	bx,es:1 		;Owner of env = our resident segment?
	jne	unload_free_prog
	mov	es,ax
	mov	ah,49h			;Free the resident environ block.
	int	21h
unload_free_prog:
	mov	es,bx
	mov	ah,49h			;Free the resident program block.
	int	21h
	jc	unload_cant_step
	lea	dx,msg_unloaded
unload_done:
	call	pr_text
	ret
unload_cant_step:
	jmp	unload_cannot
unload_tracker ENDP
;
;-----------------------------------------------------------
; Copy a saved-vector from our resident module.
;
; On entry: ES:DI points to a resident dword saved vector.
;
; Destroys AX.
;
fetch_saved_vector PROC NEAR
	mov	ax,es:[di]
	mov	[di],ax 	;Same offset in transient program.
	mov	ax,es:[di+2]
	mov	[di+2],ax
	ret
fetch_saved_vector ENDP
;
;------------------------------------------------------------------
; On entry: BX:SI=correct address of our resident handler,
;	    DI=vector number.
;
; On exit: if vector is correct then ZF=true, else ZF=false.
;
; Destroys AX,DI.
;
compare_vector PROC NEAR
	push	es
	xor	ax,ax
	mov	es,ax
	shl	di,1
	shl	di,1
	cmp	si,es:[di]
	jne	compv2
	cmp	bx,es:[di+2]
compv2: pop	es
	ret
compare_vector ENDP
;
;------------------------------------------------------------------
; On entry: DS:SI points to our dword saved vector, DI = vector number.
;
; Destroys AX,SI,DI.
;
restore_vector PROC NEAR
	cli		;Disable IRQ.
	push	es
	xor	ax,ax
	mov	es,ax
	cld
	shl	di,1
	shl	di,1
	cmp	word ptr [si+2],-1
	je	restv_end		;Not hooked.  Leave vector alone.
	movsw
	movsw
restv_end:
	pop	es
	ret
restore_vector ENDP
;
;------------------------------------------------------------------
; Fetch & save the partition tables.
;
do_partn_save PROC NEAR
	stc
	mov	dx,80h
	mov	ah,8		;Get drive parms.
	int	13h
	jc	fail_stp
	or	ah,ah
	jnz	fail_stp
	cmp	dl,0		;Do any hard drives exist?
	jg	drives_exist
null:	lea	dx,msg_ps_null	;No hard drives - no partitions.
	call	pr_text
fail_stp:
	jmp	fail
read_error:
	lea	dx,msg_ps_readerr
	call	pr_text
	jmp	fail_stp
drives_exist:
	cmp	dl,(max_drvs)
	ja	read_error
	mov	phys_drives,dl
	mov	drive,80h
	lea	bx,drive_parms
get_hard_parms:
	push	bx
	mov	dl,drive
	mov	ah,8
	int	13h
	pop	bx
	jc	read_error
	or	ah,ah
	jnz	read_error
	mov	dl,drive
	call	store_parms
	lea	bx,[bx] + SIZE drive_parm_str
	mov	al,drive
	inc	al
	mov	drive,al
	and	al,7Fh
	cmp	al,phys_drives
	jb	get_hard_parms	;Check the next drive.
got_parms:
;
	mov	al,phys_drives
	mov	ah,0
	mov	header.h_drives,ax
	mov	ah,2Ah		;Get current date (we include it in the file).
	int	21h
	mov	header.h_year, cx
	mov	header.h_month, dh
	mov	header.h_day, dl
	mov	ah,2Ch		;Get time.
	int	21h
	mov	header.h_hour, ch
	mov	header.h_min, cl
;
	xor	bx,bx
	mov	ax,3306h	;Ask DOS 5 for true DOS version
	int	21h
	mov	ax,bx
	or	ax,ax
	jnz	store_ver
	mov	ah,30h		;Get DOS version.
	int	21h
store_ver:
	xchg	al,ah
	mov	header.h_dos_ver, ax
	mov	byte ptr header.h_control, 0
	cmp	ax,400h
	jb	boot_or_not
	or	byte ptr header.h_control, bit_has_boot
boot_or_not:
	stc
	mov	bx,-1
	mov	ah,0C0h
	int	15h
	jc	setup
	or	ah,ah
	jnz	setup
	cmp	bx,-1
	je	setup
	mov	al,es:[bx+2]	;Machine ID byte.
	cmp	al,0FCh
	je	yes_ps2 	;Well, it's possibly a PS/2.  Good enough.
	cmp	al,0F9h 	;Convertible, PCjr, model 30, XT or PC?
	jae	setup		;Definitely not a PS/2.
yes_ps2:
	or	header.h_control, bit_ps2_machine
setup:	mov	dma_offset,0
	les	di,dma_addr
	cld
	mov	cx,(2* 200h) / 2
	xor	ax,ax
	rep stosw		;Clear 1st two sectors of buffer.
;
	mov	list_pointer,(offset_of_lists)
	mov	ax,(offset_of_data)
	mov	dma_offset,ax
	mov	header.h_file_size, ax
	lea	ax,drive_parms
	mov	parm_ptr,ax
	mov	partn_count,0
	mov	drive,80h		;Always start with drive 80h.
;
; Arrive here once for each physical drive.
;
fetch_lp0:
	mov	al,drive
	and	ax,7Fh
	mov	bx,ax
	shl	bx,1			;Index h_list_pointers table of words.
	mov	ax,list_pointer
	mov	header.h_list_pointers [bx], ax
	mov	ax,-1
	mov	master_flag,al
	mov	last_p_rec_ptr,ax	;No 'last partn record' for master.
	mov	head,0
	mov	cx0,1		;Begin with the master partition record.
	jmp	short fetch_lpe
fetch_lp1:
	mov	master_flag,0		;After 1st, it's not a master record.
fetch_lpe:
	mov	dl,drive
	mov	dh,head
	mov	cx,cx0
	les	bx,dma_addr
	mov	ax,0201h	;Read one sector.
	int	13h
	jnc	read_ok
read_err:
	lea	dx,msg_ps_readerr
	call	pr_text
	jmp	fail
read_ok:
	call	check_partn	;Returns CF & vars BOOT_ENTRY_PTR etc.
	jnc	seems_ok
	lea	dx,msg_ps_bad_partn
	call	pr_text
	jmp	fail
seems_ok:
	mov	ax,list_pointer 	;List item we are about to update.
	mov	di,ax
	xchg	di,last_p_rec_ptr	;Last previous partition record.
	cmp	di,-1			;'Last' = -1 (none)?
	je	seems_ok2		;Leave link=0, in previous item.
;
; Update the previous list_structure with a pointer to this
; current one, providing a forward link for REBUILD to follow.
;
	mov	es:[di].l_ext_l,ax	;Save forward link to ext partn item.
;
seems_ok2:
	call	update_list_vars	;Uses LIST_POINTER, not DI.
	test	master_flag,0FFh	;Just fetched the master partn record?
	jz	maybe_get_boot		;No.
	test	header.h_control, bit_ps2_machine
	jz	maybe_get_boot
	mov	dl,drive
	mov	dh,0
	mov	cx,2
	mov	bx,dma_offset
	mov	ax,0201h	;Read the PS/2 drive parameter sector.
	int	13h
	jc	read_err
	lea	di,[bx+2]
	lea	si,ibm_parm_id	;"IBM HARDFILE TYP"
	push	cx
	mov	cx,ibm_parm_length
	cld
	repe cmpsb
	pop	cx
	jne	maybe_get_boot
	call	update_list_vars	;Keep the sector data.
maybe_get_boot:
	test	byte ptr header.h_control, bit_has_boot
	jz	maybe_another_ext
	mov	di,dos_entry_ptr
	or	di,di
	jz	maybe_another_ext
	mov	cx, es:[di].partn_cx
	mov	dh, es:[di].partn_head
	mov	dl,drive
	mov	bx,dma_offset
	mov	ax,0201h		;Read one sector.
	int	13h
	jnc	read_boot_ok
	jmp	read_err
read_boot_ok:
	call	update_list_vars
maybe_another_ext:
	mov	di,ext_entry_ptr
	or	di,di
	jz	next_drive		;No more ext's on this phys drive.
	mov	al, es:[di].partn_head	;Yes, there is extended partn.
	mov	head,al
	mov	ax, es:[di].partn_cx
	mov	cx0,ax
next_partn:
	inc	partn_count
	cmp	partn_count,26
	jae	too_many_partns
	jmp	fetch_lp1	;Examine the extended partition table.
too_many_partns:
	lea	dx,msg_ps_too_many
	call	pr_text
	jmp	fail
;
next_drive:
	mov	al,drive
	inc	ax
	mov	drive,al
	and	al,7Fh
	cmp	al,phys_drives
	jae	done_reading
	add	list_pointer, SIZE list_structure ;One null entry after drive.
	add	parm_ptr, SIZE drive_parm_str		;Parms for next drive.
	jmp	fetch_lp0
;
; Copy header into buffer, then copy drive_parm structures.
;
done_reading:
	lea	si,header
	xor	di,di			;Header goes to offset 0 in the file.
	cld
	mov	cx,SIZE header_structure
	rep movsb
	mov	di, header.h_parm_ptr
	lea	si,drive_parms
	mov	cx,(max_drvs * (SIZE drive_parm_str))
	rep movsb
	mov	word ptr es:[0].h_id, 20CDh
;
; We have built the save_file image in memory.	Now write it to diskette.
;
prompt_for_drive:
	call	ask_for_floppy	;Updates variable FLOPPY.
	mov	dl,floppy
	inc	dl
	mov	ax,36FFh	;Get disk free space.
	int	21h
	cmp	al,0FFh
	je	prompt_for_drive
	mul	cx
	mul	bx
	or	dx,dx
	jnz	create_psav_file	;At least 64k bytes are available.
	cmp	ax, header.h_file_size	;(3+26+26)*512
	jb	prompt_for_drive	;Not enough room for our file.
;
create_psav_file:
	mov	al,floppy
	add	al,"A"
	mov	filename,al
	lea	dx,filename
	mov	cx,0
	mov	ah,3Ch		;CREATE file.
	int	21h
	mov	handle,ax
	jnc	created_ok
	jmp	short file_error
created_ok:
	mov	bx,handle
	mov	cx, header.h_file_size
	push	ds
	mov	ds,dma_seg
	xor	dx,dx
	mov	ah,40h		;WRITE to file.
	int	21h
	pop	ds
	cld
	jc	file_err_close
	cmp	ax,cx
	jne	file_err_close
success:
	mov	bx,handle
	mov	ah,3Eh		;CLOSE file.
	int	21h
	jc	file_error
	lea	dx,msg_ps_success
	call	pr_text
done:	ret
fail:	nop
	jmp	done
file_err_close:
	mov	bx,handle
	mov	ah,3Eh		;CLOSE.
	int	21h
file_error:
	lea	dx,msg_ps_file_err
	call	pr_text
	jmp	fail
do_partn_save ENDP
;
;=======================  Procedures  ============================
;
; On entry: ES:BX points to a partn sector.
;
; On exit: if any of the four entries are invalid then CF=true.  Otherwise,
;	   CF=false and DOS_ENTRY_PTR and EXT_ENTRY_PTR are updated.
;
; AX is destroyed.
;
check_partn PROC NEAR
	push	cx
	push	dx
	push	di
	cmp	word ptr es:[bx+1FEh], 0AA55h	;Proper signature?
	jne	chk_partn_err			;No.
	mov	di,1BEh ;Offset of table in the sector.
	xor	dx,dx	;Partition counters: DH=bootable DOS, DL=extended.
	mov	dos_entry_ptr,dx
	mov	ext_entry_ptr,dx
chk_partn_lp:
	mov	ah, es:[bx+di].partn_sys
	or	ah,ah				;System ID = unused (0)?
	jz	chk_partn2
	mov	al,es:[bx+di].partn_boot
	cmp	al,0
	jz	chk_partn1
	cmp	al,80h		;Boot indicator must be 0 or 80h.
	jne	chk_partn_err
	test	master_flag,0FFh	;Currently examining master partn?
	jz	chk_partn_err	;Only master record can have bootable partn.
	inc	dh		;Increment counter of bootable DOS partns.
chk_partn1:
	mov	al, es:[bx+di].partn_sys
	cmp	al,1		;DOS 12-bit FAT?
	je	chk_partn_dos
	cmp	al,4		;DOS 16-bit FAT?
	je	chk_partn_dos
	cmp	al,6		;DOS huge partition?
	je	chk_partn_dos
	cmp	al,5		;DOS extended partition?
	je	chk_partn_extd	;Yes.
	test	master_flag,0FFh	;Currently examining master partn?
	jz	chk_partn_err		;No.  Strange ID is illegal elsewhere.
	jmp	short chk_partn_next	;Ignore strange System ID in master.
chk_partn_extd:
	inc	dl
	lea	ax,[bx+di]		;It's an 'extended' partn entry.
	mov	ext_entry_ptr,ax
chk_partn2:
	cmp	byte ptr es:[bx+di].partn_boot, 0	;Marked bootable?
	jz	chk_partn_next				;No, so it's OK.
chk_partn_err:
	stc				;CF=true for error.
	jmp	short chk_partn_end
chk_partn_dos:
	call	check_partn_end
	jc	chk_partn_err
	lea	ax,[bx+di]
	mov	dos_entry_ptr,ax
chk_partn_next:
	add	di,SIZE partn_struc
	cmp	di,1FEh
	jae	chk_partn_finish
	jmp	chk_partn_lp
chk_partn_finish:
	cmp	dh,1		;More than one bootable DOS partition?
	ja	chk_partn_err	;Yes.  Error.
	cmp	dl,1		;More than one extended partition?
	ja	chk_partn_err	;Error.
	mov	al,dl
	clc
chk_partn_end:
	pop	di
	pop	dx
	pop	cx
	ret
check_partn ENDP
;
;--------------------------------------------------------------------
; On entry: ES:[BX+SI] points to one normal (#1,4,5,6) partn-table entry.
;	    PARM_PTR is assumed valid.
;
; On exit: if parition-end seems in legal range then CF=false, else CF=true.
;
; Only AX is changed.
;
check_partn_end PROC NEAR
	push	si
	mov	si,parm_ptr		;Parms for this physical drive.
	mov	al, byte ptr es:[bx+di].partn_end_cx
	mov	ah, es:[bx+di].partn_end_head
	and	ax,0C0C0h
	rol	ah,1
	rol	ah,1
	shl	ax,1
	shl	ax,1
	mov	al, byte ptr es:[bx+di].partn_end_cx + 1
	cmp	ax, [si].drive_max_cyl
	ja	chk_pend_err
	cmp	byte ptr es:[bx+di].partn_sys, 5	;Type = 'extended'?
	je	chk_pend_ok				;Skip (FDISK bug).
	mov	ah, es:[bx+di].partn_end_head
	and	ah,3Fh
	cmp	ah, [si].drive_max_head 	;Is end head # in range?
	ja	chk_pend_err
	mov	al, byte ptr es:[bx+di].partn_end_cx
	and	al,3Fh
	cmp	al, [si].drive_max_sector
	jbe	chk_pend_ok
chk_pend_err:
	stc
	jmp	short chk_pend_ret
chk_pend_ok:
	clc
chk_pend_ret:
	pop	si
	ret
check_partn_end ENDP
;
;----------------------------------------------------------------
; On entry: CX & DH are intact from INT 13h function 8.
;	    DL = drive number.
;	    DS:BX --> our drive parm structure to be filled in.
;
; Destroys AX.
;
store_parms PROC NEAR
	mov	[bx].drive_number, dl
	mov	al,dh
	and	al,3Fh
	mov	[bx].drive_max_head, al
	mov	ax,cx
	and	al,3Fh
	mov	[bx].drive_max_sector, al
	mov	al,cl
	mov	ah,dh
	and	ax,0C0C0h	;Support more cyl bits in d7,d6 of DH.
	rol	ah,1		;Max cylinder cound be up to 4095.
	rol	ah,1
	shl	ax,1
	shl	ax,1
	mov	al,ch
	mov	[bx].drive_max_cyl, ax
	ret
store_parms ENDP
;
;-----------------------------------------------------------------
; Update the sector-list table & our pointers after
; a sector has been added to the memory image.
;
; On entry: CX & DX set same as for Bios INT 13h.  ES= buffer segment.
;	    BX= file offset of the sector.
;
; Destroys AX.
;
update_list_vars PROC NEAR
	push	di
	mov	di,list_pointer
	mov	es:[di].l_cx, cx
	mov	es:[di].l_dx, dx
	mov	es:[di].l_offset, bx
	mov	ax,512				;Advance the pointers.
	add	header.h_file_size, ax
	add	dma_offset,ax
	add	list_pointer, SIZE list_structure	;Post-increment.
	pop	di
	ret
update_list_vars ENDP
;
;------------------------------------------------------------------
; Locate a segment where DMA transfers are 'safe'
; (the must not cross 64k physical boundaries).
;
; On exit: if CF=false then AX = segment for Bios DTA.
;	   If CF=true, then there isn't enough memory.
;
; Destroys AX,BX,DX.
;
calculate_dma_addr PROC NEAR
	lea	bx,end_prog
	lea	bx,[bx+16]
	mov	cl,4
	shr	bx,cl
	mov	dx,cs			;Use CS, since we are .COM file.
	add	dx,bx			;DX:0000 points after END_PROG.
calc_dma_lp:
	mov	ax,dx
	mov	bx,dx
;
; Room for:
;  header + index + parm sector + 26 partn records + 26 logical boot records.
;
	add	ax, ((3+26+26) * 512) / 16	;Paragraphs needed.
;
	cmp	ax,cs:2 		;CS=PSP.  PSP:2 is 'top_of_memory'.
	jae	calc_dma_small		;Beyond.  Not enough memory.
	and	ax,0F000h		;Isolate the 64k physical parts.
	and	bx,0F000h
	cmp	ax,bx			;Start & End are in the same bank?
	je	calc_dma_ok		;Yes.
	add	dx,512/16		;No.  Bump up addr by one sector size.
	jmp	calc_dma_lp		;Try again, with new starting_seg.
calc_dma_small:
	lea	dx,msg_ps_small_mem
	call	pr_text
	stc
	jmp	short calc_dma_exit
calc_dma_ok:
	mov	ax,dx
	clc
calc_dma_exit:
	ret
calculate_dma_addr ENDP
;
;------------------------------------------------------------
; Ask the user for the name of the floppy drive to
; write the partition info to.	Returns variable FLOPPY.
;
; Destroys AX,DX.
;
ask_for_floppy PROC NEAR
	mov	floppy,0	;Drive A is always the default.
	lea	dx,msg_ps_floppy
	call	pr_text
ask_flop0:
	lea	dx,msg_ps_drv_query
	call	pr_text
	mov	ax,0C00h	;Flush DOS keyboard.
	int	21h
	mov	line_input,4
	mov	line_input+1,0
	lea	dx,line_input
	mov	ah,0Ah		;DOS console line input.
	int	21h
	mov	dl,cr
	mov	ah,2
	int	21h
	mov	dl,lf
	mov	ah,2
	int	21h
	cmp	line_input+1,0
	jz	ask_flop_done	;Null input.  Use drive A.
	mov	al,line_input+2
	call	uppercase
	sub	al,"A"
	jb	ask_flop0
	mov	floppy,al	;Save it.  Now check if it's valid.
	mov	ah,19h		;Get current drive.
	int	21h
	push	ax		;Save current drive.
	mov	dl,floppy
	mov	ah,0Eh		;Set default drive to specified one.
	int	21h
	mov	ah,19h		;Fetch it again, to check.
	int	21h
	pop	dx		;Recover original default drive.
	push	ax		;Save resulting drive from last 19h.
	mov	ah,0Eh		;Restore original default drive.
	int	21h
	pop	ax
	cmp	al,floppy	;Did the Set succeed?
	jne	ask_flop0	;No.  Ask again.
ask_flop_done:
	ret
ask_for_floppy ENDP
;
;-----------------------------------------------------------
; Display text message at DS:DX, ending in a $.
;
pr_text PROC NEAR
	push	ax		;All regs unchanged.
	mov	ah,9
	int	21h
	pop	ax
	ret
pr_text ENDP
;
;-----------------------------------------------------------
skipb	PROC NEAR		;Skip over blanks at DS:SI.
	mov	al,[si]
	cmp	al," "
	jne	skipb_ret
	inc	si
	jmp	skipb
skipb_ret:
	ret
skipb	ENDP
;
;-----------------------------------------------------------
; Examine parms at DS:80h.
;
; On return: ZF=true means nothing for this module to do (AL=0), or
;	     ZF=false means something to do and AL = partn_opt_xxx bits.
;
; Destroys: AX,BX,CX,SI,DI,ES.
;
look_for_option PROC NEAR
	push	ds
	pop	es
	cld
	xor	bx,bx
	mov	cl,ds:80h	;Command line length, from DOS.
	and	cx,007Fh
	mov	si,81h
	cmp	cl,2
	jb	lfo_none
lfo_caps:
	mov	al,[si]
	call	uppercase
	mov	[si],al
	inc	si
	cmp	al,"?"
	je	lfo_help
	loop	lfo_caps
	mov	byte ptr [si],0Dh
	jmp	short lfo_1
lfo_help:
	mov	bl,opt_help
	jmp	short lfo_end
;
lfo_1:	mov	si,81h
	call	skipb
	jb	lfo_none
	cmp	al,"/"
	jne	lfo_none
	lea	di,option_text1
	mov	cx,option_length1
	lea	ax,[si]
	repe cmpsb
	je	lfo_partn
	mov	si,ax
	lea	di,option_text2
	mov	cx,option_length2
	repe cmpsb
	je	lfo_unload
	jmp	short lfo_none
lfo_unload:
	mov	bl,opt_unload
	jmp	short lfo_term
lfo_partn:
	mov	bl,opt_partn
lfo_term:
	cmp	byte ptr [si]," "	;Option is properly terminated?
	ja	lfo_err
	jmp	short lfo_end
lfo_none:
	mov	bl,0
	jmp	short lfo_end
lfo_err:
	lea	dx,msg_ps_bad_parm
	call	pr_text
	jmp	lfo_help
lfo_end:
	mov	al,bl
	and	ax,00FFh
	ret
look_for_option ENDP
;
option_text1	DB	"/PARTN"
option_length1	EQU	$ - option_text1
;
option_text2	DB	"/U"
option_length2	EQU	$ - option_text2

;
;-----------------------------------------------------------
;
CODE	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\rebuild\uf_incl.inc ===
; Copyright 1990 Central Point Software, Inc. All rights reserved.
;--------------  'Include file' for UNFORMAT.  ------------------------
;
dir_str	STRUC
filename DB	"        "
extension DB	"   "
file_attr DB	0		;Attribute bits are defined below.
dir_reserved DB	4 DUP (0)	;10 reserved bytes total.
zapsav_loc DB	0		;Used by CPS Formatter to keep 1st char.
	DB	5 DUP (0)	;Last 5 reserved bytes.
time	DW	0
date	DW	0
start_cluster DW 0FFFFh
file_size DW	0,0
dir_str	ENDS
;
;
ro_attr	EQU	1		;File attribute bits.
hide_attr EQU	2
sys_attr EQU	4
vol_attr EQU	8
dir_attr EQU	10h
arch_attr EQU	20h
;
; The following FAT 'reserved' cluster numbers have special meanings:
;
fm_free		EQU	0	;Free cluster (same as DOS).
fm_bad		EQU	0FFF7h	;FAT Mark for bad cluster (same as DOS).
fm_sub_start	EQU	0FFF8h	;Cluster begins a subdir ("." & "..").
fm_sub_mid	EQU	0FFF9h	;Clu contains dir entries, but not ".."
fm_sub_tail	EQU	0FFFAh	;Like sub_mid, but we also know it's the last.
fm_file_start	EQU	0FFFBh	;Clu is pointed at by some file's dir entry.
fm_file_del	EQU	0FFFCh	;Clu belonged to a file which we deleted.
fm_sub_nul	EQU	0FFFDh	;Clu is a complete subdir, but has no files.
; * unused	EQU	0FFFEh
fm_end		EQU	0FFFFh	;End of any FAT chain (same as DOS).
;
; Bit flags (stored in OPTIONS) from command line options:
;
opt_list	EQU	2	;Verbose list of files during Walk1.
opt_keep_fat	EQU	4	;Assume FAT is valid, keep it intact.
opt_keep_root	EQU	8	;Assume root is valid, make minimal changes.
opt_erase_fat	EQU	10h	;Assume FAT is crap, don't bother reading it.
opt_erase_root	EQU	20h	;Assume root is crap, ignore it.
opt_k		EQU	40h	;Keep something.  Detects conflicting options.
opt_f		EQU	80h	;Option references FAT.  Detects conflicts.
opt_r		EQU	100h	;Root option.  Used to detect conflicts.
opt_j		EQU	200h	;/J invokes Jim's 'just checking' function.
opt_u		EQU	400h	;/U jumps into UnFormat, skipping Jim's.
opt_partn	EQU	800h	;/PARTN restores partition tables from floppy.
opt_wrfake	EQU	8000h	;Don't really write to disk.  (For testing.)
;
; The following are status codes returned in AH by proc CHECK_DIR_ENTRY:
;
de_zeros EQU	1	;All zeros (may be an unused subdir entry).
de_live	EQU	2	;A valid live entry.
de_deleted EQU	4	;Deleted entry (first byte of name = E5h).
de_zapped EQU	8	;Zapped valid entry (first byte = 00).
de_sublink EQU	10h	;Entry "." or ".." (allowed only if input AX=0 or 32).
de_zapsaved EQU	20h	;Zapped by CPS Format - 1st char saved.
de_invalid EQU	80h	;Not valid (can't be a directory entry).
;
;
; Equates & structure for the format of the command line parms:
;
max_optdef_text EQU 8
;
opt_def STRUC		;This is for a single parm.  Repeat for each parm.
optdef_var_ptr DW 0	;If NZ, pointer to this parm's variable's word.
optdef_mask   DW 0	;Only used for switch-type parms.
optdef_action DB 0	;Action bits are defined below.
optdef_length DB 0	;Length of parm text (e.g. for "/SIZE=", length=6).
				;Uppercase text of the parm follows.
optdef_text DB	"        "	;max_optdef_text blanks.
opt_def ENDS
;
; Bit flags within PARM_ACTION byte of an OPT_DEF structure:
;
action_switch EQU 80h	;Switch only (OPT_MASK will be returned).
action_k EQU	   4	;Trailing K is allowed if action_dec is used.
action_dec EQU	   1	;Decimal integer number is expected.
;
; If optdef_action = 0, then this invalid struc is the end of the list.
;
; - End of include-file. -

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\rebuild\uf_jims.asm ===
; Copyright 1990 Central Point Software, Inc. 
; All rights reserved.
;--------------------------------------------------------------------
; This is Jim's portion of the program code for REBUILD.COM 4.23+
; GWD is supporting this, now.
;
; Removed all the dumb stuff regarding 'stand_alone'.  GWD.
; Now 'INCLUDEs' the messages, instead of EXTRNing them.  4-19-88 GWD.
; Added the dumb stuff that handles large disks that req
; more than two controls records.  4-25-88 JIM.
; Created equates for YES_CHAR and NO_CHAR (helps foreign vers) 5-24-88 GWD.
; Substituted YES_CHAR etc, for all the Y's and N's.  6-7-88.
; To fix problem with UnFormat finding parts of MIRROR.FIL as
;  subdirectories (Ack!), MIRROR.COM now pokes an FF into each
;  root entry at offset 21.  Added code here to undo that 6-8-88 v4.24.
; Now handles different DOS 4.xx DPB structure.  4.30  7-27-88.
; Now recognizes Zenith 3.30 DOS (like 3.31, huge partns).  5.00  11-18-88.
; Fixed date/time formats for foreign countries.  5.5	5-25-89.
; During long search for control file, checks for Ctrl-C.  5.5	 5-30-89.
; Translation-equates LAST_CHAR, PRIOR_, ABORT_, RETRY_, etc.  v6  03-05-90.
;
;       M000    MD      9/23/90         Removed output of CPS copyright
;       M002    MD                      Exit properly on user request


	 PAGE  66,132

DOSEXEC  MACRO
	 INT   21H
	 ENDM


; LIST_COUNT EQU WORD PTR DS:[SI]+18
; XLAT_TABLE EQU WORD PTR DS:[SI]+20

str1	STRUC
	DB	18 DUP (?)
list_count DW	?
xlat_table DW	?
str1	ENDS
;
str2	STRUC
from_lsn_lo DW	?
from_lsn_hi DW	?
to_lsn_lo DW	?
to_lsn_hi DW	?
str2	ENDS

; used to build the sector table
; FROM_LSN_LO EQU   WORD PTR DS:[BX]
; FROM_LSN_HI EQU   WORD PTR DS:[BX]+2
; TO_LSN_LO   EQU   WORD PTR DS:[BX]+4
; TO_LSN_HI   EQU   WORD PTR DS:[BX]+6



prog	SEGMENT PARA PUBLIC
	ASSUME CS:prog
;
	 PUBLIC J_REBUILD		;Referenced from UF_MAIN module.
;
	EXTRN	date_control:word, date_separator:byte	;In UF_IO module.
;
	INCLUDE uf_jmsg.asm



HIGHEST_CLUSTER        DW 0
SECTOR_SIZE	       DW 0
NUM_SECTORS_TO_HANDLE  DW 0
NUM_BOOT_FAT_SECTORS   DW 0
NUM_DIR_SECTORS        DW 0
FIRST_DIRECTORY_SECTOR DW 0
HARD_WAY_SECTOR_NUM_LO DW 0
HARD_WAY_SECTOR_NUM_HI DW 0

ABS_25_LIST   LABEL BYTE
ABS_25_SEC_LO DW 0
ABS_25_SEC_HI DW 0
ABS_25_COUNT  DW 0
ABS_25_OFF    DW 0
ABS_25_SEG    DW 0

MIRROR_SWITCH DB 0
ABS_25_HARD_WAY EQU 80H

SECTORS_PER_CLU   DW 0
FIRST_DATA_SECTOR DW 0
LAST_SECTOR_LO	  DW 0
LAST_SECTOR_HI	  DW 0
IO_AREA_PTR	  DW 0
dont_fix_cnt	DW 0

R_INFO	 EQU   $

R_CTL1_LSN_LO DW 0 ;***
R_CTL1_LSN_HI DW 0 ;
		   ; Gotta keep this stuff for COMPAQ DOS 3.31 >32 Meg
R_CTL2_LSN_LO DW 0 ;
R_CTL2_LSN_HI DW 0 ;***

R_SECTOR_SIZE		 DW 0
R_NUM_SECTORS_TO_HANDLE  DW 0
R_NUM_BOOT_FAT_SECTORS	 DW 0
R_NUM_DIR_SECTORS	 DW 0
R_FIRST_DIRECTORY_SECTOR DW 0
R_HEADS 		 DW 0
R_NUM_FATS		 DB 0
R_NUM_RESERVED		 DW 0
R_SECTORS_PER_CLU	 DB 0
R_SECTORS_PER_TRACK	 DW 0
R_NUM_HIDDEN		 DW 0
R_NUM_CTL_SECTORS	 DW 0  ; 4/24/88
R_ALT_SECTOR_SIZE	 DW 0  ; 4/24/88

	 DB    16 DUP(0)
	 ORG   R_INFO+48
R_INFO_LEN EQU $-R_INFO

CS_SAVE  DW    0
AX_SAVE  DW    0
BX_SAVE  DW    0
PSP_SAVE DW    0

OK_DWORD   DD  0
	   ORG OK_DWORD
OK_OFFSET  DW  0
OK_SEGMENT DW  0

NAMES	 DB    'MIRROR  FIL'
	 DB    'MIRROR  BAK'
	 DB    'MIRORSAVFIL'

ASCIIZ	 DB    'x:\'
	 DB    'MIRROR.FIL',0

CHECKS_FOR_OUR_MIRROR_FILE  DW	 0
MAX_MIRROR_CLUSTERS	    DW	 0
MIRROR_HI_CLU		    DW	 0
OUR_SIGNATURE	   DB 'aMSESLIFVASRORIMESAEP'
OUR_SIGNATURE_LEN      EQU  $-OUR_SIGNATURE

MIRROR_YEAR_1	EQU OUR_SIGNATURE_LEN+4
MIRROR_MODAY_1	EQU OUR_SIGNATURE_LEN+4+2
MIRROR_TIME_1	EQU OUR_SIGNATURE_LEN+4+4
MIRROR_LSN_LO_2 EQU OUR_SIGNATURE_LEN+4+6
MIRROR_LSN_HI_2 EQU OUR_SIGNATURE_LEN+4+8
MIRROR_YEAR_2	EQU OUR_SIGNATURE_LEN+4+10
MIRROR_MODAY_2	EQU OUR_SIGNATURE_LEN+4+12
MIRROR_TIME_2	EQU OUR_SIGNATURE_LEN+4+14

SEC_LO_FROM_MIRROR_1  DW  0
SEC_HI_FROM_MIRROR_1  DW  0
TIME_FROM_MIRROR_1    DW  0FFFFH
YEAR_FROM_MIRROR_1    DW  0
MODAY_FROM_MIRROR_1   DW  0
SEC_LO_FROM_MIRROR_2  DW  0
SEC_HI_FROM_MIRROR_2  DW  0
TIME_FROM_MIRROR_2    DW  0
YEAR_FROM_MIRROR_2    DW  0
MODAY_FROM_MIRROR_2   DW  0

SWITCH	 DB    0
JUST_CHECK     EQU 80H
INIT_F_O_F     EQU 40H
MATCH_FOUND    EQU 20H
DRIVE_FIXED    EQU 10H
REPORT_ERRORS  EQU 08H
GOT_TWO_FILES  EQU 04H
HARD_WAY       EQU 02H
ESCAPE_PRESSED EQU 01H

CHECK_FAILED DW 0
EXIT_ERROR   DB 0
;	 1 = ALL OK
;	 2 = USER CANCELLED
;	 3 = DID NOT RUN SUCCESSFULLY. DID NOT MODIFY
;	 4 = DID NOT RUN SUCCESSFULLY. DID MODIFY
;	 5 = STRANGE ENVIRONMENT OR DISK
;	 6 = PANIC EXIT, ABORT MAIN PROGRAM

DOS_VERSION  DW 0

K_ESCAPE EQU 27

ABS_SECTOR_LO DW 0
ABS_SECTOR_HI DW 0

NO_COPYRIGHT    equ     00h            ;M000

COPYRIGHT DB   10,13

	DB	"REBUILD  "             ;M000
	DB	24h

H_E_SECTOR_NUM DB '0000000.$'



J_REBUILD PROC NEAR
	 MOV   IO_AREA_PTR,BX
	 ADD   AL,41H
	 MOV   ASCIIZ,AL
	 MOV   drive_msg_patch,AL	;5-24-88 GWD.
	 MOV   WANNA_DRIVE,AL
	 MOV   SUCC_DRIVE,AL
	 MOV   SUCC_ALT_D,AL
	 MOV   CS_SAVE,CS
	 MOV   OUR_SIGNATURE,'A'
	 CALL  ISSUE_COPYRIGHT

	 CMP   AH,0
	 JE    J_REBUILD_1
	 OR    SWITCH,JUST_CHECK
	 LEA   DX,JUST_CHECKING_MSG
	 MOV   DS,CS_SAVE
	 MOV   AH,9
	 DOSEXEC

J_REBUILD_1:
	 CALL  CHECK_OBVIOUS_STUFF
	 MOV   EXIT_ERROR,5
;	 5 = STRANGE ENVIRONMENT OR DISK
	 JNC   START_REBUILD
	 JMP   BAIL_OUT

START_REBUILD:
	 MOV   AH,0DH
	 DOSEXEC

LOOK_SOME_MORE:
         MOV   EXIT_ERROR,2             ;M002 - Set error for user cancel
	 TEST  SWITCH,ESCAPE_PRESSED
	 JNZ   BAIL_OUT
	 CALL  FIND_OUR_FILE
	 JC    NO_FILE_FOUND

	 OR    SWITCH,MATCH_FOUND
	 CALL  VERIDATE_FILE
	 JC    LOOK_SOME_MORE

	 OR    SWITCH,REPORT_ERRORS
	 CALL  RE_BUILD_SYSTEM_AREA
	 JC    BAIL_OUT

	 LEA   DX,FAILED_CHK
	 CMP   CHECK_FAILED,0		; works only if all files in the
	 JA    FINAL_MSG		; same sector
	 LEA   DX,SUCC
	 TEST  SWITCH,JUST_CHECK
	 JZ    FINAL_MSG
	 LEA   DX,SUCC_ALT

FINAL_MSG:
	 MOV   DS,CS_SAVE
	 MOV   AH,9
	 DOSEXEC

	 MOV   AH,0DH
	 DOSEXEC

	 MOV   EXIT_ERROR,1
;	 1 = ALL OK
	 MOV   AL,EXIT_ERROR
	 RET

NO_FILE_FOUND:
	 LEA   DX,USER_CANCELLED
;	 3 = DID NOT RUN SUCCESSFULLY. DID NOT MODIFY
	 CMP   EXIT_ERROR,3
	 JNE   STC_EXIT
	 LEA   DX,NO_FILE
	 TEST  SWITCH,HARD_WAY
	 JNZ   STC_EXIT
	 TEST  SWITCH,MATCH_FOUND
	 JZ    STC_EXIT
	 LEA   DX,BAD_FILE

STC_EXIT:
	 MOV   DS,CS_SAVE
	 MOV   AH,9
	 DOSEXEC

BAIL_OUT:
	 LEA   DX,PROBLEMS
	 MOV   AH,9
	 DOSEXEC

	 MOV   AH,0DH
	 DOSEXEC

	 MOV   AL,EXIT_ERROR
	 RET

J_REBUILD ENDP



ISSUE_COPYRIGHT PROC NEAR
	 PUSH  AX
	 MOV   DS,CS_SAVE

	 LEA   DX,REBUILD_MAIN_MSG	    ; This will print the other part
	 MOV   AH,9			    ; of the message
	 DOSEXEC

	 POP   AX
	 RET

ISSUE_COPYRIGHT ENDP


VERIDATE_FILE PROC NEAR
	 CALL  INSERT_DATE

	 TEST  SWITCH,GOT_TWO_FILES
	 JZ    VERIDATE_FIRST
	 CALL  ASK_WITCH_FILE
	 JNC   VERIDATE_FIRST
	 TEST  SWITCH,ESCAPE_PRESSED
	 JNZ   V_F_STC_JMP
	 MOV   AX,SEC_LO_FROM_MIRROR_2	; where its at man
	 MOV   ABS_25_SEC_LO,AX
	 MOV   AX,SEC_HI_FROM_MIRROR_2	; where its at man
	 MOV   ABS_25_SEC_HI,AX
	 JMP   short VERIDATE_SECOND

VERIDATE_FIRST:
	 MOV   AX,SEC_LO_FROM_MIRROR_1	; where its at man
	 MOV   ABS_25_SEC_LO,AX
	 MOV   AX,SEC_HI_FROM_MIRROR_1	; where its at man
	 MOV   ABS_25_SEC_HI,AX

VERIDATE_SECOND:
	 MOV   BX,IO_AREA_PTR
	 MOV   CX,1
	 CALL  ABS_25

	 MOV   DS,CS_SAVE
	 MOV   ES,CS_SAVE
	 LEA   DI,R_INFO
	 MOV   SI,IO_AREA_PTR
	 ADD   SI,R_IO_INFO_OFFSET
	 MOV   CX,R_INFO_LEN
	 REP   MOVSB
	 MOV   AX,R_SECTOR_SIZE
	 CMP   AX,SECTOR_SIZE
	 JE    V_F_1

; Note, if R_SECTOR_SIZE is zero and the new field, R_NUM_CTL_SECTORS is
; two or greater, then we'll assume we have the new style that handles
; large multi-megabyte hard disks.

	 CMP   R_SECTOR_SIZE,0
	 JNE   V_F_STC_JMP
	 CMP   R_NUM_CTL_SECTORS,2
	 JB    V_F_STC_JMP
	 MOV   AX,R_ALT_SECTOR_SIZE
	 MOV   R_SECTOR_SIZE,AX
	 CMP   AX,SECTOR_SIZE
	 JE    V_F_1

V_F_STC_JMP:
	 JMP   V_F_STC

V_F_1:
	 MOV   AX,R_NUM_SECTORS_TO_HANDLE
	 CMP   AX,NUM_SECTORS_TO_HANDLE
	 JNE   V_F_STC_JMP
	 MOV   AX,R_NUM_BOOT_FAT_SECTORS
	 CMP   AX,NUM_BOOT_FAT_SECTORS
	 JNE   V_F_STC_JMP
	 MOV   AX,R_NUM_DIR_SECTORS
	 CMP   AX,NUM_DIR_SECTORS
	 JNE   V_F_STC_JMP
	 MOV   AX,R_FIRST_DIRECTORY_SECTOR
	 CMP   AX,FIRST_DIRECTORY_SECTOR
	 JNE   V_F_STC_JMP

	 MOV   AX,R_CTL1_LSN_LO 	; does this record point to
	 CMP   ABS_25_SEC_LO,AX 	; itself?
	 JNE   V_F_STC_JMP
	 MOV   AX,R_CTL1_LSN_HI
	 CMP   ABS_25_SEC_HI,AX
	 JNE   V_F_STC_JMP

	 MOV   BX,IO_AREA_PTR
	 MOV   OK_OFFSET,BX
	 MOV   OK_SEGMENT,DS

V_F_READ_CTL_1:
	 MOV   AX,R_CTL1_LSN_LO
	 MOV   ABS_25_SEC_LO,AX
	 MOV   AX,R_CTL1_LSN_HI
	 MOV   ABS_25_SEC_HI,AX

	 CMP   R_NUM_CTL_SECTORS,2	; we have the special stuff?
	 JBE   V_F_READ_CTL_1_A 	; no, branch

	 MOV   CX,R_NUM_CTL_SECTORS	; yes, get # ctl sectors
	 MOV   AH,0
	 MOV   AL,R_SECTORS_PER_CLU
	 CMP   CX,AX			; greater than sectors per clu?
	 JBE   V_F_READ_CTL_1_B 	; no, branch
	 MOV   CX,AX			; yes, force it
	 JMP   short V_F_READ_CTL_1_B

V_F_READ_CTL_1_A:
	 MOV   CX,1			; old way

V_F_READ_CTL_1_B:
	 MOV   AX,SECTOR_SIZE
	 MUL   CX
	 ADD   OK_OFFSET,AX

	 CALL  ABS_25
	 JNC   V_F_CTL1_OK
	 JMP   short V_F_STC

V_F_CTL1_OK:
	 LDS   BX,OK_DWORD

	 MOV   AX,R_CTL2_LSN_LO
	 MOV   ABS_25_SEC_LO,AX
	 MOV   AX,R_CTL2_LSN_HI
	 MOV   ABS_25_SEC_HI,AX

	 CMP   R_NUM_CTL_SECTORS,2
	 JBE   V_F_READ_CTL_2_A

	 MOV   CX,R_NUM_CTL_SECTORS
	 MOV   AH,0
	 MOV   AL,R_SECTORS_PER_CLU
	 CMP   CX,AX
	 JBE   V_F_CTL2_OK
	 SUB   CX,AX
	 JMP   short V_F_READ_CTL_2_B

V_F_READ_CTL_2_A:
	 MOV   CX,1

V_F_READ_CTL_2_B:
	 MOV   AX,SECTOR_SIZE
	 MUL   CX
	 ADD   OK_OFFSET,AX

	 CALL  ABS_25

	 JC    V_F_STC

V_F_CTL2_OK:
	 MOV   DS,CS_SAVE
	 MOV   ES,CS_SAVE
	 CLC
	 RET

V_F_STC:
	 TEST  SWITCH,HARD_WAY
	 JZ    V_F_STC_1
	 MOV   DS,CS_SAVE
	 LEA   DX,HARD_WAY_BACKUP_BAD
	 MOV   AH,9
	 DOSEXEC

V_F_STC_1:
	 STC
	 RET

VERIDATE_FILE ENDP



ASK_WITCH_FILE PROC NEAR
	 MOV   DS,CS_SAVE
	 LEA   DX,WITCH_MSG
	 MOV   AH,9
	 DOSEXEC
	 MOV   AX,0C01H
	 DOSEXEC
	 CMP   AL,K_ESCAPE
	 JE    ASK_WITCH_ESC
	 AND   AL,NOT 20H
	 CMP   AL,last_char	;'L'
	 JE    ASK_WITCH_CLC
	 CMP   AL,prior_char	;'P'
	 JE    ASK_WITCH_STC
	 JMP   ASK_WITCH_FILE

ASK_WITCH_CLC:
	 CLC
	 JMP   short ASK_WITCH_EXIT

ASK_WITCH_ESC:
	 OR    SWITCH,ESCAPE_PRESSED

ASK_WITCH_STC:
	 STC

ASK_WITCH_EXIT:
	 PUSHF
	 LEA   DX,LINE_DOWN
	 MOV   AH,9
	 DOSEXEC
	 POPF
	 RET

ASK_WITCH_FILE ENDP



RE_BUILD_SYSTEM_AREA PROC NEAR

RE_BUILD_SYSTEM_AREA_ASK:
	 MOV   DS,CS_SAVE
	 LEA   DX,LOOKS_GOOD
	 MOV   AH,9
	 DOSEXEC

	 TEST  SWITCH,JUST_CHECK
	 JNZ   DONT_ASK

	 LEA   DX,WANNA_CONT
	 MOV   AH,9
	 DOSEXEC
	 MOV   AX,0C01H
	 DOSEXEC
	 CMP   AL,K_ESCAPE
	 JE    RE_BUILD_ESCAPE
	 AND   AL,NOT 20H
	 CMP   AL,no_char
	 JE    RE_BUILD_ESCAPE
	 CMP   AL,yes_char
	 JNE   RE_BUILD_SYSTEM_AREA_ASK

DONT_ASK:
	 LEA   DX,LINE_DOWN
	 MOV   AH,9
	 DOSEXEC

	 MOV   SI,IO_AREA_PTR
	 ADD   SI,R_CTL_OFFSET
	 LEA   BX,word ptr ds:[si].xlat_table
	 MOV   BP,word ptr ds:[si].list_count
	 MOV   BX_SAVE,BX
	 mov   ax,num_boot_fat_sectors
         mov   dont_fix_cnt,ax
	 JMP   short RE_BUILD_REPEAT

RE_BUILD_ESCAPE:
	 MOV   EXIT_ERROR,2
;	 2 = USER CANCELLED
	 LEA   DX,LINE_DOWN
	 MOV   AH,9
	 DOSEXEC

RE_BUILD_CANCELLED:
	 MOV   DS,CS_SAVE
	 LEA   DX,USER_CANCELLED
	 MOV   AH,9
	 DOSEXEC

	 STC
	 RET

RE_BUILD_REPEAT:
	 MOV   BX,BX_SAVE

	 MOV   AX,word ptr ds:[bx].to_lsn_lo
	 MOV   ABS_25_SEC_LO,AX
	 MOV   AX,word ptr ds:[bx].to_lsn_hi
	 MOV   ABS_25_SEC_HI,AX

	 MOV   CX,1
	 LDS   BX,OK_DWORD
	 CALL  ABS_25
	 JC    RE_BUILD_CANCELLED

	xor	ax,ax			;We'll load AX in a moment, anyway.
	cmp	ax,dont_fix_cnt 	;Zero?
	JNE	re_build_dont_fix	;Not yet.
	mov	ds:[bx+21], al	;Fix root entry.
re_build_dont_fix:

	 MOV   BX,BX_SAVE
	 MOV   AX,word ptr ds:[bx].from_lsn_lo
	 MOV   ABS_25_SEC_LO,AX
	 MOV   AX,word ptr ds:[bx].from_lsn_hi
	 MOV   ABS_25_SEC_HI,AX

	 MOV   CX,1
	 LDS   BX,OK_DWORD
	 TEST  SWITCH,JUST_CHECK
	 JZ    RE_BUILD_WRITE
	 ADD   BX,SECTOR_SIZE
	 CALL  ABS_25
	 JC    RE_BUILD_CANCELLED

	 JMP   short RE_BUILD_INC

RE_BUILD_WRITE:
	 CALL  ABS_26
	 JC    RE_BUILD_CANCELLED

RE_BUILD_INC:
	 TEST  SWITCH,JUST_CHECK
	 JZ    RE_BUILD_INC_1

	xor	ax,ax			;We'll load AX in a moment, anyway.
	cmp	ax,dont_fix_cnt 	;Zero?
	JNE	re_build_dont_fix_2      ;Not yet.
	mov	ds:[bx+21], al	;Fix root entry.
re_build_dont_fix_2:

	 CALL  COMPARE_AREAS

RE_BUILD_INC_1:
	sub	dont_fix_cnt,1
	adc	dont_fix_cnt,0	;Keep it from going negative.
	 MOV   BX,BX_SAVE
	 ADD   BX,8
	 MOV   BX_SAVE,BX
	 DEC   BP
	jz	re_build_inc_end
	 jmp   RE_BUILD_REPEAT
re_build_inc_end:
;	 Now we gotta write the rest of the fats if any

	 DEC   R_NUM_FATS
	 JZ    RE_BUILD_THRU
	 MOV   BP,NUM_BOOT_FAT_SECTORS
	 SUB   BP,R_NUM_RESERVED	 ; # sectors per FAT
	 MOV   AX,R_NUM_RESERVED
	 MOV   CL,3
	 SHL   AX,CL
	 LEA   BX,word ptr ds:[si].xlat_table
	 ADD   BX,AX		       ; point to 1st FAT entry
	 MOV   BX_SAVE,BX
	 MOV   AX,NUM_BOOT_FAT_SECTORS ; logical sector # next sector

RE_BUILD_OTHER_FATS:
	 CALL  WRITE_OTHER_FAT_SECTOR
	 JC    RE_BUILD_OTHER_BAD
	 ADD   BX,8
	 INC   AX
	 DEC   BP
	 JNZ   RE_BUILD_OTHER_FATS

	 DEC   R_NUM_FATS
	 JZ    RE_BUILD_THRU

	 MOV   BP,NUM_BOOT_FAT_SECTORS
	 SUB   BP,R_NUM_RESERVED	 ; # sectors per FAT
	 MOV   BX,BX_SAVE
	 JMP   RE_BUILD_OTHER_FATS

RE_BUILD_THRU:
	 CLC
	 RET

RE_BUILD_OTHER_BAD:
	 STC
	 RET

RE_BUILD_SYSTEM_AREA ENDP



INSERT_DATE PROC NEAR
	 CMP   TIME_FROM_MIRROR_1,0FFFFH
	 JNE   INSERT_DATE_CONT
	 RET

INSERT_DATE_CONT:
	 MOV   AX,TIME_FROM_MIRROR_1
	 MOV   AH,0
	 CALL  HEX_TO_ASCII
	 MOV   WORD PTR TIME_MSG+3,AX

	 MOV   AX,TIME_FROM_MIRROR_1
	 MOV   AL,AH
	 MOV   AH,0
	 CALL  HEX_TO_ASCII
	 MOV   WORD PTR TIME_MSG,AX

	 MOV   AX,YEAR_FROM_MIRROR_1
	 SUB   AX,1900

	cmp	ax,100		;M006	; anything over 2000 should map back
	jb	got_date_lt_100	;M006
	sub	ax,100		;M006	; 2000 -> 00
got_date_lt_100:		;M006

	 CALL  HEX_TO_ASCII
	 MOV   WORD PTR MODAY_MSG+6,AX

	 MOV   AX,MODAY_FROM_MIRROR_1
	 MOV   AH,0
	 CALL  HEX_TO_ASCII
	 MOV   WORD PTR MODAY_MSG+3,AX

	 MOV   AX,MODAY_FROM_MIRROR_1
	 MOV   AL,AH
	 MOV   AH,0
	 CALL  HEX_TO_ASCII
	 MOV   WORD PTR MODAY_MSG,AX

	call	fix_date_foreign	;5-25-89 GWD.

	 LEA   DX,LAST_MSG
	 MOV   AH,9
	 DOSEXEC
	 LEA   DX,DATE_MSG
	 MOV   AH,9
	 DOSEXEC

	 TEST  SWITCH,GOT_TWO_FILES
	 JNZ   INSERT_DATE_CONT_1
	 RET

INSERT_DATE_CONT_1:
	 MOV   AX,TIME_FROM_MIRROR_2
	 MOV   AH,0
	 CALL  HEX_TO_ASCII
	 MOV   WORD PTR TIME_MSG+3,AX

	 MOV   AX,TIME_FROM_MIRROR_2
	 MOV   AL,AH
	 MOV   AH,0
	 CALL  HEX_TO_ASCII
	 MOV   WORD PTR TIME_MSG,AX

	 MOV   AX,YEAR_FROM_MIRROR_2
	 SUB   AX,1900

	cmp	ax,100		;M006	; anything over 2000 should map back
	jb	got_date_lt_100a ;M006
	sub	ax,100		;M006	; 2000 -> 00
got_date_lt_100a:		;M006

	 CALL  HEX_TO_ASCII
	 MOV   WORD PTR MODAY_MSG+6,AX

	 MOV   AX,MODAY_FROM_MIRROR_2
	 MOV   AH,0
	 CALL  HEX_TO_ASCII
	 MOV   WORD PTR MODAY_MSG+3,AX

	 MOV   AX,MODAY_FROM_MIRROR_2
	 MOV   AL,AH
	 MOV   AH,0
	 CALL  HEX_TO_ASCII
	 MOV   WORD PTR MODAY_MSG,AX

	call	fix_date_foreign	;5-25-89 GWD.

	 LEA   DX,PRIOR_MSG
	 MOV   AH,9
	 DOSEXEC
	 LEA   DX,DATE_MSG
	 MOV   AH,9
	 DOSEXEC
	 RET

INSERT_DATE ENDP

;
;-----------------------------------------------------------------
; Added 5-25-89, GWD.
;
; On entry: MODAY_MSG string is setup like this "MM/DD/YY".
;
; On exit: the string is adjusted for the current country-code.
;	   (country info was previously obtained by Glen's
;	    UF_Main module and is stored in Glen's UF_IO module.)
;
; AX is destroyed.
;
date_field1 EQU word ptr moday_msg
date_sep1   EQU byte ptr moday_msg+2
date_field2 EQU word ptr moday_msg+3
date_sep2   EQU byte ptr moday_msg+5
date_field3 EQU word ptr moday_msg+6
;
fix_date_foreign PROC NEAR
	mov	al,date_separator
	mov	date_sep1,al
	mov	date_sep2,al
	mov	ax,date_control ;Date format code, from DOS country-info.
	or	ax,ax
	jz	fix_d_end	;Date format = USA, so nothing to do.
	cmp	ax,2
	ja	fix_d_end	;Unknown format code.
	push	date_field3	;Year of initial US-format date.
	push	date_field1	;Month.
	push	date_field2	;Day.
	cmp	al,2		;Japan?
	je	fix_d_japan
	pop	date_field1	;Europe.
	pop	date_field2
	pop	date_field3
	jmp	short fix_d_end
fix_d_japan:
	pop	date_field3
	pop	date_field2
	pop	date_field1
fix_d_end:
	ret
fix_date_foreign ENDP



WRITE_OTHER_FAT_SECTOR PROC NEAR

;	 Upon entry AX has the logical sector # to write and
;	 BX points to the control record entry for the
;	 source of the data. With BX, we'll read the data.
;	 With AX, we'll write it.

	 PUSH  AX
	 PUSH  BX
	 MOV   AX_SAVE,AX

	 MOV   AX,word ptr ds:[bx].to_lsn_lo
	 MOV   ABS_25_SEC_LO,AX
	 MOV   AX,word ptr ds:[bx].to_lsn_hi
	 MOV   ABS_25_SEC_HI,AX

	 MOV   CX,1
	 LDS   BX,OK_DWORD
	 CALL  ABS_25
	 JC    WRITE_OTHER_STC

	 MOV   AX,AX_SAVE
	 MOV   ABS_25_SEC_LO,AX
	 MOV   ABS_25_SEC_HI,0

	 MOV   CX,1
	 LDS   BX,OK_DWORD
	 TEST  SWITCH,JUST_CHECK
	 JZ    W_O_F_S_WRITE

	 ADD   BX,SECTOR_SIZE
	 CALL  ABS_25
	 JC    WRITE_OTHER_STC
	 JMP   short W_O_F_S_WRITE_OK

W_O_F_S_WRITE:
	 CALL  ABS_26
	 JC    WRITE_OTHER_STC

W_O_F_S_WRITE_OK:
	 TEST  SWITCH,JUST_CHECK
	 JZ    W_O_F_S_WRITE_OK_1
	 CALL  COMPARE_AREAS

W_O_F_S_WRITE_OK_1:
	 POP   BX
	 POP   AX
	 CLC
	 RET

WRITE_OTHER_STC:
	 POP   BX
	 POP   AX
	 STC
	 RET

WRITE_OTHER_FAT_SECTOR ENDP


;
; Note: Glen's main module (UF_MAIN) has already validate
; the DOS version and checked for a network drive.
; So that code has been deleted.  5-2-89 GWD.
;
CHECK_OBVIOUS_STUFF PROC NEAR
	MOV	AX,3306H		; get true DOS version
	MOV	BX,0			;   ala DOS 5.0
	INT	21H
	CMP	BL,5			; function supported?
	JB	VERSION_OLD_WAY
	MOV	AX,BX
	JMP	SHORT STORE_DOSVER

VERSION_OLD_WAY:
	 MOV   AH,30H
	 DOSEXEC

STORE_DOSVER:
	 XCHG  AH,AL
	cmp	ax,(3*256)+30	;Zenith 3.30 DOS?
	jne	store_version	;No way.
	cmp	bh,5		;Zenith ID?   (GWD 11-18-88)
	jne	store_version
	mov	al,31		;Pretend it's 3.31 DOS (supports huge partns).

store_version:
	 MOV   DOS_VERSION,AX
	 CLC
	 RET

CHECK_OBVIOUS_STUFF ENDP



FIND_OUR_FILE PROC NEAR
	 TEST  SWITCH,INIT_F_O_F
	 JZ    F_O_F_FIRST_TIME
	 TEST  SWITCH,HARD_WAY
	 JZ    F_O_M_F_NEXT
	 ADD   HARD_WAY_SECTOR_NUM_LO,1
	 ADC   HARD_WAY_SECTOR_NUM_HI,0
	 JMP   NO_MIRROR_ASK_EM

F_O_F_FIRST_TIME:
	 OR    SWITCH,INIT_F_O_F
	 CALL  GET_DRIVE_SPECS
	 MOV   DS,CS_SAVE
	 JNC   F_O_F_FIND_A_MIRROR_FILE
	 JMP   F_O_F_STC

F_O_F_FIND_A_MIRROR_FILE:

; We'll look thru the last ten clusters for our wittle file. If we
;  find it we'll use the logical sector in it to begin our lookin'.
;  If we don't find it, we'll ask 'em if they want us to start from
;  the front.

	 MOV   CHECKS_FOR_OUR_MIRROR_FILE,0
	 MOV   AX,HIGHEST_CLUSTER
	 MOV   MIRROR_HI_CLU,AX

CHECK_FOR_MIRROR_LOOP:
	 MOV   AX,MIRROR_HI_CLU
	 CALL  CONVERT_CLU_TO_LOG_SECTOR
	 MOV   BX,IO_AREA_PTR
	 MOV   CX,1
	 CALL  ABS_25
	 JC    F_O_M_F_BYPASS

	 CALL  MATCH_OUR_MIRROR_FILE	; izit?
	 JC    F_O_M_F_NEXT		; not that wun
	 JMP   short FOUND_OUR_MIRROR_FILE

F_O_M_F_NEXT:
	 INC   CHECKS_FOR_OUR_MIRROR_FILE
	 MOV   AX,MAX_MIRROR_CLUSTERS
	 CMP   CHECKS_FOR_OUR_MIRROR_FILE,AX
	 JAE   NO_MIRROR_ASK_EM

	 DEC   MIRROR_HI_CLU
	 CMP   MIRROR_HI_CLU,1
	 JBE   NO_MIRROR_ASK_EM

	mov	ah,0Bh			;Check for Ctrl-C (allow user abort).
	int	21h			;Added 5-30-89	GWD.
	cmp	al,0
	jz	f_o_m_f_nokey
	mov	ax,0C00h		;Flush keyboard buffer.
	int	21h
f_o_m_f_nokey:

	 JMP   CHECK_FOR_MIRROR_LOOP
FOUND_OUR_MIRROR_FILE:
	 MOV   AX,SEC_LO_FROM_MIRROR_1	; where its at man
	 MOV   ABS_25_SEC_LO,AX
	 MOV   AX,SEC_HI_FROM_MIRROR_1	; where its at man
	 MOV   ABS_25_SEC_HI,AX

	 MOV   CX,1
	 CALL  ABS_25
	 JC    F_O_M_F_BYPASS

	 CALL  MATCH_REC
	 JNC   FOUND_OUR_FILE_CHK_PRIOR
	 JMP   F_O_M_F_NEXT

F_O_M_F_BYPASS:
	 PUSH  DX
	 LEA   DX,BAD_SECTOR_MSG
	 MOV   AH,9
	 DOSEXEC
	 POP   DX
	 JMP   F_O_M_F_NEXT

FOUND_OUR_FILE_CHK_PRIOR:
	 TEST  SWITCH,GOT_TWO_FILES
	 JZ    FOUND_OUR_FILE_JMP
	 AND   SWITCH,NOT GOT_TWO_FILES
	 MOV   AX,SEC_LO_FROM_MIRROR_2
	 MOV   ABS_25_SEC_LO,AX
	 MOV   AX,SEC_HI_FROM_MIRROR_2
	 MOV   ABS_25_SEC_HI,AX

	 MOV   CX,1
	 CALL  ABS_25
	 JC    FOUND_OUR_FILE_JMP

	 CALL  MATCH_REC
	 JC    FOUND_OUR_FILE_JMP
	 OR    SWITCH,GOT_TWO_FILES

FOUND_OUR_FILE_JMP:
	 JMP   FOUND_OUR_FILE

NO_MIRROR_ASK_EM:
	 OR    SWITCH,HARD_WAY
	 AND   SWITCH,NOT GOT_TWO_FILES

	 CMP   HARD_WAY_SECTOR_NUM_HI,0
	 JNE   FIND_OUR_FILE_READ

	 MOV   DX,HARD_WAY_SECTOR_NUM_LO
	 CMP   DX,FIRST_DATA_SECTOR
	 JNE   FIND_OUR_FILE_READ

	 MOV   DS,CS_SAVE
	 LEA   DX,CANT_FIND_MIRROR_MSG
	 MOV   AH,9
	 DOSEXEC

         public no_mirror_ask_em_again
NO_MIRROR_ASK_EM_AGAIN:
	 MOV   AX,0C01H
	 DOSEXEC
	 CMP   AL,K_ESCAPE
	 JE    F_O_F_ESC
	 AND   AL,NOT 20H
	 CMP   AL,yes_char
	 JE    FIND_OUR_FILE_SEARCH
	 CMP   AL,no_char
	 JNE   NO_MIRROR_ASK_EM_AGAIN

F_O_F_ESC:
	 LEA   DX,LINE_DOWN
	 MOV   AH,9
	 DOSEXEC
	 MOV   EXIT_ERROR,2
;	 2 = USER CANCELLED
	 JMP   short F_O_F_STC

FIND_OUR_FILE_SEARCH:
	 LEA   DX,LINE_DOWN
	 MOV   AH,9
	 DOSEXEC

FIND_OUR_FILE_READ:
	 MOV   AX,HARD_WAY_SECTOR_NUM_LO
	 MOV   ABS_25_SEC_LO,AX
	 MOV   AX,HARD_WAY_SECTOR_NUM_HI
	 MOV   ABS_25_SEC_HI,AX
	 MOV   CX,1
	 CALL  ABS_25
	 JC    F_O_F_BYPASS

	 CALL  MATCH_REC
	 JNC   FOUND_OUR_FILE_HARD
	 JMP   short F_O_F_INC

F_O_F_BYPASS:
	 PUSH  DX
	 LEA   DX,BAD_SECTOR_MSG
	 MOV   AH,9
	 DOSEXEC
	 POP   DX

F_O_F_INC:
	 ADD   HARD_WAY_SECTOR_NUM_LO,1
	 ADC   HARD_WAY_SECTOR_NUM_HI,0
	 MOV   DX,HARD_WAY_SECTOR_NUM_HI
	 CMP   DX,LAST_SECTOR_HI
	 JB    FIND_OUR_FILE_READ
	 MOV   DX,HARD_WAY_SECTOR_NUM_LO
	 CMP   DX,LAST_SECTOR_LO
	 JB    FIND_OUR_FILE_READ
	 MOV   EXIT_ERROR,3
;	 3 = DID NOT RUN SUCCESSFULLY. DID NOT MODIFY

F_O_F_STC:
	 STC
	 RET

FOUND_OUR_FILE_HARD:
	 MOV   AX,HARD_WAY_SECTOR_NUM_LO
	 MOV   SEC_LO_FROM_MIRROR_1,AX
	 MOV   ABS_SECTOR_LO,AX

	 MOV   AX,HARD_WAY_SECTOR_NUM_HI
	 MOV   SEC_HI_FROM_MIRROR_1,AX
	 MOV   ABS_SECTOR_HI,AX

	 CALL  DISPLAY_SECTOR_NUM

	 MOV   AX,WORD PTR H_E_SECTOR_NUM
	 MOV   WORD PTR HARD_WAY_NUM,AX
	 MOV   AX,WORD PTR H_E_SECTOR_NUM+2
	 MOV   WORD PTR HARD_WAY_NUM+2,AX
	 MOV   AX,WORD PTR H_E_SECTOR_NUM+4
	 MOV   WORD PTR HARD_WAY_NUM+4,AX
	 MOV   AL,H_E_SECTOR_NUM+6
	 MOV   HARD_WAY_NUM+6,AL

FOUND_OUR_FILE_HARD_AGAIN:
	 LEA   DX,HARD_WAY_MSG
	 MOV   AH,9
	 DOSEXEC

	 MOV   DI,IO_AREA_PTR
	 ADD   DI,BACKUP_IND_OFFSET
	 CMP   BYTE PTR [DI],0FFH
	 JNE   FOUND_OUR_FILE_MAYBE
	 LEA   DX,HARD_WAY_BACKUP_MSG
	 MOV   AH,9
	 DOSEXEC

FOUND_OUR_FILE_MAYBE:
	 LEA   DX,HARD_WAY_ASK_MSG
	 MOV   AH,9
	 DOSEXEC
	 MOV   AX,0C01H
	 DOSEXEC
	 CMP   AL,K_ESCAPE
	 JE    FOUND_HARD_ESC
	 AND   AL,NOT 20H
	 CMP   AL,yes_char
	 JE    FOUND_OUR_FILE_CLC
	 CMP   AL,no_char
	 JNE   FOUND_OUR_FILE_HARD_AGAIN
	 LEA   DX,LINE_DOWN
	 MOV   AH,9
	 DOSEXEC
	 JMP   F_O_F_INC

FOUND_HARD_ESC:
	 OR    SWITCH,ESCAPE_PRESSED
	 STC
	 RET

FOUND_OUR_FILE_CLC:
	 LEA   DX,LINE_DOWN
	 MOV   AH,9
	 DOSEXEC

FOUND_OUR_FILE:
	 CLC
	 RET

FIND_OUR_FILE ENDP



CONVERT_CLU_TO_LOG_SECTOR PROC NEAR
	 PUSH  BX
	 SUB   AX,2			; minus tew
	 MOV   BX,SECTORS_PER_CLU
	 MUL   BX			; times sectors per clu
	 ADD   AX,FIRST_DATA_SECTOR	; that shud be about it
	 ADC   DX,0
	 MOV   ABS_25_SEC_LO,AX
	 MOV   ABS_25_SEC_HI,DX
	 POP   BX
	 RET

CONVERT_CLU_TO_LOG_SECTOR ENDP



MATCH_REC PROC NEAR
	 MOV   SI,IO_AREA_PTR
	 LEA   DI,ASCIIZ
	 MOV   CX,14
	 TEST  SWITCH,DRIVE_FIXED
	 JNZ   MATCH_NO_INC
	 INC   SI
	 INC   DI
	 DEC   CX

MATCH_NO_INC:
	 REPE  CMPSB
	 JNE   MATCH_REC_STC

MATCH_REC_CLC:
	 CLC
	 RET

MATCH_REC_STC:
	 STC
	 RET
MATCH_REC ENDP



MATCH_OUR_MIRROR_FILE PROC NEAR
	 AND   SWITCH,NOT GOT_TWO_FILES
	 MOV   TIME_FROM_MIRROR_1,0FFFFH
	 MOV   SI,IO_AREA_PTR
	 MOV   AX,WORD PTR [SI] 	; in case this is it,
	 MOV   SEC_LO_FROM_MIRROR_1,AX	;  then save it
	 MOV   AX,WORD PTR [SI+2]	; in case this is it,
	 MOV   SEC_HI_FROM_MIRROR_1,AX	;  then save it
	 ADD   SI,4			; where it oughta be
	 LEA   DI,OUR_SIGNATURE
	 MOV   CX,OUR_SIGNATURE_LEN
	 REPE  CMPSB
	 JNE   M_O_M_F_STC

	 MOV   SI,IO_AREA_PTR
	 MOV   AX,WORD PTR MIRROR_TIME_1[SI]
	 MOV   TIME_FROM_MIRROR_1,AX
	 MOV   AX,WORD PTR MIRROR_YEAR_1[SI]
	 MOV   YEAR_FROM_MIRROR_1,AX
	 MOV   AX,WORD PTR MIRROR_MODAY_1[SI]
	 MOV   MODAY_FROM_MIRROR_1,AX

	 CMP   WORD PTR MIRROR_LSN_HI_2[SI],0
	 JNE   M_O_M_F_CHK
	 CMP   WORD PTR MIRROR_LSN_LO_2[SI],2
	 JB    M_O_M_F_CLC

M_O_M_F_CHK:
	 MOV   AX,HIGHEST_CLUSTER
	 CALL  CONVERT_CLU_TO_LOG_SECTOR
	 MOV   AX,ABS_25_SEC_HI
	 CMP   WORD PTR MIRROR_LSN_HI_2[SI],AX
	 JB    M_O_M_F_GET_2ND
	 MOV   AX,ABS_25_SEC_LO
	 CMP   WORD PTR MIRROR_LSN_LO_2[SI],AX
	 JA    M_O_M_F_CLC

M_O_M_F_GET_2ND:
	 OR    SWITCH,GOT_TWO_FILES
	 MOV   AX,WORD PTR MIRROR_LSN_LO_2[SI]
	 MOV   SEC_LO_FROM_MIRROR_2,AX
	 MOV   AX,WORD PTR MIRROR_LSN_HI_2[SI]
	 MOV   SEC_HI_FROM_MIRROR_2,AX
	 MOV   AX,WORD PTR MIRROR_TIME_2[SI]
	 MOV   TIME_FROM_MIRROR_2,AX
	 MOV   AX,WORD PTR MIRROR_YEAR_2[SI]
	 MOV   YEAR_FROM_MIRROR_2,AX
	 MOV   AX,WORD PTR MIRROR_MODAY_2[SI]
	 MOV   MODAY_FROM_MIRROR_2,AX

M_O_M_F_CLC:
	 CLC
	 RET

M_O_M_F_STC:
	 STC
	 RET

MATCH_OUR_MIRROR_FILE ENDP



GET_DRIVE_SPECS PROC NEAR
	push	si
	 MOV   MIRROR_SWITCH,0
	 MOV   AH,32H
	 MOV   DL,ASCIIZ
	 SUB   DL,40H
	 DOSEXEC
	 CMP   AL,0FFH
	 JNE   GET_DRIVE_1
	 JMP   SPEC_ERROR

GET_DRIVE_1:
	mov	si,1			;If DOS=4.xx then SI=1, else SI=0.
	cmp	dos_version,400h	;CF=true if ver# is < 400h.
	sbb	si,0			;Decrements only if DOS < 4.00.
	 CMP   BYTE PTR [BX+si]+22,0F8H   ; is it a fixed disk?
	 JE    GET_DRIVE_FIXED
	 CMP   DOS_VERSION,0300H
	 JB    GET_DRIVE_2

	 PUSH  BX
	 MOV   AX,4408H
	 MOV   BL,ASCIIZ
	 SUB   BL,40H
	 DOSEXEC
	 POP   BX
	 JC    GET_DRIVE_2
	 CMP   AL,1
	 JNE   GET_DRIVE_2

GET_DRIVE_FIXED:
	 OR    SWITCH,DRIVE_FIXED

GET_DRIVE_2:
	 MOV   CX,[BX]+11	       ; get first usable sector
	 MOV   FIRST_DATA_SECTOR,CX
	 MOV   HARD_WAY_SECTOR_NUM_LO,CX
	 MOV   HARD_WAY_SECTOR_NUM_HI,0

	 SUB   CX,[BX+si]+16	       ; minus first directory sector
	 MOV   NUM_DIR_SECTORS,CX

	 MOV   ax,[BX]+15	       ; get sectors per FAT
	or	si,si
	jnz	get_drive_2x		;DOS 4.xx
	mov	ah,0			;For DOS < 4.00, it's only a byte.
get_drive_2x:

	 ADD   AX,[BX]+6	       ; dont forget reserved (BOOT)
	 MOV   NUM_BOOT_FAT_SECTORS,AX

	 ADD   CX,AX
	 MOV   NUM_SECTORS_TO_HANDLE,CX

	 MOV   AX,[BX]+13	       ; get cluster count + 1
	 MOV   HIGHEST_CLUSTER,AX      ; save it

 	 PUSH  AX
 	 SHR   AX,1
 	 SHR   AX,1
 	 MOV   MAX_MIRROR_CLUSTERS,AX
 	 POP   AX
;        MOV   MAX_MIRROR_CLUSTERS,AX
;	 DEC   MAX_MIRROR_CLUSTERS

	 DEC   AX
	 MOV   CH,0
	 MOV   CL,[BX]+4	       ; get sectors per cluster - 1
	 INC   CX
	 MUL   CX		       ; # of sectors in data area
	 ADD   AX,[BX]+11	       ; add system sectors
	 ADC   DX,0
	 MOV   LAST_SECTOR_LO,AX
	 MOV   LAST_SECTOR_HI,DX

	 MOV   AX,[BX]+2	       ; get sector size
	 MOV   SECTOR_SIZE,AX

	 MOV   AL,[BX]+4	       ; get sectors per cluster
	 INC   AL
	 MOV   AH,0
	 MOV   SECTORS_PER_CLU,AX

	 MOV   AX,[BX+si]+16	       ; get 1st directory sector
	 MOV   FIRST_DIRECTORY_SECTOR,AX

	 CMP   DOS_VERSION,031FH	;Version 3.31 DOS?
	 JB    GET_DRIVE_THRU

	 MOV   AX,SECTORS_PER_CLU
	 MUL   HIGHEST_CLUSTER
	 ADD   AX,FIRST_DATA_SECTOR
	 ADC   DX,0
	 OR    DX,DX
	 JE    GET_DRIVE_THRU
	 OR    MIRROR_SWITCH,ABS_25_HARD_WAY

GET_DRIVE_THRU:

	 CLC
	 jmp	short get_drive_exit

SPEC_ERROR:
	 LEA   DX,DRIVE_MSG
	 MOV   AH,9
	 DOSEXEC

	 LEA   DX,DRIVE_SPEC_ERROR
	 MOV   AH,9
	 DOSEXEC

	 MOV   EXIT_ERROR,5
;	 5 = STRANGE ENVIRONMENT OR DISK
	 STC
get_drive_exit:
	pop	si
	 RET

GET_DRIVE_SPECS ENDP



ABS_25	 PROC NEAR
	 PUSH  BX
	 PUSH  CX
	 PUSH  DX
	 PUSH  SI
	 PUSH  DI
	 PUSH  BP
	 PUSH  DS

	 MOV   ABS_25_OFF,BX
	 MOV   ABS_25_SEG,DS
	 MOV   ABS_25_COUNT,CX

	 MOV   DX,ABS_25_SEC_HI
	 MOV   ABS_SECTOR_HI,DX
	 MOV   DX,ABS_25_SEC_LO
	 MOV   ABS_SECTOR_LO,DX

	 MOV   AL,ASCIIZ
	 SUB   AL,41H

	 TEST  MIRROR_SWITCH,ABS_25_HARD_WAY
	 JZ    ABS_25_READ
	 MOV   CX,-1
	 MOV   DS,CS_SAVE
	 LEA   BX,ABS_25_LIST

ABS_25_READ:
	 INT   25H
	 JC    ABS_25_ERROR
	 POPF
	 CLC

ABS_25_EXIT:
	 POP   DS
	 POP   BP
	 POP   DI
	 POP   SI
	 POP   DX
	 POP   CX
	 POP   BX
	 RET

ABS_25_ERROR:
	 POPF
	 TEST  SWITCH,REPORT_ERRORS
	 JNZ   ABS_25_HANDLE
	 STC
	 JMP   ABS_25_EXIT

ABS_25_HANDLE:
	 MOV   AX,0
	 CALL  HANDLE_ERROR
	 JC    ABS_25_EXIT
	or	ax,ax
;	 CMP   AX,0
	 JE    ABS_25_RETRY
	 CLC
	 JMP   ABS_25_EXIT

ABS_25_RETRY:
	 POP   BP
	 POP   DI
	 POP   SI
	 POP   DX
	 POP   CX
	 POP   BX
	 JMP   ABS_25

ABS_25	 ENDP



ABS_26	 PROC NEAR
	 PUSH  BX
	 PUSH  CX
	 PUSH  DX
	 PUSH  SI
	 PUSH  DI
	 PUSH  BP
	 PUSH  DS

	 MOV   ABS_25_OFF,BX
	 MOV   ABS_25_SEG,DS
	 MOV   ABS_25_COUNT,CX

	 MOV   DX,ABS_25_SEC_HI
	 MOV   ABS_SECTOR_HI,DX
	 MOV   DX,ABS_25_SEC_LO
	 MOV   ABS_SECTOR_LO,DX

	 MOV   AL,ASCIIZ
	 SUB   AL,41H

	 TEST  MIRROR_SWITCH,ABS_25_HARD_WAY
	 JZ    ABS_26_WRITE
	 MOV   CX,-1
	 MOV   DS,CS_SAVE
	 LEA   BX,ABS_25_LIST

ABS_26_WRITE:
	 INT   26H
	 JC    ABS_26_ERROR
	 POPF
	 CLC

ABS_26_EXIT:
	 POP   DS
	 POP   BP
	 POP   DI
	 POP   SI
	 POP   DX
	 POP   CX
	 POP   BX
	 RET

ABS_26_ERROR:
	 POPF
	 TEST  SWITCH,REPORT_ERRORS
	 JNZ   ABS_26_HANDLE
	 STC
	 JMP   ABS_26_EXIT

ABS_26_HANDLE:
	 MOV   AX,1
	 CALL  HANDLE_ERROR
	 JC    ABS_26_EXIT
	or	ax,ax
;	 CMP   AX,0
	 JE    ABS_26_RETRY
	 CLC
	 JMP   ABS_26_EXIT

ABS_26_RETRY:
	 POP   BP
	 POP   DI
	 POP   SI
	 POP   DX
	 POP   CX
	 POP   BX
	 JMP   ABS_26
ABS_26	 ENDP



HANDLE_ERROR PROC NEAR
	 PUSH  DS
	 MOV   DS,CS_SAVE
	 LEA   DX,ERROR_READ
	 CMP   AX,0
	 JE    H_E_1
	 LEA   DX,ERROR_WRITE

H_E_1:
	 MOV   AH,9
	 DOSEXEC
	 CALL  DISPLAY_SECTOR_NUM
	 LEA   DX,H_E_SECTOR_NUM
	 MOV   AH,9
	 DOSEXEC

H_E_AGAIN:
	 LEA   DX,H_E_QUESTION
	 MOV   AH,9
	 DOSEXEC
	 MOV   AX,0C01H
	 DOSEXEC
	 CMP   AL,K_ESCAPE
	 JE    H_E_ABORT
	 AND   AL,NOT 20H
	 CMP   AL,abort_char	;'A'
	 JE    H_E_ABORT
	 CMP   AL,retry_char	;'R'
	 JE    H_E_RETRY
	 CMP   AL,ignore_char	;'I'
	 JNE   H_E_AGAIN
	 MOV   AX,1
	 CLC
	 JMP   short H_E_EXIT

H_E_RETRY:
	xor	ax,ax
;	 MOV   AX,0
;	 CLC
	 JMP   short H_E_EXIT

H_E_ABORT:
	 MOV   EXIT_ERROR,4
;	 4 = DID NOT RUN SUCCESSFULLY. DID MODIFY
	 STC

H_E_EXIT:
	 PUSHF
	 PUSH  AX
	 LEA   DX,LINE_DOWN
	 MOV   AH,9
	 DOSEXEC
	 POP   AX
	 POPF
	 POP   DS
	 RET

HANDLE_ERROR ENDP



COMPARE_AREAS PROC NEAR
	 PUSH  ES
	 PUSH  DI
	 PUSH  DS
	 PUSH  SI
	 PUSH  CX
	 PUSH  AX
	 LES   DI,OK_DWORD
	 LDS   SI,OK_DWORD
	 ADD   DI,SECTOR_SIZE
	 MOV   CX,SECTOR_SIZE

COMPARE_AREAS_AGAIN:
	 REPE  CMPSB
	 JE    COMPARE_AREAS_EXIT

	 MOV   AX,CX
	 AND   AX,1FH
	 CMP   AX,9
	 JA    COMPARE_AREAS_FAILED
	 CMP   AX,4
	 JB    COMPARE_AREAS_FAILED
	 ADD   SI,AX
	 ADD   DI,AX
	 SUB   CX,AX
	 CALL  CHECK_OF_OK_TO_FAIL
	 JNC   COMPARE_AREAS_AGAIN

COMPARE_AREAS_FAILED:
	 INC   CHECK_FAILED

COMPARE_AREAS_EXIT:
	 POP   AX
	 POP   CX
	 POP   SI
	 POP   DS
	 POP   DI
	 POP   ES
	 RET
COMPARE_AREAS ENDP



CHECK_OF_OK_TO_FAIL PROC NEAR
	 PUSH  SI
	 PUSH  DI
	 PUSH  ES
	 PUSH  CX

	 SUB   SI,32
	 LEA   AX,NAMES
	 MOV   ES,CS_SAVE

C_O_O_T_F_COMPARE:
	 PUSH  SI
	 MOV   DI,AX
	 MOV   CX,11
	 REPE  CMPSB
	 POP   SI
	 JE    C_O_O_T_F_CLC
	 ADD   AX,11
	 CMP   AX,OFFSET NAMES+22
	 JNA   C_O_O_T_F_COMPARE
	 STC
	 JMP   short C_O_O_T_F_EXIT

C_O_O_T_F_CLC:
	 CLC

C_O_O_T_F_EXIT:
	 POP   CX
	 POP   ES
	 POP   DI
	 POP   SI
	 RET

CHECK_OF_OK_TO_FAIL ENDP



HEX_TO_ASCII PROC NEAR
	 PUSH  DX
	 PUSH  BX
	 xor	dx,dx
	 MOV   BX,10
	 DIV   BX
	 MOV   AH,DL
	 OR    AX,3030H
	 POP   BX
	 POP   DX
	 RET

HEX_TO_ASCII ENDP



DISPLAY_SECTOR_NUM PROC NEAR
	 PUSH  AX
	 PUSH  BX
	 PUSH  CX
	 PUSH  DX
	 PUSH  DI
	 PUSH  BP

	 MOV   CX,7
	 MOV   AX,ABS_SECTOR_LO
	 MOV   DX,ABS_SECTOR_HI
	 MOV   WORD PTR H_E_SECTOR_NUM,'  '
	 MOV   WORD PTR H_E_SECTOR_NUM+2,'  '
	 MOV   WORD PTR H_E_SECTOR_NUM+4,'  '

	 LEA   DI,H_E_SECTOR_NUM+6
	 MOV   BX,10000 	  ;DIVIDE BY 10000
	 DIV   BX		  ; BREAK INTO 2 PARTS
	 MOV   BP,AX		  ; SAVE HI PART
	 MOV   AX,DX		  ; WORK ON LOW PART FIRST
	xor	dx,dx

	 MOV   SI,CX
	 SUB   SI,4
	 MOV   CX,4

	 MOV   BX,10

HEX_TO_ASCIIZ_DIV:
	 DIV   BX		  ;PERFORM DIVISION
;	 AX = QUOTIENT
;	 DX = REMAINDER
	 ADD   DL,30H		  ;MAKE RELATIVE TO ASCII ZERO
	 MOV   BYTE PTR [DI],DL   ;MOVE VALUE TO OUTPUT AREA
	 DEC   DI		  ;DECREMENT OUTPUT POINTER
	 xor   dx,dx		  ;ADJUST AX BACK TO 32 BIT NUMBER
	 or	ax,ax
	 jnz   HEX_TO_ASCIIZ_CONT
	or	bp,bp
	 jz    HEX_TO_ASCIIZ_EXIT

HEX_TO_ASCIIZ_CONT:
	 LOOP  HEX_TO_ASCIIZ_DIV

	 MOV   AX,BP
	xor	dx,dx
	 MOV   CX,SI
	xor	si,si
	xor	bp,bp
	 JMP   HEX_TO_ASCIIZ_DIV

HEX_TO_ASCIIZ_EXIT:
	 POP   BP
	 POP   DI
	 POP   DX
	 POP   CX
	 POP   BX
	 POP   AX
	 RET

DISPLAY_SECTOR_NUM ENDP
;
;
OFFSET_COMP EQU $

	 DB    'x:\'
	 DB    'MIRROR.FIL',0
	 DB    9 DUP(0)

;BACKUP_LSEEK EQU $-OFFSET_COMP
BACKUP_IND_OFFSET EQU $-OFFSET_COMP

	 DB    0
	 DW    0
	 ORG   OFFSET_COMP+26

R_IO_INFO_OFFSET EQU $-OFFSET_COMP

	 DB    16 DUP(0)
	 ORG   OFFSET_COMP+64

R_CTL_OFFSET EQU $-OFFSET_COMP
;
prog	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\rebuild\uf_last.asm ===
; Copyright 1990 Central Point Software, Inc. 
; All rights reserved.
prog	SEGMENT	para public
	ASSUME	CS:prog
	PUBLIC	last_byte
last_byte LABEL byte
prog	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\rebuild\uf_msg.asm ===
; Copyright 1990 Central Point Software. Inc. 
; All rights reserved.
;----------------------------------------------------
;
;       M001    MD      10/14/90        New help message, some text cleanup
; 12-06-90 GWD	Cleaned up MSG_INSERT_DISK.
; 12-06-90 GWD	Modified messages to handle partition restore on >2 drives.
;       M007    MD      02/21/91        Corrected help text error
;
; UnFormat.  Message module.
;
;----------------------------------------------------
prog	SEGMENT public
	ASSUME	CS:prog
;
	PUBLIC	yes_char, no_char, quit_char
	PUBLIC	delete_char, truncate_char, all_char
	PUBLIC	text_yes_length
	 PUBLIC TEXT_YES
;;	 PUBLIC INSERT_DRV
	 PUBLIC MSG_INSERT_DISK
	 PUBLIC MSG_I25_WRITEF
	 PUBLIC MSG_PARTN_QUERY
	 PUBLIC MSG_DELETE
	 PUBLIC MSG_WALK1
	 PUBLIC MSG_CROSSLINK
	 PUBLIC MSG_WALK2
	 PUBLIC MSG_REBOOT
;M005	 PUBLIC MSG_DIFF_DRIVES
	public	MSG_DIFF_DRIVES_SING
	public	MSG_DIFF_DRIVES_PLURAL
	public	msg_diff_parms
	 PUBLIC MSG_SURE
	 PUBLIC MSG_PNOBOOT
	 PUBLIC MSG_IGNORING
	 PUBLIC MSG_DOS12
	 PUBLIC MSG_EXAMINED_ENT
	 PUBLIC MSG_RP_DRV_QUERY
	public	msg_menu
	 PUBLIC MSG_MENU1
	 PUBLIC MSG_MENU2
	 PUBLIC MSG_USING_DRV
	 PUBLIC MSG_DOS16
	 PUBLIC MSG_DOS_EXTEND
	 PUBLIC MSG_I25_REQ
	 PUBLIC MSG_I25_GENERAL
	 PUBLIC MSG_FILE_ERR
	 PUBLIC MSG_VIA_TABLE
	 PUBLIC MSG_PARTN_SIZE
	 PUBLIC MSG_I25_SEEK
	 PUBLIC MSG_FILES_REC
	 PUBLIC MSG_PARTN_HEADER
	 PUBLIC MSG_DOS_HUGE
	 PUBLIC MSG_SEARCHING
	 PUBLIC MSG_READ
	 PUBLIC MSG_BIOS_ERR
	 PUBLIC MSG_I25_PAPER
	 PUBLIC MSG_WRITE_WARN
	 PUBLIC MSG_ASK_TRUNC
	 PUBLIC MSG_DIR
	 PUBLIC MSG_BAD_DRIVE
	 PUBLIC MSG_VOL
	 PUBLIC MSG_FAT_PROT
;M005	 PUBLIC MSG_PROGRESS
	public	MSG_PROGRESS_SING,MSG_PROGRESS_PLURAL
	 PUBLIC MSG_BAD_AA55
	 PUBLIC MSG_NO_HARD_DRIVES
	 PUBLIC MSG_OLD_PARTN
	 PUBLIC MSG_PARTN_REL
	 PUBLIC MSG_STRANGE_PARTN
	 PUBLIC MSG_DOS
	 PUBLIC MSG_FILES
	 PUBLIC MSG_I25_WRPROT
	 PUBLIC MSG_ABORT
	 PUBLIC MSG_NO_ACTION
	 PUBLIC MSG_I25_UNIT
	 PUBLIC MSG_BAD_PARMS
	 PUBLIC MSG_PARTN_EDGE
	 PUBLIC MSG_LISTP_TITLE
	 PUBLIC MSG_HELP
	 PUBLIC MSG_WARNING
	 PUBLIC MSG_ROOT_PROT
	 PUBLIC MSG_PBOOT
	 PUBLIC MSG_WRITE_FAKE
	 PUBLIC MSG_WRITE
	 PUBLIC MSG_STRANGE_DISK
	 PUBLIC MSG_PARTN_FROM_SEC
	 PUBLIC MSG_STOP_HUNT
	 PUBLIC MSG_PARTN_DATE
	 PUBLIC MSG_PRINT
	 PUBLIC MSG_I25_BAD_CMD
	 PUBLIC MSG_SUBDIRS_FOUND
	 PUBLIC MSG_NOTHING_FOUND
	 PUBLIC MSG_ERASE_FAT
	 PUBLIC MSG_DISK_PARMS
	 PUBLIC MSG_I25_NOT_READY
	 PUBLIC MSG_DONE
	 PUBLIC MSG_SYS_READ_ERR
	 PUBLIC MSG_I25_CRC
	 PUBLIC MSG_NEWER_VER
	 PUBLIC MSG_PATH
	 PUBLIC MSG_VIA_BIOS
	 PUBLIC MSG_ONLY
	 PUBLIC MSG_RP_PROMPT
	 PUBLIC MSG_ROOT_FILES
	 PUBLIC MSG_I25_READF
	 PUBLIC MSG_ERROR
	 PUBLIC MSG_ARROW
	 PUBLIC MSG_RP_TITLE
	 PUBLIC MSG_I25_MEDIA
	 PUBLIC MSG_ERASE_ROOT
	 PUBLIC MSG_NETWORK
	 PUBLIC MSG_TRUNC
	 PUBLIC MSG_SMALL_MEM
	 PUBLIC MSG_I25_RNF
;
cr	EQU	13
lf	EQU	10
;
; These characters (initials of words) are defined here to
; make foreign versions easier.  These definitions will effect
; the whole program.  Be sure that they match the translated
; messages in this file.  They MUST be in upper case.
;
yes_char	EQU	"Y"
no_char 	EQU	"N"
quit_char	EQU	"Q"
delete_char	EQU	"D"
truncate_char	EQU	"T"
all_char	EQU	"A"
;
;----------------------------------------------------------------------
; This entire message can now be translated.
;
; Notes:
;  1. The string named text_yes must be EXACTLY the same as the
;     example given in the prompt message.
;  2. The two 8's after "No" are backspaces.  They reposition the
;     cursor so that whatever the user types, it will overwrite the "No"
;     on the screen.  If the translation of "No" requires a different
;     number of characters, then the number of backspaces must be
;     changed to match the length of the foreign negative word.
;
;msg_sure	 DB	 cr,lf,"Are you SURE you want to do this?",cr,lf
;		 DB	 "If so, type in YES; anything else cancels.",cr,lf
;		 DB	 "? No",8,8,0
;;
;text_yes	 DB	 "YES"
;;
;text_yes_length EQU	 $-text_yes	 ;Do not change this.

msg_sure	DB	cr,lf,"Are you sure you want to do this?",cr,lf
		DB	"If so, press Y; anything else cancels.",cr,lf
		DB	"? N",8,0

text_yes	DB	"Y"

text_yes_length EQU	$-text_yes	;Do not change this.

MSG_INSERT_DISK DB cr,lf,"Insert disk to rebuild in drive @0a:",cr,lf
	DB	"and press ENTER when ready.",cr,lf,cr,lf,0

;----------------------------------------------------------------------
msg_warning LABEL byte
 DB cr,lf
 DB "  CAUTION !!",cr,lf
 DB "This attempts to recover all the files lost after a",cr,lf
 DB "format, assuming you've not been using the MIRROR command.",cr,lf
 DB "This method cannot guarantee complete recovery of your files.",cr,lf
 DB cr,lf
 DB "The search-phase is safe: nothing is altered on the disk.",cr,lf
 DB "You will be prompted again before changes are written to the disk.",cr,lf
 DB cr,lf,0
;
msg_bad_drive	DB	"Invalid or unspecified drive.",cr,lf,0
msg_dos 	DB	"Incorrect DOS version.",cr,lf,0
msg_network	DB	"Cannot process network drive.",cr,lf,0
msg_bad_parms	DB	"Invalid option(s).",cr,lf,0
msg_fat_prot	DB	"FAT will be preserved.",cr,lf,0
msg_root_prot	DB	"Root directory will be preserved.",cr,lf,0
msg_erase_fat	DB	"FAT will be replaced.",cr,lf,0
msg_erase_root	DB	"Root directory will be replaced.",cr,lf,0
msg_write_fake	DB	"Simulation only.",cr,lf,0
msg_strange_disk DB	"Cannot process a network, SUBST, or unrecognized disk.",cr,lf,0        ;M007
msg_small_mem	DB	"Not enough memory.",cr,lf,0
msg_no_action	DB	"No action taken.",cr,lf,0
msg_sys_read_err DB	"Cannot read system area of disk.",cr,lf,0                              ;M007
;
;------------------------------------------------------------------
msg_error	DB	"Error @1t sector# @2w@3wh, code @4wh@5t.",cr,lf,0
;
; The @1t will be replaced by one of the following.
;
msg_read	DB	"reading",0
msg_write	DB	"writing",0
;
; The @5t will be replaced by one of the following.
; The msg_i25_xxx were all added in v6.
;
msg_i25_wrprot	DB	" write-protect",0
msg_i25_unit	DB	" bad unit#",0
msg_i25_not_ready DB	" not ready",0
msg_i25_bad_cmd DB	" bad command",0
msg_i25_crc	DB	" data error",0
msg_i25_req	DB	" bad request structure",0
msg_i25_seek	DB	" bad seek",0
msg_i25_media	DB	" unknown media",0
msg_i25_rnf	DB	" sector not found",0
msg_i25_paper	DB	" no paper",0
msg_i25_writef	DB	" write fault",0
msg_i25_readf	DB	" read fault",0
msg_i25_general DB	" general failure",0
;
;------------------------------------------------------------------
; The first two characters must not be changed.
;
msg_arrow	DB	"^ Error",cr,lf,0
;
;------------------------------------------------------------------
; Each of these messages must be exactly nine characters long!
; All eight characters may be translated as needed.  For example,
; "<abcdefg>" would be OK.
;
msg_dir 	DB	"  <DIR>  "		; For sub-directory item.
		DB	0
msg_vol 	DB	"  <VOL>  "		; For disk volume label.
		DB	0
;
;------------------------------------------------------------------
msg_examined_ent DB	"Examined @0d root entries",cr,lf,0
;
msg_root_files	DB	"Files found in the root: @0d",cr,lf,0
msg_subdirs_found DB	"Subdirectories found in the root: @0d",cr,lf,0
;
msg_searching	DB	cr,lf,"Searching disk...",cr,lf,0
;
;M005 -- made the following into two separate messages
;M005msg_progress	DB	"@0d% searched, @1d subdir@1s found.",cr,0
;
;M007 -- Note that msg_progress_sing overwrites msg_progress_plural
; when the first subdirectory is found.  This leaves an artifact bit
; of text displayed.  To fix this, _sing must be the same length as
; _plural.  Here it is padded with blanks.  Translators beware!

msg_progress_sing   DB	"@0d% searched, 1 subdirectory found.    ",cr,0         ;M007
msg_progress_plural DB	"@0d% searched, @1d subdirectories found.",cr,0
;
msg_nothing_found DB "No files or subdirectories found for the root.",cr,lf,0
msg_abort DB	cr,lf,"* Cancelled by user *",cr,lf,0
msg_walk1 DB cr,lf,"Walking the directory tree to locate all files...",cr,lf,0
msg_walk2 DB cr,lf,"Checking for file fragmentation...",cr,lf,0
msg_crosslink DB "Deleting crosslinked file.",cr,lf,0
;
msg_only	DB	"Only @1l bytes are recoverable",cr,lf,0
;
;----------------------------------------------------------------------
; This is a prompt for user input.  The allowed English answers are:
;
; "DELETE" or "TRUNCATE" or "DELETE ALL" or "TRUNCATE ALL"
;
; Actually, only the initials of the words are checked by this program.
; So, either "D A" or "Dxxx Azzz" will be taken as "DELETE ALL".
;
; If the foreign translated key-words begin with other letters, then
; the message must indicate what initials the user should type.
; Be sure to change the definitions (EQU's) of delete_char,
; truncate_char and all_char to match the chosen initials.
;
msg_ask_trunc	DB	"Truncate or Delete this file? ",0
;
;----------------------------------------------------------------
msg_delete	DB	"File deleted.",cr,lf,0
msg_trunc	DB	"File size truncated.",cr,lf,0
msg_write_warn	DB "Warning!  The next step writes changes to disk.",cr,lf,0
;
msg_files	DB	lf,"Files found: @0d",cr,lf,0
;
msg_files_rec	DB	"@0d files recovered.",cr,lf,0
;
msg_done	DB	cr,lf,"Operation completed.",cr,lf,0
msg_stop_hunt	DB	cr,lf,"Finish remainder of search (Yes/No/Quit)? ",0
msg_ignoring	DB	"Ignoring this subdirectory.",cr,lf,0
msg_print	DB	"Printout will be sent to LPT1.",cr,lf,cr,lf,0
;

;M001 - new help message
;M004 - newer help message

msg_help  db    "Restores a disk erased by the FORMAT command or restructured by the RECOVER",cr,lf
          db    "command.",cr,lf
          db    cr,lf
          db    "UNFORMAT drive: [/J]",cr,lf
          db    "UNFORMAT drive: [/U] [/L] [/TEST] [/P]",cr,lf
          db    "UNFORMAT /PARTN [/L]",cr,lf
          db    cr,lf
          db    "  drive:   Specifies the drive to unformat.",cr,lf
          db    "  /J       Verifies that the mirror files agree with the system information",cr,lf
          db    "           on the disk.",cr,lf                                                                 ;M007
          db    "  /U       Unformats without using MIRROR files.",CR,LF
          db    "  /L       Lists all file and directory names found, or, when used with the",cr,lf 
          db    "           /PARTN switch, displays current partition tables.",cr,lf
          db    "  /TEST    Displays information but does not write changes to disk.",cr,lf
          db    "  /P       Sends output messages to printer connected to LPT1.",cr,lf
          db    "  /PARTN   Restores disk partition tables.",cr,lf,lf
          db    "MIRROR, UNDELETE, and UNFORMAT Copyright (C) 1987-1993 Central Point Software,",cr,lf
          DB	"Inc.",cr,lf,0

;M004 end

;
msg_path	DB	"Path=@0t\",cr,lf,0
msg_using_drv	DB	"Using drive @0a:",cr,lf,0
;
;--------------------------------------------------------------------------
; The following are messages for the PARTITION RESTORATION module.
;
msg_rp_title	DB	"Hard Disk Partition Table restoration.",cr,lf,0
msg_no_hard_drives DB	"No hard drives found.",cr,lf,0
msg_rp_prompt	LABEL byte
	DB	cr,lf
	DB	"Insert the disk containing the file PARTNSAV.FIL",cr,lf
	DB	"and type the letter of that disk drive.",cr,lf,0
msg_rp_drv_query DB	"What drive? A",8,0
msg_file_err	DB	"Error reading the file.",cr,lf,0
msg_newer_ver	DB	"Incompatible file version #.",cr,lf,0
;
;M005 -- made the following into two separate cases for singular/plural

;M005msg_diff_drives LABEL byte
;M005	DB	cr,lf
;M005	DB	"Warning!  Partitions were saved from @1d fixed disk@1s, "
;M005	DB	"but this system has @2d.",cr,lf,0

msg_diff_drives_sing LABEL byte
	DB	cr,lf
	DB	"Warning!  Partitions were saved from 1 fixed disk, "
	DB	"but this system has @2d.",cr,lf,0

msg_diff_drives_plural LABEL byte
	DB	cr,lf
	DB	"Warning!  Partitions were saved from @1d fixed disks, "
	DB	"but this system has @2d.",cr,lf,0

msg_diff_parms LABEL byte
	DB	cr,lf
	DB	"The saved information is incompatible with fixed disk @0d.",cr,lf
	DB	"Restoration is not possible; drive @0d is skipped.",cr,lf
	DB	7,cr,lf,0
;
msg_partn_date LABEL byte
 DB	cr,lf
 DB "Partition information was saved by MIRROR @1t, ",0
;
msg_old_partn DB	cr,lf
 DB	"Old partition information for fixed disk # @1d (DL=@2bh):"
 DB	cr,lf,0
;
msg_menu LABEL byte
 DB	cr,lf
 DB	"Options:  Q  =  Quit, take no action.",cr,lf,0
msg_menu1 LABEL byte
 DB	"          1  =  Restore the partitions for fixed disk 1.",cr,lf
 DB	cr,lf,0
msg_menu2 LABEL byte
 DB   "      1 - @0d  =  Restore partitions for one selected fixed disk.",cr,lf
 DB	"          A  =  Restore partitions for all fixed disks.",cr,lf
 DB	cr,lf
 DB	0
;
msg_partn_query DB	"Which option? Q",8,0
;
msg_bios_err LABEL byte
;;	DB	"** Disk error, BIOS code @0bh.",cr,lf,0
 DB	"** Disk error (BIOS code @1bh) at cylinder @2wh, drive @3bh.",cr,lf,0
;
msg_reboot LABEL byte
 DB "Operation completed.",cr,lf
 DB cr,lf
 DB "Insert a DOS boot disk in drive A and press ENTER to reboot...."
 DB 0
;
;----------------------------------------------------------------
; The following texts are for the LIST PARTITIONS option.  v5.00  12-7-88.
;
msg_listp_title DB	"Hard Disk Partition Table display.",cr,lf,0
;
msg_disk_parms LABEL byte
 DB	"Drive # @0bh has @1d cylinders, @2d heads, @3d sectors (from @4t)."
 DB	cr,lf,0
;
msg_via_bios	DB	"BIOS",0
msg_via_table	DB	"Table",0
;
msg_partn_from_sec LABEL byte
  DB	cr,lf
  DB	"The following table is from "
  DB	"drive @4bh, cylinder @1d, head @2d, sector @3d:"
  DB	cr,lf,0
;
msg_partn_header LABEL byte
 DB cr,lf
 DB "                Total_size       Start_partition   End_partition",cr,lf
 DB "   Type       Bytes   Sectors    Cyl Head Sector   Cyl Head Sector  "
 DB "   Rel#",cr,lf	; * Refers to 'Relative sector number'.
 DB "-----------  -----------------  ----------------  ----------------  "
 DB "----------",cr,lf
 DB 0
;
msg_dos16	DB	"DOS16 ",0		;Length must not change.
msg_dos12	DB	"DOS12 ",0		;Length must not change.
msg_dos_huge	DB	"HUGE  ",0		;Length must not change.
msg_dos_extend	DB	"EXTEND",0		;Length must not change.
msg_pboot	DB	"Boot  ",0		;Length must not change.
msg_pnoboot	DB	"      ",0		;Length must not change.
;
msg_strange_partn DB	" @1bh? @2bh?  ",0	;Do not translate.
msg_partn_size	DB	"@1r@2a @3l  ",0	;Do not translate.
msg_partn_edge	DB	"@1r@2r @3r  ",0	;Do not translate.
msg_partn_rel	DB	" @1l",cr,lf,0		;Do not translate.
;
msg_bad_AA55	DB	"Invalid boot record signature.",cr,lf,0
;
prog	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\rebuild\uf_partn.asm ===
; Copyright 1990 Central Point Software, Inc. 
; All rights reserved.
;------------------------------------------------------------
; This is the module of REBUILD/UnFormat which restores
; hard disk partition records (etc) from the file
; saved by the the new partn-saving module of MIRROR.
; Invoked by /PARTN
;
; Written by GWD.   10-31-88.	v5.00
;
; * New feature (12-6-88): "/PARTN /L" can now display
;   the partition tables currently on the hard disk.
;   Also improved the format of listing.
;
; * Bug fix 2-1-89.  During Restore, leading zero partn table
;   entries would prevent the table from being displayed.
;   Unused partn table entries are now skipped & used ones are shown.
;
; * 5-1-89.  Change the meaning of minor versions.  Now really only
;   a single digit.  The field in the save-file will be 'minor_digit,0'.
;
; * 10-10-89.  v5.6  Change meaning of that extra 0 byte after minor_ver.
;   Now it is the version number of the PARTNSAV.FIL structure (still 0).
;   This avoids the problems between different ver# of MIRROR & REBUILD.
;
; * 02-16-90.	v6.0 beta.  Now handles cylinder numbers > 1023.
;		/L checks parms via INT 41h/46h & shows them if valid.
;
; * 02-22-90.	v6.  When hard drive parms don't match the PARTNSAV.FIL,
;		we display the saved info anyway, before aborting.
;
; * 12-05-90	v6 for MSoft.  /PARTN now supports up to 8 hard drives.
;		New file structure: version = 1.
;
;-------------------------------------------------------
;
prog	SEGMENT public
	ASSUME	cs:prog, DS:prog
;
IFDEF	publics
%	INCLUDE	@FileName&.pub
ENDIF
	PUBLIC	restore_partitions, list_partitions
;
	PUBLIC	list_a_partition	;(Just for debug)
;
; In the _ORG module.
	EXTRN	top_of_mem:word, major_ver:abs, minor_ver:abs
;
; In the _MAIN module.
	EXTRN	stack_end_ptr:word, options:word
;
; The following are in the _IO module.
	EXTRN	getline:near, flushkey:near, printc:near, crout:near
	EXTRN	display:near, dis_word:word
	EXTRN	pr_text:near, ask_for_yes:near
	EXTRN	show_date:near, show_time:near
;
; The following are in the _MSG module.
	EXTRN	msg_small_mem:byte, msg_abort:byte
	EXTRN	msg_no_hard_drives:byte
	EXTRN	msg_rp_prompt:byte, msg_rp_drv_query:byte
	EXTRN	msg_file_err:byte, msg_newer_ver:byte

;	M005 -- made msg_diff_drives into separate singular & plural messages

	EXTRN	msg_diff_drives_sing:byte, msg_diff_parms:byte
	EXTRN	msg_diff_drives_plural:byte

	EXTRN	msg_partn_date:byte
	EXTRN	msg_old_partn:byte
	EXTRN	msg_menu:byte, msg_menu1:byte, msg_menu2:byte
	EXTRN	msg_partn_query:byte, msg_bios_err:byte, msg_reboot:byte
	EXTRN	msg_no_action:byte
	EXTRN	msg_disk_parms:byte
	EXTRN	msg_partn_from_sec:byte, msg_bad_AA55:byte
	EXTRN	msg_partn_header:byte
	EXTRN	msg_dos12:byte, msg_dos16:byte, msg_dos_extend:byte
	EXTRN	msg_dos_huge:byte, msg_strange_partn:byte
	EXTRN	msg_pboot:byte, msg_pnoboot:byte
	EXTRN	msg_partn_size:byte, msg_partn_edge:byte, msg_partn_rel:byte
	EXTRN	msg_via_bios:byte, msg_via_table:byte
	EXTRN	quit_char:abs, all_char:abs
;
	INCLUDE UF_INCL.INC
;
max_drvs EQU	8		;The number of hard drives we can support.
;
;---------------------------------------------------------------------
; The partition table is located at offset 1BEh in the sector.
; The signature is located at offset 1FEh (= 55h, AAh or word AA55h).
;
; This is the structure of a single element of a partition table.
;
partn_struc STRUC
partn_boot	DB	?	;80h means it's bootable.
partn_head	DB	?	;Starting head.
partn_cx	DW	?	;Starting cylinder & sector.
partn_sys	DB	?	;0=none, 1=FAT12, 4=FAT16, 5=Extended, 6=Huge.
partn_end_head	DB	?
partn_end_cx	DW	?	;Cylinder & sector # combined.
partn_rel	DW	?,?	;Relative sector.
partn_size	DW	?,?	;Count of sectors.
partn_struc ENDS
;
;--------------------------------------------------------------------
; This is the format in which we store the hard-drive parameters
; (in this program's variables and also in the saved file).
;
drive_parm_str STRUC
drive_number	DB	0
drive_max_head	DB	0
drive_max_cyl	DW	0	;Pure cylinder number.
drive_max_sector DB	0
		DB	?	;Not used.
drive_parm_str ENDS
;
;--------------------------------------------------------------------
; Version number of the structure in the PARTNSAV.FIL file.
; This MUST be updated if the file structure is changed!
; This number must match the one defined inside REBUILD (UF_PARTN.ASM).
;
file_struc_ver_old EQU	0	;0 is original version.
file_struc_ver	EQU	1	;1 is the first revision.  12-4-90 GWD.
;
;--------------------------------------------------------------------
; This header is placed at the beginning of the saved file.
;
header_structure STRUC
h_id		DB	0,0		;Should be CDh,20h (INT 20h).
h_name		DB	"MIRROR "
h_major		DB	?		;Major version number of MIRROR.
		DB	"."
		DB	?
h_struc_ver	DB	file_struc_ver
h_name2		DB	" saved partitions",1Ah
h_control	DB	0		;See bit flag definitions.
h_file_size	DW	0		;Size of PARTNSAV.FIL, in bytes.
h_drives	DW	0		;Number of physical hard drives.
h_parm_ptr	DW	0		;File offset (always in 1st sector).
;
; The following two pointers are valid only in the rev 0 structure.
; In newer revisions, use the H_LIST_POINTERS instead.  12-04-90 GWD.
h_list80_ptr_old DW	0	;File offset of start of List_structures.
h_list81_ptr_old DW	0	;File offset of list_structures for drv 81h.
;
h_min		DB	0		;Date & time of the save.
h_hour		DB	0
h_day		DB	0
h_month 	DB	0
h_year		DW	0
h_dos_ver	DW	0	;DOS ver# used during save (hi byte = major).
;
h_list_pointers	DW  max_drvs DUP (0)	;Ptrs to lists for drives 80h - 87h.
;
header_structure ENDS
;
IF	(512 - SIZE header_structure) LT (max_drvs * SIZE drive_parm_str)
	.ERR	; Header structure too big!  No room for list of drive parms.
ENDIF
;
;--------------------------------------------------------------------
; The general structure of the PARTNSAV.FIL
;
offset_of_header =	0
offset_of_drv_parms =	(SIZE header_structure)	;List of drive_parm_str's.
offset_of_lists =	1*200h	;Lists are in the second sector of the file.
offset_of_data	=	2*200h	;Data (sector copies) start at third sector.
;
;--------------------------------------------------------------------
; One of these will be present for each sector of data.  Each non-zero
; H_LIST_POINTER in the header points to a sequence of these items.
;
list_structure STRUC
l_dx		DW	0	;Bios location - drive & head.	0= list end.
l_cx		DW	0	;Bios location - cylinder & sector.
l_offset	DW	0	;File offset of the saved data.
l_ext_l 	DW	0	;File offset of list item for extended partn.
list_structure ENDS
;
;
;-------------------------------------------------------------------
; Bit flags inside H_CONTROL.
;
bit_has_boot	EQU	1	;DOS 4 logical boot record follows each partn.
bit_ps2_machine EQU	2	;Probably.  Look for drive parms in 2nd sect.
;
;-------------------------------------------------------------------
partn_buf_addr LABEL dword
partn_buf_offset EQU this word
		DW	0
partn_buf_seg	DW	?
;
list_offset	DW	?	;Offset in partn_buf_seg of current list item.
handle		DW	0	;DOS handle # for open file.
;
;-------------------------------------------------------------------
drive_parms LABEL word
	drive_parm_str (max_drvs) DUP ( <> )
;
;-------------------------------------------------------------------
header	LABEL word
	header_structure <,,major_ver+"0",,"M">
;
;-------------------------------------------------------------------
packed_date	DW	?
packed_time	DW	?
;
next_cx 	DW	1	;Bios-style mixed Cyl# & sector#.
next_dx 	DW	80h
;
phys_drive	DB	?	;A physical BIOS drive number (e.g., 80h).
;
phys_drive_count DB	0	;Number of BIOS hard drives we will process.
real_drive_count DB	0	;Number of hard drives actually installed.
;
p_filename	DB	"A:\PARTNSAV.FIL",0
;
;=================================================================
;
; Upon entry here, we know that the /PARTN option was selected.
;
restore_partitions PROC NEAR
	nop
	call	calc_dma_addr
	jnc	short enough_mem
	jmp	restp_exit
enough_mem:
	call	get_phys_parms
	jnc	restp_got_parms
	jmp	restp_exit
restp_got_parms:
	lea	dx,msg_rp_prompt
	call	pr_text
ask_for_drive:
	mov	p_filename,"A"
	lea	dx,msg_rp_drv_query
	call	pr_text
	call	getline
	jc	restp_esc
	jz	open_file	;Use default of A.
	cmp	al,"A"
	jb	ask_for_drive
	cmp	al,"Z"
	ja	ask_for_drive
	mov	p_filename,al
	sub	al,"A"		;Now 0=A, 1=B, etc.
	mov	bl,al		;Save requested drive.
	mov	ah,19h		;Get current drive.
	int	21h
	mov	bh,al		;Save current drive.
	mov	dl,bl
	mov	ah,0Eh		;Set default drive to requested one.
	int	21h
	mov	ah,19h		;Fetch it again, to check.
	int	21h
	push	ax
	mov	dl,bh
	mov	ah,0Eh		;Restore original default drive.
	int	21h
	pop	ax
	cmp	al,bl		;Did the Set succeed?
	jne	ask_for_drive	;No.  Ask again.
	jmp	short open_file
restp_esc:
	lea	dx,msg_abort
	call	pr_text
	jmp	restp_exit
file_error_close:
	call	close_file
file_error:
	lea	dx,msg_file_err
	call	pr_text
	jmp	restp_exit
close_exit:
	call	close_file
	jmp	restp_exit
open_file:
	lea	dx,p_filename
	mov	ax,3D00h	;OPEN for reading.
	int	21h
	mov	handle,ax
	jc	file_error
	mov	bx,ax
	push	ds
	mov	ds,partn_buf_seg
	xor	dx,dx
	mov	cx,512		;512 bytes.
	mov	ah,3Fh		;READ from file.
	int	21h
	pop	ds
	cld
	jc	file_error_close
	cmp	ax,cx
	jne	file_error_close
	mov	es,partn_buf_seg
	cld
	xor	bx,bx
	mov	word ptr header.h_id, 20CDh
	lea	si, header.h_id
	lea	di, [bx].h_id
	mov	cx,( h_major - h_id )
	repe cmpsb			;Compare strings CDh,20h,"MIRROR "
	jne	file_error_close
	lea	si, header.h_name2
	lea	di, [bx].h_name2
	mov	cx,( h_control - h_name2 )
	repe cmpsb			;Compare string " saved partitions",1A
	jne	file_error_close
	mov	al, es:[bx].h_major
	cmp	al,"5"			;/PARTN feature began in MIRROR v5.
	jl	file_error_close
	cmp	byte ptr es:[bx].h_struc_ver, file_struc_ver
	jbe	ver_ok
ver_bad:
	lea	dx,msg_newer_ver
	call	pr_text
	jmp	close_exit
ver_ok: lea	di,header
	push	ds
	push	es		;Swap DS,ES.
	pop	ds
	pop	es		;DS=partn_buf_seg, ES=our data seg.
	xor	si,si
	mov	cx,SIZE header_structure
	rep movsb		;Copy header into our local data structure.
	push	es
	pop	ds		;Restore DS.  Now DS=ES= our data.
	nop
	lea	bx,header
	mov	ax, [bx].h_drives
	mov	phys_drive_count,al
;
; Handle the old file format.
;
	mov	al, [bx].h_struc_ver
	cmp	al,file_struc_ver
	je	know_file_version	;It's not the old format.
	cmp	al,file_struc_ver_old
	jne	ver_bad
	mov	ax, [bx].h_list80_ptr_old
	mov	[bx].h_list_pointers,ax	;Copy old list pointers to new table.
	mov	ax, [bx].h_list81_ptr_old
	mov	[bx].h_list_pointers+2,ax
know_file_version:
;
; Re-arrange text of version # from header, for display.  Make it asciiz.
;
	mov	al, [bx].h_major+2
	mov	[bx].h_major+1, al
	mov	byte ptr [bx].h_major+2, 0
	lea	ax, [bx].h_major
	mov	dis_word+(2*1),ax
;
; The main module of this program already has Procs to
; display packed-format date & time, so we'll use them.
;
	mov	ax, [bx].h_year
	sub	ax,1980
	mov	cl,9
	shl	ax,cl
	mov	dx,ax
	mov	al, [bx].h_month
	mov	ah,0
	mov	cl,5
	shl	ax,cl
	or	dx,ax
	or	dl, [bx].h_day
	mov	packed_date,dx
;
	mov	al, [bx].h_hour
	mov	ah,0
	mov	cl,11
	shl	ax,cl
	mov	dx,ax
	mov	al, [bx].h_min
	mov	ah,0
	mov	cl,5
	shl	ax,cl
	or	dx,ax
	mov	packed_time,dx
;
; "Partn info was saved by Mirror @1t "   @1t is for the version # we've read.
;
	lea	dx,msg_partn_date
	call	display
	mov	ax,packed_date
	call	show_date
	mov	al," "
	call	printc
	mov	ax,packed_time
	call	show_time
	call	crout
;
	mov	bx,handle
	mov	cx,(2 + 26 + 26) * 512	;The most we'll need to read.
	push	ds
	mov	ds,partn_buf_seg
	mov	dx,512		;Offset just after first sector, already read.
	mov	ah,3Fh		;READ from file.
	int	21h
	pop	ds
	nop
	jnc	read2_ok
	jmp	file_error_close
read2_ok:
	call	close_file
;
	mov	bx, header.h_file_size
	add	ax,512		;Adjust, since we already read the 1st sector.
	cmp	ax,bx
	je	fsize_ok
	jmp	file_error
fsize_ok:
;
	mov	phys_drive,80h
	mov	cl,phys_drive_count
	mov	ch,0
	mov	es,partn_buf_seg
	lea	si, header.h_list_pointers
display_file_loop1:
	mov	bx,[si]			; ES:BX --> start of a list.
display_file_loop2:
	call	show_old_partitions
	jnc	disp_file_next
	jmp	restp_esc
disp_file_next:
	inc	phys_drive
	lea	si,[si+2]	; SI --> list pointer for next drive.
	loop	display_file_loop1
shown_all_file:
	mov	al,phys_drive_count	;From the file.
	mov	bl,real_drive_count	;As currently installed.
	cmp	al,bl
	je	show_menu
	jb	warn_drive_count
	mov	phys_drive_count,bl	;Use the smaller of the two counts.
warn_drive_count:
	mov	ah,0
	mov	bh,0
	mov	dis_word+(1*2),ax
	mov	dis_word+(2*2),bx

;	M005 -- made the following into separate singular/plural messages

; "WARNING! Saved info for @1d drive(s), but now found @2d."
	lea	dx,msg_diff_drives_sing
	cmp	al,1				; singular drive?
	jz	msg_diff_dr_singular
	lea	dx,msg_diff_drives_plural	; use plural form, then
msg_diff_dr_singular:

;	M005 -- end changes

	call	display
;
show_menu:
	lea	dx,msg_menu	;"Options:  Q  = ..."
	call	pr_text
	lea	dx,msg_menu1	;"1 = Restore fixed disk 1"
	mov	al,phys_drive_count
	cmp	al,1
	je	show_menu2
	mov	ah,0
	lea	dx,msg_menu2	;"1 - @0d = Restore selected disk"
show_menu2:
	call	display
;
;
; Note - this input query can handle responses only for drives 80 - 87h.
; This must be rewritten for more than 8 drives.
;
IF	max_drvs GT 8
	.ERR	; Too many drives for /PARTN option user prompt.
ENDIF
;
ask_for_option:
	lea	dx,msg_partn_query	;"Which option? Q"
	call	pr_text
	call	getline
	jc	restp_esc_stp
	jz	restp_quit
	cmp	al,quit_char
	je	restp_quit
	cmp	phys_drive_count,1
	je	ask_single
	cmp	al,all_char
	jne	ask_single
	mov	phys_drive,80h
	jmp	short restp_final_ask	;Leave phys_drive_count unchanged.
ask_single:
	sub	al,"0"
	jbe	ask_for_option
	cmp	al,phys_drive_count
	ja	ask_for_option
	dec	ax
	or	al,80h			;Convert to BIOS drive number.
	mov	phys_drive,al
	mov	phys_drive_count,1	;Only do one drive.
	jmp	short restp_final_ask
restp_quit:
	lea	dx,msg_no_action
	call	pr_text
	jmp	restp_exit
restp_esc_stp:
	jmp	restp_esc
restp_final_ask:
	call	ask_for_yes
	jc	restp_esc_stp
	jnz	restp_quit
;
restp_write:
	nop
;
; Arrive here once for each hard drive.  Before
; we attempt partition restoration, verify that
; this drive is really compatible with the saved data.
; If it's not, then we abort the operation.
;
restp_wr_drv_lp:
	mov	ah,(SIZE drive_parm_str)
	mov	al,phys_drive
	and	al,7Fh
	mul	ah
	lea	si,drive_parms		;DS:SI --> current drive parms.
	mov	es,partn_buf_seg
	cld
	mov	di, header.h_parm_ptr	;ES:DI --> saved drive parms.
	add	si,ax
	add	di,ax
	mov	cx,(SIZE drive_parm_str)
	repe cmpsb			;Drive parms must be the same.
	je	parms_match
	mov	al,phys_drive
	and	ax,007Fh
	inc	ax
	lea	dx,msg_diff_parms	;"Parms wrong for drive @0d; skipping"
	call	display
	jmp	short restp_wr_next_drv
parms_match:
	mov	bl,phys_drive
	and	bx,007Fh
	shl	bx,1
	mov	di, header.h_list_pointers [bx]	; ES:DI --> list_structure's.
restp_wr_sector_lp:
	call	flushkey
	jc	restp_esc_stp
	mov	cx, es:[di].l_cx
	mov	dx, es:[di].l_dx
	or	dx,dx
	jz	restp_wr_next_drv
	mov	bx, es:[di].l_offset	;Note ES = partn_buf_seg already.
	test	options, opt_wrfake	; /TEST option was used?
	jnz	restp_wr_next_sector	;Yes.  Just pretend we've written.
	mov	ax,0301h		;Write one sector to disk.
	int	13h
	jc	restp_wr_err
restp_wr_next_sector:
	add	di,SIZE list_structure
	jmp	restp_wr_sector_lp
restp_wr_next_drv:
	inc	phys_drive
	dec	phys_drive_count
	jz	restp_done
	jmp	restp_wr_drv_lp
restp_wr_err:
	mov	al,ah
	mov	dis_word+(1*2),ax	;Error #.
	call	get_cyl_from_cx_dh
	mov	dis_word+(2*2),ax	;Cylinder.
	mov	dis_word+(3*2),dx	;Drive.
; "BIOS error @1bh on cylinder @2wh, drive @3bh."
	lea	dx,msg_bios_err
	call	display
	jmp	short restp_exit
restp_done:
	lea	dx,msg_reboot	;Success.  Press Enter to reboot.
	call	pr_text
	call	flushkey
	call	getline
	jc	restp_exit
reboot: cli
	mov	ax,40h
	mov	es,ax
	nop
	mov	es:72h,1234h	;Flag to skip memory test.
	DB	0EAh		;JMP FFFF:0 (reset).
	DW	0
	DW	0FFFFh
restp_exit:
	ret
restore_partitions ENDP
;
;---------------------------------------------------------------------
; Display current partition tables from the hard disks.
;
 COMMENT @ Output will look like this:

Drive #80h has dddd cylinders, dd heads, dd sectors per track (via Bios).

The following table is from drive dd, cylinder dddd, head dd, sector dd:

		Total_size	 Start_partition   End_partition
   Type       Bytes   Sectors	 Cyl Head Sector   Cyl Head Sector     Rel#
-----------  -----------------	----------------  ----------------  ----------
DOS16  Boot  .ddddM ddddddddd  .dddd..ddd ...dd  .dddd..ddd ...dd   ddddddddd
EXTEND	     .ddddM ddddddddd  .dddd..ddd ...dd  .dddd..ddd ...dd   ddddddddd

 @ End of comment block.
;
;
; On entry here, we know that "/PARTN /L" was selected.
;
list_partitions PROC NEAR
	call	calc_dma_addr
	jnc	lparts_enough
lparts_x_stp:
	jmp	lparts_exit
lparts_enough:
	call	get_phys_parms
	jc	lparts_x_stp
;
	mov	phys_drive,80h
lparts_drive:
	call	crout
	mov	ah,SIZE drive_parm_str
	mov	al,phys_drive
	and	al,7Fh
	mul	ah
	mov	si,ax
	lea	ax,msg_via_bios
	call	show_hard_parms
	call	get_alternate_parms	;Maybe use parms from vectors 41h/46h.
	or	ax,ax
	jz	lparts_parms_shown
	call	show_hard_parms
lparts_parms_shown:
;
	mov	dl,phys_drive
	mov	dh,0
	mov	next_dx,dx
	mov	next_cx,1
lparts_sector:
	mov	dx,next_dx
	mov	cx,next_cx
	call	get_cyl_from_cx_dh
	mov	dis_word+(1*2),ax
	mov	al,dh
	and	ax,003Fh
	mov	dis_word+(2*2),ax
	mov	al,cl
	and	al,3Fh
	mov	dis_word+(3*2),ax
	mov	dis_word+(4*2),dx
;
;"The following table is from drive @4bh, cylinder @1d, head @2d, sector @3d:"
;
	lea	dx,msg_partn_from_sec
	call	display
	call	flushkey
	jc	lparts_esc
	les	bx, partn_buf_addr
	mov	cx,next_cx
	mov	dx,next_dx
	mov	ax,0201h
	int	13h
	jnc	lparts_rd_ok
	mov	al,ah
	mov	dis_word+(1*2),ax	;Error #.
	call	get_cyl_from_cx_dh
	mov	dis_word+(2*2),ax	;Cylinder.
	mov	dis_word+(3*2),dx	;Drive.
; "BIOS error @1bh on cylinder @2wh, drive @3bh."
	lea	dx,msg_bios_err
	call	display
	jmp	short lparts_exit
lparts_rd_ok:
	xor	ax,ax
	mov	next_cx,ax		;Assume there is no extended partn.
	mov	next_dx,ax
	cmp	word ptr es:1FEh, 0AA55h	;Correct signature?
	je	lparts_sig_ok
	lea	dx,msg_bad_AA55
	call	pr_text
	jmp	short lparts_exit
lparts_esc:
	lea	dx,msg_abort
	call	pr_text
	jmp	short lparts_exit
lparts_sig_ok:
	lea	dx,msg_partn_header
	call	pr_text
;
	mov	di,1BEh 		;ES:DI = partn table in the sector.
	mov	cx,4			;There are four table entries.
lparts_table:
	call	flushkey		;This detects Ctrl-S (pause) & ESC.
	jc	lparts_esc		;ESC key pressed.
	mov	al,es:[di].partn_sys
	cmp	al,0			;Unused partn?
	jz	lparts_tbl3		;Yes.
	cmp	al,5			;Extended partn?
	jne	lparts_tbl2		;No.
	mov	ax, es:[di].partn_cx	;Yes.
	mov	dh, es:[di].partn_head
	mov	dl,phys_drive
	mov	next_cx,ax			;Remember location for next.
	mov	next_dx,dx
lparts_tbl2:
	call	list_a_partition	;ES:DI points at the entry.
lparts_tbl3:
	add	di, SIZE partn_struc
	loop	lparts_table
	cmp	next_dx,0
	jz	lparts_next_drv
	jmp	lparts_sector
lparts_next_drv:
	mov	al,phys_drive
	inc	ax
	mov	phys_drive,al
	and	al,7Fh
	cmp	al,phys_drive_count
	jae	lparts_exit
	jmp	lparts_drive
lparts_exit:
	ret
list_partitions ENDP
;
;=========================  Sub-Procedures  ============================
;
; Calculate the buffer address which is safe for Bios DMA.
;
; On entry: uses STACK_END_PTR.
;
; On exit: if successful, then CF=false & PARTN_BUF_SEG is valid.
;	   If not enough memory, then a message is shown & CF=true.
;
; Destroys AX,BX,DX.
;
calc_dma_addr PROC NEAR
	mov	bx,stack_end_ptr
	mov	cl,4
	shr	bx,cl
	mov	ax,cs		;Use CS, since we are a .COM file.
	add	bx,ax
calc_dma_lp:
	mov	ax,bx
	mov	dx,bx
	add	ax,((3 + 26 + 26) * 512) / 16	;Room for max partnsav file.
	and	ax,0F000h
	and	dx,0F000h
	cmp	ax,dx			;In the same 64k physical bank?
	je	got_dma_addr		;Yes.
	add	bx,(512 / 16)		;Bump it up & try again.
	jmp	calc_dma_lp
got_dma_addr:
	add	bx,((3 + 26 + 26) * 512) / 16
	cmp	bx,top_of_mem
	jb	dma_addr_ok
	lea	dx,msg_small_mem
	call	pr_text
	stc
	jmp	short calc_dma_exit
dma_addr_ok:
	mov	partn_buf_seg,bx
	xor	ax,ax
	mov	partn_buf_offset,ax	;CF=false.
calc_dma_exit:
	ret
calc_dma_addr ENDP
;
;---------------------------------------------------------
; Get the hard drive parms from the Bios.
;
; On exit: if OK, then CF=false.
;	   If error, then message is shown and CF=true.
;
; Destroys AX,BX,CX,DX.
;
get_phys_parms PROC NEAR
	mov	phys_drive,80h
	stc
	mov	dl,phys_drive
	mov	dh,0
	mov	ah,8		;Get drive parameters.
	int	13h
	jc	get_pp_none
	or	ah,ah
	jnz	get_pp_none
	cmp	dl,0
	jle	get_pp_none
	cmp	dl,max_drvs
	jbe	get_pp_1
	mov	dl,max_drvs	;Ignore drives beyond max.
get_pp_1:
	mov	phys_drive_count,dl
	mov	real_drive_count,dl
	lea	bx,drive_parms
get_pp_loop:
	push	bx
	mov	dl,phys_drive
	mov	[bx].drive_number,dl
	stc
	mov	ah,8		;Get parms.
	int	13h
	pop	bx
	jc	get_pp_err
	call	store_parms
	lea	bx,[bx] + SIZE drive_parm_str
	mov	al,phys_drive
	inc	ax
	mov	phys_drive,al
	and	al,7Fh
	cmp	al,phys_drive_count
	jb	get_pp_loop
get_pp_ok:
	clc
	jmp	short get_pp_end
get_pp_err:
	mov	al,ah
	mov	dis_word+(1*2),ax	;Error #.
	mov	dis_word+(2*2),-1	;No cylinder.
	mov	dis_word+(3*2),dx	;Drive.
; "BIOS error @1bh on cylinder @2wh, drive @3bh."
	lea	dx,msg_bios_err
	call	display
	mov	al,phys_drive
	and	al,7Fh
	mov	phys_drive_count,al	;Truncate the drive scanning.
	mov	real_drive_count,al
	jnz	get_pp_end
get_pp_none:
	lea	dx,msg_no_hard_drives
	call	pr_text
	stc
get_pp_end:
	ret
get_phys_parms ENDP
;
;-------------------------------------------------------------------
; See if we should use the alternate drive parms via INT 41h/46h.
; But cannot ever use them for XT-type controllers.
;
; On entry: DRIVE_PARMS [SI] is the structure for the
;	    current drive (PHYS_DRIVE).
;
; On exit: if the vectored table parms are valid and they describe
;	   a larger drive, then we copy them into our parms and
;	   return [AX] --> asciiz message indicating vectored parms.
;
;	   Otherwise, we return AX=0.
;
; Destroys AX,BX,CX,DX,DI.  SI & ES are preserved.
;
get_alternate_parms PROC NEAR
	push	si
	push	es
	mov	dl,phys_drive
	cmp	dl,81h
	ja	get_alt_no
	mov	cx,-1		;Preload CX with illegal return value.
	stc
	mov	ax,15FFh	;Read DASD type.
	int	13h
	jc	get_alt_no	;Not supported.  Must be old XT-type card.
	cmp	ch,2		;CX legal?
	ja	get_alt_no	;Sector count >32 million (16 Gbyte) is silly.
	cmp	ah,3		;Type = hard disk?
	je	get_alt3
	cmp	ax,0003h	;Bug in Speedstore returns 3 in AX, not AH.
	je	get_alt3	;Yes, it's probably Speedstore.
	jmp	short get_alt_no	;Strange Bios.
get_alt3:
	mov	ax,0F000h
	mov	es,ax
	mov	al,es:0FFFEh	;Machine ID byte.
	cmp	al,0FEh 	;Old PC or XT?
	jae	get_alt_no
	cmp	al,0FBh 	;Newer XT?
	je	get_alt_no
	jmp	short get_alt_maybe
get_alt_no:
	xor	ax,ax
	jmp	short get_alt_ret
get_alt_maybe:
	xor	ax,ax
	mov	es,ax
	mov	di,41h
	cmp	phys_drive,80h
	je	get_alt_v
	mov	di,46h
get_alt_v:
	shl	di,1
	shl	di,1
	les	bx,es:[di]
	mov	ax,es
	or	ax,bx
	jz	get_alt_no		;Vector = 0:0.
	cmp	word ptr es:[bx+12],0	;Landing zone is valid?
	jle	get_alt_no
	mov	ax,es:[bx]		;Cylinder count (well, sort-of).
	cmp	ax,4096
	ja	get_alt_no
	sub	ax, drive_parms [si].drive_max_cyl
	cmp	ax,5			;Ignore tiny differences.
	jle	get_alt_no
	mov	al,es:[bx+2]		;Head count.
	cmp	al,64
	ja	get_alt_no
	cmp	al, drive_parms [si].drive_max_head
	jbe	get_alt_no
	mov	al,es:[bx+14]		;Sectors per track.
	cmp	al,0
	jle	get_alt_no
	cmp	al,63
	ja	get_alt_no
get_alt_yes:
	mov	ax,es:[bx]
	sub	ax,2
	mov	drive_parms [si].drive_max_cyl, ax
	mov	al,es:[bx+2]
	dec	ax
	mov	drive_parms [si].drive_max_head, al
	mov	al,es:[bx+14]
	mov	drive_parms [si].drive_max_sector, al
	lea	ax,msg_via_table
get_alt_ret:
	pop	es
	pop	si
	ret
get_alternate_parms ENDP
;
;------------------------------------------------------------------
; On entry: [AX] = asciiz message for source of drive parms.
;
; Drive # xxh has nnnn cylinders, nn heads, nn sectors per track (from Bios).
;
; SI is preserved.  Destroys AX,BX,CX,DX,DI.
;
show_hard_parms PROC NEAR
	mov	dis_word+(4*2),ax	;Use appropriate message.
	mov	ax, drive_parms [si].drive_max_cyl
	inc	ax
	mov	dis_word+(1*2),ax
	mov	ah,0
	mov	al, byte ptr drive_parms [si].drive_max_head
	inc	ax
	mov	dis_word+(2*2),ax
	mov	al, byte ptr drive_parms [si].drive_max_sector
	mov	dis_word+(3*2),ax
	mov	al,phys_drive
;
; "Drive #@0bh has @1d cylinders, @2d heads, @3d sectors per track"
; " (from @4t).",cr,lf
;
	lea	dx,msg_disk_parms
	call	display
	ret
show_hard_parms ENDP
;
;---------------------------------------------------------------
; Store drive parms from CX,DX values returned by INT 13h AH=8.
;
; AX is destroyed.
;
store_parms PROC NEAR
	mov	[bx].drive_max_head, dh
	call	get_cyl_from_cx_dh
	mov	[bx].drive_max_cyl, ax
	mov	ax,cx
	and	al,3Fh
	mov	[bx].drive_max_sector, al
	ret
store_parms ENDP
;
;----------------------------------------------------------
; On entry: DH=head, CX = cyl & sector in Bios packed format.
; On exit: AX = cylinder number (0 to 4095).
;
; Only AX is changed.
;
get_cyl_from_cx_dh PROC NEAR
	mov	al,cl
	mov	ah,dh
	and	ax,0C0C0h	;Two more cyl bits in DH (bits 6,7).
	rol	ah,1
	rol	ah,1
	shl	ax,1
	shl	ax,1
	mov	al,ch
	ret
get_cyl_from_cx_dh ENDP
;
;-----------------------------------------------------------
; Close the file handle.  All regs are preserved.
;
close_file PROC NEAR
	push	ax
	push	bx
	xor	bx,bx
	xchg	bx,handle
	or	bx,bx
	jz	closef2
	mov	ah,3Eh		;CLOSE.
	int	21h
closef2:
	pop	bx
	pop	ax
	ret
close_file ENDP
;
;------------------------------------------------------------------
; Display abbreviated partition info for one drive.
;
; On entry: PHYS_DRIVE is valid (e.g., 80h),
;	    ES:BX = address of our list_structure.
;
; On exit: If user pressed ESC then CF=true, else CF=false.
;
; Preserves BX,CX,SI,DS,ES.
;
show_old_partitions PROC NEAR
	push	bx
	push	cx
	mov	al,phys_drive
	mov	dis_word+(2*2),ax
	and	ax,7Fh
	inc	ax
	mov	dis_word+(1*2),ax
;
; "Old partition info for fixed disk # @1d (DL=@2bh):"
;
	lea	dx,msg_old_partn
	call	display
	lea	dx,msg_partn_header
	call	pr_text
showp_lp:
	call	flushkey
	jnc	showp_2
	lea	dx,msg_abort
	call	pr_text
	stc
	jmp	short showp_exit
showp_2:
	mov	ax, es:[bx].l_dx
	or	ax,ax
	jz	showp_end		;End of our table of LIST_STRUCTURES.
	cmp	al,phys_drive
	jne	showp_end		;No more for this drive.
	mov	di, es:[bx].l_offset	;Buffer offset of the sector.
	add	di,1BEh 		;Offset of partn table in the sector.
	mov	cx,4			;At most, 4 entries per table.
showp_find_nz:
	mov	al, es:[di].partn_sys
	cmp	al,0
	jz	showp_skip_0		;Skip empty entries.
	cmp	al,5			;Extended partn?
	je	showp_skip_0		;Skip that, too.
	call	list_a_partition
showp_skip_0:
	add	di,SIZE partn_struc
	loop	showp_find_nz
showp_3:
	mov	bx, es:[bx].l_ext_l
	or	bx,bx			;Any extended partn to look at?
	jnz	showp_lp		;Yes.
showp_end:
	clc
showp_exit:
	pop	cx
	pop	bx
	ret
show_old_partitions ENDP
;
;---------------------------------------------------------------------
; Display, on one line, all the info in a single partn table entry.
;
; On entry: ES:DI points at a partition table entry.
;
; Destroys AX.	Others preserved.
;
list_a_partition PROC NEAR
	push	cx
	push	dx
	mov	al, es:[di].partn_sys
	mov	ah, es:[di].partn_boot
	test	ah,NOT 80h		;Value should be 0 or 80h.
	jnz	lap_strange
	lea	dx,msg_dos12
	cmp	al,1
	je	lap_type
	lea	dx,msg_dos16
	cmp	al,4
	je	lap_type
	lea	dx,msg_dos_extend
	cmp	al,5
	je	lap_type
	lea	dx,msg_dos_huge
	cmp	al,6
	je	lap_type
lap_strange:
	mov	dis_word+(1*2),ax	;Sys ID byte.
	mov	al,ah
	mov	dis_word+(2*2),ax	;Boot ind. byte.
	lea	dx,msg_strange_partn	;" @1bh?  @2bh? ",0
	call	display
	jmp	short lap_size
lap_type:
	call	pr_text
	lea	dx,msg_pboot		;"Boot "
	cmp	byte ptr es:[di].partn_boot, 80h
	je	lap_boot
	lea	dx,msg_pnoboot		;Blanks.
lap_boot:
	call	pr_text
lap_size:
	mov	ax, es:[di].partn_size
	mov	dx, es:[di].partn_size+2
	mov	dis_word+(3*2),ax
	mov	dis_word+(4*2),dx
	shr	dx,1		;DX,AX = sector count.
	rcr	ax,1		;Convert to kbytes (assume 2 sectors/kbyte).
	or	dx,dx
	jnz	lap_size_m	;More than 64M.
	cmp	ax,1024 	;1 Megabyte or greater?
	jae	lap_size_m	;Yes.
	mov	cl,"K"
	jmp	short lap_size_store
lap_size_m:
	add	ax,200h 	;Add one-half of the divisor, for round up.
	adc	dx,0
	mov	cx,10
lap_size_shr:
	shr	dx,1		;Divide by 1024 to yield Megabytes.
	rcr	ax,1
	loop	lap_size_shr
	mov	cl,"M"
lap_size_store:
	mov	dis_word+(1*2),ax
	mov	byte ptr dis_word+(2*2),cl
	lea	dx,msg_partn_size
	call	display 		;" @1r@2a @3l  ",0
;
	mov	cx, es:[di].partn_cx
	mov	dh, es:[di].partn_head
	call	get_cyl_from_cx_dh
	mov	dis_word+(1*2),ax
	mov	al,cl
	and	ax,3Fh
	mov	dis_word+(3*2),ax
	mov	al,dh
	and	al,3Fh
	mov	dis_word+(2*2),ax	;AH is already 0.
	lea	dx,msg_partn_edge	;"@1r@2r @3r  ",0
	call	display
;
	mov	cx, es:[di].partn_end_cx
	mov	dh, es:[di].partn_end_head
	call	get_cyl_from_cx_dh
	mov	dis_word+(1*2),ax
	mov	al,cl
	and	ax,3Fh
	mov	dis_word+(3*2),ax
	mov	al,dh
	and	al,3Fh
	mov	dis_word+(2*2),ax
	lea	dx,msg_partn_edge	;"@1r@2r @3r  ",0
	call	display
;
	mov	ax, es:[di].partn_rel
	mov	dis_word+(1*2),ax
	mov	ax, es:[di].partn_rel+2
	mov	dis_word+(2*2),ax
	lea	dx,msg_partn_rel
	call	display
	pop	dx
	pop	cx
	ret
list_a_partition ENDP
;
;----------------------------------------------
prog	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\rebuild\uf_main.asm ===
; Copyright 1990 Central Point Software, Inc. 
; All rights reserved.
;---------------------------------------------------------
;  MAIN MODULE of "Unformat".
;  (see _ORG module source for linking info)
;  A utility to attempt recovery from
;  an accidental hard disk "Format".
;
;  Written by GWD.  June - August 1987.
;  Revised 9-29-87.
;  Upgraded for DOS 3.31 huge partitions, etc. 12-23-87.
;  Now uses 'include' file.
;  Shortened a little.	3-31-88.
;  Deals with changed DOS 4.xx DPB structure.  7-29-88.
;  Uses new, powerful 'display' procedure.  8-5-88.
;  Amended for new Restore_partition function.	v5.00  10-31-88.
;  Improved INT25h protocol determination.  v5.00  11-18-88.
;  New partition display function (/PARTN /L) added.  5.00 12-6-88.
;  Refuses to run under 5.x DOS.  5.10	1-4-89.
;  Cosmetic.  In walk, bad sub is now subtracted from path shown.  2-3-89.
;  Cosmetic.  Show_dir_info now shows time=0 as 12:00am, not 0:00am.  3-21-89.
;  Check_cluster proc now accepts 'de_zero' OR 'de_zapped' entries.  3-21-89.
;  Now checks for network drives (IBM & Novell).  5-1-89.
;  Added international support (date & time displays).	5-23-89.
;  Added display of names of INT 25h errors.  02-14-90	6.0 BETA.
;  READ_DISK, WRITE_DISK now return true error code.  02-15-90	6.0 BETA.
;
;       M000 MD 9/23/90         Removed display of copyright message
;       M001 MD 10/14/90        Removed display of no action message with help
;       M002 MD 10/29/90        Exit correctly when Mirror file not found
;
;----------------------------------------------------------
;
	.LALL			;List all macro def's.
prog	SEGMENT public para
	ASSUME	CS:prog, DS:prog
cr	EQU	13
lf	EQU	10
;
asm_message MACRO dy1,dy2,dy3,dy4,dy5,dy6
	%OUT	*MSG: dy1&dy2&dy3&dy4&dy5&dy6
	ENDM

	 PUBLIC PROGRESS
	 PUBLIC START
	 PUBLIC CLUSTER_INDEX
	 PUBLIC STACK_END_PTR
	 PUBLIC CLUSTER_CNT_PLUS_1
	 PUBLIC CURR_FNAME
	 PUBLIC OPTION_TABLE
	 PUBLIC HSUB_COUNT
	 PUBLIC OPTIONS

;
; The following are in the ORG module.
;
	EXTRN	top_of_mem:word, fcb1:byte, parms:byte
;;	EXTRN	banner:byte
;
; The following are in the I/O module.
;
	EXTRN	display:near, dis_word:word
	EXTRN	get_country_info:near
	EXTRN	printc:near, pr_text:near
	EXTRN	getline:near, flushkey:near, uppercase:near
	EXTRN	skipb:near, ask_trunc:near, tab:near
	EXTRN	pr_dec:near, pr_decl:near
	EXTRN	crout:near, pr_hex_word:near
	EXTRN	pr_hex_byte:near, ask_for_yes:near
	EXTRN	show_progress:near, show_dir_info:near
	EXTRN	copy_fname:near, display_options:near
	EXTRN	look_for_parms:near
;
	EXTRN	print_flags:byte, pf_allowed:abs
	EXTRN	pf_con_pe:abs, pf_ptime:abs, red_pointer:word
;
; The following are in the message (MSG) module.
;
	EXTRN	MSG_INSERT_DISK:BYTE
	EXTRN	yes_char:abs, no_char:abs, quit_char:abs
	EXTRN	msg_bad_parms:byte, msg_network:byte
	EXTRN	msg_write_fake:byte
	EXTRN	msg_warning:byte, msg_bad_drive:byte, msg_print:byte
	EXTRN	msg_dos:byte, msg_strange_disk:byte, msg_small_mem:byte
	EXTRN	msg_abort:byte, msg_no_action:byte
	EXTRN	msg_sys_read_err:byte, msg_read:byte, msg_write:byte
	EXTRN	msg_error:byte
	EXTRN	msg_examined_ent:byte
	EXTRN	msg_root_files:byte, msg_subdirs_found:byte
	EXTRN	msg_searching:byte, msg_stop_hunt:byte
	EXTRN	msg_nothing_found:byte
	EXTRN	msg_only:byte, msg_crosslink:byte
	EXTRN	msg_delete:byte, msg_trunc:byte, msg_ignoring:byte
	EXTRN	msg_walk1:byte, msg_walk2:byte, msg_write_warn:byte
	EXTRN	msg_files:byte, msg_files_rec:byte, msg_done:byte
	EXTRN	msg_help:byte, msg_using_drv:byte, msg_path:byte
	EXTRN	msg_rp_title:byte, msg_listp_title:byte
	EXTRN	msg_i25_wrprot:byte, msg_i25_unit:byte
	EXTRN	msg_i25_not_ready:byte, msg_i25_bad_cmd:byte
	EXTRN	msg_i25_crc:byte, msg_i25_req:byte
	EXTRN	msg_i25_seek:byte, msg_i25_media:byte
	EXTRN	msg_i25_rnf:byte, msg_i25_paper:byte
	EXTRN	msg_i25_writef:byte, msg_i25_readf:byte
	EXTRN	msg_i25_general:byte
;
	EXTRN	restore_partitions:near ;In 'partn' module.
	EXTRN	list_partitions:near
;
	EXTRN	j_rebuild:near		;In Jim's 'Rebuild' module.
;
	EXTRN	last_byte:byte		;In 'last' module.
;
	INCLUDE UF_INCL.INC
;
;--------------------------------------------------------------------------
; This is used to translate the INT 25h error codes into text.
;
i25_error_struc STRUC
i25_err_code	DB	-1
i25_err_ptr	DW	0	;Offset of asciiz message text.
i25_error_struc ENDS
;
;--------------------------------------------------------------------------
; The following are copied from the Disk Parm Block.
; They must remain contiguous & in this order!
;
dpb_start EQU $
;
drive		DB	-1	;0=A, 1=B, 2=C, etc.
		DB	?
sector_size	DW	?	; Bytes.
cluster_mask	DB	?	; [sectors/cluster] -1.
		DB	?	; Log2 [sectors/cluster].
fat_1st_sector	DW ?
fat_count	DB	?
root_entries	DW	?
first_data_sector DW ?
cluster_cnt_plus_1 DW	?	;This is also the max allowed cluster number.
fat_size	DW	0		;In sectors.  A byte, before DOS 4.xx.
dpb_length1 EQU ($-1) - dpb_start	;Include only the lo byte of FAT_SIZE.
dpb_mid EQU $
dir_1st_sector	DW ?
		DW	?,?	;Driver address.
media		DB	0	;F8h for a hard disk.
		DB	?	;-1 mefore media chk.
		DW	?,?	;Ptr to next DPB.
		DW	?	;Last allocated cluster.
		DW	?	;Free clusters.
;
dpb_length2 EQU $ - dpb_mid	;Excludes FAT_SIZE.
;
;------------------------------------------------------------------
	EVEN
root_sectors DW ?	;Derived from the DPB above.
cluster_size DW ?	;In sectors.
clusters DW	?	;Total clusters on disk, not count+1.
dirs_per_cluster DW ?	;# of dir entries that will fit in 1 subdir cluster.
fat16bit DB	0	;NZ means FAT is 16-bit type, 0 means 12-bit type.
;
;---------------------------------------------------------------------
; User-selected disposition of fragmented files.
;
frag_opt DB	"?"
;
;	"D"	Delete this one file, ask again for next.
;	"d"	Delete all such files, don't ask again.
;	"T"	Truncate (shorten) this file, ask again.
;	"t"	Truncate all such files, don't ask again.
;
; Caution - these are not global equates.  They are defined
; in this module and again, identically, in the I/O module.
;
;----------------------------------------------------------------------
; Flags derived from the command-line parameters.
;
options DW	0	;See include-file OPT_xxxxx equates.
;
;----------------------------------------------------------------------
; Miscellanious variables.
;
dos_ver DW	0	;E.g., for DOS 3.20, =0314h.
progress DW	0	;Percentage of disk 'hunt' completed.
;
free_root_entries DW 0	;Count.
free_root_entry DW 0	;Offset of first free (unused) root entry.
file_counter DW 0
rootsub_count DW 0	;Root-level subdirs.
hsub_count DW	0	;Subdirs found during HUNT (any level).
repeat	DW	0	;Used as loop counter in various places.
root_offset DW	0	;Offset of the root entry currently being processed.
cluster_index DW 0	;Selects a disk cluster.
;
;-----------------------------------------------------------------
; Variables used by directory tree walker.
;
tree_struc STRUC
tcluster0 DW	?	;First cluster of current directory (special: 0=root).
tcluster DW	?	;Current cluster of the current directory.
toffset DW	?	;Offset of an entry in the current cluster.
tree_struc ENDS
;
;
tree_level DW	-1	;Offset into TREE.
;
tree_size EQU	33	;Max allowed depth of subdirectory tree.
tree	LABEL word
	tree_struc tree_size DUP( <0,0,0> )
;
pathdrv DB	"Q:"
;
path	DB	66 DUP(0)	;ASCIIZ path name (e.g. "\SUBDIR.1\PROGS").
path_guard DB	-1
;
curr_fname DB	"current_.fil",0	;Temp storage for ASCIIZ file name.
;
clu_in_buffer DW -1	;# of cluster now in the cluster-segment (-1=none).
clu_dirty DB	0	;0=data unchanged.  NZ=data must be rewritten to disk.
;
;------------------------------------------------------------------------
;  This controls the protocol used for INT 25h/26h.
;
i25_protocol	DB	i25p_unknown
i25p_unknown	EQU	"?"		;Use old method.
i25p_old	EQU	"o"		;Use old method.
i25p_new	EQU	"n"		;Use NEW method.
;
; Parm block for DISK_READ and DISK_WRITE.  Keep together & in order!
	EVEN
sector_lo	DW	0
sector_hi	DW	0
sector_count	DW	1
dta		DW	0
dta_seg 	DW	0F000h
;
;-------------------------------------------------------------------------
fat_para DW	0	;Paragraphs required for FAT when in 16-bit format.
;
fat_seg DW	?	;Segments are determined at run-time, of course.
dir_seg DW	?
cluster_seg DW	?	;Room for 1 cluster only.  Used when hunting/walking.
stack_end_ptr DW ?	;Offset in CS (& SS) of free space beyond our stack.
;
prog_size DW	OFFSET last_byte	;Space used by the load module.
stack_size EQU	300
;
;
;=====================	Program Code begins  =======================
;
start:	nop
	cld
	sti
	mov	bx,prog_size
	lea	bx,[bx+stack_size]
	lea	sp,[bx]
	add	bx,31
	and	bl,0F0h
	mov	stack_end_ptr,bx
	xor	bx,bx
	push	bx
	mov	bp,sp
	xor	al,0FFh ;If drive is valid then AL becomes FF, else 0.
	and	fcb1,al ;If no drive was specified, FCB1 was already 0.
;
	lea	di,parms
	mov	bl,[di]
	inc	di
	mov	bh,0
	mov	[bx+di],bh	;Make sure parmline ends with a 0.
	mov	cx,bx
	cmp	cl,2
	jb	start2

	mov	al,"?"
	cld
	repne scasb		;Search parmline for "?".
	jne	start2		;For now, ignore other parms.

;	call	show_banner             ;M000
	jmp	short show_help

start2:
	MOV	AX,3306H		; get true DOS version
	MOV	BX,0			;   ala DOS 5.0
	INT	21H
	CMP	BL,5			; function supported?
	JB	START3
	MOV	AX,BX
	JMP	SHORT START4

START3:
	mov	ah,30h		;Get DOS version.
	int	21h

start4:
	xchg	al,ah
	mov	dos_ver,ax
;	cmp	ax,600h         RI-Don't need to check upper dos version
;	jae	wrong_dos
	cmp	ax,200h
	jae	dos_ok

wrong_dos:
	lea	dx,msg_dos
	call	pr_text
	jmp	exit

dos_ok: xor	ax,ax
	mov	options,ax	;Init all parm switches OFF.
	mov	print_flags,al
;
	call	get_country_info
;
	lea	si,parms+1	;Examine the command line.
	call	look_for_parms
         jc    bad_parms

         test  options,opt_j            ; if /J specified
	jz 	parms_ok                 ; that better be all 
         cmp   options,opt_j            ; that is specified
         je    parms_ok

bad_parms:
	lea	dx,msg_bad_parms
	call	pr_text
         jmp   exit                     ; don't show help message on bad cmd line

show_help:
	lea	dx,msg_help
	call	pr_text
	jmp	exit                    ;M001

bad_drive:
;	call	show_banner             ;M000

bad_drive2:
	lea	dx,msg_bad_drive
	call	pr_text
	jmp	exit

network_drive:
;	call	show_banner             ;M000
	lea	dx,msg_network
	call	pr_text
	jmp	exit

parms_ok:
	mov	ax,options
	test	ax, opt_partn
	jz	not_partn
;
; User has selected the /PARTN option, & possibly the /L (list) option.
;
;	call	show_banner             ;M000
	test	ax, NOT (opt_wrfake OR opt_partn OR opt_list)
	jnz	bad_parms
	lea	dx,msg_rp_title 	;"Partition Table restoration"
	test	ax, opt_list
	jz	show_partn_title
	lea	dx,msg_listp_title	;"Partition Table display"

show_partn_title:
	call	pr_text
	call	display_print_opt		;(If no /P, does nothing.)
	test	print_flags, pf_allowed 	;Was /P option selected?
	jz	do_partn			;No.
	mov	al,pf_con_pe
	or	al,pf_ptime			;Combine two extrn symbols.
	or	print_flags,al			;Activate printing now.

do_partn:
	call	display_options
	test	options, opt_list
	jnz	do_list_partn
	call	restore_partitions	;In _PARTN module.
	jmp	exit

do_list_partn:
	call	list_partitions 	;In _PARTN module.
	jmp	exit
;
; For cases other than /PARTN, we require a valid drive specifier.
;
not_partn:
	mov	al,fcb1
	cmp	al,0
	jz	bad_drive
	dec	al
	mov	drive,al
	add	al,"A"
	mov	pathdrv,al
;;	 MOV   INSERT_DRV,AL

	call	check_network_drive
	jc	network_drive

	 CALL  HAVE_DISKETTE_INSERTED

	mov	bx,options
	test	bx, NOT opt_j	;Any parms other than /J ?
	jnz	do_unformat	;Yes, must be meant for us.  Skip Jim's stuff.
	test	print_flags, pf_allowed
	jnz	do_unformat	;Print options means it's for us.

do_j:	mov	ah,0		;Assume no option.
	test	bx, opt_j
	jz	do_j2
	mov	ah,1		;Inform j_rebuild of the /J option.

do_j2:
	mov	bx,stack_end_ptr
	mov	al,drive
	nop
	call	j_rebuild	;Try Jim's Rebuild first.
	nop
	push	cs
	pop	ds
	push	cs
	pop	es
	cld
	sti
	mov	bp,sp
	cmp	al,1		;Jim's side completed successfully?
	je	j_exit		;Yes.  Nothing more to do.
        cmp     al,2            ;User terminated?       M002
        je      j_exit          ;                       M002
	cmp	al,6		;Panic exit?
	je	j_exit
	test	options, opt_j	;Jim's option?
	jnz	j_exit		;Yes.  Not for us.

;       mov	ah,0Fh		;Get video mode into AL.
;	int	10h
;	and	al,7Fh		;Clear the EGA keep_screen bit.
;	mov	ah,0		;Re-init, to same mode (erases screen).
;	int	10h

;  gotta first find how many lines to clear

        MOV   CX,184FH
        XOR   DX,DX
        MOV   AX,1130H
        XOR   BH,BH
        PUSH  CX
        INT   10H
        POP   CX

        CMP   DX,18H
        JBE   CLEAR_SCREEN
        MOV   CH,DL

CLEAR_SCREEN:
        MOV   AX,0600H
        MOV   BH,7
        MOV   DX,CX
        MOV   CX,0
        INT   10H                      ; clear screen
        MOV   AH,2
        MOV   DX,0
        MOV   BH,0
        INT   10H                      ; move cursor to 0,0

	jmp	short do_unformat
j_exit: jmp	exit
;
;-------------------------------------------------------------------
do_unformat:
;	call	show_banner     ;M000
	lea	dx,msg_warning
	call	pr_text
	mov	ah,2Ah		;Get date from DOS.
	int	21h		;Returns DH=month, DL=day, CX=year.
	mov	bx,cx		;Save year into BX.
	mov	al,dl
	mov	ah,0		;Need correct date for our subdir template.
	mov	si,ax		;Build it in SI.
	mov	al,dh
	mov	cl,5
	shl	ax,cl
	or	si,ax
	sub	bx,1980
	mov	cl,9
	shl	bx,cl
	or	si,bx
	mov	subdir.date, si
	call	display_print_opt
	or	print_flags, pf_con_pe
	mov	al,drive
	add	al,"A"
	lea	dx,msg_using_drv	;"Using drive @0a:",cr,lf
	call	display
	call	ask_for_yes	;"Are you SURE?  If so, type in YES."
	jnz	no_action
	call	look_for_parms	;Slash parms are allowed after the YES.
	jnc	parms2_ok
badp_stp:
	jmp	bad_parms
no_action:
	lea	dx,msg_no_action	;"No action taken".
	call	pr_text
	jmp	exit
parms2_ok:
	mov	ax,options
	test	ax, opt_j OR opt_partn	;These are not allowed here.
	jnz	badp_stp
get_drv_parms:
	cmp	dos_ver, 314h	;3.20?
	jb	get_dpb
	mov	bl,drive
	mov	bh,0
	inc	bx
	mov	ax,4409h
	int	21h
	jc	get_dpb
	test	dx,9200h	;Network, remote or SUBST?
	jnz	strange_disk
get_dpb:
	mov	dl,drive
	inc	dl
	mov	ah,32h		;Get Drive Parm Block (DPB) for drive DL.
	int	21h		;Returns addr in DS:BX.
	cmp	al,0FFh 	;Should never happen, but check anyway.
	jne	copy_drv_parms
	push	cs
	pop	ds
	jmp	bad_drive2
;
strange_disk:
	lea	dx,msg_strange_disk
	call	pr_text
	jmp	no_action
;
copy_drv_parms:
	push	cs
	pop	es
	cld
	lea	si,[bx+1]
	mov	di,OFFSET dpb_start+1	;Don't copy the drive byte.
	mov	cx,dpb_length1-1
	rep movsb
	cmp	cs:dos_ver,400h
	jb	copy_drvp2
	movsb				;Copy the high byte of FAT_SIZE.
	jmp	short copy_drvp3
copy_drvp2:
	inc	di			;Leave high byte of FAT_SIZE = 0.
copy_drvp3:
	mov	cx,dpb_length2
	rep movsb
	push	cs
	pop	ds
	mov	al,0
	cmp	cluster_cnt_plus_1, 4085
	jbe	know_fat_type
	mov	al,16h			;Non-zero means 16-bit FAT.
know_fat_type:
	mov	fat16bit,al
;
	cmp	root_entries,4096	;Root must fit inside a 64k segment.
	jb	rt_sz_ok
strange_stp:
	jmp	strange_disk
;
rt_sz_ok:
	mov	ax,cluster_cnt_plus_1
	cmp	ax,1
	jbe	strange_stp
	mov	bx,ax
	dec	bx		;BX = cluster count.
	mov	clusters,bx
	inc	ax		;One more, for number of FAT entries (C+2).
	cmp	ax,0FFF6h
	jae	strange_stp
	add	ax,7		;Provide for rounding up.
	mov	cl,3		;8 words (FAT entries) per paragraph.
	shr	ax,cl		;AX = paragraphs for the 16-bit FAT.
	mov	bx,sector_size
	test	bx,0F1FFh	;Allow 512, 1024 and 2048 byte sectors.
	jnz	strange_stp
	mov	cl,4
	shr	bx,cl		;BX = paragraphs per sector.
	xor	dx,dx
	div	bx		;Compute for whole-sector requirement.
	call	roundup
	mul	bx		;AX = paragraphs for 16-bit FAT.
	mov	fat_para,ax
;
	mov	ax,32
	mul	root_entries	;(32 bytes/entry) * #entries.
	jc	strange_stp	;Root dir exceeds 64k bytes.
	div	sector_size
	call	roundup
	mov	root_sectors,ax ;Number of sectors in root dir.
;
	mov	al,cluster_mask
	mov	ah,0
	inc	ax
	mov	cluster_size,ax
	mul	sector_size
	mov	cx,32
	div	cx
	mov	dirs_per_cluster,ax
;
; Check available memory and setup pointers to our FAT, Dir & cluster buffers.
; Bytes needed =
;	100h + program + stack + FAT16 (maybe 128k) + root + 1 cluster.
;
	mov	bx,stack_end_ptr	;The offset base of free space.
	mov	cl,4
	shr	bx,cl		;Convert to paragraphs.
	mov	ax,cs
	add	bx,ax		;BX:0000 points at 1st free byte.
	mov	fat_seg,bx
	add	bx,fat_para
	jc	small_mem
	mov	dir_seg,bx
	mov	ax,sector_size
	mul	root_sectors
	shr	ax,cl		;CL=4.
	add	bx,ax
	jc	small_mem
	mov	cluster_seg,bx
	mov	ax,cluster_size
	mul	sector_size
	shr	ax,cl
	add	bx,ax		;BX = para just above what we need.
	jc	small_mem
	cmp	bx,top_of_mem
	jb	enough_mem
small_mem:
	lea	dx,msg_small_mem
	call	pr_text
	jmp	exit
;
enough_mem:			;Now we clear all our memory buffers.
	mov	dx,fat_seg	;First (and lowest) buffer.
	sub	bx,dx		;Compute total paragraphs for our buffers.
	xor	ax,ax
	cld
clr_all_bufs:
	mov	es,dx
	xor	di,di
	mov	cx,8		;Eight words per paragraph.
	rep stosw
	inc	dx		;Next para.
	dec	bx
	jnz	clr_all_bufs
	push	cs
	pop	es
	nop
	test	print_flags, pf_allowed
	jz	show_opts
	or	print_flags, pf_ptime		;Turn on printing, now.
show_opts:
	call	display_options
;
; Determine which INT 25h/26h protocol is required.
;
	mov	ax,dos_ver
	mov	bl,i25p_old
	cmp	ax,(3*256)+30	;Older than 3.30 DOS?
	jb	init_25p	;Always use old method.
	mov	bl,i25p_unknown
	cmp	ax,(3*256)+40	;Older than 3.40 DOS?
	jb	init_25p
	mov	bl,i25p_new	;Always use new method.
init_25p:
	mov	i25_protocol,bl
	xor	ax,ax
	mov	sector_lo,ax
	mov	sector_hi,ax
	mov	dta,ax
	inc	ax
	mov	sector_count,ax
	mov	ax,fat_seg
	mov	dta_seg,ax
try_protocol:
	call	read_disk	;See if the chosen protocol really works.
	jnc	try_ok
	cmp	al,7		;Error = unknown media ?
	jne	try_strange
	mov	al,i25p_new
	xchg	al,i25_protocol
	cmp	al,i25p_unknown
	je	try_protocol
try_strange:
	jmp	strange_disk
try_ok: cmp	i25_protocol,i25p_unknown
	jne	read_fat
	mov	i25_protocol,i25p_old
	jmp	short read_fat
;
sys_read_err:
	lea	dx,msg_sys_read_err	;"Can't read system area of disk."
	call	pr_text
	jmp	no_action
;
; Read in the entire first FAT into our buffer.
;
read_fat:
	mov	ax,fat_1st_sector
	mov	sector_lo,ax
	xor	ax,ax
	mov	sector_hi,ax
	mov	dta,ax		;Might be more than 128 sectors, which
	mov	cx,fat_size	;complicates reading & FAT addressing.
	mov	sector_count,1	;So, we will read 1 at a time.
	mov	ax,fat_seg
	mov	dta_seg,ax
readf_lp:
	call	read_disk
	jc	sys_read_err
	mov	ax,sector_size
	add	dta,ax
	jnc	readf_next
	add	dta_seg,1000h	;Next 64k segment.
	mov	dta,0
readf_next:
	inc	sector_lo
	loop	readf_lp
;
	test	fat16bit,0FFh	;Disk FAT is already in 16-bit format?
	jnz	fat_is_16	;Yes.
	call	fat12_expand	;No, convert 12-bit format into 16-bit.
fat_is_16:
	mov	ax,options
	test	ax, opt_keep_fat
	jnz	read_root	;Leave the FAT intact.
	mov	dx,fm_bad
	test	ax, opt_erase_fat
	jz	orig_fat0
	mov	dx,fm_free
orig_fat0:
	mov	cx,clusters
	mov	di,2*2		;Begin with cluster 2 (doubled for offset).
	mov	bl,media
	mov	bh,0FFh
	mov	ds,fat_seg
	ASSUME	DS:nothing
	xor	si,si
	xor	ax,ax		;AX = FM_FREE.
	xchg	bx,[si] 	;Should be unchanged.
	cmp	bx,[si] 	;FAT media byte was intact?
	jne	orig_fat_lp	;No - clear all FAT entries (AX=0).
	mov	ax,dx		;Write all entries, unless they match AX.
orig_fat_lp:
	cmp	ax,[di] 	;Matches FM_BAD (or FM_FREE)?
	je	orig_fat_next	;Yes, leave this one unchanged.
	mov	[di],si 	;Clear all other FAT entries.
orig_fat_next:
	inc	di
	inc	di
	loopnz	orig_fat_lp	;Until CX=0 (done) or DI=0 (segment limit).
	jcxz	orig_fat_end
	mov	di,ds
	add	di,1000h	;2nd segment.
	mov	ds,di
	xor	di,di
	jmp	orig_fat_lp
orig_fat_end:
	ASSUME	DS:prog
	push	cs
	pop	ds
	nop
;
; Read the entire root directory into our buffer.
;
read_root:
	mov	ax,root_sectors
	mov	sector_count,ax
	xor	ax,ax
	mov	dta,ax
	mov	sector_hi,ax
	mov	ax,dir_1st_sector
	mov	sector_lo,ax
	mov	ax,dir_seg
	mov	dta_seg,ax
	call	read_disk
	jnc	root_rdok
	jmp	sys_read_err
;
root_rdok:
	mov	ax,options
	test	ax, opt_keep_root
	jnz	alrf_stp		;Leave root intact.
	test	options, opt_erase_root
	jz	examine_root
	mov	es,dir_seg
	cld
	xor	di,di
	mov	ax,sector_size
	shr	ax,1		;Words per sector.
	mul	root_sectors
	mov	cx,ax
	xor	ax,ax		;Clear the entire root dir to zeros.
	rep stosw
alrf_stp:
	jmp	alloc_root_files
;
; Examine the root directory in the buffer.
; 1 - Existing files and level_1 subdirs are not harmed.
; 2 - Deleted root files & dirs are discarded.
; 3 - Format-zapped (1st byte=0) level_1 subdirectories will live again.
; 4 - Format-zapped root files will live again.
; 5 - Entries zapped by CPS Formatter will live again (with correct 1st char).
; 6 - The root directory is packed.
;
examine_root:
	mov	ax,root_entries
	mov	repeat,ax		;This is the big loop counter.
	mov	free_root_entries,ax
	mov	es,dir_seg
	cld
;
examine_root_lp:
	mov	ax,root_offset
	mov	di,ax
	call	check_dir_entry 	;Returns AH=status, AL=attribute.
	test	ah, de_invalid OR de_sublink
	jnz	root_corrupted
	test	ah,de_zeros
	jz	exr_not_z		;Not all zeros.
	jmp	ex_root_done		;Root has been zeroed.
root_corrupted:
	mov	byte ptr es:[di],0	;End-of-dir mark.
	mov	ax,di
	mov	cl,5
	shr	ax,cl			;Figure how many.
	lea	dx,msg_examined_ent	;"Examined @0d root entries.",cr,lf
	call	display
	jmp	ex_root_done		;Ignore remainder of root.
exr_not_z:
	test	ah,de_zapsaved	;Zapped by CPS Formatter (recoverable)?
	jz	exr_not_zs	;No.
	mov	dl,es:[di].zapsav_loc
	mov	es:[di].filename, dl	;Restore the saved 1st character.
	push	ax
	push	di
	lea	di,[di].zapsav_loc
	mov	cx,zapsav_length
	mov	al,0
	cld
	rep stosb		;Clear the zap-save area (don't need it now).
	pop	di
	pop	ax
exr_not_zs:
	test	al,vol_attr
	jnz	resurrect_vol
	test	ah,de_deleted
	jnz	ignore_dir_entry
	mov	bx,es:[di].start_cluster

         TEST  AL,DIR_ATTR              ; if this is a sub-dir
         JNZ   EXR_CLU                  ; size is gonna be zero, branch
         MOV   CX,ES:[DI].FILE_SIZE
         OR    CX,ES:[DI].FILE_SIZE+2   ; is file size zero?
         JNZ   EXR_CLU                  ; no, branch
         OR    BX,BX                    ; yes and if starting clu iz not zero
         JNZ   IGNORE_DIR_ENTRY         ; jmp
         JMP   SHORT RESURRECT_FILE     ; otherwise, process the zero len file
           
EXR_CLU:
	cmp	bx,2			;Valid starting cluster?
	jb	ignore_dir_entry
	cmp	bx,cluster_cnt_plus_1
	ja	ignore_dir_entry
	test	al,dir_attr
	jnz	resurrect_dir
resurrect_file:
	inc	file_counter
	test	ah, de_live OR de_zapsaved
	jnz	decide_if_pack			;Accept name as-is.
	mov	byte ptr es:[di].filename, "F"	;Fix 1st char of name.
	jmp	short decide_if_pack
resurrect_vol:
	test	ah,de_zapsaved
	jnz	decide_if_pack			;Accept restored name.
ignore_dir_entry:
	jmp	short next_root_entry
resurrect_dir:
	inc	rootsub_count
	test	ah, de_live OR de_zapsaved
	jnz	decide_if_pack			;Don't alter the name.
	mov	byte ptr es:[di].filename, "D"	;Fix the lost 1st char.
	call	make_subdir_entry
	push	di
	lea	di,[di].extension
	lea	si,subdir.extension
	mov	cx,3
	rep movsb			;Change the extension only.
	pop	di
decide_if_pack: 			;Valid root entry accepted.
	test	options, opt_list	;First, should we display it?
	jz	decide_ip2		;No.
	call	show_dir_info
	call	crout
decide_ip2:
	dec	free_root_entries
	mov	si,free_root_entry
	add	free_root_entry,32
	cmp	di,si			;Need to relocate this dir entry?
	je	next_root_entry 	;No.
pack:	push	es		;We want all entries to be packed near
	pop	ds		;the beginning of the root directory.
	nop
	push	di
	xchg	di,si
	mov	cx,32/2
	rep movsw		;Relocate this directory entry.
	pop	di		;Recover the pointer to old location.
	push	di		;Resave it.
	mov	cl,32/2
	xor	ax,ax
	rep stosw		;Erase the old occurrance of this entry.
	pop	di
	push	cs
	pop	ds		;Restore DS=CS.
	nop
next_root_entry:
	add	root_offset,32
	dec	repeat
	jz	ex_root_done
	call	flushkey
	jc	ex_rt_abt
	jmp	examine_root_lp
ex_rt_abt:
	jmp	no_action
ex_root_done:
	xor	ax,ax
	cmp	ax,free_root_entries
	jz	alloc_root_files	;Root is full.
	mov	di,free_root_entry
	mov	es:[di],al		;End-of-dir mark.
;
; Count the files & subdirs in the root.  Also, maybe mark
; up the FAT, according to the root entry start_clusters.
;
alloc_root_files:
	xor	ax,ax
	mov	rootsub_count,ax	;We're going to count them again.
	mov	file_counter,ax
	mov	es,dir_seg
	xor	di,di
	mov	cx,root_entries
	mov	free_root_entries,cx
alloc_rtf_lp:
	mov	ax,di
	call	check_dir_entry
	test	ah, de_zapped OR de_zeros OR de_invalid
	jnz	alloc_rtf_done
	test	ah,de_live
	jz	alloc_rtf_next
	test	al,vol_attr
	jnz	alloc_rtf_next	;Don't count vol label as a file.
	test	al,dir_attr
	jnz	alloc_rtf_d
	mov	dx,fm_file_start
	inc	file_counter
	mov	ax,es:[di].file_size
	or	ax,es:[di].file_size+2
	jz	alloc_rtf_next		;Zero length file has no clusters.
	jmp	short alloc_rtf_st
alloc_rtf_d:
	mov	dx,fm_sub_start
	inc	rootsub_count
alloc_rtf_st:
	test	options, opt_keep_fat
	jnz	alloc_rtf_next		;We're only counting them.
	mov	ax,dx
	mov	bx,es:[di].start_cluster
	call	store_link
alloc_rtf_next:
	dec	free_root_entries
	add	di,32
	loop	alloc_rtf_lp
;
alloc_rtf_done:
	mov	ax,file_counter
	or	ax,rootsub_count
	jz	hunt1
	call	crout
	mov	ax,file_counter
	lea	dx,msg_root_files	;"Files found in root: @0d",cr,lf
	call	display
	mov	ax,rootsub_count
	lea	dx,msg_subdirs_found ;"Subdirectories found in root: @0d",crlf
	call	display
	or	ax,ax
	jz	hunt1		;No subs in root, positively MUST hunt.
	test	options, opt_keep_fat
	jz	hunt1		;No, must search the disk to locate subsubs.
	jmp	nowalk		;Yes, hunt and tree walk are not needed.
;
;----------------------------------------------------------
; Hunt across the disk, reading every data cluster,
; looking for ones which look like subdirectories.
;
hunt1:	lea	dx,msg_searching	;"Searching disk...",cr,lf
	call	pr_text
	mov	cluster_index,2
	mov	hsub_count,0
	mov	progress,0
	mov	ax,clusters
	mov	repeat,ax
;
h1_lp:	call	show_progress
	call	flushkey
	jnc	h1_no_esc
h1_esc: lea	dx,msg_stop_hunt ;"Complete remainder of search (Y/N/Q)? "
	call	pr_text
	call	getline
	jc	h1_esc		;Reject ESC here, since Q is allowed.
	jz	h1_esc		;No default - must enter something.
	cmp	al,yes_char
	je	h1_no_esc	;Continue search.
	cmp	al,no_char
	je	h1_answ_no
	cmp	al,quit_char
	jne	h1_esc		;Ask again.
	lea	dx,msg_abort	;"Cancelled"
	call	pr_text
	jmp	no_action
h1_answ_no:
	jmp	h1_done
h1_no_esc:
	mov	bx,cluster_index
	call	get_link	;Fetch FAT entry # BX.
	cmp	ax,fm_bad
	je	h1_next_clu_stp ;Skip cluster already marked bad.
	mov	ax,bx
	call	calc_sector	;Updates SECTOR_HI & SECTOR_LO.
h1_read_it:
	mov	ax,cluster_seg
	mov	dta_seg,ax
	mov	es,ax
	xor	di,di
	mov	dta,di
	mov	ax,cluster_size
	mov	sector_count,ax
	call	read_disk		;Read the entire cluster.
	jnc	h1_chk
	mov	bx,cluster_index
	mov	ax,fm_bad		;Mark it bad in the FAT.
	jmp	short h1_mod_fat
h1_chk: call	check_cluster		;Is this a subdirectory cluster?
	or	ax,ax
	jnz	h1_found_sub		;Yes, it is.
h1_next_clu_stp:
	jmp	short h1_next_clu
h1_found_sub:
	mov	dx,ax			;Save return code from CHECK_CLUSTER.
	call	get_link		;Get FAT entry currently there (#BX).
	test	options, opt_keep_fat	;FAT is assumed already valid?
	jz	h1_fsub 		;No, must build it.
	cmp	ax,fm_free		;Cluster is (should be) allocated?
	je	h1_next_clu_stp 	;No.  Believe valid FAT, ignore find.
	jmp	short h1_fsubc		;Maybe need a new root entry.
h1_fsub:
	or	ax,ax			;Free cluster (as expected)?
	jnz	h1_next_clu_stp 	;Ignore it, cluster already allocated.
h1_fsubc:
	mov	ax,dx
	cmp	ax,fm_sub_start 	;Is it the start of a subdir?
	je	h1_fsubd		;Yes.
	cmp	ax,fm_end		;Complete subdir in the cluster?
	je	h1_fsubd		;Yes.
	cmp	ax,fm_sub_nul		;Empty, but a complete subdir?
	jne	h1_mod_fat		;No.  Make no root entry.
h1_fsubd:
	cmp	bx, es:[di].start_cluster	;Self-link is correct?
	jne	h1_next_clu_stp 		;Wrong.  Ignore it.
	inc	hsub_count
	cmp	word ptr es:[di+32].start_cluster, 0	;Root level subdir?
	jz	h1_make_sub				;Yes.
h1_mod_fat:
	call	store_link		;BX= cluster #, AX= new FAT entry
	jmp	short h1_next_clu	;(if /KF, STORE_LINK did nothing).
h1_make_sub:
	test	options, opt_keep_root	;Root is already valid & protected?
	jnz	h1_next_clu		;Yes.
	call	store_link
	cmp	free_root_entries,0	;We need to create a root entry.
	jz	h1_done 		;Abnormal exit, root dir is full.
	inc	rootsub_count		;Another subdir in root.
	call	make_root_sub		;Create root subdir entry.
h1_next_clu:
	inc	cluster_index
	dec	repeat
	jz	h1_done
	jmp	h1_lp			;Keep looking.
;
h1_done:
	call	crout
	mov	ax,rootsub_count
	or	ax,file_counter
	jnz	show_hunt_results
	lea	dx,msg_nothing_found
	call	pr_text
	jmp	no_action
;
show_hunt_results:
	mov	ax,file_counter
	lea	dx,msg_root_files	;"Files found in root: @0d",cr,lf
	call	display
	mov	ax,rootsub_count
	lea	dx,msg_subdirs_found ;"Subdirectories found in root: @0d",crlf
	call	display
;
	test	options, opt_keep_fat
	jz	cleanup_fat
nowalk: lea	dx,msg_write_fake	;" changes not written to disk."
	test	options,opt_wrfake
	jnz	fp_ww
	lea	dx,msg_write_warn	;"Next phase writes to hard disk."
fp_ww:	call	pr_text 		;(This appears also at WALK_DONE.)
	call	ask_for_yes
	jnz	cancel_stp
	jmp	write_system_area
cancel_stp:
	jmp	no_action
;
cleanup_fat:
	call	link_subs	;Deal with all those FM_SUB_XXXs in the FAT.
;
;-----------------------------------------------------------------------
; Now, we walk the directory tree structure, twice.
;
; First walk:  Mark 'live'-file starting_clusters, verify tree structure.
;	       Display paths.  In verbose /L mode only, list each filename.
;
; Second walk:	1. Display paths.
;		2. Check file lengths.
;		3. If fragmented, prompt user.
;		4. Delete/truncate as selected, or complete the FAT chains.
;
walk_begin:
	lea	dx,msg_walk1
	call	pr_text
	mov	repeat,2
walk_tree:
	lea	di,tree
	mov	cx,((SIZE tree_struc) * tree_size)/2
	xor	ax,ax
	mov	file_counter,ax
	push	cs
	pop	es
	cld
	rep stosw		;First, set things up.
	mov	tree_level,ax
	mov	word ptr path,ax	;AX=0.
	mov	clu_dirty,al	;Buffer never modified in 1st walk.
	dec	ax		;AX=-1.
	mov	clu_in_buffer,ax
	mov	tree.toffset,ax ;Special value for beginning of dir.
	jmp	walk_show_path	;Show it, then jump to WALK_LP.
;
walk_abort:
	lea	dx,msg_abort
	call	pr_text
	jmp	exit

walk_lp:
	call	flushkey
	jc	walk_abort
;
	call	dir_walk	;Returns ES:DI=dir entry, & AX=result.
	jc	walk_dir_end
;
	mov	dl,es:[di]	;Just to see in debugger.
	test	ah, de_zeros OR de_zapped OR de_invalid
	jnz	walk_dir_end
	test	ah,de_deleted
	jnz	walk_lp 	;Ignore deleted entries.  Get another.
	test	ah,de_sublink	;Entries "." or ".."?
	jnz	walk_lp 	;Ignore them (already checked by DIR_WALK).
	test	al,vol_attr
	jnz	walk_lp 	;Ignore volume label (uses no disk space).
	test	al,dir_attr
	jnz	walk_subdir	;It's a subdirectory entry.
	mov	dx,es:[di].file_size
	or	dx,es:[di].file_size+2
;        jz	walk_lp 	;Ignore zero length file (no disk space).
         JNZ   WALK_NON0_FILE           ; non-zero file, branch
         CMP   REPEAT,2                 ; is it the first pass
         JE    WALK1C_STP               ; yes, jmp
         INC   FILE_COUNTER             ; no, increment the file counter
         JMP   WALK_LP                  ; and then jump
          
WALK1C_STP:
         JMP   WALK1C

WALK_NON0_FILE:
	cmp	repeat,2	;Must be a live file.  First walk or 2nd?
	je	walk1
	jmp	walk2
;
walk_subdir:
	mov	bx,es:[di].start_cluster	;For subdir_nul handling.
	call	add_to_path	;(also returns CHECK_CLU code)
	jc	walk_suberr
	cmp	ax,fm_sub_nul	;Empty-subdir FAT mark?
	jne	walk_show_path	;No.
	mov	ax,fm_end	;Since this subdir IS part of the
	call	store_link	;tree, change mark #BX to FM_END.
	jmp	short walk_show_path
walk_suberr:
	test	options, opt_list
	jz	walk_lp
	call	show_dir_info
	lea	dx,msg_ignoring ;"Ignoring this subdirectory."
	call	pr_text
	lea	dx,path 	;To see in debug.
	call	sub_from_path
	cmp	repeat,2		;Which walk?
	je	walk_lp 		;Walk1 - just ignore it.
	mov	byte ptr es:[di],0E5h	;Mark deleted in walk2.
	jmp	walk2_dirt		;Maybe dirtied the buffer.
walk_dir_end:
	cmp	tree_level,0	;Root level?
	jnz	walk_backup
	jmp	walk_done
walk_backup:
	lea	dx,path 	;To see in debug.
	call	sub_from_path
walk_show_path: 		;Arrive from WALK_TREE, _SUBDIR or _DIR_END.
	lea	ax,pathdrv
	lea	dx,msg_path	;"Path=@0t\",cr,lf
	call	display
	jmp	walk_lp
;
; This is done only during the first walk.
;
walk1:	mov	bx,es:[di].start_cluster
	call	get_link
	cmp	ax,fm_free		;Starting cluster is free?
	je	walk1b			;Yes.  Allocate it for this file.
	cmp	ax,fm_file_start	;Already start-of-file there?
	jne	walk_lp_stp		;No.  Ignore cross-link.
	cmp	tree_level,0		;This is a root level file?
	jz	walk1c			;Must've been marked by EXAMINE_ROOT.
walk_lp_stp:
	jmp	walk_lp 		;Error!  Ignore cross-link.
walk1b: mov	ax,fm_file_start
	call	store_link		;Allocate the starting cluster.
walk1c: inc	file_counter
	test	options, opt_list
	jz	walk_nv
	call	show_dir_info
	call	crout
walk_nv:
	jmp	walk_lp
;
; This is done only during the second walk.
;
walk2:	mov	bx,es:[di].start_cluster
	call	get_link
	cmp	ax,fm_file_start	;The expected FAT entry.
	jne	walk2_cross		;Must've detected crosslink in walk1.
	call	check_contig_free	;Returns CF, AX=#contiguous clusters.
	mov	cx,ax
	jc	walk2_frag		;Not enough.  File must be fragmented.
	inc	file_counter
	call	complete_chain		;File seems contiguous, so it's easy.
	jmp	walk_lp
walk2_cross:
	call	show_dir_info
	lea	dx,msg_crosslink	;"Deleting crosslinked file.",CRLF.
	call	pr_text
	mov	byte ptr es:[di],0E5h	;Delete only the directory entry.
	jmp	short walk2_dirt
walk2_frag:				;CX holds max contig clusters.
	call	show_dir_info		;File name, size, date & time.
	mov	ax,sector_size
	mul	cluster_size
	mul	cx
	mov	dis_word+(2*1),ax
	mov	dis_word+(2*2),dx
	lea	dx,msg_only		;"Only @1l bytes are recoverable",crlf
	call	display
	mov	al,frag_opt
	cmp	al,"d"			;Was 'ALL' previously specified?
	jae	walk2_td		;Yes, so don't ask again.
	call	ask_trunc		;"Truncate or delete this file?"
	jnc	walk2_savop
	jmp	walk_abort
walk2_savop:
	mov	frag_opt,al
walk2_td:
	call	uppercase
	cmp	al,"T"			;Delete or Truncate the file?
	je	walk_truncate
	lea	dx,msg_delete
	call	pr_text 		;"Deleting this file."
	mov	byte ptr es:[di],0E5h	;Mark deleted, in the directory.
	mov	bx,es:[di].start_cluster
	mov	ax,fm_file_del
	call	store_link		;Mark cluster to be freed, later.
	jmp	short walk2_dirt
walk_truncate:
	lea	dx,msg_trunc		;"Truncating this file."
	call	pr_text
	mov	ax,cluster_size
	mul	cx
	mul	sector_size		;Clusters * sect/clu * bytes/sect.
	mov	es:[di].file_size,ax	;Change size in directory entry.
	mov	es:[di].file_size+2,dx
	call	complete_chain		;CX = # of clusters.
	inc	file_counter
walk2_dirt:
	cmp	tree_level,0
	jz	walk2_dirt2	;Root directory is not in cluster buffer.
	mov	clu_dirty,-1	;We have modified data in the cluster buffer.
walk2_dirt2:
	call	crout
	jmp	walk_lp
;
walk_done:
	dec	repeat
	jz	walks_both_done
	mov	ax,file_counter
	lea	dx,msg_files	;lf,"Files found: @0d",cr,lf,lf
	call	display
	lea	dx,msg_write_warn	;"Next phase writes to hard disk."
	test	options, opt_wrfake
	jz	walk_warn
	lea	dx,msg_write_fake	;"/W not specified.  Writes faked"
walk_warn:
	call	pr_text
	call	ask_for_yes
	jz	walk_wr_yes
	jmp	no_action
walk_wr_yes:
	lea	dx,msg_walk2
	call	pr_text
	jmp	walk_tree
walks_both_done:
	xor	ax,ax
	call	read_sub_cluster	;Write last changes (if any) to disk.
	call	fix_fm_dels		;Deal with any FM_FILE_DELs in FAT.
	mov	ax,file_counter
	lea	dx,msg_files_rec	;cr,lf,"@0d files recovered."
	call	display
;
;
; Lastly, we write the new FAT and root directory to the hard disk.
;
write_system_area:
	nop			;A place to put a breakpoint.
	test	options, opt_keep_fat
	jnz	write_dir
	cmp	fat16bit,0
	jnz	write_fats	;Disk FAT is 16-bit, so leave it that way.
	call	fat16_compress	;Back to 12-bit format.
write_fats:
	mov	ax,fat_1st_sector
	mov	sector_lo,ax
	mov	al,fat_count
	mov	ah,0
	mov	repeat,ax
write_fat:
	xor	ax,ax
	mov	dta,ax
	mov	sector_hi,ax
	mov	ax,fat_seg
	mov	dta_seg,ax
	mov	cx,fat_size
	mov	sector_count,1
write_fat_sec:
	call	write_disk
	jc	exit
	mov	ax,sector_size
	add	dta,ax
	jnc	write_fat_next
	add	dta_seg,1000h
	mov	dta,0
write_fat_next:
	inc	sector_lo
	loop	write_fat_sec
	sub	repeat,1	;Is there a 2nd FAT?
	ja	write_fat	;Yes.
;
; Even if root is 'protected', it might be slightly modified.  Rewrite it.
;
write_dir:
	mov	ax,dir_seg
	mov	dta_seg,ax
	xor	ax,ax
	mov	dta,ax
	mov	sector_hi,ax
	mov	ax,dir_1st_sector
	mov	sector_lo,ax
	mov	ax,root_sectors
	mov	sector_count,ax
	call	write_disk
	jc	exit
;
all_done:
	lea	dx,msg_done
	call	pr_text
;
exit:	mov	ah,0Dh		;Flush DOS disk buffers.
	int	21h
	nop
	int	20h		;Terminate.  Return to DOS.
;
;==========================  Procedures  =============================
;
; Read (write) logical sectors into (from) memory.
;
; On entry: rw_parm block must be setup with sector_lo & hi,
;	    sector_count and dta (disk transfer address).
;
; On exit: If error then CF=true and AX=error code, else CF=false.
;	   Error messages and sector # are printed in here.
;
; Only AX is changed.
;
read_disk PROC NEAR
	mov	ah,"R"
	jmp	short rw_disk
write_disk PROC NEAR
	mov	ah,"W"
rw_disk:
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	bp
	cmp	ah,"R"
	je	rw_2
	test	options, opt_wrfake	;Faking writes?
	jz	rw_2
	jmp	rw_done 		;Faking.  Leave with CF=false.
rw_2:	push	ds
	mov	al,drive
	lea	bx,sector_lo
	mov	cx,0FFFFh
	mov	dx,cx
	cmp	i25_protocol,i25p_new
	je	rw_3
	mov	dx,sector_lo
	mov	cx,sector_count
	lds	bx,dword ptr dta
rw_3:	cmp	ah,"W"
	jne	rw_25
	lea	si,msg_write	;"writing"
	push	si
	int	26h
	jmp	short rw_4
rw_25:	lea	si,msg_read	;"reading"
	push	si
	int	25h
rw_4:	pop	cx		;Discard extra flags from stupid DOS.
	pop	si		;Recover ptr to error message part.
	pop	ds		;Recover DS.
	cld
	sti
	jnc	rw_done 	;No error.
	cmp	al,7		;Error = unknown media (wrong protocol)?
	jne	rw_show_err	;No, display it.
	cmp	i25_protocol, i25p_unknown
	je	rw_error	;Suppress err msg during protocol testing.
rw_show_err:
	mov	cx,ax		;Preserve error code into CX.
	mov	dis_word+(2*4),ax
	mov	dis_word+(2*1),si
	mov	ax,sector_hi
	mov	dis_word+(2*2),ax
	mov	ax,sector_lo
	mov	dis_word+(2*3),ax
	lea	si,int25_error_list
rw_find_err_lp:
	xor	bx,bx
	mov	al, [si].i25_err_code
	cmp	al,-1
	je	rw_found_err		;End of list, without match.  BX=0.
	mov	bx, [si].i25_err_ptr
	cmp	cl,al			;Matching error code?
	je	rw_found_err
	lea	si,[si] + SIZE i25_error_struc
	jmp	rw_find_err_lp
rw_found_err:
	mov	dis_word+(2*5),bx
	lea	dx,msg_error
;
; "Error @1t sector# @2w@3wh, code @4wh@5t.",cr,lf
;
; Error writing sector# 00000000h, code 0000h sector not found.
;
	call	display
	mov	ax,cx		;Recover error code.
rw_error:
	stc
rw_done:
	pop	bp
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	ret
write_disk ENDP
read_disk ENDP
;
;-------------------------------------------------------------------
; Calculate logical sector from cluster number.
;
; On entry: AX= cluster number (range 2 to nnnn).
; On exit: If in range then CF=false and SECTOR_HI & _LO are updated.
;	   If invalid cluster number then CF=true.
;
; All regs are unchanged.
;
calc_sector PROC NEAR
	push	ax
	push	dx
	mov	dx,cluster_cnt_plus_1
	cmp	dx,ax		;Carry true if Max < requested #.
	jb	calcsec_done
	sub	ax,2
	jb	calcsec_done	;Return with CF=true.
	mul	cluster_size
	add	ax,first_data_sector
	adc	dx,0		;Should always yield CF=false.
	mov	sector_lo,ax
	mov	sector_hi,dx
calcsec_done:
	pop	dx
	pop	ax
	ret
calc_sector ENDP
;
;------------------------------------------------------------------
; Read one entire subdirectory cluster into our cluster buffer.
; If current contents of our cluster buffer have been modified
; (CLU_DIRTY non zero), that data will be rewritten to disk before
; the new cluster is read from disk.
;
; On entry: AX=cluster number (special value 0 means
;	    just flush the buffer, don't read anything).
;
; On exit: If successful then CF=false.
;	   If error writing (fatal), CF=true and AX=FFFF (-1).
;	   If error reading, then CF=true and AX=DOS code.
;	   Only AX is changed.
;
read_sub_cluster PROC NEAR
	push	bx
	cmp	ax,clu_in_buffer	;Buffer already holds desired data?
	je	read_sclu_exit		;Yes.  Do nothing, return CF=false.
	mov	bx,ax			;Save cluster # into BX.
	mov	ax,cluster_seg
	mov	dta_seg,ax
	mov	dta,0
	mov	ax,cluster_size
	mov	sector_count,ax
;
	mov	ax,clu_in_buffer
	cmp	ax,-1			;Buffer contains any data?
	je	read_sclu		;None.
	cmp	clu_dirty,0		;Buffer holds modified data?
	jz	read_sclu		;No.
	call	calc_sector		;For the cluster NOW in buffer.
	call	write_disk		;Write modified data back to disk.
	mov	clu_dirty,0
	mov	ax,-1			;Assume write error.
	jc	read_sclu_exit		;Error while writing.
read_sclu:
	mov	clu_dirty,0
	mov	clu_in_buffer,-1
	mov	ax,bx
	or	ax,ax			;Special value for flush-only?
	jz	read_sclu_exit		;Yes, don't read anything.  CF=0.
	call	calc_sector		;For desired cluster.
	call	read_disk
	jc	read_sclu_exit
	mov	clu_in_buffer,bx
read_sclu_exit:
	pop	bx
	ret
read_sub_cluster ENDP
;
;----------------------------------------------------------------
; On entry: BX=cluster number, AX=new link value to be written.
; On exit: all regs preserved.
;
store_link PROC NEAR
	cmp	bx,cluster_cnt_plus_1
	ja	stlnk2		;Out of range.
	test	options, opt_keep_fat
	jnz	stlnk3		;Do nothing.
	push	bx
	push	ds
	push	ax
	mov	ax,fat_seg
	shl	bx,1		;FAT entries are words.
	jc	stlnk4		;Offset beyond the first 64k.
stlnk1: mov	ds,ax
	pop	ax
	mov	[bx],ax
	pop	ds
	pop	bx
	ret
stlnk2: nop
stlnk3: ret
stlnk4: add	ah,10h		;Next 64k segment.
	jmp	stlnk1
store_link ENDP
;
;-----------------------------------------------------------------
; On entry: BX = cluster number (2 to nnn).
; On exit: AX = FAT entry for that cluster.  Only AX is changed.
;
get_link PROC NEAR
	push	bx
	push	ds
	mov	ax,fat_seg
	shl	bx,1		;Scale by 2 for array of words.
	jc	gtlnk2		;Beyond the first 64k.	Next segment.
gtlnk1: mov	ds,ax
	nop
	mov	ax,[bx]
	pop	ds
	pop	bx
	ret
gtlnk2: add	ah,10h
	jmp	gtlnk1
get_link ENDP
;
;----------------------------------------------------------------
; On entry: BX = cluster number (2 to nnn).
; On exit: AX = FAT entry for that cluster.
;
; AX is changed.  SI and ES are destroyed.
;
get_link_fast PROC NEAR
	mov	ax,fat_seg
	mov	si,bx
	shl	si,1		;Scale by 2 for array of words.
	jc	gtlf2		;Beyond the first 64k.
gtlf1:	mov	es,ax
	mov	ax,es:[si]
	ret
gtlf2:	add	ah,10h		;Next seg.
	jmp	gtlf1
get_link_fast ENDP
;
;----------------------------------------------------------------
; Make a new subdir entry in the root directory.
; On entry: BX = starting cluster #.
; On exit: If successful then CF=false, else CF=true (too many).
;	   All regs preserved.
;
make_root_sub PROC NEAR
	push	ax
	push	cx
	push	si
	push	di
	push	es
	call	make_subdir_entry
	jc	make_rs_exit		;Give up - more than 999 subdirs.
	mov	subdir.start_cluster, bx
	mov	es,dir_seg
	nop
	mov	di,free_root_entry	;ES:DI = free root dir entry.
	lea	si,subdir
	mov	cx,32/2
	cld
	rep movsw			;Write the new root entry.
	sub	free_root_entries,1
	jbe	make_rs_done		;Full root, no end-of-dir mark needed.
	mov	free_root_entry,di	;Update ptr.
	mov	al,0
	stosb				;New end-of-dir mark in root.
make_rs_done:
	clc
make_rs_exit:
	pop	es
	pop	di
	pop	si
	pop	cx
	pop	ax
	ret
make_root_sub ENDP
;
;-----------------------------------------------------------------------
; Build a new subdirectory entry at SUBDIR (new ext #).
; Subdirectory name will be "SUBDIR.n".
; It's up to somebody else to copy it somewhere useful.
;
; On entry: nothing
; On exit: If number of subdirs exceeds 999, CF=true.  Else CF=false.
;
; No registers changed.
;
make_subdir_entry PROC NEAR
	push	ax
	push	di
	mov	ax,rootsub_count
	mov	di,999
	cmp	di,ax			;More than 3 decimal digits?
	jb	mksub_exit
	lea	di,subdir.extension
	xchg	di,red_pointer
	call	pr_dec			;Write decimal string.
	mov	red_pointer,di		;Shut off redirection of PRINTC.
	clc
mksub_exit:
	pop	di
	pop	ax
	ret
make_subdir_entry ENDP
;---------------------------------------------------------------------
; CHECK VALIDITY OF A DIRECTORY ENTRY.
;
; On entry: ES:AX points at a possible directory entry.
;
; On exit: AH returns the status of the directory entry
;
; de_zeros	All zeros (may be an unused dir entry).
; de_live	A valid live entry (file or subdir).
; de_deleted	Deleted entry (first byte of name = E5h).
; de_zapped	Zapped valid entry (first byte = 00).
; de_sublink	Entry "." or ".." (allowed only if input AX=0 or 32).
; de_zapsaved	Zapped by CPS Format, 1st char saved in 'reserved' area.
; de_invalid	Not valid (can't be a directory entry).
;
; Only combination of above bit flags used is DE_ZAPPED+DE_ZAPSAVED.
;
;    If AH= 'de_invalid' then AL=??,
;    else AH=status and AL= the file attribute byte.
;
; Only AX is changed.
;
check_dir_entry PROC NEAR
	push	bx
	push	cx
	push	si
	push	di
	push	ds
	push	es
;
	push	es
	pop	ds		;DS=ES=yonder.
	cld
	mov	bx,ax		;Offset of the entry to be examined.
	lea	di,[bx]
	xor	ax,ax		;AX = 0.  This also inits AH= DE_XXX unknown.
	mov	cx,32/2
	repz scasw		;Entire entry is zeros?
	jnz	chkd_res
	mov	ah,de_zeros	;And AL=0.
	jmp	chkd_exit
chkd_res:
	lea	di,[bx].dir_reserved
	mov	cx,10
	mov	al,0		;Reserved bytes should normally be zeros.
	repz scasb
	jz	chkd1		;They're all 0.  Do normal processing (AH=0).
	push	cs
	pop	ds		;DS=CS for CMPSB.
	nop
	lea	di,[bx].zapsav_loc+1
	mov	si,OFFSET zapsav_text
	mov	cx,zapsav_length
	repe cmpsb		;Is it the special mark from CPS Formatter?
	jne	chkd_invalid
	push	es
	pop	ds		;DS=ES=yonder, again.
	nop
	mov	ah,de_zapsaved	;Change AH from 0 to DE_ZAPSAVED.
;
chkd1:	test	[bx].file_attr, dir_attr
	jz	chkd_file
	cmp	byte ptr [bx], "."	;Special subdir linking entry?
	je	chkd_dots
chkd_file:				;Either file or normal subdir entry.
	lea	si,[bx].filename+1
	mov	cx,8+3-1	;Name + ext - 1.
chkd_lp:

ifdef DBCS		; ### if DBCS ###
	call	dbcs_chk_file
	jnc	@f			; if valid file name
	lea	si,[bx].filename+2	; try for 1st char is Double Byte
	mov	cx,8+3-2
	call	dbcs_chk_file
	jc	chkd_invalid		; if invalid
@@:

else			; ### if Not DBCS ###

	lodsb			;Fetch one char from filename.
	cmp	al," "
	jb	chkd_invalid	;Reject control chars in filename.
	call	chk_fnchar
	loopne	chkd_lp
	je	chkd_invalid
endif			; ### end if Not DBCS ###

;
; Seems OK, so far.  Now we check the first char of the filename.
;
	mov	al,[bx].filename
	cmp	al,0			;1st char could have special things.
	je	chkd_zapped
ifdef DBCS
	cmp	al,05
	jz	chkd_lead		; if this is converted lead byte E5h
endif
	cmp	al," "
	jb	chkd_invalid
	cmp	al,0E5h
	je	chkd_deleted
ifdef DBCS
	call	IsDBCSLeadByte
	jz	chkd_lead		; if this is lead byte
endif
	call	chk_fnchar
	je	chkd_invalid		;First char of filename is invalid.
ifdef DBCS
chkd_lead:
endif
	or	ah,de_live
	jmp	short chkd_get_attr
;
chkd_dots:
	test	byte ptr [bx].file_attr, vol_attr OR sys_attr OR hide_attr
	jnz	chkd_invalid
	mov	al,[bx].filename+1
	xor	cx,cx		;". " allowed only at offset 0 (1st entry).
	cmp	al," "
	je	chkd_blanks	;Entry is ". "
	mov	cl,32		;Allowed offset of ".." in a directory.
	cmp	al,"."
	jne	chkd_invalid	;2nd char is neither "." nor " ".
chkd_blanks:
	cmp	bx,cx		;Sublink is in the allowed position?
	jne	chkd_invalid
	or	ah,de_sublink
	lea	di,[bx].filename+2
	mov	al," "
	mov	cx,8+3-2
	repz scasb		;Remainder of subdir name is blanks?
	je	chkd_get_attr	;Yes - correct.
;
chkd_invalid:
	mov	ah,de_invalid
	jmp	short chkd_exit
chkd_zapped:
	or	ah,de_zapped
	jmp	short chkd_get_attr
chkd_deleted:
	or	ah,de_deleted
chkd_get_attr:
	test	ah,de_zapsaved
	jz	chkd_attr2
	test	ah,de_zapped	;Only allowed combo is DE_ZAPPED+DE_ZAPSAVED.
	jz	chkd_invalid
chkd_attr2:
	mov	al,[bx].file_attr
	test	al,vol_attr
	jnz	chkd_exit	;Start_cluster of volume label is ignored.
	test	ah, de_live OR de_sublink
	jz	chkd_exit
	mov	cx,[bx].start_cluster	;For some types, check this too.
	cmp	cx,cs:cluster_cnt_plus_1
	ja	chkd_invalid
;
chkd_exit:
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	cx
	pop	bx
	ret
check_dir_entry ENDP

ifdef DBCS
;---------------------------------------------------------------------
;
;	*** Check if file name is valid (DBCS supported) ***
;
;	input:	DS:SI = string address
;		CX = string length
;	output:	CF = 1 if invalid
;
dbcs_chk_file	proc	near
chkf_loop:
	lodsb
	call	IsDBCSLeadByte
	jnz	@f			; if not lead byte
	dec	cx
	jz	chkf_invalid		; if no tail byte
	lodsb				; get tail byte
	call	IsDBCSTailByte
	jnz	chkf_invalid		; if not tail byte
	jmp	short chkf_next
@@:
	cmp	al," "
	jb	chkf_invalid		; if control char
	call	chk_fnchar
	jz	chkf_invalid
chkf_next:
	loop	chkf_loop
	clc				; valid file name
	jmp	short chkf_ret
chkf_invalid:
	stc				; invalid file name
chkf_ret:
	ret
dbcs_chk_file	endp
endif

;-------------------------------------------------------------------
; Check if a character is legal for a filename (or extension).
; It is checked for lowercase, ascii>126 and against BAD_CHAR_LIST.
;
; On entry: AL= character under test.
; On exit: If char is allowed then ZF=false.
;	   If illegal then ZF=true.
;
; DI is destroyed.
;
chk_fnchar PROC NEAR
	push	cx
	push	es
	push	cs
	pop	es
	cld
	cmp	al,7Eh
	ja	chkfnc_err
	cmp	al,"a"
	jb	chkfnc1
	cmp	al,"z"		;Lowercase letters are illegal.
	jb	chkfnc_err
chkfnc1:
	mov	di,OFFSET bad_char_list
	mov	cl,bad_char_length
        xor     ch,ch
	repne scasb
chkfnc_done:
	pop	es
	pop	cx
	ret
chkfnc_err:
	cmp	al,al		;Set ZF=true for a bad character.
	jmp	chkfnc_done
;
there	=$
bad_char_list DB '."/\[]:|<>+=;,'
bad_char_length =$-there
;
chk_fnchar ENDP
;---------------------------------------------------------------------
; On entry: CLUSTER_SEGment is assumed to contain a
;	    disk cluster for examination.
;
; On exit: AX returns a code (usually the suggested FAT entry)
;	0	     =	Not a valid subdirectory.
;	FM_END	     =	complete subdir in this cluster.
;	FM_SUB_START =	with "." & "..", but no 00 end-of-dir mark.
;	FM_SUB_MID   =	partial: missing both ".." and end-mark.
;	FM_SUB_TAIL  =	partial: no "..", but with end-mark.
;	FM_SUB_NUL   =	complete, but without any live files.
;
; If fm_sub_start, _end or _nul is returned, the caller should examine
; the start_cluster values in the 1st and 2nd entries ("." & "..").
;
; Only AX is changed.
;
check_cluster PROC NEAR
	push	bx
	push	cx
	push	dx
	push	es
	mov	es,cluster_seg
	xor	bx,bx		;Begin at offset 0 in the cluster segment.
	xor	dx,dx		;State flags.
	mov	cx,dirs_per_cluster
chcl_lp:
	mov	ax,bx		;AX = offset into cluster_seg.
	call	check_dir_entry
	test	ah, de_invalid OR de_zapsaved
	jnz	chcl_not_sub
	test	al,vol_attr
	jnz	chcl_not_sub	;Volume label not allowed in subdir.
	test	dh, de_zeros OR de_zapped	;Already found one zero entry?
	jz	chcl_next			;Not yet.
	test	ah, de_zeros OR de_zapped	;Remainder should be 0, too.
	jz	chcl_not_sub
chcl_next:
	or	dh,ah		;Accumulate status bits.
	add	bx,32
	loop	chcl_lp
	test	dh, de_sublink
	jz	chcl_not_start	;No "." and ".." entries.
	mov	ax,fm_sub_start
	test	dh, de_zeros OR de_zapped ;Was end-of-dir mark (0) found?
	jz	chcl_done		;No.  May be only part of a subdir.
	mov	ax,fm_sub_nul	;Assume null.
	test	dh,de_live	;Any live entries?
	jz	chcl_done	;None.	Deleted or empty complete subdir.
	mov	ax,fm_end	;Complete subdir in this cluster!
	jmp	short chcl_done
chcl_not_start:
	test	dh,de_live	;Any live entries?
	jz	chcl_not_sub	;None.	We'll ignore it.
	mov	ax,fm_sub_mid
	test	dh, de_zeros OR de_zapped ;Was the end-of-dir mark (0) found?
	jz	chcl_done		;No.
	mov	ax,fm_sub_tail
	jmp	short chcl_done
chcl_not_sub:
	xor	ax,ax
chcl_done:
	pop	es
	pop	dx
	pop	cx
	pop	bx
	ret
check_cluster ENDP
;
;--------------------------------------------------------------------
; Convert a 12-bit FAT in memory to 16-bit FAT format.
;
; The FAT_segment must be large enough to hold the 16-bit version.
;
fat12_expand PROC NEAR
	push	ax
	push	cx
	push	si
	push	di
	push	es
	mov	ax,cluster_cnt_plus_1	;Also = the max cluster number.
	mov	di,ax
	shl	di,1			;DI = 2 * max.
	mov	si,ax
	shr	si,1
	add	si,ax			;SI = 1.5 * max.
	mov	es,fat_seg
	nop
	mov	cl,4
	test	al,1			;Even or odd?
	jz	f12e_get2
f12e_lp:
	mov	ax,es:[si]		;Loop begins with the odd # entry.
	dec	si
	shr	ax,cl			;CL=4.
	cmp	ax,0FF6h		;4086.
	jb	f12e_store1
	mov	ah,0FFh
f12e_store1:
	mov	es:[di],ax
	dec	di
	dec	di
f12e_get2:
	mov	ax,es:[si]		;Fetch the even entry.
	dec	si
	dec	si
	and	ax,0FFFh
	cmp	ax,0FF7h
	jb	f12e_store2
	mov	ah,0FFh
f12e_store2:
	mov	es:[di],ax
	dec	di
	dec	di
	cmp	si,di		;Done yet?
	jne	f12e_lp
	pop	es
	pop	di
	pop	si
	pop	cx
	pop	ax
	ret
fat12_expand ENDP
;---------------------------------------------------------------
; Convert the 16-bit FAT in memory to 12-bit format.
;
;
fat16_compress PROC NEAR
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	es
	mov	bx,cluster_cnt_plus_1	; = max cluster number.
	inc	bx			;Count = max +1.
	mov	es,fat_seg
	cld
	xor	si,si
	xor	di,di
	mov	cl,4
f16c_lp:
	mov	ax,es:[si]
	and	ax,0FFFh
	inc	si
	inc	si
	mov	dx,es:[si]
	inc	si
	inc	si
	shl	dx,cl		;CL=4.
	or	ah,dl
	mov	es:[di],ax
	inc	di
	inc	di
	mov	es:[di],dh
	inc	di
	sub	bx,2
	ja	f16c_lp
;
	mov	ax,fat_size
	mov	bx,sector_size
	shr	bx,1
	mul	bx		;# words in 12-bit FAT.
	mov	cx,ax
	mov	ax,di
	inc	ax		;Round up.
	shr	ax,1		;Convert offset to word count.
	sub	cx,ax		;Words beyond 12-bit format of FAT.
	jbe	f16c_done
	xor	ax,ax
	rep stosw		;Clear out the now unused part.
f16c_done:
	pop	es
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
fat16_compress ENDP
;
;-----------------------------------------------------------------
; Scan the FAT (in forward direction) for a value.
;
; On entry: AX = FAT entry value to search for,
;	    DI = 1st cluster number to examine.
;
; On exit: If found then ZF=true and AX=cluster number.
;	   If not found then ZF=false and AX=?
;
; AX, SI & ES are changed.
;
scan_fat PROC NEAR
	push	bx
	push	cx
	push	dx
	mov	bx,di		;Beginning cluster #.
	mov	cx,cluster_cnt_plus_1	;Also = max cluster #.
	sub	cx,bx
	jb	scanf_done	;Leave with ZF=false, AX unchanged.
	inc	cx		;Count = 1 + max - beginning.
	mov	dx,ax		;Save value to hunt for.
	dec	bx		;Setup for pre-increment.
scanf_lp:
	inc	bx
	call	get_link_fast
	cmp	ax,dx
	loopne	scanf_lp
	mov	ax,bx		;Return cluster number (=? if ZF=false).
scanf_done:
	pop	dx
	pop	cx
	pop	bx
	ret
scan_fat ENDP
;
;---------------------------------------------------------------
; Scan the FAT (in backward direction) for a value.
;
; On entry: AX = FAT entry value to search for,
;	    DI = 1st cluster # to examine.
;
; On exit: If found then ZF=true and AX=cluster number.
;	   If not found then ZF=false and AX=?
;
; AX, SI & ES are always changed.
;
scan_fat_r PROC NEAR
	push	bx
	push	cx
	push	dx
	mov	bx,di
	mov	cx,di
	sub	cx,2
	jb	scanfr_done
	inc	cx
	inc	bx		;Setup for pre-decrement.
	mov	dx,ax		;Save desired value.
scanfr_lp:
	dec	bx
	call	get_link_fast
	cmp	ax,dx
	loopne	scanfr_lp
	mov	ax,bx		;Cluster #.
scanfr_done:
	pop	dx
	pop	cx
	pop	bx
	ret
scan_fat_r ENDP
;
;-----------------------------------------------------------------
; Link up (in the FAT) the pieces of subdirs we've found.
;
; On entry: DS=CS.
; On exit: All FM_SUB_XXXs are gone from the FAT.
;	   Destroys AX,BX,CX,DX,SI,DI,ES.
;
link_subs PROC NEAR
;
; Start by linking up the FAT sub_mids to the sub_starts as best we can.
;
	xor	dx,dx		;Beginning of chain is undefined, at first.
ls1_top:
	mov	es,fat_seg
	cld
	mov	bx,1		;Init to 1 (pre-incremented to 2).
	mov	cx,clusters
ls1_lp: jcxz	ls1_done
ls1_scan:
	inc	bx
	call	get_link_fast
	cmp	ax,fm_free
	loope	ls1_scan
	je	ls1_done	;Nothing more of interest.
	cmp	ax,fm_sub_start
	je	ls1_found_start
	cmp	ax,fm_sub_mid
	jne	ls1_lp
	or	dx,dx		;Any chain-building in progress?
	jz	ls1_lp		;No, don't yet know where a chain starts.
	mov	ax,bx		;Cluster # of the sub_mid we've just found.
	mov	bx,dx		;End of previous chain.
	call	store_link	;Link previous chain to this sub_mid.
	mov	dx,ax		;New end of the growing chain.
	mov	bx,ax
	jmp	ls1_lp
ls1_found_start:
	mov	ax,dx
	mov	dx,bx
	or	ax,ax		;Any previous chain?
	jz	ls1_top 	;No.  Start over, with BX= start of 1st chain.
	jmp	ls1_lp		;Yes,
ls1_done:
	or	dx,dx		;Did we find any 'sub_start's?
	jnz	linksub2	;Yes.
	mov	dx,fm_free	;None, so replace all
	jmp	short ls3_start	;FM_SUB_XX's with FM_FREE.
;
; Search for sub_tails and then link them to sub_mids or sub_starts.
;
linksub2:
	mov	bx,1		;Init 2-1.
	mov	cx,clusters
ls2_lp:
	jcxz	linksub3
ls2_scan:
	inc	bx
	call	get_link_fast
	cmp	ax,fm_sub_tail
	loopne	ls2_scan
	jne	linksub3	;Not found.  Nothing more of interest.
	mov	di,bx
	dec	di		;The entry just before the sub_tail.
	mov	ax,fm_sub_mid
	call	scan_fat_r	;Hunt backwards for a sub_mid entry.
	je	ls2_found	;Returns AX=cluster # where it was found.
	mov	ax,fm_sub_start ;Try for a sub_start, too.
	call	scan_fat_r
	je	ls2_found
	mov	di,bx
	inc	di		;The entry just after the sub_tail.
	mov	ax,fm_sub_mid
	call	scan_fat	;Hunt forwards.
	je	ls2_found
	mov	ax,fm_sub_start
	call	scan_fat
	je	ls2_found
	mov	ax,fm_free	;No place to link the sub_tail, so erase it.
	jmp	short ls2_store
ls2_found:			;AX= cluster of item found by SCAN_FAT.
	xchg	ax,bx		;So AX=clu of sub_tail, BX=_start or _mid.
	call	store_link	;Replace _start or _mid with ptr to sub_tail.
	mov	bx,ax		;BX selects the TAIL entry.
	mov	ax,fm_end	;End the chain.
ls2_store:
	call	store_link
	jmp	ls2_lp
;
; Change every remaining FM_SUB_START or FM_SUB_MID into FM_END.
; (Note: at this point, there should be no remaining FM_SUB_TAILs)
;
linksub3:
	mov	dx,fm_end
;
; Special entry for deleting (DX will be FM_FREE).
;
ls3_start:
	mov	cx,clusters
	mov	bx,1
ls3_lp: jcxz	linksub4
ls3_scan:
	inc	bx
	call	get_link_fast
	cmp	ax,fm_free
	loope	ls3_scan
	je	linksub4
	cmp	ax,fm_sub_start
	je	ls3_change
	cmp	ax,fm_sub_mid
	jne	ls3_lp
ls3_change:
	mov	ax,dx		;DX is either FM_END or FM_FREE.
	call	store_link
	jmp	ls3_lp
;
linksub4:
	push	cs
	pop	es
	ret
link_subs ENDP
;
;------------------------------------------------------------------
; Files we deleted in WALK2 were marked in the FAT as fm_file_del,
; instead of fm_free (this improves performance regarding
; fragmented files).  This proc is provided to search the FAT
; and convert any fm_file_dels into fm_free.  Also, during
; HUNT empty subdirs were marked fm_sub_nul to allow their
; possible recovery.  Remaining fm_sub_nuls are now freed.
;
; On entry: nothing.
; On exit: AX,BX,CX,DI destroyed.
;
fix_fm_dels PROC NEAR
	mov	dx,fm_file_del
fix_fd_top:
	mov	di,2
fix_fd_lp:
	mov	ax,dx
	call	scan_fat
	jne	fix_fd2
	mov	di,ax		;Update cluster # for next loop.
	mov	bx,ax
	mov	ax,fm_free
	call	store_link
	jmp	fix_fd_lp	;Look some more.
fix_fd2:
	mov	ax,fm_sub_nul
	xchg	ax,dx
	cmp	ax,dx		;1st or 2nd pass?
	jne	fix_fd_top	;Do it a 2nd time, for FM_SUB_NULs.
	ret
fix_fm_dels ENDP
;
;-----------------------------------------------------------------
; WALK THROUGH A DIRECTORY, GET THE NEXT ENTRY.
;
; On entry: TREE_LEVEL, TREE and PATH are assumed setup.
;
; On exit: If successful then CF=false and AX returns
;	   the same results as CHECK_DIR_ENTRY.
;	   Also, ES:DI points to the directory entry.
;
;	   But if a disk error occurs, then CF=true.
;
; Only AX,ES,DI are changed.
;
dir_walk PROC NEAR
	push	bx
	push	cx
	push	dx
	push	si
;
	mov	si,tree_level	;Inside this proc, SI= offset into TREE.
	mov	di,tree [si].toffset
	cmp	di,-1		;Special value for beginning of new path?
	jne	dw0		;No.
	mov	di,-32		;So upcoming 'ADD DI,32' will yield 0.
dw0:	or	si,si
	jnz	dw_nonroot
dw_root:
	mov	es,dir_seg
	nop
	add	di,32
	mov	ax,32
	mul	root_entries
	cmp	di,ax
	jae	dw_dir_end
	mov	tree [si].toffset, di	;Update.
	cmp	byte ptr es:[di],0	;End-of-dir mark?
	jz	dw_dir_end		;End of root.
	jmp	short dw_examine
dw_dir_end:
	mov	ah,de_zeros	;Slightly fake # for 'no more entries'.
	xor	al,al		;CF=0.
	jmp	short dw_done
dw_nonroot:
	mov	es,cluster_seg
	nop
	add	di,32			;Next entry.
	mov	ax,32
	mul	dirs_per_cluster	;# dir entries that fit in a cluster.
	cmp	di,ax			;Are we still inside current cluster?
	jb	dw_read 		;Yes.
	mov	bx,tree [si].tcluster	;Get current cluster number.
	call	get_link		;Get FAT entry to find next cluster.
	cmp	ax,fm_bad		;End of chain (any 'reserved' value)?
	jae	dw_dir_end		;No more clusters for this subdir.
	mov	tree [si].tcluster, ax	;Update.
	xor	di,di			;Begin new cluster of this subdir.
dw_read:
	mov	tree [si].toffset, di	;Update.
	or	si,si			;Level = root?
	jz	dw_examine		;Root is always in memory.
	mov	ax,tree [si].tcluster
	call	read_sub_cluster	;Buffer management done internally.
	jnc	dw_examine		;No error.
dw_disk_err:
	stc
	jmp	short dw_done
;
dw_examine:
	cmp	byte ptr es:[di],0	;End of directory?
	jz	dw_dir_end
	mov	ax,di
	call	check_dir_entry 	;Entry at ES:AX.
	test	ah,de_sublink
	jnz	dw_sublink
	jmp	short dw_done	;Return with ES:DI ptg at the file entry.
;
dw_sublink:			;Dir entry was "." or "..".
	or	si,si
	jz	dw_invalid		;Sublinks musn't be in the root!
	mov	dx, tree [si].tcluster
	cmp	dx, tree [si].tcluster0 ;Sublinks OK only in 1st cluster.
	jne	dw_invalid
	mov	dx,es:[di].start_cluster	;Do a few checks on it.
	cmp	byte ptr es:[di].filename+1, "."
	je	dw_sublink2
	cmp	dx, tree [si].tcluster	;Should point at itself.
	jne	dw_invalid
	jmp	short dw_done			;Note CF=false.
dw_invalid:
	mov	ah,de_invalid
	xor	al,al
	jmp	short dw_done
dw_sublink2:			;Dir entry was ".."
	mov	bx,si
	sub	bx,SIZE tree_struc
	cmp	dx,tree [bx].tcluster0	;Previous level.
	jne	dw_invalid		;Back-link doesn't point at 'parent'.
dw_done:
	pop	si
	pop	dx
	pop	cx
	pop	bx
	ret
dir_walk ENDP
;
;--------------------------------------------------------------
; ADD TO THE PATH (and update the level).
;
; On entry: ES:DI points at a subdirectory entry.
; On exit: If success then CF=false, TREE_LEVEL, TREE and PATH are
;	   updated and the new cluster is read into our cluster buffer.
;	   CHECK_CLUSTER is called, and AX returns it's result code.
;	   But if error then CF=true, AX=?.
;
; Only AX is changed.
;
add_to_path PROC NEAR
	mov	ax,di
	call	check_dir_entry
	push	bx
	push	cx
	push	dx
	push	si
	push	es	; * Note ES must be before DI (for seg:offset pair).
	push	di	; *
	push	bp
	mov	bp,sp	;Now [BP+2]=stacked DI, [BP+4]=stacked ES.
;
	cmp	ax,(256*de_live) + dir_attr
	jne	adp_err_stp
	mov	bx,tree_level
	add	bx,SIZE tree_struc		;Advance pointer to next rec.
	cmp	bx,(SIZE tree_struc) * tree_size
	jae	adp_err_stp
	mov	ax,es:[di].start_cluster
	mov	tree [bx].tcluster, ax
	mov	tree [bx].tcluster0, ax
	mov	tree [bx].toffset, -1	;Special value for new path.
;
	mov	si,bx
	cmp	bx,SIZE tree_struc	;First-level subdir?
	jbe	adp1			;Yes, looping tree can't occur yet.
adp_circ_lp:
	sub	si, SIZE tree_struc
	jbe	adp1			;Reached root level.  Done checking.
	cmp	ax, tree [si].tcluster0 ;This subdir occurs twice in the tree?
	je	adp_err 		;Yes!  Invalid tree (circular).
	cmp	ax, tree [si].tcluster
	jne	adp_circ_lp
adp_err_stp:
	jmp	short adp_err
;
adp1:	lea	di,path 	;Next, we add to the text of the path.
	push	cs
	pop	es
	cld
	xor	ax,ax
	mov	cx,SIZE path
	repnz scasb		;Find the 1st zero (the end).
	jnz	adp_err
	mov	dx,bx		;Save new tree_level value into DX.
	lea	bx,[di]
	mov	byte ptr [bx-1],"\"	;Replace 0 with \.
	les	di,dword ptr [bp+2]	;Recover ptr to dir entry.
	call	copy_fname	;From subdir name at ES:DI to CS:BX.
	lea	bx,[bx] 	;Just to see it in debug.
	cmp	path_guard,-1	;Path has grown too long?
	je	adp2		;OK.
	mov	byte ptr [bx-1],0	;Reject addition to path.
	jmp	short adp_err
;
adp2:	mov	si,dx		;Fetch new tree_level into SI.
	mov	bx,tree [si].tcluster
	call	get_link
	cmp	ax,fm_free	;Validate the FAT entry for this cluster.
	je	adp_err 	;Cluster is unallocated!
	cmp	ax,fm_bad
	je	adp_err 	;Cluster is marked bad!
	mov	ax,bx
	call	read_sub_cluster
	jc	adp_err
	call	check_cluster
	cmp	ax,fm_sub_start ;Fm_sub_start, _end or _sub_nul are expected.
	je	adp3
	cmp	ax,fm_end
	je	adp3
	cmp	ax,fm_sub_nul
	jne	adp_err
adp3:	mov	tree_level,si	;Update TREE_LEVEL (at last!).
	clc			;Success (CF=false).
	jmp	short adp_exit
adp_err:
	stc
adp_exit:
	pop	bp
	pop	di
	pop	es
	pop	si
	pop	dx
	pop	cx
	pop	bx
	ret
add_to_path ENDP
;
;-----------------------------------------------------------
; Subtract the last subdir from path name
; (shorten the path) and back up tree level by 1.
;
; On entry: nothing.
; On exit: If new level = 0 then ZF=true, else ZF=false.
;
; All regs saved.
;
sub_from_path PROC NEAR
	push	ax
	push	bx
	push	cx
	push	di
	push	es
;
	push	cs
	pop	es
	cld
	mov	bx,tree_level
	sub	bx,SIZE tree_struc
	ja	subp0		;Not root.
	xor	ax,ax
	xor	bx,bx
	mov	tree_level,ax	;0.  Root.
	mov	word ptr path,ax
	lea	di,path
	mov	cx,SIZE path
	rep stosb
	jmp	short subp3
subp0:	mov	tree_level,bx
	lea	di,path
	mov	cx,SIZE path
	xor	ax,ax
	repnz scasb		;Find final 0.
	mov	ax,cx
	mov	cx,SIZE path
	sub	cx,ax

ifdef DBCS		; ### if DBCS ###
	push	si
	lea	si,path
	xor	ah,ah
subp1:	lea	di,[di-1]
	mov	al,[di]
	mov	[di],ah
	call	CheckDBCSTailByte
	jz	subp1a			; if this is tail byte
	cmp	al,'\'
	jz	subp1b			; if '\' is found
subp1a:
	loop	subp1			; do next
subp1b:
	pop	si

else			; ### if Not DBCS ###

	mov	al,"\"
subp1:	lea	di,[di-1]
	cmp	al,[di] 	;"\" ?
	mov	[di],ah 	;Zero.
	loopne	subp1		;Continue until we replace a \.
endif			; ### end if Not DBCS ###

subp3:	or	bx,bx
	pop	es
	pop	di
	pop	cx
	pop	bx
	pop	ax
	ret
sub_from_path ENDP
;
;--------------------------------------------------------------------
; Check the length of a file against the number
; of contiguous free clusters in the FAT.
;
; On entry: ES:DI points at a directory entry.
;
; On exit: If enough contiguous space is free then CF=false and
;	   AX = number of clusters which will be needed for the file.
;	   But if not, then CF=true and AX= max contiguous file size.
;
; Only AX is changed.
;
check_contig_free PROC NEAR
	push	bx
	push	cx
	push	dx
	push	di
	mov	ax,sector_size
	mul	cluster_size
	mov	cx,ax
	mov	ax,es:[di].file_size
	mov	dx,es:[di].file_size+2
	mov	bx,es:[di].start_cluster
	div	cx		;File_size / (bytes/cluster) = # clusters.
	call	roundup
	mov	di,ax		;DI= desired # clusters.
	or	di,di
	jz	chfr_done		;Zero length file.
	mov	cx,cluster_cnt_plus_1	;Max cluster #.
	sub	cx,bx		;Max # of FAT entries to examine.
	mov	dx,1		;Already know 1st one is allocated.
	cmp	dx,di
	je	chfr_enuf	;1-cluster file.  Done.
chfr_lp:
	inc	bx
	call	get_link
	cmp	ax,fm_free	;Is this cluster free for use?
	jne	chfr_not_free
	inc	dx		;Found one more free cluster.
	cmp	dx,di		;Enough?
	je	chfr_enuf
chfr_2: loop	chfr_lp 	;Loop until enough, or end of FAT.
	jmp	short chfr_fail ;Never got enough.
chfr_enuf:
	clc			;Success.
	jmp	short chfr_done
chfr_not_free:
	cmp	ax,fm_bad	;Is the non-free cluster just a bad one?
	je	chfr_2		;Yes.  Skip bad clu and keep looking.
chfr_fail:
	stc
chfr_done:
	mov	ax,dx
	pop	di
	pop	dx
	pop	cx
	pop	bx
	ret
check_contig_free ENDP
;
;-----------------------------------------------------------------------
; Complete a file's contiguous FAT chain.
;
; On entry: ES:DI points to the directory entry and
;	    CX= number of clusters (total) for the file.
;	    Note: this routine does not read the FAT links before
;	    overwriting them, so the caller must check beforehand.
;
; On exit: nothing.  All regs preserved.
;
complete_chain PROC NEAR
	jcxz	compch_exit
	push	ax
	push	bx
	push	cx
	push	si
	push	di
	mov	si,es:[di].start_cluster
	mov	di,si		;DI=entry to be written, SI=entry under test.
	cmp	cx,1
	je	compch_end
	dec	cx		;Decr count.  Final one is special.
compch_lp:
	inc	si		;Next clu #.
	mov	bx,si
	call	get_link
	cmp	ax,fm_bad	;Bad cluster?
	je	compch_lp	;Skip it.  Look at next one.
	mov	bx,di
	mov	ax,si		;Value stored = number of next free cluster.
	call	store_link
	mov	di,si
	loop	compch_lp
compch_end:
	mov	bx,di
	mov	ax,fm_end
	call	store_link
	pop	di
	pop	si
	pop	cx
	pop	bx
	pop	ax
compch_exit:
	ret
complete_chain ENDP
;
;--------------------------------------------------------------
; Round up the 16-bit quotient after an unsigned division.
;
; On entry: AX,DX = result of DIV.
; On exit: if DX was non-zero, then AX is incremented.
;
roundup PROC NEAR
	push	cx
	xor	cx,cx
	cmp	cx,dx		;CF=true if 0 is below DX.
	adc	ax,0
	pop	cx
	ret
roundup ENDP
;
;-------------------------------------------------------------------
; Announce UnFormat name & version #.  DX is destroyed.
;
;show_banner PROC NEAR          ;M000 - function removed
;lea	dx,banner               
;call	pr_text                 
;	ret
;show_banner ENDP
;
;-------------------------------------------------------------------
; If the printing option was selected, announce that fact.
; DX is destroyed.
;
display_print_opt PROC NEAR
	test	print_flags, pf_allowed
	jz	disp_p_o_end
	lea	dx,msg_print		;"Output will be echoed to LPT1."
	call	pr_text
disp_p_o_end:
	ret
display_print_opt ENDP



HAVE_DISKETTE_INSERTED PROC NEAR
	 CMP   DOS_VER,0300H
	 JB    H_D_I_EXIT

	 MOV   BL,DRIVE
	 INC   BL
	 MOV   AX,4408H		;Check if removable.
	 INT   21H
	or	ax,ax
;	 CMP   AX,0
	 JNE   H_D_I_EXIT

	mov	al,drive
	add	al,"A"
	 LEA   DX,MSG_INSERT_DISK	;"Insert disk in drive @0a:"
	call	display
;	 MOV   AH,9
;	 INT   21H

H_D_I_RETRY:
	mov	ax,0C00h
	int	21h
	 MOV   ah,01h		;Get one key via DOS.
	 INT   21H

	 CMP   AL,13		;Return key?
	 JNE   H_D_I_RETRY

H_D_I_EXIT:
	 RET

HAVE_DISKETTE_INSERTED ENDP



;
;--------------------------------------------------------------------
; On entry: DRIVE and DOS_VERSION are assumed valid.
;
; On exit: if it's a network drive then CF=true.  Otherwise CF=false.
;
; Destroys AX,BX,CX,DX,SI,DI.
;
check_network_drive PROC NEAR		; Added 05-01-89, GWD.
	push	bp
	push	ds
	push	es
	cld
	cmp	dos_ver,300h
	jb	chknet_not_ibm
	xor	ax,ax
	int	2Ah		;Is network installed?
	or	ah,ah
	jz	chknet_not_ibm	;No.
	mov	bl,drive
	mov	bh,0
	inc	bx
	mov	ax,4409h	;Is this drive remote?
	int	21h
	jc	chknet_not_ibm
	test	dx,1000h
	jnz	chknet_error	;It's remote.  Can't touch it.
	mov	al,drive
	add	al,"A"
	mov	net_string,al
	lea	si,net_string
	clc
	mov	ax,0300h
	int	2Ah		;Returns CF=true when INT25h is illegal.
	jmp	short chknet_done
chknet_not_ibm: 		;Look for Novell Netware 286.
	mov	cx,-1
	clc
	mov	ax,0DC00h	;'Request Novell connection #'.
	int	21h
	jc	chknet_ok	;Novell is not there.
	cmp	cx,-1
	je	chknet_ok
	mov	si,-1
	clc
	mov	ax,0EF01h	;'Get Novell drive table'.
	int	21h		;Returns ES:SI = pointer to table.
	jc	chknet_ok
	cmp	si,-1
	je	chknet_ok
	mov	bl,drive
	mov	bh,0
	test	byte ptr es:[bx+si],80h ;Is it a local drive?
	jz	chknet_error		;No - cannot process it.
chknet_ok:
	clc
	jmp	short chknet_done
chknet_error:
	stc
chknet_done:
	pop	es
	pop	ds
	pop	bp
	cld
	sti
	ret
check_network_drive ENDP
;
net_string	DB	"x:\",0
;
;


ifdef DBCS		; ### if DBCS ###
;--------------------------------------------------------------------
;
;	Test if the character is DBCS Lead Byte
;
;	input:	AL = character to check
;	outpit:	ZF = 1 if DBCS Lead Byte
;

DBCSLeadByteTable	dd	0

IsDBCSLeadByte		proc	near
	push	ax
	push	si
	push	ds
	lds	si,cs:DBCSLeadByteTable
	cmp	word ptr cs:DBCSLeadByteTable+2,0
	jnz	idlb_check		; if table is already set
	push	ax
	mov	ax,6300h
	int	21h			; get DBCS lead byte table
	pop	ax
	mov	word ptr cs:DBCSLeadByteTable,si
	mov	word ptr cs:DBCSLeadByteTable+2,ds
idlb_check:
	cmp	word ptr [si],0
	jz	idlb_not		; if end of table
	cmp	al,[si]
	jb	idlb_next		; if below low value
	cmp	al,[si+1]
	jbe	idlb_yes		; if below high value
idlb_next:
	add	si,2			; do next
	jmp	short idlb_check
idlb_not:
	or	al,1			; reset ZF
	jmp	short idlb_end
idlb_yes:
	and	al,0			; set ZF
idlb_end:
	pop	ds
	pop	si
	pop	ax
	ret
IsDBCSLeadByte		endp

;
;	Test if the character is DBCS Tail Byte
;
;	input:	AL = character to check
;	outpit:	ZF = 1 if DBCS Tail Byte
;
IsDBCSTailByte		proc	near
	push	ax
	push	si
	lea	si,tail_byte_table
idtb_check:
	cmp	word ptr cs:[si],0
	jz	idtb_not		; if end of table
	cmp	al,cs:[si]
	jb	idtb_next		; if below low value
	cmp	al,cs:[si+1]
	jbe	idtb_yes		; if below high value
idtb_next:
	add	si,2			; do next
	jmp	short idtb_check
idtb_not:
	or	al,1			; reset ZF
	jmp	short idtb_end
idtb_yes:
	and	al,0			; set ZF
idtb_end:
	pop	si
	pop	ax
	ret
IsDBCSTailByte		endp

tail_byte_table		label	byte
ifdef JAPAN
	db	40h,7eh
	db	80h,0fch
	dw	0
endif
ifdef TAIWAN
	db	40h,7eh
	db	0a1h,0feh
	dw	0
endif
ifdef KOREA
	db	0a1h,0abh
	db	0b0h,0c8h
	db	0cah,0fdh
	dw	0
endif

;
;	Check if the character position is at Tail Byte of DBCS
;
;	input:	ds:si = start address of the string
;		ds:di = character position to check
;	output:	ZF = 1 if at Tail Byte
;
CheckDBCSTailByte	proc	near
	push	ax
	push	cx
	push	di
	mov	cx,di			; save character position
cdtb_check:
	cmp	di,si
	jz	cdtb_next		; if at the top
	dec	di			; go back
	mov	al,[di]			; get character
	call	IsDBCSLeadByte
	jz	cdtb_check		; if DBCS lead byte do next
	inc	di			; adjust
cdtb_next:
	sub	cx,di			; if the length is odd then
	xor	cl,1			; the character position is
	test	cl,1			; at the tail byte
	pop	di
	pop	cx
	pop	ax
	ret
CheckDBCSTailByte	endp
endif		; ### end if DBCS ###


;--------------------------------------------------------------------
; Table of possible command line parms/options.
; Note: for parsing to work properly with similar keywords
;	like "/LIST" and "/L", the longer one must be first
;	in the list.
;
option_table LABEL byte
 opt_def <options, opt_wrfake, action_switch, 5, "/TEST">
 opt_def <options, opt_partn, action_switch, 6, "/PARTN">
 opt_def <options, opt_j, action_switch, 2, "/J">
 opt_def <options, opt_u, action_switch, 2, "/U">
 opt_def <print_flags, pf_allowed, action_switch, 2, "/P">
 opt_def <options, opt_list, action_switch, 2, "/L">
;opt_def <options, opt_keep_fat+opt_k+opt_f, action_switch, 3, "/KF">
;opt_def <options, opt_keep_root+opt_k+opt_r, action_switch, 3, "/KR">
;opt_def <options, opt_erase_fat+opt_f, action_switch, 3, "/EF">
;opt_def <options, opt_erase_root+opt_r, action_switch, 3, "/ER">
 opt_def <0,0,0>
;
;------------------------------------------------------------------------
int25_error_list LABEL byte
	i25_error_struc <0, msg_i25_wrprot>
	i25_error_struc <1, msg_i25_unit>
	i25_error_struc <2, msg_i25_not_ready>
	i25_error_struc <3, msg_i25_bad_cmd>
	i25_error_struc <4, msg_i25_crc>
	i25_error_struc <5, msg_i25_req>
	i25_error_struc <6, msg_i25_seek>
	i25_error_struc <7, msg_i25_media>
	i25_error_struc <8, msg_i25_rnf>
	i25_error_struc <9, msg_i25_paper>
	i25_error_struc <0Ah, msg_i25_readf>
	i25_error_struc <0Bh, msg_i25_writef>
	i25_error_struc <0Ch, msg_i25_general>
	i25_error_struc <-1>			;End of list.
;
;------------------------------------------------------------------------
	EVEN	;Make sure it does NOT align, in the program file.
there	=$
zapsav_text DB	"zSav",0	;This is the special mark for dir entries
zapsav_length =$-there		;zapped by the CPS Formatter.
;
subdir	dir_str <"SUBDIR  ","   ",dir_attr>	;Template for dir entries.
;
prog	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\debcom1.asm ===
PAGE    60,132
	TITLE	DEBCOM1.ASM - PART1 DEBUGGER COMMANDS	PC DOS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DECOM1.asm
;
; DESCRIPTIVE NAME: DEBUGGING TOOL
;
; FUNCTION: PROVIDES USERS WITH A TOOL FOR DEBUGGING PROGRAMS.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: DEBCOM2 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM3 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBASM  - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBUASM - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBMES  - CONTAINS ROUTINES CALLED BY DEBUG
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- IMPLEMENT > 32MB SUPPORT	DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================

; Routines to perform debugger commands except ASSEMble and UASSEMble

	IF1
           ;%out COMPONENT=DEBUG, MODULE=DEBCOM1
	ENDIF
.XLIST
.XCREF
	include syscall.inc		; cas -- missing equates
	include version.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC
        INCLUDE debug.inc
.CREF
.LIST

CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
	EXTRN	SYNERR_PTR:BYTE
	EXTRN	DISPB:WORD,DSIZ:BYTE,DSSAVE:WORD
	IF	SYSVER
	    EXTRN   CIN:DWORD,PFLAG:BYTE
	ENDIF
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	DEFLEN:WORD,BYTEBUF:BYTE,DEFDUMP:BYTE
	EXTRN	ARG_BUF:BYTE,ARG_BUF_PTR:BYTE
	EXTRN	ONE_CHAR_BUF:BYTE,ONE_CHAR_BUF_PTR:WORD
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG
	PUBLIC	HEXCHK,GETHEX1,PRINT,DSRANGE,ADDRESS,HEXIN,PERROR
	PUBLIC	GETHEX,GET_ADDRESS,GETEOL,GETHX,PERR
	PUBLIC	PERR,MOVE,DUMP,ENTERDATA,FILL,SEARCH,DEFAULT
ifdef JAPAN
	public	SETDUMPMODE
	extrn	test_lead:near
endif
	IF	SYSVER
	    PUBLIC  IN
	    EXTRN   DISPREG:NEAR,DEVIOCALL:NEAR
	ENDIF
	EXTRN	CRLF:NEAR,OUTDI:NEAR,OUTSI:NEAR,SCANP:NEAR
	EXTRN	SCANB:NEAR,BLANK:NEAR,TAB:NEAR,COMMAND:NEAR
	EXTRN	HEX:NEAR,BACKUP:NEAR
	EXTRN	PRINTF_CRLF:NEAR,HEX_ADDRESS_ONLY:NEAR,HEX_ADDRESS_STR:NEAR
	EXTRN	STD_PRINTF:NEAR
DEBCOM1:
; RANGE - Looks for parameters defining an address range.
; The first parameter is the starting address. The second parameter
; may specify the ending address, or it may be preceded by
; "L" and specify a length (4 digits max), or it may be
; omitted and a length of 128 bytes is assumed. Returns with
; segment in AX, displacement in DX, and length in CX.
DSRANGE:
	MOV	BP,[DSSAVE]		; Set default segment to DS
	MOV	[DEFLEN],128		; And default length to 128 bytes
RANGE:
	CALL	ADDRESS

	PUSH	AX			; Save segment
	PUSH	DX			; Save offset
	CALL	SCANP			; Get to next parameter

	MOV	AL,[SI]
	CMP	AL,UPPER_L		; Length indicator?
	JE	GETLEN

	MOV	DX,[DEFLEN]		; Default length
	CALL	HEXIN			; Second parameter present?

	JC	GETDEF			; If not, use default

	MOV	CX,4
	CALL	GETHEX			; Get ending address (same segment)

	MOV	CX,DX			; Low 16 bits of ending addr.
	POP	DX			; Low 16 bits of starting addr.
	SUB	CX,DX			; Compute range
	JAE	DSRNG2

DSRNG1:
	JMP	PERROR			; Negative range
DSRNG2:
	INC	CX			; Include last location
;	JCXZ	DSRNG1			; Wrap around error
;	Removing this instruction allows 0 FFFF to valid range
	POP	AX			; Restore segment
	RET
GETDEF:
	POP	CX			; get original offset
	PUSH	CX			; save it
	NEG	CX			; rest of segment
	JZ	RNGRET			; use default

	CMP	CX,DX			; more room in segment?
	JAE	RNGRET			; yes, use default

	JMP	short RNGRET1 		; no, length is in CX

GETLEN:
	INC	SI			; Skip over "L" to length
	MOV	CX,4			; Length may have 4 digits
	CALL	GETHEX			; Get the range

RNGRET:
	MOV	CX,DX			; Length
RNGRET1:
	POP	DX			; Offset
	MOV	AX,CX
	ADD	AX,DX
	JNC	OKRET

	CMP	AX,1
	JAE	DSRNG1			; Look for wrap error

OKRET:
	POP	AX			; Segment
	RET
DEFAULT:
; DI points to default address and CX has default length
	CALL	SCANP

	JZ	USEDEF			; Use default if no parameters

	MOV	[DEFLEN],CX
	CALL	RANGE

	JMP	GETEOL

USEDEF:
	MOV	SI,DI
	LODSW				; Get default displacement
	MOV	DX,AX
	LODSW				; Get default segment
	RET

ifdef JAPAN
;
;	Set Dump mode to Kanji or Ascii
;
dump_mode	db	0
dbcs_flag	db	0
dbcs_adj	db	0

SETDUMPMODE:
	call	scanp			; get parameter
	jz	dm_err			; if none
	lodsb
	cmp	al,'K'			; is it for Kanji mode
	jnz	@f			; no
	call	geteol
	mov	cs:dump_mode,1		; set Kanji mode
	jmp	short dm_ret
@@:
	cmp	al,'A'			; is it for Ascii mode
	jnz	@f			; no
	call	geteol
	mov	cs:dump_mode,0		; set Ascii mode
	jmp	short dm_ret
@@:
dm_err:
	jmp	PERR
dm_ret:
	ret
endif

; Dump an area of memory in both hex and ASCII
DUMP:
ifdef JAPAN
	mov	cs:dbcs_flag,0
	mov	cs:dbcs_adj,0
endif

	MOV	BP,[DSSAVE]
	MOV	CX,DISPB
	MOV	DI,OFFSET DG:DEFDUMP
	CALL	DEFAULT 		; Get range if specified

	MOV	DS,AX			; Set segment
	ASSUME	DS:NOTHING

	MOV	SI,DX			; SI has displacement in segment
	PUSH	SI			; save SI away
	MOV	AL,DSIZ
	XOR	AH,AH
	XOR	AX,-1
	AND	SI,AX			; convert to para number
	MOV	DI,OFFSET DG:ARG_BUF	; Build the output str in arg_buf
	CALL	OUTSI			; display location

	POP	SI			; get SI back
; Determine where the registers display should begin.
	MOV	AX,SI			; move offset
	MOV	AH,3			; spaces per byte
	AND	AL,DSIZ 		; convert to real offset
	MUL	AH			; 3 char positions per byte of output
	OR	AL,AL			; at beginning?
	JZ	INROW			; if so, then no movement.

	PUSH	CX
	MOV	CX,AX
	CALL	TAB

	POP	CX
INROW:
	PUSH	SI			; Save address for ASCII dump
BYTE0:
	CALL	BLANK			; Space between bytes
BYTE1:
	LODSB				; Get byte to dump
	CALL	HEX			; and display it

	POP	DX			; DX has start addr. for ASCII dump
	DEC	CX			; Drop loop count
	JZ	ASCII			; If through do ASCII dump

	MOV	AX,SI
	TEST	AL,DSIZ 		; On row boundary?
	JZ	ENDROW

	PUSH	DX			; Didn't need ASCII addr. yet
	TEST	AL,7			; On 8-byte boundary?
	JNZ	BYTE0

	MOV	AL,CHAR_MINUS		; Mark every 8 bytes with "-"
	STOSB
	JMP	SHORT BYTE1

ENDROW:
	CALL	ASCII			; Show it in ASCII

	MOV	DI,OFFSET DG:ARG_BUF	; Build the output str in arg_buf
	CALL	OUTSI			; Get the address at start of line

	JMP	INROW			; Loop until count is zero

; Produce a dump of the ascii text characters.	We take the current SI which
; contains the byte after the last one dumped.	From this we determine how
; many spaces we need to output to get to the ascii column.  Then we look at
; the beginning address of the dump to tsee how many spaces we need to indent.
ASCII:
	PUSH	CX			; Save count of remaining bytes
; Determine how many spaces to go until the ASCII column.
	MOV	AX,SI			; get offset of next byte
	DEC	AL
	AND	AL,DSIZ
	INC	AL
; AX now has the number of bytes that we have displayed:  1 to Dsiz+1.
; Compute characters remaining to be displayed.  We *always* put the ASCII
; dump in column 51 (or whereever)
	SUB	AL,10H			; get negative of number
	DEC	AL			;
	NEG	AL			; convert to positive
	CBW				; convert to word
; 3 character positions for each byte displayed.
	MOV	CX,AX
	SHL	AX,1
	ADD	CX,AX
; Compute indent for ascii dump
	MOV	AX,DX
	AND	AL,DSIZ
	XOR	AH,AH
	ADD	CX,AX
; Tab over
	CALL	TAB

; Set up for true dump
	MOV	CX,SI
	MOV	SI,DX
	SUB	CX,SI
ASCDMP:
	LODSB				; Get ASCII byte to dump

ifdef JAPAN
	cmp	cs:dbcs_flag,1
	jz	set_dbcs		; if it was lead byte
	cmp	cs:dbcs_flag,2
	jnz	@f			; if it was not tail byte
	mov	cs:dbcs_flag,0		; reset
@@:
	call	test_lead
	jnc	@f			; if this is not lead byte
	cmp	byte ptr [si],CHAR_BLANK
	jae	set_dbcs		; if tail byte is not control corde
	mov	al,CHAR_PERIOD
	jmp	short @f
set_dbcs:
	inc	cs:dbcs_flag
@@:
	cmp	cs:dump_mode,1
	jnz	@f			; if not Kanji mode
	cmp	cs:dbcs_adj,1
	jnz	kanjiprt		; if no need to adjust
	mov	al,' '			; tail byte is displayed already
	mov	cs:dbcs_adj,0
	jmp	short kanjiprt
@@:
endif

	CMP	AL,CHAR_RUBOUT
	JAE	NOPRT			; Don't print RUBOUT or above

ifdef JAPAN
kanjiprt:
endif

	CMP	AL,CHAR_BLANK
	JAE	PRIN			; print space through RUBOUT-1

NOPRT:
	MOV	AL,CHAR_PERIOD		; If unprintable character
PRIN:
	STOSB
	LOOP	ASCDMP			; CX times

ifdef JAPAN
	cmp	cs:dump_mode,1
	jnz	@f			; if not Kanji mode
	cmp	cs:dbcs_flag,1
	jnz	@f			; if not ended with lead byte
	mov	al,[si]			; get tail byte
	stosb
	mov	cs:dbcs_adj,1
@@:
endif

	MOV	AL,0
	STOSB
	PUSH	DS
	PUSH	CS
	POP	DS
	ASSUME	DS:DG

	CALL	HEX_ADDRESS_STR

	CALL	CRLF

	POP	DS
	ASSUME	DS:NOTHING

	POP	CX			; Restore overall dump len
	MOV	WORD PTR [DEFDUMP],SI
	MOV	WORD PTR [DEFDUMP+WORD],DS ; Save last address as def
	RET

	ASSUME	DS:DG
; Block move one area of memory to another Overlapping moves are performed
; correctly, i.e., so that a source byte is not overwritten until after it has
; been moved.
MOVE:
	CALL	DSRANGE 		; Get range of source area

	PUSH	CX			; Save length
	PUSH	AX			; Save segment
	PUSH	DX			; Save source displacement
	CALL	ADDRESS 		; Get destination address (sam

	CALL	GETEOL			; Check for errors

	POP	SI
	MOV	DI,DX			; Set dest. displacement
	POP	BX			; Source segment
	MOV	DS,BX
	MOV	ES,AX			; Destination segment
	POP	CX			; Length
	CMP	DI,SI			; Check direction of move
	SBB	AX,BX			; Extend the CMP to 32 bits
	JB	COPYLIST		; Move forward into lower mem.

; Otherwise, move backward. Figure end of source and destination
; areas and flip direction flag.
	DEC	CX
	ADD	SI,CX			; End of source area
	ADD	DI,CX			; End of destination area
	STD				; Reverse direction
	INC	CX
COPYLIST:
	MOVSB				; Do at least 1 - Range is 1-1
	DEC	CX
	REP	MOVSB			; Block move
RET1:
	RET

; Fill an area of memory with a list values. If the list
; is bigger than the area, don't use the whole list. If the
; list is smaller, repeat it as many times as necessary.
FILL:
	CALL	DSRANGE 		; Get range to fill

	PUSH	CX			; Save length
	PUSH	AX			; Save segment number
	PUSH	DX			; Save displacement
	CALL	LIST			; Get list of values to fill w

	POP	DI			; Displacement in segment
	POP	ES			; Segment
	POP	CX			; Length
	CMP	BX,CX			; BX is length of fill list
	MOV	SI,OFFSET DG:BYTEBUF	; List is in byte buffer
	JCXZ	BIGRNG

	JAE	COPYLIST		; If list is big, copy part of

BIGRNG:
	SUB	CX,BX			; How much bigger is area than
	XCHG	CX,BX			; CX=length of list
	PUSH	DI			; Save starting addr. of area
	REP	MOVSB			; Move list into area
	POP	SI
; The list has been copied into the beginning of the
; specified area of memory. SI is the first address
; of that area, DI is the end of the copy of the list
; plus one, which is where the list will begin to repeat.
; All we need to do now is copy [SI] to [DI] until the
; end of the memory area is reached. This will cause the
; list to repeat as many times as necessary.
	MOV	CX,BX			; Length of area minus list
	PUSH	ES			; Different index register
	POP	DS			; requires different segment r
	JMP	SHORT COPYLIST		; Do the block move

; Search a specified area of memory for given list of bytes.
; Print address of first byte of each match.
SEARCH:
	CALL	DSRANGE 		; Get area to be searched

	PUSH	CX			; Save count
	PUSH	AX			; Save segment number
	PUSH	DX			; Save displacement
	CALL	LIST			; Get search list

	DEC	BX			; No. of bytes in list-1
	POP	DI			; Displacement within segment
	POP	ES			; Segment
	POP	CX			; Length to be searched
	SUB	CX,BX			;  minus length of list
SCAN:
	MOV	SI,OFFSET DG:BYTEBUF	; List kept in byte buffer
	LODSB				; Bring first byte into AL
DOSCAN:
	SCASB				; Search for first byte
	LOOPNE	DOSCAN			; Do at least once by using LO

	JNZ	RET1			; Exit if not found

	PUSH	BX			; Length of list minus 1
	XCHG	BX,CX
	PUSH	DI			; Will resume search here
	REPE	CMPSB			; Compare rest of string
	MOV	CX,BX			; Area length back in CX
	POP	DI			; Next search location
	POP	BX			; Restore list length
	JNZ	TTEST			 ; Continue search if no match

	DEC	DI			; Match address
	CALL	OUTDI			; Print it

	INC	DI			; Restore search address
	CALL	HEX_ADDRESS_ONLY	; Print the addresss

	CALL	CRLF

TTEST:
	JCXZ	RET1

	JMP	SHORT SCAN		; Look for next occurrence

; Get the next parameter, which must be a hex number.
; CX is maximum number of digits the number may have.

;=========================================================================
; GETHX: This routine calculates the binary representation of an address
;	 entered in ASCII by a user.  GETHX has been modified to provide
;	 support for sector addresses > 32mb.  To do this the bx register
;	 has been added to provide a 32 bit address.  BX is the high word
;	 and DX is the low word.  For routines that rely on DX for a 16
;	 bit address, the use of BX will have no effect.
;
;	Date	   : 6/16/87
;=========================================================================

GETHX:
	CALL	SCANP
GETHX1:
	XOR	DX,DX			; Initialize the number
	xor	bx,bx			;an000;initialize high word for
					;      sector address
	CALL	HEXIN			; Get a hex digit

	JC	HXERR			; Must be one valid digit

	MOV	DL,AL			; First 4 bits in position
GETLP:
	INC	SI			; Next char in buffer
	DEC	CX			; Digit count
	CALL	HEXIN			; Get another hex digit?

	JC	RETHX			; All done if no more digits

	STC
	JCXZ	HXERR			; Too many digits?


	call	ADDRESS_32_BIT		;an000;multiply by 32
	JMP	SHORT GETLP		; Get more digits

GETHEX:
	CALL	GETHX			; Scan to next parameter

	JMP	SHORT GETHX2

GETHEX1:
	CALL	GETHX1
GETHX2:
	JC	PERROR
RETHX:
	CLC
HXERR:
	RET

; Check if next character in the input buffer is a hex digit
; and convert it to binary if it is. Carry set if not.
HEXIN:
	MOV	AL,[SI]
; Check if AL  is a hex digit and convert it to binary if it
; is. Carry set if not.
HEXCHK:
	SUB	AL,CHAR_ZERO		; Kill ASCII numeric bias
	JC	RET2

	CMP	AL,10
	CMC
	JNC	RET2			; OK if 0-9

	AND	AL,5FH
	SUB	AL,7			; Kill A-F bias
	CMP	AL,10
	JC	RET2

	CMP	AL,16
	CMC
RET2:
	RET

; Process one parameter when a list of bytes is
; required. Carry set if parameter bad. Called by LIST.
LISTITEM:
	CALL	SCANP			; Scan to parameter

	CALL	HEXIN			; Is it in hex?

	JC	STRINGCHK		; If not, could be a string

	MOV	CX,2			; Only 2 hex digits for bytes
	push	bx			;an000;save it - we stomp it
	CALL	GETHEX			; Get the byte value
	pop	bx			;an000;restore it

	MOV	[BX],DL 		; Add to list
	INC	BX
GRET:
	CLC				; Parameter was OK
	RET

STRINGCHK:
	MOV	AL,[SI] 		; Get first character of param
	CMP	AL,SINGLE_QUOTE 	; String?
	JZ	STRING

	CMP	AL,DOUBLE_QUOTE 	; Either quote is all right
	JZ	STRING

	STC				; Not string, not hex - bad
	RET
STRING:
	MOV	AH,AL			; Save for closing quote
	INC	SI
STRNGLP:
	LODSB				; Next char of string
	CMP	AL,CR			; Check for end of line
	JZ	PERR			; Must find a close quote

	CMP	AL,AH			; Check for close quote
	JNZ	STOSTRG 		; Add new character to list

	CMP	AH,[SI] 		; Two quotes in a row?
	JNZ	GRET			; If not, we're done

	INC	SI			; Yes - skip second one
STOSTRG:
	MOV	[BX],AL 		; Put new char in list
	INC	BX
	JMP	SHORT STRNGLP		; Get more characters

; Get a byte list for ENTER, FILL or SEARCH. Accepts any number
; of 2-digit hex values or character strings in either single
; (') or double (") quotes.
LIST:
	MOV	BX,OFFSET DG:BYTEBUF	; Put byte list in the byte buffer
LISTLP:
	CALL	LISTITEM		; Process a parameter

	JNC	LISTLP			; If OK, try for more

	SUB	BX,OFFSET DG:BYTEBUF	; BX now has no. of bytes in list
	JZ	PERROR			; List must not be empty

; Make sure there is nothing more on the line except for
; blanks and carriage return. If there is, it is an
; unrecognized parameter and an error.
GETEOL:
	CALL	SCANB			; Skip blanks

	JNZ	PERROR			; Better be a RETURN
RET3:
	RET

; Command error.  SI has been incremented beyond the command letter so it must
; decremented for the error pointer to work.
PERR:
	DEC	SI
; Syntax error.  SI points to character in the input buffer which caused
; error.  By subtracting from start of buffer, we will know how far to tab
; over to appear directly below it on the terminal.  Then print "^ Error".
PERROR:
	SUB	SI,OFFSET DG:(BYTEBUF-1) ; How many char processed so far?
	MOV	CX,SI			; Parameter for TAB in CX
	MOV	DI,OFFSET DG:ARG_BUF	;
	CALL	TAB			; Directly below bad char

	MOV	BYTE PTR [DI],0 	; nul terminate the tab
	MOV	DX,OFFSET DG:SYNERR_PTR ; Error message
; Print error message and abort to command level
PRINT:
	CALL	PRINTF_CRLF

	JMP	COMMAND

; Gets an address in Segment:Displacement format. Segment may be omitted
; and a default (kept in BP) will be used, or it may be a segment
; register (DS, ES, SS, CS). Returns with segment in AX, OFFSET in DX.
ADDRESS:
	CALL	GET_ADDRESS

	JC	PERROR

ADRERR:
	STC
	RET

GET_ADDRESS:
	CALL	SCANP

	MOV	AL,[SI+1]
	CMP	AL,UPPER_S
	JZ	SEGREG

	MOV	CX,4
	CALL	GETHX

	JC	ADRERR

	MOV	AX,BP			; Get default segment
	CMP	BYTE PTR [SI],CHAR_COLON
	JNZ	GETRET

	PUSH	DX
GETDISP:
	INC	SI			; Skip over ":"
	MOV	CX,4
	CALL	GETHX

	POP	AX
	JC	ADRERR

GETRET:
	CLC
	RET

SEGREG:
	MOV	AL,[SI]
	MOV	DI,OFFSET DG:SEGLET	; SEGLET  DB  "CSED"
	MOV	CX,4
	REPNE	SCASB
	JNZ	ADRERR

	INC	SI
	INC	SI
	SHL	CX,1
	MOV	BX,CX
	CMP	BYTE PTR [SI],CHAR_COLON
	JNZ	ADRERR

	PUSH	[BX+DSSAVE]
	JMP	SHORT GETDISP

SEGLET	DB	"CSED"			; First letter of each of the segregs: CS,SS,ES,DS

; Short form of ENTER command. A list of values from the
; command line are put into memory without using normal
; ENTER mode.
GETLIST:
	CALL	LIST			; Get the bytes to enter

	POP	DI			; Displacement within segment
	POP	ES			; Segment to enter into
	MOV	SI,OFFSET DG:BYTEBUF	; List of bytes is in byte buffer
	MOV	CX,BX			; Count of bytes
	REP	MOVSB			; Enter that byte list
	RET

; Enter values into memory at a specified address.  If the line contains
; nothing but the address we go into "enter mode", where the address and its
; current value are printed and the user may change it if desired.  To change,
; type in new value in hex.  Backspace works to correct errors.  If an illegal
; hex digit or too many digits are typed, the bell is sounded but it is
; otherwise ignored.  To go to the next byte (with or without change), hit
; space bar.  To back CLDto a previous address, type "-".  On every 8-byte
; boundary a new line is started and the address is printed.  To terminate
; command, type carriage return.
;  Alternatively, the list of bytes to be entered may be included on the
; original command line immediately following the address.  This is in regular
; LIST format so any number of hex values or strings in quotes may be entered.
ENTERDATA:
	MOV	BP,[DSSAVE]		; Set default segment to DS
	CALL	ADDRESS

	PUSH	AX			; Save for later
	PUSH	DX
	CALL	SCANB			; Any more parameters?

	JNZ	GETLIST 		; If not end-of-line get list

	POP	DI			; Displacement of ENTER
	POP	ES			; Segment
GETROW:
	CALL	OUTDI			; Print address of entry

	PUSH	DI
	PUSH	ES
	PUSH	DS
	POP	ES
	MOV	DI,OFFSET DG:ARG_BUF
	CALL	BLANK

	XOR	AL,AL
	STOSB
	CALL	HEX_ADDRESS_STR

	POP	ES
	POP	DI
GETBYTE:
	MOV	AL,ES:[DI]		; Get current value
	PUSH	DI
	PUSH	ES
	PUSH	DS
	POP	ES
	MOV	DI,OFFSET DG:ARG_BUF
	CALL	HEX			; And display it

	MOV	AL,CHAR_PERIOD
	STOSB
	XOR	AL,AL
	STOSB
	MOV	DX,OFFSET DG:ARG_BUF_PTR
	CALL	STD_PRINTF

	POP	ES
	POP	DI
LOOK_AGAIN:
	MOV	CX,2			; Max of 2 digits in new value
	MOV	DX,0			; Intial new value
GETDIG:
	CALL	INPT			; Get digit from user

	MOV	AH,AL			; Save
	CALL	HEXCHK			; Hex digit?

	XCHG	AH,AL			; Need original for echo
	JC	NOHEX			; If not, try special command

	MOV	DH,DL			; Rotate new value
	MOV	DL,AH			; And include new digit
	LOOP	GETDIG			; At most 2 digits

; We have two digits, so all we will accept now is a command.
DWAIT:
	CALL	INPT			; Get command character
NOHEX:
	CMP	AL,CHAR_BACKSPACE	; Backspace
	JZ	BS

	CMP	AL,CHAR_RUBOUT		; RUBOUT
	JZ	RUB

	CMP	AL,CHAR_MINUS		; Back up to previous address
	JZ	PREV

	CMP	AL,CR			; All done with command?
	JZ	EOL

	CMP	AL,CHAR_BLANK		; Go to next address
	JZ	NEXT

	MOV	AL,CHAR_BACKSPACE
	CALL	OUT_CHAR		; Back up over illegal character

	CALL	BACKUP

	JCXZ	DWAIT

	JMP	SHORT GETDIG

RUB:
	MOV	AL,CHAR_BACKSPACE
	CALL	OUT_char
BS:
	CMP	CL,2			; CX=2 means nothing typed yet
	JZ	PUTDOT			; Put back the dot we backed up over

	INC	CL			; Accept one more character
	MOV	DL,DH			; Rotate out last digit
	MOV	DH,CH			; Zero this digit
	CALL	BACKUP			; Physical backspace

	JMP	SHORT GETDIG		; Get more digits

PUTDOT:
	MOV	AL,CHAR_PERIOD
	CALL	OUT_CHAR

	JMP	LOOK_AGAIN

; If new value has been entered, convert it to binary and
; put into memory. Always bump pointer to next location
STORE:
	CMP	CL,2			; CX=2 means nothing typed yet
	JZ	NOSTO			; So no new value to store

; Rotate DH left 4 bits to combine with DL and make a byte value
	PUSH	CX
	MOV	CL,4
	SHL	DH,CL
	POP	CX
	OR	DL,DH			; Hex is now converted to binary
	MOV	ES:[DI],DL		; Store new value
NOSTO:
	INC	DI			; Prepare for next location
	RET

NEXT:
	CALL	STORE			; Enter new value

	INC	CX			; Leave a space plus two for
	INC	CX			;  each digit not entered
	PUSH	DI
	MOV	DI,OFFSET DG:ARG_BUF
	PUSH	ES
	PUSH	DS
	POP	ES
	CALL	TAB

	XOR	AL,AL
	STOSB
	MOV	DX,OFFSET DG:ARG_BUF_PTR
	CALL	STD_PRINTF

	POP	ES
	POP	DI
	MOV	AX,DI			; Next memory address
	AND	AL,7			; Check for 8-byte boundary
	JZ	NEWROW			; Take 8 per line

	JMP	GETBYTE

NEWROW:
	CALL	CRLF			; Terminate line

	JMP	GETROW			; Print address on new line

PREV:
	CALL	STORE			; Enter the new value

; DI has been bumped to next byte. Drop it 2 to go to previous addr
	DEC	DI
	DEC	DI
	JMP	SHORT NEWROW		; Terminate line after backing	 CLD

EOL:
	CALL	STORE			; Enter the new value

	JMP	CRLF			; CR/LF and terminate

; Console input of single character
	IF	SYSVER
INPT:					  ;*** change for build - label to inpt
	    PUSH    DS
	    PUSH    SI
	    LDS     SI,CS:[CIN]
	    MOV     AH,4
	    CALL    DEVIOCALL

	    POP     SI
	    POP     DS
	    CMP     AL,3
	    JNZ     NOTCNTC

	    INT     VEC_CTRL_BREAK	;23H

NOTCNTC:
	    CMP     AL,UPPER_P - CHAR_AT_SIGN
	    JZ	    PRINTON

	    CMP     AL,UPPER_N - CHAR_AT_SIGN
	    JZ	    PRINTOFF

	    CALL    OUT_CHAR

	    RET

PRINTOFF:
PRINTON:
	    NOT     [PFLAG]
	    JMP     SHORT IN

	ELSE
INPT:				; Change label for build
	    MOV     AH,Std_Con_Input ;OPTION=1, STANDARD CONSOLE INPUT
	    INT     21H

	    RET

	ENDIF
OUT_CHAR:
	PUSH	DI
	PUSH	DX
	PUSH	ES
	PUSH	DS
	POP	ES
	MOV	DI,OFFSET DG:ONE_CHAR_BUF
	STOSB
	MOV	AL,0
	STOSB
	MOV	DX,OFFSET DG:ONE_CHAR_BUF_PTR
	CALL	STD_PRINTF

	POP	ES
	POP	DX
	POP	DI
	RET

;=========================================================================
; ADDRESS_32_BIT: This routine will build an address for 32bit sector
;		  addressibility.  BX will be the high word, with DX being
;		  the low word.
;
;	Inputs : DX/BX - registers to contain 32bit sector address
;		 DX & BX are both initialized to 0 on first call to routine.
;
;	Outputs: DX/BX - registers to contain 32bit sector address
;
;	Date	  : 6/16/87
;=========================================================================

ADDRESS_32_BIT	proc	near			;an000;perform 32 bit address
						;      creation
	push	cx				;an000;save affected regs.
	mov	cx,04h				;an000;initialize to
						;      nibble shift
;	$do					;an000;while cx not= 0
$$DO1:
		cmp	cx,00h			;an000;are we done?
;		$leave	e			;an000;yes, quit loop
		JE $$EN1
		shl	bx,1			;an000;shift bx 1 bit
		shl	dx,1			;an000;shift dx 1 bit
;		$if	c			;an000;did low word carry
		JNC $$IF3
			or	bx,01h		;an000;set bit 0 of high word
;		$endif				;an000;
$$IF3:
		dec	cx			;an000;decrease counter
;	$enddo					;an000;end while loop
	JMP SHORT $$DO1
$$EN1:
	or	dl,	al			;an000;overlay low word
						;      bits 0-3 with next
						;      portion of the address
	pop	cx				;an000;restore affected regs.

	ret					;an000;return to caller

ADDRESS_32_BIT	endp				;an000;end proc



CODE	ENDS
	END	DEBCOM1

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\cps\rebuild\uf_org.asm ===
; Copyright 1990 Central Point Software, Inc. 
; All rights reserved.
;------------------------------------------------------------
; This is the first module of UnFormat.
; LINK uf_org+uf_main+uf_io+uf_msg+uf_partn+uf_jims+uf_last, uf.exe/m;
;
;       M008    MD      2/28/91         Changed copyright text

prog	SEGMENT public
	ASSUME	CS:prog
	PUBLIC	top_of_mem, fcb1, parms, entry                  ;M008
	PUBLIC	major_ver, minor_ver
	EXTRN	start:near
cr	EQU	13
lf	EQU	10
;
major_ver EQU	6
minor_ver EQU	6
;
asm_message MACRO	x1,x2,x3,x4,x5,x6,x7,x8,x9
	%OUT	*MSG: x1&x2&x3&x4&x5&x6&x7&x8&x9
	ENDM
;
IF2
	asm_message <Version >,%major_ver,<.>,%minor_ver
ENDIF
;
cr	EQU	13
lf	EQU	10
;
;-----------------------------------------------------------
;
	ORG	2
top_of_mem DW	?
	ORG	5Ch
fcb1	DB	?
	ORG	80h
parms	DB	?
;
	ORG	100h
entry:	jmp	start
;
;

;M008 start
        DB 13,10,"Copyright (C) 1987-1990"
	DB	"  Central Point Software, Inc. "
;banner	DB	"PC Tools Rebuild/UnFormat "
;
;	DB	major_ver +"0"
;	DB	"."
;	DB	minor_ver + "0"
;	DB	"M"
;	DB	" "
;	DB	cr,lf
;	DB	0
;	DB	24h	;To end string when used from UF_JIMS.
;
;M008 end

        DB	1Ah
prog	ENDS
	END	entry

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\debcom3.asm ===
PAGE	80,132 ;
	TITLE	DEBCOM3.ASM - PART3 DEBUGGER COMMANDS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; ROUTINES TO PERFORM DEBUGGER COMMANDS

	IF1
	    %OUT COMPONENT=DEBUG, MODULE=DEBCOM3
	ENDIF
.XLIST
.XCREF
	include	mi.inc			; cas -- missing equates
	include	version.inc		; cas -- missing equates
	include	syscall.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC
        INCLUDE debug.inc
	INCLUDE DPL.ASM
.CREF
.LIST
CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
	EXTRN	USER_PROC_PDB:WORD,RSTACK:WORD,STACK:BYTE
	EXTRN	DSSAVE:WORD,CSSAVE:WORD,IPSAVE:WORD,axSAVE:WORD,dxSAVE:WORD
	EXTRN	SSSAVE:WORD,SPSAVE:WORD,FLSAVE:WORD
	EXTRN	NEXTCS:WORD,NEXTIP:WORD, RSETFLAG:BYTE
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	BRKCNT:WORD,TCOUNT:WORD,SWITCHAR:BYTE,BPTAB:BYTE
	EXTRN	BP_ERROR:BYTE,COMP_ARG1:WORD,COMP_ARG2:WORD,COMP_ARG3:WORD
	EXTRN	COMP_ARG4:WORD,COMP_ARG5:WORD,COMP_ARG6:WORD,COMP_PTR:BYTE
	EXTRN	ARG_BUF:BYTE,ARG_BUF_PTR:BYTE
	EXTRN	FZTRACE:BYTE, SYNERR_PTR:BYTE
	EXTRN	BEGSEG:WORD
	IF	IBMVER
	    EXTRN   cpu_not_8088:byte
	    EXTRN   OLD_MASK:BYTE
	ENDIF
	EXTRN	SAVESTATE:BYTE
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG
	PUBLIC	COMPARE,INPUT,OUTPUT,GO
	PUBLIC	TRACE,ZTRACE,SKIP_FILE
	EXTRN	GETHEX:NEAR,GETEOL:NEAR,CRLF:NEAR,ERR:NEAR, PERR:NEAR
	EXTRN	HEX:NEAR,DIGIT:NEAR,SCANP:NEAR,DISPREG:NEAR
	EXTRN	COMMAND:NEAR,DABORT:NEAR,DELIM1:NEAR,DELIM2:NEAR
	EXTRN	NMIINT:NEAR,NMIINTEND:NEAR,PRINTF_CRLF:NEAR
	EXTRN	ADDRESS:NEAR,HEXIN:NEAR,DSRANGE:NEAR
; just like trace except skips OVER next INT or CALL.
DEBCOM3:
ZTRACE:
	MOV	FZTRACE,-1
	CALL	SETADD
	CALL	SCANP
	CALL	HEXIN
	MOV	DX,1
	JC	ZSTOCNT
	MOV	CX,4
	CALL	GETHEX
	CALL	CHECKNONE
ZSTOCNT:
	MOV	[TCOUNT],DX
	CALL	GETEOL
	MOV	DX,NEXTCS
	MOV	CSSAVE,DX
	MOV	DX,NEXTIP
	MOV	IPSAVE,DX
ZSTEP:
	MOV	ES,[CSSAVE]		; point to instruction to execute
	MOV	DI,[IPSAVE]		; include offset in segment
	XOR	DX,DX			; where to place breakpoint
get_opcode:
	MOV	AL,ES:[DI]		; get the opcode
	cmp	al,0f0h 		; lock
	je	is_override
	cmp	al,26h			; es:
	je	is_override
	cmp	al,2eh			; cs:
	je	is_override
	cmp	al,36h			; ss:
	je	is_override
	cmp	al,3eh			; ds:
	jne	not_override
Is_override:
;	inc	dx			; this seemed to put us in an endless
	inc	di			; loop, try this.
	jmp	get_opcode
Not_override:
	CMP	AL,11101000B		; direct intra call
	JZ	ZTRACE3 		; yes, 3 bytes
	CMP	AL,10011010B		; direct inter call
	JZ	ZTRACE5 		; yes, 5 bytes
	CMP	AL,11111111B		; indirect?
	JZ	ZTRACEMODRM		; yes, go figure length
	CMP	AL,11001100B		; short interrupt?
	JZ	ZTRACE1 		; yes, 1 byte
	CMP	AL,11001101B		; long interrupt?
	JZ	ZTRACE2 		; yes, 2 bytes
	CMP	AL,11100010B		; loop
	JZ	ZTRACE2 		; 2 byter
	CMP	AL,11100001B		; loopz/loope
	JZ	ZTRACE2 		; 2 byter
	CMP	AL,11100000B		; loopnz/loopne
	JZ	ZTRACE2 		; 2 byter
	AND	AL,11111110B		; check for rep
	CMP	AL,11110010B		; perhaps?
	JZ	FOO1
	JMP	STEP			; can't do anything special, step
FOO1:
	MOV	AL,ES:[DI+1]		; next instruction
	AND	AL,11111110B		; ignore w bit
	CMP	AL,10100100B		; MOVS
	JZ	ZTRACE2 		; two byte
	CMP	AL,10100110B		; CMPS
	JZ	ZTRACE2 		; two byte
	CMP	AL,10101110B		; SCAS
	JZ	ZTRACE2 		; two byte
	CMP	AL,10101100B		; LODS
	JZ	ZTRACE2 		; two byte
	CMP	AL,10101010B		; STOS
	JZ	ZTRACE2 		; two byte
	JMP	short STEP		; bogus, do single step

ZTRACEMODRM:
	MOV	AL,ES:[DI+1]		; get next byte
	AND	AL,11111000B		; get mod and type
	CMP	AL,01010000B		; indirect intra 8 bit offset?
	JZ	ZTRACE3 		; yes, three byte whammy
	CMP	AL,01011000B		; indirect inter 8 bit offset
	JZ	ZTRACE3 		; yes, three byte guy
	CMP	AL,10010000B		; indirect intra 16 bit offset?
	JZ	ZTRACE4 		; four byte offset
	CMP	AL,10011000B		; indirect inter 16 bit offset?
	JZ	ZTRACE4 		; four bytes
	CMP	AL,11010000B		; indirect through reg?
	JZ	ZTRACE2 		; two byte instruction
	JMP	short STEP		; can't figger out what this is!
ZTRACE5:
	INC	DX
ZTRACE4:
	INC	DX
ZTRACE3:
	INC	DX
ZTRACE2:
	INC	DX
ZTRACE1:
	INC	DX
	ADD	DI,DX			; offset to breakpoint instruction
	MOV	WORD PTR [BPTAB],DI	; save offset
	MOV	WORD PTR [BPTAB+2],ES	; save segment
	MOV	AL,ES:[DI]		; get next opcode byte
	MOV	BYTE PTR [BPTAB+4],AL	; save it
	MOV	BYTE PTR ES:[DI],0CCH	; break point it
	MOV	[BRKCNT],1		; only this breakpoint
	JMP	DEXIT			; start the operation!

; Trace 1 instruction or the number of instruction specified
; by the parameter using 8086 trace mode. Registers are all
; set according to values in save area
TRACE:
	MOV	FZTRACE,0
	CALL	SETADD
	CALL	SCANP
	CALL	HEXIN
	MOV	DX,1
	JC	STOCNT
	MOV	CX,4
	CALL	GETHEX
	CALL	CHECKNONE
STOCNT:
	MOV	[TCOUNT],DX
	CALL	GETEOL
	MOV	DX,NEXTCS
	MOV	CSSAVE,DX
	MOV	DX,NEXTIP
	MOV	IPSAVE,DX
STEP:
	MOV	[BRKCNT],0
; The 286 has a problem with trace mode and software interrupt instructions;
; it treats them as atomic operations.	We simulate the operation in software.
	MOV	ES,[CSSAVE]		; Get next instruction pointer
	MOV	DI,[IPSAVE]
	MOV	AL,ES:[DI]		; get next opcode
	cmp	al,0e4h 		; check for 'IN' opcode
	jne	not_inal_op
	cmp	es:byte ptr[di+1],21h
	jne	not_mask_op
	add	[ipsave],2
	JMP	short SETalmask

not_inal_op:
	cmp	al,0ech 		; in al,DX ?
	jne	not_mask_op
	cmp	dxsave,21h
	jne	not_mask_op
	add	[ipsave],1
SETalmask:
	mov	ax,[axsave]
	in	al,21h
	mov	[axsave],ax
	JMP	SETENVIRON

not_mask_op:
	CMP	AL,0CDH 		; trace over an interrupt?
	JZ	DOINT			; no, check for other special cases
	CMP	AL,0CEH 		; how about int overflow
	JNZ	CHECKCC
	TEST	FLSAVE,F_OVERFLOW	 ; see it overflow is present
	JZ	CHECKOP
	MOV	BX,4			; INTO = INT 4
	DEC	IPSAVE			; INTO is a singel byte
	JMP	SHORT DOVAL
CHECKCC:
	CMP	AL,0CCH
	JNZ	CHECKOP
	MOV	BX,3			; INT 3 = CC
	DEC	IPSAVE
	JMP	SHORT DOVAL
DOINT:
; We have a software interrupt.  Get destination vector
	MOV	BL,BYTE PTR ES:[DI+1]	; get vector number
	XOR	BH,BH			; clear out upper
DOVAL:
	SHL	BX,1			; word index
	SHL	BX,1			; dword index
	XOR	DI,DI			; interrupt table
	MOV	ES,DI
	MOV	AX,ES:[BX]		; point to vector
	MOV	BX,ES:[BX+2]		; point to vector
; AX:BX is the vector.	Swap it with currect CS:IP
	XCHG	AX,IPSAVE		; new CS:IP
	XCHG	BX,CSSAVE
; AX:BX is old CS:IP.  We 'PUSH' flags, oldCS and oldIP, reset flags (ifl) and
; set CS:IP to point to interrupt instruction.
	MOV	ES,SSSAVE		; point to user stack
	MOV	DI,SPSAVE
; Take old flags and PUSH the flags.
	MOV	CX,FLSAVE		 ; get flags
	SUB	DI,2			; PUSHF
	MOV	ES:[DI],CX		; rest of push
; Push the old CS
	SUB	DI,2			; PUSH CS
	MOV	ES:[DI],BX		; rest of push
; Push the old IP
	SUB	DI,2			; PUSH IP
	ADD	AX,2			; increment IP
	MOV	ES:[DI],AX		; rest of push
; Update stack
	MOV	SPSAVE,DI		; store
; Take flags and turn interrupts off and trace mode off
	AND	CX,NOT F_INTERRUPT	; CLI
	AND	CX,NOT F_TRACE		; no trace
	MOV	FLSAVE,CX		 ; rest of CLI
; Set up correct process and go to normal reentry code.
	IF	NOT SYSVER
	    MOV     BX,[USER_PROC_PDB]
	    MOV     AH,SET_CURRENT_PDB
	    INT     21H
	ENDIF
	JMP	SETENVIRON
; We need to special case the following instructions that may push a TRACE bit
; on the stack:  PUSHF (9C)

; Save the opcode in A Special place
CHECKOP:
	MOV	RSETFLAG,AL		; no bits to turn off
SETTRACE:
	OR	FLSAVE,F_TRACE		 ; Turn on trace bit
	IF	IBMVER
;
;	the following stuff can be inhibited on 286/386/etc CPUs.  The
;	  designers of the later chips added logic to enhance trace
;	  mode operation.  The reason why we just don't run it all of
;	  the time is that it can cause a system crash if the instruction
;	  being traced causes an overflow condition because nobody will
;	  turn interrupts back on.

	test	cpu_not_8088,1		; see if 8088/8086
	jnz	no_fix_8088

	    CLI
	    IN	    AL,MASK_PORT	; Get current mask
	    JMP     SHORT FOO
FOO:
	    MOV     [OLD_MASK],AL	; Save it
	    MOV     AL,INT_MASK 	; New mask
	    OUT     MASK_PORT,AL	; Set it
	    STI

no_fix_8088:

	ENDIF
DEXIT:
	IF	NOT SYSVER
	    MOV     BX,[USER_PROC_PDB]
	    MOV     AH,SET_CURRENT_PDB
	    INT     21H
	ENDIF
; Unfortunately, any system call we issue will muck with the current extended
; errors.  Here we must restore the extended error state so that if the user
; program gets it, we do not interfere.
	MOV	AX,(SERVERCALL SHL 8) + 10
	MOV	DX,OFFSET DG:SAVESTATE
	INT	21H
	PUSH	DS
	XOR	AX,AX
	MOV	DS,AX
	MOV	WORD PTR DS:[12],OFFSET DG:BREAKFIX ; Set vector 3--breakpoint instruction
	MOV	WORD PTR DS:[14],CS
	MOV	WORD PTR DS:[4],OFFSET DG:REENTER ; Set vector 1--Single step
	MOV	WORD PTR DS:[6],CS
	CLI
	IF	SETCNTC
	    MOV     WORD PTR DS:[8CH],OFFSET DG:CONTC ; Set vector 23H (CTRL-C)
	    MOV     WORD PTR DS:[8EH],CS
	ENDIF
	POP	DS
	MOV	SP,OFFSET DG:STACK
	POP	AX
	POP	BX
	POP	CX
	POP	DX
	POP	BP
	POP	BP
	POP	SI
	POP	DI
	POP	ES
	POP	ES
	POP	SS
	MOV	SP,[SPSAVE]
	PUSH	[FLSAVE]
	PUSH	[CSSAVE]
	PUSH	[IPSAVE]
	MOV	DS,[DSSAVE]
	IRET
STEP1:
	CALL	CRLF
	CALL	DISPREG
	TEST	FZTRACE,-1
	JNZ	STEPZ
	JMP	STEP
STEPZ:	JMP	ZSTEP

; Re-entry point from CTRL-C. Top of stack has address in 86-DOS for
; continuing, so we must pop that off.
CONTC:
	ADD	SP,6
	JMP	SHORT REENTERREAL

; Re-entry point from breakpoint. Need to decrement instruction
; pointer so it points to location where breakpoint actually
; occured.
BREAKFIX:
	PUSH	BP
	MOV	BP,SP
	DEC	WORD PTR [BP].OLDIP
	POP	BP
	JMP	short REENTERREAL

; Re-entry point from trace mode or interrupt during execution.  All registers
; are saved so they can be displayed or modified.
INTERRUPT_FRAME STRUC
OLDBP	DW	?
OLDIP	DW	?
OLDCS	DW	?
OLDF	DW	?
OLDERIP DW	?
OLDERCS DW	?
OLDERF	DW	?
INTERRUPT_FRAME ENDS

ASSUME	CS:DG,DS:NOTHING,ES:NOTHING,SS:NOTHING
; ReEnter is the main entry point for breakpoint interrupts and for trace mode
; interrupts.  We treat both of these cases identically:  save state, display
; registers and go for another command.  If we get NMI's, we skip them or if
; it turns out that we are debugging ourselves, we skip them.

; Due to bogosities in the 808x chip, Consider tracing over an interrupt and
; then setting a breakpoint to where the interrupt returns.  You get the INT 3
; and then trace mode gets invoked!  This is why we ignore interrupts within
; ourselves.
REENTER:
	PUSH	BP
	MOV	BP,SP			; get a frame to address from
	PUSH	AX
;	MOV	AX,CS
;	CMP	AX,[BP].OLDCS		; Did we interrupt ourselves?
;	JNZ	GOREENTER		; no, go reenter
	IF	IBMJAPAN
	    MOV     AX,[BP].OLDIP
	    CMP     AX,OFFSET DG:NMIINT ; interrupt below NMI interrupt?
	    JB	    GOREENTER		; yes, go reenter
	    CMP     [BP].OLDIP,OFFSET DG:NMIINTEND
	    JAE     GOREENTER		; interrupt above NMI interrupt?
	    POP     AX			; restore state
	    POP     BP
	    SUB     SP,6		; switch TRACE and NMI stack frames
	    PUSH    BP
	    MOV     BP,SP		; set up frame
	    PUSH    AX			; get temp variable
	    MOV     AX,[BP].OLDERIP	; get NMI Vector
	    MOV     [BP].OLDIP,AX	; stuff in new NMI vector
	    MOV     AX,[BP].OLDERCS	; get NMI Vector
	    MOV     [BP].OLDCS,AX	; stuff in new NMI vector
	    MOV     AX,[BP].OLDERF	; get NMI Vector
	    AND     AH,0FEH		; turn off Trace if present
	    MOV     [BP].OLDF,AX	; stuff in new NMI vector
	    MOV     [BP].OLDERF,AX
	    MOV     [BP].OLDERIP,OFFSET DG:REENTER ; offset of routine
	    MOV     [BP].OLDERCS,CS	; and CS
	    POP     AX
	    POP     BP
	    IRET			; go try again
	ENDIF
GOREENTER:
	IF	IBMVER
	test	cpu_not_8088,1
	jnz	no_restore_pic_mask
	    MOV     AL,CS:[OLD_MASK]	; Recover Old mask
	    OUT     MASK_PORT,AL	; Restore it
no_restore_pic_mask:
	ENDIF

	MOV	AL,CS:[RSETFLAG]
; Determine, based on the previous instruction, what we are supposed to do
; to flags on the users stack.
	CMP	AL,09CH 		; PUSHF
	JNZ	NOFIX
; OlderIP = flags.  Turn off trace bit
	AND	[BP].OLDERIP,NOT F_TRACE
NOFIX:
	POP	AX
	POP	BP
REENTERREAL:
	MOV	CS:[SPSAVE+SEGDIF],SP
	MOV	CS:[SSSAVE+SEGDIF],SS
	MOV	CS:[FLSAVE],CS
	MOV	SS,CS:[FLSAVE]
	MOV	SP,OFFSET DG:RSTACK
	ASSUME	SS:DG

	PUSH	ES
	PUSH	DS
	PUSH	DI
	PUSH	SI
	PUSH	BP
	DEC	SP
	DEC	SP
	PUSH	DX
	PUSH	CX
	PUSH	BX
	PUSH	AX
	PUSH	SS
	POP	DS
	ASSUME	DS:DG

	MOV	SS,[SSSAVE]
	MOV	SP,[SPSAVE]
	ASSUME	SS:NOTHING

	POP	[IPSAVE]
	POP	[CSSAVE]
	POP	AX
	AND	AX,NOT F_TRACE		; TURN OFf trace mode bit
	MOV	[FLSAVE],AX
	MOV	[SPSAVE],SP
SETENVIRON:
	PUSH	DS
	POP	ES
	ASSUME	ES:DG

	PUSH	DS
	POP	SS
	ASSUME	SS:DG

	MOV	SP,OFFSET DG:STACK
	PUSH	DS
	XOR	AX,AX
	MOV	DS,AX
	ASSUME	DS:NOTHING

	IF	SETCNTC
	    MOV     WORD PTR DS:[8CH],OFFSET DG:DABORT ; Set Ctrl-C vector
	    MOV     WORD PTR DS:[8EH],CS
	ENDIF
	POP	DS
	ASSUME	DS:DG

	STI
	CLD
; Since we are about to issue system calls, let's grab the current user's
; extended error info.
	MOV	AH,GETEXTENDEDERROR
	INT	21H
	ASSUME	DS:NOTHING,ES:NOTHING

	MOV	SAVESTATE.DPL_AX,AX
	MOV	SAVESTATE.DPL_BX,BX
	MOV	SAVESTATE.DPL_CX,CX
	MOV	SAVESTATE.DPL_DX,DX
	MOV	SAVESTATE.DPL_SI,SI
	MOV	SAVESTATE.DPL_DI,DI
	MOV	SAVESTATE.DPL_DS,DS
	MOV	SAVESTATE.DPL_ES,ES
	MOV	AX,CS
	MOV	DS,AX
	MOV	ES,AX
	ASSUME	DS:DG,ES:DG

	IF	NOT SYSVER
	    MOV     AH,GET_CURRENT_PDB
	    INT     21H
	    MOV     [USER_PROC_PDB],BX
	    MOV     BX,BEGSEG
	    MOV     AH,SET_CURRENT_PDB
	    INT     21H
	ENDIF
	MOV	SI,OFFSET DG:BPTAB
	MOV	CX,[BRKCNT]
	JCXZ	SHOREG
	PUSH	ES
CLEARBP:
	LES	DI,DWORD PTR [SI]
	ADD	SI,4
	MOVSB
	LOOP	CLEARBP
	POP	ES
SHOREG:
	DEC	[TCOUNT]
	JZ	CHECKDISP
	JMP	STEP1
CHECKDISP:
	CALL	CRLF
	CALL	DISPREG
	JMP	COMMAND

; Input from the specified port and display result
INPUT:
	MOV	CX,4			; Port may have 4 digits
	CALL	GETHEX			; Get port number in DX
	CALL	GETEOL

	IN	AL,DX			; Variable port input

	PUSH	CS
	POP	ES
	MOV	DI,OFFSET DG:ARG_BUF
	CALL	HEX			; And display

	XOR	AL,AL
	STOSB
	MOV	DX,OFFSET DG:ARG_BUF_PTR
	JMP	PRINTF_CRLF

; Output a value to specified port.
OUTPUT:
	MOV	CX,4			; Port may have 4 digits
	CALL	GETHEX			; Get port number
	PUSH	DX			; Save while we get data
	MOV	CX,2			; Byte output only
	CALL	GETHEX			; Get data to output
	CALL	GETEOL
	XCHG	AX,DX			; Output data in AL
	POP	DX			; Port in DX

	OUT	DX,AL			; Variable port output

	RETURN

SETADD:
	MOV	DX,CSSAVE		; set up start addresses
	MOV	NEXTCS,DX
	MOV	DX,IPSAVE
	MOV	NEXTIP,DX
	MOV	BP,[CSSAVE]
	CALL	SCANP
	CMP	BYTE PTR [SI],"="
	RETNZ
	INC	SI
	CALL	ADDRESS
	MOV	NEXTCS,AX
	MOV	NEXTIP,DX
	RETURN

; Jump to program, setting up registers according to the
; save area. up to 10 breakpoint addresses may be specified.
GO:
	MOV	RSETFLAG,0
	CALL	SETADD
	XOR	BX,BX
	MOV	DI,OFFSET DG:BPTAB
GO1:
	CALL	SCANP
	JZ	DEXEC
	MOV	BP,[CSSAVE]
	PUSH	DI
	PUSH	BX			;AN000; DMS;SAVE BX - ADDRESS KILLS IT
	CALL	ADDRESS
	POP	BX			;AN000; DMS;RESTORE BX
	POP	DI
	MOV	[DI],DX 		; Save offset
	MOV	[DI+2],AX		; Save segment
	ADD	DI,5			; Leave a little room
	INC	BX
	CMP	BX,1+BPMAX
	JNZ	GO1
	MOV	DX,OFFSET DG:BP_ERROR	; BP ERROR
	JMP	ERR
DEXEC:
	MOV	[BRKCNT],BX
	MOV	CX,BX
	JCXZ	NOBP
	MOV	DI,OFFSET DG:BPTAB
	PUSH	DS
SETBP:
	LDS	SI,ES:DWORD PTR [DI]
	ADD	DI,4
	MOVSB
	MOV	BYTE PTR [SI-1],0CCH
	LOOP	SETBP
	POP	DS
NOBP:
	MOV	DX,NEXTCS
	MOV	CSSAVE,DX
	MOV	DX,NEXTIP
	MOV	IPSAVE,DX
	MOV	[TCOUNT],1
	JMP	DEXIT

SKIP_FILE:
	MOV	AH,CHAR_OPER
	XOR	AL,AL			; Get switch char subfunction
	INT	21H
	MOV	CS:[SWITCHAR],DL	; GET THE CURRENT SWITCH CHARACTER
FIND_DELIM:
	LODSB
	CALL	DELIM1
	JZ	GOTDELIM
	CALL	DELIM2
	JNZ	FIND_DELIM
GOTDELIM:
	DEC	SI
	RETURN

COMPARE:
	CALL	DSRANGE
	PUSH	CX
	PUSH	AX
	PUSH	DX
	CALL	ADDRESS 		; Same segment
	CALL	GETEOL
	POP	SI
	MOV	DI,DX
	MOV	ES,AX
	POP	DS
	POP	CX			; Length
	DEC	CX
	CALL	COMP			; Do one less than total
	INC	CX			; CX=1 (do last one)
COMP:
	REPE	CMPSB
	RETZ
; Compare error. Print address, value; value, address.
	DEC	SI
	MOV	CS:COMP_ARG1,DS
	MOV	CS:COMP_ARG2,SI
	XOR	AH,AH
	LODSB
	MOV	CS:COMP_ARG3,AX
	DEC	DI
	MOV	AL,ES:[DI]
	MOV	CS:COMP_ARG4,AX
	MOV	CS:COMP_ARG5,ES
	MOV	CS:COMP_ARG6,DI
	INC	DI
	PUSH	DS
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET DG:COMP_PTR
	CALL	PRINTF_CRLF
	POP	DS
	XOR	AL,AL
	JMP	SHORT COMP

	PROCEDURE CHECKNONE,NEAR
	OR	DX,DX
	RETNZ
	MOV	DX,OFFSET DG:SYNERR_PTR ; ERROR MESSAGE
	JMP	PERR
	ENDPROC CHECKNONE

CODE	ENDS
	END	DEBCOM3

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\debasm.asm ===
PAGE	80,132 ;
	TITLE	DEBASM.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; CODE FOR THE ASSEMBLE COMMAND IN THE DEBUGGER

	IF1
	    %OUT COMPONENT=DEBUG, MODULE=DEBASM
	ENDIF
.XLIST
.XCREF
	include	version.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC
        INCLUDE debug.inc
.CREF
.LIST


CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE

	EXTRN	DBMN:BYTE,CSSAVE:WORD,REG8:BYTE,REG16:BYTE,SIZ8:BYTE
	EXTRN	SYNERR_PTR:BYTE,OPTAB:BYTE,MAXOP:ABS

CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE

	EXTRN	HINUM:WORD,LOWNUM:WORD,ASSEM_CNT:BYTE
	EXTRN	ASSEM1:BYTE,ASSEM2:BYTE,ASSEM3:BYTE,ASSEM4:BYTE,ASSEM5:BYTE
	EXTRN	ASSEM6:BYTE,OPBUF:BYTE,OPCODE:WORD,REGMEM:BYTE,INDEX:WORD
	EXTRN	ASMADD:BYTE,ASMSP:WORD,MOVFLG:BYTE,SEGFLG:BYTE,TSTFLG:BYTE
	EXTRN	NUMFLG:BYTE,DIRFLG:BYTE,BYTEBUF:BYTE,F8087:BYTE,DIFLG:BYTE
	EXTRN	SIFLG:BYTE,BXFLG:BYTE,BPFLG:BYTE,NEGFLG:BYTE,MEMFLG:BYTE
	EXTRN	REGFLG:BYTE,AWORD:BYTE,MIDFLD:BYTE,MODE:BYTE
	EXTRN	ARG_BUF:BYTE,HEX_PTR:BYTE

DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG

	PUBLIC	ASSEM
	PUBLIC	DB_OPER,DW_OPER,ASSEMLOOP,GROUP2,AA_OPER,DCINC_OPER
	PUBLIC	GROUP1,ESC_OPER,FGROUPP,FGROUPX,FDE_OPER,FGROUPZ
	PUBLIC	FD9_OPER,FGROUP,FDB_OPER,FGROUPB,FGROUP3,FGROUP3W
	PUBLIC	FGROUPDS,INT_OPER,IN_OPER,DISP8_OPER,JMP_OPER,NO_OPER
	PUBLIC	OUT_OPER,L_OPER,MOV_OPER,POP_OPER,PUSH_OPER,ROTOP
	PUBLIC	TST_OPER,EX_OPER,GET_DATA16,CALL_OPER, DOORG

	EXTRN	INBUF:NEAR,SCANB:NEAR,SCANP:NEAR,GETHX:NEAR,GET_ADDRESS:NEAR
	EXTRN	DEFAULT:NEAR,OUTDI:NEAR,BLANK:NEAR,TAB:NEAR
	EXTRN	STD_PRINTF:NEAR,PRINTF_CRLF:NEAR

;	Line by line assembler

MASKMOD EQU	11000000B
SHMOD	EQU	6
MASKREG EQU	00111000B
SHREG	EQU	3
MASKRM	EQU	00000111B
SHRM	EQU	0

ASSEM:
	MOV	BP,[CSSAVE]		; Default code segment
	MOV	DI,OFFSET DG:ASMADD	; Default address
	CALL	DEFAULT
	MOV	WORD PTR [ASMADD],DX	; Displacement of disassembly
	MOV	WORD PTR [ASMADD+2],AX	; Segment
	MOV	[ASMSP],SP		; Save sp in case of error

ASSEMLOOP:
	MOV	SP,[ASMSP]		; Restore sp in case of error
	LES	DI,DWORD PTR ASMADD	; GET PC
	CALL	OUTDI			; OUTPUT ADDRESS
	PUSH	CS
	POP	ES
	PUSH	DI
	MOV	DI,OFFSET DG:ARG_BUF
; No spacing is needed.  The format string already has one.
;	CALL	BLANK			; SKIP A SPACE
	XOR	AL,AL
	STOSB
	MOV	DX,OFFSET DG:HEX_PTR
	CALL	STD_PRINTF
	POP	DI
	CALL	INBUF			; GET A BUFFER
	CALL	SCANB
	JNZ	OPLOOK
	RET				; if empty just return

;  At this point ds:si points to the opcode mnemonic...
OPLOOK:
	XOR	CX,CX			; OP-CODE COUNT = 0
	MOV	DI,OFFSET DG:DBMN
OPSCAN:
	XOR	BX,BX
OPLOOP:
	MOV	AL,[DI+BX]
	CMP	AL,[SI+BX]
	JZ	OPMATCH
	INC	CX			; INCREMENT OP-CODE COUNT
	CMP	CX,MAXOP		; CHECK FOR END OF LIST
	JB	OP1
	JMP	ASMERR
OP1:
	INC	DI			; SCAN FOR NEXT OP-CODE...
	CMP	BYTE PTR [DI-1],0
	JNZ	OP1
	JMP	OPSCAN

OPMATCH:
	INC	BX			; COMPARE NEXT CHAR
	CMP	BYTE PTR [DI+BX],0	; ARE WE DONE?
	JNZ	OPLOOP			; ..IF NOT KEEP COMPARING
	XCHG	BX,CX
	MOV	AX,BX
	SHL	AX,1
	ADD	AX,BX
	ADD	AX,OFFSET DG:OPTAB
	MOV	BX,AX

; CX = COUNT OF CHARS IN OPCODE
; BX = POINTER INTO OPCODE TABLE

	XOR	AX,AX
	MOV	BYTE PTR [AWORD],AL
	MOV	WORD PTR [MOVFLG],AX	; MOVFLG + TSTFLG
	MOV	BYTE PTR [SEGFLG],AL	; ZERO SEGMENT REGISTER FLAG
	MOV	AH,00001010B		; SET UP FOR AA_OPER
	MOV	AL,BYTE PTR [BX]
	MOV	WORD PTR [ASSEM1],AX
	MOV	BYTE PTR [ASSEM_CNT],1

	ADD	SI,CX			; SI POINTS TO OPERAND
	JMP	WORD PTR [BX+1]

; 8087 INSTRUCTIONS WITH NO OPERANDS

FDE_OPER:
	MOV	AH,0DEH
	JMP	SHORT FDX_OPER
FDB_OPER:
	MOV	AH,0DBH
	JMP	SHORT FDX_OPER
FD9_OPER:
	MOV	AH,0D9H
FDX_OPER:
	XCHG	AL,AH
	MOV	WORD PTR [ASSEM1],AX

;  AAD AND AAM INSTRUCIONS

AA_OPER:
	INC	BYTE PTR [ASSEM_CNT]

;  INSTRUCTIONS WITH NO OPERANDS

NO_OPER:
	CALL	STUFF_BYTES
	CALL	SCANP
	PUSH	CS
	POP	ES
	JNZ	OPLOOK
	JMP	ASSEMLOOP

;  PUSH INSTRUCTION

PUSH_OPER:
	MOV	AH,11111111B
	JMP	SHORT POP1

;  POP INSTRUCTION

POP_OPER:
	MOV	AH,10001111B
POP1:
	MOV	[ASSEM1],AH
	MOV	[MIDFLD],AL
	INC	BYTE PTR [MOVFLG]	; ALLOW SEGMENT REGISTERS
	MOV	BYTE PTR [AWORD],2	; MUST BE 16 BITS
	CALL	GETREGMEM
	CALL	BUILDIT
	MOV	AL,[DI+2]
	CMP	AL,11000000B
	JB	DATRET
	MOV	BYTE PTR [DI],1
	CMP	BYTE PTR [MOVFLG],2
	JNZ	POP2
	AND	AL,00011000B
	OR	AL,00000110B
	CMP	BYTE PTR [MIDFLD],0
	JNZ	POP3
	OR	AL,00000001B
	JMP	SHORT POP3

POP2:
	AND	AL,MASKRM
	OR	AL,01010000B
	CMP	BYTE PTR [MIDFLD],0
	JNZ	POP3
	OR	AL,01011000B
POP3:
	MOV	BYTE PTR [DI+1],AL
	JMP	ASSEM_EXIT

; RET AND RETF INSTRUCTIONS

GET_DATA16:
	CALL	SCANB
	MOV	CX,4
	CALL	GETHX
	JC	DATRET
	DEC	BYTE PTR [ASSEM1]	; CHANGE OP-CODE
	ADD	BYTE PTR [ASSEM_CNT],2	; UPDATE LENGTH
	MOV	WORD PTR [ASSEM2],DX	; SAVE OFFSET
DATRET:
	JMP	ASSEM_EXIT


;  INT INSTRUCTION

INT_OPER:
	CALL	SCANB
	MOV	CX,2
	CALL	GETHX
	JC	ERRV1
	MOV	AL,DL
	CMP	AL,3
	JZ	DATRET
	INC	BYTE PTR [ASSEM1]
	JMP	DISPX

;  IN INSTRUCTION

IN_OPER:
	CALL	SCANB
	LODSW
	CMP	AX,'A'+4C00H            ; "AL"
	JZ	IN_1
	CMP	AX,'A'+5800H            ; "AX"
	JZ	IN_0
ERRV1:
	JMP	ASMERR
IN_0:
	INC	BYTE PTR [ASSEM1]
IN_1:
	CALL	SCANP
	CMP	WORD PTR [SI],'D'+5800H ; "DX"
	JZ	DATRET
	MOV	CX,2
	CALL	GETHX
	JC	ERRV1
	AND	BYTE PTR [ASSEM1],11110111B
	MOV	AL,DL
	JMP	DISPX

;  OUT INSTRUCTION

OUT_OPER:
	CALL	SCANB
	CMP	WORD PTR [SI],'D'+5800H ; "DX"
	JNZ	OUT_0
	INC	SI
	INC	SI
	JMP	SHORT OUT_1
OUT_0:
	AND	BYTE PTR [ASSEM1],11110111B
	MOV	CX,2
	CALL	GETHX
	JC	ERRV1
	INC	BYTE PTR [ASSEM_CNT]
	MOV	BYTE PTR [ASSEM2],DL
OUT_1:
	CALL	SCANP
	LODSW
	CMP	AX,'A'+4C00H            ; "AL"
	JZ	DATRET
	CMP	AX,'A'+5800H            ; "AX"
	JNZ	ERRV1
	INC	BYTE PTR [ASSEM1]
	JMP	DATRET


;  JUMP INSTRUCTION

JMP_OPER:
	INC	BYTE PTR [TSTFLG]

;  CALL INSTRUCTION

CALL_OPER:
	MOV	BYTE PTR [ASSEM1],11111111B
	MOV	BYTE PTR [MIDFLD],AL
	CALL	GETREGMEM
	CALL	BUILD3
	CMP	BYTE PTR [MEMFLG],0
	JNZ	CALLJ1
	CMP	BYTE PTR [REGMEM],-1
	JZ	CALLJ2

;  INDIRECT JUMPS OR CALLS

CALLJ1:
	CMP	BYTE PTR [AWORD],1
ERRZ4:
	JZ	ERRV1
	CMP	BYTE PTR [AWORD],4
	JNZ	ASMEX4
	OR	BYTE PTR [DI+2],1000B
	JMP	SHORT ASMEX4

;   DIRECT JUMPS OR CALLS

CALLJ2:
	MOV	AX,[LOWNUM]
	MOV	DX,[HINUM]
	MOV	BL,[AWORD]
	CMP	BYTE PTR [NUMFLG],0
	JZ	ERRZ4

;  BL = NUMBER OF BYTES IN JUMP
;  DX = OFFSET
;  AX = SEGMENT

CALLJ3:
	MOV	BYTE PTR [DI],5
	MOV	[DI+2],AX
	MOV	[DI+4],DX

	MOV	AL,10011010B		; SET UP INTER SEGMENT CALL
	CMP	BYTE PTR [TSTFLG],0
	JZ	CALLJ5
	MOV	AL,11101010B		; FIX UP FOR JUMP
CALLJ5:
	MOV	BYTE PTR [DI+1],AL
	CMP	BL,4			; FAR SPECIFIED?
	JZ	ASMEX4
	OR	BL,BL
	JNZ	CALLJ6
	CMP	DX,WORD PTR [ASMADD+2]	; DIFFERENT SEGMENT?
	JNZ	ASMEX4

CALLJ6:
	MOV	BYTE PTR [DI],3
	MOV	AL,11101000B		; SET UP FOR INTRASEGMENT
	OR	AL,[TSTFLG]
	MOV	BYTE PTR [DI+1],AL

	MOV	AX,[LOWNUM]
	SUB	AX,WORD PTR [ASMADD]
	SUB	AX,3
	MOV	[DI+2],AX
	CMP	BYTE PTR [TSTFLG],0
	JZ	ASMEX4
	CMP	BL,2
	JZ	ASMEX4

	INC	AX
	MOV	CX,AX
	CBW
	CMP	AX,CX
	JNZ	ASMEX3
	MOV	BYTE PTR [DI+1],11101011B
	MOV	[DI+2],AX
	DEC	BYTE PTR [DI]
ASMEX4:
	JMP	ASSEM_EXIT

;  CONDITIONAL JUMPS AND LOOP INSTRUCTIONS

DISP8_OPER:
	MOV	BP,WORD PTR [ASMADD+2]	; GET DEFAULT DISPLACEMENT
	CALL	GET_ADDRESS
	SUB	DX,WORD PTR [ASMADD]
	DEC	DX
	DEC	DX
	CALL	CHKSIZ
	CMP	CL,1
	JNZ	ERRV2
DISPX:
	INC	[ASSEM_CNT]
	MOV	BYTE PTR [ASSEM2],AL
ASMEX3:
	JMP	ASSEM_EXIT

;  LDS, LES, AND LEA INSTRUCTIONS

L_OPER:
	CALL	SCANB
	LODSW
	MOV	CX,8
	MOV	DI,OFFSET DG:REG16
	CALL	CHKREG
	JZ	ERRV2			; CX = 0 MEANS NO REGISTER
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	MOV	BYTE PTR [MIDFLD],AL
	CALL	SCANP
	CALL	GETREGMEM
	CMP	BYTE PTR [AWORD],0
	JNZ	ERRV2
	CALL	BUILD2
	JMP	SHORT ASEXV

;  DEC AND INC INSTRUCTIONS

DCINC_OPER:
	MOV	BYTE PTR [ASSEM1],11111110B
	MOV	BYTE PTR [MIDFLD],AL
	CALL	GETREGMEM
	CALL	BUILDIT
	TEST	BYTE PTR [DI+1],1
	JZ	ASEXV
	MOV	AL,[DI+2]
	CMP	AL,MASKMOD
	JB	ASEXV
	AND	AL,1111B
	OR	AL,01000000B
	MOV	[DI+1],AL
	DEC	BYTE PTR [DI]
ASEXV:
	JMP	ASSEM_EXIT

ERRV2:
	JMP	ASMERR

; ESC INSTRUCTION

ESC_OPER:
	INC	BYTE PTR [AWORD]
	CALL	SCANB
	MOV	CX,2
	CALL	GETHX
	CMP	DX,64
	JAE	ERRV2
	CALL	SCANP
	MOV	AX,DX
	MOV	CL,3
	SHR	DX,CL
	OR	[ASSEM1],DL
	AND	AL,111B
	SHL	AL,CL
	JMP	GROUPE

; 8087 ARITHMETIC INSTUCTIONS

;  OPERANDS THAT ALLOW THE REVERSE BIT

FGROUPDS:
	CALL	SETMID
	CALL	GETREGMEM2
	CALL	BUILD3
	CMP	BYTE PTR [MODE],11000000B
	JNZ	FGROUP1
	MOV	AL,[DIRFLG]
	OR	AL,AL
	JZ	FEXIT
	OR	[DI+1],AL		; IF D=1...
	XOR	BYTE PTR [DI+2],00001000B ; ...REVERSE THE SENSE OF R
	JMP	SHORT FEXIT

;  HERE WHEN INSTRUCTION COULD HAVE MEMORY OR REGISTER OPERAND

FGROUPX:
	CALL	SETMID			; THIS ENTRY POINT FOR 1 MEM OPER
	MOV	BYTE PTR [DIRFLG],0
	JMP	SHORT FGRP2
FGROUP:
	CALL	SETMID
FGRP2:
	CALL	GETREGMEM2
	CALL	BUILD3
	CMP	BYTE PTR [MODE],11000000B
	JNZ	FGROUP1
	MOV	AL,[DIRFLG]
	OR	[DI+1],AL
	JMP	SHORT FEXIT
FGROUP1:
	CALL	SETMF
FEXIT:
	JMP	ASSEM_EXIT

; THESE 8087 INSTRUCTIONS REQUIRE A MEMORY OPERAND
FGROUPB:
	MOV	AH,5			; MUST BE TBYTE
	JMP	SHORT FGROUP3E
FGROUP3W:
	MOV	AH,2			; MUST BE WORD
	JMP	SHORT FGROUP3E
FGROUP3:
	MOV	AH,-1			; SIZE CANNOT BE SPECIFIED
FGROUP3E:
	MOV	[AWORD],AH
	CALL	SETMID
	CALL	GETREGMEM
	CMP	BYTE PTR [MODE],11000000B
	JZ	FGRPERR
FGRP:
	CALL	BUILD3
	JMP	FEXIT

; THESE 8087 INSTRUCTIONS REQUIRE A REGISTER OPERAND
FGROUPP:				; 8087 POP OPERANDS
	MOV	BYTE PTR [AWORD],-1
	CALL	SETMID
	CALL	GETREGMEM2
	CMP	BYTE PTR [DIRFLG],0
	JNZ	FGRP
FGRPERR:
	JMP	ASMERR

FGROUPZ:				; ENTRY POINT WHERE ARG MUST BE MEM
	CALL	SETMID
	MOV	BYTE PTR [DIRFLG],0
	CALL	GETREGMEM
	CMP	BYTE PTR [MODE],11000000B
	JZ	FGRPERR
	CALL	BUILD3
	CALL	SETMF
	JMP	FEXIT

; NOT, NEG, MUL, IMUL, DIV, AND IDIV INSTRUCTIONS

GROUP1:
	MOV	[ASSEM1],11110110B
GROUPE:
	MOV	BYTE PTR [MIDFLD],AL
	CALL	GETREGMEM
	CALL	BUILDIT
	JMP	FEXIT

;  SHIFT AND ROTATE INSTRUCTIONS

ROTOP:
	MOV	[ASSEM1],11010000B
	MOV	BYTE PTR [MIDFLD],AL
	CALL	GETREGMEM
	CALL	BUILDIT
	CALL	SCANP
	CMP	BYTE PTR [SI],'1'
	JZ	ASMEXV1
	CMP	WORD PTR [SI],"LC"      ; CL
	JZ	ROTOP1
ROTERR:
	JMP	ASMERR
ROTOP1:
	OR	BYTE PTR [ASSEM1],10B
ASMEXV1:
	JMP	ASSEM_EXIT

;  XCHG INSTRUCTION

EX_OPER:
	INC	BYTE PTR [TSTFLG]

;   TEST INSTRUCTION

TST_OPER:
	INC	BYTE PTR [TSTFLG]
	JMP	SHORT MOVOP

;    MOV INSTRUCTION

MOV_OPER:
	INC	BYTE PTR [MOVFLG]
MOVOP:
	XOR	AX,AX
	JMP	SHORT GROUPM

;   ADD, ADC, SUB, SBB, CMP, AND, OR, XOR instructions

GROUP2:
	MOV	BYTE PTR [ASSEM1],10000000B
GROUPM:
	MOV	BYTE PTR [MIDFLD],AL

	PUSH	AX
	CALL	GETREGMEM
	CALL	BUILD2
	CALL	SCANP			; POINT TO NEXT OPERAND
	MOV	AL,BYTE PTR [ASSEM_CNT]
	PUSH	AX
	CALL	GETREGMEM
	POP	AX
	MOV	BYTE PTR [DI],AL
	POP	AX
	MOV	BL,BYTE PTR [AWORD]
	OR	BL,BL
	JZ	ERRV5
	DEC	BL
	AND	BL,1
	OR	BYTE PTR [DI+1],BL

	CMP	BYTE PTR [MEMFLG],0
	JNZ	G21V
	CMP	BYTE PTR [NUMFLG],0	; TEST FOR IMMEDIATE DATA
	JZ	G21V
	CMP	BYTE PTR [SEGFLG],0
	JNZ	ERRV5
	CMP	BYTE PTR [TSTFLG],2	; XCHG?
	JNZ	IMMED1
ERRV5:
	JMP	ASMERR
G21V:
	JMP	GRP21

;  SECOND OPERAND WAS IMMEDIATE

IMMED1:
	MOV	AL,BYTE PTR [DI+2]
	CMP	BYTE PTR [MOVFLG],0
	JZ	NOTMOV1
	AND	AL,11000000B
	CMP	AL,11000000B
	JNZ	GRP23			; not to a register
					; MOVE IMMEDIATE TO REGISTER
	MOV	AL,BYTE PTR [DI+1]
	AND	AL,1			; SET SIZE
	PUSHF
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	OR	AL,BYTE PTR [DI+2]	; SET REGISTER
	AND	AL,00001111B
	OR	AL,10110000B
	MOV	BYTE PTR [DI+1],AL
	MOV	AX,WORD PTR [LOWNUM]
	MOV	WORD PTR [DI+2],AX
	POPF
	JZ	EXVEC
	INC	BYTE PTR [DI]
EXVEC:
	JMP	GRPEX

NOTMOV1:
	AND	AL,11000111B
	CMP	AL,11000000B
	JZ	IMMACC			; IMMEDIATE TO ACC

	CMP	BYTE PTR [TSTFLG],0
	JNZ	GRP23
	CMP	BYTE PTR [MIDFLD],1*8	; OR?
	JZ	GRP23
	CMP	BYTE PTR [MIDFLD],4*8	; AND?
	JZ	GRP23
	CMP	BYTE PTR [MIDFLD],6*8	; XOR?
	JZ	GRP23
	TEST	BYTE PTR [DI+1],1	; TEST IF BYTE OPCODE
	JZ	GRP23

	MOV	AX,[LOWNUM]
	MOV	BX,AX
	CBW
	CMP	AX,BX
	JNZ	GRP23			; SMALL ENOUGH?

	MOV	BL,[DI]
	DEC	BYTE PTR [DI]
	OR	BYTE PTR [DI+1],10B
	JMP	SHORT GRP23X

IMMACC:
	MOV	AL,BYTE PTR [DI+1]
	AND	AL,1
	CMP	BYTE PTR [TSTFLG],0
	JZ	NOTTST
	OR	AL,10101000B
	JMP	SHORT TEST1
NOTTST:
	OR	AL,BYTE PTR [MIDFLD]
	OR	AL,100B
TEST1:
	MOV	BYTE PTR [DI+1],AL
	DEC	BYTE PTR [DI]

GRP23:
	MOV	BL,BYTE PTR [DI]
GRP23X:
	XOR	BH,BH
	ADD	BX,DI
	INC	BX
	MOV	AX,WORD PTR [LOWNUM]
	MOV	WORD PTR [BX],AX
	INC	BYTE PTR [DI]
	TEST	BYTE PTR [DI+1],1
	JZ	GRPEX1
	INC	BYTE PTR [DI]
GRPEX1:
	JMP	GRPEX

;	SECOND OPERAND WAS MEMORY OR REGISTER

GRP21:
	CMP	BYTE PTR [SEGFLG],0
	JZ	GRP28			; FIRST OPERAND WAS A SEGMENT REG
	MOV	AL,BYTE PTR [REGMEM]
	TEST	AL,10000B
	JZ	NOTSEG1
ERRV3:
	JMP	ASMERR
NOTSEG1:
	AND	AL,111B
	OR	BYTE PTR [DI+2],AL
	AND	BYTE PTR [DI+1],11111110B
	CMP	BYTE PTR [MEMFLG],0
	JNZ	G22V
	JMP	GRPEX

GRP28:
	AND	BYTE PTR [DI+2],11000111B
	MOV	AL,BYTE PTR [DI+1]	; GET FIRST OPCODE
	AND	AL,1B
	CMP	BYTE PTR [MOVFLG],0
	JZ	NOTMOV2
	OR	AL,10001000B
	JMP	SHORT MOV1
NOTMOV2:
	CMP	BYTE PTR [TSTFLG],0
	JZ	NOTTST2
	OR	AL,10000100B
	CMP	BYTE PTR [TSTFLG],2
	JNZ	NOTTST2
	OR	AL,10B
NOTTST2:
	OR	AL,BYTE PTR [MIDFLD]	; MIDFLD IS ZERO FOR TST
MOV1:
	MOV	BYTE PTR [DI+1],AL
	CMP	BYTE PTR [MEMFLG],0
G22V:
	JZ	NotGRP22
	JMP	GRP22
NotGRP22:

;	SECOND OPERAND WAS A REGISTER

	MOV	AL,BYTE PTR [REGMEM]
	TEST	AL,10000B		; SEGMENT REGISTER?
	JZ	NOTSEG
	CMP	BYTE PTR [MOVFLG],0
	JZ	ERRV3
	MOV	BYTE PTR [DI+1],10001100B

NOTSEG:
	AND	AL,111B
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	OR	BYTE PTR [DI+2],AL
; ARR 2.4
; In the case of the XCHG reg,reg and TEST reg,reg we have just built the
; instruction backwards.  This is because these two instructions do not have
; the D bit.  We need to switch R/S and REG
;
; Good comment Aaron, except that we do NOT switch if a memory operand was
; present for precisely the reason that the D bit is not present
;
	CMP	BYTE PTR [TSTFLG],0
	JZ	NOSWITCH		; Not XCHG or TEST
;
; See if there is a memory operand specified.  If the MOD field is 11, then
; we do perform the exchange.
;
	MOV	AH,[DI+2]
	AND	AH,MASKMOD
	CMP	AH,MASKMOD
	JNZ	NOSWITCH
	MOV	AH,BYTE PTR [DI+2]
	AND	AH,MASKRM
	SHL	AH,1			; Low three bits to middle three
	SHL	AH,1
	SHL	AH,1
	MOV	AL,BYTE PTR [DI+2]
	AND	AL,MASKREG
	SHR	AL,1			; Middle three to low three
	SHR	AL,1
	SHR	AL,1
	OR	AL,AH			; Re combine
	AND	BYTE PTR [DI+2],MASKMOD ; Zap original
	OR	BYTE PTR [DI+2],AL	; New low 6 bits
NOSWITCH:


; SPECIAL FORM OF THE EXCHANGE COMMAND

	CMP	BYTE PTR [TSTFLG],2
	JNZ	GRPEX
	TEST	BYTE PTR [DI+1],1
	JZ	GRPEX
	PUSH	AX
	MOV	AL,BYTE PTR [DI+2]
	AND	AL,MASKMOD
	CMP	AL,MASKMOD		; MUST BE REGISTER TO REGISTER
	POP	AX
	JB	GRPEX
	OR	AL,AL
	JZ	SPECX
	MOV	AL,[DI+2]
	AND	AL,MASKRM
	JNZ	GRPEX
	MOV	CL,3
	SHR	BYTE PTR [DI+2],CL
SPECX:
	MOV	AL,[DI+2]
	AND	AL,MASKRM
	OR	AL,10010000B
	MOV	BYTE PTR [DI+1],AL
	DEC	BYTE PTR [DI]
	JMP	SHORT GRPEX

;  SECOND OPERAND WAS A MEMORY REFERENCE

GRP22:
	CMP	BYTE PTR [TSTFLG],0
	JNZ	TST2
	OR	BYTE PTR [DI+1],10B
TST2:
	MOV	AL,BYTE PTR [DI+2]
	CMP	AL,MASKMOD		; MUST BE A REGISTER
	JB	ASMERR
	CMP	BYTE PTR [SEGFLG],0
	JZ	GRP223
	AND	AL,00011000B
	JMP	SHORT GRP222
GRP223:
	AND	AL,MASKRM
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
GRP222:
	OR	AL,BYTE PTR [MODE]
	OR	AL,BYTE PTR [REGMEM]
	MOV	BYTE PTR [DI+2],AL
	MOV	AX,WORD PTR [LOWNUM]
	MOV	WORD PTR [DI+3],AX
GRPSIZ:
	MOV	BYTE PTR [DI],2
	MOV	AL,BYTE PTR [DI+2]
	AND	AL,11000111B
	CMP	AL,00000110B
	JZ	GRP24
	AND	AL,MASKMOD
	CMP	AL,01000000B
	JZ	GRP25
	CMP	AL,10000000B
	JNZ	GRPEX
GRP24:
	INC	BYTE PTR [DI]
GRP25:
	INC	BYTE PTR [DI]

GRPEX:
	CMP	BYTE PTR [MOVFLG],0
	JZ	ASSEM_EXIT

;	TEST FOR SPECIAL FORM OF MOV AX,[MEM] OR MOV [MEM],AX

	MOV	AL,[DI+1]		; GET OP-CODE
	AND	AL,11111100B
	CMP	AL,10001000B
	JNZ	ASSEM_EXIT
	CMP	BYTE PTR [DI+2],00000110B ; MEM TO AX OR AX TO MEM
	JNZ	ASSEM_EXIT
	MOV	AL,BYTE PTR [DI+1]
	AND	AL,11B
	XOR	AL,10B
	OR	AL,10100000B
	MOV	BYTE PTR [DI+1],AL
	DEC	BYTE PTR [DI]
	MOV	AX,[DI+3]
	MOV	WORD PTR [DI+2],AX

ASSEM_EXIT:
	CALL	STUFF_BYTES
	JMP	ASSEMLOOP

; Assem error. SI points to character in the input buffer
; which caused error. By subtracting from start of buffer,
; we will know how far to tab over to appear directly below
; it on the terminal. Then print "^ Error".

ASMERR:
	SUB	SI,OFFSET DG:(BYTEBUF-10) ; How many char processed so far?
	MOV	CX,SI			; Parameter for TAB in CX
	MOV	DI,OFFSET DG:ARG_BUF
	CALL	TAB			; Directly below bad char
	MOV	BYTE PTR [DI],0
	MOV	DX,OFFSET DG:SYNERR_PTR ; Error message
	CALL	PRINTF_CRLF
	JMP	ASSEMLOOP
;
;  assemble the different parts into an instruction
;
BUILDIT:
	MOV	AL,BYTE PTR [AWORD]
	OR	AL,AL
	JNZ	BUILD1
BLDERR:
	JMP	ASMERR

BUILD1:
	DEC	AL
	OR	BYTE PTR [DI+1],AL	; SET THE SIZE

BUILD2:
	CMP	BYTE PTR [NUMFLG],0	; TEST FOR IMMEDIATE DATA
	JZ	BUILD3
	CMP	BYTE PTR [MEMFLG],0
	JZ	BLDERR

BUILD3:
	MOV	AL,BYTE PTR [REGMEM]
	CMP	AL,-1
	JZ	BLD1
	TEST	AL,10000B		; TEST IF SEGMENT REGISTER
	JZ	BLD1
	CMP	BYTE PTR [MOVFLG],0
	JZ	BLDERR
	MOV	WORD PTR [DI+1],10001110B
	INC	BYTE PTR [MOVFLG]
	INC	BYTE PTR [SEGFLG]
	AND	AL,00000011B
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	OR	AL,MASKMOD
	MOV	BYTE PTR [DI+2],AL
	RET

BLD1:
	AND	AL,00000111B
BLD4:
	OR	AL,BYTE PTR [MODE]
	OR	AL,BYTE PTR [MIDFLD]
	MOV	BYTE PTR [DI+2],AL
	MOV	AX,WORD PTR [LOWNUM]
	MOV	WORD PTR [DI+3],AX
	RET

GETREGMEM:
	MOV	BYTE PTR [F8087],0
GETREGMEM2:
	CALL	SCANP
	XOR	AX,AX
	MOV	WORD PTR [LOWNUM],AX	; OFFSET
	MOV	WORD PTR [DIFLG],AX	; DIFLG+SIFLG
	MOV	WORD PTR [BXFLG],AX	; BXFLG+BPFLG
	MOV	WORD PTR [NEGFLG],AX	; NEGFLG+NUMFLG
	MOV	WORD PTR [MEMFLG],AX	; MEMFLG+REGFLG
	DEC	AL
	CMP	BYTE PTR [F8087],0
	JZ	PUTREG
	MOV	AL,1			; DEFAULT 8087 REG IS 1
PUTREG:
	MOV	BYTE PTR [REGMEM],AL

GETLOOP:
	MOV	BYTE PTR [NEGFLG],0
GETLOOP1:
	MOV	AX,WORD PTR [SI]
	CMP	AL,','
	JZ	GOMODE
	CMP	AL,13
	JZ	GOMODE
	CMP	AL,';'
	JZ	GOMODE
	CMP	AL,9
	JZ	GETTB
	CMP	AL,' '
	JNZ	GOGET
GETTB:
	INC	SI
	JMP	GETLOOP1
GOGET:
	JMP	GETINFO

;  DETERMINE THE MODE BITS

GOMODE:
	MOV	DI,OFFSET DG:ASSEM_CNT
	MOV	BYTE PTR [MODE],11000000B
	MOV	BYTE PTR [ASSEM_CNT],2
	CMP	BYTE PTR [MEMFLG],0
	JNZ	GOMODE1
	MOV	AL,[NUMFLG]
	OR	AL,[REGFLG]
	JNZ	MORET
	OR	AL,[F8087]
	JZ	ERRET
	MOV	AL,[DI+1]
	OR	AL,[DIRFLG]
	CMP	AL,0DCH 		; ARITHMETIC?
	JNZ	MORET
	MOV	BYTE PTR [DI+1],0DEH	; ADD POP TO NULL ARG 8087
MORET:
	RET
ERRET:
	JMP	ASMERR

GOMODE1:
	MOV	BYTE PTR [MODE],0
	CMP	BYTE PTR [NUMFLG],0
	JZ	GOREGMEM

	MOV	BYTE PTR [DI],4
	MOV	AX,WORD PTR [DIFLG]
	OR	AX,WORD PTR [BXFLG]
	JNZ	GOMODE2
	MOV	BYTE PTR [REGMEM],00000110B
	RET

GOMODE2:
	MOV	BYTE PTR [MODE],10000000B
	CALL	CHKSIZ1
	CMP	CL,2
	JZ	GOREGMEM
	DEC	BYTE PTR [DI]
	MOV	BYTE PTR [MODE],01000000B

;  DETERMINE THE REG-MEM BITS

GOREGMEM:
	MOV	BX,WORD PTR [BXFLG]
	MOV	CX,WORD PTR [DIFLG]
	XOR	DX,DX
GOREG0:
	MOV	AL,BL			; BX
	ADD	AL,CH			; SI
	CMP	AL,2
	JZ	GOGO
	INC	DL
	MOV	AL,BL
	ADD	AL,CL
	CMP	AL,2
	JZ	GOGO
	INC	DL
	MOV	AL,BH
	ADD	AL,CH
	CMP	AL,2
	JZ	GOGO
	INC	DL
	MOV	AL,BH
	ADD	AL,CL
	CMP	AL,2
	JZ	GOGO
	INC	DL
	OR	CH,CH
	JNZ	GOGO
	INC	DL
	OR	CL,CL
	JNZ	GOGO
	INC	DL			; BP+DISP
	OR	BH,BH
	JZ	GOREG1
	CMP	BYTE PTR [MODE],0
	JNZ	GOGO
	MOV	BYTE PTR [MODE],01000000B
	INC	BYTE PTR [DI]
	DEC	DL
GOREG1:
	INC	DL			; BX+DISP
GOGO:
	MOV	BYTE PTR [REGMEM],DL
	RET

GETINFO:
	CMP	AX,'EN'                 ; NEAR
	JNZ	GETREG3
GETREG0:
	MOV	DL,2
GETRG01:
	CALL	SETSIZ1
GETREG1:
	CALL	SCANS
	MOV	AX,WORD PTR [SI]
	CMP	AX,"TP"                 ; PTR
	JZ	GETREG1
	JMP	GETLOOP

GETREG3:
	MOV	CX,5
	MOV	DI,OFFSET DG:SIZ8
	CALL	CHKREG			; LOOK FOR BYTE, WORD, DWORD, ETC.
	JZ	GETREG41
	INC	AL
	MOV	DL,AL
	JMP	GETRG01

GETREG41:
	MOV	AX,[SI]
	CMP	BYTE PTR [F8087],0
	JZ	GETREG5
	CMP	AX,"TS"                 ; 8087 STACK OPERAND
	JNZ	GETREG5
	CMP	BYTE PTR [SI+2],','
	JNZ	GETREG5
	MOV	BYTE PTR [DIRFLG],0
	ADD	SI,3
	JMP	GETLOOP

GETREG5:
	CMP	AX,"HS"                 ; SHORT
	JZ	GETREG1

	CMP	AX,"AF"                 ; FAR
	JNZ	GETRG51
	CMP	BYTE PTR [SI+2],'R'
	JNZ	GETRG51
	ADD	SI,3
	MOV	DL,4
	JMP	GETRG01

GETRG51:
	CMP	AL,'['
	JNZ	GETREG7
GETREG6:
	INC	BYTE PTR [MEMFLG]
GETREGADD:
	INC	SI
	JMP	GETLOOP

GETREG7:
	CMP	AL,']'
	JZ	GETREG6
	CMP	AL,'.'
	JZ	GETREG6
	CMP	AL,'+'
	JZ	GETREGAdd
	CMP	AL,'-'
	JNZ	GETREG8
	INC	BYTE PTR [NEGFLG]
	INC	SI
	JMP	GETLOOP1

GETREG8:				; LOOK FOR A REGISTER
	CMP	BYTE PTR [F8087],0
	JZ	GETREGREG
	CMP	AX,"TS"
	JNZ	GETREGREG
	CMP	BYTE PTR [SI+2],'('
	JNZ	GETREGREG
	CMP	BYTE PTR [SI+4],')'
	JNZ	ASMPOP
	MOV	AL,[SI+3]
	SUB	AL,'0'
	JB	ASMPOP
	CMP	AL,7
	JA	ASMPOP
	MOV	[REGMEM],AL
	INC	BYTE PTR [REGFLG]
	ADD	SI,5
	CMP	WORD PTR [SI],"S,"
	JNZ	ZLOOP
	CMP	BYTE PTR [SI+2],'T'
	JNZ	ZLOOP
	ADD	SI,3
ZLOOP:
	JMP	GETLOOP

GETREGREG:
	MOV	CX,20
	MOV	DI,OFFSET DG:REG8
	CALL	CHKREG
	JZ	GETREG12		; CX = 0 MEANS NO REGISTER
	MOV	BYTE PTR [REGMEM],AL
	INC	BYTE PTR [REGFLG]	; TELL EVERYONE WE FOUND A REG
	CMP	BYTE PTR [MEMFLG],0
	JNZ	NOSIZE
	CALL	SETSIZ
INCSI2:
	ADD	SI,2
	JMP	GETLOOP

NOSIZE:
	CMP	AL,11			; BX REGISTER?
	JNZ	GETREG9
	CMP	WORD PTR [BXFLG],0
	JZ	GETOK
ASMPOP:
	JMP	ASMERR

GETOK:
	INC	BYTE PTR [BXFLG]
	JMP	INCSI2
GETREG9:
	CMP	AL,13			; BP REGISTER?
	JNZ	GETREG10
	CMP	WORD PTR [BXFLG],0
	JNZ	ASMPOP
	INC	BYTE PTR [BPFLG]
	JMP	INCSI2
GETREG10:
	CMP	AL,14			; SI REGISTER?
	JNZ	GETREG11
	CMP	WORD PTR [DIFLG],0
	JNZ	ASMPOP
	INC	BYTE PTR [SIFLG]
	JMP	INCSI2
GETREG11:
	CMP	AL,15			; DI REGISTER?
	JNZ	ASMPOP			; *** error
	CMP	WORD PTR [DIFLG],0
	JNZ	ASMPOP
	INC	BYTE PTR [DIFLG]
	JMP	INCSI2

GETREG12:				; BETTER BE A NUMBER!
	MOV	BP,WORD PTR [ASMADD+2]
	CMP	BYTE PTR [MEMFLG],0
	JZ	GTRG121
GTRG119:
	MOV	CX,4
GTRG120:
	CALL	GETHX
	JMP	SHORT GTRG122
GTRG121:
	MOV	CX,2
	CMP	BYTE PTR [AWORD],1
	JZ	GTRG120
	CMP	BYTE PTR [AWORD],CL
	JZ	GTRG119
	CALL	GET_ADDRESS
GTRG122:
	JC	ASMPOP
	MOV	[HINUM],AX
	CMP	BYTE PTR [NEGFLG],0
	JZ	GETREG13
	NEG	DX
GETREG13:
	ADD	WORD PTR [LOWNUM],DX
	INC	BYTE PTR [NUMFLG]
GETLOOPV:
	JMP	GETLOOP

CHKREG:
	PUSH	CX
	INC	CX
	REPNZ	SCASW
	POP	AX
	SUB	AX,CX
	OR	CX,CX
	RET

STUFF_BYTES:
	PUSH	SI
	LES	DI,DWORD PTR ASMADD
	MOV	SI,OFFSET DG:ASSEM_CNT
	XOR	AX,AX
	LODSB
	MOV	CX,AX
	JCXZ	STUFFRET
	REP	MOVSB
	MOV	WORD PTR [ASMADD],DI
STUFFRET:
	POP	SI
	RET

SETSIZ:
	MOV	DL,1
	TEST	AL,11000B		; 16 BIT OR SEGMENT REGISTER?
	JZ	SETSIZ1
	INC	DL
SETSIZ1:
	CMP	BYTE PTR [AWORD],0
	JZ	SETSIZ2
	CMP	BYTE PTR [AWORD],DL
	JZ	SETSIZ2
SETERR:
	POP	DX
	JMP	ASMPOP
SETSIZ2:
	MOV	BYTE PTR [AWORD],DL
	RET

;  DETERMINE IF NUMBER IN AX:DX IS 8 BITS, 16 BITS, OR 32 BITS

CHKSIZ:
	MOV	CL,4
	CMP	AX,BP
	JNZ	RETCHK
CHKSIZ1:
	MOV	CL,2
	MOV	AX,DX
	CBW
	CMP	AX,DX
	JNZ	RETCHK
	DEC	CL
RETCHK:
	RET

;  get first character after first space

SCANS:
	CMP	BYTE PTR [SI],13
	JZ	RETCHK
	CMP	BYTE PTR [SI],'['
	JZ	RETCHK
	LODSB
	CMP	AL,' '
	JZ	SCANBV
	CMP	AL,9
	JNZ	SCANS
SCANBV:
	JMP	SCANB

; Set up for 8087 op-codes

SETMID:
	MOV	BYTE PTR [ASSEM1],0D8H
	MOV	AH,AL
	AND	AL,111B 		; SET MIDDLE BITS OF SECOND BYTE
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	MOV	[MIDFLD],AL
	MOV	AL,AH			; SET LOWER BITS OF FIRST BYTE
	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	OR	[ASSEM1],AL
	MOV	BYTE PTR [F8087],1	; INDICATE 8087 OPERAND
	MOV	BYTE PTR [DIRFLG],100B
	RET

; Set MF bits for 8087 op-codes

SETMF:
	MOV	AL,[AWORD]
	TEST	BYTE PTR [DI+1],10B
	JNZ	SETMFI
	AND	BYTE PTR [DI+1],11111001B ; CLEAR MF BITS
	CMP	AL,3			; DWORD?
	JZ	SETMFRET
	CMP	AL,4			; QWORD?
	JZ	SETMFRET2
	TEST	BYTE PTR [DI+1],1
	JZ	SETMFERR
	CMP	AL,5			; TBYTE?
	JZ	SETMFRET3
	JMP	SHORT SETMFERR

SETMFI:
	CMP	AL,3			; DWORD?
	JZ	SETMFRET
	CMP	AL,2			; WORD?
	JZ	SETMFRET2
	TEST	BYTE PTR [DI+1],1
	JZ	SETMFERR
	CMP	AL,4			; QWORD?
	JNZ	SETMFERR
	OR	BYTE PTR [DI+1],111B
SETMFRET3:
	OR	BYTE PTR [DI+1],011B
	OR	BYTE PTR [DI+2],101000B
	JMP	SHORT SETMFRET
SETMFRET2:
	OR	BYTE PTR [DI+1],100B
SETMFRET:
	RET

SETMFERR:
	JMP	ASMPOP


DW_OPER:
	MOV	BP,1
	JMP	SHORT DBEN

DB_OPER:
	XOR	BP,BP
DBEN:
	MOV	DI,OFFSET DG:ASSEM_CNT
	DEC	BYTE PTR [DI]
	INC	DI
DB0:
	XOR	BL,BL
	CALL	SCANP
	JNZ	DB1
DBEX:
	JMP	ASSEM_EXIT
DB1:
	OR	BL,BL
	JNZ	DB3
	MOV	BH,BYTE PTR [SI]
	CMP	BH,"'"
	JZ	DB2
	CMP	BH,'"'
	JNZ	DB4
DB2:
	INC	SI
	INC	BL
DB3:
	LODSB
	CMP	AL,13
	JZ	DBEX
	CMP	AL,BH
	JZ	DB0
	STOSB
	INC	BYTE PTR [ASSEM_CNT]
	JMP	DB3
DB4:
	MOV	CX,2
	CMP	BP,0
	JZ	DB41
	MOV	CL,4
DB41:
	PUSH	BX
	CALL	GETHX
	POP	BX
	JNC	DB5
	JMP	ASMERR
DB5:
	MOV	AX,DX
	CMP	BP,0
	JZ	DB6
	STOSW
	INC	BYTE PTR [ASSEM_CNT]
	JMP	SHORT DB7
DB6:
	STOSB
DB7:
	INC	BYTE PTR [ASSEM_CNT]
	JMP	DB0

; ORG pseudo op

DOORG:
	MOV	BP,WORD PTR ASMADD+2
	CALL	GET_ADDRESS
	MOV	WORD PTR ASMADD,DX
	MOV	WORD PTR ASMADD+2,AX
	JMP	ASSEMLOOP

CODE	ENDS
	END	ASSEM

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\debcom2.asm ===
PAGE	60,132 ;
	TITLE	DEBCOM2.ASM - PART2 DEBUGGER COMMANDS	PC DOS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DECOM2.ASM
;
; DESCRIPTIVE NAME: DEBUGGING TOOL
;
; FUNCTION: PROVIDES USERS WITH A TOOL FOR DEBUGGING PROGRAMS.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: DEBCOM1 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM3 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBASM  - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBUASM - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBMES  - CONTAINS ROUTINES CALLED BY DEBUG
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;	AC000	VERSION 4.00 -
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- IMPLEMENT > 32MB SUPPORT	DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================
;
;	Change Log:
;
;     Date    WHO   #		  Description
;   --------  ---  ---	----------------------------------------------------
;   04/01/90  DIC  C01	Problem fixed - When writing a file to a full disk,
;			file would be deleted if there wasn't enough space.
;			Fix checks to make sure there is enough space.
;			(Compaq STR #1889) (Microsoft Bug #774)
;
;   05/25/90  AKM  C08	Problem fixed - Added code to limit the file size
;                       for the write command.  Size check code changed
;                       because of divide overflow error.
;			(Microsoft Bug #1157)
;
;   07/31/90  AKM  C09	Problem fixed - The fix for C08 broke C01.  Took out
;                       C08 and changed to two divides to a multiply and
;                       a divide (divide by BytesPerClust).  Also, the
;                       volume freee space was not added to the file free
;                       space when overwriting a file.
;
;===========================================================================
; Routines to perform debugger commands except ASSEMble and UASSEMble

	IF1
	    %OUT COMPONENT=DEBUG, MODULE=DEBCOM2
	ENDIF
.XLIST
.XCREF
	include syscall.inc		; cas -- missing equates
	include version.inc		; cas -- missing equates
	include pdb.inc 		; cas -- missing equates
	INCLUDE DOSSYM.INC
        INCLUDE debug.inc
.CREF
.LIST
CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
	EXTRN	NOTFND_PTR:BYTE,NOROOM_PTR:BYTE,DRVLET:BYTE,ERRMES_PTR:BYTE
	EXTRN	NAMBAD_PTR:BYTE,NOSPACE_PTR:BYTE,TOOBIG_PTR:BYTE
	EXTRN	HEXERR_PTR:BYTE,HEXWRT_PTR:BYTE,ACCMES_PTR:BYTE
	EXTRN	EXEBAD_PTR:BYTE,EXEWRT_PTR:BYTE
	EXTRN	EXECEMES_PTR:BYTE,NONAMESPEC_PTR:BYTE

	EXTRN	FLAGTAB:WORD,EXEC_BLOCK:BYTE,COM_LINE:DWORD,COM_FCB1:DWORD
	EXTRN	COM_FCB2:DWORD,COM_SSSP:DWORD,COM_CSIP:DWORD,RETSAVE:WORD
	EXTRN	NEWEXEC:BYTE,HEADSAVE:WORD
	EXTRN	REGTAB:BYTE,TOTREG:BYTE,NOREGL:BYTE
	EXTRN	USER_PROC_PDB:WORD,STACK:BYTE,RSTACK:WORD,AXSAVE:WORD
	EXTRN	BXSAVE:WORD,DSSAVE:WORD,ESSAVE:WORD,CSSAVE:WORD,IPSAVE:WORD
	EXTRN	SSSAVE:WORD,CXSAVE:WORD,SPSAVE:WORD,FLSAVE:WORD
	EXTRN	SREG:BYTE,SEGTAB:WORD,REGDIF:ABS,RDFLG:BYTE
	EXTRN	REGTABEND:WORD
	EXTRN	NAMESPEC:BYTE

	EXTRN	FileSizeLB:WORD,FileSizeHB:WORD,TempHB:WORD,TempLB:WORD   ;C01
	EXTRN	DriveOfFile:WORD					  ;C01

CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	DEFDUMP:BYTE,TRANSADD:DWORD,INDEX:WORD,BUFFER:BYTE
	EXTRN	ASMADD:BYTE,DISADD:BYTE,NSEG:WORD
	EXTRN	SWITCHAR:BYTE,XNXCMD:BYTE,XNXOPT:BYTE
	EXTRN	AWORD:BYTE,EXTPTR:WORD,HANDLE:WORD,PARSERR:BYTE
	EXTRN	REG_NAME:WORD,REG_CONTENTS:WORD,REGISTER_PTR:BYTE
	EXTRN	ARG_BUF:BYTE,ARG_BUF_PTR:BYTE,LOC_ADD:WORD,LOC_PTR:BYTE
	EXTRN	BIG_CONTENTS:WORD,BIG_PTR:BYTE,LITTLE_CONTENTS:WORD,LITTLE_PTR:BYTE
	EXTRN	SINGLE_REG_ARG:WORD,CHANGE_FLAG_PTR:BYTE,DF_ERROR:BYTE
	EXTRN	BR_ERROR:BYTE,BF_ERROR:BYTE,SINGLE_REG_PTR:WORD
	EXTRN	WRT_ARG1:WORD,WRT_ARG2:WORD,WRTMES_PTR:BYTE,BEGSEG:WORD
	EXTRN	FILESTRT:WORD,FILEEND:WORD
	EXTRN	ERR_TYPE:BYTE			;ac000;converted to buffer

	extrn	rel_read_write_tab:dword		;an000;primitive I/O
	extrn	rel_rw_add:dword			;an000;transfer address
	extrn	rel_low_sec:word			;an000;low sector word
	extrn	rel_high_sec:word			;an000;high sector word
	extrn	rel_sec_num:word			;an000;# of sectors

fnd_dbcs db    0
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG
	PUBLIC	DEFIO,PREPNAME,DEBUG_FOUND
	PUBLIC	REG,LOAD
	PUBLIC	NAMED,DWRITE
	PUBLIC	DISPREG,ERR,DELIM1,DELIM2,delim0
	public	getchrup,open1,open2,open3,open4,oc_file,opnret 		;an001;bgb
	public	delete_a_file, parse_a_file, exec_a_file, open_a_file, create_a_file ;an001;bgb
	public	gcur,ifhex							;an001;bgb
	public	comtail 							;an001;bgb
	extrn	test_lead:near							;an001;bgb
	EXTRN	OUTSI:NEAR,OUTDI:NEAR,INBUF:NEAR,SCANB:NEAR,SCANP:NEAR
	EXTRN	COMMAND:NEAR,DISASLN:NEAR,SET_TERMINATE_VECTOR:NEAR
	EXTRN	RESTART:NEAR,TERMINATE:NEAR,DRVERR:NEAR
	EXTRN	GETHEX:NEAR,GETEOL:NEAR,SKIP_FILE:NEAR
	EXTRN	HEXCHK:NEAR,GETHEX1:NEAR,PRINT:NEAR
	EXTRN	CRLF:NEAR,BLANK:NEAR
	EXTRN	HEX:NEAR,DIGIT:NEAR
	EXTRN	FIND_DEBUG:NEAR
	EXTRN	ADDRESS:NEAR,PERROR:NEAR
	EXTRN	STD_PRINTF:NEAR,PRINTF_CRLF:NEAR
DEBCOM2:
DISPLAY_LINE:
	mov	ax,word ptr [si]		;an000;move reg name to ax
	MOV	[REG_NAME],ax			;ac000;save it in reg_name
	ADD	SI,3
	MOV	AX,[BX]
	ADD	BX,2
	MOV	[REG_CONTENTS],AX
	MOV	DX,OFFSET DG:REGISTER_PTR
	CALL	STD_PRINTF

	LOOP	DISPLAY_LINE

	RETURN

DISPLAY_FLAGS:
	MOV	DI,OFFSET DG:ARG_BUF
	MOV	AL,CHAR_BLANK
	STOSB
DISPLAY_FLAGS_2:
	MOV	SI,OFFSET DG:FLAGTAB
	MOV	CX,16
	MOV	DX,[FLSAVE]
DFLAGS:
	LODS	CS:WORD PTR [SI]
	SHL	DX,1
	JC	FLAGSET

	MOV	AX,CS:[SI+30]
FLAGSET:
	OR	AX,AX
	JZ	NEXT_FLAG

	STOSW
	MOV	AL,CHAR_BLANK
	STOSB
NEXT_FLAG:
	LOOP	DFLAGS
	XOR	AL,AL
	STOSB
	RETURN

DISPREG:
	MOV	SI,OFFSET DG:REGTAB
	MOV	DI,OFFSET DG:ARG_BUF
	MOV	BX,OFFSET DG:AXSAVE
	MOV	BYTE PTR TOTREG,CR
	MOV	CH,0
	MOV	CL,NOREGL
SET_DISPLAY:
REPEAT_DISPLAY:
	SUB	TOTREG,CL
	CALL	DISPLAY_LINE

	CALL	CRLF

	XOR	CH,CH
	MOV	CL,NOREGL
	CMP	CL,TOTREG
	JB	REPEAT_DISPLAY

	MOV	CL,TOTREG
	CALL	DISPLAY_LINE

	CALL	DISPLAY_FLAGS

	MOV	DX,OFFSET DG:ARG_BUF_PTR
	CALL	PRINTF_CRLF

	MOV	AX,[IPSAVE]
	MOV	WORD PTR [DISADD],AX
	PUSH	AX
	MOV	AX,[CSSAVE]
	MOV	WORD PTR [DISADD+WORD],AX
	PUSH	AX
	MOV	[NSEG],-1
	CALL	DISASLN

	POP	WORD PTR DISADD+WORD
	POP	WORD PTR DISADD
	MOV	AX,[NSEG]
	CMP	AL,-1
	JNZ	ASSEM_LIN_CONT

	JMP	CRLF

ASSEM_LIN_CONT:
	CMP	AH,-1
	JZ	NOOVER

	XCHG	AL,AH
NOOVER:
	CBW
	MOV	BX,AX
	SHL	BX,1
	MOV	AX,WORD PTR [BX+SREG]
	MOV	DI,OFFSET DG:ARG_BUF
	STOSB
	XCHG	AL,AH
	STOSB
	XOR	AL,AL
	STOSB
	MOV	DX,[INDEX]
	MOV	LOC_ADD,DX
	MOV	DX,OFFSET DG:LOC_PTR
	CALL	STD_PRINTF

	MOV	BX,[BX+SEGTAB]
	PUSH	DS
	MOV	DS,[BX]
	MOV	BX,CS:[INDEX]

;	M000 -- begin changes.
;
;	  When we're running a '386 CPU, fetching from word [ffff] causes
;	  a CPU fault, which causes a fatal fault on Win 3 enhanced or EMM386,
;	  and on some machines (like COMPAQs) even in real mode.  Therefore,
;	  we'll replace the word fetch with a byte fetch.  Notice that the
;	  new code trashes AL.  The subroutines in the vicinity preserve
;	  it, it was left zeroed when most recently used, and does not have
;	  a guaranteed value on return from this subroutine.
;
;	  Notice that the ACTUAL value we display on word [ffff]
;	  references will be the same as an 8088 would use for that
;	  operation.  If the user goes ahead and executes said
;	  instruction on a 386, it will fault!
;
;	MOV	BX,[BX]			; old code used word fetch

	mov	al,[bx]			; get low byte
	mov	bh,1[bx]		; get high byte
	mov	bl,al			; get both into bx

;	M000 -- end changes.

	POP	DS
	MOV	BIG_CONTENTS,BX
	MOV	DX,OFFSET DG:BIG_PTR
	TEST	BYTE PTR [AWORD],-1
	JNZ	SHOW_CHARS

	XOR	BH,BH
	MOV	LITTLE_CONTENTS,BX
	MOV	DX,OFFSET DG:LITTLE_PTR
SHOW_CHARS:
	CALL	PRINTF_CRLF

	RETURN

DISPREGJ:
	JMP	DISPREG

; Perform register dump if no parameters or set register if a
; register designation is a parameter.
REG:
	CALL	SCANP

	JZ	DISPREGJ

	MOV	DL,[SI]
	INC	SI
	MOV	DH,[SI]
	CMP	DH,CR
	JZ	FLAG

	INC	SI
	CALL	GETEOL

	CMP	DH,CHAR_BLANK
	JZ	FLAG

	MOV	DI,OFFSET DG:REGTAB
	XCHG	AX,DX
	PUSH	CS
	POP	ES
	XOR	CX,CX
CHECK_NEXT_REG:
	CMP	AX,WORD PTR[ DI]
	JZ	REG_FOUND

	ADD	DI,3
	INC	CX
	CMP	DI,OFFSET DG:REGTABEND
	JB	CHECK_NEXT_REG

	JMP	short BADREG

REG_FOUND:
	CMP	DI,OFFSET DG:REGTABEND
	JNZ	NOTPC

	DEC	DI
	DEC	DI
	DEC	DI
	MOV	AX,CS:[DI-WORD]
NOTPC:
	PUSH	DI
	MOV	DI,OFFSET DG:ARG_BUF
	STOSB
	XCHG	AL,AH
	STOSB
	XOR	AL,AL
	STOSB
	POP	DI
	PUSH	DS
	POP	ES
	LEA	BX,[DI+REGDIF]
	SUB	BX,CX
	MOV	DX,[BX]
	MOV	SINGLE_REG_ARG,DX
	MOV	DX,OFFSET DG:SINGLE_REG_PTR
	CALL	STD_PRINTF

	CALL	INBUF

	CALL	SCANB

	RETZ

	push	bx				;an000;save bx - we stomp it
	MOV	CX,4
	CALL	GETHEX1
	pop	bx				;an000;restore it

	CALL	GETEOL

	MOV	[BX],DX
	RETURN
BADREG:
	MOV	DX,OFFSET DG:BR_ERROR	; BR ERROR
	JMP	short ERR

FLAG:
	CMP	DL,UPPER_F
	JNZ	BADREG

	MOV	DI,OFFSET DG:ARG_BUF
	CALL	DISPLAY_FLAGS_2

	MOV	DX,OFFSET DG:CHANGE_FLAG_PTR
	CALL	STD_PRINTF

	CALL	INBUF

	CALL	SCANB

	XOR	BX,BX
	MOV	DX,[FLSAVE]
GETFLG:
	LODSW
	CMP	AL,CR
	JZ	SAVCHG

	CMP	AH,CR
	JZ	FLGERR

	MOV	DI,OFFSET DG:FLAGTAB
	MOV	CX,32
	PUSH	CS
	POP	ES
	REPNE	SCASW
	JNZ	FLGERR

	MOV	CH,CL
	AND	CL,0FH
	MOV	AX,1
	ROL	AX,CL
	TEST	AX,BX
	JNZ	REPFLG

	OR	BX,AX
	OR	DX,AX
	TEST	CH,16
	JNZ	NEXFLG

	XOR	DX,AX
NEXFLG:
	CALL	SCANP

	JMP	SHORT GETFLG

REPFLG:
	MOV	DX,OFFSET DG:DF_ERROR	; DF ERROR
FERR:
	CALL	SAVCHG
ERR:
	push	si				;an000;save affected registers
	push	di				;an000;
	push	cx				;an000;
	mov	cx,03h				;an000;move only three bytes
	mov	di,offset dg:err_type		;an000;point to buffer
	mov	si,dx				;an000;dx holds the string
	rep	movsb				;an000;fill up the buffer
	pop	cx				;an000;restore registers
	pop	di				;an000;
	pop	si				;an000;
	MOV	DX,OFFSET DG:ERRMES_PTR
	JMP	PRINT

SAVCHG:
	MOV	[FLSAVE],DX
	RETURN

FLGERR:
	MOV	DX,OFFSET DG:BF_ERROR	; BF ERROR
	JMP	SHORT FERR

PREPNAME:
	MOV	ES,DSSAVE
	PUSH	SI
	MOV	DI,81H
COMTAIL:
	LODSB
	STOSB
	CMP	AL,CR
	JNZ	COMTAIL

	SUB	DI,82H
	XCHG	AX,DI
	MOV	ES:(BYTE PTR [80H]),AL
	POP	SI
	MOV	DI,FCB			;05cH
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR SET_DRIVEID_OPTION ;AL=01H
	INT	21H

	MOV	BYTE PTR [AXSAVE],AL	; Indicate analysis of first parm
	CALL	SKIP_FILE

	MOV	DI,6CH
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR SET_DRIVEID_OPTION ;AL=01H
	INT	21H

	MOV	BYTE PTR [AXSAVE+1],AL	; Indicate analysis of second parm
	RETURN

;  OPENS A XENIX PATHNAME SPECIFIED IN THE UNFORMATTED PARAMETERS
;  VARIABLE [XNXCMD] SPECIFIES WHICH COMMAND TO OPEN IT WITH

;  VARIABLE [HANDLE] CONTAINS THE HANDLE
;  VARIABLE [EXTPTR] POINTS TO THE FILES EXTENSION
DELETE_A_FILE:
	MOV	BYTE PTR [XNXCMD],UNLINK
	JMP	SHORT OC_FILE

PARSE_A_FILE:
	MOV	BYTE PTR [XNXCMD],0
	JMP	SHORT OC_FILE

EXEC_A_FILE:
	MOV	BYTE PTR CS:[XNXCMD],EXEC
	MOV	BYTE PTR CS:[XNXOPT],1
	JMP	SHORT OC_FILE

OPEN_A_FILE:
	MOV	BYTE PTR [XNXCMD],OPEN
	MOV	BYTE PTR [XNXOPT],2	; Try read write
	CALL	OC_FILE

	RETNC
	MOV	BYTE PTR [XNXCMD],OPEN
	MOV	BYTE PTR [XNXOPT],0	; Try read only
	JMP	SHORT OC_FILE

CREATE_A_FILE:
	MOV	BYTE PTR [XNXCMD],CREAT
OC_FILE:
	PUSH	DS
	PUSH	ES
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	SI
	XOR	AX,AX
	MOV	CS:[EXTPTR],AX		; INITIALIZE POINTER TO EXTENSIONS
	MOV	AH,CHAR_OPER
	INT	21H

	MOV	CS:[SWITCHAR],DL	; GET THE CURRENT SWITCH CHARACTER
	MOV	SI,81H

open1:	CALL	GETCHRUP		;convert 1 byte to uppercase
	CALL	DELIM2			; END OF LINE?
	JZ	OPEN4

	CALL	DELIM1			; SKIP LEADING DELIMITERS
	JZ	OPEN1

	MOV	DX,SI			; SAVE POINTER TO BEGINNING
	cmp	fnd_dbcs,1
;	$if	z
	JNZ $$IF1
	    dec   dx			;dec it twice if dbcs
;	$endif
$$IF1:
	DEC	DX
open2:	CMP	AL,CHAR_PERIOD		; LAST CHAR A "."?
	JNZ	OPEN3

	MOV	CS:[EXTPTR],SI		; SAVE POINTER TO THE EXTENSION
OPEN3:
	CALL	GETCHRUP

	CALL	DELIM1			; LOOK FOR END OF PATHNAME

	JZ	OPEN4

	CALL	DELIM2

	JNZ	OPEN2

OPEN4:	DEC	SI			; POINT BACK TO LAST CHAR
	PUSH	[SI]			; SAVE TERMINATION CHAR
	MOV	BYTE PTR [SI],0 	; NULL TERMINATE THE STRING
	MOV	AL,CS:[XNXOPT]
	MOV	AH,CS:[XNXCMD]		; OPEN OR CREATE FILE
	OR	AH,AH
	JZ	OPNRET

	MOV	CS:[FILESTRT],DX	; Set values for later call on this file
	MOV	CS:[FILEEND],SI
	PUSH	CS
	POP	ES			; Set ES seg for EXEC_BLOCK
	MOV	BX,OFFSET DG:EXEC_BLOCK
	XOR	CX,CX
	INT	21H

	MOV	CS:[HANDLE],AX		; SAVE ERROR CODE OR HANDLE
OPNRET:
	POP	[SI]
	POP	SI
	POP	DX
	POP	CX
	POP	BX
	POP	AX			; blow away error code...
	POP	ES
	POP	DS
	RETURN

GETCHRUP:									;an001;bgb
	lodsb				;get the character from [si]		;an001;bgb
	call	test_lead		;is it a dbcs lead byte?		;an001;bgb
;	$IF	C			;yes					;an001;bgb
	JNC $$IF3
	    inc     si			;bump ptr to past 2nd dbcs byte 	;an001;bgb
	    mov     fnd_dbcs,1		;found a dbcs char
	    jmp     short gcur		;dont capitalize it			;an001;bgb
;	$ENDIF									;an001;bgb
$$IF3:
					;					;an001;bgb
	mov	fnd_dbcs,0		;did not find a dbcs char
	cmp	al,lower_a		;is it >= "a" ? 			;an001;bgb
	jb	gcur			;no - exit				;an001;bgb
										;an001;bgb
	cmp	al,lower_z		;is it =< "z" ? 			;an001;bgb
	ja	gcur			;no - exit				;an001;bgb
										;an001;bgb
;if we get here, the char is lowercase, so change it				;an001;bgb
	sub	al,32			;convert to uppercase			;an001;bgb
	mov	[si-1],al		;move it back (si points 1 past)	;an001;bgb
gcur:	return									;an001;bgb

DELIM0:
	CMP	AL,CHAR_LEFT_BRACKET
	RETZ
DELIM1:
	CMP	AL,CHAR_BLANK		; SKIP THESE GUYS
	RETZ

	CMP	AL,CHAR_SEMICOLON
	RETZ

	CMP	AL,CHAR_EQUAL
	RETZ

	CMP	AL,CHAR_TAB
	RETZ

	CMP	AL,CHAR_COMMA
	RETURN

DELIM2:
	CMP	AL,CS:[SWITCHAR]	; STOP ON THESE GUYS
	RETZ

	CMP	AL,CR
	RETURN

NAMED:
	OR	[NAMESPEC],1		; Flag a name command executed
	CALL	PREPNAME

	MOV	AL,BYTE PTR AXSAVE
	MOV	PARSERR,AL
	PUSH	ES
	POP	DS
	PUSH	CS
	POP	ES
	MOV	SI,FCB			; DS:SI points to user FCB
	MOV	DI,SI			; ES:DI points to DEBUG FCB
	MOV	CX,82
	REP	MOVSW
	RETURN

BADNAM:
	MOV	DX,OFFSET DG:NAMBAD_PTR
	JMP	RESTART

IFHEX:
	CMP	BYTE PTR [PARSERR],-1	; Invalid drive specification?
	JZ	BADNAM

	CALL	PARSE_A_FILE

	MOV	BX,[EXTPTR]
	CMP	WORD PTR DS:[BX],"EH"	; "HE"
	RETNZ

	CMP	BYTE PTR DS:[BX+WORD],UPPER_X
	RETURN

IFEXE:
	PUSH	BX
	MOV	BX,[EXTPTR]
	CMP	WORD PTR DS:[BX],"XE"	; "EX"
	JNZ	RETIF

	CMP	BYTE PTR DS:[BX+WORD],UPPER_E
RETIF:
	POP	BX
	RETURN

LOAD:
	MOV	BYTE PTR [RDFLG],READ
	JMP	SHORT DSKIO

DWRITE:
	MOV	BYTE PTR [RDFLG],WRITE
DSKIO:
	MOV	BP,[CSSAVE]
	CALL	SCANB

	jz	DEFIO

	CALL	ADDRESS

	CALL	SCANB

	jz	FILEIO

;=========================================================================
; PRMIO:	This routine builds the necessary table for the new
;		generic IOCtl primitive read/write logical sector function.
;
;	Inputs : Binary addresses and values converted by GETHEX
;
;	Outputs: REL_READ_WRITE_TAB -	Table needed by IOCtl function to
;					perform 32 bit sector addressing.
;
;	Date	   : 6/17/87
;=========================================================================

	mov	word ptr dg:[rel_rw_add],dx	;ac000;save transfer address
						;      in table
	mov	word ptr dg:[rel_rw_add+2],ax	;ac000;save segment of transfer
						;      address
	MOV	CX,2
	CALL	GETHEX			; Drive number must be 2 digits or less

	PUSH	DX			;save drive number
	MOV	CX,8			;ac000;allow 32 bit addressibilty
	CALL	GETHEX			; Logical record number
	mov	word ptr dg:[rel_low_sec],dx	;ac000;save low word of logical
						;      sector address
	mov	word ptr dg:[rel_high_sec],bx	;ac000;save high word of
						;      logical sector address

	MOV	CX,3
	CALL	GETHEX			; Number of records
	mov	word ptr dg:[rel_sec_num],dx	;ac000;save number of sectors
						;      to read/write

	CALL	GETEOL

	POP	BX			;ac000;drive number
	CBW				; Turn off verify after write
	MOV	BYTE PTR DRVLET,bl	;ac000;save drive in case of error
	PUSH	BX
	MOV	DL,bL			;ac000;move drive to dl
; Clean off the buffer cache for physical I/O
	push	ds
	MOV	AH,DISK_RESET
	INT	21H

	INC	DL
	MOV	AH,GET_DPB
	INT	21H
	pop	ds

	or	al,al			;ac000;see if an error occurred
	pop	ax			;ac000;restore drive

	JNZ	DRVERRJ

	CMP	CS:BYTE PTR [RDFLG],WRITE
;	$if	z			;an000;we will write to sector(s)
	JNZ $$IF5
		call ABSWRT		;an000;logical sector write
;	$else				;an000;
	JMP SHORT $$EN5
$$IF5:
		call ABSREAD		;an000;we will read sector(s)
;	$endif				;an000;
$$EN5:


ENDABS:
	JNC	RET0

DRVERRJ:
	JMP	DRVERR

RET0:
; Clean cache again...
	MOV	AH,DISK_RESET
	INT	21H

	RETURN


;called from debug.asm
DEFIO:
	MOV	AX,[CSSAVE]		; Default segment
	MOV	DX,100H 		; Default file I/O offset
	CALL	IFHEX
	JNZ	EXECHK
	XOR	DX,DX			; If HEX file, default OFFSET is zero
HEX2BINJ:
	JMP	HEX2BIN

FILEIO:
; AX and DX have segment and offset of transfer, respectively
	CALL	IFHEX
	JZ	HEX2BINJ

EXECHK:
	CALL	IFEXE
	JNZ	BINFIL
	CMP	BYTE PTR [RDFLG],READ
	JZ	EXELJ
	MOV	DX,OFFSET DG:EXEWRT_PTR
	JMP	RESTART 		; Can't write .EXE files

BINFIL:
	CMP	BYTE PTR [RDFLG],WRITE
	JZ	BINLOAD
	CMP	WORD PTR DS:[BX],4F00H + UPPER_C ;"CO"
	JNZ	BINLOAD
	CMP	BYTE PTR DS:[BX+WORD],UPPER_M
	JNZ	BINLOAD

EXELJ:
	DEC	SI
	CMP	DX,100H
	JNZ	PRER

	CMP	AX,[CSSAVE]
	JZ	OAF

PRER:
	JMP	PERROR

OAF:
	CALL	OPEN_A_FILE

	JNC	GDOPEN

	MOV	AX,ERROR_FILE_NOT_FOUND
	JMP	EXECERR

GDOPEN:
	XOR	DX,DX
	XOR	CX,CX
	MOV	BX,[HANDLE]
	MOV	AL,2
	MOV	AH,LSEEK
	INT	21H

	CALL	IFEXE			; SUBTRACT 512 BYTES FOR EXE

	JNZ	BIN2			; FILE LENGTH BECAUSE OF

	SUB	AX,512			; THE HEADER
	SBB	DX,0			; reflect borrow, if any

BIN2:
	MOV	[BXSAVE],DX		; SET UP FILE SIZE IN DX:AX
	MOV	[CXSAVE],AX
	MOV	AH,CLOSE
	INT	21H

	JMP	EXELOAD

NO_MEM_ERR:
	MOV	DX,OFFSET DG:TOOBIG_PTR
	CALL	PRINTF_CRLF

	JMP	COMMAND

WRTFILEJ:
	JMP	WRTFILE
NOFILEJ:
	MOV	FileSizeLB,0		;save low value of file size   ;C01
	MOV	FileSizeHB,0		;save high value of file size  ;C01
	JMP	NOFILE

BINLOAD:
	PUSH	AX
	PUSH	DX
	CMP	BYTE PTR [RDFLG],WRITE
	JZ	WRTFILEJ

	CALL	OPEN_A_FILE

	JC	NOFILEJ

	MOV	BX,[HANDLE]
	MOV	AX,(LSEEK SHL 8) OR LSEEK_EOF_OPTION
	XOR	DX,DX			;CX:DX=DISTANCE (OFFSET) TO MOVE IN BYTES
	MOV	CX,DX
	INT	21H			; GET SIZE OF FILE

	MOV	FileSizeLB,ax		; save low value of file size	;C01
	MOV	FileSizeHB,dx		; save high value of file size	;C01
	MOV	TempLB,ax		; save low value of file size	;C01
	MOV	TempHB,dx		; save high value of file size	;C01

	MOV	SI,DX
	MOV	DI,AX			; SIZE TO SI:DI
	MOV	AX,(LSEEK SHL 8) OR LSEEK_FROM_START
	XOR	DX,DX
	MOV	CX,DX
	INT	21H			; RESET POINTER BACK TO BEGINNING

	POP	AX
	POP	BX
	PUSH	BX
	PUSH	AX			; TRANS ADDR TO BX:AX
	ADD	AX,15
	RCR	AX,1
	MOV	CL,3
	MOV	CL,4
	SHR	AX,CL
	ADD	BX,AX			; Start of transfer rounded up to seg
	MOV	DX,SI
	MOV	AX,DI			; DX:AX is size
	cmp	dx,10h
	jnc	no_mem_err
	MOV	CX,16
	DIV	CX
	OR	DX,DX
	JZ	NOREM

	INC	AX
NOREM:					; AX is number of paras in transfer
	ADD	AX,BX			; AX is first seg that need not exist
	jc	no_mem_err
	CMP	AX,CS:[PDB_BLOCK_LEN]
	JA	NO_MEM_ERR

	MOV	CXSAVE,DI
	MOV	BXSAVE,SI
	POP	DX
	POP	AX
; AX:DX is disk transfer address (segment:offset)
; SI:DI is length (32-bit number)
RDWR:
RDWRLOOP:
	MOV	BX,DX			; Make a copy of the offset
	AND	DX,000FH		; Establish the offset in 0H-FH range
	MOV	CL,4
	SHR	BX,CL			; Shift offset and
	ADD	AX,BX			; Add to segment register to get new Seg:offset
	PUSH	AX
	PUSH	DX			; Save AX,DX register pair
	MOV	WORD PTR [TRANSADD],DX
	MOV	WORD PTR [TRANSADD+WORD],AX
	MOV	CX,0FFF0H		; Keep request in segment
	OR	SI,SI			; Need > 64K?
	JNZ	BIGRDWR

	MOV	CX,DI			; Limit to amount requested
BIGRDWR:
	PUSH	DS
	PUSH	BX
	MOV	BX,[HANDLE]
	MOV	AH,[RDFLG]
	LDS	DX,[TRANSADD]
	INT	21H			; Perform read or write

	POP	BX
	POP	DS
	JC	BADWR

	CMP	BYTE PTR [RDFLG],WRITE
	JNZ	GOODR

	CMP	CX,AX
	JZ	GOODR

BADWR:
	MOV	CX,AX
	STC
	POP	DX			; READ OR WRITE BOMBED OUT
	POP	AX
	RETURN

GOODR:
	MOV	CX,AX
	SUB	DI,CX			; Request minus amount transferred
	SBB	SI,0			; Ripple carry
	OR	CX,CX			; End-of-file?

	mov	ax,TempHB		; new file size value high byte  ;C01
	mov	FileSizeHB,ax		; if write was successful	 ;C01
	mov	ax,TempLB		; new file size value low byte	 ;C01
	mov	FileSizeLB,ax		; if write was successful	 ;C01

	POP	DX			; Restore DMA address
	POP	AX
	JZ	DOCLOSE

	ADD	DX,CX			; Bump DMA address by transfer length
	MOV	BX,SI
	OR	BX,DI			; Finished with request
	JNZ	RDWRLOOP

DOCLOSE:
	SAVEREG <AX,BX>
	MOV	BX,HANDLE
	MOV	AH,CLOSE
	INT	21H

	RESTOREREG <BX,AX>
	RETURN

NOFILE:
	MOV	DX,OFFSET DG:NOTFND_PTR
	JMP	RESTART

NO_NAME_GIVEN:
	MOV	DX,OFFSET DG:NONAMESPEC_PTR
RESTARTJMP:
	JMP	RESTART

WRTFILE:
	CMP	[NAMESPEC],0
	JZ	NO_NAME_GIVEN		; Hey User, you forgot to specify a name

	CALL	ChkFileSz		;C01

	CALL	CREATE_A_FILE		; Create file we want to write to

	JC	CHECKREADONLY		; ARR 2.4

	MOV	SI,BXSAVE		; Get high order number of bytes to transfer
;C08    CMP	SI,000FH
;C08    JLE	WRTSIZE 		; Is bx less than or equal to FH
;C08
;C08    XOR	SI,SI			; Ignore BX if greater than FH - set to zero
	MOV	DI,CXSAVE                                                 ;C08
	CMP	SI,7FFFH                                                  ;C08
	JBE	WRTSIZE 		; Is bx less than or equal to 7FFF;C08
                                        ; Limit fsize to 2GB              ;C08
        MOV     SI,7FFFH                ; Setup maximum file size.        ;C08
        MOV     DI,0FFFFH                                                 ;C08
WRTSIZE:
	MOV	WRT_ARG2,SI
;C08    MOV	DI,CXSAVE
	MOV	WRT_ARG1,DI
	MOV	DX,OFFSET DG:WRTMES_PTR
	CALL	PRINTF_CRLF

	POP	DX
	POP	AX
	CALL	RDWR

	JNC	CLSFLE

	CALL	CLSFLE

	CALL	DELETE_A_FILE

	MOV	DX,OFFSET DG:NOSPACE_PTR
	JMP	RESTARTJMP

	CALL	CLSFLE			;is this dead code? - edk

	JMP	COMMAND

CHECKREADONLY:				; ARR 2.4
	MOV	DX,[FILESTRT]
	MOV	SI,[FILEEND]
	PUSH	[SI]
	MOV	BYTE PTR [SI],0
	MOV	AX,CHMOD SHL 8		;AL=0,REQUEST FILE'S CURRENT
					;  ATTRIBUTE BE RETURNED IN CX
	INT	21H

	POP	[SI]
	MOV	DX,OFFSET DG:NOROOM_PTR ; Creation error - report error
	JC	RESTARTJMP

	TEST	CX,ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM
	JZ	RESTARTJMP

	MOV	DX,OFFSET DG:ACCMES_PTR ; Write on read only file
	JMP	RESTARTJMP

CLSFLE:
	MOV	AH,CLOSE
	MOV	BX,[HANDLE]
	INT	21H

	RETURN

EXELOAD:
	POP	[RETSAVE]		; Suck up return addr
	INC	BYTE PTR [NEWEXEC]
	MOV	BX,[USER_PROC_PDB]
	MOV	AX,BEGSEG
	MOV	DS,AX
	ASSUME	DS:NOTHING

	CMP	AX,BX
	JZ	DEBUG_CURRENT

	JMP	FIND_DEBUG

DEBUG_CURRENT:
	MOV	AX,CS:[DSSAVE]
DEBUG_FOUND:
	MOV	CS:BYTE PTR [NEWEXEC],0
	MOV	CS:[HEADSAVE],AX
	PUSH	CS:[RETSAVE]		; Get the return address back
	PUSH	AX
	MOV	BX,CS
	SUB	AX,BX
	PUSH	ES
	MOV	ES,CS:BEGSEG
	ASSUME	ES:NOTHING

	MOV	BX,AX			; size of debug in para.
	ADD	BX,10H
	MOV	AX,CS			; and the size of printf in para.
	SUB	AX,CS:BEGSEG
	ADD	BX,AX
	MOV	AH,SETBLOCK
	INT	21H

	POP	ES
	POP	AX
	MOV	CS:WORD PTR [COM_LINE+WORD],AX
	MOV	CS:WORD PTR [COM_FCB1+WORD],AX
	MOV	CS:WORD PTR [COM_FCB2+WORD],AX
	PUSH	DS
	PUSH	CS
	POP	DS
	CALL	EXEC_A_FILE

	POP	DS
	MOV	AX,CS:[HANDLE]
	JC	EXECERR

	CALL	SET_TERMINATE_VECTOR	; Reset int 22

	MOV	AH,GET_CURRENT_PDB
	INT	21H

	MOV	CS:[USER_PROC_PDB],BX
	MOV	CS:[DSSAVE],BX
	MOV	CS:[ESSAVE],BX
	MOV	ES,BX
	MOV	WORD PTR ES:[PDB_EXIT],OFFSET DG:TERMINATE
	MOV	WORD PTR ES:[PDB_EXIT+WORD],CS
	LES	DI,CS:[COM_CSIP]
	MOV	CS:[CSSAVE],ES
	MOV	CS:[IPSAVE],DI
	MOV	CS:WORD PTR [DISADD+WORD],ES
	MOV	CS:WORD PTR [DISADD],DI
	MOV	CS:WORD PTR [ASMADD+WORD],ES
	MOV	CS:WORD PTR [ASMADD],DI
	MOV	CS:WORD PTR [DEFDUMP+WORD],ES
	MOV	CS:WORD PTR [DEFDUMP],DI
	MOV	BX,DS
	MOV	AH,SET_CURRENT_PDB
	INT	21H

	LES	DI,CS:[COM_SSSP]
	MOV	AX,ES:[DI]
	INC	DI
	INC	DI
	MOV	CS:[AXSAVE],AX
	MOV	CS:[SSSAVE],ES
	MOV	CS:[SPSAVE],DI
	RETURN

EXECERR:
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET DG:NOTFND_PTR
	CMP	AX,ERROR_FILE_NOT_FOUND
	JZ	GOTEXECEMES

	MOV	DX,OFFSET DG:ACCMES_PTR
	CMP	AX,ERROR_ACCESS_DENIED
	JZ	GOTEXECEMES

	MOV	DX,OFFSET DG:TOOBIG_PTR
	CMP	AX,ERROR_NOT_ENOUGH_MEMORY
	JZ	GOTEXECEMES

	MOV	DX,OFFSET DG:EXEBAD_PTR
	CMP	AX,ERROR_BAD_FORMAT
	JZ	GOTEXECEMES

	MOV	DX,OFFSET DG:EXECEMES_PTR
GOTEXECEMES:
	CALL	PRINTF_CRLF

	JMP	COMMAND

HEX2BIN:
	MOV	[INDEX],DX
	MOV	DX,OFFSET DG:HEXWRT_PTR
	CMP	BYTE PTR [RDFLG],WRITE
	JNZ	RDHEX

	JMP	RESTARTJ2

RDHEX:
	MOV	ES,AX
	CALL	OPEN_A_FILE

	MOV	DX,OFFSET DG:NOTFND_PTR
	JNC	HEXFND

	JMP	RESTART

HEXFND:
	XOR	BP,BP
	MOV	SI,OFFSET DG:(BUFFER+BUFSIZ) ; Flag input buffer as empty
READHEX:
	CALL	GETCH

	CMP	AL,CHAR_COLON		; Search for : to start line
	JNZ	READHEX

	CALL	GETBYT			; Get byte count

	MOV	CL,AL
	MOV	CH,0
	JCXZ	HEXDONE

	CALL	GETBYT			; Get high byte of load address

	MOV	BH,AL
	CALL	GETBYT			; Get low byte of load address

	MOV	BL,AL
	ADD	BX,[INDEX]		; Add in offset
	MOV	DI,BX
	CALL	GETBYT			; Throw away type byte

READLN:
	CALL	GETBYT			; Get data byte

	STOSB
	CMP	DI,BP			; Check if this is the largest address so far
	JBE	HAVBIG

	MOV	BP,DI			; Save new largest
HAVBIG:
	LOOP	READLN

	JMP	SHORT READHEX

GETCH:
	CMP	SI,OFFSET DG:(BUFFER+BUFSIZ)
	JNZ	NOREAD

	MOV	DX,OFFSET DG:BUFFER
	MOV	SI,DX
	MOV	AH,READ
	PUSH	BX
	PUSH	CX
	MOV	CX,BUFSIZ
	MOV	BX,cs:[HANDLE]
	INT	21H

	POP	CX
	POP	BX
	OR	AX,AX
	JZ	HEXDONE

NOREAD:
	LODSB
	CMP	AL,CHAR_EOF
	JZ	HEXDONE

	OR	AL,AL
	RETNZ

HEXDONE:
	MOV	[CXSAVE],BP
	MOV	BXSAVE,0
	RETURN

HEXDIG:
	CALL	GETCH

	CALL	HEXCHK

	RETNC

	MOV	DX,OFFSET DG:HEXERR_PTR
RESTARTJ2:
	JMP	RESTART

GETBYT:
	CALL	HEXDIG

	MOV	BL,AL
	CALL	HEXDIG

	SHL	BL,1
	SHL	BL,1
	SHL	BL,1
	SHL	BL,1
	OR	AL,BL
	RETURN

;=========================================================================
; ABSREAD:	This routine performs a primitive logical sector read of
;		the specified drive.  This routine replaces the old
;		INT 25h function which only allowed 16 bit addressibility.
;		The new generic IOCtl logical sector read will permit
;		32 bit addressibility on a disk device.
;
;	Inputs : REL_READ_WRITE_TAB	- Table provides dword sector
;					  addressibility.
;
;	Outputs: Data located at specified transfer address.
;
;	Error  : Carry is set on error.
;
;	Date	  : 6/17/87
;=========================================================================

ABSREAD 	proc	near		;an000;read logical sector(s)

	push	ds			;an000;save affected regs
	push	cx			;an000;save affected regs
	push	bx			;an000;

	mov	cx,-1			;an000;extended format
	mov	bx,offset dg:rel_read_write_tab  ;an000;point to read/write table
	int	25h			;an000;invoke relative sector read
	pop	bx			;an000;discard stack word

	pop	bx			;an000;restore regs
	pop	cx			;an000;
	pop	ds			;an000;

	ret				;an000;return to caller

ABSREAD 	endp			;an000;end proc


;=========================================================================
; ABSWRT:	This routine performs a primitive logical sector write of
;		the specified drive.  This routine replaces the old
;		INT 26h function which only allowed 16 bit addressibility.
;		The new generic IOCtl logical sector write will permit
;		32 bit addressibility on a disk device.
;
;	Inputs : REL_READ_WRITE_TAB	- Table provides dword sector
;					  addressibility.
;
;	Outputs: Data moved from transfer address to applicable sector(s).
;
;	Error  : Carry is set on error.
;
;	Date	  : 6/17/87
;=========================================================================

ABSWRT		proc	near		;an000;write logical sector(s)

	push	ds			;an000;save affected regs
	push	cx			;an000;
	push	bx			;an000;

	mov	cx,-1			;an000;extended format
	mov	bx,offset dg:rel_read_write_tab  ;an000;point to read/write table
	int	26h			;an000;invoke relative sector write
	pop	bx			;an000;discard stack word

	pop	bx			;an000;restore regs
	pop	cx			;an000;
	pop	ds			;an000;

	ret				;an000;return to caller

ABSWRT		endp			;an000;end proc

;*************************************************************************;C01
;This function is designed to test the size of any file being written to  ;C01
;disk or diskette.  If the file wanting to be written is larger than space;C01
;available on disk or diskette then the write will not occur.  This will  ;C01
;prevent the file from being deleted when "insufficient memory" is present;C01
									  ;C01
ChkFileSz   PROC    NEAR						  ;C01
	mov	bx,DriveOfFile		;get drive number of file	  ;C01
	mov	dl,bl			;				  ;C01
	mov	ah,36h			;DOS Function call		  ;C01
	int	21h			;get drive allocation information ;C01
	cmp	ax,0FFFFh		;Q: Was there an error?		  ;C01
	je	RSJMP			;  Y: yes			  ;C01
	mov	cs:AvailClusts,bx	;save # of avail. clusters	  ;C01
	mov	cs:SectsPerClust,ax	;save sectors per cluster	  ;C01
	mov	cs:BytesPerSect,cx	;save bytes per sector		  ;C01

	mul	cs:BytesPerSect						  ;C09
	mov	cs:BytesPerClust,ax	;Compute & save bytes per cluster ;C09

									  ;C01
;Determine how many clusters the new file would have to use.  This value  ;C01
;must be less than the number of available clusters, AvailClusts, or	  ;C01
;the write will have further tests made before executing.		  ;C01
									  ;C01
	mov	dx,BXSAVE	     ;get high order file size		  ;C01
	mov	TempHB,dx						  ;C01
	mov	ax,CXSAVE	     ;get low order file size		  ;C01
	mov	TempLB,ax						  ;C01

;C09	mov	ax,cs:SectsPerClust					  ;C08
;C09	mul	cs:BytesPerSect		;dx:ax = max file size available  ;C08
;C09	mul	cs:AvailClusts						  ;C08
;C09	cmp	dx,cs:TempHB		;Q: Is high word of free space	  ;C08
;C09					;  > size of file?		  ;C08
;C09	ja	CONT5			;  Y: yes, do write		  ;C08
;C09	je	TRY_LOW			;Q: Equal? Y: Try lower word	  ;C08
;C09	jmp	RSJMP			; must be greater, issue error	  ;C08
;C09TRY_LOW:								  ;C08
;C09	cmp	ax,cs:TempLB		;Q: Is low word of free space	  ;C08
;C09					;  > size of file?		  ;C08
;C09	jae	CONT5			;  Y: yes, don't write		  ;C08
;C09RSJMP:								  ;C08
;C09	mov	dx,OFFSET DG:NOSPACE_PTR				  ;C08
;C09	jmp	RESTARTJMP						  ;C08
;C09cont5	label	near						  ;C08
;C09		ret							  ;C08


;C09	div	cs:BytesPerSect		;compute # of sects. for new file ;C01
;C09	cmp	dx,0			;Q: Was there a remainder?	  ;C01
;C09	je	cont1			;  A:no, don't do anything	  ;C01
;C09	inc	ax			;    yes, incr. # of sectors	  ;C01
;C09	xor	dx,dx			;prepare for next divide	  ;C01
;C09cont1	label	near						  ;C01
;C09	div	cs:SectsPerClust	;compute # of clusts for new file ;C01

;	if the count is absurdly large (# clusters > 0ffffh), then
;	  we have to check for the overflow as a special case before
;	  doing the divide.  This is actually quite likely when
;	  people do this command without knowing that the user bx register
;	  contains one of the parameters.

	cmp	dx,cs:BytesPerClust	; see if we're going to get an overflow
	jnb	RSJMP			;  give error if we would've

	div	cs:BytesPerClust	;compute # of clusts for new file ;C09
	or	dx,dx			;Q: Was there a remainder?
	je	cont2			;  A: no, don't do anything	  ;C01
	inc	ax			;     yes, incr. # of clusters	  ;C01
	jz	RSJMP			; give error if rounded to 0
cont2	label	near							  ;C01
	cmp	cs:AvailClusts,ax	;Q: Are there enough disk clusts  ;C01
					;  for the write to occur	  ;C01
	jae	cont5			;  A: yes, write to disk	  ;C01
	mov	cs:FileSzInClusts,ax	;save # of clusters of new file	  ;C01
									  ;C01
;Determine how many clusters the given file now occupies on the disk or	  ;C01
;diskette for comparison with the # of clusters of the new file		  ;C01
									  ;C01
	mov	dx,FileSizeHB	     ;Set up DX:AX with current file	  ;C01
	mov	ax,FileSizeLB	     ;	size				  ;C01
;C09	div	cs:BytesPerSect		;compute # of sects. used by file ;C01
;C09	cmp	dx,0			;Q: Was there a remainder?	  ;C01
;C09	je	cont3			;  A:no, don't do anything	  ;C01
;C09	inc	ax			;    yes, incr. # of sectors	  ;C01
;C09	xor	dx,dx			;prepare for next divide	  ;C01
;C09cont3	label	near						  ;C01
	div	cs:BytesPerClust	;compute # of clusts used by file ;C09
	cmp	dx,0			;Q: Was there a remainder?	  ;C01
	je	cont4			;  A: no, don't do anything	  ;C01
	inc	ax			;     yes, incr. # of clusters	  ;C01
cont4	label	near							  ;C01
	add	ax,cs:AvailClusts	;Get total of file and available  ;C09
	cmp	cs:FileSzInClusts,ax	;Q: Is cluster size of new file	  ;C01
					;  > cluster size of file?	  ;C01
	jna	cont5			;  A: no, go ahead and write
									  ;C01
RSJMP:									  ;C01
	mov	dx,OFFSET DG:NOSPACE_PTR				  ;C01
	jmp	RESTARTJMP						  ;C01
cont5	label	near							  ;C01
		ret							  ;C01
									  ;C01
;   These variables used to determine if the file is larger than the	  ;C01
;   amount of disk space available whenever a write occurs.		  ;C01
									  ;C01
AvailClusts	    DW	?						  ;C01
SectsPerClust	    DW	?						  ;C01
BytesPerSect	    DW	?						  ;C01
FileSzInClusts	    DW	?						  ;C01
MaxBytesInFClust    DW	?						  ;C01
BytesPerClust	    DW	?						  ;C09
ChkFileSz endp								  ;C01

CODE	ENDS
	END	DEBCOM2

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\debconst.asm ===
;**************************************************************************
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;   Change Log:
;
;     Date    Who   #                   Description
;   --------  ---  ---  ------------------------------------------------------
;   04/01/90  DIC  C01  These variables are used to determine if enough memory
;                       is available to write a file out to disk. (Compaq STR
;                       #1889) (MS Bug #774)
;*****************************************************************************/
           PAGE    80,132 ;
	   TITLE DEBCONST.ASM
	   IF1
	       %OUT COMPONENT=DEBUG, MODULE=DEBCONST
	   ENDIF
.XLIST
.XCREF
include	version.inc		; cas -- missing equates
include	syscall.inc		; cas -- missing equates
INCLUDE    DOSSYM.INC
INCLUDE    debug.inc
.LIST
.CREF

CODE	   SEGMENT PUBLIC BYTE
CODE	   ENDS

CONST	   SEGMENT PUBLIC BYTE
CONST	   ENDS

CSTACK	   SEGMENT STACK
CSTACK	   ENDS

DATA	   SEGMENT PUBLIC BYTE
DATA	   ENDS

DG	   GROUP CODE,CONST,CSTACK,DATA

CODE	   SEGMENT PUBLIC  BYTE

	   EXTRN ALUFROMREG:NEAR, ALUTOREG:NEAR, ACCIMM:NEAR, SEGOP:NEAR
	   EXTRN ESPRE:NEAR, SSPRE:NEAR, CSPRE:NEAR, DSPRE:NEAR
	   EXTRN REGOP:NEAR, NOOPERANDS:NEAR, SAVHEX:NEAR, SHORTJMP:NEAR
	   EXTRN MOVSEGTO:NEAR, WORDTOALU:NEAR, MOVSEGFROM:NEAR
	   EXTRN GETADDR:NEAR, XCHGAX:NEAR, LONGJMP:NEAR, LOADACC:NEAR
	   EXTRN STOREACC:NEAR, REGIMMB:NEAR, SAV16:NEAR, MEMIMM:NEAR
	   EXTRN INT3:NEAR, SAV8:NEAR, CHK10:NEAR, M8087:NEAR
	   EXTRN M8087_D9:NEAR, M8087_DB:NEAR, M8087_DD:NEAR
	   EXTRN M8087_DF:NEAR, INFIXB:NEAR, INFIXW:NEAR, OUTFIXB:NEAR
	   EXTRN OUTFIXW:NEAR, JMPCALL:NEAR, INVARB:NEAR, INVARW:NEAR
	   EXTRN OUTVARB:NEAR, OUTVARW:NEAR, PREFIX:NEAR, IMMED:NEAR
	   EXTRN SIGNIMM:NEAR, SHIFT:NEAR, SHIFTV:NEAR, GRP1:NEAR
	   EXTRN GRP2:NEAR, REGIMMW:NEAR, DOORG:NEAR


	   EXTRN DB_OPER:NEAR, DW_OPER:NEAR, ASSEMLOOP:NEAR, GROUP2:NEAR
	   EXTRN NO_OPER:NEAR, GROUP1:NEAR, FGROUPP:NEAR, FGROUPX:NEAR
	   EXTRN FGROUPZ:NEAR, FD9_OPER:NEAR, FGROUPB:NEAR, FGROUP:NEAR
	   EXTRN FGROUPDS:NEAR, DCINC_OPER:NEAR, INT_OPER:NEAR
	   EXTRN IN_OPER:NEAR, DISP8_OPER:NEAR, JMP_OPER:NEAR, L_OPER:NEAR
	   EXTRN MOV_OPER:NEAR, OUT_OPER:NEAR, PUSH_OPER:NEAR
	   EXTRN GET_DATA16:NEAR, FGROUP3:NEAR, FGROUP3W:NEAR
	   EXTRN FDE_OPER:NEAR, ESC_OPER:NEAR, AA_OPER:NEAR
	   EXTRN CALL_OPER:NEAR, FDB_OPER:NEAR, POP_OPER:NEAR, ROTOP:NEAR
	   EXTRN TST_OPER:NEAR, EX_OPER:NEAR

CODE	   ENDS

CONST	   SEGMENT PUBLIC BYTE

	   PUBLIC REG8, REG16, SREG, SIZ8, DISTAB, DBMN, ADDMN, ADCMN, SUBMN
	   PUBLIC SBBMN, XORMN, ORMN, ANDMN, AAAMN, AADMN, AASMN, CALLMN, CBWMN
	   PUBLIC UPMN, DIMN, CMCMN, CMPMN, CWDMN, DAAMN, DASMN, DECMN, DIVMN
	   PUBLIC ESCMN, HLTMN, IDIVMN, IMULMN, INCMN, INTOMN, INTMN, INMN
	   PUBLIC IRETMN, JAMN, JCXZMN, JNCMN, JBEMN, JZMN, JGEMN, JGMN, JLEMN
	   PUBLIC JLMN, JMPMN, JNZMN, JPEMN, JNZMN, JPEMN, JPOMN, JNSMN, JNOMN
	   PUBLIC JOMN, JSMN, LAHFMN, LDSMN, LEAMN, LESMN, LOCKMN, LODBMN
	   PUBLIC LODWMN, LOOPNZMN, LOOPZMN, LOOPMN, MOVBMN, MOVWMN, MOVMN
	   PUBLIC MULMN, NEGMN, NOPMN, NOTMN, OUTMN, POPFMN, POPMN, PUSHFMN
	   PUBLIC PUSHMN, RCLMN, RCRMN, REPZMN, REPNZMN, RETFMN, RETMN, ROLMN
	   PUBLIC RORMN, SAHFMN, SARMN, SCABMN, SCAWMN, SHLMN, SHRMN, STCMN
	   PUBLIC DOWNMN, EIMN, STOBMN, STOWMN, TESTMN, WAITMN, XCHGMN, XLATMN
	   PUBLIC ESSEGMN, CSSEGMN, SSSEGMN, DSSEGMN, BADMN

	   PUBLIC M8087_TAB, FI_TAB, SIZE_TAB, MD9_TAB, MD9_TAB2, MDB_TAB
	   PUBLIC MDB_TAB2, MDD_TAB, MDD_TAB2, MDF_TAB, OPTAB, MAXOP, SHFTAB
	   PUBLIC IMMTAB, GRP1TAB, GRP2TAB, SEGTAB, REGTAB, REGTABEND, FLAGTAB
	   PUBLIC STACK

           PUBLIC DriveOfFile,FileSizeHB,FileSizeLB,TempLB,TempHB     ;C01

	   PUBLIC AXSAVE, BXSAVE, CXSAVE, DXSAVE, BPSAVE, SPSAVE, SISAVE
	   PUBLIC DISAVE, DSSAVE, ESSAVE, SSSAVE, CSSAVE, IPSAVE, FLSAVE, RSTACK
	   PUBLIC REGDIF, RDFLG, TOTREG, DSIZ, NOREGL, DISPB, LBUFSIZ, LBUFFCNT
	   PUBLIC LINEBUF, PFLAG, COLPOS, RSETFLAG

	   IF	SYSVER
	   PUBLIC CONFCB, POUT, COUT, CIN, IOBUFF, IOADDR, IOCALL, IOCOM
	   PUBLIC IOSTAT, IOCHRET, IOSEG, IOCNT
	   ENDIF

	   PUBLIC QFLAG, NEWEXEC, RETSAVE, USER_PROC_PDB, HEADSAVE, EXEC_BLOCK
	   PUBLIC COM_LINE, COM_FCB1, COM_FCB2, COM_SSSP, COM_CSIP, NEXTCS
	   PUBLIC NEXTIP, NAMESPEC

REG8	   DB	"ALCLDLBLAHCHDHBH"
REG16	   DB	"AXCXDXBXSPBPSIDI"
SREG	   DB	"ESCSSSDS",0,0
SIZ8	   DB	"BYWODWQWTB",0,0
; 0
DISTAB	   DW	OFFSET DG:ADDMN,ALUFROMREG
	   DW	OFFSET DG:ADDMN,ALUFROMREG
	   DW	OFFSET DG:ADDMN,ALUTOREG
	   DW	OFFSET DG:ADDMN,ALUTOREG
	   DW	OFFSET DG:ADDMN,ACCIMM
	   DW	OFFSET DG:ADDMN,ACCIMM
	   DW	OFFSET DG:PUSHMN,SEGOP
	   DW	OFFSET DG:POPMN,SEGOP
	   DW	OFFSET DG:ORMN,ALUFROMREG
	   DW	OFFSET DG:ORMN,ALUFROMREG
	   DW	OFFSET DG:ORMN,ALUTOREG
	   DW	OFFSET DG:ORMN,ALUTOREG
	   DW	OFFSET DG:ORMN,ACCIMM
	   DW	OFFSET DG:ORMN,ACCIMM
	   DW	OFFSET DG:PUSHMN,SEGOP
	   DW	OFFSET DG:DBMN,SAVHEX		; cas -- this has always been
;						; disassembled as a POP CS,
;						; which doesn't really exist.
;						; It is now a 386 prefix, but
;						; we don't know about 386
;						; instructions, so we'll put
;						; out a DB
; 10H
	   DW	OFFSET DG:ADCMN,ALUFROMREG
	   DW	OFFSET DG:ADCMN,ALUFROMREG
	   DW	OFFSET DG:ADCMN,ALUTOREG
	   DW	OFFSET DG:ADCMN,ALUTOREG
	   DW	OFFSET DG:ADCMN,ACCIMM
	   DW	OFFSET DG:ADCMN,ACCIMM
	   DW	OFFSET DG:PUSHMN,SEGOP
	   DW	OFFSET DG:POPMN,SEGOP
	   DW	OFFSET DG:SBBMN,ALUFROMREG
	   DW	OFFSET DG:SBBMN,ALUFROMREG
	   DW	OFFSET DG:SBBMN,ALUTOREG
	   DW	OFFSET DG:SBBMN,ALUTOREG
	   DW	OFFSET DG:SBBMN,ACCIMM
	   DW	OFFSET DG:SBBMN,ACCIMM
	   DW	OFFSET DG:PUSHMN,SEGOP
	   DW	OFFSET DG:POPMN,SEGOP
; 20H
	   DW	OFFSET DG:ANDMN,ALUFROMREG
	   DW	OFFSET DG:ANDMN,ALUFROMREG
	   DW	OFFSET DG:ANDMN,ALUTOREG
	   DW	OFFSET DG:ANDMN,ALUTOREG
	   DW	OFFSET DG:ANDMN,ACCIMM
	   DW	OFFSET DG:ANDMN,ACCIMM
	   DW	OFFSET DG:ESSEGMN,ESPRE
	   DW	OFFSET DG:DAAMN,NOOPERANDS
	   DW	OFFSET DG:SUBMN,ALUFROMREG
	   DW	OFFSET DG:SUBMN,ALUFROMREG
	   DW	OFFSET DG:SUBMN,ALUTOREG
	   DW	OFFSET DG:SUBMN,ALUTOREG
	   DW	OFFSET DG:SUBMN,ACCIMM
	   DW	OFFSET DG:SUBMN,ACCIMM
	   DW	OFFSET DG:CSSEGMN,CSPRE
	   DW	OFFSET DG:DASMN,NOOPERANDS
; 30H
	   DW	OFFSET DG:XORMN,ALUFROMREG
	   DW	OFFSET DG:XORMN,ALUFROMREG
	   DW	OFFSET DG:XORMN,ALUTOREG
	   DW	OFFSET DG:XORMN,ALUTOREG
	   DW	OFFSET DG:XORMN,ACCIMM
	   DW	OFFSET DG:XORMN,ACCIMM
	   DW	OFFSET DG:SSSEGMN,SSPRE
	   DW	OFFSET DG:AAAMN,NOOPERANDS
	   DW	OFFSET DG:CMPMN,ALUFROMREG
	   DW	OFFSET DG:CMPMN,ALUFROMREG
	   DW	OFFSET DG:CMPMN,ALUTOREG
	   DW	OFFSET DG:CMPMN,ALUTOREG
	   DW	OFFSET DG:CMPMN,ACCIMM
	   DW	OFFSET DG:CMPMN,ACCIMM
	   DW	OFFSET DG:DSSEGMN,DSPRE
	   DW	OFFSET DG:AASMN,NOOPERANDS
; 40H
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
; 50H
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
; 60H
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
; 70H
	   DW	OFFSET DG:JOMN,SHORTJMP
	   DW	OFFSET DG:JNOMN,SHORTJMP
	   DW	OFFSET DG:JCMN,SHORTJMP
	   DW	OFFSET DG:JNCMN,SHORTJMP
	   DW	OFFSET DG:JZMN,SHORTJMP
	   DW	OFFSET DG:JNZMN,SHORTJMP
	   DW	OFFSET DG:JBEMN,SHORTJMP
	   DW	OFFSET DG:JAMN,SHORTJMP
	   DW	OFFSET DG:JSMN,SHORTJMP
	   DW	OFFSET DG:JNSMN,SHORTJMP
	   DW	OFFSET DG:JPEMN,SHORTJMP
	   DW	OFFSET DG:JPOMN,SHORTJMP
	   DW	OFFSET DG:JLMN,SHORTJMP
	   DW	OFFSET DG:JGEMN,SHORTJMP
	   DW	OFFSET DG:JLEMN,SHORTJMP
	   DW	OFFSET DG:JGMN,SHORTJMP
; 80H
	   DW	0,IMMED
	   DW	0,IMMED
	   DW	0,IMMED
	   DW	0,SIGNIMM
	   DW	OFFSET DG:TESTMN,ALUTOREG ;ARR 2.4
	   DW	OFFSET DG:TESTMN,ALUTOREG ;ARR 2.4
	   DW	OFFSET DG:XCHGMN,ALUTOREG ;ARR 2.4
	   DW	OFFSET DG:XCHGMN,ALUTOREG ;ARR 2.4
	   DW	OFFSET DG:MOVMN,ALUFROMREG
	   DW	OFFSET DG:MOVMN,ALUFROMREG
	   DW	OFFSET DG:MOVMN,ALUTOREG
	   DW	OFFSET DG:MOVMN,ALUTOREG
	   DW	OFFSET DG:MOVMN,MOVSEGTO
	   DW	OFFSET DG:LEAMN,WORDTOALU
	   DW	OFFSET DG:MOVMN,MOVSEGFROM
	   DW	OFFSET DG:POPMN,GETADDR
; 90H
	   DW	OFFSET DG:NOPMN,NOOPERANDS
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:CBWMN,NOOPERANDS
	   DW	OFFSET DG:CWDMN,NOOPERANDS
	   DW	OFFSET DG:CALLMN,LONGJMP
	   DW	OFFSET DG:WAITMN,NOOPERANDS
	   DW	OFFSET DG:PUSHFMN,NOOPERANDS
	   DW	OFFSET DG:POPFMN,NOOPERANDS
	   DW	OFFSET DG:SAHFMN,NOOPERANDS
	   DW	OFFSET DG:LAHFMN,NOOPERANDS
; A0H
	   DW	OFFSET DG:MOVMN,LOADACC
	   DW	OFFSET DG:MOVMN,LOADACC
	   DW	OFFSET DG:MOVMN,STOREACC
	   DW	OFFSET DG:MOVMN,STOREACC
	   DW	OFFSET DG:MOVBMN,NOOPERANDS
	   DW	OFFSET DG:MOVWMN,NOOPERANDS
	   DW	OFFSET DG:CMPBMN,NOOPERANDS
	   DW	OFFSET DG:CMPWMN,NOOPERANDS
	   DW	OFFSET DG:TESTMN,ACCIMM
	   DW	OFFSET DG:TESTMN,ACCIMM
	   DW	OFFSET DG:STOBMN,NOOPERANDS
	   DW	OFFSET DG:STOWMN,NOOPERANDS
	   DW	OFFSET DG:LODBMN,NOOPERANDS
	   DW	OFFSET DG:LODWMN,NOOPERANDS
	   DW	OFFSET DG:SCABMN,NOOPERANDS
	   DW	OFFSET DG:SCAWMN,NOOPERANDS
; B0H
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
; C0H
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:RETMN,SAV16
	   DW	OFFSET DG:RETMN,NOOPERANDS
	   DW	OFFSET DG:LESMN,WORDTOALU
	   DW	OFFSET DG:LDSMN,WORDTOALU
	   DW	OFFSET DG:MOVMN,MEMIMM
	   DW	OFFSET DG:MOVMN,MEMIMM
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:RETFMN,SAV16
	   DW	OFFSET DG:RETFMN,NOOPERANDS
	   DW	OFFSET DG:INTMN,INT3
	   DW	OFFSET DG:INTMN,SAV8
	   DW	OFFSET DG:INTOMN,NOOPERANDS
	   DW	OFFSET DG:IRETMN,NOOPERANDS
; D0H
	   DW	0,SHIFT
	   DW	0,SHIFT
	   DW	0,SHIFTV
	   DW	0,SHIFTV
	   DW	OFFSET DG:AAMMN,CHK10
	   DW	OFFSET DG:AADMN,CHK10
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:XLATMN,NOOPERANDS
	   DW	0,M8087 		; d8
	   DW	0,M8087_D9		; d9
	   DW	0,M8087 		; da
	   DW	0,M8087_DB		; db
	   DW	0,M8087 		; dc
	   DW	0,M8087_DD		; dd
	   DW	0,M8087 		; de
	   DW	0,M8087_DF		; df
; E0H
	   DW	OFFSET DG:LOOPNZMN,SHORTJMP
	   DW	OFFSET DG:LOOPZMN,SHORTJMP
	   DW	OFFSET DG:LOOPMN,SHORTJMP
	   DW	OFFSET DG:JCXZMN,SHORTJMP
	   DW	OFFSET DG:INMN,INFIXB
	   DW	OFFSET DG:INMN,INFIXW
	   DW	OFFSET DG:OUTMN,OUTFIXB
	   DW	OFFSET DG:OUTMN,OUTFIXW
	   DW	OFFSET DG:CALLMN,JMPCALL
	   DW	OFFSET DG:JMPMN,JMPCALL
	   DW	OFFSET DG:JMPMN,LONGJMP
	   DW	OFFSET DG:JMPMN,SHORTJMP
	   DW	OFFSET DG:INMN,INVARB
	   DW	OFFSET DG:INMN,INVARW
	   DW	OFFSET DG:OUTMN,OUTVARB
	   DW	OFFSET DG:OUTMN,OUTVARW
; F0H
	   DW	OFFSET DG:LOCKMN,PREFIX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:REPNZMN,PREFIX
	   DW	OFFSET DG:REPZMN,PREFIX
	   DW	OFFSET DG:HLTMN,NOOPERANDS
	   DW	OFFSET DG:CMCMN,NOOPERANDS
	   DW	0,GRP1
	   DW	0,GRP1
	   DW	OFFSET DG:CLCMN,NOOPERANDS
	   DW	OFFSET DG:STCMN,NOOPERANDS
	   DW	OFFSET DG:DIMN,NOOPERANDS
	   DW	OFFSET DG:EIMN,NOOPERANDS
	   DW	OFFSET DG:UPMN,NOOPERANDS
	   DW	OFFSET DG:DOWNMN,NOOPERANDS
	   DW	0,GRP2
	   DW	0,GRP2

DBMN	   DB	"DB",0
	   DB	"DW",0
	   DB	";",0
ORGMN	   DB	"ORG",0
ADDMN	   DB	"ADD",0
ADCMN	   DB	"ADC",0
SUBMN	   DB	"SUB",0
SBBMN	   DB	"SBB",0
XORMN	   DB	"XOR",0
ORMN	   DB	"OR",0
ANDMN	   DB	"AND",0
AAAMN	   DB	"AAA",0
AADMN	   DB	"AAD",0
AAMMN	   DB	"AAM",0
AASMN	   DB	"AAS",0
CALLMN	   DB	"CALL",0
CBWMN	   DB	"CBW",0
CLCMN	   DB	"CLC",0
UPMN	   DB	"CLD",0                 ; CLD,0
DIMN	   DB	"CLI",0
CMCMN	   DB	"CMC",0
CMPBMN	   DB	"CMPSB",0               ; CMPSB
CMPWMN	   DB	"CMPSW",0               ; CMPSW,0
CMPMN	   DB	"CMP",0
CWDMN	   DB	"CWD",0
DAAMN	   DB	"DAA",0
DASMN	   DB	"DAS",0
DECMN	   DB	"DEC",0
DIVMN	   DB	"DIV",0
ESCMN	   DB	"ESC",0
	   DB	"FXCH",0
	   DB	"FFREE",0
	   DB	"FCOMPP",0
	   DB	"FCOMP",0
	   DB	"FCOM",0
	   DB	"FICOMP",0
	   DB	"FICOM",0
	   DB	"FNOP",0
	   DB	"FCHS",0
	   DB	"FABS",0
	   DB	"FTST",0
	   DB	"FXAM",0
	   DB	"FLDL2T",0
	   DB	"FLDL2E",0
	   DB	"FLDLG2",0
	   DB	"FLDLN2",0
	   DB	"FLDPI",0
	   DB	"FLD1",0
	   DB	"FLDZ",0
	   DB	"F2XM1",0
	   DB	"FYL2XP1",0
	   DB	"FYL2X",0
	   DB	"FPTAN",0
	   DB	"FPATAN",0
	   DB	"FXTRACT",0
	   DB	"FDECSTP",0
	   DB	"FINCSTP",0
	   DB	"FPREM",0
	   DB	"FSQRT",0
	   DB	"FRNDINT",0
	   DB	"FSCALE",0
	   DB	"FINIT",0
	   DB	"FDISI",0
	   DB	"FENI",0
	   DB	"FCLEX",0
	   DB	"FBLD",0
	   DB	"FBSTP",0
	   DB	"FLDCW",0
	   DB	"FSTCW",0
	   DB	"FSTSW",0
	   DB	"FSTENV",0
	   DB	"FLDENV",0
	   DB	"FSAVE",0
	   DB	"FRSTOR",0
	   DB	"FADDP",0
	   DB	"FADD",0
	   DB	"FIADD",0
	   DB	"FSUBRP",0
	   DB	"FSUBR",0
	   DB	"FSUBP",0
	   DB	"FSUB",0
	   DB	"FISUBR",0
	   DB	"FISUB",0
	   DB	"FMULP",0
	   DB	"FMUL",0
	   DB	"FIMUL",0
	   DB	"FDIVRP",0
	   DB	"FDIVR",0
	   DB	"FDIVP",0
	   DB	"FDIV",0
	   DB	"FIDIVR",0
	   DB	"FIDIV",0
	   DB	"FWAIT",0
	   DB	"FILD",0
	   DB	"FLD",0
	   DB	"FSTP",0
	   DB	"FST",0
	   DB	"FISTP",0
	   DB	"FIST",0
HLTMN	   DB	"HLT",0
IDIVMN	   DB	"IDIV",0
IMULMN	   DB	"IMUL",0
INCMN	   DB	"INC",0
INTOMN	   DB	"INTO",0
INTMN	   DB	"INT",0
INMN	   DB	"IN",0                  ; IN
IRETMN	   DB	"IRET",0
	   DB	"JNBE",0
	   DB	"JAE",0
JAMN	   DB	"JA",0
JCXZMN	   DB	"JCXZ",0
JNCMN	   DB	"JNB",0
JBEMN	   DB	"JBE",0
JCMN	   DB	"JB",0
	   DB	"JNC",0
	   DB	"JC",0
	   DB	"JNAE",0
	   DB	"JNA",0
JZMN	   DB	"JZ",0
	   DB	"JE",0
JGEMN	   DB	"JGE",0
JGMN	   DB	"JG",0
	   DB	"JNLE",0
	   DB	"JNL",0
JLEMN	   DB	"JLE",0
JLMN	   DB	"JL",0
	   DB	"JNGE",0
	   DB	"JNG",0
JMPMN	   DB	"JMP",0
JNZMN	   DB	"JNZ",0
	   DB	"JNE",0
JPEMN	   DB	"JPE",0
JPOMN	   DB	"JPO",0
	   DB	"JNP",0
JNSMN	   DB	"JNS",0
JNOMN	   DB	"JNO",0
JOMN	   DB	"JO",0
JSMN	   DB	"JS",0
	   DB	"JP",0
LAHFMN	   DB	"LAHF",0
LDSMN	   DB	"LDS",0
LEAMN	   DB	"LEA",0
LESMN	   DB	"LES",0
LOCKMN	   DB	"LOCK",0
LODBMN	   DB	"LODSB",0               ; LODSB
LODWMN	   DB	"LODSW",0               ; LODSW,0
LOOPNZMN   DB	"LOOPNZ",0
LOOPZMN    DB	"LOOPZ",0
	   DB	"LOOPNE",0
	   DB	"LOOPE",0
LOOPMN	   DB	"LOOP",0
MOVBMN	   DB	"MOVSB",0               ; MOVSB
MOVWMN	   DB	"MOVSW",0               ; MOVSW,0
MOVMN	   DB	"MOV",0
MULMN	   DB	"MUL",0
NEGMN	   DB	"NEG",0
NOPMN	   DB	"NOP",0
NOTMN	   DB	"NOT",0
OUTMN	   DB	"OUT",0                 ; OUT
POPFMN	   DB	"POPF",0
POPMN	   DB	"POP",0
PUSHFMN    DB	"PUSHF",0
PUSHMN	   DB	"PUSH",0
RCLMN	   DB	"RCL",0
RCRMN	   DB	"RCR",0
REPZMN	   DB	"REPZ",0
REPNZMN    DB	"REPNZ",0
	   DB	"REPE",0
	   DB	"REPNE",0
	   DB	"REP",0
RETFMN	   DB	"RETF",0
RETMN	   DB	"RET",0
ROLMN	   DB	"ROL",0
RORMN	   DB	"ROR",0
SAHFMN	   DB	"SAHF",0
SARMN	   DB	"SAR",0
SCABMN	   DB	"SCASB",0               ; SCASB
SCAWMN	   DB	"SCASW",0               ; SCASW,0
SHLMN	   DB	"SHL",0
SHRMN	   DB	"SHR",0
STCMN	   DB	"STC",0
DOWNMN	   DB	"STD",0                 ; STD
EIMN	   DB	"STI",0                 ; STI
STOBMN	   DB	"STOSB",0               ; STOSB
STOWMN	   DB	"STOSW",0               ; STOSW,0
TESTMN	   DB	"TEST",0
WAITMN	   DB	"WAIT",0
XCHGMN	   DB	"XCHG",0
XLATMN	   DB	"XLAT",0
ESSEGMN    DB	"ES:",0
CSSEGMN    DB	"CS:",0
SSSEGMN    DB	"SS:",0
DSSEGMN    DB	"DS:",0
BADMN	   DB	"???",0

M8087_TAB  DB	"ADD$MUL$COM$COMP$SUB$SUBR$DIV$DIVR$"
FI_TAB	   DB	"F$FI$F$FI$"
SIZE_TAB   DB	"DWORD PTR $DWORD PTR $QWORD PTR $WORD PTR $"
	   DB	"BYTE PTR $TBYTE PTR $"

MD9_TAB    DB	"LD$@$ST$STP$LDENV$LDCW$STENV$STCW$"
MD9_TAB2   DB	"CHS$ABS$@$@$TST$XAM$@$@$LD1$LDL2T$LDL2E$"
	   DB	"LDPI$LDLG2$LDLN2$LDZ$@$2XM1$YL2X$PTAN$PATAN$XTRACT$"
	   DB	"@$DECSTP$INCSTP$PREM$YL2XP1$SQRT$@$RNDINT$SCALE$@$@$"

MDB_TAB    DB	"ILD$@$IST$ISTP$@$LD$@$STP$"
MDB_TAB2   DB	"ENI$DISI$CLEX$INIT$"

MDD_TAB    DB	"LD$@$ST$STP$RSTOR$@$SAVE$STSW$"
MDD_TAB2   DB	"FREE$XCH$ST$STP$"

MDF_TAB    DB	"ILD$@$IST$ISTP$BLD$ILD$BSTP$ISTP$"


OPTAB	   DB	11111111B		; DB
	   DW	DB_OPER
	   DB	11111111B		; DW
	   DW	DW_OPER
	   DB	11111111B		; COMMENT
	   DW	ASSEMLOOP
	   DB	11111111B		; ORG
	   DW	DOORG
	   DB	0 * 8			; ADD
	   DW	GROUP2
	   DB	2 * 8			; ADC
	   DW	GROUP2
	   DB	5 * 8			; SUB
	   DW	GROUP2
	   DB	3 * 8			; SBB
	   DW	GROUP2
	   DB	6 * 8			; XOR
	   DW	GROUP2
	   DB	1 * 8			; OR
	   DW	GROUP2
	   DB	4 * 8			; AND
	   DW	GROUP2
	   DB	00110111B		; AAA
	   DW	NO_OPER
	   DB	11010101B		; AAD
	   DW	AA_OPER
	   DB	11010100B		; AAM
	   DW	AA_OPER
	   DB	00111111B		; AAS
	   DW	NO_OPER
	   DB	2 * 8			; CALL
	   DW	CALL_OPER
	   DB	10011000B		; CBW
	   DW	NO_OPER
	   DB	11111000B		; CLC
	   DW	NO_OPER
	   DB	11111100B		; CLD
	   DW	NO_OPER
	   DB	11111010B		; DIM
	   DW	NO_OPER
	   DB	11110101B		; CMC
	   DW	NO_OPER
	   DB	10100110B		; CMPB
	   DW	NO_OPER
	   DB	10100111B		; CMPW
	   DW	NO_OPER
	   DB	7 * 8			; CMP
	   DW	GROUP2
	   DB	10011001B		; CWD
	   DW	NO_OPER
	   DB	00100111B		; DAA
	   DW	NO_OPER
	   DB	00101111B		; DAS
	   DW	NO_OPER
	   DB	1 * 8			; DEC
	   DW	DCINC_OPER
	   DB	6 * 8			; DIV
	   DW	GROUP1
	   DB	11011000B		; ESC
	   DW	ESC_OPER
	   DB	00001001B		; FXCH
	   DW	FGROUPP
	   DB	00101000B		; FFREE
	   DW	FGROUPP
	   DB	11011001B		; FCOMPP
	   DW	FDE_OPER
	   DB	00000011B		; FCOMP
	   DW	FGROUPX 		; Exception to normal P instructions
	   DB	00000010B		; FCOM
	   DW	FGROUPX
	   DB	00010011B		; FICOMP
	   DW	FGROUPZ
	   DB	00010010B		; FICOM
	   DW	FGROUPZ
	   DB	11010000B		; FNOP
	   DW	FD9_OPER
	   DB	11100000B		; FCHS
	   DW	FD9_OPER
	   DB	11100001B		; FABS
	   DW	FD9_OPER
	   DB	11100100B		; FTST
	   DW	FD9_OPER
	   DB	11100101B		; FXAM
	   DW	FD9_OPER
	   DB	11101001B		; FLDL2T
	   DW	FD9_OPER
	   DB	11101010B		; FLDL2E
	   DW	FD9_OPER
	   DB	11101100B		; FLDLG2
	   DW	FD9_OPER
	   DB	11101101B		; FLDLN2
	   DW	FD9_OPER
	   DB	11101011B		; FLDPI
	   DW	FD9_OPER
	   DB	11101000B		; FLD1
	   DW	FD9_OPER
	   DB	11101110B		; FLDZ
	   DW	FD9_OPER
	   DB	11110000B		; F2XM1
	   DW	FD9_OPER
	   DB	11111001B		; FYL2XP1
	   DW	FD9_OPER
	   DB	11110001B		; FYL2X
	   DW	FD9_OPER
	   DB	11110010B		; FPTAN
	   DW	FD9_OPER
	   DB	11110011B		; FPATAN
	   DW	FD9_OPER
	   DB	11110100B		; FXTRACT
	   DW	FD9_OPER
	   DB	11110110B		; FDECSTP
	   DW	FD9_OPER
	   DB	11110111B		; FINCSTP
	   DW	FD9_OPER
	   DB	11111000B		; FPREM
	   DW	FD9_OPER
	   DB	11111010B		; FSQRT
	   DW	FD9_OPER
	   DB	11111100B		; FRNDINT
	   DW	FD9_OPER
	   DB	11111101B		; FSCALE
	   DW	FD9_OPER
	   DB	11100011B		; FINIT
	   DW	FDB_OPER
	   DB	11100001B		; FDISI
	   DW	FDB_OPER
	   DB	11100000B		; FENI
	   DW	FDB_OPER
	   DB	11100010B		; FCLEX
	   DW	FDB_OPER
	   DB	00111100B		; FBLD
	   DW	FGROUPB
	   DB	00111110B		; FBSTP
	   DW	FGROUPB
	   DB	00001101B		; FLDCW
	   DW	FGROUP3W
	   DB	00001111B		; FSTCW
	   DW	FGROUP3W
	   DB	00101111B		; FSTSW
	   DW	FGROUP3W
	   DB	00001110B		; FSTENV
	   DW	FGROUP3
	   DB	00001100B		; FLDENV
	   DW	FGROUP3
	   DB	00101110B		; FSAVE
	   DW	FGROUP3
	   DB	00101100B		; FRSTOR
	   DW	FGROUP3
	   DB	00110000B		; FADDP
	   DW	FGROUPP
	   DB	00000000B		; FADD
	   DW	FGROUP
	   DB	00010000B		; FIADD
	   DW	FGROUPZ
	   DB	00110100B		; FSUBRP
	   DW	FGROUPP
	   DB	00000101B		; FSUBR
	   DW	FGROUPDS
	   DB	00110101B		; FSUBP
	   DW	FGROUPP
	   DB	00000100B		; FSUB
	   DW	FGROUPDS
	   DB	00010101B		; FISUBR
	   DW	FGROUPZ
	   DB	00010100B		; FISUB
	   DW	FGROUPZ
	   DB	00110001B		; FMULP
	   DW	FGROUPP
	   DB	00000001B		; FMUL
	   DW	FGROUP
	   DB	00010001B		; FIMUL
	   DW	FGROUPZ
	   DB	00110110B		; FDIVRP
	   DW	FGROUPP
	   DB	00000111B		; FDIVR
	   DW	FGROUPDS
	   DB	00110111B		; FDIVP
	   DW	FGROUPP
	   DB	00000110B		; FDIV
	   DW	FGROUPDS
	   DB	00010111B		; FIDIVR
	   DW	FGROUPZ
	   DB	00010110B		; FIDIV
	   DW	FGROUPZ
	   DB	10011011B		; FWAIT
	   DW	NO_OPER
	   DB	00011000B		; FILD
	   DW	FGROUPZ
	   DB	00001000B		; FLD
	   DW	FGROUPX
	   DB	00001011B		; FSTP
	   DW	FGROUP			;an000; dms;
	   DB	00101010B		; FST
	   DW	FGROUPX
	   DB	00011011B		; FISTP
	   DW	FGROUPZ
	   DB	00011010B		; FIST
	   DW	FGROUPZ
	   DB	11110100B		; HLT
	   DW	NO_OPER
	   DB	7 * 8			; IDIV
	   DW	GROUP1
	   DB	5 * 8			; IMUL
	   DW	GROUP1
	   DB	0 * 8			; INC
	   DW	DCINC_OPER
	   DB	11001110B		; INTO
	   DW	NO_OPER
	   DB	11001100B		; INTM
	   DW	INT_OPER
	   DB	11101100B		; IN
	   DW	IN_OPER
	   DB	11001111B		; IRET
	   DW	NO_OPER
	   DB	01110111B		; JNBE
	   DW	DISP8_OPER
	   DB	01110011B		; JAE
	   DW	DISP8_OPER
	   DB	01110111B		; JA
	   DW	DISP8_OPER
	   DB	11100011B		; JCXZ
	   DW	DISP8_OPER
	   DB	01110011B		; JNB
	   DW	DISP8_OPER
	   DB	01110110B		; JBE
	   DW	DISP8_OPER
	   DB	01110010B		; JB
	   DW	DISP8_OPER
	   DB	01110011B		; JNC
	   DW	DISP8_OPER
	   DB	01110010B		; JC
	   DW	DISP8_OPER
	   DB	01110010B		; JNAE
	   DW	DISP8_OPER
	   DB	01110110B		; JNA
	   DW	DISP8_OPER
	   DB	01110100B		; JZ
	   DW	DISP8_OPER
	   DB	01110100B		; JE
	   DW	DISP8_OPER
	   DB	01111101B		; JGE
	   DW	DISP8_OPER
	   DB	01111111B		; JG
	   DW	DISP8_OPER
	   DB	01111111B		; JNLE
	   DW	DISP8_OPER
	   DB	01111101B		; JNL
	   DW	DISP8_OPER
	   DB	01111110B		; JLE
	   DW	DISP8_OPER
	   DB	01111100B		; JL
	   DW	DISP8_OPER
	   DB	01111100B		; JNGE
	   DW	DISP8_OPER
	   DB	01111110B		; JNG
	   DW	DISP8_OPER
	   DB	4 * 8			; JMP
	   DW	JMP_OPER
	   DB	01110101B		; JNZ
	   DW	DISP8_OPER
	   DB	01110101B		; JNE
	   DW	DISP8_OPER
	   DB	01111010B		; JPE
	   DW	DISP8_OPER
	   DB	01111011B		; JPO
	   DW	DISP8_OPER
	   DB	01111011B		; JNP
	   DW	DISP8_OPER
	   DB	01111001B		; JNS
	   DW	DISP8_OPER
	   DB	01110001B		; JNO
	   DW	DISP8_OPER
	   DB	01110000B		; JO
	   DW	DISP8_OPER
	   DB	01111000B		; JS
	   DW	DISP8_OPER
	   DB	01111010B		; JP
	   DW	DISP8_OPER
	   DB	10011111B		; LAHF
	   DW	NO_OPER
	   DB	11000101B		; LDS
	   DW	L_OPER
	   DB	10001101B		; LEA
	   DW	L_OPER
	   DB	11000100B		; LES
	   DW	L_OPER
	   DB	11110000B		; LOCK
	   DW	NO_OPER
	   DB	10101100B		; LODB
	   DW	NO_OPER
	   DB	10101101B		; LODW
	   DW	NO_OPER
	   DB	11100000B		; LOOPNZ
	   DW	DISP8_OPER
	   DB	11100001B		; LOOPZ
	   DW	DISP8_OPER
	   DB	11100000B		; LOOPNE
	   DW	DISP8_OPER
	   DB	11100001B		; LOOPE
	   DW	DISP8_OPER
	   DB	11100010B		; LOOP
	   DW	DISP8_OPER
	   DB	10100100B		; MOVB
	   DW	NO_OPER
	   DB	10100101B		; MOVW
	   DW	NO_OPER
	   DB	11000110B		; MOV
	   DW	MOV_OPER
	   DB	4 * 8			; MUL
	   DW	GROUP1
	   DB	3 * 8			; NEG
	   DW	GROUP1
	   DB	10010000B		; NOP
	   DW	NO_OPER
	   DB	2 * 8			; NOT
	   DW	GROUP1
	   DB	11101110B		; OUT
	   DW	OUT_OPER
	   DB	10011101B		; POPF
	   DW	NO_OPER
	   DB	0 * 8			; POP
	   DW	POP_OPER
	   DB	10011100B		; PUSHF
	   DW	NO_OPER
	   DB	6 * 8			; PUSH
	   DW	PUSH_OPER
	   DB	2 * 8			; RCL
	   DW	ROTOP
	   DB	3 * 8			; RCR
	   DW	ROTOP
	   DB	11110011B		; REPZ
	   DW	NO_OPER
	   DB	11110010B		; REPNZ
	   DW	NO_OPER
	   DB	11110011B		; REPE
	   DW	NO_OPER
	   DB	11110010B		; REPNE
	   DW	NO_OPER
	   DB	11110011B		; REP
	   DW	NO_OPER
	   DB	11001011B		; RETF
	   DW	GET_DATA16
	   DB	11000011B		; RET
	   DW	GET_DATA16
	   DB	0 * 8			; ROL
	   DW	ROTOP
	   DB	1 * 8			; ROR
	   DW	ROTOP
	   DB	10011110B		; SAHF
	   DW	NO_OPER
	   DB	7 * 8			; SAR
	   DW	ROTOP
	   DB	10101110B		; SCAB
	   DW	NO_OPER
	   DB	10101111B		; SCAW
	   DW	NO_OPER
	   DB	4 * 8			; SHL
	   DW	ROTOP
	   DB	5 * 8			; SHR
	   DW	ROTOP
	   DB	11111001B		; STC
	   DW	NO_OPER
	   DB	11111101B		; STD
	   DW	NO_OPER
	   DB	11111011B		; EI
	   DW	NO_OPER
	   DB	10101010B		; STOB
	   DW	NO_OPER
	   DB	10101011B		; STOW
	   DW	NO_OPER
	   DB	11110110B		; TEST
	   DW	TST_OPER
	   DB	10011011B		; WAIT
	   DW	NO_OPER
	   DB	10000110B		; XCHG
	   DW	EX_OPER
	   DB	11010111B		; XLAT
	   DW	NO_OPER
	   DB	00100110B		; ESSEG
	   DW	NO_OPER
	   DB	00101110B		; CSSEG
	   DW	NO_OPER
	   DB	00110110B		; SSSEG
	   DW	NO_OPER
	   DB	00111110B		; DSSEG
	   DW	NO_OPER

ZZOPCODE   LABEL BYTE
MAXOP	   =	(ZZOPCODE-OPTAB)/3

SHFTAB	   DW	OFFSET DG:ROLMN,OFFSET DG:RORMN,OFFSET DG:RCLMN
	   DW	OFFSET DG:RCRMN,OFFSET DG:SHLMN,OFFSET DG:SHRMN
	   DW	OFFSET DG:BADMN,OFFSET DG:SARMN

IMMTAB	   DW	OFFSET DG:ADDMN,OFFSET DG:ORMN,OFFSET DG:ADCMN
	   DW	OFFSET DG:SBBMN,OFFSET DG:ANDMN,OFFSET DG:SUBMN
	   DW	OFFSET DG:XORMN,OFFSET DG:CMPMN

GRP1TAB    DW	OFFSET DG:TESTMN,OFFSET DG:BADMN,OFFSET DG:NOTMN
	   DW	OFFSET DG:NEGMN,OFFSET DG:MULMN,OFFSET DG:IMULMN
	   DW	OFFSET DG:DIVMN,OFFSET DG:IDIVMN

GRP2TAB    DW	OFFSET DG:INCMN,OFFSET DG:DECMN,OFFSET DG:CALLMN
	   DW	OFFSET DG:CALLMN,OFFSET DG:JMPMN,OFFSET DG:JMPMN
	   DW	OFFSET DG:PUSHMN,OFFSET DG:BADMN

SEGTAB	   DW	OFFSET DG:ESSAVE,OFFSET DG:CSSAVE,OFFSET DG:SSSAVE
	   DW	OFFSET DG:DSSAVE

REGTAB	   DB	"AX",0,"BX",0,"CX",0,"DX",0,"SP",0,"BP",0
	   DB	"SI",0,"DI",0,"DS",0,"ES",0,"SS",0,"CS",0,"IP",0,"PC",0
REGTABEND  LABEL WORD

; Flags are ordered to correspond with the bits of the flag
; register, most significant bit first, zero if bit is not
; a flag. First 16 entries are for bit set, second 16 for
; bit reset.

FLAGTAB    DW	0
	   DW	0
	   DW	0
	   DW	0
	   DB	"OV"
	   DB	"DN"
	   DB	"EI"                    ; "STI"
	   DW	0
	   DB	"NG"
	   DB	"ZR"
	   DW	0
	   DB	"AC"
	   DW	0
	   DB	"PE"
	   DW	0
	   DB	"CY"
	   DW	0
	   DW	0
	   DW	0
	   DW	0
	   DB	"NV"
	   DB	"UP"                    ; "CLD"
	   DB	"DI"
	   DW	0
	   DB	"PL"
	   DB	"NZ"
	   DW	0
	   DB	"NA"
	   DW	0
	   DB	"PO"
	   DW	0
	   DB	"NC"

	   DW	80H DUP(?)
STACK	   LABEL BYTE


; Register save area

AXSAVE	   DW	0
BXSAVE	   DW	0
CXSAVE	   DW	0
DXSAVE	   DW	0
SPSAVE	   DW	5AH
BPSAVE	   DW	0
SISAVE	   DW	0
DISAVE	   DW	0
DSSAVE	   DW	0
ESSAVE	   DW	0
RSTACK	   LABEL WORD			; Stack set here so registers can be saved by pushing
SSSAVE	   DW	0
CSSAVE	   DW	0
IPSAVE	   DW	100H
FLSAVE	    DW	 0F202H

RSETFLAG   DB	0

;  These variables used to determine if the file is larget than the   ;C01
;  amount of disk space available whenever a write occurs.            ;C01
								      ;C01
FileSizeLB DW   0                                                     ;C01
FileSizeHB DW   0                                                     ;C01
TempHB     DW   0                                                     ;C01
TempLB     DW   0                                                     ;C01
DriveOfFile DB  ?                                                     ;C01

REGDIF	   EQU	AXSAVE-REGTAB

; This value is initially 0, it is set to non-zero if a file is specified
;  either at debug invokation, or via the (N)ame command. It is used to
;  control the printing of the NONAMESPEC message for the (W)rite command.
NAMESPEC   DB	0

; RAM area.

RDFLG	   DB	READ
TOTREG	   DB	13
DSIZ	   DB	0FH			;changed to 7 if screen 40 col mode
NOREGL	   DB	8			;changed to 4 if screen 40 col mode
DISPB	   DW	128			;changed to 64 if screen 40 col mode

LBUFSIZ    DB	BUFLEN
LBUFFCNT   DB	0
LINEBUF    DB	0DH
	   DB	BUFLEN DUP (?)
PFLAG	   DB	0
COLPOS	   DB	0

	   IF	SYSVER
CONFCB	   DB	0
	   DB	"PRN        "
	   DB	25 DUP(0)

POUT	   DD	?
COUT	   DD	?
CIN	   DD	?
IOBUFF	   DB	3 DUP (?)
IOADDR	   DD	?

IOCALL	   DB	22
	   DB	0
IOCOM	   DB	0
IOSTAT	   DW	0
	   DB	8 DUP (0)
IOCHRET    DB	0
	   DW	OFFSET DG:IOBUFF
IOSEG	   DW	?
IOCNT	   DW	1
	   DW	0
	   ENDIF

QFLAG	   DB	0
NEWEXEC    DB	0
RETSAVE    DW	?

USER_PROC_PDB DW ?
NextCS	   DW	?
NextIP	   DW	?

HEADSAVE   DW	?

EXEC_BLOCK LABEL BYTE
	   DW	0
COM_LINE   LABEL DWORD
	   DW	80H
	   DW	?
COM_FCB1   LABEL DWORD
	   DW	FCB
	   DW	?
COM_FCB2   LABEL DWORD
	   DW	FCB + 10H
	   DW	?
COM_SSSP   DD	?
COM_CSIP   DD	?

CONST	   ENDS
	   END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\debuasm.asm ===
PAGE    80,132 ;
	   TITLE DEBUASM.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; Code for the UASSEMble command in the debugger

	    IF1
		%OUT COMPONENT=DEBUG, MODULE=DEBUASM
	    ENDIF
.XLIST
.XCREF
	   include version.inc		; cas -- missing equates
	   INCLUDE DOSSYM.INC
           INCLUDE debug.inc
.CREF
.LIST
CODE	   SEGMENT PUBLIC BYTE
CODE	   ENDS

CONST	   SEGMENT PUBLIC BYTE
	   EXTRN SYNERR_PTR:BYTE,UNASSEM_LN_PTR:WORD
	   EXTRN NSEG:WORD,SISAVE:WORD,BPSAVE:WORD,DISAVE:WORD
	   EXTRN BXSAVE:WORD,DSSAVE:WORD,ESSAVE:WORD,CSSAVE:WORD,IPSAVE:WORD
	   EXTRN SSSAVE:WORD,CXSAVE:WORD,SPSAVE:WORD,FLSAVE:WORD
	   EXTRN DISTAB:WORD,SHFTAB:WORD,IMMTAB:WORD,GRP1TAB:WORD,GRP2TAB:WORD
	   EXTRN DBMN:BYTE,ESCMN:BYTE,DISPB:WORD,STACK:BYTE,REG8:BYTE
	   EXTRN REG16:BYTE,SREG:BYTE,SIZ8:BYTE,SEGTAB:WORD,M8087_TAB:BYTE
	   EXTRN FI_TAB:BYTE,SIZE_TAB:BYTE,MD9_TAB:BYTE,MD9_TAB2:BYTE
	   EXTRN MDB_TAB:BYTE,MDB_TAB2:BYTE,MDD_TAB:BYTE,MDD_TAB2:BYTE
	   EXTRN MDF_TAB:BYTE
CONST	   ENDS

CSTACK	   SEGMENT STACK
CSTACK	   ENDS

DATA	   SEGMENT PUBLIC BYTE
	   EXTRN DISADD:BYTE,DISCNT:WORD,BYTCNT:BYTE,TEMP:BYTE,AWORD:BYTE
	   EXTRN MIDFLD:BYTE,MODE:BYTE,REGMEM:BYTE,OPCODE:WORD,OPBUF:BYTE
	   EXTRN INDEX:WORD,ARG_BUF:BYTE,ARG_BUF_PTR:BYTE,ARG_BUF_INDEX:WORD
	   EXTRN OPBUF:BYTE,OPCODE:WORD
DATA	   ENDS

DG	   GROUP CODE,CONST,CSTACK,DATA

CODE	   SEGMENT PUBLIC BYTE
	   ASSUME CS:DG,DS:DG,ES:DG,SS:DG

	   PUBLIC UNASSEM
	   PUBLIC DISASLN,MEMIMM,JMPCALL,SIGNIMM,ALUFROMREG,WORDTOALU
	   PUBLIC GRP2,PREFIX,OUTVARW,GRP1,SSPRE,MOVSEGTO,DSPRE,SHIFT
	   PUBLIC ESPRE,IMMED,CSPRE,OUTVARB,CHK10,ACCIMM,INT3,INVARB
	   PUBLIC MOVSEGFROM,LOADACC,OUTFIXB,XCHGAX,REGIMMW,SHORTJMP
	   PUBLIC SAV8,M8087,M8087_DB,M8087_DF,M8087_D9,M8087_DD
	   PUBLIC SAV16,SAVHEX,INFIXW,REGIMMB,OUTFIXW,SHIFTV,LONGJMP
	   PUBLIC INVARW,STOREACC,INFIXB,NOOPERANDS,ALUTOREG
	   PUBLIC SEGOP,REGOP,GETADDR

	   EXTRN CRLF:NEAR,BLANK:NEAR,TAB:NEAR,STD_PRINTF:NEAR
	   EXTRN HEX:NEAR,DEFAULT:NEAR,OUTSI:NEAR,OUTDI:NEAR
	   EXTRN HEX_ADDRESS_ONLY:NEAR

UNASSEM:
	   MOV	BP,[CSSAVE]		; Default code segment
	   MOV	DI,OFFSET DG:DISADD	; Default address
	   MOV	CX,DISPB		; Default length
	   SHR	CX,1
	   SHR	CX,1
	   CALL DEFAULT
	   MOV	WORD PTR [DISADD],DX	; Displacement of disassembly
	   MOV	WORD PTR [DISADD+2],AX	; Segment
	   MOV	WORD PTR [DISCNT],CX	; No. of bytes (but whole instructions)
DISLP:
	   CALL DISASLN 		; Disassemble one line
	   CALL CRLF
	   TEST [DISCNT],-1		; See if we've used up the range
	   JNZ	DISLP
	   RET

GOTDIS:
	   PUSH DS			; RE-GET LAST BYTE
	   PUSH SI
	   LDS	SI,DWORD PTR [DISADD]
	   MOV	AL,[SI-1]
	   POP	SI
	   POP	DS
	   RET

GETDIS:
	   PUSH DS
	   LDS	SI,DWORD PTR [DISADD]
	   LODSB			; Get the next byte of code
	   POP	DS
	   MOV	WORD PTR [DISADD],SI	; Update pointer
	   PUSH AX
	   PUSH DI
	   MOV	DI,[ARG_BUF_INDEX]
	   CALL HEX			; Display each code byte
	   MOV	[ARG_BUF_INDEX],DI
	   POP	DI
	   MOV	SI,[DISCNT]
	   OR	SI,SI			; Check if range exhausted
	   JZ	ENDRNG			; If so, don't wrap around
	   DEC	SI			; Count off the bytes
	   MOV	[DISCNT],SI
ENDRNG:
	   INC	BYTE PTR[BYTCNT]	; Keep track of no. of bytes per line
	   POP	AX
	   RET

DSPRE:
	   INC	BYTE PTR [NSEG+1]
SSPRE:
	   INC	BYTE PTR [NSEG+1]
CSPRE:
	   INC	BYTE PTR [NSEG+1]
ESPRE:
	   INC	BYTE PTR [NSEG+1]

PREFIX:
	   POP	BX			; Dump off return address
	   CALL FINLN
	   CALL CRLF
DISASLN:
	   PUSH DS
	   LDS	SI,DWORD PTR [DISADD]
	   CALL OUTSI			; Show disassembly address
	   POP	DS
	   CALL HEX_ADDRESS_ONLY
DISASLN1:
	   MOV	BYTE PTR [BYTCNT],0	; Count of code bytes per line
; Fill overflow area with zeros
	   MOV	DI,OFFSET DG:OPBUF
	   MOV	CX,50
	   MOV	AL,0
	   REP	STOSB
; fill buffer with spaces
	   MOV	DI,OFFSET DG:OPBUF
	   MOV	CX,OPBUFLEN
	   MOV	AL," "
	   REP	STOSB
	   MOV	DI,OFFSET DG:ARG_BUF
	   MOV	[ARG_BUF_INDEX],DI
	   CALL GETDIS			; Get opcode
	   MOV	DI,[ARG_BUF_INDEX]
	   MOV	AH,0
	   MOV	BX,AX
	   AND	AL,1			; Mask to "W" bit
	   MOV	[AWORD],AL
	   MOV	AL,BL			; Restore opcode
	   SHL	BX,1
	   SHL	BX,1			; Multiply opcode by 4
	   ADD	BX,OFFSET DG:DISTAB
	   MOV	DX,[BX] 		; Get pointer to mnemonic from table
	   MOV	[OPCODE],DX
	   MOV	[ARG_BUF_INDEX],DI
	   MOV	DI,OFFSET DG:OPBUF
	   CALL WORD PTR [BX+2]
FINLN:
	   MOV	AH,[BYTCNT]		; See how many bytes in this instruction
	   ADD	AH,AH			; Each uses two characters
	   MOV	AL,14			; Amount of space we want to use
	   SUB	AL,AH			; See how many fill characters needed
	   CBW
	   XCHG CX,AX			; Parameter for TAB needed in CX
	   MOV	DI,[ARG_BUF_INDEX]
	   CALL TAB
	   MOV	SI,[OPCODE]
	   OR	SI,SI
	   JZ	GET_TAB
GET_OPCODE:
	   LODSB
	   OR	AL,AL
	   JZ	GET_TAB
	   STOSB
	   JMP	GET_OPCODE

GET_TAB:
	   MOV	AL,9
	   STOSB
	   MOV	BYTE PTR [DI],0 	; nul terminate address buffer
	   MOV	DX,OFFSET DG:UNASSEM_LN_PTR
	   CALL STD_PRINTF
	   RET

GETMODE:
	   CALL GETDIS			; Get the address mode byte
	   MOV	AH,AL
	   AND	AL,7			; Mask to "r/m" field
	   MOV	[REGMEM],AL
	   SHR	AH,1
	   SHR	AH,1
	   SHR	AH,1
	   MOV	AL,AH
	   AND	AL,7			; Mask to center 3-bit field
	   MOV	[MIDFLD],AL
	   SHR	AH,1
	   SHR	AH,1
	   SHR	AH,1
	   MOV	[MODE],AH		; Leaving 2-bit "MOD" field
	   RET

IMMED:
	   MOV	BX,OFFSET DG:IMMTAB
	   CALL GETMNE
FINIMM:
	   CALL TESTREG
	   JMP	SHORT IMM

MEMIMM:
	   CALL GETMODE
	   JMP	SHORT FINIMM

ACCIMM:
	   XOR	AL,AL
IMM1:
	   CALL SAVREG
IMM:
	   MOV	AL,","
	   STOSB
	   TEST BYTE PTR [AWORD],-1
	   JNZ	SAV16
SAV8:
	   CALL GETDIS
	   JMP	SHORT SAVHEX

LONGJMP:
	   PUSH DI
	   MOV	DI,OFFSET DG:TEMP
	   CALL SAV16
	   POP	DI
	   CALL SAV16
	   MOV	AL,":"
	   STOSB
	   MOV	SI,OFFSET DG:TEMP
	   MOV	CX,4
MOVDIG:
	   LODSB
	   STOSB
	   LOOP MOVDIG
	   RET

SAV16:
	   CALL GETDIS			; Get low byte
	   MOV	DL,AL
	   CALL GETDIS			; Get high byte
	   MOV	DH,AL
	   CALL SAVHEX			; Convert and store high byte
	   MOV	AL,DL
SAVHEX:
	   MOV	AH,AL
	   SHR	AL,1
	   SHR	AL,1
	   SHR	AL,1
	   SHR	AL,1
	   CALL SAVDIG
	   MOV	AL,AH
SAVDIG:
	   AND	AL,0FH
	   ADD	AL,90H
	   DAA
	   ADC	AL,40H
	   DAA
	   STOSB
	   RET

CHK10:
	   CALL GETDIS
	   CMP	AL,10
	   JNZ	SAVHEX
	   RET

SIGNIMM:
	   MOV	BX,OFFSET DG:IMMTAB
	   CALL GETMNE
	   CALL TESTREG
	   MOV	AL,","
	   STOSB
SAVD8:
	   CALL GETDIS			; Get signed 8-bit number
	   CBW
	   MOV	DX,AX			; Save true 16-bit value in DX
	   MOV	AH,AL
	   MOV	AL,"+"
	   OR	AH,AH
;	JZ	NOSIGN
	   JNS	POSITIV 		; OK if positive
	   MOV	AL,"-"
	   NEG	AH			; Get magnitude if negative
POSITIV:
	   STOSB
; NOSIGN:
	   MOV	AL,AH
	   JMP	SHORT SAVHEX

ALUFROMREG:
	   CALL GETADDR
	   MOV	AL,","
	   STOSB
REGFLD:
	   MOV	AL,[MIDFLD]
SAVREG:
	   MOV	SI,OFFSET DG:REG8
	   CMP	BYTE PTR [AWORD],1
	   JNE	FNDREG
SAVREG16:
	   MOV	SI,OFFSET DG:REG16
FNDREG:
	   CBW
	   ADD	SI,AX
	   ADD	SI,AX
	   MOVSW
	   RET

SEGOP:
	   SHR	AL,1
	   SHR	AL,1
	   SHR	AL,1
SAVSEG:
	   AND	AL,3
	   MOV	SI,OFFSET DG:SREG
	   JMP	SHORT FNDREG

REGOP:
	   AND	AL,7
	   JMP	SHORT SAVREG16

MOVSEGTO:
	   MOV	BYTE PTR [AWORD],1
	   CALL GETADDR
	   MOV	AL,","
	   STOSB
	   MOV	AL,[MIDFLD]
	   JMP	SHORT SAVSEG

MOVSEGFROM:
	   CALL GETMODE
	   CALL SAVSEG
	   MOV	BYTE PTR [AWORD],1
	   JMP	SHORT MEMOP2

GETADDR:
	   CALL GETMODE
	   JMP	SHORT ADDRMOD

WORDTOALU:
	   MOV	BYTE PTR [AWORD],1
ALUTOREG:
	   CALL GETMODE
	   CALL REGFLD
MEMOP2:
	   MOV	AL,","
	   STOSB
ADDRMOD:
	   CMP	BYTE PTR [MODE],3
	   MOV	AL,[REGMEM]
	   JE	SAVREG
	   XOR	BX,BX
	   MOV	BYTE PTR [NSEG],3
	   MOV	BYTE PTR [DI],"["
	   INC	DI
	   CMP	AL,6
	   JNE	NODRCT
	   CMP	BYTE PTR [MODE],0
	   JE	DIRECT			; Mode=0 and R/M=6 means direct addr.
NODRCT:
	   MOV	DL,AL
	   CMP	AL,1
	   JBE	USEBX
	   CMP	AL,7
	   JE	USEBX
	   CMP	AL,3
	   JBE	USEBP
	   CMP	AL,6
	   JNE	CHKPLS
USEBP:
	   MOV	BX,[BPSAVE]
	   MOV	BYTE PTR [NSEG],2	; Change default to Stack Segment
	   MOV	AX,BPREG
SAVBASE:
	   STOSW
CHKPLS:
	   CMP	DL,4
	   JAE	NOPLUS
	   MOV	AL,"+"
	   STOSB
NOPLUS:
	   CMP	DL,6
	   JAE	DOMODE			; No index register
	   AND	DL,1			; Even for SI, odd for DI
	   JZ	USESI
	   ADD	BX,[DISAVE]
	   MOV	AX,DIREG
SAVINDX:
	   STOSW
DOMODE:
	   MOV	AL,[MODE]
	   OR	AL,AL
	   JZ	CLOSADD 		; If no displacement, then done
	   CMP	AL,2
	   JZ	ADDDIR
	   CALL SAVD8			; Signed 8-bit displacement
ADDCLOS:
	   ADD	BX,DX
CLOSADD:
	   MOV	AL,"]"
	   STOSB
	   MOV	[INDEX],BX
NOOPERANDS:
	   RET

ADDDIR:
	   MOV	AL,"+"
	   STOSB
DIRECT:
	   CALL SAV16
	   JMP	SHORT ADDCLOS

USEBX:
	   MOV	BX,[BXSAVE]
	   MOV	AX,BXREG
	   JMP	SHORT SAVBASE

USESI:
	   ADD	BX,[SISAVE]
	   MOV	AX,SIREG
	   JMP	SHORT SAVINDX

SHORTJMP:
	   CALL GETDIS
	   CBW
	   ADD	AX,WORD PTR [DISADD]
	   XCHG DX,AX
SAVJMP:
	   MOV	AL,DH
	   CALL SAVHEX
	   MOV	AL,DL
	   JMP	SAVHEX

JMPCALL:
	   CALL GETDIS
	   MOV	DL,AL
	   CALL GETDIS
	   MOV	DH,AL
	   ADD	DX,WORD PTR [DISADD]
	   JMP	SHORT SAVJMP

XCHGAX:
	   AND	AL,7
	   CALL SAVREG16
	   MOV	AL,","
	   STOSB
	   XOR	AL,AL
	   JMP	SAVREG16

LOADACC:
	   XOR	AL,AL
	   CALL SAVREG
	   MOV	AL,","
	   STOSB
MEMDIR:
	   MOV	AL,"["
	   STOSB
	   XOR	BX,BX
	   MOV	BYTE PTR [NSEG],3
	   JMP	DIRECT

STOREACC:
	   CALL MEMDIR
	   MOV	AL,","
	   STOSB
	   XOR	AL,AL
	   JMP	SAVREG

REGIMMB:
	   MOV	BYTE PTR [AWORD],0
	   JMP	SHORT REGIMM

REGIMMW:
	   MOV	BYTE PTR [AWORD],1
REGIMM:
	   AND	AL,7
	   JMP	IMM1

INT3:
	   MOV	BYTE PTR [DI],"3"
	   INC	DI
	   RET

;  8087 instructions whose first byte is 0dfh
M8087_DF:
	   CALL GET64F
	   JZ	ISDD3
	   MOV	SI,OFFSET DG:MDF_TAB
	   JMP	short NODB3

;  8087 instructions whose first byte is 0ddh
M8087_DD:
	   CALL GET64F
	   JZ	ISDD3
	   MOV	SI,OFFSET DG:MDD_TAB
	   JMP	short NOD93

ISDD3:
	   MOV	AL,DL
	   TEST AL,100B
	   JZ	ISSTI
	   JMP	ESC0

ISSTI:
	   AND	AL,11B
	   MOV	SI,OFFSET DG:MDD_TAB2
	   MOV	CL,AL
	   CALL MOVBYT
	   JMP	short PUTRST

;  8087 instructions whose first byte is 0dbh
M8087_DB:
	   CALL GET64F
	   JZ	ISDB3
	   MOV	SI,OFFSET DG:MDB_TAB
NODB3:
	   CALL PUTOP
	   CALL PUTSIZE
	   JMP	ADDRMOD

ISDB3:
	   MOV	AL,DL
	   TEST AL,100B
	   JNZ	ISDBIG
ESC0V:
	   JMP	ESC0

ISDBIG:
	   CALL GOTDIS
	   AND	AL,11111B
	   CMP	AL,4
	   JAE	ESC0V
	   MOV	SI,OFFSET DG:MDB_TAB2
	   JMP	short DOBIG

;  8087 instructions whose first byte is 0d9h
M8087_D9:
	   CALL GET64F
	   JZ	ISD93

	   MOV	SI,OFFSET DG:MD9_TAB
NOD93:
	   CALL PUTOP
	   AND	AL,111B
	   CMP	AL,3
	   JA	NOSHO
	   MOV	AL,DL
	   CALL PUTSIZE
NOSHO:
	   JMP	ADDRMOD

ISD93:
	   MOV	AL,DL
	   TEST AL,100B
	   JNZ	ISD9BIG
	   AND	AL,111B
	   OR	AL,AL
	   JNZ	NOTFLD
	   MOV	AX,"DL"
	   STOSW
	   JMP	SHORT PUTRST

NOTFLD:
	   CMP	AL,1
	   JNZ	NOTFXCH
	   MOV	AX,"CX"
	   STOSW
	   MOV	AL,"H"
	   JMP	SHORT PUTRST1

NOTFXCH:
	   CMP	AL,3
	   JNZ	NOTFSTP
	   MOV	AX,"TS"
	   STOSW
	   MOV	AL,"P"
PUTRST1:
	   STOSB
PUTRST:
	   MOV	AL,9
	   STOSB
	   JMP	short PUTST0

NOTFSTP:
	   CALL GOTDIS
	   CMP	AL,11010000B		; CHECK FOR FNOP
	   JZ	GOTFNOP
	   JMP	ESC0

GOTFNOP:
	   MOV	AX,"ON"
	   STOSW
	   MOV	AL,"P"
	   STOSB
	   RET

ISD9BIG:
	   CALL GOTDIS			; GET THE MODE BYTE
	   MOV	SI,OFFSET DG:MD9_TAB2
DOBIG:
	   AND	AL,11111B
	   MOV	CL,AL
	   JMP	MOVBYT

; entry point for the remaining 8087 instructions
M8087:
	   CALL GET64
	   CALL PUTFI			; PUT FIRST PART OF OPCODE
	   MOV	AL,DL
	   CMP	BYTE PTR [MODE],11B	; CHECK FOR REGISTER MODE
	   JZ	MODEIS3
	   CALL PUTMN			; PUT MIDDLE PART OF OPCODE
NO3:
	   MOV	AL,9			; OUTPUT A TAB
	   STOSB
	   MOV	AL,DL
	   CALL PUTSIZE 		; OUTPUT THE OPERAND SIZE
	   JMP	ADDRMOD

MODEIS3:
	   TEST AL,100000B		; D BIT SET?
	   JZ	MPUT			; NOPE...
	   TEST AL,000100B		; FDIV OR FSUB?
	   JZ	MPUT			; NOPE...
	   XOR	AL,1			; REVERSE SENSE OF R
	   MOV	DL,AL			; SAVE CHANGE
MPUT:
	   CALL PUTMN			; PUT MIDDLE PART OF OPCODE
	   MOV	AL,DL
	   TEST AL,010000B
	   JZ	NOPSH
	   MOV	AL,"P"
	   STOSB
NOPSH:
	   MOV	AL,9
	   STOSB
	   MOV	AL,DL
	   AND	AL,00000111B
	   CMP	AL,2			; FCOM
	   JZ	PUTST0
	   CMP	AL,3			; FCOMP
	   JZ	PUTST0
	   MOV	AL,DL
	   TEST AL,100000B
	   JZ	PUTSTST0

; output 8087 registers in the form st(n),st
PUTST0ST:
	   CALL PUTST0
	   MOV	AL,','
ISCOMP:
	   STOSB

PUTST:
	   MOV	AX,"TS"
	   STOSW
	   RET

; output 8087 registers in the form st,st(n)
PUTSTST0:
	   CALL PUTST
	   MOV	AL,','
	   STOSB

PUTST0:
	   CALL PUTST
	   MOV	AL,"("
	   STOSB
	   MOV	AL,[REGMEM]
	   ADD	AL,"0"
	   STOSB
	   MOV	AL,")"
	   STOSB
	   RET

; output an 8087 mnemonic
PUTMN:
	   MOV	SI,OFFSET DG:M8087_TAB
	   MOV	CL,AL
	   AND	CL,00000111B
	   JMP	SHORT MOVBYT

; output either 'FI' or 'F' for first byte of opcode
PUTFI:
	   MOV	SI,OFFSET DG:FI_TAB
	   JMP	SHORT PUTFI2

; output size (dword, tbyte, etc.)
PUTSIZE:
	   MOV	SI,OFFSET DG:SIZE_TAB
PUTFI2:
	   CMP	BYTE PTR [MODE],11B	; check if 8087 register
	   JNZ	PUTFI3
	   AND	AL,111000B		; LOOK FOR INVALID FORM OF 0DAH OPERANDS
	   CMP	AL,010000B
	JZ	ESC0PJ
	   MOV	AL,DL
	   CMP	AL,110011B		; FCOMPP
	   JNZ	GOFI
	   CMP	BYTE PTR [REGMEM],1
	JZ	GOFI
ESC0PJ:
	jmp	short ESC0P		; we could've reached without a
;					; double branch here, but we needed
;					; a bridge for ESC0PJ
GOFI:
	   XOR	CL,CL
	   JMP	SHORT MOVBYT

;  Look for qword
PUTFI3:
	   CMP	AL,111101B
	   JZ	GOTQU
	   CMP	AL,111111B
	   JNZ	NOTQU
GOTQU:
	   MOV	CL,2
	   JMP	SHORT MOVBYT

;  look for tbyte
NOTQU:
	   CMP	AL,011101B
	   JZ	GOTTB
	   CMP	AL,111100B
	   JZ	GOTTB
	   CMP	AL,111110B
	   JZ	GOTTB
	   CMP	AL,011111B
	   JNZ	NOTTB
GOTTB:
	   MOV	CL,5
	   JMP	SHORT MOVBYT

NOTTB:
	   MOV	CL,4
	   SHR	AL,CL
	   MOV	CL,AL
; SI POINTS TO A TABLE OF TEXT SEPARATED BY "$"
; CL = WHICH ELEMENT IN THE TABLE YOU WISH TO COPY TO [DI]
MOVBYT:
	   PUSH AX
	   INC	CL
MOVBYT1:
	   DEC	CL
	   JZ	MOVBYT3
MOVBYT2:
	   LODSB
	   CMP	AL,"$"
	   JZ	MOVBYT1
	   JMP	MOVBYT2

MOVBYT3:
	   LODSB
	   CMP	AL,'$'
	   JZ	MOVBYT5
	   CMP	AL,'@'                  ; THIS MEANS RESVERED OP-CODE
	   JNZ	MOVBYT4
	   POP	AX
	   JMP	SHORT ESC0P		; GO DO AN ESCAPE COMMAND

MOVBYT4:
	   STOSB
	   JMP	MOVBYT3

MOVBYT5:
	   POP	AX
	   RET

PUTOP:
	   AND	AL,111B
	   MOV	CL,AL
	   CALL MOVBYT
	   MOV	AL,9
	   STOSB
	   MOV	AL,DL
	   RET

GET64F:
	   CALL GET64
	   MOV	AL,"F"
	   STOSB
	   CMP	BYTE PTR [MODE],3
	   MOV	AL,DL
	   RET

GET64:
	   AND	AL,7
	   MOV	DL,AL
	   CALL GETMODE
	   SHL	DL,1
	   SHL	DL,1
	   SHL	DL,1
	   OR	AL,DL
	   MOV	DL,AL			; SAVE RESULT
	   RET

ESC0P:
	   POP	DI			; CLEAN UP STACK
ESC0:
	   MOV	WORD PTR [OPCODE],OFFSET DG:ESCMN
	   MOV	AL,DL
	   MOV	DI,OFFSET DG:OPBUF
	   JMP	SHORT ESC1

ESCP:
	   CALL GET64
ESC1:
	   CALL SAVHEX
	   CMP	BYTE PTR [MODE],3
	   JZ	SHRTESC
	   MOV	BYTE PTR  [AWORD],1
	   JMP	MEMOP2

SHRTESC:
	   MOV	AL,","
	   STOSB
	   MOV	AL,[REGMEM]
	   AND	AL,7
	   JMP	SAVREG

INVARW:
	   CALL PUTAX
	   JMP	SHORT INVAR

INVARB:
	   CALL PUTAL
INVAR:
	   MOV	AL,','
	   STOSB
	   JMP	short PUTDX

INFIXW:
	   CALL PUTAX
	   JMP	SHORT INFIX

INFIXB:
	   CALL PUTAL
INFIX:
	   MOV	AL,','
	   STOSB
	   JMP	SAV8

	   STOSW			;IS THIS DEAD CODE? EMK
	   RET

OUTVARB:
	   MOV	BX,"LA"
	   JMP	SHORT OUTVAR

OUTVARW:
	   MOV	BX,"XA"
OUTVAR:
	   CALL PUTDX
OUTFV:
	   MOV	AL,','
	   STOSB
	   MOV	AX,BX
	   STOSW
	   RET

OUTFIXB:
	   MOV	BX,"LA"
	   JMP	SHORT OUTFIX

OUTFIXW:
	   MOV	BX,"XA"
OUTFIX:
	   CALL SAV8
	   JMP	OUTFV

PUTAL:
	   MOV	AX,"A"+4C00H            ; "AL"
	   JMP	SHORT PUTX

PUTAX:
	   MOV	AX,"A"+5800H            ; "AX"
	   JMP	SHORT PUTX

PUTDX:
	   MOV	AX,"D"+5800H            ; "DX"
PUTX:
	   STOSW
	   RET

SHFT:
	   MOV	BX,OFFSET DG:SHFTAB
	   CALL GETMNE
TESTREG:
	   CMP	BYTE PTR [MODE],3
	   JZ	NOFLG
	   MOV	SI,OFFSET DG:SIZE_TAB
	   MOV	CL,3
	   TEST BYTE PTR [AWORD],-1
	   JNZ	TEST_1
	   INC	CL
TEST_1:
	   CALL MOVBYT
NOFLG:
	   JMP	ADDRMOD

SHIFTV:
	   CALL SHFT
	   MOV	AL,","
	   STOSB
	   MOV	WORD PTR [DI],"C"+4C00H ; "CL"
	   ADD	DI,2
	   RET

SHIFT:
	   CALL SHFT
	   MOV	AX,"1,"
	   STOSW
	   RET

GETMNE:
	   CALL GETMODE
	   MOV	DL,AL
	   CBW
	   SHL	AX,1
	   ADD	BX,AX
	   MOV	AX,[BX]
	   MOV	[OPCODE],AX
	   MOV	AL,DL
	   RET

GRP1:
	   MOV	BX,OFFSET DG:GRP1TAB
	   CALL GETMNE
	   OR	AL,AL
	   JZ	FINIMMJ
	   JMP	TESTREG
FINIMMJ:
	   JMP	FINIMM

GRP2:
	   MOV	BX,OFFSET DG:GRP2TAB
	   CALL GETMNE
	   CMP	AL,2
	   JB	TESTREG
	   CMP	AL,6
	   JAE	INDIRECT
	   TEST AL,1
	   JZ	INDIRECT
	   MOV	AX,"AF"                 ; "FAR"
	   STOSW
	   MOV	AX," R"
	   STOSW
INDIRECT:
	   JMP	ADDRMOD

CODE	   ENDS
	   END	UNASSEM

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\debug.asm ===
PAGE	60,132			;
	TITLE	DEBUG.ASM - DEBUGger for MS-DOS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DEBUG.ASM
;
; DESCRIPTIVE NAME: DEBUGGING TOOL
;
; FUNCTION: PROVIDES USERS WITH A TOOL FOR DEBUGGING PROGRAMS.
;
; ENTRY POINT: START
;
; INPUT: DOS COMMAND LINE
;	 DEBUG COMMANDS
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: DEBCOM1 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM2 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM3 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBASM  - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBUASM - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBMES  - CONTAINS MESSAGE RETRIEVER ROUTINES
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT DBCS HANDLING	bgb:5/03/88	;an001;bgb
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- > 32 MB SUPPORT		DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;	MICROSOFT REVISION HISTORY:
;
; Modified 5/4/82 by AaronR to do all I/O direct to devices
; Runs on MS-DOS 1.28 and above
;
; REV 1.20
;	Tab expansion
;	New device interface (1.29 and above)
; REV 2.0
;	line by line assembler added by C. P.
; REV 2.1
;	Uses EXEC system call
; REV 2.2
;	Ztrace mode by zibo.
;	Fix dump display to indent properly
;	Parity nonsense by zibo
;
; REV 2.3 NP
;	Use Printf for all standard output.
;	Change to EXE file
; REV 2.4 ARR
;	Bug fixes. TEST, XCHG instructions reg order reversed.
;	Single step, break point interrupts saved and restored.
;	Access denied given on W to read only file.
;======================= END OF SPECIFICATIONS ===========================
;   Change Log:
;
;     Date    Who   #			Description
;   --------  ---  ---	------------------------------------------------------
;   04/01/90  DIC  C01	This information on the drive containing the file is
;			used within DEBCOM2.ASM for determining if enough
;			memory is available to write a file out to disk.
;			(Compaq STR #1889) (MS Bug #774)
;
;   09/xx/90   CAS	Fixed divide overflow problem when trying to
;			write ridiculously large files
;
;   10/18/90   CAS      Changed "POP CS" to DB 0F
;			Added code to override 8086/8088 Trace PIC mask
;			stuff on later CPUs to avoid crashing after
;			tracing through divide overflows.
;			Eliminated most Long Branch warnings
;
;=============================================================================

.XLIST
.XCREF
	include version.inc		; cas -- missing equates
	include syscall.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC		; ALSO VERSION NUMBER
.CREF
.LIST
        INCLUDE debug.inc
	IF	SYSVER
; Structure for system call 72
SYSINITVAR  STRUC
DPBHEAD     DD	    ?			; Pointer to head of DPB-FAT list
SFT_ADDR    DD	    ?			; Pointer to first FCB table
; The following address points to the CLOCK device
BCLOCK	    DD	    ?
; The following address is used by DISKSTATCHK it is always
; points to the console input device header
BCON	    DD	    ?			; Console device entry points
MAXSEC	    DW	    0			; Maximum allowed sector size
BUFFHEAD    DD	    ?
CDS	    DD	    ?
SFTFCB	    DD	    ?
KEEP	    DW	    ?
NUMIO	    DB	    0			; Number of disk tables
NCDS	    DB	    ?
DEVHEAD     DD	    ?
SYSINITVAR  ENDS

	ENDIF


;======================= macro equates ===================================

dbcs_delim equ	81h			;an000;delimits dbcs char
asian_blk equ	40h			;an000;asian blank
amer_blk equ	20h			;an000;american blank
quote_char equ	22h			;an000;quote delim "

;======================= end macro equates ===============================


;This segment must be the first loaded since we are using it to make
;a CREATE_PROCESS_DATA_BLOCK system call a la 1.0 and .COM files.
;For this system call CS must point to the Program Prefix Header, so
;by setting up a seperate segment just after the header we can issue
;an INT 21H via a long call.  So don't move this guy around!

A_CREATE_BLOCK SEGMENT

	PUBLIC	CREATE_CALL

;The other arguements to this system call have been set up
;by the caller.

CREATE_CALL PROC FAR
	MOV	AH,CREATE_PROCESS_DATA_BLOCK
	INT	21H
	RET

CREATE_CALL ENDP

A_CREATE_BLOCK ENDS


CODE	SEGMENT PUBLIC
CODE	ENDS

CONST	SEGMENT PUBLIC
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CONST	SEGMENT PUBLIC BYTE
	EXTRN	BADVER:BYTE,ENDMES_PTR:BYTE,CRLF_PTR:BYTE
	IF	IBMJAPAN
	    EXTRN   PARITYMES_PTR:BYTE
	ENDIF
	EXTRN	PROMPT_PTR:BYTE,ADD_PTR:BYTE,HEX_PTR:BYTE
	EXTRN	USER_PROC_PDB:WORD,CSSAVE:WORD,DSSAVE:WORD
	EXTRN	SPSAVE:WORD,IPSAVE:WORD,LINEBUF:BYTE,QFLAG:BYTE
	EXTRN	NEWEXEC:BYTE,HEADSAVE:WORD,LBUFSIZ:BYTE,BACMES_PTR:WORD
	EXTRN	QMES_1:BYTE
	EXTRN	QMES_2:BYTE
	EXTRN	QMES_3:BYTE
	EXTRN	QMES_4:BYTE
	EXTRN	QMES_5:BYTE
	EXTRN	HELP_TEXT1:BYTE
	EXTRN	HELP_TEXT2:BYTE
	EXTRN	HELP_TEXT3:BYTE
	EXTRN	HELP_TEXT4:BYTE
	EXTRN	HELP_TEXT5:BYTE
	EXTRN	HELP_TEXT6:BYTE

	IF	IBMVER
	    EXTRN   DSIZ:BYTE,NOREGL:BYTE,DISPB:WORD
	ENDIF

	IF	SYSVER
	    EXTRN   CONFCB:BYTE,POUT:DWORD,COUT:DWORD,CIN:DWORD,IOBUFF:BYTE
	    EXTRN   IOADDR:DWORD,IOCALL:BYTE,IOCOM:BYTE,IOSTAT:WORD,IOCNT:WORD
	    EXTRN   IOSEG:WORD,COLPOS:BYTE,BADDEV_PTR:BYTE,BADLSTMES_PTR:BYTE
	    EXTRN   LBUFFCNT:BYTE,PFLAG:BYTE
	ENDIF

	EXTRN	NAMESPEC:BYTE
	EXTRN	DriveOfFile:WORD       ; save default drive of file   ;C01

CONST	ENDS

CSTACK	SEGMENT STACK
	DB	(362 - 80H) + 80H DUP(?) ; (362 - 80H) == IBM'S ROM REQUIREMENTS
					; (NEW - OLD) == SIZE TO GROW STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	ARG_BUF:BYTE,ADD_ARG:WORD,SUB_ARG:WORD,HEX_ARG1:WORD
	EXTRN	HEX_ARG2:WORD,STACK:BYTE, PREV24:DWORD, FIN24:BYTE
	EXTRN	PARSERR:BYTE,DATAEND:WORD,PARITYFLAG:BYTE,DISADD:BYTE
	EXTRN	ASMADD:BYTE,DEFDUMP:BYTE,BYTEBUF:BYTE,BEGSEG:WORD
	EXTRN	BPINTSAV:DWORD,SSINTSAV:DWORD ;ARR 2.4
	EXTRN	CREATE_LONG:DWORD

	extrn	lbtbl:dword		;an000;lead byte table pointer

DATA	ENDS

	EXTRN	PRINTF:NEAR		;ac000;changed to NEAR call

CODE	SEGMENT PUBLIC
	ASSUME	CS:DG,DS:NOTHING,ES:NOTHING,SS:CSTACK

	PUBLIC	RESTART
	PUBLIC	STD_PRINTF,PRINTF_CRLF
	PUBLIC	HEX_ADDRESS_ONLY,HEX_ADDRESS_STR
	PUBLIC	RESTART,SET_TERMINATE_VECTOR,DABORT,TERMINATE,COMMAND
	PUBLIC	FIND_DEBUG,CRLF,BLANK,TAB,INBUF,SCANB,SCANP
	PUBLIC	HEX,OUTSI,OUTDI,DIGIT,BACKUP,RBUFIN
	public	test_lead							;an001;bgb
	public	test1								;an001;bgb

	IF	SYSVER
;	    PUBLIC  SETUDEV,DEVIOCALL				; kwc 12/10/86
	    PUBLIC  SETUDEV		; kwc 12/10/86
	    EXTRN   DISPREG:NEAR,INPT:NEAR
	ENDIF

	EXTRN	PERR:NEAR,COMPARE:NEAR,DUMP:NEAR,ENTERDATA:NEAR,FILL:NEAR
	EXTRN	GO:NEAR,INPUT:NEAR,LOAD:NEAR,MOVE:NEAR,NAMED:NEAR
	EXTRN	REG:NEAR,SEARCH:NEAR,DWRITE:NEAR,UNASSEM:NEAR,ASSEM:NEAR
	EXTRN	OUTPUT:NEAR,ZTRACE:NEAR,TRACE:NEAR,GETHEX:NEAR,GETEOL:NEAR
	EXTRN	PREPNAME:NEAR,DEFIO:NEAR,SKIP_FILE:NEAR,DEBUG_FOUND:NEAR
	EXTRN	TRAPPARITY:NEAR,RELEASEPARITY:NEAR
	extrn	pre_load_message:near	;an000;load messages
	extrn	debems:near		;an000;ems support
ifdef JAPAN
	extrn	SETDUMPMODE:near
endif


	DB	100H DUP (?)

START:
	JMP	SHORT DSTRT

HEADER	DB	"Vers 2.40"

DSTRT:
;=========================================================================
; invoke PRE_LOAD_MESSAGE here.  If the messages were not loaded we will
; exit with an appropriate error message.
;
;	Date	   : 6/14/87
;=========================================================================

	push	ds			;an000;save regs
	push	es			;an000;save resg

	push	cs			;an000;transfer cs
	pop	ds			;an000;    to ds

	push	cs			;an000;transfer cs
	pop	es			;an000;    to es
	assume	ds:dg,es:dg		;an000;assume them
	call	PRE_LOAD_MESSAGE	;an000;invoke SYSLOADMSG
;	$if	c			;an000;if the load was unsuccessful
	JNC $$IF1
	    mov     ax,(exit shl 8)	;an000;exit EDLIN.  PRE_LOAD_MESSAGE
					;      has already said why
	    int     21h 		;an000;exit
;	$endif				;an000;
$$IF1:

	pop	es			;an000;restore regs.
	pop	ds			;an000;
	assume	ds:nothing,es:nothing	;an000;back to original

	MOV	AX,(GET_INTERRUPT_VECTOR SHL 8) OR VEC_BREAKPOINT ;get original contents
	INT	21H			;  of the BREAKPOINT vector

	MOV	WORD PTR [BPINTSAV],BX	;  and save that vector for later
	MOV	WORD PTR [BPINTSAV+WORD],ES ; restoration

	MOV	AX,(GET_INTERRUPT_VECTOR SHL 8) OR VEC_SING_STEP ;get original contents
	INT	21H			;  of the SINGLE STEP vector

	MOV	WORD PTR [SSINTSAV],BX	;  and save that vector for later
	MOV	WORD PTR [SSINTSAV+WORD],ES ; restoration

	MOV	BEGSEG,DS		; save beginning DS
	PUSH	CS			; repair damaged ES to be
	POP	ES			;  back to just like CS
	XOR	SI,SI			; set source and destination
	XOR	DI,DI			;  indices both to zero
	MOV	CX,256			; set count to size of PSP
	REP	MOVSB			; move to es:[di] from ds:[si]
	PUSH	CS			; set up DS to be just like CS
	POP	DS			;  to match .COM rules of addressability
	ASSUME	DS:DG,ES:DG		; like CS, also have DS and DS as bases

	if	IBMVER

;	on IBM compatibles, we need to know whether we have a pre-286, so
;	  we can invoke special PIC mask code during tracing.

	extrn	cpu_not_8088:byte
	pushf				; save flags
	pushf				; copy to ax
	pop	ax
	and	ax,0fffh		; try to reset first 4 to zero
	push	ax
	popf
	pushf				; write it to flags and get it back
	pop	ax			; and back into ax
	cmp	ah,0f0h			; if all 4 are ones, then 8088/8086
;					;  otherwise, set carry (later cpu)
	sbb	al,al			; propagate carry across al
	mov	cpu_not_8088,al		; and save it for future reference
	popf				; restore flags
	endif

	CALL	TRAPPARITY		; scarf up those parity guys
	MOV	AH,GET_CURRENT_PDB	;(undocumented function call - 51h)
	INT	21H

	MOV	[USER_PROC_PDB],BX	; Initially set to DEBUG

	IF	SYSVER
	    MOV     [IOSEG],CS
	ENDIF

	MOV	[PARSERR],0


	IF	SYSVER
	    MOV     AH,GET_IN_VARS	;(undocumented function call - 52h)
	    INT     21H

	    LDS     SI,ES:[BX.BCON]	; get system console device
	    ASSUME  DS:NOTHING

	    MOV     WORD PTR CS:[CIN+WORD],DS ;save vector to console input device
	    MOV     WORD PTR CS:[CIN],SI
	    MOV     WORD PTR CS:[COUT+WORD],DS ;save vector to console output device
	    MOV     WORD PTR CS:[COUT],SI
	    PUSH    CS			; restore DS to be
	    POP     DS			;  just like CS, as before
	    ASSUME  DS:DG

	    MOV     DX,OFFSET DG:CONFCB ; get system printer device
	    MOV     AH,FCB_OPEN 	; open system printer "PRN"
	    INT     21H

	    OR	    AL,AL		; open ok?
	    JZ	    GOTLIST		; yes, it was there

	    MOV     DX,OFFSET DG:BADLSTMES_ptr ; no list file found...
	    CALL    STD_PRINTF		; tell user

	    CALL    RBUFIN		; ask for a new one

	    CALL    CRLF

	    MOV     CL,[LBUFFCNT]
	    OR	    CL,CL
	    JZ	    NOLIST1		; User didn't specify one

	    XOR     CH,CH
	    MOV     DI,OFFSET DG:(CONFCB + BYTE)
	    MOV     SI,OFFSET DG:LINEBUF ; get one from input line
	    REP     MOVSB
	    MOV     DX,OFFSET DG:CONFCB
	    MOV     AH,FCB_OPEN 	; try to open it
	    INT     21H

	    OR	    AL,AL
	    JZ	    GOTLIST		; yep, use it...

	    MOV     DX,OFFSET DG:BADDEV_Ptr ; complain again
	    CALL    STD_PRINTF
NOLIST1:				; kwc 12/10/86
	    MOV     WORD PTR [POUT+WORD],CS ; use null device for printer
	    MOV     WORD PTR [POUT],OFFSET DG:LONGRET
	    JMP     NOLIST

XXX	    PROC    FAR
LONGRET:
	    RET
XXX	    ENDP
	ENDIF

GOTLIST:
;DX = OFFSET OF 'CONFCB', WHICH HAS JUST BEEN OPENED OK
	IF	SYSVER
	    MOV     SI,DX
;	    LDS     SI,DWORD PTR DS:[SI.FCB_FIRCLUS]		; KWC 12/10/86
	    LDS     SI,DWORD PTR DS:[SI.FCB_NSLD_DRVPTR] ; KWC 12/10/86
	    ASSUME  DS:NOTHING

	    MOV     WORD PTR CS:[POUT+WORD],DS
	    MOV     WORD PTR CS:[POUT],SI
	ENDIF
NOLIST:
	MOV	AX,CS			;restore the DS and ES segregs
	MOV	DS,AX			; to become once again just like CS
	MOV	ES,AX
	ASSUME	DS:DG,ES:DG

; Code to print header
;	MOV	DX,OFFSET DG:HEADER_PTR
;	CALL	STD_PRINTF

	CALL	SET_TERMINATE_VECTOR

; Save the current INT 24 vector.  We will need this to link to the previous
; handler for handling of int 24 output.
	PUSH	ES			; save it, about to clobber it...
	MOV	AX,(GET_INTERRUPT_VECTOR SHL 8) + VEC_CRIT_ERR ; get original contents
	INT	21H			; of the int 24h vector

	MOV	WORD PTR PREV24,BX	; remember what int 24h used to
	MOV	WORD PTR PREV24+WORD,ES ;  point to
	POP	ES			; restore ES to be like CS and DS

	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) + VEC_CRIT_ERR ; change int 24h to
	MOV	DX,OFFSET DG:MY24	; point to my own int 24h handler
	INT	21H

	IF	SETCNTC
	    MOV     AL,VEC_CTRL_BREAK	; Set vector 23H
	    MOV     DX,OFFSET DG:DABORT
	    INT     21H
	ENDIF

	MOV	DX,CS			;get para of where this pgm starts
	MOV	AX,OFFSET DG:DATAEND+15 ;get offset of end of this program
	MOV	CL,4			; (plus 15 padding for rounding)
	SHR	AX,CL			; adjusted to number of paragraphs
	ADD	DX,AX			;get para of where this pgm ends
	MOV	AX,CS
	SUB	AX,BEGSEG		; add in size of printf
	ADD	DX,AX			; create program segment here
	CALL	[CREATE_LONG]		; and call special routine

	MOV	AX,DX
; Initialize the segments
	MOV	DI,OFFSET DG:DSSAVE
	CLD
	STOSW
	STOSW
	STOSW
	STOSW
	MOV	WORD PTR [DISADD+WORD],AX
	MOV	WORD PTR [ASMADD+WORD],AX
	MOV	WORD PTR [DEFDUMP+WORD],AX

	MOV	AX,100H
	MOV	WORD PTR[DISADD],AX
	MOV	WORD PTR[ASMADD],AX
	MOV	WORD PTR [DEFDUMP],AX

	MOV	DS,DX
	MOV	ES,DX
	ASSUME	DS:NOTHING,ES:NOTHING

	MOV	DX,80H
	MOV	AH,SET_DMA
	INT	21H			; Set default DMA address to 80H
; Set up initial stack.  We already have a 'good' stack set up already.  DS:6
; has the number of bytes remaining in the segment.  We should take this
; value, add 100h and use it as the Stack pointer.
	MOV	AX,WORD PTR DS:[6]	; get bytes remaining
	MOV	BX,AX
	ADD	AX,100h

;	MOV	BX,AX
;	CMP	AX,0FFF0H
;	PUSH	CS
;	POP	DS
;	JAE	SAVSTK
;	MOV	AX,WORD PTR DS:[6]
;	PUSH	BX
;	MOV	BX,OFFSET DG:DATAEND + 15
;	AND	BX,0FFF0H		; Size of DEBUG in bytes (rounded up to PARA)
;	SUB	AX,BX
;	POP	BX
;SAVSTK:
	PUSH	CS
	POP	DS
	ASSUME	DS:DG
	PUSH	BX			; bx is no. bytes remaining from PSP+6
	DEC	AX			; ax was no. bytes remaining +100h
	DEC	AX			; back up one word from end of new stack
	MOV	BX,AX			; set base to point to last word in new stack
	MOV	WORD PTR ES:[BX],0	; set final word in new stack to zero
	POP	BX			; back to beginning of new stack area
	MOV	SPSAVE,AX		; remember where new stack is
	DEC	AH
	MOV	ES:WORD PTR [6],AX	; change PSP to show usage of
	SUB	BX,AX			; new stack area
	MOV	CL,4
	SHR	BX,CL
	ADD	ES:WORD PTR [8],BX

	IF	IBMVER
; Get screen size and initialize display related variables
	    MOV     AH,15		;function = "request current video state"
	    INT     10H 		;set al=screen mode
					;    ah=no. char cols on screen
					;    bh=current active display page
	    CMP     AH,40		;is screen in 40 col mode?
	    JNZ     PARSCHK		; no, skip
					; yes, 40 col, continue
					;next fields defined in 'debconst.asm'
	    MOV     BYTE PTR DSIZ,7	; originally assembled as 0fh
	    MOV     BYTE PTR NOREGL,4	; originally assembled as 8
	    MOV     DISPB,64		; originally assembled as 128
	ENDIF

PARSCHK:


	call	DEBUG_LEAD_BYTE 	;an000;build the dbcs env. table
					;      of valid dbcs lead bytes

;=========================================================================
; prep_command_line requires the use of ds:si.	ds is left intact for
; the call.  si is initialized to point to the command line input buffer.
; ds and si are saved since we stomp all over them in prep_command_line.
;=========================================================================

	push	si			;an000;save si

	mov	si,81h			;an000;point to command line
	call	prep_command_line	;an000;invoke command line conversion

	pop	si			;an000;restore si

;=========================================================================
; we have prepped the command line for dbcs.  we can now enter the old
; routines.
;=========================================================================

; Copy rest of command line to test program's parameter area
	MOV	DI,FCB			;es[di]=to be filled with unopened FCB
	MOV	SI,80H			;ds[si]=command line to parse

; see if /? is the first argument in the command tail
NCHAR:	INC	SI
	CMP	BYTE PTR [SI], CHAR_BLANK
	JE	NCHAR
	CMP	BYTE PTR [SI], FOR_SLASH    ; are we looking at an '/' 
	JNE	NOQST                       ; if not, get out
	CMP	BYTE PTR [SI+1], Q_MARK     ;   else is the next char a '?' 
	JNE	NOQST                   

;print out /? help text
	MOV	DX, OFFSET DG:QMES_1
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:QMES_2
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:QMES_3
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:QMES_4
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:QMES_5
	CALL	STD_PRINTF
	JMP	QUITING

NOQST:  MOV	SI, 81H                 ; restore SI to what it should be
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR SET_DRIVEID_OPTION
					;func=29H, option al=1, which
					; says, drive id byte in fcb is set
					; only if drive specified in command
					; line being parsed.
	INT	21H			;parse filename from command to fcb
					; ds:si=points to first char AFTER parsed filename
					; es:di=points to first byte of formatted FCB

	mov	di,FCB			; get addr of FCB1	     ;C01
	mov	bx,[di] 		; get default drive of file  ;C01
	xor	bh,bh			; zero out high byte	     ;C01
	mov	DriveOfFile,bx		; save drive letter	     ;C01

	CALL	SKIP_FILE		; Make sure si points to delimiter
test1:					;for testing only - u can remove this
	CALL	PREPNAME

	PUSH	CS			;restore ES to point to the
	POP	ES			;  common group
FILECHK:
	MOV	DI,80H			;point to byte in PSP defining parm length
	CMP	BYTE PTR ES:[DI],0	; ANY STUFF FOUND?
	JZ	COMMAND 		; no parms, skip
					; yes parms, continue
FILOOP:
	INC	DI			;set index to first/next char in parm text
	CMP	BYTE PTR ES:[DI],CR	; carriage return? (at end of parms)
	JZ	COMMAND 		; yes, at end of parms
					; no, not at end of parms yet, continue
	CMP	BYTE PTR ES:[DI],CHAR_BLANK ; is this parm text char a blank?
	JZ	FILOOP			; yes, a blank, skip
					; no, not a blank, continue
	CMP	BYTE PTR ES:[DI],CHAR_TAB ; is this parm text char a tab?
	JZ	FILOOP			; yes, a tab, skip
					; no, not a tab, continue
	OR	[NAMESPEC],1		; set flag to indicate
					;  we have a specified file
					; (this could be set by "N" command also)
	CALL	DEFIO			; READ in the specified file

	PUSH	CS			;restore DS to point to the
	POP	DS			; common group

					;perform self-relocation on some internal vectors:
	MOV	AX,CSSAVE		; pick up the seg id to go to vectors
	MOV	WORD PTR DISADD+WORD,AX ;  shove it into the segid portion
	MOV	WORD PTR ASMADD+WORD,AX ;  of these two vectors
	MOV	AX,IPSAVE		; pick up the offset to go to vectors
	MOV	WORD PTR DISADD,AX	;  shove it into the offset portion
	MOV	WORD PTR ASMADD,AX	;  of these two vectors
COMMAND:
	CLD
	MOV	AX,CS
	MOV	DS,AX
	MOV	ES,AX
	cli				;disable before setting up the stack - EMK
	MOV	SS,AX			;now everything points to the same group
	ASSUME	SS:DG

	MOV	SP,OFFSET DG:STACK
	STI				;re-enable
	CMP	[PARITYFLAG],0		; did we detect a parity error?
	JZ	GOPROMPT		; no, go prompt
					; yes, parity error, continue
	MOV	[PARITYFLAG],0		; reset flag
	IF	IBMJAPAN
	    MOV     DX,OFFSET DG:PARITYMES_PTR
	    CALL    STD_PRINTF		;display msg about parity error
	ENDIF
GOPROMPT:
	MOV	DX,OFFSET DG:PROMPT_PTR ;display the user prompt request
	CALL	STD_PRINTF

	CALL	INBUF			; Get command line
; From now and throughout command line processing, DI points
; to next character in command line to be processed.
	CALL	SCANB			; Scan off leading blanks

	JZ	COMMAND 		; if zero, Null command, go get another
					; nonzero, got something in response
	LODSB				; AL=first non-blank character
; Prepare command letter for table lookup
; converts the first non-blank (assumed to be the command letter)
; to in index in the "comtab" array.
	SUB	AL,'?'			; Low end range check
	JB	ERR1

	CMP	AL,'Z'-'?'		; Upper end range check
	JA	ERR1

	SHL	AL,1			; Times two
	CBW				; Now a 16-bit quantity
	XCHG	BX,AX			; In BX we can address with it
	CALL	CS:[BX+COMTAB]		; Execute command

	JMP	SHORT COMMAND		; Get next command
ERR1:
	JMP	PERR

SET_TERMINATE_VECTOR:
	PUSH	DS
	PUSH	CS
	POP	DS
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR VEC_TERM_ADDR ; Set vector 22H
	MOV	DX,OFFSET DG:TERMINATE
	INT	21H

	POP	DS
	RET

RESTORE_DEB_VECT:
	PUSH	DS
	PUSH	DX
	PUSH	AX
	LDS	DX,CS:[BPINTSAV]
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR VEC_BREAKPOINT ;Vector 3
	INT	21H

	LDS	DX,CS:[SSINTSAV]
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR VEC_SING_STEP ;Vector 1
	INT	21H

	POP	AX
	POP	DX
	POP	DS
	RET

; Internal INT 24 handler.  We allow our parent's handler to decide what to do
; and how to prompt.  When our parent returns, we note the return in AL.  If
; he said ABORT, we need to see if we are aborting ourselves.  If so, we
; cannot turn it into fail; we may get a cascade of errors due to the original
; cause.  Instead, we do the ol' disk-reset hack to clean up.  This involves
; issuing a disk-reset, ignoring all errors, and then returning to the caller.
MY24:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

; If we are already inside an INT 24, just ignore this error
	TEST	FIN24,-1
	JZ	DO24

	MOV	AL,0			; signal ignore
	IRET

; Let the user decide what to do
DO24:
	PUSHF
	CALL	PREV24			; simulate INT 24 to him

	CMP	AL,2			; was it ABORT?
	JNZ	DOIRET			; no, let it happen

	PUSH	AX
	PUSH	BX
	MOV	AH,GET_CURRENT_PDB	; find out who's terminating
	INT	21H

	CMP	BX,BEGSEG		; is it us?
	POP	BX
	POP	AX
	JZ	DORESET 		; no, let it happen

DOIRET:
	IRET

; We have been instructed to abort ourselves.  Since we can't do this, we will
; perform a disk reset to flush out all buffers and then ignore the errors we
; get.
DORESET:
	MOV	FIN24,-1		; signal that we ignore errors
	MOV	AH,DISK_RESET
	INT	21H			; clean out cache

	MOV	FIN24,0 		; reset flag
	JMP	COMMAND

TERMINATE:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	CMP	QFLAG,0
	JNZ	QUITING

	MOV	AX,BEGSEG
	MOV	USER_PROC_PDB,AX
	CMP	NEWEXEC,0
	JZ	NORMTERM

	MOV	AX,CS
	MOV	DS,AX
	ASSUME	DS:DG
					;is CLI/STI needed here ? - emk
	CLI
	MOV	SS,AX
	ASSUME	SS:DG

	MOV	SP,OFFSET DG:STACK
	STI
	MOV	AX,HEADSAVE
	JMP	DEBUG_FOUND

NORMTERM:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	PUSH	CS
	POP	DS
	ASSUME	DS:DG

	MOV	DX,OFFSET DG:ENDMES_PTR
	JMP	SHORT RESTART

QUITING:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	CALL	RESTORE_DEB_VECT

	MOV	AX,(EXIT SHL 8)
	INT	21H

RESTART:
	CALL	STD_PRINTF
DABORT:
	MOV	AX,CS
	MOV	DS,AX
	ASSUME	DS:DG

					;is CLI\STI needed here? - emk
	CLI
	MOV	SS,AX
	ASSUME	SS:DG

	MOV	SP,OFFSET DG:STACK
	STI
;;;;;;	CALL	CRLF

	JMP	COMMAND

	IF	SYSVER
SETUDEV:
	    MOV     DI,OFFSET DG:CONFCB
	    MOV     AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR SET_DRIVEID_OPTION
	    INT     21H

	    CALL    USERDEV

	    JMP     DISPREG

USERDEV:
	    MOV     DX,OFFSET DG:CONFCB
	    MOV     AH,FCB_OPEN
	    INT     21H

	    OR	    AL,AL
	    JNZ     OPENERR

	    MOV     SI,DX
;	    TEST    BYTE PTR [SI.FCB_DEVID],080H ; Device?	; KWC 12/10/86
;	    JZ	    OPENERR		; NO			; KWC 12/10/86
	    MOV     AL,BYTE PTR [SI.FCB_NSL_DRIVE] ; KWC 12/10/86
	    AND     AL,NOT FCBMASK	; KWC 12/10/86
	    CMP     AL,0C0H		; KWC 12/10/86
	    JNE     OPENERR		; KWC 12/10/86
	    XOR     AL,AL		; KWC 12/10/86

;	    LDS     SI,DWORD PTR [CONFCB.FCB_FIRCLUS]		; KWC 12/10/86
	    LDS     SI,DWORD PTR [CONFCB.FCB_NSLD_DRVPTR] ; KWC 12/10/86
	    MOV     WORD PTR CS:[CIN],SI
	    MOV     WORD PTR CS:[CIN+WORD],DS

	    MOV     WORD PTR CS:[COUT],SI
	    MOV     WORD PTR CS:[COUT+WORD],DS
	    PUSH    CS
	    POP     DS
	    RET

OPENERR:
	    MOV     DX,OFFSET DG:BADDEV_PTR
	    CALL    STD_PRINTF

	    RET
	ENDIF
; Get input line. Convert all characters NOT in quotes to upper case.
INBUF:
	CALL	RBUFIN

;=========================================================================
; prep_command_line requires the use of ds:si.	ds is left intact for
; the call.  si is initialized to point to the command line input buffer.
; ds and si are saved since we stomp all over them in prep_command_line.
;=========================================================================

	push	si			;an000;save si

	mov	si,offset dg:linebuf	;an000;point to command line
	call	prep_command_line	;an000;invoke command line conversion

	pop	si			;an000;restore si

;=========================================================================
; we have prepped the command line for dbcs.  we can now enter the old
; routines.
;=========================================================================

	MOV	SI,OFFSET DG:LINEBUF
	MOV	DI,OFFSET DG:BYTEBUF

CASECHK:

	LODSB

	call	Test_Lead			;DBCS lead byte 		;an000; dms;
;	$if	c				;yes - ignore 2nd. byte 	;an000; dms;
	JNC $$IF3
		stosb				;save the byte			;an000; dms;
		lodsb				;pick up the 2nd. character	;an000; dms;
		stosb				;save it also			;an000; dms;
		jmp	CaseChk 		;read next character		;an000; dms;
;	$endif					;				;an000; dms;
$$IF3:

	CMP	AL,LOWER_A
	JB	NOCONV

	CMP	AL,LOWER_Z
	JA	NOCONV

	ADD	AL,UPPER_A - LOWER_A	; Convert to upper case
NOCONV:
	STOSB
	CMP	AL,CR
	JZ	INDONE

	CMP	AL,DOUBLE_QUOTE
	JZ	QUOTSCAN

	CMP	AL,SINGLE_QUOTE
	JNZ	CASECHK

QUOTSCAN:
	MOV	AH,AL
KILLSTR:
	LODSB
	STOSB
	CMP	AL,CR			;CARRIAGE RETURN?
	JZ	INDONE

	CMP	AL,AH
	JNZ	KILLSTR

	JMP	SHORT CASECHK

INDONE:
	MOV	SI,OFFSET DG:BYTEBUF
	CALL	CRLF

	RET

; Physical backspace - blank, backspace, blank
BACKUP:
	PUSH	DX
	MOV	DX,OFFSET DG:BACMES_PTR
	CALL	STD_PRINTF

	POP	DX
	RET

; Scan for parameters of a command
SCANP:
	CALL	SCANB			; Get first non-blank

	CMP	BYTE PTR [SI],CHAR_COMMA ; One comma between params OK
	JNE	EOLCHK			; If not comma, we found param

	INC	SI			; Skip over comma
; Scan command line for next non-blank character
SCANB:
	PUSH	AX
SCANNEXT:
	LODSB
	CMP	AL,CHAR_BLANK		;is this char a "blank"?
	JZ	SCANNEXT

	CMP	AL,CHAR_TAB		;is this char a "tab"?
	JZ	SCANNEXT

	DEC	SI			; Back to first non-blank
	POP	AX
EOLCHK:
	CMP	BYTE PTR [SI],CR	;CARRIAGE RETURN
	RET

; Hex addition and subtraction
HEXADD:
	MOV	CX,4
	CALL	GETHEX

	MOV	DI,DX
	MOV	CX,4
	CALL	GETHEX

	CALL	GETEOL

	PUSH	DX
	ADD	DX,DI
	MOV	[ADD_ARG],DX
	POP	DX
	SUB	DI,DX
	MOV	[SUB_ARG],DI
	MOV	DX,OFFSET DG:ADD_PTR
	CALL	PRINTF_CRLF

	RET

; Put the hex address in DS:SI in the argument list for a call to printf
OUTSI:
	MOV	CS:[HEX_ARG1],DS
	MOV	CS:[HEX_ARG2],SI
	RET

;Put the hex address in ES:DI in the argument list for a call to printf
OUTDI:
	MOV	[HEX_ARG1],ES
	MOV	[HEX_ARG2],DI
	RET

HEX_ADDRESS_ONLY:
	MOV	BYTE PTR [ARG_BUF],0
HEX_ADDRESS_STR:
	MOV	DX,OFFSET DG:HEX_PTR
STD_PRINTF:
	PUSH	DX
	CALL	PRINTF
	POP	DX			;ac000;restore dx

	RET

PRINTF_CRLF:
	PUSH	DX
	CALL	PRINTF
	POP	DX			;ac000;restore dx
CRLF:
	MOV	DX,OFFSET DG:CRLF_PTR
	PUSH	DX
	CALL	PRINTF
	POP	DX			;ac000;restore dx

	RET

HEX:
	MOV	AH,AL			; Save for second digit
	PUSH	CX
	MOV	CL,4
	SHR	AL,CL
	POP	CX

	CALL	DIGIT			; First digit

	MOV	AL,AH			; Now do digit saved in AH
DIGIT:
	AND	AL,0FH			; Mask to 4 bits
	ADD	AL,90H
	DAA
	ADC	AL,40H
	DAA
	AND	AL,7FH
	STOSB
	RET

RBUFIN:
	PUSH	AX
	PUSH	DX
	MOV	AH,STD_CON_STRING_INPUT
	MOV	DX,OFFSET DG:LBUFSIZ
	INT	21H

	POP	DX
	POP	AX
	RET

; Put one space in the printf output uffer
BLANK:
	MOV	AL,CHAR_BLANK
	STOSB
	RET

; Put CX spaces in the printf output buffer
TAB:
	JCXZ	TAB_RET

	CALL	BLANK

	LOOP	TAB
TAB_RET:
	RET

; Command Table. Command letter indexes into table to get
; address of command. PERR prints error for no such command.

COMTAB	DW	QUESTION_HELP		; ?
	DW	PERR			; @
	DW	ASSEM			; A
	DW	PERR			; B
	DW	COMPARE 		; C
	DW	DUMP			; D
	DW	ENTERDATA		; E
	DW	FILL			; F
	DW	GO			; G
	DW	HEXADD			; H
	DW	INPUT			; I
	DW	PERR			; J
ifdef JAPAN
	DW	SETDUMPMODE		; K
else
	DW	PERR			; K
endif
	DW	LOAD			; L
	DW	MOVE			; M
	DW	NAMED			; N
	DW	OUTPUT			; O
	DW	ZTRACE			; P
	DW	QUIT			; Q (QUIT)
	DW	REG			; R
	DW	SEARCH			; S
	DW	TRACE			; T
	DW	UNASSEM 		; U
	DW	PERR			; V
	DW	DWRITE			; W
	IF	SYSVER
	    DW	    SETUDEV		; X
	ELSE
	    DW	    DEBEMS
	ENDIF
	DW	PERR			; Y
	DW	PERR			; Z

QUESTION_HELP:
	MOV	DX, OFFSET DG:HELP_TEXT1
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT2
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT3
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT4
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT5
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT6
	JMP	STD_PRINTF


QUIT:
	INC	BYTE PTR [QFLAG]
	MOV	BX,[USER_PROC_PDB]
FIND_DEBUG:
	IF	NOT SYSVER
	    MOV     AH,SET_CURRENT_PDB
	    INT     21H
	ENDIF
	CALL	RELEASEPARITY		; let system do normal parity stuff

	CALL	RESTORE_DEB_VECT

	MOV	AX,(EXIT SHL 8)
	INT	21H

;======================= proc  prep_command_line =========================
; prep_command_line: This proc converts a Asian DBCS space delimiter (DB_SPACE)
;		     into 2 20h values.  In this way we can pass command
;		     lines throughout DEBUG without major modification
;		     to the source code.  This proc is invoked anywhere
;		     a command line is initially accessed.  In the case
;		     of DEBUG it is used in PARSCHK and INBUF.
;		     Any quoted string, a string delimited by ("), will
;		     be ignored.
;
;	input: ds - segment of command line
;	       si - offset of command line
;
;	output: command line with Asian blanks (DB_SPACE) converted to
;		2020h.
;
;=========================================================================

prep_command_line proc near		;command line conversion
    push    ax				;save affected regs.
    push    bx				;
    push    si				;

    mov     bl,00h			;initialize flag
					;bl is used to signal
					;  a quote delimiter
;   $DO 				;do while not CR
$$DO5:
	mov	al,[si] 		;move char from cmd line for compare
	cmp	al,CR			;is it a CR ?
;   $LEAVE  E				;if CR exit
    JE $$EN5

	cmp	al,quote_char		;is it a quote ?
;	$IF	Z			;if it is a quote
	JNZ $$IF7
	    xor     bl,01h		;set or reset the flag
;	$ENDIF
$$IF7:

	cmp	bl,01h			;is 1st quote set ?
;	$IF	NZ			;if not continue
	JZ $$IF9
	    call    TEST_LEAD		;test for dbcs lead byte
;	    $IF     C			;we have a lead byte
	    JNC $$IF10
		cmp	al,DB_SP_HI	;is it a dbcs char?
;		$IF	Z		;if a dbcs char
		JNZ $$IF11
		    mov     al,[si+1]	    ;move next char al
		    cmp     al,DB_SP_LO     ;is it an Asian blank?
;		    $IF     Z		    ;if an Asian blank
		    JNZ $$IF12
			mov	al,amer_blk ;set up moves
			mov	[si],al     ;  to replace
			mov	[si+1],al   ;  Asian blank w/20h
			inc	si	    ;point to si+1
;		    $ELSE		;if not an asian blank
		    JMP SHORT $$EN12
$$IF12:
			inc	si	;point to dbcs char
;		    $ENDIF		;
$$EN12:
;		$ENDIF			;
$$IF11:
;	    $ENDIF			;end lead byte test
$$IF10:
;	$ENDIF				;
$$IF9:
	inc	si			;point to si+1
;   $ENDDO				;end do while
    JMP SHORT $$DO5
$$EN5:
    pop     si				;restore affected regs.
    pop     bx				;
    pop     ax				;
    ret 				;return to caller
prep_command_line endp			;end proc


;=========================================================================
; DEBUG_LEAD_BYTE - This routine sets the lead-byte-pointers to point
;		    to the dbcs environmental vector table of lead bytes.
;		    This table will be used to determine if we have a
;		    dbcs lead byte.
;
;	Inputs - none
;
;	Outputs- pointer to dbcs environmental vector table of lead bytes
;		 LBTBL DD ?
;
;	Date	  : 6/16/87
;=========================================================================

DEBUG_LEAD_BYTE proc near		;an000;get lead byte vector

	push	ds			;an000;save affected regs
	push	es			;an000;
	push	si			;an000;

	mov	ax,(ECS_call shl 8) or 00h ;an000;get dbcs env. vector
	int	21h			;an000;invoke function

	assume	ds:nothing

	mov	word ptr cs:lbtbl[0],si ;an000;move offset of table
	mov	word ptr cs:lbtbl[2],ds ;an000;move segment of table

	pop	si			;an000;restore affected regs
	pop	es			;an000;
	pop	ds			;an000;

	ret				;an000;return to caller

DEBUG_LEAD_BYTE endp			;an000;end proc

;=========================================================================
; TEST_LEAD - This routine will determine whether or not we have a valid
;	      lead byte for a DBCS character.
;
;	Inputs : AL - Holds the byte to compare.  Passed by POP.		;an001;bgb
;
;	Outputs: Carry set if lead byte
;		 No carry if not lead byte
;
;	Date	  : 6/16/87
;=========================================================================

TEST_LEAD proc	near			;an000;check for dbcs lead byte

	push	ds			;an000;save affected regs
	push	si			;an000;
	push	ax			;an000;

	xchg	ah,al			;an000;ah used for compare
	mov	si,word ptr cs:lbtbl[2] ;an000;get segment of table
	mov	ds,si			;an000;
	mov	si,word ptr cs:lbtbl[0] ;an000;get offset of table

ck_next:

	lodsb				;an000;load al with byte table
	or	al,al			;an000;end of table?
;	$IF	z			;an000;yes, end of table
	jz	lead_exit		; exit with clear carry
	    cmp     al,ah		;an000;start > character?
;	    $IF     a			;an000;it is above
	    JNA $$IF21
		clc			;an000;clear carry flag
		jmp	short lead_exit	;an000;exit with clear carry
;	    $ELSE			;an000;
	    JMP SHORT $$EN21
$$IF21:
		lodsb			;an000;load al with byte table
		cmp	ah,al		;an000;character > end range
;		$IF	a		;an000;not a lead
		JNA $$IF23
		    jmp     ck_next	;an000;check next range
;		$ELSE			;an000;lead byte found
		JMP SHORT $$EN23
$$IF23:
		    stc 		;an000;set carry flag
;		$ENDIF			;an000;
$$EN23:
;	    $ENDIF			;an000;
$$EN21:
;	$ENDIF				;an000;

lead_exit:				;an000;exit from check

	pop	ax			;an000;
	pop	si			;an000;restore affected regs.
	pop	ds			;an000;

	ret				;an000;return to caller

TEST_LEAD endp				;an000;end proc



CODE	ENDS
	END	START

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\debdata.asm ===
PAGE    60,132 ;
	   TITLE DEBDATA.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DEBDATA.ASM
;
; DESCRIPTIVE NAME: DATA SEGMENT VALUE DEFINITION
;
; FUNCTION: PROVIDES ALL DATA SEGMENT DEFINITIONS.
;
; ENTRY POINT: NA
;
; INPUT: ANY VALUE IN DATA SEGMENT
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES: NA
;
; EXTERNAL REFERENCES: NA
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- > 32 MB SUPPORT		DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================
;
;   Change Log:
;
;     Date    Who   #			Description
;   --------  ---  ---	------------------------------------------------------
;   03/21/90  DIC  C04	Fixed Microsoft Bug #744 - A problem involving a
;			limitation on the total number of requested EMS memory
;			pages to 255.  This limit is now a 4-digit hexadecimal
;			number.
;
;=============================================================================

.XLIST
.XCREF
	   include version.inc		; cas -- missing equates
	   INCLUDE DOSSYM.INC
           INCLUDE debug.inc
	   INCLUDE DPL.ASM
.LIST
.CREF
CODE	   SEGMENT PUBLIC BYTE
CODE	   ENDS

CONST	   SEGMENT PUBLIC BYTE
CONST	   ENDS

DATA	   SEGMENT PUBLIC BYTE
DATA	   ENDS

CSTACK	   SEGMENT STACK
CSTACK	   ENDS

DG	   GROUP CODE,CONST,CSTACK,DATA

DATA	   SEGMENT PUBLIC BYTE
	   PUBLIC PARITYFLAG,XNXOPT,XNXCMD,SWITCHAR,EXTPTR,HANDLE,TRANSADD
	   PUBLIC PARSERR,ASMADD,DISADD,DISCNT,ASMSP,INDEX,DEFDUMP,DEFLEN
	   PUBLIC REGSAVE,SEGSAVE,OFFSAVE,TEMP,BUFFER,BYTCNT,OPCODE,AWORD
	   PUBLIC REGMEM,MIDFLD,MODE,NSEG,BRKCNT,TCOUNT,ASSEM_CNT
	   PUBLIC ASSEM1,ASSEM2,ASSEM3,ASSEM4,ASSEM5,ASSEM6,BYTEBUF,BPTAB
	   PUBLIC DIFLG,SIFLG,BXFLG,BPFLG,NEGFLG,NUMFLG,MEMFLG,REGFLG
	   PUBLIC MOVFLG,TSTFLG,SEGFLG,LOWNUM,HINUM,F8087,DIRFLG,DATAEND
	   PUBLIC BEGSEG,CREATE_LONG,ARG_BUF_INDEX
	   PUBLIC FILEEND,FILESTRT,SSINTSAV,BPINTSAV
	   PUBLIC FZTRACE, PREV24, FIN24

	   public rel_read_write_tab		;an000;relative read/write
						;      table
	   public rel_low_sec			;an000;sector add. low word
	   public rel_high_sec			;an000;sector add. high word
	   public rel_sec_num			;an000;# of sectors to access
	   public rel_rw_add			;an000;transfer address

	   public lbtbl 			;an000;lead byte table pointer

	public xm_page				;an000;
	public xm_log				;an000;
	public xm_phy				;an000;
	public xm_handle			;an000;
	public xm_handle_ret			;an000;
	public xm_page_cnt			;an000;
	public xm_handle_pages_buf		;an000;
	public xm_frame 			;an000;
	public xm_deall_han			;an000;
	public xm_alloc_pg			;an000;
	public xm_total_pg			;an000;
	public xm_han_total			;an000;
	public xm_han_alloc			;an000;

;=========================================================================
; REL_READ_WRITE_TAB : This table provides the new generic IOCTL primitive
;		       read/write with its values.
;
;	Date	  : 6/17/87
;=========================================================================

REL_READ_WRITE_TAB	label	dword		;an000;relative read/write
						;      table
	rel_low_sec	dw	?		;an000;sector add. low word
	rel_high_sec	dw	?		;an000;sector add. high word
	rel_sec_num	dw	?		;an000;# of sectors to write
	rel_rw_add	dd	?		;an000;holds the segment
						;      & offset of the
						;      transfer address

;=========================================================================

lbtbl		dd	?			;an000;lead byte table pointer

;C04	xm_page        db   ?			;an000;page count to allocate
	xm_page        dw   ?	;page count to allocate - raised to 64K    ;C04
	xm_log	       db   ?			;an000;log. page to map
	xm_phy	       db   ?			;an000;phy. page to map
	xm_deall_han   dw   ?			;an000;handle to deallocate
	xm_handle      dw   ?			;an000;handle to map
	xm_handle_ret  dw   ?			;an000;handle created


	xm_page_cnt    dw   ?			;an000;current page count

	xm_handle_pages_buf db	 1024 dup(0)	;an000;hold handle pages

	xm_frame	dw  ?			;an000;holds frame segment

	xm_alloc_pg	dw  ?			;an000;active page count

	xm_total_pg	dw  ?			;an000;total possible page cnt.

	xm_han_total	dw  ?			;an000;total possible handles

	xm_han_alloc	dw  ?			;an000;handles allocated

	   IF	IBMVER
	       PUBLIC OLD_MASK
OLD_MASK       DB   ?
		public	cpu_not_8088
cpu_not_8088	db	?			; true if not 8088/8086
	   ENDIF

PREV24	   DD	?			; prevvious INT 24 handler
FIN24	   DB	0			; TRUE => in the process of cleaning up
FZTRACE    DB	0			; TRUE => in a Ztrace
FILEEND    DW	?			; ARR 2.4
FILESTRT   DW	?			; ARR 2.4
SSINTSAV   DD	?			; ARR 2.4
BPINTSAV   DD	?			; ARR 2.4

PARITYFLAG DB	0

PUBLIC	   SAVESTATE
SAVESTATE  DPL	<>			; storage for extended error info

XNXOPT	   DB	?			; AL OPTION FOR DOS COMMAND
XNXCMD	   DB	?			; DOS COMMAND FOR OPEN_A_FILE TO PERFORM
SWITCHAR   DB	?			; CURRENT SWITCH CHARACTER
EXTPTR	   DW	?			; POINTER TO FILE EXTENSION
HANDLE	   DW	?			; CURRENT HANDLE
TRANSADD   DD	?			; TRANSFER ADDRESS

PARSERR    DB	?
ASMADD	   DB	4 DUP (?)
DISADD	   DB	4 DUP (?)
DISCNT	   DW	?
ASMSP	   DW	?			; SP AT ENTRY TO ASM
INDEX	   DW	?
DEFDUMP    DB	4 DUP (?)
DEFLEN	   DW	?
REGSAVE    DW	?
SEGSAVE    DW	?
OFFSAVE    DW	?

;Do NOT move this dword variable - it sets up a long call for
;a Create_process_data_block call issued in DEBUG
CREATE_LONG LABEL DWORD
	   DW	100H
BEGSEG	   DW	?

; The following data areas are destroyed during hex file read
TEMP	   DB	4 DUP(?)
BUFFER	   LABEL BYTE
BYTCNT	   DB	?
ARG_BUF_INDEX DW ?
OPCODE	   DW	?
AWORD	   DB	?
REGMEM	   DB	?
MIDFLD	   DB	?
MODE	   DB	?
NSEG	   DW	?
BRKCNT	   DW	?			; Number of breakpoints
TCOUNT	   DW	?			; Number of steps to trace
ASSEM_CNT  DB	?			; preserve order of assem_cnt and assem1
ASSEM1	   DB	?
ASSEM2	   DB	?
ASSEM3	   DB	?
ASSEM4	   DB	?
ASSEM5	   DB	?
ASSEM6	   DB	?			; preserve order of assemx and bytebuf
BYTEBUF    DB	BUFLEN	DUP (?) 	; Table used by LIST
BPTAB	   DB	BPLEN	DUP (?) 	; Breakpoint table
DIFLG	   DB	?
SIFLG	   DB	?
BXFLG	   DB	?
BPFLG	   DB	?
NEGFLG	   DB	?
NUMFLG	   DB	?			; ZERO MEANS NO NUMBER SEEN
MEMFLG	   DB	?
REGFLG	   DB	?
MOVFLG	   DB	?
TSTFLG	   DB	?
SEGFLG	   DB	?
LOWNUM	   DW	?
HINUM	   DW	?
F8087	   DB	?
DIRFLG	   DB	?
	   DB	BUFFER+BUFSIZ-$ DUP (?)

DATAEND    LABEL WORD

DATA	   ENDS
	   END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\debmes.asm ===
PAGE	60,132				;
	TITLE	DEBMES.ASM - DEBUGGER MESSAGES PC DOS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	IF1
	    %OUT    COMPONENT=DEBUG, MODULE=DEBMES
	ENDIF

;******************* START OF SPECIFICATIONS *****************************
;
; MODULE NAME:DEBMES.ASM
;
; DESCRIPTIVE NAME: SUPPLIES APPLICABLE MESSAGES TO DEBUG.ASM
;
; FUNCTION: THIS ROUTINE PROVIDES A MEANS BY WHICH MESSAGES MAY BE
;	    OUTPUT FOR DEBUG.  THIS IS HANDLED THROUGH THE MESSAGE
;	    RETRIEVER FUNCTION SYSDISPMSG.  TO
;	    FACILITATE MIGRATION AWAY FROM THE PRINTF UTILITY
;	    THE INTERFACE FOR INVOKING MESSAGES HAS REMAINED THE SAME.
;	    THIS IS ACCOMPLISHED THROUGH THE USE OF MACROS AND TABLES.
;	    EACH MESSAGE HAS A TABLE OF VALUES REQUIRED BY THE MESSAGE
;	    RETRIEVER UTILITIES.  THE MACROS OPERATE ON THESE TABLES
;	    TO SUPPLY SYSDISPMSG WITH THE VALUES NECESSARY
;	    TO PRINT A MESSAGE.
;
; ENTRY POINT: PRINTF
;
; INPUT: PRINTF IS INVOKED AS IT HAS ALWAYS BEEN INVOKED.  DX MUST
;	 POINT TO THE OFFSET OF A MESSAGE TABLE.  THE TABLE POINTED TO
;	 BY DX CONTAINS ALL THE NECESSARY INFORMATION FOR THAT MESSAGE
;	 TO BE PRINTED.
;
; EXIT-NORMAL: NO CARRY
;
; EXIT-ERROR: CARRY SET - EITHER MESSAGE NOT FOUND OR UNABLE TO BE DISPLAYED
;
; INTERNAL REFERENCES:
;
;	ROUTINE:DISP_MESSAGE - THIS MACRO IS USED TO DIPLAY A MESSAGE
;			       VIA SYSDISPMSG.	IT TAKES AS INPUT A POINTER
;			       IN DX.  THIS POINTER POINTS TO A TABLE OF
;			       VALUES FOR THE REQUESTED MESSAGE.
;			       DISP_MESSAGE OBTAINS THE VALUES IT NEEDS TO
;			       TO INVOKE SYSDISPMSG FROM THIS TABLE.
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: SYSMSG.INC  - THIS ROUTINE IS SUPPLIED TO INTERFACE THE
;			       MESSAGE RETRIEVER SERVICES.
;
; NOTES: THIS MODULE SHOULD BE PROCESSED WITH THE SALUT PRE-PROCESSOR
;	 WITH OPTIONS "PR".
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+DEBCONST+
;	      DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.0 - MESSAGE RETRIEVER IMPLEMENTED.  DMS:6/17/87
;
;
; COPYRIGHT: "MS DOS DEBUG Utility"
;	     "Version 4.00 (C) Copyright 1988 Microsoft"
;	     "Licensed Material - Property of Microsoft  "
;
;******************** END OF SPECIFICATIONS ******************************
;
;  CHANGE LOG:
;
;     DATE    WHO   #		       DESCRIPTION
;   --------  ---  ---	---------------------------------------------------
;   04/01/90  DIC  C02	Message was only printing first parameter, not
;			first and second.  I made the BX:CX message print
;			1 byte for BX and left CX at 4 bytes. Corresponding
;			change in message file, DEBUG line 38. (Compaq STR
;			#1804) (MS Bug #338)
;
;   05/25/90  AKM  C07	Problem fixed - Number of bytes writtem message
;                       was being printed with the wrong alignment &
;                       precision.
;			(Microsoft Bug #1156)
;
;============================================================================
.xlist

	include sysmsg.inc		;an000;message retriever

.list

msg_utilname <DEBUG>			;an000;DEBUG messages

;=========================================================================
;revised debmes.asm
;=========================================================================

fatal_error	equ	45		;fatal message handler error
unlim_width	equ	00h		;unlimited output width
pad_blank	equ	20h		;blank pad
pre_load	equ	00h		;an000;normal pre-load
pad_zero	equ	30h		;an000;zero pad


FALSE	EQU	0
TRUE	EQU	NOT FALSE

;SYSVER 	 EQU FALSE		 ;if true, i/o direct to bios
	INCLUDE SYSVER.INC

;=========================================================================
; macro disp_message: the macro takes the message obtained in get_message
;		      and displays it to the applicable screen device.
;=========================================================================

disp_message macro tbl			;an000;display message macro

	push	si			;an000;save affected reg
	push	di			;an000;
	push	ax			;an000;
	push	bx			;an000;
	push	cx			;an000;
	push	dx			;an000;

	push	tbl			;an000;exchange tbl with si
	pop	si			;an000;

	mov	ax,[si] 		;an000;move message number to ax
	mov	bx,[si+3]		;an000;display handle
	mov	cx,[si+7]		;an000;number of subs
	mov	dl,[si+9]		;an000;function type
	mov	di,[si+10]		;an000;input buffer if appl.
	mov	dh,[si+2]		;an000;message type
	mov	si,[si+5]		;an000;sublist

	call	sysdispmsg		;an000;display the message

	pop	dx			;an000;restore affected reg
	pop	cx			;an000;
	pop	bx			;an000;
	pop	ax			;an000;
	pop	di			;an000;
	pop	si			;an000;


endm					;an000;end macro disp_message

;=========================================================================
; macro disp_message: end macro
;=========================================================================



CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE

DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA


code	segment public byte		;an000;code segment
	assume	cs:dg,ds:dg,ss:dg,es:dg ;an000;

	public	printf			;an000;share printf
;;	public	disp_fatal		;an000;fatal error display
	public	pre_load_message	;an000;message pre load

.xlist

msg_services <MSGDATA>

.list

;=========================================================================
;	  include sysmsg.inc - message retriever services
;options selected:
;		   NEARmsg
;		   DISPLAYmsg
;		   LOADmsg
;		   INPUTmsg
;		   CHARmsg
;		   NUMmsg
;		   CLSAmsg
;		   CLSBmsg
;		   CLSCmsg
;		   CLSDmsg
;=========================================================================

.xlist

msg_services <LOADmsg>			;an000;load the messages
msg_services <DISPLAYmsg,CHARmsg,NUMmsg>;an000;get and display messages
msg_services <INPUTmsg> 		;an000;input from keyboard
msg_services <DEBUG.CLA,DEBUG.CLB>	;an000;message types
msg_services <DEBUG.CLC,DEBUG.CLD>	;an000;
msg_services <DEBUG.CL1,DEBUG.CL2>	;an000;

.list

;=========================================================================
; printf: printf is a replacement of the printf procedure used in DOS
;	  releases prior 4.00.	printf invokes the macros get_message and
;	  disp_message to invoke the new message handler.  the interface
;	  into printf will continue to be a pointer to a message passed
;	  in DX.  the pointer is pointing to more than a message now.  it
;	  is pointing to a table for that message containing all relevant
;	  information for retieving and printing the message.  the macros
;	  get_message and disp_message operate on these tables.
;=========================================================================

printf	proc	near			;an000;printf procedure

	disp_message dx 		;an000;display a message
;;	$if	c			;an000;if an error occurred
;;		call disp_fatal 	;an000;display the fatal error
;;	$endif				;an000;

	ret				;an000;return to caller

printf	endp				;an000;end printf


;=========================================================================
; disp_fatal: this routine displays a fatal error message in the event
;	      an error occurred in disp_message.
;=========================================================================

;;disp_fatal	  proc	  near		  ;an000;fatal error message
;;
;;	  mov	  ax,fatal_error	  ;an000;fatal_error number
;;	  mov	  bx,stdout		  ;an000;print to console
;;	  mov	  cx,0			  ;an000;no parameters
;;	  mov	  dl,no_input		  ;an000;no input will be coming
;;	  mov	  dh,UTILITY_MSG_CLASS	     ;an000;utility messages
;;	  call	  sysdispmsg		  ;an000;dispaly fatal error
;;	  ret				  ;an000;return to caller
;;
;;disp_fatal	  endp			  ;an000;end disp_fatal


;=========================================================================
; PRE_LOAD_MESSAGE : This routine provides access to the messages required
;		     by DEBUG.	This routine will report if the load was
;		     successful.  An unsuccessful load will cause DEBUG
;		     to terminate with an appropriate error message.
;
;	Date	  : 6/15/87
;=========================================================================

PRE_LOAD_MESSAGE	proc	near		;an000;pre-load messages

	call	SYSLOADMSG			;an000;invoke loader

;	$if	c				;an000;if an error
	JNC $$IF1
		pushf				;an000;save flags
		call	SYSDISPMSG		;an000;let him say why
		popf				;an000;restore flags
;	$endif					;an000;
$$IF1:

	ret					;an000;return to caller

PRE_LOAD_MESSAGE	endp			;an000;end proc

include msgdcl.inc

code	ends				;an000;end code segment


CONST	SEGMENT PUBLIC BYTE

	PUBLIC	ENDMES_PTR,CRLF_PTR,NAMBAD_PTR
	PUBLIC	NOTFND_PTR,NOROOM_PTR,BADVER
	PUBLIC	NOSPACE_PTR,DRVLET
	PUBLIC	ACCMES_PTR,PROMPT_PTR
	PUBLIC	TOOBIG_PTR,SYNERR_PTR,BACMES_PTR
	PUBLIC	HEXERR_PTR,HEXWRT_PTR,WRTMES_PTR,EXEBAD_PTR,EXEWRT_PTR
	PUBLIC	EXECEMES_PTR, PARITYMES_PTR, NONAMESPEC_PTR
	PUBLIC	dr1_ptr,dr2_ptr,dr3_ptr,dr4_ptr 	;ac000;new messages
	PUBLIC	CHANGE_FLAG_PTR,DF_ERROR,BF_ERROR,BR_ERROR,BP_ERROR
	PUBLIC	CONSTEND

;======================= TABLE STRUCTURE =================================
;
;	byte 1	-	message number of message to be displayed
;	byte 2	-	message type to be used, i.e.;class 1, utility, etc.
;	byte 3	-	display handle, i.e.; console, printer, etc.
;	byte 4	-	pointer to substitution list, if any.
;	byte 6	-	number of replaceable parameters, if any.
;	byte 7	-	type of input from keyboard, if any.
;	byte 8	-	pointer to buffer for keyboard input, if any.
;
;=========================================================================

	IF	SYSVER

	    PUBLIC  BADDEV_PTR,BADLSTMES_PTR


baddev_ptr  label   word		;an000;"Bad device name",0
	    dw	    0006		;an000;message number 6
	    db	    UTILITY_MSG_CLASS	   ;an000;utility message
	    dw	    stdout		;an000;display handle
	    dw	    00			;an000;sublist
	    dw	    00			;an000;no subs
	    db	    no_input		;an000;no keyboard input
	    dw	    00			;an000;no keyboard buffer

badlstmes_ptr label word		;an000;"Couldn't open list device
					;      PRN","Enter name of list
					;      device?"
	    dw	    0007		;an000;message number 7
	    db	    UTILITY_MSG_CLASS	   ;an000;utility message
	    dw	    stdout		;an000;display handle
	    dw	    00			;an000;sublist
	    dw	    00			;an000;no subs
	    db	    DOS_KEYB_INP	;an000;keyboard input
	    dw	    00			;an000;no keyboard buffer


	ENDIF

;================= REPLACEABLE PARAMETER SUBLIST STRUCTURE ===============
;
;	byte 1	-	substitution list size, always 11
;	byte 2	-	reserved for use by message handler
;	byte 3	-	pointer to parameter to be used as a substitution
;	byte 7	-	which parameter is this to replace, %1, %2, etc.
;	byte 8	-	determines how the parameter is to be output
;	byte 9	-	determines the maximum width of the parameter string
;	byte 10 -	determines the minimum width of the parameter string
;	byte 11 -	define what is to be used as a pad character
;
;=========================================================================


;=========================================================================
;		replaceable parameter sublists
;=========================================================================

db_synerr_sub label dword		;an000;synerr parameters
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad

db_change_sub label dword		;an000;synerr parameters
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad

db_drive_error label dword		;an000;drive error parameters
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:drvlet		;an000;point to drive letter
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	01			;an000;1 byte
	db	01			;an000;1 byte
	db	pad_blank		;an000;blank pad



;=========================================================================
;		end replaceable parameter sublists
;=========================================================================


crlf_ptr label	word			;an000;13,10,0
	dw	0008			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


bacmes_ptr label word			;an000;32,8,0
	dw	0044			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


badver	label	word			;an000;"Incorrect DOS version"
	dw	0001			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

endmes_ptr label word			;an000;13,10,"Program terminated
					;	      normally",0
	dw	0009			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


nambad_ptr label word			;an000;"Invalid drive specification",0
	dw	0010			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


notfnd_ptr label word			;an000;"File not found",0
	dw	0002			;an000;message number
	db	Ext_Err_Class		;an000;extended error
	dw	stderr			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


noroom_ptr label word			;an000;"File creation error",0
	dw	0012			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


nospace_ptr label word			;an000;"Insufficient space on disk",0
	dw	0013			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


dr1_ptr label	word			;an000;"Disk error reading drive %1"
	dw	0014			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_drive_error	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


dr2_ptr label	word			;an000;"Disk error writing drive %1"
	dw	0015			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_drive_error	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


dr3_ptr label	word			;an000;"Write protect error reading
					;	drive %1"
	dw	0016			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_drive_error	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


dr4_ptr label	word			;an000;"Write protect error writing
					;	drive %1"
	dw	0017			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_drive_error	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


toobig_ptr label word			;an000;"Insufficient memory",0
	dw	0008			;an000;message number
	db	Ext_Err_Class		;an000;utility message
	dw	stderr			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

synerr_ptr label word			;an000;"%1^Error",0
	dw	0019			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_synerr_sub	;an000;sublist
	dw	01			;an000;1 sub - leading spaces
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


hexerr_ptr label word			;an000;"Error in EXE or HEX file",0
	dw	0020			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

exebad_ptr label word			;an000;"Error in EXE or HEX file",0
	dw	0020			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


hexwrt_ptr label word			;an000;"EXE and HEX files cannot be
					;	written",0
	dw	0021			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

exewrt_ptr label word			;an000;"EXE and HEX files cannot be
					;	written",0
	dw	0021			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


execemes_ptr label word 		;an000;"EXEC failure",0
	dw	0022			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


nonamespec_ptr label word		;an000;"(W)rite error, no destination
					;	defined",0
	dw	0023			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

accmes_ptr label word			;an000;Access denied",0
	dw	0024			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


paritymes_ptr label word		;an000;"Parity error or nonexistant
					;	memory error detected",0
	dw	0025			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


prompt_ptr label word			;an000;"-",0
	dw	0026			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


change_flag_ptr label word		;an000;"%1 -",0
	dw	0027			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_change_sub	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

df_error	db	"df",0
bf_error	db	"bf",0
br_error	db	"br",0
bp_error	db	"bp",0
drvlet		db	"A",0

CONSTEND LABEL	BYTE

CONST	ENDS

DATA	SEGMENT PUBLIC BYTE

	PUBLIC	HEX_ARG1,HEX_ARG2,HEX_PTR,ARG_BUF
	PUBLIC	ARG_BUF_PTR,ADD_PTR,ERR_TYPE
	PUBLIC	CRLF_PTR,ADD_ARG,SUB_ARG,PROMPT_PTR
	PUBLIC	REGISTER_PTR,REG_NAME,REG_CONTENTS
	PUBLIC	SINGLE_REG_PTR,SINGLE_REG_ARG
	PUBLIC	ERRMES_PTR,LOC_PTR,LOC_ADD
	PUBLIC	LITTLE_PTR,BIG_PTR,LITTLE_CONTENTS
	PUBLIC	BIG_CONTENTS,COMP_PTR,COMP_ARG1,COMP_ARG2
	PUBLIC	COMP_ARG3,COMP_ARG4,COMP_ARG5,COMP_ARG6
	PUBLIC	WRTMES_PTR,WRT_ARG1,WRT_ARG2
	PUBLIC	IOTYP,MESTYP
	PUBLIC	ONE_CHAR_BUF,ONE_CHAR_BUF_PTR
	PUBLIC	OPBUF,UNASSEM_LN_PTR
	PUBLIC  QMES_1
	PUBLIC	QMES_2
	PUBLIC  QMES_3
	PUBLIC  QMES_4
	PUBLIC  QMES_5
	PUBLIC	HELP_TEXT1
	PUBLIC	HELP_TEXT2
	PUBLIC	HELP_TEXT3
	PUBLIC	HELP_TEXT4
	PUBLIC	HELP_TEXT5
	PUBLIC	HELP_TEXT6

	PUBLIC	xm_han_ret_ptr
	PUBLIC	xm_mapped_ptr
	PUBLIC	xm_err80_ptr
	PUBLIC	xm_err83_ptr
	PUBLIC	xm_err84_ptr
	PUBLIC	xm_err85_ptr
	PUBLIC	xm_err86_ptr
	PUBLIC	xm_err87_ptr
	PUBLIC	xm_err88_ptr
	PUBLIC	xm_err89_ptr
	PUBLIC	xm_err8a_ptr
	PUBLIC	xm_err8b_ptr
	PUBLIC	xm_err8d_ptr
	PUBLIC	xm_err8e_ptr
	PUBLIC	xm_err_gen_ptr
	PUBLIC	xm_parse_err_ptr
	PUBLIC	xm_status_ptr
	PUBLIC	xm_page_seg_ptr
	PUBLIC	xm_deall_ptr
	PUBLIC	xm_errff_ptr
	PUBLIC	xm_unall_ptr
	PUBLIC	xm_han_alloc_ptr

	EXTRN	XM_HANDLE_RET:word
	EXTRN	XM_LOG:byte
	EXTRN	XM_PHY:byte
	EXTRN	XM_PAGE_CNT:word
	EXTRN	XM_FRAME:word
	EXTRN	XM_DEALL_HAN:word
	EXTRN	XM_ALLOC_PG:word
	EXTRN	XM_TOTAL_PG:word
	EXTRN	XM_HAN_ALLOC:word
	EXTRN	XM_HAN_TOTAL:word

;=========================================================================
;		    begin parameter sublists
;=========================================================================

;======================= unassemble parameter sublists ===================

db_unassem_sb1 label dword		;an000;unassemble parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad

db_unassem_sb2 label dword		;an000;unassemble parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:opbuf		;an000;point to argument buffer
	db	02			;an000;parameter two
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad


;================== hex argument parameter sublists ======================

db_hexarg_sb1 label dword		;an000;hex argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:hex_arg1		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;right align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_hexarg_sb2 label dword		;an000;hex argument parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:hex_arg2		;an000;point to argument buffer
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_hexarg_sb3 label dword		;an000;hex argument parameter 3
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	03			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad


;================== hex add parameter sublists ===========================

db_hexadd_sb1 label dword		;an000;hex add parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:add_arg		;an000;point to add_arg
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_hexadd_sb2 label dword		;an000;hex argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:sub_arg		;an000;point to sub_arg
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;================== end hex add parameter sublists =======================

;================== single register parameter sublists ===================
;string: "%1 %2",13,10,":",0

db_singrg_sb1 label dword		;an000;single register parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_singrg_sb2 label dword		;an000;single register parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:single_reg_arg	;an000;point single_reg_arg
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;================== register parameter sublists ==========================
;string: "%1=%2  ",0

db_regist_sb1 label dword		;an000;register parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:reg_name		;an000;point to reg_name
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	02			;an000;unlimited width
	db	02			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_regist_sb2 label dword		;an000;register parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:reg_contents 	;an000;point to reg_contents
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;================== error message parameter sublists =====================
;string: "%1 Error",0

db_error_sb1 label dword		;an000;error message parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:err_type		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

;================== writing message parameter sublists ===================
;string: "Writing %1%2 bytes",0

db_wrtmes_sb1 label dword		;an000;wrtmes parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:wrt_arg1		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;right align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_wrtmes_sb2 label dword		;an000;wrtmes parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:wrt_arg2		;an000;point to argument buffer
	db	02			;an000;parameter two
;C07	db	left_align+bin_hex_word
	db	right_align+bin_hex_word                                  ;C07
					;an000;left align/word/hexadecimal
;C02	db	04			;an000;maximum of 4 bytes
;C02	db	04			;an000;minimum of 4 bytes
;C07	db	01			;an000;maximum of 4 bytes	    ;C02
;C07	db	00			;an000;minimum of 4 bytes	    ;C02
	db	04			;an000;maximum of 4 bytes	  ;C07
	db	01			;an000;minimum of 4 bytes         ;C07
	db	pad_zero		;an000;blank pad

;================== loc address parameter sublists =======================
;string: "%1:%2=",0

db_locadd_sb1 label dword		;an000;loc address parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	right_align+Char_field_ASCIIZ
					;an000;left align/ASCIZZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_locadd_sb2 label dword		;an000;loc address parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:loc_add		;an000;point to loc_add
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;================== little contents parameter sublists ===================
;string "%1",0

db_little_sb1 label dword		;an000;one byte output parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:little_contents	;an000;point to little_contents
	db	01			;an000;parameter one
	db	right_align+bin_hex_byte
					;an000;left align/byte/hexadecimal
	db	02			;an000;maximum of 2 bytes
	db	02			;an000;minimum of 2 bytes
	db	pad_zero		;an000;blank pad

;================== big argument parameter sublists ======================
;string: "%1",0

db_big_sb1 label dword			;an000;word argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:big_contents 	;an000;point to big_contents
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;======================= comp argument parameter sublists ================
;string "%1:%2  %3  %4  %5:%6",0

db_comp_sb1 label dword 		;an000;comp argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg1		;an000;point to comp_arg1
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb2 label dword 		;an000;comp argument parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg2		;an000;point to comp_arg2
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb3 label dword 		;an000;comp argument parameter 3
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg3		;an000;point to comp_arg3
	db	03			;an000;parameter three
	db	right_align+bin_hex_byte
					;an000;left align/byte/hexadecimal
	db	02			;an000;maximum of 2 bytes
	db	02			;an000;minimum of 2 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb4 label dword 		;an000;comp argument parameter 4
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg4		;an000;point to comp_arg4
	db	04			;an000;parameter four
	db	right_align+bin_hex_byte
					;an000;left align/byte/hexadecimal
	db	02			;an000;maximum of 2 bytes
	db	02			;an000;minimum of 2 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb5 label dword 		;an000;comp argument parameter 5
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg5		;an000;point to comp_arg5
	db	05			;an000;parameter five
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb6 label dword 		;an000;comp argument parameter 6
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg6		;an000;
	db	06			;an000;parameter 6
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;======================= disk error parameter sublists ===================
;string: "%1 error %2 drive %3",0

db_disk_sb1 label dword 		;an000;disk argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:mestyp		;an000;point to mestyp
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_disk_sb2 label dword 		;an000;disk argument parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:iotyp		;an000;point to iotyp
	db	02			;an000;parameter two
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_disk_sb3 label dword 		;an000;disk argument parameter 3
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:drive		;an000;point to drive
	db	03			;an000;parameter three
	db	left_align+char_field_char
					;an000;left align/character/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

arg_buf_sb1 label dword 		;an000;argument sublist
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_Field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

one_char_sb1 label dword		;an000;character buffer sublist
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:one_char_buf 	;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_Field_Char
					;an000;left align/character/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

xm_han_sub	label	dword		;an000;sublist for handles
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_HANDLE_RET	;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_map_sub	label	dword		;an000;sublist for mappings
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_LOG		;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Byte;an000;
	db	02			;an000;maximum width
	db	02			;an000;minimum width
	db	30h			;an000;pad with zeros

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_PHY		;an000;parameter 2
	db	02			;an000;parameter 2
	db	right_align+Bin_Hex_Byte;an000;
	db	02			;an000;maximum width
	db	02			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_sta_sub	label	word		;an000;sublist for status
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_HANDLE_RET	;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_PAGE_CNT		;an000;parameter 2
	db	02			;an000;parameter 2
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_page_seg_sub label	word		;an000;sublist for frame seg status
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_PHY		;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Byte;an000;
	db	02			;an000;maximum width
	db	02			;an000;minimum width
	db	30h			;an000;pad with zeros

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_FRAME		;an000;parameter 2
	db	02			;an000;parameter 2
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_deall_sub	label	word		;an000;sublist for handle deallocation
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_DEALL_HAN 	;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Byte;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_unall_sub	label	word		;an000;sublist unallocated page report
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_ALLOC_PG		;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	20h			;an000;pad with blanks

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_TOTAL_PG		;an000;parameter 1
	db	02			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	20h			;an000;pad with zeros


xm_han_alloc_sub label	 word		 ;an000;sublist unallocated page report
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_HAN_ALLOC 	;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	20h			;an000;pad with blanks

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_HAN_TOTAL 	;an000;parameter 1
	db	02			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	20h			;an000;pad with zeros
;=========================================================================
;		    end parameter sublists
;=========================================================================


unassem_ln_ptr label word		;an000;"%1%2",0
	dw	0032			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_unassem_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


hex_ptr label	word			;an000;"%1:%2 %3",0
	dw	0033			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_hexarg_sb1	;an000;sublist
	dw	03			;an000;3 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


add_ptr label	word			;an000;"%1  %2",0
	dw	0034			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_hexadd_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer



single_reg_ptr label word		;an000;"%1 %2",13,10,":",0
	dw	0035			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_singrg_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer



register_ptr label word 		;an000;"%1=%2  ",0 ex: AX=FFFF
	dw	0036			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_regist_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


errmes_ptr label word			;an000;"%1 Error",0
	dw	0037			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_error_sb1 	;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


wrtmes_ptr label word			;an000;"Writing %1 bytes",0
	dw	0038			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_wrtmes_sb1	;an000;sublist
;C02	dw	01			;an000;1 sub
	dw	02			;an000;1 sub			   ;C02
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


loc_ptr label	word			;an000:"%1;%2=",0 ex:CX:0000
	dw	0039			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_locadd_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


little_ptr label word			;an000;"%1",0 ex:FF
	dw	0040			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_little_sb1	;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


big_ptr label	word			;an000;"%1",0
	dw	0041			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_big_sb1		;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


comp_ptr label	word			;an000;"%1:%2  %3  %4  %5:%6",0
	dw	0042			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_comp_sb1		;an000;sublist
	dw	06			;an000;6 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


arg_buf_ptr label	word		;an000;"%1"
	dw	0046			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:arg_buf_sb1		;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


one_char_buf_ptr label	word		;an000;"%1"
	dw	0047			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:one_char_sb1 	;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_unall_ptr	label	word		;an000;unallocated message report
	dw	0050			;an000;"%1 of a total %2 EMS pages
					;      have been allocated",cr,lf
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_UNALL_SUB 	;an000;sublist
	dw	02			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_han_alloc_ptr label	 word		;an000;unallocated message report
	dw	0051			;an000;"%1 of a total %2 EMS handles
					;      have been allocated",cr,lf
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_HAN_ALLOC_SUB	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_han_ret_ptr	label	word		;an000;prints handle created
	dw	0055			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_HAN_SUB		;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_mapped_ptr	label	word		;an000;prints log/phy pages
	dw	0056			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_MAP_SUB		;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err80_ptr	label	word		;an000;ems error message
	dw	0057			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err83_ptr	label	word		;an000;ems error message
	dw	0058			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err84_ptr	label	word		;an000;ems error message
	dw	0059			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err85_ptr	label	word		;an000;ems error message
	dw	0060			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err86_ptr	label	word		;an000;ems error message
	dw	0061			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err87_ptr	label	word		;an000;ems error message
	dw	0062			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err88_ptr	label	word		;an000;ems error message
	dw	0063			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err89_ptr	label	word		;an000;ems error message
	dw	0064			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err8a_ptr	label	word		;an000;ems error message
	dw	0065			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err8b_ptr	label	word		;an000;ems error message
	dw	0066			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err8d_ptr	label	word		;an000;ems error message
	dw	0067			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err8e_ptr	label	word		;an000;ems error message
	dw	0068			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err_gen_ptr	label	word		;an000;ems error message
	dw	0070			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_parse_err_ptr label	word		;an000;input error message
	dw	0071			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_status_ptr	label	word		;an000;prints status of EMS
	dw	0072			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_STA_SUB		;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_page_seg_ptr label	word		;an000;"Physical page %1 = Frame
					;	segment %2"
	dw	0075			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_PAGE_SEG_SUB	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_deall_ptr	label	word		;an000;"Handle %1 deallocated"

	dw	0076			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_DEALL_SUB 	;an000;sublist
	dw	01			;an000;1 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_errff_ptr	    label word		;an000;"EMS not installed"

	dw	0078			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;0 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

qmes_1 label	word			;
	dw	0090			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

qmes_2 label	word			;
	dw	0091			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

qmes_3 label	word			;
	dw	0092			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00
			;an000;no keyboard buffer
qmes_4 label	word			;
	dw	0093			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

qmes_5 label	word			;
	dw	0094			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text1	label	word
	dw	0100			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text2	label	word
	dw	0101			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text3	label	word
	dw	0102			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text4	label	word
	dw	0103			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text5	label	word
	dw	0104			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text6	label	word
	dw	0105			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

arg_buf 	db   80 dup (?) 	;an000;argument buffer
one_char_buf	db   ?			;an000;character buffer

opbuf	db	51h dup (?)

hex_arg1 dw	?
hex_arg2 dw	?

add_arg dw	?
sub_arg dw	?

single_reg_arg dw ?

reg_name dw	?
reg_contents dw ?

err_type db	3	dup(0)		;ac000;changed to hold bf,bp,etc.

wrt_arg1 dw	?
wrt_arg2 dw	?

loc_add dw	?

little_contents dw ?
big_contents dw ?

comp_arg1 dw	?
comp_arg2 dw	?
comp_arg3 dw	?
comp_arg4 dw	?
comp_arg5 dw	?
comp_arg6 dw	?

mestyp	dw	?
iotyp	dw	?
drive	db	?


DATA	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\debems.asm ===
PAGE	60,132 ;
	TITLE	DEBEMS.ASM - EMS DEBUGGER COMMANDS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DEBEMS.ASM
;
; DESCRIPTIVE NAME: DEBUGGING TOOL
;
; FUNCTION: PROVIDES USERS WITH ACCESS TO RUDIMENTARY EMS FACILITIES.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: DEBCOM2 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM3 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBASM  - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBUASM - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBMES  - CONTAINS ROUTINES CALLED BY DEBUG
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT EMS FUNCTIONS	DSM:6/24/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================
;
;   Change Log:
;
;     Date    Who   #			Description
;   --------  ---  ---	------------------------------------------------------
;   03/21/90  DIC  C04	Fixed Microsoft Bug #744 - A problem involving a
;                   			limitation on the total number of requested EMS memory
;                   			pages to 255.  This limit is now a 4-digit hexadecimal
;                   			number.
;   04/05/90  DIC  C05 MSFT #990 - "XS" command in debug always displays the
;                      default total handle of "FF" instead of the actual
;                      number.  This fix uses  func-54h, sub-func: 02h via
;                      EMS V4.0.
;   04/30/90  DIC  C06 MSFT # 994 - Debug does not use the "approved" means
;                      of checking EMS status.  This version uses a more
;                      traditional method of: (1) Attempting an OPEN on the
;                      guaranteed resource name of: EMMXXXX0 and (2) using
;                      IOCTL sub-functions (0) and (7) to determine if the
;                      name EMMXXXX0 actually represents a file or not.
;
;==============================================================================
INCLUDE DOSSYM.INC
include version.inc		; cas -- missing equates
include debug.inc


CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE

	extrn xm_page:word		   ;an000;page count to allocate  ;C04
		      ; allow max of 64K pages to allocate.		  ;C04
		      ; "xm_page" was an 8-bit quantity.		  ;C04

	extrn xm_log:byte			;an000;log. page to map
	extrn xm_phy:byte			;an000;phy. page to map
	extrn xm_handle:word			;an000;handle to map
	extrn xm_handle_ret:word		;an000;handle created

	extrn xm_page_cnt:word			;an000;page count
	extrn xm_handle_pages_buf:byte		;an000;holds handles and pages
	extrn xm_frame:word			;an000;EMS frame value
	extrn xm_deall_han:word 		;an000;handle to deallocate
	extrn xm_alloc_pg:word			;an000;pages allocated
	extrn xm_total_pg:word			;an000;total pages possible
	extrn xm_han_alloc:word 		;an000;handles allocated
	extrn xm_han_total:word 		;an000;total handles possible

	extrn	  xm_han_ret_ptr:word		;an000;prints handle created
	extrn	  xm_mapped_ptr:word		;an000;prints log/phy pages
	extrn	  xm_page_seg_ptr:word		;an000;Frame seg status
	extrn	  xm_deall_ptr:word		;an000;Handle deallocation
	extrn	  xm_unall_ptr:word		;an000;prints page status
	extrn	  xm_han_alloc_ptr:word 	;an000;print handle status

	extrn	  xm_err80_ptr:word		;an000;ems error message
	extrn	  xm_err83_ptr:word		;an000;ems error message
	extrn	  xm_err84_ptr:word		;an000;ems error message
	extrn	  xm_err85_ptr:word		;an000;ems error message
	extrn	  xm_err86_ptr:word		;an000;ems error message
	extrn	  xm_err87_ptr:word		;an000;ems error message
	extrn	  xm_err88_ptr:word		;an000;ems error message
	extrn	  xm_err89_ptr:word		;an000;ems error message
	extrn	  xm_err8a_ptr:word		;an000;ems error message
	extrn	  xm_err8b_ptr:word		;an000;ems error message
	extrn	  xm_err8d_ptr:word		;an000;ems error message
	extrn	  xm_err8e_ptr:word		;an000;ems error message
	extrn	  xm_errff_ptr:word		;an000;ems error message
	extrn	  xm_err_gen_ptr:word		;an000;ems error message
	extrn	  xm_parse_err_ptr:word 	;an000;input error message
	extrn	  xm_status_ptr:word		;an000;prints status of EMS

DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG

	public	  debems			;an000;entry point
	extrn	  std_printf:near		;an000;message retriever
	extrn	  gethx:near			;an000;ASCII to bin conversion
	extrn	  inbuf:near			;an000;input command line
	extrn	  scanb:near			;an000;scan off blanks
	extrn	  scanp:near			;an000;scan for parm
	extrn	  perr:near			;an000;print ^ error
	extrn	  geteol:near
	extrn	  crlf:near			;an000;prints a cr,lf

	IF	SYSVER
	ENDIF

DEBEMS: 					;an000;entry to module

	call SCANP				;an000;scan for M or S parm
;	$if  z					;an000;no parms found
	JNZ $$IF1
	     call XM_PARSE_ERROR		;an000;tell user of error
;	$else					;an000;
	JMP SHORT $$EN1
$$IF1:
	     mov  al,[si]			;an000;grab parm
	     cmp  al,"M"			;an000;is it MAP?
;	     $if  e				;an000;yes
	     JNE $$IF3
		  inc  si			;an000;point to next byte
		  call XM_EMS_MAP		;an000;
;	     $else				;an000;
	     JMP SHORT $$EN3
$$IF3:
		  cmp  al,"S"			;an000;is it a status check?
;		  $if  e			;an000;yes
		  JNE $$IF5
		       inc  si			;an000;point to next byte
		       call XM_EMS_STATUS	;an000;
;		  $else 			;an000;
		  JMP SHORT $$EN5
$$IF5:
		       cmp  al,"D"		;an000;Deallocate pages?
;		       $if  e			;an000;yes
		       JNE $$IF7
			    inc   si		;an000;point to next byte
			    call  XM_EMS_DEALL	;an000;
;		       $else			;an000;
		       JMP SHORT $$EN7
$$IF7:
			    cmp  al,"A" 	;an000;Allocate pages?
;			    $if  e		;an000;yes
			    JNE $$IF9
				 inc  si	;an000;point to next byte
				 call XM_EMS_ALLOC    ;an000;
;			    $else		;an000;
			    JMP SHORT $$EN9
$$IF9:
				call GETEOL	;an000;check out parm
;			    $endif		;an000;
$$EN9:
;		       $endif			;an000;
$$EN7:
;		  $endif			;an000;
$$EN5:
;	    $endif				;an000;
$$EN3:
;	$endif					;an000;
$$EN1:

	ret					;an000;return to caller



;=========================================================================
; XM_EMS_ALLOC	  :    This function will provide the user the
;		       capability to set and change EMS logical and
;		       physical pages within page frame 0.
;
;	Inputs:   none
;
;	Outputs:  EMS page frames set or altered
;
;	Date:	  6/24/87
;=========================================================================

XM_EMS_ALLOC	proc	near			;an000;XM functions

	call XM_GET_MAN_STATUS			;an000;see if EMS active
;	$if  nc 				;an000;EMS active
	JC $$IF16
	     call XM_PAGE_PROMPT		;an000;get pages to allocate
	     call XM_GET_HAN_ALLOC		;an000;allocate pages
	     mov  dg:XM_HANDLE_RET,dx		;an000;save handle returned
;	     $if  z				;an000;good return
	     JNZ $$IF17
		  pushf 			;an000;save our flags
		  call XM_DISP1 		;an000;tell user results
		  popf				;an000;restore our flags
;	     $else				;an000;
	     JMP SHORT $$EN17
$$IF17:
		  call XM_ERROR 		;an000;print error message
;	     $endif				;an000;
$$EN17:
;	$else					;an000;EMS not active
	JMP SHORT $$EN16
$$IF16:
	     call XM_ERROR			;an000;say why not active
;	$endif					;an000;
$$EN16:

	ret					;an000;return to caller

XM_EMS_ALLOC	  endp				;an000;


;=========================================================================
; XM_EMS_MAP	  :    This function will provide the user the
;		       capability to set and change EMS logical and
;		       physical pages within page frame 0.
;
;	Inputs:   none
;
;	Outputs:  EMS page frames set or altered
;
;	Date:	  6/24/87
;=========================================================================

XM_EMS_MAP	proc	near			;an000;XM functions

	call XM_GET_MAN_STATUS			;an000;see if EMS active
;	$if  nc 				;an000;EMS active
	JC $$IF22
	     call XM_LOG_PROMPT 		;an000;get logical page
	     call XM_PHY_PROMPT 		;an000;get physical page
	     call XM_HAN_PROMPT 		;an000;get handle
	     call XM_MAP_MEMORY 		;an000;map the page
;	     $if  z				;an000;good return
	     JNZ $$IF23
		  pushf 			;an000;save our flags
		  call XM_DISP2 		;an000;tell user results
		  popf				;an000;restore our flags
;	     $else				;an000;
	     JMP SHORT $$EN23
$$IF23:
		   call XM_ERROR		;an000;tell error
;	     $endif				;an000;
$$EN23:
;	$else					;an000;EMS not active
	JMP SHORT $$EN22
$$IF22:
	     call XM_ERROR			;an000;say why not active
;	$endif					;an000;
$$EN22:

	ret					;an000;return to caller

XM_EMS_MAP	  endp				;an000;

;=========================================================================
; XM_GET_MAN_STATUS :  This routine will determine if EMS is active for
;		       this session.
;
;	Called Procs:  none
;
;	Inputs:        none
;
;	Outputs:       Z  - no error
;		       NZ - error
;		       AH - error message number
;
;	Date:	       6/24/87
; C06 - DIC    4/30/90 This routine has been updated in order to employ
;                      a slightly more traditional method to determine the
;                      existence or absence of EMS.
;=========================================================================

std_emm_name   db      "EMMXXXX0",0     ;  C06 - Standard device name for the
                                        ;  C06 - Expanded Memory Manager.

XM_GET_MAN_STATUS proc near			;an000;see if EMS active

;   C06   	push	ds				;an000;save ds - we stomp it
;   C06   	mov	ax,00h				;an000;set ax to 0
;   C06   	mov	ds,ax				;an000;set ds to 0
;   C06   	cmp	ds:word ptr[067h*4+0],0 	;an000;see if int 67h is there
;   C06   	pop	ds				;an000;restore ds
;   C06   ;	$if	e				;an000;EMS not installed
;   C06   	JNE $$IF28
;   C06   		stc				;an000;flag no ems
;   C06   		mov	ah,XM_NOT_INST		;an000;signal EMS not installed
;   C06   ;	$else					;an000;
;   C06   	JMP SHORT $$EN28
;   C06   $$IF28:
;   C06   		call	XM_INSTALL_CHECK	;an000;see if EMS installed
;   C06   ;		$if	z			;AN000;IS EMS INSTALLED
;   C06   		JNZ $$IF30
;   C06   			clc			;AN000;EMS INSTALLED - FLAG IT
;   C06   ;		$else				;an000;
;   C06   		JMP SHORT $$EN30
;   C06   $$IF30:
;   C06   			stc			;AN000;FLAG EMS NOT INSTALLED
;   C06   			mov  ah,XM_NOT_INST	;an000;signal EMS not installed
;   C06   ;		$endif				;an000;
;   C06   $$EN30:
;   C06   ;	$endif					;an000;
;   C06   $$EN28:
;   C06   
;   C06   	RET					;AN000;RETURN TO CALLER

           push    ds                        ;  C06
           push    cs                        ;  C06
           pop     ds                        ;  C06
           mov     dx,offset std_emm_name    ;  C06 - Attempt to OPEN the 
           mov     ax,3d00h                  ;  C06 - Standard (guaranteed) EMM driver
           int     21h                       ;  C06 - name.  It might actually be a file.
           jc      emm_not_present           ;  C06 - If EMM driver is not present.
           
           ;  Otherwise, the name: EMMXXXX0 does exist, but it might turn out   C06
           ;  to be a file instead of the name of a device driver.              C06

           mov     bx,ax                     ;  C06 - Handle from the OPEN operation.
           mov     ax,4400h                  ;  C06 - Get device information
           int     21h                       ;  C06 - using traditional MSDOS method.
           jc      emm_not_present           ;  C06 - If error, then assume EMM does not exist.
           and     dx,80h                    ;  C06 - Is it a character device ?
           jz      emm_not_present           ;  C06 - NO--> Assume EMM is not present
           mov     ax,4407h                  ;  C06 - Request OUTPUT status
           int     21h                       ;  C06 - via traditional MSDOS method.
           jc      emm_not_present           ;  C06 - interpret as EMM-not-present.
           or      al,al                     ;  C06 - Device status ?
           jz      emm_not_present           ;  C06 - if EMM is not available
           
           ; since these tests have been passed, we can assume            C06
           ; that the EMMXXXX0 drive does indeed exist.                   C06

           mov     ah,03eh                   ;  C06 - Close out the EMM device handle
           int     21h                       ;  C06
           jc      emm_not_present           ;  C06 - Failure here is interpreted as:
                                             ;  C06 - EMM not available.
           call    XM_INSTALL_CHECK          ;  C06 - Do std EMS installation check.
           jnz     emm_not_present           ;  C06 - If EMS does not exist.
           clc                               ;  C06 - Successful return
           pop     ds                        ;  C06 - He gets restored.
           ret                               ;  C06

emm_not_present:

           stc                               ;  C06
           mov     ah,XM_NOT_INST            ;  C06 - error number
           pop     ds                        ;  C06
           ret                               ;  C06

XM_GET_MAN_STATUS endp				;an000;

;=========================================================================
; XM_PAGE_PROMPT :     This routine prompts the user for the number of
;		       pages to be allocated, if he desires a new handle.
;		       This routine will determine whether or not the other
;		       prompt messages will be displayed.
;
;	Called Procs:  STD_PRINTF
;		       XM_PARSE
;
;	Inputs:        none
;
;	Outputs:       XM_PAGE_FLAG
;		       XM_PAGE_BUF
;		       XM_PAGE
;
;	Date:	       6/24/87
;=========================================================================

XM_PAGE_PROMPT	  proc near			;an000;prompt user for number
						;      of pages to allocate
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;if parm found
	JZ $$IF34
;C04	     mov  cx,02 			;an000;bytes to parse
	     mov  cx,04 			;an000;bytes to parse	   ;C04
						;   (maximum entry of 64K) ;C04
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF35
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN35
$$IF35:
;C04		  mov  dg:XM_PAGE,dl		;an000;save page count
		  mov  word ptr dg:XM_PAGE,dx	;save page cnt (max=64K)  ;C04
;	     $endif				;an000;
$$EN35:
;	$else					;an000;
	JMP SHORT $$EN34
$$IF34:
	     call PERR				;an000;display ^ error
;	$endif					;an000;
$$EN34:

	ret					;an000;return to caller

XM_PAGE_PROMPT	  endp				;an000;


;=========================================================================
; XM_LOG_PROMPT :      This routine prompts the user for the number of the
;		       logical page that is to be mapped in EMS.  This
;		       routine will not be performed if a page count
;		       was specified.
;
;	Called Procs:  STD_PRINTF
;		       XM_PARSE
;
;	Inputs:        none
;
;	Outputs:       XM_LOG_BUF
;		       XM_LOG
;
;	Date:	       6/24/87
;=========================================================================


XM_LOG_PROMPT	  proc near			;an000;prompt user for the
						;      logical page to be
						;      mapped
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;parm entered
	JZ $$IF40
	     mov  cx,02 			;an000;bytes to parse
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF41
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN41
$$IF41:
		  mov  dg:XM_LOG,dl		;an000;save logical page
;	     $endif				;an000;
$$EN41:
;	$else					;an000;
	JMP SHORT $$EN40
$$IF40:
	     call PERR				;an000;display ^ error
;	$endif					;an000;
$$EN40:

	ret					;an000;return to caller

XM_LOG_PROMPT	  endp				;an000;


;=========================================================================
; XM_PHY_PROMPT :      This routine prompts the user for the number of the
;		       physical page that is to be mapped in EMS.  This
;		       routine will not be performed if a page count
;		       was specified.
;
;	Called Procs:  STD_PRINTF
;		       XM_PARSE
;
;	Inputs:        none
;
;	Outputs:       XM_PHY_BUF
;		       XM_PHY
;
;	Date:	       6/24/87
;=========================================================================


XM_PHY_PROMPT	  proc near			;an000;prompt user for the
						;      physical page to be
						;      mapped
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;parm found
	JZ $$IF46
	     mov  cx,02 			;an000;bytes to parse
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF47
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN47
$$IF47:
		  mov  dg:XM_PHY,dl		;an000;save logical page
;	     $endif				;an000;
$$EN47:
;	$else					;an000;
	JMP SHORT $$EN46
$$IF46:
	     call PERR				;an000;
;	$endif					;an000;
$$EN46:

	ret					;an000;return to caller

XM_PHY_PROMPT	  endp				;an000;


;=========================================================================
; XM_HAN_PROMPT :      This routine prompts the user for the number of the
;		       handle that the mapping is to occur on. This
;		       routine will not be performed if a page count
;		       was specified.
;
;	Called Procs:  STD_PRINTF
;		       XM_PARSE
;
;	Inputs:        none
;
;	Outputs:       XM_HAN_BUF
;		       XM_HAN
;
;	Date:	       6/24/87
;=========================================================================


XM_HAN_PROMPT	  proc near			;an000;prompt user for the
						;      handle to be mapped
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;prompt found
	JZ $$IF52
	     mov  cx,04 			;an000;bytes to parse
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF53
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN53
$$IF53:
		  mov  dg:XM_HANDLE,dx		;an000;save logical page
;	     $endif				;an000;
$$EN53:
;	$else					;an000;
	JMP SHORT $$EN52
$$IF52:
	     call PERR				;an000;display ^ error
;	$endif					;an000;
$$EN52:

	ret					;an000;return to caller

XM_HAN_PROMPT	  endp				;an000;



;=========================================================================
; XM_GET_HAN_ALLOC :   This routine will get a handle and allocate the
;		       requested number of pages to that handle.
;
;	Called Procs:  none
;
;	Inputs:        XM_PAGE - number of pages to allocate to handle
;
;	Outputs:       Z  - no error
;		       NZ - error
;		       DX - handle allocated
;
;	Date:	       6/24/87
;=========================================================================

XM_GET_HAN_ALLOC  proc near			;an000;create handle and alloc.
						;      requested pages.
	push bx 				;an000;save regs.
	mov  ah,EMS_HAN_ALLOC			;an000;function 43h
;C04	xor  bh,bh				;an000;clear byte
;C04	mov  bl,dg:XM_PAGE			;an000;number of pages to
	mov  bx,word ptr dg:XM_PAGE		;num of pages (64K limit) to;C04
						;      allocate
	int  67h				;an000;call EMS
	or   ah,ah				;an000;was there an error
	pop  bx 				;an000;restore regs.

	ret					;an000;return to caller

XM_GET_HAN_ALLOC  endp				;an000;

;=========================================================================
; XM_MAP_MEMORY :      This routine will map the requested logical page
;		       to the requested physical page in EMS.
;
;	Called Procs:  none
;
;	Inputs:        XM_PHY - physical page to map to
;		       XM_HAN - logical page to map
;
;	Outputs:       Z  - no error
;		       NZ - error
;		       page mapped
;
;	Date:	       6/24/87
;=========================================================================

XM_MAP_MEMORY	  proc near			;an000;map a logical page to
						;      a physical page in
						;      EMS
	push bx 				;an000;save regs.
	push dx 				;an000;
	mov  ah,EMS_MAP_MEMORY			;an000;function 44h
	mov  al,dg:XM_PHY			;an000;physical page to map
	xor  bh,bh				;an000;zero byte
	mov  bl,dg:XM_LOG			;an000;logical page to map
	mov  dx,dg:XM_HANDLE			;an000;handle to map page to
	int  67h				;an000;call EMS
	or   ah,ah				;an000;was there an error
	pop  dx 				;an000;restore regs.
	pop  bx 				;an000;

	ret					;an000;return to caller

XM_MAP_MEMORY	  endp				;an000;


;=========================================================================
; XM_DISP1 :	       This routine displays the current page frame and
;		       the handle created as a result of the allocate pages.
;
;	Called Procs:  STD_PRINTF
;
;	Inputs:        XM_FRAME_SEG	- page frame segment
;		       XM_HANDLE_RET	- created handle
;		       XM_PG_FRAME_PTR	- pointer to message
;		       XM_HAN_RET_PTR	- pointer to message
;
;	Outputs:       "Page Frame Segment : %1",0d,0a
;		       "Handle Created     : %1",0d,0a
;
;	Date:	       6/24/87
;=========================================================================

XM_DISP1	  proc near			;an000;display messages

	mov  dx,offset dg:XM_HAN_RET_PTR	;an000;"Handle Created    : "
	call STD_PRINTF 			;an000;call message ret.

	ret					;an000;return to caller

XM_DISP1	  endp				;an000;


;=========================================================================
; XM_DISP2 :	       This routine displays the logical page mapped and
;		       the physical page it was mapped to.
;
;	Called Procs:  STD_PRINTF
;
;	Inputs:        XM_MAPPED_PTR	- pointer to message
;		       XM_LOG		- logical page mapped
;		       XM_PHY		- physical page mapped
;
;	Outputs:       "Logical page %1 mapped to physical page %2",0d0a
;
;	Date:	       6/24/87
;=========================================================================

XM_DISP2	  proc near			;an000;display messages

	mov  dx,offset dg:XM_MAPPED_PTR 	;an000;"Logical page %1 mapped
						;	to physical page %2"
	call STD_PRINTF 			;an000;call message ret.

	ret					;an000;return to caller

XM_DISP2	  endp				;an000;

;=========================================================================
; XM_ERROR:	  This routine will determine what error we have by
;		  querying the result in the AH register.  It will then
;		  report the error to the user through STD_PRINTF
;
;	Called Procs:  STD_PRINTF
;
;	Inputs:        AH - error code
;
;	Outputs:       error message
;
;	Date:	       6/24/87
;=========================================================================

XM_ERROR	  proc near			;an000;error message printer

	mov	dx,offset dg:XM_ERR80_PTR	;an000;point to message
	cmp	ah,XM_ERR80			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR83_PTR	;an000;point to message
	cmp	ah,XM_ERR83			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR84_PTR	;an000;point to message
	cmp	ah,XM_ERR84			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR85_PTR	;an000;point to message
	cmp	ah,XM_ERR85			;an000;error message
	je	XM_ERROR_CONT			; print error


	mov	dx,offset dg:XM_ERR86_PTR	;an000;point to message
	cmp	ah,XM_ERR86			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR87_PTR	;an000;point to message
	cmp	ah,XM_ERR87			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR88_PTR	;an000;point to message
	cmp	ah,XM_ERR88			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR89_PTR	;an000;point to message
	cmp	ah,XM_ERR89			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR8A_PTR	;an000;point to message
	cmp	ah,XM_ERR8A			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR8B_PTR	;an000;point to message
	cmp	ah,XM_ERR8B			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR8D_PTR	;an000;point to message
	cmp	ah,XM_ERR8D			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR8E_PTR	;an000;point to message
	cmp	ah,XM_ERR8E			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERRFF_PTR	;an000;point to message
	cmp	ah,XM_NOT_INST			;an000;EMS not installed
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR_GEN_PTR	;an000;general error message

XM_ERROR_CONT:

	jmp STD_PRINTF 				;an000;call message ret.


XM_ERROR	  endp				;an000;

;=========================================================================
; XM_PARSE_ERROR :     This routine will display that an error has occurred
;		       on the input of the requested data.
;
;	Called Procs:  STD_PRINTF
;
;	Inputs:        XM_PARSE_ERR_PTR - error message
;
;	Outputs:       "Invalid value for parameter",0d,0a
;
;	Date:	       6/24/87
;=========================================================================

XM_PARSE_ERROR	  proc near			;an000;input error message

	mov  dx,offset dg:XM_PARSE_ERR_PTR	;an000;error message
	call STD_PRINTF 			;an000;call message ret.
	ret					;an000;return to caller

XM_PARSE_ERROR	  endp				;an000;



;=========================================================================
; XM_EMS_STATUS   :    This function will provide the user with
;		       a report the the current status of EMS.
;
;	Inputs:   none
;
;	Outputs:  EMS page frames set or altered
;
;	Date:	  6/24/87
;=========================================================================

XM_EMS_STATUS	proc	near			;an000;XM functions

	call XM_GET_MAN_STATUS			;an000;see if EMS active
;	$if  nc 				;an000;EMS active
	JC $$IF84
	     call XM_CURR_STATUS		;an000;current status of EMS
;	$else					;an000;EMS not active
	JMP SHORT $$EN84
$$IF84:
	     call XM_ERROR			;an000;say why not active
;	$endif					;an000;
$$EN84:

	ret					;an000;return to caller

XM_EMS_STATUS	  endp				;an000;


;=========================================================================
; XM_CURR_STATUS :	This routine will display the current status of
;			all active EMS handles.
;
;	Inputs	 :	none
;
;	Outputs  :	Current status of all active EMS handles
;			"Handle %1 has %2 pages allocated"
;
;			Physical page with it associated frame segment
;			"Physical page %1 = Frame segment %2"
;
;	Date:	       8/05/86
;=========================================================================

XM_CURR_STATUS		proc	near		;an000;current EMS status

	mov  ah,EMS_HANDLE_PAGES		;an000;get handle pages
	mov  di,offset dg:XM_HANDLE_PAGES_BUF	;an000;point to the buffer
	int  67h				;an000;

	or   ah,ah				;an000;see if an error occurred
;	$if  z					;an000;no error
	JNZ $$IF87
;	     $do				;an000;do while data in buffer
$$DO88:
		  cmp  bx,0			;an000;end of buffer?
;		  $leave  e			;an000;yes
		  JE $$EN88
		       mov  ax,word ptr es:[di] ;an000;page handle
		       mov  dg:XM_HANDLE_RET,ax ;an000;save in var
		       mov  ax,word ptr es:[di+02];an000;page count
		       mov  dg:XM_PAGE_CNT,ax	;an000;save in var
		       mov  dx,offset dg:XM_STATUS_PTR ;an000;point to message
		       call STD_PRINTF		;an000;print it
		       add  di,04h		;an000;next record
		       dec  bx			;an000;decrement counter
;	     $enddo				;an000;
	     JMP SHORT $$DO88
$$EN88:

	     call  CRLF 			;an000;place a blank line
						;      between reports

	     call  XM_FRAME_BUFFER		;an000;get frame buffer
						;ES:DI points to frame buffer
;	     $do				;an000;while cx not = 0
$$DO91:
		  cmp  cx,00			;an000;at end?
;		  $leave e			;an000;yes
		  JE $$EN91
		       call  XM_GET_FRAME_SEG	;an000;obtain page and seg
		       mov   dx,offset dg:XM_PAGE_SEG_PTR  ;an000;message
		       call  STD_PRINTF 	;an000;print it
		       dec   cx 		;an000;decrease counter
		       add   di,04		;an000;adjust pointer
;	     $enddo				;an000;
	     JMP SHORT $$DO91
$$EN91:

	     call  XM_UNALL_COUNT		;an000;display page status
	     call  XM_HANDLE_COUNT		;an000;display handle status

;	$else
	JMP SHORT $$EN87
$$IF87:
	     call  XM_ERROR			;an000;display the error
;	$endif					;an000;
$$EN87:
	ret					;an000;

XM_CURR_STATUS		endp			;an000;

;=========================================================================
; XM_UNALL_COUNT :	This routine generates a line of the status report
;			displaying the number of pages allocated out of
;			the total possible
;
;	Inputs	 :	none
;
;	Outputs  :	Current status of allocated pages
;			"%1 of a total %2 EMS pages have been allocated"
;
;	Date:	       8/05/86
;=========================================================================

XM_UNALL_COUNT		proc	near		;an000;

	mov	ah,EMS_UNALL_PG_CNT		;an000;see how many pages
						;      remaining
	int	67h				;an000;
	or	ah,ah				;an000;see if error

;	$if	z				;an000;no error
	JNZ $$IF96
		push	bx			;an000;save bx
		push	dx			;an000;save dx
		call	CRLF			;an000;
		pop	dx			;an000;restore dx
		pop	bx			;an000;restore bx
		mov	ax,dx			;an000;total page count
		sub	ax,bx			;an000;get pages allocated
		mov	dg:XM_ALLOC_PG,ax	;an000;save allocated pages
		mov	dg:XM_TOTAL_PG,dx	;an000;save total page count
		mov	dx,offset dg:XM_UNALL_PTR ;an000;"%1 of a total %2 EMS
						;      pages have been allocated",cr,lf
		call	STD_PRINTF		;an000;print it
;	$endif					;an000;
$$IF96:

	ret					;an000;

XM_UNALL_COUNT		endp			;an000;


;=========================================================================
; XM_HANDLE_COUNT:	This routine generates a line of the status report
;			displaying the number of handles allocated out of
;			the total possible.
;
;	Inputs	 :	none
;
;	Outputs  :	Current status of allocated pages
;			"%1 of a total %2 EMS handles have been allocated"
;
;	Date:	       8/05/86
;=========================================================================

XM_HANDLE_COUNT 	proc	near		;an000;

	mov	ah,EMS_HANDLE_CNT		;an000;see how many handles
                  						;      possible
 int 67h                ; C05 - Request total currently allocated.
 or  ah,ah              ; C05 - 
 jnz $$IF98             ; C05 - If error
 mov word ptr dg:XM_HAN_ALLOC,bx ; C05 - save total number of active handles.
 mov ax,EMS_TOT_HANDLES         ; C05 - Request total handles possible for
                                ; C05 - EMS 4.0
	int	67h				;an000;
	or	ah,ah				;an000;see if error

;	$if	z				;an000;no error
	JNZ $$IF98
;C05      		mov	ax,EMS_HANDLE_TOTAL	;an000;total possible handles
  mov ax,bx                     ;C05 - Total possible handles for EMS 4.0

		mov	dg:XM_HAN_TOTAL,ax	;an000;save total page count
;C05      		mov	dg:XM_HAN_ALLOC,bx	;an000;save allocated pages
  mov bx,dg:XM_HAN_ALLOC           ; C05 - This may not be needed.
		mov	dx,offset dg:XM_HAN_ALLOC_PTR
						;an000;"%1 of a total %2 EMS
						;      handles have been allocated",cr,lf
		call	STD_PRINTF		;an000;print it
;	$endif					;an000;
$$IF98:

	ret					;an000;

XM_HANDLE_COUNT 	endp			;an000;


;=========================================================================
; XM_FRAME_SEG	 :	This routine accesses the vector created by
;			function 58h, int 67h.	It obtains a physical
;			page of EMS and its segment from this vector
;
;	Inputs	 :	ES:DI - points to frame buffer
;
;	Outputs  :	XM_PHY - a physical page in EMS
;			XM_FRAME - segment corresponding to the physical page
;
;	Date:	       8/05/86
;=========================================================================


XM_GET_FRAME_SEG	proc	near		;an000;find the frame segment

	mov	al,byte ptr es:[di+2]		;an000;get physical page
	mov	dg:XM_PHY,al			;an000;place in print var
	mov	ax,word ptr es:[di]		;an000;get frame segment
	mov	dg:XM_FRAME,ax			;an000;place in print var

	ret					;an000;

XM_GET_FRAME_SEG	endp			;an000;

;=========================================================================
; XM_INSTALL_CHECK:	This routine performs function 51h, int 67h to
;			determine if EMS is indeed active.
;
;	Inputs	 :	XM_FRAME_BUFFER - used to receive physical page
;					  and segment data for EMS.
;
;	Outputs  :	XM_FRAME_BUFFER - buffer holds physical page
;					  and segment data for EMS.
;
;	Date:	       8/05/86
;=========================================================================

XM_INSTALL_CHECK	proc	near		;an000;see if EMS installed

	MOV	AH,EMS_GET_MAN_STAT		;AN000;GET EMS STATUS
	XOR	AL,AL				;an000;clear low byte
	INT	67h				;an000;
	OR	AH,AH				;an000;check for error
;	$IF	Z				;an000;no error
	JNZ $$IF100
		MOV	AH,EMS_VERSION		;an000;get version number
		INT	67h			;an000;
		CMP	AL,EMS_LIM_40		;an000;LIM 4.0 ?
;		$IF	AE			;an000;4.0 or greater
		JNAE $$IF101
			MOV	AH,00h		;an000;set up for flag pass
			OR	AH,AH		;an000;set flag to ZR
;		$ELSE				;an000;below 4.0
		JMP SHORT $$EN101
$$IF101:
			MOV	AH,01h		;an000;set up for flag pass
			OR	AH,AH		;an000;set flag to NZ
;		$ENDIF				;an000;
$$EN101:
;	$ENDIF					;an000;
$$IF100:

	ret					;an000;

XM_INSTALL_CHECK	endp			;an000;




;=========================================================================
; XM_EMS_DEALL	:	This routine deallocates handles from EMS.
;
;	Inputs	 :	DX - Handle supplied by XM_DEALL_PROMPT
;
;	Outputs  :	Good return - "Handle %1 deallocated"
;			Bad return  - message describing error
;
;	Date:	       8/05/86
;=========================================================================

XM_EMS_DEALL		proc	near		;an000;deallocate EMS pages

	call XM_GET_MAN_STATUS			;an000;see if EMS installed
;	$if  nc 				;an000;error?
	JC $$IF105
	     call XM_DEALL_PROMPT		;an000;prompt user for handle
	     mov  ah,EMS_PAGE_DEALL		;an000;function 45h, int 67h
	     int  67h				;an000;

	     or   ah,ah 			;an000;error?
;	     $if  nz				;an000;yes
	     JZ $$IF106
		  call XM_ERROR 		;an000;say why
;	     $else				;an000;
	     JMP SHORT $$EN106
$$IF106:
		  mov  dx,offset dg:XM_DEALL_PTR;an000;"Handle %1 deallocated"
		  call STD_PRINTF		;an000;print message
;	     $endif				;an000;
$$EN106:
;	$else					;an000;
	JMP SHORT $$EN105
$$IF105:
	     call XM_ERROR			;an000;print type of error
;	$endif					;an000;
$$EN105:

	ret					;an000;

XM_EMS_DEALL		endp			;an000;

;=========================================================================
; XM_DEALL_PROMPT :	This routine prompts the user for the handle to be
;			deallocated.  It converts the handle entered to
;			binary and passes it back to the caller in DX.
;
;	Inputs	 :	none
;
;	Outputs  :	DX - Handle to be deallocated.
;
;	Date:	       8/05/86
;=========================================================================

XM_DEALL_PROMPT 	proc	near		;an000;prompt user for handle
						;      to deallocate
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;parm found
	JZ $$IF111
	     mov  cx,04 			;an000;bytes to parse
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF112
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN112
$$IF112:
		  mov  dg:XM_DEALL_HAN,dx	;an000;save handle to deallocate
;	     $endif				;an000;
$$EN112:
;	$else					;an000;
	JMP SHORT $$EN111
$$IF111:
	     call PERR				;an000;display ^ error
;	$endif					;an000;
$$EN111:

	ret					;an000;return to caller

XM_DEALL_PROMPT 	endp			;an000;


;=========================================================================
; XM_FRAME_BUFFER	:	This routine obtains the frame buffer
;				of EMS pages.
;
;	Inputs	:	none
;
;	Outputs :	ES:DI - Pointer to frame array
;			CX    - Number of elements in array
;=========================================================================

XM_FRAME_BUFFER 	proc	near		;an000;

	mov	ax,EMS_PG_FRAME 		;an000;get frame buffer
	int	67h				;an000;

	ret					;an000;

XM_FRAME_BUFFER 	endp			;an000;


CODE	ENDS
	END	DEBEMS

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\deberr.asm ===
PAGE	80,132 ;
	TITLE	DEBERR.ASM - DEBUGGER DISK ERROR HANDLER
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;******************* START OF SPECIFICATIONS *****************************
;
; MODULE NAME:DEBERR.ASM
;
; DESCRIPTIVE NAME: DISK ERROR HANDLER
;
; FUNCTION: THIS ROUTINE IS A CATCHALL ERROR HANDLER.  IT PRIMARILY
;	    HANDLES DISK ERROR.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; INPUT: NA
;
; EXIT-NORMAL: NA
;
; EXIT-ERROR: NA
;
; INTERNAL REFERENCES:
;
;
; EXTERNAL REFERENCES:
;
; NOTES: THIS MODULE SHOULD BE PROCESSED WITH THE SALUT PRE-PROCESSOR
;	 WITH OPTIONS "PR".
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+DEBCONST+
;	      DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.0 - MESSAGE RETRIEVER IMPLEMENTED.  DMS:6/17/87
;
;
; COPYRIGHT: "MS DOS DEBUG Utility"
;	     "Version 4.00 (C) Copyright 1988 Microsoft"
;	     "Licensed Material - Property of Microsoft  "
;
;******************** END OF SPECIFICATIONS ******************************
;
;   Change Log:
;
;     Date    Who   #			Description
;   --------  ---  ---	------------------------------------------------------
;   03/27/90  DIC  C03	MSFT # 696 - DEBUG seemed to be reporting the wrong
;                      error after	attempting to reading logical sector zero
;                      on an SCO-XENIX boot diskette.  The message "Write
;                      Protect Error	Reading drive A." was displayed.
;*****************************************************************************

.XLIST
.XCREF
	include version.inc		; cas -- missing equates
	include syscall.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC
.CREF
.LIST

        INCLUDE debug.inc

FIRSTDRV EQU	"A"

CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
	EXTRN	RDFLG:BYTE
	EXTRN	DRVLET:BYTE
	EXTRN	dr1_ptr:word,dr2_ptr:word,dr3_ptr:word,dr4_ptr:word ;ac000
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	PARITYFLAG:BYTE
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
	ASSUME	CS:DG,DS:DG,ES:DG,SS:DG

	EXTRN	RESTART:NEAR
	PUBLIC	DRVERR, TRAPPARITY, RELEASEPARITY, NMIINT, NMIINTEND

TRAPPARITY:
	IF	IBMJAPAN
	    PUSH    BX
	    PUSH    ES
	    PUSH    DX			; save location of new offset
	    MOV     DX,OFFSET DG:NMIINT ; DS:DX has new interrupt vector
	    CALL    SWAPINT		; diddle interrupts
	    ASSUME  ES:NOTHING

	    MOV     WORD PTR [NMIPTR],BX ; save old offset
	    MOV     WORD PTR [NMIPTR+2],ES ; save old segment
	    POP     DX			; get old regs back
	    POP     ES			; restore old values
	    ASSUME  ES:DG

	    POP     BX
	    MOV     BYTE PTR [PARITYFLAG],0 ; no interrupts detected yet!
	    RET

SWAPINT:
	    PUSH    AX
	    MOV     AX,(GET_INTERRUPT_VECTOR SHL 8) + 2
	    INT     21H 		; Get old NMI Vector
	    MOV     AX,(SET_INTERRUPT_VECTOR SHL 8) + 2
	    INT     21h 		; let OS set new vector
	    POP     AX
	ENDIF
	RET

RELEASEPARITY:
	IF	IBMJAPAN
	    PUSH    DX
	    PUSH    DS
	    PUSH    BX
	    PUSH    ES
	    LDS     DX,DWORD PTR [NMIPtr] ; get old vector
	    CALL    SwapInt		; diddle back to original
	    POP     ES
	    POP     BX
	    POP     DS
	    POP     DX
	    MOV     [PARITYFLAG],0	; no interrupts possible!
	ENDIF
	RET

NMIInt:
	IF	IBMJAPAN
	    PUSH    AX			; save AX
	    IN	    AL,0A0H		; get status register
	    OR	    AL,1		; was there parity check?
	    POP     AX			; get old AX back
	    JZ	    NMICHAIN		; no, go chain interrupt
	    OUT     0A2H,AL		; reset NMI detector
	    MOV     CS:[PARITYFLAG],1	; signal detection
	    IRET
NMICHAIN:
	    JMP     DWORD PTR CS:[NMIPTR] ; chain the vectors
NMIPTR	    DD	    ?			; where old NMI gets stashed
	ENDIF
NMIINTEND:

DRVERR:

	or	al,al				;ac000;see if drive specified
;	$if	nz				;an000;drive specified
	JZ $$IF1
		add	byte ptr drvlet,firstdrv;ac000;determine drive letter
		cmp	byte ptr rdflg,write	;ac000;see if it is read/write
;		$if	z			;an000;it is write
		JNZ $$IF2
			mov	dx,offset dg:dr2_ptr	;an000;message
;		$else				;an000;it is read
		JMP SHORT $$EN2
$$IF2:
			mov	dx,offset dg:dr1_ptr	;an000;message
;		$endif				;an000;
$$EN2:
;	$else					;an000;write protect error
	JMP SHORT $$EN1
$$IF1:
		add	byte ptr drvlet,firstdrv;ac000;determine drive letter
		cmp	byte ptr rdflg,write	;ac000;see if it is read/write
;		$if	z			;an000;it is write
		JNZ $$IF6
			mov	dx,offset dg:dr4_ptr	;an000;message
;		$else				;an000;it is read
		JMP SHORT $$EN6
$$IF6:
			mov	dx,offset dg:dr1_ptr	;an000;message ;C03
;		$endif				;an000;
$$EN6:
;	$endif					;an000;
$$EN1:

; CLEAN OUT THE DISK...
	MOV	AH,DISK_RESET
	INT	21H

	JMP	RESTART
CODEEND:

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\debug.inc ===
;**************************************************************************
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;*									                                                               * 
;*  Change History:							                                                *
;*									                                                               *
;*  DATE   ID	MSFT#  STR#	      Descripton			                             *
;* ------ ----	----- -----  --------------------------------------------  *
;* 05APR90 C05	 990  ????   The XS command always returned a value of	    *
;*	                  		     (FF) for the total number of handles that	    *
;*                  			     are supported.  Now, for EMS V4.0, the	       *
;*			                       actual # of total handles will be displayed.  *
;*                  			     See also: DEBEMS.SAL module.		                *
;**************************************************************************

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DEBEQU.SAL
;
; DESCRIPTIVE NAME: EQUATES NEEDED BY DEBUG
;
; FUNCTION: PROVIDES EQUATES NEEDED BY DEBUG
;
; ENTRY POINT: NA
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES: NA
;
; EXTERNAL REFERENCES: NA
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- > 32 MB SUPPORT		DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================


; Version control switches moved to VERSION.INC

	INCLUDE SYSVER.INC

SETCNTC EQU	TRUE			; If this is FALSE, DEBUG will not set
					; the Control C int vector

PROMPT	EQU	"-"
FCB	EQU	5CH
EXEFCB	EQU	FCB
BUFLEN	EQU	80			; Maximum length of line input buffer
BPMAX	EQU	10			; Maximum number of breakpoints
BPLEN	EQU	5*BPMAX 		; Length of breakpoint table
REGTABLEN EQU	14			; Number of registers
SEGDIF	EQU	0
BUFSIZ	EQU	512

BXREG	EQU	"B"+5800H		; "BX"
BPREG	EQU	"B"+5000H		; "BP"
SIREG	EQU	"S"+4900H		; "SI"
DIREG	EQU	"D"+4900H		; "DI"
COMMA	EQU	2C00H
OPBUFLEN EQU	35

	IF	IBMVER
MASK_PORT   EQU     21H 		; 8259 interrupt control register
INT_MASK    EQU     11111111B		; Disable ALL interrupts
	ENDIF

CR	EQU	13			;CARRIAGE RETURN
LF	EQU	10			;LINE FEED
CHAR_TAB EQU	9			;TAB
CHAR_BACKSPACE EQU 8			;BACKSPACE CHARACTER
CHAR_EOF EQU	1AH			;END OF FILE CHARACTER
CHAR_RUBOUT EQU 7FH			;RUBOUT CHARACTER

CHAR_EQUAL EQU	"="			;CHARACTER EQUAL
CHAR_MINUS EQU	"-"			;MINUS CHARACTER
CHAR_BLANK EQU	" "			;BLANK CHARACTER
DOUBLE_QUOTE EQU '"'			;DOUBLE QUOTE CHARACTER
SINGLE_QUOTE EQU "'"			;SINGLE QUOTE CHARACTER
CHAR_COMMA EQU	","			;CHARACTER COMMA
CHAR_PERIOD EQU "."			;CHARACTER PERIOD
CHAR_COLON EQU	":"			;CHARACTER COLON
CHAR_SEMICOLON EQU ";"			;CHARACTER SEMICOLON
CHAR_LEFT_BRACKET EQU "["		;CHARACTER LEFT BRACKET
CHAR_AT_SIGN EQU "@"			;CHARACTER "AT" SIGN
CHAR_ZERO EQU	"0"			;CHARACTER ZERO

LOWER_A EQU	"a"			;LOWER CASE CHARACTER "a"
LOWER_Z EQU	"z"			;LOWER CASE CHARACTER "z"

UPPER_A EQU	"A"			;UPPER CASE CHARACTER "A"
UPPER_C EQU	"C"			;UPPER CASE CHARACTER "C"
UPPER_E EQU	"E"			;UPPER CASE CHARACTER "E"
UPPER_F EQU	"F"			;UPPER CASE CHARACTER "F"
UPPER_L EQU	"L"			;UPPER CASE CHARACTER "L"
UPPER_M EQU	"M"			;UPPER CASE CHARACTER "M"
UPPER_N EQU	"N"			;UPPER CASE CHARACTER "N"
UPPER_P EQU	"P"			;UPPER CASE CHARACTER "P"
UPPER_S EQU	"S"			;UPPER CASE CHARACTER "S"
UPPER_X EQU	"X"			;UPPER CASE CHARACTER "X"
UPPER_Z EQU	"Z"			;UPPER CASE CHARACTER "Z"
FOR_SLASH  EQU	'/'
Q_MARK	EQU	'?'

VEC_SING_STEP EQU 1			;ID OF THE SINGLE STEP VECTOR
VEC_BREAKPOINT EQU 3			;ID OF THE BREAKPOINT VECTOR
VEC_TERM_ADDR EQU 22H			;ID OF THE TERMINATE ADDRESS VECTOR
VEC_CTRL_BREAK EQU 23H			;ID OF THE CTRL BREAK EXIT ADDRESS VECTOR
VEC_CRIT_ERR EQU 24H			;ID OF THE CRITICAL ERROR HANDLER VECTOR
VEC_PRIMITIVE_DISK_READ EQU 25H 	;ID OF THE PRIMITAVE DISK READ VECTOR
VEC_PRIMITIVE_DISK_WRITE EQU 26H	;ID OF THE PRIMITAVE DISK WRITE VECTOR
GENERIC_IOCTL EQU 440DH 		;an000;Generic IOCtl function
READ_WRITE EQU	08H			;an000;read/write relative sectors
READ_SECTOR EQU 00H			;an000;currently unknown value
WRITE_SECTOR EQU 00H			;an000;currently unknown value

SET_DRIVEID_OPTION EQU 1		;AL VALUE FOR "PARSE FILENAME" FUNCTION
LSEEK_FROM_START EQU 0			;AL VALUE FOR "LSEEK" FUNCTION
LSEEK_EOF_OPTION EQU 2			;AL VALUE FOR "LSEEK" FUNCTION

;======================= EMS Equates Begin ===============================

EMS_GET_MAN_STAT equ 40h		;an000;function 40h, int 67h
EMS_UNALL_PG_CNT equ 42h		;an000;funciton 42h, int 67h
EMS_HAN_ALLOC equ 43h			;an000;function 43h, int 67h
EMS_MAP_MEMORY equ 44h			;an000;function 44h, int 67h
EMS_PAGE_DEALL equ 45h			;an000;function 45h, int 67h
EMS_VERSION equ 46h			;an000;function 46h, int 67h
EMS_SAVE_PAGE_MAP equ 47h		;an000;function 47h, int 67h
EMS_REST_PAGE_MAP equ 48h		;an000;function 48h, int 67h
EMS_HANDLE_CNT equ 4bh			;an000;function 4bh, int 67h
EMS_HANDLE_PAGES equ 4dh		;an000;function 4dh, int 67h
EMS_GET_SET_PG_MP equ 4eh		;an000;function 4eh, int 67h
EMS_TOT_HANDLES   equ 5402h ;  Function 54h, sub-func:02 Get total handles  ; C05
EMS_GET_PAGE_MAP equ 00h		;an000;sub function 00h of
EMS_PG_FRAME equ 5800h			;an000;function 58h, int 67h
					;      function 4eh, int 67h
EMS_SET_PAGE_MAP equ 01h		;an000;sub function 01h of
					;      function 4eh, int 67h
EMS_HANDLE_TOTAL equ 0ffh		;an000;total possible handles

EMS_LIM_40 equ	040h			;an000;LIM 4.0 I.D.

XM_ERR80 equ	80h			;an000;error message type
XM_ERR83 equ	83h			;an000;error message type
XM_ERR84 equ	84h			;an000;error message type
XM_ERR85 equ	85h			;an000;error message type
XM_ERR86 equ	86h			;an000;error message type
XM_ERR87 equ	87h			;an000;error message type
XM_ERR88 equ	88h			;an000;error message type
XM_ERR89 equ	89h			;an000;error message type
XM_ERR8A equ	8Ah			;an000;error message type
XM_ERR8B equ	8Bh			;an000;error message type
XM_ERR8D equ	8Dh			;an000;error message type
XM_ERR8E equ	8Eh			;an000;error message type
XM_ERR8F equ	8Fh			;an000;error message type
XM_NOT_INST equ 0ffh			;an000;EMS not inst

;======================= EMS Equates End =================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\debug\sysver.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


		   IF1
                       %OUT Including ..SYSVER.FAL..
		   ENDIF

SYSVER		   EQU	FALSE		; if true, i/o direct to bios
					; so DOS can be debugged


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcomp\dcompp.asm ===
PAGE	90,132			;AN000;A2
	TITLE	DCOMPP.SAL - DISKCOMP SYSTEM COMMAND LINE PARSER
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: DCOMPP.SAL
;
; DESCRIPTIVE NAME: Include the DOS system PARSER in the SEGMENT
;		    configuration expected by the modules of DISKCOMP.
;
;FUNCTION: The common code of the DOS command line PARSER is optimized by
;	   the setting of certain switches that cause the conditional
;	   assembly of only the required portions of the common PARSER.
;	   The segment registers are ASSUMED according to the type .COM.
;	   The Common PARSER is then INCLUDEd.
;
; ENTRY POINT: SYSPARSE, near
;
; INPUT:
;	ES - has seg id of the SEGMENT
;	     that contains the input control blocks,
;	     defined below.
;
;	DI - offset into ES of the PARMS INPUT BLOCK
;
;	DS - has seg id of the SEGMENT
;	     that contains the DOS input COMMAND
;	     string, which is originally presented at 81h
;	     in the PSP.
;
;	SI - offset into DS of the text of the DOS input COMMAND string
;	     as originally presented at 81H in the PSP.
;
;	DX - zero
;
;	CX - ordinal value, intially zero, updated on each subsequent call
;	     to the value returned in CX on the previous call.
;
;	CS - points to the segment containing the
;	     INCLUDE PARSE.ASM statement
;
;	DS - also points to the segment containing the INCLUDE
;	     PARSE.ASM statement.
;
; EXIT-NORMAL:	Output registers:
;	 AX - return code:
;	    RC_No_Error     equ     0	 ; No error
;	    RC_EOL	    equ     -1	 ; End of command line
;
;	 DX - Offset into ES of the selected RESULT BLOCK.
;	 BL - terminated delimiter code
;	 CX - new operand ordinal
;	 SI - set past scanned operand
;
; EXIT-ERROR: Output registers:
;	 AX - return code:
;	    RC_Too_Many     equ     1	 ; Too many operands
;	    RC_Op_Missing   equ     2	 ; Required operand missing
;	    RC_Not_In_SW    equ     3	 ; Not in switch list provided
;	    RC_Not_In_Key   equ     4	 ; Not in keyword list provided
;	    RC_Out_Of_Range equ     6	 ; Out of range specified
;	    RC_Not_In_Val   equ     7	 ; Not in value list provided
;	    RC_Not_In_Str   equ     8	 ; Not in string list provided
;	    RC_Syntax	    equ     9	 ; Syntax error
;
; INTERNAL REFERENCES:
;    ROUTINES: SYSPARSE:near (INCLUDEd in PARSE.ASM)
;
;    DATA AREAS: none
;
; EXTERNAL REFERENCES:
;    ROUTINES: none
;
;    DATA AREAS: control blocks pointed to by input registers.
;
; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT DCOMPP,NUL,;
;
;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;	 DISKCOMP.SAL.
;
;****************** END OF SPECIFICATIONS *****************************
	IF1				;AN000;
	    %OUT    COMPONENT=DISKCOMP, MODULE=DCOMPP.SAL... ;AN000;
	ENDIF				;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	INCLUDE PATHMAC.INC		;AN013;
CSEG	SEGMENT PARA PUBLIC 'CODE'	;AN000;
	ASSUME	CS:CSEG,DS:CSEG,ES:CSEG,SS:CSEG ;AN000;

	PUBLIC	SYSPARSE		;AN000;SUBROUTINE ENTRY POINT

INCSW	EQU	0			;AC013;DO NOT INCLUDE PSDATA.INC
FARSW	EQU	0			;AN000;CALL THE PARSER BY NEAR CALL
DATESW	EQU	0			;AN000;SUPPRESS DATE CHECKING
TIMESW	EQU	0			;AN000;SUPPRESS TIME CHECKING
FILESW	EQU	0			;AN000;SUPPRESS CHECK FILE SPECIFICATION
CAPSW	EQU	0			;AN000;SUPPRESS FILE TABLE CAPS
CMPXSW	EQU	0			;AN000;SUPPRESS CHECKING COMPLEX LIST
DRVSW	EQU	1			;AN000;DO SUPPORT DRIVE ONLY FORMAT
QUSSW	EQU	0			;AN000;SUPPRESS SUPPORT OF QUOTED STRING FORMAT
NUMSW	EQU	0			;AN000;SUPPRESS CHECKING NUMERIC VALUE
KEYSW	EQU	0			;AN000;SUPPRESS KEYWORD SUPPORT
SWSW	EQU	1			;AN000;DO SUPPORT SWITCHES
VAL1SW	EQU	0			;AN000;SUPPRESS SUPPORT OF VALUE DEFINITION 1
VAL2SW	EQU	0			;AN000;SUPPRESS SUPPORT OF VALUE DEFINITION 2
VAL3SW	EQU	0			;AN000;SUPPRESS SUPPORT OF VALUE DEFINITION 3
BASESW	EQU	1			;AN012;SPECIFY, PSDATA POINTED TO BY "DS"
	include version.inc   ; psdata.inc needs def of db_sp_hi, lo
	INCLUDE PSDATA.INC		;AN013;PARSER DATA AREA
	PATHLABL DCOMPP 		;AN013;
;.XLIST 				 ;AN000;
;.XCREF 				 ;AN000;
	INCLUDE PARSE.ASM		;AN000;
.LIST					;AN000;
.CREF					;AN000;
	PATHLABL DCOMPP 		;AN013;
CSEG	ENDS				;AN000;
	END				;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcomp\dcmpmacr.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	IF1				;AN000;
	    %OUT INCLUDING DCMPMACR.INC...;AN000;
	ELSE				;AN000;
;	    %OUT INCLUDING DCMPMACR.INC...
	ENDIF				;AN000;
;***************************************************************************;
;			     MACRO DEFINITION				    ;
;***************************************************************************;

HEADER	MACRO	TEXT		       ;;AN000;
.XLIST				       ;;AN000;
	SUBTTL	&TEXT		       ;;AN000;
.LIST				       ;;AN000;
	PAGE			       ;;AN000;
	ENDM			       ;;AN000;
;  =  =  =  =  =  =  =	=  =
DOSCALL 			   MACRO FUNC,SUBFUNC  ;;AN000;
				   IFNB <FUNC> ;;AN000;IS THERE ANY PARMS AT ALL?
				   IFNB <SUBFUNC> ;;AN000;
				   MOV AX,(FUNC SHL 8)+SUBFUNC ;;AN000;FUNC TO AH,SUBFUNC TO AL
				   ELSE    ;;AN000;SINCE THERE IS NO SUBFUNC
				   MOV AH,FUNC ;;AN000;
				   ENDIF   ;;AN000;
				   ENDIF   ;;AN000;
				   INT 21H ;;AN000;
				   ENDM    ;;AN000;
;  =  =  =  =  =  =  =	=  =
PRINT	MACRO	MESSAGE 		   ;;AN000;
				   MOV	   DI,OFFSET MESSAGE ;;AC000;
				   CALL    SENDMSG ;;AC000;
	ENDM					   ;;AN000;
;  =  =  =  =  =  =  =	=  =
.xlist						   ;AN000;
;INPUT	 MACRO	 MESSAGE
;				    PRINT   MESSAGE
;				    CALL PROMPT
;	 ENDM
.list						   ;AN000;
;	       $SALUT (0,16,22,36)
MY_TRACKLAYOUT MACRO		   ;;AN000;
	       LOCAL CSECT_F	   ;;AN000;
CSECT_F        DW    0		   ;;AN000;# OF SECTORS IN A TRACK. Currently 18 is max.
				   ;;  THE REST IS FOR FUTURE MEDIA
	       DW    1		   ;;AN000;1 ST SECTOR
	       DW    512	   ;;AN000;# OF BYTES
	       DW    2		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    3		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    4		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    5		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    6		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    7		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    8		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    9		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    10 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    11 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    12 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    13 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    14 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    15 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    16 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    17 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    18 	   ;;AN000;
	       DW    512	   ;;AN000;CURRENTLY 18 SECTORS/TRACK IS MAXIMUM
	       DW    19 	   ;;AN000;BELOW IS FOR THE FUTURE MEDIA.
	       DW    512	   ;;AN000;
	       DW    20 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    21 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    22 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    23 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    24 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    25 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    26 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    27 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    28 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    29 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    30 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    31 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    32 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    33 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    34 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    35 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    36 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    37 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    38 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    39 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    40 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    41 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    42 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    43 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    44 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    45 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    46 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    47 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    48 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    49 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    50 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    51 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    52 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    53 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    54 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    55 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    56 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    57 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    58 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    59 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    60 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    61 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    62 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    63 	   ;;AN000;
	       DW    512	   ;;AN000;
	       ENDM								;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcomp\dcomppar.asm ===
PAGE	90,132			;AN000;A2
	TITLE	DCOMPPAR.SAL - LOOK AT COMMAND LINE PARMS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: DCOMPPAR.SAL

; DESCRIPTIVE NAME: Handle the definition of the DOS command line parameters
;		    and the interface to the DOS system PARSER.

;FUNCTION: The static data areas are prescribed by the DOS system PARSER
;	   to define the several parameters presented to DISKCOMP.  These
;	   data areas are passed to the PARSER, and its responses checked
;	   to determine the nature of the user's specifications.  Any errors
;	   found in the user's parameters are defined in messages back
;	   to the user.

; ENTRY POINT: PARSER, near

; INPUT: (DOS COMMAND LINE PARAMETERS)

;	      [d:][path] DISKCOMP  [d: [d:]] [/1] [/8]

;	 WHERE
;	      [d:][path] - Path where the DISKCOMP command resides.

;	      [d:] - To specify the Source drive
;
;	      [d:] - To specify the Target drive
;
;	      [/1] - To compare only the first side of the diskette,
;		     regardless of the diskette or drive type.

;	      [/8] - To compare only the first 8 sectors per track,
;		     even if the first diskette contains 9/15 sectors
;		     per track.
;
;	Upon entry to PARSER in this module,
;	"CURRENT_PARM" = offset to start of parm text in command string
;	"ORDINAL" = initialized to zero
;	PSP+81H = text of DOS command line parms string

; EXIT-NORMAL:
;      "SOURCE_DRIVE" = CHAR OF FIRST DRIVE ID SPECIFIED, BLANK IF NONE
;      "TARGET_DRIVE" = CHAR OF SECOND DRIVE ID IF BOTH SPECIFIED, BLANK
;		   IF NONE OR ONLY ONE SPECIFIED
;      "USER_OPTION" = 01 ON IF /1, -1 IF /1 NOT SPECIFIED.
;      "USER_OPTION_8" = 01 ON IF /8, -1 IF /8 NOT SPECIFIED.

; EXIT-ERROR:
;      IF ERROR, ERROR MESSAGE IS DISPLAYED, AND "EXITFL" HAS "EXPAR".

; INTERNAL REFERENCES:
;    ROUTINES:
;	PARSER:NEAR Call the system Parser to decode command line
;	PARSE_ERROR:NEAR Display the appropriate Parse error message.

;    DATA AREAS:
;	The several parameter control blocks, defined by the System
;	PARSER interface, defining the DISKCOMP parameters.

; EXTERNAL REFERENCES:
;    ROUTINES:
;	SENDMSG:NEAR	Uses Msg Descriptor to drive message handler.
;	SYSPARSE:NEAR	System Command Line Common Parser.

;    DATA AREAS:
;	EXITFL:BYTE	Errorlevel return code.
;	MSGNUM_PARSE:WORD Message descriptor for all parse errors.
;	USER_OPTION:BYTE /1 parm indicator
;	USER_OPTION_8:BYTE /8 parm indicator
;	SOURCE_DRIVE:BYTE character of first specified drive
;	TARGET_DRIVE:BYTE character of second specified drive

; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:

;		SALUT DCOMPPAR,NUL

;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.

;	 For LINK instructions, refer to the PROLOG of the main module,
;	 DISKCOMP.SAL.

;****************** END OF SPECIFICATIONS *****************************
	IF1				;AN000;
	    %OUT    COMPONENT=DISKCOMP, MODULE=DCOMPPAR.SAL... ;AN000;
	ENDIF				;AN000;
	INCLUDE PATHMAC.INC		;AN013;
	INCLUDE DCMPMACR.INC
; =  =	=  =  =  =  =  =  =  =	=  =
HEADER	MACRO	TEXT			;;AN000;
.XLIST					;AN000;
	SUBTTL	TEXT			;AN000;
.LIST					;AN000;
	PAGE				;;AN000;
	ENDM				;;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
;		      $SALUT (4,23,28,36) ;AN000;
CHAR_A		      EQU  "A"	   ;AN000;ASCII VALUE OF CHARACTER "A"
NUL		      EQU  0	   ;AN003;ASCIIZ STRING DELIMITER
;		EXIT CODES FROM SYSPARSE (WHEN CY=0)

SYSPRM_EX_OK	      EQU  0	   ;AN000; no error
SYSPRM_EX_MANY	      EQU  1	   ;AN000; too many operands
SYSPRM_EX_MISSING     EQU  2	   ;AN000; required operand missing
SYSPRM_EX_NOT_SWLIST  EQU  3	   ;AN000; not in switch list provided
SYSPRM_EX_NOT_KEYLIST EQU  4	   ;AN000; not in keyword list provided
SYSPRM_EX_RANGE       EQU  6	   ;AN000; out of range specified
SYSPRM_EX_VALUE       EQU  7	   ;AN000; not in value list provided
SYSPRM_EX_STRING      EQU  8	   ;AN000; not in string list provided
SYSPRM_EX_SYNTAX      EQU  9	   ;AN000; syntax error
SYSPRM_EX_EOL	      EQU  -1	   ;AN000; end of command line
; =  =	=  =  =  =  =  =  =  =	=  =
		      HEADER <STRUC - DEFINITIONS OF EXTERNAL CONTROL BLOCKS> ;AN000;
PSP		      STRUC	   ;AN000;
		      DB   80H DUP (?) ;AN000;SKIP OVER FIRST HALF OF PSP
PSP_PARMLEN	      DB   ?	   ;AN000;NUMBER OF BYTES IN DOS COMMAND LINE
PSP_COMMAND	      DB   127 DUP(?) ;AN000;TEXT OF DOS COMMAND LINE
PSP		      ENDS	   ;AN000;

MSG_DESC	      STRUC	   ;AN003;
MSG_NUM 	      DW   ?	   ;AN003;MESSAGE NUMBER (TO AX)
MSG_HANDLE	      DW   ?	   ;AN003;HANDLE OF OUTPUT DEVICE (TO BX)
MSG_SUBLIST	      DW   ?	   ;AN003;POINTER TO SUBLIST (TO SI)
MSG_COUNT	      DW   ?	   ;AN003;SUBSTITUTION COUNT (TO CX)
MSG_CLASS	      DW   ?	   ;AN003;MESSAGE CLASS (IN HIGH BYTE, TO DH)
				   ; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL);AN003;
MSG_DESC	      ENDS	   ;AN003;

ONE_SUBS	      EQU  1	   ;AN003;NUMBER OF VARIABLES

SUBLIST 	      STRUC	   ;AN000;
SUB_SIZE	      DB   ?	   ;AN003;SUBLIST SIZE (POINTER TO NEXT SUBLIST)
SUB_RES 	      DB   ?	   ;AN003;RESERVED
				   ;NEXT FIELD IS TO BE USED AS A DOUBLE WORD	   ;AN003;
SUB_VALUE	      DW   ?	   ;AN003;TIME, DATE, OR PTR TO DATA ITEM
SUB_VALUE_SEG	      DW   ?	   ;AN003;SEG ID OF PTR
				   ;(ABOVE FIELD MUST BE FILLED AT EXECUTION TIME  ;AN003;
				   ; IF THIS IS A .COM FILE)			   ;AN003;
SUB_ID		      DB   ?	   ;AN003;N OF %N
SUB_FLAGS	      DB   ?	   ;AN003;DATA TYPE FLAGS
SUB_MAX_WIDTH	      DB   ?	   ;AN003;MAXIMUM FIELD WIDTH (0=UNLIMITED)
SUB_MIN_WIDTH	      DB   ?	   ;AN003;MINIMUM FIELD WIDTH
SUB_PAD_CHAR	      DB   ?	   ;AN003;CHARACTER FOR PAD FIELD
				   ; CAN BE " ", "0" OR ",".			   ;AN003;
				   ; "," CAUSES INSERTION OF THE ACTIVE 	   ;AN003;
				   ; THOUSANDS SEPARATOR BETWEEN EVERY 3 DIGITS.   ;AN003;
SUBLIST 	      ENDS	   ;AN003;

; =  =	=  =  =  =  =  =  =  =	=  =
		      HEADER <PARSING WORKAREAS> ;AN000;
;	     $SALUT (4,14,19,36)   ;AN000;
	     EXTRN EXPAR:ABS	   ;AN000;ERRORLEVEL VALUE FOR BAD PARMS
	     EXTRN FINE:ABS	   ;AN000;RETURN STATUS INDICATOR
	     EXTRN MSGNUM_OPTIONS  : BYTE
	     EXTRN MSG_OPTIONS_FIRST: ABS
	     EXTRN MSG_OPTIONS_LAST: ABS

BLANK	     EQU  " "		   ;AN002;WIPE OUT SWITCH TO AVOID DUPLICATE

CSEG	     SEGMENT PARA PUBLIC 'CODE' ;AN000;
	     ASSUME CS:CSEG,DS:CSEG,ES:CSEG,SS:CSEG ;AN000;

	     EXTRN SENDMSG:NEAR    ;AN000;USES MSG DESCRIPTOR TO DRIVE MESSAGE HANDLR
	     EXTRN SYSPARSE:NEAR   ;AN000;SYSTEM COMMAND LINE PARSER

	     EXTRN EXITFL:BYTE	   ;AN000;ERRORLEVEL RETURN CODE

	     EXTRN SOURCE_DRIVE:BYTE ;AN000;FIRST DRIVE LETTER SPECIFIED IN PARMS
	     EXTRN USER_OPTION:BYTE ;AN000;NO OPTION (-1)  /1 (1), INVALID (9)
NO_OPTION    EQU  -1		   ;AN000;OPTION NOT SPECIFIED
OPTION_1     EQU  1		   ;AN000;OPTION "/1" SPECIFIED
OPTION_8     EQU  1		   ;AN000;OPTION "/8" SPECIFIED
	     EXTRN USER_OPTION_8:BYTE ;AN000;NO OPTION (-1)  /8 (1), INVALID (9)

	     EXTRN MSGNUM_PARSE:WORD ;AN000;MESSAGE DESCRIPTOR FOR ALL PARSE ERRORS
	     EXTRN MSGNUM_INVALID_PARM2:WORD ;AN005;HELP MESSAGE DESCRIPTOR
	     EXTRN SUBLIST_PARSE:WORD ;AN003;POINTS TO INVALID PARM
; =  =	=  =  =  =  =  =  =  =	=  =

CURRENT_PARM DW   81H		   ;AN000;POINTER INTO COMMAND OF NEXT OPERAND
	     PUBLIC CURRENT_PARM   ;AN000;

ORDINAL      DW   0		   ;AN000;ORDINAL NUMBER OF WHICH PARM TO PARSE
	     PUBLIC ORDINAL	   ;AN000;

; =  =	=  =  =  =  =  =  =  =	=  =
	     HEADER <DOS COMMAND LINE PARSER CONTROL BLOCKS> ;AN000;

;INPUT PARAMETERS CONTROL BLOCK, POINTED TO BY ES:DI WHEN CALLING PARSER

	     PUBLIC PARMS	   ;AN000;LET LINK MAKE PARMS BLOCK ADDRESSABLE
PARMS	     LABEL BYTE 	   ;AN000;PARMS CONTROL BLOCK
	     DW   PARMSX	   ;AN000;POINTER TO PARMS EXTENSION
	     DB   0		   ;AN000; NUMBER OF STRINGS (0, 1, 2)
				   ; NEXT LIST WOULD BE EXTRA DELIM LIST
				   ;  (,& WHITESPACE ALWAYS)
				   ; NEXT LIST WOULD BE EXTRA END OF LINE LIST
				   ;  (CR,LF,0 ALWAYS)

;SYSTEM PARSER PARAMETER EXTENSION CONTROL BLOCK
PARMSX	     LABEL BYTE 	   ;AN000;PARMS EXTENSION CONTROL BLOCK
	     DB   0,2		   ;AN000; MIN, MAX POSITIONAL OPERANDS ALLOWED
	     DW   CONTROL_POS	   ;AN000; DESCRIPTION OF POSITIONAL 1
	     DW   CONTROL_POS	   ;AN000; DESCRIPTION OF POSITIONAL 2

	     DB   1		   ;AN000; MAX SWITCH OPERANDS ALLOWED
	     DW   CONTROL_SW	   ;AN000; DESCRIPTION OF SWITCH

	     DB   0		   ;AN000; MAX KEYWORD OPERANDS ALLOWED
				   ; THERE IS NO CONTROL BLOCK
				   ;  DEFINING KEYWORDS

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	     HEADER <POSITIONAL PARM DESCRIPTOR BLOCK> ;AN000;
;PARSER CONTROL BLOCK DEFINING THE ONLY POSITIONAL PARAMETER, OPTIONAL

;FIRST POSITIONAL PARAMETER IS:
;	[D:] - SPECIFY THE SOURCE DRIVE.

	     PUBLIC CONTROL_POS    ;AN000;LET LINK MAKE THIS ADDRESSABLE
CONTROL_POS  LABEL BYTE 	   ;AN000;FIRST POSITIONAL DESCRIPTOR FOR FILESPEC,
				   ; OPTIONAL
	     DW   0101H 	   ;AN000; CONTROLS TYPE MATCHED
				   ; SELECTED BITS: "DRIVE ONLY" AND "OPTIONAL"

				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE
				   ;   CHECKED)
				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0010H=IGNORE ":" AT END IN MATCH
				   ; 0002H=REPEATS ALLOWED
				   ; 0001H=OPTIONAL

	     DW   0000H 	   ;AN000;FUNCTION_FLAGS (NO CAPITALIZATION NEEDED)
				   ; 0001H=CAP RESULT BY FILE TABLE
				   ; 0002H=CAP RESULT BY CHAR TABLE
				   ; 0010H=REMOVE ":" AT END
	     DW   RESULT1	   ;AN000; RESULT BUFFER
	     DW   NOVALS	   ;AN000; NO VALUE LISTS
	     DB   0		   ;AN000; NUMBER OF KEYWORD/SWITCH SYNONYMS
				   ;   IN FOLLOWING LIST

;VALUE CONTROL BLOCK FOR THE POSITIONAL PARAMETERS
NOVALS	     DB   0		   ;AN000;NO VALUE DEFINITIONS

;RESULTS CONTROL BLOCK FOR THE POSITIONAL PARAMETER
RESULT1      LABEL BYTE 	   ;AN000; BELOW FILLED IN FOR DEFAULTS
	     DB   3		   ;AN000; TYPE RETURNED: 0=RESERVED,
				   ;	   1=NUMBER, 2=LIST INDEX,
				   ;	   3=STRING, 4=COMPLEX,
				   ;	   5=FILESPEC, 6=DRIVE
				   ;	   7=DATE, 8=TIME
				   ;	   9=QUOTED STRING
RESULT_TAG   DB   0FFH		   ;AN000; MATCHED ITEM TAG
	     DW   0		   ;AN000;POINTER TO SYNONYM

RESULT_PTR1  DB   ?		   ;AN000;DRIVE NUMBER (A=1, B=2, ETC)

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	     HEADER <SWITCH PARM DESCRIPTOR BLOCK> ;AN000;
;PARSER CONTROL BLOCK DEFINING THE TWO SWITCHES, OPTIONAL

;THE SWITCH IS "/1", MEANING ONLY COMPARE THE FIRST SIDE.
;THE SECOND SWITCH IS "/8", MEANING ONLY LOOK AT FIRST 8 SECTORS PER TRACK.

	     PUBLIC CONTROL_SW	   ;AN000;LET LINK MAKE THIS ADDRESSABLE
CONTROL_SW   LABEL BYTE 	   ;AN000;SWITCH DESCRIPTOR FOR /1 OR /8
	     DW   0000H 	   ;AN000; CONTROLS TYPE MATCHED
				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE
				   ;   CHECKED)
				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0010H=IGNORE ":" AT END IN MATCH
				   ; 0002H=REPEATS ALLOWED
				   ; 0001H=OPTIONAL

	     DW   0000H 	   ;AN000;FUNCTION_FLAGS (NO CAPITALIZATION)
				   ; 0001H=CAP RESULT BY FILE TABLE
				   ; 0002H=CAP RESULT BY CHAR TABLE
				   ; 0010H=REMOVE ":" AT END

	     DW   RESULTSW1	   ;AN000; RESULT BUFFER
	     DW   NOVALS	   ;AN000; VALUE LISTS
	     DB   3		   ;AN000; NUMBER OF KEYWORD/SWITCH SYNONYMS
				   ;   IN FOLLOWING LIST
SINGLE_SIDED LABEL BYTE 	   ;AN002;
SW_1	     DB   "/1",0	   ;AN000; IF n >0, KEYWORD 1
SW_8	     DB   "/8",0	   ;AN000;SECOND KEYWORD
SW_?	     DB   "/?",0           ; third switch

PUBLIC 	     Q_BREAK
Q_BREAK	     DB    0               ; flag saying we broke out early due to ?

;RESULTS CONTROL BLOCK FOR THE SWITCHES
RESULTSW1    LABEL BYTE 	   ;AN000; BELOW FILLED IN FOR DEFAULTS
	     DB   3		   ;AN000; TYPE RETURNED: 0=RESERVED,
				   ;	   1=NUMBER, 2=LIST INDEX,
				   ;	   3=STRING, 4=COMPLEX,
				   ;	   5=FILESPEC, 6=DRIVE
				   ;	   7=DATE, 8=TIME
				   ;	   9=QUOTED STRING
	     DB   0FFh		   ;AN000; MATCHED ITEM TAG

RESULTSWSYN  DW   0		   ;AN000; SYNONYM POINTER (BASED ON ES:)
RESULT_PTR2  DD   ?		   ;AN000; OFFSET OF STRING VALUE
; =  =	=  =  =  =  =  =  =  =	=  =
	     PATHLABL DCOMPPAR	   ;AN013;
	     HEADER <PARSER - ASK SYSPARM TO DECODE PARAMETERS> ;AN000;
;  $SALUT (4,4,9,36)		   ;AN000;
PARSER PROC NEAR		   ;AN000;
   PUBLIC PARSER		   ;AN000;

;INPUT: "CURRENT_PARM" = OFFSET TO NEXT PARM IN COMMAND STRING
;	"ORDINAL" = COUNT OF NEXT PARM TO PARSE
;	PSP+81H = TEXT OF DOS COMMAND LINE PARMS STRING
;OUTPUT: "SOURCE_DRIVE" = A=1, B=2, 0 IF NONE
;	 "TARGET_DRIVE" = A=1, B=2, 0 IF NONE
;	 "USER_OPTION" = 01 ON IF /1, -1 IF /1 NOT SPECIFIED.
;	 "USER_OPTION_8" = 01 ON IF /8, -1 IF /8 NOT SPECIFIED.
;	IF ERROR, ERROR MESSAGE IS DISPLAYED, AND "EXITFL" HAS "EXPAR".
; =  =	=  =  =  =  =  =  =  =	=  =
   MOV	USER_OPTION,NO_OPTION	   ;AN000;SET DEFAULT, SWITCH NOT FOUND
   MOV	USER_OPTION_8,NO_OPTION    ;AN000;SET DEFAULT, SWITCH NOT FOUND

   JMP SHORT $$SS1
$$DO1:
				   ;LOOKING AT RETURN CODE FROM SYSPARSE...	;AN000;
       CMP  AX,SYSPRM_EX_OK	   ;AN000;WERE THERE ANY ERRORS?
   JE $$IF1
       CALL PARSE_ERROR 	   ;AN000;DISPLAY REASON FOR ERROR

   JMP $$SR1
$$IF1:
       MOV  ORDINAL,CX		   ;AN000;SAVE UPDATED COUNT
       MOV  CURRENT_PARM,SI	   ;AN000;REMEMBER HOW FAR I GOT
       MOV  BX,DX		   ;AN000;SET DATA BASE REG TO POINT TO THIS OPERAND
       CMP  BX,OFFSET RESULT1	   ;AN000;WAS POSITIONAL PARM SPECIFIED?
       JNE $$IF4
	   MOV	SI,CX		   ;AN000;USE COUNT OF POSITIONALS AS INDEX
	   MOV	AL,RESULT_PTR1	   ;AN000;GET VALUE OF DRIVE (A=1, B=2, ETC)
	   MOV	SOURCE_DRIVE-1[SI],AL ;AN000;SAVE RESPONSE DRIVE VALUE
				   ;IN EITHER SOURCE_DRIVE OR TARGET_DRIVE
				   ;ACCORDING TO ORDINAL IN SI (FROM CX)
        			   ;AN000;SINCE NOT POSITIONAL PARM SPECIFIED
       JMP SHORT $$EN4
$$IF4:
	   MOV  AL,SW_?+BYTE
	   MOV	BX,RESULTSWSYN
	   CMP	[BX]+BYTE,AL
	   JNE  NXT
	   CALL DISPLAY_OPTIONS	   ; display the options message lines
	   MOV	EXITFL,0           ; EXOK= 0
	   MOV  Q_BREAK,1          ; set a flag for "begin" to check saying
                                   ; we broke out early because of a /? option
	   MOV  DX,FINE            ; say that parsing went ok
	   JMP  $$SR1

NXT:	   MOV	AL,SINGLE_SIDED+BYTE ;AN000;GET ID PORTION OF SWITCH
	   MOV	BX,RESULTSWSYN	   ;AN000;GET OFFSET TO MATCHING SWITCH
	   CMP	[BX]+BYTE,AL	   ;AN000;WAS IT /1?
				   ;AN000;YES IT WAS /1
	   JNE $$IF6
	       MOV  SW_1,BLANK	   ;AN002;AVOID GETTING /1 AGAIN
	       MOV  USER_OPTION,OPTION_1 ;AN000;MUST HAVE BEEN THE SWITCH, /1
				   ;AN000;SINCE IT WAS NOT /1, MUST BE /8
	   JMP SHORT $$EN6
$$IF6:
	       MOV  SW_8,BLANK	   ;AN002;AVOID GETTING /8 AGAIN
	       MOV  USER_OPTION_8,OPTION_8 ;AN000;REPORT BACK, IT WAS /8
$$EN6:
$$EN4:
$$SS1:
       LEA  DI,PARMS		   ;AN000; ES:DI = PARSE CONTROL DEFINITON
       MOV  SI,CURRENT_PARM	   ;AN000; DS:SI = COMMAND STRING, NEXT PARM
       XOR  DX,DX		   ;AN000; RESERVED, INIT TO ZERO
       MOV  CX,ORDINAL		   ;AN000; OPERAND ORDINAL, INITIALLY ZERO
       CALL SYSPARSE		   ;AN000;LOOK AT DOS PARMS
				   ; AX=EXIT CODE
				   ; BL=TERMINATED DELIMETER CODE
				   ; CX=NEW OPERAND ORDINAL
				   ; SI=SET TO PAST SCANNED OPERAND
				   ; DX=SELECTED RESULT BUFFER
       CMP  AX,SYSPRM_EX_EOL	   ;AN000; IS THAT THE END OF THE PARMS?
				   ;IF NOT, LOOP BACK AND FIND OUT
				   ; WHAT THAT PARM IS
				   ;AN000;END OF LIST
       JE   SKIPO
       JMP  $$DO1
SKIPO:  MOV  DX,FINE		   ;AN000;REPORT THAT PARSER WENT OK
				   ;AN000;FINISHED WITH DOS COMMAND LINE
$$SR1:
   RET				   ;AN000;RETURN TO CALLER
PARSER ENDP			   ;AN000;

	 HEADER <DISPLAY_OPTIONS - DISPLAY OPTIONS MSG>
; =  =	=  =  =  =  =  =  =  =	=  =
; SUBROUTINE NAME :  DISPLAY_OPTIONS                                          *
;                                                                             *
; INPUT 	  :  NONE						      *
;                                                                             *
; OUTPUT	  :  NONE                                                     *
;                                                                             *
; FUNCTION        :  Displays all the lines of the user options message on    *
;                    standard output.                                         *
;                                                                             *
; =  =	=  =  =  =  =  =  =  =	=  =

	PUBLIC	DISPLAY_OPTIONS
DISPLAY_OPTIONS	PROC NEAR

	push	di
	mov	di, offset MSGNUM_OPTIONS	; get message
DO_LOOP:
	call	SENDMSG			; send this line
	cmp	word ptr[MSGNUM_OPTIONS], MSG_OPTIONS_LAST	; last msg?
	je	DO_DONE			; done if so
	inc	word ptr[MSGNUM_OPTIONS]	; else bump msg number
	jmp	short DO_LOOP		; and go display it.
DO_DONE:
	pop	di
	ret

DISPLAY_OPTIONS	ENDP

; =  =	=  =  =  =  =  =  =  =	=  =
   HEADER <PARSE_ERROR - DISPLAY REASON FOR PARSE ERROR> ;AN000;
PARSE_ERROR PROC NEAR		   ;AN000;
;INPUT:  AX - ERROR NUMBER RETURNED FROM PARSE.
;	"CURRENT_PARM" - OFFSET INTO COMMAND OF WHERE TO START LOOKING FOR PARM
;OUTPUT: APPROPRIATE ERROR MESSAGE IS PREPARED FOR DISPLAY.
;	 DX IS SET TO OFFSET OF PARSE ERROR DESCRIPTOR.
; =  =	=  =  =  =  =  =  =  =	=  =

   MOV	MSGNUM_PARSE,AX 	   ;AN000;PASS MESSAGE NUMBER TO DESCRIPTOR
   MOV	EXITFL,EXPAR		   ;AN000;ERRORLEVEL CODE TO "PARM ERROR"
   MOV	AX,CURRENT_PARM 	   ;AN003;GET POINTER TO START OF BAD PARM
   CMP	SI,AX			   ;AN003;HAS THE INDEX TO COMMAND LINE MOVED?
;  $IF	NE			   ;AN003;YES, THERE IS A FAULTY PARM
   JE $$IF13
       MOV  BYTE PTR [SI],NUL	   ;AN003;DELIMIT THE BAD PARM
       MOV  SUBLIST_PARSE.SUB_VALUE,AX ;AN000;POINT SUBLIST TO BAD PARM

       MOV  MSGNUM_PARSE.MSG_SUBLIST,OFFSET SUBLIST_PARSE ;AN003;POINT TO SUBLIST
       MOV  MSGNUM_PARSE.MSG_COUNT,ONE_SUBS ;AN003;SET COUNT OF SUBLISTS TO ONE
;  $ENDIF			   ;AN003;INDEX MOVED?
$$IF13:
   MOV	DI,OFFSET MSGNUM_PARSE	   ;AC005;OFFSET TO PARSE ERR DESCRIPTOR
   CALL SENDMSG 		   ;AN005;DISPLAY ERROR MSG

   MOV	DX,OFFSET MSGNUM_INVALID_PARM2 ;AN005;PASS BACK OFFSET TO HELP MSG
   RET				   ;AN000;RETURN TO CALLER
PARSE_ERROR ENDP		   ;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
   PATHLABL DCOMPPAR		   ;AN013;
CSEG ENDS			   ;AN000;
   END				   ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcomp\dcompms.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;:util DISKCOMP 	    ;utility name
;:class 1		    ;DOS extended errors:
;:class 2		    ;parse errors:
;1  Too many parameters
;2  Required parameter missing
;3  Invalid switch
;4  Invalid keyword
;5  Parameter value not in allowed range
;6  Parameter value not allowed    [parse ret codes 6 and 7]
;7   (undefined)
;8  Parameter format not correct
;9   (undefined)
;10 Invalid parameter		   [no corresponding parse ret code]
;11 Invalid parameter combination  [no corresponding parse ret code]
;;
;:class A		    ;system messages
;
;:use 1 COMMON1 	    ;"Incorrect DOS version"
;
;:use 2 EXTEND8 	    ;"Insufficient memory"
;
;:use 3 PARSE10 	    ;"Invalid parameter"
;;
;:def 4 "Do not specify filename(s)",CR,LF
;"Command format: DISKCOMP d: d: [/1][/8]",LF,CR
;
;:def 5 CR,LF,"Invalid drive specification",CR,LF
;"Specified drive does not exist",CR,LF
;"or is non-removable",CR,LF
;
;:def 6 CR,LF,"Cannot DISKCOMP to or from",CR,LF
;"a network drive",CR,LF
;
;:def 7 CR,LF,"Insert FIRST diskette in drive %1:",CR,LF
;
;:def 8 CR,LF,"Insert SECOND diskette in drive %1:",CR,LF
;
;:def 9 CR,LF,"FIRST diskette bad or incompatible",CR,LF
;
;:def 10 CR,LF,"SECOND diskette bad or incompatible",CR,LF
;
;:use 11 EXTEND21	      ;"Drive not ready"            NOTE CHANGE %1 TO %0
;
;:use 12 COMMON28	      ;"Press any key to continue . . ."
;
;:use 13 EXTEND19  ;CR,LF,"Attempt to write to write-protected diskette",CR,LF
;
;:def 14 CR,LF,"Compare another diskette (Y/N) ?"
;
;:def 15 CR,LF,"Comparing %1 tracks",CR,LF
;"%2 sectors per track, %3 side(s)",CR,LF
;
;:def 16 CR,LF,"Drive types or diskette types",CR,LF
;"not compatible",CR,LF
;
;:def 17 CR,LF,"Unrecoverable read error on drive %2",CR,LF
;"side %3, track %4",CR,LF
;
;:def 18 CR,LF,"Compare error on",CR,LF,"side %3, track %4",CR,LF
;
;:def 19 "Make sure a diskette is inserted into",CR,LF
;"the drive and the door is closed",CR,LF
;
;:def 20 CR,LF,"Compare process ended",CR,LF
;
;:def 21 CR,LF,"Compare OK",CR,LF
;
;:def 22 CR,LF
;:end
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	IF1				;AN000;
	    %OUT    COMPONENT=DISKCOMP, MODULE=DCOMPMS.INC...;AN000;
	ENDIF				;AN000;
;	    $SALUT (0,13,18,22) ;						;AN000;
;THIS MODULE IS INCLUDED IN DCOMPSM.SAL.
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

FOUR_SUBS   EQU  4   ;AN000;FOUR VARIABLES IN ONE MSG
PC_ID_4     EQU  4   ;AN000;IDENTIFIES FOURTH REPLACEMENT PARM
PC_ID_5     EQU  5   ;AN000;IDENTIFIES FIFTH REPLACEMENT PARM
LETTER_A    EQU  "A" ;AN000;DEFAULT DRIVE ID
CLEAR_BUF   EQU  0C0H ;AN006;CLEAR KEYBOARD BUFFER BEFORE INPUT
KEY_IN_ECHO EQU  1   ;AN000;REQUEST KEYBOARD INPUT TO AL, ECHO RESPONSE
KEY_IN	    EQU  8   ;AN000;REQUEST KEYBOARD INPUT TO AL, NO ECHO
FILL_OFF    EQU  0   ;AN000;TO BE FILLED IN WITH OFFSET TO DATA
FILL_SEG    EQU  0   ;AN000;TO BE FILLED IN WITH THE COMMON SEG ID
		     ; SINCE A .COM FILE CANNOT HAVE
		     ; SEGMENT FIXUP RECORDS

SUBLIST_PARSE  SUBLIST <,,FILL_OFF,FILL_SEG,PC_ID_0,SF_BITS <SF_LEFT,,SF_ASCIIZ,SF_CHAR>,MAX_0,MIN_1,PAD_BLK> ;AN003;
	PUBLIC SUBLIST_PARSE	   ;AN003;

;		THE NEXT GROUP ARE ADDITIONAL CLASS "A" MESSAGES
;		SPECIFICALLY DEFINED FOR THE DISKCOMP UTILITY

		     ;"Insufficient memory"
MSGNUM_UNSUF_MEMORY MSG_DESC <2> ;AN000;
	PUBLIC MSGNUM_UNSUF_MEMORY ;AN000;

		     ;CR,LF,"Invalid parameter",CR,LF
MSGNUM_INVALID_PARM MSG_DESC <3> ;AN000;
	PUBLIC MSGNUM_INVALID_PARM ;AN000;

		     ;"Do not specify filename(s)",CR,LF
		     ;"Command format: DISKCOMP d: d: [/1][/8]",CR,LF
MSGNUM_INVALID_PARM2 MSG_DESC <4> ;AN000;
	    PUBLIC MSGNUM_INVALID_PARM2 ;AN000;

; = = = = = = = = = = = = = = = =
		     ;CR,LF,"Invalid drive specification",CR,LF
		     ;"Specified drive does not exist",CR,LF
		     ;"or is non-removable",CR,LF
MSGNUM_INVALID_DRV MSG_DESC <5> ;AN000;
	    PUBLIC MSGNUM_INVALID_DRV ;AN000;

; = = = = = = = = = = = = = = = =
		     ;CR,LF,"Cannot DISKCOMP to or from",CR,LF
		     ;"a network drive",CR,LF
MSGNUM_DRV_REDIRECTED MSG_DESC <6> ;AN000;
	    PUBLIC MSGNUM_DRV_REDIRECTED ;AN000;

; = = = = = = = = = = = = = = = =
		     ;CR,LF,"Insert FIRST diskette in drive %1:",CR,LF
MSGNUM_LOAD_FIRST MSG_DESC <7,,SUBLIST_78,ONE_SUBS> ;AN000;
	    PUBLIC MSGNUM_LOAD_FIRST,SUBLIST_78 ;AN000;

SUBLIST_78  SUBLIST <,,FILL_OFF,FILL_SEG,PC_ID_1,SF_BITS<SF_LEFT,,SF_CH,SF_CHAR>,MAX_0,MIN_1>;AN000;
;THE "FILL" FIELDS NEED TO BE SET TO POINT TO
;"ASCII_DRV1_ID" OR "ASCII_DRV2_ID"(BELOW).

		     ;CR,LF,"Insert SECOND diskette in drive %1:",CR,LF
MSGNUM_LOAD_SECOND MSG_DESC <8,,SUBLIST_78,ONE_SUBS> ;AN000;
	    PUBLIC MSGNUM_LOAD_SECOND ;AN000;

		     ;IF "FIRST" SPECIFIED
ASCII_DRV1_ID DB LETTER_A-BYTE ;AN000;

		     ;IF "SECOND" SPECIFIED
ASCII_DRV2_ID DB LETTER_A-BYTE ;AN000;
	    PUBLIC ASCII_DRV1_ID,ASCII_DRV2_ID ;AN000;

; = = = = = = = = = = = = = = = =
		     ;CR,LF,"FIRST diskette bad or incompatible",CR,LF
MSGNUM_BAD_FIRST  MSG_DESC <9> ;AN000;
	    PUBLIC MSGNUM_BAD_FIRST ;AN000;
; = = = = = = = = = = = = = = = =
		     ;CR,LF,"SECOND diskette bad or incompatible",CR,LF
MSGNUM_BAD_SECOND  MSG_DESC <10> ;AN000;
	    PUBLIC MSGNUM_BAD_SECOND ;AN000;
; = = = = = = = = = = = = = = = =
		     ;CR,LF,Drive not ready",CR,LF
MSGNUM_GET_READY MSG_DESC <11,,SUBLIST_11,ONE_SUBS> ;AN000;
	    PUBLIC MSGNUM_GET_READY ;AN000;

SUBLIST_11  SUBLIST <,,DRIVE_LETTER,FILL_SEG,PC_ID_0,SF_BITS<SF_LEFT,,SF_ASCIIZ,SF_CHAR>,MAX_0,MIN_1>;AN000;
	    PUBLIC SUBLIST_11 ;AN000;

DRIVE_LETTER DB  LETTER_A,":",NULL ;AN000;
	    PUBLIC DRIVE_LETTER ;AN000;

SKIP_MSG     DB  NULL ;AN000;
	    PUBLIC SKIP_MSG ;AN000;
; = = = = = = = = = = = = = = = =
		     ;CR,LF,"Press any key to continue . . .",CR,LF
MSGNUM_STRIKE MSG_DESC <12,,,,(CLASS_A SHL 8) OR (CLEAR_BUF + KEY_IN)> ;AN006;
	    PUBLIC MSGNUM_STRIKE ;AN000;
; = = = = = = = = = = = = = = = =
;		     ;CR,LF,"Attempt to write to write-protected diskette",CR,LF
MSGNUM_WRITE_PROTECT MSG_DESC <13> ;AN000;
	    PUBLIC MSGNUM_WRITE_PROTECT ;AN000;
; = = = = = = = = = = = = = = = =
		     ;CR,LF,"Compare another diskette (Y/N) ?"
MSGNUM_COMP_ANOTHER MSG_DESC <14,,,,(CLASS_A SHL 8) OR (CLEAR_BUF + KEY_IN_ECHO)> ;AN006;
	    PUBLIC MSGNUM_COMP_ANOTHER ;AN000;
; = = = = = = = = = = = = = = = =
		     ;CR,LF,"Comparing %1 tracks",CR,LF
		     ;"%2 Sectors/Track, %3 Side(s)",CR,LF
MSGNUM_COMPARING MSG_DESC <15,,SUBLIST_15A,THREE_SUBS> ;AN000;
	    PUBLIC MSGNUM_COMPARING ;AN000;

SUBLIST_15A SUBLIST <,,MSG_TRACKS,FILL_SEG,PC_ID_1,SF_BITS<SF_LEFT,,SF_WORD,SF_UN_BD>,MAX_0,MIN_1>;AN000;
SUBLIST_15B SUBLIST <,,MSG_SECTRK,FILL_SEG,PC_ID_2,SF_BITS<SF_LEFT,,SF_WORD,SF_UN_BD>,MAX_0,MIN_1>;AN000;
SUBLIST_15C SUBLIST <,,MSG_SIDES,FILL_SEG,PC_ID_3,SF_BITS<SF_LEFT,,SF_WORD,SF_UN_BD>,MAX_0,MIN_1>;AN000;
	    PUBLIC SUBLIST_15A,SUBLIST_15B,SUBLIST_15C ;AN000;

MSG_TRACKS  DW	 0   ;AN000;NUMBER OF TRACKS
MSG_SECTRK  DW	 0   ;AN000;NUMBER OF SECTORS PER TRACK
MSG_SIDES   DW	 0   ;AN000;NUMBER OF SIDES
	    PUBLIC MSG_TRACKS,MSG_SECTRK,MSG_SIDES ;AN000;
; = = = = = = = = = = = = = = = =
		     ;CR,LF,"Drive types or diskette types",CR,LF
		     ;"not compatible",CR,LF
MSGNUM_NOT_COMPATIBLE MSG_DESC <16> ;AN000;
	    PUBLIC MSGNUM_NOT_COMPATIBLE ;AN000;
; = = = = = = = = = = = = = = = =
		     ;CR,LF,"Unrecoverable read error on drive %2",CR,LF
		     ;"side %3, track %4",CR,LF
		     ;%2 IS "DRIVE_LETTER", AND
		     ;"MSG_SIDES" AND "MSG_TRACKS" ARE %3 AND %4.
MSGNUM_HARD_ERROR_READ MSG_DESC <17,,SUBLIST_17B,THREE_SUBS> ;AN000;
	    PUBLIC MSGNUM_HARD_ERROR_READ ;AN000;

SUBLIST_17B SUBLIST <,,DRIVE_LETTER,FILL_SEG,PC_ID_2,SF_BITS<SF_LEFT,,SF_ASCIIZ,SF_CHAR>,MAX_0,MIN_1>;AN000;
SUBLIST_17C SUBLIST <,,MSG_SIDES,FILL_SEG,PC_ID_3,SF_BITS<SF_LEFT,,SF_WORD,SF_UN_BD>,MAX_0,MIN_1> ;AN000;
SUBLIST_17D SUBLIST <,,MSG_TRACKS,FILL_SEG,PC_ID_4,SF_BITS<SF_LEFT,,SF_WORD,SF_UN_BD>,MAX_0,MIN_1>;AN000;
	    PUBLIC SUBLIST_17B,SUBLIST_17C,SUBLIST_17D ;AN000;

		     ;CR,LF,"Compare error on",CR,LF
		     ;"side %3, track %4",CR,LF
		     ;"MSG_SIDES" AND "MSG_TRACKS" ARE %3 AND %4.
MSGNUM_HARD_ERROR_COMP MSG_DESC <18,,SUBLIST_17C,TWO_SUBS> ;AN000;
	    PUBLIC MSGNUM_HARD_ERROR_COMP ;AN000;
; = = = = = = = = = = = = = = = =
		     ;:def 19 "Make sure a diskette is inserted into",CR,LF
		     ;"the drive and the door is closed",CR,LF
MSGNUM_CLOSE_DOOR MSG_DESC <19> ;AN004;
	    PUBLIC MSGNUM_CLOSE_DOOR ;AN004;
; = = = = = = = = = = = = = = = =
		     ;CR,LF,"Compare process ended",CR,LF
MSGNUM_FATAL_ERROR MSG_DESC <20> ;AN000;
	    PUBLIC MSGNUM_FATAL_ERROR ;AN000;
; = = = = = = = = = = = = = = = =
		     ;CR,LF,"Compare OK",CR,LF
MSGNUM_COMP_OK MSG_DESC <21> ;AN000;
	    PUBLIC MSGNUM_COMP_OK ;AN000;
; = = = = = = = = = = = = = = = =
		     ;CR,LF
MSGNUM_NEWLINE MSG_DESC <22> ;AC007;
	    PUBLIC MSGNUM_NEWLINE ;AN000;
; = = = = = = = = = = = = = = = =
			; Options help message

MSG_OPTIONS_FIRST	equ	300
MSG_OPTIONS_LAST	equ	303
	    PUBLIC MSG_OPTIONS_FIRST, MSG_OPTIONS_LAST

MSGNUM_OPTIONS MSG_DESC <MSG_OPTIONS_FIRST>
	    PUBLIC MSGNUM_OPTIONS
; = = = = = = = = = = = = = = = =
;end of DCOMPMS.INC

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcomp\compinit.asm ===
PAGE    90,132                  ;A2
        TITLE   COMPINIT -- DISKCOMP INITIALIZATION PROGRAM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: COMPINIT

; DESCRIPTIVE NAME: Initialization for Diskette to diskette copy Utility

;FUNCTION: DISKCOMP is to compare the contents of the diskette in the
;          specified source drive to the diskette in the target
;          drive.  If necessary for the diskettes to use volume serial
;          numbers, the actual value of those number is ignored.

;          Multiple compares may be performed with one load of DISKCOMP.
;          A prompt, "Compare another (Y/N)?" permits additional
;          executions, all with the same drive specifications.

; ENTRY POINT: "DISKCOMP" at ORG 100h, jumps to "BEGIN".

; INPUT: (DOS command line parameters)

;             [d:][path] DISKCOMP  [d: [d:]] [/1] [/8]

;        WHERE
;             [d:][path] - Path where the DISKCOMP command resides.

;             [d:] - To specify the Source drive
;
;             [d:] - To specify the Target drive
;
;             [/1] - To compare only the first side of the diskette,
;                    regardless of the diskette or drive type.

;             [/8] - To compare only the first 8 sectors per track,
;                    even if the first diskette contains 9/15 sectors
;                    per track.
;
; EXIT-NORMAL: Errorlevel = 0
;             Function completed successfully.

; EXIT-ERROR: Errorlevel = 1
;             Abnormal termination due to error, wrong DOS,
;             invalid parameters, unrecoverable I/O errors on
;             the diskette.

; EFFECTS: The entire source diskette is compared, including the unused
;          sectors.  There is no awareness of the separate files
;          involved.  A unique volume serial number, if present,
;          is ignored in the comparison process.

; INCLUDED FILES:
;          PATHMAC.INC - PATHGEN MACRO
;          INCLUDE DCMPMACR.INC            ;(FORMERLY CALLED MACRO.DEF)

; INTERNAL REFERENCES:
;    ROUTINES:
;         INIT - initialization main routine
;         SOURCE_TARGET_DRV - convert source/target drive to bios values
;         TEST_DRIVE_VALIDITY - are source/target drives valid?
;         DOS_DRIVE_VALIDITY -- check dos drive validity byte
;         TEST_REMOVABLE - is specified drive removable?
;         CHK_SINGLE_DRIV_OP - is target drive same as source?
;         GET_LOGICAL_DRIVE - get logical drive who owns the physical drive
;         DISKETTE_DRV_TYPE - check compatability source/target drives
;         CHECK_REDIRECTION - is device redirected?
;         BUFFER_SIZE - finds start and end of buffer
;         SETUP_CTRL_BREAK - setup the ctrl-break vector
;         CHECK_SERVER - is server or redirector loaded?

;    DATA AREAS:
;       PSP - Contains the DOS command line parameters.
;       WORKAREA - Temporary storage

; EXTERNAL REFERENCES:
;    ROUTINES:
;       SYSDISPMSG - Uses the MSG parm lists to construct the messages
;                on STDOUT.
;       SYSLOADMSG - Loads messages, makes them accessable.
;       PARSER - Processes the DOS Command line, finds parms.

;    DATA AREAS:
;        DCOMPSM.SAL - Defines the control blocks that describe the messages
;        DCOMPPAR.SAL - Defines the control blocks that describe the
;               DOS Command line parameters.

; NOTES:
;        This module should be processed with the SALUT preprocessor
;        with the re-alignment not requested, as:

;               SALUT COMPINIT,NUL

;        To assemble these modules, the alphabetical or sequential
;        ordering of segments may be used.

;        For instructions as to how to LINK, see prolog for DISKCOMP.

;PROGRAM AUTHOR: Original written by: Jin K.
;                4.00 modifications by: Edwin M. K.
;       ;C02    MKS     Bug#727 against DISKCOMP wasn't allowing two 720k
;                       diskettes to DISKCOMP or DISKCOPY if they were in
;                       drives of differing capacities.  This is fixed by
;                       checking for drive type 7 as well as 2, and permitting
;                       the copy if both diskettes are 720k.  The equate
;                       DRV_OTHER comes from DISKCOMP.EQU.
;       ;C05    MKS     Bug#1061.  Removeable hard disks were causing problems.
;                       Now they are disallowed.  FixedDisk comes from
;                       DISKCOMP.EQU.
;****************** END OF SPECIFICATIONS *****************************

;REVISION HISTORY:
;DATE:   10-30-84 - chk_para routine added. Many parts are modified to
;        permit DISKCOMP /1, DISKCOMP D: /1 cases. Restore diskbase
;        before return to DOS when invalid DOS version occurs.
;DATE:   3-27-85  MAIN PARTS OF DISKCOMP PROGRAM HAS BEEN REWRITTEN
;        TO USE NEW IOCTL FUNCTIONS 'READ', 'GET_DEVICE_PARAMETERS'.
;       A000 - Change spelling of "LOCAL" to "LOCALX" to make MASM 3 happy.

        INCLUDE PATHMAC.INC             ;AN013;
        INCLUDE DCMPMACR.INC            ;(FORMERLY CALLED MACRO.DEF)

CSEG    SEGMENT PARA PUBLIC 'CODE'      ;                                            ;AC000;
        ASSUME  CS:CSEG, DS:CSEG, ES:CSEG, SS:CSEG

        INCLUDE DISKCOMP.EQU
        include version.inc             ; MSKK02 07/14/89

NOOP    EQU     90H                     ;NO-OPERTION INSTRUCTION, USED TO DELETE     ;AN001;
                                        ; 386 SUPPORT                           ;AN001;
;$salut (4,2,9,41)
;****************************************************************************
;                                                                           *
;                        EXTERNAL VARIABLES                                 *
;                                                                           *
;****************************************************************************
 EXTRN  PARSER:NEAR                     ;DCOPYPAR.SAL - DRIVES SYS PARSER       ;AN000;

 EXTRN  RECOMMENDED_BYTES_SECTOR:WORD
 EXTRN  S_OWNER_SAVED:BYTE
 EXTRN  T_OWNER_SAVED:BYTE
 EXTRN  ASCII_DRV1_ID:BYTE              ;40H    SOURCE DRIVE ID IN ASCII
 EXTRN  ASCII_DRV2_ID:BYTE              ;40H    TARGET DRIVE ID IN ASCII

 EXTRN  SUBLIST_78          :WORD       ;                                       ;AN000;
 EXTRN  SUBLIST_11          :WORD       ;                                       ;AN000;
 EXTRN  SUBLIST_15A         :WORD       ;                                       ;AN000;
 EXTRN  SUBLIST_15B         :WORD       ;                                       ;AN000;
 EXTRN  SUBLIST_15C         :WORD       ;                                       ;AN000;
 EXTRN  SUBLIST_17B         :WORD       ;                                       ;AN000;
 EXTRN  SUBLIST_17C         :WORD       ;                                       ;AN000;
 EXTRN  SUBLIST_17D         :WORD       ;                                       ;AN000;
 EXTRN  SUBLIST_PARSE:WORD              ;PARSE ERROR XX - %0                         ;AN004;

 EXTRN  MSGNUM_INVALID_PARM:BYTE        ;"INVALID PARAMETER"                    ;AC000;
 EXTRN  MSGNUM_INVALID_DRV:BYTE         ;"INVALID DRIVE SPECIFICATION"          ;AC000;
 EXTRN  MSGNUM_DRV_REDIRECTED:BYTE      ;"INVALID, DRIVE REDIRECTED"            ;AC000;
 EXTRN  MSGNUM_NOT_COMPATIBLE:BYTE      ;"DEVICE OR DISKETTE TYPES NOT COMPATIBLE";AC000;
.XLIST
;EXTRN  MSG_INVALID_DOS :BYTE           ;MSG FOR DOS1.0 AND 1.1
.LIST

 EXTRN  TRACK_TO_READ :WORD
 EXTRN  SIDE:BYTE

 EXTRN  S_DRV_SECT_TRACK :BYTE          ;SECT/TRACK
 EXTRN  S_DRV_HEADS :BYTE               ;# OF HEADS
 EXTRN  S_DRV_TRACKS :WORD              ;# OF TRACKS
 EXTRN  T_DRV_SECT_TRACK :BYTE
 EXTRN  T_DRV_HEADS :BYTE
 EXTRN  T_DRV_TRACKS :WORD

 EXTRN  COPY_TYPE :BYTE                 ;1 = 1-DRIVE COPY  2 = 2-DRIVE COPY
 EXTRN  USER_OPTION :BYTE               ;NO OPTION (-1)  /1 (1), INVALID (9)
 EXTRN  USER_OPTION_8 :BYTE             ;NO OPTION (-1)  /8 (1), INVALID (9)
 EXTRN  BUFFER_BEGIN :WORD              ;STARTING BUFFER @ FOR LOADING
 EXTRN  BUFFER_END :WORD                ;ENDING BUFFER @ FOR LOADING
 EXTRN  START_BUFFER :WORD              ;START OF BUFFER SPACE
 EXTRN  MAIN_EXIT :WORD                 ;EXIT ADDRESS FOR CONTROL-BREAK

 EXTRN  ORG_SOURCE_DRIVE:BYTE           ;LOGICAL SOURCE DRIVE NUMBER
 EXTRN  ORG_TARGET_DRIVE:BYTE           ;        TARGET
 EXTRN  SOURCE_DRIVE:BYTE               ;AS SPECIFIED BY USER PARMS, DR NUM     ;AN000;
 EXTRN  TARGET_DRIVE:BYTE               ;AS SPECIFIED BY USER PARMS, DR NUM     ;AN000;

 EXTRN  IO_ERROR :BYTE

 EXTRN  DS_IOCTL_DRV_PARM :BYTE         ;PLACE HOLDER FOR DEFAULT SOURCE DRV PARM
 EXTRN  DT_IOCTL_DRV_PARM :BYTE         ;PLACE HOLDER FOR DEFAULT TARGET DRV PARM
 EXTRN  DS_specialFunctions :BYTE       ;AND THEIR CONTENTS
 EXTRN  DT_specialFunctions :BYTE
 EXTRN  DS_deviceType:BYTE
 EXTRN  DT_deviceType:BYTE
 EXTRN  DS_deviceAttributes :WORD
 EXTRN  DT_deviceAttributes :WORD
 EXTRN  DS_numberOfCylinders :WORD
 EXTRN  DT_numberOfCylinders :WORD
 EXTRN  DS_mediaType :BYTE
 EXTRN  DT_mediaType :BYTE
 EXTRN  DS_BPB_PTR :BYTE
 EXTRN  DT_BPB_PTR :BYTE

 EXTRN  MS_IOCTL_DRV_PARM :BYTE         ;DRIVE PARM FROM SOURCE MEDIUM
 EXTRN  MT_IOCTL_DRV_PARM :BYTE

 EXTRN  PATCH_386:BYTE                  ;PATCH AREA, CHANGED TO NOOP IF NOT 386 ;AN001;

 EXTRN  Q_BREAK : BYTE                  ; dcomppar.asm

 EXTRN  GENERIC_IOCTL :NEAR
 EXTRN  SET_LOGICAL_DRIVE :NEAR
;                      $salut (4,24,28,41)
MY_BPB                 STRUC
CBYTE_SECT             DW  0            ; 200H  BYTES / SECTOR
CSECT_CLUSTER          DB  0            ; 2h    SECTORS / CLUSTER
CRESEV_SECT            DW  0            ; 1h    RESERVED SECTORS
CFAT                   DB  0            ; 2h    # OF FATS
CROOTENTRY             DW  0            ; 70h   # OF ROOT ENTRIES
CTOTSECT               DW  0            ; 02D0h TOT. # OF SECT.
                                        ; INCL BOOT SECT, DIRS
MEDIA_DESCRIP          DB  0            ;0FDh   MEDIA DISCRIPTOR
CSECT_FAT              DW  0            ; 2h    SECTORS / FAT
CSECT_TRACK            DW  0            ;
CHEAD                  DW  0            ;
CHIDDEN_SECT           DD  0            ;
BIG_TOT_SECT           DD  0            ;
                       DB  6 DUP (0)    ;
MY_BPB                 ENDS

;USED TO CHECK FOR PRESENCE OF 386 MACHINE:
BIOS_SYSTEM_DESCRIPTOR struc            ;SYSTEM TYPE STRUC                      ;AN001;
bios_SD_leng           dw  ?            ;VECTOR LENGTH                          ;AN001;
bios_SD_modelbyte      db  ?            ;SYSTEM MODEL TYPE                      ;AN001;
bios_SD_scnd_modelbyte db  ?            ;                                       ;AN001;
                       db  ?            ;                                       ;AN001;
bios_SD_featurebyte1   db  ?            ;                                       ;AN001;
                       db  4 dup (?)    ;                                       ;AN001;
BIOS_SYSTEM_DESCRIPTOR ends             ;END OF STRUC                           ;AN001;


;****************************************************************************
;                                                                           *
;                        VARIABLE DECLARATIONS                              *
;                                                                           *
;****************************************************************************
DRIVE_VALID            DW  ?            ;DRIVE VALIDITY BYTE
DEFAULT_DRV            DB  ?            ;DEFAULT DRIVE ID
NUMBER_OF_DRV          DB  ?            ;TOTAL # OF DISKT DRIVES ON THE SYS
                                        ;(NUMBER_OF_DRV = 0 ---> 1 DRIVE)
ASCII_DRIVE_LETTER     DB  " :",0
                       PATHLABL COMPINIT ;AN013;
                       HEADER <INIT - INITIALIZATION ROUTINE, MAIN PROGRAM> ;       ;AN000;
;       $salut (4,9,15,41)              ;                                       ;AN000;
;#############################################################################
;                     INITIALIZATION ROUTINE - MAIN PROGRAM
INIT    PROC  NEAR
        PUBLIC INIT                     ;MAKE ENTRY IN LINK MAP                 ;AN000;

;OUTPUT: DX = EXIT CODE, "FINE"
;#############################################################################

        MOV   DRIVE_VALID,AX            ;SAVE DRIVE VALIDITY BYTE
        CALL  PC_386_CHK                ;SEE IF THIS IS A 386 MACHINE           ;AN001;

;               REPLACE THE "FILL_SEG" IN THE SUBLIST MESSAGE CONTROL BLOCKS.

;               BECAUSE THIS IS A .COM STYLE FILE, THESE SEGID VALUES CANNOT
;               BE PROVIDED BY THE DOS SYSTEM LOADER, BUT MUST BE DYNAMICALLY
;               PERFORMED AT EXECUTION TIME AS PART OF A .COM FILE'S OBLIGATION
;               TO BE "SELF-RELOCATING".

        MOV   AX,CS                     ;GET SEGID OF COMMON SEGMENT
        MOV   SUBLIST_78.SUB_VALUE_SEG,AX ;                                     ;AN000;
        MOV   SUBLIST_11.SUB_VALUE_SEG,AX ;                                     ;AN000;
        MOV   SUBLIST_15A.SUB_VALUE_SEG,AX ;                                    ;AN000;
        MOV   SUBLIST_15B.SUB_VALUE_SEG,AX ;                                    ;AN000;
        MOV   SUBLIST_15C.SUB_VALUE_SEG,AX ;                                    ;AN000;
        MOV   SUBLIST_17B.SUB_VALUE_SEG,AX ;                                    ;AN000;
        MOV   SUBLIST_17C.SUB_VALUE_SEG,AX ;                                    ;AN000;
        MOV   SUBLIST_17D.SUB_VALUE_SEG,AX ;                                    ;AN000;
        MOV   SUBLIST_PARSE.SUB_VALUE_SEG,AX ;                                  ;AN004;

        CALL  SETUP_CTRL_BREAK          ;STEALS CTRL_BREAK
        CLD                             ;CLEAR DIRECTION FLAG
        MOV   DX,FINE                   ;ASSUME EVERYTHING IS FINE
.XLIST
;       CALL  SCREENING                 ;CHECK DOS VERSION AND INPUT PARMS
;       CMP   DX,FINE                   ;IF FINE & DANDY
;       JNE   EXIT_INIT
.LIST
        CALL  PARSER                    ;LOOK AT DOS COMMAND LINE               ;AN000;
        CMP   [Q_BREAK], 0              ; exit after options msg?
        JNE   INIT_EXIT                 ;  jump if so

        CMP   DX,FINE                   ;IF ALL OK                              ;AN000;
        JNE $$IF1
	CALL  SOURCE_TARGET_DRV     ;DETERMINE SOURCE AND TARGET DRV

$$IF1:
        CMP   DX,FINE                   ;IF STILL FINE AND DANDY                ;AN000;
	JNE   INIT_EXIT
	CALL  TEST_DRIVE_VALIDITY

	CMP   DX,FINE
	JNE   INIT_EXIT
	CALL  DISKETTE_DRV_TYPE ;SOURCE & TARGET DRIVE TYPES

	CMP   DX,FINE		;IF FINE & DANDY
	JNE   INIT_EXIT
	CALL  BUFFER_SIZE   ;GET BUFFER SIZE FOR COPYING

INIT_EXIT:
        RET                             ;RETURN TO CALLER

INIT    ENDP                            ;END INITIALLIZATION PROGRAM

;#############################################################################
.XLIST
;       HEADER <SCREENING - CHECK DOS VERSION, SYNTAX PARMS>
;******************************************************************************
; SUBROUTINE NAME :  SCREENING  - CHECKS THE FOLLOWING:                       *
;                                 - DOS VERSION                               *
;                                 - DRIVE ID VALIDITY                         *
;                                 - FILE NAME ENTERED BY MISTAKE?             *
; INPUT           :  BL : DRIVE VALIDITY BYTE                                 *
; OUTPUT          :  DX : FINE    - NO ERROR                                  *
;                         (OTHERS)- ERROR MSG OFFSET                          *
;******************************************************************************
;SCREENING PROC NEAR

                                        ;CHECK DOS VERSION:
;        MOV   AH,DOSVER_FUNC            ;SEE IF CORRECT DOS VERSION
;        INT   21H                       ;FUNCTION CALL (AL <- DOS VERSION)
;;        XCHG    AH,AL                   ;AH=MAJOR VER, AL=MINOR VER
;        CMP   AX,expected_version       ;IF DOS MAJOR VERSION LESS THAN 2.0
;        $IF   NE                        ;THEN ISSUE ERROR MSG
;            MOV   DX,OFFSET MSG_INVALID_DOS
;            MOV   AH,PRINT_FUNC         ;USE PRINT FUNCTION TO TELL USER
;            INT   21H                   ;THAT HE IS USING THE OLD VERSION
;            INT   20H
;        $ELSE                           ;VERSION OK
;            CALL  CHK_PARA              ;GENERAL SYNTAX CHECK
;        $ENDIF                          ;END VERSION TEST
;        RET
;SCREENING ENDP
;        HEADER <CHK_PARA - SYNTAX PARMS, OPTION /1 /8>
;;**************************************************************************
;CHK_PARA PROC NEAR
;;       CHECK SYNTAX OF THE ENTERED PARAMETERS                            *
;;       ALSO, DETERMINE THE USER OPTION "/1" AND/OR "/8" IS ENTERED.      *
;;  INPUT: DX = FINE                                                       *
;;         IF /1 HAS BEEN ENTERED, THE VARIABLE USER_OPTION = OPTION_1     *
;;         ELSE USER_OPTION = NO_OPTION.                                   *
;;         IF /8 HAS BEEN ENTERED, THE USER_OPTION_8 WILL BE ON            *
;;  OUTPUT: DX = FINE    - NO ERROR                                        *
;;          OTHERWISE DX POINTS TO ERROR MSG                               *
;;**************************************************************************
;        PUSH  CX
;        MOV   USER_OPTION, NO_OPTION    ;ASSUME NO /1 IS ENTERED.
;        MOV   USER_OPTION_8, OFF        ;ASSUME /8 IS NOT ENTERED.
;        XOR   CX, CX
;        MOV   CL, BYTE PTR DS:BEGIN_UNFORM_AREA ;GET # OF CHR
;        CMP   CL, 0
;        JZ    CHK_PARA_EXIT
;        CLD                             ;CLEAR DIRECTION
;        MOV   DI, BEGIN_UNFORM_AREA+2   ;STARTING POINT OF PARA
;        DEC   CL                        ;TO IGNORE LAST CHR (0DH)
;        CALL  SKIP_BLANKS               ;SKIP BLANKS, IF ANY. THE POINTER WILL POINT TO THE NEXT NON_BLANK CHR
;        JZ    CHK_PARA_EXIT             ;ONLY BLANKS ARE ENTERED.
;        CALL  CHK_SLASH_ONE             ;IS NEXT WORD /1 OR /8 ?
;        JNC   SLASH_ONE                 ;YES
;        CALL  CHK_DRV_SPEC              ;IS IT A DRIVE SPECIFICATION LIKE d: ?
;        JC    INVALID_PARA              ;IF NOT, THEN ERROR
;        JZ    CHK_PARA_EXIT             ;NO MORE CHR? THEN, OK. (EX. DISKCOMP D:)
;        CALL  CHK_SLASH_ONE             ;IS NEXT WORD /1 OR /8 ?
;        JNC   SLASH_ONE                 ;YES.(EX. DISKCOMP D:/1)
;        CALL  CHK_BLANK                 ;IF NOT, NEXT CHR SHOULD BE A BLANK.
;        JC    INVALID_PARA              ;OTHERWISE, ERROR.
;        CALL  SKIP_BLANKS               ;SKIP BLANKS, IF ANY.
;        JZ    CHK_PARA_EXIT             ;(EX. DISKCOMP D:  )
;        CALL  CHK_SLASH_ONE             ;IS IT /1 OR /8 ?
;        JNC   SLASH_ONE                 ;YES. (EX. DISKCOMP D:  /1)
;        CALL  CHK_DRV_SPEC              ;IF NOT /1 OR /8, THEN IS IT A DRV SPEC?
;        JC    INVALID_PARA              ;OTHERWISE, ERROR.
;        CALL  SKIP_BLANKS               ;SKIP BLANKS, IF ANY.
;        JZ    CHK_PARA_EXIT             ;NO MORE CHR. (EX. DISKCOMP D: D:)
;        CALL  CHK_SLASH_ONE             ;OTHERWISE, /1 AND/OR /8 SHOULD BE FOLLOWED.
;        JNC   SLASH_ONE                 ;YES, /1 OR /8. JMP TO SLASH_ONE
;        JMP   INVALID_PARA              ;PARAMETER ERROR.
;SLASH_ONE:                              ;YES, FOUND EITHER OF /1 OR /8.
;        CALL  SKIP_BLANKS               ;/1 SHOULD BE END OF PARAMETERS, OR ONLY BLANKS CAN FOLLOW.
;        JZ    CHK_PARA_EXIT             ;NO MORE CHR? THEN OK.
;        CMP   USER_OPTION, OPTION_1     ;WAS IT /1?
;        JZ    SLASH_8                   ;THEN CHECK WHETHER NEXT IS /8.
;        CALL  CHK_SLASH_ONE             ;OTHERWISE, IT WAS /8. NOW CHECK /1.
;        JC    INVALID_PARA              ;NOT FOUND, ERROR
;        CMP   USER_OPTION, OPTION_1
;        JZ    CHK_PRE_EXIT              ;YES, IT IS /1
;        JMP   INVALID_PARA              ;OTHERWISE, FOUND /8 AGAIN. ERROR
;SLASH_8:
;        CALL  CHK_SLASH_ONE             ;CHECK IT IS /8
;        JC    INVALID_PARA              ;NOT FOUND? ERROR
;        CMP   USER_OPTION_8, ON
;        JZ    CHK_PRE_EXIT              ;YES. IT IS /8
;        JMP   INVALID_PARA              ;OTHERWISE, FOUND /1 AGAIN. ERROR
;CHK_PRE_EXIT:
;        CALL  SKIP_BLANKS               ;SKIP BLANKS IF ANY.
;        JZ    CHK_PARA_EXIT             ;THERE SHOULD NOT BE ANY MORE PARAMETER.
;INVALID_PARA:
;        MOV   DX,OFFSET MSG_INVALID_PARM_PTR ;WRONG PARM ENTERED MSG
;CHK_PARA_EXIT:
;        POP   CX
;
;        RET
;CHK_PARA ENDP
;        HEADER <SKIP_BLANKS - IGNORE BLANKS/TABS IN PARMS PARSING>
;***************************************************************************
;SKIP_BLANKS PROC NEAR
; ** SKIP BLANKS OR TABS, IF ANY, IN THE PARAMETER STRING.                 *
; INPUT: ES:DI POINTS TO THE CURRENT CHR.                                  *
;        CX - # OF REMAINING CHR IN THE STRING.                            *
; OUTPUT: ES:DI POINT TO THE NEXT NON_BLANK CHR.                           *
;         CX IS ADJUSTED ACCORINGLY.                                       *
;         IF THE CURRENT CHR IS NOT A BLANK, THEN DI, CX VALUE NOT CHANGED.*
;         IF CX = 0, THEN ZERO FLAG WILL BE SET AND EXIT THIS PROC.        *
;***************************************************************************
;SKIP_AGAIN:
;        MOV   AL, 20H                   ;20H=BLANK
;        CLD                             ;CLEAR DIRECTION
;        REPE  SCASB
;        JZ    SK_BL_1                   ;IF NOT FOUND A NON_BLANK CHR YET, AND CX=0, EXIT THIS ROUTINE.
;        DEC   DI                        ;OTHERWISE, RESTORE DI TO THE NON_BLANK POSITION.
;        INC   CX                        ;  AND RESTORE CX TO WHERE IT WAS AT NON_BLANK CHR
;                                        ;(IF FOUND A NON_BLANK CHR, ZERO FLAG WOULD NOT BE SET)
;        MOV   AL, ES:BYTE PTR [DI]
;        CMP   AL, 09H                   ;09H=TAB
;        JNZ   SK_BL_1                   ;IF THE NON_BLANK CHR IS NOT A TAB THEN EXIT
;        INC   DI                        ;ELSE TRY SKIP AGAIN.
;        DEC   CX
;        JMP   SKIP_AGAIN
;SK_BL_1:
;        RET
;SKIP_BLANKS ENDP
;        HEADER <CHK_SLASH - IS CURRENT PARM /1 OR /8>
;;***************************************************************************
;CHK_SLASH_ONE PROC NEAR
; ** CHECK CURRENT CHR IS / FOLLOWED BY 1.                                 *
; INPUT: ES:DI POINTS TO THE CURRENT CHR TO BE CHECKED.                    *
;        CX REPRESENTS THE # OF CHR'S IN THE STRING.                       *
; OUTPUT: FOUND - DI POINTS TO THE NEXT CHR.  CX CHANGED ACCORDINGLY.      *
;                 IF THIS HAD BEEN A LAST WORD, ZERO FLAG WILL BE SET.     *
;         NOT FOUND - CARRY IS SET. DI, CX UNCHANGED.                      *
;***************************************************************************

;        CLC                             ;CLEAR CARRY FLAG
;        CMP   CX, 2                     ;# OF CHR IN THE STRING.
;        JL    CK_SL_0                   ;IF LESS THAN 2, THEN SET CARRY AND EXIT.
;        MOV   AX, ES:WORD PTR [DI]      ;GET CURRENT WORD IN AX
;        CMP   AX, '1/'                  ;IS IT /1 ?
;        JZ    CK_SL_1                   ;YES. SET USER_OPTION
;        CMP   AX, '8/'                  ;IS IT /8 THEN ?
;        JZ    CK_SL_2                   ;YES. SET USER_OPTION_8
;CK_SL_0:
;        STC                             ;OTHERWISE, NOT FOUND. SET CARRY
;        JMP   CK_SL_4                   ; AND RETURN
;CK_SL_1:
;        MOV   USER_OPTION, OPTION_1
;        JMP   CK_SL_3
;CK_SL_2:
;        MOV   USER_OPTION_8, ON
;CK_SL_3:                                ;ADJUST CX, DI TO THE NEXT CHR.
;        INC   DI
;        INC   DI
;        DEC   CX
;        DEC   CX
;        CMP   CX, 0                     ;SET ZERO FLAG IF NO MORE CHR.
;CK_SL_4:
;        RET
;CHK_SLASH_ONE ENDP
;        HEADER <CHK_DRV - CURRENT PARM CHAR IS DRIVE AND COLON?>
;;***************************************************************************
;CHK_DRV_SPEC PROC NEAR
; ** CHECK CURRENT CHR IS ALPHA CHR FOLLOWED BY COLON.                     *
; INPUT: ES:DI POINTS TO THE CURRENT CHR TO BE CHECKED.                    *
;        CX -- # OF CHR IN THE STRING.                                     *
; OUTPUT: FOUND - DI POINTS TO THE NEXT CHR. CX ADJUSTED ACCORDINGLY.      *
;                 IF THIS HAD BEEN A LAST WORD, ZERO FLAG WILL BE SET.     *
;         NOT FOUND - CARRY IS SET. DI, CX UNCHANGED.                      *
;***************************************************************************

;        CLC                             ;CLEAR CARRY
;        CMP   CX, 2                     ;# OF CHR REMAINING IN THE STRING.
;        JL    CK_DR_1                   ;IF LESS THAN 2, THEN NOT FOUND - SET CARRY AND EXIT.
;        MOV   AL, ES:BYTE PTR [DI]      ;GET CURRENT CHR
;        AND   AL, 11011111B             ;CHANGE IT TO UPPER_CASE CHR.
;        CMP   AL, 'A'
;        JB    CK_DR_1                   ;LESS THAN 'A', THEN NOT FOUND.
;        CMP   AL, 'Z'
;        JA    CK_DR_1                   ;ABOVE 'Z', THEN NOT FOUND.
;        MOV   AL, ES:BYTE PTR [DI+1]    ;LOOK AHEAD THE FOLLOWING CHR.
;        CMP   AL, ':'                   ;SHOULD BE A COLON.
;        JNZ   CK_DR_1                   ;NOT FOUND.
;        INC   DI                        ;FOUND. ADJUST CX, DI TO THE NEXT CHR.
;        INC   DI
;        DEC   CX
;        DEC   CX
;        CMP   CX, 0                     ;IF NO MORE CHR, THAN SET THE ZERO FLAG.
;        JMP   CK_DR_2
;CK_DR_1:
;        STC                             ;SET CARRY
;CK_DR_2:
;        RET
;CHK_DRV_SPEC ENDP
;        HEADER <CHK_BLANK - IS CURRENT CHAR IN PARM BLANK OR TAB>
;;***************************************************************************
;CHK_BLANK PROC NEAR
;; ** CHECK THE CURRENT CHR IS A BLANK OR A TAB.                            *
;; INPUT: ES:DI POINTS TO THE CURRENT CHR.                                  *
;;        CX - # OF CHR IN THE STRING.                                      *
;; OUTPUT: FOUND - DI MOVES TO THE NEXT CHR. CX DECREASES BY 1.             *
;;         NOT FOUND - CARRY IS SET. DI, CX UNCHANGED.                      *
;;***************************************************************************
;
;        CLC                             ;CLEAR CARRY
;        CMP   CX, 1                     ;IF LESS THAN 1, NOT FOUND.
;        JL    CK_BL_0                   ;SET CARRY AND EXIT
;        MOV   AL, ES:BYTE PTR [DI]      ;GET CURRENT CHR
;        CMP   AL, 020H                  ;020H=BLANK CHR
;        JZ    CK_BL_1                   ;FOUND
;        CMP   AL, 09H                   ;09H=TAB CHR
;        JZ    CK_BL_1                   ;FOUND
;CK_BL_0:
;        STC                             ;NOT FOUND. SET CARRY
;        JMP   CK_BL_2
;CK_BL_1:
;        INC   DI                        ;FOUND. ADJUST DI, CX
;        DEC   CX
;CK_BL_2:
;        RET
;CHK_BLANK ENDP
.LIST
        HEADER <PC_386_CHK - SEE IF THIS IS A 386 MACHINE>
; QUERIES THE BIOS TO DETERMINE WHAT TYPE OF
; MACHINE WE ARE ON.  WE ARE LOOKING FOR A 386.
; THIS WILL BE USED TO DETERMINE IF A DOUBLE WORD MOVE
; IS TO BE PERFORMED.
;
;       INPUTS          : NONE
;
;       OUTPUTS         : IF A 386 NOT PRESENT, CODE IS
;                            *** P A T C H E D ***
;                         TO NO-OP THE SUPPORT FOR THE DOUBLE WORD MOVE
;=========================================================================

PC_386_CHK PROC NEAR			;DETERMINE MACHINE TYPE

	PUSH  AX			;SAVE AFFECTED REGS
	PUSH  BX			;
	PUSH  ES			;

	xor	ax,ax			; determine CPU type
	push	ax
	popf				; try to put that in the flags
	pushf
	pop	ax			; look at what really went into flags
	test	ax,8000h		; was high bit set?
	jnz	not_a_80386		; jump if so - it's 8086/88
	mov	ax,7000h		; try to set the NT/IOPL bits
	push	ax
	popf				; ...in the flags
	pushf
	pop	ax			; look at actual flags
	test	ax,7000h		; any high bit set?
	jnz	its_a_80386		; jump if so - it's 80386

not_a_80386:
	MOV   AL,NOOP			;WITH A NO-OP INSTRUCTION
	MOV   PATCH_386,AL		;
	MOV   PATCH_386+1,AL		;
	MOV   PATCH_386+2,AL		;
its_a_80386:

	POP   ES			;RESTORE REGS.
	ASSUME ES:CSEG			;BACK TO USUAL

	POP   BX			;
	POP   AX			;

	RET				;

PC_386_CHK ENDP 			;
	HEADER <SOURCE_TARGET_DRV - CONVERT SRC/TARGET DR TO BIOS VALS> ;
;******************************************************************************
; SUBROUTINE NAME :  SOURCE_TARGET_DRV    DETERMINES SOURCE & TARGET DRIVES & *
;                                         CONVERT THEM FROM DOS TO BIOS VALUE *
; INPUT           :  SOURCE_DRIVE & TARGET_DRIVE HAVE DOS DRIVE ID'S:         *
;                         0 = DEFAULT        1 = DRV A   ETC.                 *
;                                                                             *
; OUTPUT          :  ORG_SOURCE_DRIVE        1 = DRIVE A    2 = DRIVE B  ETC. *
;                 :  ORG_TARGET_DRIVE        1 = DRIVE A    2 = DRIVE B  ETC. *
;                                                                             *
;                 :  COPY_TYPE      1 = SINGLE DRV COPY, 2 = 2 DRIVE COPY     *
;                 :  DX : FINE    - NO ERROR                                  *
;******************************************************************************
SOURCE_TARGET_DRV PROC NEAR
	PUBLIC SOURCE_TARGET_DRV	;MAKE ENTRY IN LINK MAP
                                        ;GET CURRENT DEFAULT DRIVE
        MOV   AH,CURRENTDRV_FUNC        ;FUNCTION CALL (19H)
                                        ;(AL <- CURRENT DEFAULT DRV
        INT   21H                       ;0 = A, 1 = B, ETC)

        MOV   DEFAULT_DRV,AL            ;SAVE IT

	CMP   SOURCE_DRIVE,ZERO 	;FIRST DRV ENTERED?
	JNE $$IF9			;NO DRIVE LETTER ENTERED
	MOV   CH, DEFAULT_DRV		;SET SOURCE, TARGET DRIVE TO
	INC   CH
	MOV   ORG_SOURCE_DRIVE, CH	;DEFAULT DRIVE
	MOV   CL, CH
	MOV   ORG_TARGET_DRIVE, CL
	JMP SHORT $$EN11

$$IF9:
	MOV   CH,SOURCE_DRIVE	    ;GET SOURCE DRIVE FROM SPECIFIED PARM
	MOV   ORG_SOURCE_DRIVE, CH
	CMP   TARGET_DRIVE,ZERO     ;WAS A SECOND DRIVE SPECIFIED
	JNE $$IF11		    ;TARGET DRIVE IS DEFAULT
	MOV   CL, DEFAULT_DRV
	INC   CL		;MAKE IT A LOGICAL DRIVE NUMBER
	MOV   ORG_TARGET_DRIVE, CL
	JMP SHORT $$EN11

$$IF11:
	MOV   CL, TARGET_DRIVE	;USE USER SPECIFIED TARGET DRIVE
	MOV   ORG_TARGET_DRIVE, CL
$$EN11:

        ADD   ASCII_DRV1_ID,CH          ;SETUP DRIVE ID ALPHABET IN THE
        ADD   ASCII_DRV2_ID,CL          ;MESSAGES

        RET
SOURCE_TARGET_DRV ENDP
	HEADER <TEST_DRIVE_VALIDITY - ARE SOURCE/TARGET DRIVES VALID?> ;
;******************************************************************************
; SUBROUTINE NAME :  TEST_DRIVE_VALIDITY--MAKE SURE SOURCE AND TARGET DRIVES  *
;                    SPECIFIED BY USER ARE VALID FOR DISKCOPY                 *
;                                                                             *
; INPUT           :  ORG_SOURCE_DRIVE:BYTE, ORG_TARGET_DRIVE:BYTE             *
;                                                                             *
; OUTPUT          :  DX=FILE IF DRIVES ARE VALID ELSE DX CONTAINS MESSAGE PTR *
;******************************************************************************

TEST_DRIVE_VALIDITY PROC NEAR
        PUBLIC TEST_DRIVE_VALIDITY      ;MAKE ENTRY IN LINK MAP                 ;AN000;

        CALL  DOS_DRIVE_VALIDITY

        CMP   DX,FINE
        JNE $$IF15

        MOV   BL,ORG_SOURCE_DRIVE
        CALL  CHECK_REDIRECTION

        CMP   DX,FINE
        JNE $$IF15

        MOV   BL,ORG_TARGET_DRIVE
        CALL  CHECK_REDIRECTION

        CMP   DX,FINE
        JNE $$IF15

        MOV   BL,ORG_SOURCE_DRIVE
        CALL  CHECK_SERVER

        CMP   DX,FINE
        JNE $$IF15

        MOV   BL,ORG_TARGET_DRIVE
        CALL  CHECK_SERVER

        CMP   DX,FINE
        JNE $$IF15

        CALL  TEST_REMOVABLE

        CMP   DX,FINE
        JNE $$IF15

	CALL  CHK_SINGLE_DRV_OP     ;CHECK IF IT IS
                                        ; ONE PHYSICAL DRIVE OPERATION
$$IF15:
        RET

TEST_DRIVE_VALIDITY ENDP
        HEADER <DOS_DRIVE_VALIDITY - CHECK DOS DRIVE VALIDITY BYTE>
;******************************************************************************
; SUBROUTINE NAME :  DOS_DRIVE_VALIDITY -- CHEKC DOS DRIVE VALIDITY BYTE      *
;                                                                             *
; INPUT           :  DRIVE_VALID:BYTE                                         *
;                    THIS IS THE ORIGINAL VALUE PRESENTED IN AX BY DOS LOADER *
;                                                                             *
; OUTPUT          :  DX=FILE IF DRIVES ARE VALID ELSE DX CONTAINS MESSAGE PTR *
;******************************************************************************

DOS_DRIVE_VALIDITY PROC NEAR
        PUBLIC DOS_DRIVE_VALIDITY       ;MAKE ENTRY IN LINK MAP                 ;AN000;

        CMP   DRIVE_VALID,0             ;SEE IF DRIVES ARE VALID DOS DEVICE
        JE $$IF17
	MOV   DX,OFFSET MSGNUM_INVALID_DRV

$$IF17:
        RET

DOS_DRIVE_VALIDITY ENDP
        HEADER <TEST_REMOVABLE - IS SPECIFIED DRIVE REMOVABLE?>
;******************************************************************************
; SUBROUTINE NAME :  TEST_REMOVABLE -- CHECK IF DRIVES SPECIFED ARE REMOVABLE *
;                                                                             *
; INPUT           :  SOURCE_DRIVE:BYTE, TARGET_DRIVE:BYTE                     *
;                                                                             *
; OUTPUT          :  DX=FILE IF DRIVES ARE VALID ELSE DX CONTAINS MESSAGE PTR *
;******************************************************************************

TEST_REMOVABLE PROC NEAR
        PUBLIC TEST_REMOVABLE           ;MAKE ENTRY IN LINK MAP                 ;AN000;

        MOV   BL,ORG_SOURCE_DRIVE       ;GET PARM 1 DRIVE ID

        MOV   AX,DRIVE_CHECK            ;CHECK FOR REMOVABLE DRIVE
        INT   21H                       ;IOCTL CALL

;       $IF   NC                        ;IF DRIVE ID IS WITHIN RANGE
        JC $$IF19
            CMP   AX,REMOVABLE          ;THEN IF SOURCE DRIVE IS FIXED
;           $IF   NE                    ;  THEN
            JE $$IF20
                MOV   DX,OFFSET MSGNUM_INVALID_DRV ;GENERATE                    ;AC000;
                                        ; HARD DRIVE ERROR MESSAGE
;           $ELSE                       ;ELSE, SRC IS REMOVABLE;
            JMP SHORT $$EN20
$$IF20:
                MOV   BL,ORG_TARGET_DRIVE ;NOW GO CHECK TARGET
                MOV   AX,DRIVE_CHECK    ;CHECK FOR REMOVABLE DRIVE
                INT   21H               ;IOCTL CALL

;               $IF   NC                ;IF DRV WITHIN RANGE
                JC $$IF22
                    CMP   AX,REMOVABLE  ;THEN TGT DRV IS FIXED
;                   $IF   NE            ;     THEN
                    JE $$IF23
                        MOV   DX,OFFSET MSGNUM_INVALID_DRV ;GENERATE            ;AC000;
                                        ; HARD DRV ERROR MSG
;                   $ENDIF              ;END TEST IF TGT DRV IS FIXED
$$IF23:
;               $ELSE                   ;TGT DRV OUT OF RANGE.  EX. DRIVE X:
                JMP SHORT $$EN22
$$IF22:
                    MOV   DX,OFFSET MSGNUM_INVALID_DRV ;GENERATE                ;AC000;
                                        ; HARD DRV ERROR MSG
;               $ENDIF                  ;END TEST IF TGT WITHIN RANGE
$$EN22:
;           $ENDIF                      ;END IF SRC IS REMOVABLE
$$EN20:
;       $ELSE                           ;ELSE,  SRC DRV OUT OF RANGE
        JMP SHORT $$EN19
$$IF19:
            MOV   DX,OFFSET MSGNUM_INVALID_DRV ;PRINT ERROR MSG                 ;AC000;
;       $ENDIF                          ;END TEST IF SRC DRV WITHIN RANGE
$$EN19:
        RET

TEST_REMOVABLE ENDP
        HEADER <CHK_SINGLE_DRIV_OP - IS TARGET DRIVE SAME AS SOURCE?>
;******************************************************************************
; SUBROUTINE NAME :  CHK_SINGLE_DRV_OP                                        *
;                                                                             *
; INPUT           :  ORG_SOURCE_DRIVE - LOGICAL DRIVE NUMBER                  *
;                    ORG_TARGET_DRIVE                                         *
;                                                                             *
; OUTPUT          :  COPY_TYPE WILL BE SET TO ONE OR TWO DEPENDING ON THE     *
;                    TEST RESULT.  IF IT IS A SINGLE DRIVE COPY, THEN         *
;                    TARGET DRIVE LETTER WILL BE CHANGED TO THAT OF SOURCE.   *
;                    THE OWNERSHIP OF THE SOURCE AND TARGET DRIVE LETTER      *
;                    MIGHT HAVE BEEN CHANGED.                                 *
;                    SO, BEFORE EXIT TO DOS, THEY SHOULD BE RESET TO THE SAVED*
;                    ONE USING S_OWNER_SAVED AND T_OWNER_SAVED UNLESS THEY    *
;                    ARE EQUAL TO 0. (0 MEANS ONLY ONE DRIVE LETTER ASSIGNED.)*
;                    ASCII_DRV1_ID, ASCII_DRV2_ID MAY BE CHANGED ACCORDINGLY. *
;******************************************************************************

CHK_SINGLE_DRV_OP PROC NEAR
        PUBLIC CHK_SINGLE_DRV_OP        ;MAKE ENTRY IN LINK MAP                 ;AN000;

        PUSH  AX

        MOV   BL,ORG_SOURCE_DRIVE
        CALL  GET_LOGICAL_DRIVE

        MOV   S_OWNER_SAVED, AL         ;SAVE CURRENT OWNER DRIVE LETTER.
        MOV   BL, ORG_TARGET_DRIVE
        CALL  GET_LOGICAL_DRIVE

        MOV   T_OWNER_SAVED, AL         ;SAVE CURRENT OWNER
        MOV   BL, ORG_SOURCE_DRIVE
        CALL  SET_LOGICAL_DRIVE

        MOV   BL, ORG_TARGET_DRIVE
        CALL  SET_LOGICAL_DRIVE

        MOV   BL, ORG_SOURCE_DRIVE
        CALL  GET_LOGICAL_DRIVE         ;CHECK IF SOURCE DRIVE OWNERSHIP HAS NOT BEEN CHAGNED?

        CMP   AL, ORG_SOURCE_DRIVE
;       $IF   NE                        ;IF IT HAS BEEN CHANGED TO TARGET, THEN A SINGLE DRIVE COMPARE.
        JE $$IF30
            MOV   COPY_TYPE, ONE
            MOV   BL, ORG_SOURCE_DRIVE
            MOV   ORG_TARGET_DRIVE, BL  ;SET TARGET DRV LETTER TO THE SOURCE.
            MOV   BL, ASCII_DRV1_ID
            MOV   ASCII_DRV2_ID, BL
            MOV   BL, ORG_SOURCE_DRIVE
            CALL  SET_LOGICAL_DRIVE     ;SET THE OWNER BACK TO SOURCE DRV LETTER

;       $ELSE
        JMP SHORT $$EN30
$$IF30:
            CMP   AL, ORG_TARGET_DRIVE  ; SOURCE DRV LETTER = TARGET DRV LETTER CASE, FOR EX. DISKCOMP A: A:
;           $IF   E
            JNE $$IF32
                MOV   COPY_TYPE, ONE
;           $ELSE
            JMP SHORT $$EN32
$$IF32:
                MOV   COPY_TYPE, TWO
;           $ENDIF
$$EN32:
;       $ENDIF
$$EN30:

        POP   AX

        RET
CHK_SINGLE_DRV_OP ENDP
        HEADER <GET_LOGICAL_DRIVE - GET LOG. DRIV NO. WHO OWNS PHYSICAL DRIVE>
;******************************************************************************
GET_LOGICAL_DRIVE PROC NEAR
        PUBLIC GET_LOGICAL_DRIVE        ;MAKE ENTRY IN LINK MAP                 ;AN000;
;       *** GET THE LOGICAL DRIVE NUMBER WHO HAS THE OWNERSHIP OF THE PHYSICAL
;           DRIVE.
;       INPUT: BL = DRIVE NUMBER (0=DEFAULT, 1=A, 2=B...)
;       OUTPUT: AL = DRIVE NUMBER (0= ONLY ONE DRIVE LETTER ASSIGNED TO THE
;                                     BLOCK DEVICE. OTHERWISE, 1=A, 2=B...)
;
;******************************************************************************

        MOV   AH, 44H
        MOV   AL, 0EH                   ; GET THE OWNER OF LOGICAL DRIVE NUMBER
        INT   21H

        CMP   AL, 0                     ;ONLY ONE DRIVE LETTER ASSIGNED?
;       $IF   E
        JNE $$IF36
            MOV   AL, BL                ;THEN SET IT TO THE INPUT DRIVE LETTER
;       $ENDIF
$$IF36:

        RET

GET_LOGICAL_DRIVE ENDP
        HEADER <DISKETTE_DRV_TYPE - CHECK COMPATABILITY SOURCE/TARGET DRIVES>
;******************************************************************************
; SUBROUTINE NAME :  DISKETTE_DRV_TYPE DOES THE FOLLOWING:                    *
;                    - GETS SOURCE, TARGET DRIVE INFORMATIONS                 *
;                    - CHECK IF IT IS A REMOVABLE DRIVE.                      *
; INPUT           :  SOURCE_DRIVE  &  TARGET_DRIVE                            *
;                          1 = DRIVE A          2 = DRIVE B, ETC.             *
;                                                                             *
; OUTPUT          :  DX : FINE    - NO ERROR                                  *
;                         (OTHERS)- ERROR MSG OFFSET                          *
;******************************************************************************
DISKETTE_DRV_TYPE PROC NEAR
        PUBLIC DISKETTE_DRV_TYPE        ;MAKE ENTRY IN LINK MAP                 ;AN000;

        PUSH  AX
        XOR   BX,BX
        MOV   BL, ORG_SOURCE_DRIVE
        MOV   CL, GETDEVPARM            ;=60h
        MOV   DX, OFFSET DS_IOCTL_DRV_PARM ;POINTER TO THE CONTROL STRING
        CALL  GENERIC_IOCTL             ;GET DEVICE PARM.

        TEST  DS_deviceAttributes, 0001h ;CHECK REMOVABLE. 0001 = NOT REMOVABLE
	JZ  check_fixed_disk			;Removable, hard disk also?;C05
        JMP $$IF38                              ;Not removeable, can't copy;C05
check_fixed_disk:                               ;Here to check for fixed d ;C05
        cmp   DS_DeviceType,FixedDisk           ;Q: Removeable fixed disk? ;C05
        JE  $$IF38                              ; Y: then error out        ;C05

        MOV   AX, DS_numberOfCylinders
        MOV   S_DRV_TRACKS, AX
        MOV   BX, OFFSET DS_BPB_PTR
        MOV   AX, [BX].CHead
        MOV   S_DRV_HEADS, AL
        MOV   AX, [BX].CSECT_TRACK
        MOV   S_DRV_SECT_TRACK, AL
        MOV   AX, [BX].CBYTE_SECT       ;RECOMMENDED BYTES/SECTOR
        MOV   RECOMMENDED_BYTES_SECTOR, AX

        XOR   BX,BX
        MOV   BL, ORG_TARGET_DRIVE
        MOV   CL, GETDEVPARM
        MOV   DX, OFFSET DT_IOCTL_DRV_PARM
        CALL  GENERIC_IOCTL

        TEST  DT_deviceAttributes, 0001h
	JNZ $$IF38				;TARGET IS NOT FIXED DISK, OK		    ;AC000;
        cmp   DS_DeviceType,FixedDisk           ;Q: Removeable fixed disk? ;C05
        JE  $$IF38                              ; Y: then error out        ;C05
	MOV   AX, DT_numberOfCylinders
	MOV   T_DRV_TRACKS, AX
	MOV   BX, OFFSET DT_BPB_PTR
	MOV   AX, [BX].CHead
	MOV   T_DRV_HEADS, AL
	MOV   AX, [BX].CSECT_TRACK
	MOV   T_DRV_SECT_TRACK, AL

;*** CHECK DEVICE COMPATIBILITY
	MOV   DX, FINE		    ;GUESS, ALL WILL BE OK
				    ; DX MAY BE CHANGED TO REFLECT ERROR
	CMP   DS_deviceType, DRV_720 ;0 - 48 TPI, 5.25", 96 TPI,
				    ; 5.25", 2 - 720kb, 3.5"
	JNE $$IF39		    ;WILL ONLY ALLOW DISKCOPY BETWEEN
				    ; 720KB, 3.5 SOURCE, TARGET

	CMP   DT_deviceType, DRV_720 ;target = 720KB also?
	JE    $$EN38
	CMP   DT_deviceType, DRV_OTHER ;target might be 1.44M ;C02
	JE    $$EN38
	MOV   DX, OFFSET MSGNUM_NOT_COMPATIBLE ;
	jmp   short $$EN38

$$IF39:
	CMP   DT_deviceType, DRV_720 ;SOURCE IS NOT 720kb,
				    ; IS TARGET 720?
	JNE   $$EN38		    ;IF SO, THEN
				    ;DDT IS NOT COMPATIBLE
	CMP   DS_deviceType, DRV_OTHER ;source might be 1.44M ;C02
	JE    $$EN38
	MOV   DX, OFFSET MSGNUM_NOT_COMPATIBLE ;
	JMP   SHORT $$EN38	    ;SINCE SOURCE IS FIXED DISK, ERROR	    ;AC000;

$$IF38:
	MOV   DX, OFFSET MSGNUM_INVALID_DRV ;ISSUE INVALID DRV MSG	    ;AC000;

$$EN38:
        POP   AX
        RET

DISKETTE_DRV_TYPE ENDP
        HEADER <CHECK_REDIRECTION - IS DEVICE REDIRECTED?>
;******************************************************************************
; SUBROUTINE NAME  : CHECK_REDIRECTION   FIND OUT IF DEVICE IS REDIRECTED     *
;                                        IF IT IS, GENERATE ERROR MSG & EXIT  *
; INPUT            : BL - DRIVE TO BE TESTED                                  *
;                  : AL : CURRENT DEFAULT DRIV                                *
;                                                                             *
; OUTPUT           : DX                = LOCAL_DRV  (-1)                      *
;                                      = DIRECTED   ( ERROR MSG OFFSET)       *
;                                      = INVALID_DRIVE (ERROR MSG OFFSET)     *
;******************************************************************************
CHECK_REDIRECTION PROC NEAR
        PUBLIC CHECK_REDIRECTION        ;MAKE ENTRY IN LINK MAP                 ;AN000;

        PUSH  AX                        ;SAVE REGISTERS
        PUSH  BX
        PUSH  CX

        MOV   CX,DX                     ;SAVE RET TEMPORARILY
        MOV   AH,IOCTL_FUNC             ;GET IOCTL FUNTION &
        MOV   AL,REDIRECTED_FUNC        ;IOCTL SUB-FUNCTION ******CHECK***

        INT   21H                       ;AND GO FIND OUT IF IT'S LOCAL
;       $IF   C
        JNC $$IF52
            MOV   CX,OFFSET MSGNUM_INVALID_DRV ;REDIR INVALID                   ;AC000;

;       $ELSE
        JMP SHORT $$EN52
$$IF52:
            TEST  DX,REMOTE_DRV         ;IF DRIVE IS REDIRECTED
;           $IF   NZ
            JZ $$IF54

                MOV   CX,OFFSET MSGNUM_DRV_REDIRECTED ;                         ;AC000;
;           $ENDIF
$$IF54:
;       $ENDIF
$$EN52:
        MOV   DX,CX                     ;GET ERROR MSG @

        POP   CX                        ;RESTORE REGISTERS
        POP   BX
        POP   AX
        RET                             ;RETURN TO CALLER
CHECK_REDIRECTION ENDP
        HEADER <BUFFER_SIZE - FINDS START AND END OF BUFFER>
;******************************************************************************
; SUBROUTINE NAME :  BUFFER_SIZE    DETERMINES WHERE BUFFER STARTS & ENDS     *
; INPUT           :  NONE                                                     *
;                                                                             *
; OUTPUT          :  BUFFER_BEGIN ADDRESS                                     *
;                 :  BUFFER_END   ADDRESS                                     *
;                 :  START_BUFFER ADDRESS
;******************************************************************************
BUFFER_SIZE PROC NEAR
        PUBLIC BUFFER_SIZE              ;MAKE ENTRY IN LINK MAP                 ;AN000;

        PUSH  AX                        ;SAVE REGISTERS
        PUSH  BX
        PUSH  CX
        MOV   BX,OFFSET init            ;GET ADDR OF INIT+1024 AS A FREE MEMORY
        add   bx, 1024                  ;(OFFSET FROM CS, IN BYTES)
        MOV   CL,4                      ;CONVERT OFFSET INTO SEGMT BY DIVIDING
        SHR   BX,CL                     ;IT BY 16

        MOV   AX,CS                     ;CS + OFFSET => INIT @ IN SEGMENT
        ADD   BX,AX                     ;WHERE BUFFER CAN START

                                        ;NEED TO START AT A NEW SECTOR ==>
        AND   BL,CLEAR_SEGMENT          ;TRUNCATE TO PREVIOUS 512 BYTE BOUNDRY
                                        ;(GET PREVIOUS SECTOR NUMBER)
        ADD   BX,20H                    ;THEN, ADVANCE TO THE BEGINNING OF
                                        ;NEXT SECTOR (SINCE PART OF PREVIOUS
                                        ;SECTOR WAS USED)

        MOV   BUFFER_BEGIN,BX           ;SAVE OUR BUFFER START SEGMENT ADDR
        MOV   START_BUFFER,BX           ;SAVE IT AGAIN ELSEWHERE
                                        ;(AT THE BEGINNING OF A SECTOR WITH
                                        ;SEGMENT BITS CLEARED)

        MOV   BX,DS:TWO                 ;GET ADDR WHERE BUFFER ENDS
        MOV   BUFFER_END,BX             ;(TOP OF MEMORY, OFFSET 2 IN PSP)

        POP   CX                        ;RESTORE REGISTERS
        POP   BX
        POP   AX
        RET                             ;RETURN TO CALLER
BUFFER_SIZE ENDP
        HEADER <SETUP_CTRL_BREAK - SETUP THE CTRL-BREAK VECTOR>
;******************************************************************************
SETUP_CTRL_BREAK PROC NEAR              ;SETUP CTRL-BREAK VECTOR
        PUBLIC SETUP_CTRL_BREAK         ;MAKE ENTRY IN LINK MAP                 ;AN000;
;******************************************************************************
        PUSH  AX
        PUSH  BX
        PUSH  DX
        PUSH  ES

        MOV   AX,2523H                  ;SET THE CTRL-BREAK VECTOR
        MOV   DX,OFFSET MAIN_EXIT
        INT   21H

        POP   ES
        POP   DX
        POP   BX
        POP   AX
        RET

SETUP_CTRL_BREAK ENDP
        HEADER <CHECK_SERVER - IS SERVER OR REDIRECTOR LOADED?>
;******************************************************************************
CHECK_SERVER PROC NEAR                  ;SEE IF SERVER OR REDIRECTOR IS IN++
        PUBLIC CHECK_SERVER             ;MAKE ENTRY IN LINK MAP                 ;AN000;
;
; INPUT: BL = DRIVE NUMBER (1=A,2=B ETC....)
;******************************************************************************
        MOV   AH,0                      ;SEE IF SERVER LOADED
        INT   SERVER
        CMP   AH,0
;       $IF   E
        JNE $$IF57
            MOV   DX,FINE
;       $ELSE
        JMP SHORT $$EN57
$$IF57:
            DEC   BL
            ADD   BL,"A"                ;CONVERT TO ASCII DRIVE LETTER
            MOV   ASCII_DRIVE_LETTER,BL ;PUT IN ASCIIZ STRING
            MOV   SI,OFFSET ASCII_DRIVE_LETTER
            MOV   AH,SHARED
            CLC
            INT   SERVER
;           $IF   C
            JNC $$IF59
                MOV   DX,OFFSET MSGNUM_DRV_REDIRECTED ;AC000;
;           $ELSE
            JMP SHORT $$EN59
$$IF59:
                MOV   DX,FINE
;           $ENDIF
$$EN59:
;       $ENDIF
$$EN57:
        RET
CHECK_SERVER ENDP

        Public INIT_END
INIT_END LABEL BYTE
        PATHLABL COMPINIT               ;AN013;
CSEG    ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcomp\dcompsm.asm ===
PAGE	90,132			;AN000;A2
	TITLE	DCOMPSM.SAL - DISKCOMP SYSTEM MESSAGES
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: DCOMPSM.SAL

; DESCRIPTIVE NAME: Include the DOS system MESSAGE HANDLER in the SEGMENT
;		    configuration expected by the modules of DISKCOMP.

;FUNCTION: The common code of the DOS SYSTEM MESSAGE HANDLER is made a
;	   part of the DISKCOMP module by using INCLUDE to bring in the
;	   common portion, in SYSMSG.INC.  This included code contains
;	   the routines to initialize for message services, to find
;	   where a particular message is, and to display a message.

; ENTRY POINT: SYSDISPMSG:near
;	       SYSGETMSG:near
;	       SYSLOADMSG:near

; INPUT:
;    AX = MESSAGE NUMBER
;    BX = HANDLE TO DISPLAY TO (-1 means use DOS functions 1-12)
;    SI = OFFSET IN ES: OF SUBLIST, OR 0 IF NONE
;    CX = NUMBER OF %PARMS, 0 IF NONE
;    DX = CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW
;   CALL SYSDISPMSG		;DISPLAY THE MESSAGE

;    If carry set, extended error already called:
;    AX = EXTENDED MESSAGE NUMBER
;    BH = ERROR CLASS
;    BL = SUGGESTED ACTION
;    CH = LOCUS
; _ _ _ _ _ _ _ _ _ _ _ _

;    AX = MESSAGE NUMBER
;    DH = MESSAGE CLASS (1=DOS EXTENDED ERROR, 2=PARSE ERROR, -1=UTILITY MSG)
;   CALL SYSGETMSG		 ;FIND WHERE A MSG IS

;    If carry set, error
;     CX = 0, MESSAGE NOT FOUND
;    If carry  NOT set ok, and resulting regs are:
;     CX = MESSAGE SIZE
;     DS:SI = MESSAGE TEXT
; _ _ _ _ _ _ _ _ _ _ _ _

;   CALL SYSLOADMSG		 ;SET ADDRESSABILITY TO MSGS, CHECK DOS VERSION
;    If carry not set:
;    CX = SIZE OF MSGS LOADED

;    If carry is set, regs preset up for SYSDISPMSG, as:
;    AX = ERROR CODE IF CARRY SET
;	  AX = 1, INCORRECT DOS VERSION
;	  DH =-1, (Utility msg)
;	OR,
;	  AX = 1, Error loading messages
;	  DH = 0, (Message manager error)
;    BX = STDERR
;    CX = NO_REPLACE
;    DL = NO_INPUT

; EXIT-NORMAL: CARRY is not set

; EXIT-ERROR:  CARRY is set
;	       Call Get Extended Error for reason code, for SYSDISPMSG and
;	       SYSGETMSG.

; INTERNAL REFERENCES:
;    ROUTINES: (Generated by the MSG_SERVICES macro)
;	SYSLOADMSG
;	SYSDISPMSG
;	SYSGETMSG

;    DATA AREAS:
;	INCLUDED "DCOMPMS.INC" - message defining control blocks
;	INCLUDE SYSMSG.INC   ;Permit System Message handler definition

; EXTERNAL REFERENCES:
;    ROUTINES: none

;    DATA AREAS: control blocks pointed to by input registers.

; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:

;		SALUT DCOMPSM,NUL

;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.

;	 For LINK instructions, refer to the PROLOG of the main module,
;	 DISKCOMP.SAL.

; COPYRIGHT: "Version 4.00 (C)Copyright 1988 Microsoft"
;	     "Licensed Material - Property of Microsoft  "
;
;****************** END OF SPECIFICATIONS *****************************
	IF1				;AN000;
	    %OUT    COMPONENT=DISKCOMP, MODULE=DCOMPSM.SAL... ;AN000;
	ENDIF				;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<LOCAL MACRO DEFINITIONS> ;AN000;
	INCLUDE PATHMAC.INC		;AN013;
; =  =	=  =  =  =  =  =  =  =	=  =
HEADER	MACRO	TEXT			;;AN000;
.XLIST					;;AN000;
	SUBTTL	TEXT			;AN000;
.LIST					;;AN000;
	PAGE				;;AN000;
	ENDM				;;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	INCLUDE SYSMSG.INC		;AN000;PERMIT SYSTEM MESSAGE HANDLER DEFINITION
	MSG_UTILNAME <DISKCOMP> 	;AN000;IDENTIFY THE COMPONENT
; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<DEFINITION OF MESSAGES> ;AN000;
;	   $SALUT (4,12,18,36)	   ;AN000;
CSEG	   SEGMENT PARA PUBLIC 'CODE' ;AN000;
	   ASSUME CS:CSEG	   ;AN000;ESTABLISHED BY CALLER
	   ASSUME SS:CSEG	   ;AN000;ESTABLISHED BY CALLER
	   ASSUME DS:CSEG	   ;AN000;ESTABLISHED BY CALLER
	   ASSUME ES:CSEG	   ;AN000;ESTABLISHED BY CALLER

;(deleted ;AN010;) PUBLIC COPYRIGHT ;
;(deleted ;AN010;) COPYRIGHT DB "MS DOS DISKCOMP Utility                   "
;(deleted ;AN010;) INCLUDE COPYRIGH.INC ;(moved to MSG_SERVICES)
	   HEADER <MESSAGE HANDLER CONTROL BLOCKS> ;AN000;
	   INCLUDE MSGHAN.INC	   ;AN000;DEFINE THE MESSAGE HANDLER CONTROL BLOCKS
	   INCLUDE DCOMPMS.INC	   ;AN000;DEFINE THE MESSAGES, AND CONTROL BLOCKS
	   HEADER <MESSAGE DATA AREAS> ;AN000;
	   MSG_SERVICES <MSGDATA>  ;AN000;DATA AREA FOR THE MESSAGE HANDLER
; =  =	=  =  =  =  =  =  =  =	=  =
	   HEADER <SYSTEM MESSAGE HANDLER> ;AN000;
	   PUBLIC SYSLOADMSG	   ;AN000;
	   PUBLIC SYSDISPMSG	   ;AN000;

	   MSG_SERVICES <DISKCOMP.CLA,DISKCOMP.CL1,DISKCOMP.CL2> ;AN000;MSG TEXT
	   PATHLABL DCOMPSM	   ;AN013;
				   ;DEFAULT=CHECK DOS VERSION
				   ;DEFAULT=NEARmsg
				   ;DEFAULT=INPUTmsg
				   ;DEFAULT=NUMmsg
				   ;DEFAULT=NO TIMEmsg
				   ;DEFAULT=NO DATEmsg
				   ;DEFAULT=NO GETmsg
;	   MSG_SERVICES <LOADmsg,DISPLAYmsg,CHARmsg,NUMmsg,INPUTmsg>
.XLIST				   ;AN000;
.XCREF				   ;AN000;
	   MSG_SERVICES <LOADmsg,DISPLAYmsg,CHARmsg,NUMmsg,INPUTmsg> ;AN000;
.LIST				   ;AN000;
.CREF				   ;AN000;
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	   PATHLABL DCOMPSM	   ;AN013;


CSEG	   ENDS 		   ;AN000;

include msgdcl.inc

	   END			   ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcopy\copyinit.asm ===
PAGE    90,132                  ;A2
        TITLE   COPYINIT -- DISKCOPY INITIALIZATION PROGRAM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: COPYINIT

; DESCRIPTIVE NAME: Initialization for Diskette to diskette copy Utility

;FUNCTION: DISKCOPY is to copy the contents of the diskette in the
;          specified source drive to the diskette in the target
;          drive.  If necessary, the target diskette is also
;          formatted.

;          Multiple copies may be performed with one load of DISKCOPY.
;          A prompt, "Copy another (Y/N)?" permits additional
;          executions, all with the same drive specifications.

; ENTRY POINT: "DISKCOPY" at ORG 100h, jumps to "BEGIN".

; INPUT: (DOS command line parameters)
;        [d:][path]DISKCOPY [d: [D:]][/1]

;        Where

;        [d:][path] before DISKCOPY to specify the drive and path that
;                   contains the DISKCOPY command file.

;        [d:]       to specify the source drive id

;        [D:]       to specify the destination drive id

;        [/1]       to request single sided operations only

; EXIT-NORMAL: Errorlevel = 0
;             Function completed successfully.

; EXIT-ERROR: Errorlevel = 1
;             Abnormal termination due to error, wrong DOS,
;             invalid parameters, unrecoverable I/O errors on
;             the diskette.

; EFFECTS: The entire source diskette is copied, including the unused
;          sectors.  There is no awareness of the separate files
;          involved.  A unique volume serial number is generated
;          for the target diskette.

; INCLUDED FILES:
;       INCLUDE DCPYMACR.INC
;       INCLUDE DISKCOPY.EQU
;       INCLUDE PATHMAC.INC             ;PATHGEN MACRO

; INTERNAL REFERENCES:
;    ROUTINES:
;       INIT - INITIALIZATION ROUTINE, MAIN PROGRAM
;       SOURCE_TARGET_DRV - CONVERT SOURCE/TARGET DRIVE TO BIOS VALUES
;       TEST_DRIVE_VALIDITY - ARE SOURCE/TARGET DRIVES VALID?
;       DOS_DRIVE_VALIDITY - CHECK DOS DRIVE VALIDITY BYTE
;       TEST_REMOVABLE - IS SPECIFIED DRIVE REMOVABLE?
;       CHK_SINGLE_DRIV_OP - IS TARGET DRIVE SAME AS SOURCE?
;       GET_LOGICAL_DRIVE - GET LOG. DRIV NO. WHO OWNS PHYSICAL DRIVE
;       DISKETTE_DRV_TYPE - CHECK COMPATABILITY SOURCE/TARGET DRIVES
;       CHECK_REDIRECTION - IS DEVICE REDIRECTED?
;       BUFFER_SIZE - FINDS START AND END OF BUFFER
;       SETUP_CTRL_BREAK - SETUP THE CTRL-BREAK VECTOR
;       CHECK_SERVER - IS SERVER OR REDIRECTOR LOADED?

;    DATA AREAS:
;       PSP - Contains the DOS command line parameters.
;       WORKAREA - Temporary storage

; EXTERNAL REFERENCES:
;    ROUTINES:
;       SYSDISPMSG - Uses the MSG parm lists to construct the messages
;                on STDOUT.
;       SYSLOADMSG - Loads messages, makes them accessable.
;       PARSER - Processes the DOS Command line, finds parms.

;    DATA AREAS:
;        DCOPYSM.SAL - Defines the control blocks that describe the messages
;        DCOPYPAR.SAL - Defines the control blocks that describe the
;               DOS Command line parameters.

; NOTES:
;        This module should be processed with the SALUT preprocessor
;        with the re-alignment not requested, as:

;               SALUT COPYINIT,NUL

;        To assemble these modules, the alphabetical or sequential
;        ordering of segments may be used.

;        For instructions as to how to LINK, see prolog for DISKCOPY.

;PROGRAM AUTHOR: Original written by: JK
;                4.00 modifications by: EMK
;       ;C02    MKS     Bug#727 against DISKCOMP wasn't allowing two 720k
;                       diskettes to DISKCOMP or DISKCOPY if they were in
;                       drives of differing capacities.  This is fixed by
;                       checking for drive type 7 as well as 2, and permitting
;                       the copy if both diskettes are 720k.  The equate
;                       DRV_OTHER comes from DISKCOPY.EQU.
;       ;C05    MKS     Bug#1061.  Removeable hard disks were causing problems.
;                       Now they are disallowed.  FixedDisk comes from
;                       DISKCOPY.EQU.
;****************** END OF SPECIFICATIONS *****************************
        IF1
            %OUT    COMPONENT=DISKCOPY, MODULE=COPYINIT.SAL
        ENDIF

;DATE:   9-22-83
;TIME:   8:00 PM
;DATE:   10-30-84 - chk_para routine added. many parts are modified to
;        permit DISKCOPY /1, DISKCOPY D: /1 cases. Restore diskbase
;        before return to DOS when invalid DOS version occurs.
;DATE:   3-27-85  MAIN PARTS OF DISKCOPY PROGRAM HAS BEEN REWRITTEN
;        TO USE NEW IOCTL FUNCTION CALLS - READ, WRITE AND FORMAT.

        INCLUDE DCPYMACR.INC
        INCLUDE PATHMAC.INC             ;AN015;PATHGEN MACRO

CSEG    SEGMENT PARA PUBLIC 'CODE'      ;AN000;
        ASSUME  CS:CSEG, DS:CSEG, ES:CSEG, SS:CSEG

        INCLUDE DISKCOPY.EQU
	INCLUDE	VERSION.INC		; M003
;$salut (4,2,9,41)
;****************************************************************************
;                                                                           *
;                        EXTERNAL VARIABLES                                 *
;                                                                           *
;****************************************************************************

 EXTRN  PARSER:NEAR                     ;DCOPYPAR.SAL - DRIVES SYS PARSER       ;AN000;

 EXTRN  RECOMMENDED_BYTES_SECTOR:WORD   ;SOURCE DRIVE DEFAULT BYTES/SECTOR
 EXTRN  S_OWNER_SAVED:BYTE
 EXTRN  T_OWNER_SAVED:BYTE
 EXTRN  ASCII_DRV1_ID:BYTE              ;40H    SOURCE DRIVE ID IN ASCII
 EXTRN  ASCII_DRV2_ID:BYTE              ;40H    TARGET DRIVE ID IN ASCII
 EXTRN  MSGNUM_INVALID_DRV:BYTE         ;"INVALID DRIVE SPECIFICATION"          ;AC000;
 EXTRN  MSGNUM_NOT_COMPATIBLE :BYTE     ;"DEVICE TYPE OF DISKETTE TYPES NOT COMPATIBLE";AC000;
 EXTRN  MSGNUM_DRV_REDIRECTED:BYTE      ;"INVALID, DRIVE REDIRECTED"            ;AC000;
 EXTRN  MSGNUM_OPTIONS       :BYTE      ; /? options message
 EXTRN  MSG_OPTIONS_FIRST    :ABS       ; /? first options message
 EXTRN  MSG_OPTIONS_LAST     :ABS       ; /? last options message
IF	IBMCOPYRIGHT NE TRUE		; M003
 EXTRN  MSGNUM_CMCDD_DRIVE   :BYTE	; M003
ENDIF					; M003

 EXTRN  SENDMSG              :NEAR      ; message sender

 EXTRN  SUBLIST_8            :WORD      ;                                       ;AN000;
 EXTRN  SUBLIST_9            :WORD      ;                                       ;AN000;
 EXTRN  SUBLIST_13           :WORD      ;                                       ;AN000;
 EXTRN  SUBLIST_17A          :WORD      ;                                       ;AN000;
 EXTRN  SUBLIST_17B          :WORD      ;                                       ;AN000;
 EXTRN  SUBLIST_17C          :WORD      ;                                       ;AN000;
 EXTRN  SUBLIST_19C          :WORD      ;                                       ;AN000;
 EXTRN  SUBLIST_19D          :WORD      ;                                       ;AN000;
 EXTRN  SUBLIST_19E          :WORD      ;                                       ;AN000;
 EXTRN  SUBLIST_26A          :WORD      ;                                       ;AN001;
 EXTRN  SUBLIST_26B          :WORD      ;                                       ;AN001;
 EXTRN  SUBLIST_PARSE:WORD              ;PARSE ERROR XX - %0                         ;AN003;

.XLIST
;EXTRN  MSG_INVALID_PARM_PTR:BYTE       ;"INVALID PARAMETER"
;EXTRN  MSG_INVALID_DOS :BYTE           ;"INVALID DOS"
.LIST
 EXTRN  S_DRV_SECT_TRACK :BYTE          ;SECT/TRACK
 EXTRN  S_DRV_HEADS :BYTE               ;# OF HEADS
 EXTRN  S_DRV_TRACKS :WORD              ;# OF TRACKS
 EXTRN  T_DRV_SECT_TRACK :BYTE
 EXTRN  T_DRV_HEADS :BYTE
 EXTRN  T_DRV_TRACKS :WORD
 EXTRN  SOURCE_DRIVE :BYTE              ;SRC DRV LOGICAL NUMBER
 EXTRN  TARGET_DRIVE :BYTE              ;TARGET DRV LOGICAL NUMBER
 EXTRN  COPY_TYPE :BYTE                 ;1 = 1-DRIVE COPY  2 = 2-DRIVE COPY
 EXTRN  USER_OPTION :BYTE               ;NO OPTION (-1)  /1 (1), INVALID (9)
 EXTRN  BUFFER_BEGIN :WORD              ;STARTING BUFFER @ FOR LOADING
 EXTRN  BUFFER_END :WORD                ;ENDING BUFFER @ FOR LOADING
 EXTRN  MAIN_EXIT :WORD                 ;EXIT ADDRESS FOR CONTROL-BREAK
 EXTRN  SHOW_OPTIONS :BYTE              ; show command line options and exit

 EXTRN  IO_ERROR :BYTE

 EXTRN  DS_IOCTL_DRV_PARM :BYTE         ;PLACE HOLDER FOR DEFAULT SOURCE DRV PARM
 EXTRN  DT_IOCTL_DRV_PARM :BYTE         ;PLACE HOLDER FOR DEFAULT TARGET DRV PARM
 EXTRN  DS_specialFunctions :BYTE       ;AND THEIR CONTENTS
 EXTRN  DT_specialFunctions :BYTE
 EXTRN  DS_deviceType:BYTE
 EXTRN  DT_deviceType:BYTE
 EXTRN  DS_deviceAttributes :WORD
 EXTRN  DT_deviceAttributes :WORD
 EXTRN  DS_numberOfCylinders :WORD
 EXTRN  DT_numberOfCylinders :WORD
 EXTRN  DS_mediaType :BYTE
 EXTRN  DT_mediaType :BYTE
 EXTRN  DS_BPB_PTR :BYTE
 EXTRN  DT_BPB_PTR :BYTE

 EXTRN  MS_IOCTL_DRV_PARM :BYTE         ;DRIVE PARM FROM SOURCE MEDIUM
 EXTRN  MT_IOCTL_DRV_PARM :BYTE

 EXTRN  GENERIC_IOCTL :NEAR
 EXTRN  SET_LOGICAL_DRIVE :NEAR

;                  $salut (4,20,24,41)  ;                                       ;AN000;
MY_BPB             STRUC
CBYTE_SECT         DW  0                ; 200H  BYTES / SECTOR
CSECT_CLUSTER      DB  0                ; 2h    SECTORS / CLUSTER
CRESEV_SECT        DW  0                ; 1h    RESERVED SECTORS
CFAT               DB  0                ; 2h    # OF FATS
CROOTENTRY         DW  0                ; 70h   # OF ROOT ENTRIES
CTOTSECT           DW  0                ; 02D0h TOTAL # OF SECTORS
                                        ;   INC. BOOT SECT, DIRECTORIES
MEDIA_DESCRIP      DB  0                ;0FDh   MEDIA DISCRIPTOR
CSECT_FAT          DW  0                ; 2h    SECTORS / FAT
CSECT_TRACK        DW  0                ;
CHEAD              DW  0                ;
CHIDDEN_SECT       DD  0                ;
BIG_TOT_SECT       DD  0                ;
                   DB  6 DUP (0)        ;
MY_BPB             ENDS


;****************************************************************************
;                                                                           *
;                        VARIABLE DECLARATIONS                              *
;                                                                           *
;****************************************************************************
DRIVE_VALID        DW  ?                ;DRIVE VALIDITY INDICATOR
DEFAULT_DRV        DB  ?                ;DEFAULT DRIVE ID (0=A,1=B,ETC)
NUMBER_OF_DRV      DB  ?                ;TOTAL # OF DISKT DRIVES ON THE SYS
                                        ;(NUMBER_OF_DRV = 0 ---> 1 DRIVE)
ASCII_DRIVE_LETTER DB  " :",0
                   PATHLABL COPYINIT    ;AN015;
                   HEADER <INIT - INITIALIZATION ROUTINE, MAIN PROGRAM> ;       ;AN000;
;       $salut (4,9,15,41)              ;                                       ;AN000;
;#############################################################################
;                     INITIALIZATION ROUTINE - MAIN PROGRAM
INIT    PROC  NEAR
        PUBLIC INIT                     ;MAKE ENTRY IN LINK MAP                 ;AN000;

;OUTPUT: DX = EXIT CODE, "FINE"
;#############################################################################

        MOV   DRIVE_VALID,AX            ;SAVE DRIVE VALIDITY BYTE

;               REPLACE THE "FILL_SEG" IN THE SUBLIST MESSAGE CONTROL BLOCKS.

;               BECAUSE THIS IS A .COM STYLE FILE, THESE SEGID VALUES CANNOT
;               BE PROVIDED BY THE DOS SYSTEM LOADER, BUT MUST BE DYNAMICALLY
;               PERFORMED AT EXECUTION TIME AS PART OF A .COM FILE'S OBLIGATION
;               TO BE "SELF-RELOCATING".

        MOV   AX,CS                     ;GET SEGID OF COMMON SEGMENT            ;AN000;
        MOV   SUBLIST_8.SUB_VALUE_SEG,AX ;                                      ;AN000;
        MOV   SUBLIST_9.SUB_VALUE_SEG,AX ;                                      ;AN000;
        MOV   SUBLIST_13.SUB_VALUE_SEG,AX ;                                     ;AN000;
        MOV   SUBLIST_17A.SUB_VALUE_SEG,AX ;                                    ;AN000;
        MOV   SUBLIST_17B.SUB_VALUE_SEG,AX ;                                    ;AN000;
        MOV   SUBLIST_17C.SUB_VALUE_SEG,AX ;                                    ;AN000;
        MOV   SUBLIST_19C.SUB_VALUE_SEG,AX ;                                    ;AN000;
        MOV   SUBLIST_19D.SUB_VALUE_SEG,AX ;                                    ;AN000;
        MOV   SUBLIST_19E.SUB_VALUE_SEG,AX ;                                    ;AN000;
        MOV   SUBLIST_26A.SUB_VALUE_SEG,AX ;                                    ;AN001;
        MOV   SUBLIST_26B.SUB_VALUE_SEG,AX ;                                    ;AN001;
        MOV   SUBLIST_PARSE.SUB_VALUE_SEG,AX ;                                  ;AN003;

        CALL  SETUP_CTRL_BREAK          ;STEALS CTRL_BREAK
        CLD                             ;CLEAR DIRECTION FLAG
        MOV   DX,FINE                   ;ASSUME EVERYTHING IS FINE
.XLIST
;        CALL  SCREENING                 ;CHECK DOS VERSION AND INPUT PARMS
;        CALL  CHK_PARA                  ; GENERAL SYNTAX CHECK
.LIST
        CALL  PARSER                    ;LOOK AT DOS COMMAND LINE               ;AN000;

        CMP   DX,FINE                   ;IF ALL OK                              ;AN000;
;       $IF   E                         ;                                       ;AN000;
        JNE $$IF1

            ; If the user entered /? on the command line,
            ; show them the possible options and then exit.

            cmp   SHOW_OPTIONS, 0       ; does the user want them?
            je    ShowOptionsDone       ; jump if not
            call  DISPLAY_OPTIONS       ;  else display message
            mov   DX, offset MSGNUM_OPTIONS     ; to get back out
            jmp   short EXIT_INIT       ; and bail out with it
ShowOptionsDone:

            CALL  SOURCE_TARGET_DRV     ;SET UP TO USE THE DRIVE LETTERS        ;AN000;

            CALL  TEST_DRIVE_VALIDITY

            CMP   DX,FINE
;           $IF   E                     ;                                       ;AN000;
            JNE $$IF2
                CALL  DISKETTE_DRV_TYPE ;SOURCE & TARGET DRIVE TYPES

                CMP   DX,FINE           ;IF FINE & DANDY
;               $IF   E                 ;                                       ;AN000;
                JNE $$IF3
                    CALL  BUFFER_SIZE   ;GET BUFFER SIZE FOR COPYING

;               $ENDIF                  ;                                       ;AN000;
$$IF3:
;           $ENDIF                      ;                                       ;AN000;
$$IF2:
;       $ENDIF                          ;                                       ;AN000;
$$IF1:
EXIT_INIT:                              ;DX <-- 1  IF INIT OK
        RET                             ;DX <-- ERROR OFFSET IF NOT OK
                                        ;RETURN TO CALLER
INIT    ENDP                            ;END INITIALLIZATION PROGRAM

         HEADER <DISPLAY_OPTIONS - DISPLAY OPTIONS MSG>
;******************************************************************************
; SUBROUTINE NAME :  DISPLAY_OPTIONS                                          *
;                                                                             *
; INPUT           :  NONE                                                     *
;                                                                             *
; OUTPUT          :  NONE                                                     *
;                                                                             *
; FUNCTION        :  Displays all the lines of the user options message on    *
;                    standard output.                                         *
;                                                                             *
;******************************************************************************

        PUBLIC  DISPLAY_OPTIONS
DISPLAY_OPTIONS PROC NEAR

        push    di
        mov     di, offset MSGNUM_OPTIONS       ; get message
DO_LOOP:
        call    SENDMSG                 ; send this line
        cmp     word ptr[MSGNUM_OPTIONS], MSG_OPTIONS_LAST      ; last msg?
        je      DO_DONE                 ; done if so
        inc     word ptr[MSGNUM_OPTIONS]        ; else bump msg number
        jmp     short DO_LOOP           ; and go display it.
DO_DONE:
        pop     di
        ret

DISPLAY_OPTIONS ENDP

.XLIST
;        HEADER <SCREENING - CHECK DOS VERSION, SYNTAX PARMS>
;******************************************************************************
; SUBROUTINE NAME :  SCREENING  - CHECKS THE FOLLOWING:                       *
;                                 - DOS VERSION                               *
;                                 - GENERAL SYNTAX CHECKING FOR PARAMETERS    *
; INPUT           :  NONE                                                     *
; OUTPUT          :  DX : FINE    - NO ERROR                                  *
;                         (OTHERS)- ERROR MSG OFFSET                          *
;******************************************************************************

;SCREENING PROC NEAR
                                        ;CHECK DOS VERSION:
;        MOV   AH,DOSVER_FUNC            ;SEE IF CORRECT DOS VERSION
;        INT   21H                       ;FUNCTION CALL (AL <- DOS VERSION)
                                        ;NOTE: BX IS DESTROYED
;       XCHG    AH,AL                   ;AH=MAJOR VER, AL=MINOR VER
;        CMP   AX,expected_version       ;IF DOS MAJOR VERSION LESS THAN 3.00
;        $IF   NE                        ;THEN ISSUE ERROR MSG
;            MOV   DX,OFFSET MSG_INVALID_DOS
;            MOV   AH,PRINT_FUNC         ;USE PRINT FUNCTION TO TELL USER
;            INT   21H                   ;THAT HE IS USING THE OLD VERSION
;            INT   20H                   ;EXIT TO DOS
;        $ELSE                           ;VERSION OK
;            CALL  CHK_PARA              ;GENERAL SYNTAX CHECK
;        $ENDIF                          ;END VERSION TEST
;        RET
;SCREENING ENDP
;        HEADER <CHK_PARA - SYNTAX PARMS, OPTION /1>
;**************************************************************************

;kiser: this proc is to be deleted

;CHK_PARA PROC NEAR
;       CHECK SYNTAX OF THE ENTERED PARAMETERS                            *
;       ALSO, DETERMINE THE USER OPTION "/1" IS ENTERED OR NOT.           *
;  INPUT: DX = FINE                                                       *
;         IF /1 HAS BEEN ENTERED, THE VARIABLE USER_OPTION = OPTION_1     *
;         ELSE USER_OPTION = NO_OPTION.                                   *
;  OUTPUT: DX = FINE    - NO ERROR                                        *
;          OTHERWISE DX POINTS TO ERROR MSG                               *
;**************************************************************************
;        PUSH  CX
;        MOV   USER_OPTION, NO_OPTION    ;ASSUME NO /1 IS ENTERED.
;        XOR   CX, CX
;        MOV   CL, BYTE PTR DS:BEGIN_UNFORM_AREA ;GET # OF CHR
;        CMP   CL, 0
;        $IF   NZ
;            CLD                         ;CLEAR DIRECTION
;            MOV   DI, BEGIN_UNFORM_AREA+2 ;STARTING POINT OF PARA
;            DEC   CL                    ;TO IGNORE LAST CHR (0DH)
;            CALL  SKIP_BLANKS           ;SKIP BLANKS, IF ANY. THE POINTER
;                                        ; WILL POINT TO THE NEXT NON_BLANK CHR
;
;            $IF   NZ                    ;SOMETHING OTHER THAN BLANKS
;                                        ; ARE ENTERED
;                CALL  CHK_SLASH_ONE     ;IS NEXT WORD /1 ?
;
;                JNC   SLASH_ONE         ;YES
;                CALL  CHK_DRV_SPEC      ;IS IT A DRIVE SPECIFICATION LIKE d: ?
;
;                JC    INVALID_PARA      ;IF NOT, THEN ERROR
;                JZ    CHK_PARA_EXIT     ;NO MORE CHR? THEN, OK. (EX. DISKCOPY D:)
;                CALL  CHK_SLASH_ONE     ;IS NEXT WORD /1 ?
;
;                JNC   SLASH_ONE         ;YES.(EX. DISKCOPY D:/1)
;                CALL  CHK_BLANK         ;IF NOT, NEXT CHR SHOULD BE A BLANK.
;
;                JC    INVALID_PARA      ;OTHERWISE, ERROR.
;                CALL  SKIP_BLANKS       ;SKIP BLANKS, IF ANY.
;
;                JZ    CHK_PARA_EXIT     ;(EX. DISKCOPY D:  )
;                CALL  CHK_SLASH_ONE     ;IS IT A /1 ?
;
;                JNC   SLASH_ONE         ;YES. (EX. DISKCOPY D:  /1)
;                CALL  CHK_DRV_SPEC      ;IF NOT /1, THEN IS IT A DRV SPEC?
;
;                JC    INVALID_PARA      ;OTHERWISE, ERROR.
;                CALL  SKIP_BLANKS       ;SKIP BLANKS, IF ANY.
;
;                JZ    CHK_PARA_EXIT     ;NO MORE CHR. (EX. DISKCOPY D: D:)
;                CALL  CHK_SLASH_ONE     ;OTHERWISE, IT SHOULD BE /1.
;
;                JNC   SLASH_ONE         ;YES, /1. JMP TO SLASH_ONE
;                JMP   INVALID_PARA      ;PARAMETER ERROR.
;SLASH_ONE:
;                MOV   USER_OPTION, OPTION_1 ;YES, /1 HAS BEEN ENTERED.
;                CALL  SKIP_BLANKS       ;/1 SHOULD BE END OF PARAMETERS, OR ONLY BLANKS CAN FOLLOW.
;
;                $IF   NZ
;INVALID_PARA:
;                    MOV   DX,OFFSET MSG_INVALID_PARM_PTR ;WRONG PARM ENTERED MSG
;                $ENDIF
;            $ENDIF
;        $ENDIF
;CHK_PARA_EXIT:
;        POP   CX
;
;        RET
;CHK_PARA ENDP
;        HEADER <SKIP_BLANKS - IGNORE BLANKS/TABS IN PARMS PARSING>
;***************************************************************************
;SKIP_BLANKS PROC NEAR
; ** SKIP BLANKS, OR TABS IF ANY, IN THE PARAMETER STRING.                 *
; INPUT: ES:DI POINTS TO THE CURRENT CHR.                                  *
;        CX - # OF REMAINING CHR IN THE STRING.                            *
; OUTPUT: ES:DI POINT TO THE NEXT NON_BLANK CHR.                           *
;         CX IS ADJUSTED ACCORINGLY.                                       *
;         IF THE CURRENT CHR IS NOT A BLANK, THEN DI, CX VALUE NOT CHANGED.*
;         IF CX = 0, THEN ZERO FLAG WILL BE SET AND EXIT THIS PROC.        *
;***************************************************************************
;        $DO
;            MOV   AL, 20H               ;20H=BLANK
;            CLD                         ;CLEAR DIRECTION
;            REPE  SCASB
;        $LEAVE Z                        ;IF NOT FOUND A NON_BLANK CHR YET, AND CX=0, EXIT THIS ROUTINE.
;            DEC   DI                    ;OTHERWISE, RESTORE DI TO THE NON_BLANK POSITION.
;            INC   CX                    ;  AND RESTORE CX TO WHERE IT WAS AT NON_BLANK CHR
;                                        ;(IF FOUND A NON_BLANK CHR, ZERO FLAG WOULD NOT BE SET)
;            MOV   AL, ES:BYTE PTR [DI]
;            CMP   AL, 09H               ;09H=TAB
;        $LEAVE NZ                       ;IF THE NON_BLANK CHR IS NOT A TAB THEN EXIT
;            INC   DI                    ;ELSE TRY SKIP AGAIN
;            DEC   CX
;        $ENDDO
;        RET
;SKIP_BLANKS ENDP
;        HEADER <CHK_SLASH - IS CURRENT PARM /1>
;***************************************************************************

;kiser: this proc is to be deleted

;CHK_SLASH_ONE PROC NEAR
; ** CHECK CURRENT CHR IS / FOLLOWED BY 1.                                 *
; INPUT: ES:DI POINTS TO THE CURRENT CHR TO BE CHECKED.                    *
;        CX REPRESENTS THE # OF CHR'S IN THE STRING.                       *
; OUTPUT: FOUND - DI POINTS TO THE NEXT CHR.  CX CHANGED ACCORDINGLY.      *
;                 IF THIS HAD BEEN A LAST WORD, ZERO FLAG WILL BE SET.     *
;         NOT FOUND - CARRY IS SET. DI, CX UNCHANGED.                      *
;***************************************************************************
;
;        CLC                             ;CLEAR CARRY FLAG
;        CMP   CX, 2                     ;# OF CHR IN THE STRING.
;        $IF   NL,AND                    ;IF LESS THAN 2, THEN SET CARRY AND EXIT.
;
;        MOV   AX, ES:WORD PTR [DI]      ;GET CURRENT WORD IN AX
;        CMP   AX, '1/'                  ;IS IT /1 ?
;        $IF   Z                         ;IF NOT, THEN SET CARRY AND EXIT
;            INC   DI                    ;ADJUST CX, DI TO THE NEXT CHR
;            INC   DI
;            DEC   CX
;            DEC   CX
;            CMP   CX, 0                 ;IF NO MORE CHR, THEN SET ZERO FLAG.
;        $ELSE
;            STC                         ;NOT FOUND, SET CARRY FLAG.
;        $ENDIF
;        RET
;CHK_SLASH_ONE ENDP
;        HEADER <CHK_DRV - CURRENT PARM CHAR IS DRIVE AND COLON?>
;***************************************************************************

;kiser: this proc is to be deleted

;CHK_DRV_SPEC PROC NEAR
; ** CHECK CURRENT CHR IS ALPHA CHR FOLLOWED BY COLON.                     *
; INPUT: ES:DI POINTS TO THE CURRENT CHR TO BE CHECKED.                    *
;        CX -- # OF CHR IN THE STRING.                                     *
; OUTPUT: FOUND - DI POINTS TO THE NEXT CHR. CX ADJUSTED ACCORDINGLY.      *
;                 IF THIS HAD BEEN A LAST WORD, ZERO FLAG WILL BE SET.     *
;         NOT FOUND - CARRY IS SET. DI, CX UNCHANGED.                      *
;***************************************************************************

;        CLC                             ;CLEAR CARRY
;        CMP   CX, 2                     ;# OF CHR REMAINING IN THE STRING.
;        $IF   NL,AND                    ;IF NOT LESS THAN 2, THEN FOUND
;                                        ;IF LESS THAN 2, THEN NOT FOUND - SET CARRY AND EXIT.
;        MOV   AL, ES:BYTE PTR [DI]      ;GET CURRENT CHR
;        AND   AL, 11011111B             ;CHANGE IT TO UPPER_CASE CHR.
;        CMP   AL, 'A'
;        $IF   NB,AND                    ;NOT BELOW 'A', THEN MAYBE FOUND OK
;
;        CMP   AL, 'Z'
;        $IF   NA,AND                    ;NOT ABOVE 'Z', THEN FOUND
;
;        MOV   AL, ES:BYTE PTR [DI+1]    ;LOOK AHEAD THE FOLLOWING CHR.
;        CMP   AL, ':'                   ;SHOULD BE A COLON.
;        $IF   Z                         ;IF FOUND.
;            INC   DI                    ;FOUND. ADJUST CX, DI TO THE NEXT CHR.
;            INC   DI
;            DEC   CX
;            DEC   CX
;            CMP   CX, 0                 ;IF NO MORE CHR, THAN SET THE ZERO FLAG.
;        $ELSE
;            STC                         ;SET CARRY
;        $ENDIF
;        RET
;CHK_DRV_SPEC ENDP
;        HEADER <CHK_BLANK - IS CURRENT CHAR IN PARM BLANK OR TAB>
;***************************************************************************

;kiser: this proc is to be deleted

;CHK_BLANK PROC NEAR
;; ** CHECK THE CURRENT CHR IS A BLANK OR TAB                               *
;; INPUT: ES:DI POINTS TO THE CURRENT CHR.                                  *
;        CX - # OF CHR IN THE STRING.                                      *
; OUTPUT: FOUND - DI MOVES TO THE NEXT CHR. CX DECREASES BY 1.             *
;         NOT FOUND - CARRY IS SET. DI, CX UNCHANGED.                      *
;***************************************************************************

;        CLC                             ;CLEAR CARRY
;        CMP   CX, 1                     ;IF LESS THAN 1, NOT FOUND.
;        $IF   L,OR                      ;GO SET CARRY AND EXIT
;
;        MOV   AL, ES:BYTE PTR [DI]      ;GET CURRENT CHR
;        CMP   AL, 020H                  ;020H=BLANK CHR
;        $IF   NZ,AND                    ;NOT FOUND
;        CMP   AL, 09H                   ;09H=TAB CHR
;        $IF   NZ                        ;NOT FOUND EITHER
;
;                                        ;THEN NOT FOUND
;            STC                         ;SET CARRY
;        $ELSE                           ;CHAR MUST BE EITHER TAB OR BLANK
;            INC   DI                    ;FOUND. ADJUST DI, CX
;            DEC   CX
;        $ENDIF
;        RET
;CHK_BLANK ENDP
.LIST
        HEADER <SOURCE_TARGET_DRV - CONV. SRC/TARGET DRV TO BIOS VALUES> ;      ;AN000;
;******************************************************************************
; SUBROUTINE NAME :  SOURCE_TARGET_DRV    DETERMINES SOURCE & TARGET DRIVES & *
;                                         CONVERT THEM FROM DOS TO BIOS VALUE *
; INPUT           :  SOURCE_DRIVE & TARGET_DRIVE HAVE DOS DRIVE ID'S:         *
;                         0 = DEFAULT        1 = DRV A                        *
;                         2 = DRV B          3 = DRV C ETC                    *
;                                                                             *
;                                                                             *
; OUTPUT          :  DEFAULT_DRV: CURRENT DEFAULT DRIVE                       *
;                          0 - DRIVE A           1 - DRIVE B                  *
;                          2 - DRIVE C           3 - DRIVE D                  *
;                                                                             *
;                 :  SOURCE_DRIVE          1 = DRIVE A    2 = DRIVE B  ETC.   *
;                 :  TARGET_DRIVE          1 = DRIVE A    2 = DRIVE B  ETC.   *
;                      (UNCHANGED)                                            *
;******************************************************************************
SOURCE_TARGET_DRV PROC NEAR
        PUBLIC SOURCE_TARGET_DRV        ;MAKE ENTRY IN LINK MAP                 ;AN000;
                                        ;GET CURRENT DEFAULT DRIVE
        MOV   AH,CURRENTDRV_FUNC        ;FUNCTION CALL (19H)
                                        ;(AL <- CURRENT DEFAULT DRV
        INT   21H                       ;0 = A, 1 = B, ETC)

        MOV   DEFAULT_DRV,AL            ;SAVE IT
        INC   AL                        ;NOW A=1, B=2, ETC                      ;AN000;
        CMP   SOURCE_DRIVE,ZERO         ;FIRST DRV ENTERED?                     ;AC000;
;       $IF   E                         ;NO DRIVE LETTER ENTERED
        JNE $$IF7
            MOV   SOURCE_DRIVE,AL       ;USE DEFAULT DRIVE AS SOURCE            ;AC000;
            MOV   TARGET_DRIVE,AL       ; AND AS TARGET                         ;AC000;
;       $ELSE
        JMP SHORT $$EN7
$$IF7:
            CMP   TARGET_DRIVE,ZERO     ;WAS THE SECOND DRIVE ID SPECIFIED?     ;AC000;
;           $IF   E                     ;NO, SO TARGET DRV IS DEFAULT           ;AC000;
            JNE $$IF9
                MOV   TARGET_DRIVE,AL   ;USE DEFAULT DRIVE AS TARGET            ;AC000;
;           $ENDIF
$$IF9:
;       $ENDIF
$$EN7:
        MOV   AX,WORD PTR SOURCE_DRIVE  ;SOURCE TO AL, TARGET TO AH             ;AC000;
        ADD   ASCII_DRV1_ID,AL          ;MAKE THE DRIVE ALPHABET READABLE
        ADD   ASCII_DRV2_ID,AH          ;IN THE MESSAGE

        RET

SOURCE_TARGET_DRV ENDP
        HEADER <TEST_DRIVE_VALIDITY - ARE SOURCE/TARGET DRIVES VALID?> ;        ;AN000;
;******************************************************************************
; SUBROUTINE NAME :  TEST_DRIVE_VALIDITY--MAKE SURE SOURCE AND TARGET DRIVES  *
;                    SPECIFIED BY USER ARE VALID FOR DISKCOPY                 *
;                                                                             *
; INPUT           :  SOURCE_DRIVE:BYTE, TARGET_DRIVE:BYTE                     *
;                                                                             *
; OUTPUT          :  DX='FINE' IF DRIVES ARE VALID, ELSE DX CONTAINS MSG PTR  *
;******************************************************************************

TEST_DRIVE_VALIDITY PROC NEAR
        PUBLIC TEST_DRIVE_VALIDITY      ;MAKE ENTRY IN LINK MAP                 ;AN000;

        CALL  DOS_DRIVE_VALIDITY

        CMP   DX,FINE
;       $IF   E,AND                     ;                                       ;AC000;
        JNE $$IF12

        MOV   BL,SOURCE_DRIVE
        CALL  CHECK_REDIRECTION

        CMP   DX,FINE
;       $IF   E,AND                     ;                                       ;AC000;
        JNE $$IF12

        MOV   BL,TARGET_DRIVE
        CALL  CHECK_REDIRECTION

        CMP   DX,FINE
;       $IF   E,AND                     ;                                       ;AC000;
        JNE $$IF12

        MOV   BL,SOURCE_DRIVE
        CALL  CHECK_SERVER

        CMP   DX,FINE
;       $IF   E,AND                     ;                                       ;AC000;
        JNE $$IF12

        MOV   BL,TARGET_DRIVE
        CALL  CHECK_SERVER

        CMP   DX,FINE
;       $IF   E,AND                     ;                                       ;AC000;
        JNE $$IF12

        CALL  TEST_REMOVABLE

        CMP   DX,FINE
;       $IF   E                         ;                                       ;AC000;
        JNE $$IF12

            CALL  CHK_SINGLE_DRV_OP     ;CHECK IF IT IS
                                        ; ONE PHYSICAL DRIVE OPERATION
;       $ENDIF                          ;                                       ;AC000;
$$IF12:
        RET

TEST_DRIVE_VALIDITY ENDP
        HEADER <DOS_DRIVE_VALIDITY - CHECK DOS DRIVE VALIDITY BYTE> ;           ;AN000;
;******************************************************************************
; SUBROUTINE NAME :  DOS_DRIVE_VALIDITY -- CHECK DOS DRIVE VALIDITY BYTE      *
;                                                                             *
; INPUT           :  DRIVE_VALID:BYTE                                         *
;                                                                             *
; OUTPUT          :  DX="FINE" IF DRIVES ARE VALID ELSE DX CONTAINS MESSAGE PTR *
;******************************************************************************

DOS_DRIVE_VALIDITY PROC NEAR

        CMP   DRIVE_VALID,0             ;SEE IF DRIVES ARE VALID DOS DEVICE
;       $IF   NE
        JE $$IF14
            MOV   DX,OFFSET MSGNUM_INVALID_DRV ;                                ;AC000;
;       $ENDIF
$$IF14:
        RET

DOS_DRIVE_VALIDITY ENDP
        HEADER <TEST_REMOVABLE - IS SPECIFIED DRIVE REMOVABLE?> ;               ;AN000;
;******************************************************************************
; SUBROUTINE NAME :  TEST_REMOVABLE -- CHECK IF DRIVES SPECIFED ARE REMOVABLE *
;                                                                             *
; INPUT           :  SOURCE_DRIVE:BYTE, TARGET_DRIVE:BYTE                     *
;                                                                             *
; OUTPUT          :  DX=FILE IF DRIVES ARE VALID ELSE DX CONTAINS MESSAGE PTR *
;******************************************************************************

TEST_REMOVABLE PROC NEAR

        MOV   BL,SOURCE_DRIVE           ;GET PARM 1 DRIVE ID

        MOV   AX,DRIVE_CHECK            ;CHECK FOR REMOVABLE DRIVE = 4408h
        INT   21H                       ;IOCTL CALL
;       $IF   NC                        ;IF DRIVE ID IS WITHIN RANGE
        JC $$IF16
            CMP   AX,REMOVABLE          ;THEN IF SOURCE DRIVE IS FIXED
;           $IF   NE                    ;  THEN
            JE $$IF17
                MOV   DX,OFFSET MSGNUM_INVALID_DRV ;GENERATE HARD               ;AC000;
                                        ; DRIVE ERROR MESSAGE
;           $ELSE                       ;ELSE, SRC IS REMOVABLE;
            JMP SHORT $$EN17
$$IF17:
                MOV   BL,TARGET_DRIVE   ;NOW GO CHECK TARGET

                MOV   AX,DRIVE_CHECK    ;CHECK FOR REMOVABLE DRIVE
                INT   21H               ;IOCTL CALL
;               $IF   NC                ;IF DRV WITHIN RANGE
                JC $$IF19
                    CMP   AX,REMOVABLE  ;THEN TGT DRV IS FIXED
;                   $IF   NE            ;     THEN
                    JE $$IF20
                        MOV   DX,OFFSET MSGNUM_INVALID_DRV ;GENERATE HARD       ;AC000;
                                        ; DRV ERROR MSG
;                   $ENDIF              ;END TEST IF TGT DRV IS FIXED
$$IF20:
;               $ELSE                   ;TGT DRV OUT OF RANGE.  EX. DRIVE X:
                JMP SHORT $$EN19
$$IF19:
                    MOV   DX,OFFSET MSGNUM_INVALID_DRV ;                        ;AC000;
;               $ENDIF                  ;END TEST IF TGT WITHIN RANGE
$$EN19:
;           $ENDIF                      ;END IF SRC IS REMOVABLE
$$EN17:
;       $ELSE                           ;ELSE,  SRC DRV OUT OF RANGE
        JMP SHORT $$EN16
$$IF16:
            MOV   DX,OFFSET MSGNUM_INVALID_DRV ;PRINT ERROR MSG                 ;AC000;
;       $ENDIF                          ;END TEST IF SRC DRV WITHIN RANGE
$$EN16:
        RET

TEST_REMOVABLE ENDP
        HEADER <CHK_SINGLE_DRIV_OP - IS TARGET DRIVE SAME AS SOURCE?> ;         ;AN000;
;******************************************************************************
; SUBROUTINE NAME :  CHK_SINGLE_DRV_OP                                        *
;                                                                             *
; INPUT           :  SOURCE_DRIVE - LOGICAL DRIVE NUMBER                      *
;                    TARGET_DRIVE                                             *
;                                                                             *
; OUTPUT          :  COPY_TYPE WILL BE SET TO ONE OR TWO DEPENDING ON THE     *
;                    TEST RESULT.  IF IT IS A SINGLE DRIVE COPY, THEN         *
;                    TARGET DRIVE LETTER WILL BE CHANGED TO THAT OF SOURCE.   *
;                    THE OWNERSHIP OF THE SOURCE AND TARGET DRIVE LETTER      *
;                    MIGHT HAVE BEEN CHANGED.                                 *
;                    SO, BEFORE EXIT TO DOS, THEY SHOULD BE RESET TO THE SAVED*
;                    ONE USING S_OWNER_SAVED AND T_OWNER_SAVED UNLESS THEY    *
;                    ARE EQUAL TO 0. (0 MEANS ONLY ONE DRIVE LETTER ASSIGNED.)*
;                    ASCII_DRV1_ID, ASCII_DRV2_ID MAY BE CHANGED ACCORDINGLY. *
;******************************************************************************

CHK_SINGLE_DRV_OP PROC NEAR

        PUSH  AX

        MOV   BL,SOURCE_DRIVE
        CALL  GET_LOGICAL_DRIVE

        MOV   S_OWNER_SAVED, AL         ;SAVE CURRENT OWNER DRIVE LETTER.
        MOV   BL, TARGET_DRIVE
        CALL  GET_LOGICAL_DRIVE

        MOV   T_OWNER_SAVED, AL         ;SAVE CURRENT OWNER
        MOV   BL, SOURCE_DRIVE
        CALL  SET_LOGICAL_DRIVE

        MOV   BL, TARGET_DRIVE
        CALL  SET_LOGICAL_DRIVE

        MOV   BL, SOURCE_DRIVE
        CALL  GET_LOGICAL_DRIVE         ;CHECK SOURCE DRV LETTER
                                        ; STILL HAS A OWNERSHIP.

        CMP   AL, SOURCE_DRIVE          ;
;       $IF   NE                        ;IF IT DOES NOT, THEN A
        JE $$IF27
                                        ; SINGLE DRIVE COPY.
            MOV   COPY_TYPE, ONE
            MOV   BL, SOURCE_DRIVE
            MOV   TARGET_DRIVE, BL      ;SET TARGET DRV LETTER
                                        ; TO THAT OF SOURCE
            MOV   BL, ASCII_DRV1_ID
            MOV   ASCII_DRV2_ID, BL
            MOV   BL, SOURCE_DRIVE
            CALL  SET_LOGICAL_DRIVE     ;SET THE OWNER BACK TO
                                        ; SOURCE DRV LETTER

;       $ELSE
        JMP SHORT $$EN27
$$IF27:
            CMP   AL, TARGET_DRIVE      ;SOURCE DRV LETTER = TARGET DRV
                                        ; LETTER CASE, FOR EX. DISKCOPY A: A:
;           $IF   E
            JNE $$IF29
                MOV   COPY_TYPE, ONE
;           $ELSE
            JMP SHORT $$EN29
$$IF29:
                MOV   COPY_TYPE, TWO
;           $ENDIF
$$EN29:
;       $ENDIF
$$EN27:

        POP   AX

        RET
CHK_SINGLE_DRV_OP ENDP
        HEADER <GET_LOGICAL_DRIVE - GET LOG. DRIV NO. WHO OWNS PHYS. DRIVE> ;AN000;
;******************************************************************************
GET_LOGICAL_DRIVE PROC NEAR
;       *** GET THE LOGICAL DRIVE NUMBER WHO HAS THE OWNERSHIP OF THE PHYSICAL
;           DRIVE.
;       INPUT: BL = DRIVE NUMBER (0=DEFAULT, 1=A, 2=B...)
;       OUTPUT: AL = DRIVE NUMBER (0= ONLY ONE DRIVE LETTER ASSIGNED TO THE
;                                     BLOCK DEVICE. OTHERWISE, 1=A, 2=B...)
;
;******************************************************************************

        MOV   AH, 44H
        MOV   AL, 0EH                   ; GET THE OWNER OF LOGICAL DRIVE NUMBER
        INT   21H
        CMP   AL, 0                     ;ONLY ONE DRIVE LETTER ASSIGNED?
;       $IF   E
        JNE $$IF33
            MOV   AL, BL                ;THEN SET THE INPUT DRIVE NUMBER TO AL.
;       $ENDIF
$$IF33:

        RET

GET_LOGICAL_DRIVE ENDP
        HEADER <DISKETTE_DRV_TYPE - CHECK COMPATABILITY SOURCE/TARGET DRIVES> ; ;AN000;
;******************************************************************************
; SUBROUTINE NAME :  DISKETTE_DRV_TYPE DOES THE FOLLOWING:                    *
;                    - GETS SOURCE, TARGET DRIVE INFORMATION                  *
;                    - CHECK REMOVABLE DRIVE                                  *
; *** REMARK: WILL NOT ALLOW DISKCOPY BETWEEN 5.25" AND 3.5" DRIVES.          *
; *** ALSO, IN THE MAIN PROGRAM, SOURCE MEDIA BPB INFORMATIONS (# OF SEC/TRK, *
; *** # OF TRACKS) SHOULD BE CHECKED AGAINST TARGET DEVICE INFORMATIONS.      *
; *** IF # OF SECT/TRACK, # OF TRACKS OF TARGET DEVICE ARE EQUAL TO, OR       *
; *** GREATER THAN THOSE OF THE SOURCE MEDIA BPB, THEN IT IS OK. OTHERWISE    *
; *** DEVICE NOT COMPATIBLE.                                                  *
; *** IF THIS DOES NOT GAURANTEES COMPATIBILITY BETWEEN SOURCE AND TARGET     *
; *** DEVICE OR MEDIA, EVENTUALLY, FAILURE TO FORMAT THE TARGET WILL          *
; *** TELL THAT SOURCE, TARGET DEVICE OR MEDIA ARE NOT COMPATIBLE.            *
;                                                                             *
;******************************************************************************
DISKETTE_DRV_TYPE PROC NEAR
        PUSH  AX

		; M003  Added check for CMCDD drives
IF IBMCOPYRIGHT NE TRUE
	mov	ax,(44h shl 8) or 11h ; Check if function supported
	xor	bx,bx
	mov	bl, SOURCE_DRIVE
	mov	cx,(8 shl 8) or 73h		; Determine if get_system_info
						; exist (only CMCDD has it).
	int	21h				; see if CMCDD
	jc	@f
	mov	dx, OFFSET MSGNUM_CMCDD_DRIVE
	jmp	$$EN35
@@:
ENDIF		; End M003

        xor   bx, bx
        MOV   BL, SOURCE_DRIVE
        MOV   CL, GETDEVPARM            ;=60h
        MOV   DX, OFFSET DS_IOCTL_DRV_PARM ;POINTER TO THE CONTROL STRING
        CALL  GENERIC_IOCTL             ;GET DEFAULT DEVICE PARM.

        TEST  DS_deviceAttributes, 0001h ;CHECK REMOVABLE. 0001 = NOT REMOVABLE
;       $IF   E,AND                     ;NO, CONTINUE                           ;AC000;
;C05    JNE $$IF35
        JE  check_fixed_disk                    ;Removable, hard disk also?;C05
        JMP $$IF35                              ;Not removeable, can't copy;C05
check_fixed_disk:                               ;Here to check for fixed d ;C05
        cmp   DS_DeviceType,FixedDisk           ;Q: Removeable fixed disk? ;C05
        JE  $$IF35                              ; Y: then error out        ;C05

        MOV   AX, DS_numberOfCylinders
        MOV   S_DRV_TRACKS, AX
        MOV   BX, OFFSET DS_BPB_PTR
        MOV   AX, [BX].CHead
        MOV   S_DRV_HEADS, AL
        MOV   AX, [BX].CSECT_TRACK
        MOV   S_DRV_SECT_TRACK, AL
        MOV   AX, [BX].CBYTE_SECT       ;RECOMMENDED BYTES/SECTOR
        MOV   RECOMMENDED_BYTES_SECTOR, AX

        XOR   BX,BX
        MOV   BL, TARGET_DRIVE
        MOV   CL, GETDEVPARM
        MOV   DX, OFFSET DT_IOCTL_DRV_PARM
        CALL  GENERIC_IOCTL             ;GET DEFAULT DEVICE PARM.

        TEST  DT_deviceAttributes, 0001h ;FIXED DISK?
;       $IF   Z                         ;TARGET IS NOT FIXED DISK, OK           ;AC000;
        JNZ $$IF35
        cmp   DT_DeviceType,FixedDisk           ;Q: Removeable fixed disk? ;C05
        JE  $$IF35                              ; Y: then error out        ;C05

            MOV   AX, DT_numberOfCylinders
            MOV   T_DRV_TRACKS, AX
            MOV   BX, OFFSET DT_BPB_PTR
            MOV   AX, [BX].CHead
            MOV   T_DRV_HEADS, AL
            MOV   AX, [BX].CSECT_TRACK
            MOV   T_DRV_SECT_TRACK, AL

;**NOW, CHECK SOURCE, TARGET DEVICE COMPATIBILITY
            MOV   DX, FINE              ;GUESS, ALL WILL BE OK
                                        ; DX MAY BE CHANGED TO REFLECT ERROR
            CMP   DS_deviceType, DRV_720 ;0 - 48 TPI, 5.25", 96 TPI,
                                        ; 5.25", 2 - 720kb, 3.5"
;           $IF   E                     ;WILL ONLY ALLOW DISKCOPY BETWEEN       ;AC000;
            JNE $$IF36
                                        ; 720KB, 3.5 SOURCE, TARGET

                CMP   DT_deviceType, DRV_720 ;target = 720KB also?
;               $IF   NE                ;                                       ;AC000;
                JE $$IF37
                  CMP   DT_deviceType, DRV_OTHER ;target might be 1.44M ;C02
;                 $IF   NE                                              ;C02
                  JE $$IF38
                    MOV   DX, OFFSET MSGNUM_NOT_COMPATIBLE ;AC000;
;                 $ENDIF                                                ;C02
$$IF38:
;               $ENDIF                  ;                                       ;AC000;
$$IF37:
;           $ELSE                       ;SINCE SOURCE NOT 720                   ;AC000;
            JMP SHORT $$EN36
$$IF36:
                CMP   DT_deviceType, DRV_720 ;SOURCE IS NOT 720kb,
                                        ; IS TARGET 720?
;               $IF   E                 ;IF SO, THEN                            ;AC000;
                JNE $$IF42
                                        ;DDT IS NOT COMPATIBLE
                  CMP   DS_deviceType, DRV_OTHER ;source might be 1.44M ;C02
;                 $IF   NE                                              ;C02
                  JE $$IF43
                    MOV   DX, OFFSET MSGNUM_NOT_COMPATIBLE ;                    ;AC000;
;                 $ENDIF                                                ;C02
$$IF43:
;               $ENDIF                  ;                                       ;AC000;
$$IF42:
;           $ENDIF                      ;                                       ;AC000;
$$EN36:
;       $ELSE                           ;SINCE SOURCE IS FIXED DISK, ERROR      ;AC000;
        JMP SHORT $$EN35
$$IF35:
            MOV   DX, OFFSET MSGNUM_INVALID_DRV ;ISSUE BAD DRV MSG              ;AC000;
;       $ENDIF                          ;                                       ;AC000;
$$EN35:
        POP   AX
        RET

DISKETTE_DRV_TYPE ENDP
        HEADER <CHECK_REDIRECTION - IS DEVICE REDIRECTED?> ;                    ;AN000;
;******************************************************************************
; SUBROUTINE NAME  : CHECK_REDIRECTION   FIND OUT IF DEVICE IS REDIRECTED     *
;                                        IF IT IS, GENERATE ERROR MSG & EXIT  *
; INPUT            : BL - DRIVE TO BE TESTED                                  *
;                  : AL : CURRENT DEFAULT DRIV                                *
;                                                                             *
; OUTPUT           : DX                = LOCAL_DRV  (-1)                      *
;                                      = DIRECTED   ( ERROR MSG OFFSET)       *
;                                      = INVALID_DRIVE (ERROR MSG OFFSET)     *
;******************************************************************************
CHECK_REDIRECTION PROC NEAR

        PUSH  AX                        ;SAVE REGISTERS
        PUSH  BX
        PUSH  CX

        MOV   CX,DX                     ;SAVE RET TEMPORARILY
        MOV   AH,IOCTL_FUNC             ;GET IOCTL FUNTION &
        MOV   AL,REDIRECTED_FUNC        ;IOCTL SUB-FUNCTION ******CHECK***

        INT   21H                       ;AND GO FIND OUT IF IT'S LOCAL
;       $IF   C
        JNC $$IF49
            MOV   CX,OFFSET MSGNUM_INVALID_DRV ;REDIR INVALID                   ;AC000;

;       $ELSE
        JMP SHORT $$EN49
$$IF49:
            TEST  DX,REMOTE_DRV         ;IF DRIVE IS REDIRECTED
;           $IF   NZ
            JZ $$IF51

                MOV   CX,OFFSET MSGNUM_DRV_REDIRECTED ;                         ;AC000;
;           $ENDIF
$$IF51:
;       $ENDIF
$$EN49:
        MOV   DX,CX                     ;GET ERROR MSG @

        POP   CX                        ;RESTORE REGISTERS
        POP   BX
        POP   AX
        RET                             ;RETURN TO CALLER
CHECK_REDIRECTION ENDP
        HEADER <BUFFER_SIZE - FINDS START AND END OF BUFFER> ;                  ;AN000;
;******************************************************************************
; SUBROUTINE NAME :  BUFFER_SIZE    DETERMINES WHERE BUFFER STARTS & ENDS     *
; INPUT           :  NONE                                                     *
;                                                                             *
; OUTPUT          :  BUFFER_BEGIN ADDRESS                                     *
;                 :  BUFFER_END   ADDRESS                                     *
;******************************************************************************
BUFFER_SIZE PROC NEAR


        PUSH  AX                        ;SAVE REGISTERS
        PUSH  BX
        PUSH  CX
        MOV   BX, offset init           ;GET ADDR OF INIT + 1024 AS
                                        ; A START OF BUFFER
        add   bx, 1024                  ;(OFFSET FROM CS, IN BYTES)
        MOV   CL,4                      ;CONVERT OFFSET INTO SEGMT BY DIVIDING
        SHR   BX,CL                     ;IT BY 16

        MOV   AX,CS                     ;CS + OFFSET => INIT+1024@ IN SEGMENT
        ADD   BX,AX                     ;WHERE BUFFER CAN START

                                        ;NEED TO START AT A NEW SECTOR ==>
        AND   BL,CLEAR_SEGMENT          ;TRUNCATE TO PREVIOUS 512 BYTE BOUNDRY
                                        ;(GET PREVIOUS SECTOR NUMBER)
        ADD   BX,20H                    ;THEN, ADVANCE TO THE BEGINNING OF
                                        ;NEXT SECTOR (SINCE PART OF PREVIOUS
                                        ;SECTOR WAS USED)

        MOV   BUFFER_BEGIN,BX           ;SAVE OUR BUFFER START SEGMENT ADDR
                                        ;(AT THE BEGINNING OF A SECTOR WITH
                                        ;SEGMENT BITS CLEARED)

        MOV   BX,DS:TWO                 ;GET ADDR WHERE BUFFER ENDS
        MOV   BUFFER_END,BX             ;(TOP OF MEMORY, OFFSET 2 IN PSP)

        POP   CX                        ;RESTORE REGISTERS
        POP   BX
        POP   AX
        RET                             ;RETURN TO CALLER
BUFFER_SIZE ENDP
        HEADER <SETUP_CTRL_BREAK - SETUP THE CTRL-BREAK VECTOR> ;               ;AN000;
;******************************************************************************
SETUP_CTRL_BREAK PROC NEAR              ;SETUP CTRL-BREAK VECTOR
;******************************************************************************
        PUSH  AX
        PUSH  BX
        PUSH  DX
        PUSH  ES

        MOV   AX,SET_CTL_BREAK_VECT     ;SET THE CTRL-BREAK VECTOR
        MOV   DX,OFFSET MAIN_EXIT
        INT   21H

        POP   ES
        POP   DX
        POP   BX
        POP   AX
        RET

SETUP_CTRL_BREAK ENDP
        HEADER <CHECK_SERVER - IS SERVER OR REDIRECTOR LOADED?> ;               ;AN000;
;******************************************************************************
CHECK_SERVER PROC NEAR                  ;SEE IF SERVER OR REDIRECTOR IS IN++
;
; INPUT: BL = DRIVE NUMBER (1=A,2=B ETC....)
;******************************************************************************
        MOV   AH,0                      ;SEE IF SERVER LOADED
        INT   SERVER
        CMP   AH,0
;       $IF   E
        JNE $$IF54
            MOV   DX,FINE
;       $ELSE
        JMP SHORT $$EN54
$$IF54:
            DEC   BL
            ADD   BL,"A"                ;CONVERT TO ASCII DRIVE LETTER
            MOV   ASCII_DRIVE_LETTER,BL ;PUT IN ASCIIZ STRING
            MOV   SI,OFFSET ASCII_DRIVE_LETTER
            MOV   AH,SHARED
            CLC
            INT   SERVER
;           $IF   C
            JNC $$IF56
                MOV   DX,OFFSET MSGNUM_DRV_REDIRECTED ;                         ;AC000;
;           $ELSE
            JMP SHORT $$EN56
$$IF56:
                MOV   DX,FINE
;           $ENDIF
$$EN56:
;       $ENDIF
$$EN54:
        RET
CHECK_SERVER ENDP

COPYINIT_END LABEL NEAR
        PUBLIC COPYINIT_END

        PATHLABL COPYINIT               ;AN015;

CSEG    ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcomp\diskcomp.asm ===
PAGE    90,132                  ;A2
        TITLE   DISKCOMP.SAL - COPY COMPLETE DISKETTE
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: DISKCOMP

; DESCRIPTIVE NAME: Diskette to diskette complete compare Utility

;FUNCTION: DISKCOMP is to compare the contents of the diskette in the
;          specified first drive to the diskette in the second
;          drive.  If the first drive has a vol serial number, that
;          field in both diskettes is ignored in the comparison
;          of that one sector, because DISKCOPY will create a unique
;          volume serial number when it duplicates a diskette.

;          Multiple compares may be performed with one load of DISKCOMP.
;          A prompt, "Compare another (Y/N)?" permits additional
;          executions, all with the same drive specifications.

; ENTRY POINT: "DISKCOMP" at ORG 100h, jumps to "BEGIN".

; INPUT: (DOS command line parameters)

;             [d:][path] DISKCOMP  [d: [d:]] [/1] [/8]

;        WHERE
;             [d:][path] - Path where the DISKCOMP command resides.

;             [d:] - To specify the First drive
;
;             [d:] - To specify the Second drive
;
;             [/1] - To compare only the first side of the diskette,
;                    regardless of the diskette or drive type.

;             [/8] - To compare only the first 8 sectors per track,
;                    even if the first diskette contains 9/15 sectors
;                    per track.
;
; EXIT-NORMAL: Errorlevel = 0
;             Function completed successfully.

; EXIT-ERROR: Errorlevel = 1
;             Abnormal termination due to error, wrong DOS,
;             invalid parameters, unrecoverable I/O errors on
;             the diskette.
;             Errorlevel = 2
;             Termination requested by CTRL-BREAK.

; EFFECTS: The entire diskette is compared, including the unused
;          sectors.  There is no awareness of the separate files
;          involved.  A unique volume serial number is ignored
;          for the comparison of the first sector.

; INCLUDED FILES:
;          PATHMAC.INC - PATHGEN MACRO
;          INCLUDE DCMPMACR.INC            ;(FORMERLY CALLED MACRO.DEF)
;          INCLUDE DISKCOMP.EQU            ;EQUATES

; INTERNAL REFERENCES:
;    ROUTINES:
;        BEGIN - entry point from DOS
;        SET_LOGICAL_DRIVE - set log. drive letter as owner of drive
;        COMP - compare the diskette image
;        TEST_REPEAT - see if user wants to compare another
;        READ_SOURCE - read from first drive as much as possible
;        CHECK_SOURCE - determine first diskette type
;        READ_A_SECTOR - use IOCTL read to get a sector
;        CALC_TRACK_SIZE - find mem size to hold one track
;        CHECK_MEMORY_SIZE - be sure enuf memory to compare 1 track
;        COMP_TARGET - compare memory data with secon diskette
;        CHECK_TARGET - compare second disk boot record
;        SET_DRV_PARM - request IOCTL to set device parm
;        COMP_TRACK - read and compare specified track
;        SWAP_DRIVE - setup for diskette swapping
;        READ_TRACK - read a track to memory
;        READ_OP - IOCTL to read a track
;        SET_FOR_THE_OLD - use pre 2.0 BPB
;        SET_TRACKLAYOUT - determine sectors per track
;        GENERIC_IOCTL - perform specified IOCTL function
;        EXTENDED_ERROR_HANDLER - determine and service extended errors
;        SET_DRV_PARM_DEF - set drive parms via IOCTL
;
;        VOLSER - during compare of first sector, avoid vol ser #
;        SENDMSG - passes parms to regs and invokes the system message routine.

;    DATA AREAS:
;       PSP - Contains the DOS command line parameters.
;       WORKAREA - Temporary storage

; EXTERNAL REFERENCES:
;    ROUTINES:
;       SYSDISPMSG - Uses the MSG parm lists to construct the messages
;                on STDOUT.
;       SYSLOADMSG - Loads messages, makes them accessable.
;       SYSPARSE - Processes the DOS Command line, finds parms.

;    DATA AREAS:
;        DCOMPSM.SAL - Defines the control blocks that describe the messages
;        DCOMPPAR.SAL - Defines the control blocks that describe the
;               DOS Command line parameters.

; NOTES:
;        This module should be processed with the SALUT preprocessor
;        with the re-alignment not requested, as:

;               SALUT DISKCOMP,NUL

;        To assemble these modules, the alphabetical or sequential
;        ordering of segments may be used.

;        Sample LINK command:

; LINK @DISKCOMP.ARF

; Where the DISKCOMP.ARF is defined as:

;        DISKCOMP+
;        DCOMPSM+
;        DCOMPP+
;        DCOMPPAR+
;        COMPINIT

;        These modules must be linked in this order.  The load module is
;        a COM file, to be converted to COM with EXE2BIN.

; REVISION HISTORY:
;            A000 Version 4.00: add PARSER, System Message Handler,
;                 Ignore vol serial number differences.
;            A001 386 Support
;            A002 Avoid duplicate switches
;            A003 PTM 540 Show parm in error
;            A004 PTM 752 Add close door after drive not ready
;            A005 PTM 756 Add help msg after parm error message
;            A006 PTM1100 Clear keyboard buffer before input response
;            A007 PTM1464 Delete unused msgs: 22,23,24
;            A008 PTM1406 USE 69H INSTEAD OF IOCTL FOR GET/SET MEDIA ID
;            A009 PTM1605 PUT A BLANK LINE OUT BEFORE PRESS ANY KEY MSG
;            A010 PTM1821 move INCLUDE COPYRIGH.INC to MSG_SERVICE macro
;            A011 PTM3184 SUPPORT OS/2 1.0/1.1 TYPE BOOT RECORDS ALSO
;                       REMOVE USE OF GET/SET MEDIA ID
;            A012 PTM3262 Specify BASESW EQU 1 before PARSE.ASM
;            A013 PTM3512 PATHGEN
;           ;C00 MKS     Cleaned up the build.  Made short jumps out of long
;                        jumps.
;           ;C01 MKS     Disallowing DISKCOMP of 720K to 1.44M diskettes.
;           ;C04 MKS     More for Bug#725.  Now, we check the target diskette
;                        on a 2 drive copy before we read the data from the
;                        first diskette.  This way if the second drive is
;                        different, we don't waste the time of reading the
;                        first diskette.
;
;            ;C08 MKS     Someone changed DISKCOPY for the ENHANCED diskettes,
;                         and in so doing caused some problems.  This should
;                         fix these new problems.  One of the problems was a
;                         divide by zero since the source diskette parameters
;                         were used instead of the target parameters.
;
;            ;C09 MKS     DISKCOMP would not compare two diskettes that were
;                         identical (1.44M 3.5").  These diskettes were
;                         formatted, then had 10 sectors of 00h written at the
;                         start of the diskette.   This fixes this problem.
;
;            ;C10 MKS     DISKCOPY of a 720K diskette without a BPB would only
;                         copy 40 tracks.  This is all part of the same old
;                         problem that DISKCOPY/DISKCOMP did not work right on
;                         3.5" media.
;
;            ;C11 MKS     Fixing to understand 2.88M diskettes better.  The
;                         original problem this is fixing is a copy from 2.88M
;                         to a preformatted 720k.  The message "Formatting..."
;                         is displaying, then it errored out, leaving the
;                         720k floppy unreadable.
;
;            ;C12 MKS     Fixing bug#4237.  Errorlevels 3 and 4 weren't
;                         working.
;

;            "Version 5.00 (C) Copyright 1990 Microsoft"
;            "Licensed Material - Property of Microsoft  "

;PROGRAM AUTHOR: Original written by: Jin K.
;                4.00 modifications by: Edwin M. K.
;****************** END OF SPECIFICATIONS *****************************
;*****************************************************************************
;                                                                            *
;                            D I S K C O M P                                 *
;                                                                            *
;  UPDATE HISTORY: 8-21, 8-22, 8-30, 9-4, 9-20, 9-21, 12-19                  *
;                  2-15-84, 2-17, 4-29, 6-20,7-24,3-27-85                    *
;                                                                            *
;*****************************************************************************

        INCLUDE PATHMAC.INC             ;AN013;
        INCLUDE DCMPMACR.INC            ;(FORMERLY CALLED MACRO.DEF)
        INCLUDE DISKCOMP.EQU            ;EQUATES
	INCLUDE	VERSION.INC

;              $salut (4,16,22,36) ;                                            ;AN000;
;THIS MESSAGE DESCRIPTOR CONTROL BLOCK IS GENERATED, ONE PER MESSAGE,
;TO DEFINE THE SEVERAL PARAMETERS THAT ARE EXPECTED TO BE PASSED IN
;CERTAIN REGISTERS WHEN THE SYSDISPMSG FUNCTION IS TO BE INVOKED.

MSG_DESC       STRUC               ;                                            ;AN000;
MSG_NUM        DW    ?             ;MESSAGE NUMBER (TO AX)                      ;AN000;
MSG_HANDLE     DW    ?             ;HANDLE OF OUTPUT DEVICE (TO BX)             ;AN000;
MSG_SUBLIST    DW    ?             ;POINTER TO SUBLIST (TO SI)                  ;AN000;
MSG_COUNT      DW    ?             ;SUBSTITUTION COUNT (TO CX)                  ;AN000;
MSG_CLASS      DW    ?             ;MESSAGE CLASS (IN HIGH BYTE, TO DH)         ;AN000;
                                   ;LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL) ;AN000;
MSG_DESC       ENDS                ;                                            ;AN000;

MY_BPB         STRUC
CBYTE_SECT     DW    0             ; 200H  ;BYTES / SECTOR
CSECT_CLUSTER  DB    0             ; 2h    ;SECTORS / CLUSTER
CRESEV_SECT    DW    0             ; 1h    ;RESERVED SECTORS
CFAT           DB    0             ; 2h    ;# OF FATS
CROOTENTRY     DW    0             ; 70h   ;# OF ROOT ENTRIES
CTOTSECT       DW    0             ; 02D0h ;TOTAL # OF SECTORS INCLUDING
                                   ;         BOOT SECT, DIRECTORIES
MEDIA_DESCRIP  DB    0             ;0FDh   ;MEDIA DISCRIPTOR
CSECT_FAT      DW    0             ; 2h    ;SECTORS / FAT
CSECT_TRACK    DW    0             ;
CHEAD          DW    0             ;
CHIDDEN_SECT   DD    0             ;
BIG_TOT_SECT   DD    0             ;
               DB    6 DUP (0)     ;
MY_BPB         ENDS

CSEG           SEGMENT PARA PUBLIC 'CODE' ;                                     ;AN000;
               ASSUME CS:CSEG, DS:CSEG, ES:CSEG, SS:CSEG

;*****************************************************************************
;                                                                            *
;                       EXTERNAL VARIABLES                                   *
;                                                                            *
;*****************************************************************************
;$salut (4,2,9,36)

.XLIST
;EXTRN  PROMPT        :NEAR        ;MESSAGE DISPLAY AND KEYBOARD INPUT ROUTINE
;EXTRN  ERROR_MESSAGE :NEAR        ;ERROR MESSAGE DISPLAY ROUTINE
;EXTRN  COMPAT_ERROR  :NEAR
;EXTRN  PRINTF        :NEAR        ;MESSAGE DISPLAY ROUTINE
;EXTRN  YES                 :BYTE
;EXTRN  NO                  :BYTE
;EXTRN  MSG_FIRST_BAD_PTR   :BYTE
.LIST

 EXTRN  SYSLOADMSG    :NEAR        ;SYSTEM MSG HANDLER INTIALIZATION            ;AN000;
 EXTRN  SYSDISPMSG    :NEAR        ;SYSTEM MSG HANDLER DISPLAY                  ;AN000;

 EXTRN  INIT          :NEAR        ;INITIALIZATION ROUTINE

 EXTRN  MSG_TRACKS         :WORD   ;                                            ;AN000;
 EXTRN  MSG_SECTRK         :WORD   ;                                            ;AN000;
 EXTRN  MSG_SIDES          :WORD   ;                                            ;AN000;

 EXTRN  ASCII_DRV1_ID      :BYTE   ;                                            ;AN000;
 EXTRN  ASCII_DRV2_ID      :BYTE   ;                                            ;AN000;

 EXTRN  SUBLIST_78         :WORD   ;                                            ;AN000;
 EXTRN  SUBLIST_17B        :WORD   ;                                            ;AN000;

 EXTRN  Q_BREAK            :BYTE   ; dcomppar.asm

 EXTRN  MSGNUM_EXTERR      :WORD   ;EXTENDED ERROR MSG DESCRIPTOR               ;AN000;
 EXTRN  MSGNUM_LOAD_FIRST  :BYTE   ;                                            ;AC000;
 EXTRN  MSGNUM_LOAD_SECOND :BYTE   ;                                            ;AC000;
 EXTRN  MSGNUM_NOT_COMPATIBLE:BYTE ;                                            ;AC000;
 EXTRN  MSGNUM_COMP_ANOTHER:BYTE   ;                                            ;AC000;
 EXTRN  MSGNUM_GET_READY   :BYTE   ;                                            ;AC000;
 EXTRN  MSGNUM_CLOSE_DOOR  :BYTE   ;                                            ;AN004;
 EXTRN  MSGNUM_FATAL_ERROR :BYTE   ;                                            ;AC000;
 EXTRN  MSGNUM_UNSUF_MEMORY:BYTE   ;                                            ;AC000;
 EXTRN  MSGNUM_BAD_FIRST   :BYTE   ;                                            ;AC000;
 EXTRN  MSGNUM_BAD_SECOND  :BYTE   ;                                            ;AC000;
 EXTRN  MSGNUM_HARD_ERROR_READ :BYTE ;                                          ;AC000;
 EXTRN  MSGNUM_HARD_ERROR_COMP :BYTE ;                                          ;AC000;
 EXTRN  MSGNUM_COMPARING   :BYTE   ;                                            ;AC000;
 EXTRN  MSGNUM_STRIKE      :BYTE   ;                                            ;AC000;
 EXTRN  MSGNUM_WRITE_PROTECT:BYTE  ;                                            ;AC000;
 EXTRN  MSGNUM_COMP_OK     :BYTE   ;                                            ;AC000;
 EXTRN  MSGNUM_NEWLINE     :BYTE   ;
 EXTRN  DRIVE_LETTER       :BYTE   ;
 EXTRN  SKIP_MSG           :BYTE   ;NULL REPLACEMENT FOR DRIVE LETTER           ;AN000;
 PAGE
;*****************************************************************************
;                                                                            *
;                            PUBLIC VARIABLES                                *
;                                                                            *
;*****************************************************************************

 PUBLIC DISKCOMP_BEGIN
 PUBLIC DISKCOMP_END
 PUBLIC RECOMMENDED_BYTES_SECTOR
 PUBLIC S_OWNER_SAVED
 PUBLIC T_OWNER_SAVED
 PUBLIC COMP
 PUBLIC SOURCE_DRIVE
 PUBLIC TARGET_DRIVE
 PUBLIC S_DRV_SECT_TRACK
 PUBLIC S_DRV_HEADS
 PUBLIC S_DRV_TRACKS
 PUBLIC T_DRV_SECT_TRACK
 PUBLIC T_DRV_HEADS
 PUBLIC T_DRV_TRACKS
 PUBLIC USER_OPTION
 PUBLIC COPY_TYPE
 PUBLIC END_OF_TRACK
 PUBLIC BUFFER_BEGIN
 PUBLIC START_BUFFER
 PUBLIC BUFFER_END
 PUBLIC TRACK_TO_READ
 PUBLIC TRACK_TO_COMP
 PUBLIC SIDE
 PUBLIC USER_INPUT
 PUBLIC MAIN_EXIT

 PUBLIC NO_OF_SIDES
 PUBLIC USER_OPTION_8
 PUBLIC ORG_SOURCE_DRIVE
 PUBLIC ORG_TARGET_DRIVE
 PUBLIC COMP_STATUS
 PUBLIC OPERATION

 PUBLIC IO_ERROR

 PUBLIC DS_IOCTL_DRV_PARM          ;PLACE HOLDER FOR DEFAULT SOURCE DRV PARM
 PUBLIC DT_IOCTL_DRV_PARM          ;PLACE HOLDER FOR DEFAULT TARGET DRV PARM
 PUBLIC DS_specialFunctions        ;AND THEIR CONTENTS
 PUBLIC DT_specialFunctions
 PUBLIC DS_deviceType
 PUBLIC DT_deviceType
 PUBLIC DS_deviceAttributes
 PUBLIC DT_deviceAttributes
 PUBLIC DS_numberOfCylinders
 PUBLIC DT_numberOfCylinders
 PUBLIC DS_mediaType
 PUBLIC DT_mediaType
 PUBLIC DS_BPB_PTR
 PUBLIC DT_BPB_PTR

 PUBLIC MS_IOCTL_DRV_PARM          ;DRIVE PARM FROM SOURCE MEDIUM
 PUBLIC MT_IOCTL_DRV_PARM          ;DRIVE PARM FROM TARGET MEDIUM

;*****************************************************************************
 ORG    100H                       ;PROGRAM ENTRY POINT                                ;

DISKCOMP:
 JMP    BEGIN
;*****************************************************************************
 EVEN                              ;PUT STACK ONTO A WORD ALIGNMENT BOUNDARY    ;AN000;
;INTERNAL STACK AREA

 DB     64 DUP  ('STACK   ')       ;512 BYTES

MY_STACK_PTR LABEL WORD
 PAGE
;*****************************************************************************
;                                                                            *
;                       INTERNAL VARIABLES                                   *
;                                                                            *
;*****************************************************************************

;                    $salut (4,22,26,36) ;                                      ;AN000;
;DEFAULT BPB FOR OLD MEDIA
;5.25, 48 TPI BPB SINGLE SIDE (9 SECTORS/TRACK)
BPB48_SINGLE         DW  512       ;BYTES/SECTOR
                     DB  1         ;SECTOR/CLUSTER
                     DW  1         ;# OF RESERVED SECTORS
                     DB  2         ;# OF FATS
                     DW  40h       ;# OF ROOT ENTRY
                     DW  168h      ;TOTAL # OF SECTORS IN THE MEDIA
                     DB  0FCh      ;MEDIA BYTE
                     DW  2         ;SECTORS/FAT

;5.25, 48 TPI BPB DOUBLE SIDE (9 SECTORS/TRACK)
BPB48_DOUBLE         DW  512       ;BYTES/SECTOR
                     DB  2         ;SECTOR/CLUSTER
                     DW  1         ;# OF RESERVED SECTORS
                     DB  2         ;# OF FATS
                     DW  70h       ;# OF ROOT ENTRY
                     DW  2D0h      ;TOTAL # OF SECTORS IN THE MEDIA
                     DB  0FDh      ;MEDIA BYTE
                     DW  2         ;SECTORS/FAT

;5.25, 96 TPI BPB DOUBLE SIDE (15 SECTORS/TRACK)
BPB96                DW  512       ;BYTES/SECTOR
                     DB  1         ;SECTOR/CLUSTER
                     DW  1         ;# OF RESERVED SECTORS
                     DB  2         ;# OF FATS
                     DW  0E0h      ;# OF ROOT ENTRY
                     DW  960h      ;TOTAL # OF SECTORS IN THE MEDIA
                     DB  0F9h      ;MEDIA BYTE
                     DW  7         ;SECTORS/FAT
BPB96_LENG           EQU $-BPB96   ;THIS LENGTH WILL BE USED FOR BPB48 ALSO.



; INPUT PARMETERS FROM INIT SUBROUTINE:

S_OWNER_SAVED        DB  0         ;DRIVE LETTER THAT OWNED
                                   ; SOURCE DRIVE OWNERSHIP
T_OWNER_SAVED        DB  0
RECOMMENDED_BYTES_SECTOR DW 0      ;RECOMMENED BYTES/SECTOR FROM DEVICE PARA

;IT IS ASSUMED THE NEXT TWO BYTES ARE CONSECUTIVE,
;AND DEFINED IN SOURCE/TARGET ORDER, BY DCOMPPAR.SAL.
SOURCE_DRIVE         DB  0         ;1=A:, 2=B:,...
TARGET_DRIVE         DB  0

ORG_SOURCE_DRIVE     DB  ?         ;ORIGINAL SOURCE DRIVE
ORG_TARGET_DRIVE     DB  ?         ;ORIGINAL TARGET DRIVE

USER_OPTION          DB  0
COPY_TYPE            DB  1
START_BUFFER         DW  0
BUFFER_BEGIN         DW  1000H     ;BEGINNING OF BUFFER ADDR [IN SEGMENT]
BUFFER_END           DW  3FF0H     ;END OF BUFFER ADDR [IN SEGMENT]
USER_OPTION_8        DB  ?
SECT_TRACK_LAYOUT    DW  0

S_DRV_SECT_TRACK     DB  ?         ;SECT/TRACK, device informations.
S_DRV_HEADS          DB  ?         ;# OF HEADS
S_DRV_TRACKS         DW  ?         ;# OF TRACKS
T_DRV_SECT_TRACK     DB  ?
T_DRV_HEADS          DB  ?
T_DRV_TRACKS         DW  ?

;LOCAL VARIABLES:
FIRST_TIME           DB  0         ;SWITCH TO ACTIVATE VOLSER CHECK             ;AN000;
EXITFL               DB  EXOK      ;ERRORLEVEL VALUE                            ;AN000;
                     PUBLIC EXITFL ;                                            ;AN000;
;C12 EXCBR                EQU 2         ;CONTROL-BREAK REQUESTED TERMINATION         ;AN000;
;C12 EXVER                EQU 1         ;BAD DOS VERSION ERRORLEVEL CODE             ;AN000;
;C12 EXPAR                EQU 1         ;ERROR IN INPUT PARMS IN COMMAND LINE        ;AN000;
EXOK                 EQU 0         ;NORMAL ERRORLEVEL RET CODE                  ;AN000;
EX_DIFFERENT         EQU 1         ;ERRORLEVEL - DIFFERENCES FOUND         ;C12
EX_HARD_ERROR        EQU 3         ;ERRORLEVEL - HARD ERROR OCCURRED       ;C12
EXCBR                EQU 2         ;ERRORLEVEL - CTRL+C REQUESTED          ;C12
EX_INIT_ERROR        EQU 4         ;ERRORLEVEL - ERROR DURING INIT         ;C12
EXVER                EQU 4         ;ERRORLEVEL - ERROR DURING INIT(DOSVER) ;C12
EXPAR                EQU 4         ;ERRORLEVEL - ERROR DURING INIT(PARSE)  ;C12
                     PUBLIC EXPAR  ;                                            ;AN000;

IOCTL_SECTOR         DW  1         ;used for READ_A_SECTOR routine.
IOCTL_TRACK          DW  0         ;IN THE TRACK
IOCTL_HEAD           DW  0         ;HEAD 0
SAV_CSECT            DW  0         ;TEMPORARY SAVING PLACE

BOOT_SECT_TRACK      DW  0         ;TEMP SAVING PLACE OF SECTOR/TRACK
BOOT_TOT_TRACK       DW  0         ;FOUND FROM THE BOOT SECTOR. max # of tracks
BOOT_NUM_HEAD        DW  0         ;NUMBER OF HEADS
BOOT_BYTE_SECTOR     DW  0         ;BYTES / SECTOR

READ_S_BPB_FAILURE   DB  0         ;GET MEDIA BPB. SUCCESS=0, FAILURE=1
READ_T_BPB_FAILURE   DB  0

;*** Informations gotten from CHECK_SOURCE.
;*** These will be used as a basis for the comp process.
LAST_TRACK           DW  79        ;LAST CYLINDER OF THE DASD (39 OR 79)
END_OF_TRACK         DB  15        ;END OF TRACK
bSECTOR_SIZE         DW  512       ;BYTES/SECTOR in bytes
NO_OF_SIDES          DB  ?         ;0=SINGLE SIDED, 1=DOUBLE SIDED

TRACK_TO_READ        DW  0
TRACK_TO_COMP        DW  0
TRACK_SIZE           DW  0         ;BYTES/CYLINDER [IN SEGMENTS]
SECTOR_SIZE          DB  0         ;BYTES/SECTOR [IN SEGMENTS]
BYTES_IN_TRACK       DW  ?         ;BYTES/ONE SIDE TRACK (USED IN COMP_TRACK)
BUFFER_PTR           DW  ?
COMP_ERROR           DB  0
SIDE                 DB  ?
OPERATION            DB  ?
COMP_STATUS          DB  ?
USER_INPUT           DB  ?         ;DISKCOMP AGAIN?
SEC_BUFFER           DW  ?         ;SECONDARY BUFFER SEG ADDR
COMPARE_PTR          DW  ?         ;COMPARE POINTER
IO_ERROR             DB  0         ;USED TO INDICATE IF READ/WRITE ERROR MESSAGE
MSG_FLAG             DB  ?
S_DRV_SET_FLAG       DB  0         ;SOURCE DEVICE PARM HAS BEEN SET?
T_DRV_SET_FLAG       DB  0

;---------------------------------------
;DEVICE PARAMETER TABLE
;the returned info. still has the following format.

DS_IOCTL_DRV_PARM    LABEL BYTE    ;PLACE HOLDER FOR DEFAULT TARGET DRV PARM
DS_specialFunctions  db  ?
DS_deviceType        db  ?         ;0=5.25, 1=5.25 96 TPI, 2=3.5" 720 KB
                                   ;3=8" SINGLE, 4=8" DOUBLE, 5=HARD DISK
DS_deviceAttributes  dw  ?         ;0001h - NOT REMOVABLE, 0002h - CHANGE
                                   ; LINE SUPPORTED
DS_numberOfCylinders dw  ?
DS_mediaType         db  ?
DS_BPB_PTR           LABEL BYTE
DS_deviceBPB         my_bpb <>
DS_trackLayout       LABEL WORD    ;                                            ;AC000;
                     my_trackLayout ;                                           ;AC000;
;---------------------------------------

DT_IOCTL_DRV_PARM    LABEL BYTE
DT_specialFunctions  db  ?
DT_deviceType        db  ?         ;0=5.25, 1=5.25 96 TPI, 2=3.5" 720 KB
                                   ;3=8" SINGLE, 4=8" DOUBLE, 5=HARD DISK
DT_deviceAttributes  dw  ?         ;0001h - NOT REMOVABLE, 0002h - CHANGE
                                   ; LINE SUPPORTED
DT_numberOfCylinders dw  ?
DT_mediaType         db  ?
DT_BPB_PTR           LABEL BYTE
DT_deviceBPB         my_bpb <>
DT_trackLayout       LABEL WORD    ;                                            ;AC000;
                     my_trackLayout ;                                           ;AC000;

;---------------------------------------

MS_IOCTL_DRV_PARM    LABEL BYTE    ;DRIVE PARM FROM SOURCE MEDIUM
MS_specialFunctions  db  ?
MS_deviceType        db  ?         ;0=5.25, 1=5.25 96 TPI, 2=3.5" 720 KB
                                   ;3=8" SINGLE, 4=8" DOUBLE, 5=HARD DISK
MS_deviceAttributes  dw  ?         ;0001h - NOT REMOVABLE, 0002h - CHANGE
                                   ; LINE SUPPORTED
MS_numberOfCylinders dw  ?
MS_mediaType         db  ?
MS_BPB_PTR           LABEL BYTE
MS_deviceBPB         my_bpb <>
MS_deviceBPB_leng    equ $-MS_deviceBPB
MS_trackLayout       LABEL WORD    ;                                            ;AC000;
                     my_trackLayout ;                                           ;AC000;
;---------------------------------------
MT_IOCTL_DRV_PARM    LABEL BYTE    ;DRIVE PARM FROM TARGET MEDIUM
MT_specialFunctions  db  ?
MT_deviceType        db  ?         ;0=5.25, 1=5.25 96 TPI, 2=3.5" 720 KB
                                   ;3=8" SINGLE, 4=8" DOUBLE, 5=HARD DISK
MT_deviceAttributes  dw  ?         ;0001h - NOT REMOVABLE, 0002h - CHANGE
                                   ; LINE SUPPORTED
MT_numberOfCylinders dw  ?
MT_mediaType         db  ?
MT_BPB_PTR           LABEL BYTE
MT_deviceBPB         my_bpb <>
MT_trackLayout       LABEL WORD    ;                                            ;AC000;
                     my_trackLayout ;                                           ;AC000;

;IOCTL read/write a track.
IOCTL_R_W            LABEL BYTE
specialFunctions     db  0
Head                 dw  ?
Cylinder             dw  ?
FirstSectors         dw  ?
numberOfSectors      dw  ?
TAddress_off         dw  ?
TAddress_seg         dw  ?

;(deleted ;AN011;) MEDIA_ID_BUFFER A_MEDIA_ID_INFO <> ;BUFFER FOR GET/SET MEDIA ID ;AN000;
                     PATHLABL DISKCOMP ;AN013;
                     HEADER <BEGIN - VERSION CHECK, SYSMSG INIT, EXIT TO DOS> ; ;AN000;
                     PUBLIC DISKCOMP_BEGIN ;                                    ;AN000;
DISKCOMP_BEGIN       LABEL BYTE
;*****************************************************************************
;                                                                            *
;                D I S K C O M P   M A I N   P R O G R A M                   *
;                                                                            *
;*****************************************************************************

;  $salut (4,4,10,36)              ;                                            ;AN000;
BEGIN PROC NEAR
   PUBLIC BEGIN                    ;                                            ;AN000;
;OUTPUT - "EXITFL" HAS ERRORLEVEL RETURN CODE

   MOV   SP, OFFSET MY_STACK_PTR   ;MOVE SP TO MY STACK AREA
   CALL  SYSLOADMSG                ;INIT SYSMSG HANDLER                         ;AN000;
   JNC $$IF1

   CALL  SYSDISPMSG                ;LET HIM SAY WHY HE HAD A PROBLEM            ;AN000;
   MOV   EXITFL,EXVER              ;TELL ERRORLEVEL BAD DOS VERSION             ;AN000;
   JMP SHORT $$EN1

$$IF1:
       CALL  INIT                  ;RUN INITIALIZATION ROUTINE
       CMP   [Q_BREAK], 0          ; exit after displaying options msg?
       JNE   EXIT_TO_DOS           ;  jump to exit if so

       CMP   DX,FINE               ;CHECK FOR ERROR DURING INIT
;      $IF   E                     ;IF NO ERROR THEN PROCEED TO COMP
       JNE $$IF3
;          $DO
$$DO4:
               MOV   EXITFL,EXOK   ;Reset errorlevel                       ;C12
               CALL  COMP          ;PERFORM DISKCOMP

               CALL  TEST_REPEAT   ;COMP ANOTHER ?

;          $ENDDO C
           JNC $$DO4
                                   ;NORMAL RETURN CODE ALREADY IN "EXITFL"
;      $ELSE                       ;ELSE IF ERROR DETECTED IN INIT
       JMP SHORT $$EN3
$$IF3:
           MOV   DI,DX             ;PASS NUMBER OF ERROR MSG, IF ANY            ;AD000;
                                   ;DI HAS OFFSET OF MESSAGE DESCRIPTOR
           CALL  SENDMSG           ;DISPLAY THE ERROR MESSAGE                   ;AC000;

           MOV   EXITFL,EXVER      ;ERROR RETURN CODE                           ;AC000;
;      $ENDIF
$$EN3:
       JMP   SHORT EXIT_TO_DOS

MAIN_EXIT:                         ;COME HERE AFTER CONTROL-BREAK
       MOV   EXITFL,EXCBR          ;  FOR CONTROL-BREAK EXIT                    ;AC000;

EXIT_TO_DOS:
       XOR   BX, BX

       MOV   BL, S_OWNER_SAVED     ;RESTORE ORIGINAL SOURCE,
                                   ; TARGET DRIVE OWNER.
       CALL  SET_LOGICAL_DRIVE

       MOV   BL, T_OWNER_SAVED
       CALL  SET_LOGICAL_DRIVE

       CMP   S_DRV_SET_FLAG, 0
;      $IF   NE                    ;                                            ;AN000;
       JE $$IF8
                                   ; Compaq bug fix -- reset original drive
;;         MOV   BL, S_OWNER_SAVED

           MOV   BL, ORG_SOURCE_DRIVE
           MOV   DS_specialFunctions, SET_SP_FUNC_DOS ;=0
           MOV   DX, OFFSET DS_IOCTL_DRV_PARM
           CALL  SET_DRV_PARM_DEF  ;RESTORE SOURCE DRIVE PARM

;      $ENDIF                      ;                                            ;AN000;
$$IF8:

       CMP   T_DRV_SET_FLAG, 0
;      $IF   NE                    ;                                            ;AN000;
       JE $$IF10
                                   ; Compaq bug fix -- reset original drive
;;         MOV   BL, T_OWNER_SAVED

           MOV   BL, ORG_TARGET_DRIVE
           MOV   DT_specialFunctions, SET_SP_FUNC_DOS ;=0
           MOV   DX, OFFSET DT_IOCTL_DRV_PARM
           CALL  SET_DRV_PARM_DEF  ;RESTORE TARGET DRIVE PARM

;      $ENDIF                      ;                                            ;AN000;
$$IF10:
EXIT_PROGRAM:
       MOV   AL,EXITFL             ;PASS ERRORLEVEL RET CODE                    ;AN000;
;  $ENDIF                          ;OK WITH SYSDISPMSG?                         ;AN000;
$$EN1:
   MOV   AL,EXITFL                 ;PASS BACK ERRORLEVEL RET CODE               ;AN000;
   DOSCALL RET_CD_EXIT             ;RETURN TO DOS WITH RET CODE                 ;AN000;

   INT   20H                       ;IF ABOVE NOT WORK,                          ;AN000;
BEGIN ENDP                         ;                                            ;AN000;
; = = = = = = = = = = = = = = = = =
   HEADER <MORE_INIT - FINISH INIT, DO COMP> ;                                  ;AN000;
MORE_INIT PROC NEAR                ;                                            ;AN000;
   RET                             ;RETURN TO CALLER                            ;AN000;
MORE_INIT ENDP                     ;                                            ;AN000;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <SET_LOGICAL_DRIVE - SET LOG. DRV LETTER THAT OWNS DRIVE> ;           ;AN000;
   PUBLIC SET_LOGICAL_DRIVE
;*****************************************************************************
SET_LOGICAL_DRIVE PROC NEAR
;       *** SET THE LOGICAL DRIVE LETTER THAT WILL BE THE OWNER OF THE DRIVE
;       INPUT: BL - DRIVE LETTER
;       OUTPUT: OWNER WILL BE SET ACCORDINGLY.
;*****************************************************************************
   CMP   BL, 0                     ;IS THIS DRIVE ZERO?
                                   ;IF BL = 0, THEN JUST RETURN
;  $IF   NE
   JE $$IF13
       DOSCALL IOCTL_FUNC,SET_LOG_DRIVE ;                                       ;AC000;
                                   ;SET BL AS AN OWNER OF THAT DRIVE
;  $ENDIF
$$IF13:
   RET
SET_LOGICAL_DRIVE ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <COMP - PERFORM THE OVERALL COMPARISON> ;                             ;AN000;
;*****************************************************************************
COMP PROC NEAR
;*****************************************************************************
   MOV   AL,ORG_SOURCE_DRIVE       ;INITIALIZE THE FIRST AND SECOND
   MOV   SOURCE_DRIVE,AL           ;DRIVE IN THE ORDER THE USER
   MOV   AL,ORG_TARGET_DRIVE       ;ENTERED ON THE COMMAND LINE
   MOV   TARGET_DRIVE,AL
   MOV   AX, RECOMMENDED_BYTES_SECTOR
   MOV   bSECTOR_SIZE, AX          ;USE RECOMMENDED SECTOR SIZE
                                   ; TO READ A SECTOR
   MOV   READ_S_BPB_FAILURE, 0     ;RESET GET BPB FAILURE FLAG
   MOV   READ_T_BPB_FAILURE, 0
   MOV   COMP_ERROR,0              ;RESET COMPARE ERROR COUNT
   MOV   COMP_STATUS,OK            ;RESET COMP STATUS BYTE
   CMP   COPY_TYPE,2               ;IF TWO DRIVE COMP
;  $IF   E
   JNE $$IF15
       CALL  DISPLAY_LOAD_FIRST    ;"Insert FIRST diskette in drive %1:"        ;AN000;

       CALL  DISPLAY_LOAD_SECOND   ;"Insert SECOND diskette in drive %1:"       ;AN000;

       CALL  PRESS_ANY_KEY         ;"Press any key to continue . . ."           ;AC009;

;  $ENDIF
$$IF15:
   MOV   TRACK_TO_READ,0           ;INITIALIZE TRACK NUMBERS
   MOV   TRACK_TO_COMP,0

COMP_TEST_END:
   MOV   AX,TRACK_TO_COMP          ;WHILE TRACK_TO_COMP<=LAST_TRACK
   CMP   AX,LAST_TRACK
   JA    COMP_END

   CALL  READ_SOURCE

   CMP   COMP_STATUS,FATAL         ;MAKE SURE DRIVES WERE COMPATIBLE
   JE    COMP_EXIT

   CALL  COMP_TARGET

   CMP   COMP_STATUS,FATAL         ;MAKE SURE TARGET AND SOURCE
   JE    COMP_EXIT                 ;DISKETTES ARE COMPATIBLE

   JMP   COMP_TEST_END

COMP_END:
   CMP   COMP_ERROR,0              ;IF ERROR IN COMP
;  $IF   E                         ;WARN USER
   JNE $$IF17
       PRINT MSGNUM_COMP_OK        ;"Compare OK"                                ;AC000;

;kiser note: this is a warning????

;  $ENDIF
$$IF17:

COMP_EXIT:
   CMP   COMP_STATUS,FATAL         ;WAS COMP ABORTED ?
;  $IF   E
   JNE $$IF19
                                   ;"Compare process ended"
       PRINT MSGNUM_FATAL_ERROR    ;IF SO THEN TELL USER                        ;AC000;

       CMP EXITFL,EXOK             ;Q: Was there already an error          ;C12
       JNZ $$IF19                  ; Y: then save that error               ;C12
       MOV EXITFL,EX_DIFFERENT     ; N: then force an errorlevel           ;C12
;  $ENDIF
$$IF19:
   RET

COMP ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <DISPLAY_LOAD_FIRST - MOUNT FIRST DISKETTE> ;                         ;AN000;
DISPLAY_LOAD_FIRST PROC NEAR       ;                                            ;AN000;
   PUBLIC DISPLAY_LOAD_FIRST       ;                                            ;AN000;
;  =  =  =  =  =  =  =  =  =  =  =  =

   MOV   SUBLIST_78.SUB_VALUE,OFFSET ASCII_DRV1_ID ;PASS CHAR DRIVE ID          ;AN000;
                                   ;"Insert FIRST diskette in drive %1:"
   PRINT MSGNUM_LOAD_FIRST         ;OUTPUT LOAD FIRST DISKETTE MESSAGE          ;AC000;

   MOV   MSG_FLAG,SECOND
   RET                             ;RETURN TO CALLER                            ;AN000;
DISPLAY_LOAD_FIRST ENDP            ;                                            ;AN000;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <DISPLAY_SECOND  - MOUNT FIRST DISKETTE> ;                            ;AN000;
DISPLAY_LOAD_SECOND PROC NEAR      ;                                            ;AN000;
   PUBLIC DISPLAY_LOAD_SECOND      ;                                            ;AN000;
;  =  =  =  =  =  =  =  =  =  =  =  =

   MOV   SUBLIST_78.SUB_VALUE,OFFSET ASCII_DRV2_ID ;PASS CHAR DRIVE ID          ;AN000;
                                   ;CR,LF,"Insert SECOND diskette in drive %1:",CR,LF
   PRINT MSGNUM_LOAD_SECOND        ;OUTPUT LOAD SECOND DISKETTE MESSAGE         ;AC000;

   MOV   MSG_FLAG,FIRST
   RET                             ;RETURN TO CALLER                            ;AN000;
DISPLAY_LOAD_SECOND ENDP           ;                                            ;AN000;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <TEST_REPEAT - PROMPT FOR ANOTHER COMPARE> ;                          ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC TEST_REPEAT              ;MAKE ENTRY IN LINK MAP                      ;AN000;
TEST_REPEAT PROC NEAR              ;TEST IF USER WANTS TO COMP ANOTHER       *
;                                DISKETTE                                    *
; INPUT : USER_INPUT ("Y" OR "N")
; OUTPUT: NC = COMP AGAIN                                                    *
;         CY = EXIT TO DOS                                                   *
;*****************************************************************************
;  $SEARCH                         ;REPEAT THIS PROMPT UNTIL (Y/N) RESPONDED    ;AC000;
$$DO21:
                                   ;"Compare another diskette (Y/N)?"
       PRINT MSGNUM_COMP_ANOTHER   ;SEE IF USER WANTS TO COMPARE ANOTHER        ;AC000;
                                   ; AND READ RESPONSE TO AL
       PUSH  AX                    ;SAVE THE RESPONSE                           ;AN000;
       PRINT MSGNUM_NEWLINE        ;CR,LF,LF                                    ;AC000;

       POP   DX                    ;RESTORE THE REPONSE CHAR TO DL              ;AN000;
       CALL  YESNO                 ;CHECK FOR (Y/N)                             ;AN000;

;  $EXITIF C,NUL                   ;QUIT IF OK ANSWER                           ;AN000;
   JC $$SR21
       CMP   AL,BAD_YESNO          ;WAS THE RESPONSE INVALID?                   ;AN000;
;  $ENDLOOP B                      ;QUIT IF OK ANSWER (AX=0 OR 1)               ;AN000;
   JNB $$DO21
       CMP   AL,YES                ;WAS "YES" SPECIFIED                         ;AN000;
;      $IF   E                     ;IF "YES"                                    ;AN000;
       JNE $$IF24
           MOV   FIRST_TIME,ZERO   ;SET UP TO DO ANOTHER VOLSER CHECK           ;AN000;
           CLC                     ;CLEAR CARRY TO INDICATE COMPARE AGAIN       ;AN000;
;      $ELSE                       ;SINCE NOT "YES"                             ;AN000;
       JMP SHORT $$EN24
$$IF24:
           STC                     ;SET CARRY TO INDICATE NO REPEAT             ;AN000;
;      $ENDIF                      ;                                            ;AN000;
$$EN24:
;  $ENDSRCH                        ;                                            ;AN000;
$$SR21:
   RET

TEST_REPEAT ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <READ_SOURCE - FILL AVAIL MEM WITH FIRST DISKETTE> ;                  ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC READ_SOURCE              ;MAKE ENTRY IN LINK MAP                      ;AN000;
READ_SOURCE PROC NEAR              ;FILL ALL AVAILABLE MOMORY WITH SOURCE DATA
;                                                                            *
;*****************************************************************************

   CMP   TRACK_TO_READ,0           ;1ST TRACK ?
;  $IF   E                         ;IF SO
   JNE $$IF28
       CMP   COPY_TYPE,1           ;IF SINGLE DRIVE COMP
;      $IF   E                     ;PROMPT MSG
       JNE $$IF29
           CALL  DISPLAY_LOAD_FIRST ;"Insert FIRST diskette in drive %1:"       ;AN000;

           CALL  PRESS_ANY_KEY     ;"Press any key to continue . . ."           ;AC000;

;      $ENDIF
$$IF29:
       CALL  CHECK_SOURCE          ;DO NECESSARY CHECKING
       cmp copy_type,1                  ;Q: single drive copy?          ;c04
       jz  skip_target_check            ;Y: don't check target yet      ;c04
       call  check_target               ;N: check_target now            ;c04
skip_target_check:                                                      ;c04

       CALL  CALC_TRACK_SIZE

       CALL  CHECK_MEMORY_SIZE

       CMP   COMP_STATUS,FATAL
       JE    RS_EXIT

;  $ENDIF
$$IF28:
   MOV   BX,BUFFER_BEGIN
   MOV   BUFFER_PTR,BX             ;INITIALIZE BUFFER POINTER

;  $DO
$$DO32:
       MOV   AX,TRACK_TO_READ      ;DID WE FINISH READING ALL TRACKS?
       CMP   AX,LAST_TRACK
;  $LEAVE A
   JA $$EN32

       MOV   AX,BUFFER_PTR         ;DID WE RUN OUT OF BUFFER SPACE
       ADD   AX,TRACK_SIZE
       CMP   AX,BUFFER_END
;  $LEAVE A
   JA $$EN32

       CALL  READ_TRACK            ;NO, GO READ ANOTHER TRACK

       INC   TRACK_TO_READ
;  $ENDDO
   JMP SHORT $$DO32
$$EN32:

RS_EXIT:
   RET

READ_SOURCE ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <CHECK_SOURCE - DETERMINE FIRST DISKETTE TYPE> ;                      ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC CHECK_SOURCE             ;MAKE ENTRY IN LINK MAP                      ;AN000;
CHECK_SOURCE PROC NEAR             ;CHECK SOURCE DISKETTE TYPE               *
;                                  SET END_OF_TRACK, LAST_TRACK              *
;                                  NO_OF_SIDES, bSECTOR_SIZE                 *
; ** this routine will call "Get dev parm" with "BUILD BPB BIT" on.  If it   *
; ** fails to get that info, then the source medium must be bad(vergin) or   *
; ** below DOS 2.0 level diskette, and will jmp to the old logic.            *
; ** For compatibility reasons (in case of non IBM formatted media), this    *
; ** routine covers old diskcopy routines.  But this will only supports
; ** 5.25" 48 tpi 8, 9 sectors, 40 tracks and 5.25" 96 tpi, 15 sectors, 80 tracks
; ** media.  Other non IBM formatted media which are formatted differenty
; ** from those values will result in unpreditable copy process.
;*****************************************************************************

CS_AGAIN:
   XOR   BX, BX
   MOV   BL, SOURCE_DRIVE
   MOV   MS_specialFunctions, GET_SP_FUNC_MED ;=00000001b
   MOV   CL, GETDEVPARM            ;=60h
   MOV   DX, OFFSET MS_IOCTL_DRV_PARM
   CALL  GENERIC_IOCTL             ;TRY TO GET MEDIA BPB INFO TOGETHER
                                   ;WITH DEFAULT DEVICE INFO.
   CMP   IO_ERROR, SOFT_ERROR      ;TRY AGAIN?
   JE    CS_AGAIN

   CMP   IO_ERROR, HARD_ERROR      ;CANNOT GET MEDIA BPB?
   JNE   CS_NEW                    ;                                            ;AC000;
CS_OLD_BRIDGE:
   JMP   CS_OLD                    ;ASSUME OLD FORMATTED DISKETTE, FIRST.      ;C00
CS_NEW:                            ;                                            ;AN000;
   cmp   ms_deviceBPB.csect_track,0 ;patch 1/16/86 J.K.
   je    cs_old_BRIDGE

   cmp   ms_deviceBPB.chead,0      ;cannot trust the info. from DOS.
   je    cs_old_bridge             ;sanity check for devide by 0.

   MOV   AX, MS_deviceBPB.CTOTSECT ;
   CWD                             ;CONVERT IT TO A DOUBLE WORD
   OR    AX,AX
   JNZ   NOT_ENHANCED
   MOV   AX, WORD PTR MS_deviceBPB.BIG_TOT_SECT
   MOV   DX, WORD PTR MS_deviceBPB.BIG_TOT_SECT+2

NOT_ENHANCED:
   DIV   MS_deviceBPB.CSECT_TRACK
   MOV   BX,MS_deviceBPB.CHEAD     ;(TOTAL SECTORS / # OF TRACKS) / # OF HEADS
   DIV   BX                        ;ENSURE WORD DIVISION
   CMP   AX, T_DRV_TRACKS          ;IF # OF TRACKS FOR SOURCE MEDIA > # OF
                                   ; TRACKS FOR TARGET DEVICE
   JA    CS_FATAL                  ;THEN, NOT COMPATIBLE

   DEC   AX                        ;DECREASE BY 1 FOR THIS PROGRAM'S USE.
   MOV   LAST_TRACK, AX            ;SET LAST_TRACK
   MOV   AX, MS_deviceBPB.CSECT_TRACK
   MOV   SECT_TRACK_LAYOUT, AX     ;VARIABLE FOR MS, MT_trackLayout.CSECT_F
   CMP   USER_OPTION_8, ON         ;/8 OPTION SPECIFIED?
   JNE   CS_GO_ON

   CMP   AX, 8                     ;SOURCE MEDIA # OF SECTORS/TRACK < 8 ?
   JB    CS_FATAL                  ;IF IT IS, THEN FATAL ERROR.

   MOV   AX, 8                     ;ELSE SET IT TO 8
CS_GO_ON:
   CMP   AL, T_DRV_SECT_TRACK
   JA    CS_FATAL

   MOV   END_OF_TRACK, AL          ;SET END_OF_TRACK
   MOV   AX, MS_deviceBPB.CBYTE_SECT
   MOV   bSECTOR_SIZE, AX          ;set the sector size in bytes.
   CMP   USER_OPTION, 1
;C11 JE    CS_OPTION_1
   JNE   CS_BRIDGE_OPTION               ;                                  ;C11
   JMP   CS_OPTION_1                    ;                                  ;C11
CS_BRIDGE_OPTION:                       ;                                  ;C11

   MOV   AX, MS_deviceBPB.CHEAD    ;HEAD=1, 2
   CMP   AL, T_DRV_HEADS           ;COMPARE SOURCE MEDIA SIDE WITH TARGET
                                   ; DRIVE HEAD NUMBER
   JA    CS_FATAL                  ;SOURCE MEDIUM IS DOUBLE SIDED AND
                                   ; TARGET DRIVE IS SINGLE SIDED.

   DEC   AX
   MOV   NO_OF_SIDES, AL           ;NO_OF_SIDES=0, 1
   JMP   CS_SET_TABLE

CS_FATAL:
   MOV   COMP_STATUS, FATAL
                                   ;"Drive types or diskette types"
                                   ;"not compatible"
   PRINT MSGNUM_NOT_COMPATIBLE     ;                                            ;AC000;
   MOV EXITFL,EX_INIT_ERROR        ;Show there was an INIT error           ;C12

   JMP   CS_EXIT

CS_BAD:
   MOV   COMP_STATUS, FATAL
   PRINT MSGNUM_BAD_FIRST          ;"FIRST diskette bad or incompatible"        ;AC000;
   MOV EXITFL,EX_INIT_ERROR        ;Show there was an INIT error           ;C12

   JMP   CS_EXIT

CS_OLD:

   MOV   READ_S_BPB_FAILURE, 1     ;SET FLAG
   MOV   bSECTOR_SIZE, 512         ;OLD SECTOR SIZE MUST BE 512 BYTES
   XOR   BX, BX
   MOV   BL, SOURCE_DRIVE
   MOV   IOCTL_TRACK, 0            ;TRACK=0
   MOV   IOCTL_SECTOR, 8           ;SECTOR=8
   MOV   IOCTL_HEAD, 0             ;HEAD = 0
   CALL  READ_A_SECTOR

   JC    CS_BAD                    ;SOURCE BAD

   MOV   IOCTL_SECTOR, 9           ;TRY TO READ SECTOR=9
   CALL  READ_A_SECTOR

   JC    CS_SECT8                  ;YES, 8 SECTORS. ASSUME 40 TRACKS

   MOV   IOCTL_SECTOR, 15          ;try to read sector=15
   CALL  READ_A_SECTOR

   JC    CS_SECT9                  ;**REMEMBER THIS ROUTINE DOES NOT COVER 3.5" MEDIA
                                        ;*** Now it does!!! ***         ;C06
;                                                                       ;C06
   MOV   IOCTL_SECTOR, 18          ;try to read sector=18               ;C06
   CALL  READ_A_SECTOR             ;                                    ;C06
   JC    CS_SECT15                 ;It doesn't exist, must only be 15   ;C06
                                                                        ;C06
;                                                                       ;C11
   MOV   IOCTL_SECTOR, 36          ;try to read sector=36               ;C11
   CALL  READ_A_SECTOR             ;                                    ;C11
   JC    CS_SECT18                 ;It doesn't exist, must only be 18   ;C11
                                                                        ;C11
   JMP SHORT CS_SECT36            ;36 sect/track, (2.88M 3.5" diskette) ;C11

CS_OPTION_1:
   MOV   NO_OF_SIDES, 0            ;1 SIDE COPY
;C10   JMP   SHORT CS_SET_TABLE                                        ;C00
   JMP   CS_SET_TABLE                                                   ;C10

CS_SECT36:                                                              ;C11
   MOV   SECT_TRACK_LAYOUT, 36     ;VARIABLE FOR MS, MT_trackLayout.CSECT_F;C11
   MOV   END_OF_TRACK, 36          ;ELSE END_OF_TRACK = 15              ;C11
   MOV   LAST_TRACK, 79                                                 ;C11
   JMP   SHORT CS_OPTIONS                                               ;C11

CS_SECT18:                                                              ;C06
   MOV   SECT_TRACK_LAYOUT, 18     ;VARIABLE FOR MS, MT_trackLayout.CSECT_F;C06
   MOV   END_OF_TRACK, 18          ;ELSE END_OF_TRACK = 15              ;C06
   MOV   LAST_TRACK, 79                                                 ;C06
   JMP   SHORT CS_OPTIONS                                               ;C06

CS_SECT15:
   MOV   SECT_TRACK_LAYOUT, 15     ;VARIABLE FOR MS, MT_trackLayout.CSECT_F
   MOV   END_OF_TRACK, 15          ;ELSE END_OF_TRACK = 15
   MOV   LAST_TRACK, 79
;C00   JMP   CS_OPTIONS
   JMP   SHORT CS_OPTIONS                                               ;C00

CS_SECT8:
   MOV   SECT_TRACK_LAYOUT, 8      ;VARIABLE FOR MS, MT_trackLayout.CSECT_F
   MOV   END_OF_TRACK, 8           ;SOURCE 8 SECTORS
   MOV   LAST_TRACK,  39           ;ASSUME 40 TRACKS.
;C00   JMP   CS_OPTIONS
   JMP   SHORT CS_OPTIONS                                               ;C00
_CS_OPTION_1:                   ;This must be after an unconditional jmp;C10
   JMP    CS_OPTION_1           ;Fixes out of range errors              ;C10
CS_SECT9:
   MOV   SECT_TRACK_LAYOUT, 9      ;VARIABLE FOR MS, MT_trackLayout.CSECT_F
   MOV   END_OF_TRACK, 9
   MOV   LAST_TRACK, 39            ;ASSUME 5.25 DISKETTE
   MOV   IOCTL_TRACK, 79           ;now try to read track 80 (3.5")     ;C10
   MOV   IOCTL_SECTOR, 9           ;SECTOR=9                            ;C10
   MOV   IOCTL_HEAD, 0             ;HEAD = 0                            ;C10
   CALL  READ_A_SECTOR             ;                                    ;C10
   JC    CS_OPTIONS                ;It failed, we assumed right (5.25") ;C10
   MOV   LAST_TRACK, 79            ;It is a 3.5" 720k diskette!         ;C10
CS_OPTIONS:
   CMP   USER_OPTION_8, ON
   JNE   CS_CHK_SIDE

   MOV   END_OF_TRACK, 8
CS_CHK_SIDE:
   CMP   USER_OPTION, 1
;C10 JE      CS_OPTION_1
   JE    _CS_OPTION_1                                                   ;C10

   MOV   IOCTL_HEAD, 1             ;HEAD 1
   XOR   AX, AX
   MOV   AL, END_OF_TRACK          ;READ MATCHING END_OF_TRACK
                                   ; OF THE OTHER SURFACE.
   MOV   IOCTL_SECTOR, AX
   CALL  READ_A_SECTOR

;C10   JC    CS_OPTION_1               ;1 SIDED SOURCE
   JC    _CS_OPTION_1               ;1 SIDED SOURCE                     ;C10

   MOV   NO_OF_SIDES, 1            ;2 SIDED SOURCE
   CMP   T_DRV_HEADS, 2            ;SOUCE=2 SIDED MEDIUM. IS TARGET
                                   ; DOUBLE SIDED DRV?
   JE    CS_SET_TABLE

   JMP   CS_FATAL                  ;NOT COMPATIBLE

CS_SET_TABLE:
   CMP   READ_S_BPB_FAILURE, 1     ;diskette without BPB info?
   JNE   CS_SET_TABLE_NEXT

   CALL  SET_FOR_THE_OLD           ;set deviceBPB info for before 2.0 level

CS_SET_TABLE_NEXT:
   MOV   BX, OFFSET MS_trackLayout ;SET TRACKLAYOUT OF SOURCE
   CALL  SET_TRACKLAYOUT

   MOV   S_DRV_SET_FLAG, 1         ;indicate SOURCE DRIVE
                                   ; PARAMETER HAS BEEN SET
   XOR   BX, BX
   MOV   BL, SOURCE_DRIVE
   MOV   DX, OFFSET MS_IOCTL_DRV_PARM
   MOV   MS_specialFunctions, SET_SP_FUNC_DEF
   CALL  SET_DRV_PARM_DEF          ;set device parameter for read

   XOR   AX, AX
   MOV   AL, END_OF_TRACK
   MOV   numberOfSectors, AX       ;SET NUMBEROFSECTORS IN IOCTL_R_W TABLE

   MOV   AX, LAST_TRACK            ;NOW, SHOW THE MESSAGE "COMPARING ..."
   INC   AX
   MOV   MSG_TRACKS,AX             ;HOW MANY TRACKS?                            ;AC000;

   MOV   AL, END_OF_TRACK
   MOV   BYTE PTR MSG_SECTRK,AL    ;HOW MANY SECTORS?                           ;AC000;

   MOV   AL, NO_OF_SIDES           ;TELL USER HOW MANY SIDE TO COPY
   INC   AL
   MOV   BYTE PTR MSG_SIDES,AL     ;                                            ;AC000;
                                   ;CR,LF,"Comparing %1 tracks",CR,LF
                                   ;"%2 Sectors/Track, %3 Side(s)",CR,LF
   PRINT MSGNUM_COMPARING          ;                                            ;AC000;

CS_EXIT:
   RET

CHECK_SOURCE ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <READ_A_SECTOR - USE IOCTL READ TO GET A SECTOR> ;                    ;AN000;
;*****************************************************************************
   PUBLIC READ_A_SECTOR            ;MAKE ENTRY IN LINK MAP                      ;AN000;
READ_A_SECTOR PROC NEAR
;
;TRY TO READ A SECTOR USING IOCTL READ FUNCTION CALL.
;THIS ROUTINE WILL STEAL "IOCTL_R_W" TABLE TEMPORARILY.
;INPUT: BX - LOGICAL DRIVE NUMBER
;       IOCTL_SECTOR - SECTOR TO READ
;       IOCTL_TRACK - TRACK
;       IOCTL_HEAD - HEAD TO READ
;       bSECTOR_SIZE - SECTOR SIZE IN BYTES
;OUTPUT:
;       IF NOT A SUCCESS, CARRY WILL BE SET
;       ALL REGISTORS SAVED
;*****************************************************************************
   PUSH  AX
   PUSH  BX
   PUSH  CX
   PUSH  DX

   MOV   AX, numberOfSectors       ;SAVE IOCTL_R_W TABLE VALUES
   MOV   SAV_CSECT, AX

;  $DO
$$DO36:
       MOV   AX, IOCTL_HEAD
       MOV   Head, AX              ;SURFACE TO READ
       MOV   AX, IOCTL_TRACK
       MOV   Cylinder, AX          ;TRACK TO READ
       MOV   AX, IOCTL_SECTOR
       dec   ax                    ;????? currently firstsector=0 =>
                                   ; 1st sector ????
       MOV   FirstSectors, AX      ;SECTOR TO READ
       MOV   numberOfSectors, 1    ;read just one sector
       MOV   AX, offset INIT       ;READ IT INTO INIT (CURRELTLY, MAX 1K)
       MOV   TAddress_off, AX
       MOV   TAddress_seg, DS
       MOV   CL, READ_FUNC
       MOV   DX, OFFSET IOCTL_R_W  ;POINTS TO CONTROL TABLE
       call  generic_ioctl

       CMP   IO_ERROR, SOFT_ERROR  ;TRY ONCE MORE?
;  $ENDDO NE
   JE $$DO36

   CMP   IO_ERROR, HARD_ERROR      ;HARD ERROR?
;  $IF   NE
   JE $$IF38

       CLC                         ;READ SUCCESS
;  $ELSE
   JMP SHORT $$EN38
$$IF38:

       STC                         ;READ FAILURE, SET CARRY
;  $ENDIF
$$EN38:
   MOV   AX, SAV_CSECT             ;RESTORE ORIGINAL IOCTL_R_W TABLE
   MOV   numberOfSectors, AX
   POP   DX
   POP   CX
   POP   BX
   POP   AX
   RET
READ_A_SECTOR ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <CALC_TRACK_SIZE - FIND MEM SIZE TO HOLD ONE TRACK> ;                 ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC CALC_TRACK_SIZE          ;MAKE ENTRY IN LINK MAP                      ;AN000;
CALC_TRACK_SIZE PROC NEAR          ;CALCULATE MEMORY SIZE REQUIRED TO STORE ONE
;                                  TRACK (IN SEGMENTS)                       *
;CALCULATE SECTOR_SIZE IN PARA FROM bSECTOR_SIZE.  IF bSECTOR_SIZE CANNOT BE
;CHANGED TO SECTOR_SIZE IN PARA EXACTLY, THEN ADD 1 TO THE SECTOR_SIZE.
;SECTOR_SIZE IS USED FOR MEMORY MANAGEMANT ONLY.  THE ACTUAL COPY OR FORMAT
;SHOULD BE DEPENDS ON bSECTOR_SIZE TO FIGURE OUT HOW BIG A SECTOR IS.
;ALSO, CURRENTLY, THIS ROUTINE ASSUME A BSECTOR SIZE BE LESS THAN 0FFFh.
;*****************************************************************************

   PUSH  AX
   PUSH  BX
   PUSH  CX

   MOV   AX, bSECTOR_SIZE
   XOR   DX, DX
   XOR   BX, BX
   MOV   BL, END_OF_TRACK
   MUL   BX                        ;ASSUME DX=0
   MOV   BYTES_IN_TRACK,AX         ;BYTES/TRACK ON A SIDE OF THE DISKETTE

   MOV   AX, bSECTOR_SIZE
   MOV   CL, 16
   DIV   CL                        ;AX / 16 = AL ... AH
   CMP   AH, 0                     ;NO REMAINER?
;  $IF   NE
   JE $$IF41

       INC   AL                    ;THERE REMAINER IS.  INC AL
;  $ENDIF
$$IF41:
   MOV   SECTOR_SIZE, AL           ;SECTOR_SIZE+ IN PARA.
   MOV   AL,NO_OF_SIDES            ;TRACK_SIZE = (NO OF SIDES
   INC   AL                        ;              + 1)
   MUL   END_OF_TRACK              ;              * END_OF_TRACK
   MOV   BL,SECTOR_SIZE            ;              * SECTPR_SIZE
   MUL   BL                        ;AMOUNT OF MEMORY REQUIRED (IN SEG)
   MOV   TRACK_SIZE,AX             ;TO STORE A TRACK

   MOV   BX,START_BUFFER           ;SET SECONDARY AT START OF BUFFER SPACE
   MOV   SEC_BUFFER,BX             ;SET THE SECONDARY BUFFER SEG ADDR
   ADD   BX,AX                     ;MOVE THE PRIMARY BUFFER BELOW THE
   MOV   BUFFER_BEGIN,BX           ;SECONDARY BUFFER
   POP   CX
   POP   BX
   POP   AX

   RET

CALC_TRACK_SIZE ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <CHECK_MEMORY_SIZE - BE SURE ENUF ME TO COMPARE 1 TRACK> ;            ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC CHECK_MEMORY_SIZE        ;MAKE ENTRY IN LINK MAP                      ;AN000;
CHECK_MEMORY_SIZE PROC NEAR        ;MAKE SURE WE HAVE ENOUGH TO COMP 1 TRACK INTO
;                             TO BUFFER ELSE ABORT COMP                      *
;*****************************************************************************
   MOV   AX,BUFFER_END
   SUB   AX,BUFFER_BEGIN
   CMP   AX,TRACK_SIZE
;  $IF   B
   JNB $$IF43
       MOV   COMP_STATUS,FATAL
                                   ;"Insufficient memory"
       PRINT MSGNUM_UNSUF_MEMORY   ;                                            ;AC000;
       MOV EXITFL,EX_INIT_ERROR    ;Show there was an INIT error           ;C12

;  $ENDIF
$$IF43:
   RET

CHECK_MEMORY_SIZE ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <COMP_TARGET - COMPARE MEM DATA WITH SECOND DISKETTE> ;               ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC COMP_TARGET              ;MAKE ENTRY IN LINK MAP                      ;AN000;
COMP_TARGET PROC NEAR              ;COMPARE DATA FROM MEMORY TO TARGET DISKETTE
;                                                                            *
;*****************************************************************************

   CMP   COPY_TYPE,1               ;IF SINGLE DRIVE COMP
;  $IF   E                         ;PROMPT MSG
   JNE $$IF45
       CMP   MSG_FLAG,SECOND
;      $IF   E
       JNE $$IF46
           CALL  DISPLAY_LOAD_SECOND ;"Insert SECOND diskette in drive %1:"     ;AN000;

;      $ELSE
       JMP SHORT $$EN46
$$IF46:
           CALL  DISPLAY_LOAD_FIRST ;"Insert FIRST diskette in drive %1:"        ;AN000;

;      $ENDIF
$$EN46:
       CALL  PRESS_ANY_KEY         ;"Press any key to continue . . ."           ;AC009;

;  $ENDIF
$$IF45:
   MOV   BX,BUFFER_BEGIN
   MOV   COMPARE_PTR,BX            ;INITIALIZE BUFFER POINTER
   CMP   TRACK_TO_COMP,0           ;IF TRK 0, CHECK COMPATIBILITY
;  $IF   E
   JNE $$IF50
       cmp   copy_type,1                ;Q: single drive copy?          ;c04
       jnz   already_checked_Target     ; N: don't check target again   ;c04
       CALL  CHECK_TARGET
already_checked_target:                                                 ;c04

       CMP   COMP_STATUS,FATAL     ;IF INCOMPATIBLE, THEN EXIT
       JE    CT_EXIT

;  $ENDIF
$$IF50:

   CALL  SWAP_DRIVE

;  $DO
$$DO52:
       CALL  COMP_TRACK            ;NO, GO READ ANOTHER TRACK

       INC   TRACK_TO_READ
       MOV   AX,TRACK_TO_READ      ;DID WE FINISH READING ALL TRACKS?
       CMP   AX,LAST_TRACK
;  $LEAVE A
   JA $$EN52

       MOV   AX,COMPARE_PTR        ;DID WE RUN OUT OF BUFFER SPACE
       ADD   AX,TRACK_SIZE
       CMP   AX,BUFFER_END
;  $ENDDO A
   JNA $$DO52
$$EN52:

CT_EXIT:
   RET
COMP_TARGET ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <CHECK_TARGET - COMPARE SECOND DISK BOOT RECORD> ;                    ;AN000;
;*****************************************************************************
   PUBLIC CHECK_TARGET             ;MAKE ENTRY IN LINK MAP                      ;AN000;
CHECK_TARGET PROC NEAR             ;                                    *
;   ** CHECK_SOURCE PROCEDURE ALREADY CHECKS OUT THE INCOMPATIBILITY BETWEEN *
;   ** SOURCE MEDIA AND TARGET DRIVE.  (CHECKING SOURCE MEDIA SECTOR/TRACK   *
;   ** EXCEEDS TARGET DRV SECTOR/TRACK, AND SOURCE MEDIA # OF TRACKS WITH    *
;   ** THAT OF TARGET DRV.)                                                  *
;   ** THIS ROUTINE WILL TRY TO READ TARGET MEDIA BOOT RECORD.               *
;   ** IF A SUCCESS,THEN COMPARE BPB INFO WITH THAT OF SOURCE MEDIA.         *
;   ** IF THEY ARE DIFFERENT, THEN ERROR - NOT COMPATIBLE                    *
;   ** IF FAILED TO READ A BOOT, THEN TRY OLD LOGICS BEFORE DOS 3.2 FOR      *
;   ** COMPATIBILITY REASONS.                                                *
;*****************************************************************************
;  $DO
$$DO55:
       XOR   BX, BX
       MOV   BL, TARGET_DRIVE
       MOV   MT_specialFunctions, GET_SP_FUNC_MED ;=00000001b
       MOV   CL, GETDEVPARM
       MOV   DX, OFFSET MT_IOCTL_DRV_PARM
       CALL  GENERIC_IOCTL         ;TRY TO GET MEDIA BPB INFO TOGETHER
                                   ;WITH THE DEFAULT DEVICE INFO.
       CMP   IO_ERROR, SOFT_ERROR  ;TRY AGAIN?
;  $ENDDO NE
   JE $$DO55

   CMP   IO_ERROR, HARD_ERROR      ;ASSUME OLD DISKTETTE. OR DISKETTE BAD
   jne   continue_cht_old                                                  ;C12
;C12   JNE   @F
CHT_OLD_BRIDGE:                                                            ;C12
   JMP   CHT_OLD
;C12 @@:
continue_cht_old:                                                          ;C12
   cmp   mt_deviceBPB.csect_track,0 ;patch 1/16/86, J.K.
   je    cht_old_bridge

   cmp   mt_deviceBPB.chead,0      ;cannot trust the info from DOS.
   je    cht_old                   ;sanity check for devide by 0

;C08   MOV   AX, MS_deviceBPB.CTOTSECT ;
   MOV   AX, MT_deviceBPB.CTOTSECT ;                                      ;C08
   CWD                             ;CONVERT IT TO A DOUBLE WORD
   OR    AX,AX
   JNZ   NOT_ENHANCED2
;C08   MOV   AX, WORD PTR MS_deviceBPB.BIG_TOT_SECT
;C08   MOV   DX, WORD PTR MS_deviceBPB.BIG_TOT_SECT+2
   MOV   AX, WORD PTR MT_deviceBPB.BIG_TOT_SECT                           ;C08
   MOV   DX, WORD PTR MT_deviceBPB.BIG_TOT_SECT+2                         ;C08

NOT_ENHANCED2:
;C08   DIV   MS_deviceBPB.CSECT_TRACK  ;
;C08   MOV   BX,MS_deviceBPB.CHEAD ;(TOTAL SECTORS / # OF TRACKS) / # OF HEADS
   DIV   MT_deviceBPB.CSECT_TRACK  ;                                      ;C08
   MOV   BX,MT_deviceBPB.CHEAD ;(TOTAL SECTORS / # OF TRACKS) / # OF HEADS;C08
   DIV   BX                        ;ENSURE WORD DIVISION
   DEC   AX                        ;DECREASE BY 1 FOR THIS PROGRAM
   CMP   LAST_TRACK, AX            ;COMPARE WITH SOURCE LAST TRACK
   JNE   CHT_FATAL_BRIDGE          ;IF LAST_TRACK IS DIFFERENT,
                                   ; THEN INCOMPATIBLE.

   MOV   AX, MT_deviceBPB.CSECT_TRACK
   MOV   SECT_TRACK_LAYOUT, AX     ;VARIBLE FOR MT_trackLayout.CSECT_F
CHT_GO_ON:
   CMP   END_OF_TRACK, AL
   JA    CHT_FATAL_BRIDGE          ;IF SOURCE END_OF_TRACK > TARGET
                                   ; END_OF_TRACK, THEN ERROR

   JE    CHT_GO_ON_2               ;IF SOURCE SEC/TRACK = TARGET SEC/TRACK ;C01
                                   ;NO REASON TO CHECK FURTHER             ;C01

   CMP   USER_OPTION_8,ON          ;IF /8, ALLOW DISKCOMP OF 720K to 1.44M
   JNE   CHT_GO_ON_1               ;OTHERWAISE MUST BE NO MORE THAN 1 OFF

   CMP   END_OF_TRACK,8            ;CHECK ONLY IF TARGET HAS AT LEAST 8
   JB    CHT_SECOND_BAD            ;IF NOT 8, SECOND DISK IS BAD
   JMP   SHORT CHT_GO_ON_2         ;OTHERWISE THE CHECK IS BYPASSED

CHT_GO_ON_1:
                                                                           ;C01
   SUB   AL,byte ptr END_OF_TRACK  ;AX = (SOURCE SEC/TRK - TARGET SEC/TRK) ;C01
   SBB   AH,0
   DEC   AX                        ;ALLOW FOR 8 SECTOR SOURCE AND 9 TARGET ;C01
   JNZ   CHT_FATAL_BRIDGE          ;IF MORE THAN 1 SECTOR OFF, ERROR OUT   ;C01
                                                                           ;C01
CHT_GO_ON_2:                       ;                                       ;C01
                                   ;8 SECTORED SOURCE AND 9 SECTORED TARGET
                                   ; IS OK AS FAR AS THE COMPATIBILITY GOES.
   MOV   AX, MT_deviceBPB.CBYTE_SECT
   CMP   AX, bSECTOR_SIZE          ;IF SECTOR SIZE ARE DIFFERENT, THEN
                                   ; NOT COMPATIBLE
   JNE   CHT_FATAL_BRIDGE

   CMP   NO_OF_SIDES, 1            ;TWO SIDED COPY?
   JNE   CHT_SET_BRIDGE            ;NO, ONE SIDED. DON'T
                                   ; CARE ABOUT TARGET SIDES.

   CMP   MT_deviceBPB.CHEAD, 2     ;TARGET FORMATTED INTO TWO SIDES?
   JNE   CHT_FATAL_BRIDGE          ;NO, NOT COMPATIBLE

   JMP   CHT_SET_DRV               ;OK. SOURCE, TARGET MEDIA ARE MATCHING. SET
                                   ; DRV PARM FOR READING

CHT_SET_BRIDGE:
   JMP   CHT_SET_DRV

CHT_FATAL_BRIDGE:
   JMP   CHT_FATAL

CHT_SECOND_BAD:
   MOV   COMP_STATUS, FATAL
   PRINT MSGNUM_BAD_SECOND         ;"SECOND diskette bad or incompatible"        ;AC000;
   MOV EXITFL,EX_INIT_ERROR        ;Show there was an INIT error           ;C12

   JMP   CHT_EXIT

CHT_OLD:                           ;SAME OLD. ;AGAIN, THIS DOES
                                   ; NOT RECOGNIZE 3.5 MEDIA
   MOV   READ_T_BPB_FAILURE, 1     ;SET THE FLAG.
   XOR   BX, BX
   MOV   BL, TARGET_DRIVE
   MOV   IOCTL_TRACK, 0
   MOV   IOCTL_SECTOR, 8
   MOV   IOCTL_HEAD, 0             ;TRY TO READ HEAD 0, TRACK 0, SECTOR 8
   CALL  READ_A_SECTOR

   JC    CHT_SECOND_BAD            ;ASSUME TARGET MEDIA NOT FORMATTED.

   MOV   IOCTL_SECTOR, 9           ;TRY TO READ SECTOR 9
   CALL  READ_A_SECTOR

   JC    CHT_8_SECTOR              ;TARGET IS 8 SECTOR MEDIA

   MOV   IOCTL_SECTOR, 15
   CALL  READ_A_SECTOR

   JC    CHT_9_SECTOR              ;TARGET IS 9 SECTOR MEDIA

   MOV   IOCTL_SECTOR, 18                                               ;C09
   CALL  READ_A_SECTOR                                                  ;C09
                                                                        ;C09
   JC    CHT_15_SECTOR             ;TARGET IS 15 SECTOR MEDIA           ;C09
                                                                        ;C09
   MOV   IOCTL_SECTOR, 36                                               ;C11
   CALL  READ_A_SECTOR                                                  ;C11
                                                                        ;C11
   JC    CHT_18_SECTOR             ;TARGET IS 18 SECTOR MEDIA           ;C11
                                                                        ;C11
;CHT_36_SECTOR:                          ;TARGET IS 36 SECTOR MEDIA     ;C11
   MOV   SECT_TRACK_LAYOUT, 36                                          ;C11
   CMP   END_OF_TRACK, 36          ;IS SOURCE ALSO 36 SECTORS/TRACK?    ;C11
   JNE   CHT_FATAL                 ;NO, FATAL ERROR                     ;C11
                                                                        ;C11
   JMP   SHORT CHT_CHK_SIDE        ;YES, OK.                            ;C11
                                                                        ;C09
                                                                        ;C09
CHT_18_SECTOR:                           ;TARGET IS 18 SECTOR MEDIA     ;C09
   MOV   SECT_TRACK_LAYOUT, 18                                          ;C09
   CMP   END_OF_TRACK, 18          ;IS SOURCE ALSO 18 SECTORS/TRACK?    ;C09
   JNE   CHT_FATAL                 ;NO, FATAL ERROR                     ;C09
                                                                        ;C09
   JMP   SHORT CHT_CHK_SIDE        ;YES, OK.                            ;C09
                                                                        ;C09


CHT_15_SECTOR:                          ;TARGET IS 15 SECTOR MEDIA      ;C09
   MOV   SECT_TRACK_LAYOUT, 15
   CMP   END_OF_TRACK, 15          ;IS SOUCE ALSO 96 TPI?
   JNE   CHT_FATAL                 ;NO, FATAL ERROR

   JMP   SHORT CHT_CHK_SIDE        ;YES, OK.

CHT_8_SECTOR:
   MOV   SECT_TRACK_LAYOUT, 8
   CMP   END_OF_TRACK, 15
   JE    CHT_FATAL                 ;IF SOURCE IS 96 TPI, THEN FATAL ERROR

   CMP   END_OF_TRACK, 9
   JE    CHT_FATAL                 ;IF SOURCE IS 9 SECTOR, THEN
                                   ; SHOULD FORMAT TARGET

   JMP   SHORT CHT_CHK_SIDE        ;ELSE ASSUME SOURCE IS 8 SECTOR.

CHT_9_SECTOR:
   MOV   SECT_TRACK_LAYOUT, 9
   CMP   END_OF_TRACK, 15          ;IS SOURCE 96 TPI? THEN ERROR
   JE    CHT_FATAL                 ;ELSE SOUCE IS 8 OR 9 SECTORED
                                   ; 48 TPI DISKETTE

CHT_CHK_SIDE:                      ;CHECK THE TARGET DISKETTE # OF SIDES
   CMP   NO_OF_SIDES, 0            ;1 SIDE COMP?
   JE    CHT_EXIT_OLD              ;

   MOV   IOCTL_HEAD, 1             ;ELSE TWO SIDE COMP
   XOR   AX, AX
   MOV   AL, END_OF_TRACK          ;TRY TO READ MATCHING TARGET SECTOR
   MOV   IOCTL_SECTOR, AX          ;OF THE OTHERSIDE
   CALL  READ_A_SECTOR

   JNC   CHT_EXIT_OLD              ;SUCCESS? OK

CHT_FATAL:
   CALL  COMPAT_ERROR

   JMP   SHORT   CHT_EXIT

CHT_EXIT_OLD:
   CALL  SET_FOR_THE_OLD           ;SET MT_deviceBPB INFO.

CHT_SET_DRV:
   MOV   BX, OFFSET MT_trackLayout ;SET TARGET TRACK LAYOUT
   CALL  SET_TRACKLAYOUT

   JC    CHT_FATAL                 ;IF FAILED, THEN, NOT COMPATIBLE

   MOV   T_DRV_SET_FLAG, 1         ;INDICATES THE TARGET DEFAULT
                                   ; DEVICE PARM HAS BEEN SET
   mov   bx, last_track            ;To make sure the number of
                                   ; cyl. of target. 3/27/86,J.K.
   inc   bx
   mov   MT_numberOfCylinders, bx
   MOV   BL, TARGET_DRIVE
   MOV   DX, OFFSET MT_IOCTL_DRV_PARM
   MOV   MT_specialFunctions, SET_SP_FUNC_DEF
   CALL  SET_DRV_PARM_DEF

CHT_EXIT:
   RET

CHECK_TARGET ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <SET_DRV_PARM - REQUEST IOCTL TO SET DEVICE PARM> ;                   ;AN000;
;*****************************************************************************
   PUBLIC SET_DRV_PARM_DEF         ;MAKE ENTRY IN LINK MAP                      ;AN000;
SET_DRV_PARM_DEF PROC NEAR
;INPUT: BL - DRIVE NUMBER
;       DX - POINTER TO THE PARAMETER TABLE
;       specialFunction should be set before this call
;*****************************************************************************

   MOV   CL, SETDEVPARM            ;=40H
   CALL  GENERIC_IOCTL

   RET

SET_DRV_PARM_DEF ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <COMP_TRACK - READ AND COMPARE SPECIFIED TRACK> ;                     ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC COMP_TRACK               ;MAKE ENTRY IN LINK MAP                      ;AN000;
COMP_TRACK PROC NEAR               ;COMPARE TRACK SPECIFIED IN TRACK_TO_COMP
;                                                                            *
;*****************************************************************************
   MOV   AX,SEC_BUFFER             ;READ IN THE TRACK TO BE COMPARED
   MOV   BUFFER_PTR,AX             ;INTO THE SECONDARY BUFFER
   CALL  READ_TRACK

   MOV   SIDE,0                    ;START ON SIDE ZERO
   MOV   CX,BYTES_IN_TRACK         ;GET NUMBER TO COMPARE
   PUSH  DS
   PUSH  ES
   MOV   ES,COMPARE_PTR            ;SET DESTINATION SEG ADDR
   MOV   DS,SEC_BUFFER             ;SET SOURCE SEG ADDR

   ASSUME ES:NOTHING
   ASSUME DS:NOTHING

   XOR   DI,DI                     ;SET TO START OF TRACK
   XOR   SI,SI
   CMP   FIRST_TIME,ZERO           ;IF THIS IS THE FIRST SECTOR TO BE COMPARED  ;AN000;
;  $IF   E                         ;                                            ;AN000;
   JNE $$IF57
       CALL  VOLSER                ;SPECIAL HANDLING FOR VOL SER #              ;AN000;

       MOV   FIRST_TIME,ONE        ;FLAG FIRST TIME AS "DONE"                   ;AN000;
;  $ENDIF                          ;                                            ;AN000;
$$IF57:
   CALL  DO_COMPARE                ;COMPARE STRING                              ;AN000;

   POP   ES
   POP   DS

   ASSUME ES:CSEG
   ASSUME DS:CSEG

;  $IF   NZ
   JZ $$IF59
       PUSH  AX                    ;SAVE AX SINCE ERROR_MESSAGE WILL DESTROY IT
       MOV   OPERATION,COMPARE_FUNC
       CALL  ERROR_MESSAGE

       INC   COMP_ERROR
       POP   AX
;  $ENDIF
$$IF59:
   CMP   NO_OF_SIDES,1             ;TWO SIDED COMPARE?
;  $IF   E                         ;YES
   JNE $$IF61
       MOV   SIDE,1                ;MARK IT AS SUCH
       MOV   SI,BYTES_IN_TRACK     ;BUMP UP BUFFER POINTERS
       MOV   DI,BYTES_IN_TRACK     ;TO START OF SECOND SIDE
       MOV   CX,BYTES_IN_TRACK     ;GET NUMBER TO COMPARE
       PUSH  DS
       PUSH  ES
       MOV   ES,COMPARE_PTR        ;SET DESTINATION SEG ADDR
       MOV   DS,SEC_BUFFER         ;SET SOURCE SEG ADDR
       CALL  DO_COMPARE            ;COMPARE STRING                              ;AN000;

       POP   ES
       POP   DS
;      $IF   NZ
       JZ $$IF62
           PUSH  AX                ;SAVE AX SINCE ERROR_MESSAGE WILL DESTROY IT
           MOV   OPERATION,COMPARE_FUNC
           CALL  ERROR_MESSAGE

           INC   COMP_ERROR
           POP   AX
;      $ENDIF
$$IF62:
;  $ENDIF
$$IF61:
   MOV   AX,TRACK_SIZE             ;ADVANCE COMPARE POINTER
   ADD   COMPARE_PTR,AX
   RET
COMP_TRACK ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <DO_COMPARE - PERFORM THE COMPARISON> ;                               ;AN000;
DO_COMPARE PROC NEAR               ;                                            ;AN000;
   PUBLIC DO_COMPARE               ;ADD ENTRY TO LINK MAP                       ;AN000;
;INPUT: DS:[SI] POINTS TO ONE BUFFER, ES:[DI] POINTS TO THE OTHER
;       CX HAS THE BYTE COUNT
;OUTPUT:CONDITION CODE IN CONDITION FLAGS REFLECT RESULT OF COMPARISON
;  =  =  =  =  =  =  =  =  =  =  =  =
   SHR   CX,1                      ;DIVIDE BY TWO, CHANGE TO WORD COUNT         ;AN000;

   PUBLIC PATCH_386                ;SO INIT CAN DO FIXUP                        ;AN001;
PATCH_386 LABEL BYTE
   SHR   CX,1                      ;CONVERT WORD COUNT TO DWORD COUNT           ;AN001;
   DB    66H                       ;PREFIX FOR A DWORD COMPARE                  ;AN001;
; END OF PATCH AREA.  IF THIS IS NOT A 386, THE ABOVE 3 BYTES ARE CHANGED
; TO NOP BY DISKINIT.SAL DURING INITIALIZATION.

   REPE  CMPSW                     ;PERFORM THE COMPARISON                      ;AN000;

   RET                             ;RETURN TO CALLER                            ;AN000;
DO_COMPARE ENDP                    ;                                            ;AN000;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <SWAP_DRIVE - SETUP FOR DISKETTE SWAPPING> ;                          ;AN000;
;*****************************************************************************
   PUBLIC SWAP_DRIVE               ;MAKE ENTRY IN LINK MAP                      ;AN000;
SWAP_DRIVE PROC NEAR               ;SWAP SOURCE, TARGET DRIVE
;*****************************************************************************
   MOV   AL,SOURCE_DRIVE
   XCHG  AL,TARGET_DRIVE
   MOV   SOURCE_DRIVE,AL
   MOV   AX,TRACK_TO_COMP
   XCHG  AX,TRACK_TO_READ
   MOV   TRACK_TO_COMP,AX
   RET

SWAP_DRIVE ENDP
   HEADER <READ_TRACK - READ A TRACK TO MEMORY> ;                               ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC READ_TRACK               ;MAKE ENTRY IN LINK MAP                      ;AN000;
READ_TRACK PROC NEAR               ;READ A TRACK AND STORE IT INTO MEMORY
;                                                                            *
;*****************************************************************************

   MOV   SIDE, 0
;  $DO
$$DO65:
       CALL  READ_OP


	XOR	DX, DX		; The old code (in the ELSE) was
	MOV	AX, TRACK_SIZE	; assuming there is either 1 head or 2.

	MOV	CL, NO_OF_SIDES
	XOR	CH, CH
	INC	CX	       	; 0 based

	DIV	CX

       ADD   BUFFER_PTR, AX
       INC   SIDE                  ;NEXT SIDE
       MOV   AL, SIDE
       CMP   AL, NO_OF_SIDES       ;FINISHED WITH THE LAST SIDE?
;  $ENDDO G
   JNG $$DO65
   RET

READ_TRACK ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <READ_OP - IOCTL TO READ A TRACK> ;                                   ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC READ_OP                  ;MAKE ENTRY IN LINK MAP                      ;AN000;
READ_OP PROC NEAR                  ;IOCTL READ A TRACK OPERATION
;                                                                            *
;*****************************************************************************
;  $SEARCH
$$DO70:
RO_AGAIN:
       XOR   AX, AX
       MOV   AL, SIDE
       MOV   Head, AX              ;HEAD TO READ
       MOV   AX, TRACK_TO_READ
       MOV   Cylinder, AX          ;TRACK TO READ
       MOV   FirstSectors, 0       ;???? SHOULD BE 1 BUT CURRENTLY 0 ???
       MOV   AX, BUFFER_PTR
       MOV   Taddress_seg, AX      ;BUFFER ADDRESS
       MOV   Taddress_off, 0
       XOR   BX, BX
       MOV   BL, SOURCE_DRIVE
       MOV   CL, READ_FUNC         ;=61h
       MOV   DX, OFFSET IOCTL_R_W
       CALL  GENERIC_IOCTL

       CMP   IO_ERROR, NO_ERROR    ;OK?
;  $EXITIF E,NUL
   JE $$SR70

       CMP   IO_ERROR, SOFT_ERROR  ;TRY AGAIN?
;  $ENDLOOP NE
   JE $$DO70

       MOV   OPERATION, READ_FUNC
       PUSH  AX
       CALL  ERROR_MESSAGE

       POP   AX
       INC   COMP_ERROR            ;INCREASE COPY_ERROR COUNT
;  $ENDSRCH
$$SR70:
   RET
READ_OP ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <SET_FOR_THE_OLD - USE PRE 2.0 BPB> ;                                 ;AN000;
;*****************************************************************************
   PUBLIC SET_FOR_THE_OLD          ;MAKE ENTRY IN LINK MAP                      ;AN000;
SET_FOR_THE_OLD PROC NEAR
;set MS_deviceBPB or MT_deviceBPB for before-2.0 formatted media.
;*****************************************************************************
   PUSH  AX

   CMP   SECT_TRACK_LAYOUT,9       ;IF SECTORS/TRACK <= 9, THEN CHECK
                                   ;NO_OF_SIDES. IF SINGLE SIDE COPY
                                   ; THEN USE BPB48_SINGLE
                                   ;ELSE USE BPB48_DOUBLE.
;  $IF   A                         ;SECTORS/TRACK > 9 THEN USE BPB96 TABLE
   JNA $$IF74
       MOV   SI, OFFSET BPB96
;  $ELSE
   JMP SHORT $$EN74
$$IF74:
       CMP   NO_OF_SIDES, 0        ;SINGLE SIDE COPY?
;      $IF   NE
       JE $$IF76
           MOV   SI, OFFSET BPB48_DOUBLE ;ELSE USE BPB48 DOUBLE
;      $ELSE
       JMP SHORT $$EN76
$$IF76:
           MOV   SI, OFFSET BPB48_SINGLE
;      $ENDIF
$$EN76:
;  $ENDIF
$$EN74:
   MOV   AX, SECT_TRACK_LAYOUT
   CMP   READ_S_BPB_FAILURE, 1     ;FAILURE ON THE SOURCE?
;  $IF   E
   JNE $$IF80
       MOV   MS_deviceBPB.CSECT_TRACK,AX ;SET # OF SECTORS IN IOCTL_DRV_PARM
       MOV   DI, OFFSET MS_deviceBPB
       MOV   CX, BPB96_LENG
       REP   MOVSB                 ;OLD DEFAULT BPB INFO => MS_deviceBPB
;  $ELSE
   JMP SHORT $$EN80
$$IF80:
       CMP   READ_T_BPB_FAILURE, 1 ;FAILURE ON THE TARGET?
;      $IF   E
       JNE $$IF82
           MOV   MT_deviceBPB.CSECT_TRACK,AX
           MOV   DI, OFFSET MT_deviceBPB
           MOV   CX, BPB96_LENG
           REP   MOVSB             ;OLD DEFAULT BPB INTO => MT_deviceBPB
;      $ENDIF
$$IF82:
;  $ENDIF
$$EN80:
   POP   AX
   RET
SET_FOR_THE_OLD ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <SET_TRACKLAYOUT - DETERMINE SECTORS PER TRACK> ;                     ;AN000;
;*****************************************************************************
   PUBLIC SET_TRACKLAYOUT          ;MAKE ENTRY IN LINK MAP                      ;AN000;
SET_TRACKLAYOUT PROC NEAR
;INPUT: BX - POINTER TO DESTINATION
;       SECT_TRACK_LAYOUT
;*****************************************************************************
   MOV   CX, SECT_TRACK_LAYOUT     ;MEDIA SECTORS/TRACK
   MOV   WORD PTR [BX], CX         ;SET CSECT_F TO THE NUMBER OF SECTORS
                                   ; IN A TRACK
   ADD   BX, 2                     ;NOW BX POINTS TO THE FIRST SECTORNUMBER
   MOV   CX, 1
   MOV   AX, bSECTOR_SIZE

;  $DO
$$DO85:
       CMP   CX, SECT_TRACK_LAYOUT
;  $LEAVE A
   JA $$EN85

       MOV   WORD PTR [BX], CX
       INC   BX
       INC   BX
       MOV   WORD PTR [BX], AX
       INC   BX
       INC   BX

       INC   CX
;  $ENDDO
   JMP SHORT $$DO85
$$EN85:

   RET
SET_TRACKLAYOUT ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <GENERIC_IOCTL - PERFORM SPECIFIED IOCTL FUNCTION> ;                  ;AN000;
PUBLIC GENERIC_IOCTL
;******************************************************************************
GENERIC_IOCTL PROC NEAR
;INPUT: CL - MINOR CODE; 60 - GET DEVICE PARM, 40 - SET DEVICE PARM
;                        61 - READ TRACK, 41 - WRITE TRACK,
;                        42 - FORMAT AND VERIFY TRACK
;                        62 - VERIFY TRACK
;       BL - LOGICAL DRIVE LETTER
;       DS:DX - POINTER TO PARAMETERS
;******************************************************************************

   MOV   IO_ERROR, NO_ERROR        ;reset io_error
   MOV   AH, IOCTL_FUNC            ;IOCTL FUNC = 44H
   MOV   AL, GENERIC_IOCTL_CODE    ;GENERIC IOCTL REQUEST = 0DH
   MOV   CH, MAJOR_CODE            ;MAJOR CODE=08H, REMOVABLE
   INT   21H
;  $IF   C
   JNC $$IF88
       CALL  EXTENDED_ERROR_HANDLER ;ERROR, SEE WHAT IT IS!

;  $ENDIF
$$IF88:
   RET
GENERIC_IOCTL ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <EXTENDED_ERROR - DETERMINE AND SERVICE EXTENDED ERRORS> ;            ;AN000;
;******************************************************************************
   PUBLIC EXTENDED_ERROR_HANDLER   ;MAKE ENTRY IN LINK MAP                      ;AN000;
EXTENDED_ERROR_HANDLER PROC NEAR
;INPUT: BL - LOGICAL DRIVE LETTER
;******************************************************************************
   PUSHF
   PUSH  AX
   PUSH  BX
   PUSH  CX
   PUSH  DX
   PUSH  SI
   PUSH  DI
   PUSH  ES
   PUSH  DS
   PUSH  BX

   MOV   AH, 59H
   MOV   BX, 0
   INT   21H

;        CMP     BL, 5                   ;ACTION=IMMEDIATE EXIT?
;        JE      EEH_JUST_EXIT

   POP   BX                        ;RESTORE BL FOR DRIVE LETTER
   POP   DS
   POP   ES

   CMP   AX, 21                    ;DRIVE NOT READY?
   JE    WARN_USER_1

   CMP   AX, 19                    ;ATTEMP TO WRITE ON WRITE_PROTECTED?
   JE    WARN_USER_2

;C00   JMP   EEH_HARD_ERROR            ;OTHERWISE, HARD_ERROR
   JMP   SHORT EEH_HARD_ERROR      ;OTHERWISE, HARD_ERROR               ;C00

WARN_USER_1:
   MOV   DRIVE_LETTER, 'A'
   DEC   BL                        ;CHANGE LOGICAL TO PHYSICAL
   ADD   DRIVE_LETTER, BL
                                   ;"Drive not ready - X:"
   PRINT MSGNUM_GET_READY          ;                                            ;AC000;

   PRINT MSGNUM_CLOSE_DOOR         ;"Make sure a diskette is inserted into      ;AN004;
                                   ; the drive and the door is closed"
;C00   JMP   WAIT_FOR_USER
   JMP   SHORT WAIT_FOR_USER                                            ;C00

WARN_USER_2:
                                   ;"Attempt to write to write-protected diskette"
   PRINT MSGNUM_WRITE_PROTECT      ;                                            ;AC000;

WAIT_FOR_USER:
   CALL  PRESS_ANY_KEY             ;"Press any key to continue . . ."           ;AC009;

EEH_SOFT_ERROR:
   MOV   IO_ERROR, SOFT_ERROR      ;INDICATE THE CALLER TO TRY AGAIN
   JMP   SHORT EEH_EXIT

EEH_HARD_ERROR:
   MOV   IO_ERROR, HARD_ERROR

EEH_EXIT:
   POP   DI
   POP   SI
   POP   DX
   POP   CX
   POP   BX
   POP   AX
   POPF
   RET

;EEH_JUST_EXIT:
;   JMP   EXIT_PROGRAM              ;UNCONDITIONAL EXIT

EXTENDED_ERROR_HANDLER ENDP
.XLIST
;   HEADER <CALL_PRINTF - COMMON DRIVER TO PRINTF, DISPLAY MESSAGE>
;CALL_PRINTF PROC NEAR
;   PUBLIC CALL_PRINTF
;;INPUT - DX HAS OFFSET INTO DS OF MESSAGE PARM LIST
;   PUSH  DX
;   PUSH  CS
;   CALL  PRINTF
;
;   RET
;CALL_PRINTF ENDP
.LIST
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <ERROR_MESSAGE - DISPLAY THE ERROR MESSAGE> ;                         ;AN000;
ERROR_MESSAGE PROC NEAR            ;DISPLAY ERROR MESSAGE
   PUBLIC ERROR_MESSAGE
;
;  FUNCTION: THIS SUBROUTINE DISPLAYS WHAT OPERATION FAILED (READ OR WRITE)
;            AND WHERE IT FAILED (TRACK NO. AND SIDE).
;
;  INPUT: OPERATION = IOCTL DISKETTE READ(=61H) OR COMPARE_FUNC(59H)
;  =  =  =  =  =  =  =  =  =  =  =  =

   CMP   OPERATION,READ_FUNC       ;ERROR DURING READ ?
;  $IF   E
   JNE $$IF90
.XLIST
;            MOV     BX,OFFSET READ_ERROR ;TELL USER ERROR DURING READ OP
;            MOV     MSG_HARD_ERROR_PTR+2,BX
.LIST
       MOV   DL,SOURCE_DRIVE       ;WHICH DRIVE IS BAD
       dec   dl                    ;change logical letter to phisical
       ADD   DL,"A"                ;CORRESPONDANT ALPHABET
       MOV   DRIVE_LETTER,DL
       MOV   SUBLIST_17B.SUB_VALUE,OFFSET DRIVE_LETTER ;

       MOV   BX,TRACK_TO_READ      ;SAVE BAD TRACK NUMBER FOR READ
                                   ;CR,LF,"Unrecoverable read error on drive %2",CR,LF
                                   ;"side %3, track %4",CR,LF
                                   ;%2 IS "DRIVE_LETTER", AND
                                   ;"MSG_SIDES" AND "MSG_TRACKS" ARE %3 AND %4.
       MOV   DI,OFFSET MSGNUM_HARD_ERROR_READ ;                                 ;AN000;
       MOV EXITFL,EX_HARD_ERROR    ;Show there was an HARD error           ;C12
;  $ELSE
   JMP SHORT $$EN90
$$IF90:
.XLIST
;            MOV     BX,OFFSET COMPARE_ERROR ;TELL USER ERROR DURING COMPARE OP
;            MOV     MSG_HARD_ERROR_PTR+2,BX
.LIST
       MOV   BX,TRACK_TO_READ      ;SAVE BAD TRACK NUMBER FOR WRITE
                                   ;CR,LF,"Compare error on",CR,LF
                                   ;"side %3, track %4",CR,LF
                                   ;"MSG_SIDES" AND "MSG_TRACKS" ARE %3 AND %4.
       MOV   DI,OFFSET MSGNUM_HARD_ERROR_COMP ;                                 ;AN000;
       CMP EXITFL,EXOK             ;Q: Is there already an errorlevel set  ;C12
       JNZ $$EN90                  ; Y: then don't give it a new one       ;C12
       MOV EXITFL,EX_DIFFERENT     ; N: Show there are differences         ;C12
;  $ENDIF
$$EN90:

   MOV   AL,SIDE
   MOV   BYTE PTR MSG_SIDES,AL
   MOV   MSG_TRACKS,BX
   CALL  SENDMSG                   ;PRINT MSG SELECTED ABOVE                    ;AN000;

   RET
ERROR_MESSAGE ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <COMBAT_ERROR - DISPLAY INCOMPATIBLE MSG> ;                           ;AN000;
COMPAT_ERROR PROC NEAR             ;DISPLAY COMPAT MSG
   PUBLIC COMPAT_ERROR
;  =  =  =  =  =  =  =  =  =  =  =  =

   MOV   COMP_STATUS,FATAL         ;INCOMPATIBLE, ABORT
                                   ;"Drive types or diskette types"
                                   ;"not compatible"
   PRINT MSGNUM_NOT_COMPATIBLE
   MOV EXITFL,EX_INIT_ERROR        ;Show there was an INIT error           ;C12

   RET
COMPAT_ERROR ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <PRESS_ANY_KEY - PUTS A BLANK LINE BEFORE PROMPT> ;                     ;AN009;
PRESS_ANY_KEY PROC NEAR            ;
;THE CANNED MESSAGE "PRESS ANY KEY..." DOES NOT START WITH CR,LF.
;THIS PUTS OUT THE CR LF TO CAUSE SEPARATION OF THIS PROMP FROM
;PRECEEDING MESSAGES.
;  =  =  =  =  =  =  =  =  =  =  =  =
   PRINT MSGNUM_NEWLINE            ;SKIP A SPACE                               ;AN009;

   PRINT MSGNUM_STRIKE             ;"Press any key when ready..."              ;AN009;

   RET                             ;RETURN TO CALLER                           ;AN009;
PRESS_ANY_KEY ENDP                 ;                                           ;AN009;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <SENDMSG - PASS IN REGS DATA FROM MSG DESCRIPTOR TO DISP MSG> ;       ;AN000;
SENDMSG PROC NEAR                  ;                                            ;AN000;
   PUBLIC SENDMSG                  ;                                            ;AN000;
; INPUT - DI=POINTER TO MSG_DESC STRUC FOR THIS MESSAGE
; OUTPUT - IF CARRY SET, EXTENDED ERROR MSG ATTEMPTED DISPLAYED
;          IF CARRY CLEAR, ALL OK
;          IN EITHER CASE, DI AND AX ALTERED, OTHERS OK

;  =  =  =  =  =  =  =  =  =  =  =  =

   PUSH  BX                        ; SAVE CALLER'S REGS                         ;AN000;
   PUSH  CX                        ;                                            ;AN000;
   PUSH  DX                        ;                                            ;AN000;
   PUSH  SI                        ;                                            ;AN000;

;                PASS PARMS TO MESSAGE HANDLER IN
;                THE APPROPRIATE REGISTERS IT NEEDS.
   MOV   AX,[DI].MSG_NUM           ;MESSAGE NUMBER                              ;AN000;
   MOV   BX,[DI].MSG_HANDLE        ;HANDLE TO DISPLAY TO                        ;AN000;
   MOV   SI,[DI].MSG_SUBLIST       ;OFFSET IN ES: OF SUBLIST, OR 0 IF NONE      ;AN000;
   MOV   CX,[DI].MSG_COUNT         ;NUMBER OF %PARMS, 0 IF NONE                 ;AN000;
   MOV   DX,[DI].MSG_CLASS         ;CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW   ;AN000;
   CALL  SYSDISPMSG                ;DISPLAY THE MESSAGE                         ;AN000;

;  $IF   C                         ;IF THERE IS A PROBLEM                       ;AN000;
   JNC $$IF93
                                   ;AX=EXTENDED ERROR NUMBER                    ;AN000;
       LEA   DI,MSGNUM_EXTERR      ;GET REST OF ERROR DESCRIPTOR                ;AN000;
       MOV   BX,[DI].MSG_HANDLE    ;HANDLE TO DISPLAY TO                        ;AN000;
       MOV   SI,[DI].MSG_SUBLIST   ;OFFSET IN ES: OF SUBLIST, OR 0 IF NONE      ;AN000;
       MOV   CX,[DI].MSG_COUNT     ;NUMBER OF %PARMS, 0 IF NONE                 ;AN000;
       MOV   DX,[DI].MSG_CLASS     ;CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW   ;AN000;
       CALL  SYSDISPMSG            ;TRY TO SAY WHAT HAPPENED                    ;AN000;

       STC                         ;REPORT PROBLEM                              ;AN000;
;  $ENDIF                          ;PROBLEM WITH DISPLAY?                       ;AN000;
$$IF93:

   POP   SI                        ;RESTORE CALLER'S REGISTERS                  ;AN000;
   POP   DX                        ;                                            ;AN000;
   POP   CX                        ;                                            ;AN000;
   POP   BX                        ;                                            ;AN000;

   RET                             ;RETURN TO CALLER                            ;AN000;
SENDMSG ENDP                       ;                                            ;AN000;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <YESNO - DETERMINE IF A RESPONSE IS YES OR NO> ;                      ;AN000;
YESNO PROC NEAR                    ;                                            ;AN000;
   PUBLIC YESNO                    ;MAKE ENTRY IN LINK MAP                      ;AN000;
;INPUT: DL=CHAR WITH Y OR N EQUIVALENT CHAR TO BE TESTED
;OUTPUT: AX=0=NO; AX=1=YES ; AX=2=INVALID RESPONSE, NEITHER Y NOR N
;       IF CARRY SET, PROBLEM WITH THE FUNCTION, CALLER SHOULD ASSUME "NO"
;  =  =  =  =  =  =  =  =  =  =  =  =
                                   ;AL=SUBFUNCTION, AS:
                                   ;  20H=CAPITALIZE SINGLE CHAR
                                   ;  21H=CAPITALIZE STRING
                                   ;  22H=CAPITALIZE ASCIIZ STRING
                                   ;  23H=YES/NO CHECK
                                   ;  80H BIT 0=USE NORMAL UPPER CASE TABLE
                                   ;  80H BIT 1=USE FILE UPPER CASE TABLE
                                   ;DL=CHAR TO CAP (FUNCTION 23H)               ;AN000;
   MOV   AX,(GET_EXT_CNTRY_INFO SHL 8) + YESNO_CHECK ;(6523H) GET EXTENDED      ;AN000;
                                   ; COUNTRY INFORMATION, (Y/N)
   INT   21H                       ;SEE IF Y OR N                               ;AN000;

   RET                             ;RETURN TO CALLER                            ;AN000;
YESNO ENDP                         ;                                            ;AN000;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <VOLSER - VERIFY FIRST SECTOR, IGNORE VOL SER #> ;                     ;AN000;
VOLSER PROC NEAR                   ;VERIFY FIRST SECTOR, IGNORING VOL SER #     ;AN000;
   PUBLIC VOLSER                   ;                                            ;AN000;
;IF THE FIRST DISKETTE SUPPORTED A VOL SERIAL NUMBER, THEN
;COPY IT TO THE SECOND DISKETTE BUFFER AREA (NOT THE DISKETTE).
;INPUT: FIRST DRIVE NUMBER
;       DS:=SEGID OF BUFFER OF FIRST DISKETTE, FIRST SECTOR, SIDE 0
;       ES:=SEGID OF BUFFER OF SECOND DISKETTE, FIRST SECTOR, SIDE 0
;       SI AND DI = 0, INDEX OF WHERE IN BUFFERS TO START LOOKING
;       CX="BYTES_IN_TRACK"; NUMBER OF BYTES TO BE EVENTUALLY COMPARED
;OUTPUT: BUFFER OF 2ND DISKETTE ALTERED TO MATCH THE VOL SERIAL NUMBER OF 1ST.
; = = = = = = = = = = = = = = = = = =

   ASSUME DS:NOTHING               ;BUFFER OF FIRST DISKETTE                    ;AN000;
   ASSUME ES:NOTHING               ;BUFFER OF SECOND DISKETTE                   ;AN000;

   PUSH  CX                        ;SAVE CALLER'S REGS                          ;AN000;
   PUSH  SI                        ;                                            ;AN000;
   PUSH  DI                        ;                                            ;AN000;
;(deleted ;AN011;)   PUSH  DS                        ;SAVE BUFFER OF FIRST DISKETTE               ;AN000;

;(deleted ;AN011;)   PUSH  CS                        ;RESTORE ADDRESSABILITY TO COMMON SEG        ;AN000;
;(deleted ;AN011;)   POP   DS                        ; TO ACCESS GET MEDIA ID BUFFER AREA         ;AN000;
;(deleted ;AN011;)   ASSUME DS:CSEG                  ;AN000;

;(deleted ;AN011;);              ISSUE GET MEDIA ID FROM SOURCE
;(deleted ;AN011;)   MOV   BH,0                      ;BH=0, RES                                   ;AN000;
;(deleted ;AN011;)   MOV   BL,SOURCE_DRIVE           ;BL=DRIVE NUM (A:=1, B:=2, ETC.)             ;AN000;
;(deleted ;AN011;)   MOV   DX,OFFSET MEDIA_ID_BUFFER ;DS:DX=BUFFER
;(deleted ;AN011;)   DOSCALL GSET_MEDIA_ID,GET_ID    ;(6900H) GET MEDIA ID                        ;AC008;
;(deleted ;AN011;)                                   ;CARRY SET ON ERROR (OLD STYLE BOOT RECORD)
;(deleted ;AN011;)   POP   DS                        ;RESTORE THIS BACK TO BUFFER OF FIRST DISKETTE;AN000;
;(deleted ;AN011;)   ASSUME DS:NOTHING               ; LIKE IT WAS AT ENTRY TO THIS PROC          ;AN000;

;(deleted ;AN011;)   $IF   NC                        ;IF THERE IS NO PROBLEM                      ;AN000;
;(deleted ;AN011;)                                   ; THEN THIS DISKETTE HAS A VOL SER #

   PUSH  BX                        ;AN011;
   LEA   BX,DS:[DI].EXT_BOOT_BPB   ;AN011;POINT TO BPB PORTION OF BOOT RECORD
   MOV   AL,DS:[BX].EBPB_MEDIADESCRIPTOR ;AN011;GET TYPE OF MEDIA
   AND   AL,0F0H                   ;AN011;SAVE LEFT NIBBLE ONLY
   CMP   AL,0F0H                   ;AN011;IF DISKETTE HAS PROPER DESCRIPTOR
;  $IF   E                         ;AN011;
   JNE $$IF95
       MOV   AL,DS:[DI].EXT_BOOT_SIG ;AN011;GET "SIGNATURE" OF BOOT RECORD
       CMP   AL,28H                ;AN011;IS THIS BOOT STYLE OF OS/2 1.0 OR 1.1?
;      $IF   E,OR                  ;AN011;YES, IS A BOOT WITH A SERIAL IN IT
       JE $$LL96
       CMP   AL,29H                ;AN011;IS THIS A BOOT STYLE OF OS/S 1.2?
;      $IF   E                     ;AN011;YES, IS A BOOT WITH A SERIAL IN IT
       JNE $$IF96
$$LL96:

;THE PURPOSE HERE IS TO CAUSE DISKCOMP TO IGNORE ANY DIFFERENCES IN THE
;VOL SERIAL NUMBER FIELD.  THIS IS DONE BY TAKING ONE VOL SERIAL NUMBER
;FROM ONE BUFFER, ALREADY LOADED WITH THE FIRST TRACK OF ONE DISKETTE,
;AND MOVING THAT SERIAL NUMBER TO THE CORRESPONDING POSITION IN THE OTHER
;BUFFER, ALREADY LOADED WITH THE SIMILAR TRACK FROM THE OTHER DISKETTE.
;WHEN THIS RETURNS TO THE MAIN ROUTINE, THE ENTIRE TRACK (INCUDING THIS
;VOL SERIAL NUMBER FIELD) WILL BE COMPARED.  IF THERE ARE ANY DIFFERENCES,
;THEY WILL BE OTHER THAN IN THE VOL SERIAL NUMBERS.

           MOV   SI,OFFSET VOL_SERIAL ;GET WHERE VOL SERIAL NUMBER IS
           MOV   DI,OFFSET VOL_SERIAL ;GET WHERE VOL SERIAL NUMBER IS
           MOV   CX,TYPE VOL_SERIAL ;GET NUMBER BYTES IN VOL SER FIELD
           REP   MOVSB             ;FORCE THE SERIAL NUMBERS TO BE ALIKE

;      $ENDIF                      ;                                            ;AN000;
$$IF96:
;  $ENDIF                          ;AN011;
$$IF95:
   POP   BX                        ;AN011;
   POP   DI
   POP   SI
   POP   CX                        ;RESTORE COUNT
   RET                             ;RETURN TO CALLER                            ;AN000;
VOLSER ENDP                        ;AN000;
; = = = = = = = = = = = = = = = = = = =
DISKCOMP_END LABEL BYTE
   PATHLABL DISKCOMP               ;AN013;
CSEG ENDS
   END   DISKCOMP

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcopy\dcpymacr.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	IF1				;AN000;
	    %OUT    COMPONENT=DISKCOPY, INCLUDING DCPYMACR.INC...;AN000;
	ENDIF				;AN000;
;***************************************************************************;
;			     MACRO DEFINITION				    ;
;***************************************************************************;

HEADER	MACRO	TEXT			;AN000;
.XLIST					;AN000;
	SUBTTL	&TEXT			;AN000;
.LIST					;AN000;
	PAGE				;AN000;
	ENDM				;AN000;
;  =  =  =  =  =  =  =	=  =
;				   $SALUT (0,36,40,44)
DOSCALL 			   MACRO FUNC,SUBFUNC ;;AN000;
				   IFNB <FUNC> ;;AN000;IS THERE ANY PARMS AT ALL?
				   IFNB <SUBFUNC> ;;AN000;
				   MOV AX,(FUNC SHL 8)+SUBFUNC ;;AN000;FUNC TO AH,SUBFUNC TO AL
				   ELSE    ;;AN000;SINCE THERE IS NO SUBFUNC
				   MOV AH,FUNC ;;AN000;
				   ENDIF   ;;AN000;
				   ENDIF   ;;AN000;
				   INT 21H ;;AN000;
				   ENDM    ;;AN000;
;  =  =  =  =  =  =  =	=  =
PRINT				   MACRO MESSAGE;;AN000;
				   MOV DI,OFFSET MESSAGE  ;;AC000;
				   CALL SENDMSG 	  ;;AC000;
				   ENDM 		  ;;AN000;
;  =  =  =  =  =  =  =	=  =
;	       $SALUT (0,16,22,36)
MY_TRACKLAYOUT MACRO		   ;AN000;
	       LOCAL CSECT_F							;AN000;
CSECT_F        DW    0		   ;;AN000;# OF SECTORS IN A TRACK. Currently 18 is max.
				   ;;  THE REST IS FOR FUTURE MEDIA
	       DW    1		   ;;AN000;1 ST SECTOR
	       DW    512	   ;;AN000;# OF BYTES
	       DW    2		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    3		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    4		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    5		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    6		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    7		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    8		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    9		   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    10 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    11 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    12 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    13 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    14 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    15 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    16 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    17 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    18 	   ;;AN000;
	       DW    512	   ;;AN000;CURRENTLY 18 SECTORS/TRACK IS MAXIMUM
	       DW    19 	   ;;AN000;BELOW IS FOR THE FUTURE MEDIA.
	       DW    512	   ;;AN000;
	       DW    20 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    21 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    22 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    23 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    24 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    25 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    26 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    27 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    28 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    29 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    30 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    31 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    32 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    33 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    34 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    35 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    36 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    37 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    38 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    39 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    40 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    41 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    42 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    43 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    44 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    45 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    46 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    47 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    48 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    49 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    50 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    51 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    52 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    53 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    54 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    55 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    56 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    57 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    58 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    59 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    60 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    61 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    62 	   ;;AN000;
	       DW    512	   ;;AN000;
	       DW    63 	   ;;AN000;
	       DW    512	   ;;AN000;
	       ENDM								;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcopy\dcopysm.asm ===
PAGE	90,132			;AN000;A2
	TITLE	DCOPYSM.SAL - DISKCOPY SYSTEM MESSAGES
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: DCOPYSM.SAL

; DESCRIPTIVE NAME: Include the DOS system MESSAGE HANDLER in the SEGMENT
;		    configuration expected by the modules of DISKCOPY.

;FUNCTION: The common code of the DOS SYSTEM MESSAGE HANDLER is made a
;	   part of the DISKCOPY module by using INCLUDE to bring in the
;	   common portion, in SYSMSG.INC.  This included code contains
;	   the routines to initialize for message services, to find
;	   where a particular message is, and to display a message.

; ENTRY POINT: SYSDISPMSG:near
;	       SYSGETMSG:near
;	       SYSLOADMSG:near

; INPUT:
;    AX = MESSAGE NUMBER
;    BX = HANDLE TO DISPLAY TO (-1 means use DOS functions 1-12)
;    SI = OFFSET IN ES: OF SUBLIST, OR 0 IF NONE
;    CX = NUMBER OF %PARMS, 0 IF NONE
;    DX = CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW
;   CALL SYSDISPMSG		;DISPLAY THE MESSAGE

;    If carry set, extended error already called:
;    AX = EXTENDED MESSAGE NUMBER
;    BH = ERROR CLASS
;    BL = SUGGESTED ACTION
;    CH = LOCUS
; _ _ _ _ _ _ _ _ _ _ _ _

;    AX = MESSAGE NUMBER
;    DH = MESSAGE CLASS (1=DOS EXTENDED ERROR, 2=PARSE ERROR, -1=UTILITY MSG)
;   CALL SYSGETMSG		 ;FIND WHERE A MSG IS

;    If carry set, error
;     CX = 0, MESSAGE NOT FOUND
;    If carry not set, ok, and resulting regs are:
;     CX = MESSAGE SIZE
;     DS:SI = MESSAGE TEXT
; _ _ _ _ _ _ _ _ _ _ _ _

;   CALL SYSLOADMSG		 ;SET ADDRESSABILITY TO MSGS, CHECK DOS VERSION
;    If carry not set:
;    CX = SIZE OF MSGS LOADED

;    If carry is set, regs preset up for SYSDISPMSG, as:
;    AX = ERROR CODE IF CARRY SET
;	  AX = 1, INCORRECT DOS VERSION
;	  DH =-1, (Utility msg)
;	OR,
;	  AX = 1, Error loading messages
;	  DH = 0, (Message manager error)
;    BX = STDERR
;    CX = NO_REPLACE
;    DL = NO_INPUT

; EXIT-NORMAL: CARRY is not set

; EXIT-ERROR:  CARRY is set
;	       Call Get Extended Error for reason code, for SYSDISPMSG and
;	       SYSGETMSG.

; INTERNAL REFERENCES:
;    ROUTINES: (Generated by the MSG_SERVICES macro)
;	SYSLOADMSG
;	SYSDISPMSG
;	SYSGETMSG

;    DATA AREAS:
;	INCLUDED "DCOPYMS.INC" - message defining control blocks
;	INCLUDE SYSMSG.INC   ;Permit System Message handler definition

; EXTERNAL REFERENCES:
;    ROUTINES: none

;    DATA AREAS: control blocks pointed to by input registers.

; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:

;		SALUT DCOPYSM,NUL

;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.

;	 For LINK instructions, refer to the PROLOG of the main module,
;	 DISKCOPY.SAL.

; COPYRIGHT: "Version 4.00 (C)Copyright 1988 Microsoft"
;	     "Licensed Material - Property of Microsoft  "
;
;****************** END OF SPECIFICATIONS *****************************
	IF1				;AN000;
	    %OUT    COMPONENT=DISKCOPY, MODULE=DCOPYSM.SAL... ;AN000;
	ENDIF				;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	INCLUDE PATHMAC.INC		;AN015;PATHGEN MACRO
; =  =	=  =  =  =  =  =  =  =	=  =
HEADER	MACRO	TEXT			;;AN000;
.XLIST					;;AN000;
	SUBTTL	TEXT			;;AN000;
.LIST					;;AN000;
	PAGE				;;AN000;
	ENDM				;;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	INCLUDE SYSMSG.INC		;AN000;PERMIT SYSTEM MESSAGE HANDLER DEFINITION
	MSG_UTILNAME <DISKCOPY> 	;AN000;IDENTIFY THE COMPONENT
; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<DEFINITION OF MESSAGES> ;AN000;
;	   $SALUT (4,12,18,36)	   ;AN000;
CSEG	   SEGMENT PARA PUBLIC 'CODE' ;AN000;
	   ASSUME CS:CSEG	   ;AN000;ESTABLISHED BY CALLER
	   ASSUME SS:CSEG	   ;AN000;ESTABLISHED BY CALLER
	   ASSUME DS:CSEG	   ;AN000;ESTABLISHED BY CALLER
	   ASSUME ES:CSEG	   ;AN000;ESTABLISHED BY CALLER

;(deleted ;AN010;) PUBLIC COPYRIGHT ;
;(deleted ;AN010;) COPYRIGHT  DB    "MS DOS DISKCOPY Utility                   "
;(deleted ;AN010;) INCLUDE COPYRIGH.INC ;(this is now being done my MSG_SERVICES)
	   HEADER <MESSAGE HANDLER CONTROL BLOCKS> ;AN000;
	   INCLUDE MSGHAN.INC	   ;AN000;DEFINE THE MESSAGE HANDLER CONTROL BLOCKS
	   INCLUDE VERSION.INC     ;M003
	   INCLUDE DCOPYMS.INC	   ;AN000;DEFINE THE MESSAGES, AND CONTROL BLOCKS
	   HEADER <MESSAGE DATA AREAS> ;AN000;
	   MSG_SERVICES <MSGDATA>  ;AN000;WORKAREAS FOR SYSTEM MESSAGE HANDLER
; =  =	=  =  =  =  =  =  =  =	=  =
	   HEADER <SYSTEM MESSAGE HANDLER> ;AN000;
	   PUBLIC SYSLOADMSG	   ;AN000;
	   PUBLIC SYSDISPMSG	   ;AN000;

	   MSG_SERVICES <DISKCOPY.CL1,DISKCOPY.CL2,DISKCOPY.CLA> ;AN000;MSG TEXT

	   PATHLABL DCOPYSM	   ;AN015;
				   ;DEFAULT=CHECK DOS VERSION
				   ;DEFAULT=NEARmsg
				   ;DEFAULT=INPUTmsg
				   ;DEFAULT=NUMmsg
				   ;DEFAULT=NO TIMEmsg
				   ;DEFAULT=NO DATEmsg
;	   MSG_SERVICES <LOADmsg,DISPLAYmsg,CHARmsg,NUMmsg,INPUTmsg>
.xlist				   ;AN000;
.xcref				   ;AN000;
	   MSG_SERVICES <LOADmsg,DISPLAYmsg,CHARmsg,NUMmsg,INPUTmsg> ;AN000;
.cref				   ;AN000;
.list				   ;AN000;
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	   PATHLABL DCOPYSM	   ;AN015;
CSEG	   ENDS 		   ;AN000;
	   END			   ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcopy\dcopyp.asm ===
PAGE	90,132			;AN000;A2
	TITLE	DCOPYP.SAL - DISKCOPY SYSTEM COMMAND LINE PARSER
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: DCOPYP.SAL
;
; DESCRIPTIVE NAME: Include the DOS system PARSER in the SEGMENT
;		    configuration expected by the modules of DISKCOPY.
;
;FUNCTION: The common code of the DOS command line PARSER is optimized by
;	   the setting of certain switches that cause the conditional
;	   assembly of only the required portions of the common PARSER.
;	   The segment registers are ASSUMED according to the type .COM.
;	   The Common PARSER is then INCLUDEd.
;
; ENTRY POINT: SYSPARSE, near
;
; INPUT:
;	ES - has seg id of the SEGMENT
;	     that contains the input control blocks,
;	     defined below.
;
;	DI - offset into ES of the PARMS INPUT BLOCK
;
;	DS - has seg id of the SEGMENT
;	     that contains the DOS input COMMAND
;	     string, which is originally presented at 81h
;	     in the PSP.
;
;	SI - offset into DS of the text of the DOS input COMMAND string
;	     as originally presented at 81H in the PSP.
;
;	DX - zero
;
;	CX - ordinal value, intially zero, updated on each subsequent call
;	     to the value returned in CX on the previous call.
;
;	CS - points to the segment containing the
;	     INCLUDE PARSE.ASM statement
;
;	DS - also points to the segment containing the INCLUDE
;	     PARSE.ASM statement.
;
; EXIT-NORMAL:	Output registers:
;	 AX - return code:
;	    RC_No_Error     equ     0	 ; No error
;	    RC_EOL	    equ     -1	 ; End of command line
;
;	 DX - Offset into ES of the selected RESULT BLOCK.
;	 BL - terminated delimiter code
;	 CX - new operand ordinal
;	 SI - set past scanned operand
;
; EXIT-ERROR: Output registers:
;	 AX - return code:
;	    RC_Too_Many     equ     1	 ; Too many operands
;	    RC_Op_Missing   equ     2	 ; Required operand missing
;	    RC_Not_In_SW    equ     3	 ; Not in switch list provided
;	    RC_Not_In_Key   equ     4	 ; Not in keyword list provided
;	    RC_Out_Of_Range equ     6	 ; Out of range specified
;	    RC_Not_In_Val   equ     7	 ; Not in value list provided
;	    RC_Not_In_Str   equ     8	 ; Not in string list provided
;	    RC_Syntax	    equ     9	 ; Syntax error
;
; INTERNAL REFERENCES:
;    ROUTINES: SYSPARSE:near (INCLUDEd in PARSE.ASM)
;
;    DATA AREAS: none
;
; EXTERNAL REFERENCES:
;    ROUTINES: none
;
;    DATA AREAS: control blocks pointed to by input registers.
;
; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT DCOPYP,NUL,;
;
;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;	 DISKCOPY.SAL.
;
;PROGRAM AUTHOR: DOS 4.00 EMK
;
;****************** END OF SPECIFICATIONS *****************************
	IF1				;AN000;
	    %OUT    COMPONENT=DISKCOPY, MODULE=DCOPYP.SAL... ;AN000;
	ENDIF				;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<MACRO DEFINITION>	;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	INCLUDE PATHMAC.INC		;AN015;PATHGEN MACRO
; =  =	=  =  =  =  =  =  =  =	=  =
HEADER	MACRO	TEXT			;;AN000;
.XLIST					;AN000;
	SUBTTL	TEXT			;AN000;
.LIST					;AN000;
	PAGE				;;AN000;
	ENDM				;;AN000;

; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<SYSPARSE - SYSTEM COMMAND LINE PARSER> ;AN000;
CSEG	SEGMENT PARA PUBLIC 'CODE'	;AN000;
	ASSUME	CS:CSEG,DS:CSEG,ES:CSEG,SS:CSEG ;AN000;

;DISKCOPY INPUT PARMS EXPECTED:
;	[D: [d:]] [/1]

	PUBLIC	SYSPARSE		;AN000;SUBROUTINE ENTRY POINT

FARSW	EQU	0			;AN000;CALL THE PARSER BY NEAR CALL
DATESW	EQU	0			;AN000;SUPPRESS DATE CHECKING
TIMESW	EQU	0			;AN000;SUPPRESS TIME CHECKING
FILESW	EQU	0			;AN000;SUPPRESS CHECK FILE SPECIFICATION
CAPSW	EQU	1			;AN000;DO USE FILE TABLE CAPS
CMPXSW	EQU	0			;AN000;SUPPRESS CHECKING COMPLEX LIST
DRVSW	EQU	1			;AN000;DO SUPPORT DRIVE ONLY FORMAT
QUSSW	EQU	0			;AN000;SUPPRESS SUPPORT OF QUOTED STRING FORMAT
NUMSW	EQU	0			;AN000;SUPPRESS CHECKING NUMERIC VALUE
KEYSW	EQU	0			;AN000;SUPPRESS KEYWORD SUPPORT
SWSW	EQU	1			;AN000;DO SUPPORT SWITCHES
VAL1SW	EQU	0			;AN000;SUPPRESS SUPPORT OF VALUE DEFINITION 1
VAL2SW	EQU	0			;AN000;SUPPRESS SUPPORT OF VALUE DEFINITION 2
VAL3SW	EQU	0			;AN000;SUPPRESS SUPPORT OF VALUE DEFINITION 3
INCSW	EQU	0			;AN000;DO NOT INCLUDE PSDATA.INC
BASESW	EQU	1			;AN014;SPECIFY, PSDATA POINTED TO BY "DS"

	include version.inc	 ; psdata needs def of db_sp_hi, lo
	INCLUDE PSDATA.INC		;AN015;

	PATHLABL DCOPYP 		;AN015;
	INCLUDE PARSE.ASM		;AN000;
	PATHLABL DCOPYP 		;AN015;

CSEG	ENDS				;AN000;
	END				;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcopy\dcopyms.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;:util DISKCOPY             ;utility name
;:class 1                   ;DOS extended errors:
;:class 2                   ;parse errors:
;1  Too many parameters
;2  Required parameter missing
;3  Invalid switch
;4  Invalid keyword
;5  Parameter value not in allowed range
;6  Parameter value not allowed    [parse ret codes 6 and 7]
;7   (undefined)
;8  Parameter format not correct
;9   (undefined)
;10 Invalid parameter              [no corresponding parse ret code]
;11 Invalid parameter combination  [no corresponding parse ret code]
;;
;:class A                   ;system messages
;:use 1 COMMON1             ;MSG 1 is always "Incorrect DOS version"
;;
;:def 2 CR,LF
;
;:use 3 PARSE10             ;CR,LF,"Invalid parameter",CR,LF
;
;:def 4 "Do not specify filename(s)",CR,LF
;"Command Format: DISKCOPY d: d: [/1]",CR,LF
;;
;:def 5 CR,LF,"Invalid drive specification",CR,LF
;"Specified drive does not exist",CR,LF
;"or is non-removable",CR,LF
;
;:def 6 CR,LF,"Cannot DISKCOPY to or from",CR,LF
;"a network drive",CR,LF
;
;:def 7 CR,LF,"Formatting while copying",CR,LF
;
;:def 8 CR,LF,"Insert SOURCE diskette in drive %1:",CR,LF
;
;:def 9 CR,LF,"Insert TARGET diskette in drive %1:",CR,LF
;
;:def 10 "Make sure a diskette is inserted into",CR,LF
;"the drive and the door is closed",CR,LF
;
;:def 11 CR,LF,"Target diskette may be unusable",CR,LF
;
;:def 12 CR,LF,"Target diskette unusable",CR,LF
;
;:use 13 EXTEND21           ;CR,LF,Drive not ready",CR,LF
;
;:use 14 EXTEND19  ;CR,LF,"Attempt to write to write-protected diskette",CR,LF
;
;:use 15 COMMON28           ;CR,LF,"Press any key to continue . . .",CR,LF
;
;:def 16 CR,LF,"Copy another diskette (Y/N)? "
;
;:def 17 CR,LF,"Copying %1 tracks",CR,LF
;"%2 Sectors/Track, %3 Side(s)",CR,LF
;
;:def 18 CR,LF,"Drive types or diskette types",CR,LF
;"not compatible",CR,LF
;
;:def 19 CR,LF,"Unrecoverable read error on drive %1",CR,LF
;"Side %2, track %3",CR,LF
;
;:def 20 CR,LF,"Unrecoverable write error on drive %1",CR,LF
;"Side %2, track %3",CR,LF
;
;:def 21 CR,LF,"Copy process ended",CR,LF
;
;:def 22 CR,LF,"SOURCE diskette bad or incompatible"
;
;:def 23 CR,LF,"TARGET diskette bad or incompatible"
;
;:use 25 EXTEND8            ;CR,LF,"Insufficient memory",CR,LF
;
;:use 26 COMMON36           ;"Volume Serial Number is %1-%2",CR,LF
;
;:def 30 CR,LF,"TARGET media has lower capacity than SOURCE",CR,LF ;SA;added for
;"Continue anyway (Y/N)?"                                          ;media sensing
;
;:def 032 CR,LF,"CMCDD drives are not supported",CR,LF
;
;:end
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
        IF1                                                       ;AN000;
            %OUT    COMPONENT=DISKCOPY, MODULE=DCOPYMS.INC...     ;AN000;
        ENDIF                                                     ;AN000;
;           $SALUT (0,13,18,22) ;                                 ;AN000;
;THIS MODULE IS INCLUDED IN DCOPYSM.SAL.
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
            HEADER <MESSAGE DESCRIPTORS FOR SPECIFIC MESSAGES> ;AN000;

FOUR_SUBS   EQU  4   ;AN000;FOUR VARIABLES IN ONE MSG
PC_ID_4     EQU  4   ;AN000;IDENTIFIES FOURTH REPLACEMENT PARM
LETTER_A    EQU  "A" ;AN000;DEFAULT DRIVE ID
PAD_0       EQU  "0" ;AN001;PAD CHAR FOR NUMERIC FIXED LEN FIELD
FILL_OFF    EQU  0   ;AN000;TO BE FILLED IN WITH OFFSET TO DATA
FILL_SEG    EQU  0   ;AN000;TO BE FILLED IN WITH THE COMMON SEG ID
                     ; SINCE A .COM FILE CANNOT HAVE
                     ; SEGMENT FIXUP RECORDS

;               DOS FUNCTIONS REFERENCED:
CLEAR_BUF   EQU  0C0H ;AN007;CLEAR KEYBOARD BUFFER BEFORE INPUT
KEY_IN      EQU  08H ;AN000;WAIT FOR STD INPUT, NO ECHO
                     ;OUTPUT: AL = CHAR FROM KEYBOARD
                     ;CTL-BREAK IS CHECKED FOR

KEY_IN_ECHO EQU  01H ;AN000;WAIT FOR STD INPUT, ECHO RESPONSE
                     ;OUTPUT: AL = CHAR FROM KEYBOARD
                     ;CTL-BREAK IS CHECKED FOR

SUBLIST_PARSE  SUBLIST <,,FILL_OFF,FILL_SEG,PC_ID_0,SF_BITS <SF_LEFT,,SF_ASCIIZ,SF_CHAR>,MAX_0,MIN_1,PAD_BLK> ;AN003;
        PUBLIC SUBLIST_PARSE       ;AN003;

;               THE NEXT GROUP ARE ADDITIONAL CLASS "A" MESSAGES
;               SPECIFICALLY DEFINED FOR THE DISKCOPY UTILITY

                     ;CR,LF
MSGNUM_CR_LF  MSG_DESC <2> ;AN000;
            PUBLIC MSGNUM_CR_LF ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Invalid parameter",CR,LF
MSGNUM_INVALID_PARM MSG_DESC <3> ;AN000;
            PUBLIC MSGNUM_INVALID_PARM ;AN000;
; = = = = = = = = = = = = = = = =
                     ; "Do not specify filename(s)",CR,LF
                     ; "Command Format: DISKCOPY d: d: [/1]",CR,LF
MSGNUM_INVALID_PARM2 MSG_DESC <4> ;AN000;
            PUBLIC MSGNUM_INVALID_PARM2 ;AN000;
; = = = = = = = = = = = = = = = =
                     ;:def 5 CR,LF,"Invalid drive specification",CR,LF
                     ;"Specified drive does not exist",CR,LF
                     ;"or is non-removable",CR,LF
MSGNUM_INVALID_DRV MSG_DESC <5> ;AN000;
            PUBLIC MSGNUM_INVALID_DRV ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Cannot DISKCOPY to or from",CR,LF
                     ;"a network drive",CR,LF
MSGNUM_DRV_REDIRECTED MSG_DESC <6> ;AN000;
            PUBLIC MSGNUM_DRV_REDIRECTED ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Formatting while copying",CR,LF
MSGNUM_FORMATTING MSG_DESC <7> ;AN000;
            PUBLIC MSGNUM_FORMATTING ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Insert SOURCE diskette in drive %1:",CR,LF
MSGNUM_LOAD_SOURCE MSG_DESC <8,,SUBLIST_8,ONE_SUBS> ;AN000;
            PUBLIC MSGNUM_LOAD_SOURCE ;AN000;

SUBLIST_8  SUBLIST <,,ASCII_DRV1_ID,FILL_SEG,PC_ID_1,SF_BITS<SF_LEFT,,SF_CH,SF_CHAR>,MAX_0,MIN_1> ;AN000;
            PUBLIC SUBLIST_8 ;AN000;

ASCII_DRV1_ID DB LETTER_A - BYTE;AN000;
            PUBLIC ASCII_DRV1_ID ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Insert TARGET diskette in drive %1:",CR,LF
MSGNUM_LOAD_TARGET MSG_DESC <9,,SUBLIST_9,ONE_SUBS> ;AN000;
            PUBLIC MSGNUM_LOAD_TARGET ;AN000;

SUBLIST_9  SUBLIST <,,ASCII_DRV2_ID,FILL_SEG,PC_ID_1,SF_BITS<SF_LEFT,,SF_CH,SF_CHAR>,MAX_0,MIN_1> ;AN000;
            PUBLIC SUBLIST_9 ;AN000;

ASCII_DRV2_ID DB LETTER_A - BYTE ;AN000;A:=1, B:=1, ETC
            PUBLIC ASCII_DRV2_ID ;AN000;
; = = = = = = = = = = = = = = = =
                     ;:def 10 "Make sure a diskette is inserted into",CR,LF
                     ;"the drive and the door is closed",CR,LF
MSGNUM_CLOSE_DOOR MSG_DESC <10> ;AN004;
            PUBLIC MSGNUM_CLOSE_DOOR ;AN004;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Target diskette may be unusable",CR,LF
MSGNUM_TARGET_MB_UNUSABLE MSG_DESC <11> ;AN000;
            PUBLIC MSGNUM_TARGET_MB_UNUSABLE ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Target diskette unusable",CR,LF
MSGNUM_TARGET_UNUSABLE MSG_DESC <12> ;AN000;
            PUBLIC MSGNUM_TARGET_UNUSABLE ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Drive not ready - %0",CR,LF
MSGNUM_GET_READY MSG_DESC <13,,SUBLIST_13,ONE_SUBS> ;AN000;
            PUBLIC MSGNUM_GET_READY ;AN000;

SUBLIST_13  SUBLIST <,,DRIVE_LETTER,FILL_SEG,PC_ID_0,SF_BITS<SF_LEFT,,SF_ASCIIZ,SF_CHAR>,MAX_0,MIN_1> ;AN000;
            PUBLIC SUBLIST_13 ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Attempt to write to write-protected diskette",CR,LF
MSGNUM_WRITE_PROTECT MSG_DESC <14> ;AN000;
            PUBLIC MSGNUM_WRITE_PROTECT ;AN000;
; = = = = = = = = = = = = = = = =
                     ;"Press any key to continue . . .",CR,LF
MSGNUM_STRIKE MSG_DESC <15,,,,(CLASS_A SHL 8) OR (CLEAR_BUF + KEY_IN)> ;AN007;
            PUBLIC MSGNUM_STRIKE ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Copy another diskette (Y/N)? "
                     ; AND READ RESPONSE TO AL
                     ; (EVENTUALLY EXPECTED IN "USER_INPUT")
MSGNUM_COPY_ANOTHER MSG_DESC <16,,,,(CLASS_A SHL 8) OR (CLEAR_BUF + KEY_IN_ECHO)> ;AN007;
            PUBLIC MSGNUM_COPY_ANOTHER ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Copying %1 tracks",CR,LF
                     ;"%2 Sectors/Track, %3 Side(s)",CR,LF
MSGNUM_COPYING MSG_DESC <17,,SUBLIST_17A,THREE_SUBS> ;AN000;
            PUBLIC MSGNUM_COPYING ;AN000;

SUBLIST_17A SUBLIST <,,MSG_TRACKS,FILL_SEG,PC_ID_1,SF_BITS<SF_LEFT,,SF_WORD,SF_UN_BD>,MAX_0,MIN_1> ;AN000;
SUBLIST_17B SUBLIST <,,MSG_SECTRK,FILL_SEG,PC_ID_2,SF_BITS<SF_LEFT,,SF_WORD,SF_UN_BD>,MAX_0,MIN_1> ;AN000;
SUBLIST_17C SUBLIST <,,MSG_SIDES,FILL_SEG,PC_ID_3,SF_BITS<SF_LEFT,,SF_WORD,SF_UN_BD>,MAX_0,MIN_1> ;AN000;
            PUBLIC SUBLIST_17A ;AN000;
            PUBLIC SUBLIST_17B ;AN000;
            PUBLIC SUBLIST_17C ;AN000;

MSG_TRACKS  DW   0   ;AN000;NUMBER OF TRACKS
MSG_SECTRK  DW   0   ;AN000;NUMBER OF SECTORS PER TRACK
MSG_SIDES   DW   0   ;AN000;NUMBER OF SIDES
            PUBLIC MSG_TRACKS ;AN000;
            PUBLIC MSG_SECTRK ;AN000;
            PUBLIC MSG_SIDES ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Drive types or diskette types",CR,LF
                     ;"not compatible",CR,LF
MSGNUM_NOT_COMPATIBLE MSG_DESC <18> ;AN000;
            PUBLIC MSGNUM_NOT_COMPATIBLE ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Unrecoverable read error on drive %1",CR,LF
                     ;"Side %2, track %3",CR,LF
MSGNUM_HARD_ERROR_READ MSG_DESC <19,,SUBLIST_19C,THREE_SUBS> ;AN000;
            PUBLIC MSGNUM_HARD_ERROR_READ ;AN000;

                     ;CR,LF,"Unrecoverable write error on drive %1",CR,LF
                     ;"Side %2, track %3",CR,LF
MSGNUM_HARD_ERROR_WRITE MSG_DESC <20,,SUBLIST_19C,THREE_SUBS> ;AN000;
            PUBLIC MSGNUM_HARD_ERROR_WRITE ;AN000;

SUBLIST_19C SUBLIST <,,DRIVE_LETTER,FILL_SEG,PC_ID_1,SF_BITS<SF_LEFT,,SF_ASCIIZ,SF_CHAR>,MAX_0,MIN_1> ;AN000;
SUBLIST_19D SUBLIST <,,ERROR_SIDE_NUMBER,FILL_SEG,PC_ID_2,SF_BITS<SF_LEFT,,SF_WORD,SF_UN_BD>,MAX_0,MIN_1> ;AN000;
SUBLIST_19E SUBLIST <,,ERROR_TRACK_NUMBER,FILL_SEG,PC_ID_3,SF_BITS<SF_LEFT,,SF_WORD,SF_UN_BD>,MAX_0,MIN_1> ;AN000;
            PUBLIC SUBLIST_19C ;AN000;
            PUBLIC SUBLIST_19D ;AN000;
            PUBLIC SUBLIST_19E ;AN000;

DRIVE_LETTER DB  LETTER_A,":",NULL ;AN000;
            PUBLIC DRIVE_LETTER ;AN000;

ERROR_SIDE_NUMBER DW ? ;AN000;
            PUBLIC ERROR_SIDE_NUMBER ;AN000;

ERROR_TRACK_NUMBER DW ? ;AN000;
            PUBLIC ERROR_TRACK_NUMBER ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Copy process ended",CR,LF
MSGNUM_FATAL_ERROR MSG_DESC <21> ;AN000;
            PUBLIC MSGNUM_FATAL_ERROR ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"SOURCE diskette bad or incompatible"
MSGNUM_BAD_SOURCE  MSG_DESC <22> ;AN000;
            PUBLIC MSGNUM_BAD_SOURCE ;AN000;

; = = = = = = = = = = = = = = = =
                     ;CR,LF,"TARGET diskette bad or incompatible"
MSGNUM_BAD_TARGET MSG_DESC <23> ;AN000;
            PUBLIC MSGNUM_BAD_TARGET ;AN000;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"Insufficient memory",CR,LF
MSGNUM_UNSUF_MEMORY MSG_DESC <25> ;AN000;
            PUBLIC MSGNUM_UNSUF_MEMORY ;AN000;
; = = = = = = = = = = = = = = = =
                     ;"Volume Serial Number is %1-%2"
MSGNUM_SERNO MSG_DESC <26,,SUBLIST_26A,TWO_SUBS> ;AN001;
            PUBLIC MSGNUM_SERNO ;AN001;

SUBLIST_26A  SUBLIST <,,FILL_OFF,FILL_SEG,PC_ID_1,SF_BITS<SF_RIGHT,,SF_WORD,SF_UN_BH>,DWORD,DWORD,PAD_0> ;AN001;
SUBLIST_26B  SUBLIST <,,FILL_OFF,FILL_SEG,PC_ID_2,SF_BITS<SF_RIGHT,,SF_WORD,SF_UN_BH>,DWORD,DWORD,PAD_0> ;AN001;
            PUBLIC SUBLIST_26A,SUBLIST_26B ;AN001;
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"TARGET media has lower capacity than SOURCE",CR,LF
                     ;"Continue anyway (Y/N)?"
                     ; AND READ RESPONSE TO AL
MSGNUM_TARGETTOOSMALL MSG_DESC <30,,,,(CLASS_A SHL 8) OR (CLEAR_BUF + KEY_IN_ECHO)> ;SA;media sense
            PUBLIC MSGNUM_TARGETTOOSMALL
; = = = = = = = = = = = = = = = =
                     ;"Correct problem, press CTRL+C to abort,",CR,LF   ;C12
                     ;"or press any other key to continue . . .",CR,LF  ;C12
MSGNUM_CORRECT MSG_DESC <31,,,,(CLASS_A SHL 8) OR (CLEAR_BUF + KEY_IN)> ;C12
            PUBLIC MSGNUM_CORRECT                                       ;C12

; = = = = = = = = = = = = = = = =	; M003
IF  IBMCOPYRIGHT NE TRUE		; M003
		     ;M003 "DISKCOPY cannot copy memory card (CMCDD) devices."
MSGNUM_CMCDD_DRIVE MSG_DESC <32>	; M003
            PUBLIC MSGNUM_CMCDD_DRIVE	; M003
ENDIF					; M003
; = = = = = = = = = = = = = = = =
                     ;CR,LF,"<<< DISKCOPY options message >>>",CR,LF

MSG_OPTIONS_FIRST       equ     300
MSG_OPTIONS_LAST        equ     304

MSGNUM_OPTIONS MSG_DESC <MSG_OPTIONS_FIRST>
            PUBLIC MSGNUM_OPTIONS, MSG_OPTIONS_FIRST, MSG_OPTIONS_LAST

; = = = = = = = = = = = = = = = =
;end of DCOPYMS.INC


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcopy\dcopypar.asm ===
PAGE	90,132			;AN000;A2
	TITLE	DCOPYPAR.SAL - LOOK AT COMMAND LINE PARMS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: DCOPYPAR.SAL
;
; DESCRIPTIVE NAME: Handle the definition of the DOS command line parameters
;		    and the interface to the DOS system PARSER.
;
;FUNCTION: The static data areas are prescribed by the DOS system PARSER
;	   to define the several parameters presented to DISKCOPY.  These
;	   data areas are passed to the PARSER, and its responses checked
;	   to determine the nature of the user's specifications.  Any errors
;	   found in the user's parameters are defined in messages back
;	   to the user.
;
; ENTRY POINT: PARSER, near
;
; INPUT: (DOS COMMAND LINE PARAMETERS)
;
;	      [d:][path] DISKCOPY  [d: [d:]][/1]
;
;	 WHERE
;	      [d:][path] - Path where the DISKCOPY command resides.
;
;	      [d:] - To specify the Source drive
;
;	      [d:] - To specify the Destination drive
;
;	      [/1] - To copy only the first side of the diskette,
;		     regardless of the diskette or drive type.
;
;	Upon entry to PARSER in this module,
;	"CURRENT_PARM" = offset to start of parm text in command string
;	"ORDINAL" = initialized to zero
;	PSP+81H = text of DOS command line parms string

; EXIT-NORMAL:
;      "SOURCE_DRIVE" = CHAR OF FIRST DRIVE ID SPECIFIED, BLANK IF NONE
;      "TARGET_DRIVE" = CHAR OF SECOND DRIVE ID IF BOTH SPECIFIED, BLANK
;		   IF NONE OR ONLY ONE SPECIFIED
;      "USER_OPTION" = 01 ON IF /1, -1 IF /1 NOT SPECIFIED.

; EXIT-ERROR:
;      IF ERROR, ERROR MESSAGE IS DISPLAYED, AND "EXITFL" HAS "EXPAR".

; INTERNAL REFERENCES:
;    ROUTINES:
;	PARSER:NEAR Call the system Parser to decode command line
;	PARSE_ERROR:NEAR Display the appropriate Parse error message.

;    DATA AREAS:
;	The several parameter control blocks, defined by the System
;	PARSER interface, defining the DISKCOPY parameters.

; EXTERNAL REFERENCES:
;    ROUTINES:
;	SENDMSG:NEAR	Uses Msg Descriptor to drive message handler.
;	SYSPARSE:NEAR	System Command Line Common Parser.
;
;    DATA AREAS:
;	EXITFL:BYTE	Errorlevel return code.
;	MSGNUM_PARSE:WORD Message descriptor for all parse errors.
;	USER_OPTION:BYTE /1 parm indicator
;	SOURCE_DRIVE:BYTE character of first specified drive
;	TARGET_DRIVE:BYTE character of second specified drive
;
; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT DCOPYPAR,NUL
;
;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;	 DISKCOPY.SAL.
;
;PROGRAM AUTHOR: DOS 4.00 EMK
;****************** END OF SPECIFICATIONS *****************************
	IF1				;AN000;
	    %OUT    COMPONENT=DISKCOPY, MODULE=DCOPYPAR.SAL... ;AN000;
	ENDIF				;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	INCLUDE PATHMAC.INC		;AN015;PATHGEN MACRO
; =  =	=  =  =  =  =  =  =  =	=  =
HEADER	MACRO	TEXT			;;AN000;
.XLIST					;;AN000;
	SUBTTL	TEXT			;;AN000;
.LIST					;;AN000;
	PAGE				;;AN000;
	ENDM				;;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
;		      $SALUT (4,23,28,36) ;AN000;
;		LOCAL EQUATES

FALSE		      EQU  0	   ;AN000;RETURN VALUES FOR
TRUE		      EQU  NOT FALSE ;AN000; /1 SWITCH
CHAR_A		      EQU  "A"	   ;AN000;ASCII VALUE OF CHARACTER "A"
BLANK		      EQU  " "	   ;AN001;
NUL		      EQU  0	   ;AN003;
; =  =	=  =  =  =  =  =  =  =	=  =
;		EXIT CODES FROM SYSPARSE (WHEN CY=0)

SYSPRM_EX_OK	      EQU  0	   ;AN000; no error
SYSPRM_EX_MANY	      EQU  1	   ;AN000; too many operands
SYSPRM_EX_MISSING     EQU  2	   ;AN000; required operand missing
SYSPRM_EX_NOT_SWLIST  EQU  3	   ;AN000; not in switch list provided
SYSPRM_EX_NOT_KEYLIST EQU  4	   ;AN000; not in keyword list provided
SYSPRM_EX_RANGE       EQU  6	   ;AN000; out of range specified
SYSPRM_EX_VALUE       EQU  7	   ;AN000; not in value list provided
SYSPRM_EX_STRING      EQU  8	   ;AN000; not in string list provided
SYSPRM_EX_SYNTAX      EQU  9	   ;AN000; syntax error
SYSPRM_EX_EOL	      EQU  -1	   ;AN000; end of command line
; =  =	=  =  =  =  =  =  =  =	=  =
		      HEADER <STRUC - DEFINITIONS OF EXTERNAL CONTROL BLOCKS> ;AN000;
PSP		      STRUC	   ;AN000;
		      DB   80H DUP (?) ;AN000;SKIP OVER FIRST HALF OF PSP
PSP_PARMLEN	      DB   ?	   ;AN000;NUMBER OF BYTES IN DOS COMMAND LINE
PSP_COMMAND	      DB   127 DUP(?) ;AN000;TEXT OF DOS COMMAND LINE
PSP		      ENDS	   ;AN000;

MSG_DESC	      STRUC	   ;AN003;
MSG_NUM 	      DW   ?	   ;AN003;MESSAGE NUMBER (TO AX)
MSG_HANDLE	      DW   ?	   ;AN003;HANDLE OF OUTPUT DEVICE (TO BX)
MSG_SUBLIST	      DW   ?	   ;AN003;POINTER TO SUBLIST (TO SI)
MSG_COUNT	      DW   ?	   ;AN003;SUBSTITUTION COUNT (TO CX)
MSG_CLASS	      DW   ?	   ;AN003;MESSAGE CLASS (IN HIGH BYTE, TO DH)
				   ; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL)
MSG_DESC	      ENDS	   ;AN003;

ONE_SUBS	      EQU  1	   ;AN003;NUMBER OF VARIABLES

SUBLIST 	      STRUC	   ;AN000;
SUB_SIZE	      DB   ?	   ;AN003;SUBLIST SIZE (POINTER TO NEXT SUBLIST)
SUB_RES 	      DB   ?	   ;AN003;RESERVED
				   ;NEXT FIELD IS TO BE USED AS A DOUBLE WORD
SUB_VALUE	      DW   ?	   ;AN003;TIME, DATE, OR PTR TO DATA ITEM
SUB_VALUE_SEG	      DW   ?	   ;AN003;SEG ID OF PTR
				   ;(ABOVE FIELD MUST BE FILLED AT EXECUTION TIME
				   ; IF THIS IS A .COM FILE)
SUB_ID		      DB   ?	   ;AN003;N OF %N
SUB_FLAGS	      DB   ?	   ;AN003;DATA TYPE FLAGS
SUB_MAX_WIDTH	      DB   ?	   ;AN003;MAXIMUM FIELD WIDTH (0=UNLIMITED)
SUB_MIN_WIDTH	      DB   ?	   ;AN003;MINIMUM FIELD WIDTH
SUB_PAD_CHAR	      DB   ?	   ;AN003;CHARACTER FOR PAD FIELD
				   ; CAN BE " ", "0" OR ",".
				   ; "," CAUSES INSERTION OF THE ACTIVE
				   ; THOUSANDS SEPARATOR BETWEEN EVERY 3 DIGITS.
SUBLIST 	      ENDS	   ;AN003;

; =  =	=  =  =  =  =  =  =  =	=  =
		      HEADER <PARSING WORKAREAS> ;AN000;
;	     $SALUT (4,14,19,36)   ;AN000;
	     EXTRN EXPAR:ABS	   ;AN000;ERRORLEVEL VALUE FOR BAD PARMS
	     EXTRN FINE:ABS	   ;AN000;RETURN STATUS INDICATOR
CSEG	     SEGMENT PARA PUBLIC 'CODE' ;AN000;
	     ASSUME CS:CSEG,DS:CSEG,ES:CSEG,SS:CSEG ;AN000;

	     EXTRN SENDMSG:NEAR    ;AN000;USES MSG DESCRIPTOR TO DRIVE MESSAGE HANDLR
	     EXTRN SYSPARSE:NEAR   ;AN000;SYSTEM COMMAND LINE PARSER

	     EXTRN EXITFL:BYTE	   ;AN000;ERRORLEVEL RETURN CODE

	     EXTRN SOURCE_DRIVE:BYTE ;AN000;FIRST DRIVE LETTER SPECIFIED IN PARMS
	     EXTRN TARGET_DRIVE:BYTE ;AN000;SECOND DRIVE LETTER SPECIFIED

	     EXTRN USER_OPTION:BYTE ;AN000;NO OPTION (-1)  /1 (1), INVALID (9)
	     EXTRN VERIFY_OPTION:BYTE ; 0 - do not verify, 1 - verify
	     EXTRN SHOW_OPTIONS:BYTE ; 0 - do not show options, 1 - show 'em
NO_OPTION    EQU  -1		   ;AN000;NO OPTION "/1" SPECIFIED
OPTION_1     EQU  1		   ;AN000;OPTION "/1" SPECIFIED
	     EXTRN MSGNUM_PARSE:WORD ;AN000;MESSAGE DESCRIPTOR FOR ALL PARSE ERRORS
	     EXTRN MSGNUM_INVALID_PARM2:WORD ;AN005;HELP INFO
	     EXTRN SUBLIST_PARSE:WORD ;AN003;POINTS TO INVALID PARM
; =  =	=  =  =  =  =  =  =  =	=  =

CURRENT_PARM DW   81H		   ;AN000;POINTER INTO COMMAND OF NEXT OPERAND
	     PUBLIC CURRENT_PARM   ;AN000;

ORDINAL      DW   0		   ;AN000;ORDINAL NUMBER OF WHICH PARM TO PARSE
	     PUBLIC ORDINAL	   ;AN000;

; =  =	=  =  =  =  =  =  =  =	=  =
	     HEADER <DOS COMMAND LINE PARSER CONTROL BLOCKS> ;AN000;

;INPUT PARAMETERS CONTROL BLOCK, POINTED TO BY ES:DI WHEN CALLING PARSER

	     PUBLIC PARMS	   ;AN000;LET LINK MAKE PARMS BLOCK ADDRESSABLE
PARMS	     LABEL BYTE 	   ;AN000;PARMS CONTROL BLOCK
	     DW   PARMSX	   ;AN000;POINTER TO PARMS EXTENSION
	     DB   0		   ;AN000; NUMBER OF STRINGS (0, 1, 2)
				   ; NEXT LIST WOULD BE EXTRA DELIM LIST
				   ;  (,& WHITESPACE ALWAYS)
				   ; NEXT LIST WOULD BE EXTRA END OF LINE LIST
				   ;  (CR,LF,0 ALWAYS)

;SYSTEM PARSER PARAMETER EXTENSION CONTROL BLOCK
PARMSX	     LABEL BYTE 	   ;AN000;PARMS EXTENSION CONTROL BLOCK
	     DB   0,2		   ;AN000; MIN, MAX POSITIONAL OPERANDS ALLOWED
	     DW   CONTROL_POS	   ;AN000; DESCRIPTION OF POSITIONAL 1
	     DW   CONTROL_POS	   ;AN000; DESCRIPTION OF POSITIONAL 2

	     DB   3		   ;AN000; MAX SWITCH OPERANDS ALLOWED
	     DW   CONTROL_SW1	   ;AN000; DESCRIPTION OF SWITCH 1
	     DW   CONTROL_SW2	   ;AN000; DESCRIPTION OF SWITCH 2
	     DW   CONTROL_SW3	   ;4/18/90 /? switch

	     DB   0		   ;AN000; MAX KEYWORD OPERANDS ALLOWED
				   ; THERE IS NO CONTROL BLOCK
				   ;  DEFINING KEYWORDS

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	     HEADER <POSITIONAL PARM DESCRIPTOR BLOCK> ;AN000;
;PARSER CONTROL BLOCK DEFINING THE ONLY POSITIONAL PARAMETER, OPTIONAL

;FIRST POSITIONAL PARAMETER IS:
;	[D:] - SPECIFY THE SOURCE DRIVE.

	     PUBLIC CONTROL_POS    ;AN000;LET LINK MAKE THIS ADDRESSABLE
CONTROL_POS  LABEL BYTE 	   ;AN000;FIRST POSITIONAL DESCRIPTOR FOR FILESPEC,
				   ; OPTIONAL
	     DW   0101H 	   ;AN000; CONTROLS TYPE MATCHED
				   ; SELECTED BITS: "DRIVE ONLY" AND "OPTIONAL"

				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE
				   ;   CHECKED)
				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0010H=IGNORE ":" AT END IN MATCH
				   ; 0002H=REPEATS ALLOWED
				   ; 0001H=OPTIONAL

	     DW   0002H 	   ;AN000;FUNCTION_FLAGS
				   ; 0001H=CAP RESULT BY FILE TABLE
				   ; 0002H=CAP RESULT BY CHAR TABLE
				   ; 0010H=REMOVE ":" AT END
	     DW   RESULT1	   ;AN000; RESULT BUFFER
	     DW   NOVALS	   ;AN000; NO VALUE LISTS
	     DB   0		   ;AN000; NUMBER OF KEYWORD/SWITCH SYNONYMS
				   ;   IN FOLLOWING LIST

;VALUE CONTROL BLOCK FOR THE POSITIONAL PARAMETERS
NOVALS	     DB   0		   ;AN000;NO VALUE DEFINITIONS

;RESULTS CONTROL BLOCK FOR THE POSITIONAL PARAMETER
RESULT1      LABEL BYTE 	   ;AN000; BELOW FILLED IN FOR DEFAULTS
	     DB   6		   ;AN000; TYPE RETURNED: 0=RESERVED,
				   ;	   1=NUMBER, 2=LIST INDEX,
				   ;	   3=STRING, 4=COMPLEX,
				   ;	   5=FILESPEC, 6=DRIVE
				   ;	   7=DATE, 8=TIME
				   ;	   9=QUOTED STRING
RESULT_TAG   DB   0FFH		   ;AN000; MATCHED ITEM TAG
	     DW   0		   ;AN000;POINTER TO SYNONYM

RESULT_PTR1  DB   ?		   ;AN000;DRIVE NUMBER (A=1, B=2, ETC)

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	     HEADER <SWITCH PARM DESCRIPTOR BLOCK> ;AN000;
;PARSER CONTROL BLOCK DEFINING THE SWITCHES, OPTIONAL

;THE SWITCH IS "/1", MEANING ONLY COPY FIRST SIDE.

	     PUBLIC CONTROL_SW1    ;AN000;LET LINK MAKE THIS ADDRESSABLE
CONTROL_SW1   LABEL BYTE	   ;AN000;SWITCH DESCRIPTOR FOR /1
	     DW   0001H 	   ;AN000; CONTROLS TYPE MATCHED
				   ;SELECTED BITS: "OPTIONAL"
				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE
				   ;   CHECKED)
				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0010H=IGNORE ":" AT END IN MATCH
				   ; 0002H=REPEATS ALLOWED
				   ; 0001H=OPTIONAL

	     DW   0002H 	   ;AN000;FUNCTION_FLAGS
				   ; 0001H=CAP RESULT BY FILE TABLE
				   ; 0002H=CAP RESULT BY CHAR TABLE
				   ; 0010H=REMOVE ":" AT END

	     DW   RESULTSW1	   ;AN000; RESULT BUFFER
	     DW   NOVALS	   ;AN000; VALUE LISTS
	     DB   1		   ;AN000; NUMBER OF KEYWORD/SWITCH SYNONYMS
				   ;   IN FOLLOWING LIST
SW_1	     DB   "/1",0	   ;AN000; IF n >0, SWITCH 1

;RESULTS CONTROL BLOCK FOR THE SWITCHES
RESULTSW1    LABEL BYTE 	   ;AN000; BELOW FILLED IN FOR DEFAULTS
	     DB   3		   ;AN000; TYPE RETURNED: 0=RESERVED,
				   ;	   1=NUMBER, 2=LIST INDEX,
				   ;	   3=STRING, 4=COMPLEX,
				   ;	   5=FILESPEC, 6=DRIVE
				   ;	   7=DATE, 8=TIME
				   ;	   9=QUOTED STRING
	     DB   0FFh		   ;AN000; MATCHED ITEM TAG

	     DW   0		   ;AN000; SYNONYM POINTER (BASED ON ES:)
RESULT_PTR21 DD   ?		   ;AN000; OFFSET OF STRING VALUE

;THE SWITCH IS "/V", MEANING VERIFY ALL TRACK WRITES

	     PUBLIC CONTROL_SW2    ;AN000;LET LINK MAKE THIS ADDRESSABLE
CONTROL_SW2   LABEL BYTE	   ;AN000;SWITCH DESCRIPTOR FOR /1
	     DW   0001H 	   ;AN000; CONTROLS TYPE MATCHED
				   ;SELECTED BITS: "OPTIONAL"

	     DW   0002H 	   ;AN000;FUNCTION_FLAGS
				   ; 0001H=CAP RESULT BY FILE TABLE
				   ; 0002H=CAP RESULT BY CHAR TABLE
				   ; 0010H=REMOVE ":" AT END

	     DW   RESULTSW2	   ;AN000; RESULT BUFFER
	     DW   NOVALS	   ;AN000; VALUE LISTS
	     DB   1		   ;AN000; NUMBER OF KEYWORD/SWITCH SYNONYMS
				   ;   IN FOLLOWING LIST
SW_2	     DB   "/V",0	   ;AN000; IF n >0, SWITCH 1

;RESULTS CONTROL BLOCK FOR THE SWITCHES
RESULTSW2    LABEL BYTE 	   ;AN000; BELOW FILLED IN FOR DEFAULTS
	     DB   3		   ;AN000; TYPE RETURNED: 0=RESERVED,
				   ;	   1=NUMBER, 2=LIST INDEX,
				   ;	   3=STRING, 4=COMPLEX,
				   ;	   5=FILESPEC, 6=DRIVE
				   ;	   7=DATE, 8=TIME
				   ;	   9=QUOTED STRING
	     DB   0FFh		   ;AN000; MATCHED ITEM TAG

	     DW   0		   ;AN000; SYNONYM POINTER (BASED ON ES:)
RESULT_PTR22 DD   ?		   ;AN000; OFFSET OF STRING VALUE

;THE SWITCH IS "/?", MEANING DISPLAY OPTIONS MESSAGE

	     PUBLIC CONTROL_SW3
CONTROL_SW3   LABEL BYTE
	     DW   0000H 	   ; MatchMask bits
	     DW   0000H 	   ; FuncMask bits
	     DW   RESULTSW3	   ; ptr to Result Buffer
	     DW   NOVALS	   ; ptr to Value Buffer
	     DB   1		   ; count of synonyms that follow
SW_3	     DB   "/?",0	   ; text of /? switch

;RESULTS CONTROL BLOCK FOR THIS SWITCH

RESULTSW3    LABEL BYTE
	     DB   0		   ; ValueType
	     DB   0FFh		   ; Value List Tag
	     DW   0		   ; ptr to Synonym (filled in)
RESULT_PTR3  DD   ?		   ; Value returned (dummy)

; =  =	=  =  =  =  =  =  =  =	=  =
	     PATHLABL DCOPYPAR	   ;AN015;
	     HEADER <PARSER - ASK SYSPARM TO DECODE PARAMETERS> ;AN000;
;  $SALUT (4,4,9,36)		   ;AN000;
PARSER PROC NEAR		   ;AN000;
   PUBLIC PARSER		   ;AN000;

;INPUT: "CURRENT_PARM" = OFFSET TO NEXT PARM IN COMMAND STRING
;	"ORDINAL" = COUNT OF NEXT PARM TO PARSE
;	PSP+81H = TEXT OF DOS COMMAND LINE PARMS STRING
;OUTPUT: "SOURCE_DRIVE" = VALUE OF FIRST DRIVE ID SPECIFIED, 0 IF NONE
;	 "TARGET_DRIVE" = VALUE OF SECOND DRIVE ID IF BOTH SPECIFIED, 0
;		     IF NONE OR ONLY ONE SPECIFIED
;	 "USER_OPTION" = "OPTION_1" IF /1 SPECIFIED, -1 IF NOT SPECIFIED
;	IF ERROR, ERROR MESSAGE IS DISPLAYED, AND "EXITFL" HAS "EXPAR".
;	DX="FINE" IF NO ERROR, OR HAS OFFSET OF PARSE ERROR DESCRIPTOR IF PROBLEM
; =  =	=  =  =  =  =  =  =  =	=  =

   mov	VERIFY_OPTION, 0	   ; assume no verify option
   MOV	USER_OPTION, NO_OPTION	   ;AN000;ASSUME NO /1 IS ENTERED.
;  $SEARCH COMPLEX		   ;AN000;LOOP THRU COMMAND LINE
   JMP SHORT $$SS1
$$DO1:
				   ;LOOKING AT RETURN CODE FROM SYSPARSE...
       CMP  AX,SYSPRM_EX_OK	   ;AN000;WERE THERE ANY ERRORS?
;  $EXITIF NE			   ;AN000;HAD A PROBLEM
   JE $$IF1
       CALL PARSE_ERROR 	   ;AN000;DISPLAY REASON FOR ERROR

;  $ORELSE			   ;AN000;SINCE NO PROBLEM, SO FAR
   JMP SHORT $$SR1
$$IF1:
       MOV  ORDINAL,CX		   ;AN000;SAVE UPDATED COUNT
       MOV  CURRENT_PARM,SI	   ;AN000;REMEMBER HOW FAR I GOT
       MOV  BX,DX		   ;AN000;SET DATA BASE REG TO POINT TO THIS OPERAND
       CMP  BX,OFFSET RESULT1	   ;AN000;WAS POSITIONAL PARM SPECIFIED?
;      $IF  E			   ;AN000;IF POSITIONAL PARM SPECIFIED,
       JNE $$IF4
	   MOV	SI,CX		   ;AN000;USE COUNT OF POSITIONALS AS INDEX
	   MOV	AL,RESULT_PTR1	   ;AN000;GET VALUE OF DRIVE (A=1, B=2, ETC)
	   MOV	SOURCE_DRIVE-1[SI],AL ;AN000;SAVE RESPONSE VALUE
				   ;IN EITHER SOURCE_DRIVE OR TARGET_DRIVE
				   ;ACCORDING TO ORDINAL IN SI (FROM CX)
;      $ELSE			   ;AN000;SINCE NOT POSITIONAL PARM SPECIFIED
       JMP SHORT $$EN4
$$IF4:

; Check to see if the parameter is one of
; the switches.

	; Check Switch 1 (/1)

	cmp	bx, offset RESULTSW1	   ; was it /1 ?
	jne	NotSwitch1 	   ; no, it should be /V
	   MOV	SW_1,BLANK	   ;AN001;AVOID GETTING DUPLICATE SWITCH
	   MOV	USER_OPTION,OPTION_1 ;AN000;MUST HAVE BEEN THE SWITCH, /1
	   jmp	short sw_set
NotSwitch1:

	; Check Switch 2 (/V)

	cmp	bx, offset RESULTSW2	; was it /V?
	jne	NotSwitch2
	  mov	SW_2, BLANK	   ; only one /V allowed
	  mov	VERIFY_OPTION, 1   ; enable Verify operation
	  jmp	short sw_set
NotSwitch2:

	; Check Switch 3 (/?)

	cmp	bx, offset RESULTSW3	; was it /?
	jne	NotSwitch3		; jump if not
	  mov	SHOW_OPTIONS, 1		; set flag for INIT
	  jmp	short sw_set		; (multiple /?s okay)
NotSwitch3:

	; Not one of the valid switches.
	; What do we do now?
	; When in doubt, fall thru to:

sw_set:
;      $ENDIF			   ;AN000;
$$EN4:
;  $STRTSRCH			   ;AN000;
$$SS1:
       LEA  DI,PARMS		   ;AN000; ES:DI = PARSE CONTROL DEFINITON
       MOV  SI,CURRENT_PARM	   ;AN000; DS:SI = COMMAND STRING, NEXT PARM
       XOR  DX,DX		   ;AN000; RESERVED, INIT TO ZERO
       MOV  CX,ORDINAL		   ;AN000; OPERAND ORDINAL, INITIALLY ZERO
       CALL SYSPARSE		   ;AN000;LOOK AT DOS PARMS
				   ; AX=EXIT CODE
				   ; BL=TERMINATED DELIMETER CODE
				   ; CX=NEW OPERAND ORDINAL
				   ; SI=SET TO PAST SCANNED OPERAND
				   ; DX=SELECTED RESULT BUFFER
       CMP  AX,SYSPRM_EX_EOL	   ;AN000; IS THAT THE END OF THE PARMS?
				   ;IF NOT, LOOP BACK AND FIND OUT
				   ; WHAT THAT PARM IS
;  $ENDLOOP E			   ;AN000;END OF LIST
   JNE $$DO1
       MOV  DX,FINE		   ;AN000;REPORT THAT PARSER WENT OK
;  $ENDSRCH			   ;AN000;FINISHED WITH DOS COMMAND LINE
$$SR1:
   RET				   ;AN000;RETURN TO CALLER
PARSER ENDP			   ;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
   HEADER <PARSE_ERROR - DISPLAY REASON FOR PARSE ERROR> ;AN000;
PARSE_ERROR PROC NEAR		   ;AN000;
;INPUT:  AX - ERROR NUMBER RETURNED FROM PARSE.
;	 "CURRENT_PARM" - OFFSET TO WHERE THE BAD PARM STARTED
;OUTPUT: APPROPRIATE ERROR MESSAGE IS PREPARED FOR DISPLAY.
;	 DX IS SET TO OFFSET OF PARSE ERROR DESCRIPTOR.
; =  =	=  =  =  =  =  =  =  =	=  =

   MOV	MSGNUM_PARSE,AX 	   ;AN000;PASS MESSAGE NUMBER TO DESCRIPTOR
   MOV	EXITFL,EXPAR		   ;AN000;ERRORLEVEL CODE TO "PARM ERROR"
   MOV	AX,CURRENT_PARM 	   ;AN003;GET POINTER TO START OF BAD PARM
   CMP	SI,AX			   ;AN003;HAS THE INDEX TO COMMAND LINE MOVED?
;  $IF	NE			   ;AN003;YES, THERE IS A FAULTY PARM
   JE $$IF10
       MOV  BYTE PTR [SI],NUL	   ;AN003;DELIMIT THE BAD PARM
       MOV  SUBLIST_PARSE.SUB_VALUE,AX ;AN000;POINT SUBLIST TO BAD PARM

       MOV  MSGNUM_PARSE.MSG_SUBLIST,OFFSET SUBLIST_PARSE ;AN003;POINT TO SUBLIST
       MOV  MSGNUM_PARSE.MSG_COUNT,ONE_SUBS ;AN003;SET COUNT OF SUBLISTS TO ONE
;  $ENDIF			   ;AN003;INDEX MOVED?
$$IF10:
   MOV	DI,OFFSET MSGNUM_PARSE	   ;AC005;PASS BACK OFFSET TO PARSE ERR DESCRIPTOR
   CALL SENDMSG 		   ;AN005;DISPLAY THE ERROR MESSAGE

				   ; "Do not specify filename(s)",CR,LF
				   ; "Command Format: DISKCOPY d: d: [/1]",CR,LF
   MOV	DX,OFFSET MSGNUM_INVALID_PARM2 ;AN005;DISPLAY HELP INFO
   RET				   ;AN000;RETURN TO CALLER
PARSE_ERROR ENDP		   ;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
   PATHLABL DCOPYPAR		   ;AN015;
CSEG ENDS			   ;AN000;
   END				   ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\diskcopy\diskcopy.asm ===
PAGE    90,132                  ;A2
        TITLE   DISKCOPY.SAL - DISKETTE DUPLICATION UTILITY ;
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: DISKCOPY

; DESCRIPTIVE NAME: Diskette to diskette complete copy Utility

;FUNCTION: DISKCOPY is to copy the contents of the diskette in the
;          specified source drive to the diskette in the target
;          drive.  If necessary, the target diskette is also
;          formatted.


;          Multiple copies may be performed with one load of DISKCOPY.
;          A prompt, "Copy another (Y/N)?" permits additional
;          executions, all with the same drive specifications.

; ENTRY POINT: "DISKCOPY" at ORG 100h, jumps to "BEGIN".

; INPUT: (DOS command line parameters)
;        [d:][path]DISKCOPY [d: [D:]][/1]

;        Where

;        [d:][path] before DISKCOPY to specify the drive and path that
;                   contains the DISKCOPY command file.

;        [d:]       to specify the source drive id

;        [D:]       to specify the destination drive id

;        [/1]       to request single sided operations only

; EXIT-NORMAL: Errorlevel = 0
;             Function completed successfully.

; EXIT-ERROR: Errorlevel = 1
;             Abnormal termination due to error, wrong DOS,
;             invalid parameters, unrecoverable I/O errors on
;             the diskette.
;
;             Errorlevel = 2
;             Termination requested by Cntrl-Break.

; EFFECTS: The entire source diskette is copied, including the unused
;          sectors.  There is no awareness of the separate files
;          involved.  A unique volume serial number is generated
;          for the target diskette.

; INCLUDED FILES:
;       INCLUDE DCPYMACR.INC            ;(formerly called MACRO.DEF)
;       INCLUDE DISKCOPY.EQU            ;EQUATES
;       INCLUDE BOOTFORM.INC            ;DEFINE EXT_BPB_INFO & EXT_IBMBOOT_HEADER
;       INCLUDE PATHMAC.INC             ;PATHGEN MACRO

; INTERNAL REFERENCES:
;    ROUTINES:
;        BEGIN - VERSION CHECK, SYSMSG INIT, EXIT TO DOS
;        SET_LOGICAL_DRIVE - SET LOG. DRV LETTER THAT OWNS DRIVE
;        COPY - COPY THE DISKETTE IMAGE
;        TEST_REPEAT - SEE IF USER WANTS TO COPY ANOTHER
;        READ_SOURCE - READ FROM SOURCE AS MUCH AS POSSIBLE
;        WRITE_TARGET - WRITE DATA FROM MEMORY TO TARGET DISKETTE
;        READ_WRITE_TRACK - READ A TRACK AND STORE IT INTO MEMORY
;        READ_OP - IOCTL READ A TRACK OPERATION
;        MAYBE_ADJUST_SERIAL - MAKE NEW SERIAL IN BOOT
;        WRITE_OP - IOCTL WRITE A TRACK OPERATION
;        FORMAT_ALL - FORMATS ALL TRACKS TO END
;        FORMAT_TRACK - IOCTL FORMAT A TRACK
;        CHECK_SOURCE - CHECK SOURCE DISKETTE TYPE
;        READ_A_SECTOR - GET ONE SECTOR WITH IOCTL READ
;        CALC_TRACK_SIZE - GET MEM SIZE TO STORE ONE TRACK
;        CHECK_MEMORY_SIZE - VERIFY WE HAVE ENUF TO COPY 1 TRACK
;        SET_FOR_THE_OLD  - SET BPB FOR BEFORE-2.0 FMTTED MEDIA
;        SET_TRACKLAYOUT - MOVE DATA TO TRACK IMAGE
;        CHECK_TARGET - READ TARGET BOOT RCD, NEEDS FORMAT?
;        CHK_MULTI_MEDIA - CHECK IF DRIVE IS MULTI-MEDIA
;        SET_DRV_PARM_DEF - SET DRIVE PARMS VIA IOCTL
;        CHK_MEDIATYPE - DETERMINE MEDIATYPE OF TARGET FOR FORMAT
;        GENERIC_IOCTL - COMMUNICATE WITH THE DEVICE DRIVER
;        EXTENDED_ERROR_HANDLER - RESPOND TO DOS ERRORS
;        TRY_FORMAT - ATTEMPT TRACK FORMAT, TRY FOR ERROR RECOVERY
;        ERROR_MESSAGE - SAY WHAT AND WHERE FAILURE
;        SENDMSG - PASS IN REGS DATA FROM MSG DESCRIPTOR TO DISP MSG
;        YESNO - DETERMINE IF A RESPONSE IS YES OR NO
;(DELETED ;AN013;)READ_VOLSER - OBTAIN OLD VOLUME SERIAL NUMBER FROM SOURCE
;        WRITE_VOLSER - PUT NEW VOL SER NUMBER TO TARGET
;        TARGETMEDIASENSE - GIVE WARNING & PROMPT IF TARGET MEDIA TOO SMALL
;        TARGETBIGENOUGH - DETERMINE WHETHER TARGET MEDIA DENSITY >= SOURCE
;    DATA AREAS:
;       PSP - Contains the DOS command line parameters.
;       WORKAREA - Temporary storage

; EXTERNAL REFERENCES:
;    ROUTINES:
;       SYSDISPMSG - Uses the MSG parm lists to construct the messages
;                on STDOUT.
;       SYSLOADMSG - Loads messages, makes them accessable.
;       SYSPARSE - Processes the DOS Command line, finds parms.

;    DATA AREAS:
;        DCOPYSM.SAL - Defines the control blocks that describe the messages
;        DCOPYPAR.SAL - Defines the control blocks that describe the
;               DOS Command line parameters.

; NOTES:
;        This module should be processed with the SALUT preprocessor
;        with the re-alignment not requested, as:

;               SALUT DISKCOPY,NUL

;        To assemble these modules, the alphabetical or sequential
;        ordering of segments may be used.

;        Sample LINK command:

; LINK @DISKCOPY.ARF

; Where the DISKCOPY.ARF is defined as:

;        DISKCOPY+
;        DCOPYSM+
;        DCOPYP+
;        DCOPYPAR+
;        COPYINIT

;        These modules must be linked in this order.  The load module is
;        a COM file, to be converted to COM with EXE2BIN.

; REVISION HISTORY:
;            A000 Version 4.00: add PARSER, System Message Handler,
;                 Make new unique vol serial number on new diskette.
;            A001 DCR 27, display vol serial number, if present.
;            A002 ptm473 Flag duplicate switches as error
;            A003 Display parm in error
;            A004 PTR752 Add close door to drive not ready
;            A005 PTR756 After bad parms, specify help info
;            A006 DCR210 SELECT, if present, handles all msgs
;            A007 PTM1100 Clear keyboard buffer before input response
;            A008 PTM1434 CR,LF MISSING FROM MSGS 22 AND 23
;            A009 PTM1406 USE 69H INSTEAD OF IOCTL FOR GET/SET MEDIA ID
;            A010 PTM1821 Move INCLUDE COPYRIGH.INC into MSG_SERVICE macro.
;            A011 PTM1837 ADD CHECK FOR UNKNOWN MEDIA TO TRIGGER FORMAT
;            A012 PTM2441 COPY FROM 360 TO 1.2 CLOBBERS 1.2
;            A013 PTM3184 SUPPORT OS/2 1.0/1.1 TYPE BOOT RECORDS ALSO
;                       REMOVE USE OF GET/SET MEDIA ID
;            A014 PTM3262 specify BASESW EQU 1 before PARSE.ASM
;            A015 PTM3512 PATHGEN
;            ;C00 MKS     Cleaned up the build.  Made short jumps out of long
;                         jumps, and got rid of some extra inserted nops.
;            ;C03 MKS     Bug#562.  DISKCOPY was allowing you to copy from a
;                         720K to a previously formatted 1.44M diskette.  This
;                         is officially unsupported, and now you get the error
;                         message.  The second part of the bug report was that
;                         you could not DISKCOPY from a 360k to a 1.2M disk,
;                         and this is by design for the same reason.  The third
;                         part of the bug report was that you could not
;                         DISKCOPY from a 320k disk to a 360k disk.  This is
;                         fixed with change ;C04 below.
;            ;C04 MKS     Bug#775 and #723.  DISKCOPY was not allowing a
;                         DISKCOPY from an 8 sector disk to a 9 sector disk.
;                         Now, an 8 sector disk (160k, 320k) will successfully
;                         DISKCOPY to unformatted media, other 8 sector disks,
;                         and 9 sector diskettes.  Obviously, the unformatted
;                         and the 9 sector diskettes will be formatted as they
;                         are copied.
;            D01  SA      Added support for media sensing, for 720K,1.44M,2.88M
;                         media, for 5.00.
;
;            ;C06 MKS     DISKCOPY of a 1.44M diskette without a BPB would
;                         only copy the first 15 sectors per track.  Now it
;                         does all 18.
;
;            ;C07 MKS     DISKCOPY was permitting a diskcopy of a 1.2M diskette
;                         to a 1.44M diskette.  This will be disallowed with
;                         this change.
;
;            ;C08 MKS     Someone changed DISKCOPY for the ENHANCED diskettes,
;                         and in so doing caused some problems.  This should
;                         fix these new problems.  One of the problems was a
;                         divide by zero since the source diskette parameters
;                         were used instead of the target parameters.
;
;            ;C10 MKS     DISKCOPY of a 720K diskette without a BPB would only
;                         copy 40 tracks.  This is all part of the same old
;                         problem that DISKCOPY/DISKCOMP did not work right on
;                         3.5" media.
;
;            4417 PYS     Form Factor = 9 for 2.88 floppies.
;
;            ;C11 MKS     Fixing to understand 2.88M diskettes better.  The
;                         original problem this is fixing is a copy from 2.88M
;                         to a preformatted 720k.  The message "Formatting..."
;                         is displaying, then it errored out, leaving the
;                         720k floppy unreadable.
;
;            ;C12 MKS     Fixing bug#4238,4239.  Errorlevels 3 and 4 weren't
;                         working.
;
; COPYRIGHT: The following notice is found in the OBJ code generated from
;            the "DCOPYSM.SAL" module:

;            "Version 4.00 (C) Copyright 1988 Microsoft"
;            "Licensed Material - Property of Microsoft  "

;PROGRAM AUTHOR: Original written by: JK
;                4.00 modifications by: EMK
;****************** END OF SPECIFICATIONS *****************************
        IF1                             ;
            %OUT    COMPONENT=DISKCOPY, MODULE=DISKCOPY.SAL ;
        ENDIF                           ;

;*****************************************************************************
;                                                                            *
;                            D I S K C O P Y                                 *
;                                                                            *
;  UPDATE HISTORY: 7-31, 8-3, 8-5A, 8-6, 8-7, 8-8, 8-10, 8-11, 8-13, 8-14    *
;                  8-16, 8-17, 8-18, 8-20, 8-28, 9-3, 9-11, 10-6, 10-11      *
;                  11-7,11-12, 11-17, 11-18, 12-19, 2-16-84, 3-27, 4-5, 4-7  *
;                  6-20,7-23,10-31,3-27,4-24                                 *
;                                                                            *
;*****************************************************************************



;*****************************************************************************
;                                                                            *
;                            MACRO DEFINITION                                *
;                                                                            *
;*****************************************************************************

        INCLUDE PATHMAC.INC             ;AN015;PATHGEN MACRO
        INCLUDE DCPYMACR.INC            ;(formerly called MACRO.DEF)
        INCLUDE DISKCOPY.EQU            ;EQUATES
	INCLUDE VERSION.INC

;              $salut (4,16,22,36) ;AN000;
MY_BPB         STRUC               ;
CBYTE_SECT     DW    0             ; 200H  BYTES / SECTOR
CSECT_CLUSTER  DB    0             ; 2h    SECTORS / CLUSTER
CRESEV_SECT    DW    0             ; 1h    RESERVED SECTORS
CFAT           DB    0             ; 2h    # OF FATS
CROOTENTRY     DW    0             ; 70h   # OF ROOT ENTRIES
CTOTSECT       DW    0             ; 02D0h TOTAL # OF SECTORS INCLUDING
                                   ; BOOT SECT, DIRECTORIES ...
MEDIA_DESCRIP  DB    0             ;0FDh   MEDIA DISCRIPTOR
CSECT_FAT      DW    0             ; 2h    SECTORS / FAT
CSECT_TRACK    DW    0             ;
CHEAD          DW    0             ;
CHIDDEN_SECT   DD    0             ;
BIG_TOT_SECT   DD    0             ;
               DB    6 DUP (0)     ;
MY_BPB         ENDS                ;

               INCLUDE BOOTFORM.INC ;AN013;DEFINE EXT_BPB_INFO & EXT_IBMBOOT_HEADER

CSEG           SEGMENT PARA PUBLIC 'CODE' ;AN000;
               ASSUME CS:CSEG, DS:CSEG, ES:CSEG, SS:CSEG ;

;*****************************************************************************
;                                                                            *
;                       EXTERNAL VARIABLES                                   *
;                                                                            *
;*****************************************************************************
;$salut (4,2,9,36)                 ;AN000;
 EXTRN  SYSLOADMSG          :NEAR  ;AN000;SYSTEM MSG HANDLER INTIALIZATION
 EXTRN  SYSDISPMSG          :NEAR  ;AN000;SYSTEM MSG HANDLER DISPLAY

 EXTRN  INIT                :NEAR  ;INITIALIZATION ROUTINE
.XLIST                             ;
;EXTRN  PRINTF              :NEAR  ;MESSAGE DISPLAY ROUTINE
;EXTRN  PROMPT              :NEAR  ;MESSAGE DISPLAY AND KEYBOARD INPUT ROUTINE
;EXTRN  ERROR_MESSAGE       :NEAR  ;ERROR MESSAGE DISPLAY ROUTINE
;EXTRN  MSG_SOURCE_BAD_PTR  :BYTE
;EXTRN  YES                 :BYTE
;EXTRN  NO                  :BYTE
.LIST                              ;
 EXTRN  ASCII_DRV1_ID       :BYTE  ;AN000;SOURCE DRIVE LETTER CHARACTER
 EXTRN  ASCII_DRV2_ID       :BYTE  ;AN000;TARGET DRIVE LETTER CHARACTER
 EXTRN  MSG_TRACKS          :WORD  ;AN000;NUMBER OF TRACKS
 EXTRN  MSG_SECTRK          :WORD  ;AN000;SECTORS PER TRACK
 EXTRN  MSG_SIDES           :WORD  ;AN000;NUMBER OF SIDES
 EXTRN  ERROR_SIDE_NUMBER   :WORD  ;AN000;NUMBER OF SIDES (SUBFIELD OF MSG 19)
 EXTRN  ERROR_TRACK_NUMBER  :WORD  ;AN000;NUMBER OF TRACKS (SUBFIELD OF MSG 19)

 EXTRN  MSGNUM_EXTERR       :WORD  ;AN000;EXTENDED ERROR MSG DESCRIPTOR
 EXTRN  MSGNUM_HARD_ERROR_READ:WORD ;AN000;"Unrecoverable read/write error on drive %1",CR,LF
 EXTRN  MSGNUM_HARD_ERROR_WRITE:WORD ;AN000;"Side %2, track %3" ;
 EXTRN  MSGNUM_LOAD_SOURCE   :WORD ;AC000;"Insert SOURCE diskette in drive %2:"
 EXTRN  MSGNUM_LOAD_TARGET   :WORD ;AC000;"Insert TARGET diskette in drive %2:"
 EXTRN  MSGNUM_TARGET_MB_UNUSABLE :WORD ;AC000;"Target diskette may be unusable"
 EXTRN  MSGNUM_NOT_COMPATIBLE :WORD ;AC000;"Drive types or diskette types",CR,LF
                                   ;"not compatible"
 EXTRN  MSGNUM_BAD_SOURCE  :WORD   ;AC000;"SOURCE diskette bad or incompatible"
 EXTRN  MSGNUM_BAD_TARGET  :WORD   ;AC000;"TARGET diskette bad or incompatible"
 EXTRN  MSGNUM_COPY_ANOTHER :WORD  ;AC000;"Copy another diskette (Y/N)?"
 EXTRN  MSGNUM_FORMATTING  :WORD   ;AC000;"Formatting while copying"
 EXTRN  MSGNUM_GET_READY   :WORD   ;AC000;"Drive not ready - %0"
 EXTRN  MSGNUM_CLOSE_DOOR  :WORD   ;AN004;"Make sure a diskette is inserted into
                                   ; the drive and the door is closed"
 EXTRN  MSGNUM_FATAL_ERROR :WORD   ;AC000;"Copy process ended"
 EXTRN  MSGNUM_UNSUF_MEMORY:WORD   ;AC000;"Insufficient memory"
 EXTRN  MSGNUM_COPYING     :WORD   ;AC000;"Copying %1 tracks",CR,LF
                                   ;"%2 Sectors/Track, %3 Side(s)"
 EXTRN  MSGNUM_STRIKE      :WORD   ;AC000;"Press any key to continue . . ."
 EXTRN  MSGNUM_CORRECT     :WORD   ;"Press any key to continue . . ."      ;C12
 EXTRN  MSGNUM_WRITE_PROTECT :WORD ;AC000;"Attempt to write to write-protected diskette"
 EXTRN  MSGNUM_CR_LF       :WORD   ;AC000;
 EXTRN  MSGNUM_SERNO        :WORD  ;AN001;"VOLUME SERIAL NUMBER IS %1-%0"
 EXTRN  SUBLIST_26A         :WORD  ;AN001;POINTS TO FIRST PART OF SERIAL NUMBER
 EXTRN  SUBLIST_26B         :WORD  ;AN001;POINTS TO SECND PART OF SERIAL NUMBER
 EXTRN  MSGNUM_TARGETTOOSMALL :WORD;D01;"TARGET media has lower capacity than
                                   ;D01;"SOURCE","Continue anyway (Y/N)?"
 EXTRN  MSGNUM_OPTIONS      :WORD  ; options help message

 EXTRN  DRIVE_LETTER       :BYTE   ;AN000;
;*****************************************************************************
;                                                                            *
;                            PUBLIC VARIABLES                                *
;                                                                            *
;*****************************************************************************

 PUBLIC RECOMMENDED_BYTES_SECTOR   ;
 PUBLIC COPY                       ;
 PUBLIC S_OWNER_SAVED              ;
 PUBLIC T_OWNER_SAVED              ;
 PUBLIC SOURCE_DRIVE               ;
 PUBLIC TARGET_DRIVE               ;
 PUBLIC S_DRV_SECT_TRACK           ;
 PUBLIC S_DRV_HEADS                ;
 PUBLIC S_DRV_TRACKS               ;
 PUBLIC T_DRV_SECT_TRACK           ;
 PUBLIC T_DRV_HEADS                ;
 PUBLIC T_DRV_TRACKS               ;
 PUBLIC USER_OPTION                ;
 PUBLIC VERIFY_OPTION              ;
 PUBLIC SHOW_OPTIONS
 PUBLIC COPY_TYPE                  ;
 PUBLIC BUFFER_BEGIN               ;
 PUBLIC BUFFER_END                 ;
 PUBLIC TRACK_TO_READ              ;
 PUBLIC TRACK_TO_WRITE             ;
 PUBLIC SIDE                       ;
 PUBLIC USER_INPUT                 ;
 PUBLIC MAIN_EXIT                  ;

 PUBLIC IO_ERROR                   ;

 PUBLIC DS_IOCTL_DRV_PARM          ;PLACE HOLDER FOR DEFAULT SOURCE DRV PARM
 PUBLIC DT_IOCTL_DRV_PARM          ;PLACE HOLDER FOR DEFAULT TARGET DRV PARM
 PUBLIC DS_specialFunctions        ;AND THEIR CONTENTS
 PUBLIC DT_specialFunctions        ;
 PUBLIC DS_deviceType              ;
 PUBLIC DT_deviceType              ;
 PUBLIC DS_deviceAttributes        ;
 PUBLIC DT_deviceAttributes        ;
 PUBLIC DS_numberOfCylinders       ;
 PUBLIC DT_numberOfCylinders       ;
 PUBLIC DS_mediaType               ;
 PUBLIC DT_mediaType               ;
 PUBLIC DS_BPB_PTR                 ;
 PUBLIC DT_BPB_PTR                 ;

 PUBLIC MS_IOCTL_DRV_PARM          ;DRIVE PARM FROM SOURCE MEDIUM
 PUBLIC MT_IOCTL_DRV_PARM          ;DRIVE PARM FROM TARGET MEDIUM

;*****************************************************************************
 ORG    100H                       ;PROGRAM ENTRY POINT

DISKCOPY:                          ;
 JMP    BEGIN                      ;
;*****************************************************************************

;INTERNAL STACK AREA
 EVEN                              ;AN000;MAKE STACK WORD ALIGNED
 DB     64 DUP ('STACK   ')        ;512 BYTES
MY_STACK_PTR LABEL WORD            ;

;*****************************************************************************
;                                                                            *
;                       INTERNAL VARIABLES                                   *
;                                                                            *
;*****************************************************************************
;                    $salut (4,22,26,36) ;AN000;
; INPUT PARMETERS FROM INIT SUBROUTINE:

S_OWNER_SAVED        DB  0         ;DRIVE LETTER THAT OWNED SOUCE DRIVE OWNERSHIP
T_OWNER_SAVED        DB  0         ;

RECOMMENDED_BYTES_SECTOR DW 0      ;RECOMMENED BYTES/SECTOR FROM DEVICE PARA
SOURCE_DRIVE         DB  0         ;SOURCE DRIVE ID: 1=DRV A, 2=DRV B ETC.
TARGET_DRIVE         DB  0         ;TARGET DRIVE ID
USER_OPTION          DB  0         ;=1 IF /1 OPTION IS ENTERED
VERIFY_OPTION        DB  0         ;=1 IF /V OPTION IS ENTERED
SHOW_OPTIONS         DB  0         ;=1 if /? option is entered
COPY_TYPE            DB  1         ;SINGLE DRV COPY=1, DOUBLE DRIVE COPY=2
BUFFER_BEGIN         DW  1000H     ;BEGINNING OF BUFFER ADDR [IN SEGMENT]
BUFFER_END           DW  3FF0H     ;END OF BUFFER ADDR [IN SEGMENT]
S_DRV_SECT_TRACK     DB  ?         ;SECT/TRACK, device informations.
S_DRV_HEADS          DB  ?         ;# OF HEADS
S_DRV_TRACKS         DW  ?         ;# OF TRACKS
T_DRV_SECT_TRACK     DB  ?         ;
T_DRV_HEADS          DB  ?         ;
T_DRV_TRACKS         DW  ?         ;

;DEFAULT BPB FOR OLD MEDIA
;5.25, 48 TPI BPB SINGLE SIDE (9 SECTORS/TRACK)
BPB48_SINGLE         DW  512       ;BYTES/SECTOR
                     DB  1         ;SECTOR/CLUSTER
                     DW  1         ;# OF RESERVED SECTORS
                     DB  2         ;# OF FATS
                     DW  40h       ;# OF ROOT ENTRY
                     DW  168h      ;TOTAL # OF SECTORS IN THE MEDIA
                     DB  0FCh      ;MEDIA BYTE
                     DW  2         ;SECTORS/FAT

;5.25, 48 TPI BPB DOUBLE SIDE (9 SECTORS/TRACK)
BPB48_DOUBLE         DW  512       ;BYTES/SECTOR
                     DB  2         ;SECTOR/CLUSTER
                     DW  1         ;# OF RESERVED SECTORS
                     DB  2         ;# OF FATS
                     DW  70h       ;# OF ROOT ENTRY
                     DW  2D0h      ;TOTAL # OF SECTORS IN THE MEDIA
                     DB  0FDh      ;MEDIA BYTE
                     DW  2         ;SECTORS/FAT

;5.25, 96 TPI BPB DOUBLE SIDE (15 SECTORS/TRACK)
BPB96                DW  512       ;BYTES/SECTOR
                     DB  1         ;SECTOR/CLUSTER
                     DW  1         ;# OF RESERVED SECTORS
                     DB  2         ;# OF FATS
                     DW  0E0h      ;# OF ROOT ENTRY
                     DW  960h      ;TOTAL # OF SECTORS IN THE MEDIA
                     DB  0F9h      ;MEDIA BYTE
                     DW  7         ;SECTORS/FAT
BPB96_LENG           EQU $-BPB96   ;THIS LENGTH WILL BE USED FOR BPB48 ALSO.

                                   ;This table holds the total #sectors    ;D01
                                   ;for the indicated media.  It is indexed;D01
                                   ;by the value returned by the media     ;D01
                                   ;sensing function.                      ;D01
MediaTable      LABEL WORD                                                 ;D01
                                                                           ;D01
        dw      00                      ; 0                                ;D01
        dw      00                      ; 1                                ;D01
        dw      2*9*80                  ; 2  (720K)                        ;D01
        dw      00                      ; 3                                ;D01
        dw      00                      ; 4                                ;D01
        dw      00                      ; 5                                ;D01
        dw      00                      ; 6                                ;D01
        dw      2*18*80                 ; 7  (1.44M)                       ;D01
        dw      00                      ; 8                                ;4417
        dw      2*36*80                 ; 9  (2.88M)                       ;4417
                                                                           ;D01
EndMediaTable   LABEL WORD                                                 ;D01

A_MEDIA_SENSE   STRUC                   ; Media sense structure added 5.00 ;D01
MS_ISDEFAULT            DB      ?       ; If 1 type returned is drv default;D01
MS_DEVMEDIATYPE         DB      ?       ; Drive type                       ;D01
MS_RESERVED1            DB      ?       ; RESERVED                         ;D01
MS_RESERVED2            DB      ?       ; RESERVED                         ;D01
A_MEDIA_SENSE   ENDS                                                       ;D01

;                       LOCAL VARIABLES:
VOLSER_FLAG          DB  0         ;AN000;0=EITHER MEDIA NOT READ YET, OR
;                                   SOURCE VOL SER ID NOT AVAILABLE
;                                   1=TARGET NEEDS VOL SER WRITTEN
SERIAL               DD  0         ;AN013;SERIAL NUMBER OF NEW DISKETTE
EXITFL               DB  EXOK      ;AN000;ERRORLEVEL VALUE
                     PUBLIC EXITFL ;AN000;
                     PUBLIC EXPAR  ;AN000;
;C12 EXCBR                EQU 2         ;AN000;CONTROL BREAK
;C12 EXVER                EQU 1         ;AN000;BAD DOS VERSION ERRORLEVEL CODE
;C12 EXPAR                EQU 1         ;AN000; BAD PARMS, OR OTHER ERRORS
EXOK                 EQU 0         ;AN000;NORMAL ERRORLEVEL RET CODE
EX_RW_ERROR          EQU 1         ;ERRORLEVEL - READ/WRITE ERROR          ;C12
EX_HARD_ERROR        EQU 3         ;ERRORLEVEL - HARD ERROR OCCURRED       ;C12
EXCBR                EQU 2         ;ERRORLEVEL - CTRL+C REQUESTED          ;C12
EX_INIT_ERROR        EQU 4         ;ERRORLEVEL - ERROR DURING INIT         ;C12
EXVER                EQU 4         ;ERRORLEVEL - ERROR DURING INIT(DOSVER) ;C12
EXPAR                EQU 4         ;ERRORLEVEL - ERROR DURING INIT(PARSE)  ;C12

S_DRV_SET_FLAG       DB  0         ;1 = SOURCE DRIVE PARM HAD BEEN SET
T_DRV_SET_FLAG       DB  0         ;1 = TARGET DRIVE PARM HAD BEEN SET

IOCTL_SECTOR         DW  1         ;used for READ_A_SECTOR routine.
IOCTL_TRACK          DW  0         ;IN THE TRACK
IOCTL_HEAD           DW  0         ;HEAD 0
SAV_CSECT            DW  0         ;TEMPORARY SAVING PLACE
SAV_CN1              DW  0         ;
SAV_CB1              DW  0         ;
SAV_CYLN             DW  0         ;

BOOT_SECT_TRACK      DW  0         ;TEMP SAVING PLACE OF SECTOR/TRACK
BOOT_TOT_TRACK       DW  0         ;FOUND FROM THE BOOT SECTOR. max # of tracks
BOOT_NUM_HEAD        DW  0         ;NUMBER OF HEADS
BOOT_BYTE_SECTOR     DW  0         ;BYTES / SECTOR

READ_S_BPB_FAILURE   DB  0         ;GET MEDIA BPB. SUCCESS=0, FAILURE=1
READ_T_BPB_FAILURE   DB  0         ;

;*** Informations from CHECK_SOURCE.
;*** These will be used as a basis for the copy process.
LAST_TRACK           DW  79        ;LAST CYLINDER OF THE DASD (39 OR 79)
END_OF_TRACK         DB  15        ;END OF TRACK, 8,9 OR 15 CURRENTLY.
bSECTOR_SIZE         DW  512       ;BYTES/SECTOR in bytes
NO_OF_SIDES          DB  ?         ;0=SINGLE SIDED, 1=DOUBLE SIDED

FORMAT_FLAG          DB  0         ;(ON/OFF) FORMAT BEFORE WRITE IF TURNED ON
TRACK_TO_READ        DW  0         ;NEXT TRACK TO READ
TRACK_TO_WRITE       DW  0         ;NEXT TRACK TO WRITE
TRACK_TO_FORMAT      DW  0         ;STARTS FORMAT WITH THIS TRACK
                                   ; TO THE LAST TRACK
TRACK_SIZE           DW  ?         ;BYTES/CYLINDER [IN SEGMENTS]
SECTOR_SIZE          DB  ?         ;BYTES/SECTOR [IN SEGMENTS]
BUFFER_PTR           DW  ?         ;BUFFER POINTER FOR READ/WRITE OP
COPY_ERROR           DB  0         ;=0 IF NO ERROR, >0 IF ERROR DETECTED
SIDE                 DB  ?         ;NEXT SIDE TO READ/WRITE (0,1)
SIDE_TO_FORMAT       DB  0         ;NEXT SIDE TO FORMAT (0, 1)
OPERATION            DB  ?         ;READ/WRITE/VERIFY OPERATION
COPY_STATUS          DB  ?         ;(OK OR FATAL) ABORT COPY PROCESS IF FATAL
USER_INPUT           DB  ?         ;DISKCOPY AGAIN?
IO_ERROR             DB  0         ;SET BY EXTENDED_ERROR_HANDLER
UKM_ERR              DB  0         ;AN011;IF ON, HARD ERROR IS TYPE: "UNKNOWN MEDIA"
MSG_FLAG             DB  ?         ;USED TO INDICATE IF READ/WRITE ERROR MESSAGE
                                   ;IS TO BE DISPLAYED (ON/OFF)
TARGET_OP            DB  0         ;FLAG TO INDICATE ANY OPERATIONS ON TARGET
TRY_FORMAT_FLAG      DB  0         ;FLAG TO INDICATE "TRY_FORMAT" PROCEDURE TO
                                   ; CHECK THE "TIME OUT ERROR"
TIME_OUT_FLAG        DB  0         ;FLAG TO INDICATE THE "TIME OUT" ERROR
                                   ; WAS A REAL "TIME OUT ERROR"
SELECT_FLAG          DB  0         ;INDICATES SELECT IS PRESENT

MediaSensePacket     A_MEDIA_SENSE      <>      ;Structure for media sensing function;D01

                     PAGE          ;
;                   DEVICE PARAMETER TABLE
;the returned info. still has the following format.

DS_IOCTL_DRV_PARM    LABEL BYTE    ;PLACE HOLDER FOR DEFAULT TARGET DRV PARM
DS_specialFunctions  db  ?         ;
DS_deviceType        db  ?         ;0 - 5.25"(48tpi), 1 - 5.25"(96tpi),
                                   ; 2 - 3.5"(720KB)
DS_deviceAttributes  dw  ?         ;0001h - NOT REMOVABLE,
                                   ; 0002h - CHANGE LINE SUPPORTED
DS_numberOfCylinders dw  ?         ;
DS_mediaType         db  ?         ;
DS_BPB_PTR           LABEL BYTE    ;
DS_deviceBPB         my_bpb <>     ;
DS_trackLayout       LABEL WORD    ;AC000;
                     my_trackLayout ;AC000;
;---------------------------------------

DT_IOCTL_DRV_PARM    LABEL BYTE    ;
DT_specialFunctions  db  ?         ;
DT_deviceType        db  ?         ;
DT_deviceAttributes  dw  ?         ;0001h - NOT REMOVABLE,
                                   ; 0002h - CHANGE LINE SUPPORTED
DT_numberOfCylinders dw  ?         ;
DT_mediaType         db  ?         ;
DT_BPB_PTR           LABEL BYTE    ;
DT_deviceBPB         my_bpb <>     ;
DT_trackLayout       LABEL WORD    ;AC000;
                     my_trackLayout ;AC000;

;---------------------------------------

MS_IOCTL_DRV_PARM    LABEL BYTE    ;DRIVE PARM FROM SOURCE MEDIUM
MS_specialFunctions  db  ?         ;
MS_deviceType        db  ?         ;
MS_deviceAttributes  dw  ?         ;0001h - NOT REMOVABLE,
                                   ; 0002h - CHANGE LINE SUPPORTED
MS_numberOfCylinders dw  ?         ;
MS_mediaType         db  ?         ;
MS_BPB_PTR           LABEL BYTE    ;
MS_deviceBPB         my_bpb <>     ;
MS_deviceBPB_leng    equ $-MS_deviceBPB ;
MS_trackLayout       LABEL WORD    ;AC000;
                     my_trackLayout ;AC000;
;---------------------------------------
MT_IOCTL_DRV_PARM    LABEL BYTE    ;DRIVE PARM FROM TARGET MEDIUM
MT_specialFunctions  db  ?         ;
MT_deviceType        db  ?         ;
MT_deviceAttributes  dw  ?         ;0001h - NOT REMOVABLE,
                                   ; 0002h - CHANGE LINE SUPPORTED
MT_numberOfCylinders dw  ?         ;
MT_mediaType         db  ?         ;
MT_BPB_PTR           LABEL BYTE    ;
MT_deviceBPB         my_bpb <>     ;
MT_trackLayout       LABEL WORD    ;AC000;
                     my_trackLayout ;AC000;


;               IOCTL  format a track function control string.
IOCTL_FORMAT         LABEL BYTE    ;
FspecialFunctions    db  0         ;
FHead                dw  ?         ;
FCylinder            dw  ?         ;

;               IOCTL read/write a track.
IOCTL_R_W            LABEL BYTE    ;
specialFunctions     db  0         ;
Head                 dw  ?         ;
Cylinder             dw  ?         ;
FirstSectors         dw  ?         ;
numberOfSectors      dw  ?         ;
TAddress_off         dw  ?         ;
TAddress_seg         dw  ?         ;
;  =  =  =  =  =  =  =  =  =  =  =  =
;               GET/SET MEDIA ID - FUNCTION OF GENERIC IOCTL
;                       (USED BY VOLSER PROC)
;(Deleted ;AN013;) MEDIA_ID_BUF A_MEDIA_ID_INFO <> ;                            ;AN000;
;  =  =  =  =  =  =  =  =  =  =  =  =
                     PATHLABL DISKCOPY ;AN015;
                     HEADER <BEGIN - VERSION CHECK, SYSMSG INIT, EXIT TO DOS> ;AN000;
                     PUBLIC DISKCOPY_BEGIN ;
DISKCOPY_BEGIN       LABEL NEAR    ;

;*****************************************************************************
;                                                                            *
;                D I S K C O P Y   M A I N   P R O G R A M                   *
;                                                                            *
;*****************************************************************************
;  $salut (4,4,10,36)              ;AN000;
BEGIN PROC NEAR                    ;
   PUBLIC BEGIN                    ;AN000;
;OUTPUT - "EXITFL" HAS ERRORLEVEL RETURN CODE

   MOV   SP, OFFSET MY_STACK_PTR   ;MOVE SP TO MY STACK PTR
   CALL  SYSLOADMSG                ;AN000;INIT SYSMSG HANDLER

;  $IF   C                         ;AN000;IF THERE WAS A PROBLEM
   JNC $$IF1
       CALL  SYSDISPMSG            ;AN000;LET HIM SAY WHY HE HAD A PROBLEM

       MOV   EXITFL,EXVER          ;AN000;TELL ERRORLEVEL BAD DOS VERSION
;  $ELSE                           ;AN000;SINCE SYSDISPMSG IS HAPPY
   JMP SHORT $$EN1
$$IF1:
       CALL  INIT                  ;RUN INITIALIZATION ROUTINE
       MOV   EXITFL, 0             ; ASSUME NO ERROR
       CMP   DX, offset MSGNUM_OPTIONS ; OPTIONS MSG SENT?
       JE    EXIT_TO_DOS           ; EXIT NOW IF SO

       CMP   DX,FINE               ;CHECK FOR ERROR DURING INIT
;      $IF   E                     ;IF NO ERROR THEN PROCEED TO COPY
       JNE $$IF3
;          $DO                     ;
$$DO4:
               MOV   EXITFL,EXOK   ;Reset errorlevel                       ;C12
               CALL  COPY          ;PERFORM DISKCOPY

               CALL  TEST_REPEAT   ;COPY ANOTHER ?

;          $ENDDO C                ;
           JNC $$DO4
                                   ;NORMAL RETURN CODE ALREADY IN "EXITFL"
;      $ELSE                       ;ELSE IF ERROR DETECTED IN INIT
       JMP SHORT $$EN3
$$IF3:
.XLIST                             ;
;      PUSH  DX
;      PUSH  CS
;      CALL  PRINTF                ;DISPLAY ERROR MESSAGE
.LIST                              ;
           MOV   DI,DX             ;PASS NUMBER OF ERROR MSG, IF ANY            ;AD000;
                                   ;DI HAS OFFSET OF MESSAGE DESCRIPTOR
           CALL  SENDMSG           ;AC000;DISPLAY THE ERROR MESSAGE

           MOV   EXITFL,EXVER      ;AC000;ERROR RETURN CODE
;      $ENDIF                      ;
$$EN3:
       JMP   SHORT EXIT_TO_DOS     ;

MAIN_EXIT:                         ;COME HERE AFTER CONTROL-BREAK
       MOV   EXITFL,EXCBR          ;AC000;  FOR CONTROL-BREAK EXIT

EXIT_TO_DOS:                       ;
       XOR   BX, BX                ;

       MOV   BL, S_OWNER_SAVED     ;RESTORE ORIGINAL SOURCE,
                                   ; TARGET DRIVE OWNER.
       CALL  SET_LOGICAL_DRIVE     ;

       MOV   BL, T_OWNER_SAVED     ;
       CALL  SET_LOGICAL_DRIVE     ;

       CMP   S_DRV_SET_FLAG, 0     ;
;      $IF   NE                    ;AN000;
       JE $$IF8
           MOV   BL, SOURCE_DRIVE  ;
           MOV   DS_specialFunctions, SET_SP_FUNC_DOS ;=0
           MOV   DX, OFFSET DS_IOCTL_DRV_PARM ;
           CALL  SET_DRV_PARM_DEF  ;RESTORE SOURCE DRIVE PARM

;      $ENDIF                      ;AN000;
$$IF8:

       CMP   T_DRV_SET_FLAG, 0     ;
;      $IF   NE                    ;AN000;
       JE $$IF10
           MOV   BL, TARGET_DRIVE  ;
           MOV   DT_specialFunctions, SET_SP_FUNC_DOS ;=0
           MOV   DX, OFFSET DT_IOCTL_DRV_PARM ;
           CALL  SET_DRV_PARM_DEF  ;RESTORE TARGET DRIVE PARM

;      $ENDIF                      ;AN000;
$$IF10:
EXIT_PROGRAM:                      ;

;  $ENDIF                          ;AN000;OK WITH SYSDISPMSG?
$$EN1:
   MOV   AL,EXITFL                 ;AN000;PASS BACK ERRORLEVEL RET CODE
   DOSCALL RET_CD_EXIT             ;AN000;RETURN TO DOS WITH RET CODE

   INT   20H                       ;AN000;IF ABOVE NOT WORK,
BEGIN ENDP                         ;AN000;
; = = = = = = = = = = = = = = = = =
   HEADER <SET_LOGICAL_DRIVE - SET LOG. DRV LETTER THAT OWNS DRIVE> ;AN000;
   PUBLIC SET_LOGICAL_DRIVE        ;
;*****************************************************************************
SET_LOGICAL_DRIVE PROC NEAR        ;
;       *** SET THE LOGICAL DRIVE LETTER THAT WILL BE THE OWNER OF THE DRIVE
;       INPUT: BL - DRIVE LETTER
;       OUTPUT: OWNER WILL BE SET ACCORDINGLY.
;*****************************************************************************
   CMP   BL, 0                     ;
;  $IF   NE                        ;IF BL = 0, THEN JUST RETURN
   JE $$IF13
                                   ;ELSE SET BL AS AN OWNER OF THAT DRIVE
       MOV   AX,(IOCTL_FUNC SHL 8)+SET_LOGIC_DRIVE ;AC000;
       INT   21H                   ;
;  $ENDIF                          ;
$$IF13:
   RET                             ;
SET_LOGICAL_DRIVE ENDP             ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <COPY - COPY THE DISKETTE IMAGE> ;AN000;
;*****************************************************************************
;MODULE NAME:  COPY                                                          *
;                                                                            *
;      INPUT:  COPY_TYPE  BYTE  1=SINGLE DRIVE COPY                          *
;                               2=DOUBLE DRIVE COPY                          *
;                                                                            *
;     OUTPUT:  NONE                                                          *
;*****************************************************************************
COPY PROC NEAR                     ;COPY DISKETTE IMAGE
   MOV   VOLSER_FLAG,0             ;AN000;RESET MEDIA ID VOL SERIAL NUMBER FLAG
   MOV   COPY_ERROR,0              ;RESET COPY ERROR FLAG
   MOV   COPY_STATUS,OK            ;RESET COPY STATUS BYTE
   MOV   TARGET_OP, OFF            ;
   MOV   TRY_FORMAT_FLAG, OFF      ;
   MOV   TIME_OUT_FLAG, OFF        ;
   MOV   FORMAT_FLAG,OFF           ;ASSUME FORMAT IS NOT REQUIRED
   MOV   READ_S_BPB_FAILURE, 0     ;RESET GET BPB FAILURE FLAG
   MOV   READ_T_BPB_FAILURE, 0     ;
   MOV   AX, RECOMMENDED_BYTES_SECTOR ;
   MOV   bSECTOR_SIZE, AX          ;USE RECOMMENDED SECTOR SIZE TO READ A SECTOR
   CMP   COPY_TYPE,2               ;IF TWO DRIVE COPY
;  $IF   E                         ;
   JNE $$IF15
       PRINT MSGNUM_LOAD_SOURCE    ;AC000;OUTPUT LOAD SOURCE DISKETTE MESSAGE
                                   ;"INSERT SOURCE DISKETTE INTO DRIVE X:"

       PRINT MSGNUM_LOAD_TARGET    ;AC000;"INSERT TARGET DISKETTE INTO DRIVE X:"

       CALL  PRESS_ANY_KEY         ;AC000;"PRESS ANY KEY TO CONTINUE" (WAIT FOR KEYB)

;  $ENDIF                          ;
$$IF15:
   MOV   TRACK_TO_READ,0           ;INITIALIZE TRACK NUMBERS
   MOV   TRACK_TO_WRITE,0          ;

COPY_TEST_END:                     ;
;  $SEARCH                         ;
$$DO17:
       MOV   AX,TRACK_TO_WRITE     ;WHILE TRACK_TO_WRITE<=LAST_TRACK
       CMP   AX,LAST_TRACK         ;
;  $LEAVE A                        ;
   JA $$EN17
       CALL  READ_SOURCE           ;READ AS MANY TRACK AS POSSIBLE

       CMP   COPY_STATUS,FATAL     ;MAKE SURE DRIVES WERE COMPATIBLE
;  $EXITIF E,NUL,OR                ;
   JE $$SR17
       CALL  WRITE_TARGET          ;WRITE THE CONTENT OF BUFFER TO TARGET

       CMP   COPY_STATUS,FATAL     ;MAKE SURE TARGET AND SOURCE
;  $EXITIF E,NUL                   ;
   JE $$SR17
;  $ENDLOOP                        ;
   JMP SHORT $$DO17
$$EN17:

       CMP   COPY_ERROR,FALSE      ;IF ERROR IN COPY
;      $IF   NE                    ;
       JE $$IF21
                                   ;CR,LF,"Target diskette may be unusable",CR,LF
           PRINT MSGNUM_TARGET_MB_UNUSABLE ;AC000;

;      $ENDIF                      ;
$$IF21:
;  $ENDSRCH                        ;
$$SR17:
   CMP   COPY_STATUS,FATAL         ;WAS COPY ABORTED ?
;  $IF   E                         ;
   JNE $$IF24
                                   ;CR,LF,"Copy process ended",CR,LF
       PRINT MSGNUM_FATAL_ERROR    ;AC000;IF SO THEN TELL USER
       CMP EXITFL,EXOK             ;Q: Was there already an error          ;C12
       JNZ $$EN24                  ; Y: then save that error               ;C12
       MOV EXITFL,EX_RW_ERROR      ; N: then force an errorlevel           ;C12

;  $ELSE                           ;AN000;SINCE NOT ABORTED,
   JMP SHORT $$EN24
$$IF24:
       CALL  WRITE_VOLSER          ;AN000;GO CHANGE VOLID OF TARGET

;  $ENDIF                          ;
$$EN24:
   RET                             ;

COPY ENDP                          ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <TEST_REPEAT - SEE IF USER WANTS TO COPY ANOTHER> ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC TEST_REPEAT              ;AN000;MAKE ENTRY IN LINK MAP
TEST_REPEAT PROC NEAR              ;TEST IF USER WANTS TO COPY ANOTHER          *
;                                DISKETTE                                    *
; INPUT : USER_INPUT ("Y" OR "N")
; OUTPUT: NC = COPY AGAIN                                                    *
;         CY = EXIT TO DOS                                                   *
;*****************************************************************************
;  $SEARCH COMPLEX                 ;AC000;REPEAT THIS PROMPT UNTIL (Y/N) RESPONDED
   JMP SHORT $$SS27
$$DO27:
       PRINT MSGNUM_CR_LF          ;AC000;

;  $STRTSRCH                       ;AN000;
$$SS27:
                                   ;CR,LF,"Copy another diskette (Y/N)?"
       PRINT MSGNUM_COPY_ANOTHER   ;AC000;SEE IF USER WANTS TO COPY ANOTHER
                                   ; AND READ RESPONSE TO AL
       PUSH  AX                    ;AN000;SAVE THE RESPONSE
       PRINT MSGNUM_CR_LF          ;AC000;

       POP   DX                    ;AN000;RESTORE THE REPONSE CHAR TO DL
       CALL  YESNO                 ;AN000;CHECK FOR (Y/N)
                                   ;AX=0,NO; AX=1,YES; AX=2,INVALID
;  $EXITIF C,NUL                   ;AN000;IF CARRY SET, PROBLEM,PRETEND "NO"
   JC $$SR27

       CMP   AX,BAD_YESNO          ;AN000;WAS THE RESPONSE INVALID?
;  $ENDLOOP B                      ;AN000;QUIT IF OK ANSWER (AX=0 OR 1)
   JNB $$DO27
       CMP   AL,YES                ;AN000;WAS "YES" SPECIFIED
;      $IF   E                     ;AN000;IF "YES"
       JNE $$IF31
           CLC                     ;AN000;CLEAR CARRY TO INDICATE COPY AGAIN
;      $ELSE                       ;AN000;SINCE NOT "YES"
       JMP SHORT $$EN31
$$IF31:
           STC                     ;AN000;SET CARRY TO INDICATE NO REPEAT
;      $ENDIF                      ;AN000;
$$EN31:
;  $ENDSRCH                        ;AN000;
$$SR27:
.XLIST                             ;
;       MOV   AL,USER_INPUT
;       AND   AL,11011111B          ;MAKE USER INPUT UPPER CASE
;       CMP   AL,YES                ;IF YES THEN COPY AGAIN
;   $EXITIF E
;       CLC                         ;CLEAR CARRY TO INDICATE COPY AGAIN
;   $ORELSE
;       CMP   AL,NO                 ;IF NOT "N" OR "Y" THEN PROMPT AGAIN
;   $ENDLOOP E
;       STC                         ;SET CARRY TO INDICATE NO REPEAT
;   $ENDSRCH
.LIST                              ;
   RET                             ;

TEST_REPEAT ENDP                   ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <READ_SOURCE - READ FROM SOURCE AS MUCH AS POSSIBLE> ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC READ_SOURCE              ;AN000;MAKE ENTRY IN LINK MAP                   *
READ_SOURCE PROC NEAR              ;READ AS MANY TRACKS AS POSSIBLE FROM SOURCE*
;                           ;DISKETTE TO FILL THE AVAILABLE BUFFER SPACE     *
;*****************************************************************************

   CMP   COPY_TYPE,1               ;IF SINGLE DRIVE COPY
;  $IF   E                         ;PROMPT MSG
   JNE $$IF35
       PRINT MSGNUM_LOAD_SOURCE    ;AN000;"INSERT SOURCE DISKETTE INTO DRIVE X:"

       CALL  PRESS_ANY_KEY         ;AC000;"PRESS ANY KEY TO CONTINUE" (WAIT FOR KEYB)

;  $ENDIF                          ;
$$IF35:
   CMP   TRACK_TO_READ,0           ;1ST TRACK ?
;  $IF   NE,OR                     ;IF NOT
   JNE $$LL37

   CALL  CHECK_SOURCE              ;DO NECESSARY CHECKING

   CALL  CALC_TRACK_SIZE           ;

   CALL  CHECK_MEMORY_SIZE         ;

   CMP   COPY_STATUS,FATAL         ;
;  $IF   NE                        ;
   JE $$IF37
$$LL37:
;(deleted ;AN013;) CALL  READ_VOLSER ;GO READ THE MEDIA ID TO GET SERIAL NUMBER ;AN000;

       MOV   BX,BUFFER_BEGIN       ;
       MOV   BUFFER_PTR,BX         ;INITIALIZE BUFFER POINTER

;      $DO                         ;
$$DO38:
           MOV   AX,TRACK_TO_READ  ;DID WE FINISH READING ALL TRACKS?
           CMP   AX,LAST_TRACK     ;
;      $LEAVE A                    ;
       JA $$EN38
           MOV   AX,BUFFER_PTR     ;DID WE RUN OUT OF BUFFER SPACE
           ADD   AX,TRACK_SIZE     ;
           CMP   AX,BUFFER_END     ;
;      $LEAVE A                    ;
       JA $$EN38
           MOV   OPERATION,READ_FUNC ;
           CALL  READ_WRITE_TRACK  ;NO, GO READ ANOTHER TRACK

           INC   TRACK_TO_READ     ;
;      $ENDDO                      ;
       JMP SHORT $$DO38
$$EN38:
;  $ENDIF                          ;
$$IF37:
   RET                             ;
READ_SOURCE ENDP                   ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <WRITE_TARGET - WRITE DATA FROM MEMORY TO TARGET DISKETTE> ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC WRITE_TARGET             ;AN000;MAKE ENTRY IN LINK MAP
WRITE_TARGET PROC                  ;WRITE DATA FROM MEMORY TO TARGET DISKETTE*
;                                                                            *
;*****************************************************************************

   CMP   COPY_TYPE,1               ;IF SINGLE DRIVE COPY
;  $IF   E                         ;PROMPT MSG
   JNE $$IF43
       PRINT MSGNUM_LOAD_TARGET    ;AC000;"INSERT TARGET DISKETTE INTO DRIVE X:"

       CALL  PRESS_ANY_KEY         ;AC000;"PRESS ANY KEY TO CONTINUE" (WAIT FOR KEYB)

;  $ENDIF                          ;
$$IF43:
   MOV   TARGET_OP, ON             ;INDICATE A OPERATION ON TARGET
   MOV   BX,BUFFER_BEGIN           ;
   MOV   BUFFER_PTR,BX             ;INITIALIZE BUFFER POINTER
   CMP   TRACK_TO_WRITE,0          ;IF TRK 0, CHECK COMPATIBILITY
;  $IF   NE,OR                     ;
   JNE $$LL45

   MOV   SIDE, 0                   ;
   CALL  CHECK_TARGET              ;

   CMP   COPY_STATUS,FATAL         ;IF INCOMPATIBLE, THEN EXIT
;  $IF   NE                        ;
   JE $$IF45
$$LL45:

;      $DO                         ;
$$DO46:
           MOV   AX,TRACK_TO_WRITE ;DID WE FINISH WRITING ALL TRACKS?
           CMP   AX,LAST_TRACK     ;
;      $LEAVE A                    ;
       JA $$EN46
           MOV   AX,BUFFER_PTR     ;DID WE RUN OUT OF BUFFER SPACE
           ADD   AX,TRACK_SIZE     ;
           CMP   AX,BUFFER_END     ;
;      $LEAVE A                    ;
       JA $$EN46
           MOV   OPERATION,WRITE_FUNC ;
           CALL  READ_WRITE_TRACK  ;NO, GO WRITE ANOTHER TRACK

           CMP   COPY_STATUS,FATAL ;IF INCOMPATIBLE, THEN EXIT
;      $LEAVE E                    ;
       JE $$EN46
           INC   TRACK_TO_WRITE    ;
;      $ENDDO                      ;
       JMP SHORT $$DO46
$$EN46:
;  $ENDIF                          ;
$$IF45:
   MOV   TARGET_OP, OFF            ;
   RET                             ;
WRITE_TARGET ENDP                  ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <READ_WRITE_TRACK - READ A TRACK AND STORE IT INTO MEMORY> ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC READ_WRITE_TRACK         ;AN000;MAKE ENTRY IN LINK MAP
READ_WRITE_TRACK PROC NEAR         ;READ A TRACK AND STORE IT INTO MEMORY   *
;                                                                            *
;INPUT:  OPERATION = 61h THEN READ OPERATION                                 *
;                    41h THEN WRITE OPERATION                                *
;*****************************************************************************

   MOV   SIDE, 0                   ;
;  $DO                             ;
$$DO52:
       MOV   MSG_FLAG, ON          ;
       CMP   OPERATION, READ_FUNC  ;
;      $IF   E                     ;
       JNE $$IF53
           CALL  READ_OP           ;

;      $ELSE                       ;
       JMP SHORT $$EN53
$$IF53:
           CALL  WRITE_OP          ;

           CMP   COPY_STATUS, FATAL ;
           JE    RWT_EXIT          ;

;      $ENDIF                      ;
$$EN53:

	XOR	DX, DX		; The old code was
	MOV	AX, TRACK_SIZE	; assuming there is either 1 head or 2.

	MOV	CL, NO_OF_SIDES
	XOR	CH, CH
	INC	CX	       	; 0 based

	DIV	CX

       ADD   BUFFER_PTR, AX        ;
       INC   SIDE                  ;NEXT SIDE
       MOV   AL, SIDE              ;
       CMP   AL, NO_OF_SIDES       ;FINISHED WITH THE LAST SIDE?
;  $ENDDO G                        ;
   JNG $$DO52
RWT_EXIT:                          ;
   RET                             ;
READ_WRITE_TRACK ENDP              ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <READ_OP - IOCTL READ A TRACK OPERATION> ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC READ_OP                  ;AN000;MAKE ENTRY IN LINK MAP
READ_OP PROC NEAR                  ;IOCTL READ A TRACK OPERATION        *
;                                                                            *
;*****************************************************************************

;  $SEARCH                         ;
$$DO60:
       XOR   AX, AX                ;
       MOV   AL, SIDE              ;
       MOV   Head, AX              ;HEAD TO READ
       MOV   AX, TRACK_TO_READ     ;
       MOV   Cylinder, AX          ;TRACK TO READ
       MOV   FirstSectors, 0       ;???? SHOULD BE 1 BUT CURRENTLY 0 ???
       MOV   AX, BUFFER_PTR        ;
       MOV   Taddress_seg, AX      ;BUFFER ADDRESS
       MOV   Taddress_off, 0       ;
       XOR   BX, BX                ;
       MOV   BL, SOURCE_DRIVE      ;
       MOV   CL, READ_FUNC         ;=61h
       MOV   DX, OFFSET IOCTL_R_W  ;
       CALL  GENERIC_IOCTL         ;

       CMP   IO_ERROR, NO_ERROR    ;OK?
;  $EXITIF E                       ;AC013;IF NO ERROR SO FAR, GOOD
   JNE $$IF60
       CMP   CYLINDER,0            ;AN013;IS THIS THE FIRST READ?
;      $IF   E,AND                 ;AN013;IF THIS IS THE FIRST TRACK, AND
       JNE $$IF62
       CMP   HEAD,0                ;AN013;IS THIS THE FIRST SIDE?
;      $IF   E                     ;AN013;AND IF THIS IS THE FIRST SIDE
       JNE $$IF62
           CALL  MAYBE_ADJUST_SERIAL ;AN013;IF BOOT HAS SERIAL, GENERATE NEW ONE

;      $ENDIF                      ;AN013;FIRST TRACK AND HEAD?
$$IF62:
;  $ORELSE                         ;AN013;SINCE SOME KIND OF ERROR, OOPS
   JMP SHORT $$SR60
$$IF60:
       CMP   IO_ERROR, SOFT_ERROR  ;TRY AGAIN?
;  $ENDLOOP NE                     ;
   JE $$DO60

       CMP   MSG_FLAG, ON          ;ELSE HARD ERROR. SEE IF
                                   ; MESSAGE TO BE DISPLAYED
;      $IF   E                     ;
       JNE $$IF66

           MOV   AH, READ_FUNC     ;
           mov   dl, source_drive  ;
           CALL  ERROR_MESSAGE     ;

           INC   COPY_ERROR        ;INCREASE COPY_ERROR COUNT
           MOV   MSG_FLAG, OFF     ;
;      $ENDIF                      ;
$$IF66:
;  $ENDSRCH                        ;
$$SR60:
   RET                             ;
READ_OP ENDP                       ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <MAYBE_ADJUST_SERIAL - MAKE NEW SERIAL IN BOOT> ;AN013;
MAYBE_ADJUST_SERIAL PROC NEAR      ;AN013;
;INPUT: TADDRESS_OFF/_SEG HAS TRACK BUFFER WHICH HAS BOOT RECORD
;       "VOLSER_FLAG" IS FALSE.
;OUTPUT:SERIAL NUMBER FIELD IS MODIFIED TO HAVE NEW SERIAL NUMBER
;       A COPY OF WHICH IS PRESERVED IN "SERIAL" FOR LATER DISPLAY IN MSG.
;       "VOLSER_FLAG" SET TO TRUE TO INDICATE NEW SERIAL GENERATED.
;       IF THIS BOOT DOES NOT HAVE A SERIAL, NO CHANGE MADE, AND
;       "VOLSER_FLAG" LEFT AS FALSE.

;       A BOOT RECORD IS ASSUMED TO HAVE A SERIAL NUMBER IF:
;       EBPB_MEDIADESCRIPTOR=0F?H AND EXT_BOOT_SIG IS EITHER 28H OR 29H.

   PUSH  ES                        ;AN013;SAVE EXTRA SEG REG TEMPORARILY
   PUSH  BX                        ;AN013;AND SAVE THE BASE POINTER
   PUSH  SI                        ;AN013; AND THE INDEX
   LES   BX,DWORD PTR TADDRESS_OFF ;AN013;POINT TO BUFFER AREA CONTAINING BOOT RECORD
   LEA   SI,ES:[BX].EXT_BOOT_BPB   ;AN013;POINT TO BPB PORTION OF BOOT RECORD
   MOV   AL,ES:[SI].EBPB_MEDIADESCRIPTOR ;AN013;GET TYPE OF MEDIA
   AND   AL,0F0H                   ;AN013;SAVE LEFT NIBBLE ONLY
   CMP   AL,0F0H                   ;AN013;IF DISKETTE HAS PROPER DESCRIPTOR
;  $IF   E                         ;AN013;IF OK DESCRIPTOR
   JNE $$IF69
       MOV   AL,ES:[BX].EXT_BOOT_SIG ;AN013;GET "SIGNATURE" OF BOOT RECORD
       CMP   AL,28H                ;AN013;IS THIS BOOT STYLE OF OS/2 1.0 OR 1.1?
;      $IF   E,OR                  ;AN013;YES, IS A BOOT WITH A SERIAL IN IT
       JE $$LL70
       CMP   AL,29H                ;AN013;IS THIS A BOOT STYLE OF OS/S 1.2?
;      $IF   E                     ;AN013;YES, IS A BOOT WITH A SERIAL IN IT
       JNE $$IF70
$$LL70:
;               GET CURRENT DATE
           DOSCALL GET_DATE        ;AN013;READ SYSTEM DATE
                                   ;OUTPUT: DL = DAY (1-31)
                                   ;  AL = DAY OF WEEK (0=SUN,6=SAT)
                                   ;  CX = YEAR (1980-2099)
                                   ;  DH = MONTH (1-12)
           PUSH  CX                ;AN013;SAVE THESE FOR
           PUSH  DX                ;AN013; INPUT INTO HASH ALGORITHM
;               GET CURRENT TIME
           DOSCALL GET_TIME        ;AN013;READ SYSTEM TIME CLOCK
                                   ;OUTPUT: CH = HOUR (0-23)
                                   ;  CL = MINUTES (0-59)
                                   ;  DH = SECONDS (0-59)
                                   ;  DL = HUNDREDTHS (0-99)

;                  HASH THESE INTO A UNIQUE 4 BYTE NEW VOLUME SERIAL NUMBER:
;                          SERIAL+0 = DX FROM DATE + DX FROM TIME
;                          SERIAL+2 = CX FROM DATE + CX FROM TIME

           POP   AX                ;AN013;GET THE DX FROM DATE
           ADD   AX,DX             ;AN013;ADD IN THE DX FROM TIME
           MOV   WORD PTR SERIAL,AX ;AN013;SAVE FIRST RESULT OF HASH
           MOV   WORD PTR ES:[BX].EXT_BOOT_SERIAL,AX ;AN013;AND IN BOOT RECORD ITSELF

           POP   AX                ;AN013;GET THE CX FROM DATE
           ADD   AX,CX             ;AN013;ADD IN THE CX FROM TIME
           MOV   WORD PTR SERIAL+WORD,AX ;AN013;SAVE SECOND RESULT OF HASH
           MOV   WORD PTR ES:[BX].EXT_BOOT_SERIAL+WORD,AX ;AN013;AND IN BOOT RECORD

           MOV   VOLSER_FLAG,TRUE  ;AN013;REQUEST THE NEW VOL SERIAL NUMBER BE WRITTEN

;      $ENDIF                      ;AN013;BOOT HAVE SERIAL?
$$IF70:
;  $ENDIF                          ;AN013;PROPER DESCRIPTOR?
$$IF69:
   POP   SI                        ;AN013;RESTORE THE INDEX REG
   POP   BX                        ;AN013;RESTORE THE BASE POINTER
   POP   ES                        ;AN013;RESTORE EXTRA SEG REG
   RET                             ;AN013;RETURN TO CALLER
MAYBE_ADJUST_SERIAL ENDP           ;AN013;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <WRITE_OP - IOCTL WRITE A TRACK OPERATION> ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC WRITE_OP                 ;AN000;MAKE ENTRY IN LINK MAP
WRITE_OP PROC NEAR                 ;IOCTL WRITE A TRACK OPERATION       *
;                                                                            *
;*****************************************************************************

WO_AGAIN:                          ;
;  $SEARCH                         ;
$$DO73:
       XOR   AX, AX                ;
       MOV   AL, SIDE              ;
       MOV   Head, AX              ;HEAD TO WRITE
       MOV   AX, TRACK_TO_WRITE    ;
       MOV   Cylinder, AX          ;TRACK TO WRITE
       MOV   FirstSectors, 0       ;???? SHOULD BE 1 BUT CURRENTLY 0 ???
       MOV   AX, BUFFER_PTR        ;
       MOV   Taddress_seg, AX      ;BUFFER ADDRESS
       MOV   Taddress_off, 0       ;
       XOR   BX, BX                ;
       MOV   BL, TARGET_DRIVE      ;
       MOV   CL, WRITE_FUNC        ;= 41h
       MOV   DX, OFFSET IOCTL_R_W  ;
       CALL  GENERIC_IOCTL         ;

       CMP   IO_ERROR, NO_ERROR    ;OK?
        jne     is_it_soft_error
        cmp     VERIFY_OPTION, 0
        je      skip_verify
        mov     cl, VERIFY_FUNC         ; verify the track if WRITE says OK
        call    GENERIC_IOCTL
        cmp     IO_ERROR, NO_ERROR
skip_verify:
;  $LEAVE E                        ;YES, SUCCESS. EXIT THIS ROUTINE
   JE $$EN73
is_it_soft_error:
       CMP   IO_ERROR, SOFT_ERROR  ;TRY AGAIN?
       JE    WO_AGAIN              ;
                                   ;ELSE HARD ERROR
                                   ;WRITE FAILURE, LET'S TRY TO FORMAT.
       CMP   FORMAT_FLAG, ON       ;WAS THIS TRACK FORMATTED BEFORE?
;  $EXITIF E                       ;YES, GIVE UP WRITING AND
   JNE $$IF73
                                   ; CHECK WHEN IT HAPPENDED.
                                   ;GIVE UP WRITING AND SHOW ERROR MESSAGE.
       INC   COPY_ERROR            ;INDICATE ERROR OCCURS DURING COPY.
       MOV   AH, WRITE_FUNC        ;
       mov   dl, target_drive      ;
       CALL  ERROR_MESSAGE         ;SHOW MESSAGE 'WRITE ERROR SIDE, TRACK...'

       MOV   MSG_FLAG, OFF         ;
;  $ORELSE                         ;ELSE TRY FORMAT AND TRY WRITE AGAIN
   JMP SHORT $$SR73
$$IF73:

                                   ;CR,LF,"Formatting while copying",CR,LF
       PRINT MSGNUM_FORMATTING     ;AN000;SHOW MESSAGE

       MOV   FORMAT_FLAG, ON       ;FORMAT ALL TRACKS FROM THIS TRACK
       CALL  FORMAT_ALL            ;format all the rest of the tracks

       CMP   COPY_STATUS, FATAL    ;
;  $ENDLOOP E                      ;
   JNE $$DO73
$$EN73:
.XLIST                             ;
;this next is dead code, nobody calls WO_FATAL, so the move copy_status
;and the print not compatible msg should be removed, and just the JMP WO_EXIT
;will no longer be needed to skip stuff that is not there.  Kiser
;   JMP   WO_EXIT                   ;AND EXIT THIS ROUTINE
;WO_FATAL:
;   MOV   COPY_STATUS, FATAL        ;WE ARE GOING TO ABORT PROGRAM
;   PRINT MSG_NOT_COMPATIBLE        ;SHOW NOT COMPATIABLE MESSAGE
.LIST                              ;
;  $ENDSRCH                        ;
$$SR73:
WO_EXIT:                           ;
   RET                             ;

WRITE_OP ENDP                      ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <FORMAT_ALL - FORMATS ALL TRACKS TO END> ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC FORMAT_ALL               ;AN000;MAKE ENTRY IN LINK MAP
FORMAT_ALL PROC NEAR               ;
;                                                                            *
;Format all tracks starting from TRACK_TO_WRITE to the end.                  *
;This routine will set MT_deviceBPB to that of MS_deviceBPB.                 *
;trackLayout had been all set correctly.                                     *
;If error, then fail to diskcopy.                                            *
;*****************************************************************************

   MOV     byte ptr cs:mks_byte,0  ;Initialize our little flag            ;C04
   MOV     CX, MS_deviceBPB.cSECT_TRACK                                   ;C04
   CMP     CX, 8                   ;Q: Source 8 sectors/track?            ;C04
   JNZ     GO_TRANSFER             ; N: Continue normally                 ;C04
   MOV     CX, MT_deviceBPB.cSECT_TRACK                                   ;C04
   CMP     CX, 9                   ;Q: Target 9 sectors/track?            ;C04
   JZ      SET_OUR_BYTE            ; Y: Set our byte, we will format      ;C04
   CMP     CX, 0                   ;Q: Target unformatted?                ;C04
   JNZ     GO_TRANSFER             ; N: Continue normally                 ;C04
SET_OUR_BYTE    LABEL NEAR         ;                                      ;C04
   MOV     byte ptr cs:mks_byte,1  ; Y: Set our flag                      ;C04
GO_TRANSFER     LABEL   NEAR                                              ;C04
   MOV   CX, MS_deviceBPB_leng     ;set length of BPB
   MOV   SI, OFFSET MS_deviceBPB   ;
   MOV   DI, OFFSET MT_deviceBPB   ;
   REP   MOVSB                     ;
   CALL  CHK_MEDIATYPE             ;set MT_mediaTYPE for FORMAT operation

   MOV   MT_specialFunctions, SET_SP_BF_FORM ;=00000101B
   MOV   CL, SETDEVPARM            ;=40h
   MOV   DX, OFFSET MT_IOCTL_DRV_PARM ;
   mov   bx, last_track            ;patch 3/27/86 for 3.2 diskcopy. J.K.
   inc   bx                        ;
   mov   MT_numberOfCylinders, bx  ;make sure target # of cyl.
   MOV   BL, TARGET_DRIVE          ;
   CALL  GENERIC_IOCTL             ;

   JC    FA_FATAL                  ;

   MOV   FspecialFunctions, STATUS_CHK ;check to see if the parameters set
                                   ;by "SET DEVICE PARM" func above are
                                   ; supported or not.
   MOV   AX,(IOCTL_FUNC SHL 8)+GENERIC_IOCTL_CODE ;AC000;(440DH)
   MOV   CH, MAJOR_CODE            ;=8
   MOV   CL, FORMAT_FUNC           ;=42H
   XOR   BX, BX                    ;
   MOV   BL, TARGET_DRIVE          ;
   MOV   DX, OFFSET IOCTL_FORMAT   ;result is in Fspecialfunction
   INT   21H                       ;0 - Thre is ROM support of AH=18h, INT 13h, and
                                   ; it is a valid combination

   MOV   AL, FspecialFunctions     ;1 - No ROM support. 2 - There is ROM support,
                                   ; but invalid combination
   MOV   FspecialFunctions, FORMAT_SP_FUNC ;restore specialfunction value
   CMP   AL, 2                     ;ROM support, but this combination is not valid?
;C04   JE    FA_FATAL                  ;
   JNE   LEGAL_FORMAT              ;This is supported, continue           ;C04
   CMP   CS:MKS_BYTE,0             ;Q: 8 sector - 9 sector?               ;C04
   JE    FA_FATAL                  ; N: then it is a fatal error          ;C04
                                                                          ;C04
LEGAL_FORMAT    LABEL   NEAR                                              ;C04

   MOV   AX, TRACK_TO_WRITE        ;
   MOV   TRACK_TO_FORMAT, AX       ;
   MOV   AL, SIDE                  ;
   MOV   SIDE_TO_FORMAT, AL        ;
   CMP   AL, NO_OF_SIDES           ;
   JE    FA_SIDE_WHILE             ;STARTS WITH THE OTHER SIDE TO FORMAT

FA_TRACK_WHILE:                    ;
   MOV   AX, LAST_TRACK            ;
   CMP   TRACK_TO_FORMAT, AX       ;
   JA    FA_DONE                   ;

FA_SIDE_WHILE:                     ;
   MOV   AL, NO_OF_SIDES           ;
   CMP   SIDE_TO_FORMAT, AL        ;
   JA    FA_NEXT_TRACK             ;

   CALL  FORMAT_TRACK              ;FORMAT THIS TRACK

   CMP   IO_ERROR, HARD_ERROR      ;
   JNE   FA_NEXT_SIDE              ;

   CMP   SIDE_TO_FORMAT, 1         ;HARD ERROR AT SIDE 1?
   JNE   FA_TARGET_BAD             ;THEN ASSUME TARGET DISKETTE BAD

   CMP   TRACK_TO_FORMAT, 0        ;AT CYLINDER 0?
   JNE   FA_TARGET_BAD             ;

;C00   JMP   FA_FATAL                  ;THEN, SOURCE IS TWO SIDED AND
   JMP   SHORT FA_FATAL            ;THEN, SOURCE IS TWO SIDED AND       ;C00
                                   ; TARGET IS SINGLE SIDE DISKETTE

FA_NEXT_SIDE:                      ;
   INC   SIDE_TO_FORMAT            ;
   JMP   FA_SIDE_WHILE             ;

FA_NEXT_TRACK:                     ;
   MOV   SIDE_TO_FORMAT, 0         ;RESET SIDE_TO_FORMAT
   INC   TRACK_TO_FORMAT           ;
   JMP   FA_TRACK_WHILE            ;

FA_FATAL:                          ;
   MOV   COPY_STATUS, FATAL        ;WE ARE GOING TO ABORT PROGRAM
                                   ;"Drive types or diskette types"
                                   ;"not compatible"
   PRINT MSGNUM_NOT_COMPATIBLE     ;AC000;SHOW NOT COMPATIBLE MESSAGE
   CMP EXITFL,EXOK                 ;Q: Was there already an error          ;C12
   JNZ FA_DONE                     ; Y: then save that error               ;C12
   MOV EXITFL,EX_INIT_ERROR        ; N: Force an initialization error      ;C12

   JMP   SHORT FA_DONE             ;

FA_TARGET_BAD:                     ;
   MOV   COPY_STATUS, FATAL        ;WE ARE GOING TO ABORT PROGRAM
                                   ;CR,LF,"TARGET diskette bad or incompatible"
   PRINT MSGNUM_BAD_TARGET         ;AC000;SHOW TARGET BAD MESSAGE
   CMP EXITFL,EXOK                 ;Q: Was there already an error          ;C12
   JNZ FA_DONE                     ; Y: then save that error               ;C12
   MOV EXITFL,EX_INIT_ERROR        ;Force an initialization error          ;C12

FA_DONE:                           ;
   XOR   BX, BX                    ;
   MOV   BL, TARGET_DRIVE          ;
   MOV   T_DRV_SET_FLAG, 1         ;INDICATE TARGET DRIVE PARM HAS BEEN SET
   MOV   DX, OFFSET MT_IOCTL_DRV_PARM ;
   MOV   MT_specialFunctions, SET_SP_FUNC_DEF ;
   CALL  SET_DRV_PARM_DEF          ;SET IT BACK FOR WRITING.

   RET                             ;
mks_byte        db      0          ;flag for 8 sector to 9 sector copy   ;C04
FORMAT_ALL ENDP                    ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <FORMAT_TRACK - IOCTL FORMAT A TRACK> ;AN000;
;******************************************************************************
; SUBROUTINE NAME :  FORMAT_TRACK     -  IOCTL FORMAT A TRACK                 *
;                                        (BOTH SIDES IF 2-SIDED DSKT)         *
;                                                                             *
; INPUT           :   TRACK_TO_FORMAT                                         *
;                 :   SIDE             BYTE  0, 1  (HEAD NUMBER)              *
;                 :   END_OF_TRACK     BYTE  8, 9, 15                         *
;                 :   TARGET_DRIVE     BYTE  1 = A, 2 = B, ETC                *
;                                                                             *
; OUTPUT          :   none. This routine does not report format error.        *
;                     Write routine will detect the error consequently.       *
; REGISTER(S) AFFECTED:                                                       *
;******************************************************************************
   PUBLIC FORMAT_TRACK             ;AN000;MAKE ENTRY IN LINK MAP
FORMAT_TRACK PROC NEAR             ;

FT_AGAIN:                          ;
;  $DO                             ;
$$DO79:
       XOR   AX, AX                ;
       MOV   AL, SIDE_TO_FORMAT    ;
       MOV   FHead, AX             ;HEAD TO FORMAT
       MOV   AX, TRACK_TO_FORMAT   ;
       MOV   FCylinder, AX         ;TRACK TO FORMAT

       XOR   BX, BX                ;
       MOV   BL, TARGET_DRIVE      ;DRIVE TO FORMAT
       MOV   CL, FORMAT_FUNC       ;=42h
       MOV   DX, OFFSET IOCTL_FORMAT ;
       CALL  GENERIC_IOCTL         ;

       CMP   IO_ERROR, SOFT_ERROR  ;TRY FORMAT AGAIN?
                                   ; (DRIVE NOT READY OR WRITE PROTECTED)
;  $ENDDO NE                       ;
   JE $$DO79

   RET                             ;
FORMAT_TRACK ENDP                  ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <CHECK_SOURCE - CHECK SOURCE DISKETTE TYPE> ;AN000;
;*****************************************************************************
;                                                                            *
   PUBLIC CHECK_SOURCE             ;AN000;MAKE ENTRY IN LINK MAP
CHECK_SOURCE PROC NEAR             ;CHECK SOURCE DISKETTE TYPE               *
;                                  SET END_OF_TRACK, LAST_TRACK              *
;                                  NO_OF_SIDES, bSECTOR_SIZE                 *
; ** this routine will call "Get dev parm" with "BUILD BPB BIT" on.  If it   *
; ** fails to get that info, then the source medium must be bad(vergin) or   *
; ** below DOS 2.0 level diskette, and will jmp to the old logic.            *
; ** For compatibility reasons (in case of non IBM formatted media), this    *
; ** routine covers old diskcopy routines.  But this will only supports
; ** 5.25" 48 tpi 8, 9 sectors, 40 tracks and 5.25" 96 tpi, 15 sectors, 80 tracks
; ** media.  Other non IBM formatted media which are formatted differenty
; ** from those values will result in unpreditable copy process.
;*****************************************************************************

;  $DO                             ;
$$DO81:
       XOR   BX, BX                ;
       MOV   BL, SOURCE_DRIVE      ;
       MOV   MS_specialFunctions, GET_SP_FUNC_MED ;=00000001b
       MOV   CL, GETDEVPARM        ;=60h
       MOV   DX, OFFSET MS_IOCTL_DRV_PARM ;
       CALL  GENERIC_IOCTL         ;TRY TO GET MEDIA BPB INFO TOGETHER
                                   ;WITH DEFAULT DEVICE INFO.
       CMP   IO_ERROR, SOFT_ERROR  ;TRY AGAIN?
;  $ENDDO NE                       ;
   JE $$DO81

   CMP   IO_ERROR, HARD_ERROR      ;CANNOT GET MEDIA BPB?
   jne   @f                        ;ASSUME OLD FORMATTED DISKETTE, FIRST.
   jmp   cs_old
@@:

   cmp   ms_deviceBPB.csect_track,0 ;patch 1/16/86
;C11 je    cs_old                    ;
   jne   bridge_around1            ;                                       ;C11
bridge_cs_old:                                                             ;C12
   jmp   cs_old                    ;                                       ;C11
bridge_around1:                    ;                                       ;C11

   cmp   ms_deviceBPB.chead,0      ;cannot trust the info from dos
   je    bridge_cs_old             ;sanity check for divide by 0

   MOV   AX, MS_deviceBPB.CTOTSECT ;
   CWD                             ;CONVERT IT TO A DOUBLE WORD
   OR    AX,AX
   JNZ   NOT_ENHANCED
   MOV   AX, WORD PTR MS_deviceBPB.BIG_TOT_SECT
   MOV   DX, WORD PTR MS_deviceBPB.BIG_TOT_SECT+2

NOT_ENHANCED:
   DIV   MS_deviceBPB.CSECT_TRACK
   MOV   BX,MS_deviceBPB.CHEAD     ;(TOTAL SECTORS / # OF TRACKS) / # OF HEADS
   DIV   BX                        ;ENSURE WORD DIVISION
   CMP   COPY_TYPE,1               ;Q: One drive copy?                      ;*A
   JE    PASS_FIRST                ; Y: T_DRV_TRACKS can't be trusted, jump ;*A
   CMP   AX, T_DRV_TRACKS          ;SOURCE MEDIA # OF TRACK > TARGET
                                   ; DEVICE # OF TRACKS?
   JA    CS_FATAL                  ;THEN, NOT COMPATIBLE.

PASS_FIRST:
   DEC   AX                        ;DECREASE BY 1 FOR THE USE OF THIS PROGRAM.
   MOV   LAST_TRACK, AX            ;SET LAST_TRACK
   MOV   AX, MS_deviceBPB.CSECT_TRACK ;
   CMP   COPY_TYPE,1               ;Q: One drive copy?                      ;*A
   JE    PASS_SECOND               ; Y: T_DRV_SECT_TRACK can't be trusted   ;*A
   CMP   AL, T_DRV_SECT_TRACK      ;SOURCE MEDIA # OF SECT/TRACK > TARGET
                                   ; DEVICE # OF SECT/TRACK?
   JA    CS_FATAL                  ;THEN, NOT COMPATIBLE

PASS_SECOND:
   MOV   END_OF_TRACK, AL          ;
   MOV   AX, MS_deviceBPB.CBYTE_SECT ;
   MOV   bSECTOR_SIZE, AX          ;set the sector size in bytes.
   CMP   USER_OPTION, 1            ;
   JNE   BRIDGE_CS_OPTION_1        ;                                       ;C11
   JMP   CS_OPTION_1               ;                                       ;C11
BRIDGE_CS_OPTION_1:                                                        ;C11

   MOV   AX, MS_deviceBPB.CHEAD    ;HEAD=1, 2
   CMP   AL, T_DRV_HEADS           ;COMPARE SOURCE MEDIA SIDE WITH
                                   ; TARGET DRIVE HEAD NUMBER
   JA    CS_FATAL                  ;SOURCE MEDIUM IS DOUBLE SIDED AND
                                   ; TARGET DRIVE IS SINGLE SIDED.

   DEC   AX                        ;
   MOV   NO_OF_SIDES, AL           ;NO_OF_SIDES=0, 1
   JMP   CS_SET_TABLE              ;
;  =  =  =  =  =  =  =  =  =  =  =
CS_FATAL:                          ;
   MOV   COPY_STATUS, FATAL        ;
                                   ;CR,LF,"Drive types or diskette types",CR,LF
                                   ;"not compatible",CR,LF
   PRINT MSGNUM_NOT_COMPATIBLE     ;AC000;
   CMP EXITFL,EXOK                 ;Q: Was there already an error          ;C12
   JNZ CS_EXIT_BRIDGE              ; Y: then save that error               ;C12
   MOV EXITFL,EX_INIT_ERROR        ; N: Force an initialization error      ;C12
CS_EXIT_BRIDGE:                    ;Long jump to CS_EXIT                   ;C12
   JMP   CS_EXIT                   ;

;  =  =  =  =  =  =  =  =  =  =  =
CS_BAD:                            ;
   MOV   COPY_STATUS, FATAL        ;
   PRINT MSGNUM_BAD_SOURCE         ;CR,LF,"SOURCE diskette bad or incompatible"
   MOV EXITFL,EX_HARD_ERROR        ;Indicate hard error                    ;C12

   JMP   CS_EXIT                   ;

;  =  =  =  =  =  =  =  =  =  =  =
CS_OLD:                            ;
   MOV   READ_S_BPB_FAILURE, 1     ;SET FLAG
   MOV   bSECTOR_SIZE, 512         ;OLD SECTOR SIZE MUST BE 512 BYTES
   XOR   BX, BX                    ;
   MOV   BL, SOURCE_DRIVE          ;
   MOV   IOCTL_TRACK, 0            ;TRACK=0
   MOV   IOCTL_SECTOR, 8           ;SECTOR=8
   MOV   IOCTL_HEAD, 0             ;HEAD = 0
   CALL  READ_A_SECTOR             ;

   JC    CS_BAD                    ;SOURCE BAD

   MOV   IOCTL_SECTOR, 9           ;TRY TO READ SECTOR=9
   CALL  READ_A_SECTOR             ;

   JC    CS_SECT8                  ;YES, 8 SECTORS. ASSUME 40 TRACKS

   MOV   IOCTL_SECTOR, 15          ;try to read sector=15
   CALL  READ_A_SECTOR             ;

   JC    CS_SECT9                  ;**REMEMBER THIS ROUTINE DOES COVER 3.5" MEDIA

;                                                                          ;C06
   MOV   IOCTL_SECTOR,18           ;try to read sector=18 (1.44M diskette) ;C06
   CALL  READ_A_SECTOR             ;                                       ;C06
   JC    CS_SECT15                 ;No sector 18, must only be 15 sec/trk  ;C06
;C11 JMP   SHORT CS_SECT18           ;Sector 18 exists, process accordingly;C06
;                                                                          ;C11
   MOV   IOCTL_SECTOR,36           ;try to read sector=36 (2.88M diskette) ;C11
   CALL  READ_A_SECTOR             ;                                       ;C11
   JC    CS_SECT18                 ;No sector 36, must only be 18 sec/trk  ;C11
   JMP   SHORT CS_SECT36           ;Sector 36 exists, process accordingly  ;C11
;                                                                          ;C06

;  =  =  =  =  =  =  =  =  =  =  =
CS_OPTION_1:                       ;
   MOV   NO_OF_SIDES, 0            ;1 SIDE COPY
   JMP   CS_SET_TABLE              ;

;  =  =  =  =  =  =  =  =  =  =  =                                         ;C11
CS_SECT36:                         ;                                       ;C11
   MOV   END_OF_TRACK, 36          ;ELSE END_OF_TRACK = 36 (2.88M)         ;C11
   MOV   LAST_TRACK, 79            ;                                       ;C11
   JMP   SHORT CS_CHK_SIDE         ;                                       ;C11
                                                                           ;C11
;  =  =  =  =  =  =  =  =  =  =  =                                         ;C06
CS_SECT18:                         ;                                       ;C06
   MOV   END_OF_TRACK, 18          ;ELSE END_OF_TRACK = 18                 ;C06
   MOV   LAST_TRACK, 79            ;                                       ;C06
   JMP   SHORT CS_CHK_SIDE         ;                                       ;C06
                                                                           ;C06
;  =  =  =  =  =  =  =  =  =  =  =
CS_SECT15:                         ;
   MOV   END_OF_TRACK, 15          ;ELSE END_OF_TRACK = 15
   MOV   LAST_TRACK, 79            ;
   JMP   SHORT CS_CHK_SIDE         ;

;  =  =  =  =  =  =  =  =  =  =  =
CS_SECT8:                          ;
   MOV   END_OF_TRACK, 8           ;SOURCE 8 SECTORS
   MOV   LAST_TRACK,  39           ;ASSUME 40 TRACKS.
   JMP   SHORT CS_CHK_SIDE         ;

;  =  =  =  =  =  =  =  =  =  =  =
CS_SECT9:                          ;
   MOV   END_OF_TRACK, 9           ;
   MOV   LAST_TRACK, 39            ;ASSUME 5.25 DISKETTE
   MOV   IOCTL_TRACK, 79           ;now try to read track 80 (3.5")     ;C10
   MOV   IOCTL_SECTOR, 9           ;SECTOR=9                            ;C10
   MOV   IOCTL_HEAD, 0             ;HEAD = 0                            ;C10
   CALL  READ_A_SECTOR             ;                                    ;C10
   JC    CS_CHK_SIDE               ;It failed, we assumed right (5.25") ;C10
   MOV   LAST_TRACK, 79            ;It is a 3.5" 720k diskette!         ;C10
;C10   JMP   SHORT CS_CHK_SIDE         ;

;  =  =  =  =  =  =  =  =  =  =  =
CS_CHK_SIDE:                       ;
   CMP   USER_OPTION, 1            ;
   JE    CS_OPTION_1               ;

   MOV   IOCTL_HEAD, 1             ;HEAD 1
   XOR   AX, AX                    ;
   MOV   AL, END_OF_TRACK          ;READ MATCHING END_OF_TRACK
                                   ; OF THE OTHER SURFACE.
   MOV   IOCTL_SECTOR, AX          ;
   CALL  READ_A_SECTOR             ;

   JC    CS_OPTION_1               ;1 SIDED SOURCE

   MOV   NO_OF_SIDES, 1            ;2 SIDED SOURCE
   CMP   T_DRV_HEADS, 2            ;SOUCE=2 SIDED MEDIUM. IS TARGET
                                   ; DOUBLE SIDED DRV?
   JE    CS_SET_TABLE              ;

   JMP   CS_FATAL                  ;NOT COMPATIBLE

;  =  =  =  =  =  =  =  =  =  =  =
CS_SET_TABLE:                      ;
   CMP   READ_S_BPB_FAILURE, 1     ;DISKETTE WITHOUT BPB INFO?
;  $IF   E                         ;
   JNE $$IF83
       CALL  SET_FOR_THE_OLD       ;

;  $ENDIF                          ;
$$IF83:
   MOV   BX, OFFSET MS_trackLayout ;SET TRACKLAYOUT OF SOURCE
   CALL  SET_TRACKLAYOUT           ;

   MOV   BX, OFFSET MT_trackLayout ;YES, ASSUME TARGET IS SAME
   CALL  SET_TRACKLAYOUT           ;

   MOV   S_DRV_SET_FLAG, 1         ;
   XOR   BX, BX                    ;
   MOV   BL, SOURCE_DRIVE          ;
   MOV   MS_specialFunctions, SET_SP_FUNC_DEF ;=00000100B
   MOV   DX, OFFSET MS_IOCTL_DRV_PARM ;
   CALL  SET_DRV_PARM_DEF          ;NOW, SET SOURCE DRIVE PARM
                                   ; FOR READ OPERATION.

   XOR   AX, AX                    ;
   MOV   AL, END_OF_TRACK          ;
   MOV   numberOfSectors, AX       ;SET NUMBEROFSECTORS IN IOCTL_R_W TABLE

   MOV   AX, LAST_TRACK            ;NOW, SHOW THE MESSAGE "COPYING ..."
   INC   AX                        ;
.XLIST                             ;
;  MOV   MSG_COPYING_PTR+2, AX     ;HOW MANY TRACKS?
.LIST                              ;
   MOV   MSG_TRACKS, AX            ;AC000;HOW MANY TRACKS?

   MOV   AL, END_OF_TRACK          ;
.XLIST                             ;
;  MOV   BYTE PTR MSG_COPYING_PTR+4, AL ;HOW MANY SECTORS?
.LIST                              ;
   MOV   BYTE PTR MSG_SECTRK,AL    ;AC000;HOW MANY SECTORS?

   MOV   AL, NO_OF_SIDES           ;TELL USER HOW MANY SIDE TO COPY
   INC   AL                        ;
.XLIST                             ;
;  MOV   BYTE PTR MSG_COPYING_PTR+6, AL
.LIST                              ;
   MOV   BYTE PTR MSG_SIDES,AL     ;AC000;HOW MANY SIDES?
                                   ;CR,LF,"Copying %1 tracks",CR,LF
                                   ;"%2 Sectors/Track, %3 Side(s)",CR,LF
   PRINT MSGNUM_COPYING            ;AC000;

CS_EXIT:                           ;
   RET                             ;

CHECK_SOURCE ENDP                  ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <READ_A_SECTOR - GET ONE SECTOR WITH IOCTL READ> ;AN000;
;******************************************************************************
   PUBLIC READ_A_SECTOR            ;AN000;MAKE ENTRY IN LINK MAP
READ_A_SECTOR PROC NEAR            ;
;                                                                             *
;TRY TO READ A SECTOR USING IOCTL READ FUNCTION CALL.                         *
;THIS ROUTINE WILL STEAL "IOCTL_R_W" TABLE TEMPORARILY.                       *
;INPUT: BX - LOGICAL DRIVE NUMBER                                             *
;       IOCTL_SECTOR - SECTOR TO READ                                         *
;       IOCTL_TRACK - TRACK                                                   *
;       IOCTL_HEAD - HEAD TO READ                                             *
;       bSECTOR_SIZE - SECTOR SIZE IN BYTES                                   *
;OUTPUT:                                                                      *
;       IF NOT A SUCCESS, CARRY WILL BE SET                                   *
;       ALL REGISTORS SAVED                                                   *
;
;******************************************************************************

   PUSH  AX                        ;
   PUSH  BX                        ;
   PUSH  CX                        ;
   PUSH  DX                        ;

   MOV   AX, numberOfSectors       ;SAVE IOCTL_R_W TABLE VALUES
   MOV   SAV_CSECT, AX             ;

;RAS_AGAIN:
;  $DO                             ;
$$DO85:
       MOV   AX, IOCTL_HEAD        ;
       MOV   Head, AX              ;SURFACE TO READ
       MOV   AX, IOCTL_TRACK       ;
       MOV   Cylinder, AX          ;TRACK TO READ
       MOV   AX, IOCTL_SECTOR      ;
       dec   ax                    ;????? currently
                                   ; firstsector=0 => 1st sector ????
       MOV   FirstSectors, AX      ;SECTOR TO READ
       MOV   numberOfSectors, 1    ;read just one sector
       MOV   AX, offset INIT       ;READ IT INTO INIT
                                   ; (CURRELTLY, MAX 1K)
       MOV   TAddress_off, AX      ;
       MOV   TAddress_seg, DS      ;
       MOV   CL, READ_FUNC         ;
       MOV   DX, OFFSET IOCTL_R_W  ;POINTS TO CONTROL TABLE
       call  generic_ioctl         ;

       CMP   IO_ERROR, SOFT_ERROR  ;TRY ONCE MORE?
;  $ENDDO NE                       ;
   JE $$DO85

   CMP   IO_ERROR, HARD_ERROR      ;HARD ERROR?
;  $IF   NE                        ;
   JE $$IF87

       CLC                         ;READ SUCCESS
;  $ELSE                           ;
   JMP SHORT $$EN87
$$IF87:
       STC                         ;SET CARRY
;  $ENDIF                          ;
$$EN87:
   MOV   AX, SAV_CSECT             ;RESTORE ORIGINAL IOCTL_R_W TABLE
   MOV   numberOfSectors, AX       ;
   POP   DX                        ;
   POP   CX                        ;
   POP   BX                        ;
   POP   AX                        ;
   RET                             ;

READ_A_SECTOR ENDP                 ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <CALC_TRACK_SIZE - GET MEM SIZE TO STORE ONE TRACK> ;AN000;
;*****************************************************************************
   PUBLIC CALC_TRACK_SIZE          ;AN000;MAKE ENTRY IN LINK MAP
CALC_TRACK_SIZE PROC NEAR          ;CALCULATE MEMORY SIZE REQUIRED TO STORE ONE
;                             TRACK (IN SEGMENTS)                            *
;
;CALCULATE SECTOR_SIZE IN PARA FROM bSECTOR_SIZE.  IF bSECTOR_SIZE CANNOT BE *
;CHANGED TO SECTOR_SIZE IN PARA EXACTLY, THEN ADD 1 TO THE SECTOR_SIZE.      *
;SECTOR_SIZE IS USED FOR MEMORY MANAGEMANT ONLY.  THE ACTUAL COPY OR FORMAT  *
;SHOULD BE DEPENDS ON bSECTOR_SIZE TO FIGURE OUT HOW BIG A SECTOR IS.        *
;ALSO, CURRENTLY, THIS ROUTINE ASSUME A BSECTOR SIZE BE LESS THAN 0FFFh.     *
;*****************************************************************************

   PUSH  AX                        ;
   PUSH  BX                        ;
   PUSH  CX                        ;

   MOV   AX, bSECTOR_SIZE          ;
   MOV   CL, 16                    ;
   DIV   CL                        ;AX / 16 = AL ... AH
   CMP   AH, 0                     ;NO REMAINER?
;  $IF   NE                        ;
   JE $$IF90

       INC   AL                    ;THERE REMAINER IS.  INC AL

;  $ENDIF                          ;
$$IF90:
   MOV   SECTOR_SIZE, AL           ;SECTOR_SIZE+ IN PARA.
   MOV   AL,NO_OF_SIDES            ;TRACK_SIZE = (NO OF SIDES
   INC   AL                        ;              + 1)
   MUL   END_OF_TRACK              ;              * END_OF_TRACK
   MOV   BL,SECTOR_SIZE            ;              * SECTPR_SIZE
   MUL   BL                        ;AMOUNT OF MEMORY REQUIRED (IN SEG)
   MOV   TRACK_SIZE,AX             ;TO STORE A TRACK
   POP   CX                        ;
   POP   BX                        ;
   POP   AX                        ;

   RET                             ;
CALC_TRACK_SIZE ENDP               ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <CHECK_MEMORY_SIZE - VERIFY WE HAVE ENUF TO COPY 1 TRACK> ;AN000;
;*****************************************************************************
   PUBLIC CHECK_MEMORY_SIZE        ;AN000;MAKE ENTRY IN LINK MAP
CHECK_MEMORY_SIZE PROC NEAR        ;MAKE SURE WE HAVE ENOUGH TO COPY 1 TRACK INTO
;                             TO BUFFER ELSE ABORT COPY                      *
;*****************************************************************************
   MOV   AX,BUFFER_END             ;CALCULATE AVAILABLE MEMORY
   SUB   AX,BUFFER_BEGIN           ;IN SEGMENTS
   CMP   AX,TRACK_SIZE             ;DO WE HAVE ENOUGH TO STORE A CYLINDER?
;  $IF   B                         ;
   JNB $$IF92
       MOV   COPY_STATUS,FATAL     ;NO, ABORT COPY
       PRINT MSGNUM_UNSUF_MEMORY   ;AC000;AND TELL USER WHY
       MOV EXITFL,EX_INIT_ERROR    ;Force an initialization error          ;C12

;  $ENDIF                          ;
$$IF92:
   RET                             ;

CHECK_MEMORY_SIZE ENDP             ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <SET_FOR_THE_OLD  - SET BPB FOR BEFORE-2.0 FMTTED MEDIA> ;AN000;
;*****************************************************************************
   PUBLIC SET_FOR_THE_OLD          ;AN000;MAKE ENTRY IN LINK MAP
SET_FOR_THE_OLD PROC NEAR          ;

;set MS_deviceBPB for before-2.0 formatted media
;*****************************************************************************
   PUSH  AX                        ;

   CMP   END_OF_TRACK,9            ;IF SECTORS/TRACK <= 9, THEN CHECK
                                   ;NO_OF_SIDES. IF SINGLE SIDE
                                   ; COPY THEN USE BPB48_SINGLE
                                   ;ELSE USE BPB48_DOUBLE.
;  $IF   A                         ;SECTORS/TRACK > 9 THEN USE BPB96 TABLE
   JNA $$IF94
       MOV   SI, OFFSET BPB96      ;
;  $ELSE                           ;
   JMP SHORT $$EN94
$$IF94:
       CMP   NO_OF_SIDES, 0        ;SINGLE SIDE COPY?
;      $IF   NE                    ;IF NOT,
       JE $$IF96
           MOV   SI, OFFSET BPB48_DOUBLE ;USE BPB48 DOUBLE
;      $ELSE                       ;
       JMP SHORT $$EN96
$$IF96:
           MOV   SI, OFFSET BPB48_SINGLE ;
;      $ENDIF                      ;
$$EN96:
;  $ENDIF                          ;
$$EN94:
   XOR   AX, AX                    ;
   MOV   AL, END_OF_TRACK          ;

   MOV   MS_deviceBPB.CSECT_TRACK,AX ;SET # OF SECTORS IN IOCTL_DRV_PARM
   MOV   DI, OFFSET MS_deviceBPB   ;
   MOV   CX, BPB96_LENG            ;
   REP   MOVSB                     ;OLD DEFAULT BPB INFO => MS_deviceBPB

   POP   AX                        ;
   RET                             ;
SET_FOR_THE_OLD ENDP               ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <SET_TRACKLAYOUT - MOVE DATA TO TRACK IMAGE> ;AN000;
;*****************************************************************************
   PUBLIC SET_TRACKLAYOUT          ;AN000;MAKE ENTRY IN LINK MAP
SET_TRACKLAYOUT PROC NEAR          ;

;INPUT: BX - POINTER TO DESTINATION
;*****************************************************************************

   XOR   CX, CX                    ;
   MOV   CL, END_OF_TRACK          ;
   MOV   WORD PTR [BX], CX         ;SET CSECT_F TO THE NUMBER OF
                                   ; SECTORS IN A TRACK
   ADD   BX, 2                     ;NOW BX POINTS TO
                                   ; THE FIRST SECTORNUMBER
   MOV   CX, 1                     ;
   MOV   AX, bSECTOR_SIZE          ;

;  $DO                             ;
$$DO100:
       CMP   CL, END_OF_TRACK      ;
;  $LEAVE A                        ;
   JA $$EN100

       MOV   WORD PTR [BX], CX     ;
       INC   BX                    ;
       INC   BX                    ;
       MOV   WORD PTR [BX], AX     ;
       INC   BX                    ;
       INC   BX                    ;

       INC   CX                    ;
;  $ENDDO                          ;
   JMP SHORT $$DO100
$$EN100:

   RET                             ;
SET_TRACKLAYOUT ENDP               ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <CHECK_TARGET - READ TARGET BOOT RCD, NEEDS FORMAT?> ;AN000;
;*****************************************************************************
   PUBLIC CHECK_TARGET             ;AN000;MAKE ENTRY IN LINK MAP
CHECK_TARGET PROC NEAR             ;                                    *
;   ** THIS ROUTINE WILL TRY TO READ TARGET MEDIA BOOT RECORD.               *
;   ** IF A SUCCESS,THEN COMPARES BPB INFO WITH THAT OF SOURCE MEDIA.        *
;   ** IF THEY ARE DIFFERENT, THEN SET FORMAT_FLAG AND RETURN.               *
;   ** IF FAILED TO READ A BOOT, THEN TRY OLD LOGICS BEFORE DOS 3.2 FOR      *
;   ** COMPATIBILITY REASON.                                                 *
;*****************************************************************************

;  $DO                             ;
$$DO103:
       XOR   BX, BX                ;
       MOV   BL, TARGET_DRIVE      ;
       MOV   MT_specialFunctions, GET_SP_FUNC_MED ;=00000001b
       MOV   CL, GETDEVPARM        ;=60h
       MOV   DX, OFFSET MT_IOCTL_DRV_PARM ;
       CALL  GENERIC_IOCTL         ;TRY TO GET MEDIA BPB INFO TOGETHER
                                   ;WITH DEFAULT DEVICE INFO.
       CMP   IO_ERROR, SOFT_ERROR  ;TRY AGAIN?
;  $ENDDO NE                       ;
   JE $$DO103

   CMP   IO_ERROR, HARD_ERROR      ;CANNOT GET MEDIA BPB?
;C03   JE    CT_OLD                    ;ASSUME OLD FORMATTED DISKETTE, FIRST.
   JNE   CHECK_0_SECT_TRACK        ;ASSUME OLD FORMATTED DISKETTE, FIRST. ;C03
   JMP   CT_OLD                    ;AND DO A FAR JUMP TO GET THERE        ;C03
CHECK_0_SECT_TRACK:                ;       